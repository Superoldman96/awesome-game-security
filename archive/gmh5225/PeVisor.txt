Project Path: arc_gmh5225_PeVisor_hjug57od

Source Tree:

```txt
arc_gmh5225_PeVisor_hjug57od
├── Dependency
│   ├── Blackbone
│   ├── unicorn
│   └── zydis
├── LICENSE
├── PeVisor
│   ├── Inc
│   │   ├── Buffer.hpp
│   │   ├── CPUID.hpp
│   │   ├── Crt.hpp
│   │   ├── EmuApiFuncs.hpp
│   │   ├── Encode.hpp
│   │   ├── IEApiErrorCodes.hpp
│   │   ├── Nativestructs.hpp
│   │   ├── Registers.hpp
│   │   ├── Trace.hpp
│   │   ├── UCPE.hpp
│   │   ├── ucHooks.hpp
│   │   └── wsprintf.h
│   ├── PeVisor.vcxproj
│   ├── PeVisor.vcxproj.filters
│   └── Src
│       ├── Buffer.cpp
│       ├── Crt.cpp
│       ├── EmuApiBasis.cpp
│       ├── EmuApiFuncs.cpp
│       ├── Encode.cpp
│       ├── Find.cpp
│       ├── InternalEmulationApi.cpp
│       ├── Ldr.cpp
│       ├── Main.cpp
│       ├── Map.cpp
│       ├── Memory.cpp
│       ├── Rtls.cpp
│       ├── Trace.cpp
│       ├── ucHooks.cpp
│       └── wsprintf.cpp
├── PeVisor.sln
├── README.md
└── Samples
    ├── Protected
    │   ├── CrackMe1.exe
    │   └── CrackMe1.vmp.exe
    └── Unprotect
        ├── CrackMe1.exe
        ├── CrackMe1.map
        ├── CrackMe1.vmp.exe
        ├── CrackMe1PRR.exe
        └── CrackMe1_protected.exe

```

`LICENSE`:

```
MIT License

Copyright (c) 2024 Nitr0-G

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`PeVisor.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34723.18
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PeVisor", "PeVisor\PeVisor.vcxproj", "{43744415-C650-49C0-9E9A-870A46E7099F}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Zydis", "Dependency\zydis\msvc\zydis\Zydis.vcxproj", "{88A23124-5640-35A0-B890-311D7A67A7D2}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BlackBone", "Dependency\Blackbone\src\BlackBone\BlackBone.vcxproj", "{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug Kernel|x64 = Debug Kernel|x64
		Debug Kernel|x86 = Debug Kernel|x86
		Debug MD DLL|x64 = Debug MD DLL|x64
		Debug MD DLL|x86 = Debug MD DLL|x86
		Debug MD|x64 = Debug MD|x64
		Debug MD|x86 = Debug MD|x86
		Debug MT DLL|x64 = Debug MT DLL|x64
		Debug MT DLL|x86 = Debug MT DLL|x86
		Debug MT|x64 = Debug MT|x64
		Debug MT|x86 = Debug MT|x86
		Debug(DLL)|x64 = Debug(DLL)|x64
		Debug(DLL)|x86 = Debug(DLL)|x86
		Debug(XP)|x64 = Debug(XP)|x64
		Debug(XP)|x86 = Debug(XP)|x86
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release Kernel|x64 = Release Kernel|x64
		Release Kernel|x86 = Release Kernel|x86
		Release MD DLL|x64 = Release MD DLL|x64
		Release MD DLL|x86 = Release MD DLL|x86
		Release MD|x64 = Release MD|x64
		Release MD|x86 = Release MD|x86
		Release MT DLL|x64 = Release MT DLL|x64
		Release MT DLL|x86 = Release MT DLL|x86
		Release MT|x64 = Release MT|x64
		Release MT|x86 = Release MT|x86
		Release(DLL)|x64 = Release(DLL)|x64
		Release(DLL)|x86 = Release(DLL)|x86
		Release(XP)|x64 = Release(XP)|x64
		Release(XP)|x86 = Release(XP)|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug Kernel|x64.ActiveCfg = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug Kernel|x64.Build.0 = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug Kernel|x86.ActiveCfg = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug Kernel|x86.Build.0 = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MD DLL|x64.ActiveCfg = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MD DLL|x64.Build.0 = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MD DLL|x86.ActiveCfg = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MD DLL|x86.Build.0 = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MD|x64.ActiveCfg = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MD|x64.Build.0 = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MD|x86.ActiveCfg = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MD|x86.Build.0 = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MT DLL|x64.ActiveCfg = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MT DLL|x64.Build.0 = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MT DLL|x86.ActiveCfg = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MT DLL|x86.Build.0 = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MT|x64.ActiveCfg = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MT|x64.Build.0 = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MT|x86.ActiveCfg = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug MT|x86.Build.0 = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug(DLL)|x64.ActiveCfg = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug(DLL)|x64.Build.0 = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug(DLL)|x86.ActiveCfg = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug(DLL)|x86.Build.0 = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug(XP)|x64.ActiveCfg = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug(XP)|x64.Build.0 = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug(XP)|x86.ActiveCfg = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug(XP)|x86.Build.0 = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug|x64.ActiveCfg = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug|x64.Build.0 = Debug|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug|x86.ActiveCfg = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Debug|x86.Build.0 = Debug|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release Kernel|x64.ActiveCfg = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release Kernel|x64.Build.0 = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release Kernel|x86.ActiveCfg = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release Kernel|x86.Build.0 = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MD DLL|x64.ActiveCfg = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MD DLL|x64.Build.0 = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MD DLL|x86.ActiveCfg = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MD DLL|x86.Build.0 = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MD|x64.ActiveCfg = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MD|x64.Build.0 = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MD|x86.ActiveCfg = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MD|x86.Build.0 = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MT DLL|x64.ActiveCfg = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MT DLL|x64.Build.0 = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MT DLL|x86.ActiveCfg = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MT DLL|x86.Build.0 = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MT|x64.ActiveCfg = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MT|x64.Build.0 = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MT|x86.ActiveCfg = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release MT|x86.Build.0 = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release(DLL)|x64.ActiveCfg = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release(DLL)|x64.Build.0 = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release(DLL)|x86.ActiveCfg = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release(DLL)|x86.Build.0 = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release(XP)|x64.ActiveCfg = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release(XP)|x64.Build.0 = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release(XP)|x86.ActiveCfg = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release(XP)|x86.Build.0 = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release|x64.ActiveCfg = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release|x64.Build.0 = Release|x64
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release|x86.ActiveCfg = Release|Win32
		{43744415-C650-49C0-9E9A-870A46E7099F}.Release|x86.Build.0 = Release|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug Kernel|x64.ActiveCfg = Debug Kernel|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug Kernel|x64.Build.0 = Debug Kernel|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug Kernel|x64.Deploy.0 = Debug Kernel|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug Kernel|x86.ActiveCfg = Debug Kernel|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug Kernel|x86.Build.0 = Debug Kernel|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug Kernel|x86.Deploy.0 = Debug Kernel|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MD DLL|x64.ActiveCfg = Debug MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MD DLL|x64.Build.0 = Debug MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MD DLL|x86.ActiveCfg = Debug MD DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MD DLL|x86.Build.0 = Debug MD DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MD|x64.ActiveCfg = Debug MD|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MD|x64.Build.0 = Debug MD|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MD|x86.ActiveCfg = Debug MD|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MD|x86.Build.0 = Debug MD|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MT DLL|x64.ActiveCfg = Debug MT DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MT DLL|x64.Build.0 = Debug MT DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MT DLL|x86.ActiveCfg = Debug MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MT DLL|x86.Build.0 = Debug MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MT|x64.ActiveCfg = Debug MT|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MT|x64.Build.0 = Debug MT|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MT|x86.ActiveCfg = Debug MT|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug MT|x86.Build.0 = Debug MT|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug(DLL)|x64.ActiveCfg = Debug MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug(DLL)|x64.Build.0 = Debug MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug(DLL)|x86.ActiveCfg = Debug MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug(DLL)|x86.Build.0 = Debug MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug(XP)|x64.ActiveCfg = Debug MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug(XP)|x64.Build.0 = Debug MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug(XP)|x86.ActiveCfg = Debug MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug(XP)|x86.Build.0 = Debug MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug|x64.ActiveCfg = Debug MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug|x64.Build.0 = Debug MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug|x86.ActiveCfg = Debug MD|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Debug|x86.Build.0 = Debug MD|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release Kernel|x64.ActiveCfg = Release Kernel|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release Kernel|x64.Build.0 = Release Kernel|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release Kernel|x64.Deploy.0 = Release Kernel|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release Kernel|x86.ActiveCfg = Release Kernel|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release Kernel|x86.Build.0 = Release Kernel|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release Kernel|x86.Deploy.0 = Release Kernel|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MD DLL|x64.ActiveCfg = Release MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MD DLL|x64.Build.0 = Release MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MD DLL|x86.ActiveCfg = Release MD DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MD DLL|x86.Build.0 = Release MD DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MD|x64.ActiveCfg = Release MD|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MD|x64.Build.0 = Release MD|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MD|x86.ActiveCfg = Release MD|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MD|x86.Build.0 = Release MD|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MT DLL|x64.ActiveCfg = Release MT DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MT DLL|x64.Build.0 = Release MT DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MT DLL|x86.ActiveCfg = Release MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MT DLL|x86.Build.0 = Release MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MT|x64.ActiveCfg = Release MT|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MT|x64.Build.0 = Release MT|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MT|x86.ActiveCfg = Release MT|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release MT|x86.Build.0 = Release MT|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release(DLL)|x64.ActiveCfg = Release MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release(DLL)|x64.Build.0 = Release MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release(DLL)|x86.ActiveCfg = Release MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release(DLL)|x86.Build.0 = Release MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release(XP)|x64.ActiveCfg = Release MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release(XP)|x64.Build.0 = Release MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release(XP)|x86.ActiveCfg = Release MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release(XP)|x86.Build.0 = Release MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release|x64.ActiveCfg = Release MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release|x64.Build.0 = Release MD DLL|x64
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release|x86.ActiveCfg = Release MT DLL|Win32
		{88A23124-5640-35A0-B890-311D7A67A7D2}.Release|x86.Build.0 = Release MT DLL|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug Kernel|x64.ActiveCfg = Debug(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug Kernel|x64.Build.0 = Debug(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug Kernel|x86.ActiveCfg = Debug(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug Kernel|x86.Build.0 = Debug(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MD DLL|x64.ActiveCfg = Debug(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MD DLL|x64.Build.0 = Debug(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MD DLL|x86.ActiveCfg = Debug(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MD DLL|x86.Build.0 = Debug(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MD|x64.ActiveCfg = Debug(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MD|x64.Build.0 = Debug(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MD|x86.ActiveCfg = Debug(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MD|x86.Build.0 = Debug(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MT DLL|x64.ActiveCfg = Debug(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MT DLL|x64.Build.0 = Debug(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MT DLL|x86.ActiveCfg = Debug(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MT DLL|x86.Build.0 = Debug(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MT|x64.ActiveCfg = Debug(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MT|x64.Build.0 = Debug(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MT|x86.ActiveCfg = Debug(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug MT|x86.Build.0 = Debug(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug(DLL)|x64.ActiveCfg = Debug(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug(DLL)|x64.Build.0 = Debug(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug(DLL)|x86.ActiveCfg = Debug(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug(DLL)|x86.Build.0 = Debug(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug(XP)|x64.ActiveCfg = Debug(XP)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug(XP)|x64.Build.0 = Debug(XP)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug(XP)|x86.ActiveCfg = Debug(XP)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug(XP)|x86.Build.0 = Debug(XP)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug|x64.ActiveCfg = Debug|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug|x64.Build.0 = Debug|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug|x86.ActiveCfg = Debug|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Debug|x86.Build.0 = Debug|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release Kernel|x64.ActiveCfg = Release(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release Kernel|x64.Build.0 = Release(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release Kernel|x86.ActiveCfg = Release(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release Kernel|x86.Build.0 = Release(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MD DLL|x64.ActiveCfg = Release(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MD DLL|x64.Build.0 = Release(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MD DLL|x86.ActiveCfg = Release(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MD DLL|x86.Build.0 = Release(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MD|x64.ActiveCfg = Release(XP)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MD|x64.Build.0 = Release(XP)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MD|x86.ActiveCfg = Release(XP)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MD|x86.Build.0 = Release(XP)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MT DLL|x64.ActiveCfg = Release(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MT DLL|x64.Build.0 = Release(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MT DLL|x86.ActiveCfg = Release(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MT DLL|x86.Build.0 = Release(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MT|x64.ActiveCfg = Release(XP)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MT|x64.Build.0 = Release(XP)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MT|x86.ActiveCfg = Release(XP)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release MT|x86.Build.0 = Release(XP)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release(DLL)|x64.ActiveCfg = Release(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release(DLL)|x64.Build.0 = Release(DLL)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release(DLL)|x86.ActiveCfg = Release(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release(DLL)|x86.Build.0 = Release(DLL)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release(XP)|x64.ActiveCfg = Release(XP)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release(XP)|x64.Build.0 = Release(XP)|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release(XP)|x86.ActiveCfg = Release(XP)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release(XP)|x86.Build.0 = Release(XP)|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release|x64.ActiveCfg = Release|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release|x64.Build.0 = Release|x64
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release|x86.ActiveCfg = Release|Win32
		{A2C53563-46F5-4D87-903F-3F1F2FDB2DEB}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {A9253B32-0019-4F9D-ADDA-7C1D933AC77C}
	EndGlobalSection
EndGlobal

```

`PeVisor/Inc/Buffer.hpp`:

```hpp
#pragma once
#include <memory>
#include <Windows.h>

class virtual_buffer_t
{
public:
	virtual_buffer_t();
	virtual_buffer_t(size_t size);
	~virtual_buffer_t();
	void* GetSpace(size_t needSize);
	size_t GetLength() { return m_cbSize; }
	void* GetBuffer() { return m_pBuffer; }

	void* m_pBuffer;
	size_t m_cbSize;
};

class crt_buffer_t
{
public:
	crt_buffer_t();
	crt_buffer_t(size_t size);
	~crt_buffer_t();
	void* GetSpace(size_t needSize);
	size_t GetLength() { return m_cbSize; }
	void* GetBuffer() { return m_pBuffer; }

	void* m_pBuffer;
	size_t m_cbSize;
};
```

`PeVisor/Inc/CPUID.hpp`:

```hpp
#pragma once

union CPUID_REGS {
    int Raw[4];
    struct {
        unsigned int Eax;
        unsigned int Ebx;
        unsigned int Ecx;
        unsigned int Edx;
    } Regs;
};
static_assert(sizeof(CPUID_REGS) == sizeof(int) * 4, "Size of CPUID_REGS != sizeof(int[4])");

namespace CPUID {
    namespace Generic {
        enum CPUID_FUNCTIONS { // EAX values:
            // Standard CPUID functions:
            CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID = 0x00000000,
            CPUID_FEATURE_INFORMATION = 0x00000001,
            CPUID_MONITOR_MWAIT_PARAMETERS = 0x00000005,
            CPUID_THERMAL_POWER_MANAGEMENT = 0x00000006,
            CPUID_STRUCTURED_EXTENDED_FEATURE_ENUMERATION = 0x00000007,

            // Extended CPUID functions:
            CPUID_MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID = 0x80000000,
            CPUID_EXTENDED_FEATURE_INFORMATION = 0x80000001,
            CPUID_PROCESSOR_BRAND_STRING_0 = 0x80000002,
            CPUID_PROCESSOR_BRAND_STRING_1 = 0x80000003,
            CPUID_PROCESSOR_BRAND_STRING_2 = 0x80000004,
        };
    }

    namespace AMD {
        enum CPUID_FUNCTIONS { // EAX values:
            // Standard CPUID functions:
            CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID = 0x00000000,
            CPUID_FEATURE_INFORMATION = 0x00000001,
            // 0x00000002..0x00000004 are reserved
            CPUID_MONITOR_MWAIT_PARAMETERS = 0x00000005,
            CPUID_THERMAL_POWER_MANAGEMENT = 0x00000006,
            CPUID_STRUCTURED_EXTENDED_FEATURE_ENUMERATION = 0x00000007,
            // 0x00000008..0x0000000C are reserved
            CPUID_PROCESSOR_EXTENDED_STATE_ENUMERATION = 0x0000000C,
            // 0x40000000..0x400000FF are reserved for hypervisor use

            // Extended CPUID functions:
            CPUID_MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID = 0x80000000,
            CPUID_EXTENDED_FEATURE_INFORMATION = 0x80000001,
            CPUID_PROCESSOR_BRAND_STRING_0 = 0x80000002,
            CPUID_PROCESSOR_BRAND_STRING_1 = 0x80000003,
            CPUID_PROCESSOR_BRAND_STRING_2 = 0x80000004,
            CPUID_L1_AND_TLB = 0x80000005,
            CPUID_L2_L3_TLB = 0x80000006,
            CPUID_POWER_MANAGEMENT_AND_RAS_CAPABILITIES = 0x80000007,
            CPUID_CAPACITY_AND_EXTENDED_FEATURES = 0x80000008,
            // 0x80000009 is reserved
            CPUID_SVM_FEATURES = 0x8000000A,
            // 0x8000000B..0x80000018 are reserved
            CPUID_TLB_CHARACTERISTICS_FOR_1GB_PAGES = 0x80000019,
            CPUID_INSTRUCTION_OPTIMIZATIONS = 0x8000001A,
            CPUID_INSTRUCTION_BASED_SAMPLING_CAPABILITIES = 0x8000001B,
            CPUID_LIGHTWEIGHT_PROFILING_CAPABILITIES = 0x8000001C,
            CPUID_CACHE_TOPOLOGY_INFORMATION = 0x8000001D,
            CPUID_PROCESSOR_TOPOLOGY_INFORMATION = 0x8000001E,
            CPUID_ENCRYPTED_MEMORY_CAPABILITIES = 0x8000001F
        };
    }

    union MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID {
        CPUID_REGS Regs;
        struct {
            unsigned int LargestStandardFunctionNumber;
            unsigned int VendorPart1; // 'uneG' || 'htuA'
            unsigned int VendorPart3; // 'letn' || 'DMAc' --> 'GenuineIntel' or 'AuthenticAMD' (EAX + EDX + ECX)
            unsigned int VendorPart2; // 'Ieni' || 'itne'
        } Bitmap;
    };
    static_assert(sizeof(MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID) == sizeof(CPUID_REGS), "Size of MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID != sizeof(int[4])");

    union MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID {
        CPUID_REGS Regs;
        struct {
            unsigned int LargestExtendedFunctionNumber;
            unsigned int VendorPart1; // 'uneG' || 'htuA'
            unsigned int VendorPart3; // 'letn' || 'DMAc' --> 'GenuineIntel' or 'AuthenticAMD' (EAX + EDX + ECX)
            unsigned int VendorPart2; // 'Ieni' || 'itne'
        } Bitmap;
    };
    static_assert(sizeof(MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID) == sizeof(CPUID_REGS), "Size of MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID != sizeof(int[4])");

    union FEATURE_INFORMATION {
        CPUID_REGS Regs;
        struct {
            // EAX:
            unsigned int Stepping : 4;
            unsigned int Model : 4;
            unsigned int FamilyId : 4;
            unsigned int Reserved0 : 4;
            unsigned int ExtendedModelId : 4;
            unsigned int ExtendedFamilyId : 8;
            unsigned int Reserved1 : 4;

            // EBX:
            unsigned int BrandIndex : 8;
            unsigned int ClflushLineSize : 8; // Value * 8 = cache line size in bytes
            unsigned int LogicalProcessorCount : 8; // Valid only if CPUID.1.EDX.HTT == 1
            unsigned int InitialApicId : 8;

            // ECX:
            unsigned int SSE3 : 1;
            unsigned int PCLMULQDQ : 1;
            unsigned int Reserved2 : 1;
            unsigned int MONITOR : 1;
            unsigned int Reserved3 : 5;
            unsigned int SSSE3 : 1;
            unsigned int Reserved4 : 2;
            unsigned int FMA : 1;
            unsigned int CMPXCHG16B : 1;
            unsigned int Reserved5 : 5;
            unsigned int SSE41 : 1;
            unsigned int SSE42 : 1;
            unsigned int Reserved6 : 1;
            unsigned int MOVBE : 1;
            unsigned int POPCNT : 1;
            unsigned int Reserved7 : 1;
            unsigned int AES : 1;
            unsigned int XSAVE : 1;
            unsigned int OSXSAVE : 1;
            unsigned int AVX : 1;
            unsigned int F16C : 1;
            unsigned int RDRAND : 1;
            unsigned int ReservedForHvGuestStatus : 1; // Reserved for use by hypervisor to indicate guest status

            // EDX:
            unsigned int FPU : 1;
            unsigned int VME : 1; // Virtual 8086-mode enhancements (including CR4.VME, CR4.PVI, EFLAGS.VIF and EFLAGS.VIP, etc.)
            unsigned int DE : 1; // Debugging extensions
            unsigned int PSE : 1; // Page size extension
            unsigned int TSC : 1; // Time stamp counter
            unsigned int MSR : 1; // RDMSR/WRMSR support
            unsigned int PAE : 1; // Physical address extensions support
            unsigned int MCE : 1; // Machine check exception
            unsigned int CMPXCHG8B : 1;
            unsigned int APIC : 1;
            unsigned int Reserved8 : 1;
            unsigned int SysEnterSysExit : 1; // SYSENTER/SYSEXIT instructions support
            unsigned int MTRR : 1; // Memory-Type Range Registers support
            unsigned int PGE : 1; // Page global bit (CR4.PGE bit controls this feature)
            unsigned int MCA : 1; // Machine check architecture
            unsigned int CMOV : 1; // Conditional move instruction support
            unsigned int PAT : 1; // Page attribute table
            unsigned int PSE36 : 1; // 36-bit page size extension
            unsigned int Reserved9 : 1;
            unsigned int CLFSH : 1; // CLFLUSH instruction support
            unsigned int Reserved10 : 3;
            unsigned int MMX : 1;
            unsigned int FXSR : 1; // FXSAVE and FXRSTOR support
            unsigned int SSE : 1;
            unsigned int SSE2 : 1;
            unsigned int Reserved11 : 1;
            unsigned int HTT : 1; // Max APIC IDs reserved field is Valid (CPUID.1.EBX.LogicalProcessorCount is valid)
            unsigned int Reserved12 : 3;
        } Generic, AMD;
    };
    static_assert(sizeof(FEATURE_INFORMATION) == sizeof(CPUID_REGS), "Size of FEATURE_INFORMATION != sizeof(int[4])");

    union EXTENDED_FEATURE_INFORMATION {
        CPUID_REGS Regs;
        struct {
            // EAX:
            unsigned int Stepping : 4;
            unsigned int Model : 4;
            unsigned int FamilyId : 4;
            unsigned int Reserved0 : 4;
            unsigned int ExtendedModelId : 4;
            unsigned int ExtendedFamilyId : 8;
            unsigned int Reserved1 : 4;

            // EBX:
            unsigned int Reserved2 : 32;

            // ECX:
            unsigned int LahfSahf : 1;
            unsigned int Reserved3 : 4;
            unsigned int LZCNT : 1;
            unsigned int Reserved4 : 2;
            unsigned int PREFETCHW : 1;
            unsigned int Reserved5 : 23;

            // EDX:
            unsigned int Reserved6 : 11;
            unsigned int SysCallSysRet : 1;
            unsigned int Reserved7 : 8;
            unsigned int NX : 1;
            unsigned int Reserved8 : 5;
            unsigned int Page1Gb : 1; // 1-Gb large page support
            unsigned int RDTSCP : 1;
            unsigned int Reserved9 : 1;
            unsigned int LongMode : 1; // 64-bit mode
            unsigned int Reserved10 : 2;
        } Generic;
        struct {
            // EAX:
            unsigned int Stepping : 4;
            unsigned int Model : 4;
            unsigned int FamilyId : 4;
            unsigned int Reserved0 : 4;
            unsigned int ExtendedModelId : 4;
            unsigned int ExtendedFamilyId : 8;
            unsigned int Reserved1 : 4;

            // EBX:
            unsigned int BrandId : 16;
            unsigned int Reserved2 : 12;
            unsigned int PkgType : 4;

            // ECX:
            unsigned int LahfSahf : 1;
            unsigned int CmpLegacy : 1; // Core multiprocessing legacy mode
            unsigned int SVM : 1; // Secure virtual machine
            unsigned int ExtApicSpace : 1;
            unsigned int AltMovCr8 : 1; // "lock mov cr0" means "mov cr8"
            unsigned int ABM : 1; // Advanced bit manipulation
            unsigned int SSE4A : 1; // EXTRQ, INSERTQ, MOVNTSS, and MOVNTSD instruction support
            unsigned int MisAlignSse : 1; // Misaligned SSE mode
            unsigned int _3DNowPrefetch : 1; // PREFETCH and PREFETCHW instruction support
            unsigned int OSVW : 1; // OS visible workaround
            unsigned int IBS : 1; // Instruction based sampling
            unsigned int XOP : 1; // Extended operation support
            unsigned int SKINIT : 1; // SKINIT and STGI are supported, independent of the value of MSRC000_0080[SVME]
            unsigned int WDT : 1; // Watchdog time support
            unsigned int Reserved3 : 1;
            unsigned int LWP : 1; // Lightweight profiling support
            unsigned int FMA4 : 1;
            unsigned int Reserved4 : 1;
            unsigned int Reserved5 : 1;
            unsigned int NodeId : 1;
            unsigned int Reserved6 : 1;
            unsigned int TBM : 1; // Trailing bit manipulation instruction support
            unsigned int TopologyExtension : 1;
            unsigned int Reserved7 : 9;

            // EDX:
            unsigned int FPU : 1;
            unsigned int VME : 1; // Virtual 8086-mode enhancements (including CR4.VME, CR4.PVI, EFLAGS.VIF and EFLAGS.VIP, etc.)
            unsigned int DE : 1; // Debugging extensions
            unsigned int PSE : 1; // Page size extension
            unsigned int TSC : 1; // Time stamp counter
            unsigned int MSR : 1; // RDMSR/WRMSR support
            unsigned int PAE : 1; // Physical address extensions support
            unsigned int MCE : 1; // Machine check exception
            unsigned int CMPXCHG8B : 1;
            unsigned int APIC : 1;
            unsigned int Reserved8 : 1;
            unsigned int SysCallSysRet : 1; // SYSCALL/SYSRET instructions support
            unsigned int MTRR : 1; // Memory-Type Range Registers support
            unsigned int PGE : 1; // Page global bit (CR4.PGE bit controls this feature)
            unsigned int MCA : 1; // Machine check architecture
            unsigned int CMOV : 1; // Conditional move instruction support
            unsigned int PAT : 1; // Page attribute table
            unsigned int PSE36 : 1; // 36-bit page size extension
            unsigned int Reserved9 : 2;
            unsigned int NX : 1; // No-execute page protection
            unsigned int Reserved10 : 1;
            unsigned int MmxExt : 1;
            unsigned int MMX : 1;
            unsigned int FXSR : 1; // FXSAVE and FXRSTOR support
            unsigned int FFXSR : 1;  // FXSAVE and FXRSTOR instruction optimizations
            unsigned int Page1Gb : 1; // 1-Gb large page support
            unsigned int RDTSCP : 1;
            unsigned int Reserved11 : 1;
            unsigned int LM : 1; // Long-mode
            unsigned int _3DNowExt : 1;
            unsigned int _3DNow : 1;
        } AMD;
    };
    static_assert(sizeof(EXTENDED_FEATURE_INFORMATION) == sizeof(CPUID_REGS), "Size of EXTENDED_FEATURE_INFORMATION != sizeof(int[4])");

    union PROCESSOR_BRAND_STRING_0 {
        CPUID_REGS Regs;
        struct {
            unsigned int Part0;
            unsigned int Part1;
            unsigned int Part2;
            unsigned int Part3;
        } ProcessorName;
    };
    static_assert(sizeof(PROCESSOR_BRAND_STRING_0) == sizeof(CPUID_REGS), "Size of PROCESSOR_BRAND_STRING_0 != sizeof(int[4])");

    union PROCESSOR_BRAND_STRING_1 {
        CPUID_REGS Regs;
        struct {
            unsigned int Part4;
            unsigned int Part5;
            unsigned int Part6;
            unsigned int Part7;
        } ProcessorName;
    };
    static_assert(sizeof(PROCESSOR_BRAND_STRING_1) == sizeof(CPUID_REGS), "Size of PROCESSOR_BRAND_STRING_1 != sizeof(int[4])");

    union PROCESSOR_BRAND_STRING_2 {
        CPUID_REGS Regs;
        struct {
            unsigned int Part8;
            unsigned int Part9;
            unsigned int Part10;
            unsigned int Part11;
        } ProcessorName;
    };
    static_assert(sizeof(PROCESSOR_BRAND_STRING_2) == sizeof(CPUID_REGS), "Size of PROCESSOR_BRAND_STRING_2 != sizeof(int[4])");
}
```

`PeVisor/Inc/Crt.hpp`:

```hpp
#pragma once
#include <unicorn/unicorn.h>

void crt_va_arg_func(uc_engine* uc, uint64_t* ap, void* result, size_t type_size);
```

`PeVisor/Inc/EmuApiFuncs.hpp`:

```hpp
#pragma once
#include "BlackBone/ManualMap/MMap.h"
#include "BlackBone/Process/Process.h"
#include "Encode.hpp"
#include "wsprintf.h"
#include "Crt.hpp"
#include "IEApiErrorCodes.hpp"
#include "Nativestructs.hpp"
#include "UCPE.hpp"
#include "unicorn/unicorn.h"
#include "Zydis/Zydis.h"
#include <iostream>
#include <sstream>

#define NtCurrentThread ((HANDLE)-2)
#define ALIGN_TO_4KB(size) (((size) + 4095) / 4096) * 4096

typedef enum class __PROCESSINFOCLASS {
	ProcessBasicInformation = 0,
	ProcessDebugPort = 7,
	ProcessWow64Information = 26,
	ProcessImageFileName = 27,
	ProcessBreakOnTermination = 29,
	ProcessDebugObjectHandle = 30,
	ProcessDebugFlags = 31,
	ProcessTelemetryIdInformation = 64,
	ProcessSubsystemInformation = 75
} PROCESSINFOCLASS_;

typedef struct __PROCESS_BASIC_INFORMATION {
	NTSTATUS ExitStatus;
	PPEB PebBaseAddress;
	ULONG_PTR AffinityMask;
	KPRIORITY BasePriority;
	ULONG_PTR UniqueProcessId;
	ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION_;

typedef enum _SUBSYSTEM_INFORMATION_TYPE {
	SubsystemInformationTypeWin32,
	SubsystemInformationTypeWSL,
	MaxSubsystemInformationType
} SUBSYSTEM_INFORMATION_TYPE, * PSUBSYSTEM_INFORMATION_TYPE;

typedef struct _PROCESS_TELEMETRY_ID_INFORMATION {
	ULONG HeaderSize;
	ULONG ProcessId;
	ULONG64 ProcessStartKey;
	ULONG64 CreateTime;
	ULONG64 CreateInterruptTime;
	ULONG64 CreateUnbiasedInterruptTime;
	ULONG64 ProcessSequenceNumber;
	ULONG64 SessionCreateTime;
	ULONG SessionId;
	ULONG BootId;
	ULONG ImageChecksum;
	ULONG ImageTimeDateStamp;
	ULONG UserSidOffset;
	ULONG ImagePathOffset;
	ULONG PackageNameOffset;
	ULONG RelativeAppNameOffset;
	ULONG CommandLineOffset;
} PROCESS_TELEMETRY_ID_INFORMATION, * PPROCESS_TELEMETRY_ID_INFORMATION;

typedef struct _THREAD_BASIC_INFORMATION {
	NTSTATUS ExitStatus;
	PVOID TebBaseAddress;
	CLIENT_ID ClientId;
	KAFFINITY AffinityMask;
	KPRIORITY Priority;
	KPRIORITY BasePriority;
} THREAD_BASIC_INFORMATION, * PTHREAD_BASIC_INFORMATION;

typedef enum class __THREADINFOCLASS {
	ThreadBasicInformation = 0x0,
	ThreadTimes = 0x01,
	ThreadPriority = 0x02,
	ThreadBasePriority = 0x03,
	ThreadAffinityMask = 0x04,
	ThreadImpersonationToken = 0x05,
	ThreadDescriptorTableEntry = 0x06,
	ThreadEnableAlignmentFaultFixup = 0x07,
	ThreadEventPair = 0x08,
	ThreadQuerySetWin32StartAddress = 0x09,
	ThreadZeroTlsCell = 0x0A,
	ThreadPerformanceCount = 0x0B,
	ThreadAmILastThread = 0x0C,
	ThreadIdealProcessor = 0x0D,
	ThreadPriorityBoost = 0x0E,
	ThreadSetTlsArrayAddress = 0x0F,
	ThreadIsIoPending = 0x10,
	ThreadHideFromDebugger = 0x11,
	ThreadBreakOnTermination = 0x12,
	ThreadSwitchLegacyState = 0x13,
	ThreadIsTerminated = 0x14,
	ThreadLastSystemCall = 0x15,
	ThreadIoPriority = 0x16,
	ThreadCycleTime = 0x17,
	ThreadPagePriority = 0x18,
	ThreadActualBasePriority = 0x19,
	ThreadTebInformation = 0x1A,
	ThreadCSwitchMon = 0x1B,
	ThreadCSwitchPmu = 0x1C,
	ThreadWow64Context = 0x1D,
	ThreadGroupInformation = 0x1E,
	ThreadUmsInformation = 0x1F,
	ThreadCounterProfiling = 0x20,
	ThreadIdealProcessorEx = 0x21,
	ThreadCpuAccountingInformation = 0x22,
	ThreadSuspendCount = 0x23,
	ThreadHeterogeneousCpuPolicy = 0x24,
	ThreadContainerId = 0x25,
	ThreadNameInformation = 0x26,
	ThreadSelectedCpuSets = 0x27,
	ThreadSystemThreadInformation = 0x28,
	ThreadActualGroupAffinity = 0x29
} THREADINFOCLASS__;

namespace InternalEmuApi {
	bool EmuWriteNullTermString(_In_ uc_engine* uc, _Inout_ DWORD_PTR address, _In_ const std::string& str);
	bool EmuWriteNullTermUnicodeString(_In_ uc_engine* uc, _Inout_ DWORD_PTR address, _In_ const std::wstring& str);
	bool EmuReadNullTermString(_In_ uc_engine* uc, _In_ DWORD_PTR address, _Inout_ std::string& str, _In_opt_ bool OnLengthLimit = false,
		_In_opt_ size_t Length = 0);
	bool EmuReadNullTermUnicodeString(_In_ uc_engine* uc, _In_ DWORD_PTR address, _Inout_ std::wstring& str, _In_opt_ bool OnLengthLimit = false,
		_In_opt_ size_t Length = 0);
	void EmuCopyASCIStrs(_In_ uc_engine* uc, _In_ LPSTR Dst, _In_ std::string Src);
	void EmuCopyUnicodeStrs(_In_ uc_engine* uc, _In_ LPWSTR EmuAddr, _In_ std::wstring Src);
	void EmuCopyBufferFromUc(_In_ uc_engine* uc, _In_ LPVOID MyAddr, _In_ LPVOID EmuAddr, _In_ size_t NumberOfBytes);
	void EmuCopyBufferToUc(_In_ uc_engine* uc, _In_ LPVOID EmuAddr, _In_ LPVOID MyAddr, _In_ size_t NumberOfBytes);
	DWORD_PTR EmuReadReturnAddress(_In_ uc_engine* uc);
}

using namespace InternalEmuApi;

typedef NTSTATUS(NTAPI* TNtQueryInformationProcess)(
	IN HANDLE           ProcessHandle,
	IN PROCESSINFOCLASS_ ProcessInformationClass,
	OUT PVOID           ProcessInformation,
	IN ULONG            ProcessInformationLength,
	OUT PULONG          ReturnLength
	);

typedef NTSTATUS(NTAPI* TNtOpenSection)(
	OUT PHANDLE             SectionHandle,
	IN ACCESS_MASK          DesiredAccess,
	IN POBJECT_ATTRIBUTES   ObjectAttributes
	);

namespace EmuApi
{
	void EmuGetSystemTimeAsFileTime(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	////////////////////////////////////////////////////////////////////////////////GUI
	void EmuMessageBoxA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuMessageBoxW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetProcessWindowStation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetUserObjectInformationW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetUserObjectInformationA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	////////////////////////////////////////////////////////////////////////////////GUI

	void EmuExitProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuGetCurrentThreadId(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetCurrentProcessId(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuQueryPerformanceCounter(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuLoadLibraryExW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuLoadLibraryA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetProcAddress(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetModuleHandleA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetModuleHandleW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetModuleFileNameA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetModuleFileNameW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetModuleHandleExW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetStartupInfoW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetStartupInfoA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetStdHandle(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetFileSize(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetFileSizeEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetFileType(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetProcessHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetCommandLineA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetCommandLineW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuCloseHandle(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuVirtualProtect(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuWvsprintfA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuWvsprintfW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuWriteFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuCreateFileW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuCreateFileA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuCreateFileMappingA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuCreateFileMappingW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuMapViewOfFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuUnmapViewOfFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuAreFileApisANSI(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuIsValidCodePage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetACP(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetCPInfo(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuWideCharToMultiByte(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuMultiByteToWideChar(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuGetStringTypeW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuLCMapStringW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	///////////////////////////////////////////////////////////////////////////////ANTI-DEBUG
	void EmuIsDebuggerPresent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuCheckRemoteDebuggerPresent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuNtQueryInformationProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuNtSetInformationThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	///////////////////////////////////////////////////////////////////////////////ANTI-DEBUG

	void EmuGetLastError(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuSetLastError(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuInitializeCriticalSectionAndSpinCount(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuInitializeCriticalSectionEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuRtlEnterCriticalSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuRtlLeaveCriticalSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuTlsAlloc(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuTlsSetValue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuTlsGetValue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuTlsFree(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuDeleteCriticalSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuLocalAlloc(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuRtlAllocateHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuLocalFree(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuRtlFreeHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuRtlIsProcessorFeaturePresent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuGetProcessAffinityMask(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuSetThreadAffinityMask(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuSleep(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuGetEnvironmentStringsW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuFreeEnvironmentStringsW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuSetUnhandledExceptionFilter(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuRtlUnwindEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	
	void EmuRtlInitializeSListHead(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuHeapValidate(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuNtOpenFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuNtOpenSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);

	void EmuExAllocatePool(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuNtProtectVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuNtQuerySystemInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuExFreePool(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuExFreePoolWithTag(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuIoAllocateMdl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuMmProbeAndLockPages(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuMmMapLockedPagesSpecifyCache(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuKeQueryActiveProcessors(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuKeSetSystemAffinityThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuKeRevertToUserAffinityThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuMmUnlockPages(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuIoFreeMdl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuRtlGetVersion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuDbgPrint(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuKeInitializeMutex(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuRtlInitUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuKeWaitForSingleObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuKeReleaseMutex(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void Emusrand(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void Emurand(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuRtlZeroMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuRtlFillMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuRtlCopyMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void Emuwcsstr(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuMmIsAddressValid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void EmuExGetPreviousMode(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void Emu__C_specific_handler(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
}
```

`PeVisor/Inc/Encode.hpp`:

```hpp
#pragma once
#include <string>
#include <Windows.h>

void ANSIToUnicode(const std::string& str, std::wstring& out);
void UnicodeToANSI(const std::wstring& str, std::string& out);
void UnicodeToUTF8(const std::wstring& str, std::string& out);
void UTF8ToUnicode(const std::string& str, std::wstring& out);
```

`PeVisor/Inc/IEApiErrorCodes.hpp`:

```hpp
#pragma once

enum class IApiEmuErrorCode
{
	GetModuleHandleAInvalidValue = 0xC000005,
};
```

`PeVisor/Inc/Nativestructs.hpp`:

```hpp
#pragma once
/// See: MEMORY-MANAGEMENT REGISTERS
#include <pshpack1.h>
struct Idtr {
	unsigned short limit;
	ULONG_PTR base;
};

struct Idtr32 {
	unsigned short limit;
	ULONG32 base;
};
static_assert(sizeof(Idtr32) == 6, "Size check");

/// @copydoc Idtr
using Gdtr = Idtr;
#if defined(_AMD64_)
static_assert(sizeof(Idtr) == 10, "Size check");
static_assert(sizeof(Gdtr) == 10, "Size check");
#else
static_assert(sizeof(Idtr) == 6, "Size check");
static_assert(sizeof(Gdtr) == 6, "Size check");
#endif
#include <poppack.h>

/// See: Segment Selectors
#include <pshpack1.h>
union SegmentSelector {
	unsigned short all;
	struct {
		unsigned short rpl : 2;  //!< Requested Privilege Level
		unsigned short ti : 1;   //!< Table Indicator
		unsigned short index : 13;
	} fields;
};
static_assert(sizeof(SegmentSelector) == 2, "Size check");
#include <poppack.h>

/// See: Segment Descriptor
union SegmentDescriptor {
	ULONG64 all;
	struct {
		ULONG64 limit_low : 16;
		ULONG64 base_low : 16;
		ULONG64 base_mid : 8;
		ULONG64 type : 4;
		ULONG64 system : 1;
		ULONG64 dpl : 2;
		ULONG64 present : 1;
		ULONG64 limit_high : 4;
		ULONG64 avl : 1;
		ULONG64 l : 1;  //!< 64-bit code segment (IA-32e mode only)
		ULONG64 db : 1;
		ULONG64 gran : 1;
		ULONG64 base_high : 8;
	} fields;
};
static_assert(sizeof(SegmentDescriptor) == 8, "Size check");

/// @copydoc SegmentDescriptor
struct SegmentDesctiptorX64 {
	SegmentDescriptor descriptor;
	ULONG32 base_upper32;
	ULONG32 reserved;
};
static_assert(sizeof(SegmentDesctiptorX64) == 16, "Size check");

/// See: MODEL-SPECIFIC REGISTERS (MSRS)
enum class Msr : unsigned int {
	kIa32ApicBase = 0x01B,

	kIa32FeatureControl = 0x03A,

	kIa32SysenterCs = 0x174,
	kIa32SysenterEsp = 0x175,
	kIa32SysenterEip = 0x176,

	kIa32Debugctl = 0x1D9,

	kIa32MtrrCap = 0xFE,
	kIa32MtrrDefType = 0x2FF,
	kIa32MtrrPhysBaseN = 0x200,
	kIa32MtrrPhysMaskN = 0x201,
	kIa32MtrrFix64k00000 = 0x250,
	kIa32MtrrFix16k80000 = 0x258,
	kIa32MtrrFix16kA0000 = 0x259,
	kIa32MtrrFix4kC0000 = 0x268,
	kIa32MtrrFix4kC8000 = 0x269,
	kIa32MtrrFix4kD0000 = 0x26A,
	kIa32MtrrFix4kD8000 = 0x26B,
	kIa32MtrrFix4kE0000 = 0x26C,
	kIa32MtrrFix4kE8000 = 0x26D,
	kIa32MtrrFix4kF0000 = 0x26E,
	kIa32MtrrFix4kF8000 = 0x26F,

	kIa32VmxBasic = 0x480,
	kIa32VmxPinbasedCtls = 0x481,
	kIa32VmxProcBasedCtls = 0x482,
	kIa32VmxExitCtls = 0x483,
	kIa32VmxEntryCtls = 0x484,
	kIa32VmxMisc = 0x485,
	kIa32VmxCr0Fixed0 = 0x486,
	kIa32VmxCr0Fixed1 = 0x487,
	kIa32VmxCr4Fixed0 = 0x488,
	kIa32VmxCr4Fixed1 = 0x489,
	kIa32VmxVmcsEnum = 0x48A,
	kIa32VmxProcBasedCtls2 = 0x48B,
	kIa32VmxEptVpidCap = 0x48C,
	kIa32VmxTruePinbasedCtls = 0x48D,
	kIa32VmxTrueProcBasedCtls = 0x48E,
	kIa32VmxTrueExitCtls = 0x48F,
	kIa32VmxTrueEntryCtls = 0x490,
	kIa32VmxVmfunc = 0x491,

	kIa32Efer = 0xC0000080,
	kIa32Star = 0xC0000081,
	kIa32Lstar = 0xC0000082,

	kIa32Fmask = 0xC0000084,

	kIa32FsBase = 0xC0000100,
	kIa32GsBase = 0xC0000101,
	kIa32KernelGsBase = 0xC0000102,
	kIa32TscAux = 0xC0000103,
};

union FlagRegister {
	ULONG_PTR all;
	struct {
		ULONG_PTR cf : 1;          //!< [0] Carry flag
		ULONG_PTR reserved1 : 1;   //!< [1] Always 1
		ULONG_PTR pf : 1;          //!< [2] Parity flag
		ULONG_PTR reserved2 : 1;   //!< [3] Always 0
		ULONG_PTR af : 1;          //!< [4] Borrow flag
		ULONG_PTR reserved3 : 1;   //!< [5] Always 0
		ULONG_PTR zf : 1;          //!< [6] Zero flag
		ULONG_PTR sf : 1;          //!< [7] Sign flag
		ULONG_PTR tf : 1;          //!< [8] Trap flag
		ULONG_PTR intf : 1;        //!< [9] Interrupt flag
		ULONG_PTR df : 1;          //!< [10] Direction flag
		ULONG_PTR of : 1;          //!< [11] Overflow flag
		ULONG_PTR iopl : 2;        //!< [12:13] I/O privilege level
		ULONG_PTR nt : 1;          //!< [14] Nested task flag
		ULONG_PTR reserved4 : 1;   //!< [15] Always 0
		ULONG_PTR rf : 1;          //!< [16] Resume flag
		ULONG_PTR vm : 1;          //!< [17] Virtual 8086 mode
		ULONG_PTR ac : 1;          //!< [18] Alignment check
		ULONG_PTR vif : 1;         //!< [19] Virtual interrupt flag
		ULONG_PTR vip : 1;         //!< [20] Virtual interrupt pending
		ULONG_PTR id : 1;          //!< [21] Identification flag
		ULONG_PTR reserved5 : 10;  //!< [22:31] Always 0
	} fields;
};
static_assert(sizeof(FlagRegister) == sizeof(void*), "Size check");

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

typedef struct _DRIVER_OBJECT {
	SHORT Type;
	SHORT Size;

	//
	// The following links all of the devices created by a single driver
	// together on a list, and the Flags word provides an extensible flag
	// location for driver objects.
	//

	PVOID DeviceObject;
	ULONG Flags;

	//
	// The following section describes where the driver is loaded.  The count
	// field is used to count the number of times the driver has had its
	// registered reinitialization routine invoked.
	//

	PVOID DriverStart;
	ULONG DriverSize;
	PVOID DriverSection;
	PVOID DriverExtension;

	//
	// The driver name field is used by the error log thread
	// determine the name of the driver that an I/O request is/was bound.
	//

	UNICODE_STRING DriverName;

	//
	// The following section is for registry support.  This is a pointer
	// to the path to the hardware information in the registry
	//

	PUNICODE_STRING HardwareDatabase;

	//
	// The following section contains the optional pointer to an array of
	// alternate entry points to a driver for "fast I/O" support.  Fast I/O
	// is performed by invoking the driver routine directly with separate
	// parameters, rather than using the standard IRP call mechanism.  Note
	// that these functions may only be used for synchronous I/O, and when
	// the file is cached.
	//

	PVOID FastIoDispatch;

	//
	// The following section describes the entry points to this particular
	// driver.  Note that the major function dispatch table must be the last
	// field in the object so that it remains extensible.
	//

	PVOID DriverInit;
	PVOID DriverStartIo;
	PVOID DriverUnload;
	PVOID MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT* PDRIVER_OBJECT;

typedef enum _SYSTEM_INFORMATION_CLASS_EX
{
	SystemProcessorInformation = 0x1,
	SystemPathInformation = 0x4,
	SystemCallCountInformation = 0x6,
	SystemDeviceInformation = 0x7,
	SystemFlagsInformation = 0x9,
	SystemCallTimeInformation = 0xa,
	SystemModuleInformation = 0xb,
	SystemLocksInformation = 0xc,
	SystemStackTraceInformation = 0xd,
	SystemPagedPoolInformation = 0xe,
	SystemNonPagedPoolInformation = 0xf,
	SystemHandleInformation = 0x10,
	SystemObjectInformation = 0x11,
	SystemPageFileInformation = 0x12,
	SystemVdmInstemulInformation = 0x13,
	SystemVdmBopInformation = 0x14,
	SystemFileCacheInformation = 0x15,
	SystemPoolTagInformation = 0x16,
	SystemDpcBehaviorInformation = 0x18,
	SystemFullMemoryInformation = 0x19,
	SystemLoadGdiDriverInformation = 0x1a,
	SystemUnloadGdiDriverInformation = 0x1b,
	SystemTimeAdjustmentInformation = 0x1c,
	SystemSummaryMemoryInformation = 0x1d,
	SystemMirrorMemoryInformation = 0x1e,
	SystemPerformanceTraceInformation = 0x1f,
	SystemObsolete0 = 0x20,
	SystemCrashDumpStateInformation = 0x22,
	SystemKernelDebuggerInformation = 0x23,
	SystemContextSwitchInformation = 0x24,
	SystemExtendServiceTableInformation = 0x26,
	SystemPrioritySeperation = 0x27,
	SystemVerifierAddDriverInformation = 0x28,
	SystemVerifierRemoveDriverInformation = 0x29,
	SystemProcessorIdleInformation = 0x2a,
	SystemLegacyDriverInformation = 0x2b,
	SystemCurrentTimeZoneInformation = 0x2c,
	SystemTimeSlipNotification = 0x2e,
	SystemSessionCreate = 0x2f,
	SystemSessionDetach = 0x30,
	SystemSessionInformation = 0x31,
	SystemRangeStartInformation = 0x32,
	SystemVerifierInformation = 0x33,
	SystemVerifierThunkExtend = 0x34,
	SystemSessionProcessInformation = 0x35,
	SystemLoadGdiDriverInSystemSpace = 0x36,
	SystemNumaProcessorMap = 0x37,
	SystemPrefetcherInformation = 0x38,
	SystemExtendedProcessInformation = 0x39,
	SystemRecommendedSharedDataAlignment = 0x3a,
	SystemComPlusPackage = 0x3b,
	SystemNumaAvailableMemory = 0x3c,
	SystemProcessorPowerInformation = 0x3d,
	SystemEmulationBasicInformation = 0x3e,
	SystemEmulationProcessorInformation = 0x3f,
	SystemExtendedHandleInformation = 0x40,
	SystemLostDelayedWriteInformation = 0x41,
	SystemBigPoolInformation = 0x42,
	SystemSessionPoolTagInformation = 0x43,
	SystemSessionMappedViewInformation = 0x44,
	SystemHotpatchInformation = 0x45,
	SystemObjectSecurityMode = 0x46,
	SystemWatchdogTimerHandler = 0x47,
	SystemWatchdogTimerInformation = 0x48,
	SystemLogicalProcessorInformation = 0x49,
	SystemWow64SharedInformationObsolete = 0x4a,
	SystemRegisterFirmwareTableInformationHandler = 0x4b,
	SystemFirmwareTableInformation = 0x4c,
	SystemModuleInformationEx = 0x4d,
	SystemVerifierTriageInformation = 0x4e,
	SystemSuperfetchInformation = 0x4f,
	SystemMemoryListInformation = 0x50,
	SystemFileCacheInformationEx = 0x51,
	SystemThreadPriorityClientIdInformation = 0x52,
	SystemProcessorIdleCycleTimeInformation = 0x53,
	SystemVerifierCancellationInformation = 0x54,
	SystemProcessorPowerInformationEx = 0x55,
	SystemRefTraceInformation = 0x56,
	SystemSpecialPoolInformation = 0x57,
	SystemProcessIdInformation = 0x58,
	SystemErrorPortInformation = 0x59,
	SystemBootEnvironmentInformation = 0x5a,
	SystemHypervisorInformation = 0x5b,
	SystemVerifierInformationEx = 0x5c,
	SystemTimeZoneInformation = 0x5d,
	SystemImageFileExecutionOptionsInformation = 0x5e,
	SystemCoverageInformation = 0x5f,
	SystemPrefetchPatchInformation = 0x60,
	SystemVerifierFaultsInformation = 0x61,
	SystemSystemPartitionInformation = 0x62,
	SystemSystemDiskInformation = 0x63,
	SystemProcessorPerformanceDistribution = 0x64,
	SystemNumaProximityNodeInformation = 0x65,
	SystemDynamicTimeZoneInformation = 0x66,
	SystemCodeIntegrityInformation_ = 0x67,
	SystemProcessorMicrocodeUpdateInformation = 0x68,
	SystemProcessorBrandString = 0x69,
	SystemVirtualAddressInformation = 0x6a,
	SystemLogicalProcessorAndGroupInformation = 0x6b,
	SystemProcessorCycleTimeInformation = 0x6c,
	SystemStoreInformation = 0x6d,
	SystemRegistryAppendString = 0x6e,
	SystemAitSamplingValue = 0x6f,
	SystemVhdBootInformation = 0x70,
	SystemCpuQuotaInformation = 0x71,
	SystemNativeBasicInformation = 0x72,
	SystemErrorPortTimeouts = 0x73,
	SystemLowPriorityIoInformation = 0x74,
	SystemBootEntropyInformation = 0x75,
	SystemVerifierCountersInformation = 0x76,
	SystemPagedPoolInformationEx = 0x77,
	SystemSystemPtesInformationEx = 0x78,
	SystemNodeDistanceInformation = 0x79,
	SystemAcpiAuditInformation = 0x7a,
	SystemBasicPerformanceInformation = 0x7b,
	SystemQueryPerformanceCounterInformation = 0x7c,
	SystemSessionBigPoolInformation = 0x7d,
	SystemBootGraphicsInformation = 0x7e,
	SystemScrubPhysicalMemoryInformation = 0x7f,
	SystemBadPageInformation = 0x80,
	SystemProcessorProfileControlArea = 0x81,
	SystemCombinePhysicalMemoryInformation = 0x82,
	SystemEntropyInterruptTimingInformation = 0x83,
	SystemConsoleInformation = 0x84,
	SystemPlatformBinaryInformation = 0x85,
	SystemThrottleNotificationInformation = 0x86,
	SystemHypervisorProcessorCountInformation = 0x87,
	SystemDeviceDataInformation = 0x88,
	SystemDeviceDataEnumerationInformation = 0x89,
	SystemMemoryTopologyInformation = 0x8a,
	SystemMemoryChannelInformation = 0x8b,
	SystemBootLogoInformation = 0x8c,
	SystemProcessorPerformanceInformationEx = 0x8d,
	SystemSpare0 = 0x8e,
	SystemSecureBootPolicyInformation = 0x8f,
	SystemPageFileInformationEx = 0x90,
	SystemSecureBootInformation = 0x91,
	SystemEntropyInterruptTimingRawInformation = 0x92,
	SystemPortableWorkspaceEfiLauncherInformation = 0x93,
	SystemFullProcessInformation = 0x94,
	SystemKernelDebuggerInformationEx = 0x95,
	SystemBootMetadataInformation = 0x96,
	SystemSoftRebootInformation = 0x97,
	SystemElamCertificateInformation = 0x98,
	SystemOfflineDumpConfigInformation = 0x99,
	SystemProcessorFeaturesInformation = 0x9a,
	SystemRegistryReconciliationInformation = 0x9b,

	SystemKernelVaShadowInformation = 196,
	MaxSystemInfoClass = 0x9c,
} SYSTEM_INFORMATION_CLASS_EX;

typedef struct _RTL_PROCESS_MODULE_INFORMATION
{
	HANDLE Section;         // Not filled in
	PVOID MappedBase;
	PVOID ImageBase;
	ULONG ImageSize;
	ULONG Flags;
	USHORT LoadOrderIndex;
	USHORT InitOrderIndex;
	USHORT LoadCount;
	USHORT OffsetToFileName;
	UCHAR  FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, * PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_USER_PROCESS_PARAMETERS_EX {
	ULONG                   MaximumLength;//+0
	ULONG                   Length;//+4
	ULONG                   Flags;//+8
	ULONG                   DebugFlags;//+12
	PVOID                   ConsoleHandle;//+16
	ULONG                   ConsoleFlags;//+24
	HANDLE                  StdInputHandle;//+32
	HANDLE                  StdOutputHandle;//+40
	HANDLE                  StdErrorHandle;//+48
	UNICODE_STRING          CurrentDirectoryPath;//+56
	HANDLE                  CurrentDirectoryHandle;//+72
	UNICODE_STRING          DllPath;//+80
	UNICODE_STRING ImagePathName;//Offset=96 in x64
	UNICODE_STRING CommandLine;
	//MORE
} RTL_USER_PROCESS_PARAMETERS_EX, * PRTL_USER_PROCESS_PARAMETERS_EX;

typedef struct _RTL_PROCESS_MODULES
{
	ULONG NumberOfModules;
	RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, * PRTL_PROCESS_MODULES;

typedef struct _RTL_CRITICAL_SECTION_64 {
	uint64_t DebugInfo;
	uint32_t LockCount;
	uint32_t RecursionCount;
	uint64_t OwningThread;
	uint64_t LockSemaphore;
	uint64_t SpinCount;
} RTL_CRITICAL_SECTION_64, * PRTL_CRITICAL_SECTION_64;

typedef struct _MDL {
	struct _MDL* Next;
	SHORT Size;
	SHORT MdlFlags;

	PVOID Process;
	PVOID MappedSystemVa;   /* see creators for field size annotations. */
	PVOID StartVa;   /* see creators for validity; could be address 0.  */
	ULONG ByteCount;
	ULONG ByteOffset;
} MDL, * PMDL;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION
{
	BOOLEAN DebuggerEnabled;
	BOOLEAN DebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, * PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _KLDR_DATA_TABLE_ENTRY {
	LIST_ENTRY InLoadOrderLinks;
	PVOID ExceptionTable;
	ULONG ExceptionTableSize;
	// ULONG padding on IA64
	PVOID GpValue;
	PVOID NonPagedDebugInfo;
	PVOID DllBase;
	PVOID EntryPoint;
	ULONG SizeOfImage;
	UNICODE_STRING FullDllName;
	UNICODE_STRING BaseDllName;
	ULONG Flags;
	USHORT LoadCount;
	USHORT __Unused5;
	PVOID SectionPointer;
	ULONG CheckSum;
	// ULONG padding on IA64
	PVOID LoadedImports;
	PVOID PatchInformation;
} KLDR_DATA_TABLE_ENTRY, * PKLDR_DATA_TABLE_ENTRY;

#define UNWIND_HISTORY_TABLE_NONE 0
#define UNWIND_HISTORY_TABLE_GLOBAL 1
#define UNWIND_HISTORY_TABLE_LOCAL 2

#define MAXIMUM_INVERTED_FUNCTION_TABLE_SIZE 160

typedef struct _INVERTED_FUNCTION_TABLE_ENTRY {
	PRUNTIME_FUNCTION FunctionTable;
	PVOID ImageBase;
	ULONG SizeOfImage;
	ULONG SizeOfTable;
} INVERTED_FUNCTION_TABLE_ENTRY, * PINVERTED_FUNCTION_TABLE_ENTRY;

typedef struct _INVERTED_FUNCTION_TABLE {
	ULONG CurrentSize;
	ULONG MaximumSize;
	BOOLEAN Overflow;
	INVERTED_FUNCTION_TABLE_ENTRY TableEntry[MAXIMUM_INVERTED_FUNCTION_TABLE_SIZE];
} INVERTED_FUNCTION_TABLE, * PINVERTED_FUNCTION_TABLE;

typedef enum _UNWIND_OP_CODES {
	UWOP_PUSH_NONVOL = 0,
	UWOP_ALLOC_LARGE,
	UWOP_ALLOC_SMALL,
	UWOP_SET_FPREG,
	UWOP_SAVE_NONVOL,
	UWOP_SAVE_NONVOL_FAR,
	//UWOP_EPILOG,
	UWOP_SPARE_CODE1,
	UWOP_SPARE_CODE2,
	UWOP_SAVE_XMM128,
	UWOP_SAVE_XMM128_FAR,
	UWOP_PUSH_MACHFRAME
} UNWIND_OP_CODES, * PUNWIND_OP_CODES;

//
// Define unwind code structure.
//

typedef union _UNWIND_CODE {
	struct {
		UCHAR CodeOffset;
		UCHAR UnwindOp : 4;
		UCHAR OpInfo : 4;
	};

	struct {
		UCHAR OffsetLow;
		UCHAR UnwindOp : 4;
		UCHAR OffsetHigh : 4;
	} EpilogueCode;

	USHORT FrameOffset;
} UNWIND_CODE, * PUNWIND_CODE;

//
// Define unwind information flags.
//

#define UNW_FLAG_NHANDLER 0x0
#define UNW_FLAG_EHANDLER 0x1
#define UNW_FLAG_UHANDLER 0x2
#define UNW_FLAG_CHAININFO 0x4

//
// Define unwind information structure.
//

typedef struct _UNWIND_INFO {
	UCHAR Version : 3;
	UCHAR Flags : 5;
	UCHAR SizeOfProlog;
	UCHAR CountOfCodes;
	UCHAR FrameRegister : 4;
	UCHAR FrameOffset : 4;
	UNWIND_CODE UnwindCode[1];

	//
	// The unwind codes are followed by an optional DWORD aligned field that
	// contains the exception handler address or a function table entry if
	// chained unwind information is specified. If an exception handler address
	// is specified, then it is followed by the language specified exception
	// handler data.
	//
	//  union {
	//      struct {
	//          ULONG ExceptionHandler;
	//          ULONG ExceptionData[];
	//      };
	//
	//      RUNTIME_FUNCTION FunctionEntry;
	//  };
	//

} UNWIND_INFO, * PUNWIND_INFO;
```

`PeVisor/Inc/Registers.hpp`:

```hpp
#pragma once

/*
    Registers CR1, CR5..CR7, CR9..CR15, DR8..DR15 aren't implemented.
    Any attempt to access unimplemented registers results in an invalid-opcode exception (#UD).
*/

#pragma pack(push, 1)
union EFLAGS {
    unsigned int Value;
    struct {
        unsigned int CF : 1; // Carry flag
        unsigned int MustBe1Bit1 : 1;
        unsigned int PF : 1; // Parity flag
        unsigned int MustBe0Bit3 : 1;
        unsigned int AF : 1; // Auxiliary carry flag
        unsigned int MustBe0Bit5 : 1;
        unsigned int ZF : 1; // Zero flag
        unsigned int SF : 1; // Sign flag
        unsigned int TF : 1; // Trap flag
        unsigned int IF : 1; // Interrupt enable flag
        unsigned int DF : 1; // Direction flag
        unsigned int OF : 1; // Overflow flag
        unsigned int IOPL : 2; // Input-output privilege level
        unsigned int NT : 1; // Nested task
        unsigned int MD : 1; //Mode flag (NEC V-series only), reserved on all Intel CPUs. Always 1 on 8086/186, 0 on 286 and later.
        unsigned int RF : 1; // Resume flag
        unsigned int VM : 1; // Virtual-8086 mode
        unsigned int AC : 1; // Alignment-check / access control
        unsigned int VIF : 1; // Virtual interrupt flag
        unsigned int VIP : 1; // Virtual interrupt pending
        unsigned int ID : 1; // ID flag
        unsigned int MustBe0Bit22 : 1;
        unsigned int MustBe0Bit23 : 1;
        unsigned int MustBe0Bit24 : 1;
        unsigned int MustBe0Bit25 : 1;
        unsigned int MustBe0Bit26 : 1;
        unsigned int MustBe0Bit27 : 1;
        unsigned int MustBe0Bit28 : 1;
        unsigned int MustBe0Bit29 : 1;
        unsigned int AESKSLF : 1;//AES key schedule loaded flag (CPUs with VIA PadLock only)
        unsigned int AI : 1;//Alternate Instruction Set enabled (VIA C5XL processors only)
    } Bitmap;
};

union RFLAGS {
    unsigned long long Value;
    struct {
        EFLAGS Eflags;
        unsigned int Reserved;
    } Bitmap;
};

union CR0 {
    unsigned long long Value;
    union {
        unsigned int Value;
        struct {
            unsigned int PE : 1; // Protection enabled
            unsigned int MP : 1; // Monitor coprocessor
            unsigned int EM : 1; // Emulation of 8087
            unsigned int TS : 1; // Task switched
            unsigned int ET : 1; // Extension type (readonly)
            unsigned int NE : 1; // Numeric error
            unsigned int Reserved0 : 10;
            unsigned int WP : 1; // Write protect
            unsigned int Reserved1 : 1;
            unsigned int AM : 1; // Alignment mask
            unsigned int Reserved3 : 10;
            unsigned int NW : 1; // Not writethrough
            unsigned int CD : 1; // Cache disable
            unsigned int PG : 1; // Paging
        } Bitmap;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long PE : 1; // Protection enabled
            unsigned long long MP : 1; // Monitor coprocessor
            unsigned long long EM : 1; // Emulation of 8087
            unsigned long long TS : 1; // Task switched
            unsigned long long ET : 1; // Extension type (readonly)
            unsigned long long NE : 1; // Numeric error
            unsigned long long Reserved0 : 10;
            unsigned long long WP : 1; // Write protect
            unsigned long long Reserved1 : 1;
            unsigned long long AM : 1; // Alignment mask
            unsigned long long Reserved3 : 10;
            unsigned long long NW : 1; // Not writethrough
            unsigned long long CD : 1; // Cache disable
            unsigned long long PG : 1; // Paging
            unsigned long long Reserved4 : 32;
        } Bitmap;
    } x64;
};

union CR2 {
    unsigned long long Value;
    struct {
        unsigned int PageFaultLinearAddress;
    } x32;
    struct {
        unsigned long long PageFaultLinearAddress;
    } x64;
};

union CR3 {
    unsigned long long Value;
    union {
        unsigned int Value;
        struct {
            unsigned int Reserved0 : 3;
            unsigned int PWT : 1; // Write through
            unsigned int PCD : 1; // Cache disable
            unsigned int Reserved1 : 7;
            unsigned int PD : 20; // Page Directory table base address
        } NonPae;
        struct {
            unsigned int Reserved0 : 3;
            unsigned int PWT : 1; // Write through
            unsigned int PCD : 1; // Cache disable
            unsigned int PDP : 27; // Page Directory Pointer table base address
        } Pae;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long Reserved0 : 3;
            unsigned long long PWT : 1; // Write through
            unsigned long long PCD : 1; // Cache disable
            unsigned long long Reserved1 : 7;
            unsigned long long PML4 : 40; // PML4 table base address
            unsigned long long Reserved2 : 12;
        } Bitmap;
    } x64;
};

union CR4 {
    unsigned long long Value;
    union {
        unsigned int Value;
        struct {
            unsigned int VME : 1; // Virtual 8086-mode extensions
            unsigned int PVI : 1; // Protected-mode virtual interrupts
            unsigned int TSD : 1; // Timestamp disable
            unsigned int DE : 1; // Debugging extensions
            unsigned int PSE : 1; // Page size extensions
            unsigned int PAE : 1; // Physical address extension
            unsigned int MCE : 1; // Machine check enable
            unsigned int PGE : 1; // Page global enable
            unsigned int PCE : 1; // Performance-monitoring counter enable
            unsigned int OSFXSR : 1; // Operating system FXSAVE/FXSTOR support
            unsigned int OSXMMEXCPT : 1; // Operating system unmasked exception support
            unsigned int UMIP : 1; // Usermode instruction prevention
            unsigned int LA57 : 1; // AMD EPYC 7004 "Genoa"(https://www.phoronix.com/news/AMD-5-Level-Paging-KVM)++
            unsigned int VMXE : 1; // VMX-enable bit (Intel only)
            unsigned int SMXE : 1; // SMX-enable bit (Safer Mode Extensions, Intel only)
            unsigned int KL : 1; // Key Locker Enable
            unsigned int FSGSBASE : 1; // Enable RDFSBASE, RDGSBASE, WRFSBASE and WRGSBASE instructions
            unsigned int PCIDE : 1; // PCID-enable bit (Process-Context Identifiers, Intel only)
            unsigned int OSXSAVE : 1; // XSAVE and Processor Extended States Enable bit
            unsigned int Reserved2 : 1;
            unsigned int SMEP : 1; // Supervisor mode execution prevention
            unsigned int SMAP : 1; // Supervisor mode access prevention
            unsigned int PKE : 1; // Protection key enable
            unsigned int CET : 1; // Control-flow Enforcement Technology
            unsigned long long PKS : 1; // Enable Protection Keys for Supervisor-Mode Pages
            unsigned long long UINTR : 1; // User Interrupts Enable
            unsigned int Reserved3 : 7;
        } Bitmap;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long VME : 1; // Virtual 8086-mode extensions
            unsigned long long PVI : 1; // Protected-mode virtual interrupts
            unsigned long long TSD : 1; // Timestamp disable
            unsigned long long DE : 1; // Debugging extensions
            unsigned long long PSE : 1; // Page size extensions
            unsigned long long PAE : 1; // Physical address extension
            unsigned long long MCE : 1; // Machine check enable
            unsigned long long PGE : 1; // Page global enable
            unsigned long long PCE : 1; // Performance-monitoring counter enable
            unsigned long long OSFXSR : 1; // Operating system FXSAVE/FXSTOR support
            unsigned long long OSXMMEXCPT : 1; // Operating system unmasked exception support
            unsigned long long UMIP : 1; // Usermode instruction prevention
            unsigned long long LA57 : 1; // AMD EPYC 7004 "Genoa"(https://www.phoronix.com/news/AMD-5-Level-Paging-KVM)++
            unsigned long long VMXE : 1; // VMX-enable bit (Intel only)
            unsigned long long SMXE : 1; // SMX-enable bit (Safer Mode Extensions, Intel only)
            unsigned long long KL : 1; // Key Locker Enable
            unsigned long long FSGSBASE : 1; // Enable RDFSBASE, RDGSBASE, WRFSBASE and WRGSBASE instructions
            unsigned long long PCIDE : 1; // PCID-enable bit (Process-Context Identifiers, Intel only)
            unsigned long long OSXSAVE : 1; // XSAVE and Processor Extended States Enable bit
            unsigned long long Reserved2 : 1;
            unsigned long long SMEP : 1; // Supervisor mode execution prevention
            unsigned long long SMAP : 1; // Supervisor mode access prevention
            unsigned long long PKE : 1; // Protection key enable
            unsigned long long CET : 1; // Control-flow Enforcement Technology
            unsigned long long PKS : 1; // Enable Protection Keys for Supervisor-Mode Pages
            unsigned long long UINTR : 1; // User Interrupts Enable
            unsigned long long Reserved3 : 38;
        } Bitmap;
    } x64;
};

union CR8 { // Task priority register:
    unsigned long long Reserved;
    struct {
        unsigned long long TPR : 4; // Priority
        unsigned long long Reserved : 60;
    } x64;
};



union DR0 {
    unsigned long long Breakpoint0LinearAddress;
    struct {
        unsigned int Breakpoint0LinearAddress;
    } x32;
    struct {
        unsigned long long Breakpoint0LinearAddress;
    } x64;
};

union DR1 {
    unsigned long long Breakpoint1LinearAddress;
    struct {
        unsigned int Breakpoint1LinearAddress;
    } x32;
    struct {
        unsigned long long Breakpoint1LinearAddress;
    } x64;
};

union DR2 {
    unsigned long long Breakpoint2LinearAddress;
    struct {
        unsigned int Breakpoint2LinearAddress;
    } x32;
    struct {
        unsigned long long Breakpoint2LinearAddress;
    } x64;
};

union DR3 {
    unsigned long long Breakpoint3LinearAddress;
    struct {
        unsigned int Breakpoint3LinearAddress;
    } x32;
    struct {
        unsigned long long Breakpoint3LinearAddress;
    } x64;
};

union DR4 { // Aliased to the DR6
    unsigned long long Reserved;
};

union DR5 { // Aliased to the DR7
    unsigned long long Reserved;
};

union DR6 {
    unsigned long long Value;
    union {
        unsigned int Value;
        struct {
            unsigned int B0 : 1; // Breakpoint #0 condition detected
            unsigned int B1 : 1; // Breakpoint #1 condition detected
            unsigned int B2 : 1; // Breakpoint #2 condition detected
            unsigned int B3 : 1; // Breakpoint #3 condition detected
            unsigned int FilledByOnes0 : 8; // Must be 0xFF (8 bits of ones: 0b1111_1111)
            unsigned int ReservedByZero : 1;
            unsigned int BD : 1; // Debug register access detected
            unsigned int BS : 1; // Single step
            unsigned int BT : 1; // Task switch
            unsigned int RTM : 1; // Intel only, must be 1 on AMD platforms
            unsigned int FilledByOnes1 : 15; // Must be 0x7FFF (15 bits of ones: 0b111_1111_1111_1111)
        } Bitmap;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long B0 : 1; // Breakpoint #0 condition detected
            unsigned long long B1 : 1; // Breakpoint #1 condition detected
            unsigned long long B2 : 1; // Breakpoint #2 condition detected
            unsigned long long B3 : 1; // Breakpoint #3 condition detected
            unsigned long long FilledByOnes0 : 8; // Must be 0xFF (8 bits of ones: 0b1111_1111)
            unsigned long long ReservedByZero : 1;
            unsigned long long BD : 1; // Debug register access detected
            unsigned long long BS : 1; // Single step
            unsigned long long BT : 1; // Task switch
            unsigned long long RTM : 1; // Intel only, must be 1 on AMD platforms
            unsigned long long FilledByOnes1 : 15; // Must be 0x7FFF (15 bits of ones: 0b111_1111_1111_1111)
            unsigned long long MustBeZero : 32;
        } Bitmap;
    } x64;
};

union DR7 {
    unsigned long long Value;
    union {
        unsigned int Value;
        struct {
            unsigned int L0 : 1; // Local  exact breakpoint #0 enabled
            unsigned int G0 : 1; // Global exact breakpoint #0 enabled
            unsigned int L1 : 1; // Local  exact breakpoint #1 enabled
            unsigned int G1 : 1; // Global exact breakpoint #1 enabled
            unsigned int L2 : 1; // Local  exact breakpoint #2 enabled
            unsigned int G2 : 1; // Global exact breakpoint #2 enabled
            unsigned int L3 : 1; // Local  exact breakpoint #3 enabled
            unsigned int G3 : 1; // Global exact breakpoint #3 enabled
            unsigned int LE : 1; // Local  exact breakpoint enabled
            unsigned int GE : 1; // Global exact breakpoint enabled
            unsigned int ReservedAsOne : 1;
            unsigned int RTM : 1; // Intel only, must be zero on AMD platforms
            unsigned int ReservedAsZero0 : 1;
            unsigned int GD : 1; // General detect enabled
            unsigned int ReservedAsZero1 : 2;
            unsigned int RW0 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned int LEN0 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned int RW1 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned int LEN1 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned int RW2 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned int LEN2 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned int RW3 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned int LEN3 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
        } Bitmap;
    } x32;
    union {
        unsigned long long Value;
        struct {
            unsigned long long L0 : 1; // Local  exact breakpoint #0 enabled
            unsigned long long G0 : 1; // Global exact breakpoint #0 enabled
            unsigned long long L1 : 1; // Local  exact breakpoint #1 enabled
            unsigned long long G1 : 1; // Global exact breakpoint #1 enabled
            unsigned long long L2 : 1; // Local  exact breakpoint #2 enabled
            unsigned long long G2 : 1; // Global exact breakpoint #2 enabled
            unsigned long long L3 : 1; // Local  exact breakpoint #3 enabled
            unsigned long long G3 : 1; // Global exact breakpoint #3 enabled
            unsigned long long LE : 1; // Local  exact breakpoint enabled
            unsigned long long GE : 1; // Global exact breakpoint enabled
            unsigned long long ReservedAsOne : 1;
            unsigned long long RTM : 1; // Intel only, must be zero on AMD platforms
            unsigned long long ReservedAsZero0 : 1;
            unsigned long long GD : 1; // General detect enabled
            unsigned long long ReservedAsZero1 : 2;
            unsigned long long RW0 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned long long LEN0 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned long long RW1 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned long long LEN1 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned long long RW2 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned long long LEN2 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned long long RW3 : 2; // 0b00 - Execute, 0b01 - Write, 0b10 - CR4.DE(0 - Undefined, 1 - I/O Reads & Writes), 0b11 - Read/Write only
            unsigned long long LEN3 : 2; // 0b00 = 1 byte, 0b01 = 2 bytes, 0b10 = 8 bytes (long mode only, otherwise undefined), 0b11 = 4 bytes
            unsigned long long ReservedAsZero2 : 32;
        } Bitmap;
    } x64;
};



union DbgCtl {
    struct {
        unsigned long long Lbr : 1;
        unsigned long long Btf : 1;
        unsigned long long Reserved1 : 4;
        unsigned long long Tr : 1;
        unsigned long long Bts : 1;
        unsigned long long Btint : 1;
        unsigned long long BtsOffOs : 1;
        unsigned long long BtsOffUsr : 1;
        unsigned long long FreezeLbrsOnPmi : 1;
        unsigned long long FreezePerfmonOnPmi : 1;
        unsigned long long EnableUncorePmi : 1;
        unsigned long long FreezeWhileSmm : 1;
        unsigned long long RtmDebugHigh : 48;
    } fields;
    unsigned long long Value;
};
#pragma pack(pop)
```

`PeVisor/Inc/Trace.hpp`:

```hpp
#pragma once 
#include "Zydis/Zydis.h"
#include <basetsd.h>

class Trace {
private:

public:
	Trace(_In_ DWORD_PTR Rip);
};
```

`PeVisor/Inc/UCPE.hpp`:

```hpp
#pragma once
#include "CPUID.hpp"
#include "Registers.hpp"
#include "BlackBone/ManualMap/MMap.h"
#include "BlackBone/Process/Process.h"
#include "Buffer.hpp"
#include "Encode.hpp"
#include "Nativestructs.hpp"
#include "unicorn/unicorn.h"
#include <functional>
#include <iostream>
#include <sstream>
#include <filesystem>
#include <intrin.h>
using api_emu_callback = std::function<bool(uc_engine* uc)>;

enum IntelEnc : unsigned int { IEbx = 'uneG', IEdx = 'Ieni', IEcx = 'letn' };
enum AmdEnc : unsigned int { AEbx = 'htuA', AEdx = 'itne', AEcx = 'DMAc' };

enum class CpuVendor { CpuUnknown, CpuIntel, CpuAmd };

typedef struct _KPCR
{
	SegmentDesctiptorX64 gdt[8];
} KPCR;

typedef struct _UCPE_CacheFile
{
	size_t ImageSize = 0;
	size_t HeapSize = 0;
	size_t StackSize = 0;
	DWORD RealEntryPoint = 0;

	CONTEXT ContextAtRealEntryPoint;
} UCPE_CacheFile, *PUCPE_CacheFile;

typedef struct _FakeAPI
{
	_FakeAPI(const char* n, uint64_t va) : ProcedureName(n), VirtualAddress(va) {}

	DWORD_PTR VirtualAddress = 0;

	PVOID EmuCallback = nullptr;

	std::string ProcedureName;
} FakeAPI, *PFakeAPI;

typedef struct _FakeSection
{
	_FakeSection(ULONG a, ULONG d, ULONG l, SIZE_T b, char* c, bool u, DWORD_PTR j = 0) 
		: SectionBase(a), RealflProtect(d), EmuflProtect(l), SectionSize(b), IsUnknownSection(u), SectionFullAddress(j) {}
	DWORD SectionBase = 0;
	DWORD_PTR SectionFullAddress = 0;//For sections thar was allocated via VirtualAlloc and etc. funcs
	DWORD RealflProtect = 0;
	DWORD EmuflProtect = 0;

	size_t SectionSize = 0;

	CHAR SectionName[9]{};

	bool IsUnknownSection = false;
} FakeSection, *PFakeSection;

typedef struct _FakeModule
{
	_FakeModule(DWORD_PTR b, ULONG s, DWORD_PTR e, const std::wstring& n, const std::filesystem::path& p) : 
		ImageBase(b), ImageSize(s), ImageEntry(e), DllName(n), FullPath(p) {}

	PVOID ImgPtr = nullptr;

	DWORD_PTR ImageBase = 0;
	DWORD_PTR ImageEntry = 0;
	DWORD_PTR ExceptionTable = 0;

	ULONG ImageSize = 0;
	ULONG ExceptionTableSize = 0;

	int Priority = 0;

	std::wstring DllName;
	std::filesystem::path FullPath;
	std::vector<FakeAPI> FakeAPIs;
	std::vector<FakeSection> FakeSections;
} FakeModule, *PFakeModule;

typedef struct _HandleMapping
{
	_HandleMapping(std::wstring wName) :
		ProgName(wName) {}

	std::wstring ProgName;
	std::list<HANDLE> Handles;
} HandleMapping, *PHandleMapping;

typedef struct _AllocBlock
{
	_AllocBlock(DWORD_PTR b, size_t s) : base(b), size(s) {}

	DWORD_PTR base = 0;

	size_t size = 0;

	bool free = false;
} AllocBlock, *PAllocBlock;

typedef struct _MemMappingBlock
{
	_MemMappingBlock(DWORD_PTR v, DWORD_PTR val, size_t s) : va(v), value(val), size(s) {}

	DWORD_PTR va = 0;
	DWORD_PTR value = 0;
	
	size_t size = 0;
} MemMappingBlock, *PMemMappingBlock;

typedef struct _MemMapping
{
	_MemMapping(DWORD_PTR b, DWORD_PTR v, size_t s) : baseva(b), mappedva(v), size(s) {}

	DWORD_PTR baseva = 0;
	DWORD_PTR mappedva = 0;

	size_t size = 0;

	std::vector<MemMappingBlock> blocks;
} MemMapping, *PMemMapping;

namespace ucHooks {
	void HookCpuid(uc_engine* uc, void* user_data);
	void HookSySCall(uc_engine* uc, void* user_data);
	void HookCode(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void HookIntr(uc_engine* uc, int exception, void* user_data);
	void HookRwx(uc_engine* uc, uc_mem_type type,
		DWORD_PTR address, int size, INT_PTR value, void* user_data);
	bool HookInvalidRwx(uc_engine* uc, uc_mem_type type,
		DWORD_PTR address, int size, INT_PTR value, void* user_data);
	void EmuUnknownAPI(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
}

blackbone::LoadData ManualMapCallback(blackbone::CallbackType type, void* context, blackbone::Process& /*process*/, const blackbone::ModuleData& modInfo);

class PeEmulation
{
public: //Basis emu api
	void AddAPIEmulation(_Inout_ PFakeAPI FApi, _Out_ PVOID callback);
	bool RegisterAPIEmulation(
		_In_ const std::wstring& DllName,
		_In_ const char* ProcedureName,
		_In_ PVOID callback);
public:
	void GetModuleHandleInternalEmulation(_Out_ DWORD_PTR* ImageBase, _In_ std::wstring& wModuleName);
	NTSTATUS LdrFindDllByNameInternalEmualtion(_In_ const std::wstring& DllName, _Out_ DWORD_PTR* ImageBase, _Out_ size_t* ImageSize, _In_ bool LoadIfNotExist);
	std::filesystem::path GetModuleFileInternalEmulation(_In_ PVOID hModule);
public:
	//Usermode only
	void InitProcessorState();
	void InitLdrModuleList();
	void InitTebPeb();

	//Kernelmode only
	void SortModuleList();
	void InitPsLoadedModuleList();
	void InitDriverObject();

	//Usermode + Kernelmode
	void InsertTailList(_In_ DWORD_PTR ListHeadAddress, _In_ DWORD_PTR EntryAddress);
	void InitKSharedUserData();

public:	//Finders
	bool FindAddressInRegion(
		_In_ DWORD_PTR address, 
		_Inout_ std::stringstream& RegionName,
		_In_opt_ bool FindInModules = true, 
		_In_opt_ bool FindInStack = true,
		_In_opt_ bool FindInHeap = true);
	bool FindAPIByAddress(_In_ DWORD_PTR address, _Inout_ std::wstring& DllName, _Inout_ FakeAPI** api);
	bool FindSectionByAddress(_In_ DWORD_PTR address, _Inout_ FakeSection** section);
	bool FindModuleByAddress(_In_ DWORD_PTR address, _Inout_ DWORD_PTR& DllBase);

public: //Memory block
	//Stack
	DWORD_PTR StackAlloc(_In_ size_t AllocBytes);
	void StackFree(_In_ size_t AllocBytes);

	//Heap
	DWORD_PTR HeapAlloc(_In_ size_t AllocBytes, _In_opt_ bool IsPageAlign = false);
	bool HeapFree(_In_ DWORD_PTR FreeAddress);

	//Mem mapping
	bool CreateMemMapping(_In_ DWORD_PTR BaseAddress, _In_ DWORD_PTR MapAddress, _In_ size_t Bytes);
	bool WriteMemMapping(_In_ DWORD_PTR baseaddress, _In_ DWORD_PTR value, _In_ size_t size);
	void DeleteMemMapping(_In_ DWORD_PTR MapAddress);
	void FlushMemMapping(_In_ void);

public: //Ldrs
	DWORD_PTR LdrGetProcAddress(_In_ DWORD_PTR ImageBase, _In_ const char* ProcedureName);
	void LdrResolveExportTable(_Inout_ FakeModule* module, _In_ PVOID ImageBase, _In_ DWORD_PTR MappedBase);
	NTSTATUS LdrFindDllByName(_In_ const std::wstring& DllName, _Out_ DWORD_PTR* ImageBase, _Out_ size_t* ImageSize, _In_ bool LoadIfNotExist);
	NTSTATUS LdrLoadDllByName(_In_ const std::wstring& DllName, _Out_ DWORD_PTR* ImageBase);

public: //ManualMap
	void MapImageToEngine(
		_In_ const std::filesystem::path& FullPath,
		_In_ const std::wstring& ImageName,
		_In_ PVOID ImageBase,
		_In_ ULONG ImageSize,
		_In_ DWORD_PTR MappedBase,
		_In_ DWORD_PTR EntryPoint);
public: //RTLs
	LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(
		_In_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
	void RtlInitializeSListHead(_Inout_ PSLIST_HEADER ListHead);
	void RtlpGetStackLimits(_Out_ PDWORD_PTR LowLimit, _Out_ PDWORD_PTR HighLimit);
	void RtlpCaptureContext(_In_ PCONTEXT ContextRecord);
	void RtlpRestoreContext(_In_ PCONTEXT ContextRecord, _In_ PEXCEPTION_RECORD ExceptionRecord OPTIONAL);
	BOOLEAN RtlpDispatchException(_In_ PEXCEPTION_RECORD ExceptionRecord, _In_ PCONTEXT ContextRecord);
	void RtlRaiseStatus(_In_ NTSTATUS Status);
	NTSTATUS RaiseException(
		_In_ PEXCEPTION_RECORD ExceptionRecord, 
		_In_ PCONTEXT ContextRecord, 
		_In_ BOOLEAN FirstChance);
	void RtlInsertInvertedFunctionTable(
		_Inout_ PINVERTED_FUNCTION_TABLE InvertedTable,
		_In_ DWORD_PTR MappedBase,
		_In_ PVOID ImageBase,
		_In_ ULONG SizeOfImage);
	EXCEPTION_DISPOSITION RtlpExecuteHandlerForException(
		_Inout_ struct _EXCEPTION_RECORD* ExceptionRecord, 
		_In_ PVOID EstablisherFrame,
		_Inout_ struct _CONTEXT* ContextRecord, 
		_In_ PDISPATCHER_CONTEXT DispatcherContext);
	PRUNTIME_FUNCTION RtlpLookupFunctionTable(_In_ PVOID ControlPc, _Out_ PVOID* ImageBase, _Out_ PULONG SizeOfTable);
	PRUNTIME_FUNCTION RtlpLookupFunctionEntry(
		_In_ DWORD_PTR ControlPc,
		_Out_ PDWORD_PTR ImageBase,
		_Inout_ PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL);
	PRUNTIME_FUNCTION RtlpConvertFunctionEntry(_In_ PRUNTIME_FUNCTION FunctionEntry, _In_ DWORD_PTR ImageBase);
	PEXCEPTION_ROUTINE RtlpVirtualUnwind(
		_In_ ULONG HandlerType,
		_In_ DWORD_PTR ImageBase,
		_In_ DWORD_PTR ControlPc,
		_In_ PRUNTIME_FUNCTION FunctionEntry,
		_Inout_ PCONTEXT ContextRecord,
		_Out_ PVOID* HandlerData,
		_Out_ PDWORD_PTR EstablisherFrame,
		_Inout_ PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
	);
	PRUNTIME_FUNCTION RtlpSameFunction(_In_ PRUNTIME_FUNCTION FunctionEntry, _In_ DWORD_PTR ImageBase, _In_ DWORD_PTR ControlPc);
	PUNWIND_INFO RtlpLookupPrimaryUnwindInfo(
		_In_ PRUNTIME_FUNCTION FunctionEntry,
		_In_ DWORD_PTR ImageBase,
		_Out_ PRUNTIME_FUNCTION* PrimaryEntry);
	PRUNTIME_FUNCTION RtlpUnwindPrologue(
		_In_ DWORD_PTR ImageBase,
		_In_ DWORD_PTR ControlPc,
		_In_ DWORD_PTR FrameBase,
		_In_ PRUNTIME_FUNCTION FunctionEntry,
		_Inout_ PCONTEXT ContextRecord,
		_Inout_ PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
	);
	EXCEPTION_DISPOSITION C_specific_handler(void);
	void RtlpUnwindEx(
		_In_ PVOID TargetFrame OPTIONAL,
		_In_ PVOID TargetIp OPTIONAL,
		_In_ PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
		_In_ PVOID ReturnValue,
		_In_ PCONTEXT OriginalContext,
		_In_ PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL
	);
private:
	LPTOP_LEVEL_EXCEPTION_FILTER BasepCurrentTopLevelFilter = 0;
public:
	//PPEB_LDR_DATA InternalLdr = nullptr;

	blackbone::Process thisProc;

	uc_engine* m_uc = nullptr;

	bool m_IsWin64 = false;
	//-k flag
	bool m_IsKernel = false;
	//-disasm flag
	bool m_DisplayDisasm = false;
	//-packed flag
	bool m_IsPacked = false;
	//-boundcheck flag
	bool m_BoundCheck = false;
	//-dump flag
	bool m_Dump = false;
	bool m_Cache = false;
	bool m_HasCache = false;

	std::filesystem::path m_PathExe;

	DWORD_PTR m_KSharedUserDataBase = 0;
	DWORD_PTR m_KSharedUserDataEnd = 0;
	DWORD_PTR m_StackBase = 0;
	DWORD_PTR m_StackSize = 0x10000;
	DWORD_PTR m_StackEnd = 0;
	DWORD_PTR m_ImageBase = 0;
	DWORD_PTR m_ImageEnd = 0;
	DWORD_PTR m_ImageEntry = 0;
	DWORD_PTR m_ImageRealEntry = 0;
	DWORD_PTR m_HeapBase = 0;
	DWORD_PTR m_HeapEnd = 0;
	DWORD_PTR m_LoadModuleBase = 0;

	//Usermode only
	DWORD_PTR m_PebBase = 0;
	DWORD_PTR m_PebEnd = 0;
	DWORD_PTR m_LdrBase = 0;
	DWORD_PTR m_LdrEnd = 0;
	DWORD_PTR m_TebBase = 0;
	DWORD_PTR m_TebEnd = 0;
	DWORD m_Win32LastError = 0;
	DWORD_PTR m_CommandLineABase = 0;
	DWORD_PTR m_CommandLineWBase = 0;

	//Kernelmode only
	DWORD_PTR m_DriverObjectBase = 0;
	DWORD_PTR m_RegistryPathBase = 0;
	DWORD_PTR m_KThreadBase = 0;
	DWORD_PTR m_PsLoadedModuleListBase = 0;
	DWORD_PTR m_DriverLdrEntry = 0;
	DWORD_PTR m_LastRip = 0;
	DWORD_PTR m_LastRipModule = 0;
	DWORD_PTR m_ExecCodeCount = 0;
	DWORD_PTR m_ExecuteFromRip = 0;
	DWORD_PTR m_LastFakeAPICallReturnAddress = 0;

	NTSTATUS m_LastException = 0;

	int m_MainModuleIndex = 0;
	size_t m_LastHeapAllocBytes = 0;
	int m_ExecuteExceptionHandler = 0;

	UCHAR m_RtlpUnwindOpSlotTable[11]{};

	bool m_FakeAPICallEnabled = false;

	PFakeAPI m_LastFakeAPICall;
	CONTEXT m_InitReg;
	INVERTED_FUNCTION_TABLE m_PsInvertedFunctionTable;

	std::vector<PFakeModule> m_FakeModules;
	std::vector<AllocBlock> m_HeapAllocs;
	std::vector<HandleMapping> m_HandleMap;
	std::vector<MemMapping> m_MemMappings;
	std::vector<FakeSection> m_FakeAllocations;
	std::list<std::pair<DWORD, LPVOID>> m_TlsValue;

	std::string filename;

	LPSTR EmuCommandLineA;
	LPWSTR EmuCommandLineW;
	std::string szCommandLineA;
	std::wstring szCommandLineW;
};

#define API_FUNCTION_SIZE 8
#define PAGE_SIZE 0x1000
#define PAGE_ALIGN(Va) (ULONG_PTR)(Va) & ~(PAGE_SIZE - 1)
#define PAGE_ALIGN_64(Va) (Va) & ~(0x1000ull - 1)
#define PAGE_ALIGN_64k(Va) ((Va)) & ~(0x10000ull - 1)

#define AlignSize(Size, Align) (Size+Align-1)/Align*Align

#define EXCP00_DIVZ	0
#define EXCP01_DB	1
#define EXCP02_NMI	2
#define EXCP03_INT3	3
#define EXCP04_INTO	4
#define EXCP05_BOUND	5
#define EXCP06_ILLOP	6
#define EXCP07_PREX	7
#define EXCP08_DBLE	8
#define EXCP09_XERR	9
#define EXCP0A_TSS	10
#define EXCP0B_NOSEG	11
#define EXCP0C_STACK	12
#define EXCP0D_GPF	13
#define EXCP0E_PAGE	14
#define EXCP10_COPR	16
#define EXCP11_ALGN	17
#define EXCP12_MCHK	18

#define EXCP_SYSCALL    0x100 /* only happens in user only emulation
								 for syscall instruction */
```

`PeVisor/Inc/ucHooks.hpp`:

```hpp
#ifndef UNICORN_HOOKS
#define UNICORN_HOOKS

#include "UCPE.hpp"

namespace ucHooks {
	void HookCode(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data);
	void HookIntr(uc_engine* uc, int exception, void* user_data);
}

#endif
```

`PeVisor/Inc/wsprintf.h`:

```h
#pragma once

/*
 * wsprintf functions
 *
 * Copyright 1996 Alexandre Julliard
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
 *
 * NOTE:
 * This code is duplicated in shlwapi. If you change something here make sure
 * to change it in shlwapi too.
 */

#include <stdarg.h>
#include <string.h>
#include <stdio.h>

#include <Windows.h>
#include <unicorn/unicorn.h>

#define WPRINTF_LEFTALIGN   0x0001  /* Align output on the left ('-' prefix) */
#define WPRINTF_PREFIX_HEX  0x0002  /* Prefix hex with 0x ('#' prefix) */
#define WPRINTF_ZEROPAD     0x0004  /* Pad with zeros ('0' prefix) */
#define WPRINTF_LONG        0x0008  /* Long arg ('l' prefix) */
#define WPRINTF_SHORT       0x0010  /* Short arg ('h' prefix) */
#define WPRINTF_UPPER_HEX   0x0020  /* Upper-case hex ('X' specifier) */
#define WPRINTF_WIDE        0x0040  /* Wide arg ('w' prefix) */
#define WPRINTF_INTPTR      0x0080  /* Pointer-size arg ('I' prefix) */
#define WPRINTF_I64         0x0100  /* 64-bit arg ('I64' prefix) */

#define ARRAY_SIZE(x) (sizeof(x) / sizeof((x)[0]))

typedef enum
{
    WPR_UNKNOWN,
    WPR_CHAR,
    WPR_WCHAR,
    WPR_STRING,
    WPR_WSTRING,
    WPR_SIGNED,
    WPR_UNSIGNED,
    WPR_HEXA
} WPRINTF_TYPE;

typedef struct
{
    UINT         flags;
    UINT         width;
    UINT         precision;
    WPRINTF_TYPE   type;
} WPRINTF_FORMAT;

typedef union {
    WCHAR    wchar_view;
    CHAR     char_view;
    LPCSTR   lpcstr_view;
    LPCWSTR  lpcwstr_view;
    LONGLONG int_view;
} WPRINTF_DATA;

INT CustomWvsprintfA(uc_engine* uc, LPSTR buffer, LPCSTR spec, va_list args);
INT CustomWvsprintfW(uc_engine* uc, LPWSTR buffer, LPCWSTR spec, va_list args);
INT CustomWsprintfA(uc_engine* uc, LPSTR buffer, LPCSTR spec, ...);
INT CustomWsprintfW(uc_engine* uc, LPWSTR buffer, LPCWSTR spec, ...);
```

`PeVisor/PeVisor.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Src\Buffer.cpp" />
    <ClCompile Include="Src\Crt.cpp" />
    <ClCompile Include="Src\EmuApiBasis.cpp" />
    <ClCompile Include="Src\EmuApiFuncs.cpp" />
    <ClCompile Include="Src\Encode.cpp" />
    <ClCompile Include="Src\Find.cpp" />
    <ClCompile Include="Src\InternalEmulationApi.cpp" />
    <ClCompile Include="Src\Ldr.cpp" />
    <ClCompile Include="Src\Main.cpp" />
    <ClCompile Include="Src\Map.cpp" />
    <ClCompile Include="Src\Memory.cpp" />
    <ClCompile Include="Src\Rtls.cpp" />
    <ClCompile Include="Src\Trace.cpp" />
    <ClCompile Include="Src\ucHooks.cpp" />
    <ClCompile Include="Src\wsprintf.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Inc\Buffer.hpp" />
    <ClInclude Include="Inc\CPUID.hpp" />
    <ClInclude Include="Inc\Crt.hpp" />
    <ClInclude Include="Inc\EmuApiFuncs.hpp" />
    <ClInclude Include="Inc\Encode.hpp" />
    <ClInclude Include="Inc\IEApiErrorCodes.hpp" />
    <ClInclude Include="Inc\Nativestructs.hpp" />
    <ClInclude Include="Inc\Registers.hpp" />
    <ClInclude Include="Inc\Trace.hpp" />
    <ClInclude Include="Inc\UCPE.hpp" />
    <ClInclude Include="Inc\wsprintf.h" />
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{43744415-C650-49C0-9E9A-870A46E7099F}</ProjectGuid>
    <RootNamespace>PeVisor</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>Default</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalIncludeDirectories>$(SolutionDir)PeVisor\Inc;$(SolutionDir)Dependency\Blackbone\src;$(SolutionDir)Dependency\zydis\dependencies\zycore\include;$(SolutionDir)Dependency\zydis\include;$(SolutionDir)Dependency\unicorn\include</AdditionalIncludeDirectories>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>D:\Programs\Soft\Coding\C\VisualStudio\Coders\unicorn\bld\Release;$(SolutionDir)$(Platform)\$(Configuration)\;$(SolutionDir)Dependency\zydis\msvc\bin\DebugX64</AdditionalLibraryDirectories>
      <AdditionalDependencies>unicorn-common.lib;unicorn-import.lib;x86_64-softmmu.lib;Zydis.lib;BlackBone.lib;ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <RandomizedBaseAddress>true</RandomizedBaseAddress>
      <BaseAddress>
      </BaseAddress>
    </Link>
    <Lib>
      <AdditionalLibraryDirectories>D:\Programs\Soft\Coding\C\VisualStudio\Coders\unicorn\bld\Debug</AdditionalLibraryDirectories>
    </Lib>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalIncludeDirectories>$(SolutionDir)PeVisor\Inc;$(SolutionDir)Dependency\Blackbone\src;$(SolutionDir)Dependency\zydis\dependencies\zycore\include;$(SolutionDir)Dependency\zydis\include;$(SolutionDir)Dependency\unicorn\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)$(Platform)\$(Configuration)\;$(SolutionDir)Dependency\zydis\msvc\bin\ReleaseX64;D:\Programs\Soft\Coding\C\VisualStudio\Coders\unicorn\bld\Release</AdditionalLibraryDirectories>
      <AdditionalDependencies>unicorn-common.lib;unicorn-import.lib;x86_64-softmmu.lib;Zydis.lib;BlackBone.lib;ntdll.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PeVisor/PeVisor.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Src">
      <UniqueIdentifier>{396229ad-3889-4c66-99a6-4dd662a39667}</UniqueIdentifier>
    </Filter>
    <Filter Include="Inc">
      <UniqueIdentifier>{1759c9d8-083f-48d3-b8b7-1d4f3bef12ab}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Src\Main.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\Encode.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\Buffer.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\Memory.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\Find.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\Ldr.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\Rtls.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\ucHooks.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\EmuApiFuncs.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\EmuApiBasis.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\Map.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\InternalEmulationApi.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\Trace.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\wsprintf.cpp">
      <Filter>Src</Filter>
    </ClCompile>
    <ClCompile Include="Src\Crt.cpp">
      <Filter>Src</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Inc\UCPE.hpp">
      <Filter>Inc</Filter>
    </ClInclude>
    <ClInclude Include="Inc\Encode.hpp">
      <Filter>Inc</Filter>
    </ClInclude>
    <ClInclude Include="Inc\Buffer.hpp">
      <Filter>Inc</Filter>
    </ClInclude>
    <ClInclude Include="Inc\Nativestructs.hpp">
      <Filter>Inc</Filter>
    </ClInclude>
    <ClInclude Include="Inc\EmuApiFuncs.hpp">
      <Filter>Inc</Filter>
    </ClInclude>
    <ClInclude Include="Inc\IEApiErrorCodes.hpp">
      <Filter>Inc</Filter>
    </ClInclude>
    <ClInclude Include="Inc\Trace.hpp">
      <Filter>Inc</Filter>
    </ClInclude>
    <ClInclude Include="Inc\CPUID.hpp">
      <Filter>Inc</Filter>
    </ClInclude>
    <ClInclude Include="Inc\Registers.hpp">
      <Filter>Inc</Filter>
    </ClInclude>
    <ClInclude Include="Inc\wsprintf.h">
      <Filter>Inc</Filter>
    </ClInclude>
    <ClInclude Include="Inc\Crt.hpp">
      <Filter>Inc</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`PeVisor/Src/Buffer.cpp`:

```cpp
#include "Buffer.hpp"

virtual_buffer_t::virtual_buffer_t() : m_cbSize(0), m_pBuffer(NULL)
{
}
virtual_buffer_t::virtual_buffer_t(size_t size) : m_cbSize(size), m_pBuffer(VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE))
{
}

virtual_buffer_t::~virtual_buffer_t()
{
	if (m_pBuffer)
		VirtualFree(m_pBuffer, 0, MEM_RELEASE);
}

void* virtual_buffer_t::GetSpace(size_t needSize)
{
	if (m_cbSize < needSize)
	{
		if (m_pBuffer)
			VirtualFree(m_pBuffer, 0, MEM_RELEASE);
		m_pBuffer = VirtualAlloc(NULL, needSize, MEM_COMMIT, PAGE_READWRITE);
		m_cbSize = needSize;
	}
	return m_pBuffer;
}

crt_buffer_t::crt_buffer_t() : m_cbSize(0), m_pBuffer(NULL)
{
}

crt_buffer_t::crt_buffer_t(size_t size) : m_cbSize(size), m_pBuffer(malloc(size))
{
}

crt_buffer_t::~crt_buffer_t()
{
	if (m_pBuffer)
		free(m_pBuffer);
}

void* crt_buffer_t::GetSpace(size_t needSize)
{
	if (m_cbSize < needSize)
	{
		if (m_pBuffer)
			m_pBuffer = realloc(m_pBuffer, needSize);
		else
			m_pBuffer = malloc(needSize);
		m_cbSize = needSize;
	}
	return m_pBuffer;
}
```

`PeVisor/Src/Crt.cpp`:

```cpp
#include "Crt.hpp"

void crt_va_arg_func(uc_engine* uc, uint64_t* ap, void* result, size_t type_size) {
	if (type_size > sizeof(__int64) || (type_size & (type_size - 1)) != 0) {
		// Если размер больше 8 байт или не кратен 8, считаем данные как двойной указатель
		char* buffer = (char*)malloc(type_size); // Выделяем память под буфер
		uc_err err = uc_mem_read(uc, ((*ap += sizeof(__int64)) - sizeof(__int64)), buffer, type_size);
		if (err != UC_ERR_OK) {
			// Обработка ошибки чтения
			free(buffer);
			return;
		}
		memcpy(result, buffer, type_size); // Копируем данные из буфера в результат
		free(buffer);


	}
	else {
		// Для типов размером до 8 байт считываем напрямую
		uc_err err = uc_mem_read(uc, ((*ap += sizeof(__int64)) - sizeof(__int64)), result, type_size);
		if (err != UC_ERR_OK) {
			// Обработка ошибки чтения
			return;
		}
	}
}
```

`PeVisor/Src/EmuApiBasis.cpp`:

```cpp
#include "UCPE.hpp"

extern std::ostream* outs;

void PeEmulation::AddAPIEmulation(_Inout_ PFakeAPI FApi, _Out_ PVOID callback)
{
	FApi->EmuCallback = callback;

	if (callback)
	{
		uc_err err;

		const unsigned char Code[] = "\xC3";
		err = uc_mem_write(m_uc, FApi->VirtualAddress, Code, sizeof(Code));
	}
}

bool PeEmulation::RegisterAPIEmulation(
	_In_ const std::wstring& DllName, 
	_In_ const char* ProcedureName,
	_In_ PVOID callback)
{
	std::vector<std::thread> threads;
	std::mutex mtx;
	std::condition_variable cv;
	bool found = false;

	for (size_t i = 0; i < m_FakeModules.size(); ++i)
	{
		threads.emplace_back([&, i]() {
			auto& m = m_FakeModules[i];
			if (!_wcsicmp(m->DllName.c_str(), DllName.c_str()))
			{
				for (size_t j = 0; j < m->FakeAPIs.size(); ++j)
				{
					if (m->FakeAPIs[j].ProcedureName == ProcedureName)
					{
						std::unique_lock<std::mutex> lock(mtx);
						AddAPIEmulation(&m->FakeAPIs[j], callback);
						found = true;
						lock.unlock();
						cv.notify_all();// Notify all pending threads
						return;
					}
				}
			}
			});
	}

	// Waiting for one of the threads to finish
	{
		std::unique_lock<std::mutex> lock(mtx);
		cv.wait(lock, [&] { return found; });
	}

	// Completion of all threads
	for (auto& t : threads)
	{
		if (t.joinable())
			t.join();
	}

	if (!found)
	{
		*outs << "failed to register API emulation for " << ProcedureName << "\n";
	}

	return found;
}
```

`PeVisor/Src/EmuApiFuncs.cpp`:

```cpp
#include "EmuApiFuncs.hpp"
#include <cstdarg>

extern std::ostream* outs;

static DWORD GetProcessIdByThreadHandle(HANDLE hThread)
{
	THREAD_BASIC_INFORMATION tbi;

	if (NT_SUCCESS(NtQueryInformationThread(hThread, (THREADINFOCLASS)__THREADINFOCLASS::ThreadBasicInformation,
		&tbi, sizeof(THREAD_BASIC_INFORMATION), 0)))
	{
		return (DWORD)tbi.ClientId.UniqueProcess;
	}

	return 0;
}

static std::string GetAccessMaskString(ACCESS_MASK mask) {
	std::string result;
	if (mask & FILE_READ_DATA) result += " FILE_READ_DATA ";
	if (mask & FILE_READ_ATTRIBUTES) result += " FILE_READ_ATTRIBUTES ";
	if (mask & FILE_WRITE_DATA) result += " FILE_WRITE_DATA ";
	if (mask & FILE_WRITE_ATTRIBUTES) result += " FILE_WRITE_ATTRIBUTES ";
	if (mask & FILE_APPEND_DATA) result += " FILE_APPEND_DATA ";
	if (mask & FILE_EXECUTE) result += " FILE_EXECUTE ";
	return result;
}

static std::string GetShareAccessString(ULONG shareAccess) {
	std::string result;
	if (shareAccess & FILE_SHARE_READ) result += " FILE_SHARE_READ ";
	if (shareAccess & FILE_SHARE_WRITE) result += " FILE_SHARE_WRITE ";
	if (shareAccess & FILE_SHARE_DELETE) result += " FILE_SHARE_DELETE ";

	return result;
}

static std::string GetFlagsRtlAllocateHeap(ULONG Flags) {
	std::string result;
	if (Flags & HEAP_GENERATE_EXCEPTIONS) result += " HEAP_GENERATE_EXCEPTIONS ";
	if (Flags & HEAP_NO_SERIALIZE) result += " HEAP_NO_SERIALIZE ";
	if (Flags & HEAP_ZERO_MEMORY) result += " HEAP_ZERO_MEMORY ";

	return result;
}

static std::string GetOpenOptionsString(ULONG openOptions) {
	std::string result;
	if (openOptions & FILE_DIRECTORY_FILE) result += " FILE_DIRECTORY_FILE ";
	if (openOptions & FILE_NON_DIRECTORY_FILE) result += " FILE_NON_DIRECTORY_FILE ";
	if (openOptions & FILE_WRITE_THROUGH) result += " FILE_WRITE_THROUGH ";
	if (openOptions & FILE_SEQUENTIAL_ONLY) result += " FILE_SEQUENTIAL_ONLY ";
	if (openOptions & FILE_RANDOM_ACCESS) result += " FILE_RANDOM_ACCESS ";
	if (openOptions & FILE_NO_INTERMEDIATE_BUFFERING) result += " FILE_NO_INTERMEDIATE_BUFFERING ";
	if (openOptions & FILE_SYNCHRONOUS_IO_ALERT) result += " FILE_SYNCHRONOUS_IO_ALERT ";
	if (openOptions & FILE_SYNCHRONOUS_IO_NONALERT) result += " FILE_SYNCHRONOUS_IO_NONALERT ";
	if (openOptions & FILE_CREATE_TREE_CONNECTION) result += " FILE_CREATE_TREE_CONNECTION ";
	if (openOptions & FILE_COMPLETE_IF_OPLOCKED) result += " FILE_COMPLETE_IF_OPLOCKED ";
	if (openOptions & FILE_NO_EA_KNOWLEDGE) result += " FILE_NO_EA_KNOWLEDGE ";
	if (openOptions & FILE_OPEN_REPARSE_POINT) result += " FILE_OPEN_REPARSE_POINT ";
	if (openOptions & FILE_DELETE_ON_CLOSE) result += " FILE_DELETE_ON_CLOSE ";
	if (openOptions & FILE_OPEN_BY_FILE_ID) result += " FILE_OPEN_BY_FILE_ID ";
	if (openOptions & FILE_OPEN_FOR_BACKUP_INTENT) result += " FILE_OPEN_FOR_BACKUP_INTENT ";
	if (openOptions & FILE_RESERVE_OPFILTER) result += " FILE_RESERVE_OPFILTER ";
	if (openOptions & FILE_OPEN_REQUIRING_OPLOCK) result += " FILE_OPEN_REQUIRING_OPLOCK ";

	return result;
}

extern "C"
{
	NTSYSAPI NTSTATUS RtlGetVersion(
		PRTL_OSVERSIONINFOW lpVersionInformation
	);
}

namespace InternalEmuApi {
	bool EmuWriteNullTermString(_In_ uc_engine* uc, _Inout_ DWORD_PTR address, _In_ const std::string& str)
	{
		char c;
		uc_err err;
		size_t len = 0;
		while (len < str.size())
		{
			c = str[len];
			err = uc_mem_write(uc, address + len, &c, sizeof(char));
			if (err != UC_ERR_OK)
				return false;

			len += sizeof(char);

			if (len > 1024 * sizeof(char)) { break; }
		}

		// Write null terminator
		err = uc_mem_write(uc, address + len, &c, sizeof(char));
		if (err != UC_ERR_OK) { return false; }

		return true;
	}

	bool EmuWriteNullTermUnicodeString(_In_ uc_engine* uc, _Inout_ DWORD_PTR address, _In_ const std::wstring& str)
	{
		wchar_t c;
		uc_err err;
		size_t len = 0;
		while (len < str.size())
		{
			c = str[len];
			err = uc_mem_write(uc, address + len, &c, sizeof(wchar_t));
			if (err != UC_ERR_OK) { return false; }

			len += sizeof(wchar_t);

			if (len > 1024 * sizeof(wchar_t)) { break; }
		}

		// Write null terminator
		err = uc_mem_write(uc, address + len, &c, sizeof(wchar_t));
		if (err != UC_ERR_OK) { return false; }

		return true;
	}

	bool EmuReadNullTermString(_In_ uc_engine* uc, _In_ DWORD_PTR address, _Inout_ std::string& str, _In_opt_ bool OnLengthLimit,
		_In_opt_ size_t Length)
	{
		char c;
		uc_err err;
		size_t len = 0;
		while (1)
		{
			err = uc_mem_read(uc, address + len, &c, sizeof(char));
			if (err != UC_ERR_OK) { return false; }
			if (c != '\0') { str.push_back(c); }
			else { break; }

			if (OnLengthLimit)
			{
				if (Length >= len)
				{
					str.push_back('\0');
					break;
				}
			}

			len += sizeof(char);

			if (len > 1024 * sizeof(char)) { break; }
		}

		return true;
	}

	bool EmuReadNullTermUnicodeString(_In_ uc_engine* uc, _In_ DWORD_PTR address, _Inout_ std::wstring& str, _In_opt_ bool OnLengthLimit, 
		_In_opt_ size_t Length)
	{
		wchar_t c;
		uc_err err;
		size_t len = 0;
		while (1)
		{
			err = uc_mem_read(uc, address + len, &c, sizeof(wchar_t));
			if (err != UC_ERR_OK) { return false; }
			if (c != L'\0') { str.push_back(c); }
			else { break; }

			if (OnLengthLimit)
			{
				if (Length >= len)
				{
					str.push_back(L'\0');
					break;
				}
			}

			len += sizeof(wchar_t);

			if (len > 1024 * sizeof(wchar_t)) { break; }
		}

		return true;
	}

	void EmuCopyASCIStrs(_In_ uc_engine* uc, _In_ LPSTR Dst, _In_ std::string Src)
	{
		uc_mem_write(uc, (DWORD_PTR)Dst, Src.data(), Src.size());
		//for (size_t Index = 0; Index < Src.size(); ++Index)
		//{
		//	uc_mem_write(uc, (DWORD_PTR)Dst, Src.data() + Index, sizeof(char));
		//}
	}

	void EmuCopyUnicodeStrs(_In_ uc_engine* uc, _In_ LPWSTR EmuAddr, _In_ std::wstring Src)
	{
		uc_mem_write(uc, (DWORD_PTR)EmuAddr, Src.data(), Src.size() * sizeof(wchar_t));
		//for (size_t Index = 0; Index < Src.size() * sizeof(wchar_t); Index += sizeof(wchar_t))
		//{
		//	uc_mem_write(uc, (DWORD_PTR)Dst, Src.data() + Index, sizeof(wchar_t));
		//}
	}

	void EmuCopyBufferFromUc(_In_ uc_engine* uc, _In_ LPVOID MyAddr, _In_ LPVOID EmuAddr, _In_ size_t NumberOfBytes)
	{
		uc_mem_read(uc, (DWORD_PTR)EmuAddr, MyAddr, NumberOfBytes);
	}

	void EmuCopyBufferToUc(_In_ uc_engine* uc, _In_ LPVOID EmuAddr, _In_ LPVOID MyAddr, _In_ size_t NumberOfBytes)
	{
		uc_mem_write(uc, (DWORD_PTR)EmuAddr, MyAddr, NumberOfBytes);
	}

	DWORD_PTR EmuReadReturnAddress(_In_ uc_engine* uc)
	{
		DWORD_PTR rsp;
		uc_reg_read(uc, UC_X86_REG_RSP, &rsp);
		uc_mem_read(uc, rsp, &rsp, 8);

		return rsp;
	}
}

namespace EmuApi
{
	template<typename... Args, std::size_t... I>
	void ReadArgsFromRegistersHelper(uc_engine* uc, std::tuple<Args...> args, std::initializer_list<int> regs, std::index_sequence<I...>) {
		(uc_reg_read(uc, regs.begin()[I], std::get<I>(args)), ...);
	}

	template<typename... Args>
	void ReadArgsFromRegisters(uc_engine* uc, std::tuple<Args...> args, std::initializer_list<int> regs) {
		ReadArgsFromRegistersHelper(uc, args, regs, std::make_index_sequence<sizeof...(Args)>());
	}

	void EmuGetSystemTimeAsFileTime(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		DWORD_PTR rcx;
		uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		FILETIME ft;
		GetSystemTimeAsFileTime(&ft);

		uc_mem_write(uc, rcx, &ft, sizeof(FILETIME));

		*outs << "GetSystemTimeAsFileTime" << "\n";

		uc_reg_write(uc, UC_X86_REG_EAX, &ft.dwLowDateTime);
	}

	void EmuMessageBoxA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HWND hWnd = nullptr;
		LPCSTR lpText = nullptr;
		LPCSTR lpCaption = nullptr;
		UINT uType = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hWnd, &lpText, &lpCaption, &uType),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8, UC_X86_REG_R9W });

		std::string szlpText;
		std::string szlpCaption;
		EmuReadNullTermString(uc, (DWORD_PTR)lpText, szlpText);
		EmuReadNullTermString(uc, (DWORD_PTR)lpCaption, szlpCaption);

		int Res = MessageBoxA(hWnd, szlpText.data(), szlpCaption.data(), uType);

		*outs << "MessageBoxA " << "hWnd: " << hWnd << " Text: " << szlpText << " Caption: "
			<< szlpCaption << " uType: " << uType << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Res);
	}

	void EmuMessageBoxW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HWND hWnd = nullptr;
		LPCWSTR lpText = nullptr;
		LPCWSTR lpCaption = nullptr;
		UINT uType = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hWnd, &lpText, &lpCaption, &uType),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8, UC_X86_REG_R9W });

		std::wstring wlpText;
		std::wstring wlpCaption;
		EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpText, wlpText);
		EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpCaption, wlpCaption);

		int Res = MessageBoxW(hWnd, wlpText.data(), wlpCaption.data(), uType);

		std::string alpText;
		std::string alpCaption;
		UnicodeToANSI(wlpText, alpText);
		UnicodeToANSI(wlpCaption, alpCaption);

		*outs << "MessageBoxW " << "hWnd: " << hWnd << " Text: " << alpText << " Caption: "
			<< alpCaption << " uType: " << uType << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Res);
	}

	void EmuGetProcessWindowStation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HWINSTA gpws = GetProcessWindowStation();

		*outs << "GetProcessWindowStation " << "return(HWINSTA): " << std::hex << gpws << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &gpws);
	}

	void EmuGetUserObjectInformationW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HANDLE hObj = nullptr;
		int nIndex = 0;
		PVOID pvInfo = nullptr;
		DWORD nLength = 0;
		LPDWORD lpnLengthNeeded = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hObj, &nIndex, &pvInfo, &nLength),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8, UC_X86_REG_R9D });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &lpnLengthNeeded, sizeof(LPDWORD));

		BOOL Result = GetUserObjectInformationW(hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
		uc_reg_write(uc, UC_X86_REG_RAX, &Result);

		std::string sznIndex;
		switch (nIndex)
		{
		case UOI_FLAGS: { sznIndex = "UOI_FLAGS"; break; }
		case UOI_NAME: { sznIndex = "UOI_NAME"; break; }
		case UOI_TYPE: { sznIndex = "UOI_TYPE"; break; }
		case UOI_HEAPSIZE: { sznIndex = "UOI_HEAPSIZE"; break; }
		case UOI_IO: { sznIndex = "UOI_IO"; break; }
		case UOI_TIMERPROC_EXCEPTION_SUPPRESSION:
		{
			sznIndex = "UOI_TIMERPROC_EXCEPTION_SUPPRESSION";
			break;
		}
		}

		*outs << "GetUserObjectInformationA " << "hObj: " << hObj << " nIndex: " << sznIndex << " pvInfo: " <<
			pvInfo << " nLength: " << nLength << " lpnLengthNeeded: " << lpnLengthNeeded << "\n";
	}

	void EmuGetUserObjectInformationA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HANDLE hObj = nullptr;
		int nIndex = 0;
		PVOID pvInfo = nullptr;
		DWORD nLength = 0;
		LPDWORD lpnLengthNeeded = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hObj, &nIndex, &pvInfo, &nLength),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8, UC_X86_REG_R9D });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &lpnLengthNeeded, sizeof(LPDWORD));

		BOOL Result = GetUserObjectInformationA(hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
		uc_reg_write(uc, UC_X86_REG_RAX, &Result);

		std::string sznIndex;
		switch (nIndex)
		{
		case UOI_FLAGS: { sznIndex = "UOI_FLAGS"; break; }
		case UOI_NAME: { sznIndex = "UOI_NAME"; break; }
		case UOI_TYPE: { sznIndex = "UOI_TYPE"; break; }
		case UOI_HEAPSIZE: { sznIndex = "UOI_HEAPSIZE"; break; }
		case UOI_IO: { sznIndex = "UOI_IO"; break; }
		case UOI_TIMERPROC_EXCEPTION_SUPPRESSION:
		{
			sznIndex = "UOI_TIMERPROC_EXCEPTION_SUPPRESSION";
			break;
		}
		}

		*outs << "GetUserObjectInformationA " << "hObj: " << hObj << " nIndex: " << sznIndex << " pvInfo: " <<
			pvInfo << " nLength: " << nLength << " lpnLengthNeeded: " << lpnLengthNeeded << "\n";
	}

	void EmuGetCurrentThreadId(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		DWORD ThreadId = 1024;

		*outs << "GetCurrentThreadId " << ThreadId << "\n";

		uc_reg_write(uc, UC_X86_REG_EAX, &ThreadId);
	}

	void EmuGetCurrentProcessId(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		DWORD ProcessId = 1000;

		*outs << "GetCurrentProcessId " << ProcessId << "\n";

		uc_reg_write(uc, UC_X86_REG_EAX, &ProcessId);
	}

	void EmuQueryPerformanceCounter(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		DWORD_PTR rcx;
		uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		LARGE_INTEGER li;
		BOOL r = QueryPerformanceCounter(&li);

		uc_mem_write(uc, rcx, &li, sizeof(LARGE_INTEGER));

		*outs << "QueryPerformanceCounter " << r << "\n";

		uc_reg_write(uc, UC_X86_REG_EAX, &r);
	}

	void EmuLoadLibraryExW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		LPCWSTR lpLibFileName = nullptr;
		HANDLE hFile = nullptr;
		DWORD dwFlags = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&lpLibFileName, &hFile, &dwFlags),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8D });

		std::wstring DllName;
		DWORD_PTR r = 0;
		if (EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpLibFileName, DllName))
		{
			std::string aDllName;
			UnicodeToANSI(DllName, aDllName);

			ULONG64 ImageBase = 0;
			NTSTATUS st = ctx->LdrFindDllByNameInternalEmualtion(DllName, &ImageBase, nullptr, true);
			if (NT_SUCCESS(st))
			{
				r = ImageBase;
			}

			*outs << "LoadLibraryExW " << aDllName << ", return " << std::hex << r << "\n";
		}

		uc_reg_write(uc, UC_X86_REG_RAX, &r);
	}

	void EmuLoadLibraryA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		LPCSTR lpLibFileName = nullptr;
		HANDLE hFile = nullptr;
		DWORD dwFlags = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&lpLibFileName, &hFile, &dwFlags),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8D });

		std::string DllName;
		DWORD_PTR r = 0;
		if (EmuReadNullTermString(uc, (DWORD_PTR)lpLibFileName, DllName))
		{
			std::wstring wDllName;
			ANSIToUnicode(DllName, wDllName);

			ULONG64 ImageBase = 0;
			NTSTATUS st = ctx->LdrFindDllByNameInternalEmualtion(wDllName, &ImageBase, nullptr, true);
			if (NT_SUCCESS(st))
			{
				r = ImageBase;
			}

			*outs << "LoadLibraryA " << DllName << ", return " << std::hex << r << "\n";
		}

		uc_reg_write(uc, UC_X86_REG_RAX, &r);
	}

	void EmuGetProcAddress(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		HMODULE hModule = nullptr;
		LPCSTR lpProcName = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hModule, &lpProcName),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX });

		std::string ProcedureName;
		DWORD_PTR r = 0;
		if (EmuReadNullTermString(uc, (DWORD_PTR)lpProcName, ProcedureName))
		{
			r = ctx->LdrGetProcAddress((DWORD_PTR)hModule, ProcedureName.c_str());

			*outs << "GetProcAddress " << ProcedureName << ", return " << std::hex << r << "\n";
		}

		uc_reg_write(uc, UC_X86_REG_RAX, &r);
	}

	void EmuGetProcessHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		uc_reg_write(uc, UC_X86_REG_RAX, &ctx->m_HeapBase);

		*outs << "GetProcessHeap" << ", return: " << ctx->m_HeapBase << "\n";
	}

	void EmuCloseHandle(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HANDLE hObject = nullptr;
		uc_reg_read(uc, UC_X86_REG_RCX, &hObject);

		BOOL Return = false;

		if (hObject != (HANDLE)0xDEADC0DE)
		{
			Return = CloseHandle(hObject);
		}
		*outs << "CloseHandle " << hObject << ", return " << Return << "\n";
		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuRtlUnwindEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		PVOID TargetFrame = nullptr;
		PVOID TargetIp = nullptr;

		uc_reg_read(uc, UC_X86_REG_RDX, &TargetIp);

		PEXCEPTION_RECORD ExceptionRecord = nullptr;
		PVOID ReturnValue = nullptr;
		PCONTEXT ContextRecord = nullptr;
		PUNWIND_HISTORY_TABLE HistoryTable = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&TargetFrame, &TargetIp, &ExceptionRecord, &ReturnValue),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8, UC_X86_REG_R9 });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &ContextRecord, sizeof(PCONTEXT));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x30, &HistoryTable, sizeof(PUNWIND_HISTORY_TABLE));

		if (TargetIp == nullptr)
		{
			EXCEPTION_RECORD ExceptionRecord1{};
			CONTEXT ContextRecord1{};
			UNWIND_HISTORY_TABLE HistoryTable1{};

			uc_mem_read(uc, (DWORD_PTR)ExceptionRecord, &ExceptionRecord1, sizeof(EXCEPTION_RECORD));
			uc_mem_read(uc, (DWORD_PTR)ContextRecord, &ContextRecord1, sizeof(CONTEXT));
			uc_mem_read(uc, (DWORD_PTR)HistoryTable, &HistoryTable1, sizeof(UNWIND_HISTORY_TABLE));

			ctx->RtlpUnwindEx(TargetFrame, TargetIp, &ExceptionRecord1, ReturnValue, &ContextRecord1, &HistoryTable1);
		}
		else
		{
			uc_mem_write(uc, (DWORD_PTR)SP, &TargetIp, sizeof(PVOID));
		}

		*outs << "RtlUnwindEx " << "Target frame: " << TargetFrame << " Target Rip: " << TargetIp
			<< " ExceptionRecord: " << ExceptionRecord << " ReturnValue: " << ReturnValue
			<< " ContextRecord: " << ContextRecord << " HistoryTable: " << HistoryTable << "\n";
	}

	void EmuGetModuleHandleA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		LPSTR ModuleName;
		uc_reg_read(uc, UC_X86_REG_RCX, &ModuleName);

		std::string szModuleName;
		DWORD_PTR ImageBase = 0;
		if (EmuReadNullTermString(uc, (DWORD_PTR)ModuleName, szModuleName))
		{
			std::wstring wModuleName;
			ANSIToUnicode(szModuleName, wModuleName);
			ctx->GetModuleHandleInternalEmulation(&ImageBase, wModuleName);

			*outs << "GetModuleHandleA " << szModuleName << ", return " << ImageBase << "\n";
			if (ImageBase == (DWORD_PTR)IApiEmuErrorCode::GetModuleHandleAInvalidValue)
			{
				ImageBase = 0;
				uc_reg_write(uc, UC_X86_REG_RAX, &ImageBase);
				//*outs << "Error!!!!!!!!!!!!!!!!!" << "\n";
				//uc_emu_stop(uc);
			}
		}

		uc_reg_write(uc, UC_X86_REG_RAX, &ImageBase);
	}

	void EmuGetModuleHandleW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		LPWSTR ModuleName = nullptr;
		uc_reg_read(uc, UC_X86_REG_RCX, &ModuleName);

		std::wstring wModuleName;
		DWORD_PTR ImageBase = 0;
		if (EmuReadNullTermUnicodeString(uc, (DWORD_PTR)ModuleName, wModuleName))
		{
			std::string ModuleName;
			UnicodeToANSI(wModuleName, ModuleName);
			ctx->GetModuleHandleInternalEmulation(&ImageBase, wModuleName);

			*outs << "GetModuleHandleW " << ModuleName << ", return " << ImageBase << "\n";
			if (ImageBase == (DWORD_PTR)IApiEmuErrorCode::GetModuleHandleAInvalidValue)
			{
				ImageBase = 0;
				uc_reg_write(uc, UC_X86_REG_RAX, &ImageBase);
			}
		}

		uc_reg_write(uc, UC_X86_REG_RAX, &ImageBase);
	}

	void EmuVirtualProtect(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		LPVOID lpAddress = nullptr;
		SIZE_T dwSize = 0;
		DWORD flNewProtect = 0;
		PDWORD lpflOldProtect = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&lpAddress, &dwSize, &flNewProtect, &lpflOldProtect),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8D, UC_X86_REG_R9 });

		BOOL Return = true;

		for (auto& FakeModule : ctx->m_FakeModules)
		{
			if ((DWORD_PTR)lpAddress >= FakeModule->ImageBase && (DWORD_PTR)lpAddress < FakeModule->ImageBase + FakeModule->ImageSize)
			{
				for (auto& FakeSection : FakeModule->FakeSections)
				{
					uc_mem_write(uc, (DWORD_PTR)lpflOldProtect, &FakeSection.RealflProtect, sizeof(FakeSection.RealflProtect));
					
					DWORD EmuflProtect = 0;

					std::string szflNewProtect;
					switch (flNewProtect)
					{
					case PAGE_NOACCESS:
					{
						szflNewProtect = "PAGE_NOACCESS || UC_PROT_NONE";
						FakeSection.RealflProtect = PAGE_NOACCESS;
						EmuflProtect = UC_PROT_NONE;
						break;
					}
					case PAGE_READONLY:
					{
						szflNewProtect = "PAGE_READONLY || UC_PROT_READ";
						FakeSection.RealflProtect = PAGE_READONLY;
						EmuflProtect = UC_PROT_READ;
						break;
					}
					case PAGE_READWRITE:
					{
						szflNewProtect = "PAGE_READWRITE || UC_PROT_READ | UC_PROT_WRITE";
						FakeSection.RealflProtect = PAGE_READWRITE;
						EmuflProtect = UC_PROT_READ | UC_PROT_WRITE;
						break;
					}
					case PAGE_WRITECOPY:
					{
						szflNewProtect = "PAGE_WRITECOPY || UC_PROT_WRITE";
						FakeSection.RealflProtect = PAGE_WRITECOPY;
						EmuflProtect = UC_PROT_WRITE;
						break;
					}
					case PAGE_EXECUTE:
					{
						szflNewProtect = "PAGE_EXECUTE || UC_PROT_EXEC";
						FakeSection.RealflProtect = PAGE_EXECUTE;
						EmuflProtect = UC_PROT_EXEC;
						break;
					}
					case PAGE_EXECUTE_READ:
					{
						szflNewProtect = "PAGE_EXECUTE_READ || UC_PROT_EXEC | UC_PROT_READ";
						FakeSection.RealflProtect = PAGE_EXECUTE_READ;
						EmuflProtect = UC_PROT_EXEC | UC_PROT_READ;
						break;
					}
					case PAGE_EXECUTE_READWRITE:
					{
						szflNewProtect = "PAGE_EXECUTE_READWRITE || UC_PROT_ALL";
						FakeSection.RealflProtect = PAGE_EXECUTE_READWRITE;
						EmuflProtect = UC_PROT_ALL;
						break;
					}
					case PAGE_EXECUTE_WRITECOPY:
					{
						szflNewProtect = "PAGE_EXECUTE_WRITECOPY || UC_PROT_EXEC | UC_PROT_WRITE";
						FakeSection.RealflProtect = PAGE_EXECUTE_WRITECOPY;
						EmuflProtect = UC_PROT_EXEC | UC_PROT_WRITE;
						break;
					}
					default:
					{
						szflNewProtect = "PAGE_EXECUTE_READWRITE || UC_PROT_ALL";
						FakeSection.RealflProtect = PAGE_EXECUTE_READWRITE;
						EmuflProtect = UC_PROT_ALL;
						break;
					}
					}

					uc_err Err = uc_mem_protect(uc, ALIGN_TO_4KB((DWORD_PTR)lpAddress), ALIGN_TO_4KB((DWORD_PTR)dwSize), EmuflProtect);
						
					if (Err == UC_ERR_OK) { Return = true; }
					else { Return = false; }

					std::string ModuleName;
					UnicodeToANSI(FakeModule->DllName, ModuleName);

					*outs << "VirtualProtect lpAddress: " << lpAddress << " Module name: " << ModuleName << " dwSize: " << dwSize
						<< " flNewProtect: " << szflNewProtect << " lpflOldProtect: " << lpflOldProtect << ", return: " << Return << "\n";

					break;
				}
			}
		}

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
		//TODO: change protection of pages that was generated via VirtualAlloc
	}

	void EmuExitProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		UINT uExitCode = 0;
		uc_reg_read(uc, UC_X86_REG_ECX, &uExitCode);

		*outs << "ExitProcess uExitCode: " << uExitCode << "\n";

		uc_emu_stop(uc);
		_CrtDbgBreak();
	}

	void EmuWvsprintfW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		LPWSTR unnamedParam1 = nullptr;
		LPCWSTR unnamedParam2 = nullptr;
		va_list arglist = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&unnamedParam1, &unnamedParam2, &arglist),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8 });

		wchar_t buf[1024];
		std::wstring szunnamedParam2;
		if (EmuReadNullTermUnicodeString(uc, (DWORD_PTR)unnamedParam2, szunnamedParam2))
		{
			int Return = CustomWvsprintfW(uc, buf, szunnamedParam2.data(), arglist);

			std::string szbuf;
			UnicodeToANSI(buf, szbuf);
			*outs << "wvsprintfW unnamedParam1: " << szbuf << ", return: " << Return << "\n";

			EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)unnamedParam1, buf);

			uc_reg_write(uc, UC_X86_REG_RAX, &Return);
		}
	}

	void EmuWvsprintfA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		LPSTR unnamedParam1 = nullptr;
		LPCSTR unnamedParam2 = nullptr;
		va_list arglist = nullptr;
		
		ReadArgsFromRegisters(uc,
			std::make_tuple(&unnamedParam1, &unnamedParam2, &arglist),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8 });

		char buf[1024];
		std::string szunnamedParam2;
		if (EmuReadNullTermString(uc, (DWORD_PTR)unnamedParam2, szunnamedParam2))
		{
			int Return = CustomWvsprintfA(uc, buf, szunnamedParam2.data(), arglist);

			*outs << "wvsprintfA unnamedParam1: " << buf << ", return: " << Return << "\n";

			EmuWriteNullTermString(uc, (DWORD_PTR)unnamedParam1, buf);

			uc_reg_write(uc, UC_X86_REG_RAX, &Return);
		}
	}

	void EmuGetModuleHandleExW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD dwFlags = 0;
		LPCWSTR lpModuleName = nullptr;
		HMODULE* phModule = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&dwFlags, &lpModuleName, &phModule),
			{ UC_X86_REG_ECX, UC_X86_REG_RDX, UC_X86_REG_R8 });

		std::wstring wModuleName;
		DWORD_PTR ImageBaseModule = 0;
		BOOL Return = true;
		if (EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpModuleName, wModuleName))
		{
			std::string ModuleName;
			UnicodeToANSI(wModuleName, ModuleName);
			ctx->GetModuleHandleInternalEmulation(&ImageBaseModule, wModuleName);

			*outs << "GetModuleHandleExW dwFlags: " << dwFlags << " lpModuleName: " << ModuleName
				<< " phModule: " << ImageBaseModule << ", return " << Return << "\n";

			if (ImageBaseModule == (DWORD_PTR)IApiEmuErrorCode::GetModuleHandleAInvalidValue)
			{
				ImageBaseModule = 0;

				uc_mem_write(uc, (DWORD_PTR)phModule, &ImageBaseModule, sizeof(ImageBaseModule));
				uc_reg_write(uc, UC_X86_REG_RAX, &Return);
			}
		}

		uc_mem_write(uc, (DWORD_PTR)phModule, &ImageBaseModule, sizeof(ImageBaseModule));
		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuIsDebuggerPresent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		DWORD_PTR Return = 0;
		uc_reg_write(uc, UC_X86_REG_RAX, &Return);

		*outs << "IsDebuggerPresent, return " << Return << "\n";
	}

	void EmuCheckRemoteDebuggerPresent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HANDLE hProcess = nullptr;
		PBOOL pbDebuggerPresent = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hProcess, &pbDebuggerPresent),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX });

		bool DebuggerIsNotPresent = false;
		uc_mem_write(uc, (DWORD_PTR)pbDebuggerPresent, (void*)&DebuggerIsNotPresent, sizeof(bool));

		DWORD_PTR Return = 1;
		uc_reg_write(uc, UC_X86_REG_RAX, &Return);

		*outs << "CheckRemoteDebuggerPresent " << "handle: " << std::hex
			<< hProcess << " " << "DebuggerPresent: " << pbDebuggerPresent << ", return " << Return << "\n";
	}

	void EmuGetModuleFileNameA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		HMODULE hModule = nullptr;
		LPSTR lpFilename = nullptr;
		DWORD nSize = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hModule, &lpFilename, &nSize),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8D });

		std::string Name;

		if (nSize >= ctx->m_PathExe.wstring().size())
		{
			if (hModule == nullptr)
			{
				uc_mem_write(uc, (DWORD_PTR)lpFilename, ctx->m_PathExe.string().data(), ctx->m_PathExe.string().size());
				Name = ctx->m_PathExe.string();
			}
			else
			{
				auto path = ctx->GetModuleFileInternalEmulation(hModule);
				uc_mem_write(uc, (DWORD_PTR)lpFilename, path.string().data(), path.string().size());
				Name = path.string();
			}

			*outs << "GetModuleFileNameA " << "hModule: " << hModule << " nSize: " << nSize << " return(path): "
				<< Name << "\n";
		}
		else
		{
			if (hModule == nullptr)
			{
				std::string truncatedPath = ctx->m_PathExe.string().substr(0, nSize - 1);
				truncatedPath += '\0';

				uc_mem_write(uc, (DWORD_PTR)lpFilename, truncatedPath.data(), truncatedPath.size());

				uc_reg_write(uc, UC_X86_REG_RAX, &nSize);

				ctx->m_Win32LastError = ERROR_INSUFFICIENT_BUFFER;
				Name = truncatedPath;
			}
			else
			{
				auto path = ctx->GetModuleFileInternalEmulation(hModule);

				std::string truncatedPath = path.string().substr(0, nSize - 1);
				truncatedPath += '\0';

				uc_mem_write(uc, (DWORD_PTR)lpFilename, truncatedPath.data(), truncatedPath.size());

				uc_reg_write(uc, UC_X86_REG_RAX, &nSize);

				ctx->m_Win32LastError = ERROR_INSUFFICIENT_BUFFER;
				Name = truncatedPath;
			}

			*outs << "GetModuleFileNameA " << "hModule: " << hModule << " nSize: " << nSize << " return(path): "
				<< Name << " ERROR: " << "ERROR_INSUFFICIENT_BUFFER" << "\n";
		}
	}

	void EmuGetModuleFileNameW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		HMODULE hModule = nullptr;
		LPWSTR lpFilename = nullptr;
		DWORD nSize = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hModule, &lpFilename, &nSize),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8D });

		std::string Name;

		if (nSize >= ctx->m_PathExe.wstring().size())
		{
			if (hModule == nullptr)
			{
				uc_mem_write(uc, (DWORD_PTR)lpFilename, ctx->m_PathExe.wstring().data(), ctx->m_PathExe.wstring().size() * sizeof(wchar_t));
				size_t len = ctx->m_PathExe.wstring().length();
				uc_reg_write(uc, UC_X86_REG_RAX, &len);

				UnicodeToANSI(ctx->m_PathExe.wstring(), Name);
			}
			else
			{
				auto path = ctx->GetModuleFileInternalEmulation(hModule);
				uc_mem_write(uc, (DWORD_PTR)lpFilename, path.wstring().data(), path.wstring().size() * sizeof(wchar_t));
				size_t len = path.wstring().length();
				uc_reg_write(uc, UC_X86_REG_RAX, &len);

				UnicodeToANSI(path.wstring(), Name);
			}

			*outs << "GetModuleFileNameW " << "hModule: " << hModule << " nSize: " << nSize << " return(path): "
				<< Name << "\n";
		}
		else
		{
			if (hModule == nullptr)
			{
				std::wstring truncatedPath = ctx->m_PathExe.wstring().substr(0, nSize - 1);
				truncatedPath += L'\0';

				uc_mem_write(uc, (DWORD_PTR)lpFilename, truncatedPath.data(), truncatedPath.size() * sizeof(wchar_t));

				uc_reg_write(uc, UC_X86_REG_RAX, &nSize);

				ctx->m_Win32LastError = ERROR_INSUFFICIENT_BUFFER;

				UnicodeToANSI(truncatedPath, Name);
			}
			else
			{
				auto path = ctx->GetModuleFileInternalEmulation(hModule);

				std::wstring truncatedPath = path.wstring().substr(0, nSize - 1);
				truncatedPath += L'\0';

				uc_mem_write(uc, (DWORD_PTR)lpFilename, truncatedPath.data(), truncatedPath.size() * sizeof(wchar_t));

				uc_reg_write(uc, UC_X86_REG_RAX, &nSize);

				ctx->m_Win32LastError = ERROR_INSUFFICIENT_BUFFER;

				UnicodeToANSI(truncatedPath, Name);
			}

			*outs << "GetModuleFileNameW " << "hModule: " << hModule << " nSize: " << nSize << " return(path): "
				<< Name << " ERROR: " << "ERROR_INSUFFICIENT_BUFFER" << "\n";
		}
	}

	void EmuGetCommandLineA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		*outs << "GetCommandLineA, return: " << ctx->szCommandLineA << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &ctx->EmuCommandLineA);
	}

	void EmuGetCommandLineW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		std::string szCommandLineA;
		UnicodeToANSI(ctx->szCommandLineW, szCommandLineA);

		*outs << "GetCommandLineW, return: " << szCommandLineA << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &ctx->EmuCommandLineW);
	}

	void EmuGetFileSizeEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HANDLE hFile = nullptr;
		PLARGE_INTEGER lpFileSize = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hFile, &lpFileSize),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX });

		LARGE_INTEGER FileSize{};
		BOOL Return = GetFileSizeEx(hFile, &FileSize);

		uc_mem_write(uc, (DWORD_PTR)lpFileSize, &FileSize, sizeof(FileSize));

		*outs << "GetFileSizeEx hFile: " << hFile << " FileSize: " << FileSize.QuadPart << ", return: " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuGetFileSize(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HANDLE hFile = nullptr;
		LPDWORD lpFileSizeHigh = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hFile, &lpFileSizeHigh),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX });

		DWORD FileSizeHigh = 0;
		DWORD Return = GetFileSize(hFile, &FileSizeHigh);

		if (lpFileSizeHigh != nullptr) { uc_mem_write(uc, (DWORD_PTR)lpFileSizeHigh, &FileSizeHigh, sizeof(FileSizeHigh)); }

		*outs << "GetFileSize hFile: " << hFile << " lpFileSizeHigh: " << lpFileSizeHigh << ", return: " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuGetFileType(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HANDLE hFile = nullptr;
		uc_reg_read(uc, UC_X86_REG_RCX, &hFile);

		DWORD Return = GetFileType(hFile);

		*outs << "GetFileType hFile: " << hFile << ", return(type of file): " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuGetStdHandle(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		DWORD nStdHandle = 0;
		uc_reg_read(uc, UC_X86_REG_ECX, &nStdHandle);
		HANDLE rv = GetStdHandle(nStdHandle);

		*outs << "GetStdHandle nStdHandle: " << nStdHandle << ", return: " << rv << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &rv);
	}

	void EmuAreFileApisANSI(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		BOOL Return = AreFileApisANSI();

		*outs << "AreFileApisANSI, return: " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuIsValidCodePage(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		UINT CodePage = 0;
		uc_reg_read(uc, UC_X86_REG_ECX, &CodePage);

		BOOL Return = IsValidCodePage(CodePage);

		*outs << "GetACP " << "CodePage: " << CodePage << ", return: " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuGetACP(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		UINT Return = GetACP();

		*outs << "GetACP, return: " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuMultiByteToWideChar(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		UINT CodePage = 0;
		DWORD dwFlags = 0;
		LPCCH lpMultiByteStr = nullptr;
		int cbMultiByte = 0;
		LPWSTR lpWideCharStr = nullptr;
		int cchWideChar = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&CodePage, &dwFlags, &lpMultiByteStr, &cbMultiByte),
			{ UC_X86_REG_ECX, UC_X86_REG_EDX, UC_X86_REG_R8, UC_X86_REG_R9D });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &lpWideCharStr, sizeof(lpWideCharStr));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x30, &cchWideChar, sizeof(cchWideChar));

		std::wstring wlpWideCharStr;
		EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpWideCharStr, wlpWideCharStr, true, cchWideChar);

		std::string alpMultiByteStr;
		EmuReadNullTermString(uc, (DWORD_PTR)lpMultiByteStr, alpMultiByteStr, true, cbMultiByte);

		ANSIToUnicode(alpMultiByteStr, wlpWideCharStr);

		if (cchWideChar != 0) { EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)lpMultiByteStr, wlpWideCharStr); }

		size_t SizeStr = wlpWideCharStr.size() * sizeof(wchar_t);

		*outs << "MultiByteToWideChar CodePage: " << CodePage << " dwFlags: " << dwFlags << " lpMultiByteStr: " << alpMultiByteStr
			<< " cbMultiByte: " << cbMultiByte << " lpWideCharStr: " << alpMultiByteStr << " cchWideChar: " << cchWideChar << ", return: "
			<< SizeStr << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &SizeStr);
	}

	void EmuGetStringTypeW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		DWORD dwInfoType = 0;
		LPCWCH lpSrcStr = nullptr;
		int cchSrc = 0;
		LPWORD lpCharType = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&dwInfoType, &lpSrcStr, &cchSrc, &lpCharType),
			{ UC_X86_REG_ECX, UC_X86_REG_RDX, UC_X86_REG_R8D, UC_X86_REG_R9 });

		std::wstring wlpSrcStr;
		if (EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpSrcStr, wlpSrcStr, true, cchSrc))
		{
			LPWORD CharType = (LPWORD)VirtualAlloc(nullptr, wlpSrcStr.size(), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
			if (CharType != nullptr)
			{
				std::string alpSrcStr;
				UnicodeToANSI(wlpSrcStr, alpSrcStr);

				BOOL Return = GetStringTypeW(dwInfoType, wlpSrcStr.data(), cchSrc, CharType);
				uc_mem_write(uc, (DWORD_PTR)lpCharType, &CharType, wlpSrcStr.size());

				VirtualFree((LPVOID)CharType, 0, MEM_DECOMMIT);

				*outs << "GetStringTypeW dwInfoType: " << dwInfoType << " lpSrcStr: " << alpSrcStr << " cchSrc: " << cchSrc
					<< " lpCharType: " << lpCharType << ", return: " << Return << "\n";

				uc_reg_write(uc, UC_X86_REG_RAX, &Return);
			}
		}
	}

	void EmuCreateFileMappingA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		HANDLE hFile = nullptr;
		LPSECURITY_ATTRIBUTES lpFileMappingAttributes = nullptr;
		DWORD flProtect = 0;
		DWORD dwMaximumSizeHigh = 0;
		DWORD dwMaximumSizeLow = 0;
		LPCSTR lpName = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hFile, &lpFileMappingAttributes, &flProtect, &dwMaximumSizeHigh),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8D, UC_X86_REG_R9D });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &dwMaximumSizeLow, sizeof(dwMaximumSizeLow));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x30, &lpName, sizeof(lpName));

		std::string alpName;
		EmuReadNullTermString(uc, (DWORD_PTR)lpName, alpName);

		HANDLE Return = nullptr;

		if (lpFileMappingAttributes != nullptr)
		{
			SECURITY_ATTRIBUTES SecurityAttributes{};
			uc_mem_read(uc, (DWORD_PTR)lpFileMappingAttributes, &SecurityAttributes, sizeof(SecurityAttributes));

			SECURITY_DESCRIPTOR SecurityDescriptor{};
			uc_mem_read(uc, (DWORD_PTR)(lpFileMappingAttributes + offsetof(SECURITY_ATTRIBUTES, lpSecurityDescriptor)),
				&SecurityDescriptor, sizeof(SecurityDescriptor));

			SecurityAttributes.lpSecurityDescriptor = &SecurityDescriptor;

			Return = CreateFileMappingA(
				hFile,
				&SecurityAttributes,
				flProtect,
				dwMaximumSizeHigh,
				dwMaximumSizeLow,
				lpName == nullptr ? lpName : alpName.data());
		}
		else
		{
			Return = CreateFileMappingA(
				hFile,
				lpFileMappingAttributes,
				flProtect,
				dwMaximumSizeHigh,
				dwMaximumSizeLow,
				lpName == nullptr ? lpName : alpName.data());
		}

		*outs << "CreateFileMappingW hFile: " << hFile << " lpFileMappingAttributes: " << lpFileMappingAttributes << " flProtect: "
			<< flProtect << " dwMaximumSizeHigh: " << dwMaximumSizeHigh << " dwMaximumSizeLow: " << dwMaximumSizeLow << " lpName: ";

		if (lpName != nullptr)
		{
			*outs << alpName;
		}
		else
		{
			*outs << (DWORD_PTR)lpName;
		}

		auto it = std::find_if(ctx->m_HandleMap.begin(), ctx->m_HandleMap.end(),
			[&hFile](const HandleMapping& mapping)
			{
				for (auto& HANDLE : mapping.Handles)
				{
					if (HANDLE == hFile)
					{
						return HANDLE == hFile;
					}
				}
			});


		if (it != ctx->m_HandleMap.end())
		{
			it->Handles.push_back(Return);
		}

		*outs << ", return: " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);

		if (GetLastError() == ERROR_ALREADY_EXISTS)
		{
			ctx->m_LastException = ERROR_ALREADY_EXISTS;
		}
	}

	void EmuCreateFileMappingW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		HANDLE hFile = nullptr;
		LPSECURITY_ATTRIBUTES lpFileMappingAttributes = nullptr;
		DWORD flProtect = 0;
		DWORD dwMaximumSizeHigh = 0;
		DWORD dwMaximumSizeLow = 0;
		LPCWSTR lpName = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hFile, &lpFileMappingAttributes, &flProtect, &dwMaximumSizeHigh),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8D, UC_X86_REG_R9D });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &dwMaximumSizeLow, sizeof(dwMaximumSizeLow));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x30, &lpName, sizeof(lpName));

		std::wstring wlpName;
		EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpName, wlpName);

		HANDLE Return = nullptr;

		if (lpFileMappingAttributes != nullptr)
		{
			SECURITY_ATTRIBUTES SecurityAttributes{};
			uc_mem_read(uc, (DWORD_PTR)lpFileMappingAttributes, &SecurityAttributes, sizeof(SecurityAttributes));

			SECURITY_DESCRIPTOR SecurityDescriptor{};
			uc_mem_read(uc, (DWORD_PTR)(lpFileMappingAttributes + offsetof(SECURITY_ATTRIBUTES, lpSecurityDescriptor)),
				&SecurityDescriptor, sizeof(SecurityDescriptor));

			SecurityAttributes.lpSecurityDescriptor = &SecurityDescriptor;
			
			Return = CreateFileMappingW(
				hFile,
				&SecurityAttributes,
				flProtect,
				dwMaximumSizeHigh,
				dwMaximumSizeLow,
				lpName == nullptr ? lpName : wlpName.data());
		}
		else
		{
			Return = CreateFileMappingW(
				hFile,
				lpFileMappingAttributes,
				flProtect,
				dwMaximumSizeHigh,
				dwMaximumSizeLow,
				lpName == nullptr ? lpName : wlpName.data());
		}

		std::string alpName;
		UnicodeToANSI(wlpName, alpName);

		*outs << "CreateFileMappingW hFile: " << hFile << " lpFileMappingAttributes: " << lpFileMappingAttributes << " flProtect: "
			<< flProtect << " dwMaximumSizeHigh: " << dwMaximumSizeHigh << " dwMaximumSizeLow: " << dwMaximumSizeLow << " lpName: ";

		if (lpName != nullptr)
		{
			*outs << alpName;
		}
		else
		{
			*outs << (DWORD_PTR)lpName;
		}

		for (auto& HandleMap : ctx->m_HandleMap)
		{
			auto it = std::find_if(HandleMap.Handles.begin(), HandleMap.Handles.end(),
				[&hFile](const HANDLE& Handle) { return Handle == hFile; });
		}

		auto it = std::find_if(ctx->m_HandleMap.begin(), ctx->m_HandleMap.end(),
			[&hFile](const HandleMapping& mapping) 
			{ 
				for (auto& HANDLE : mapping.Handles)
				{
					if (HANDLE == hFile)
					{
						return HANDLE == hFile;
					}
				}
			});


		if (it != ctx->m_HandleMap.end())
		{
			it->Handles.push_back(Return);
		}

		*outs << ", return: " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);

		if (GetLastError() == ERROR_ALREADY_EXISTS)
		{
			ctx->m_LastException = ERROR_ALREADY_EXISTS;
		}
	}

	void EmuUnmapViewOfFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		LPCVOID lpBaseAddress = nullptr;

		uc_reg_read(uc, UC_X86_REG_RCX, &lpBaseAddress);

		for (auto& FakeModule : ctx->m_FakeModules)
		{
			if ((DWORD_PTR)lpBaseAddress >= FakeModule->ImageBase && (DWORD_PTR)lpBaseAddress < FakeModule->ImageBase + FakeModule->ImageSize)
			{
				BOOL Return = true; 

				*outs << "UnmapViewOfFile lpBaseAddress: " << lpBaseAddress << ", return: " << Return << "\n";

				uc_reg_write(uc, UC_X86_REG_RAX, &Return);

				break;
			}
		}

		//TODO:unmaping of pages that was generated via MapViewOfFile
	}

	void EmuMapViewOfFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		HANDLE hFileMappingObject = nullptr;
		DWORD dwDesiredAccess = 0;
		DWORD dwFileOffsetHigh = 0;
		DWORD dwFileOffsetLow = 0;
		SIZE_T dwNumberOfBytesToMap = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hFileMappingObject, &dwDesiredAccess, &dwFileOffsetHigh, &dwFileOffsetLow),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8D, UC_X86_REG_R9D });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &dwNumberOfBytesToMap, sizeof(dwNumberOfBytesToMap));

		auto it = std::find_if(ctx->m_HandleMap.begin(), ctx->m_HandleMap.end(),
			[&hFileMappingObject](const HandleMapping& mapping)
			{
				for (auto& HANDLE : mapping.Handles)
				{
					if (HANDLE == hFileMappingObject)
					{
						return HANDLE == hFileMappingObject;
					}
				}
			});

		if (it != ctx->m_HandleMap.end())
		{
			for (auto& Module : ctx->m_FakeModules)
			{
				if (Module->DllName == it->ProgName)
				{
					*outs << "MapViewOfFile hFileMappingObject: " << hFileMappingObject << " dwDesiredAccess:"
						<< dwDesiredAccess << "dwFileOffsetHigh: " << dwFileOffsetHigh << " dwFileOffsetLow: "
						<< dwFileOffsetLow << " dwNumberOfBytesToMap: " << dwNumberOfBytesToMap << ", return: " << Module->ImageBase <<
						"\n";
					uc_reg_write(uc, UC_X86_REG_RAX, &Module->ImageBase);
				}
			}
		}
		else
		{
			*outs << "This option of EmuMapViewOfFile not implemented" << "\n";
			_CrtDbgBreak();
			//LPVOID Return = MapViewOfFile(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);
			//
			//MEMORY_BASIC_INFORMATION info;
			//VirtualQueryEx(GetCurrentProcess(), Return, &info, sizeof(info));
			//
			//SIZE_T szBufferSize = ALIGN_TO_4KB(info.RegionSize);
			//
			//DWORD EmuflProtect = 0;
			//DWORD RealflProtect = 0;
			//switch (dwDesiredAccess)
			//{
			//case FILE_MAP_ALL_ACCESS:
			//{
			//	EmuflProtect = UC_PROT_ALL;
			//	RealflProtect = PAGE_EXECUTE_READWRITE;
			//	break;
			//}
			//case FILE_MAP_READ:
			//{
			//	EmuflProtect = UC_PROT_READ;
			//	RealflProtect = PAGE_READONLY;
			//	break;
			//}
			//case FILE_MAP_WRITE:
			//{
			//	EmuflProtect = UC_PROT_WRITE;
			//	RealflProtect = PAGE_WRITECOPY;
			//	break;
			//}
			//case FILE_MAP_COPY:
			//{
			//	EmuflProtect = UC_PROT_WRITE | UC_PROT_READ;
			//	RealflProtect = PAGE_READWRITE;
			//	break;
			//}
			//case FILE_MAP_EXECUTE:
			//{
			//	EmuflProtect = UC_PROT_EXEC;
			//	RealflProtect = PAGE_EXECUTE;
			//	break;
			//}
			//}
			//
			//uc_mem_map_ptr(uc, ALIGN_TO_4KB((DWORD_PTR)Return), szBufferSize, EmuflProtect, Return);
			//
			//
			//ctx->m_FakeAllocations.emplace_back(
			//	(ULONG)0,
			//	(ULONG)RealflProtect,
			//	(ULONG)EmuflProtect,
			//	szBufferSize,
			//	(char*)"",
			//	(bool)false,
			//	(DWORD_PTR)Return);
			//
			//uc_reg_write(uc, UC_X86_REG_RAX, &Return);
		}
	}

	void EmuCreateFileW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		LPCWSTR lpFileName = nullptr;
		DWORD dwDesiredAccess = 0;
		DWORD dwShareMode = 0;
		LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr;
		DWORD dwCreationDisposition = 0;
		DWORD dwFlagsAndAttributes = 0;
		HANDLE hTemplateFile = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&lpFileName, &dwDesiredAccess, &dwShareMode, &lpSecurityAttributes),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8D, UC_X86_REG_R9 });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &dwCreationDisposition, sizeof(dwCreationDisposition));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x30, &dwFlagsAndAttributes, sizeof(dwFlagsAndAttributes));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x38, &hTemplateFile, sizeof(hTemplateFile));

		std::wstring wlpFileName;
		HANDLE Return = INVALID_HANDLE_VALUE;
		if (EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpFileName, wlpFileName))
		{
			if (lpSecurityAttributes != nullptr)
			{
				SECURITY_ATTRIBUTES SecurityAttributes{};
				uc_mem_read(uc, (DWORD_PTR)lpSecurityAttributes, &SecurityAttributes, sizeof(SecurityAttributes));

				SECURITY_DESCRIPTOR SecurityDescriptor{};
				uc_mem_read(uc, (DWORD_PTR)(lpSecurityAttributes + offsetof(SECURITY_ATTRIBUTES, lpSecurityDescriptor)),
					&SecurityDescriptor, sizeof(SecurityDescriptor));

				SecurityAttributes.lpSecurityDescriptor = &SecurityDescriptor;

				Return = CreateFileW(
					wlpFileName.data(),
					dwDesiredAccess,
					dwShareMode,
					&SecurityAttributes,
					dwCreationDisposition,
					dwFlagsAndAttributes,
					hTemplateFile);
			}
			else
			{
				Return = CreateFileW(
					wlpFileName.data(),
					dwDesiredAccess,
					dwShareMode,
					nullptr,
					dwCreationDisposition,
					dwFlagsAndAttributes,
					hTemplateFile);
			}
		}

		std::string alpFileName;
		UnicodeToANSI(wlpFileName, alpFileName);
		*outs << "CreateFileW lpFileName: " << alpFileName << " dwDesiredAccess: " << dwDesiredAccess
			<< " dwShareMode:" << GetShareAccessString(dwShareMode) << "lpSecurityAttributes: " << lpSecurityAttributes
			<< " dwCreationDisposition: " << dwCreationDisposition << " dwFlagsAndAttributes: " << dwFlagsAndAttributes
			<< " hTemplateFile: " << hTemplateFile << ", return: " << Return << "\n";

		auto it = std::find_if(ctx->m_HandleMap.begin(), ctx->m_HandleMap.end(),
			[&wlpFileName](const HandleMapping& mapping) { return mapping.ProgName == wlpFileName; });

		if (it != ctx->m_HandleMap.end())
		{
			it->Handles.push_back(Return);
		}
		else
		{
			HandleMapping stHandleMapping(wlpFileName);
			stHandleMapping.Handles.push_back(Return);

			ctx->m_HandleMap.push_back(stHandleMapping);
		}

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuCreateFileA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		LPCSTR lpFileName = nullptr;
		DWORD dwDesiredAccess = 0;
		DWORD dwShareMode = 0;
		LPSECURITY_ATTRIBUTES lpSecurityAttributes = nullptr;
		DWORD dwCreationDisposition = 0;
		DWORD dwFlagsAndAttributes = 0;
		HANDLE hTemplateFile = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&lpFileName, &dwDesiredAccess, &dwShareMode, &lpSecurityAttributes),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8D, UC_X86_REG_R9 });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &dwCreationDisposition, sizeof(dwCreationDisposition));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x30, &dwFlagsAndAttributes, sizeof(dwFlagsAndAttributes));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x38, &hTemplateFile, sizeof(hTemplateFile));

		std::string alpFileName;
		HANDLE Return = INVALID_HANDLE_VALUE;
		if (EmuReadNullTermString(uc, (DWORD_PTR)lpFileName, alpFileName))
		{
			if (lpSecurityAttributes != nullptr)
			{
				SECURITY_ATTRIBUTES SecurityAttributes{};
				uc_mem_read(uc, (DWORD_PTR)lpSecurityAttributes, &SecurityAttributes, sizeof(SecurityAttributes));

				SECURITY_DESCRIPTOR SecurityDescriptor{};
				uc_mem_read(uc, (DWORD_PTR)(lpSecurityAttributes + offsetof(SECURITY_ATTRIBUTES, lpSecurityDescriptor)),
					&SecurityDescriptor, sizeof(SecurityDescriptor));

				SecurityAttributes.lpSecurityDescriptor = &SecurityDescriptor;

				Return = CreateFileA(
					alpFileName.data(), 
					dwDesiredAccess, 
					dwShareMode,
					&SecurityAttributes, 
					dwCreationDisposition, 
					dwFlagsAndAttributes, 
					hTemplateFile);
			}
			else
			{
				Return = CreateFileA(
					alpFileName.data(),
					dwDesiredAccess,
					dwShareMode,
					nullptr,
					dwCreationDisposition,
					dwFlagsAndAttributes,
					hTemplateFile);
			}
		}

		std::wstring wlpFileName;
		ANSIToUnicode(alpFileName, wlpFileName);
		*outs << "CreateFileA lpFileName: " << alpFileName << " dwDesiredAccess: " << dwDesiredAccess
			<< " dwShareMode:" << GetShareAccessString(dwShareMode) << "lpSecurityAttributes: " << lpSecurityAttributes
			<< " dwCreationDisposition: " << dwCreationDisposition << " dwFlagsAndAttributes: " << dwFlagsAndAttributes
			<< " hTemplateFile: " << hTemplateFile << ", return: " << Return << "\n";

		auto it = std::find_if(ctx->m_HandleMap.begin(), ctx->m_HandleMap.end(),
			[&wlpFileName](const HandleMapping& mapping) { return mapping.ProgName == wlpFileName; });

		if (it != ctx->m_HandleMap.end())
		{
			it->Handles.push_back(Return);
		}
		else
		{
			HandleMapping stHandleMapping(wlpFileName);
			stHandleMapping.Handles.push_back(Return);

			ctx->m_HandleMap.push_back(stHandleMapping);
		}

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuWriteFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HANDLE hFile = nullptr;
		LPCVOID lpBuffer = nullptr;
		DWORD nNumberOfBytesToWrite = 0;
		LPDWORD lpNumberOfBytesWritten = 0;
		LPOVERLAPPED lpOverlapped = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hFile, &lpBuffer, &nNumberOfBytesToWrite, &lpNumberOfBytesWritten),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8D, UC_X86_REG_R9 });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &lpOverlapped, sizeof(lpOverlapped));

		LPVOID MylpBuffer = (LPVOID)VirtualAlloc(nullptr, nNumberOfBytesToWrite, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
		if (MylpBuffer != nullptr)
		{
			ZeroMemory(MylpBuffer, nNumberOfBytesToWrite);
			EmuCopyBufferFromUc(uc, MylpBuffer, (LPVOID)lpBuffer, nNumberOfBytesToWrite);

			DWORD NumberOfBytesWritten = 0;

			BOOL Return = true;
			if (lpOverlapped == nullptr)
			{
				Return = WriteFile(hFile, (LPCVOID)MylpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, nullptr);
			}
			else
			{
				OVERLAPPED Overlapped{};

				uc_mem_read(uc, (DWORD_PTR)lpOverlapped, &Overlapped, sizeof(Overlapped));
				Return = WriteFile(hFile, (LPCVOID)MylpBuffer, nNumberOfBytesToWrite, &NumberOfBytesWritten, &Overlapped);
				uc_mem_write(uc, (DWORD_PTR)lpOverlapped, &Overlapped, sizeof(Overlapped));
			}

			if (lpNumberOfBytesWritten != nullptr) 
			{ uc_mem_write(uc, (DWORD_PTR)lpNumberOfBytesWritten, &NumberOfBytesWritten, sizeof(NumberOfBytesWritten)); }

			*outs << "WriteFile hFile: " << hFile << " lpBuffer: " << lpBuffer << " nNumberOfBytesToWrite: " 
				<< nNumberOfBytesToWrite << " lpNumberOfBytesWritten: " << lpNumberOfBytesWritten << " lpOverlapped: " << lpOverlapped 
				<< "\n";

			VirtualFree(MylpBuffer, 0, MEM_DECOMMIT);

			uc_reg_write(uc, UC_X86_REG_RAX, &Return);
		}
	}

	void EmuSetUnhandledExceptionFilter(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter = 0;
		uc_reg_read(uc, UC_X86_REG_RCX, &lpTopLevelExceptionFilter);

		LPTOP_LEVEL_EXCEPTION_FILTER PreviousTopLevelFilter = ctx->SetUnhandledExceptionFilter(lpTopLevelExceptionFilter);

		*outs << "SetUnhandledExceptionFilter lpTopLevelExceptionFilter: " << lpTopLevelExceptionFilter << ", return: "
			<< PreviousTopLevelFilter << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &PreviousTopLevelFilter);
	}

	void EmuGetEnvironmentStringsW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR ProcessParameters = 0;
		uc_mem_read(uc, ctx->m_PebBase + offsetof(PEB, ProcessParameters), &ProcessParameters, sizeof(ProcessParameters));

		PVOID Environment = nullptr;
		uc_mem_read(uc, ProcessParameters + offsetof(RTL_USER_PROCESS_PARAMETERS, Environment),
			&Environment, sizeof(Environment));

		*outs << "GetEnvironmentStringsW, return(RTL_USER_PROCESS_PARAMETERS, Environment): " << Environment << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Environment);
	}

	void EmuFreeEnvironmentStringsW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		BOOL Return = true;

		*outs << "FreeEnvironmentStringsW, return: " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuRtlInitializeSListHead(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		PSLIST_HEADER ListHead = nullptr;
		uc_reg_read(uc, UC_X86_REG_RCX, &ListHead);

		ctx->RtlInitializeSListHead(ListHead);

		*outs << "RtlInitializeSListHead ListHead: " << ListHead << "\n";
	}

	void EmuLCMapStringW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		LCID Locale = 0;
		DWORD dwMapFlags = 0;
		LPCWSTR lpSrcStr = nullptr;
		int cchSrc = 0;
		LPWSTR lpDestStr = nullptr;
		int cchDest = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&Locale, &dwMapFlags, &lpSrcStr, &cchSrc),
			{ UC_X86_REG_ECX, UC_X86_REG_EDX, UC_X86_REG_R8, UC_X86_REG_R9D });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &lpDestStr, sizeof(lpDestStr));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x30, &cchDest, sizeof(cchDest));

		std::wstring wlpSrcStr;
		EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpSrcStr, wlpSrcStr, true, cchSrc);

		std::string alpSrcStr;
		UnicodeToANSI(wlpSrcStr, alpSrcStr);

		int Return = 0;
		if (lpDestStr != nullptr)
		{
			std::wstring wlpDestStr;
			EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpDestStr, wlpDestStr, true, cchDest);

			Return = LCMapStringW(Locale, dwMapFlags, wlpSrcStr.data(), cchSrc, wlpDestStr.data(), cchDest);

			EmuWriteNullTermUnicodeString(uc, (DWORD_PTR)lpDestStr, wlpDestStr);
		}
		else
		{
			Return = LCMapStringW(Locale, dwMapFlags, wlpSrcStr.data(), cchSrc, nullptr, cchDest);
		}

		*outs << "LCMapStringW Locale: " << Locale << " dwMapFlags: " << dwMapFlags << " lpSrcStr: " << alpSrcStr
			<< " cchSrc: " << cchSrc << " lpDestStr: " << (DWORD_PTR)lpDestStr << " cchDest: " << cchDest << ", return: " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuWideCharToMultiByte(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		UINT CodePage = 0;
		DWORD dwFlags = 0;
		LPCWCH lpWideCharStr = nullptr;
		int cchWideChar = 0;
		LPSTR lpMultiByteStr = nullptr;
		int cbMultiByte = 0;
		LPCCH lpDefaultChar = nullptr;
		LPBOOL lpUsedDefaultChar = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&CodePage, &dwFlags, &lpWideCharStr, &cchWideChar),
			{ UC_X86_REG_ECX, UC_X86_REG_EDX, UC_X86_REG_R8, UC_X86_REG_R9D });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &lpMultiByteStr, sizeof(lpMultiByteStr));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x30, &cbMultiByte, sizeof(cbMultiByte));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x38, &lpDefaultChar, sizeof(lpDefaultChar));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x40, &lpUsedDefaultChar, sizeof(lpUsedDefaultChar));

		std::wstring wlpWideCharStr;
		EmuReadNullTermUnicodeString(uc, (DWORD_PTR)lpWideCharStr, wlpWideCharStr, true, cchWideChar);

		std::string alpMultiByteStr;
		EmuReadNullTermString(uc, (DWORD_PTR)lpMultiByteStr, alpMultiByteStr, true, cbMultiByte);

		UnicodeToANSI(wlpWideCharStr, alpMultiByteStr);

		if (cbMultiByte != 0) { EmuWriteNullTermString(uc, (DWORD_PTR)lpMultiByteStr, alpMultiByteStr); }

		size_t SizeStr = alpMultiByteStr.size();

		*outs << "WideCharToMultiByte CodePage: " << CodePage << " dwFlags: " << dwFlags << " lpWideCharStr: " << alpMultiByteStr
			<< " cchWideChar: " << cchWideChar << " lpMultiByteStr: " << alpMultiByteStr << " cbMultiByte: " << cbMultiByte <<
			" lpDefaultChar: " << (DWORD_PTR)lpDefaultChar << " lpUsedDefaultChar: " << (DWORD_PTR)lpUsedDefaultChar << ", return: "
			<< SizeStr << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &SizeStr);
	}

	void EmuGetCPInfo(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		UINT CodePage = 0;
		LPCPINFO lpCPInfo = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&CodePage, &lpCPInfo),
			{ UC_X86_REG_ECX, UC_X86_REG_RDX});

		CPINFO CPInfo{};

		BOOL Return = GetCPInfo(CodePage, &CPInfo);

		//PBYTE DefaultChar = (PBYTE)ctx->HeapAlloc(MAX_DEFAULTCHAR);

		//std::string Dc = (LPSTR)CPInfo.DefaultChar;
		//EmuCopyASCIStrs(uc, (LPSTR)DefaultChar, Dc);

		uc_mem_write(uc, (DWORD_PTR)lpCPInfo, &CPInfo, sizeof(CPInfo));
		//uc_mem_write(uc, (DWORD_PTR)lpCPInfo + offsetof(CPInfo, DefaultChar), &DefaultChar, sizeof(DefaultChar));


		*outs << "GetCPInfo CodePage: " << CodePage << " lpCPInfo: " << lpCPInfo << ", return: " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuGetStartupInfoW(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		//PeEmulation* ctx = (PeEmulation*)user_data;

		//LPSTARTUPINFOW lppStartupInfo = nullptr;
		//PDWORD_PTR lpStartupInfo = nullptr;
		//uc_reg_read(uc, UC_X86_REG_RAX, &lppStartupInfo);
		//uc_mem_read(uc, (DWORD_PTR)lppStartupInfo, &lpStartupInfo, sizeof(lpStartupInfo));

		///*
		//    LPWSTR  lpReserved;
		//	LPWSTR  lpDesktop;
		//	LPWSTR  lpTitle;
		//*/
		//STARTUPINFOW StartupInfo{};

		//GetStartupInfoW(&StartupInfo);

		//std::wstring slpReserved = StartupInfo.lpReserved;
		//std::wstring slpDesktop = StartupInfo.lpDesktop;
		//std::wstring slpTitle = StartupInfo.lpTitle;

		//LPWSTR wlpReserved = (LPWSTR)ctx->HeapAlloc(slpReserved.size() * sizeof(wchar_t));
		//LPWSTR wlpDesktop = (LPWSTR)ctx->HeapAlloc(slpDesktop.size() * sizeof(wchar_t));
		//LPWSTR wlpTitle = (LPWSTR)ctx->HeapAlloc(slpTitle.size() * sizeof(wchar_t));
		////LPSTARTUPINFOW lpppStartupInfo = (LPSTARTUPINFOW)ctx->HeapAlloc(sizeof(STARTUPINFOW));

		//EmuCopyUnicodeStrs(uc, wlpReserved, slpReserved);
		//EmuCopyUnicodeStrs(uc, wlpDesktop, slpDesktop);
		//EmuCopyUnicodeStrs(uc, wlpTitle, slpTitle);

		//StartupInfo.lpReserved = (LPWSTR)wlpReserved;
		//StartupInfo.lpDesktop = (LPWSTR)wlpDesktop;
		//StartupInfo.lpTitle = (LPWSTR)wlpTitle;

		//uc_mem_write(uc, (DWORD_PTR)lpppStartupInfo, &StartupInfo, sizeof(StartupInfo));
		//uc_mem_write(uc, (DWORD_PTR)lppStartupInfo, &StartupInfo, sizeof(StartupInfo));

		//uc_mem_write(uc, (DWORD_PTR)lpStartupInfo + offsetof(STARTUPINFOW, lpReserved), (void*)&wlpReserved, sizeof(wlpReserved));
		//uc_mem_write(uc, (DWORD_PTR)lpStartupInfo + offsetof(STARTUPINFOW, lpDesktop), (void*)&wlpDesktop, sizeof(wlpDesktop));
		//uc_mem_write(uc, (DWORD_PTR)lpStartupInfo + offsetof(STARTUPINFOW, lpTitle), (void*)&wlpTitle, sizeof(wlpTitle));
	}

	void EmuGetStartupInfoA(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		//PeEmulation* ctx = (PeEmulation*)user_data;

		//LPSTARTUPINFOA lppStartupInfo = nullptr;
		//PDWORD_PTR lpStartupInfo = nullptr;
		//uc_reg_read(uc, UC_X86_REG_RAX, &lppStartupInfo);
		//uc_mem_read(uc, (DWORD_PTR)lppStartupInfo, &lpStartupInfo, sizeof(lpStartupInfo));

		///*
		//    LPSTR   lpReserved;
		//	LPSTR   lpDesktop;
		//	LPSTR   lpTitle;
		//*/
		//STARTUPINFOA StartupInfo{};

		//GetStartupInfoA(&StartupInfo);

		//std::string slpReserved = StartupInfo.lpReserved;
		//std::string slpDesktop = StartupInfo.lpDesktop;
		//std::string slpTitle = StartupInfo.lpTitle;

		//LPSTR lpReserved = (LPSTR)ctx->HeapAlloc(slpReserved.size());
		//LPSTR lpDesktop = (LPSTR)ctx->HeapAlloc(slpDesktop.size());
		//LPSTR lpTitle = (LPSTR)ctx->HeapAlloc(slpTitle.size());

		//EmuCopyASCIStrs(uc, lpReserved, slpReserved);
		//EmuCopyASCIStrs(uc, lpDesktop, slpDesktop);
		//EmuCopyASCIStrs(uc, lpTitle, slpTitle);

		//uc_mem_write(uc, (DWORD_PTR)lpStartupInfo, &StartupInfo, sizeof(STARTUPINFOA));
	}

	void EmuNtSetInformationThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HANDLE ThreadHandle = nullptr;
		DWORD ThreadInformationClass = 0;
		PVOID ThreadInformation = nullptr;
		ULONG ThreadInformationLength = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&ThreadHandle, &ThreadInformationClass, &ThreadInformation, &ThreadInformationLength),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8, UC_X86_REG_R9D });

		DWORD_PTR Return = STATUS_SUCCESS;

		if (ThreadInformationClass == (DWORD)THREADINFOCLASS__::ThreadHideFromDebugger && 
			ThreadInformation == 0 && ThreadInformationLength == 0)
		{
			if (ThreadHandle == NtCurrentThread || 
				GetCurrentProcessId() == GetProcessIdByThreadHandle(ThreadHandle)) //thread inside this process?
			{
				uc_reg_write(uc, UC_X86_REG_RAX, &Return);
			}
			else
			{
				Return = NtQueryInformationThread(ThreadHandle, (THREADINFOCLASS)ThreadInformationClass,
					&ThreadInformation, ThreadInformationLength, 0);

				uc_reg_write(uc, UC_X86_REG_RAX, &Return);
			}
		}
		else
		{
			Return = NtQueryInformationThread(ThreadHandle, (THREADINFOCLASS)ThreadInformationClass,
				&ThreadInformation, ThreadInformationLength, 0);

			uc_reg_write(uc, UC_X86_REG_RAX, &Return);
		}

		std::string szThreadInformationClass;

		switch (ThreadInformationClass)
		{
		case (DWORD)__THREADINFOCLASS::ThreadBasicInformation:
			szThreadInformationClass = "ThreadBasicInformation";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadTimes:
			szThreadInformationClass = "ThreadTimes";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadPriority:
			szThreadInformationClass = "ThreadPriority";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadBasePriority:
			szThreadInformationClass = "ThreadBasePriority";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadAffinityMask:
			szThreadInformationClass = "ThreadAffinityMask";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadImpersonationToken:
			szThreadInformationClass = "ThreadImpersonationToken";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadDescriptorTableEntry:
			szThreadInformationClass = "ThreadDescriptorTableEntry";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadEnableAlignmentFaultFixup:
			szThreadInformationClass = "ThreadEnableAlignmentFaultFixup";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadEventPair:
			szThreadInformationClass = "ThreadEventPair";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadQuerySetWin32StartAddress:
			szThreadInformationClass = "ThreadQuerySetWin32StartAddress";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadZeroTlsCell:
			szThreadInformationClass = "ThreadZeroTlsCell";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadPerformanceCount:
			szThreadInformationClass = "ThreadPerformanceCount";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadAmILastThread:
			szThreadInformationClass = "ThreadAmILastThread";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadIdealProcessor:
			szThreadInformationClass = "ThreadIdealProcessor";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadPriorityBoost:
			szThreadInformationClass = "ThreadPriorityBoost";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadSetTlsArrayAddress:
			szThreadInformationClass = "ThreadSetTlsArrayAddress";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadIsIoPending:
			szThreadInformationClass = "ThreadIsIoPending";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadHideFromDebugger:
			szThreadInformationClass = "ThreadHideFromDebugger";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadBreakOnTermination:
			szThreadInformationClass = "ThreadBreakOnTermination";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadSwitchLegacyState:
			szThreadInformationClass = "ThreadSwitchLegacyState";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadIsTerminated:
			szThreadInformationClass = "ThreadIsTerminated";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadLastSystemCall:
			szThreadInformationClass = "ThreadLastSystemCall";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadIoPriority:
			szThreadInformationClass = "ThreadIoPriority";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadCycleTime:
			szThreadInformationClass = "ThreadCycleTime";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadPagePriority:
			szThreadInformationClass = "ThreadPagePriority";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadActualBasePriority:
			szThreadInformationClass = "ThreadActualBasePriority";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadTebInformation:
			szThreadInformationClass = "ThreadTebInformation";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadCSwitchMon:
			szThreadInformationClass = "ThreadCSwitchMon";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadCSwitchPmu:
			szThreadInformationClass = "ThreadCSwitchPmu";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadWow64Context:
			szThreadInformationClass = "ThreadWow64Context";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadGroupInformation:
			szThreadInformationClass = "ThreadGroupInformation";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadUmsInformation:
			szThreadInformationClass = "ThreadUmsInformation";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadCounterProfiling:
			szThreadInformationClass = "ThreadCounterProfiling";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadIdealProcessorEx:
			szThreadInformationClass = "ThreadIdealProcessorEx";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadCpuAccountingInformation:
			szThreadInformationClass = "ThreadCpuAccountingInformation";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadSuspendCount:
			szThreadInformationClass = "ThreadSuspendCount";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadHeterogeneousCpuPolicy:
			szThreadInformationClass = "ThreadHeterogeneousCpuPolicy";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadContainerId:
			szThreadInformationClass = "ThreadContainerId";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadNameInformation:
			szThreadInformationClass = "ThreadNameInformation";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadSelectedCpuSets:
			szThreadInformationClass = "ThreadSelectedCpuSets";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadSystemThreadInformation:
			szThreadInformationClass = "ThreadSystemThreadInformation";
			break;
		case (DWORD)__THREADINFOCLASS::ThreadActualGroupAffinity:
			szThreadInformationClass = "ThreadActualGroupAffinity";
			break;
		}

		*outs << "NtSetInformationThread " << "ThreadHandle: " << ThreadHandle << " ThreadInformationClass: "
			<< szThreadInformationClass << " ThreadInformation: " << ThreadInformation << " ThreadInformationLength: "
			<< ThreadInformationLength << "\n";
	}

	void EmuNtQueryInformationProcess(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		HANDLE ProcessHandle = nullptr;
		DWORD ProcessInformationClass = 0;
		PVOID ProcessInformation = nullptr;
		ULONG ProcessInformationLength = 0;
		PULONG ReturnLength = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&ProcessHandle, &ProcessInformationClass, &ProcessInformation, &ProcessInformationLength),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8, UC_X86_REG_R9D });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &ReturnLength, sizeof(PULONG));

		HMODULE hNtdll = LoadLibraryA("ntdll.dll");
		auto pfnNtQueryInformationProcess = (TNtQueryInformationProcess)GetProcAddress(
			hNtdll, "NtQueryInformationProcess");

		std::string szProcessInformationClass;
		DWORD_PTR Return = STATUS_SUCCESS;

		switch ((PROCESSINFOCLASS_)ProcessInformationClass)
		{
		case PROCESSINFOCLASS_::ProcessBasicInformation:
		{
			szProcessInformationClass = "ProcessBasicInformation";

			PROCESS_BASIC_INFORMATION_ pbi{};

			NTSTATUS status = pfnNtQueryInformationProcess(
				ProcessHandle,
				PROCESSINFOCLASS_::ProcessTelemetryIdInformation,
				&pbi,
				sizeof(PROCESS_BASIC_INFORMATION_),
				nullptr
			);

			pbi.UniqueProcessId = 1000;
			pbi.PebBaseAddress = (PPEB)ctx->m_PebBase;

			ProcessInformationLength = sizeof(PROCESS_BASIC_INFORMATION_);
			break;
		}
		case PROCESSINFOCLASS_::ProcessDebugPort:
		{
			szProcessInformationClass = "ProcessDebugPort";

			DWORD dbg = 0;
			uc_mem_write(uc, (DWORD_PTR)ProcessInformation, &dbg, sizeof(DWORD));
			ProcessInformationLength = sizeof(DWORD);
			break;
		}
		case PROCESSINFOCLASS_::ProcessWow64Information:
		{
			szProcessInformationClass = "ProcessWow64Information";
			PBOOL IsWow64 = nullptr;
			IsWow64Process(GetCurrentProcess(), IsWow64);

			uc_mem_write(uc, (DWORD_PTR)ProcessInformation, &IsWow64, sizeof(BOOL));
			ProcessInformationLength = sizeof(BOOL);

			break;
		}
		case PROCESSINFOCLASS_::ProcessImageFileName:
		{
			szProcessInformationClass = "ProcessImageFileName";

			uc_mem_write(uc, (DWORD_PTR)ProcessInformation, ctx->m_PathExe.wstring().data(), ctx->m_PathExe.wstring().size());
			ProcessInformationLength = (ULONG)ctx->m_PathExe.wstring().size();
			break;
		}
		case PROCESSINFOCLASS_::ProcessBreakOnTermination:
		{
			szProcessInformationClass = "ProcessBreakOnTermination";

			BOOLEAN breakOnTermination = FALSE;
			uc_mem_write(uc, (DWORD_PTR)ProcessInformation, &breakOnTermination, sizeof(BOOLEAN));
			ProcessInformationLength = sizeof(BOOLEAN);

			break;
		}
		case PROCESSINFOCLASS_::ProcessDebugObjectHandle:
		{
			szProcessInformationClass = "ProcessDebugObjectHandle";

			HANDLE DbgIsNotPresent = 0;
			uc_mem_write(uc, (DWORD_PTR)ProcessInformation, &DbgIsNotPresent, sizeof(HANDLE));
			ProcessInformationLength = sizeof(HANDLE);
			Return = STATUS_PORT_NOT_SET;
			break;
		}
		case PROCESSINFOCLASS_::ProcessDebugFlags:
		{
			szProcessInformationClass = "ProcessDebugFlags";

			DWORD DbgIsNotPresent = 1;
			uc_mem_write(uc, (DWORD_PTR)ProcessInformation, &DbgIsNotPresent, sizeof(DWORD));
			ProcessInformationLength = sizeof(DWORD);
			break;
		}
		case PROCESSINFOCLASS_::ProcessTelemetryIdInformation:
		{
			szProcessInformationClass = "ProcessTelemetryIdInformation";

			PROCESS_TELEMETRY_ID_INFORMATION ptii{};
			NTSTATUS status = pfnNtQueryInformationProcess(
				ProcessHandle,
				PROCESSINFOCLASS_::ProcessTelemetryIdInformation,
				&ptii,
				sizeof(PROCESS_TELEMETRY_ID_INFORMATION),
				nullptr
			);

			if (status == STATUS_SUCCESS) {
				uc_mem_write(uc, (DWORD_PTR)ProcessInformation, &ptii, sizeof(PROCESS_TELEMETRY_ID_INFORMATION));
				ProcessInformationLength = sizeof(PROCESS_TELEMETRY_ID_INFORMATION);
			}
			else {
				ProcessInformationLength = 0;
			}
			break;
		}
		case PROCESSINFOCLASS_::ProcessSubsystemInformation:
		{
			szProcessInformationClass = "ProcessSubsystemInformation";

			DWORD sit = SUBSYSTEM_INFORMATION_TYPE::SubsystemInformationTypeWin32;
			uc_mem_write(uc, (DWORD_PTR)ProcessInformation, &sit, sizeof(SUBSYSTEM_INFORMATION_TYPE));
			ProcessInformationLength = sizeof(DWORD);
			break;
		}
		}

		if (ReturnLength != nullptr) {
			uc_mem_write(uc, (DWORD_PTR)ReturnLength, &ProcessInformationLength, sizeof(ULONG));
		}

		*outs << "NtQueryInformationProcess" << " Process Handle: " << ProcessHandle << " ProcessInfoClass: " <<
			szProcessInformationClass << " Process Information: " << ProcessInformation
			<< " Process Information Length: " << ProcessInformationLength << " (PVOID)Return length: "
			<< ReturnLength << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuNtOpenFile(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PHANDLE FileHandle = nullptr;
		ACCESS_MASK DesiredAccess = 0;
		POBJECT_ATTRIBUTES ObjectAttributes = nullptr;
		PIO_STATUS_BLOCK IoStatusBlock = nullptr;
		ULONG ShareAccess = 0;
		ULONG OpenOptions = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&FileHandle, &DesiredAccess, &ObjectAttributes, &IoStatusBlock),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8, UC_X86_REG_R9 });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &ShareAccess, sizeof(ULONG));
		uc_mem_read(uc, (DWORD_PTR)SP + 0x30, &OpenOptions, sizeof(ULONG));

		DWORD_PTR Return = NtOpenFile(FileHandle, DesiredAccess, ObjectAttributes, IoStatusBlock, ShareAccess, OpenOptions);

		*outs << "NtOpenFile " << "FileHandle: " << FileHandle << " DesiredAccess: " << GetAccessMaskString(DesiredAccess) << " ObjectAttributes: " << ObjectAttributes
			<< " IoStatusBlock: " << IoStatusBlock << " ShareAccess: " << GetShareAccessString(ShareAccess) << " OpenOptions: " << GetOpenOptionsString(OpenOptions) << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuNtOpenSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PHANDLE SectionHandle = nullptr;
		HANDLE SectionHandle1 = nullptr;
		ACCESS_MASK DesiredAccess = 0;
		POBJECT_ATTRIBUTES ObjectAttributes = nullptr;
		OBJECT_ATTRIBUTES ObjectAttributes1{};
		NTSTATUS Status = STATUS_SUCCESS;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&SectionHandle, &DesiredAccess, &ObjectAttributes),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8 });

		HMODULE hNtdll = LoadLibraryA("ntdll.dll");
		auto NtOpenSection = (TNtOpenSection)GetProcAddress(
			hNtdll, "NtOpenSection");

		uc_mem_read(uc, (DWORD_PTR)ObjectAttributes, &ObjectAttributes1, sizeof(OBJECT_ATTRIBUTES));
		
		UNICODE_STRING ObjectName{};

		uc_mem_read(uc, (DWORD_PTR)(ObjectAttributes + offsetof(OBJECT_ATTRIBUTES, ObjectName)),
			&ObjectName, sizeof(UNICODE_STRING));

		Status = NtOpenSection(&SectionHandle1, DesiredAccess, &ObjectAttributes1);

		*outs << "NtOpenSection " << "SectionHandle: " << SectionHandle1 << " DesiredAccess:" << GetAccessMaskString(DesiredAccess)
			<< "return: " << Status << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Status);
	}

	void EmuGetLastError(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		auto err = uc_reg_write(uc, UC_X86_REG_RAX, &ctx->m_Win32LastError);

		*outs << "GetLastError return " << ctx->m_Win32LastError << "\n";
	}

	void EmuSetLastError(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD dwErrCode = 0;

		uc_reg_read(uc, UC_X86_REG_ECX, &dwErrCode);

		ctx->m_Win32LastError = dwErrCode;

		*outs << "SetLastError dwErrCode: " << dwErrCode << "\n";
	}

	void EmuInitializeCriticalSectionAndSpinCount(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		LPCRITICAL_SECTION lpCriticalSection = nullptr;
		DWORD dwSpinCount = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&lpCriticalSection, &dwSpinCount),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX });

		RTL_CRITICAL_SECTION_64 CrtSection;
		CrtSection.DebugInfo = 0;
		CrtSection.LockCount = 0;
		CrtSection.LockSemaphore = 0;
		CrtSection.OwningThread = 0;
		CrtSection.RecursionCount = 0;
		CrtSection.SpinCount = dwSpinCount;

		uc_mem_write(uc, (DWORD_PTR)lpCriticalSection, &CrtSection, sizeof(RTL_CRITICAL_SECTION_64));

		DWORD r = 1;

		uc_reg_write(uc, UC_X86_REG_EAX, &r);

		*outs << "InitializeCriticalSectionAndSpinCount " << lpCriticalSection << "\n";
	}

	void EmuInitializeCriticalSectionEx(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		LPCRITICAL_SECTION lpCriticalSection = nullptr;
		DWORD dwSpinCount = 0;
		DWORD Flags = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&lpCriticalSection, &dwSpinCount, &Flags),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8D });

		RTL_CRITICAL_SECTION_64 CrtSection;
		CrtSection.DebugInfo = 0;
		CrtSection.LockCount = 0;
		CrtSection.LockSemaphore = 0;
		CrtSection.OwningThread = 0;
		CrtSection.RecursionCount = 0;
		CrtSection.SpinCount = dwSpinCount;

		uc_mem_write(uc, (DWORD_PTR)lpCriticalSection, &CrtSection, sizeof(RTL_CRITICAL_SECTION_64));

		DWORD r = 1;

		uc_reg_write(uc, UC_X86_REG_EAX, &r);

		*outs << "InitializeCriticalSectionEx " << lpCriticalSection << "\n";
	}

	void EmuRtlEnterCriticalSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PRTL_CRITICAL_SECTION CriticalSection = nullptr;
		uc_reg_read(uc, UC_X86_REG_RCX, &CriticalSection);

		NTSTATUS Status = STATUS_SUCCESS;
		uc_reg_write(uc, UC_X86_REG_RAX, &Status);

		*outs << "RtlEnterCriticalSection " << "CriticalSection: " << CriticalSection << ", return: " << Status << "\n";
	}

	void EmuRtlLeaveCriticalSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PRTL_CRITICAL_SECTION CriticalSection = nullptr;
		uc_reg_read(uc, UC_X86_REG_RCX, &CriticalSection);

		NTSTATUS Status = STATUS_SUCCESS;
		uc_reg_write(uc, UC_X86_REG_RAX, &Status);

		*outs << "RtlLeaveCriticalSection " << "CriticalSection: " << CriticalSection << ", return: " << Status << "\n";
	}

	void EmuTlsAlloc(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		uint32_t Return = 0;
		_rdrand32_step(&Return);

		ctx->m_TlsValue.push_back(std::make_pair(Return, nullptr));

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);

		*outs << "TlsAlloc, return: " << Return << "\n";
	}

	void EmuTlsSetValue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR Return = true;

		DWORD dwTlsIndex = 0;
		uc_reg_read(uc, UC_X86_REG_ECX, &dwTlsIndex);

		LPVOID lpTlsValue = nullptr;
		uc_reg_read(uc, UC_X86_REG_RDX, &lpTlsValue);

		DWORD_PTR TlsValue = 0;
		uc_mem_read(uc, (DWORD_PTR)lpTlsValue, &TlsValue, sizeof(TlsValue));

		auto it = std::find_if(ctx->m_TlsValue.begin(), ctx->m_TlsValue.end(),
			[&dwTlsIndex](const std::pair<DWORD, LPVOID>& pair) {
				return pair.first == dwTlsIndex;
			});

		if (it == ctx->m_TlsValue.end()) {
			ctx->m_TlsValue.push_back(std::make_pair(dwTlsIndex, lpTlsValue));
		}
		else 
		{
			it->second = lpTlsValue;
		}
		uc_reg_write(uc, UC_X86_REG_RAX, &Return);

		*outs << "TlsSetValue " << "dwTlsIndex: " << dwTlsIndex << " TlsValue: " << TlsValue << ", return: " << Return << "\n";
	}

	void EmuTlsGetValue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD dwTlsIndex = 0;
		uc_reg_read(uc, UC_X86_REG_ECX, &dwTlsIndex);

		auto it = std::find_if(ctx->m_TlsValue.begin(), ctx->m_TlsValue.end(),
			[&dwTlsIndex](const std::pair<DWORD, LPVOID>& pair) {
				return pair.first == dwTlsIndex;
			});

		LPVOID lpTlsValue = nullptr;
		DWORD_PTR TlsValue = 0;
		if (it != ctx->m_TlsValue.end()) {
			uc_mem_read(uc, (DWORD_PTR)it->second, &TlsValue, sizeof(TlsValue));
			lpTlsValue = it->second;
		}

		uc_reg_write(uc, UC_X86_REG_RAX, &lpTlsValue);

		*outs << "TlsGetValue " << "dwTlsIndex: " << dwTlsIndex << ", return: " << TlsValue << "\n";
	}

	void EmuTlsFree(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR Return = true;

		DWORD dwTlsIndex = 0;
		uc_reg_read(uc, UC_X86_REG_ECX, &dwTlsIndex);

		ctx->m_TlsValue.remove_if([&](auto& pair) {
			return pair.first == dwTlsIndex;
			});

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);

		*outs << "TlsFree, return: " << dwTlsIndex << "\n";
	}

	void EmuFlsAlloc(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{

	}

	void EmuFlsSetValue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{

	}

	void EmuFlsGetValue(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{

	}

	void EmuFlsFree(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{

	}

	void EmuDeleteCriticalSection(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		LPCRITICAL_SECTION lpCriticalSection = nullptr;
		uc_reg_read(uc, UC_X86_REG_RCX, &lpCriticalSection);

		RTL_CRITICAL_SECTION_64 CrtSection;
		CrtSection.DebugInfo = 0;
		CrtSection.LockCount = 0;
		CrtSection.LockSemaphore = 0;
		CrtSection.OwningThread = 0;
		CrtSection.RecursionCount = 0;
		CrtSection.SpinCount = 0;

		uc_mem_write(uc, (DWORD_PTR)lpCriticalSection, &CrtSection, sizeof(RTL_CRITICAL_SECTION_64));

		*outs << "DeleteCriticalSection " << lpCriticalSection << "\n";
	}

	void EmuHeapValidate(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		BOOL Return = true;
		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuRtlAllocateHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR alloc = 0;
		PVOID HeapHandle = nullptr;
		ULONG Flags = 0;
		SIZE_T Size = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&HeapHandle, &Flags, &Size),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8 });

		if (HeapHandle != nullptr)
		{
			alloc = ctx->HeapAlloc(Size);

			if (Flags & HEAP_ZERO_MEMORY)
			{
				BYTE Zero = 0x00;
				for (size_t Index = 0; Index < Size; ++Index)
				{
					uc_mem_write(uc, alloc + Index, &Zero, sizeof(Zero));
				}
			}
		}
		*outs << "RtlAllocateHeap " << "HeapHandle: " << HeapHandle << " Flags: "
			<< GetFlagsRtlAllocateHeap(Flags) << " Size: " << Size << ", return: " << std::hex << alloc << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &alloc);
	}

	void EmuRtlFreeHeap(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		PVOID HeapHandle = nullptr;
		ULONG Flags = 0;
		PVOID BaseAddress = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&HeapHandle, &Flags, &BaseAddress),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8 });
		BOOL Return = false;
		if (HeapHandle != nullptr)
		{
			Return = ctx->HeapFree((DWORD_PTR)BaseAddress);
		}

		*outs << "RtlFreeHeap " << "HeapHandle: " << HeapHandle << " Flags: " 
			<< GetFlagsRtlAllocateHeap(Flags) << " BaseAddress: " << BaseAddress << ", return: " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuLocalAlloc(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR alloc = 0;
		UINT uFlags = 0;
		DWORD uBytes = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&uFlags, &uBytes),
			{ UC_X86_REG_ECX, UC_X86_REG_EDX });

		if (uFlags == LMEM_FIXED)
		{
			alloc = ctx->HeapAlloc(uBytes);
		}
		else if (uFlags == LPTR || uFlags == LMEM_ZEROINIT)
		{
			alloc = ctx->HeapAlloc(uBytes);
			BYTE Zero = 0x00;
			for (size_t Index = 0; Index < uBytes; ++Index)
			{
				uc_mem_write(uc, alloc, &Zero, sizeof(Zero));
			}
		}

		*outs << "LocalAlloc " << uBytes << " bytes, allocated at " << std::hex << alloc << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &alloc);
	}

	void EmuLocalFree(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		HLOCAL hMem = nullptr;
		uc_reg_read(uc, UC_X86_REG_RCX, &hMem);

		HLOCAL Return = nullptr;

		BOOL Result = ctx->HeapFree((DWORD_PTR)hMem);
		if (!Result) { Return = hMem; }

		*outs << "LocalFree, free at " << std::hex << hMem << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuRtlIsProcessorFeaturePresent(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		uint8_t al = 0;

		DWORD ProcessorFeature = 0;
		uc_reg_read(uc, UC_X86_REG_ECX, &ProcessorFeature);

		if (ProcessorFeature == 0x1C)
		{
			al = 0;
		}
		else
		{
			al = IsProcessorFeaturePresent(ProcessorFeature);
		}

		*outs << "RtlIsProcessorFeaturePresent feature " << ProcessorFeature << "\n";

		uc_reg_write(uc, UC_X86_REG_AL, &al);
	}

	void EmuGetProcessAffinityMask(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HANDLE hProcess = nullptr;
		PDWORD_PTR lpProcessAffinityMask = nullptr;
		PDWORD_PTR lpSystemAffinityMask = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hProcess, &lpProcessAffinityMask, &lpSystemAffinityMask),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8 });

		DWORD_PTR ProcessAffinityMask = 0;
		DWORD_PTR SystemAffinityMask = 0;

		BOOL Return = GetProcessAffinityMask(hProcess, &ProcessAffinityMask, &SystemAffinityMask);

		uc_mem_write(uc, (DWORD_PTR)lpProcessAffinityMask, &ProcessAffinityMask, sizeof(ProcessAffinityMask));
		uc_mem_write(uc, (DWORD_PTR)lpSystemAffinityMask, &SystemAffinityMask, sizeof(SystemAffinityMask));

		*outs << "GetProcessAffinityMask " << "hProcess: " << hProcess << " ProcessAffinityMask: " << ProcessAffinityMask
			<< " SystemAffinityMask: " << SystemAffinityMask << ", return:" << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuSetThreadAffinityMask(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		HANDLE hThread = nullptr;
		DWORD_PTR dwThreadAffinityMask = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&hThread, &dwThreadAffinityMask),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX });

		DWORD_PTR Return = SetThreadAffinityMask(hThread, dwThreadAffinityMask);

		*outs << "SetThreadAffinityMask " << "hThread: " << hThread << " dwThreadAffinityMask: "
			<< dwThreadAffinityMask << ", return: " << Return << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &Return);
	}

	void EmuSleep(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		DWORD dwMilliseconds = 0;

		uc_reg_read(uc, UC_X86_REG_ECX, &dwMilliseconds);

		Sleep(dwMilliseconds);

		*outs << "Sleep " << "dwMilliseconds: " << dwMilliseconds << "\n";

		DWORD_PTR Zero = 0;
		uc_reg_write(uc, UC_X86_REG_RAX, &Zero);
	}

	void EmuExAllocatePool(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR alloc = 0;

		DWORD PoolType = 0;
		DWORD NumberOfBytes = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&PoolType, &NumberOfBytes),
			{ UC_X86_REG_ECX, UC_X86_REG_EDX });

		alloc = ctx->HeapAlloc(NumberOfBytes, NumberOfBytes >= PAGE_SIZE);

		*outs << "ExAllocatePool " << NumberOfBytes << " bytes, allocated at " << std::hex << alloc << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &alloc);
	}

	void EmuNtProtectVirtualMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		HANDLE ProcessHandle = nullptr;
		PVOID aBaseAddress = nullptr;
		PULONG NumberOfBytesToProtect = nullptr;
		ULONG NewAccessProtection = 0;
		PULONG OldAccessProtection = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&ProcessHandle, &aBaseAddress, &NumberOfBytesToProtect, &NewAccessProtection),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8, UC_X86_REG_R9D });

		DWORD_PTR SP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &SP);
		uc_mem_read(uc, (DWORD_PTR)SP + 0x28, &OldAccessProtection, sizeof(PULONG));

		DWORD_PTR oldprot;
		uc_mem_read(uc, (DWORD_PTR)OldAccessProtection + 5 * 8, &oldprot, sizeof(oldprot));

		NTSTATUS status;

		if (ProcessHandle == INVALID_HANDLE_VALUE)
		{
			DWORD_PTR RequestAddress, BaseAddress, EndAddress;
			DWORD NumberOfBytes;

			uc_mem_read(uc, (DWORD_PTR)aBaseAddress, &RequestAddress, sizeof(BaseAddress));
			uc_mem_read(uc, (DWORD_PTR)NumberOfBytesToProtect, &NumberOfBytes, sizeof(NumberOfBytes));

			EndAddress = RequestAddress + NumberOfBytes - 1;
			BaseAddress = PAGE_ALIGN(RequestAddress);
			EndAddress = AlignSize(EndAddress, PAGE_SIZE);

			int prot = 0;

			if (NewAccessProtection == PAGE_EXECUTE_READWRITE)
				prot = UC_PROT_ALL;
			else if (NewAccessProtection == PAGE_EXECUTE_READ)
				prot = (UC_PROT_READ | UC_PROT_EXEC);
			else if (NewAccessProtection == PAGE_READWRITE)
				prot = (UC_PROT_READ | UC_PROT_WRITE);
			else if (NewAccessProtection == PAGE_READONLY)
				prot = UC_PROT_READ;
			else
				status = STATUS_INVALID_PARAMETER;

			if (prot != 0)
			{
				uc_mem_region* regions;
				uint32_t count;
				uc_mem_regions(uc, &regions, &count);

				for (uint32_t i = 0; i < count; ++i)
				{
					if (regions[i].begin <= BaseAddress && regions[i].end >= BaseAddress)
					{
						if (regions[i].perms == UC_PROT_ALL)
							oldprot = PAGE_EXECUTE_READWRITE;
						else if (regions[i].perms == (UC_PROT_READ | UC_PROT_EXEC))
							oldprot = PAGE_EXECUTE_READ;
						else if (regions[i].perms == (UC_PROT_READ | UC_PROT_WRITE))
							oldprot = PAGE_READWRITE;
						else if (regions[i].perms == UC_PROT_READ)
							oldprot = PAGE_READONLY;

						break;
					}
				}
				uc_free(regions);

				uc_mem_write(uc, (DWORD_PTR)OldAccessProtection + 5 * 8, &oldprot, sizeof(oldprot));

				auto err = uc_mem_protect(uc, BaseAddress, EndAddress - BaseAddress, prot);

				if (err == UC_ERR_OK)
					status = STATUS_SUCCESS;
				else
					status = STATUS_INVALID_PARAMETER;

				*outs << "NtProtectVirtualMemory at " << RequestAddress;

				std::stringstream region;
				if (ctx->FindAddressInRegion(RequestAddress, region))
					*outs << " (" << region.str() << ")";
				*outs << ", size " << NumberOfBytes << " bytes, return " << std::hex << status << "\n";
			}
		}
		else
		{
			status = STATUS_INVALID_HANDLE;
		}

		uc_reg_write(uc, UC_X86_REG_EAX, &status);
	}

	void EmuNtQuerySystemInformation(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		SYSTEM_INFORMATION_CLASS SystemInformationClass = SystemBasicInformation;
		PVOID SystemInformation = nullptr;
		ULONG SystemInformationLength = 0;
		PULONG ReturnLength = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&SystemInformationClass, &SystemInformation, &SystemInformationLength, &ReturnLength),
			{ UC_X86_REG_ECX, UC_X86_REG_RDX, UC_X86_REG_R8D, UC_X86_REG_R9});

		char* buf = (char*)malloc(SystemInformationLength);
		memset(buf, 0, SystemInformationLength);

		ULONG retlen = 0;

		auto rax = (DWORD_PTR)NtQuerySystemInformation(SystemInformationClass, buf, SystemInformationLength, &retlen);

		if (SystemInformationClass == SystemModuleInformation)
			retlen += sizeof(RTL_PROCESS_MODULE_INFORMATION);

		if (SystemInformationClass == SystemFirmwareTableInformation)
		{
			retlen = 0;
			rax = STATUS_ACCESS_DENIED;
		}

		if (rax == STATUS_INFO_LENGTH_MISMATCH)
		{

		}
		else if (rax == STATUS_SUCCESS)
		{
			/*if (SystemInformationClass == SystemModuleInformation)
			{
				auto pMods = (PRTL_PROCESS_MODULES)buf;
				PRTL_PROCESS_MODULES newMods = (PRTL_PROCESS_MODULES)malloc(SystemInformationLength);
				memset(newMods, 0, SystemInformationLength);

				ULONG numberNewMods = 0;
				for (ULONG i = 0; i < pMods->NumberOfModules; i++)
				{
					PCHAR modname = (PCHAR)pMods->Modules[i].FullPathName + pMods->Modules[i].OffsetToFileName;
					std::wstring wModName;
					ANSIToUnicode(modname, wModName);

					ULONG64 ImageBase = 0;
					ULONG ImageSize = 0;
					auto stFind = ctx->LdrFindDllByName(wModName, &ImageBase, (size_t*)&ImageSize, false);
					if (stFind == STATUS_SUCCESS)
					{
						memcpy(&newMods->Modules[numberNewMods], &pMods->Modules[i], sizeof(pMods->Modules[i]));
						newMods->Modules[numberNewMods].ImageBase = (PVOID)ImageBase;
						newMods->Modules[numberNewMods].ImageSize = ImageSize;
						numberNewMods++;
					}
				}
				newMods->Modules[numberNewMods].ImageBase = (PVOID)ctx->m_ImageBase;
				newMods->Modules[numberNewMods].ImageSize = (ULONG)(ctx->m_ImageEnd - ctx->m_ImageBase);
				newMods->Modules[numberNewMods].LoadCount = 1;
				newMods->Modules[numberNewMods].LoadOrderIndex = newMods->Modules[numberNewMods - 1].LoadOrderIndex + 1;
				numberNewMods++;

				newMods->NumberOfModules = numberNewMods;

				retlen = offsetof(RTL_PROCESS_MODULES, Modules) + sizeof(newMods->Modules[0]) * numberNewMods;

				uc_mem_write(uc, (DWORD_PTR)SystemInformation, newMods, retlen);

				free(newMods);

			}*/
			if (SystemInformationClass == SystemKernelDebuggerInformation)
			{
				SYSTEM_KERNEL_DEBUGGER_INFORMATION info;
				info.DebuggerEnabled = FALSE;
				info.DebuggerNotPresent = TRUE;
				uc_mem_write(uc, (DWORD_PTR)SystemInformation, &info, sizeof(info));
			}
		}

		if (ReturnLength != nullptr)
		{
			uc_mem_write(uc, (DWORD_PTR)ReturnLength, &retlen, sizeof(retlen));
		}

		free(buf);

		std::string szSystemInformationClass;

		switch (SystemInformationClass)
		{
		case SystemProcessorInformation:
			szSystemInformationClass = "SystemProcessorInformation";
			break;
		case SystemPathInformation:
			szSystemInformationClass = "SystemPathInformation";
			break;
		case SystemCallCountInformation:
			szSystemInformationClass = "SystemCallCountInformation";
			break;
		case SystemDeviceInformation:
			szSystemInformationClass = "SystemDeviceInformation";
			break;
		case SystemFlagsInformation:
			szSystemInformationClass = "SystemFlagsInformation";
			break;
		case SystemCallTimeInformation:
			szSystemInformationClass = "SystemCallTimeInformation";
			break;
		case SystemModuleInformation:
			szSystemInformationClass = "SystemModuleInformation";
			break;
		case SystemLocksInformation:
			szSystemInformationClass = "SystemLocksInformation";
			break;
		case SystemStackTraceInformation:
			szSystemInformationClass = "SystemStackTraceInformation";
			break;
		case SystemPagedPoolInformation:
			szSystemInformationClass = "SystemPagedPoolInformation";
			break;
		case SystemNonPagedPoolInformation:
			szSystemInformationClass = "SystemNonPagedPoolInformation";
			break;
		case SystemHandleInformation:
			szSystemInformationClass = "SystemHandleInformation";
			break;
		case SystemObjectInformation:
			szSystemInformationClass = "SystemObjectInformation";
			break;
		case SystemPageFileInformation:
			szSystemInformationClass = "SystemPageFileInformation";
			break;
		case SystemVdmInstemulInformation:
			szSystemInformationClass = "SystemVdmInstemulInformation";
			break;
		case SystemVdmBopInformation:
			szSystemInformationClass = "SystemVdmBopInformation";
			break;
		case SystemFileCacheInformation:
			szSystemInformationClass = "SystemFileCacheInformation";
			break;
		case SystemPoolTagInformation:
			szSystemInformationClass = "SystemPoolTagInformation";
			break;
		case SystemDpcBehaviorInformation:
			szSystemInformationClass = "SystemDpcBehaviorInformation";
			break;
		case SystemFullMemoryInformation:
			szSystemInformationClass = "SystemFullMemoryInformation";
			break;
		case SystemLoadGdiDriverInformation:
			szSystemInformationClass = "SystemLoadGdiDriverInformation";
			break;
		case SystemUnloadGdiDriverInformation:
			szSystemInformationClass = "SystemUnloadGdiDriverInformation";
			break;
		case SystemTimeAdjustmentInformation:
			szSystemInformationClass = "SystemTimeAdjustmentInformation";
			break;
		case SystemSummaryMemoryInformation:
			szSystemInformationClass = "SystemSummaryMemoryInformation";
			break;
		case SystemMirrorMemoryInformation:
			szSystemInformationClass = "SystemMirrorMemoryInformation";
			break;
		case SystemPerformanceTraceInformation:
			szSystemInformationClass = "SystemPerformanceTraceInformation";
			break;
		case SystemObsolete0:
			szSystemInformationClass = "SystemObsolete0";
			break;
		case SystemCrashDumpStateInformation:
			szSystemInformationClass = "SystemCrashDumpStateInformation";
			break;
		case SystemKernelDebuggerInformation:
			szSystemInformationClass = "SystemKernelDebuggerInformation";
			break;
		case SystemContextSwitchInformation:
			szSystemInformationClass = "SystemContextSwitchInformation";
			break;
		case SystemExtendServiceTableInformation:
			szSystemInformationClass = "SystemExtendServiceTableInformation";
			break;
		case SystemPrioritySeperation:
			szSystemInformationClass = "SystemPrioritySeperation";
			break;
		case SystemVerifierAddDriverInformation:
			szSystemInformationClass = "SystemVerifierAddDriverInformation";
			break;
		case SystemVerifierRemoveDriverInformation:
			szSystemInformationClass = "SystemVerifierRemoveDriverInformation";
			break;
		case SystemProcessorIdleInformation:
			szSystemInformationClass = "SystemProcessorIdleInformation";
			break;
		case SystemLegacyDriverInformation:
			szSystemInformationClass = "SystemLegacyDriverInformation";
			break;
		case SystemCurrentTimeZoneInformation:
			szSystemInformationClass = "SystemCurrentTimeZoneInformation";
			break;
		case SystemTimeSlipNotification:
			szSystemInformationClass = "SystemTimeSlipNotification";
			break;
		case SystemSessionCreate:
			szSystemInformationClass = "SystemSessionCreate";
			break;
		case SystemSessionDetach:
			szSystemInformationClass = "SystemSessionDetach";
			break;
		case SystemSessionInformation:
			szSystemInformationClass = "SystemSessionInformation";
			break;
		case SystemRangeStartInformation:
			szSystemInformationClass = "SystemRangeStartInformation";
			break;
		case SystemVerifierInformation:
			szSystemInformationClass = "SystemVerifierInformation";
			break;
		case SystemVerifierThunkExtend:
			szSystemInformationClass = "SystemVerifierThunkExtend";
			break;
		case SystemSessionProcessInformation:
			szSystemInformationClass = "SystemSessionProcessInformation";
			break;
		case SystemLoadGdiDriverInSystemSpace:
			szSystemInformationClass = "SystemLoadGdiDriverInSystemSpace";
			break;
		case SystemNumaProcessorMap:
			szSystemInformationClass = "SystemNumaProcessorMap";
			break;
		case SystemPrefetcherInformation:
			szSystemInformationClass = "SystemPrefetcherInformation";
			break;
		case SystemExtendedProcessInformation:
			szSystemInformationClass = "SystemExtendedProcessInformation";
			break;
		case SystemRecommendedSharedDataAlignment:
			szSystemInformationClass = "SystemRecommendedSharedDataAlignment";
			break;
		case SystemComPlusPackage:
			szSystemInformationClass = "SystemComPlusPackage";
			break;
		case SystemNumaAvailableMemory:
			szSystemInformationClass = "SystemNumaAvailableMemory";
			break;
		case SystemProcessorPowerInformation:
			szSystemInformationClass = "SystemProcessorPowerInformation";
			break;
		case SystemEmulationBasicInformation:
			szSystemInformationClass = "SystemEmulationBasicInformation";
			break;
		case SystemEmulationProcessorInformation:
			szSystemInformationClass = "SystemEmulationProcessorInformation";
			break;
		case SystemExtendedHandleInformation:
			szSystemInformationClass = "SystemExtendedHandleInformation";
			break;
		case SystemLostDelayedWriteInformation:
			szSystemInformationClass = "SystemLostDelayedWriteInformation";
			break;
		case SystemBigPoolInformation:
			szSystemInformationClass = "SystemBigPoolInformation";
			break;
		case SystemSessionPoolTagInformation:
			szSystemInformationClass = "SystemSessionPoolTagInformation";
			break;
		case SystemSessionMappedViewInformation:
			szSystemInformationClass = "SystemSessionMappedViewInformation";
			break;
		case SystemHotpatchInformation:
			szSystemInformationClass = "SystemHotpatchInformation";
			break;
		case SystemObjectSecurityMode:
			szSystemInformationClass = "SystemObjectSecurityMode";
			break;
		case SystemWatchdogTimerHandler:
			szSystemInformationClass = "SystemWatchdogTimerHandler";
			break;
		case SystemWatchdogTimerInformation:
			szSystemInformationClass = "SystemWatchdogTimerInformation";
			break;
		case SystemLogicalProcessorInformation:
			szSystemInformationClass = "SystemLogicalProcessorInformation";
			break;
		case SystemWow64SharedInformationObsolete:
			szSystemInformationClass = "SystemWow64SharedInformationObsolete";
			break;
		case SystemRegisterFirmwareTableInformationHandler:
			szSystemInformationClass = "SystemRegisterFirmwareTableInformationHandler";
			break;
		case SystemFirmwareTableInformation:
			szSystemInformationClass = "SystemFirmwareTableInformation";
			break;
		case SystemModuleInformationEx:
			szSystemInformationClass = "SystemModuleInformationEx";
			break;
		case SystemVerifierTriageInformation:
			szSystemInformationClass = "SystemVerifierTriageInformation";
			break;
		case SystemSuperfetchInformation:
			szSystemInformationClass = "SystemSuperfetchInformation";
			break;
		case SystemMemoryListInformation:
			szSystemInformationClass = "SystemMemoryListInformation";
			break;
		case SystemFileCacheInformationEx:
			szSystemInformationClass = "SystemFileCacheInformationEx";
			break;
		case SystemThreadPriorityClientIdInformation:
			szSystemInformationClass = "SystemThreadPriorityClientIdInformation";
			break;
		case SystemProcessorIdleCycleTimeInformation:
			szSystemInformationClass = "SystemProcessorIdleCycleTimeInformation";
			break;
		case SystemVerifierCancellationInformation:
			szSystemInformationClass = "SystemVerifierCancellationInformation";
			break;
		case SystemProcessorPowerInformationEx:
			szSystemInformationClass = "SystemProcessorPowerInformationEx";
			break;
		case SystemRefTraceInformation:
			szSystemInformationClass = "SystemRefTraceInformation";
			break;
		case SystemSpecialPoolInformation:
			szSystemInformationClass = "SystemSpecialPoolInformation";
			break;
		case SystemProcessIdInformation:
			szSystemInformationClass = "SystemProcessIdInformation";
			break;
		case SystemErrorPortInformation:
			szSystemInformationClass = "SystemErrorPortInformation";
			break;
		case SystemBootEnvironmentInformation:
			szSystemInformationClass = "SystemBootEnvironmentInformation";
			break;
		case SystemHypervisorInformation:
			szSystemInformationClass = "SystemHypervisorInformation";
			break;
		case SystemVerifierInformationEx:
			szSystemInformationClass = "SystemVerifierInformationEx";
			break;
		case SystemTimeZoneInformation:
			szSystemInformationClass = "SystemTimeZoneInformation";
			break;
		case SystemImageFileExecutionOptionsInformation:
			szSystemInformationClass = "SystemImageFileExecutionOptionsInformation";
			break;
		case SystemCoverageInformation:
			szSystemInformationClass = "SystemCoverageInformation";
			break;
		case SystemPrefetchPatchInformation:
			szSystemInformationClass = "SystemPrefetchPatchInformation";
			break;
		case SystemVerifierFaultsInformation:
			szSystemInformationClass = "SystemVerifierFaultsInformation";
			break;
		case SystemSystemPartitionInformation:
			szSystemInformationClass = "SystemSystemPartitionInformation";
			break;
		case SystemSystemDiskInformation:
			szSystemInformationClass = "SystemSystemDiskInformation";
			break;
		case SystemProcessorPerformanceDistribution:
			szSystemInformationClass = "SystemProcessorPerformanceDistribution";
			break;
		case SystemNumaProximityNodeInformation:
			szSystemInformationClass = "SystemNumaProximityNodeInformation";
			break;
		case SystemDynamicTimeZoneInformation:
			szSystemInformationClass = "SystemDynamicTimeZoneInformation";
			break;
		case SystemCodeIntegrityInformation_:
			szSystemInformationClass = "SystemCodeIntegrityInformation_";
			break;
		case SystemProcessorMicrocodeUpdateInformation:
			szSystemInformationClass = "SystemProcessorMicrocodeUpdateInformation";
			break;
		case SystemProcessorBrandString:
			szSystemInformationClass = "SystemProcessorBrandString";
			break;
		case SystemVirtualAddressInformation:
			szSystemInformationClass = "SystemVirtualAddressInformation";
			break;
		case SystemLogicalProcessorAndGroupInformation:
			szSystemInformationClass = "SystemLogicalProcessorAndGroupInformation";
			break;
		case SystemProcessorCycleTimeInformation:
			szSystemInformationClass = "SystemProcessorCycleTimeInformation";
			break;
		case SystemStoreInformation:
			szSystemInformationClass = "SystemStoreInformation";
			break;
		case SystemRegistryAppendString:
			szSystemInformationClass = "SystemRegistryAppendString";
			break;
		case SystemAitSamplingValue:
			szSystemInformationClass = "SystemAitSamplingValue";
			break;
		case SystemVhdBootInformation:
			szSystemInformationClass = "SystemVhdBootInformation";
			break;
		case SystemCpuQuotaInformation:
			szSystemInformationClass = "SystemCpuQuotaInformation";
			break;
		case SystemNativeBasicInformation:
			szSystemInformationClass = "SystemNativeBasicInformation";
			break;
		case SystemErrorPortTimeouts:
			szSystemInformationClass = "SystemErrorPortTimeouts";
			break;
		case SystemLowPriorityIoInformation:
			szSystemInformationClass = "SystemLowPriorityIoInformation";
			break;
		case SystemBootEntropyInformation:
			szSystemInformationClass = "SystemBootEntropyInformation";
			break;
		case SystemVerifierCountersInformation:
			szSystemInformationClass = "SystemVerifierCountersInformation";
			break;
		case SystemPagedPoolInformationEx:
			szSystemInformationClass = "SystemPagedPoolInformationEx";
			break;
		case SystemSystemPtesInformationEx:
			szSystemInformationClass = "SystemSystemPtesInformationEx";
			break;
		case SystemNodeDistanceInformation:
			szSystemInformationClass = "SystemNodeDistanceInformation";
			break;
		case SystemAcpiAuditInformation:
			szSystemInformationClass = "SystemAcpiAuditInformation";
			break;
		case SystemBasicPerformanceInformation:
			szSystemInformationClass = "SystemBasicPerformanceInformation";
			break;
		case SystemQueryPerformanceCounterInformation:
			szSystemInformationClass = "SystemQueryPerformanceCounterInformation";
			break;
		case SystemSessionBigPoolInformation:
			szSystemInformationClass = "SystemSessionBigPoolInformation";
			break;
		case SystemBootGraphicsInformation:
			szSystemInformationClass = "SystemBootGraphicsInformation";
			break;
		case SystemScrubPhysicalMemoryInformation:
			szSystemInformationClass = "SystemScrubPhysicalMemoryInformation";
			break;
		case SystemBadPageInformation:
			szSystemInformationClass = "SystemBadPageInformation";
			break;
		case SystemProcessorProfileControlArea:
			szSystemInformationClass = "SystemProcessorProfileControlArea";
			break;
		case SystemCombinePhysicalMemoryInformation:
			szSystemInformationClass = "SystemCombinePhysicalMemoryInformation";
			break;
		case SystemEntropyInterruptTimingInformation:
			szSystemInformationClass = "SystemEntropyInterruptTimingInformation";
			break;
		case SystemConsoleInformation:
			szSystemInformationClass = "SystemConsoleInformation";
			break;
		case SystemPlatformBinaryInformation:
			szSystemInformationClass = "SystemPlatformBinaryInformation";
			break;
		case SystemThrottleNotificationInformation:
			szSystemInformationClass = "SystemThrottleNotificationInformation";
			break;
		case SystemHypervisorProcessorCountInformation:
			szSystemInformationClass = "SystemHypervisorProcessorCountInformation";
			break;
		case SystemDeviceDataInformation:
			szSystemInformationClass = "SystemDeviceDataInformation";
			break;
		case SystemDeviceDataEnumerationInformation:
			szSystemInformationClass = "SystemDeviceDataEnumerationInformation";
			break;
		case SystemMemoryTopologyInformation:
			szSystemInformationClass = "SystemMemoryTopologyInformation";
			break;
		case SystemMemoryChannelInformation:
			szSystemInformationClass = "SystemMemoryChannelInformation";
			break;
		case SystemBootLogoInformation:
			szSystemInformationClass = "SystemBootLogoInformation";
			break;
		case SystemProcessorPerformanceInformationEx:
			szSystemInformationClass = "SystemProcessorPerformanceInformationEx";
			break;
		case SystemSpare0:
			szSystemInformationClass = "SystemSpare0";
			break;
		case SystemSecureBootPolicyInformation:
			szSystemInformationClass = "SystemSecureBootPolicyInformation";
			break;
		case SystemPageFileInformationEx:
			szSystemInformationClass = "SystemPageFileInformationEx";
			break;
		case SystemSecureBootInformation:
			szSystemInformationClass = "SystemSecureBootInformation";
			break;
		case SystemEntropyInterruptTimingRawInformation:
			szSystemInformationClass = "SystemEntropyInterruptTimingRawInformation";
			break;
		case SystemPortableWorkspaceEfiLauncherInformation:
			szSystemInformationClass = "SystemPortableWorkspaceEfiLauncherInformation";
			break;
		case SystemFullProcessInformation:
			szSystemInformationClass = "SystemFullProcessInformation";
			break;
		case SystemKernelDebuggerInformationEx:
			szSystemInformationClass = "SystemKernelDebuggerInformationEx";
			break;
		case SystemBootMetadataInformation:
			szSystemInformationClass = "SystemBootMetadataInformation";
			break;
		case SystemSoftRebootInformation:
			szSystemInformationClass = "SystemSoftRebootInformation";
			break;
		case SystemElamCertificateInformation:
			szSystemInformationClass = "SystemElamCertificateInformation";
			break;
		case SystemOfflineDumpConfigInformation:
			szSystemInformationClass = "SystemOfflineDumpConfigInformation";
			break;
		case SystemProcessorFeaturesInformation:
			szSystemInformationClass = "SystemProcessorFeaturesInformation";
			break;
		case SystemRegistryReconciliationInformation:
			szSystemInformationClass = "SystemRegistryReconciliationInformation";
			break;
		case SystemKernelVaShadowInformation:
			szSystemInformationClass = "SystemKernelVaShadowInformation";
			break;
		case MaxSystemInfoClass:
			szSystemInformationClass = "MaxSystemInfoClass";
			break;
		}

		*outs << "NtQuerySystemInformation  " << "SystemInformationClass: " << szSystemInformationClass
			<< " SystemInformation: " << SystemInformation << " SystemInformationLength: " << SystemInformationLength
			<< " ReturnLength: " << ReturnLength << " return " << std::hex << rax << "\n";

		//VMProtect 2.x use rax as ntstatus result 
		uc_reg_write(uc, UC_X86_REG_RAX, &rax);
	}

	void EmuExFreePool(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR rcx;
		auto err = uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		if (!ctx->HeapFree(rcx))
			*outs << "ExFreePool failed to free " << std::hex << rcx << "\n";
		else
			*outs << "ExFreePool free " << std::hex << rcx << "\n";
	}

	void EmuExFreePoolWithTag(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		PVOID P = nullptr;
		ULONG Tag = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&P, &Tag),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX});

		if (!ctx->HeapFree((DWORD_PTR)P))
			*outs << "ExFreePoolWithTag failed to free " << std::hex << P << "\n";
		else
			*outs << "ExFreePoolWithTag free " << std::hex << P << "\n";
	}

	void EmuIoAllocateMdl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR rcx;
		uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		uint32_t edx;
		uc_reg_read(uc, UC_X86_REG_EDX, &edx);

		DWORD_PTR mdl_base = ctx->HeapAlloc(sizeof(MDL));

		MDL mdl = { 0 };
		mdl.Size = sizeof(MDL);
		mdl.ByteCount = edx;
		mdl.StartVa = (PVOID)rcx;
		uc_mem_write(uc, mdl_base, &mdl, sizeof(mdl));

		uc_reg_write(uc, UC_X86_REG_RAX, &mdl_base);

		*outs << "IoAllocateMdl va " << std::hex << rcx << ", len " << std::dec << edx << ", return mdl " << std::hex << mdl_base << "\n";
	}

	void EmuMmProbeAndLockPages(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PMDL MemoryDescriptorList = nullptr;
		uint32_t AccessMode = 0;
		uint32_t Operation = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&MemoryDescriptorList, &AccessMode, &Operation),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX, UC_X86_REG_R8D});

		*outs << "MmProbeAndLockPages mdl " << std::hex << MemoryDescriptorList << ", AccessMode " << std::dec << AccessMode << ", Operation " << std::dec << Operation << "\n";
	}

	void EmuMmMapLockedPagesSpecifyCache(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR rcx;
		uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		uint32_t edx;
		uc_reg_read(uc, UC_X86_REG_EDX, &edx);

		uint32_t r8d;
		uc_reg_read(uc, UC_X86_REG_R8D, &r8d);

		DWORD_PTR r9;
		uc_reg_read(uc, UC_X86_REG_R9, &r9);

		MDL mdl = { 0 };
		uc_mem_read(uc, rcx, &mdl, sizeof(mdl));

		DWORD_PTR alloc = ctx->HeapAlloc(mdl.ByteCount, true);

		mdl.MappedSystemVa = (PVOID)alloc;
		uc_mem_write(uc, rcx, &mdl, sizeof(mdl));

		ctx->CreateMemMapping((ULONG64)mdl.StartVa, (ULONG64)mdl.MappedSystemVa, mdl.ByteCount);

		*outs << "MmMapLockedPagesSpecifyCache mdl " << std::hex << rcx << ", AccessMode " << std::dec << edx <<
			", CacheType " << std::dec << r8d << ", RequestedAddress " << std::hex << r9 << "\n";
		*outs << "return va " << std::hex << alloc << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &alloc);
	}

	void EmuKeQueryActiveProcessors(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR ret = 1;

		*outs << "KeQueryActiveProcessors return " << std::dec << ret << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &ret);
	}

	void EmuKeSetSystemAffinityThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR rcx;
		uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		*outs << "KeSetSystemAffinityThread Affinity " << std::hex << rcx << "\n";
	}

	void EmuKeRevertToUserAffinityThread(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		*outs << "KeRevertToUserAffinityThread\n";
	}

	void EmuMmUnlockPages(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR rcx;
		uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		MDL mdl = { 0 };
		uc_mem_read(uc, rcx, &mdl, sizeof(mdl));

		ctx->DeleteMemMapping((ULONG64)mdl.MappedSystemVa);

		if (!ctx->HeapFree((ULONG64)mdl.MappedSystemVa))
		{
			*outs << "MmUnlockPages failed to free mapped va " << std::hex << (ULONG64)mdl.MappedSystemVa << "\n";
		}

		*outs << "MmUnlockPages mdl " << std::hex << rcx << "\n";
	}

	void EmuIoFreeMdl(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR rcx;
		uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		ctx->HeapFree(rcx);

		*outs << "IoFreeMdl free " << std::hex << rcx << "\n";
	}

	void EmuRtlGetVersion(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR rcx;
		uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		RTL_OSVERSIONINFOW verinfo = { 0 };

		uc_mem_read(uc, rcx, &verinfo, sizeof(verinfo));

		auto st = RtlGetVersion(&verinfo);

		uc_mem_write(uc, rcx, &verinfo, sizeof(verinfo));

		*outs << "RtlGetVersion return " << std::dec << st << "\n";

		uc_reg_write(uc, UC_X86_REG_RAX, &st);
	}

	void EmuDbgPrint(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR rcx;
		uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		DWORD_PTR rdx;
		uc_reg_read(uc, UC_X86_REG_RDX, &rdx);

		std::string str, wstra;
		EmuReadNullTermString(uc, rcx, str);

		std::wstring wstr;
		EmuReadNullTermUnicodeString(uc, rdx, wstr);

		UnicodeToANSI(wstr, wstra);

		*outs << "DbgPrint " << str << "\n";
	}

	void EmuKeInitializeMutex(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR Mutex = 0;
		ULONG Level = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&Mutex, &Level),
			{ UC_X86_REG_RCX, UC_X86_REG_EDX});

		*outs << "KeInitializeMutex Mutex " << std::hex << Mutex << ", level " << Level << "\n";
	}

	void EmuRtlInitUnicodeString(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		PUNICODE_STRING DestinationString = nullptr;
		PCWSTR SourceString = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&DestinationString, &SourceString),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX });

		std::wstring wstr;
		EmuReadNullTermUnicodeString(uc, (DWORD_PTR)SourceString, wstr);

		std::string str;
		UnicodeToANSI(wstr, str);

		UNICODE_STRING ustr;
		ustr.Buffer = (PWCH)SourceString;
		ustr.Length = (USHORT)wstr.length() * sizeof(WCHAR);
		ustr.MaximumLength = (USHORT)(wstr.length() + 1) * sizeof(WCHAR);

		uc_mem_write(uc, (DWORD_PTR)DestinationString, &ustr, sizeof(ustr));

		*outs << "RtlInitUnicodeString DestString " << std::hex << DestinationString << ", SourceString " << str << "\n";
	}

	void EmuKeWaitForSingleObject(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR rcx;
		uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		uint32_t edx;
		uc_reg_read(uc, UC_X86_REG_EDX, &edx);

		uint8_t r8b;
		uc_reg_read(uc, UC_X86_REG_R8B, &r8b);

		uint8_t r9b;
		uc_reg_read(uc, UC_X86_REG_R9B, &r9b);

		*outs << "KeWaitForSingleObject Object " << std::hex << rcx << ", WaitReason " << edx << ", WaitMode " << (int)r8b << ", Alertable " << (int)r9b << "\n";
	}

	void EmuKeReleaseMutex(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		DWORD_PTR rcx;
		uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		uint8_t dl;
		uc_reg_read(uc, UC_X86_REG_DL, &dl);

		*outs << "KeReleaseMutex Object " << std::hex << rcx << ", Wait " << (int)dl << "\n";
	}

	void Emusrand(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		uint32_t ecx;
		uc_reg_read(uc, UC_X86_REG_ECX, &ecx);

		srand((unsigned int)ecx);

		*outs << "srand " << ecx << "\n";
	}

	void Emurand(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		int eax = rand();

		*outs << "rand return " << eax << "\n";
	}

	void EmuRtlZeroMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PVOID Destination = nullptr;
		size_t Length = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&Destination, &Length),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX });

		virtual_buffer_t temp(Length);
		uc_mem_write(uc, Length, temp.GetBuffer(), Length);

		*outs << "RtlZeroMemory " << std::hex << Destination << ", len " << Length << "\n";
	}

	void EmuRtlFillMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PVOID Destination = nullptr;
		size_t Length = 0;
		int Fill = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&Destination, &Length, &Fill),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8B });

		virtual_buffer_t temp(Length);
		memset(temp.GetBuffer(), Fill, Length);
		uc_mem_write(uc, (DWORD_PTR)Destination, temp.GetBuffer(), Length);

		*outs << "RtlFillMemory " << std::hex << Destination << ", len " << Length << ", ch " << (int)Fill << "\n";
	}

	void EmuRtlCopyMemory(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PVOID Destination = nullptr;
		PVOID Source = nullptr;
		size_t Length = 0;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&Destination, &Source, &Length),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX, UC_X86_REG_R8 });

		virtual_buffer_t temp(Length);
		uc_mem_read(uc, (DWORD_PTR)Source, temp.GetBuffer(), Length);
		uc_mem_write(uc, (DWORD_PTR)Destination, temp.GetBuffer(), Length);

		uc_reg_write(uc, UC_X86_REG_RAX, &Destination);

		*outs << "RtlCopyMemory dst " << std::hex << Destination << ", src " << Source << ", len " << Length << "\n";
	}

	void Emuwcsstr(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		wchar_t* str = nullptr;
		wchar_t* strSearch = nullptr;

		ReadArgsFromRegisters(uc,
			std::make_tuple(&str, &strSearch),
			{ UC_X86_REG_RCX, UC_X86_REG_RDX});

		std::wstring wstr1, wstr2;
		EmuReadNullTermUnicodeString(uc, (DWORD_PTR)str, wstr1);
		EmuReadNullTermUnicodeString(uc, (DWORD_PTR)strSearch, wstr2);

		std::string str1, str2;
		UnicodeToANSI(wstr1, str1);
		UnicodeToANSI(wstr2, str2);

		auto ptr = wcsstr(wstr1.c_str(), wstr2.c_str());

		DWORD_PTR rax = ptr ? ((char*)ptr - (char*)wstr1.c_str()) + (DWORD_PTR)str : 0;

		uc_reg_write(uc, UC_X86_REG_RAX, &rax);

		*outs << "wcsstr String1 " << std::hex << (DWORD_PTR)str << " " << str1
			<< ", String2 " << (DWORD_PTR)strSearch << " " << str2
			<< ", return " << rax << "\n";
	}

	void EmuMmIsAddressValid(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		DWORD_PTR rcx;
		uc_reg_read(uc, UC_X86_REG_RCX, &rcx);

		uint8_t test;
		auto err = uc_mem_read(uc, rcx, &test, 1);

		uint8_t al = (err == UC_ERR_READ_UNMAPPED) ? 0 : 1;

		uc_reg_write(uc, UC_X86_REG_AL, &al);

		*outs << "MmIsAddressValid address " << std::hex << rcx << ", return " << (int)al << "\n";
	}

	void EmuExGetPreviousMode(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		uint32_t eax = 0;
		uc_reg_write(uc, UC_X86_REG_EAX, &eax);

		*outs << "ExGetPreviousMode return " << std::hex << eax << "\n";
	}

	void Emu__C_specific_handler(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		ctx->m_ExecuteExceptionHandler = 1;

		uc_emu_stop(uc);
	}
}
```

`PeVisor/Src/Encode.cpp`:

```cpp
#include "Encode.hpp"

void ANSIToUnicode(const std::string& str, std::wstring& out)
{
	int len = MultiByteToWideChar(CP_ACP, 0, str.c_str(), (int)str.length(), NULL, 0);
	out.resize(len);
	MultiByteToWideChar(CP_ACP, 0, str.c_str(), (int)str.length(), (LPWSTR)out.data(), len);
}

void UnicodeToANSI(const std::wstring& str, std::string& out)
{
	int len = WideCharToMultiByte(CP_ACP, 0, str.c_str(), (int)str.length(), NULL, 0, NULL, NULL);
	out.resize(len);
	WideCharToMultiByte(CP_ACP, 0, str.c_str(), (int)str.length(), (LPSTR)out.data(), len, NULL, NULL);
}

void UnicodeToUTF8(const std::wstring& str, std::string& out)
{
	int len = WideCharToMultiByte(CP_UTF8, 0, str.c_str(), (int)str.length(), NULL, 0, NULL, NULL);
	out.resize(len);
	WideCharToMultiByte(CP_UTF8, 0, str.c_str(), (int)str.length(), (LPSTR)out.data(), len, NULL, NULL);
}

void UTF8ToUnicode(const std::string& str, std::wstring& out)
{
	int len = MultiByteToWideChar(CP_UTF8, 0, str.c_str(), (int)str.length(), NULL, 0);
	out.resize(len);
	MultiByteToWideChar(CP_UTF8, 0, str.c_str(), (int)str.length(), (LPWSTR)out.data(), len);
}
```

`PeVisor/Src/Find.cpp`:

```cpp
#include "UCPE.hpp"

// About: Function for finding of address in region
// Param 1: address
// Param 2: Region name for finding
// Mode: Usermode + Kernelmode
bool PeEmulation::FindAddressInRegion(
	_In_ DWORD_PTR address, 
	_Inout_ std::stringstream& RegionName,
	_In_opt_ bool FindInModules,
	_In_opt_ bool FindInStack,
	_In_opt_ bool FindInHeap)
{
	if (FindInModules)
	{
		for (size_t i = 0; i < m_FakeModules.size(); ++i)
		{
			if (address >= m_FakeModules[i]->ImageBase && address < m_FakeModules[i]->ImageBase + m_FakeModules[i]->ImageSize)
			{
				std::string dllname;
				UnicodeToANSI(m_FakeModules[i]->DllName, dllname);
				RegionName << dllname << "+" << std::uppercase << std::hex << (address - m_FakeModules[i]->ImageBase);
				return true;
			}
		}
	}

	if (FindInStack)
	{
		if (address >= m_StackBase && address < m_StackEnd)
		{
			RegionName << "StackBase+" << std::hex << (address - m_StackBase);
			return true;
		}
	}

	if (FindInHeap)
	{
		if (address >= m_HeapBase && address < m_HeapEnd)
		{
			RegionName << "HeapBase+" << std::hex << (address - m_HeapBase);
			return true;
		}
	}

	if (!m_IsKernel)
	{
		if (address >= m_PebBase && address < m_PebEnd)
		{
			RegionName << "Peb+" << std::hex << (address - m_PebBase);
			return true;
		}

		if (address >= m_LdrBase && address < m_LdrEnd)
		{
			RegionName << "Ldr+" << std::hex << (address - m_LdrBase);
			return true;
		}

		if (address >= m_TebBase && address < m_TebEnd)
		{
			RegionName << "Teb+" << std::hex << (address - m_TebBase);
			return true;
		}
	}
	else
	{
		if (address >= m_DriverObjectBase && address < m_DriverObjectBase + sizeof(DRIVER_OBJECT))
		{
			RegionName << "DriverObject+" << std::hex << (address - m_DriverObjectBase);
			return true;
		}
	}

	if (address >= m_KSharedUserDataBase && address < m_KSharedUserDataEnd)
	{
		RegionName << "KSharedUserData+" << std::hex << (address - m_KSharedUserDataBase);
		return true;
	}

	return false;
}

// About: Function for finding of section by address
// Param 1: address 
// Param 2: our section(aka 'FakeSection') 
// Mode: Usermode + Kernelmode
bool PeEmulation::FindSectionByAddress(_In_ DWORD_PTR address, _Inout_ FakeSection** section)
{
	for (size_t i = 0; i < m_FakeModules.size(); ++i)
	{
		auto& m = m_FakeModules[i];
		if (address >= m->ImageBase && address < m->ImageBase + m->ImageSize)
		{
			for (size_t j = 0; j < m->FakeSections.size(); ++j)
			{
				auto r = &m->FakeSections[j];
				if (address >= m->ImageBase + r->SectionBase && address < m->ImageBase + r->SectionBase + r->SectionSize)
				{
					*section = r;
					return true;
				}
			}

			break;
		}
	}
	return false;
}

// About: Function for finding of API by address
// Mode: Usermode + Kernelmode
bool PeEmulation::FindAPIByAddress(_In_ DWORD_PTR address, _Inout_ std::wstring& DllName, _Inout_ FakeAPI** api)
{
	for (size_t i = 0; i < m_FakeModules.size(); ++i)
	{
		auto& m = m_FakeModules[i];
		DllName = m->DllName;
		if (address >= m->ImageBase && address < m->ImageBase + m->ImageSize)
		{
			for (size_t j = 0; j < m->FakeAPIs.size(); ++j)
			{
				auto r = &m->FakeAPIs[j];
				if (r->VirtualAddress == address)
				{
					*api = r;
					return true;
				}
			}
			break;
		}
	}
	return false;
}

// About: Function for finding of module by address
// Mode: Usermode + Kernelmode
bool PeEmulation::FindModuleByAddress(_In_ DWORD_PTR address, _Inout_ DWORD_PTR& DllBase)
{
	if (address >= m_ImageBase && address < m_ImageEnd)
	{
		DllBase = m_ImageBase;
		return true;
	}

	for (size_t i = 0; i < m_FakeModules.size(); ++i)
	{
		auto& m = m_FakeModules[i];
		if (address >= m->ImageBase && address < m->ImageBase + m->ImageSize)
		{
			DllBase = m->ImageBase;
			return true;
		}
	}
	return false;
}
```

`PeVisor/Src/InternalEmulationApi.cpp`:

```cpp
#include "UCPE.hpp"
#include "IEApiErrorCodes.hpp"

std::filesystem::path PeEmulation::GetModuleFileInternalEmulation(_In_ PVOID hModule) {
    for (PFakeModule module : m_FakeModules) {
        if (module->ImgPtr == hModule) {
            return module->FullPath;
        }
    }

    return std::filesystem::path();
}

void PeEmulation::GetModuleHandleInternalEmulation(_Out_ DWORD_PTR* ImageBase, _In_ std::wstring& wModuleName)
{
	std::transform(wModuleName.begin(), wModuleName.end(), wModuleName.begin(),
		[](unsigned char c) { return std::tolower(c); });

	if (wModuleName.find(L'.') == std::wstring::npos) {
		wModuleName.append(L".dll");
	}

	auto it = std::find_if(m_FakeModules.begin(), m_FakeModules.end(), [wModuleName](PFakeModule module) {
		std::wstring moduleNameLower = module->DllName;
		std::transform(moduleNameLower.begin(), moduleNameLower.end(), moduleNameLower.begin(),
			[](unsigned char c) { return std::tolower(c); });

		return moduleNameLower == wModuleName;
		});

	if (it != m_FakeModules.end()) {
		*ImageBase = (*it)->ImageBase;
	}
	else {
		*ImageBase = (DWORD_PTR)IApiEmuErrorCode::GetModuleHandleAInvalidValue;
	}
	return;
}

NTSTATUS PeEmulation::LdrFindDllByNameInternalEmualtion(
    _In_ const std::wstring& DllName,
    _Out_ DWORD_PTR* ImageBase, 
    _Out_ size_t* ImageSize, 
    _In_ bool LoadIfNotExist)
{
	using namespace blackbone;

	std::wstring newDllName = DllName;

	if (!_wcsicmp(newDllName.c_str(), L"NTOSKRNL.DLL"))
	{
		newDllName = L"NTOSKRNL.EXE";
	}

	if (newDllName.find(L'.') == std::wstring::npos)
	{
		if (m_IsKernel)
			newDllName += L".sys";
		else
			newDllName += L".dll";
	}

	auto it = std::find_if(m_FakeModules.begin(), m_FakeModules.end(), [newDllName](PFakeModule module) {
		return module->DllName == newDllName;
		});

	//auto moduleptr = GetModuleHandleAInternalEmulation(ImageBase, newDllName);
	//auto moduleptr = thisProc.modules().GetModule(newDllName, blackbone::eModSeachType::PEHeaders, mt_default);

	if (it != m_FakeModules.end())
	{
		if (ImageBase)
			*ImageBase = (*it)->ImageBase;
		if (ImageSize)
			*ImageSize = (*it)->ImageSize;

		return STATUS_SUCCESS;
	}

	if (LoadIfNotExist)
	{
		return LdrLoadDllByName(newDllName, ImageBase);
	}

	return STATUS_OBJECT_NAME_NOT_FOUND;
}
```

`PeVisor/Src/Ldr.cpp`:

```cpp
#include "UCPE.hpp"

extern "C"
{
	NTSYSAPI
		PVOID
		NTAPI
		RtlImageDirectoryEntryToData(
			PVOID BaseAddress,
			BOOLEAN MappedAsImage,
			USHORT Directory,
			PULONG Size
		);
}

// About: Function for getting of proc address via LDR
// Param 1: ImageBase
// Param 2: ProcedureName
// Mode: Usermode + Kernelmode
DWORD_PTR PeEmulation::LdrGetProcAddress(_In_ DWORD_PTR ImageBase, _In_ const char* ProcedureName)
{
	//if (!strcmp(ProcedureName, "FlsAlloc"))
	//{
	//	return 0;
	//}
	//if (!strcmp(ProcedureName, "FlsSetValue"))
	//{
	//	return 0;
	//}
	//if (!strcmp(ProcedureName, "FlsFree"))
	//{
	//	return 0;
	//}

	for (size_t i = 0; i < m_FakeModules.size(); ++i)
	{
		auto& m = m_FakeModules[i];
		if (m->ImageBase == ImageBase)
		{
			for (size_t j = 0; j < m->FakeAPIs.size(); ++j)
			{
				auto& r = m->FakeAPIs[j];
				if (r.ProcedureName == ProcedureName)
				{
					return r.VirtualAddress;
				}
			}
		}
	}

	return 0;
}

// About: Function for resolving export table via LDR
// Param 1: our module(aka 'Fake module')
// Param 2: Image base
// Param 3: Mapped base
// Mode: Usermode + Kernelmode
void PeEmulation::LdrResolveExportTable(_Inout_ FakeModule* module, _In_ PVOID ImageBase, _In_ DWORD_PTR MappedBase)
{
	DWORD uExportSize = 0;
	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)
		RtlImageDirectoryEntryToData(ImageBase, TRUE, IMAGE_DIRECTORY_ENTRY_EXPORT, &uExportSize);

	if (!pImageExportDirectory)
		return;

	DWORD dwNumberOfNames = (DWORD)(pImageExportDirectory->NumberOfNames);
	DWORD* pAddressOfFunction = (DWORD*)((PUCHAR)ImageBase + pImageExportDirectory->AddressOfFunctions);
	DWORD* pAddressOfNames = (DWORD*)((PUCHAR)ImageBase + pImageExportDirectory->AddressOfNames);
	WORD* pAddressOfNameOrdinals = (WORD*)((PUCHAR)ImageBase + pImageExportDirectory->AddressOfNameOrdinals);

	for (size_t i = 0; i < dwNumberOfNames; i++)
	{
		char* strFunction = (char*)((PUCHAR)ImageBase + pAddressOfNames[i]);

		DWORD functionRva = pAddressOfFunction[pAddressOfNameOrdinals[i]];
		//forward
		if ((PUCHAR)ImageBase + functionRva >= (PUCHAR)pImageExportDirectory &&
			(PUCHAR)ImageBase + functionRva < (PUCHAR)pImageExportDirectory + uExportSize)
		{
			char* strForward = (char*)ImageBase + functionRva;
			char* strForwardFunction = strchr(strForward, '.');
			if (strForwardFunction)
			{
				std::string strForwardDll(strForward, strForwardFunction - strForward);
				strForwardDll += ".dll";
				DWORD_PTR ForwardDllBase = 0;
				std::wstring wszForwardDll;
				ANSIToUnicode(strForwardDll, wszForwardDll);
				if (NT_SUCCESS(LdrFindDllByName(wszForwardDll, &ForwardDllBase, NULL, true)))
				{
					DWORD_PTR ForwardFunction = LdrGetProcAddress(ForwardDllBase, strForwardFunction + 1);
					if (ForwardFunction)
						module->FakeAPIs.emplace_back(strFunction, ForwardFunction);
				}
			}
		}
		else
		{
			module->FakeAPIs.emplace_back(strFunction, MappedBase + functionRva);
		}
	}
}

// About: Function for finding dll by name
// Param 1: name of dll
// Param 2: Image base
// Param 3: size of image
// Param 4: loading dll if our dll not exist
// Mode: Usermode + Kernelmode
NTSTATUS PeEmulation::LdrFindDllByName(_In_ const std::wstring& DllName, _Out_ DWORD_PTR* ImageBase, _Out_ size_t* ImageSize, _In_ bool LoadIfNotExist)
{
	using namespace blackbone;

	std::wstring newDllName = DllName;

	if (!_wcsicmp(newDllName.c_str(), L"NTOSKRNL.DLL"))
	{
		newDllName = L"NTOSKRNL.EXE";
	}

	if (newDllName.find(L'.') == std::wstring::npos)
	{
		if (m_IsKernel)
			newDllName += L".sys";
		else
			newDllName += L".dll";
	}

	auto moduleptr = thisProc.modules().GetModule(newDllName, blackbone::eModSeachType::PEHeaders, mt_default);

	if (moduleptr)
	{
		if (ImageBase)
			*ImageBase = moduleptr->baseAddress;
		if (ImageSize)
			*ImageSize = moduleptr->size;

		return STATUS_SUCCESS;
	}

	if (LoadIfNotExist)
	{
		return LdrLoadDllByName(newDllName, ImageBase);
	}

	return STATUS_OBJECT_NAME_NOT_FOUND;
}

// About: Function for loading dll by name
// Param 1: name of dll
// Mode: Usermode + Kernelmode
NTSTATUS PeEmulation::LdrLoadDllByName(_In_ const std::wstring& DllName, _Out_ DWORD_PTR* ImageBase)
{
	using namespace blackbone;

	auto MapResult = thisProc.mmap().MapImage(DllName,
		ManualImports | NoSxS | NoDelayLoad | NoExceptions | NoTLS | NoExceptions,
		ManualMapCallback, this);

	if (!MapResult.success())
	{
		printf("LdrLoadDllByName failed to MapImage %ws, status %X\n", DllName.c_str(), MapResult.status);
		return MapResult.status;
	}

	if (ImageBase != nullptr)
	{
		*ImageBase = MapResult.result_data->get()->imgPtr;
	}

	return STATUS_SUCCESS;
}
```

`PeVisor/Src/Main.cpp`:

```cpp
#include "UCPE.hpp"
#include <EmuApiFuncs.hpp>

std::ostream* outs;

extern "C"
{
	NTSYSAPI
		PIMAGE_NT_HEADERS
		NTAPI
		RtlImageNtHeader(IN PVOID BaseAddress);

	NTSYSAPI
		PVOID
		NTAPI
		RtlImageDirectoryEntryToData(
			PVOID BaseAddress,
			BOOLEAN MappedAsImage,
			USHORT Directory,
			PULONG Size
		);
}

static ULONG ExtractEntryPointRva(PVOID ModuleBase)
{
	return RtlImageNtHeader(ModuleBase)->OptionalHeader.AddressOfEntryPoint;
}

// TO DO: x86 support => InitDescriptor32 function support,
// DWORD Virtual addresses and etc..
namespace InitOfDescriptor
{
	// About: Function for initialization of 64 bit process descriptor
	// Mode: Usermode + Kernelmode
	static void InitDescriptor64(SegmentDesctiptorX64* desc, DWORD_PTR base, DWORD_PTR limit, bool is_code, bool is_long_mode)
	{
		desc->descriptor.all = 0;  //clear the descriptor
		desc->descriptor.fields.base_low = base;
		desc->descriptor.fields.base_mid = (base >> 16) & 0xff;
		desc->descriptor.fields.base_high = base >> 24;
		desc->base_upper32 = base >> 32;

		if (limit > 0xfffff) {
			limit >>= 12;
			desc->descriptor.fields.gran = 1;
		}

		desc->descriptor.fields.limit_low = limit & 0xffff;
		desc->descriptor.fields.limit_high = limit >> 16;

		desc->descriptor.fields.dpl = 0;
		desc->descriptor.fields.present = 1;
		desc->descriptor.fields.db = 1;   //64 bit
		desc->descriptor.fields.type = is_code ? 0xb : 3;
		desc->descriptor.fields.system = 1;  //code or data
		desc->descriptor.fields.l = is_long_mode ? 1 : 0;
	}
}

// About: Function for initialization of Processor State
// TO DO: x86 support => InitDescriptor32 function support,
// DWORD Virtual addresses and etc..
// Mode: Usermode + Kernelmode
void PeEmulation::InitProcessorState()
{
	uc_x86_mmr gdtr;

	DWORD_PTR kpcr_base = 0xfffff00000000000ull;

	KPCR kpcr;

	memset(&kpcr, 0, sizeof(KPCR));

	gdtr.base = kpcr_base + offsetof(KPCR, gdt);
	gdtr.limit = sizeof(kpcr.gdt) - 1;

	InitOfDescriptor::InitDescriptor64(&kpcr.gdt[1], 0, 0xffffffffffffffff, true, true);
	InitOfDescriptor::InitDescriptor64(&kpcr.gdt[2], 0, 0xffffffffffffffff, false, true);

	auto err = uc_mem_map(m_uc, kpcr_base, PAGE_SIZE, UC_PROT_READ);
	err = uc_mem_write(m_uc, kpcr_base, &kpcr, sizeof(KPCR));
	err = uc_reg_write(m_uc, UC_X86_REG_GDTR, &gdtr);

	SegmentSelector cs = { 0 };
	cs.fields.index = 1;
	uc_reg_write(m_uc, UC_X86_REG_CS, &cs.all);

	SegmentSelector ds = { 0 };
	ds.fields.index = 2;
	uc_reg_write(m_uc, UC_X86_REG_DS, &ds.all);

	SegmentSelector ss = { 0 };
	ss.fields.index = 2;
	uc_reg_write(m_uc, UC_X86_REG_SS, &ss.all);

	SegmentSelector es = { 0 };
	es.fields.index = 2;
	uc_reg_write(m_uc, UC_X86_REG_ES, &es.all);

	SegmentSelector gs = { 0 };
	gs.fields.index = 2;
	uc_reg_write(m_uc, UC_X86_REG_GS, &gs.all);

	FlagRegister eflags = { 0 };
	eflags.fields.id = 1;
	eflags.fields.intf = 1;
	eflags.fields.reserved1 = 1;

	uc_reg_write(m_uc, UC_X86_REG_EFLAGS, &eflags.all);

	DWORD_PTR cr8 = 0;
	uc_reg_write(m_uc, UC_X86_REG_CR8, &cr8);
}

// About: Function for insertion of something in tail list
// Mode: Usermode + Kernelmode
void PeEmulation::InsertTailList(_In_ DWORD_PTR ListHeadAddress, _In_ DWORD_PTR EntryAddress)
{
	PLIST_ENTRY Blink;

	//Blink = ListHead->Blink;
	uc_mem_read(m_uc, ListHeadAddress + offsetof(LIST_ENTRY, Blink), &Blink, sizeof(Blink));

	//Entry->Flink = (PLIST_ENTRY)ListHeadAddress;

	uc_mem_write(m_uc, EntryAddress + offsetof(LIST_ENTRY, Flink), &ListHeadAddress, sizeof(ListHeadAddress));

	//Entry->Blink = Blink;

	uc_mem_write(m_uc, EntryAddress + offsetof(LIST_ENTRY, Blink), &Blink, sizeof(Blink));

	//Blink->Flink = (PLIST_ENTRY)EntryAddress;

	uc_mem_write(m_uc, (uint64_t)Blink + offsetof(LIST_ENTRY, Flink), &EntryAddress, sizeof(EntryAddress));

	//ListHead->Blink = (PLIST_ENTRY)EntryAddress;

	uc_mem_write(m_uc, ListHeadAddress + offsetof(LIST_ENTRY, Blink), &EntryAddress, sizeof(EntryAddress));
}

// About: Function for initialization of KSharedUserData
// TO DO: Normal initialization of KSharedUserData without zeroes or making of reading redirection to my own KSharedUserData in process.
// Mode: Usermode + Kernelmode
void PeEmulation::InitKSharedUserData()
{
	if (m_IsKernel)
	{
		m_KSharedUserDataBase = 0xfffff78000000000ull;
		m_KSharedUserDataEnd = 0xfffff78000001000ull;
	}
	else
	{
		m_KSharedUserDataBase = 0x7FFE0000;
		m_KSharedUserDataEnd = 0x7FFF0000;
	}

	uc_mem_map(m_uc, m_KSharedUserDataBase, PAGE_SIZE, UC_PROT_READ);
	uc_mem_write(m_uc, m_KSharedUserDataBase, (void*)0x7FFE0000, PAGE_SIZE);
}

// About: Function for intialization of TebPeb
// TO DO: Normal initialization of peb and teb without zeroes.
// Mode: Usermode
void PeEmulation::InitTebPeb()
{
	RTL_USER_PROCESS_PARAMETERS LocalProcessParameters{};
	PRTL_USER_PROCESS_PARAMETERS EmuProcessParameters = (PRTL_USER_PROCESS_PARAMETERS)HeapAlloc(sizeof(RTL_USER_PROCESS_PARAMETERS));

	std::wstring MyEnvironment = GetEnvironmentStringsW();
	LPWCH EmuEnvironment = (LPWCH)HeapAlloc(MyEnvironment.size() * sizeof(wchar_t));

	InternalEmuApi::EmuCopyUnicodeStrs(m_uc, EmuEnvironment, MyEnvironment);

	LocalProcessParameters.Environment = (PVOID)EmuEnvironment;

	uc_mem_write(m_uc, (DWORD_PTR)EmuProcessParameters, &LocalProcessParameters, sizeof(RTL_USER_PROCESS_PARAMETERS));

	PEB peb{};

	m_PebBase = 0x90000ull;
	m_PebEnd = m_PebBase + AlignSize(sizeof(PEB), PAGE_SIZE);
	m_LdrBase = 0x70000ull;
	m_LdrEnd = m_LdrBase + AlignSize(sizeof(PEB_LDR_DATA), PAGE_SIZE);

	peb.Ldr = (PPEB_LDR_DATA)m_LdrBase;
	peb.ProcessHeap = (PVOID)m_HeapBase;
	peb.ProcessParameters = EmuProcessParameters;

	uc_mem_map(m_uc, m_PebBase, m_PebEnd - m_PebBase, UC_PROT_READ);
	uc_mem_write(m_uc, m_PebBase, &peb, sizeof(PEB));

	m_TebBase = 0x80000ull;
	m_TebEnd = m_TebBase + AlignSize(sizeof(TEB), PAGE_SIZE);

	TEB teb = { 0 };

	teb.ProcessEnvironmentBlock = (PPEB)m_PebBase;

	uc_mem_map(m_uc, m_TebBase, m_TebEnd - m_TebBase, UC_PROT_READ);
	uc_mem_write(m_uc, m_TebBase, &teb, sizeof(TEB));

	int StackBase = 0x8;
	int StackLimit = 0x10;
	uc_mem_write(m_uc, m_TebBase + StackBase, &m_StackBase, sizeof(m_StackBase));
	uc_mem_write(m_uc, m_TebBase + StackLimit, &m_StackEnd, sizeof(m_StackEnd));

	uc_x86_msr MsrIa32GsBase;
	MsrIa32GsBase.rid = (uint32_t)Msr::kIa32GsBase;
	MsrIa32GsBase.value = m_TebBase;

	uc_reg_write(m_uc, UC_X86_REG_MSR, &MsrIa32GsBase);

	CR4 cr4{};
	cr4.x64.Bitmap.VME = true;
	cr4.x64.Bitmap.PVI = true;
	cr4.x64.Bitmap.TSD = false;
	cr4.x64.Bitmap.DE = false;
	cr4.x64.Bitmap.PSE = false;
	cr4.x64.Bitmap.PAE = false;
	cr4.x64.Bitmap.MCE = true;
	cr4.x64.Bitmap.PGE = false;
	cr4.x64.Bitmap.PCE = true;
	cr4.x64.Bitmap.OSFXSR = true;
	cr4.x64.Bitmap.OSXMMEXCPT = true;
	cr4.x64.Bitmap.UMIP = true;
	cr4.x64.Bitmap.LA57 = false;
	cr4.x64.Bitmap.VMXE = false;
	cr4.x64.Bitmap.SMXE = true;
	cr4.x64.Bitmap.FSGSBASE = true;
	cr4.x64.Bitmap.PCIDE = false;
	cr4.x64.Bitmap.OSXSAVE = true;
	cr4.x64.Bitmap.KL = true;
	cr4.x64.Bitmap.SMEP = false;
	cr4.x64.Bitmap.SMAP = false;
	cr4.x64.Bitmap.PKE = false;
	cr4.x64.Bitmap.CET = true;
	cr4.x64.Bitmap.PKS = false;
	cr4.x64.Bitmap.UINTR = false;

	uc_reg_write(m_uc, UC_X86_REG_CR4, &cr4.Value);
}

// About: Function for intialization of PsLoadedModuleList in usermode app
// Mode: Usermode
void PeEmulation::InitLdrModuleList()
{
	PEB_LDR_DATA Ldr{};

	Ldr.InInitializationOrderModuleList.Flink = (_LIST_ENTRY*)HeapAlloc(sizeof(LIST_ENTRY));
	Ldr.InMemoryOrderModuleList.Flink = (_LIST_ENTRY*)HeapAlloc(sizeof(LIST_ENTRY));
	Ldr.InLoadOrderModuleList.Flink = (_LIST_ENTRY*)HeapAlloc(sizeof(LIST_ENTRY));

	Ldr.Length = m_FakeModules.size() - 1;
	Ldr.Initialized = true;

	LIST_ENTRY PsLoadedModuleList = { 0 };
	PsLoadedModuleList.Blink = PsLoadedModuleList.Flink = (PLIST_ENTRY)Ldr.InInitializationOrderModuleList.Flink;

	LIST_ENTRY PsLoadedModuleList1 = { 0 };
	PsLoadedModuleList1.Blink = PsLoadedModuleList1.Flink = (PLIST_ENTRY)Ldr.InMemoryOrderModuleList.Flink;

	LIST_ENTRY PsLoadedModuleList2 = { 0 };
	PsLoadedModuleList2.Blink = PsLoadedModuleList2.Flink = (PLIST_ENTRY)Ldr.InLoadOrderModuleList.Flink;

	uc_mem_write(m_uc, (DWORD_PTR)Ldr.InInitializationOrderModuleList.Flink, &PsLoadedModuleList, sizeof(PsLoadedModuleList));
	uc_mem_write(m_uc, (DWORD_PTR)Ldr.InMemoryOrderModuleList.Flink, &PsLoadedModuleList1, sizeof(PsLoadedModuleList));
	uc_mem_write(m_uc, (DWORD_PTR)Ldr.InLoadOrderModuleList.Flink, &PsLoadedModuleList2, sizeof(PsLoadedModuleList));

	for (size_t i = 0; i < m_FakeModules.size(); ++i)
	{
		auto LdrEntryBase = HeapAlloc(sizeof(LDR_DATA_TABLE_ENTRY));

		LDR_DATA_TABLE_ENTRY LdrEntry = { 0 };
		LdrEntry.DllBase = (PVOID)m_FakeModules[i]->ImageBase;
		LdrEntry.ReferenceCount = 1;
		LdrEntry.EntryPoint = (PVOID)m_FakeModules[i]->ImageEntry;
		LdrEntry.SizeOfImage = m_FakeModules[i]->ImageSize;

		LdrEntry.FullDllName.Length = (USHORT)m_FakeModules[i]->FullPath.wstring().length() * sizeof(WCHAR);
		LdrEntry.FullDllName.MaximumLength = ((USHORT)(m_FakeModules[i]->FullPath.wstring().length() + 1) * sizeof(WCHAR));
		PWSTR FullDllNameBase = (PWSTR)HeapAlloc(LdrEntry.FullDllName.MaximumLength);
		LdrEntry.FullDllName.Buffer = FullDllNameBase;

		LdrEntry.BaseDllName.Length = (USHORT)m_FakeModules[i]->DllName.length() * sizeof(WCHAR);
		LdrEntry.BaseDllName.MaximumLength = ((USHORT)(m_FakeModules[i]->DllName.length() + 1) * sizeof(WCHAR));
		PWSTR BaseDllNameBase = (PWSTR)HeapAlloc(LdrEntry.BaseDllName.MaximumLength);
		LdrEntry.BaseDllName.Buffer = BaseDllNameBase;

		//printf("%p\n", BaseDllNameBase);
		//printf("%p\n", LdrEntryBase);

		InternalEmuApi::EmuCopyUnicodeStrs(m_uc, FullDllNameBase, m_FakeModules[i]->FullPath);
		InternalEmuApi::EmuCopyUnicodeStrs(m_uc, BaseDllNameBase, m_FakeModules[i]->DllName);

		uc_mem_write(m_uc, LdrEntryBase, &LdrEntry, sizeof(LdrEntry));

		InsertTailList((DWORD_PTR)Ldr.InInitializationOrderModuleList.Flink, LdrEntryBase);
		InsertTailList((DWORD_PTR)Ldr.InMemoryOrderModuleList.Flink, LdrEntryBase);
		InsertTailList((DWORD_PTR)Ldr.InLoadOrderModuleList.Flink, LdrEntryBase);
	}

	m_LdrBase = 0x70000ull;
	m_LdrEnd = m_LdrBase + AlignSize(sizeof(PEB_LDR_DATA), PAGE_SIZE);
	uc_mem_map(m_uc, m_LdrBase, m_LdrEnd - m_LdrBase, UC_PROT_READ);
	uc_mem_write(m_uc, m_LdrBase, &Ldr, sizeof(PEB_LDR_DATA));

	return;
}

// About: Function for intialization of PsLoadedModuleList in driver
// Mode: Kernelmode
void PeEmulation::InitPsLoadedModuleList()
{
	m_PsLoadedModuleListBase = HeapAlloc(sizeof(LIST_ENTRY));

	LIST_ENTRY PsLoadedModuleList = { 0 };
	PsLoadedModuleList.Blink = PsLoadedModuleList.Flink = (PLIST_ENTRY)m_PsLoadedModuleListBase;

	uc_mem_write(m_uc, m_PsLoadedModuleListBase, &PsLoadedModuleList, sizeof(PsLoadedModuleList));

	for (size_t i = 0; i < m_FakeModules.size(); ++i)
	{
		auto LdrEntryBase = HeapAlloc(sizeof(KLDR_DATA_TABLE_ENTRY));

		KLDR_DATA_TABLE_ENTRY LdrEntry = { 0 };
		LdrEntry.DllBase = (PVOID)m_FakeModules[i]->ImageBase;
		LdrEntry.LoadCount = 1;
		LdrEntry.EntryPoint = (PVOID)m_FakeModules[i]->ImageEntry;
		LdrEntry.SizeOfImage = m_FakeModules[i]->ImageSize;

		auto fullname = m_FakeModules[i]->FullPath.wstring();
		LdrEntry.FullDllName.Length = (USHORT)fullname.length() * sizeof(WCHAR);
		LdrEntry.FullDllName.MaximumLength = ((USHORT)fullname.length() + 1) * sizeof(WCHAR);
		auto FullDllNameBase = HeapAlloc(LdrEntry.FullDllName.MaximumLength);
		LdrEntry.FullDllName.Buffer = (PWSTR)FullDllNameBase;

		auto BaseDllName = m_FakeModules[i]->DllName;
		LdrEntry.BaseDllName.Length = (USHORT)m_FakeModules[i]->DllName.length() * sizeof(WCHAR);
		LdrEntry.BaseDllName.MaximumLength = ((USHORT)m_FakeModules[i]->DllName.length() + 1) * sizeof(WCHAR);
		auto BaseDllNameBase = HeapAlloc(LdrEntry.BaseDllName.MaximumLength);
		LdrEntry.BaseDllName.Buffer = (PWSTR)BaseDllNameBase;

		LdrEntry.ExceptionTable = (PVOID)m_FakeModules[i]->ExceptionTable;
		LdrEntry.ExceptionTableSize = m_FakeModules[i]->ExceptionTableSize;

		uc_mem_write(m_uc, FullDllNameBase, fullname.data(), LdrEntry.FullDllName.MaximumLength);
		uc_mem_write(m_uc, BaseDllNameBase, BaseDllName.data(), LdrEntry.BaseDllName.MaximumLength);

		uc_mem_write(m_uc, LdrEntryBase, &LdrEntry, sizeof(LdrEntry));

		if (m_FakeModules[i]->ImageBase == m_ImageBase)
		{
			m_DriverLdrEntry = LdrEntryBase;
			m_MainModuleIndex = (int)i;
		}

		InsertTailList(m_PsLoadedModuleListBase, LdrEntryBase);
	}

	return;
}

// About: Function for intialization of DriverObject
// Mode: Kernelmode
void PeEmulation::InitDriverObject()
{
	m_DriverObjectBase = HeapAlloc(sizeof(DRIVER_OBJECT));

	DRIVER_OBJECT DriverObject = { 0 };
	DriverObject.DriverSize = (ULONG)(m_ImageEnd - m_ImageBase);
	DriverObject.DriverStart = (PVOID)m_ImageBase;
	DriverObject.DriverInit = (PVOID)m_ImageEntry;
	DriverObject.Size = sizeof(DRIVER_OBJECT);
	DriverObject.DriverSection = (PVOID)m_DriverLdrEntry;

	uc_mem_write(m_uc, m_DriverObjectBase, &DriverObject, sizeof(DriverObject));

	return;
}

// About: Function for sorting of module list by Priority, i.e. value1->Priority > value2->Priority
// Mode: Kernelmode
void PeEmulation::SortModuleList()
{
	std::sort(m_FakeModules.begin(), m_FakeModules.end(),
		[](const FakeModule* value1, const FakeModule* value2)
		{
			return value1->Priority > value2->Priority;
		});
}

int main(int argc, char** argv)
{
	using namespace blackbone;

	PeEmulation ctx;

	if (argc < 2)
	{
		printf("usage: unicorn_pe (filename) [-k] [-disasm]\n");
		return -1;
	}

	outs = &std::cout;

	std::string filename = argv[1];
	std::wstring wfilename;
	ANSIToUnicode(filename, wfilename);

	bool bKernel = true;

	{
		for (int i = 2; i < argc; ++i)
		{
			if (!strcmp(argv[i], "-k"))
			{
				ctx.m_IsKernel = true;
			}
			if (!strcmp(argv[i], "-disasm"))
			{
				ctx.m_DisplayDisasm = true;
			}
			if (!strcmp(argv[i], "-packed"))
			{
				ctx.m_IsPacked = true;
			}
			if (!strcmp(argv[i], "-boundcheck"))
			{
				ctx.m_BoundCheck = true;
			}
			if (!strcmp(argv[i], "-dump"))
			{
				ctx.m_Dump = true;
			}
		}
	}

	uc_engine* uc = NULL;
	auto err = uc_open(UC_ARCH_X86, UC_MODE_64, &uc);
	uc_ctl_set_cpu_model(uc, UC_CPU_X86_EPYC);
	if (err)
	{
		printf("failed to uc_open %d\n", err);
		return -1;
	}

	ctx.m_uc = uc;
	ctx.thisProc.Attach(GetCurrentProcessId());

	uc_hook ucHookInvalidRwx = 0, 
		ucHookRwx = 0, 
		ucHookCode = 0,
		ucHookIntr = 0,
		ucHookCpuid = 0, 
		ucHookSySCall = 0;

	DWORD_PTR Stack = (!ctx.m_IsKernel) ? 0x40000 : 0xFFFFFC0000000000ull;

	virtual_buffer_t StackBuf;
	if (!StackBuf.GetSpace(ctx.m_StackSize))
	{
		printf("failed to allocate virtual stack\n");
		return 0;
	}

	//allocate virtual stack for execution
	memset(StackBuf.GetBuffer(), 0, StackBuf.GetLength());
	uc_mem_map(uc, Stack, ctx.m_StackSize, UC_PROT_READ | UC_PROT_WRITE);
	uc_mem_write(uc, Stack, StackBuf.GetBuffer(), ctx.m_StackSize);

	ctx.m_StackBase = Stack;
	ctx.m_StackEnd = Stack + ctx.m_StackSize;
	ctx.m_LoadModuleBase = (!ctx.m_IsKernel) ? 0x180000000ull : 0xFFFFF80000000000ull;
	ctx.m_HeapBase = (!ctx.m_IsKernel) ? 0x10000000ull : 0xFFFFFA0000000000ull;
	ctx.m_HeapEnd = ctx.m_HeapBase + 0x1000000ull;

	DWORD_PTR Zero = 0;
	uc_mem_map(uc, ctx.m_HeapBase, ctx.m_HeapEnd - ctx.m_HeapBase, (ctx.m_IsKernel) ? UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC : UC_PROT_READ | UC_PROT_WRITE);
	for (size_t Index = 0; Index <= ctx.m_HeapEnd - ctx.m_HeapBase; Index += sizeof(Zero))
	{
		uc_mem_write(uc, ctx.m_HeapBase + Index, &Zero, sizeof(Zero));
	}

	auto MapResult = ctx.thisProc.mmap().MapImage(wfilename,
		ManualImports | NoSxS | NoExceptions | NoDelayLoad | NoTLS | NoExceptions | NoExec,
		ManualMapCallback, &ctx, 0);

	if (!MapResult.success())
	{
		printf("failed to MapImage\n");
		return 0;
	}

	auto res = MapResult.result();
	ctx.m_PathExe = wfilename;
	ctx.m_ImageBase = res->baseAddress;
	ctx.m_ImageEnd = res->baseAddress + res->size;
	ctx.m_ImageEntry = ctx.m_ImageBase + ExtractEntryPointRva((PVOID)res->imgPtr);
	ctx.m_LastRipModule = ctx.m_ImageBase;
	ctx.m_ExecuteFromRip = ctx.m_ImageEntry;

	if (!ctx.m_IsKernel)
	{
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetSystemTimeAsFileTime", EmuApi::EmuGetSystemTimeAsFileTime);

		///////////////////////////////////////////////////////////////////////////////ANTI-DEBUG
		ctx.RegisterAPIEmulation(L"kernel32.dll", "IsDebuggerPresent", EmuApi::EmuIsDebuggerPresent);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "CheckRemoteDebuggerPresent", EmuApi::EmuCheckRemoteDebuggerPresent);
		///////////////////////////////////////////////////////////////////////////////ANTI-DEBUG

		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetCurrentThreadId", EmuApi::EmuGetCurrentThreadId);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetCurrentProcessId", EmuApi::EmuGetCurrentProcessId);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "QueryPerformanceCounter", EmuApi::EmuQueryPerformanceCounter);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "LoadLibraryExW", EmuApi::EmuLoadLibraryExW);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "LoadLibraryA", EmuApi::EmuLoadLibraryA);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetProcAddress", EmuApi::EmuGetProcAddress);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetModuleHandleA", EmuApi::EmuGetModuleHandleA);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetModuleHandleW", EmuApi::EmuGetModuleHandleW);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetModuleHandleExW", EmuApi::EmuGetModuleHandleExW);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetLastError", EmuApi::EmuGetLastError);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "SetLastError", EmuApi::EmuSetLastError);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "InitializeCriticalSectionAndSpinCount", EmuApi::EmuInitializeCriticalSectionAndSpinCount);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetModuleFileNameA", EmuApi::EmuGetModuleFileNameA);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetModuleFileNameW", EmuApi::EmuGetModuleFileNameW);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetCommandLineA", EmuApi::EmuGetCommandLineA);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetCommandLineW", EmuApi::EmuGetCommandLineW);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetStdHandle", EmuApi::EmuGetStdHandle);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetFileType", EmuApi::EmuGetFileType);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetFileSize", EmuApi::EmuGetFileSize);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetFileSizeEx", EmuApi::EmuGetFileSizeEx);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "ExitProcess", EmuApi::EmuExitProcess);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "VirtualProtect", EmuApi::EmuVirtualProtect);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "WriteFile", EmuApi::EmuWriteFile);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "CreateFileW", EmuApi::EmuCreateFileW);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "CreateFileA", EmuApi::EmuCreateFileA);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "CreateFileMappingW", EmuApi::EmuCreateFileMappingW);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "CreateFileMappingA", EmuApi::EmuCreateFileMappingA);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "MapViewOfFile", EmuApi::EmuMapViewOfFile);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "UnmapViewOfFile", EmuApi::EmuUnmapViewOfFile);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetEnvironmentStringsW", EmuApi::EmuGetEnvironmentStringsW);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "FreeEnvironmentStringsW", EmuApi::EmuFreeEnvironmentStringsW);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "IsProcessorFeaturePresent", EmuApi::EmuRtlIsProcessorFeaturePresent);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "HeapValidate", EmuApi::EmuHeapValidate);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "RtlUnwindEx", EmuApi::EmuRtlUnwindEx);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "SetUnhandledExceptionFilter", EmuApi::EmuSetUnhandledExceptionFilter);

		////////////////////////////////////////////////////////////////////////////////GUI
		ctx.RegisterAPIEmulation(L"user32.dll", "wvsprintfW", EmuApi::EmuWvsprintfW);
		ctx.RegisterAPIEmulation(L"user32.dll", "wvsprintfA", EmuApi::EmuWvsprintfA);
		ctx.RegisterAPIEmulation(L"user32.dll", "MessageBoxA", EmuApi::EmuMessageBoxA);
		ctx.RegisterAPIEmulation(L"user32.dll", "MessageBoxW", EmuApi::EmuMessageBoxW);
		ctx.RegisterAPIEmulation(L"user32.dll", "GetProcessWindowStation", EmuApi::EmuGetProcessWindowStation);
		ctx.RegisterAPIEmulation(L"user32.dll", "GetUserObjectInformationW", EmuApi::EmuGetUserObjectInformationW);
		ctx.RegisterAPIEmulation(L"user32.dll", "GetUserObjectInformationA", EmuApi::EmuGetUserObjectInformationA);
		////////////////////////////////////////////////////////////////////////////////GUI

		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetStartupInfoW", EmuApi::EmuGetStartupInfoW);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetStartupInfoA", EmuApi::EmuGetStartupInfoA);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetStringTypeW", EmuApi::EmuGetStringTypeW);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "LCMapStringW", EmuApi::EmuLCMapStringW);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "WideCharToMultiByte", EmuApi::EmuWideCharToMultiByte);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "MultiByteToWideChar", EmuApi::EmuMultiByteToWideChar);

		ctx.RegisterAPIEmulation(L"kernelbase.dll", "InitializeCriticalSectionEx", EmuApi::EmuInitializeCriticalSectionEx);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "InitializeCriticalSectionEx", EmuApi::EmuInitializeCriticalSectionEx);

		ctx.RegisterAPIEmulation(L"ntdll.dll", "RtlDeleteCriticalSection", EmuApi::EmuDeleteCriticalSection);
		ctx.RegisterAPIEmulation(L"ntdll.dll", "RtlIsProcessorFeaturePresent", EmuApi::EmuRtlIsProcessorFeaturePresent);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetProcessHeap", EmuApi::EmuGetProcessHeap);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "HeapFree", EmuApi::EmuRtlFreeHeap);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetProcessAffinityMask", EmuApi::EmuGetProcessAffinityMask);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "SetThreadAffinityMask", EmuApi::EmuSetThreadAffinityMask);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "Sleep", EmuApi::EmuSleep);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "VirtualProtect", EmuApi::EmuVirtualProtect);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetCPInfo", EmuApi::EmuGetCPInfo);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "GetACP", EmuApi::EmuGetACP);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "AreFileApisANSI", EmuApi::EmuAreFileApisANSI);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "IsValidCodePage", EmuApi::EmuIsValidCodePage);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "TlsAlloc", EmuApi::EmuTlsAlloc);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "TlsSetValue", EmuApi::EmuTlsSetValue);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "TlsGetValue", EmuApi::EmuTlsGetValue);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "TlsFree", EmuApi::EmuTlsFree);

		ctx.RegisterAPIEmulation(L"kernelbase.dll", "FlsAlloc", EmuApi::EmuTlsAlloc);
		ctx.RegisterAPIEmulation(L"kernelbase.dll", "FlsSetValue", EmuApi::EmuTlsSetValue);
		ctx.RegisterAPIEmulation(L"kernelbase.dll", "FlsGetValue", EmuApi::EmuTlsGetValue);
		ctx.RegisterAPIEmulation(L"kernelbase.dll", "FlsFree", EmuApi::EmuTlsFree);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "FlsAlloc", EmuApi::EmuTlsAlloc);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "FlsSetValue", EmuApi::EmuTlsSetValue);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "FlsGetValue", EmuApi::EmuTlsGetValue);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "FlsFree", EmuApi::EmuTlsFree);

		ctx.RegisterAPIEmulation(L"kernel32.dll", "LocalAlloc", EmuApi::EmuLocalAlloc);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "LocalFree", EmuApi::EmuLocalFree);
		ctx.RegisterAPIEmulation(L"kernel32.dll", "CloseHandle", EmuApi::EmuCloseHandle);

		ctx.RegisterAPIEmulation(L"ntdll.dll", "NtProtectVirtualMemory", EmuApi::EmuNtProtectVirtualMemory);
		ctx.RegisterAPIEmulation(L"ntdll.dll", "NtQueryInformationProcess", EmuApi::EmuNtQueryInformationProcess);
		ctx.RegisterAPIEmulation(L"ntdll.dll", "NtSetInformationThread", EmuApi::EmuNtSetInformationThread);
		ctx.RegisterAPIEmulation(L"ntdll.dll", "NtQuerySystemInformation", EmuApi::EmuNtQuerySystemInformation);
		ctx.RegisterAPIEmulation(L"ntdll.dll", "NtOpenFile", EmuApi::EmuNtOpenFile);
		//ctx.RegisterAPIEmulation(L"ntdll.dll", "NtOpenSection", EmuApi::EmuNtOpenSection);
		//ctx.RegisterAPIEmulation(L"ntdll.dll", "ZwOpenSection", EmuApi::EmuNtOpenSection);

		ctx.RegisterAPIEmulation(L"ntdll.dll", "RtlAllocateHeap", EmuApi::EmuRtlAllocateHeap);
		ctx.RegisterAPIEmulation(L"ntdll.dll", "RtlFreeHeap", EmuApi::EmuRtlFreeHeap);
		ctx.RegisterAPIEmulation(L"ntdll.dll", "RtlEnterCriticalSection", EmuApi::EmuRtlEnterCriticalSection);
		ctx.RegisterAPIEmulation(L"ntdll.dll", "RtlLeaveCriticalSection", EmuApi::EmuRtlLeaveCriticalSection);
		ctx.RegisterAPIEmulation(L"ntdll.dll", "RtlInitializeSListHead", EmuApi::EmuRtlInitializeSListHead);
	}
	else
	{
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "ExAllocatePool", EmuApi::EmuExAllocatePool);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "ExAllocatePoolWithTag", EmuApi::EmuExAllocatePool);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "NtQuerySystemInformation", EmuApi::EmuNtQuerySystemInformation);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "ZwQuerySystemInformation", EmuApi::EmuNtQuerySystemInformation);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "ExFreePool", EmuApi::EmuExFreePool);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "ExFreePoolWithTag", EmuApi::EmuExFreePoolWithTag);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "IoAllocateMdl", EmuApi::EmuIoAllocateMdl);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "MmProbeAndLockPages", EmuApi::EmuMmProbeAndLockPages);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "MmMapLockedPagesSpecifyCache", EmuApi::EmuMmMapLockedPagesSpecifyCache);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "KeQueryActiveProcessors", EmuApi::EmuKeQueryActiveProcessors);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "KeSetSystemAffinityThread", EmuApi::EmuKeSetSystemAffinityThread);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "KeRevertToUserAffinityThread", EmuApi::EmuKeRevertToUserAffinityThread);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "MmUnlockPages", EmuApi::EmuMmUnlockPages);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "IoFreeMdl", EmuApi::EmuIoFreeMdl);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "RtlGetVersion", EmuApi::EmuRtlGetVersion);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "DbgPrint", EmuApi::EmuDbgPrint);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "KeInitializeMutex", EmuApi::EmuKeInitializeMutex);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "RtlInitUnicodeString", EmuApi::EmuRtlInitUnicodeString);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "KeWaitForSingleObject", EmuApi::EmuKeWaitForSingleObject);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "KeWaitForMutexObject", EmuApi::EmuKeWaitForSingleObject);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "KeReleaseMutex", EmuApi::EmuKeReleaseMutex);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "srand", EmuApi::Emusrand);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "rand", EmuApi::Emurand);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "RtlZeroMemory", EmuApi::EmuRtlZeroMemory);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "RtlCopyMemory", EmuApi::EmuRtlCopyMemory);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "RtlFillMemory", EmuApi::EmuRtlFillMemory);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "wcsstr", EmuApi::Emuwcsstr);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "MmIsAddressValid", EmuApi::EmuMmIsAddressValid);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "ExGetPreviousMode", EmuApi::EmuExGetPreviousMode);
		ctx.RegisterAPIEmulation(L"ntoskrnl.exe", "__C_specific_handler", EmuApi::Emu__C_specific_handler);
	}

	memset(&ctx.m_InitReg, 0, sizeof(ctx.m_InitReg));
	ctx.m_InitReg.Rsp = ctx.m_StackEnd - 64;

	ctx.InitProcessorState();

	ctx.szCommandLineA = "D:\\Programs\\Soft\\Coding\\C\\VisualStudio\\Coders\\PeVisor\\x64\\Debug\\Peb.exe";
	ctx.EmuCommandLineA = (LPSTR)ctx.HeapAlloc(ctx.szCommandLineA.size());
	InternalEmuApi::EmuCopyASCIStrs(ctx.m_uc, ctx.EmuCommandLineA, ctx.szCommandLineA);

	ctx.szCommandLineW = L"D:\\Programs\\Soft\\Coding\\C\\VisualStudio\\Coders\\PeVisor\\x64\\Debug\\Peb.exe";
	ctx.EmuCommandLineW = (LPWSTR)ctx.HeapAlloc(ctx.szCommandLineW.size() * sizeof(wchar_t));
	InternalEmuApi::EmuCopyUnicodeStrs(ctx.m_uc, ctx.EmuCommandLineW, ctx.szCommandLineW);

	if (!ctx.m_IsKernel)
	{
		ctx.SortModuleList();
		ctx.InitPsLoadedModuleList();
		ctx.InitLdrModuleList();
		ctx.InitTebPeb();

		//Dll
		//ctx.m_InitReg.Rcx = ctx.m_ImageBase;
		//ctx.m_InitReg.Rdx = DLL_PROCESS_ATTACH;
		//ctx.m_InitReg.R8 = 0;
		//ctx.m_InitReg.Dr0 = 0;
		//ctx.m_InitReg.Dr1 = 0;
		//ctx.m_InitReg.Dr2 = 0;
		//ctx.m_InitReg.Dr3 = 0;
		//ctx.m_InitReg.Dr6 = 0;
		//ctx.m_InitReg.Dr7 = 0;

		ctx.m_InitReg.Rax = ctx.m_ExecuteFromRip;
		ctx.m_InitReg.Rcx = ctx.m_PebBase;
		ctx.m_InitReg.Rdx = ctx.m_ExecuteFromRip;
		ctx.m_InitReg.R8 = ctx.m_PebBase;
		ctx.m_InitReg.R9 = ctx.m_ExecuteFromRip;
		ctx.m_InitReg.Dr0 = 0;
		ctx.m_InitReg.Dr1 = 0;
		ctx.m_InitReg.Dr2 = 0;
		ctx.m_InitReg.Dr3 = 0;
		ctx.m_InitReg.Dr6 = 0;
		ctx.m_InitReg.Dr7 = 0;
	}
	else
	{
		ctx.SortModuleList();
		ctx.InitPsLoadedModuleList();
		ctx.InitDriverObject();

		ctx.m_InitReg.Rcx = ctx.m_DriverObjectBase;
		ctx.m_InitReg.Rdx = 0;
	}

	ctx.InitKSharedUserData();

	//return to image end when entrypoint is executed
	uc_mem_write(uc, ctx.m_InitReg.Rsp, &ctx.m_ImageEnd, sizeof(ctx.m_ImageEnd));
	uc_mem_map(uc, ctx.m_ImageEnd, 0x1000, UC_PROT_EXEC | UC_PROT_READ);

	uc_reg_write(uc, UC_X86_REG_RAX, &ctx.m_InitReg.Rax);
	uc_reg_write(uc, UC_X86_REG_RBX, &ctx.m_InitReg.Rbx);
	uc_reg_write(uc, UC_X86_REG_RCX, &ctx.m_InitReg.Rcx);
	uc_reg_write(uc, UC_X86_REG_RDX, &ctx.m_InitReg.Rdx);
	uc_reg_write(uc, UC_X86_REG_RSI, &ctx.m_InitReg.Rsi);
	uc_reg_write(uc, UC_X86_REG_RDI, &ctx.m_InitReg.Rdi);
	uc_reg_write(uc, UC_X86_REG_R8, &ctx.m_InitReg.R8);
	uc_reg_write(uc, UC_X86_REG_R9, &ctx.m_InitReg.R9);
	uc_reg_write(uc, UC_X86_REG_R10, &ctx.m_InitReg.R10);
	uc_reg_write(uc, UC_X86_REG_R11, &ctx.m_InitReg.R11);
	uc_reg_write(uc, UC_X86_REG_R12, &ctx.m_InitReg.R12);
	uc_reg_write(uc, UC_X86_REG_R13, &ctx.m_InitReg.R13);
	uc_reg_write(uc, UC_X86_REG_R14, &ctx.m_InitReg.R14);
	uc_reg_write(uc, UC_X86_REG_R15, &ctx.m_InitReg.R15);
	uc_reg_write(uc, UC_X86_REG_RBP, &ctx.m_InitReg.Rbp);
	uc_reg_write(uc, UC_X86_REG_RSP, &ctx.m_InitReg.Rsp);

	//////////////////////////////////////////////////////////////// HOOKS_SPACE
	{
		uc_hook_add(uc, &ucHookInvalidRwx, UC_HOOK_MEM_READ_UNMAPPED | UC_HOOK_MEM_WRITE_UNMAPPED |
			UC_HOOK_MEM_FETCH_UNMAPPED | UC_HOOK_MEM_FETCH_PROT | UC_HOOK_MEM_WRITE_PROT,
			ucHooks::HookInvalidRwx, &ctx, 1, 0);

		uc_hook_add(uc, &ucHookRwx, UC_HOOK_MEM_READ | UC_HOOK_MEM_WRITE | UC_HOOK_MEM_FETCH,
			ucHooks::HookRwx, &ctx, 1, 0);

		uc_hook_add(uc, &ucHookCode, UC_HOOK_CODE,
			ucHooks::HookCode, &ctx, 1, 0);

		uc_hook_add(uc, &ucHookIntr, UC_HOOK_INTR,
			ucHooks::HookIntr, &ctx, 1, 0);

		uc_hook_add(uc, &ucHookCpuid, UC_HOOK_INSN,
			ucHooks::HookCpuid, &ctx, 1, 0, UC_X86_INS_CPUID);

		uc_hook_add(uc, &ucHookSySCall, UC_HOOK_INSN,
			ucHooks::HookSySCall, &ctx, 1, 0, UC_X86_INS_SYSCALL);
	}
	//////////////////////////////////////////////////////////////// HOOKS_SPACE

	//Infinity while loop and start of emulation
	while (true)
	{
		err = uc_emu_start(uc, ctx.m_ExecuteFromRip, ctx.m_ImageEnd, 0, 0);

		if (ctx.m_LastException != STATUS_SUCCESS)
		{
			auto except = ctx.m_LastException;
			ctx.m_LastException = STATUS_SUCCESS;
			ctx.RtlRaiseStatus(except);
		}
		else { break; }
	}

	//////////////////////////////////////////////////////////////// HOOKS_SPACE
	{
		uc_hook_del(uc, ucHookInvalidRwx);
		uc_hook_del(uc, ucHookRwx);
		uc_hook_del(uc, ucHookCode);
		uc_hook_del(uc, ucHookIntr);
		uc_hook_del(uc, ucHookCpuid);
		uc_hook_del(uc, ucHookSySCall);
	}
	//////////////////////////////////////////////////////////////// HOOKS_SPACE

	DWORD_PTR result_rax = 0;
	uc_reg_read(uc, UC_X86_REG_RAX, &result_rax);

	//deumping of our image if we selected -dump flag
	if (ctx.m_Dump)
	{
		//virtual_buffer_t imagebuf(ctx.m_ImageEnd - ctx.m_ImageBase);
		//virtual_buffer_t RebuildSectionBuffer;
		//
		//uc_mem_read(uc, ctx.m_ImageBase, imagebuf.GetBuffer(), ctx.m_ImageEnd - ctx.m_ImageBase);
		//
		//auto ntheader = RtlImageNtHeader(imagebuf.GetBuffer());
		//
		//auto SectionHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)ntheader + sizeof(ntheader->Signature) + \
		//	sizeof(ntheader->FileHeader) + ntheader->FileHeader.SizeOfOptionalHeader);
		//
		//auto SectionCount = ntheader->FileHeader.NumberOfSections;
		//for (USHORT i = 0; i < SectionCount; ++i)
		//{
		//	SectionHeader[i].PointerToRawData = SectionHeader[i].VirtualAddress;
		//	SectionHeader[i].SizeOfRawData = SectionHeader[i].Misc.VirtualSize;
		//}
		//
		//ctx.RebuildSection(imagebuf.GetBuffer(), (DWORD)(ctx.m_ImageEnd - ctx.m_ImageBase), RebuildSectionBuffer);
		//
		//if (ctx.m_ImageRealEntry)
		//{
		//	ntheader->OptionalHeader.AddressOfEntryPoint = (DWORD)(ctx.m_ImageRealEntry - ctx.m_ImageBase);
		//}
		//
		//auto dumpfile = filename + ".dump";
		//
		//FILE* fp = nullptr;
		//fopen_s(&fp, dumpfile.c_str(), "wb");
		//
		//fwrite(imagebuf.GetBuffer(), ctx.m_ImageEnd - ctx.m_ImageBase, 1, fp);
		//
		//if (RebuildSectionBuffer.GetBuffer())
		//{
		//	fwrite(RebuildSectionBuffer.GetBuffer(), RebuildSectionBuffer.GetLength(), 1, fp);
		//}
		//
		//fclose(fp);
	}

	uc_close(uc);

	ctx.thisProc.mmap().UnmapAllModules();

	*outs << "uc_emu_start return: " << std::dec << err << "\n";

	*outs << "entrypoint return: " << std::hex << result_rax << "\n";
	*outs << "last rip: " << std::hex << ctx.m_LastRip;

	std::stringstream RipRegion, RealentryRegion;
	if (ctx.FindAddressInRegion(ctx.m_LastRip, RipRegion))
		*outs << " (" << RipRegion.str() << ")\n";

	if (ctx.m_ImageRealEntry)
	{
		if (ctx.FindAddressInRegion(ctx.m_ImageRealEntry, RealentryRegion))
			*outs << "real entrypoint: " << RealentryRegion.str() << "\n";
	}

	outs->flush();

	return 0;
}
```

`PeVisor/Src/Map.cpp`:

```cpp
#include "UCPE.hpp"

extern "C"
{
	NTSYSAPI
		PIMAGE_NT_HEADERS
		NTAPI
		RtlImageNtHeader(IN PVOID BaseAddress);

	NTSYSAPI
		PVOID
		NTAPI
		RtlImageDirectoryEntryToData(
			PVOID BaseAddress,
			BOOLEAN MappedAsImage,
			USHORT Directory,
			PULONG Size
		);
}

static ULONG ExtractEntryPointRva(PVOID ModuleBase)
{
	return RtlImageNtHeader(ModuleBase)->OptionalHeader.AddressOfEntryPoint;
}

blackbone::LoadData ManualMapCallback(blackbone::CallbackType type, void* context, blackbone::Process& /*process*/, const blackbone::ModuleData& modInfo)
{
	PeEmulation* ctx = (PeEmulation*)context;
	//if (type == blackbone::ImageCallback)
	//{
	//	//uint64_t desiredBase = ctx->m_LoadModuleBase;
	//	//uint64_t desiredNextLoadBase = PAGE_ALIGN_64k((uint64_t)ctx->m_LoadModuleBase + (uint64_t)modInfo.size + 0x10000ull);
	//	//ctx->m_LoadModuleBase = desiredNextLoadBase;

	//	return blackbone::LoadData(blackbone::MT_Default, blackbone::Ldr_None, ctx->m_LoadModuleBase);
	//}
	if (type == blackbone::PostCallback)
	{
		ctx->MapImageToEngine(modInfo.fullPath, modInfo.name, (PVOID)modInfo.imgPtr, modInfo.size, modInfo.baseAddress,
			(ULONG64)modInfo.baseAddress + ExtractEntryPointRva((PVOID)modInfo.imgPtr));
	}

	return blackbone::LoadData(blackbone::MT_Default, blackbone::Ldr_None, 0);
}

void PeEmulation::MapImageToEngine(
	_In_ const std::filesystem::path& FullPath,
	_In_ const std::wstring& ImageName, 
	_In_ PVOID ImageBase,
	_In_ ULONG ImageSize, 
	_In_ DWORD_PTR MappedBase, 
	_In_ DWORD_PTR EntryPoint)
{
	FakeModule* mod = new FakeModule(MappedBase, ImageSize, EntryPoint, ImageName, FullPath);

	mod->ImgPtr = ImageBase;

	if (!_wcsicmp(ImageName.c_str(), L"ntoskrnl.exe"))
		mod->Priority = 100;
	else if (!_wcsicmp(ImageName.c_str(), L"hal.dll"))
		mod->Priority = 99;

	auto ExceptionTable = RtlImageDirectoryEntryToData(ImageBase,
		TRUE,
		IMAGE_DIRECTORY_ENTRY_EXCEPTION,
		&mod->ExceptionTableSize);

	mod->ExceptionTable = MappedBase + ((PUCHAR)ExceptionTable - (PUCHAR)ImageBase);

	RtlInsertInvertedFunctionTable(&m_PsInvertedFunctionTable, MappedBase, ImageBase, ImageSize);

	m_FakeModules.push_back(mod);

	LdrResolveExportTable(mod, ImageBase, MappedBase);

	DWORD_PTR image_base = MappedBase;
	DWORD_PTR image_end = PAGE_ALIGN_64(image_base + ImageSize);

	if (image_end != image_base)
		uc_mem_map(m_uc, image_base, (size_t)(image_end - image_base), UC_PROT_READ);
	else
		uc_mem_map(m_uc, image_base, PAGE_SIZE, UC_PROT_READ);

	uc_mem_write(m_uc, image_base, ImageBase, ImageSize);

	auto ntheader = (PIMAGE_NT_HEADERS)RtlImageNtHeader(ImageBase);

	DWORD SectionAlignment;

	if (ntheader->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64)
	{
		auto ntheader64 = (PIMAGE_NT_HEADERS64)ntheader;
		SectionAlignment = ntheader64->OptionalHeader.SectionAlignment;
	}
	else
	{
		SectionAlignment = ntheader->OptionalHeader.SectionAlignment;
	}

	auto SectionHeader = (PIMAGE_SECTION_HEADER)((PUCHAR)ntheader + sizeof(ntheader->Signature) + \
		sizeof(ntheader->FileHeader) + ntheader->FileHeader.SizeOfOptionalHeader);

	for (WORD i = 0; i < ntheader->FileHeader.NumberOfSections; i++)
	{
		DWORD EmuflProtect = UC_PROT_READ;
		DWORD RealflProtect = PAGE_READONLY;
		if (SectionHeader[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
		{
			RealflProtect = PAGE_EXECUTE_READ;
			EmuflProtect |= UC_PROT_EXEC;
		}
		if (SectionHeader[i].Characteristics & IMAGE_SCN_MEM_WRITE)
		{
			RealflProtect = PAGE_EXECUTE_READWRITE;
			EmuflProtect |= UC_PROT_WRITE;
		}

		auto SectionSize = AlignSize(
			max(SectionHeader[i].Misc.VirtualSize, SectionHeader[i].SizeOfRawData),
			SectionAlignment);

		uc_mem_protect(m_uc, image_base + SectionHeader[i].VirtualAddress, SectionSize, EmuflProtect);

		if (SectionHeader[i].Characteristics & (IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_CNT_CODE))
		{
			bool bIsUnknownSection = (0 == memcmp((char*)SectionHeader[i].Name, ".text\0\0\0", 8)
				|| 0 == memcmp((char*)SectionHeader[i].Name, "INIT\0\0\0\0", 8)
				|| 0 == memcmp((char*)SectionHeader[i].Name, "PAGE\0\0\0\0", 8)) ? false : true;

			mod->FakeSections.emplace_back(
				SectionHeader[i].VirtualAddress, 
				RealflProtect, 
				EmuflProtect, 
				SectionSize,
				(char*)SectionHeader[i].Name,
				bIsUnknownSection);

			uc_hook trace3;
			uc_hook_add(m_uc, &trace3, UC_HOOK_CODE, ucHooks::EmuUnknownAPI,
				this, image_base + SectionHeader[i].VirtualAddress,
				image_base + SectionHeader[i].VirtualAddress + SectionSize - 1);
		}
	}
}
```

`PeVisor/Src/Memory.cpp`:

```cpp
#include "UCPE.hpp"

// About: Function for stack allocation
// Param 1: size of bytes
// Mode: Usermode + Kernelmode
DWORD_PTR PeEmulation::StackAlloc(_In_ size_t AllocBytes)
{
	DWORD_PTR rsp;
	uc_reg_read(m_uc, UC_X86_REG_RSP, &rsp);
	rsp -= AllocBytes;
	uc_reg_write(m_uc, UC_X86_REG_RSP, &rsp);
	return rsp;
}

// About: Function for stack free
// Param 1: size of bytes
// Mode: Usermode + Kernelmode
void PeEmulation::StackFree(_In_ size_t AllocBytes)
{
	DWORD_PTR rsp;
	uc_reg_read(m_uc, UC_X86_REG_RSP, &rsp);
	rsp += AllocBytes;
	uc_reg_write(m_uc, UC_X86_REG_RSP, &rsp);
}

// About: Function for heap allocation
// Param 1: size of bytes
// Param 2: page alignment
// Mode: Usermode + Kernelmode
DWORD_PTR PeEmulation::HeapAlloc(_In_ size_t AllocBytes, _In_opt_ bool IsPageAlign)
{
	DWORD_PTR alloc = 0;

	for (size_t i = 0; i < m_HeapAllocs.size(); ++i)
	{
		if (m_HeapAllocs[i].free && m_HeapAllocs[i].size >= AllocBytes)
		{
			m_LastHeapAllocBytes = AllocBytes;
			m_HeapAllocs[i].free = false;
			alloc = m_HeapAllocs[i].base;
			break;
		}
	}

	if (!alloc)
	{
		for (size_t i = 0; i < m_HeapAllocs.size(); ++i)
		{
			if (alloc < m_HeapAllocs[i].base + m_HeapAllocs[i].size)
				alloc = m_HeapAllocs[i].base + m_HeapAllocs[i].size;
		}

		if (!alloc)
			alloc = m_HeapBase;

		if (IsPageAlign)
		{
			alloc = (alloc % 0x1000ull == 0) ? alloc : AlignSize(alloc, 0x1000ull);
			AllocBytes = (AllocBytes % 0x1000 == 0) ? AllocBytes : (ULONG)AlignSize(AllocBytes, 0x1000);
		}

		if (alloc + AllocBytes > m_HeapEnd)
		{
			m_LastHeapAllocBytes = 0;
			return 0;
		}

		m_LastHeapAllocBytes = AllocBytes;
		m_HeapAllocs.emplace_back(alloc, AllocBytes);
	}

	return alloc;
}

// About: Function for heap free
// Param 1: size of bytes
// Mode: Usermode + Kernelmode
bool PeEmulation::HeapFree(_In_ DWORD_PTR FreeAddress)
{
	DWORD_PTR maxaddr = 0;

	for (size_t i = 0; i < m_HeapAllocs.size(); ++i)
	{
		if (maxaddr < m_HeapAllocs[i].base)
			maxaddr = m_HeapAllocs[i].base;
	}

	for (size_t i = 0; i < m_HeapAllocs.size(); ++i)
	{
		if (!m_HeapAllocs[i].free && m_HeapAllocs[i].base == FreeAddress)
		{
			if (maxaddr == FreeAddress)
				m_HeapAllocs.erase(m_HeapAllocs.begin() + i);
			else
				m_HeapAllocs[i].free = true;
			return true;
		}
	}
	return false;
}

// About: Function for create memory mapping
// Param 1: src address
// Param 2: dst address
// Param 3: size of bytes
// Mode: Usermode + Kernelmode
bool PeEmulation::CreateMemMapping(_In_ DWORD_PTR BaseAddress, _In_ DWORD_PTR MapAddress, _In_ size_t Bytes)
{
	Bytes = AlignSize(Bytes, 0x1000ull);

	virtual_buffer_t buf(Bytes);
	uc_mem_read(m_uc, BaseAddress, buf.GetBuffer(), Bytes);
	uc_mem_write(m_uc, MapAddress, buf.GetBuffer(), Bytes);

	m_MemMappings.emplace_back(BaseAddress, MapAddress, Bytes);

	return true;
}

// About: Function for deletion of memory map page
// Param 1: addr to delete, i.e. param 2 addr from `CreateMemMapping`
// Mode: Usermode + Kernelmode
void PeEmulation::DeleteMemMapping(_In_ DWORD_PTR MapAddress)
{
	for (auto itor = m_MemMappings.begin(); itor != m_MemMappings.end();)
	{
		if (itor->mappedva == MapAddress)
		{
			itor = m_MemMappings.erase(itor);
			return;
		}
		else
		{
			itor++;
		}
	}
}

// About: Function for write to memory mapped region
// Param 1: src address
// Param 2: val to write
// Param 3: size of val
// Mode: Usermode + Kernelmode
bool PeEmulation::WriteMemMapping(_In_ DWORD_PTR baseaddress, _In_ DWORD_PTR value, _In_ size_t size)
{
	for (size_t i = 0; i < m_MemMappings.size(); ++i)
	{
		if (baseaddress >= m_MemMappings[i].mappedva && baseaddress < m_MemMappings[i].mappedva + m_MemMappings[i].size)
		{
			auto mapaddress = m_MemMappings[i].baseva + (baseaddress - m_MemMappings[i].mappedva);
			m_MemMappings[i].blocks.emplace_back(mapaddress, value, size);
			return true;
		}
	}
	return false;
}

// About: Function for fulshing of memory map
// Mode: Usermode + Kernelmode
void PeEmulation::FlushMemMapping(_In_ void)
{
	for (size_t i = 0; i < m_MemMappings.size(); ++i)
	{
		for (size_t j = 0; j < m_MemMappings[i].blocks.size(); ++j)
		{
			uc_mem_write(m_uc, m_MemMappings[i].blocks[j].va, &m_MemMappings[i].blocks[j].value, m_MemMappings[i].blocks[j].size);
		}
		m_MemMappings[i].blocks.clear();
	}
}
```

`PeVisor/Src/Rtls.cpp`:

```cpp
#include "UCPE.hpp"

extern "C"
{
	NTSYSAPI
		PVOID
		NTAPI
		RtlImageDirectoryEntryToData(
			PVOID BaseAddress,
			BOOLEAN MappedAsImage,
			USHORT Directory,
			PULONG Size
		);
}

LPTOP_LEVEL_EXCEPTION_FILTER PeEmulation::SetUnhandledExceptionFilter(
	_In_ LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
{
	LPTOP_LEVEL_EXCEPTION_FILTER PreviousTopLevelFilter;

	PreviousTopLevelFilter = BasepCurrentTopLevelFilter;
	BasepCurrentTopLevelFilter = lpTopLevelExceptionFilter;

	return PreviousTopLevelFilter;
}

void PeEmulation::RtlInitializeSListHead(_Inout_ PSLIST_HEADER ListHead)
{
	if (((uint8_t)ListHead & 0xF) != 0)
	{
		RtlRaiseStatus(EXCEPTION_DATATYPE_MISALIGNMENT);
	}

	*ListHead = {0};
}

BOOLEAN RtlpIsFrameInBounds(
	_Inout_ PDWORD_PTR LowLimit,
	_In_ DWORD_PTR StackFrame,
	_Inout_ PDWORD_PTR HighLimit
)
{
	if ((StackFrame & 0x7) != 0) {
		return FALSE;
	}

	if ((StackFrame < *LowLimit) ||
		(StackFrame >= *HighLimit)) {

		return FALSE;

	}
	else {
		return TRUE;
	}
}

PRUNTIME_FUNCTION RtlpSearchInvertedFunctionTable(
	_In_ PINVERTED_FUNCTION_TABLE InvertedTable,
	_In_ PVOID ControlPc,
	_Out_ PVOID* ImageBase,
	_Out_ PULONG SizeOfTable
)

/*++

Routine Description:

	This function searches for a matching entry in an inverted function
	table using the specified control PC value.

	N.B. It is assumed that appropriate locks are held when this routine
		 is called.

Arguments:

	InvertedTable - Supplies a pointer to an inverted function table.

	ControlPc - Supplies a PC value to to use in searching the inverted
		function table.

	ImageBase - Supplies a pointer to a variable that receives the base
		 address of the corresponding module.

	SizeOfTable - Supplies a pointer to a variable that receives the size
		 of the function table in bytes.

Return Value:

	If a matching entry is located in the specified function table, then
	the function table address is returned as the function value. Otherwise,
	a value of NULL is returned.

--*/

{

	PVOID Bound;
	LONG High;
	//ULONG Index;
	PINVERTED_FUNCTION_TABLE_ENTRY InvertedEntry;
	LONG Low;
	LONG Middle;

	//
	// If there are any entries in the specified inverted function table,
	// then search the table for a matching entry.
	//

	if (InvertedTable->CurrentSize != 0) {
		Low = 0;
		High = InvertedTable->CurrentSize - 1;
		while (High >= Low) {

			//
			// Compute next probe index and test entry. If the specified
			// control PC is greater than of equal to the beginning address
			// and less than the ending address of the inverted function
			// table entry, then return the address of the function table.
			// Otherwise, continue the search.
			//

			Middle = (Low + High) >> 1;
			InvertedEntry = &InvertedTable->TableEntry[Middle];
			Bound = (PVOID)((ULONG_PTR)InvertedEntry->ImageBase + InvertedEntry->SizeOfImage);
			if (ControlPc < InvertedEntry->ImageBase) {
				High = Middle - 1;

			}
			else if (ControlPc >= Bound) {
				Low = Middle + 1;

			}
			else {
				*ImageBase = InvertedEntry->ImageBase;
				*SizeOfTable = InvertedEntry->SizeOfTable;
				return InvertedEntry->FunctionTable;
			}
		}
	}

	return NULL;
}

void PeEmulation::RtlInsertInvertedFunctionTable(
	_Inout_ PINVERTED_FUNCTION_TABLE InvertedTable,
	_In_ DWORD_PTR MappedBase,
	_In_ PVOID ImageBase,
	_In_ ULONG SizeOfImage
) {

	ULONG CurrentSize;
	PVOID FunctionTable;
	ULONG Index;
	ULONG SizeOfTable;

	//
	// If the inverted table is not full, then insert the entry in the
	// specified inverted table.
	//

	CurrentSize = InvertedTable->CurrentSize;
	if (CurrentSize != InvertedTable->MaximumSize) {

		//
		// If the inverted table has no entries, then insert the new entry as
		// the first entry. Otherwise, search the inverted table for the proper
		// insert position, shuffle the table, and insert the new entry.
		//

		Index = 0;
		if (CurrentSize != 0) {
			for (Index = 0; Index < CurrentSize; Index += 1) {
				if (ImageBase < InvertedTable->TableEntry[Index].ImageBase) {
					break;
				}
			}

			//
			// If the new entry does not go at the end of the specified table,
			// then shuffle the table down to make room for the new entry.
			//

			if (Index != CurrentSize) {
				RtlMoveMemory(&InvertedTable->TableEntry[Index + 1],
					&InvertedTable->TableEntry[Index],
					(CurrentSize - Index) * sizeof(INVERTED_FUNCTION_TABLE_ENTRY));
			}
		}

		//
		// Insert the specified entry in the specified inverted function table.
		//

		FunctionTable = RtlImageDirectoryEntryToData(ImageBase,
			TRUE,
			IMAGE_DIRECTORY_ENTRY_EXCEPTION,
			&SizeOfTable);

		InvertedTable->TableEntry[Index].FunctionTable = (PRUNTIME_FUNCTION)(MappedBase + ((PUCHAR)FunctionTable - (PUCHAR)ImageBase));
		InvertedTable->TableEntry[Index].ImageBase = (PVOID)MappedBase;
		InvertedTable->TableEntry[Index].SizeOfImage = SizeOfImage;
		InvertedTable->TableEntry[Index].SizeOfTable = SizeOfTable;
		InvertedTable->CurrentSize += 1;
	}
	else {
		InvertedTable->Overflow = TRUE;
	}

	return;
}

NTSTATUS PeEmulation::RaiseException(
	_In_ PEXCEPTION_RECORD ExceptionRecord,
	_In_ PCONTEXT ContextRecord,
	_In_ BOOLEAN FirstChance)
{
	return STATUS_SUCCESS;
}

void PeEmulation::RtlpGetStackLimits(
	_Out_ PDWORD_PTR LowLimit,
	_Out_ PDWORD_PTR HighLimit
)
{
	*LowLimit = m_StackBase;
	*HighLimit = m_StackEnd;
}

void PeEmulation::RtlRaiseStatus(_In_ NTSTATUS Status)
{
	CONTEXT ContextRecord;
	EXCEPTION_RECORD ExceptionRecord;

	//
	// Capture the current context and construct an exception record.
	//

	RtlpCaptureContext(&ContextRecord);
	ExceptionRecord.ExceptionCode = Status;
	ExceptionRecord.ExceptionRecord = NULL;
	ExceptionRecord.NumberParameters = 0;
	ExceptionRecord.ExceptionFlags = EXCEPTION_NONCONTINUABLE;
#ifdef _WIN64
	ExceptionRecord.ExceptionAddress = (PVOID)ContextRecord.Rip;
#else 
	ExceptionRecord.ExceptionAddress = (PVOID)ContextRecord.Eip;
#endif
	//
	// Attempt to dispatch the exception.
	//
	// N.B. This exception is non-continuable.
	//

	RtlpDispatchException(&ExceptionRecord, &ContextRecord);
	Status = RaiseException(&ExceptionRecord, &ContextRecord, FALSE);
}

PRUNTIME_FUNCTION PeEmulation::RtlpLookupFunctionTable(
	_In_ PVOID ControlPc,
	_Out_ PVOID* ImageBase,
	_Out_ PULONG SizeOfTable
)
{
	PVOID Base;
	ULONG_PTR Bound;

	PKLDR_DATA_TABLE_ENTRY Entry;

	PLIST_ENTRY Next;

	PRUNTIME_FUNCTION FunctionTable;

	FunctionTable = RtlpSearchInvertedFunctionTable(&m_PsInvertedFunctionTable,
		ControlPc,
		&Base,
		SizeOfTable);

	if ((FunctionTable == NULL) &&
		(m_PsInvertedFunctionTable.Overflow != FALSE))

	{
		LIST_ENTRY PsLoadedModuleList;
		uc_mem_read(m_uc, m_PsLoadedModuleListBase, &PsLoadedModuleList, sizeof(PsLoadedModuleList));

		Next = PsLoadedModuleList.Flink;
		if (Next != NULL) {
			while (Next != (PLIST_ENTRY)m_PsLoadedModuleListBase) {
				Entry = CONTAINING_RECORD(Next,
					KLDR_DATA_TABLE_ENTRY,
					InLoadOrderLinks);

				uc_mem_read(m_uc, (DWORD_PTR)Entry + offsetof(KLDR_DATA_TABLE_ENTRY, DllBase), &Base, sizeof(Base));

				ULONG SizeOfImage;
				uc_mem_read(m_uc, (DWORD_PTR)Entry + offsetof(KLDR_DATA_TABLE_ENTRY, SizeOfImage), &SizeOfImage, sizeof(SizeOfImage));

				Bound = (ULONG_PTR)Base + SizeOfImage;
				if (((ULONG_PTR)ControlPc >= (ULONG_PTR)Base) &&
					((ULONG_PTR)ControlPc < Bound)) {

					ULONG sizeOfTable;
					uc_mem_read(m_uc, (DWORD_PTR)Entry + offsetof(KLDR_DATA_TABLE_ENTRY, ExceptionTable), &FunctionTable, sizeof(FunctionTable));
					uc_mem_read(m_uc, (DWORD_PTR)Entry + offsetof(KLDR_DATA_TABLE_ENTRY, ExceptionTableSize), &sizeOfTable, sizeof(sizeOfTable));

					*SizeOfTable = sizeOfTable;
					break;
				}

				PLIST_ENTRY ptrFlink;
				uc_mem_read(m_uc, (DWORD_PTR)Next + offsetof(LIST_ENTRY, Flink), &ptrFlink, sizeof(ptrFlink));
				Next = ptrFlink;
			}
		}
	}

	*ImageBase = Base;
	return FunctionTable;
}

PRUNTIME_FUNCTION PeEmulation::RtlpConvertFunctionEntry(
	_In_ PRUNTIME_FUNCTION FunctionEntry,
	_In_ DWORD_PTR ImageBase
)
{

	//
	// If the specified function entry is not NULL and specifies indirection,
	// then compute the address of the master function table entry.
	//

	if (FunctionEntry) {
		RUNTIME_FUNCTION FunctionEntryCell;
		uc_mem_read(m_uc, (DWORD_PTR)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));

		if ((FunctionEntryCell.UnwindData & RUNTIME_FUNCTION_INDIRECT) != 0) {
			FunctionEntry = (PRUNTIME_FUNCTION)(FunctionEntryCell.UnwindData + ImageBase - 1);
		}
	}

	return FunctionEntry;
}

PRUNTIME_FUNCTION PeEmulation::RtlpLookupFunctionEntry(
	_In_ DWORD_PTR ControlPc,
	_Out_ PDWORD_PTR ImageBase,
	_Inout_ PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL
)
{

	DWORD_PTR BaseAddress;
	DWORD_PTR BeginAddress;
	DWORD_PTR EndAddress;
	PRUNTIME_FUNCTION FunctionEntry = NULL;
	PRUNTIME_FUNCTION FunctionTable = NULL;
	LONG High;
	ULONG Index;
	LONG Low;
	LONG Middle;
	ULONG RelativePc;
	ULONG SizeOfTable;

	//
	// Attempt to find an image that contains the specified control PC. If
	// an image is found, then search its function table for a function table
	// entry that contains the specified control PC. If an image is not found
	// then search the dynamic function table for an image that contains the
	// specified control PC.
	//
	// If a history table is supplied and search is specfied, then the current
	// operation that is being performed is the unwind phase of an exception
	// dispatch followed by a unwind. 
	//

	if (HistoryTable &&
		(HistoryTable->Search != UNWIND_HISTORY_TABLE_NONE)) {

		//
		// Search the global unwind history table if there is a chance of a
		// match.
		//
		// N.B. The global unwind history table never contains indirect entries.
		//

		/*if (HistoryTable->Search == UNWIND_HISTORY_TABLE_GLOBAL) {
			if ((ControlPc >= RtlpUnwindHistoryTable.LowAddress) &&
				(ControlPc < RtlpUnwindHistoryTable.HighAddress)) {

				for (Index = 0; Index < RtlpUnwindHistoryTable.Count; Index += 1) {
					BaseAddress = RtlpUnwindHistoryTable.Entry[Index].ImageBase;
					FunctionEntry = RtlpUnwindHistoryTable.Entry[Index].FunctionEntry;
					BeginAddress = FunctionEntry->BeginAddress + BaseAddress;
					EndAddress = FunctionEntry->EndAddress + BaseAddress;
					if ((ControlPc >= BeginAddress) && (ControlPc < EndAddress)) {
						*ImageBase = BaseAddress;
						return FunctionEntry;
					}
				}
			}

			HistoryTable->Search = UNWIND_HISTORY_TABLE_LOCAL;
		}*/

		//
		// Search the dynamic unwind history table if there is a chance of a
		// match.
		//
		// N.B. The dynamic unwind history table can contain indirect entries.
		//

		if ((ControlPc >= HistoryTable->LowAddress) &&
			(ControlPc < HistoryTable->HighAddress)) {

			for (Index = 0; Index < HistoryTable->Count; Index += 1) {
				BaseAddress = HistoryTable->Entry[Index].ImageBase;
				FunctionEntry = HistoryTable->Entry[Index].FunctionEntry;

				RUNTIME_FUNCTION FunctionEntryCell;
				uc_mem_read(m_uc, (DWORD_PTR)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));

				BeginAddress = FunctionEntryCell.BeginAddress + BaseAddress;
				EndAddress = FunctionEntryCell.EndAddress + BaseAddress;
				if ((ControlPc >= BeginAddress) && (ControlPc < EndAddress)) {
					*ImageBase = BaseAddress;
					return RtlpConvertFunctionEntry(FunctionEntry, *ImageBase);
				}
			}
		}
	}

	//
	// There was not a match in either of the unwind history tables so attempt
	// to find a matching entry in the loaded module list.
	//

	FunctionTable = RtlpLookupFunctionTable((PVOID)ControlPc,
		(PVOID*)ImageBase,
		&SizeOfTable);

	//
	// If a function table is located, then search for a function table
	// entry that contains the specified control PC.
	//

	if (FunctionTable != NULL) {
		Low = 0;
		High = (SizeOfTable / sizeof(RUNTIME_FUNCTION)) - 1;
		RelativePc = (ULONG)(ControlPc - *ImageBase);
		while (High >= Low) {

			//
			// Compute next probe index and test entry. If the specified
			// control PC is greater than of equal to the beginning address
			// and less than the ending address of the function table entry,
			// then return the address of the function table entry. Otherwise,
			// continue the search.
			//

			Middle = (Low + High) >> 1;
			FunctionEntry = &FunctionTable[Middle];

			RUNTIME_FUNCTION FunctionEntryCell;
			uc_mem_read(m_uc, (DWORD_PTR)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));

			if (RelativePc < FunctionEntryCell.BeginAddress) {
				High = Middle - 1;

			}
			else if (RelativePc >= FunctionEntryCell.EndAddress) {
				Low = Middle + 1;
			}
			else {
				break;
			}
		}

		if (High < Low) {
			FunctionEntry = NULL;
		}

	}
	else {

		//
		// There was not a match in the loaded module list so attempt to find
		// a matching entry in the dynamic function table list.
		//

		FunctionEntry = NULL;
	}

	//
	// If a function table entry was located, search is not specified, and
	// the specfied history table is not full, then attempt to make an entry
	// in the history table.
	//

	if (FunctionEntry != NULL) {
		if (HistoryTable &&
			(HistoryTable->Search == UNWIND_HISTORY_TABLE_NONE) &&
			(HistoryTable->Count < UNWIND_HISTORY_TABLE_SIZE)) {

			Index = HistoryTable->Count;
			HistoryTable->Count += 1;
			HistoryTable->Entry[Index].ImageBase = *ImageBase;
			HistoryTable->Entry[Index].FunctionEntry = FunctionEntry;
			RUNTIME_FUNCTION FunctionEntryCell;
			uc_mem_read(m_uc, (DWORD_PTR)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));
			BeginAddress = FunctionEntryCell.BeginAddress + *ImageBase;
			EndAddress = FunctionEntryCell.EndAddress + *ImageBase;
			if (BeginAddress < HistoryTable->LowAddress) {
				HistoryTable->LowAddress = BeginAddress;

			}

			if (EndAddress > HistoryTable->HighAddress) {
				HistoryTable->HighAddress = EndAddress;
			}
		}
	}

	return RtlpConvertFunctionEntry(FunctionEntry, *ImageBase);
}

PUNWIND_INFO PeEmulation::RtlpLookupPrimaryUnwindInfo(
	_In_ PRUNTIME_FUNCTION FunctionEntry,
	_In_ DWORD_PTR ImageBase,
	_Out_ PRUNTIME_FUNCTION* PrimaryEntry
)
{
	ULONG Index;
	PUNWIND_INFO UnwindInfo;
	RUNTIME_FUNCTION FunctionEntryCell;
	uc_mem_read(m_uc, (DWORD_PTR)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));

	//
	// Locate the unwind information and determine whether it is chained.
	// If the unwind information is chained, then locate the parent function
	// entry and loop again.
	//

	do {
		UnwindInfo = (PUNWIND_INFO)(FunctionEntryCell.UnwindData + ImageBase);

		crt_buffer_t UnwindInfoCell(offsetof(UNWIND_INFO, UnwindCode));
		uc_mem_read(m_uc, (DWORD_PTR)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
		PUNWIND_INFO UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();
		UnwindInfoCell.GetSpace(offsetof(UNWIND_INFO, UnwindCode) + UnwindInfoCellPtr->CountOfCodes * sizeof(UNWIND_CODE));
		uc_mem_read(m_uc, (DWORD_PTR)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
		UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();

		if ((UnwindInfoCellPtr->Flags & UNW_FLAG_CHAININFO) == 0) {
			break;
		}

		Index = UnwindInfoCellPtr->CountOfCodes;
		if ((Index & 1) != 0) {
			Index += 1;
		}

		FunctionEntry = (PRUNTIME_FUNCTION)&UnwindInfoCellPtr->UnwindCode[Index];
	} while (TRUE);

	*PrimaryEntry = FunctionEntry;
	return UnwindInfo;
}

PRUNTIME_FUNCTION PeEmulation::RtlpSameFunction(
	_In_ PRUNTIME_FUNCTION FunctionEntry,
	_In_ DWORD_PTR ImageBase,
	_In_ DWORD_PTR ControlPc
)
{

	PRUNTIME_FUNCTION PrimaryFunctionEntry;
	PRUNTIME_FUNCTION TargetFunctionEntry;
	DWORD_PTR TargetImageBase;
	PUNWIND_INFO UnwindInfo1;
	PUNWIND_INFO UnwindInfo2;

	//
	// Lookup the primary function entry associated with the specified
	// function entry.
	// 

	UnwindInfo1 = RtlpLookupPrimaryUnwindInfo(FunctionEntry,
		ImageBase,
		&PrimaryFunctionEntry);

	//
	// Determine the function entry containing the control Pc and similarly
	// resolve its primary function entry.  If no function entry can be
	// found then the control pc resides in a different function.
	//

	TargetFunctionEntry = RtlpLookupFunctionEntry(ControlPc,
		&TargetImageBase,
		NULL);

	if (TargetFunctionEntry == NULL) {
		return NULL;
	}

	//
	// Lookup the primary function entry associated with the target function
	// entry.
	//

	UnwindInfo2 = RtlpLookupPrimaryUnwindInfo(TargetFunctionEntry,
		TargetImageBase,
		&PrimaryFunctionEntry);

	//
	// If the address of the two sets of unwind information are equal, then
	// return the address of the primary function entry. Otherwise, return
	// NULL.
	//

	if (UnwindInfo1 == UnwindInfo2) {
		return PrimaryFunctionEntry;

	}
	else {
		return NULL;
	}
}

#ifdef _WIN64

void RtlpCopyContext(
	_Out_ PCONTEXT Destination,
	_In_ PCONTEXT Source
) {

	//
	// Copy nonvolatile context required for exception dispatch and unwind.
	//

	Destination->Rip = Source->Rip;
	Destination->Rbx = Source->Rbx;
	Destination->Rsp = Source->Rsp;
	Destination->Rbp = Source->Rbp;
	Destination->Rsi = Source->Rsi;
	Destination->Rdi = Source->Rdi;
	Destination->R12 = Source->R12;
	Destination->R13 = Source->R13;
	Destination->R14 = Source->R14;
	Destination->R15 = Source->R15;
	Destination->Xmm6 = Source->Xmm6;
	Destination->Xmm7 = Source->Xmm7;
	Destination->Xmm8 = Source->Xmm8;
	Destination->Xmm9 = Source->Xmm9;
	Destination->Xmm10 = Source->Xmm10;
	Destination->Xmm11 = Source->Xmm11;
	Destination->Xmm12 = Source->Xmm12;
	Destination->Xmm13 = Source->Xmm13;
	Destination->Xmm14 = Source->Xmm14;
	Destination->Xmm15 = Source->Xmm15;
	Destination->SegCs = Source->SegCs;
	Destination->SegSs = Source->SegSs;
	Destination->MxCsr = Source->MxCsr;
	Destination->EFlags = Source->EFlags;

	return;
}

//Make x86 bit version of this function
PRUNTIME_FUNCTION PeEmulation::RtlpUnwindPrologue(
	_In_ DWORD_PTR ImageBase,
	_In_ DWORD_PTR ControlPc,
	_In_ DWORD_PTR FrameBase,
	_In_ PRUNTIME_FUNCTION FunctionEntry,
	_Inout_ PCONTEXT ContextRecord,
	_Inout_ PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
)
{

	PM128A FloatingAddress;
	PM128A FloatingRegister;
	ULONG FrameOffset;
	ULONG Index;
	PDWORD_PTR IntegerAddress;
	PDWORD_PTR IntegerRegister;
	BOOLEAN MachineFrame;
	ULONG OpInfo;
	ULONG PrologOffset;
	//PDWORD_PTR RegisterAddress;
	PDWORD_PTR ReturnAddress;
	PDWORD_PTR StackAddress;
	//PUNWIND_CODE UnwindCode;
	PUNWIND_INFO UnwindInfo;
	ULONG UnwindOp;
	DWORD_PTR ValueFromAddress;

	//
	// Process the unwind codes.
	//

	FloatingRegister = &ContextRecord->Xmm0;
	IntegerRegister = &ContextRecord->Rax;
	Index = 0;
	MachineFrame = FALSE;

	RUNTIME_FUNCTION FunctionEntryCell;
	uc_mem_read(m_uc, (DWORD_PTR)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));

	PrologOffset = (ULONG)(ControlPc - (FunctionEntryCell.BeginAddress + ImageBase));
	UnwindInfo = (PUNWIND_INFO)(FunctionEntryCell.UnwindData + ImageBase);

	crt_buffer_t UnwindInfoCell(offsetof(UNWIND_INFO, UnwindCode));
	uc_mem_read(m_uc, (DWORD_PTR)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
	PUNWIND_INFO UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();
	UnwindInfoCell.GetSpace(offsetof(UNWIND_INFO, UnwindCode) + UnwindInfoCellPtr->CountOfCodes * sizeof(UNWIND_CODE) + sizeof(DWORD) * 2);
	uc_mem_read(m_uc, (DWORD_PTR)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
	UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();

	while (Index < UnwindInfoCellPtr->CountOfCodes) {

		//
		// If the prologue offset is greater than the next unwind code offset,
		// then simulate the effect of the unwind code.
		//

		UnwindOp = UnwindInfoCellPtr->UnwindCode[Index].UnwindOp;
		OpInfo = UnwindInfoCellPtr->UnwindCode[Index].OpInfo;
		if (PrologOffset >= UnwindInfoCellPtr->UnwindCode[Index].CodeOffset) {
			switch (UnwindOp) {

				//
				// Push nonvolatile integer register.
				//
				// The operation information is the register number of the
				// register than was pushed.
				//

			case UWOP_PUSH_NONVOL:
				IntegerAddress = (PDWORD_PTR)(ContextRecord->Rsp);

				uc_mem_read(m_uc, (DWORD_PTR)IntegerAddress, &ValueFromAddress, sizeof(ValueFromAddress));

				IntegerRegister[OpInfo] = ValueFromAddress;
				if (ContextPointers) {
					ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
				}

				ContextRecord->Rsp += 8;
				break;

				//
				// Allocate a large sized area on the stack.
				//
				// The operation information determines if the size is
				// 16- or 32-bits.
				//

			case UWOP_ALLOC_LARGE:
				Index += 1;
				FrameOffset = UnwindInfoCellPtr->UnwindCode[Index].FrameOffset;
				if (OpInfo != 0) {
					Index += 1;
					FrameOffset += (UnwindInfoCellPtr->UnwindCode[Index].FrameOffset << 16);

				}
				else {
					FrameOffset *= 8;
				}

				ContextRecord->Rsp += FrameOffset;
				break;

				//
				// Allocate a small sized area on the stack.
				//
				// The operation information is the size of the unscaled
				// allocation size (8 is the scale factor) minus 8.
				//

			case UWOP_ALLOC_SMALL:
				ContextRecord->Rsp += (OpInfo * 8) + 8;
				break;

				//
				// Establish the the frame pointer register.
				//
				// The operation information is not used.
				//

			case UWOP_SET_FPREG:
				ContextRecord->Rsp = IntegerRegister[UnwindInfoCellPtr->FrameRegister];
				ContextRecord->Rsp -= UnwindInfoCellPtr->FrameOffset * 16;
				break;

				//
				// Save nonvolatile integer register on the stack using a
				// 16-bit displacment.
				//
				// The operation information is the register number.
				//

			case UWOP_SAVE_NONVOL:
				Index += 1;
				FrameOffset = UnwindInfoCellPtr->UnwindCode[Index].FrameOffset * 8;
				IntegerAddress = (PDWORD_PTR)(FrameBase + FrameOffset);

				uc_mem_read(m_uc, (DWORD_PTR)IntegerAddress, &ValueFromAddress, sizeof(ValueFromAddress));

				IntegerRegister[OpInfo] = ValueFromAddress;
				if (ContextPointers) {
					ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
				}

				break;

				//
				// Save nonvolatile integer register on the stack using a
				// 32-bit displacment.
				//
				// The operation information is the register number.
				//

			case UWOP_SAVE_NONVOL_FAR:
				Index += 2;
				FrameOffset = UnwindInfoCellPtr->UnwindCode[Index - 1].FrameOffset;
				FrameOffset += (UnwindInfoCellPtr->UnwindCode[Index].FrameOffset << 16);
				IntegerAddress = (PDWORD_PTR)(FrameBase + FrameOffset);
				uc_mem_read(m_uc, (DWORD_PTR)IntegerAddress, &ValueFromAddress, sizeof(ValueFromAddress));
				IntegerRegister[OpInfo] = ValueFromAddress;
				if (ContextPointers) {
					ContextPointers->IntegerContext[OpInfo] = IntegerAddress;
				}

				break;

				//
				// Spare unused codes.
				//

			case UWOP_SPARE_CODE1:
			case UWOP_SPARE_CODE2:

				break;

				//
				// Save a nonvolatile XMM(128) register on the stack using a
				// 16-bit displacement.
				//
				// The operation information is the register number.
				//

			case UWOP_SAVE_XMM128:
				Index += 1;
				FrameOffset = UnwindInfoCellPtr->UnwindCode[Index].FrameOffset * 16;
				FloatingAddress = (PM128A)(FrameBase + FrameOffset);
				FloatingRegister[OpInfo].Low = FloatingAddress->Low;
				FloatingRegister[OpInfo].High = FloatingAddress->High;
				if (ContextPointers) {
					ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
				}

				break;

				//
				// Save a nonvolatile XMM(128) register on the stack using a
				// 32-bit displacement.
				//
				// The operation information is the register number.
				//

			case UWOP_SAVE_XMM128_FAR:
				Index += 2;
				FrameOffset = UnwindInfoCellPtr->UnwindCode[Index - 1].FrameOffset;
				FrameOffset += (UnwindInfoCellPtr->UnwindCode[Index].FrameOffset << 16);
				FloatingAddress = (PM128A)(FrameBase + FrameOffset);
				FloatingRegister[OpInfo].Low = FloatingAddress->Low;
				FloatingRegister[OpInfo].High = FloatingAddress->High;
				if (ContextPointers) {
					ContextPointers->FloatingContext[OpInfo] = FloatingAddress;
				}

				break;

				//
				// Push a machine frame on the stack.
				//
				// The operation information determines whether the machine
				// frame contains an error code or not.
				//

			case UWOP_PUSH_MACHFRAME:
				MachineFrame = TRUE;
				ReturnAddress = (PDWORD_PTR)(ContextRecord->Rsp);
				StackAddress = (PDWORD_PTR)(ContextRecord->Rsp + (3 * 8));
				if (OpInfo != 0) {
					ReturnAddress += 1;
					StackAddress += 1;
				}

				uc_mem_read(m_uc, (DWORD_PTR)ReturnAddress, &ValueFromAddress, sizeof(ValueFromAddress));

				ContextRecord->Rip = ValueFromAddress;

				uc_mem_read(m_uc, (DWORD_PTR)StackAddress, &ValueFromAddress, sizeof(ValueFromAddress));

				ContextRecord->Rsp = ValueFromAddress;
				break;

				//
				// Unused codes.
				//

			default:

				break;
			}

			Index += 1;

		}
		else {

			//
			// Skip this unwind operation by advancing the slot index by the
			// number of slots consumed by this operation.
			//

			Index += m_RtlpUnwindOpSlotTable[UnwindOp];

			//
			// Special case any unwind operations that can consume a variable
			// number of slots.
			// 

			switch (UnwindOp) {

				//
				// A non-zero operation information indicates that an
				// additional slot is consumed.
				//

			case UWOP_ALLOC_LARGE:
				if (OpInfo != 0) {
					Index += 1;
				}

				break;

				//
				// No other special cases.
				//

			default:
				break;
			}
		}
	}

	//
	// If chained unwind information is specified, then recursively unwind
	// the chained information. Otherwise, determine the return address if
	// a machine frame was not encountered during the scan of the unwind
	// codes.
	//

	if ((UnwindInfoCellPtr->Flags & UNW_FLAG_CHAININFO) != 0) {
		Index = UnwindInfoCellPtr->CountOfCodes;
		if ((Index & 1) != 0) {
			Index += 1;
		}

		FunctionEntry = (PRUNTIME_FUNCTION)(&UnwindInfoCellPtr->UnwindCode[Index]);
		return RtlpUnwindPrologue(ImageBase,
			ControlPc,
			FrameBase,
			FunctionEntry,
			ContextRecord,
			ContextPointers);

	}
	else {
		if (MachineFrame == FALSE) {

			DWORD_PTR ValueFromAddress;
			uc_mem_read(m_uc, (DWORD_PTR)ContextRecord->Rsp, &ValueFromAddress, sizeof(ValueFromAddress));

			ContextRecord->Rip = ValueFromAddress;
			ContextRecord->Rsp += 8;
		}

		return FunctionEntry;
	}
}

//Make x86 bit version of this function
PEXCEPTION_ROUTINE PeEmulation::RtlpVirtualUnwind(
	_In_ ULONG HandlerType,
	_In_ DWORD_PTR ImageBase,
	_In_ DWORD_PTR ControlPc,
	_In_ PRUNTIME_FUNCTION FunctionEntry,
	_Inout_ PCONTEXT ContextRecord,
	_Out_ PVOID* HandlerData,
	_Out_ PDWORD_PTR EstablisherFrame,
	_Inout_ PKNONVOLATILE_CONTEXT_POINTERS ContextPointers OPTIONAL
)
{
	//
	// Define opcode and prefix values.
	//

#define SIZE64_PREFIX 0x48
#define ADD_IMM8_OP 0x83
#define ADD_IMM32_OP 0x81
#define JMP_IMM8_OP 0xeb
#define JMP_IMM32_OP 0xe9
#define JMP_IND_OP 0xff
#define LEA_OP 0x8d
#define REPNE_PREFIX 0xf2
#define REP_PREFIX 0xf3
#define POP_OP 0x58
#define RET_OP 0xc3
#define RET_OP_2 0xc2

#define IS_REX_PREFIX(x) (((x) & 0xf0) == 0x40)

	//DWORD_PTR BranchBase;
	DWORD_PTR BranchTarget;
	LONG Displacement;
	ULONG EpilogueOffset = 0;
	ULONG EpilogueSize;
	ULONG FrameRegister;
	ULONG Index;
	bool InEpilogue;
	PDWORD_PTR IntegerAddress;
	PDWORD_PTR IntegerRegister;
	PUCHAR NextByte;
	PRUNTIME_FUNCTION PrimaryFunctionEntry;
	ULONG PrologOffset;
	ULONG RegisterNumber;
	ULONG RelativePc;
	PUNWIND_INFO UnwindInfo;
	DWORD_PTR ValueFromAddress;
	UNWIND_CODE UnwindOp;

	RUNTIME_FUNCTION FunctionEntryCell;
	uc_mem_read(m_uc, (DWORD_PTR)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));

	UnwindInfo = (PUNWIND_INFO)(FunctionEntryCell.UnwindData + ImageBase);
	PrologOffset = (ULONG)(ControlPc - (FunctionEntryCell.BeginAddress + ImageBase));

	crt_buffer_t UnwindInfoCell(offsetof(UNWIND_INFO, UnwindCode));
	uc_mem_read(m_uc, (DWORD_PTR)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
	PUNWIND_INFO UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();
	UnwindInfoCell.GetSpace(offsetof(UNWIND_INFO, UnwindCode) + UnwindInfoCellPtr->CountOfCodes * sizeof(UNWIND_CODE) + sizeof(DWORD) * 2);
	uc_mem_read(m_uc, (DWORD_PTR)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
	UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();

	if (UnwindInfoCellPtr->FrameRegister == 0) {
		*EstablisherFrame = ContextRecord->Rsp;

	}
	else if ((PrologOffset >= UnwindInfoCellPtr->SizeOfProlog) ||
		((UnwindInfoCellPtr->Flags & UNW_FLAG_CHAININFO) != 0)) {

		*EstablisherFrame = (&ContextRecord->Rax)[UnwindInfoCellPtr->FrameRegister];
		*EstablisherFrame -= UnwindInfoCellPtr->FrameOffset * 16;

	}
	else {
		Index = 0;
		while (Index < UnwindInfo->CountOfCodes) {
			if (UnwindInfoCellPtr->UnwindCode[Index].UnwindOp == UWOP_SET_FPREG) {
				break;
			}

			Index += 1;
		}

		if (PrologOffset >= UnwindInfoCellPtr->UnwindCode[Index].CodeOffset) {
			*EstablisherFrame = (&ContextRecord->Rax)[UnwindInfoCellPtr->FrameRegister];
			*EstablisherFrame -= UnwindInfoCellPtr->FrameOffset * 16;

		}
		else {
			*EstablisherFrame = ContextRecord->Rsp;
		}
	}

	//
	// If the point at which control left the specified function is in an
	// epilogue, then emulate the execution of the epilogue forward and
	// return no exception handler.
	//

	IntegerRegister = &ContextRecord->Rax;

	NextByte = (PUCHAR)ControlPc;

	UCHAR NextByteBuffer[15];
	uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
	//
	// Check for one of:
	//
	//   add rsp, imm8
	//       or
	//   add rsp, imm32
	//       or
	//   lea rsp, -disp8[fp]
	//       or
	//   lea rsp, -disp32[fp]
	//

	if ((NextByteBuffer[0] == SIZE64_PREFIX) &&
		(NextByteBuffer[1] == ADD_IMM8_OP) &&
		(NextByteBuffer[2] == 0xc4)) {

		//
		// add rsp, imm8.
		//

		NextByte += 4;
		uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
	}
	else if ((NextByteBuffer[0] == SIZE64_PREFIX) &&
		(NextByteBuffer[1] == ADD_IMM32_OP) &&
		(NextByteBuffer[2] == 0xc4)) {

		//
		// add rsp, imm32.
		//

		NextByte += 7;
		uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
	}
	else if (((NextByteBuffer[0] & 0xfe) == SIZE64_PREFIX) &&
		(NextByteBuffer[1] == LEA_OP)) {

		FrameRegister = ((NextByteBuffer[0] & 0x1) << 3) | (NextByteBuffer[2] & 0x7);
		if ((FrameRegister != 0) &&
			(FrameRegister == UnwindInfoCellPtr->FrameRegister)) {

			if ((NextByteBuffer[2] & 0xf8) == 0x60) {

				//
				// lea rsp, disp8[fp].
				//

				NextByte += 4;
				uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
			}
			else if ((NextByteBuffer[2] & 0xf8) == 0xa0) {

				//
				// lea rsp, disp32[fp].
				//

				NextByte += 7;
				uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
			}
		}
	}

	//
	// Check for any number of:
	//
	//   pop nonvolatile-integer-register[0..15].
	//

	while (TRUE) {
		if ((NextByteBuffer[0] & 0xf8) == POP_OP) {
			NextByte += 1;
			uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
		}
		else if (IS_REX_PREFIX(NextByteBuffer[0]) &&
			((NextByteBuffer[1] & 0xf8) == POP_OP)) {

			NextByte += 2;
			uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
		}
		else {
			break;
		}
	}


	//
	// A REPNE prefix may optionally precede a control transfer
	// instruction with no effect on unwinding.
	//

	if (NextByteBuffer[0] == REPNE_PREFIX) {
		NextByte += 1;
		uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
	}


	//
	// If the next instruction is a return or an appropriate jump, then
	// control is currently in an epilogue and execution of the epilogue
	// should be emulated. Otherwise, execution is not in an epilogue and
	// the prologue should be unwound.
	//

	InEpilogue = FALSE;
	if ((NextByteBuffer[0] == RET_OP) ||
		(NextByteBuffer[0] == RET_OP_2) ||
		((NextByteBuffer[0] == REP_PREFIX) && (NextByteBuffer[1] == RET_OP))) {

		//
		// A return is an unambiguous indication of an epilogue.
		//

		InEpilogue = TRUE;

	}
	else if ((NextByteBuffer[0] == JMP_IMM8_OP) || (NextByteBuffer[0] == JMP_IMM32_OP)) {

		//
		// An unconditional branch to a target that is equal to the start of
		// or outside of this routine is logically a call to another function.
		// 

		BranchTarget = (DWORD_PTR)NextByte - ImageBase;
		if (NextByteBuffer[0] == JMP_IMM8_OP) {
			BranchTarget += 2 + (CHAR)NextByteBuffer[1];

		}
		else {
			LONG32 delta = NextByteBuffer[1] | (NextByteBuffer[2] << 8) |
				(NextByteBuffer[3] << 16) | (NextByteBuffer[4] << 24);

			BranchTarget += 5 + delta;
		}

		//
		// Determine whether the branch target refers to code within this
		// function. If not, then it is an epilogue indicator.
		//
		// A branch to the start of self implies a recursive call, so
		// is treated as an epilogue.
		//

		if (BranchTarget < FunctionEntryCell.BeginAddress ||
			BranchTarget >= FunctionEntryCell.EndAddress) {

			//
			// The branch target is outside of the region described by
			// this function entry. See whether it is contained within
			// an indirect function entry associated with this same
			// function.
			//
			// If not, then the branch target really is outside of
			// this function.
			//

			PrimaryFunctionEntry = RtlpSameFunction(FunctionEntry,
				ImageBase,
				BranchTarget + ImageBase);

			RUNTIME_FUNCTION PrimaryFunctionEntryCell;
			uc_mem_read(m_uc, (DWORD_PTR)PrimaryFunctionEntry, &PrimaryFunctionEntryCell, sizeof(PrimaryFunctionEntryCell));

			if ((PrimaryFunctionEntry == NULL) ||
				(BranchTarget == PrimaryFunctionEntryCell.BeginAddress)) {

				InEpilogue = TRUE;
			}

		}
		else if ((BranchTarget == FunctionEntryCell.BeginAddress) &&
			((UnwindInfoCellPtr->Flags & UNW_FLAG_CHAININFO) == 0)) {

			InEpilogue = TRUE;
		}

	}
	else if ((NextByteBuffer[0] == JMP_IND_OP) && (NextByteBuffer[1] == 0x25)) {

		//
		// An unconditional jump indirect.
		//
		// This is a jmp outside of the function, probably a tail call
		// to an import function.
		//

		InEpilogue = TRUE;

	}
	else if (((NextByteBuffer[0] & 0xf8) == SIZE64_PREFIX) &&
		(NextByteBuffer[1] == 0xff) &&
		(NextByteBuffer[2] & 0x38) == 0x20) {

		//
		// This is an indirect jump opcode: 0x48 0xff /4.  The 64-bit
		// flag (REX.W) is always redundant here, so its presence is
		// overloaded to indicate a branch out of the function - a tail
		// call.
		//
		// Such an opcode is an unambiguous epilogue indication.
		//

		InEpilogue = TRUE;
	}

	if (InEpilogue != FALSE) {
		NextByte = (PUCHAR)ControlPc;
		uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
		//
		// Emulate one of (if any):
		//
		//   add rsp, imm8
		//       or
		//   add rsp, imm32
		//       or                
		//   lea rsp, disp8[frame-register]
		//       or
		//   lea rsp, disp32[frame-register]
		//

		if ((NextByteBuffer[0] & 0xf8) == SIZE64_PREFIX) {

			if (NextByteBuffer[1] == ADD_IMM8_OP) {

				//
				// add rsp, imm8.
				//

				ContextRecord->Rsp += (CHAR)NextByteBuffer[3];
				NextByte += 4;
				uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
			}
			else if (NextByteBuffer[1] == ADD_IMM32_OP) {

				//
				// add rsp, imm32.
				//

				Displacement = NextByteBuffer[3] | (NextByteBuffer[4] << 8);
				Displacement |= (NextByteBuffer[5] << 16) | (NextByteBuffer[6] << 24);
				ContextRecord->Rsp += Displacement;
				NextByte += 7;
				uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
			}
			else if (NextByteBuffer[1] == LEA_OP) {
				if ((NextByteBuffer[2] & 0xf8) == 0x60) {

					//
					// lea rsp, disp8[frame-register].
					//

					ContextRecord->Rsp = IntegerRegister[FrameRegister];
					ContextRecord->Rsp += (CHAR)NextByteBuffer[3];
					NextByte += 4;
					uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
				}
				else if ((NextByteBuffer[2] & 0xf8) == 0xa0) {

					//
					// lea rsp, disp32[frame-register].
					//

					Displacement = NextByteBuffer[3] | (NextByteBuffer[4] << 8);
					Displacement |= (NextByteBuffer[5] << 16) | (NextByteBuffer[6] << 24);
					ContextRecord->Rsp = IntegerRegister[FrameRegister];
					ContextRecord->Rsp += Displacement;
					NextByte += 7;
					uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
				}
			}
		}

		//
		// Emulate any number of (if any):
		//
		//   pop nonvolatile-integer-register.
		//

		while (TRUE) {
			if ((NextByteBuffer[0] & 0xf8) == POP_OP) {

				//
				// pop nonvolatile-integer-register[0..7]
				//

				RegisterNumber = NextByteBuffer[0] & 0x7;

				IntegerAddress = (PDWORD_PTR)ContextRecord->Rsp;

				DWORD_PTR ValueFromAddress;
				uc_mem_read(m_uc, (DWORD_PTR)IntegerAddress, &ValueFromAddress, sizeof(ValueFromAddress));

				IntegerRegister[RegisterNumber] = ValueFromAddress;
				if (ContextPointers) {
					ContextPointers->IntegerContext[RegisterNumber] = IntegerAddress;
				}

				ContextRecord->Rsp += 8;
				NextByte += 1;

			}
			else if (IS_REX_PREFIX(NextByteBuffer[0]) &&
				((NextByteBuffer[1] & 0xf8) == POP_OP)) {

				//
				// pop nonvolatile-integer-register[8..15]
				//

				RegisterNumber = ((NextByteBuffer[0] & 1) << 3) | (NextByteBuffer[1] & 0x7);

				IntegerAddress = (PDWORD_PTR)ContextRecord->Rsp;

				uc_mem_read(m_uc, (DWORD_PTR)IntegerAddress, &ValueFromAddress, sizeof(ValueFromAddress));

				IntegerRegister[RegisterNumber] = ValueFromAddress;

				if (ContextPointers) {
					ContextPointers->IntegerContext[RegisterNumber] = IntegerAddress;
				}

				ContextRecord->Rsp += 8;
				NextByte += 2;
				uc_mem_read(m_uc, (DWORD_PTR)NextByte, NextByteBuffer, sizeof(NextByteBuffer));
			}
			else {
				break;
			}
		}

		//
		// Emulate return and return null exception handler.
		//
		// Note: this instruction might in fact be a jmp, however
		//       we want to emulate a return regardless.
		//

		DWORD_PTR ValueFromRsp;
		uc_mem_read(m_uc, (DWORD_PTR)ContextRecord->Rsp, &ValueFromRsp, sizeof(ValueFromRsp));
		ContextRecord->Rip = ValueFromRsp;
		ContextRecord->Rsp += 8;
		return NULL;
	} 
	else if (UnwindInfo->CountOfCodes != 0)
	{
		//
		// Capture the first unwind code and check if it is an epilogue code.
		// If it is not an epilogue code, the current function entry does not
		// contain any epilogues (it could represent a body region of a
		// separated function or it could represent a function which never
		// returns).
		//

		UnwindOp = UnwindInfo->UnwindCode[0];
		if (UnwindOp.UnwindOp == UWOP_SPARE_CODE1) {
			EpilogueSize = UnwindOp.CodeOffset;

			//
			// If the low bit of the OpInfo field of the first epilogue code
			// is set, the function has a single epilogue at the end of the
			// function. Otherwise, subsequent epilogue unwind codes indicate
			// the offset of the epilogue(s) from the function end and the
			// relative PC must be compared against each epilogue record.
			//
			// N.B. The relative instruction pointer may not be within the
			//      bounds of the runtime function entry if control left the
			//      function in a region described by an indirect function
			//      entry. Such a region cannot contain any epilogues.
			//

			RelativePc = (ULONG)(ControlPc - ImageBase);
			if ((UnwindOp.OpInfo & 1) != 0) {
				EpilogueOffset = FunctionEntry->EndAddress - EpilogueSize;
				if (RelativePc - EpilogueOffset < EpilogueSize) {
					InEpilogue = TRUE;
				}
			}

			if (InEpilogue == FALSE) {
				for (Index = 1; Index < UnwindInfo->CountOfCodes; Index += 1) {
					UnwindOp = UnwindInfo->UnwindCode[Index];

					if (UnwindOp.UnwindOp == UWOP_SPARE_CODE1) {
						EpilogueOffset = UnwindOp.EpilogueCode.OffsetLow +
							UnwindOp.EpilogueCode.OffsetHigh * 256;

						//
						// An epilogue offset of 0 indicates that this is
						// a padding entry (the number of epilogue codes
						// is a multiple of 2).
						//

						if (EpilogueOffset == 0) {
							break;
						}

						EpilogueOffset = FunctionEntry->EndAddress - EpilogueOffset;
						if (RelativePc - EpilogueOffset < EpilogueSize) {

							InEpilogue = TRUE;
							break;
						}

					}
					else {
						break;
					}
				}
			}

			if (InEpilogue != FALSE) {
				FunctionEntry = RtlpUnwindPrologue(ImageBase,
					ControlPc,
					RelativePc - EpilogueOffset,
					FunctionEntry,
					ContextRecord,
					ContextPointers);
			}
		}
	}
	//
	// Control left the specified function outside an epilogue. Unwind the
	// subject function and any chained unwind information.
	//

	FunctionEntry = RtlpUnwindPrologue(ImageBase,
		ControlPc,
		*EstablisherFrame,
		FunctionEntry,
		ContextRecord,
		ContextPointers);

	uc_mem_read(m_uc, (DWORD_PTR)FunctionEntry, &FunctionEntryCell, sizeof(FunctionEntryCell));

	//
	// If control left the specified function outside of the prologue and
	// the function has a handler that matches the specified type, then
	// return the address of the language specific exception handler.
	// Otherwise, return NULL.
	//

	UnwindInfo = (PUNWIND_INFO)(FunctionEntryCell.UnwindData + ImageBase);

	uc_mem_read(m_uc, (DWORD_PTR)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
	UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();
	UnwindInfoCell.GetSpace(offsetof(UNWIND_INFO, UnwindCode) + UnwindInfoCellPtr->CountOfCodes * sizeof(UNWIND_CODE) + sizeof(DWORD) * 2);
	uc_mem_read(m_uc, (DWORD_PTR)UnwindInfo, UnwindInfoCell.GetBuffer(), UnwindInfoCell.GetLength());
	UnwindInfoCellPtr = (PUNWIND_INFO)UnwindInfoCell.GetBuffer();

	if (HandlerType != 0) {
		PrologOffset = (ULONG)(ControlPc - (FunctionEntryCell.BeginAddress + ImageBase));
		if ((PrologOffset >= UnwindInfoCellPtr->SizeOfProlog) &&
			((UnwindInfoCellPtr->Flags & HandlerType) != 0)) {
			Index = UnwindInfoCellPtr->CountOfCodes;
			if ((Index & 1) != 0) {
				Index += 1;
			}

			*HandlerData = (PVOID)((PUCHAR)UnwindInfo + ((PUCHAR)&UnwindInfoCellPtr->UnwindCode[Index + 2] - (PUCHAR)UnwindInfoCellPtr));
			return (PEXCEPTION_ROUTINE)(*((PULONG)&UnwindInfoCellPtr->UnwindCode[Index]) + ImageBase);

		}
		else {
			return NULL;
		}
	}
	else
	{
		return NULL;
	}
}

//Make x86 bit version of this function
BOOLEAN PeEmulation::RtlpDispatchException(
	_In_ PEXCEPTION_RECORD ExceptionRecord,
	_In_ PCONTEXT ContextRecord
) 
{
	BOOLEAN Completion = FALSE;
	CONTEXT ContextRecord1;
	DWORD_PTR ControlPc;
	DISPATCHER_CONTEXT DispatcherContext;
	EXCEPTION_DISPOSITION Disposition;
	DWORD_PTR EstablisherFrame;
	ULONG ExceptionFlags;
	PEXCEPTION_ROUTINE ExceptionRoutine;
	PRUNTIME_FUNCTION FunctionEntry;
	PVOID HandlerData;
	DWORD_PTR HighLimit;
	PUNWIND_HISTORY_TABLE HistoryTable;
	DWORD_PTR ImageBase;
	DWORD_PTR LowLimit;
	DWORD_PTR NestedFrame;
	BOOLEAN Repeat;
	ULONG ScopeIndex;
	UNWIND_HISTORY_TABLE UnwindTable;

	//
	// Get current stack limits, copy the context record, get the initial
	// PC value, capture the exception flags, and set the nested exception
	// frame pointer.
	//

	RtlpGetStackLimits(&LowLimit, &HighLimit);
	RtlpCopyContext(&ContextRecord1, ContextRecord);
	ControlPc = (DWORD_PTR)ExceptionRecord->ExceptionAddress;
	ExceptionFlags = ExceptionRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE;
	NestedFrame = 0;

	//
	// Initialize the unwind history table.
	//

	HistoryTable = &UnwindTable;
	HistoryTable->Count = 0;
	HistoryTable->Search = UNWIND_HISTORY_TABLE_NONE;
	HistoryTable->LowAddress = -1;
	HistoryTable->HighAddress = 0;

	//
	// Start with the frame specified by the context record and search
	// backwards through the call frame hierarchy attempting to find an
	// exception handler that will handle the exception.
	//

	do {

		//
		// Lookup the function table entry using the point at which control
		// left the procedure.
		//

		FunctionEntry = RtlpLookupFunctionEntry(ControlPc,
			&ImageBase,
			HistoryTable);

		//
		// If there is a function table entry for the routine, then virtually
		// unwind to the caller of the current routine to obtain the virtual
		// frame pointer of the establisher and check if there is an exception
		// handler for the frame.
		//

		if (FunctionEntry != NULL) {
			ExceptionRoutine = RtlpVirtualUnwind(UNW_FLAG_EHANDLER,
				ImageBase,
				ControlPc,
				FunctionEntry,
				&ContextRecord1,
				&HandlerData,
				&EstablisherFrame,
				NULL);

			//
			// If the establisher frame pointer is not within the specified
			// stack limits or the established frame pointer is unaligned,
			// then set the stack invalid flag in the exception record and
			// return exception not handled. Otherwise, check if the current
			// routine has an exception handler.
			//

			if (RtlpIsFrameInBounds(&LowLimit, EstablisherFrame, &HighLimit) == FALSE) {
				ExceptionFlags |= EXCEPTION_STACK_INVALID;
				break;

			}
			else if (ExceptionRoutine != NULL) {

				//
				// The frame has an exception handler.
				//
				// A linkage routine written in assembler is used to actually
				// call the actual exception handler. This is required by the
				// exception handler that is associated with the linkage
				// routine so it can have access to two sets of dispatcher
				// context when it is called.
				//
				// Call the language specific handler.
				//

				ScopeIndex = 0;
				do {

					//
					// Log the exception if exception logging is enabled.
					//

					ExceptionRecord->ExceptionFlags = ExceptionFlags;


					//
					// Clear repeat, set the dispatcher context, and call the
					// exception handler.
					//

					Repeat = FALSE;
					DispatcherContext.ControlPc = ControlPc;
					DispatcherContext.ImageBase = ImageBase;
					DispatcherContext.FunctionEntry = FunctionEntry;
					DispatcherContext.EstablisherFrame = EstablisherFrame;
					DispatcherContext.ContextRecord = &ContextRecord1;
					DispatcherContext.LanguageHandler = ExceptionRoutine;
					DispatcherContext.HandlerData = HandlerData;
					DispatcherContext.HistoryTable = HistoryTable;
					DispatcherContext.ScopeIndex = ScopeIndex;

					//
					Disposition = RtlpExecuteHandlerForException(
						ExceptionRecord, (PVOID)EstablisherFrame,
						ContextRecord, &DispatcherContext);

					//
					// Propagate noncontinuable exception flag.
					//

					ExceptionFlags |=
						(ExceptionRecord->ExceptionFlags & EXCEPTION_NONCONTINUABLE);

					if (m_ExecuteExceptionHandler == 2)
					{
						m_ExecuteExceptionHandler = 0;
						Completion = TRUE;
						goto DispatchExit;
					}

					//
					// If the current scan is within a nested context and the
					// frame just examined is the end of the nested region,
					// then clear the nested context frame and the nested
					// exception flag in the exception flags.
					//

					if (NestedFrame == EstablisherFrame) {
						ExceptionFlags &= (~EXCEPTION_NESTED_CALL);
						NestedFrame = 0;
					}

					//
					// Case on the handler disposition.
					//

					switch (Disposition) {

						//
						// The disposition is to continue execution.
						//
						// If the exception is not continuable, then raise
						// the exception STATUS_NONCONTINUABLE_EXCEPTION.
						// Otherwise return exception handled.
						//

					case ExceptionContinueExecution:
						if ((ExceptionFlags & EXCEPTION_NONCONTINUABLE) != 0) {
							RtlRaiseStatus(STATUS_NONCONTINUABLE_EXCEPTION);

						}
						else {
							Completion = TRUE;
							goto DispatchExit;
						}

						//
						// The disposition is to continue the search.
						//
						// Get next frame address and continue the search.
						//

					case ExceptionContinueSearch:
						break;

						//
						// The disposition is nested exception.
						//
						// Set the nested context frame to the establisher frame
						// address and set the nested exception flag in the
						// exception flags.
						//

					case ExceptionNestedException:
						ExceptionFlags |= EXCEPTION_NESTED_CALL;
						if (DispatcherContext.EstablisherFrame > NestedFrame) {
							NestedFrame = DispatcherContext.EstablisherFrame;
						}

						break;

						//
						// The dispostion is collided unwind.
						//
						// A collided unwind occurs when an exception dispatch
						// encounters a previous call to an unwind handler. In
						// this case the previous unwound frames must be skipped.
						//

					case ExceptionCollidedUnwind:
						ControlPc = DispatcherContext.ControlPc;
						ImageBase = DispatcherContext.ImageBase;
						FunctionEntry = DispatcherContext.FunctionEntry;
						EstablisherFrame = DispatcherContext.EstablisherFrame;
						RtlpCopyContext(&ContextRecord1,
							DispatcherContext.ContextRecord);

						ContextRecord1.Rip = ControlPc;
						ExceptionRoutine = DispatcherContext.LanguageHandler;
						HandlerData = DispatcherContext.HandlerData;
						HistoryTable = DispatcherContext.HistoryTable;
						ScopeIndex = DispatcherContext.ScopeIndex;
						Repeat = TRUE;
						break;

						//
						// All other disposition values are invalid.
						//
						// Raise invalid disposition exception.
						//

					default:
						RtlRaiseStatus(STATUS_INVALID_DISPOSITION);
					}

				} while (Repeat != FALSE);
			}

		}
		else {

			//
			// If the old control PC is the same as the return address,
			// then no progress is being made and the function tables are
			// most likely malformed.
			//

			DWORD_PTR ValueFromRsp;
			uc_mem_read(m_uc, ContextRecord1.Rsp, &ValueFromRsp, sizeof(ValueFromRsp));
			if (ControlPc == ValueFromRsp) {
				break;
			}

			//
			// Set the point where control left the current function by
			// obtaining the return address from the top of the stack.
			//

			ContextRecord1.Rip = ValueFromRsp;
			ContextRecord1.Rsp += 8;
		}

		//
		// Set point at which control left the previous routine.
		//

		ControlPc = ContextRecord1.Rip;
	} while (RtlpIsFrameInBounds(&LowLimit, (DWORD_PTR)ContextRecord1.Rsp, &HighLimit) == TRUE);

	//
	// Set final exception flags and return exception not handled.
	//

	ExceptionRecord->ExceptionFlags = ExceptionFlags;

	//
	// Call vectored continue handlers.
	//

DispatchExit:

	return Completion;
}

//Make x86 bit version of this function
void PeEmulation::RtlpUnwindEx(
	_In_ PVOID TargetFrame OPTIONAL,
	_In_ PVOID TargetIp OPTIONAL,
	_In_ PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
	_In_ PVOID ReturnValue,
	_In_ PCONTEXT OriginalContext,
	_In_ PUNWIND_HISTORY_TABLE HistoryTable OPTIONAL
)
{

	DWORD_PTR ControlPc;
	PCONTEXT CurrentContext;
	DISPATCHER_CONTEXT DispatcherContext;
	EXCEPTION_DISPOSITION Disposition;
	DWORD_PTR EstablisherFrame;
	ULONG ExceptionFlags;
	EXCEPTION_RECORD ExceptionRecord1;
	PEXCEPTION_ROUTINE ExceptionRoutine;
	PRUNTIME_FUNCTION FunctionEntry;
	PVOID HandlerData = nullptr;
	DWORD_PTR HighLimit;
	DWORD_PTR ImageBase;
	CONTEXT LocalContext{};
	DWORD_PTR LowLimit;
	PCONTEXT PreviousContext;
	ULONG ScopeIndex;
	PCONTEXT TempContext;

	DWORD_PTR ValueFromAddress;
	//
	// Get current stack limits, capture the current context, virtually
	// unwind to the caller of this routine, get the initial PC value, and
	// set the unwind target address.
	//

	CurrentContext = OriginalContext;
	PreviousContext = &LocalContext;
	RtlpGetStackLimits(&LowLimit, &HighLimit);
	RtlpCaptureContext(CurrentContext);

	CurrentContext->Rip = (DWORD_PTR)TargetIp;
	CurrentContext->Rsp = (DWORD_PTR)TargetFrame;
	//
	// If a history table is specified, then set to search history table.
	//

	if (HistoryTable) {
		HistoryTable->Search = UNWIND_HISTORY_TABLE_GLOBAL;
	}

	//
	// If an exception record is not specified, then build a local exception
	// record for use in calling exception handlers during the unwind operation.
	//

	if (!ExceptionRecord) {
		ExceptionRecord = &ExceptionRecord1;
		ExceptionRecord1.ExceptionCode = STATUS_UNWIND;
		ExceptionRecord1.ExceptionRecord = NULL;
		ExceptionRecord1.ExceptionAddress = (PVOID)CurrentContext->Rip;
		ExceptionRecord1.NumberParameters = 0;
	}

	//
	// If the target frame of the unwind is specified, then a normal unwind
	// is being performed. Otherwise, an exit unwind is being performed.
	//

	ExceptionFlags = EXCEPTION_UNWINDING;
	if (!TargetFrame) {
		ExceptionFlags |= EXCEPTION_EXIT_UNWIND;
	}

	//
	// Scan backward through the call frame hierarchy and call exception
	// handlers until the target frame of the unwind is reached.
	//

	do {

		//
		// Lookup the function table entry using the point at which control
		// left the procedure.
		//

		ControlPc = CurrentContext->Rip;
		FunctionEntry = RtlpLookupFunctionEntry(ControlPc,
			&ImageBase,
			HistoryTable);

		//
		// If there is a function table entry for the routine, then virtually
		// unwind to the caller of the routine to obtain the virtual frame
		// pointer of the establisher, but don't update the context record.
		//

		if (FunctionEntry != NULL) {
			RtlpCopyContext(PreviousContext, CurrentContext);

			ExceptionRoutine = RtlpVirtualUnwind(UNW_FLAG_UHANDLER,
				ImageBase,
				ControlPc,
				FunctionEntry,
				PreviousContext,
				&HandlerData,
				&EstablisherFrame,
				NULL);

			//
			// If the establisher frame pointer is not within the specified
			// stack limits, the establisher frame pointer is unaligned, or
			// the target frame is below the establisher frame and an exit
			// unwind is not being performed, then raise a bad stack status.
			// Otherwise, check to determine if the current routine has an
			// exception handler.
			//

			if ((RtlpIsFrameInBounds(&LowLimit, EstablisherFrame, &HighLimit) == FALSE) ||
				(!TargetFrame &&
					((DWORD_PTR)TargetFrame < EstablisherFrame))) {

				RtlRaiseStatus(STATUS_BAD_STACK);

			}
			else if (ExceptionRoutine != NULL) {

				//
				// The frame has a exception handler.
				//
				// A linkage routine written in assembler is used to actually
				// call the actual exception handler. This is required by the
				// exception handler that is associated with the linkage
				// routine so it can have access to two sets of dispatcher
				// context when it is called.
				//
				// Call the language specific handler.
				//

				DispatcherContext.TargetIp = (DWORD_PTR)TargetIp;
				ScopeIndex = 0;
				do {

					//
					// If the establisher frame is the target of the unwind
					// operation, then set the target unwind flag.
					//

					if ((DWORD_PTR)TargetFrame == EstablisherFrame) {
						ExceptionFlags |= EXCEPTION_TARGET_UNWIND;
					}

					//ExceptionRecord->ExceptionFlags = ExceptionFlags;
					uc_mem_write(m_uc, (DWORD_PTR)ExceptionRecord + offsetof(EXCEPTION_RECORD, ExceptionFlags), &ExceptionFlags, sizeof(ExceptionFlags));

					//
					// Set the specified return value and target IP in case
					// the exception handler directly continues execution.
					//

					CurrentContext->Rax = (DWORD_PTR)ReturnValue;

					//
					// Set the dispatcher context and call the termination
					// handler.
					//

					DispatcherContext.ControlPc = ControlPc;
					DispatcherContext.ImageBase = ImageBase;
					DispatcherContext.FunctionEntry = FunctionEntry;
					DispatcherContext.EstablisherFrame = EstablisherFrame;
					DispatcherContext.ContextRecord = CurrentContext;
					DispatcherContext.LanguageHandler = ExceptionRoutine;
					DispatcherContext.HandlerData = HandlerData;
					DispatcherContext.HistoryTable = HistoryTable;
					DispatcherContext.ScopeIndex = ScopeIndex;

					Disposition = RtlpExecuteHandlerForException(ExceptionRecord,
						(PVOID)EstablisherFrame,
						CurrentContext,
						&DispatcherContext);

					//
					// Clear target unwind and collided unwind flags.
					//

					ExceptionFlags &=
						~(EXCEPTION_COLLIDED_UNWIND | EXCEPTION_TARGET_UNWIND);

					//
					// Case on the handler disposition.
					//

					switch (Disposition) {

						//
						// The disposition is to continue the search.
						//
						// If the target frame has not been reached, then
						// swap context pointers.
						//

					case ExceptionContinueSearch:
						if (EstablisherFrame != (DWORD_PTR)TargetFrame) {
							TempContext = CurrentContext;
							CurrentContext = PreviousContext;
							PreviousContext = TempContext;
						}

						break;

						//
						// The disposition is collided unwind.
						//
						// Copy the context of the previous unwind and
						// virtually unwind to the caller of the establisher,
						// then set the target of the current unwind to the
						// dispatcher context of the previous unwind, and
						// reexecute the exception handler from the collided
						// frame with the collided unwind flag set in the
						// exception record.
						//

					case ExceptionCollidedUnwind:
						ControlPc = DispatcherContext.ControlPc;
						ImageBase = DispatcherContext.ImageBase;
						FunctionEntry = DispatcherContext.FunctionEntry;
						RtlpCopyContext(OriginalContext,
							DispatcherContext.ContextRecord);

						CurrentContext = OriginalContext;
						PreviousContext = &LocalContext;
						RtlpCopyContext(PreviousContext, CurrentContext);
						RtlpVirtualUnwind(UNW_FLAG_NHANDLER,
							ImageBase,
							ControlPc,
							FunctionEntry,
							PreviousContext,
							&HandlerData,
							&EstablisherFrame,
							NULL);

						EstablisherFrame = DispatcherContext.EstablisherFrame;
						ExceptionRoutine = DispatcherContext.LanguageHandler;
						HandlerData = DispatcherContext.HandlerData;
						HistoryTable = DispatcherContext.HistoryTable;
						ScopeIndex = DispatcherContext.ScopeIndex;
						ExceptionFlags |= EXCEPTION_COLLIDED_UNWIND;
						break;

						//
						// All other disposition values are invalid.
						//
						// Raise invalid disposition exception.
						//

					default:
						RtlRaiseStatus(STATUS_INVALID_DISPOSITION);
					}

				} while ((ExceptionFlags & EXCEPTION_COLLIDED_UNWIND) != 0);

			}
			else {

				//
				// If the target frame has not been reached, then swap
				// context pointers.
				//

				if (EstablisherFrame != (DWORD_PTR)TargetFrame) {
					TempContext = CurrentContext;
					CurrentContext = PreviousContext;
					PreviousContext = TempContext;
				}
			}

		}
		else {

			//
			// Set the point where control left the current function by
			// obtaining the return address from the top of the stack.
			//

			uc_mem_read(m_uc, (DWORD_PTR)CurrentContext->Rsp, &ValueFromAddress, sizeof(ValueFromAddress));

			CurrentContext->Rip = ValueFromAddress;
			CurrentContext->Rsp += 8;
		}

	} while ((RtlpIsFrameInBounds(&LowLimit, EstablisherFrame, &HighLimit) == TRUE) &&
		(EstablisherFrame != (DWORD_PTR)TargetFrame));

	//
	// If the establisher stack pointer is equal to the target frame pointer,
	// then continue execution. Otherwise, an exit unwind was performed or the
	// target of the unwind did not exist and the debugger and subsystem are
	// given a second chance to handle the unwind.
	//

	if (EstablisherFrame == (DWORD_PTR)TargetFrame) {
		CurrentContext->Rax = (DWORD_PTR)ReturnValue;

		ULONG ExceptionCode;
		uc_mem_read(m_uc, (DWORD_PTR)ExceptionRecord + offsetof(EXCEPTION_RECORD, ExceptionCode), &ExceptionCode, sizeof(ExceptionCode));

		if (ExceptionCode != STATUS_UNWIND_CONSOLIDATE) {
			CurrentContext->Rip = (DWORD_PTR)TargetIp;
		}

		RtlpRestoreContext(CurrentContext, ExceptionRecord);
	}
	else {

		//
		// If the old control PC is the same as the new control PC, then
		// no progress is being made and the function tables are most likely
		// malformed. Otherwise, give the debugger and subsystem a second
		// chance to handle the exception.

		if (ControlPc == CurrentContext->Rip) {
			RtlRaiseStatus(STATUS_BAD_FUNCTION_TABLE);

		}
		else {
			RaiseException(ExceptionRecord, CurrentContext, FALSE);
		}
	}
}

//Make x86 bit version of this function
EXCEPTION_DISPOSITION PeEmulation::RtlpExecuteHandlerForException(
	_Inout_ struct _EXCEPTION_RECORD* ExceptionRecord,
	_In_ PVOID EstablisherFrame,
	_Inout_ struct _CONTEXT* ContextRecord,
	_In_ PDISPATCHER_CONTEXT DispatcherContext
)
{
	EXCEPTION_DISPOSITION dispo = ExceptionContinueExecution;
	auto ExceptionRecordBase = StackAlloc(sizeof(EXCEPTION_RECORD));
	auto ContextRecordBase = StackAlloc(sizeof(CONTEXT));
	auto DispatcherContextBase = StackAlloc(sizeof(DISPATCHER_CONTEXT));

	uc_mem_write(m_uc, ExceptionRecordBase, ExceptionRecord, sizeof(EXCEPTION_RECORD));
	uc_mem_write(m_uc, ContextRecordBase, ContextRecord, sizeof(CONTEXT));
	uc_mem_write(m_uc, DispatcherContextBase, DispatcherContext, sizeof(DISPATCHER_CONTEXT));

	uc_reg_write(m_uc, UC_X86_REG_RCX, &ExceptionRecordBase);
	uc_reg_write(m_uc, UC_X86_REG_RDX, &EstablisherFrame);
	uc_reg_write(m_uc, UC_X86_REG_R8, &ContextRecordBase);
	uc_reg_write(m_uc, UC_X86_REG_R9, &DispatcherContextBase);

	DWORD_PTR Zero = 0;
	uc_reg_write(m_uc, UC_X86_REG_DR0, &Zero);
	uc_reg_write(m_uc, UC_X86_REG_DR1, &Zero);
	uc_reg_write(m_uc, UC_X86_REG_DR2, &Zero);
	uc_reg_write(m_uc, UC_X86_REG_DR3, &Zero);
	uc_reg_write(m_uc, UC_X86_REG_DR6, &Zero);
	uc_reg_write(m_uc, UC_X86_REG_DR7, &Zero);

	DWORD_PTR retAddr = StackAlloc(sizeof(m_ImageEnd));
	uc_mem_write(m_uc, retAddr, &m_ImageEnd, sizeof(m_ImageEnd));
	StackAlloc(7 * sizeof(ULONG64));
	//push m_ImageEnd
	//sub rsp, 7 * dq

	auto err = uc_emu_start(m_uc, (DWORD_PTR)DispatcherContext->LanguageHandler, m_ImageEnd, 0, 0);

	if (m_ExecuteExceptionHandler == 1)
	{
		m_ExecuteExceptionHandler = 0;
		return C_specific_handler();
	}

	//add rsp, 7 * dq
	StackFree(7 * sizeof(DWORD_PTR));

	uc_mem_read(m_uc, ExceptionRecordBase, ExceptionRecord, sizeof(EXCEPTION_RECORD));
	uc_mem_read(m_uc, ContextRecordBase, ContextRecord, sizeof(CONTEXT));
	uc_mem_read(m_uc, DispatcherContextBase, DispatcherContext, sizeof(DISPATCHER_CONTEXT));

	StackFree(sizeof(EXCEPTION_RECORD));
	StackFree(sizeof(CONTEXT));
	StackFree(sizeof(DISPATCHER_CONTEXT));

	return dispo;
}

//Make x86 bit version of this function
EXCEPTION_DISPOSITION PeEmulation::C_specific_handler(void)
{
	ULONG_PTR ControlPc = 0;
	PEXCEPTION_FILTER ExceptionFilter = NULL;
	EXCEPTION_POINTERS ExceptionPointers = { 0 };
	ULONG_PTR ImageBase = 0;
	ULONG_PTR Handler = 0;
	ULONG Index = 0;
	PSCOPE_TABLE ScopeTable = NULL;
	ULONG TargetIndex = 0;
	ULONG_PTR TargetPc = 0;
	PTERMINATION_HANDLER TerminationHandler = NULL;
	LONG Value = 0;

	DWORD_PTR ExceptionRecordBase;
	uc_reg_read(m_uc, UC_X86_REG_RCX, &ExceptionRecordBase);
	EXCEPTION_RECORD ExceptionRecord;
	uc_mem_read(m_uc, ExceptionRecordBase, &ExceptionRecord, sizeof(EXCEPTION_RECORD));

	DWORD_PTR EstablisherFrame;
	uc_reg_read(m_uc, UC_X86_REG_RDX, &EstablisherFrame);

	DWORD_PTR ContextRecordBase;
	uc_reg_read(m_uc, UC_X86_REG_R8, &ContextRecordBase);
	CONTEXT ContextRecord;
	uc_mem_read(m_uc, ContextRecordBase, &ContextRecord, sizeof(CONTEXT));

	DWORD_PTR DispatcherContextBase;
	uc_reg_read(m_uc, UC_X86_REG_R9, &DispatcherContextBase);
	DISPATCHER_CONTEXT DispatcherContext;
	uc_mem_read(m_uc, DispatcherContextBase, &DispatcherContext, sizeof(DISPATCHER_CONTEXT));

	ImageBase = DispatcherContext.ImageBase;
	ControlPc = DispatcherContext.ControlPc - ImageBase;
	ScopeTable = (PSCOPE_TABLE)(DispatcherContext.HandlerData);

	typedef struct {
		DWORD BeginAddress;
		DWORD EndAddress;
		DWORD HandlerAddress;
		DWORD JumpTarget;
	} ScopeRecord_t;

	crt_buffer_t ScopeTableCell(offsetof(SCOPE_TABLE, ScopeRecord));
	uc_mem_read(m_uc, (DWORD_PTR)ScopeTable, ScopeTableCell.GetBuffer(), ScopeTableCell.GetLength());
	PSCOPE_TABLE ScopeTableCellPtr = (PSCOPE_TABLE)ScopeTableCell.GetBuffer();
	ScopeTableCell.GetSpace(offsetof(SCOPE_TABLE, ScopeRecord) + ScopeTableCellPtr->Count * sizeof(ScopeRecord_t));
	uc_mem_read(m_uc, (DWORD_PTR)ScopeTable, ScopeTableCell.GetBuffer(), ScopeTableCell.GetLength());
	ScopeTableCellPtr = (PSCOPE_TABLE)ScopeTableCell.GetBuffer();

	if (IS_DISPATCHING(ExceptionRecord.ExceptionFlags)) {
		ExceptionPointers.ExceptionRecord = (PEXCEPTION_RECORD)ExceptionRecordBase;
		ExceptionPointers.ContextRecord = (PCONTEXT)ContextRecordBase;

		for (Index = DispatcherContext.ScopeIndex;
			Index < ScopeTableCellPtr->Count;
			Index += 1) {
			if ((ControlPc >= ScopeTableCellPtr->ScopeRecord[Index].BeginAddress) &&
				(ControlPc < ScopeTableCellPtr->ScopeRecord[Index].EndAddress) &&
				(ScopeTableCellPtr->ScopeRecord[Index].JumpTarget != 0)) {
				if (ScopeTableCellPtr->ScopeRecord[Index].HandlerAddress == 1) {
					Value = EXCEPTION_EXECUTE_HANDLER;
				}
				else {
					ExceptionFilter = (PEXCEPTION_FILTER)
						(ScopeTableCellPtr->ScopeRecord[Index].HandlerAddress + ImageBase);

					//Value = ExceptionFilter(&ExceptionPointers, (PVOID)EstablisherFrame);
					auto ExceptionPointersBase = StackAlloc(sizeof(ExceptionPointers));
					uc_mem_write(m_uc, ExceptionPointersBase, &ExceptionPointers, sizeof(ExceptionPointers));

					uc_reg_write(m_uc, UC_X86_REG_RCX, &ExceptionPointersBase);
					uc_reg_write(m_uc, UC_X86_REG_RDX, &EstablisherFrame);

					DWORD_PTR retAddr = StackAlloc(sizeof(m_ImageEnd));
					uc_mem_write(m_uc, retAddr, &m_ImageEnd, sizeof(m_ImageEnd));

					auto err = uc_emu_start(m_uc, (DWORD_PTR)ExceptionFilter, m_ImageEnd, 0, 0);

					StackFree(sizeof(ExceptionPointers));

					uc_reg_read(m_uc, UC_X86_REG_RAX, &Value);
				}

				if (Value < 0) {
					return ExceptionContinueExecution;
				}
				else if (Value > 0) {

					RtlpUnwindEx(
						(PVOID)EstablisherFrame,
						(PVOID)(ScopeTableCellPtr->ScopeRecord[Index].JumpTarget + ImageBase),
						(PEXCEPTION_RECORD)ExceptionRecordBase,
						(PVOID)((ULONG_PTR)ExceptionRecord.ExceptionCode),
						(PCONTEXT)DispatcherContext.ContextRecord,
						DispatcherContext.HistoryTable);

					m_ExecuteExceptionHandler = 2;

					return ExceptionContinueExecution;
				}
			}
		}
	}
	else {

		TargetPc = DispatcherContext.TargetIp - ImageBase;

		for (Index = DispatcherContext.ScopeIndex;
			Index < ScopeTableCellPtr->Count;
			Index += 1) {
			if ((ControlPc >= ScopeTableCellPtr->ScopeRecord[Index].BeginAddress) &&
				(ControlPc < ScopeTableCellPtr->ScopeRecord[Index].EndAddress)) {
				if (IS_TARGET_UNWIND(ExceptionRecord.ExceptionFlags)) {
					for (TargetIndex = 0;
						TargetIndex < ScopeTableCellPtr->Count;
						TargetIndex += 1) {
						if ((TargetPc >= ScopeTableCellPtr->ScopeRecord[TargetIndex].BeginAddress) &&
							(TargetPc < ScopeTableCellPtr->ScopeRecord[TargetIndex].EndAddress) &&
							(ScopeTableCellPtr->ScopeRecord[TargetIndex].JumpTarget ==
								ScopeTableCellPtr->ScopeRecord[Index].JumpTarget) &&
							(ScopeTableCellPtr->ScopeRecord[TargetIndex].HandlerAddress ==
								ScopeTableCellPtr->ScopeRecord[Index].HandlerAddress)) {
							break;
						}
					}

					if (TargetIndex != ScopeTableCellPtr->Count) {
						break;
					}
				}

				if (ScopeTableCellPtr->ScopeRecord[Index].JumpTarget != 0) {
					if ((TargetPc == ScopeTableCellPtr->ScopeRecord[Index].JumpTarget) &&
						(IS_TARGET_UNWIND(ExceptionRecord.ExceptionFlags))) {
						break;
					}
				}
				else {
					DispatcherContext.ScopeIndex = Index + 1;

					TerminationHandler = (PTERMINATION_HANDLER)
						(ScopeTable->ScopeRecord[Index].HandlerAddress + ImageBase);


					//TerminationHandler(TRUE, (PVOID)EstablisherFrame);
				}
			}
		}
	}

	return ExceptionContinueSearch;
}

void PeEmulation::RtlpRestoreContext(
	_In_ PCONTEXT ContextRecord,
	_In_ PEXCEPTION_RECORD ExceptionRecord OPTIONAL
)
{
	uc_reg_write(m_uc, UC_X86_REG_CS, &ContextRecord->SegCs);
	uc_reg_write(m_uc, UC_X86_REG_DS, &ContextRecord->SegDs);
	uc_reg_write(m_uc, UC_X86_REG_ES, &ContextRecord->SegEs);
	uc_reg_write(m_uc, UC_X86_REG_SS, &ContextRecord->SegSs);
	uc_reg_write(m_uc, UC_X86_REG_FS, &ContextRecord->SegFs);
	uc_reg_write(m_uc, UC_X86_REG_GS, &ContextRecord->SegGs);

	uc_reg_write(m_uc, UC_X86_REG_RAX, &ContextRecord->Rax);
	uc_reg_write(m_uc, UC_X86_REG_RBX, &ContextRecord->Rbx);
	uc_reg_write(m_uc, UC_X86_REG_RCX, &ContextRecord->Rcx);
	uc_reg_write(m_uc, UC_X86_REG_RDX, &ContextRecord->Rdx);
	uc_reg_write(m_uc, UC_X86_REG_RSI, &ContextRecord->Rsi);
	uc_reg_write(m_uc, UC_X86_REG_RDI, &ContextRecord->Rdi);
	uc_reg_write(m_uc, UC_X86_REG_R8, &ContextRecord->R8);
	uc_reg_write(m_uc, UC_X86_REG_R9, &ContextRecord->R9);
	uc_reg_write(m_uc, UC_X86_REG_R10, &ContextRecord->R10);
	uc_reg_write(m_uc, UC_X86_REG_R11, &ContextRecord->R11);
	uc_reg_write(m_uc, UC_X86_REG_R12, &ContextRecord->R12);
	uc_reg_write(m_uc, UC_X86_REG_R13, &ContextRecord->R13);
	uc_reg_write(m_uc, UC_X86_REG_R14, &ContextRecord->R14);
	uc_reg_write(m_uc, UC_X86_REG_R15, &ContextRecord->R15);
	uc_reg_write(m_uc, UC_X86_REG_RBP, &ContextRecord->Rbp);

	uc_reg_write(m_uc, UC_X86_REG_XMM0, &ContextRecord->Xmm0);
	uc_reg_write(m_uc, UC_X86_REG_XMM1, &ContextRecord->Xmm1);
	uc_reg_write(m_uc, UC_X86_REG_XMM2, &ContextRecord->Xmm2);
	uc_reg_write(m_uc, UC_X86_REG_XMM3, &ContextRecord->Xmm3);
	uc_reg_write(m_uc, UC_X86_REG_XMM4, &ContextRecord->Xmm4);
	uc_reg_write(m_uc, UC_X86_REG_XMM5, &ContextRecord->Xmm5);
	uc_reg_write(m_uc, UC_X86_REG_XMM6, &ContextRecord->Xmm6);
	uc_reg_write(m_uc, UC_X86_REG_XMM7, &ContextRecord->Xmm7);
	uc_reg_write(m_uc, UC_X86_REG_XMM8, &ContextRecord->Xmm8);
	uc_reg_write(m_uc, UC_X86_REG_XMM9, &ContextRecord->Xmm9);
	uc_reg_write(m_uc, UC_X86_REG_XMM10, &ContextRecord->Xmm10);
	uc_reg_write(m_uc, UC_X86_REG_XMM11, &ContextRecord->Xmm11);
	uc_reg_write(m_uc, UC_X86_REG_XMM12, &ContextRecord->Xmm12);
	uc_reg_write(m_uc, UC_X86_REG_XMM13, &ContextRecord->Xmm13);
	uc_reg_write(m_uc, UC_X86_REG_XMM14, &ContextRecord->Xmm14);
	uc_reg_write(m_uc, UC_X86_REG_XMM15, &ContextRecord->Xmm15);

	uc_reg_write(m_uc, UC_X86_REG_EFLAGS, &ContextRecord->EFlags);
	uc_reg_write(m_uc, UC_X86_REG_RSP, &ContextRecord->Rsp);
	uc_reg_write(m_uc, UC_X86_REG_RIP, &ContextRecord->Rip);
	m_ExecuteFromRip = ContextRecord->Rip;

	uc_reg_write(m_uc, UC_X86_REG_DR0, &ContextRecord->Dr0);
	uc_reg_write(m_uc, UC_X86_REG_DR1, &ContextRecord->Dr1);
	uc_reg_write(m_uc, UC_X86_REG_DR2, &ContextRecord->Dr2);
	uc_reg_write(m_uc, UC_X86_REG_DR3, &ContextRecord->Dr3);
	uc_reg_write(m_uc, UC_X86_REG_DR6, &ContextRecord->Dr6);
	uc_reg_write(m_uc, UC_X86_REG_DR7, &ContextRecord->Dr7);
}

void PeEmulation::RtlpCaptureContext(_In_ PCONTEXT ContextRecord)
{
	uc_reg_read(m_uc, UC_X86_REG_CS, &ContextRecord->SegCs);
	uc_reg_read(m_uc, UC_X86_REG_DS, &ContextRecord->SegDs);
	uc_reg_read(m_uc, UC_X86_REG_ES, &ContextRecord->SegEs);
	uc_reg_read(m_uc, UC_X86_REG_SS, &ContextRecord->SegSs);
	uc_reg_read(m_uc, UC_X86_REG_FS, &ContextRecord->SegFs);
	uc_reg_read(m_uc, UC_X86_REG_GS, &ContextRecord->SegGs);

	uc_reg_read(m_uc, UC_X86_REG_RAX, &ContextRecord->Rax);
	uc_reg_read(m_uc, UC_X86_REG_RBX, &ContextRecord->Rbx);
	uc_reg_read(m_uc, UC_X86_REG_RCX, &ContextRecord->Rcx);
	uc_reg_read(m_uc, UC_X86_REG_RDX, &ContextRecord->Rdx);
	uc_reg_read(m_uc, UC_X86_REG_RSI, &ContextRecord->Rsi);
	uc_reg_read(m_uc, UC_X86_REG_RDI, &ContextRecord->Rdi);
	uc_reg_read(m_uc, UC_X86_REG_R8, &ContextRecord->R8);
	uc_reg_read(m_uc, UC_X86_REG_R9, &ContextRecord->R9);
	uc_reg_read(m_uc, UC_X86_REG_R10, &ContextRecord->R10);
	uc_reg_read(m_uc, UC_X86_REG_R11, &ContextRecord->R11);
	uc_reg_read(m_uc, UC_X86_REG_R12, &ContextRecord->R12);
	uc_reg_read(m_uc, UC_X86_REG_R13, &ContextRecord->R13);
	uc_reg_read(m_uc, UC_X86_REG_R14, &ContextRecord->R14);
	uc_reg_read(m_uc, UC_X86_REG_R15, &ContextRecord->R15);
	uc_reg_read(m_uc, UC_X86_REG_RBP, &ContextRecord->Rbp);

	uc_reg_read(m_uc, UC_X86_REG_XMM0, &ContextRecord->Xmm0);
	uc_reg_read(m_uc, UC_X86_REG_XMM1, &ContextRecord->Xmm1);
	uc_reg_read(m_uc, UC_X86_REG_XMM2, &ContextRecord->Xmm2);
	uc_reg_read(m_uc, UC_X86_REG_XMM3, &ContextRecord->Xmm3);
	uc_reg_read(m_uc, UC_X86_REG_XMM4, &ContextRecord->Xmm4);
	uc_reg_read(m_uc, UC_X86_REG_XMM5, &ContextRecord->Xmm5);
	uc_reg_read(m_uc, UC_X86_REG_XMM6, &ContextRecord->Xmm6);
	uc_reg_read(m_uc, UC_X86_REG_XMM7, &ContextRecord->Xmm7);
	uc_reg_read(m_uc, UC_X86_REG_XMM8, &ContextRecord->Xmm8);
	uc_reg_read(m_uc, UC_X86_REG_XMM9, &ContextRecord->Xmm9);
	uc_reg_read(m_uc, UC_X86_REG_XMM10, &ContextRecord->Xmm10);
	uc_reg_read(m_uc, UC_X86_REG_XMM11, &ContextRecord->Xmm11);
	uc_reg_read(m_uc, UC_X86_REG_XMM12, &ContextRecord->Xmm12);
	uc_reg_read(m_uc, UC_X86_REG_XMM13, &ContextRecord->Xmm13);
	uc_reg_read(m_uc, UC_X86_REG_XMM14, &ContextRecord->Xmm14);
	uc_reg_read(m_uc, UC_X86_REG_XMM15, &ContextRecord->Xmm15);

	uc_reg_read(m_uc, UC_X86_REG_RIP, &ContextRecord->Rip);
	uc_reg_read(m_uc, UC_X86_REG_RSP, &ContextRecord->Rsp);
	uc_reg_read(m_uc, UC_X86_REG_EFLAGS, &ContextRecord->EFlags);

	ContextRecord->Dr0 = 0;
	ContextRecord->Dr1 = 0;
	ContextRecord->Dr2 = 0;
	ContextRecord->Dr3 = 0;
	ContextRecord->Dr6 = 0;
	ContextRecord->Dr7 = 0;

	ContextRecord->ContextFlags = CONTEXT_FULL;
}
#else
void RtlpCopyContext(
	_Out_ PCONTEXT Destination,
	_In_ PCONTEXT Source
) {

	//
	// Copy nonvolatile context required for exception dispatch and unwind.
	//

	Destination->Eip = Source->Eip;
	Destination->Ebx = Source->Ebx;
	Destination->Esp = Source->Esp;
	Destination->Ebp = Source->Ebp;
	Destination->Esi = Source->Esi;
	Destination->Edi = Source->Edi;
	Destination->SegCs = Source->SegCs;
	Destination->SegSs = Source->SegSs;
	Destination->MxCsr = Source->MxCsr;
	Destination->EFlags = Source->EFlags;

	return;
}

void PeEmulation::RtlpRestoreContext(
	_In_ PCONTEXT ContextRecord,
	_In_ PEXCEPTION_RECORD ExceptionRecord OPTIONAL
)
{
	uc_reg_write(m_uc, UC_X86_REG_CS, &ContextRecord->SegCs);
	uc_reg_write(m_uc, UC_X86_REG_DS, &ContextRecord->SegDs);
	uc_reg_write(m_uc, UC_X86_REG_ES, &ContextRecord->SegEs);
	uc_reg_write(m_uc, UC_X86_REG_SS, &ContextRecord->SegSs);
	uc_reg_write(m_uc, UC_X86_REG_FS, &ContextRecord->SegFs);
	uc_reg_write(m_uc, UC_X86_REG_GS, &ContextRecord->SegGs);

	uc_reg_write(m_uc, UC_X86_REG_EAX, &ContextRecord->Eax);
	uc_reg_write(m_uc, UC_X86_REG_EBX, &ContextRecord->Ebx);
	uc_reg_write(m_uc, UC_X86_REG_ECX, &ContextRecord->Ecx);
	uc_reg_write(m_uc, UC_X86_REG_EDX, &ContextRecord->Edx);
	uc_reg_write(m_uc, UC_X86_REG_ESI, &ContextRecord->Esi);
	uc_reg_write(m_uc, UC_X86_REG_EDI, &ContextRecord->Edi);
	uc_reg_write(m_uc, UC_X86_REG_EBP, &ContextRecord->Ebp);

	uc_reg_write(m_uc, UC_X86_REG_EFLAGS, &ContextRecord->EFlags);
	uc_reg_write(m_uc, UC_X86_REG_ESP, &ContextRecord->Esp);
	uc_reg_write(m_uc, UC_X86_REG_EIP, &ContextRecord->Eip);
	m_ExecuteFromRip = ContextRecord->Eip;

	uc_reg_write(m_uc, UC_X86_REG_DR0, &ContextRecord->Dr0);
	uc_reg_write(m_uc, UC_X86_REG_DR1, &ContextRecord->Dr1);
	uc_reg_write(m_uc, UC_X86_REG_DR2, &ContextRecord->Dr2);
	uc_reg_write(m_uc, UC_X86_REG_DR3, &ContextRecord->Dr3);
	uc_reg_write(m_uc, UC_X86_REG_DR6, &ContextRecord->Dr6);
	uc_reg_write(m_uc, UC_X86_REG_DR7, &ContextRecord->Dr7);
}

void PeEmulation::RtlpCaptureContext(_In_ PCONTEXT ContextRecord)
{
	uc_reg_read(m_uc, UC_X86_REG_CS, &ContextRecord->SegCs);
	uc_reg_read(m_uc, UC_X86_REG_DS, &ContextRecord->SegDs);
	uc_reg_read(m_uc, UC_X86_REG_ES, &ContextRecord->SegEs);
	uc_reg_read(m_uc, UC_X86_REG_SS, &ContextRecord->SegSs);
	uc_reg_read(m_uc, UC_X86_REG_FS, &ContextRecord->SegFs);
	uc_reg_read(m_uc, UC_X86_REG_GS, &ContextRecord->SegGs);

	uc_reg_read(m_uc, UC_X86_REG_EAX, &ContextRecord->Eax);
	uc_reg_read(m_uc, UC_X86_REG_EBX, &ContextRecord->Ebx);
	uc_reg_read(m_uc, UC_X86_REG_ECX, &ContextRecord->Ecx);
	uc_reg_read(m_uc, UC_X86_REG_EDX, &ContextRecord->Edx);
	uc_reg_read(m_uc, UC_X86_REG_ESI, &ContextRecord->Esi);
	uc_reg_read(m_uc, UC_X86_REG_EDI, &ContextRecord->Edi);
	uc_reg_read(m_uc, UC_X86_REG_EBP, &ContextRecord->Ebp);

	uc_reg_read(m_uc, UC_X86_REG_EIP, &ContextRecord->Eip);
	uc_reg_read(m_uc, UC_X86_REG_ESP, &ContextRecord->Esp);
	uc_reg_read(m_uc, UC_X86_REG_EFLAGS, &ContextRecord->EFlags);

	uc_reg_read(m_uc, UC_X86_REG_DR0, &ContextRecord->Dr0);
	uc_reg_read(m_uc, UC_X86_REG_DR1, &ContextRecord->Dr1);
	uc_reg_read(m_uc, UC_X86_REG_DR2, &ContextRecord->Dr2);
	uc_reg_read(m_uc, UC_X86_REG_DR3, &ContextRecord->Dr3);
	uc_reg_read(m_uc, UC_X86_REG_DR6, &ContextRecord->Dr6);
	uc_reg_read(m_uc, UC_X86_REG_DR7, &ContextRecord->Dr7);

	ContextRecord->ContextFlags = CONTEXT_FULL;
}
#endif


```

`PeVisor/Src/Trace.cpp`:

```cpp
#include "Trace.hpp"

Trace::Trace(_In_ DWORD_PTR Rip)
{

}
```

`PeVisor/Src/ucHooks.cpp`:

```cpp
#include "UCPE.hpp"
#include "EmuApiFuncs.hpp"
#include "Trace.hpp"
#include <fstream>
extern std::ostream* outs;

namespace ucHooks {

	std::vector<std::string> Instrs;

	void HookSySCall(uc_engine* uc, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		std::stringstream region;

		DWORD_PTR Rip = 0;
		uc_reg_read(uc, UC_X86_REG_RIP, &Rip);
		ctx->FindAddressInRegion(Rip, region);
		*outs << "Syscall at " << region.str() << "\n";
	}

	void HookCpuid(uc_engine* uc, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;
		CPUID_REGS Regs{};

		uint32_t eax;
		uc_reg_read(uc, UC_X86_REG_EAX, &eax);

		std::string szCPUID_FUNCTION;

		// Check the 'AuthenticAMD' vendor name:
		__cpuid(Regs.Raw, CPUID::Generic::CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID);
		if (Regs.Regs.Ebx != AmdEnc::AEbx || Regs.Regs.Edx != AmdEnc::AEdx || Regs.Regs.Ecx != AmdEnc::AEcx)
		{
			Regs = {0};

			__cpuid(Regs.Raw, eax);
			switch (eax)
			{
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID:
				szCPUID_FUNCTION = "CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_FEATURE_INFORMATION:
				szCPUID_FUNCTION = "CPUID_FEATURE_INFORMATION";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_MONITOR_MWAIT_PARAMETERS:
				szCPUID_FUNCTION = "CPUID_MONITOR_MWAIT_PARAMETERS";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_THERMAL_POWER_MANAGEMENT:
				szCPUID_FUNCTION = "CPUID_THERMAL_POWER_MANAGEMENT";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_STRUCTURED_EXTENDED_FEATURE_ENUMERATION:
				szCPUID_FUNCTION = "CPUID_STRUCTURED_EXTENDED_FEATURE_ENUMERATION";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_PROCESSOR_EXTENDED_STATE_ENUMERATION:
				szCPUID_FUNCTION = "CPUID_PROCESSOR_EXTENDED_STATE_ENUMERATION";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID:
				szCPUID_FUNCTION = "CPUID_MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_EXTENDED_FEATURE_INFORMATION:
				szCPUID_FUNCTION = "CPUID_EXTENDED_FEATURE_INFORMATION";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_PROCESSOR_BRAND_STRING_0:
				szCPUID_FUNCTION = "CPUID_PROCESSOR_BRAND_STRING_0";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_PROCESSOR_BRAND_STRING_1:
				szCPUID_FUNCTION = "CPUID_PROCESSOR_BRAND_STRING_1";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_PROCESSOR_BRAND_STRING_2:
				szCPUID_FUNCTION = "CPUID_PROCESSOR_BRAND_STRING_2";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_L1_AND_TLB:
				szCPUID_FUNCTION = "CPUID_L1_AND_TLB";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_L2_L3_TLB:
				szCPUID_FUNCTION = "CPUID_L2_L3_TLB";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_POWER_MANAGEMENT_AND_RAS_CAPABILITIES:
				szCPUID_FUNCTION = "CPUID_POWER_MANAGEMENT_AND_RAS_CAPABILITIES";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_CAPACITY_AND_EXTENDED_FEATURES:
				szCPUID_FUNCTION = "CPUID_CAPACITY_AND_EXTENDED_FEATURES";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_SVM_FEATURES:
				szCPUID_FUNCTION = "CPUID_SVM_FEATURES";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_TLB_CHARACTERISTICS_FOR_1GB_PAGES:
				szCPUID_FUNCTION = "CPUID_TLB_CHARACTERISTICS_FOR_1GB_PAGES";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_INSTRUCTION_OPTIMIZATIONS:
				szCPUID_FUNCTION = "CPUID_INSTRUCTION_OPTIMIZATIONS";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_INSTRUCTION_BASED_SAMPLING_CAPABILITIES:
				szCPUID_FUNCTION = "CPUID_INSTRUCTION_BASED_SAMPLING_CAPABILITIES";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_LIGHTWEIGHT_PROFILING_CAPABILITIES:
				szCPUID_FUNCTION = "CPUID_LIGHTWEIGHT_PROFILING_CAPABILITIES";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_CACHE_TOPOLOGY_INFORMATION:
				szCPUID_FUNCTION = "CPUID_CACHE_TOPOLOGY_INFORMATION";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_PROCESSOR_TOPOLOGY_INFORMATION:
				szCPUID_FUNCTION = "CPUID_PROCESSOR_TOPOLOGY_INFORMATION";
				break;
			case CPUID::AMD::CPUID_FUNCTIONS::CPUID_ENCRYPTED_MEMORY_CAPABILITIES:
				szCPUID_FUNCTION = "CPUID_ENCRYPTED_MEMORY_CAPABILITIES";
				break;
			}
		}
		else
		{
			Regs = {0};

			__cpuid(Regs.Raw, eax);
			switch (eax)
			{
			case CPUID::Generic::CPUID_FUNCTIONS::CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID:
				szCPUID_FUNCTION = "CPUID_MAXIMUM_FUNCTION_NUMBER_AND_VENDOR_ID";
				break;
			case CPUID::Generic::CPUID_FUNCTIONS::CPUID_FEATURE_INFORMATION:
				szCPUID_FUNCTION = "CPUID_FEATURE_INFORMATION";
				break;
			case CPUID::Generic::CPUID_FUNCTIONS::CPUID_MONITOR_MWAIT_PARAMETERS:
				szCPUID_FUNCTION = "CPUID_MONITOR_MWAIT_PARAMETERS";
				break;
			case CPUID::Generic::CPUID_FUNCTIONS::CPUID_THERMAL_POWER_MANAGEMENT:
				szCPUID_FUNCTION = "CPUID_THERMAL_POWER_MANAGEMENT";
				break;
			case CPUID::Generic::CPUID_FUNCTIONS::CPUID_STRUCTURED_EXTENDED_FEATURE_ENUMERATION:
				szCPUID_FUNCTION = "CPUID_STRUCTURED_EXTENDED_FEATURE_ENUMERATION";
				break;
			case CPUID::Generic::CPUID_FUNCTIONS::CPUID_MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID:
				szCPUID_FUNCTION = "CPUID_MAXIMUM_EXTENDED_FUNCTION_NUMBER_AND_VENDOR_ID";
				break;
			case CPUID::Generic::CPUID_FUNCTIONS::CPUID_EXTENDED_FEATURE_INFORMATION:
				szCPUID_FUNCTION = "CPUID_EXTENDED_FEATURE_INFORMATION";
				break;
			case CPUID::Generic::CPUID_FUNCTIONS::CPUID_PROCESSOR_BRAND_STRING_0:
				szCPUID_FUNCTION = "CPUID_PROCESSOR_BRAND_STRING_0";
				break;
			case CPUID::Generic::CPUID_FUNCTIONS::CPUID_PROCESSOR_BRAND_STRING_1:
				szCPUID_FUNCTION = "CPUID_PROCESSOR_BRAND_STRING_1";
				break;
			case CPUID::Generic::CPUID_FUNCTIONS::CPUID_PROCESSOR_BRAND_STRING_2:
				szCPUID_FUNCTION = "CPUID_PROCESSOR_BRAND_STRING_2";
				break;
			}
		}

		DWORD_PTR Rax = Regs.Regs.Eax, Rbx = Regs.Regs.Ebx, Rcx = Regs.Regs.Ecx, Rdx = Regs.Regs.Edx;
		uc_reg_write(uc, UC_X86_REG_RAX, &Rax);
		uc_reg_write(uc, UC_X86_REG_RBX, &Rbx);
		uc_reg_write(uc, UC_X86_REG_RCX, &Rcx);
		uc_reg_write(uc, UC_X86_REG_RDX, &Rdx);

		std::stringstream region;

		DWORD_PTR Rip = 0;
		uc_reg_read(uc, UC_X86_REG_RIP, &Rip);
		ctx->FindAddressInRegion(Rip, region);

		std::cout << "CPUID at " << region.str() << " with cpuid function: " << szCPUID_FUNCTION << "\n";
		std::cout << "EAX: " << Regs.Regs.Eax << " EBX: " << Regs.Regs.Ebx << " ECX: " << Regs.Regs.Ecx
			<< " EDX: " << Regs.Regs.Edx << "\n";
	}

	void HookCode(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		/*PeEmulation* ctx = (PeEmulation*)user_data;

		ZydisDecoder DecoderMinimal{ ZYDIS_MACHINE_MODE_LONG_64, ZYDIS_STACK_WIDTH_64, ZYDIS_DECODER_MODE_MINIMAL };
		ZydisDecodedInstruction Instruction{};
		ZydisDecodedOperand Operands[ZYDIS_MAX_OPERAND_COUNT];

		ZydisFormatter Formatter;
		ZydisFormatterInit(&Formatter, ZYDIS_FORMATTER_STYLE_INTEL);

		ZydisDecoderDecodeFull(
			&DecoderMinimal,
			(const void*)address,
			ZYDIS_MAX_INSTRUCTION_LENGTH,
			&Instruction,
			Operands);

		std::stringstream region;
		ctx->FindAddressInRegion(address, region);

		char buffer[512]{};
		ZydisFormatterFormatInstruction(&Formatter, &Instruction, Operands,
			Instruction.operand_count_visible, buffer, sizeof(buffer), address, ZYAN_NULL);

		*outs << region.str() << ": " << buffer << "\n";*/
		//Instrs.push_back(buffer);

		//EmuReadReturnAddress(uc);
		//DWORD_PTR RCX = EmuReadReturnAddress(uc);
		////uc_reg_read(uc, UC_X86_REG_RSP, &RCX);
		//std::stringstream szR8;
		//if (ctx->FindAddressInRegion(RCX, szR8))
		//{
		//	*outs << "RCX: " << szR8.str() << "\n";
		//}
		//else
		//{
		//	*outs << "RCX: " << RCX << "\n";
		//}

		//DWORD_PTR Val = 0;
		//uc_mem_read(uc, (DWORD_PTR)(ctx->m_HeapBase + 0x1838), &Val, sizeof(Val));
		//*outs << "Val: " << Val << "\n";

		//if (Instruction.mnemonic == ZYDIS_MNEMONIC_RDTSC)
		//{
		//	std::stringstream region;
		//	DWORD_PTR Rax = __rdtsc();
		//	DWORD_PTR Rip = address + size;
		//	Rax = 0;
		//	DWORD_PTR Rdx = 0;
		//	uc_reg_write(uc, UC_X86_REG_RAX, &Rax);
		//	uc_reg_write(uc, UC_X86_REG_RDX, &Rdx);
		//	uc_reg_write(uc, UC_X86_REG_RIP, &Rip);
		//	if (ctx->FindAddressInRegion(address, region))
		//	{
		//		*outs << "RDTSC at " << region.str() << "\n";
		//	}
		//	else
		//	{
		//		*outs << "RDTSC at " << address << "\n";
		//	}
		//}
	}
	
	void HookIntr(uc_engine* uc, int exception, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;
		*outs << "Exception " << std::hex << exception << "\n";

		if (exception == EXCP01_DB)
		{
			ctx->m_LastException = STATUS_SINGLE_STEP;

			DWORD_PTR rflags = 0;
			uc_reg_read(uc, UC_X86_REG_RFLAGS, &rflags);

			rflags &= ~(1 << 8);
			uc_reg_write(uc, UC_X86_REG_RFLAGS, &rflags);

			CONTEXT CpuContext{};

			ctx->RtlpCaptureContext(&CpuContext);

			EXCEPTION_RECORD excprec{};
			DWORD_PTR Rip = 0;
			uc_reg_read(uc, UC_X86_REG_RIP, &Rip);
			excprec.ExceptionCode = EXCEPTION_SINGLE_STEP;
			excprec.ExceptionFlags = 0;
			excprec.ExceptionAddress = (PVOID)Rip;

			BOOL A = ctx->RtlpDispatchException(&excprec, &CpuContext);

			ctx->RtlpRestoreContext(&CpuContext, &excprec);
		}
		else if (exception == EXCP03_INT3)
		{
			ctx->m_LastException = STATUS_BREAKPOINT;
			CONTEXT CpuContext{};

			ctx->RtlpCaptureContext(&CpuContext);

			EXCEPTION_RECORD excprec{};
			DWORD_PTR Rip = 0;
			uc_reg_read(uc, UC_X86_REG_RIP, &Rip);
			excprec.ExceptionCode = EXCEPTION_BREAKPOINT;
			excprec.ExceptionFlags = 0;
			excprec.ExceptionAddress = (PVOID)Rip;

			BOOL A = ctx->RtlpDispatchException(&excprec, &CpuContext);

			ctx->RtlpRestoreContext(&CpuContext, &excprec);
		}
		else
		{
			ctx->m_LastException = STATUS_SUCCESS;
		}

		DWORD_PTR RIP = 0;
		uc_reg_read(uc, UC_X86_REG_RSP, &RIP);
		std::stringstream szR8;
		if (ctx->FindAddressInRegion(RIP, szR8))
		{
			*outs << "RIP: " << szR8.str() << "\n";
		}
		else
		{
			*outs << "RIP: " << RIP << "\n";
		}

		uc_emu_stop(uc);
	}

	void HookRwx(uc_engine* uc, uc_mem_type type,
		DWORD_PTR address, int size, INT_PTR value, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		switch (type) {
		case UC_MEM_READ: {
			if (ctx->m_BoundCheck)
			{
				std::stringstream region;
				if (!ctx->FindAddressInRegion(address, region))
				{
					*outs << "UC_MEM_READ out of region\n";

					uint64_t rip;
					uc_reg_read(uc, UC_X86_REG_RIP, &rip);
					if (ctx->FindAddressInRegion(rip, region))
						*outs << "UC_MEM_READ rip at " << region.str() << "\n";

					uc_emu_stop(uc);
				}
			}

			std::stringstream region;
			if (ctx->FindAddressInRegion(address, region, false, false, true))
			{
				*outs << "UC_MEM_READ on region " << region.str() << "\n";

				uint64_t rip;
				uc_reg_read(uc, UC_X86_REG_RIP, &rip);
				region.str("");
				if (ctx->FindAddressInRegion(rip, region))
					*outs << "UC_MEM_READ rip at " << region.str() << "\n";
			}

			break;
		}
		case UC_MEM_WRITE: {
			if (ctx->m_BoundCheck)
			{
				std::stringstream region;
				if (!ctx->FindAddressInRegion(address, region))
				{
					*outs << "UC_MEM_WRITE out of region\n";

					uint64_t rip;
					uc_reg_read(uc, UC_X86_REG_RIP, &rip);
					if (ctx->FindAddressInRegion(rip, region))
						*outs << "UC_MEM_WRITE rip at " << region.str() << "\n";

					uc_emu_stop(uc);
				}
			}

			std::stringstream region;
			if (ctx->FindAddressInRegion(address, region, false, false, true))
			{
				*outs << "UC_MEM_WRITE on region " << region.str() << "\n";

				uint64_t rip;
				uc_reg_read(uc, UC_X86_REG_RIP, &rip);
				region.str("");
				if (ctx->FindAddressInRegion(rip, region))
					*outs << "UC_MEM_WRITE rip at " << region.str() << "\n";
			}

			if (ctx->WriteMemMapping(address, value, size))
			{
				//*outs << "write to mapping address " << address << "\n";
			}

			break;
		}
		case UC_MEM_FETCH: {


			break;
		}
		}
	}

	bool HookInvalidRwx(uc_engine* uc, uc_mem_type type,
		DWORD_PTR address, int size, INT_PTR value, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		std::ofstream file("output.txt");
		if (!file.is_open()) {
			std::cerr << "Failed to open file for writing." << std::endl;
			return 1;
		}

		for (const auto& instr : Instrs) {
			file << instr << "\n";
		}

		file.close();

		switch (type) {
		case UC_MEM_FETCH_PROT: {
			uint64_t rip;
			uc_reg_read(uc, UC_X86_REG_RIP, &rip);

			std::stringstream region;
			if (ctx->FindAddressInRegion(address, region))
				*outs << "UC_MEM_FETCH_PROT from " << region.str() << "\n";
			else
				*outs << "UC_MEM_FETCH_PROT from " << std::hex << address << "\n";

			std::stringstream region2;
			if (ctx->FindAddressInRegion(rip, region2))
				*outs << "UC_MEM_FETCH_PROT rip at " << region2.str() << "\n";
			else
				*outs << "UC_MEM_FETCH_PROT rip at " << std::hex << rip << "\n";

			uc_emu_stop(uc);
			break;
		}
		case UC_MEM_WRITE_PROT: {
			uint64_t rip;
			uc_reg_read(uc, UC_X86_REG_RIP, &rip);

			std::stringstream region;
			if (ctx->FindAddressInRegion(address, region))
				*outs << "UC_MEM_WRITE_PROT from " << region.str() << "\n";
			else
				*outs << "UC_MEM_WRITE_PROT from " << std::hex << address << "\n";

			std::stringstream region2;
			if (ctx->FindAddressInRegion(rip, region2))
				*outs << "UC_MEM_WRITE_PROT rip at " << region2.str() << "\n";
			else
				*outs << "UC_MEM_WRITE_PROT rip at " << std::hex << rip << "\n";

			uc_emu_stop(uc);
			break;
		}
		case UC_MEM_FETCH_UNMAPPED: {
			uint64_t rip;
			uc_reg_read(uc, UC_X86_REG_RIP, &rip);

			std::stringstream region;
			if (ctx->FindAddressInRegion(address, region))
				*outs << "UC_MEM_FETCH_UNMAPPED from " << region.str() << "\n";
			else
				*outs << "UC_MEM_FETCH_UNMAPPED from " << std::hex << address << "\n";

			std::stringstream region2;
			if (ctx->FindAddressInRegion(rip, region2))
				*outs << "UC_MEM_FETCH_UNMAPPED rip at " << region2.str() << "\n";
			else
				*outs << "UC_MEM_FETCH_UNMAPPED rip at " << std::hex << rip << "\n";

			uc_emu_stop(uc);
			break;
		}
		case UC_MEM_READ_UNMAPPED: {
			uint64_t rip;
			uc_reg_read(uc, UC_X86_REG_RIP, &rip);

			std::stringstream region;
			if (ctx->FindAddressInRegion(address, region))
				*outs << "UC_MEM_READ_UNMAPPED from " << region.str() << "\n";
			else
				*outs << "UC_MEM_READ_UNMAPPED from " << std::hex << address << "\n";

			std::stringstream region2;
			if (ctx->FindAddressInRegion(rip, region2))
				*outs << "UC_MEM_READ_UNMAPPED rip at " << region2.str() << "\n";
			else
				*outs << "UC_MEM_READ_UNMAPPED rip at " << std::hex << rip << "\n";

			uc_emu_stop(uc);
			break;
		}
		case UC_MEM_WRITE_UNMAPPED: {
			uint64_t rip;
			uc_reg_read(uc, UC_X86_REG_RIP, &rip);

			std::stringstream region;
			if (ctx->FindAddressInRegion(address, region))
				*outs << "UC_MEM_WRITE_UNMAPPED from " << region.str() << "\n";
			else
				*outs << "UC_MEM_WRITE_UNMAPPED from " << std::hex << address << "\n";

			std::stringstream region2;
			if (ctx->FindAddressInRegion(rip, region2))
				*outs << "UC_MEM_WRITE_UNMAPPED rip at " << region2.str() << "\n";
			else
				*outs << "UC_MEM_WRITE_UNMAPPED rip at " << std::hex << rip << "\n";

			uc_emu_stop(uc);
			break;
		}
		}
		return false;
	}

	void EmuUnknownAPI(uc_engine* uc, DWORD_PTR address, size_t size, void* user_data)
	{
		PeEmulation* ctx = (PeEmulation*)user_data;

		std::wstring DllName;
		PFakeAPI api = nullptr;

		DWORD_PTR currentModule = 0;
		ctx->FindModuleByAddress(address, currentModule);

		if (currentModule != ctx->m_LastRipModule)
		{
			if (ctx->m_LastRipModule == ctx->m_ImageBase)
			{
				if (ctx->FindAPIByAddress(address, DllName, &api))
				{
					if (!api->EmuCallback)
					{
						std::string aDllName;
						UnicodeToANSI(DllName, aDllName);
						*outs << "API emulation callback not registered: " << aDllName << "!" << api->ProcedureName << "\n";
						auto retaddr = EmuReadReturnAddress(uc);
						if (retaddr >= ctx->m_ImageBase && retaddr < ctx->m_ImageEnd)
							*outs << "called from imagebase+0x" << std::hex << (ULONG)(retaddr - ctx->m_ImageBase) << "\n";
						uc_emu_stop(uc);
					}
					else
					{
						void(*callback)(uc_engine * uc, DWORD_PTR address, size_t size, void* user_data)
							= (decltype(callback))api->EmuCallback;

						callback(uc, address, size, user_data);
					}
				}
				else
				{
					*outs << "unknown API called\n";
					auto retaddr = EmuReadReturnAddress(uc);
					if (retaddr >= ctx->m_ImageBase && retaddr < ctx->m_ImageEnd)
						*outs << "called from imagebase+0x" << std::hex << (ULONG)(retaddr - ctx->m_ImageBase) << "\n";
					uc_emu_stop(uc);
				}
			}
			ctx->m_LastRipModule = currentModule;
		}
		else if (currentModule != ctx->m_ImageBase)
		{
			if (ctx->FindAPIByAddress(address, DllName, &api))
			{
				_CrtDbgBreak();
			}
		}

		if (currentModule == ctx->m_ImageBase && ctx->m_IsPacked && !ctx->m_ImageRealEntry)
		{
			PFakeSection section = nullptr;
			if (ctx->FindSectionByAddress(address, &section) && !section->IsUnknownSection)
			{
				ctx->m_ImageRealEntry = address;
			}
		}
	}
}
```

`PeVisor/Src/wsprintf.cpp`:

```cpp
#include "wsprintf.h"
#include "Crt.hpp"

/***********************************************************************
 *           WPRINTF_ParseFormatA
 *
 * Parse a format specification. A format specification has the form:
 *
 * [-][#][0][width][.precision]type
 *
 * Return value is the length of the format specification in characters.
 */
static INT WPRINTF_ParseFormatA(uc_engine* uc, LPCSTR format, WPRINTF_FORMAT *res)
{
    LPCSTR p = format;

    res->flags = 0;
    res->width = 0;
    res->precision = 0;
    if (*p == '-') { res->flags |= WPRINTF_LEFTALIGN; p++; }
    if (*p == '#') { res->flags |= WPRINTF_PREFIX_HEX; p++; }
    if (*p == '0') { res->flags |= WPRINTF_ZEROPAD; p++; }
    while ((*p >= '0') && (*p <= '9'))  /* width field */
    {
        res->width = res->width * 10 + *p - '0';
        p++;
    }
    if (*p == '.')  /* precision field */
    {
        p++;
        while ((*p >= '0') && (*p <= '9'))
        {
            res->precision = res->precision * 10 + *p - '0';
            p++;
        }
    }
    if (*p == 'l') { res->flags |= WPRINTF_LONG; p++; }
    else if (*p == 'h') { res->flags |= WPRINTF_SHORT; p++; }
    else if (*p == 'w') { res->flags |= WPRINTF_WIDE; p++; }
    else if (*p == 'I')
    {
        if (p[1] == '6' && p[2] == '4') { res->flags |= WPRINTF_I64; p += 3; }
        else if (p[1] == '3' && p[2] == '2') { p += 3; }
        else { res->flags |= WPRINTF_INTPTR; p++; }
    }

    switch(*p)
    {
    case 'c':
    {
        res->type = (res->flags & WPRINTF_LONG) ? WPR_WCHAR : WPR_CHAR;
        break;
    }
    case 'C':
    {
        res->type = (res->flags & WPRINTF_SHORT) ? WPR_CHAR : WPR_WCHAR;
        break;
    }
    case 'd': __fallthrough;
    case 'i':
    {
        res->type = WPR_SIGNED;
        break;
    }
    case 's':
    {
        res->type = (res->flags & (WPRINTF_LONG | WPRINTF_WIDE)) ? WPR_WSTRING : WPR_STRING;
        break;
    }
    case 'S':
    {
        res->type = (res->flags & (WPRINTF_SHORT | WPRINTF_WIDE)) ? WPR_STRING : WPR_WSTRING;
        break;
    }
    case 'u':
    {
        res->type = WPR_UNSIGNED;
        break;
    }
    case 'p':
    {
        res->width = 2 * sizeof(void*);
        res->flags |= WPRINTF_ZEROPAD | WPRINTF_INTPTR;
        __fallthrough;/* fall through */
    }
    case 'X':
    {
        res->flags |= WPRINTF_UPPER_HEX;
        __fallthrough;/* fall through */
    }
    case 'x':
    {
        res->type = WPR_HEXA;
        break;
    }
    default: /* unknown format char */
    {
        res->type = WPR_UNKNOWN;
        p--;  /* print format as normal char */
        break;
    }
    }
    return (INT)(p - format) + 1;
}


/***********************************************************************
 *           WPRINTF_ParseFormatW
 *
 * Parse a format specification. A format specification has the form:
 *
 * [-][#][0][width][.precision]type
 *
 * Return value is the length of the format specification in characters.
 */
static INT WPRINTF_ParseFormatW(uc_engine* uc, LPCWSTR format, WPRINTF_FORMAT *res)
{
    LPCWSTR p = format;

    res->flags = 0;
    res->width = 0;
    res->precision = 0;
    if (*p == '-') { res->flags |= WPRINTF_LEFTALIGN; p++; }
    if (*p == '#') { res->flags |= WPRINTF_PREFIX_HEX; p++; }
    if (*p == '0') { res->flags |= WPRINTF_ZEROPAD; p++; }
    while ((*p >= '0') && (*p <= '9'))  /* width field */
    {
        res->width = res->width * 10 + *p - '0';
        p++;
    }
    if (*p == '.')  /* precision field */
    {
        p++;
        while ((*p >= '0') && (*p <= '9'))
        {
            res->precision = res->precision * 10 + *p - '0';
            p++;
        }
    }
    if (*p == 'l') { res->flags |= WPRINTF_LONG; p++; }
    else if (*p == 'h') { res->flags |= WPRINTF_SHORT; p++; }
    else if (*p == 'w') { res->flags |= WPRINTF_WIDE; p++; }
    else if (*p == 'I')
    {
        if (p[1] == '6' && p[2] == '4') { res->flags |= WPRINTF_I64; p += 3; }
        else if (p[1] == '3' && p[2] == '2') { p += 3; }
        else { res->flags |= WPRINTF_INTPTR; p++; }
    }
    switch(*p)
    {
    case 'c':
    {
        res->type = (res->flags & WPRINTF_SHORT) ? WPR_CHAR : WPR_WCHAR;
        break;
    }
    case 'C':
    {
        res->type = (res->flags & WPRINTF_LONG) ? WPR_WCHAR : WPR_CHAR;
        break;
    }
    case 'd': __fallthrough;
    case 'i':
    {
        res->type = WPR_SIGNED;
        break;
    }
    case 's':
    {
        res->type = ((res->flags & WPRINTF_SHORT) && !(res->flags & WPRINTF_WIDE)) ? WPR_STRING : WPR_WSTRING;
        break;
    }
    case 'S':
    {
        res->type = (res->flags & (WPRINTF_LONG | WPRINTF_WIDE)) ? WPR_WSTRING : WPR_STRING;
        break;
    }
    case 'u':
    {
        res->type = WPR_UNSIGNED;
        break;
    }
    case 'p':
    {
        res->width = 2 * sizeof(void*);
        res->flags |= WPRINTF_ZEROPAD | WPRINTF_INTPTR;
        __fallthrough;/* fall through */
    }
    case 'X':
    {
        res->flags |= WPRINTF_UPPER_HEX;
        __fallthrough;/* fall through */
    }
    case 'x':
    {
        res->type = WPR_HEXA;
        break;
    }
    default:
    {
        res->type = WPR_UNKNOWN;
        p--;  /* print format as normal char */
        break;
    }
    }
    return (INT)(p - format) + 1;
}


/***********************************************************************
 *           WPRINTF_GetLen
 */
static UINT WPRINTF_GetLen(uc_engine* uc, WPRINTF_FORMAT *format, WPRINTF_DATA *arg,
                            LPSTR number, UINT maxlen, BOOL dst_is_wide)
{
    UINT len;

    if (format->flags & WPRINTF_LEFTALIGN) format->flags &= ~WPRINTF_ZEROPAD;
    if (format->width > maxlen) format->width = maxlen;
    switch(format->type)
    {
    case WPR_CHAR: { return (format->precision = 1); }
    case WPR_WCHAR:
    {
        if (dst_is_wide) len = 1;
        else len = WideCharToMultiByte(CP_ACP, 0, &arg->wchar_view, 1, NULL, 0, NULL, NULL);
        return (format->precision = len);
    }
    case WPR_STRING:
    {
        if (!arg->lpcstr_view) arg->lpcstr_view = "(null)";
        if (dst_is_wide)
        {
            LPCSTR p = arg->lpcstr_view;
            for (len = 0; (!format->precision || len < format->precision) && *p; p++)
            {
                /* This isn't applicable for UTF-8 and UTF-7 */
                if (IsDBCSLeadByte(*p)) p++;
                len++;
                if (!*p) break;
            }
        }
        else
        {
            for (len = 0; !format->precision || (len < format->precision); len++)
                if (!*(arg->lpcstr_view + len)) break;
        }
        if (len > maxlen) len = maxlen;
        return (format->precision = len);
    }
    case WPR_WSTRING:
    {
        if (!arg->lpcwstr_view) arg->lpcwstr_view = L"(null)";
        if (dst_is_wide)
        {
            for (len = 0; !format->precision || (len < format->precision); len++)
                if (!*(arg->lpcwstr_view + len)) break;
        }
        else
        {
            LPCWSTR p = arg->lpcwstr_view;
            for (len = 0; (!format->precision || len < format->precision) && *p; p++)
                len += WideCharToMultiByte(CP_ACP, 0, p, 1, NULL, 0, NULL, NULL);
            if (format->precision && len > format->precision) len = format->precision;
        }
        if (len > maxlen) len = maxlen;
        return (format->precision = len);
    }
    case WPR_SIGNED: __fallthrough;
    case WPR_UNSIGNED: __fallthrough;
    case WPR_HEXA:
    {
        const char *digits = (format->flags & WPRINTF_UPPER_HEX) ? "0123456789ABCDEF" : "0123456789abcdef";
        ULONGLONG num = arg->int_view;
        int base = format->type == WPR_HEXA ? 16 : 10;
        char buffer[20], *p = buffer, *dst = number;

        if (format->type == WPR_SIGNED && arg->int_view < 0)
        {
            *dst++ = '-';
            num = -arg->int_view;
        }
        if (format->flags & WPRINTF_INTPTR) num = (UINT_PTR)num;
        else if (!(format->flags & WPRINTF_I64)) num = (UINT)num;

        do
        {
            *p++ = digits[num % base];
            num /= base;
        } while (num);
        while (p > buffer) *dst++ = *(--p);
        *dst = 0;
        len = dst - number;
        break;
    }
    default:
        return 0;
    }
    if (len > maxlen) { len = maxlen; }
    if (format->precision < len) { format->precision = len; }
    if (format->precision > maxlen) { format->precision = maxlen; }
    if ((format->flags & WPRINTF_ZEROPAD) && (format->width > format->precision)) { format->precision = format->width; }
    if (format->flags & WPRINTF_PREFIX_HEX) { len += 2; }
    return len;
}


/***********************************************************************
 *           wvsnprintfA   (internal)
 */
static INT InternalwvsnprintfA(uc_engine* uc, LPSTR buffer, UINT maxlen, LPCSTR spec, va_list args)
{
    WPRINTF_FORMAT format;
    LPSTR p = buffer;
    UINT i, len, sign;
    CHAR number[21]; /* 64bit number can be 18446744073709551616 which is 20 chars. and a \0 */
    WPRINTF_DATA argData;

    //TRACE("%p %u %s\n", buffer, maxlen, debugstr_a(spec));

    while (*spec && (maxlen > 1))
    {
        if (*spec != '%') { *p++ = *spec++; maxlen--; continue; }
        spec++;
        if (*spec == '%') { *p++ = *spec++; maxlen--; continue; }
        spec += WPRINTF_ParseFormatA(uc, spec, &format);

        switch(format.type)
        {
        case WPR_WCHAR:
        {
            crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.wchar_view, sizeof(int));
            //argData.wchar_view = (WCHAR)va_arg(args, int);
            break;
        }
        case WPR_CHAR:
        {
            crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.char_view, sizeof(int));
            //argData.char_view = (CHAR)va_arg(args, int);
            break;
        }
        case WPR_STRING:
        {
            crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.lpcstr_view, sizeof(LPCSTR));
            //argData.lpcstr_view = va_arg(args, LPCSTR);
            break;
        }
        case WPR_WSTRING:
        {
            crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.lpcwstr_view, sizeof(LPCWSTR));
            //argData.lpcwstr_view = va_arg(args, LPCWSTR);
            break;
        }
        case WPR_HEXA: __fallthrough;
        case WPR_SIGNED: __fallthrough;
        case WPR_UNSIGNED:
        {
            if (format.flags & WPRINTF_INTPTR)
            { 
                crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.int_view, sizeof(INT_PTR));
                //argData.int_view = va_arg(args, INT_PTR);
            }
            else if (format.flags & WPRINTF_I64)
            { 
                crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.int_view, sizeof(LONGLONG));
                //argData.int_view = va_arg(args, LONGLONG); 
            }
            else 
            { 
                crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.int_view, sizeof(INT));
                //argData.int_view = va_arg(args, INT);
            }
            break;
        }
        default:
        {
            argData.wchar_view = 0;
            break;
        }
        }

        len = WPRINTF_GetLen(uc, &format, &argData, number, maxlen - 1, FALSE );
        sign = 0;
        if (!(format.flags & WPRINTF_LEFTALIGN))
        {
            for (i = format.precision; i < format.width; i++, maxlen--)
            {
                *p++ = ' ';
            }
        }
        switch(format.type)
        {
        case WPR_WCHAR:
        {
            CHAR mb[5];
            if (WideCharToMultiByte(CP_ACP, 0, &argData.wchar_view, 1, mb, sizeof(mb), NULL, NULL))
            {
                memcpy(p, mb, len);
                p += len;
            }
            break;
        }
        case WPR_CHAR:
        {
            *p++ = argData.char_view;
            break;
        }
        case WPR_STRING:
        {
            memcpy(p, argData.lpcstr_view, len);
            p += len;
            break;
        }
        case WPR_WSTRING:
        {
            LPCWSTR ptr = argData.lpcwstr_view;
            for (i = 0; i < len; ptr++)
            {
                CHAR mb[5]; /* 5 is MB_LEN_MAX */
                int ret = WideCharToMultiByte(CP_ACP, 0, ptr, 1, mb, sizeof(mb), NULL, NULL);
                if (ret > len - i) ret = len - i;
                i += ret;
                memcpy(p, mb, ret);
                p += ret;
            }
            break;
        }
        case WPR_HEXA:
        {
            if ((format.flags & WPRINTF_PREFIX_HEX) && (maxlen > 3))
            {
                *p++ = '0';
                *p++ = (format.flags & WPRINTF_UPPER_HEX) ? 'X' : 'x';
                maxlen -= 2;
                len -= 2;
            }
            __fallthrough;/* fall through */
        }
        case WPR_SIGNED:
        {
            /* Transfer the sign now, just in case it will be zero-padded*/
            if (number[0] == '-')
            {
                *p++ = '-';
                sign = 1;
            }
            __fallthrough;/* fall through */
        }
        case WPR_UNSIGNED:
        {
            for (i = len; i < format.precision; i++, maxlen--)
            {
                *p++ = '0';
            }
            memcpy(p, number + sign, len - sign);
            p += len - sign;
            break;
        }
        case WPR_UNKNOWN: { continue; }
        }
        if (format.flags & WPRINTF_LEFTALIGN)
        {
            for (i = format.precision; i < format.width; i++, maxlen--)
            {
                *p++ = ' ';
            }
        }
        maxlen -= len;
    }
    *p = 0;
    //TRACE("%s\n",debugstr_a(buffer));

    return (maxlen > 1) ? (INT)(p - buffer) : -1;
}


/***********************************************************************
 *           wvsnprintfW   (internal)
 */
static INT InternalwvsnprintfW(uc_engine* uc, LPWSTR buffer, UINT maxlen, LPCWSTR spec, va_list args)
{
    WPRINTF_FORMAT format;
    LPWSTR p = buffer;
    UINT i, len, sign;
    CHAR number[21]; /* 64bit number can be 18446744073709551616 which is 20 chars. and a \0 */
    WPRINTF_DATA argData;

    //TRACE("%p %u %s\n", buffer, maxlen, debugstr_w(spec));

    while (*spec && (maxlen > 1))
    {
        if (*spec != '%') { *p++ = *spec++; maxlen--; continue; }
        spec++;
        if (*spec == '%') { *p++ = *spec++; maxlen--; continue; }
        spec += WPRINTF_ParseFormatW(uc, spec, &format);

        switch(format.type)
        {
        case WPR_WCHAR:
        {
            crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.wchar_view, sizeof(int));
            //argData.wchar_view = (WCHAR)va_arg(args, int);
            break;
        }
        case WPR_CHAR:
        {
            crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.char_view, sizeof(int));
            //argData.char_view = (CHAR)va_arg(args, int);
            break;
        }
        case WPR_STRING:
        {
            crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.lpcstr_view, sizeof(LPCSTR));
            //argData.lpcstr_view = va_arg(args, LPCSTR);
            break;
        }
        case WPR_WSTRING:
        {
            crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.lpcwstr_view, sizeof(LPCWSTR));
            //argData.lpcwstr_view = va_arg(args, LPCWSTR);
            break;
        }
        case WPR_HEXA: __fallthrough;
        case WPR_SIGNED: __fallthrough;
        case WPR_UNSIGNED:
        {
            if (format.flags & WPRINTF_INTPTR) 
            { 
                crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.int_view, sizeof(INT_PTR));
                //argData.int_view = va_arg(args, INT_PTR);
            }
            else if (format.flags & WPRINTF_I64)
            { 
                crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.int_view, sizeof(LONGLONG));
                //argData.int_view = va_arg(args, LONGLONG); 
            }
            else 
            { 
                crt_va_arg_func(uc, (PDWORD_PTR)&args, &argData.int_view, sizeof(INT));
                //argData.int_view = va_arg(args, INT);
            }
            break;
        }
        default:
        {
            argData.wchar_view = 0;
            break;
        }
        }

        len = WPRINTF_GetLen(uc, &format, &argData, number, maxlen - 1, TRUE);
        sign = 0;
        if (!(format.flags & WPRINTF_LEFTALIGN))
        {
            for (i = format.precision; i < format.width; i++, maxlen--)
            {
                *p++ = ' ';
            }
        }

        switch (format.type)
        {
        case WPR_WCHAR:
        {
            *p++ = argData.wchar_view;
            break;
        }
        case WPR_CHAR:
        {
            WCHAR wc;
            if (!IsDBCSLeadByte((BYTE)argData.char_view) &&
                MultiByteToWideChar(CP_ACP, 0, &argData.char_view, 1, &wc, 1) > 0)
            {
                *p++ = wc;
            }
            else
            {
                *p++ = 0;
            }
            break;
        }
        case WPR_STRING:
        {
            LPCSTR ptr = argData.lpcstr_view;
            for (i = 0; i < len; i++)
            {
                WCHAR buf[2]; /* for LeadByte + NUL case, we need 2 WCHARs. */
                int ret, mb_len = IsDBCSLeadByte(*ptr) ? 2 : 1;
                ret = MultiByteToWideChar(CP_ACP, 0, ptr, mb_len, buf, ARRAY_SIZE(buf));
                *p++ = buf[ret - 1];
                ptr += mb_len;
            }
            break;
        }
        case WPR_WSTRING:
        {
            if (len)
            {
                memcpy(p, argData.lpcwstr_view, len * sizeof(WCHAR));
            }
            p += len;
            break;
        }
        case WPR_HEXA:
        {
            if ((format.flags & WPRINTF_PREFIX_HEX) && (maxlen > 3))
            {
                *p++ = '0';
                *p++ = (format.flags & WPRINTF_UPPER_HEX) ? 'X' : 'x';
                maxlen -= 2;
                len -= 2;
            }
            __fallthrough; /* fall through */
        }
        case WPR_SIGNED:
        {
            /* Transfer the sign now, just in case it will be zero-padded*/
            if (number[0] == '-')
            {
                *p++ = '-';
                sign = 1;
            }
            __fallthrough;/* fall through */
        }
        case WPR_UNSIGNED:
        {
            for (i = len; i < format.precision; i++, maxlen--)
            {
                *p++ = '0';
            }

            for (i = sign; i < len; i++)
            {
                *p++ = (BYTE)number[i];
            }
            break;
        }
        case WPR_UNKNOWN: { continue; }
        }

        if (format.flags & WPRINTF_LEFTALIGN)
        {
            for (i = format.precision; i < format.width; i++, maxlen--)
            {
                *p++ = ' ';
            }
        }
        maxlen -= len;
    }
    *p = 0;
    //TRACE("%s\n",debugstr_w(buffer));

    return (maxlen > 1) ? (INT)(p - buffer) : -1;
}


/***********************************************************************
 *           wvsprintfA   (USER32.@)
 */
INT CustomWvsprintfA(uc_engine* uc, LPSTR buffer, LPCSTR spec, va_list args)
{
    INT res = InternalwvsnprintfA(uc, buffer, 1024, spec, args);

    return ( res == -1 ) ? 1024 : res;
}


/***********************************************************************
 *           wvsprintfW   (USER32.@)
 */
INT CustomWvsprintfW(uc_engine* uc, LPWSTR buffer, LPCWSTR spec, va_list args)
{
    INT res = InternalwvsnprintfW(uc, buffer, 1024, spec, args);

    return ( res == -1 ) ? 1024 : res;
}


/***********************************************************************
 *           wsprintfA   (USER32.@)
 */
INT CustomWsprintfA(uc_engine* uc, LPSTR buffer, LPCSTR spec, ...)
{
    va_list valist;
    INT res;

    va_start( valist, spec );
    res = InternalwvsnprintfA(uc, buffer, 1024, spec, valist);
    va_end( valist );

    return ( res == -1 ) ? 1024 : res;
}


/***********************************************************************
 *           wsprintfW   (USER32.@)
 */
INT CustomWsprintfW(uc_engine* uc, LPWSTR buffer, LPCWSTR spec, ...)
{
    va_list valist;
    INT res;

    va_start( valist, spec );
    res = InternalwvsnprintfW(uc, buffer, 1024, spec, valist);
    va_end( valist );

    return ( res == -1 ) ? 1024 : res;
}
```

`README.md`:

```md
# PeVisor
 
In the future, there will be a full-fledged library and a normal description

```

`Samples/Unprotect/CrackMe1.map`:

```map
 CrackMe1

 Timestamp is 66293104 (Wed Apr 24 19:19:16 2024)

 Preferred load address is 0000000140000000

 Start         Length     Name                   Class
 0001:00000000 000009ccH .text                   CODE
 0002:00000000 0000001aH .rdata                  DATA
 0002:000004f8 00000064H .xdata                  DATA
 0003:00000000 0030038aH .data                   DATA
 0003:00300390 00000018H .bss                    DATA
 0004:00000000 00000078H .pdata                  DATA

  Address         Publics by Value              Rva+Base               Lib:Object

 0001:00000000       ?mem_cpy@InternalFuncs@@YAPEAXPEAX0_K@Z 0000000140001000     CrackMe1.obj
 0001:000000c0       ?str_cmp@InternalFuncs@@YAHPEBD0@Z 00000001400010c0     CrackMe1.obj
 0001:00000130       ?str_len@InternalFuncs@@YA_KPEBD@Z 0000000140001130     CrackMe1.obj
 0001:00000170       ?GetIcon@ImageFromMemory@@YAPEAUHICON__@@XZ 0000000140001170     CrackMe1.obj
 0001:00000200       ?LoadBitmapFromMemory@ImageFromMemory@@YAPEAUHBITMAP__@@PEADHH@Z 0000000140001200     CrackMe1.obj
 0001:000002b0       encrypt                    00000001400012b0     CrackMe1.obj
 0001:00000340       GenerateKey                0000000140001340     CrackMe1.obj
 0001:00000370       LicenseFunction            0000000140001370     CrackMe1.obj
 0001:00000480       ?WindowProcedure@@YA_JPEAUHWND__@@I_K_J@Z 0000000140001480     CrackMe1.obj
 0001:00000600       ?WinMainCRTStartup@@YAHPEAUHINSTANCE__@@0PEA_WH@Z 0000000140001600     CrackMe1.obj
 0002:0000001a       ??_C@_07PBILKAFL@Success?$AA@ 000000014000201a     CrackMe1.obj
 0002:00000022       ??_C@_09NJCFLIIN@Try?5again?$AA@ 0000000140002022     CrackMe1.obj
 0002:0000002c       ??_C@_07DIMJBLAB@Failure?$AA@ 000000014000202c     CrackMe1.obj
 0002:00000034       ??_C@_0BJ@JMHCFCHC@Now?5you?5are?5a?5cracker?5?$DN?$CJ?$AA@ 0000000140002034     CrackMe1.obj
 0002:0000004d       ??_C@_06JPHCLLC@Error?$CB?$AA@ 000000014000204d     CrackMe1.obj
 0002:00000054       ??_C@_0BM@HAHCIOBC@Window?5Registration?5Failed?$CB?$AA@ 0000000140002054     CrackMe1.obj
 0002:00000070       ??_C@_0BI@GFGNBIPO@Window?5Creation?5Failed?$CB?$AA@ 0000000140002070     CrackMe1.obj
 0002:00000088       ??_C@_1M@PLKLLLDN@?$AAC?$AAh?$AAe?$AAc?$AAk?$AA?$AA@ 0000000140002088     CrackMe1.obj
 0002:00000094       ??_C@_19KFAJFECL@?$AAE?$AAD?$AAI?$AAT?$AA?$AA@ 0000000140002094     CrackMe1.obj
 0002:0000009e       ??_C@_1O@MOBNNEMB@?$AAB?$AAU?$AAT?$AAT?$AAO?$AAN?$AA?$AA@ 000000014000209e     CrackMe1.obj
 0002:000000ac       ??_C@_1O@ELLBDENI@?$AAS?$AAT?$AAA?$AAT?$AAI?$AAC?$AA?$AA@ 00000001400020ac     CrackMe1.obj
 0002:000000ba       ??_C@_19FBJPIBMN@?$AAK?$AAe?$AAy?$AA?3?$AA?$AA@ 00000001400020ba     CrackMe1.obj
 0002:000000c4       ??_C@_1M@NDELDCMA@?$AAN?$AAi?$AAc?$AAk?$AA?3?$AA?$AA@ 00000001400020c4     CrackMe1.obj
 0002:000000d0       ??_C@_1EC@OHAKJDOG@?$AAC?$AAr?$AAa?$AAc?$AAk?$AAM?$AAe?$AA?5?$AAC?$AAo?$AAd?$AAe?$AA?5?$AAV?$AAi?$AAr?$AAt?$AAu?$AAa?$AAl?$AAi?$AAz?$AAe?$AAr?$AA?5?$AA2?$AA?4?$AA2?$AA?4?$AA2?$AA?4?$AA0@ 00000001400020d0     CrackMe1.obj
 0002:00000110       ??_C@_11LOCGONAA@?$AA?$AA@ 0000000140002110     CrackMe1.obj
 0002:00000248       __imp_VirtualAlloc         0000000140002248     Kernel32:KERNEL32.dll
 0002:00000250       __imp_VirtualFree          0000000140002250     Kernel32:KERNEL32.dll
 0002:00000260       __imp_BeginPaint           0000000140002260     user32:USER32.dll
 0002:00000268       __imp_CreateIconFromResourceEx 0000000140002268     user32:USER32.dll
 0002:00000270       __imp_CreateWindowExW      0000000140002270     user32:USER32.dll
 0002:00000278       __imp_DefWindowProcW       0000000140002278     user32:USER32.dll
 0002:00000280       __imp_DestroyWindow        0000000140002280     user32:USER32.dll
 0002:00000288       __imp_DispatchMessageW     0000000140002288     user32:USER32.dll
 0002:00000290       __imp_EndPaint             0000000140002290     user32:USER32.dll
 0002:00000298       __imp_GetMessageW          0000000140002298     user32:USER32.dll
 0002:000002a0       __imp_GetWindowTextA       00000001400022a0     user32:USER32.dll
 0002:000002a8       __imp_LoadCursorW          00000001400022a8     user32:USER32.dll
 0002:000002b0       __imp_LookupIconIdFromDirectoryEx 00000001400022b0     user32:USER32.dll
 0002:000002b8       __imp_MessageBoxA          00000001400022b8     user32:USER32.dll
 0002:000002c0       __imp_PostQuitMessage      00000001400022c0     user32:USER32.dll
 0002:000002c8       __imp_RegisterClassW       00000001400022c8     user32:USER32.dll
 0002:000002d0       __imp_ShowWindow           00000001400022d0     user32:USER32.dll
 0002:000002d8       __imp_TranslateMessage     00000001400022d8     user32:USER32.dll
 0002:000002e0       __imp_UpdateWindow         00000001400022e0     user32:USER32.dll
 0002:000002f0       __imp_BitBlt               00000001400022f0     Gdi32:GDI32.dll
 0002:000002f8       __imp_CreateCompatibleDC   00000001400022f8     Gdi32:GDI32.dll
 0002:00000300       __imp_CreateDIBSection     0000000140002300     Gdi32:GDI32.dll
 0002:00000308       __imp_DeleteDC             0000000140002308     Gdi32:GDI32.dll
 0002:00000310       __imp_GetStockObject       0000000140002310     Gdi32:GDI32.dll
 0002:00000318       __imp_SelectObject         0000000140002318     Gdi32:GDI32.dll
 0003:00000000       ?Ico@@3PAEA                0000000140003000     CrackMe1.obj
 0003:00000300       ?BmpBackgroundImage@@3PAEA 0000000140003300     CrackMe1.obj
 0003:00300390       ?hWndNick@@3PEAUHWND__@@EA 0000000140303390     CrackMe1.obj
 0003:00300398       ?hWndKey@@3PEAUHWND__@@EA  0000000140303398     CrackMe1.obj
 0003:003003a0       ?g_hInst@@3PEAUHINSTANCE__@@EA 00000001403033a0     CrackMe1.obj

 entry point at         0001:00000600

 Static symbols


```