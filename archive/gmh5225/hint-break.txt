Project Path: arc_gmh5225_hint-break_gvecycdt

Source Tree:

```txt
arc_gmh5225_hint-break_gvecycdt
â”œâ”€â”€ LICENSE
â”œâ”€â”€ README.md
â”œâ”€â”€ images
â”‚   â””â”€â”€ sample.png
â”œâ”€â”€ papers
â”‚   â”œâ”€â”€ en.pdf
â”‚   â””â”€â”€ ru.pdf
â”œâ”€â”€ sample
â”‚   â””â”€â”€ patched.exe
â””â”€â”€ src
    â””â”€â”€ example.cpp

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 Ivan

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# ðŸ‘» Ghost in opcode

This repository contains the Proof-of-Concept and research for a 25-year-old architectural blind spot affecting modern reverse engineering tools.

[![SAMPLE X86](https://raw.githubusercontent.com/sapdragon/hint-break/refs/heads/main/images/sample.png)](https://raw.githubusercontent.com/sapdragon/hint-break/refs/heads/main/images/sample.png)

## The Blind Spot

In 1997, Intel patented (US5,701,442) a series of "Hintable NOPs". While most of these have been assigned functions or are correctly parsed, two opcodes â€” **`0F 1A`** and **`0F 1B`** â€” remain ghosts in the machine.

CPUs execute these instructions as valid, multi-byte NOPs. However, leading disassemblers like **IDA Pro, Ghidra, and Binary Ninja** fail to recognize them. They interpret valid, executable code as unknown data, breaking static analysis and creating a simple but highly effective method for anti-disassembly.

This fundamental issue has remained largely unnoticed for decades.

## How to Test

You can see the blind spot in action yourself in under a minute.

1.  Grab the pre-compiled binary: `/samples/patched.exe`.
2.  Open it in your favorite disassembler (IDA, Ghidra, etc.).
3.  Navigate to the function.
4.  Observe how the tool fails on the `0F 1A` and `0F 1B` opcodes, showing them as `db 0Fh, 1Ah...`, `undefined`, or `???`, effectively halting the analysis of the function.
5.  Run `patched.exe`. It will execute flawlessly and print a success message, proving the instructions are valid.

## Repository Structure

-   `/src/`: The C++ source code used to generate the test binary.
-   `/samples/`
    -   `patched.exe`: The pre-compiled 64-bit PoC binary.
-   `/papers/`:
    -   `ru.pdf`: The full research paper (Russian).
    -   `en.pdf`: The full research paper (English).

## LICENSE
MIT

```

`src/example.cpp`:

```cpp
#include <iostream>
#include <array>
#include <windows.h>

int main () {
    std::array <uint8_t, 11> shell = { 0x0F, 0x1A, 0x24, 0x4C, 0x30, 0xC0, 0x0F, 0x1B, 0x24, 0x4C, 0xC3 };

    auto mem = VirtualAlloc(0, 0x1000, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    std::memcpy(mem, shell.data(), shell.size());

    using fn = int (__fastcall*)();
    fn func = reinterpret_cast<fn>(mem);
    func ();

    return 0;
}
```