Project Path: arc_gmh5225_LockFile-Poc_ii5ywxd7

Source Tree:

```txt
arc_gmh5225_LockFile-Poc_ii5ywxd7
├── Bug_in_NtLockFile.txt
├── IopXxxControlFile.png
├── NT_Api_poc.cpp
├── NT_poc.log
├── NtLockFile.png
├── win32_api_poc(new pool).cpp
├── win32_api_poc(new pool).log
├── win32_api_poc.cpp
└── win32_poc.log

```

`Bug_in_NtLockFile.txt`:

```txt
NTSTATUS NtLockFile(... PVOID ApcContext ...)
{
	PFILE_OBJECT FileObject;

	// code after FastIoLock return TRUE - look NtLockFile.png

	PIO_COMPLETION_CONTEXT CompletionContext = FileObject->CompletionContext;

	if (CompletionContext &&
	    ApcContext &&
	    !(FileObject->Flags & FO_SKIP_COMPLETION_PORT))
	{
		if (0 > IoSetIoCompletionEx2( CompletionContext->Port,
			CompletionContext->Key,
			ApcContext,
			status, // not checked for NT_ERROR !!!
			Information,
			...)) status = STATUS_INSUFFICIENT_RESOURCES;
	}

        return status;
}

if FastIoLock return TRUE (which only mean that I/O complete) the I/O manager try post entry to IOCP (via IoSetIoCompletionEx2)
without looking for status returned by FastIoLock 
as result possible situation, when NtLockFile return NT_ERROR status (say STATUS_LOCK_NOT_GRANTED or STATUS_INVALID_PARAMETER)
but will be IOCP entry anyway

------------------------------------------------------------------
// for compare - look fixed in win 8 IopXxxControlFile code

NTSTATUS IopXxxControlFile(... PVOID ApcContext ...)
{
	PFILE_OBJECT FileObject;

	NTSTATUS status;
	PVOID Port = 0, Key = 0;

	// code after FastIoDeviceControl - look IopXxxControlFile.png

	PIO_COMPLETION_CONTEXT CompletionContext = FileObject->CompletionContext;

	if (
		CompletionContext && 
		(!(FileObject->Flags & FO_SKIP_COMPLETION_PORT) || NT_WARNING(status)) &&
		!NT_ERROR(status) // <------------ checked !!!
		)
	{
		Port = CompletionContext->Port, Key = CompletionContext->Key;
	}

	if (Port && ApcContext)
	{
		if (0 > IoSetIoCompletionEx2( Port, Key, ApcContext,status, Information,...)) status = STATUS_INSUFFICIENT_RESOURCES;

		if (NT_WARNING(status)) status = STATUS_PENDING;
	}

	return status;
}

so if FastIoDeviceControl return NT_ERROR(status) - will be no IOCP entry
or if IoSetIoCompletionEx2 fail - final status replaced to STATUS_INSUFFICIENT_RESOURCES, which is NT_ERROR

so

if api return NT_ERROR(status) - will be no IOCP entry

otherwise

if FastIoDeviceControl return NT_WARNING(status) - will IOCP entry and final status STATUS_PENDING

so

if api return STATUS_PENDING - always will be IOCP entry (even if FO_SKIP_COMPLETION_PORT set on file) 

otherwise

result := !(FileObject->Flags & FO_SKIP_COMPLETION_PORT)

so code inside IopXxxControlFile (begin from windows 8.1 or 8) conformed to common logic

// status - returned by asynchronous api call (i.e. NtXxx(HANDLE FileHandle,HANDLE Event,PIO_APC_ROUTINE ApcRoutine,PVOID ApcContext,IO_STATUS_BLOCK IoStatusBlock,..)
// bSkipOnSuccess = FileObject->Flags & FO_SKIP_COMPLETION_PORT - i.e - are we set FILE_SKIP_COMPLETION_PORT_ON_SUCCESS on file
// of course FileObject->CompletionContext must be not 0 and we must pass no zero ApcContext to api call

bool Will_be_IOCP_Notification(NTSTATUS status, BOOLEAN bSkipOnSuccess = FALSE)
{
	return !NT_ERROR(status) && (status == STATUS_PENDING || !bSkipOnSuccess);
}

or if want

!NT_ERROR(status) && (status == STATUS_PENDING || !bSkipOnSuccess) ->

(!NT_ERROR(status) && status == STATUS_PENDING) || (!NT_ERROR(status) && !bSkipOnSuccess) ->

status == STATUS_PENDING) || (!NT_ERROR(status) && !bSkipOnSuccess) ->

bool Will_be_IOCP_Notification(NTSTATUS status, BOOLEAN bSkipOnSuccess = FALSE)
{
	return status == STATUS_PENDING || (!NT_ERROR(status) && !bSkipOnSuccess);
}


(in win7 still exist bug in IopXxxControlFile)
```

`NT_Api_poc.cpp`:

```cpp
#include "stdafx.h"

extern "C"
NTSYSCALLAPI
NTSTATUS
NTAPI
NtCancelIoFile(
			   _In_ HANDLE FileHandle,
			   _Out_ PIO_STATUS_BLOCK IoStatusBlock
			   );

#if 1 //1 //0
#define UM_IRP_ UM_IRP_WRONG
#else
#define UM_IRP_ UM_IRP_OK
#endif

class UM_IRP;

class __declspec(novtable) IoFile
{
	friend UM_IRP;
protected:
	HANDLE _hFile;
private:
	LONG _dwRefCount;

protected:

	virtual void IoCompletion(ULONG opCode, NTSTATUS status, ULONG_PTR dwNumberOfBytesTransfered, PVOID Pointer) = 0;

	virtual ~IoFile()
	{
		if (_hFile) NtClose(_hFile);
	}

	IoFile() : _dwRefCount(1), _hFile(0)
	{ 
	}

public:
	void AddRef()
	{
		InterlockedIncrementNoFence(&_dwRefCount);
	}

	void Release()
	{
		if (!InterlockedDecrement(&_dwRefCount)) delete this;
	}
};

class __declspec(novtable) UM_IRP : public IO_STATUS_BLOCK
{
	IoFile* pObj;
	PVOID Pointer;
	ULONG opCode;

	VOID IoCompletion(NTSTATUS status, ULONG_PTR dwNumberOfBytesTransfered)
	{
		DbgPrint("%x>%s<%p>(%x, %p)\n", GetCurrentThreadId(), __FUNCTION__, this, status, dwNumberOfBytesTransfered);
		pObj->IoCompletion(opCode, status, dwNumberOfBytesTransfered, Pointer);
		DeleteOrReleaseSelf();
	}

	static VOID WINAPI IoCompletionNT(
		_In_    NTSTATUS status,
		_In_    ULONG_PTR dwNumberOfBytesTransfered,
		_Inout_ PVOID ApcContext
		)
	{
		DbgPrint("%x> !! %s<%p>(%x, %p)\n", GetCurrentThreadId(), __FUNCTION__, ApcContext, status, dwNumberOfBytesTransfered);
		reinterpret_cast<UM_IRP*>(ApcContext)->IoCompletion(status, dwNumberOfBytesTransfered);
	}

protected:

	virtual ~UM_IRP()
	{
		pObj->Release();
		DbgPrint("%x>%s<%p>\n", GetCurrentThreadId(), __FUNCTION__, this);
	}

	virtual void DeleteOrReleaseSelf() = 0;
	virtual bool IsWillBeNotification(NTSTATUS status, BOOL bSkipOnSynchronous) = 0;

	UM_IRP(IoFile* pObj, ULONG opCode, PVOID Pointer = 0) : pObj(pObj), opCode(opCode), Pointer(Pointer)
	{
		pObj->AddRef();
		Status = STATUS_PENDING, Information = 0;
		DbgPrint("%x>%s<%p>\n", GetCurrentThreadId(), __FUNCTION__, this);
	}

public:

	void CheckError(NTSTATUS status, BOOL bSkipOnSynchronous)
	{
		if (!IsWillBeNotification(status, bSkipOnSynchronous))
		{
			IoCompletion(status, Information);
		}
	}

	static NTSTATUS BindIoCompletionCallback (HANDLE FileHandle)
	{
		return RtlSetIoCompletionCallback(FileHandle, IoCompletionNT, 0);
	}
};

class UM_IRP_OK : public UM_IRP
{
	LONG dwRefCount;

	void Release()
	{
		if (!InterlockedDecrement(&dwRefCount)) delete this;
	}

	virtual void DeleteOrReleaseSelf()
	{
		Release();
	}

	virtual bool IsWillBeNotification(NTSTATUS status, BOOL bSkipOnSynchronous)
	{
		bool b = (status == STATUS_PENDING || (Status != STATUS_PENDING && !bSkipOnSynchronous));

		Release();

		return b;
	}

public:
	UM_IRP_OK(IoFile* pObj, ULONG opCode, PVOID Pointer = 0) : UM_IRP(pObj, opCode, Pointer), dwRefCount(2)
	{
	}
};

class UM_IRP_WRONG : public UM_IRP
{
	virtual void DeleteOrReleaseSelf()
	{
		delete this;
	}

	virtual bool IsWillBeNotification(NTSTATUS status, BOOL bSkipOnSynchronous)
	{
		return (status == STATUS_PENDING) || (!NT_ERROR(status) && !bSkipOnSynchronous);
	}
public:
	UM_IRP_WRONG(IoFile* pObj, ULONG opCode, PVOID Pointer = 0) : UM_IRP(pObj, opCode, Pointer)
	{
	}
};

class LockTestFile : public IoFile
{
public:
	struct IO_RESULT 
	{
		NTSTATUS status;
		ULONG dwThreadId, opCode;
	};
private:
	virtual ~LockTestFile()
	{
		DbgPrint("%x>%s<%p>\n", GetCurrentThreadId(), __FUNCTION__, this);
	}

	virtual void IoCompletion(ULONG opCode, NTSTATUS status, ULONG_PTR /*dwNumberOfBytesTransfered*/, PVOID Pointer)
	{
		IO_RESULT* pio = (IO_RESULT*)Pointer;
		pio->status = status;
		pio->opCode = opCode;
		PostThreadMessageW(pio->dwThreadId, WM_QUIT, 0, 0);
	}
public:
	enum { opLock = 'kcol', opUnlock = 'klnu' };

	NTSTATUS Open(POBJECT_ATTRIBUTES poa)
	{
		HANDLE hFile;
		IO_STATUS_BLOCK iosb;

		NTSTATUS status = NtOpenFile(&hFile, FILE_WRITE_DATA, poa, &iosb, FILE_SHARE_VALID_FLAGS, FILE_NON_DIRECTORY_FILE);

		if (0 <= status)
		{
			_hFile = hFile;

			status = UM_IRP::BindIoCompletionCallback(hFile);
		}

		return status;
	}

	void Init(IO_RESULT* pio)
	{
		pio->dwThreadId = GetCurrentThreadId();
		pio->status = STATUS_PENDING;
	}

	bool Lock(IO_RESULT* pio, bool bSkipOnSynchronous)
	{
		if (UM_IRP_* Irp = new UM_IRP_(this, opLock, pio))
		{
			Init(pio);

			LARGE_INTEGER ByteOffset {}, Length {1};
			// try also with FailImmediately = FALSE for compare, here no error even with UM_IRP_WRONG
			Irp->CheckError(
				NtLockFile(_hFile, 0, 0, Irp, Irp, &ByteOffset, &Length, 'keyX', TRUE, TRUE), bSkipOnSynchronous);

			return true;
		}

		return false;
	}

	NTSTATUS Unlock()
	{
		IO_STATUS_BLOCK iosb;
		LARGE_INTEGER ByteOffset {}, Length {1};
		return NtUnlockFile(_hFile, &iosb, &ByteOffset, &Length, 'keyX');
	}

	NTSTATUS CancelIo()
	{
		IO_STATUS_BLOCK iosb;
		return NtCancelIoFile(_hFile, &iosb);
	}

	LockTestFile()
	{
		DbgPrint("%x>%s<%p>\n", GetCurrentThreadId(), __FUNCTION__, this);
	}
};

ULONG WINAPI TestLockThread(LockTestFile* pObj)
{
	WCHAR caption[64];
	swprintf_s(caption, L"[%x]", GetCurrentThreadId());

	//MessageBoxW(0, L"Before Test", caption, MB_OK);

	LockTestFile::IO_RESULT ior;

	pObj->Lock(&ior, false);

	MessageBoxW(0, L"Waiting For Lock...", caption, MB_OK);

	MSG msg;

	if (ior.status == STATUS_PENDING)
	{
		if (0 > pObj->CancelIo()) __debugbreak();

		while (GetMessageW(&msg, 0, 0, 0)) continue;

		if (ior.status == STATUS_PENDING) __debugbreak();
	}

	if (0 > ior.status)
	{
		PWSTR psz;
		if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_HMODULE, GetModuleHandle(L"ntdll"), ior.status, 
			MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),(PWSTR)&psz, 0, NULL))
		{
			DbgPrint("%x> %S\n", GetCurrentThreadId(), psz);
			while (PeekMessageW(&msg, 0, 0, 0, PM_REMOVE)) continue;//for remove WM_QUIT
			MessageBoxW(0, psz, caption, MB_ICONWARNING);
			LocalFree(psz);
		}
	}
	else
	{
		switch (ior.opCode)
		{
		case LockTestFile::opLock:

			while (PeekMessageW(&msg, 0, 0, 0, PM_REMOVE)) continue;//for remove WM_QUIT

			MessageBoxW(0, L"Lock Held!", caption, MB_OK);

			DbgPrint("\n======== unlock ======\n");
			if (0 > pObj->Unlock()) __debugbreak();
		}
	}

	pObj->Release();

	return 0;
}

void LockPOC(POBJECT_ATTRIBUTES poa)
{
	if (LockTestFile* pObj = new LockTestFile)
	{
		if (!pObj->Open(poa))
		{
			int n = 2;
			do 
			{
				pObj->AddRef();
				if (HANDLE hThread = CreateThread(0, 0, (PTHREAD_START_ROUTINE)TestLockThread, pObj, 0, 0))
				{
					CloseHandle(hThread);
				}
				else
				{
					pObj->Release();
				}
			} while (--n);
		}
		pObj->Release();
	}

	MessageBoxW(0, 0, L"POC", MB_OK);
}

```

`NT_poc.log`:

```log
//////////////////////////////////////////////////////////////////////////////////////
// with UM_IRP_OK and FailImmediately = TRUE:

1b00>NT::LockTestFile::LockTestFile<000002992A60F4D0>
16a0>NT::UM_IRP::UM_IRP<000002992A605310>
15a4>NT::UM_IRP::UM_IRP<000002992A64D490>
488> !! NT::UM_IRP::IoCompletionNT<000002992A64D490>(c0000055, 0000000000000000)
488>NT::UM_IRP::IoCompletion<000002992A64D490>(c0000055, 0000000000000000)
1628> !! NT::UM_IRP::IoCompletionNT<000002992A605310>(0, 0000000000000000)
1628>NT::UM_IRP::IoCompletion<000002992A605310>(0, 0000000000000000)
488>NT::UM_IRP::~UM_IRP<000002992A64D490>
1628>NT::UM_IRP::~UM_IRP<000002992A605310>
15a4> A requested file lock cannot be granted due to other existing locks.

The thread 'Win64 Thread' (0x15a4) has exited with code 0 (0x0).

======== unlock ======
16a0>NT::LockTestFile::~LockTestFile<000002992A60F4D0>
The thread 'Win64 Thread' (0x16a0) has exited with code 0 (0x0).


//////////////////////////////////////////////////////////////////////////////////////
// with UM_IRP_WRONG and FailImmediately = TRUE: - main POC case

b8c>NT::LockTestFile::LockTestFile<00000145C6FE2DF0>
1528>NT::UM_IRP::UM_IRP<00000145C701D460>
384>NT::UM_IRP::UM_IRP<00000145C701C940>
384>NT::UM_IRP::IoCompletion<00000145C701C940>(c0000055, 0000000000000000)
33c> !! NT::UM_IRP::IoCompletionNT<00000145C701C940>(c0000055, 0000000000000000)
384>NT::UM_IRP::~UM_IRP<00000145C701C940>
33c>NT::UM_IRP::IoCompletion<00000145C701C940>(c0000055, 0000000000000000)
First-chance exception at 0x00007ff6ddd8503c in poc.exe: 0xC0000005: Access violation reading location 0xffffffffffffffff.
1598> !! NT::UM_IRP::IoCompletionNT<00000145C701D460>(0, 0000000000000000)
1598>NT::UM_IRP::IoCompletion<00000145C701D460>(0, 0000000000000000)
Unhandled exception at 0x00007ff6ddd8503c in poc.exe: 0xC0000005: Access violation reading location 0xffffffffffffffff.

crash because double-free of UM_IRP_WRONG - after got c0000055 i assume that will be no IOCP packet and free UM_IRP_WRONG
but really - will be IOCP packet and callback called, where also free UM_IRP_WRONG


------------------------- not for POC, just for demo, here no different with UM_IRP_WRONG or UM_IRP_OK, if FailImmediately = FALSE -----------------

//////////////////////////////////////////////////////////////////////////////////////
// with UM_IRP_WRONG or UM_IRP_OK and FailImmediately = FALSE, wait for lock not canceled:

e68>NT::LockTestFile::LockTestFile<000001EFF1306D00>
171c>NT::UM_IRP::UM_IRP<000001EFF134D380>
f0c>NT::UM_IRP::UM_IRP<000001EFF134DF60>
10cc> !! NT::UM_IRP::IoCompletionNT<000001EFF134D380>(0, 0000000000000000)
10cc>NT::UM_IRP::IoCompletion<000001EFF134D380>(0, 0000000000000000)
10cc>NT::UM_IRP::~UM_IRP<000001EFF134D380>

======== unlock ======
10cc> !! NT::UM_IRP::IoCompletionNT<000001EFF134DF60>(0, FFFF830992CBC450)
10cc>NT::UM_IRP::IoCompletion<000001EFF134DF60>(0, FFFF830992CBC450)
10cc>NT::UM_IRP::~UM_IRP<000001EFF134DF60>
The thread 'Win64 Thread' (0x171c) has exited with code 0 (0x0).

======== unlock ======
f0c>NT::LockTestFile::~LockTestFile<000001EFF1306D00>
The thread 'Win64 Thread' (0xf0c) has exited with code 0 (0x0).


//////////////////////////////////////////////////////////////////////////////////////
// with UM_IRP_WRONG or UM_IRP_OK and FailImmediately = FALSE, wait for lock not canceled:


1690>NT::LockTestFile::LockTestFile<000002610F052E00>
1950>NT::UM_IRP::UM_IRP<000002610F08D470>
15e4>NT::UM_IRP::UM_IRP<000002610F08E050>
8d8> !! NT::UM_IRP::IoCompletionNT<000002610F08D470>(0, 0000000000000000)
8d8>NT::UM_IRP::IoCompletion<000002610F08D470>(0, 0000000000000000)
8d8>NT::UM_IRP::~UM_IRP<000002610F08D470>
8d8> !! NT::UM_IRP::IoCompletionNT<000002610F08E050>(c0000120, 0000000000000000)
8d8>NT::UM_IRP::IoCompletion<000002610F08E050>(c0000120, 0000000000000000)
8d8>NT::UM_IRP::~UM_IRP<000002610F08E050>
15e4> The I/O request was canceled.

The thread 'Win64 Thread' (0x15e4) has exited with code 0 (0x0).

======== unlock ======
1950>NT::LockTestFile::~LockTestFile<000002610F052E00>
The thread 'Win64 Thread' (0x1950) has exited with code 0 (0x0).


```

`win32_api_poc(new pool).cpp`:

```cpp
#include "stdafx.h"

extern "C"
{
	NTSYSAPI ULONG __cdecl DbgPrint (PCSTR Format, ...);
}

#if 1 //1 //0
#define UM_IRP_ UM_IRP_WRONG
#else
#define UM_IRP_ UM_IRP_OK
#endif

class UM_IRP;

class __declspec(novtable) IoFile
{
	friend UM_IRP;
protected:
	HANDLE _hFile;
	PTP_IO _pio;
private:
	LONG _dwRefCount;

protected:

	virtual void IoCompletion(ULONG opCode, DWORD dwErrorCode, ULONG_PTR dwNumberOfBytesTransfered, PVOID Pointer) = 0;

	virtual ~IoFile()
	{
		if (_pio) CloseThreadpoolIo(_pio);
		if (_hFile) CloseHandle(_hFile);
	}

	IoFile() : _dwRefCount(1), _hFile(0), _pio(0)
	{ 
	}

	void CheckError(UM_IRP* irp, BOOL fOk, BOOL bSkipOnSynchronous);

public:
	void AddRef()
	{
		InterlockedIncrementNoFence(&_dwRefCount);
	}

	void Release()
	{
		if (!InterlockedDecrement(&_dwRefCount)) delete this;
	}
};

class __declspec(novtable) UM_IRP : public OVERLAPPED
{
	PVOID Pointer;
	ULONG opCode;

	VOID IoCompletionWin32(IoFile* pObj, ULONG dwErrorCode, ULONG_PTR dwNumberOfBytesTransfered)
	{
		DbgPrint("%x>%s<%p>(%x, %p)\n", GetCurrentThreadId(), __FUNCTION__, this, dwErrorCode, dwNumberOfBytesTransfered);
		pObj->IoCompletion(opCode, dwErrorCode, dwNumberOfBytesTransfered, Pointer);
		pObj->Release();
		DeleteOrReleaseSelf();
	}

protected:

	virtual ~UM_IRP()
	{
		DbgPrint("%x>%s<%p>\n", GetCurrentThreadId(), __FUNCTION__, this);
	}

	virtual void DeleteOrReleaseSelf() = 0;
	virtual bool IsWillBeNotification(ULONG dwErrorCode, BOOL bSkipOnSynchronous) = 0;

	UM_IRP(ULONG opCode, PVOID Pointer = 0) : opCode(opCode), Pointer(Pointer)
	{
		// Status = STATUS_PENDING, Information = 0;
		Internal = STATUS_PENDING, InternalHigh = 0;
		hEvent = 0, Offset = 0, OffsetHigh = 0;
		DbgPrint("%x>%s<%p>\n", GetCurrentThreadId(), __FUNCTION__, this);
	}

public:

	void CheckError(PTP_IO pio, IoFile* pObj, ULONG dwErrorCode, BOOL bSkipOnSynchronous)
	{
		if (!IsWillBeNotification(dwErrorCode, bSkipOnSynchronous))
		{
			IoCompletionWin32(pObj, dwErrorCode, InternalHigh);
			CancelThreadpoolIo(pio);
		}
	}

	static VOID CALLBACK IoCompletionCallback(
		__inout      PTP_CALLBACK_INSTANCE /*Instance*/,
		__inout_opt  PVOID Context,
		__inout_opt  PVOID Overlapped,
		__in         ULONG IoResult,
		__in         ULONG_PTR NumberOfBytesTransferred,
		__inout      PTP_IO /*Io*/
		)
	{
		DbgPrint("%x> !! %s<%p>(%x, %p)\n", GetCurrentThreadId(), __FUNCTION__, 
			static_cast<UM_IRP*>(reinterpret_cast<OVERLAPPED*>(Overlapped)), IoResult, NumberOfBytesTransferred);

		static_cast<UM_IRP*>(reinterpret_cast<OVERLAPPED*>(Overlapped))->
			IoCompletionWin32(reinterpret_cast<IoFile*>(Context), IoResult, NumberOfBytesTransferred);
	}
};

void IoFile::CheckError(UM_IRP* irp, BOOL fOk, BOOL bSkipOnSynchronous)
{
	irp->CheckError(_pio, this, fOk ? NOERROR : GetLastError(), bSkipOnSynchronous);
}

class UM_IRP_OK : public UM_IRP
{
	LONG dwRefCount;

	void Release()
	{
		if (!InterlockedDecrement(&dwRefCount)) delete this;
	}

	virtual void DeleteOrReleaseSelf()
	{
		Release();
	}

	virtual bool IsWillBeNotification(ULONG dwErrorCode, BOOL bSkipOnSynchronous)
	{
		bool b = (dwErrorCode == ERROR_IO_PENDING || (Internal != STATUS_PENDING && !bSkipOnSynchronous));

		Release();

		return b;
	}

public:
	UM_IRP_OK(ULONG opCode, PVOID Pointer = 0) : UM_IRP(opCode, Pointer), dwRefCount(2)
	{
	}
};

class UM_IRP_WRONG : public UM_IRP
{
	virtual void DeleteOrReleaseSelf()
	{
		delete this;
	}

	virtual bool IsWillBeNotification(ULONG dwErrorCode, BOOL bSkipOnSynchronous)
	{
		switch (dwErrorCode)
		{
		case ERROR_IO_PENDING:
			return true;
		case NOERROR:
			return !bSkipOnSynchronous;
		default:
			return false;
		}
	}
public:
	UM_IRP_WRONG(ULONG opCode, PVOID Pointer = 0) : UM_IRP(opCode, Pointer)
	{
	}
};

class LockTestFile : public IoFile
{
public:
	struct IO_RESULT 
	{
		ULONG dwThreadId, opCode, dwErrorCode;
	};
private:
	virtual ~LockTestFile()
	{
		DbgPrint("%x>%s<%p>\n", GetCurrentThreadId(), __FUNCTION__, this);
	}

	virtual void IoCompletion(ULONG opCode, ULONG dwErrorCode, ULONG_PTR /*dwNumberOfBytesTransfered*/, PVOID Pointer)
	{
		IO_RESULT* pio = (IO_RESULT*)Pointer;
		pio->dwErrorCode = dwErrorCode;
		pio->opCode = opCode;
		PostThreadMessageW(pio->dwThreadId, WM_QUIT, 0, 0);
	}
public:
	enum { opLock = 'kcol' };

	LockTestFile()
	{
		DbgPrint("%x>%s<%p>\n", GetCurrentThreadId(), __FUNCTION__, this);
	}

	ULONG Open(PCWSTR pszFileName)
	{
		HANDLE hFile = CreateFileW(pszFileName, FILE_WRITE_DATA, FILE_SHARE_WRITE|FILE_SHARE_READ, 
			0, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_OVERLAPPED, 0);

		if (hFile != INVALID_HANDLE_VALUE)
		{
			_hFile = hFile;

			if (_pio = CreateThreadpoolIo(hFile, UM_IRP::IoCompletionCallback, this, 0))
			{
				return NOERROR;
			}
		}

		return GetLastError();
	}

	void Init(IO_RESULT* pio)
	{
		pio->dwThreadId = GetCurrentThreadId();
		pio->dwErrorCode = ERROR_IO_PENDING;
	}

	bool Lock(IO_RESULT* pio, bool bSkipOnSynchronous)
	{
		if (UM_IRP_* lpOverlapped = new UM_IRP_(opLock, pio))
		{
			Init(pio);

			AddRef();
			StartThreadpoolIo(_pio);

			// try also with LOCKFILE_EXCLUSIVE_LOCK for compare, here no error even with UM_IRP_WRONG
			CheckError(lpOverlapped, //
				LockFileEx(_hFile, LOCKFILE_EXCLUSIVE_LOCK|LOCKFILE_FAIL_IMMEDIATELY, 0, 1, 0, lpOverlapped), 
				bSkipOnSynchronous);

			return true;
		}

		return false;
	}

	BOOL Unlock()
	{
		OVERLAPPED ov{};
		return UnlockFileEx(_hFile, 0, 1, 0, &ov);
	}

	BOOL CancelIo()
	{
		return ::CancelIo(_hFile);
	}
};

ULONG WINAPI TestLockThread(LockTestFile* pObj)
{
	WCHAR caption[64];
	swprintf_s(caption, L"[%x]", GetCurrentThreadId());

	//MessageBoxW(0, L"Before Test", caption, MB_OK);

	LockTestFile::IO_RESULT ior;

	pObj->Lock(&ior, false);

	MessageBoxW(0, L"Waiting For Lock...", caption, MB_OK);

	MSG msg;

	if (ior.dwErrorCode == ERROR_IO_PENDING)
	{
		if (!pObj->CancelIo()) __debugbreak();

		while (GetMessageW(&msg, 0, 0, 0)) continue;

		if (ior.dwErrorCode == ERROR_IO_PENDING) __debugbreak();
	}

	if (ior.dwErrorCode != NOERROR)
	{
		PWSTR psz;
		if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_SYSTEM, 0, ior.dwErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			(PWSTR)&psz, 0, NULL))
		{
			DbgPrint("%x> %S\n", GetCurrentThreadId(), psz);
			while (PeekMessageW(&msg, 0, 0, 0, PM_REMOVE)) continue;//for remove WM_QUIT
			MessageBoxW(0, psz, caption, MB_ICONWARNING);
			LocalFree(psz);
		}
	}
	else
	{
		switch (ior.opCode)
		{
		case LockTestFile::opLock:

			while (PeekMessageW(&msg, 0, 0, 0, PM_REMOVE)) continue;//for remove WM_QUIT

			MessageBoxW(0, L"Lock Held!", caption, MB_OK);

			DbgPrint("\n======== unlock ======\n");
			if (!pObj->Unlock()) __debugbreak();
		}
	}

	pObj->Release();

	return 0;
}

void LockPOC(PCWSTR szfile)
{
	if (LockTestFile* pObj = new LockTestFile)
	{
		if (!pObj->Open(szfile))
		{
			int n = 2;
			do 
			{
				pObj->AddRef();
				if (HANDLE hThread = CreateThread(0, 0, (PTHREAD_START_ROUTINE)TestLockThread, pObj, 0, 0))
				{
					CloseHandle(hThread);
				}
				else
				{
					pObj->Release();
				}
			} while (--n);
		}
		pObj->Release();
	}

	MessageBoxW(0, 0, L"POC", MB_OK);
}

```

`win32_api_poc(new pool).log`:

```log
//////////////////////////////////////////////////////////////////////////////////////
// with UM_IRP_OK and LOCKFILE_FAIL_IMMEDIATELY:


11bc>LockTestFile::LockTestFile<000001B1B073F4F0>
b8>UM_IRP::UM_IRP<000001B1B077D380>
a90>UM_IRP::UM_IRP<000001B1B0734100>
1b80> !! UM_IRP::IoCompletionCallback<000001B1B0734100>(21, 0000000000000000)
1b80>UM_IRP::IoCompletionWin32<000001B1B0734100>(21, 0000000000000000)
a48> !! UM_IRP::IoCompletionCallback<000001B1B077D380>(0, 0000000000000000)
a48>UM_IRP::IoCompletionWin32<000001B1B077D380>(0, 0000000000000000)
1b80>UM_IRP::~UM_IRP<000001B1B0734100>
a48>UM_IRP::~UM_IRP<000001B1B077D380>
a90> The process cannot access the file because another process has locked a portion of the file.

The thread 'Win64 Thread' (0xa90) has exited with code 0 (0x0).

======== unlock ======
b8>LockTestFile::~LockTestFile<000001B1B073F4F0>
The thread 'Win64 Thread' (0xb8) has exited with code 0 (0x0).


//////////////////////////////////////////////////////////////////////////////////////
// with UM_IRP_WRONG and LOCKFILE_FAIL_IMMEDIATELY - main POC case

14f4>LockTestFile::LockTestFile<000002825367F4F0>
dd0>UM_IRP::UM_IRP<00000282536BD470>
d24>UM_IRP::UM_IRP<00000282536B41B0>
d24>UM_IRP::IoCompletionWin32<00000282536B41B0>(21, 0000000000000000)
1acc> !! UM_IRP::IoCompletionCallback<00000282536B41B0>(21, 0000000000000000)
1acc>UM_IRP::IoCompletionWin32<00000282536B41B0>(21, 0000000000000000)
d24>UM_IRP::~UM_IRP<00000282536B41B0>
First-chance exception at 0x00007ff7774350a3 in poc.exe: 0xC0000005: Access violation reading location 0xffffffffffffffff.
Unhandled exception at 0x00007ff7774350a3 in poc.exe: 0xC0000005: Access violation reading location 0xffffffffffffffff.

crash because double-free of UM_IRP_WRONG - after got 0x21 error i assume that will be no IOCP packet and free UM_IRP_WRONG
but really - will be IOCP packet and callback called, where also free UM_IRP_WRONG


------------------------- not for POC, just for demo, here no different with UM_IRP_WRONG or UM_IRP_OK, if FailImmediately = FALSE -----------------

//////////////////////////////////////////////////////////////////////////////////////
// with UM_IRP_WRONG or UM_IRP_OK and without LOCKFILE_FAIL_IMMEDIATELY, wait for lock not canceled:

618>LockTestFile::LockTestFile<000001FBCD231650>
11f0>UM_IRP::UM_IRP<000001FBCD232B50>
37c>UM_IRP::UM_IRP<000001FBCD26E0E0>
704> !! UM_IRP::IoCompletionCallback<000001FBCD232B50>(0, 0000000000000000)
704>UM_IRP::IoCompletionWin32<000001FBCD232B50>(0, 0000000000000000)
704>UM_IRP::~UM_IRP<000001FBCD232B50>

======== unlock ======
704> !! UM_IRP::IoCompletionCallback<000001FBCD26E0E0>(0, FFFF830992CBC450)
704>UM_IRP::IoCompletionWin32<000001FBCD26E0E0>(0, FFFF830992CBC450)
704>UM_IRP::~UM_IRP<000001FBCD26E0E0>
The thread 'Win64 Thread' (0x11f0) has exited with code 0 (0x0).

======== unlock ======
37c>LockTestFile::~LockTestFile<000001FBCD231650>
The thread 'Win64 Thread' (0x37c) has exited with code 0 (0x0).


//////////////////////////////////////////////////////////////////////////////////////
// with UM_IRP_WRONG or UM_IRP_OK and without LOCKFILE_FAIL_IMMEDIATELY, wait for lock canceled:


de0>LockTestFile::LockTestFile<0000014B8D9E08F0>
10bc>UM_IRP::UM_IRP<0000014B8DA1D340>
d90>UM_IRP::UM_IRP<0000014B8DA1DF20>
1ae4> !! UM_IRP::IoCompletionCallback<0000014B8DA1D340>(0, 0000000000000000)
1ae4>UM_IRP::IoCompletionWin32<0000014B8DA1D340>(0, 0000000000000000)
1ae4>UM_IRP::~UM_IRP<0000014B8DA1D340>
1ae4> !! UM_IRP::IoCompletionCallback<0000014B8DA1DF20>(3e3, 0000000000000000)
1ae4>UM_IRP::IoCompletionWin32<0000014B8DA1DF20>(3e3, 0000000000000000)
1ae4>UM_IRP::~UM_IRP<0000014B8DA1DF20>
d90> The I/O operation has been aborted because of either a thread exit or an application request.

The thread 'Win64 Thread' (0xd90) has exited with code 0 (0x0).

======== unlock ======
10bc>LockTestFile::~LockTestFile<0000014B8D9E08F0>
The thread 'Win64 Thread' (0x10bc) has exited with code 0 (0x0).


```

`win32_api_poc.cpp`:

```cpp
#include "stdafx.h"

extern "C"
{
	NTSYSAPI ULONG __cdecl DbgPrint (PCSTR Format, ...);

	NTSYSAPI ULONG NTAPI RtlNtStatusToDosError (_In_ NTSTATUS Status);
}

#if 1 //1 //0
#define UM_IRP_ UM_IRP_WRONG
#else
#define UM_IRP_ UM_IRP_OK
#endif

class UM_IRP;

class __declspec(novtable) IoFile
{
	friend UM_IRP;
protected:
	HANDLE _hFile;
private:
	LONG _dwRefCount;

protected:

	virtual void IoCompletion(ULONG opCode, DWORD dwErrorCode, ULONG_PTR dwNumberOfBytesTransfered, PVOID Pointer) = 0;

	virtual ~IoFile()
	{
		if (_hFile) CloseHandle(_hFile);
	}

	IoFile() : _dwRefCount(1), _hFile(0)
	{ 
	}

public:
	void AddRef()
	{
		InterlockedIncrementNoFence(&_dwRefCount);
	}

	void Release()
	{
		if (!InterlockedDecrement(&_dwRefCount)) delete this;
	}
};

class __declspec(novtable) UM_IRP : public OVERLAPPED
{
	IoFile* pObj;
	PVOID Pointer;
	ULONG opCode;

	VOID IoCompletionWin32(ULONG dwErrorCode, ULONG_PTR dwNumberOfBytesTransfered)
	{
		DbgPrint("%x>%s<%p>(%x, %p)\n", GetCurrentThreadId(), __FUNCTION__, this, dwErrorCode, dwNumberOfBytesTransfered);
		pObj->IoCompletion(opCode, dwErrorCode, dwNumberOfBytesTransfered, Pointer);
		DeleteOrReleaseSelf();
	}

	static VOID WINAPI IoCompletionNT(
		_In_    NTSTATUS status,
		_In_    ULONG_PTR dwNumberOfBytesTransfered,
		_Inout_ LPOVERLAPPED lpOverlapped
		)
	{
		DbgPrint("%x> !! %s<%p>(%x, %p)\n", GetCurrentThreadId(), __FUNCTION__, static_cast<UM_IRP*>(lpOverlapped), status, dwNumberOfBytesTransfered);
		static_cast<UM_IRP*>(lpOverlapped)->IoCompletionWin32(RtlNtStatusToDosError(status), dwNumberOfBytesTransfered);
	}

protected:

	virtual ~UM_IRP()
	{
		pObj->Release();
		DbgPrint("%x>%s<%p>\n", GetCurrentThreadId(), __FUNCTION__, this);
	}

	virtual void DeleteOrReleaseSelf() = 0;
	virtual bool IsWillBeNotification(ULONG dwErrorCode, BOOL bSkipOnSynchronous) = 0;

	UM_IRP(IoFile* pObj, ULONG opCode, PVOID Pointer = 0) : pObj(pObj), opCode(opCode), Pointer(Pointer)
	{
		pObj->AddRef();
		// Status = STATUS_PENDING, Information = 0;
		Internal = STATUS_PENDING, InternalHigh = 0;
		hEvent = 0, Offset = 0, OffsetHigh = 0;
		DbgPrint("%x>%s<%p>\n", GetCurrentThreadId(), __FUNCTION__, this);
	}

public:

	void CheckError(BOOL fOk, BOOL bSkipOnSynchronous)
	{
		CheckError(fOk ? NOERROR : GetLastError(), bSkipOnSynchronous);
	}

	void CheckError(ULONG dwErrorCode, BOOL bSkipOnSynchronous)
	{
		if (!IsWillBeNotification(dwErrorCode, bSkipOnSynchronous))
		{
			IoCompletionWin32(dwErrorCode, InternalHigh);
		}
	}

	static BOOL BindIoCompletionCallback (HANDLE FileHandle)
	{
		return ::BindIoCompletionCallback(FileHandle, (LPOVERLAPPED_COMPLETION_ROUTINE)IoCompletionNT, 0);
	}
};

class UM_IRP_OK : public UM_IRP
{
	LONG dwRefCount;

	void Release()
	{
		if (!InterlockedDecrement(&dwRefCount)) delete this;
	}

	virtual void DeleteOrReleaseSelf()
	{
		Release();
	}

	virtual bool IsWillBeNotification(ULONG dwErrorCode, BOOL bSkipOnSynchronous)
	{
		bool b = (dwErrorCode == ERROR_IO_PENDING || (Internal != STATUS_PENDING && !bSkipOnSynchronous));

		Release();

		return b;
	}

public:
	UM_IRP_OK(IoFile* pObj, ULONG opCode, PVOID Pointer = 0) : UM_IRP(pObj, opCode, Pointer), dwRefCount(2)
	{
	}
};

class UM_IRP_WRONG : public UM_IRP
{
	virtual void DeleteOrReleaseSelf()
	{
		delete this;
	}

	virtual bool IsWillBeNotification(ULONG dwErrorCode, BOOL bSkipOnSynchronous)
	{
		switch (dwErrorCode)
		{
		case ERROR_IO_PENDING:
			return true;
		case NOERROR:
			return !bSkipOnSynchronous;
		default:
			return false;
		}
	}
public:
	UM_IRP_WRONG(IoFile* pObj, ULONG opCode, PVOID Pointer = 0) : UM_IRP(pObj, opCode, Pointer)
	{
	}
};

class LockTestFile : public IoFile
{
public:
	struct IO_RESULT 
	{
		ULONG dwThreadId, opCode, dwErrorCode;
	};
private:
	virtual ~LockTestFile()
	{
		DbgPrint("%x>%s<%p>\n", GetCurrentThreadId(), __FUNCTION__, this);
	}

	virtual void IoCompletion(ULONG opCode, ULONG dwErrorCode, ULONG_PTR /*dwNumberOfBytesTransfered*/, PVOID Pointer)
	{
		IO_RESULT* pio = (IO_RESULT*)Pointer;
		pio->dwErrorCode = dwErrorCode;
		pio->opCode = opCode;
		PostThreadMessageW(pio->dwThreadId, WM_QUIT, 0, 0);
	}
public:
	enum { opLock = 'kcol' };

	LockTestFile()
	{
		DbgPrint("%x>%s<%p>\n", GetCurrentThreadId(), __FUNCTION__, this);
	}

	ULONG Open(PCWSTR pszFileName)
	{
		HANDLE hFile = CreateFileW(pszFileName, FILE_WRITE_DATA, FILE_SHARE_WRITE|FILE_SHARE_READ, 0, OPEN_EXISTING,
			FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_OVERLAPPED, 0);

		if (hFile != INVALID_HANDLE_VALUE)
		{
			_hFile = hFile;

			if (UM_IRP::BindIoCompletionCallback(hFile))
			{
				return NOERROR;
			}
		}

		return GetLastError();
	}

	void Init(IO_RESULT* pio)
	{
		pio->dwThreadId = GetCurrentThreadId();
		pio->dwErrorCode = ERROR_IO_PENDING;
	}

	bool Lock(IO_RESULT* pio, bool bSkipOnSynchronous)
	{
		if (UM_IRP_* lpOverlapped = new UM_IRP_(this, opLock, pio))
		{
			Init(pio);

			// try also with LOCKFILE_EXCLUSIVE_LOCK only for compare, here no error even with UM_IRP_WRONG
			lpOverlapped->CheckError(//
				LockFileEx(_hFile, LOCKFILE_EXCLUSIVE_LOCK|LOCKFILE_FAIL_IMMEDIATELY, 0, 1, 0, lpOverlapped), bSkipOnSynchronous);

			return true;
		}

		return false;
	}

	BOOL Unlock()
	{
		OVERLAPPED ov{};
		return UnlockFileEx(_hFile, 0, 1, 0, &ov);
	}

	BOOL CancelIo()
	{
		return ::CancelIo(_hFile);
	}
};

ULONG WINAPI TestLockThread(LockTestFile* pObj)
{
	WCHAR caption[64];
	swprintf_s(caption, L"[%x]", GetCurrentThreadId());

	//MessageBoxW(0, L"Before Test", caption, MB_OK);

	LockTestFile::IO_RESULT ior;

	pObj->Lock(&ior, false);

	MessageBoxW(0, L"Waiting For Lock...", caption, MB_OK);

	MSG msg;

	if (ior.dwErrorCode == ERROR_IO_PENDING)
	{
		if (!pObj->CancelIo()) __debugbreak();

		while (GetMessageW(&msg, 0, 0, 0)) continue;

		if (ior.dwErrorCode == ERROR_IO_PENDING) __debugbreak();
	}

	if (ior.dwErrorCode != NOERROR)
	{
		PWSTR psz;
		if (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS|FORMAT_MESSAGE_ALLOCATE_BUFFER |
			FORMAT_MESSAGE_FROM_SYSTEM, 0, ior.dwErrorCode, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			(PWSTR)&psz, 0, NULL))
		{
			DbgPrint("%x> %S\n", GetCurrentThreadId(), psz);
			while (PeekMessageW(&msg, 0, 0, 0, PM_REMOVE)) continue;//for remove WM_QUIT
			MessageBoxW(0, psz, caption, MB_ICONWARNING);
			LocalFree(psz);
		}
	}
	else
	{
		switch (ior.opCode)
		{
		case LockTestFile::opLock:

			while (PeekMessageW(&msg, 0, 0, 0, PM_REMOVE)) continue;//for remove WM_QUIT

			MessageBoxW(0, L"Lock Held!", caption, MB_OK);

			DbgPrint("\n======== unlock ======\n");
			if (!pObj->Unlock()) __debugbreak();
		}
	}

	pObj->Release();

	return 0;
}

void LockPOC(PCWSTR szfile)
{
	if (LockTestFile* pObj = new LockTestFile)
	{
		if (!pObj->Open(szfile))
		{
			int n = 2;
			do 
			{
				pObj->AddRef();
				if (HANDLE hThread = CreateThread(0, 0, (PTHREAD_START_ROUTINE)TestLockThread, pObj, 0, 0))
				{
					CloseHandle(hThread);
				}
				else
				{
					pObj->Release();
				}
			} while (--n);
		}
		pObj->Release();
	}

	MessageBoxW(0, 0, L"POC", MB_OK);
}

```

`win32_poc.log`:

```log
//////////////////////////////////////////////////////////////////////////////////////
// with UM_IRP_OK and LOCKFILE_FAIL_IMMEDIATELY:


708>LockTestFile::LockTestFile<000001884BCD5490>
1ba8>UM_IRP::UM_IRP<000001884BCEB310>
eb0>UM_IRP::UM_IRP<000001884BCEE0E0>
12f4> !! UM_IRP::IoCompletionNT<000001884BCEE0E0>(c0000055, 0000000000000000)
12f4>UM_IRP::IoCompletionWin32<000001884BCEE0E0>(21, 0000000000000000)
1428> !! UM_IRP::IoCompletionNT<000001884BCEB310>(0, 0000000000000000)
1428>UM_IRP::IoCompletionWin32<000001884BCEB310>(0, 0000000000000000)
12f4>UM_IRP::~UM_IRP<000001884BCEE0E0>
1428>UM_IRP::~UM_IRP<000001884BCEB310>
eb0> The process cannot access the file because another process has locked a portion of the file.

The thread 'Win64 Thread' (0xeb0) has exited with code 0 (0x0).

======== unlock ======
1ba8>LockTestFile::~LockTestFile<000001884BCD5490>
The thread 'Win64 Thread' (0x1ba8) has exited with code 0 (0x0).


//////////////////////////////////////////////////////////////////////////////////////
// with UM_IRP_WRONG and LOCKFILE_FAIL_IMMEDIATELY - main POC case

ac4>LockTestFile::LockTestFile<0000021706C3F4F0>
143c>UM_IRP::UM_IRP<0000021706C7D460>
11e4>UM_IRP::UM_IRP<0000021706C7E040>
11e4>UM_IRP::IoCompletionWin32<0000021706C7E040>(21, 0000000000000000)
1138> !! UM_IRP::IoCompletionNT<0000021706C7E040>(c0000055, 0000000000000000)
1138>UM_IRP::IoCompletionWin32<0000021706C7E040>(21, 0000000000000000)
11e4>UM_IRP::~UM_IRP<0000021706C7E040>
2b8> !! UM_IRP::IoCompletionNT<0000021706C7D460>(0, 0000000000000000)
2b8>UM_IRP::IoCompletionWin32<0000021706C7D460>(0, 0000000000000000)
First-chance exception at 0x00007ff78371507d in poc.exe: 0xC0000005: Access violation reading location 0xffffffffffffffff.
2b8>UM_IRP::~UM_IRP<0000021706C7D460>
Unhandled exception at 0x00007ff78371507d in poc.exe: 0xC0000005: Access violation reading location 0xffffffffffffffff.

crash because double-free of UM_IRP_WRONG - after got c0000055/21 i assume that will be no IOCP packet and free UM_IRP_WRONG
but really - will be IOCP packet and callback called, where also free UM_IRP_WRONG


------------------------- not for POC, just for demo, here no different with UM_IRP_WRONG or UM_IRP_OK, if FailImmediately = FALSE -----------------

//////////////////////////////////////////////////////////////////////////////////////
// with UM_IRP_WRONG or UM_IRP_OK and without LOCKFILE_FAIL_IMMEDIATELY, wait for lock not canceled:

18cc>LockTestFile::LockTestFile<0000026FDE1DE7E0>
e54>UM_IRP::UM_IRP<0000026FDE21D3F0>
ad0>UM_IRP::UM_IRP<0000026FDE208210>
5b0> !! UM_IRP::IoCompletionNT<0000026FDE21D3F0>(0, 0000000000000000)
5b0>UM_IRP::IoCompletionWin32<0000026FDE21D3F0>(0, 0000000000000000)
5b0>UM_IRP::~UM_IRP<0000026FDE21D3F0>

======== unlock ======
5b0> !! UM_IRP::IoCompletionNT<0000026FDE208210>(0, FFFF830992CBC450)
5b0>UM_IRP::IoCompletionWin32<0000026FDE208210>(0, FFFF830992CBC450)
5b0>UM_IRP::~UM_IRP<0000026FDE208210>
The thread 'Win64 Thread' (0xe54) has exited with code 0 (0x0).

======== unlock ======
ad0>LockTestFile::~LockTestFile<0000026FDE1DE7E0>
The thread 'Win64 Thread' (0xad0) has exited with code 0 (0x0).

//////////////////////////////////////////////////////////////////////////////////////
// with UM_IRP_WRONG or UM_IRP_OK and without LOCKFILE_FAIL_IMMEDIATELY, wait for lock canceled:

1574>LockTestFile::LockTestFile<000001F511DFE790>
1a5c>UM_IRP::UM_IRP<000001F511E3D510>
2cc>UM_IRP::UM_IRP<000001F511E3E0F0>
fb0> !! UM_IRP::IoCompletionNT<000001F511E3D510>(0, 0000000000000000)
fb0>UM_IRP::IoCompletionWin32<000001F511E3D510>(0, 0000000000000000)
fb0>UM_IRP::~UM_IRP<000001F511E3D510>
fb0> !! UM_IRP::IoCompletionNT<000001F511E3E0F0>(c0000120, 0000000000000000)
fb0>UM_IRP::IoCompletionWin32<000001F511E3E0F0>(3e3, 0000000000000000)
fb0>UM_IRP::~UM_IRP<000001F511E3E0F0>
2cc> The I/O operation has been aborted because of either a thread exit or an application request.

The thread 'Win64 Thread' (0x2cc) has exited with code 0 (0x0).

======== unlock ======
1a5c>LockTestFile::~LockTestFile<000001F511DFE790>
The thread 'Win64 Thread' (0x1a5c) has exited with code 0 (0x0).



```