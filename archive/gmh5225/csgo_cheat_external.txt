Project Path: arc_gmh5225_csgo_cheat_external_waxzkxhn

Source Tree:

```txt
arc_gmh5225_csgo_cheat_external_waxzkxhn
├── CSGO5E.sln
├── CSGO5E.vcxproj
├── CSGO5E.vcxproj.filters
├── CSGO5E.vcxproj.user
├── DIA2Dump.lib
├── Game.cpp
├── Game.h
├── MemTool.cpp
├── MemTool.h
├── README.md
├── Tool.cpp
├── Tool.h
├── csgo.cpp
├── driver.h
├── global.hpp
├── offsets.h
└── valve-bsp-parser.lib

```

`CSGO5E.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.2092
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "CSGO5E", "CSGO5E.vcxproj", "{B366386F-F37F-4C1C-9A76-9C3564129F81}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "valve-bsp-parser", "..\..\..\源码\csgo源码\valve-bsp-parser-legacy\valve-bsp-parser.vcxproj", "{39750587-C53C-44E3-8542-80112A0E8AB3}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{B366386F-F37F-4C1C-9A76-9C3564129F81}.Debug|x64.ActiveCfg = Debug|x64
		{B366386F-F37F-4C1C-9A76-9C3564129F81}.Debug|x64.Build.0 = Debug|x64
		{B366386F-F37F-4C1C-9A76-9C3564129F81}.Debug|x86.ActiveCfg = Debug|Win32
		{B366386F-F37F-4C1C-9A76-9C3564129F81}.Debug|x86.Build.0 = Debug|Win32
		{B366386F-F37F-4C1C-9A76-9C3564129F81}.Release|x64.ActiveCfg = Release|x64
		{B366386F-F37F-4C1C-9A76-9C3564129F81}.Release|x64.Build.0 = Release|x64
		{B366386F-F37F-4C1C-9A76-9C3564129F81}.Release|x86.ActiveCfg = Release|Win32
		{B366386F-F37F-4C1C-9A76-9C3564129F81}.Release|x86.Build.0 = Release|Win32
		{39750587-C53C-44E3-8542-80112A0E8AB3}.Debug|x64.ActiveCfg = Debug|x64
		{39750587-C53C-44E3-8542-80112A0E8AB3}.Debug|x64.Build.0 = Debug|x64
		{39750587-C53C-44E3-8542-80112A0E8AB3}.Debug|x86.ActiveCfg = Debug|Win32
		{39750587-C53C-44E3-8542-80112A0E8AB3}.Debug|x86.Build.0 = Debug|Win32
		{39750587-C53C-44E3-8542-80112A0E8AB3}.Release|x64.ActiveCfg = Release|x64
		{39750587-C53C-44E3-8542-80112A0E8AB3}.Release|x64.Build.0 = Release|x64
		{39750587-C53C-44E3-8542-80112A0E8AB3}.Release|x86.ActiveCfg = Release|Win32
		{39750587-C53C-44E3-8542-80112A0E8AB3}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {0F9960CE-04E6-4E1E-A560-739E66300134}
	EndGlobalSection
EndGlobal

```

`CSGO5E.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{b366386f-f37f-4c1c-9a76-9c3564129f81}</ProjectGuid>
    <RootNamespace>CSGO5E</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;$(VC_IncludePath);$(WindowsSDK_IncludePath);G:\源码\csgo源码\valve-bsp-parser-legacy\include;G:\源码\csgo源码\valve-bsp-parser-legacy\thirdparty\liblzma\include</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86);$(NETFXKitsDir)Lib\um\x86;G:\源码\csgo源码\valve-bsp-parser-legacy\build\Release-x86;G:\源码\csgo源码\valve-bsp-parser-legacy\thirdparty\liblzma\lib\x86;D:\VS2019\VS\VC\Tools\MSVC\14.16.27023\lib\onecore\x86;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x86</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Include;$(VC_IncludePath);$(WindowsSDK_IncludePath);G:\源码\csgo源码\valve-bsp-parser-legacy\include;G:\源码\csgo源码\valve-bsp-parser-legacy\thirdparty\liblzma\include</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x64);$(WindowsSDK_LibraryPath_x64);G:\源码\csgo源码\valve-bsp-parser-legacy\build\Release-x64;G:\源码\csgo源码\valve-bsp-parser-legacy\thirdparty\liblzma\lib\x64;D:\VS2019\VS\VC\Tools\MSVC\14.16.27023\lib\onecore\x64;C:\Program Files (x86)\Microsoft DirectX SDK (June 2010)\Lib\x64</LibraryPath>
    <ExternalIncludePath>G:\源码\csgo源码\valve-bsp-parser-legacy\include;G:\源码\csgo源码\valve-bsp-parser-legacy\thirdparty\liblzma\include;$(ExternalIncludePath)</ExternalIncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>false</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <Optimization>MinSpace</Optimization>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <LanguageStandard>stdcpp20</LanguageStandard>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>d3dx9.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;NOMINMAX;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <Optimization>Disabled</Optimization>
      <LanguageStandard>stdcpp17</LanguageStandard>
      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>
      <InlineFunctionExpansion>Default</InlineFunctionExpansion>
      <FavorSizeOrSpeed>
      </FavorSizeOrSpeed>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <EnableFiberSafeOptimizations>false</EnableFiberSafeOptimizations>
      <OmitFramePointers>
      </OmitFramePointers>
      <ExceptionHandling>Async</ExceptionHandling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>false</DataExecutionPrevention>
      <AdditionalDependencies>d3dx9.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <IgnoreAllDefaultLibraries>
      </IgnoreAllDefaultLibraries>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="csgo.cpp">
      <Optimization Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Disabled</Optimization>
    </ClCompile>
    <ClCompile Include="Game.cpp" />
    <ClCompile Include="MemTool.cpp" />
    <ClCompile Include="Tool.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h" />
    <ClInclude Include="Game.h" />
    <ClInclude Include="global.hpp" />
    <ClInclude Include="MemTool.h" />
    <ClInclude Include="offsets.h" />
    <ClInclude Include="Tool.h" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\..\..\源码\csgo源码\valve-bsp-parser-legacy\valve-bsp-parser.vcxproj">
      <Project>{39750587-c53c-44e3-8542-80112a0e8ab3}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`CSGO5E.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="csgo.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Game.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="MemTool.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
    <ClCompile Include="Tool.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="driver.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Game.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="MemTool.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="Tool.h">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="global.hpp">
      <Filter>头文件</Filter>
    </ClInclude>
    <ClInclude Include="offsets.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`CSGO5E.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`Game.cpp`:

```cpp
#include "Game.h"
#include "offsets.h"



Game::Game() {
	this->mem = new MemTool();
	this->tool = new Tool();
	this->aimScope = 120;
	this->silkyNum = 7;
	this->bp = new bsp_parser();
	this->clientBase = 0;
	this->mouseEngineBase = 0;
	this->serverBase = 0;
	this->canShoot = FALSE;
}

//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================

DWORD Thread_KeyWatch(PVOID param) {
	Game* g = (Game*)param;
	while (true)
	{
		if ((GetAsyncKeyState(VK_ADD) & 1) > 0)
		{
			g->aimScope += 20;
		}
		else if ((GetAsyncKeyState(VK_SUBTRACT) & 1) > 0)
		{
			g->aimScope -= 20;
		}
		else if ((GetAsyncKeyState(VK_NUMPAD1) & 1) > 0)
		{
			g->silkyNum = 1;
		}
		else if ((GetAsyncKeyState(VK_NUMPAD2) & 1) > 0)
		{
			g->silkyNum = 2;
		}
		else if ((GetAsyncKeyState(VK_NUMPAD3) & 1) > 0)
		{
			g->silkyNum = 3;
		}
		else if ((GetAsyncKeyState(VK_NUMPAD4) & 1) > 0)
		{
			g->silkyNum = 4;
		}
		else if ((GetAsyncKeyState(VK_NUMPAD5) & 1) > 0)
		{
			g->silkyNum = 5;
		}
		else if ((GetAsyncKeyState(VK_NUMPAD6) & 1) > 0)
		{
			g->silkyNum = 6;
		}
		else if ((GetAsyncKeyState(VK_NUMPAD7) & 1) > 0)
		{
			g->silkyNum = 7;
		}
		else if ((GetAsyncKeyState(VK_NUMPAD8) & 1) > 0)
		{
			g->silkyNum = 8;
		}
		else if ((GetAsyncKeyState(VK_NUMPAD9) & 1) > 0)
		{
			g->silkyNum = 9;
		}
		else if ((GetAsyncKeyState(VK_F7) & 1) > 0)
		{
			g->canShoot = TRUE;
		}
		else if ((GetAsyncKeyState(VK_F8) & 1) > 0)
		{
			g->canShoot = FALSE;
		}
	}
}

DWORD Thread_Bhop(PVOID param) {
	Game* g = (Game*)param;
	while (true)
	{
		try
		{
			if (GetAsyncKeyState(VK_SPACE))
			{
				int flags = g->mem->ReadDWord(g->pid, xxbase(g->gbSelfAddr + offsets::m_fFlags),xxoff);

				if (flags & (1 << 0)) {
					g->mem->WriteDword(g->pid, xxbase(g->clientBase + offsets::dwForceJump), 6,xxoff);
				}
			}
		}
		catch (...)
		{
			continue;
		}
	}
	return 0;
}
DWORD Thread_NewQuickStop(PVOID param) {
	Game* g = (Game*)param;
	while (true)
	{
		try
		{
			if (g->gbSelfHealth)
			{
				int flags = g->mem->ReadDWord(g->pid, xxbase(g->gbSelfAddr + offsets::m_fFlags),xxoff);
				if ((flags & 1) != 0) {
					float oldxSpeed = g->mem->ReadFloat(g->pid, xxbase(g->gbSelfAddr + offsets::m_vecVelocity),xxoff);
					float oldySpeed = g->mem->ReadFloat(g->pid, xxbase(g->gbSelfAddr + offsets::m_vecVelocity + 4),xxoff);

					float yView = g->mem->ReadFloat(g->pid, xxbase(g->gbClientState + offsets::dwClientState_ViewAngles + 4),xxoff);

					float xSpeed = (oldxSpeed * cos(yView / 180 * 3.1415926f) + oldySpeed * sin(yView / 180 * 3.1415926f));
					float ySpeed = (oldySpeed * cos(yView / 180 * 3.1415926f) - oldxSpeed * sin(yView / 180 * 3.1415926f));
					if (xSpeed != 0.0f && ySpeed != 0.0f)
					{
						if ((GetAsyncKeyState('W') & 0x8000) <= 0 && (GetAsyncKeyState('S') & 0x8000) <= 0)
						{
							if (xSpeed > 15) {
								g->mem->WriteDword(g->pid, xxbase(g->clientBase + offsets::dwForceBackward), 6,xxoff);
							}
							if (xSpeed < -15) {
								g->mem->WriteDword(g->pid, xxbase(g->clientBase + offsets::dwForceForward), 6,xxoff);
							}
						}
						if ((GetAsyncKeyState('A') & 0x8000) <= 0 && (GetAsyncKeyState('D') & 0x8000) <= 0) {

							if (ySpeed > 15) {
								g->mem->WriteDword(g->pid, xxbase(g->clientBase + offsets::dwForceRight), 6,xxoff);
							}
							if (ySpeed < -15) {
								g->mem->WriteDword(g->pid, xxbase(g->clientBase + offsets::dwForceLeft), 6,xxoff);
							}
						}
					}
				}
			}
		}
		catch (...)
		{
			continue;
		}
	}
	return 0;
}








DWORD Thread_FakeLag(PVOID param) {
	Game* g = (Game*)param;
	srand(GetTickCount());
	while (true)
	{
		try
		{
			if (g->gbSelfAddr && g->gbSelfHealth && (GetAsyncKeyState(VK_LBUTTON) & 0x8000) <= 0)
			{
				g->mem->WriteByte(g->pid, xxbase(g->mouseEngineBase + offsets::dwbSendPackets), 0,xxoff);
				std::this_thread::sleep_for(std::chrono::milliseconds(rand() % 70 + 60));
				g->mem->WriteByte(g->pid, xxbase(g->mouseEngineBase + offsets::dwbSendPackets), 1,xxoff);
				Sleep(rand() % 70 + 30);
			}
		}
		catch (...)
		{
			continue;
		}
	}
	return 1;
}
DWORD Thread_UpdateCmdInfo(PVOID param) {
	Game* g = (Game*)param;
	while (true)
	{
		try
		{
			g->mem->ReadArr(g->pid, xxbase(g->clientBase + offsets::dwInput + sizeof(Input) - 8), &g->input_cmd, sizeof(InputCmd),xxoff);
			g->last_outgoing_cmd_num = g->mem->ReadDWord(g->pid, xxbase(g->gbClientState + offsets::clientstate_last_outgoing_command), xxoff);
			g->curr_cmd_address = g->input_cmd.pCommands_ + ((g->last_outgoing_cmd_num + 1) % 150) * sizeof(Commands);
			g->curr_verified_cmd_address = g->input_cmd.pVerifiedCommands_ + ((g->last_outgoing_cmd_num + 1) % 150) * sizeof(VerifiedCommands);
			g->mem->ReadArr(g->pid, xxbase(g->mouseEngineBase + offsets::dwGlobalVars), &g->server_info, sizeof(GlobalVar), xxoff);
			if (g->server_info.interval_per_tick_)
			{
				g->tick_rate = static_cast<int>(round(1.0f / g->server_info.interval_per_tick_));
			}
		}
		catch (...)
		{
			continue;
		}
	}
	return 1;
}
POS pppp = { 0 };
DWORD Thread_BackTrack(PVOID param) {
	Game* g = (Game*)param;
	while (true)
	{
		try
		{
			//if (!GetAsyncKeyState(0x01))
			//{
			//	if (GetAsyncKeyState('W') & 1 << 15 || GetAsyncKeyState('S') & 1 << 15 || GetAsyncKeyState('A') & 1 << 15 || GetAsyncKeyState('D') & 1 << 15)
			//	{
			//		std::this_thread::sleep_for(std::chrono::milliseconds(20));
			//		continue;
			//	}
			//}
			g->mem->WriteByte(g->pid, xxbase(g->mouseEngineBase + offsets::dwbSendPackets), 0,xxoff);
			int incoming_cmd_num = g->last_outgoing_cmd_num + 2;
			int connect_state = g->mem->ReadDWord(g->pid, xxbase(g->gbClientState + offsets::dwClientState_State),xxoff);
			while (connect_state == kFullyConnected)
			{
				DWORD cmd_num = g->mem->ReadDWord(g->pid, xxbase(g->gbClientState + offsets::clientstate_net_channel),xxoff);
				cmd_num = g->mem->ReadDWord(g->pid, xxbase(cmd_num + 0x18),xxoff);
				if (cmd_num >= incoming_cmd_num) break;
			}

			Commands0X4 cmd;
			g->mem->ReadArr(g->pid, xxbase(g->curr_cmd_address + 4), &cmd, sizeof(Commands0X4),xxoff);
			g->current_tick = cmd.tick_count_;

			if ((GetAsyncKeyState(VK_LBUTTON) & 0x8000) > 0)
			{
				const int chosen_tick = g->backtrack_tick;
				if (chosen_tick > 0)
				{
					//g->mem->WriteDword(g->pid, g->clientBase + offsets::dwForceAttack, 0);
					//apply backtrack
					cmd.buttons_mask_ |= Input::IN_ATTACK;
					if (GetAsyncKeyState(VK_CONTROL) & 1 << 15) cmd.buttons_mask_ |= Input::IN_DUCK;
					cmd.tick_count_ = chosen_tick;
					cmd.view_angles_.x = g->mem->ReadFloat(g->pid, xxbase(g->gbClientState + offsets::dwClientState_ViewAngles),xxoff);
					cmd.view_angles_.y = g->mem->ReadFloat(g->pid, xxbase(g->gbClientState + offsets::dwClientState_ViewAngles + 4),xxoff);
					g->mem->WriteArr(g->pid, xxbase(g->curr_cmd_address + 4), &cmd, sizeof(Commands0X4),xxoff);
					g->mem->WriteArr(g->pid, xxbase(g->curr_verified_cmd_address + 4), &cmd, sizeof(Commands0X4),xxoff);
				}
				else if (g->gbSelfWeaponType != WEAPONTYPE_SNIPER_RIFLE && g->gbSelfWeaponType != WEAPONTYPE_SHOTGUN)
				{
					if (g->canShoot || g->gbSelfWeaponType == WEAPONTYPE_GRENADE || g->gbSelfWeaponType == WEAPONTYPE_KNIFE)
					{
						g->mem->WriteDword(g->pid, xxbase(g->clientBase + offsets::dwForceAttack), 5,xxoff);
					}
				}
			}
			else
			{
				g->mem->WriteDword(g->pid, xxbase(g->clientBase + offsets::dwForceAttack), 4,xxoff);
			}
			g->mem->WriteByte(g->pid, xxbase(g->mouseEngineBase + offsets::dwbSendPackets), 1,xxoff);
			std::this_thread::sleep_for(std::chrono::milliseconds(1));
		}
		catch (...)
		{
			continue;
		}
	}
	return 1;
}

DWORD Thread_FindGameProc(PVOID param) {
	Game* g = (Game*)param;
	while (true)
	{
		try
		{
			g->pid = g->mem->GetPidByName("csgo.exe");
			Sleep(5000);
		}
		catch (...)
		{
			continue;
		}
	}
}

DWORD Thread_StartDraw(PVOID param) {
	Game* g = (Game*)param;
	while (true)
	{
		try
		{
			g->Aimbot();
		}
		catch (...)
		{
			continue;
		}
	}
}
DWORD Thread_UpdateClientInfo(PVOID param) {
	Game* g = (Game*)param;
	while (true)
	{
		try
		{
			if (g->pid)
			{
				g->clientBase = g->mem->GetProcModuleBase(g->pid, "client.dll");
				g->serverBase = g->mem->GetProcModuleBase(g->pid, "server.dll");
				g->mouseEngineBase = g->mem->GetProcModuleBase(g->pid, "engine.dll");
				g->gbClientState = g->mem->ReadDWord(g->pid, xxbase(g->mouseEngineBase + offsets::dwClientState),xxoff);
				g->gbSelfAddr = g->mem->ReadDWord(g->pid, xxbase(g->clientBase + offsets::dwLocalPlayer),xxoff);
				g->gbSelfHealth = g->mem->ReadDWord(g->pid, xxbase(g->gbSelfAddr + offsets::m_iHealth),xxoff);
				g->gbSlelfPosX = g->mem->ReadFloat(g->pid, xxbase(g->gbSelfAddr + offsets::m_vecOrigin),xxoff);
				g->gbSlelfPosY = g->mem->ReadFloat(g->pid, xxbase(g->gbSelfAddr + offsets::m_vecOrigin + 4),xxoff);
				g->gbSlelfPosZ = g->mem->ReadFloat(g->pid, xxbase(g->gbSelfAddr + offsets::m_vecOrigin + 8),xxoff);
				g->gbSelfTeam = g->mem->ReadDWord(g->pid, xxbase(g->gbSelfAddr + offsets::m_iTeamNum),xxoff);
				g->gbMatrixBase = g->clientBase + offsets::dwViewMatrix;
				int curr_weapon_entity_index = g->mem->ReadDWord(g->pid, xxbase(g->gbSelfAddr + offsets::m_hActiveWeapon),xxoff) & 0xfff;
				DWORD curr_weapon_entity_address = g->mem->ReadDWord(g->pid, xxbase(g->clientBase + offsets::dwEntityList + (curr_weapon_entity_index - 1) * 0x10),xxoff);
				short temp_curr_weapon_def_index = g->mem->ReadWWord(g->pid, xxbase(curr_weapon_entity_address + offsets::m_iItemDefinitionIndex),xxoff);
				g->gbSelfWeaponIndex = (0 <= temp_curr_weapon_def_index && temp_curr_weapon_def_index < 65 ? temp_curr_weapon_def_index : 0);
				g->gbSelfWeaponType = g->GetWeaponType(g->gbSelfWeaponIndex);
			}
			Sleep(5000);
		}
		catch (...)
		{
			continue;
		}
	}
}
DWORD Thread_UpdateMapInfo(PVOID param) {
	Game* g = (Game*)param;
	const char* csgoMapDir = "D:\\steam\\steamapps\\common\\Counter-Strike Global Offensive\\csgo\\maps";
	while (true)
	{
		try
		{
			if (g->pid)
			{
				char mapName[40] = { 0 };
				char mapFullName[50] = { 0 };
				g->mem->ReadArr(g->pid, xxbase(g->gbClientState + offsets::dwClientState_Map), mapName, 0x20,xxoff);
				if (strcmp(mapName, g->current_map_name))
				{
					g->bp->unload_map();
					sprintf(mapFullName, "%s.bsp", mapName);
					if (g->bp->load_map(csgoMapDir, mapFullName))
					{
						strcpy(g->current_map_name, mapName);
						//MessageBoxA(0, mapFullName, "success", 0);
					}
				}
			}
			Sleep(5000);
		}
		catch (...)
		{
			continue;
		}
	}
}
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================



HANDLE Game::KeysWatch() {
	return CreateThread(NULL, NULL, Thread_KeyWatch, this, NULL, NULL);//按键监控
}
HANDLE Game::Bhop() {
	return CreateThread(NULL, NULL, Thread_Bhop, this, NULL, NULL);//Bhop监控
}
HANDLE Game::QuickStop() {
	return CreateThread(NULL, NULL, Thread_NewQuickStop, this, NULL, NULL);//急停监控
}
HANDLE Game::FakeLag() {
	return CreateThread(NULL, NULL, Thread_FakeLag, this, NULL, NULL);//假卡
}
HANDLE Game::BackTrack() {
	return CreateThread(NULL, NULL, Thread_BackTrack, this, NULL, NULL);//回溯
}
HANDLE Game::FindGameProc() {
	return CreateThread(NULL, NULL, Thread_FindGameProc, this, NULL, NULL);//获取PID
}
HANDLE Game::StartDraw() {
	return CreateThread(NULL, NULL, Thread_StartDraw, this, NULL, NULL);//自瞄主逻辑
}
HANDLE Game::UpdateClientInfo() {
	return CreateThread(NULL, NULL, Thread_UpdateClientInfo, this, NULL, NULL);//更新Client结构
}
HANDLE Game::UpdateMapInfo() {
	return CreateThread(NULL, NULL, Thread_UpdateMapInfo, this, NULL, NULL);//更新地图信息
}
HANDLE Game::UpdateCmdInfo() {
	return CreateThread(NULL, NULL, Thread_UpdateCmdInfo, this, NULL, NULL);//更新cmd信息
}


//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================
//============================================================================================================================================

void ViewAngleToScreenRelative(PPOS newP, PPOS nowP, PPOS mouseP) {
	mouseP->y = (newP->y - nowP->y) * 15;
	mouseP->x = (nowP->x - newP->x) * 15;
	//mouseP->y = (newP->y - nowP->y) / 0.1099999994;
	//mouseP->x = (nowP->x - newP->x) / 0.1099999994;
}

int lastP = -1;
int lastB = -1;
void Game::Aimbot() {
	if (!this->pid)
	{
		return;
	}

	this->FlushBackTrackHistory();

	POS bestPos = { 0 };
	int p, b;
	int curr_backtrack_tick = this->ChooseBestTick(0, lastP, lastB, bestPos, p, b);

	this->backtrack_tick = curr_backtrack_tick;

	if (!curr_backtrack_tick) return;

	POS selfBone = { 0 };
	this->GetSelfEyePos(&selfBone);

	POS newP = { 0 };
	this->NewAim(&selfBone, &bestPos, &newP);

	this->RecoilCalc(newP);

	this->AimTo(newP, p, b);
}





void Game::AimTo(POS newP,int p,int b) {
	POS mouseMove = { 0 };
	POS nowAngle = { 0 };
	nowAngle.x = this->mem->ReadFloat(this->pid, xxbase(this->gbClientState + offsets::dwClientState_ViewAngles + 4),xxoff);
	nowAngle.y = this->mem->ReadFloat(this->pid, xxbase(this->gbClientState + offsets::dwClientState_ViewAngles),xxoff);

	
	DWORD mtX;
	ViewAngleToScreenRelative(&newP, &nowAngle, &mouseMove);
	if ((mouseMove.x > 0 ? mouseMove.x : mouseMove.x * -1) > this->weight / 2 || (mouseMove.y > 0 ? mouseMove.y : mouseMove.y * -1) > this->hight / 2)
	{
		return;
	}
	if ((GetAsyncKeyState(VK_RBUTTON) & 0x8000) > 0)
	{
		if (p != lastP && lastP != -1)
		{
			Sleep(300);
		}
		lastP = p;
		lastB = b;
		//this->mem->ExpKmMouseMoveRelative(mouseMove.x, mouseMove.y);
		//for (size_t i = 0; i < this->silkyNum * 500000; i++)
		//{
		//	mtX = GetAsyncKeyState(VK_RBUTTON);//无意义代码，防止空循环编译时被优化掉
		//}
		this->mem->WriteFloat(this->pid, xxbase(this->gbClientState + offsets::dwClientState_ViewAngles + 4), (newP.x - nowAngle.x) / 4 / this->silkyNum + nowAngle.x,xxoff);
		this->mem->WriteFloat(this->pid, xxbase(this->gbClientState + offsets::dwClientState_ViewAngles), (newP.y - nowAngle.y) / 4 / this->silkyNum + nowAngle.y, xxoff);
		this->mem->WriteDword(this->pid, 0, mtX,0);
	}
	else
	{
		lastP = -1;
		lastB = -1;
	}
}


void Game::RecoilCalc(POS &aimVec) {
	if (this->gbSelfWeaponType == WEAPONTYPE_SUBMACHINEGUN ||
		this->gbSelfWeaponType == WEAPONTYPE_RIFLE ||
		this->gbSelfWeaponType == WEAPONTYPE_MACHINEGUN)
	{
		float yyyy = this->mem->ReadFloat(this->pid, xxbase(this->gbSelfAddr + offsets::m_aimPunchAngle),xxoff);//后坐力数据
		float xxxx = this->mem->ReadFloat(this->pid, xxbase(this->gbSelfAddr + offsets::m_aimPunchAngle + 4),xxoff);//后坐力数据
		aimVec.x -= xxxx * 2.0099;
		aimVec.y -= yyyy * 2.0099;
	}
}



int Game::ChooseBestTick(int max_tick,int preferPlayerIndex,int preferBoneIndex,POS &out_aimVec3,int &playerIndex,int &boneIndex) {
	int boneArr[] = { 8,6, 5,4, 3 };
	int curr_backtrack_tick = 0;
	int record_to_search = static_cast<int>(0.2f / this->server_info.interval_per_tick_) - 1;//max tick
	float closestPwn = 99999.f;
	POS bestPos = { 0 };

	if (max_tick) record_to_search = max_tick;

	int nowScanPindex = 0;
	int nowScanBindex = 0;
	int tempRetPlayer = -1;
	int tempRetBone = -1;

	for (int i = 0; i < 32; i++)
	{
		bool curPlayerHasChosen = false;
		nowScanPindex = i;
		PLAYER p = { 0 };
		p.addr = this->mem->ReadDWord(this->pid, xxbase(this->clientBase + offsets::dwEntityList + i * 16),xxoff);
		p.health = this->mem->ReadDWord(this->pid, xxbase(p.addr + offsets::m_iHealth),xxoff);
		p.team = this->mem->ReadDWord(this->pid, xxbase(p.addr + offsets::m_iTeamNum),xxoff);
		DWORD objFlush = this->mem->ReadDWord(this->pid, xxbase(p.addr + offsets::m_bDormant),xxoff);
		DWORD boneAddr = this->mem->ReadDWord(this->pid, xxbase(p.addr + offsets::m_dwBoneMatrix),xxoff);
		//
		if (p.team == this->gbSelfTeam ||
			p.health < 1
			|| objFlush != 0)
		{
			for (int j = 0; j < 5; ++j)
			{
				history_[i][j].clear();
			}
			continue;
		}

		for (int j = 0; j < 5; j++)
		{
			nowScanBindex = boneArr[j];
			//remove expired tick
			while (!history_[i][j].empty())
			{
				//删掉超过maxtick以外的tick记录
				if (history_[i][j].back().tick + record_to_search < this->current_tick) history_[i][j].pop_back();
				else break;
			}

			int bone_id = boneArr[j];
			int record_searched = 0;
			for (int k = 0; k < history_[i][j].size(); k++)
			{
				BacktrackRecord br = history_[i][j].at(k);
				POS selfBone = { 0 };
				this->GetSelfEyePos(&selfBone);
				vector3 selfVec = vector3(selfBone.x, selfBone.y, selfBone.z);

				vector3 enemyVec = vector3(br.pos.x, br.pos.y, br.pos.z);
				if (!this->bp->is_visible(selfVec, enemyVec))
				{
					continue;
				}
				POS sc = { 0 };
				this->WorldToScreen(&br.pos, &sc);
				float dx = sc.x > this->centerX ? sc.x - this->centerX : this->centerX - sc.x;
				float dy = sc.y > this->centerY ? sc.y - this->centerY : this->centerY - sc.y;
				if (dx > this->aimScope || dy > this->aimScope)
				{
					continue;
				}

				//float distance = sqrt(dx * dx + dy * dy);
				float distance = dy;
				if (distance < closestPwn)
				{
					curPlayerHasChosen = true;
					closestPwn = distance;
					curr_backtrack_tick = br.tick;
					bestPos.x = br.pos.x;
					bestPos.y = br.pos.y;
					bestPos.z = br.pos.z;
					tempRetPlayer = i;
					tempRetBone = boneArr[j];
				}
				//check searched record, no more than once without backtrack
				if (++record_searched == record_to_search) break;
			}
			if (curPlayerHasChosen && nowScanPindex == preferPlayerIndex && nowScanBindex == preferBoneIndex)
			{
				goto RET;
			}
		}
	}
RET:
	playerIndex = tempRetPlayer;
	boneIndex = tempRetBone;
	out_aimVec3 = bestPos;
	return curr_backtrack_tick;
}



void Game::FlushBackTrackHistory() {
	int boneArr[] = { 8,6, 5,4, 3 };
	for (int i = 0; i < 32; i++)
	{
		PLAYER p = { 0 };
		p.addr = this->mem->ReadDWord(this->pid, xxbase(this->clientBase + offsets::dwEntityList + i * 16),xxoff);
		p.health = this->mem->ReadDWord(this->pid, xxbase(p.addr + offsets::m_iHealth),xxoff);
		p.team = this->mem->ReadDWord(this->pid, xxbase(p.addr + offsets::m_iTeamNum),xxoff);
		DWORD objFlush = this->mem->ReadDWord(this->pid, xxbase(p.addr + offsets::m_bDormant),xxoff);
		DWORD boneAddr = this->mem->ReadDWord(this->pid, xxbase(p.addr + offsets::m_dwBoneMatrix),xxoff);
		if (p.team == this->gbSelfTeam ||
			p.health < 1
			|| objFlush != 0)
		{
			continue;
		}
		for (int j = 0; j < 5; j++)
		{
			POS bone = { 0 };
			this->GetBonePos(&bone, p.addr, boneArr[j]);
			if (history_[i][j].empty() ||
				history_[i][j].front().tick != this->current_tick)
			{
				BacktrackRecord bcr = { this->current_tick, bone };
				history_[i][j].emplace_front(bcr);
			}
			else
			{
				//update the position to avoid duplicated record
				history_[i][j].front().pos = bone;
			}
		}
	}
}












void Game::GetBonePos(POS * pos, ULONG64 playerBase, int boneIndex) {
	DWORD offsetLevel1 = this->mem->ReadDWord(this->pid, xxbase(playerBase + offsets::m_dwBoneMatrix),xxoff) + 12;
	pos->z = this->mem->ReadFloat(this->pid, xxbase(offsetLevel1 + boneIndex * 48 + 32),xxoff);
	pos->y = this->mem->ReadFloat(this->pid, xxbase(offsetLevel1 + boneIndex * 48 + 16),xxoff);
	pos->x = this->mem->ReadFloat(this->pid, xxbase(offsetLevel1 + boneIndex * 48 + 0 ),xxoff);
}

void Game::GetSelfEyePos(POS * pos) {
	POS origin = { 0 };
	this->mem->ReadArr(this->pid, xxbase(this->gbSelfAddr + offsets::m_vecOrigin), &origin, sizeof(POS),xxoff);
	POS offset = { 0 };
	this->mem->ReadArr(this->pid, xxbase(this->gbSelfAddr + offsets::m_vecViewOffset), &offset, sizeof(POS),xxoff);

	pos->x = origin.x + offset.x;
	pos->y = origin.y + offset.y;
	pos->z = origin.z + offset.z;
}

BOOLEAN Game::WorldToScreen(POS * world, POS * screen) {
	float matrixArray[4][4] = { 0.0f };
	this->ReadMatrix(&matrixArray[0][0]);
	screen->z = world->x * matrixArray[3][0] + world->y * matrixArray[3][1] + world->z * matrixArray[3][2] + matrixArray[3][3];
	if (screen->z < 0)
	{
		return FALSE;
	}
	screen->x = (float)(this->weight / 2) + (world->x * matrixArray[0][0] + world->y * matrixArray[0][1] + world->z * matrixArray[0][2] + matrixArray[0][3]) / screen->z * (this->weight / 2);
	screen->y = (float)(this->hight / 2) - (world->x * matrixArray[1][0] + world->y * matrixArray[1][1] + world->z * matrixArray[1][2] + matrixArray[1][3]) / screen->z * (this->hight / 2);
	return TRUE;
}
void Game::ReadMatrix(float* matrixArray) {
	this->mem->ReadArr(this->pid, xxbase(this->gbMatrixBase), matrixArray, 64,xxoff);
}
void Game::NewAim(PPOS self, PPOS enemy, PPOS ret) {
	float aimX = self->x - enemy->x;
	float aimY = self->y - enemy->y;
	float aimZ = self->z - enemy->z + 1;
	double PI = 3.1415926535;
	if (aimX <= 0 && aimY <= 0)
	{
		ret->x = atan(aimY / aimX) / PI * 180;
	}
	else if (aimX >= 0 && aimY <= 0)
	{
		ret->x = atan(aimY / aimX) / PI * 180 + 180;
	}
	else if (aimX >= 0 && aimY >= 0)
	{
		ret->x = atan(aimY / aimX) / PI * 180 - 180;
	}
	else if (aimX <= 0 && aimY >= 0)
	{
		ret->x = atan(aimY / aimX) / PI * 180;
	}
	ret->y = atan(aimZ / sqrt(aimX * aimX + aimY * aimY)) / PI * 180;
}


CSWeaponType Game::GetWeaponType(int itemDefIndex)
{
	switch (itemDefIndex)
	{
	case WEAPON_TASER:
	case WEAPON_KNIFE_GG:
	case WEAPON_KNIFE_CT:
	case WEAPON_KNIFE_T:
	case WEAPON_KNIFE_GHOST:
	case WEAPON_KNIFE_BAYONET:
	case WEAPON_KNIFE_FLIP:
	case WEAPON_KNIFE_GUT:
	case WEAPON_KNIFE_KARAMBIT:
	case WEAPON_KNIFE_M9_BAYONET:
	case WEAPON_KNIFE_TACTICAL:
	case WEAPON_KNIFE_FALCHION:
	case WEAPON_KNIFE_SURVIVAL_BOWIE:
	case WEAPON_KNIFE_BUTTERFLY:
	case WEAPON_KNIFE_PUSH:
	case WEAPON_KNIFE_URSUS:
	case WEAPON_KNIFE_GYPSY_JACKKNIFE:
	case WEAPON_KNIFE_STILETTO:
	case WEAPON_KNIFE_WIDOWMAKER:
		return WEAPONTYPE_KNIFE;
	case WEAPON_DEAGLE:
	case WEAPON_ELITE:
	case WEAPON_FIVESEVEN:
	case WEAPON_GLOCK:
	case WEAPON_TEC9:
	case WEAPON_HKP2000:
	case WEAPON_P250:
	case WEAPON_USP_SILENCER:
	case WEAPON_CZ75A:
	case WEAPON_REVOLVER:
		return WEAPONTYPE_PISTOL;
	case WEAPON_MAC10:
	case WEAPON_P90:
	case WEAPON_MP5SD:
	case WEAPON_UMP45:
	case WEAPON_BIZON:
	case WEAPON_MP7:
	case WEAPON_MP9:
		return WEAPONTYPE_SUBMACHINEGUN;
	case WEAPON_AK47:
	case WEAPON_AUG:
	case WEAPON_FAMAS:
	case WEAPON_GALILAR:
	case WEAPON_M4A1:
	case WEAPON_SG556:
	case WEAPON_M4A1_SILENCER:
		return WEAPONTYPE_RIFLE;
	case WEAPON_XM1014:
	case WEAPON_MAG7:
	case WEAPON_SAWEDOFF:
	case WEAPON_NOVA:
		return WEAPONTYPE_SHOTGUN;
	case WEAPON_AWP:
	case WEAPON_G3SG1:
	case WEAPON_SCAR20:
	case WEAPON_SSG08:
		return WEAPONTYPE_SNIPER_RIFLE;
	case WEAPON_M249:
	case WEAPON_NEGEV:
		return WEAPONTYPE_MACHINEGUN;
	case WEAPON_C4:
		return WEAPONTYPE_C4;
	case WEAPON_FLASHBANG:
	case WEAPON_HEGRENADE:
	case WEAPON_SMOKEGRENADE:
	case WEAPON_MOLOTOV:
	case WEAPON_DECOY:
	case WEAPON_INCGRENADE:
	case WEAPON_TAGRENADE:
	case WEAPON_FIREBOMB:
	case WEAPON_DIVERSION:
	case WEAPON_FRAG_GRENADE:
		return WEAPONTYPE_GRENADE;
	case WEAPON_FISTS:
		return WEAPONTYPE_FISTS;
	case WEAPON_BREACHCHARGE:
		return WEAPONTYPE_BREACHCHARGE;
	case WEAPON_TABLET:
		return WEAPONTYPE_TABLET;
	case WEAPON_AXE:
	case WEAPON_HAMMER:
	case WEAPON_SPANNER:
		return WEAPONTYPE_MELEE;
	default:
		return WEAPONTYPE_UNKNOWN;
	}
}
```

`Game.h`:

```h
#pragma once
#include "global.hpp"
#include "MemTool.h"
#include "Tool.h"


class Game
{
public:
	MemTool* mem;
	Tool* tool;
	bsp_parser* bp;

	DWORD pid = 0;  //游戏进程ID

	ULONG64 clientBase = 0;
	ULONG64 serverBase = 0;
	ULONG64 mouseEngineBase = 0;

	ULONG64 gbClientState = 0;
	ULONG64 gbSelfAddr = 0;
	ULONG64 gbSelfHealth = 0;
	float gbSlelfPosX = 0.f;
	float gbSlelfPosY = 0.f;
	float gbSlelfPosZ = 0.f;
	short gbSelfWeaponIndex = 0;
	CSWeaponType gbSelfWeaponType = WEAPONTYPE_UNKNOWN;
	ULONG64 gbSelfTeam = 0;
	ULONG64 gbMatrixBase = 0;
	ULONG64 gbLightingBase = 0;

#define SCREEN_WEIGHT 2560
#define SCREEN_HIGHT 1440

	
	LONG weight = SCREEN_WEIGHT;
	LONG hight = SCREEN_HIGHT;
	LONG centerX = SCREEN_WEIGHT / 2;
	LONG centerY = SCREEN_HIGHT / 2;
	

	void Aimbot();
	void ReadMatrix(float* matrixArray);
	void NewAim(PPOS self, PPOS enemy, PPOS ret);
	void GetBonePos(POS* pos, ULONG64 playerBase, int boneIndex);
	void GetSelfEyePos(POS * pos);
	BOOLEAN WorldToScreen(POS* world, POS* screen);
	CSWeaponType GetWeaponType(int itemDefIndex);
	void FlushBackTrackHistory();
	int ChooseBestTick(int max_tick, int preferPlayerIndex, int preferBoneIndex, POS &aimVec3, int &playerIndex, int &boneIndex);
	void RecoilCalc(POS &aimVec);
	void AimTo(POS newP, int p, int b);

public:
	DWORD aimScope;
	DWORD silkyNum;

	InputCmd input_cmd = {};
	int last_outgoing_cmd_num = 0;
	DWORD curr_cmd_address = NULL;
	DWORD curr_verified_cmd_address = NULL;
	GlobalVar server_info;
	int tick_rate = 0;

	Game();
	
	HANDLE FindGameProc();
	HANDLE KeysWatch();
	HANDLE Bhop();
	HANDLE QuickStop();
	HANDLE FakeLag();
	HANDLE BackTrack();
	HANDLE UpdateClientInfo();
	HANDLE UpdateMapInfo();
	HANDLE UpdateCmdInfo();
	HANDLE StartDraw();

	bool canShoot = FALSE;
	char current_map_name[256] = { 0 };
	int current_tick;
	int backtrack_tick;
	std::deque<BacktrackRecord> history_[32][5]{};


};


```

`MemTool.cpp`:

```cpp
#pragma once
#include "MemTool.h"
#include <tlhelp32.h>



MemTool::MemTool() {
	this->handle = LoadLibraryA("silky.dll");
	this->ExpGetModuleBase = (gExpGetModuleBase)GetProcAddress(this->handle, "ExpGetModuleBase");
	this->ExpLoadDriver = (gExpLoadDriver)GetProcAddress(this->handle, "ExpLoadDriver");
	this->ExpGetPidByName = (gExpGetPidByName)GetProcAddress(this->handle, "ExpGetPidByName");
	this->ExpReadProcMemory = (gExpReadProcMemory)GetProcAddress(this->handle, "ExpReadProcMemory");
	this->ExpWriteProcMemory = (gExpWriteProcMemory)GetProcAddress(this->handle, "ExpWriteProcMemory");

	this->ExpKmInstall = (gExpKmInstall)GetProcAddress(this->handle, "ExpKmInstall");
	this->ExpKmKeyDown = (gExpKmKeyDown)GetProcAddress(this->handle, "ExpKmKeyDown");
	this->ExpKmKeyUp = (gExpKmKeyUp)GetProcAddress(this->handle, "ExpKmKeyUp");
	this->ExpKmMouseLeftDown = (gExpKmMouseLeftDown)GetProcAddress(this->handle, "ExpKmMouseLeftDown");
	this->ExpKmMouseLeftUp = (gExpKmMouseLeftUp)GetProcAddress(this->handle, "ExpKmMouseLeftUp");
	this->ExpKmMouseRightDown = (gExpKmMouseRightDown)GetProcAddress(this->handle, "ExpKmMouseRightDown");
	this->ExpKmMouseRightUp = (gExpKmMouseRightUp)GetProcAddress(this->handle, "ExpKmMouseRightUp");
	this->ExpKmMouseMoveRelative = (gExpKmMouseMoveRelative)GetProcAddress(this->handle, "ExpKmMouseMoveRelative");
	this->ExpKmMouseMoveTo = (gExpKmMouseMoveTo)GetProcAddress(this->handle, "ExpKmMouseMoveTo");

	this->ExpHideProcessByPid = (gExpHideProcessByPid)GetProcAddress(this->handle, "ExpHideProcessByPid");

	//this->ExpDwmDrInit = (gExpDwmDrInit)GetProcAddress(this->handle, "ExpDwmDrInit");
	//this->ExpDwmDrStartDraw = (gExpDwmDrStartDraw)GetProcAddress(this->handle, "ExpDwmDrStartDraw");
	//this->ExpDwmDrEndDraw = (gExpDwmDrEndDraw)GetProcAddress(this->handle, "ExpDwmDrEndDraw");
	//this->ExpDwmDrDrawBox = (gExpDwmDrDrawBox)GetProcAddress(this->handle, "ExpDwmDrDrawBox");
}





ULONG64 MemTool::GetProcModuleBase(DWORD pid, const char* mName) {
	ULONG64 base = 0;
	LONG ret = this->ExpGetModuleBase(pid,(char*)mName,&base);
	return base;
}

LONG64 MemTool::ReadQWord(DWORD pid, ULONG64 base, ULONG64 offset) {
	LONG64 val = 0;
	this->ExpReadProcMemory(pid, base, (ULONG64)&val, 8, offset);
	return val;
}
float MemTool::ReadFloat(DWORD pid, ULONG64 base, ULONG64 offset) {
	DWORD val = 0;
	this->ExpReadProcMemory(pid, base, (ULONG64)&val, 4, offset);
	float t = *(float*)(&val);
	return t;
}
DWORD MemTool::ReadDWord(DWORD pid, ULONG64 base, ULONG64 offset) {
	DWORD val = 0;
	this->ExpReadProcMemory(pid, base, (ULONG64)&val, 4, offset);
	return val;
}
UWORD MemTool::ReadWWord(DWORD pid, ULONG64 base, ULONG64 offset) {
	UWORD val = 0;
	this->ExpReadProcMemory(pid, base, (ULONG64)&val, 2, offset);
	return val;
}
UCHAR MemTool::ReadByte(DWORD pid, ULONG64 base, ULONG64 offset) {
	UCHAR val = 0;
	this->ExpReadProcMemory(pid, base, (ULONG64)&val, 1, offset);
	return val;
}
void MemTool::ReadArr(DWORD pid, ULONG64 dst, PVOID arr, ULONG64 size, ULONG64 offset) {
	this->ExpReadProcMemory(pid, dst, (ULONG64)arr, size, offset);
}



void MemTool::WriteDword(DWORD pid, ULONG64 base, DWORD data, ULONG64 offset) {
	DWORD buf = data;
	LONG ret = this->ExpWriteProcMemory(pid, base, (ULONG64)&buf, 4, offset);
}
void MemTool::WriteFloat(DWORD pid, ULONG64 base, float val, ULONG64 offset) {
	float val1 = val;
	LONG ret = this->ExpWriteProcMemory(pid, base, (ULONG64)&val1, 4, offset);
}

void MemTool::WriteArr(DWORD pid, ULONG64 base, PVOID arr, ULONG64 size, ULONG64 offset) {
	this->ExpWriteProcMemory(pid, base, (ULONG64)arr, size, offset);
}
void MemTool::WriteByte(DWORD pid, ULONG64 base, UCHAR data, ULONG64 offset) {
	UCHAR buf = data;
	LONG ret = this->ExpWriteProcMemory(pid, base, (ULONG64)&buf, 1, offset);
}


DWORD MemTool::GetPidByName(const char* name) {
	ULONG64 pid = 0;
	LONG ret = this->ExpGetPidByName((char*)name,(ULONG64)&pid);
	return pid;
}


```

`MemTool.h`:

```h
#pragma once
#include "global.hpp"


//自定义枚举进程参数
typedef struct
{
	HWND	hwnd;
	DWORD	processId;
}WindowsArg;

class MemTool
{

	HMODULE handle;


public:
	MemTool();
	ULONG64 GetProcModuleBase(DWORD pid, const char* mName);
	LONG64 ReadQWord(DWORD pid, ULONG64 base, ULONG64 offset);
	DWORD ReadDWord(DWORD pid, ULONG64 base, ULONG64 offset);
	float ReadFloat(DWORD pid, ULONG64 base, ULONG64 offset);
	UWORD ReadWWord(DWORD pid, ULONG64 base, ULONG64 offset);
	UCHAR ReadByte(DWORD pid, ULONG64 base, ULONG64 offset);
	void ReadArr(DWORD pid, ULONG64 dst, PVOID arr, ULONG64 size, ULONG64 offset);

	void WriteDword(DWORD pid, ULONG64 base, DWORD data, ULONG64 offset);
	void WriteFloat(DWORD pid, ULONG64 base, float val, ULONG64 offset);
	void WriteByte(DWORD pid, ULONG64 base, UCHAR data, ULONG64 offset);
	void WriteArr(DWORD pid, ULONG64 base, PVOID arr, ULONG64 size, ULONG64 offset);
	BOOLEAN FarCall(DWORD pid, PUCHAR code, ULONG64 size);

	DWORD GetPidByName(const char* name);
	HWND  GetHwndByProcessId(DWORD processId);






	gExpLoadDriver ExpLoadDriver;
	gExpGetPidByName ExpGetPidByName;
	gExpGetModuleBase ExpGetModuleBase;
	gExpReadProcMemory ExpReadProcMemory;
	gExpWriteProcMemory ExpWriteProcMemory;
	gExpHideProcessByPid ExpHideProcessByPid;

	gExpKmInstall ExpKmInstall;
	gExpKmKeyDown ExpKmKeyDown;
	gExpKmKeyUp ExpKmKeyUp;
	gExpKmMouseLeftDown ExpKmMouseLeftDown;
	gExpKmMouseLeftUp ExpKmMouseLeftUp;
	gExpKmMouseRightDown ExpKmMouseRightDown;
	gExpKmMouseRightUp ExpKmMouseRightUp;
	gExpKmMouseMoveRelative ExpKmMouseMoveRelative;
	gExpKmMouseMoveTo ExpKmMouseMoveTo;

	gExpDwmDrInit ExpDwmDrInit;
	gExpDwmDrStartDraw ExpDwmDrStartDraw;
	gExpDwmDrEndDraw ExpDwmDrEndDraw;
	gExpDwmDrDrawBox ExpDwmDrDrawBox;


};


```

`README.md`:

```md
# csgo_cheat_external
csgo_cheat_external


offset: https://github.com/frk1/hazedumper


bsp parser:https://github.com/ReactiioN1337/valve-bsp-parser

```

`Tool.cpp`:

```cpp
#pragma once
#include "Tool.h"

CHAR* Tool::GetSelfPhyPath() {

	CHAR* path = (CHAR*)malloc(0x10000);
	memset(path, 0, 0x10000);
	CHAR path1[0x1000];
	HMODULE hm = GetModuleHandle(NULL);
	GetModuleFileNameA(hm, path1, sizeof(path1));
	sprintf(path, "\\??\\%s", path1);
	return path;
}

void Tool::Log(const char* msg, LONG code) {
	if (code != 0 && code != 0xF3000002)
	{
		CHAR txt[1000] = { 0 };
		sprintf(txt, "%s  错误码：%08x",msg,code);
		MessageBoxA(NULL, txt, "踏雪提示：", 0);
	}
	else
	{
		MessageBoxA(NULL, msg, "踏雪提示：", 0);
	}
}

```

`Tool.h`:

```h
#pragma once
#include "global.hpp"

class Tool
{

public:
	CHAR* GetSelfPhyPath();
	void Log(const char* msg,LONG code);
};


```

`csgo.cpp`:

```cpp
#pragma once
#include "global.hpp"
#include "Game.h"

;




Game* game = NULL;
/*int WinMain(HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
	LPSTR lpCmdLine,
	int nCmdShow)*/
Game* game = NULL;
int main(
	LPSTR lpCmdLine,
	int nCmdShow)
{
	game = new Game();
	
	LONG ret = game->mem->ExpLoadDriver("skCVXuFtBvzjKw8VdP6oab3fk435U2p7HCQ");
	if (ret != 0x66666666)
	{
		game->tool->Log( "驱动加载失败！", ret);
		return -1;
	}
	//ret = game->mem->ExpKmInstall();
	//if (ret != 0)
	//{
	//	game->tool->Log("键鼠加载失败！", ret);
	//	return -1;
	//}
	HANDLE handleList[100] = { 0 };
	int nowIndex = 0;
	handleList[nowIndex++] = game->KeysWatch();
	handleList[nowIndex++] = game->FindGameProc();
	handleList[nowIndex++] = game->Bhop();
	handleList[nowIndex++] = game->QuickStop();
	handleList[nowIndex++] = game->BackTrack();
	handleList[nowIndex++] = game->UpdateClientInfo();
	handleList[nowIndex++] = game->UpdateMapInfo();
	handleList[nowIndex++] = game->UpdateCmdInfo();
	handleList[nowIndex++] = game->StartDraw(); 
	//handleList[nowIndex++] = game->FakeLag();
	
	game->tool->Log( "加载成功！请登陆游戏，游戏请事先设置无边框模式，否则绘制将失效！", 0);
	ret = game->mem->ExpHideProcessByPid(GetCurrentProcessId(), 0, TRUE);
	while (true)
	{
		DWORD waitRet = WaitForMultipleObjects(nowIndex,&handleList[0], FALSE,5000);
		if (waitRet == WAIT_TIMEOUT) continue;
		char msg[256] = { 0 };
		sprintf(msg, "thread %d crash!", waitRet);
		MessageBoxA(0, msg, "", 0);
	}
	return 0;
}

```

`global.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <d3d9.h>
#include <d3dx9math.h>
#include <math.h>
#include <tchar.h>
#include <valve-bsp-parser/bsp_parser.hpp>
#include <deque>

using namespace rn;

typedef struct _BOX {
	float x;
	float y;
	float z;
	float Y2;
	float W;
}BOX,*PBOX;
typedef struct _POS {
	float x;
	float y;
	float z;
}POS, * PPOS;
typedef struct _PLAYER {
	DWORD addr;
	DWORD health;
	DWORD team;
	float x;
	float y;
	float z;
	POS p;
	POS head;
}PLAYER, * PPLAYER;

#define AIMPOS_HEAD 6
#define AIMPOS_RANDOM 0

#define xxor(v)			((v ^ 0x65083911))
#define xxoff			0
#define xxbase(v)			((v) - xxoff)

EXTERN_C typedef DWORD(WINAPI* gExpLoadDriver)(const char * key);
EXTERN_C typedef DWORD(WINAPI* gExpGetPidByName)(const char* name, ULONG64 ppid);
EXTERN_C typedef DWORD(WINAPI* gExpGetModuleBase)(ULONG64 pid, const char* name, PULONG64 base);
EXTERN_C typedef DWORD(WINAPI* gExpReadProcMemory)(ULONG64 pid, ULONG64 dst, ULONG64 buf, ULONG64 len, ULONG64 way);
EXTERN_C typedef DWORD(WINAPI* gExpWriteProcMemory)(ULONG64 pid, ULONG64 dst, ULONG64 buf, ULONG64 len, ULONG64 way);
EXTERN_C typedef DWORD(WINAPI* gExpHideProcessByPid)(ULONG64 pid, ULONG64 dstpid, ULONG64 needClearObj);
EXTERN_C typedef DWORD(WINAPI* gExpKmInstall)();
EXTERN_C typedef DWORD(WINAPI* gExpKmKeyDown)(ULONG64 kVal);
EXTERN_C typedef DWORD(WINAPI* gExpKmKeyUp)(ULONG64 kVal);
EXTERN_C typedef DWORD(WINAPI* gExpKmMouseLeftDown)();
EXTERN_C typedef DWORD(WINAPI* gExpKmMouseLeftUp)();
EXTERN_C typedef DWORD(WINAPI* gExpKmMouseRightDown)();
EXTERN_C typedef DWORD(WINAPI* gExpKmMouseRightUp)();
EXTERN_C typedef DWORD(WINAPI* gExpKmMouseMoveRelative)(LONG64 dx, LONG64 dy);
EXTERN_C typedef DWORD(WINAPI* gExpKmMouseMoveTo)(LONG64 dx, LONG64 dy);
EXTERN_C typedef DWORD(WINAPI* gExpDwmDrInit)();
EXTERN_C typedef BOOL(WINAPI* gExpDwmDrStartDraw)();
EXTERN_C typedef void(WINAPI* gExpDwmDrEndDraw)();
EXTERN_C typedef void(WINAPI* gExpDwmDrDrawBox)(float X, float Y, float W, float H, float R, float G, float B, float A, int T);

enum ItemDefinitionIndex
{
	WEAPON_NONE = 0,
	WEAPON_DEAGLE,
	WEAPON_ELITE,
	WEAPON_FIVESEVEN,
	WEAPON_GLOCK,
	WEAPON_AK47 = 7,
	WEAPON_AUG,
	WEAPON_AWP,
	WEAPON_FAMAS,
	WEAPON_G3SG1,
	WEAPON_GALILAR = 13,
	WEAPON_M249,
	WEAPON_M4A1 = 16,
	WEAPON_MAC10,
	WEAPON_P90 = 19,
	WEAPON_MP5SD = 23,
	WEAPON_UMP45,
	WEAPON_XM1014,
	WEAPON_BIZON,
	WEAPON_MAG7,
	WEAPON_NEGEV,
	WEAPON_SAWEDOFF,
	WEAPON_TEC9,
	WEAPON_TASER,
	WEAPON_HKP2000,
	WEAPON_MP7,
	WEAPON_MP9,
	WEAPON_NOVA,
	WEAPON_P250,
	WEAPON_SCAR20 = 38,
	WEAPON_SG556,
	WEAPON_SSG08,
	WEAPON_KNIFE_GG,
	WEAPON_KNIFE_CT,
	WEAPON_FLASHBANG,
	WEAPON_HEGRENADE,
	WEAPON_SMOKEGRENADE,
	WEAPON_MOLOTOV,
	WEAPON_DECOY,
	WEAPON_INCGRENADE,
	WEAPON_C4,
	WEAPON_HEALTHSHOT = 57,
	WEAPON_KNIFE_T = 59,
	WEAPON_M4A1_SILENCER,
	WEAPON_USP_SILENCER,
	WEAPON_CZ75A = 63,
	WEAPON_REVOLVER,
	WEAPON_TAGRENADE = 68,
	WEAPON_FISTS,
	WEAPON_BREACHCHARGE,
	WEAPON_TABLET = 72,
	//WEAPON_MELEE = 74,	// prefab
	WEAPON_AXE = 75,
	WEAPON_HAMMER,
	WEAPON_SPANNER = 78,
	WEAPON_KNIFE_GHOST = 80,
	WEAPON_FIREBOMB,
	WEAPON_DIVERSION,
	WEAPON_FRAG_GRENADE,
	WEAPON_KNIFE_BAYONET = 500,
	WEAPON_KNIFE_FLIP = 505,
	WEAPON_KNIFE_GUT,
	WEAPON_KNIFE_KARAMBIT,
	WEAPON_KNIFE_M9_BAYONET,
	WEAPON_KNIFE_TACTICAL,
	WEAPON_KNIFE_FALCHION = 512,
	WEAPON_KNIFE_SURVIVAL_BOWIE = 514,
	WEAPON_KNIFE_BUTTERFLY,
	WEAPON_KNIFE_PUSH,
	WEAPON_KNIFE_URSUS = 519,
	WEAPON_KNIFE_GYPSY_JACKKNIFE,
	WEAPON_KNIFE_STILETTO = 522,
	WEAPON_KNIFE_WIDOWMAKER
};
enum CSWeaponType
{
	WEAPONTYPE_KNIFE = 0,
	WEAPONTYPE_PISTOL,   //手枪
	WEAPONTYPE_SUBMACHINEGUN, //冲锋
	WEAPONTYPE_RIFLE,  //步枪
	WEAPONTYPE_SHOTGUN,   //霰弹枪
	WEAPONTYPE_SNIPER_RIFLE,  //狙击
	WEAPONTYPE_MACHINEGUN,  //机枪
	WEAPONTYPE_C4,
	WEAPONTYPE_GRENADE = 9,   //雷
	WEAPONTYPE_STACKABLE = 11,
	WEAPONTYPE_FISTS,   //拳头
	WEAPONTYPE_BREACHCHARGE, //？
	WEAPONTYPE_TABLET,   //药片
	WEAPONTYPE_MELEE,   //？
	WEAPONTYPE_UNKNOWN
};
struct GlowStruct {
	BYTE base[8];
	float red;
	float green;
	float blue;
	float alpha;
	BYTE buffer[16];
	bool redner_occluded;
	bool render_unoccluded;
	bool fullBloom;
	BYTE buffer1[5];
	int glow_style;
};



struct BacktrackRecord
{
	int tick;
	POS pos;
};

enum ConnectionState : int
{
	kNone,
	kChallenge,
	kConnected, //loading screen
	kNew,
	kPrespawn,
	kSpawn,
	kFullyConnected, //fully connected to the game
	kChangeLevel
};


class Commands0X4
{
public:
	int cmd_number_;
	int tick_count_;

	POS view_angles_;
	POS aim_angles_;

	float forward_move_;
	float side_move_;
	float up_move_;
	int buttons_mask_;
};

class Commands
{
	DWORD pad0_; //mysterious hash???

public:
	Commands0X4 cmd_0x4_;

private:
	uint8_t pad1_[46];
};


class VerifiedCommands
{
	Commands commands_;

private:
	DWORD pad0_;
};






class InputCmd
{
public:
	DWORD pCommands_;
	DWORD pVerifiedCommands_;
};

class Input
{
public:

	enum Button : int
	{
		IN_ATTACK = 1 << 0, // Fire weapon
		IN_JUMP = 1 << 1, // Jump
		IN_DUCK = 1 << 2, // Crouch
		IN_FORWARD = 1 << 3, // Walk forward
		IN_BACK = 1 << 4, // Walk backwards
		IN_USE = 1 << 5, // Use (Defuse bomb, etc...)
		IN_CANCEL = 1 << 6, // ??
		IN_LEFT = 1 << 7,// Walk left
		IN_RIGHT = 1 << 8,// Walk right
		IN_MOVELEFT = 1 << 9,// Alias? (not sure)
		IN_MOVERIGHT = 1 << 10,// Alias? (not sure)
		IN_ATTACK2 = 1 << 11,// Secondary fire (Revolver, Glock change fire mode, Famas change fire mode) (not sure)
		IN_RUN = 1 << 12,
		IN_RELOAD = 1 << 13,// Reload weapon
		IN_ALT1 = 1 << 14,
		IN_ALT2 = 1 << 15,
		IN_SCORE = 1 << 16,
		IN_SPEED = 1 << 17,
		IN_WALK = 1 << 18,// Shift
		IN_ZOOM = 1 << 19,// Zoom weapon (not sure)
		IN_WEAPON1 = 1 << 20,
		IN_WEAPON2 = 1 << 21,
		IN_BULLRUSH = 1 << 22
	};

	static constexpr int MULTIPLAYER_BACKUP = 150;


private:
	uint8_t  pad0[0xC];
public:

	bool  bTrackIRAvailable;
	bool  bMouseInitialized;
	bool  bMouseActive;

private:
	uint8_t  pad1[0x9A];
public:

	bool  bCameraInThirdPerson;

private:
	uint8_t  pad2[0x2];
public:

	POS vecCameraOffset;

private:
	uint8_t pad3[0x38];
public:

	InputCmd pCmds;
};



class GlobalVar
{
public:
	float realtime_;
	int simulation_tick_;
	float absolute_frametime_;
	float foot_yaw_;
	float curtime_;
	float frametime_;
	int max_clients_;
	int tick_count_;
	float interval_per_tick_;
	float interpolation_amount_;
};

```

`offsets.h`:

```h
namespace offsets {
	unsigned int   cs_gamerules_data = 0x0;
	unsigned int   m_ArmorValue = 0x117CC;
	unsigned int   m_Collision = 0x320;
	unsigned int   m_CollisionGroup = 0x474;
	unsigned int   m_Local = 0x2FCC;
	unsigned int   m_MoveType = 0x25C;
	unsigned int   m_OriginalOwnerXuidHigh = 0x31D4;
	unsigned int   m_OriginalOwnerXuidLow = 0x31D0;
	unsigned int   m_SurvivalGameRuleDecisionTypes = 0x1328;
	unsigned int   m_SurvivalRules = 0xD00;
	unsigned int   m_aimPunchAngle = 0x303C;
	unsigned int   m_aimPunchAngleVel = 0x3048;
	unsigned int   m_angEyeAnglesX = 0x117D0;
	unsigned int   m_angEyeAnglesY = 0x117D4;
	unsigned int   m_bBombDefused = 0x29C0;
	unsigned int   m_bBombPlanted = 0x9A5;
	unsigned int   m_bBombTicking = 0x2990;
	unsigned int   m_bFreezePeriod = 0x20;
	unsigned int   m_bGunGameImmunity = 0x9990;
	unsigned int   m_bHasDefuser = 0x117DC;
	unsigned int   m_bHasHelmet = 0x117C0;
	unsigned int   m_bInReload = 0x32B5;
	unsigned int   m_bIsDefusing = 0x997C;
	unsigned int   m_bIsQueuedMatchmaking = 0x74;
	unsigned int   m_bIsScoped = 0x9974;
	unsigned int   m_bIsValveDS = 0x7C;
	unsigned int   m_bSpotted = 0x93D;
	unsigned int   m_bSpottedByMask = 0x980;
	unsigned int   m_bStartedArming = 0x3400;
	unsigned int   m_bUseCustomAutoExposureMax = 0x9D9;
	unsigned int   m_bUseCustomAutoExposureMin = 0x9D8;
	unsigned int   m_bUseCustomBloomScale = 0x9DA;
	unsigned int   m_clrRender = 0x70;
	unsigned int   m_dwBoneMatrix = 0x26A8;
	unsigned int   m_fAccuracyPenalty = 0x3340;
	unsigned int   m_fFlags = 0x104;
	unsigned int   m_flC4Blow = 0x29A0;
	unsigned int   m_flCustomAutoExposureMax = 0x9E0;
	unsigned int   m_flCustomAutoExposureMin = 0x9DC;
	unsigned int   m_flCustomBloomScale = 0x9E4;
	unsigned int   m_flDefuseCountDown = 0x29BC;
	unsigned int   m_flDefuseLength = 0x29B8;
	unsigned int   m_flFallbackWear = 0x31E0;
	unsigned int   m_flFlashDuration = 0x10470;
	unsigned int   m_flFlashMaxAlpha = 0x1046C;
	unsigned int   m_flLastBoneSetupTime = 0x2928;
	unsigned int   m_flLowerBodyYawTarget = 0x9ADC;
	unsigned int   m_flNextAttack = 0x2D80;
	unsigned int   m_flNextPrimaryAttack = 0x3248;
	unsigned int   m_flSimulationTime = 0x268;
	unsigned int   m_flTimerLength = 0x29A4;
	unsigned int   m_hActiveWeapon = 0x2F08;
	unsigned int   m_hBombDefuser = 0x29C4;
	unsigned int   m_hMyWeapons = 0x2E08;
	unsigned int   m_hObserverTarget = 0x339C;
	unsigned int   m_hOwner = 0x29DC;
	unsigned int   m_hOwnerEntity = 0x14C;
	unsigned int   m_hViewModel = 0x3308;
	unsigned int   m_iAccountID = 0x2FD8;
	unsigned int   m_iClip1 = 0x3274;
	unsigned int   m_iCompetitiveRanking = 0x1A84;
	unsigned int   m_iCompetitiveWins = 0x1B88;
	unsigned int   m_iCrosshairId = 0x11838;
	unsigned int   m_iDefaultFOV = 0x333C;
	unsigned int   m_iEntityQuality = 0x2FBC;
	unsigned int   m_iFOV = 0x31F4;
	unsigned int   m_iFOVStart = 0x31F8;
	unsigned int   m_iGlowIndex = 0x10488;
	unsigned int   m_iHealth = 0x100;
	unsigned int   m_iItemDefinitionIndex = 0x2FBA;
	unsigned int   m_iItemIDHigh = 0x2FD0;
	unsigned int   m_iMostRecentModelBoneCounter = 0x2690;
	unsigned int   m_iObserverMode = 0x3388;
	unsigned int   m_iShotsFired = 0x103E0;
	unsigned int   m_iState = 0x3268;
	unsigned int   m_iTeamNum = 71376;
	unsigned int   m_lifeState = 0x25F;
	unsigned int   m_nBombSite = 0x2994;
	unsigned int   m_nFallbackPaintKit = 0x31D8;
	unsigned int   m_nFallbackSeed = 0x31DC;
	unsigned int   m_nFallbackStatTrak = 0x31E4;
	unsigned int   m_nForceBone = 0x268C;
	unsigned int   m_nModelIndex = 0x258;
	unsigned int   m_nTickBase = 0x3440;
	unsigned int   m_nViewModelIndex = 0x29D0;
	unsigned int   m_rgflCoordinateFrame = 0x444;
	unsigned int   m_szCustomName = 0x304C;
	unsigned int   m_szLastPlaceName = 0x35C4;
	unsigned int   m_thirdPersonViewAngles = 0x31E8;
	unsigned int   m_vecOrigin = 0x138;
	unsigned int   m_vecVelocity = 0x114;
	unsigned int   m_vecViewOffset = 0x108;
	unsigned int   m_viewPunchAngle = 0x3030;
	unsigned int   m_zoomLevel = 0x33E0;

	unsigned int   anim_overlays = 0x2990;
	unsigned int   clientstate_choked_commands = 0x4D30;
	unsigned int   clientstate_delta_ticks = 0x174;
	unsigned int   clientstate_last_outgoing_command = 0x4D2C;
	unsigned int   clientstate_net_channel = 0x9C;
	unsigned int   convar_name_hash_table = 0x301A0;
	unsigned int   dwClientState = 0x59F194;
	unsigned int   dwClientState_GetLocalPlayer = 0x180;
	unsigned int   dwClientState_IsHLTV = 0x4D48;
	unsigned int   dwClientState_Map = 0x28C;
	unsigned int   dwClientState_MapDirectory = 0x188;
	unsigned int   dwClientState_MaxPlayer = 0x388;
	unsigned int   dwClientState_PlayerInfo = 0x52C0;
	unsigned int   dwClientState_State = 0x108;
	unsigned int   dwClientState_ViewAngles = 0x4D90;
	unsigned int   dwEntityList = 0x4DFFF14;
	unsigned int   dwForceAttack = 0x322DD10;
	unsigned int   dwForceAttack2 = 0x322DD1C;
	unsigned int   dwForceBackward = 0x322DD40;
	unsigned int   dwForceForward = 0x322DD34;
	unsigned int   dwForceJump = 0x52BBC9C;
	unsigned int   dwForceLeft = 0x322DD4C;
	unsigned int   dwForceRight = 0x322DD58;
	unsigned int   dwGameDir = 0x63AD80;
	unsigned int   dwGameRulesProxy = 0x532F4CC;
	unsigned int   dwGetAllClasses = 0xE0BFDC;
	unsigned int   dwGlobalVars = 0x59EE58;
	unsigned int   dwGlowObjectManager = 0x535A9D8;
	unsigned int   dwInput = 0x525D4E8;
	unsigned int   dwInterfaceLinkList = 0x99BC84;
	unsigned int   dwLocalPlayer = 0xDEA964;
	unsigned int   dwMouseEnable = 0x5239148;
	unsigned int   dwMouseEnablePtr = 0x5239118;
	unsigned int   dwPlayerResource = 0x322C0C0;
	unsigned int   dwRadarBase = 0x52369EC;
	unsigned int   dwSensitivity = 0xDEEB80;
	unsigned int   dwSensitivityPtr = 0xDEEB80;
	unsigned int   dwSetClanTag = 0x8DA80;
	unsigned int   dwViewMatrix = 0x4DF0D44;
	unsigned int   dwWeaponTable = 0x525E5C4;
	unsigned int   dwWeaponTableIndex = 0x326C;
	unsigned int   dwYawPtr = 0xDEE910;
	unsigned int   dwZoomSensitivityRatioPtr = 0xDF4380;
	unsigned int   dwbSendPackets = 0xDD072;
	unsigned int   dwppDirect3DDevice9 = 0xA62C0;
	unsigned int   find_hud_element = 0x2ECDFBD0;
	unsigned int   force_update_spectator_glow = 0x3D91CA;
	unsigned int   interface_engine_cvar = 0x3FA9C;
	unsigned int   is_c4_owner = 0x3E69E0;
	unsigned int   m_bDormant = 0xED;
	unsigned int   m_bIsLocalPlayer = 0x3628;
	unsigned int   m_flSpawnTime = 0x103C0;
	unsigned int   m_pStudioHdr = 0x2950;
	unsigned int   m_pitchClassPtr = 0x5239040;
	unsigned int   m_yawClassPtr = 0xDEE910;
	unsigned int   model_ambient_min = 0x5A118C;
	unsigned int   set_abs_angles = 0x1E72D0;
	unsigned int   set_abs_origin = 0x1E7110;





	unsigned int  m_pVerifiedCommands = dwInput + 0xF4 + 0x4;
	unsigned int  m_NetChannel = 0xDCFAF;//m_NetChannel				= Mem::FindSignature("engine.dll",		"\x8B\x8F\x00\x00\x00\x00\x8B\x01\x8B\x40\x18",						"xx????xxxxx",		2) + ClientState;
	unsigned int  m_nOutSequenceNr = 0x18;
}
```