Project Path: arc_gmh5225_Sensum_u573qe58

Source Tree:

```txt
arc_gmh5225_Sensum_u573qe58
├── LICENSE
├── README.md
├── Sensum.sln
├── action.yml
├── dist
│   └── index.js
├── instructions.md
├── lib
│   └── main.js
└── src
    ├── Sensum.vcxproj
    ├── Sensum.vcxproj.filters
    ├── features
    │   ├── Chams.cpp
    │   ├── aimbot.cpp
    │   ├── auto_strafe.cpp
    │   ├── bhop.cpp
    │   ├── bomb_event_info.cpp
    │   ├── buylogger.cpp
    │   ├── color_modulate.cpp
    │   ├── esp.cpp
    │   ├── fast_stop.cpp
    │   ├── features.h
    │   ├── grenade_prediction.cpp
    │   ├── lefthand_knife.cpp
    │   ├── nade_helper.cpp
    │   ├── nade_helper.h
    │   ├── player_infobox.cpp
    │   ├── popflash_helper.cpp
    │   ├── popflash_helper.h
    │   ├── remove_skin_patches.cpp
    │   ├── selfnade.cpp
    │   ├── skins.cpp
    │   ├── thirdperson.cpp
    │   └── visuals.cpp
    ├── helpers
    │   ├── autowall.cpp
    │   ├── autowall.h
    │   ├── console.cpp
    │   ├── console.h
    │   ├── entities.cpp
    │   ├── entities.h
    │   ├── fnv.h
    │   ├── imdraw.cpp
    │   ├── imdraw.h
    │   ├── input.cpp
    │   ├── input.h
    │   ├── math.cpp
    │   ├── math.h
    │   ├── notifies.cpp
    │   ├── notifies.h
    │   ├── utils.cpp
    │   └── utils.h
    ├── hooks
    │   ├── hooked_functions
    │   │   ├── create_move.cpp
    │   │   ├── draw_model_execute.cpp
    │   │   ├── frame_stage_notify.cpp
    │   │   ├── game_event_listener.cpp
    │   │   ├── game_event_listener.h
    │   │   ├── get_color_modulation.cpp
    │   │   ├── is_using_static_debug_prop_modes.cpp
    │   │   ├── override_view.cpp
    │   │   ├── paint_traverse.cpp
    │   │   ├── present.cpp
    │   │   ├── reset.cpp
    │   │   └── sequence.cpp
    │   ├── hooks.cpp
    │   └── hooks.h
    ├── imgui
    │   ├── directx9
    │   │   ├── imgui_impl_dx9.cpp
    │   │   └── imgui_impl_dx9.h
    │   ├── imgui.cpp
    │   ├── imgui.h
    │   ├── imgui_draw.cpp
    │   ├── imgui_internal.h
    │   ├── stb_rect_pack.h
    │   ├── stb_textedit.h
    │   └── stb_truetype.h
    ├── jsoncpp
    │   ├── json-forwards.h
    │   ├── json.h
    │   └── jsoncpp.cpp
    ├── main.cpp
    ├── minhook
    │   ├── buffer.c
    │   ├── buffer.h
    │   ├── hde
    │   │   ├── hde32.c
    │   │   ├── hde32.h
    │   │   ├── pstdint.h
    │   │   └── table32.h
    │   ├── hook.c
    │   ├── minhook.h
    │   ├── trampoline.c
    │   └── trampoline.h
    ├── render
    │   ├── fonts
    │   │   ├── droidsans.hpp
    │   │   └── undefeated.hpp
    │   ├── menu.cpp
    │   ├── menu_strings.h
    │   ├── render.cpp
    │   ├── render.h
    │   ├── spectators.cpp
    │   ├── tabs
    │   │   ├── aimbot_tab.cpp
    │   │   ├── colors_tab.cpp
    │   │   ├── configs_tab.cpp
    │   │   ├── misc_tab.cpp
    │   │   ├── players_tab.cpp
    │   │   ├── skins_tab.cpp
    │   │   └── visuals_tab.cpp
    │   └── timers.cpp
    ├── security
    │   ├── importer.h
    │   └── xor.h
    ├── settings
    │   ├── config.cpp
    │   ├── config.h
    │   ├── globals.cpp
    │   ├── globals.h
    │   ├── options.cpp
    │   ├── options.hpp
    │   ├── settings.cpp
    │   └── settings.h
    └── valve_sdk
        ├── classids.cpp
        ├── classids.h
        ├── csgostructs.cpp
        ├── csgostructs.hpp
        ├── interfaces
        │   ├── CClientState.h
        │   ├── CFireBullets.h
        │   ├── CGlobalVarsBase.h
        │   ├── CGlowObjectManager.h
        │   ├── CHud.h
        │   ├── CHudChat.h
        │   ├── CInput.hpp
        │   ├── IAppSystem.h
        │   ├── IBaseClientDLL.h
        │   ├── IClientEntity.hpp
        │   ├── IClientEntityList.hpp
        │   ├── IClientMode.hpp
        │   ├── IClientNetworkable.hpp
        │   ├── IClientRenderable.hpp
        │   ├── IClientThinkable.hpp
        │   ├── IClientUnknown.hpp
        │   ├── IConVar.hpp
        │   ├── ICvar.h
        │   ├── IEngineSound.hpp
        │   ├── IEngineTrace.hpp
        │   ├── IFileSystem.h
        │   ├── IGameEvent.hpp
        │   ├── IInputSystem.h
        │   ├── ILocalize.h
        │   ├── IMDLCache.hpp
        │   ├── IMaterial.h
        │   ├── IMaterialSystem.hpp
        │   ├── IMaterialVar.h
        │   ├── IMemAlloc.h
        │   ├── IMoveHelper.hpp
        │   ├── INetMessage.h
        │   ├── IPanel.hpp
        │   ├── IPhysics.hpp
        │   ├── IPrediction.hpp
        │   ├── IRefCounted.h
        │   ├── IStudioRender.h
        │   ├── ISurface.h
        │   ├── IVDebugOverlay.h
        │   ├── IVEngineClient.hpp
        │   ├── IVModelInfo.h
        │   ├── IVModelRender.h
        │   ├── IVRenderView.h
        │   ├── IViewRender.hpp
        │   ├── IViewRenderBeams.h
        │   └── ServerClass.h
        ├── kit_parser.cpp
        ├── kit_parser.hpp
        ├── math
        │   ├── QAngle.hpp
        │   ├── VMatrix.cpp
        │   ├── VMatrix.hpp
        │   ├── Vectors.cpp
        │   └── Vectors.hpp
        ├── misc
        │   ├── BaseHandle.hpp
        │   ├── CUserCmd.hpp
        │   ├── ClientClass.hpp
        │   ├── Color.cpp
        │   ├── Color.hpp
        │   ├── Convar.cpp
        │   ├── Convar.hpp
        │   ├── EHandle.hpp
        │   ├── Enums.hpp
        │   ├── IHandleEntity.hpp
        │   ├── Recv.hpp
        │   ├── Studio.hpp
        │   ├── UtlBuffer.cpp
        │   ├── UtlBuffer.hpp
        │   ├── UtlMemory.hpp
        │   ├── UtlString.cpp
        │   ├── UtlString.hpp
        │   ├── UtlVector.hpp
        │   ├── characterset.cpp
        │   ├── characterset.hpp
        │   ├── checksum_crc.cpp
        │   ├── checksum_crc.hpp
        │   ├── platform.hpp
        │   └── vfunc.hpp
        ├── netvars.cpp
        ├── netvars.hpp
        ├── patterns.cpp
        ├── patterns.h
        ├── sdk.cpp
        ├── sdk.hpp
        └── steam.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2019-2022 Martin Janás (MartiNJ409)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
## Sensum - Internal legit cheat [**Discord**](https://discord.gg/nnHPMf6W5u)
[**List of features**](https://pastebin.com/twMkYr0q) | ***Check the Discussions tab to request a feature.***

Click on ***[this](instructions.md)*** if You are new to compiling cheats.

**Further optimizations:**<br>
This project is using the SSE2 instructions set by default.<br>
If your cpu supports AVX, AVX2 or AVX512 you can enable it in the project settings under:<br> **"C++ -> Code Generation"**, to gain more performance.

**FAQ:**
- > Config location?
  -- C:\Sensum\configs    
- > Low fps?
    -- Compile the cheat in release x86
    
 [**See more menu tabs here**](https://imgur.com/a/tuDbTXH)
    
![Screenshot](https://i.imgur.com/A1agCyT.png)





```

`Sensum.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.28621.142
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Sensum", "src\Sensum.vcxproj", "{F3E42845-8D56-4BB3-821D-8163AB1337F0}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{F3E42845-8D56-4BB3-821D-8163AB1337F0}.Debug|x86.ActiveCfg = Debug|Win32
		{F3E42845-8D56-4BB3-821D-8163AB1337F0}.Debug|x86.Build.0 = Debug|Win32
		{F3E42845-8D56-4BB3-821D-8163AB1337F0}.Release|x86.ActiveCfg = Release|Win32
		{F3E42845-8D56-4BB3-821D-8163AB1337F0}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {67674A94-B2CB-462F-9E02-1A494C848E75}
	EndGlobalSection
EndGlobal

```

`action.yml`:

```yml
name: Issue matching auto-closer
description: Automatically close issues based on regexs matching.
author: arkon
branding:
  icon: alert-circle
  color: red
inputs:
  repo-token:
    required: true
    description: GitHub token
  rules:
    required: true
    description: |
      A JSON-compliant string containing a list of rules, where a rule consists of:
      {
        type: 'title' | 'body';  // Part to run regex against.
        regex: string;           // Pattern which if matched closes the issue.
        message: string;         // Message to post when closing the issue.
      }
runs:
  using: node12
  main: dist/index.js
```

`dist/index.js`:

```js
module.exports =
/******/ (function(modules, runtime) { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete installedModules[moduleId];
/******/ 		}
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	__webpack_require__.ab = __dirname + "/";
/******/
/******/ 	// the startup function
/******/ 	function startup() {
/******/ 		// Load entry module and return exports
/******/ 		return __webpack_require__(131);
/******/ 	};
/******/
/******/ 	// run startup
/******/ 	return startup();
/******/ })
/************************************************************************/
/******/ ({

/***/ 11:
/***/ (function(module) {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ 16:
/***/ (function(module) {

module.exports = require("tls");

/***/ }),

/***/ 18:
/***/ (function(module) {

module.exports = eval("require")("encoding");


/***/ }),

/***/ 49:
/***/ (function(module, __unusedexports, __webpack_require__) {

var wrappy = __webpack_require__(11)
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ 82:
/***/ (function(__unusedmodule, exports) {

"use strict";

// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Sanitizes an input into a string so it can be passed into issueCommand safely
 * @param input input to sanitize into a string
 */
function toCommandValue(input) {
    if (input === null || input === undefined) {
        return '';
    }
    else if (typeof input === 'string' || input instanceof String) {
        return input;
    }
    return JSON.stringify(input);
}
exports.toCommandValue = toCommandValue;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 87:
/***/ (function(module) {

module.exports = require("os");

/***/ }),

/***/ 102:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

// For internal use, subject to change.
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
// We use any as a valid input type
/* eslint-disable @typescript-eslint/no-explicit-any */
const fs = __importStar(__webpack_require__(747));
const os = __importStar(__webpack_require__(87));
const utils_1 = __webpack_require__(82);
function issueCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
    }
    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
        encoding: 'utf8'
    });
}
exports.issueCommand = issueCommand;
//# sourceMappingURL=file-command.js.map

/***/ }),

/***/ 127:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApiBaseUrl = exports.getProxyAgent = exports.getAuthString = void 0;
const httpClient = __importStar(__webpack_require__(539));
function getAuthString(token, options) {
    if (!token && !options.auth) {
        throw new Error('Parameter token or opts.auth is required');
    }
    else if (token && options.auth) {
        throw new Error('Parameters token and opts.auth may not both be specified');
    }
    return typeof options.auth === 'string' ? options.auth : `token ${token}`;
}
exports.getAuthString = getAuthString;
function getProxyAgent(destinationUrl) {
    const hc = new httpClient.HttpClient();
    return hc.getAgent(destinationUrl);
}
exports.getProxyAgent = getProxyAgent;
function getApiBaseUrl() {
    return process.env['GITHUB_API_URL'] || 'https://api.github.com';
}
exports.getApiBaseUrl = getApiBaseUrl;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 131:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const core = __importStar(__webpack_require__(470));
const github = __importStar(__webpack_require__(469));
const ALLOWED_ACTIONS = ['opened', 'edited', 'reopened'];
function run() {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const rules = core.getInput('rules', { required: true });
            // Get client and context
            const client = github.getOctokit(core.getInput('repo-token', { required: true }));
            const context = github.context;
            const payload = context.payload;
            // Do nothing if it's wasn't a relevant action or it's not an issue
            if (ALLOWED_ACTIONS.indexOf(payload.action) === -1 || !payload.issue) {
                return;
            }
            if (!payload.sender) {
                throw new Error('Internal error, no sender provided by GitHub');
            }
            const issue = context.issue;
            const parsedRules = JSON.parse(rules);
            const results = parsedRules
                .map(rule => {
                var _a, _b;
                const text = rule.type === 'title' ? (_a = payload === null || payload === void 0 ? void 0 : payload.issue) === null || _a === void 0 ? void 0 : _a.title : (_b = payload === null || payload === void 0 ? void 0 : payload.issue) === null || _b === void 0 ? void 0 : _b.body;
                const regexMatches = check(rule.regex, text);
                if (regexMatches) {
                    core.info(`Failed: ${rule.message}`);
                    return rule.message;
                }
                else {
                    core.info(`Passed: ${rule.message}`);
                }
            })
                .filter(Boolean);
            if (results.length > 0) {
                // Comment and close if failed any rule
                const infoMessage = payload.action === 'opened'
                    ? 'automatically closed'
                    : 'not reopened';
                const message = [`@\${issue.user.login} this issue was ${infoMessage} because:\n`, ...results].join('\n- ');
                yield client.issues.createComment({
                    owner: issue.owner,
                    repo: issue.repo,
                    issue_number: issue.number,
                    body: evalTemplate(message, payload)
                });
                yield client.issues.update({
                    owner: issue.owner,
                    repo: issue.repo,
                    issue_number: issue.number,
                    state: 'closed'
                });
            }
            else if (payload.action === 'edited') {
                // Re-open if edited issue is valid
                yield client.issues.update({
                    owner: issue.owner,
                    repo: issue.repo,
                    issue_number: issue.number,
                    state: 'open'
                });
            }
        }
        catch (error) {
            core.setFailed(error.message);
        }
    });
}
function check(patternString, text) {
    const pattern = new RegExp(patternString);
    if (text === null || text === void 0 ? void 0 : text.match(pattern)) {
        return true;
    }
    else {
        return false;
    }
}
function evalTemplate(template, params) {
    return Function(...Object.keys(params), `return \`${template}\``)(...Object.values(params));
}
run();


/***/ }),

/***/ 141:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";


var net = __webpack_require__(631);
var tls = __webpack_require__(16);
var http = __webpack_require__(605);
var https = __webpack_require__(211);
var events = __webpack_require__(614);
var assert = __webpack_require__(357);
var util = __webpack_require__(669);


exports.httpOverHttp = httpOverHttp;
exports.httpsOverHttp = httpsOverHttp;
exports.httpOverHttps = httpOverHttps;
exports.httpsOverHttps = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent;
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent;
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port, localAddress) {
    var options = toOptions(host, port, localAddress);
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === options.host && pending.port === options.port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
  var self = this;
  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push(options);
    return;
  }

  // If we are under maxSockets create a new one.
  self.createSocket(options, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    req.onSocket(socket);

    function onFree() {
      self.emit('free', socket, options);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions, {
    method: 'CONNECT',
    path: options.host + ':' + options.port,
    agent: false,
    headers: {
      host: options.host + ':' + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        new Buffer(connectOptions.proxyAuth).toString('base64');
  }

  debug('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode !== 200) {
      debug('tunneling socket could not be established, statusCode=%d',
        res.statusCode);
      socket.destroy();
      var error = new Error('tunneling socket could not be established, ' +
        'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug('got illegal response body from proxy');
      socket.destroy();
      var error = new Error('got illegal response body from proxy');
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
      return;
    }
    debug('tunneling connection has established');
    self.sockets[self.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug('tunneling socket could not be established, cause=%s\n',
          cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' +
                          'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket)
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(pending, function(socket) {
      pending.request.onSocket(socket);
    });
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    var hostHeader = options.request.getHeader('host');
    var tlsOptions = mergeOptions({}, self.options, {
      socket: socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host
    });

    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, tlsOptions);
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function toOptions(host, port, localAddress) {
  if (typeof host === 'string') { // since v0.10
    return {
      host: host,
      port: port,
      localAddress: localAddress
    };
  }
  return host; // for v0.11 or later
}

function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}


var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  }
} else {
  debug = function() {};
}
exports.debug = debug; // for test


/***/ }),

/***/ 211:
/***/ (function(module) {

module.exports = require("https");

/***/ }),

/***/ 262:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.Context = void 0;
const fs_1 = __webpack_require__(747);
const os_1 = __webpack_require__(87);
class Context {
    /**
     * Hydrate the context from the environment
     */
    constructor() {
        this.payload = {};
        if (process.env.GITHUB_EVENT_PATH) {
            if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
                this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, { encoding: 'utf8' }));
            }
            else {
                const path = process.env.GITHUB_EVENT_PATH;
                process.stdout.write(`GITHUB_EVENT_PATH ${path} does not exist${os_1.EOL}`);
            }
        }
        this.eventName = process.env.GITHUB_EVENT_NAME;
        this.sha = process.env.GITHUB_SHA;
        this.ref = process.env.GITHUB_REF;
        this.workflow = process.env.GITHUB_WORKFLOW;
        this.action = process.env.GITHUB_ACTION;
        this.actor = process.env.GITHUB_ACTOR;
        this.job = process.env.GITHUB_JOB;
        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
    }
    get issue() {
        const payload = this.payload;
        return Object.assign(Object.assign({}, this.repo), { number: (payload.issue || payload.pull_request || payload).number });
    }
    get repo() {
        if (process.env.GITHUB_REPOSITORY) {
            const [owner, repo] = process.env.GITHUB_REPOSITORY.split('/');
            return { owner, repo };
        }
        if (this.payload.repository) {
            return {
                owner: this.payload.repository.owner.login,
                repo: this.payload.repository.name
            };
        }
        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
}
exports.Context = Context;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ 280:
/***/ (function(module) {

module.exports = register;

function register(state, name, method, options) {
  if (typeof method !== "function") {
    throw new Error("method for before hook must be a function");
  }

  if (!options) {
    options = {};
  }

  if (Array.isArray(name)) {
    return name.reverse().reduce(function (callback, name) {
      return register.bind(null, state, name, callback, options);
    }, method)();
  }

  return Promise.resolve().then(function () {
    if (!state.registry[name]) {
      return method(options);
    }

    return state.registry[name].reduce(function (method, registered) {
      return registered.hook.bind(null, method, options);
    }, method)();
  });
}


/***/ }),

/***/ 299:
/***/ (function(__unusedmodule, exports) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

const VERSION = "2.11.0";

/**
 * Some “list” response that can be paginated have a different response structure
 *
 * They have a `total_count` key in the response (search also has `incomplete_results`,
 * /installation/repositories also has `repository_selection`), as well as a key with
 * the list of the items which name varies from endpoint to endpoint.
 *
 * Octokit normalizes these responses so that paginated results are always returned following
 * the same structure. One challenge is that if the list response has only one page, no Link
 * header is provided, so this header alone is not sufficient to check wether a response is
 * paginated or not.
 *
 * We check if a "total_count" key is present in the response data, but also make sure that
 * a "url" property is not, as the "Get the combined status for a specific ref" endpoint would
 * otherwise match: https://developer.github.com/v3/repos/statuses/#get-the-combined-status-for-a-specific-ref
 */
function normalizePaginatedListResponse(response) {
  const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
  if (!responseNeedsNormalization) return response; // keep the additional properties intact as there is currently no other way
  // to retrieve the same information.

  const incompleteResults = response.data.incomplete_results;
  const repositorySelection = response.data.repository_selection;
  const totalCount = response.data.total_count;
  delete response.data.incomplete_results;
  delete response.data.repository_selection;
  delete response.data.total_count;
  const namespaceKey = Object.keys(response.data)[0];
  const data = response.data[namespaceKey];
  response.data = data;

  if (typeof incompleteResults !== "undefined") {
    response.data.incomplete_results = incompleteResults;
  }

  if (typeof repositorySelection !== "undefined") {
    response.data.repository_selection = repositorySelection;
  }

  response.data.total_count = totalCount;
  return response;
}

function iterator(octokit, route, parameters) {
  const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
  const requestMethod = typeof route === "function" ? route : octokit.request;
  const method = options.method;
  const headers = options.headers;
  let url = options.url;
  return {
    [Symbol.asyncIterator]: () => ({
      async next() {
        if (!url) return {
          done: true
        };
        const response = await requestMethod({
          method,
          url,
          headers
        });
        const normalizedResponse = normalizePaginatedListResponse(response); // `response.headers.link` format:
        // '<https://api.github.com/users/aseemk/followers?page=2>; rel="next", <https://api.github.com/users/aseemk/followers?page=2>; rel="last"'
        // sets `url` to undefined if "next" URL is not present or `link` header is not set

        url = ((normalizedResponse.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
        return {
          value: normalizedResponse
        };
      }

    })
  };
}

function paginate(octokit, route, parameters, mapFn) {
  if (typeof parameters === "function") {
    mapFn = parameters;
    parameters = undefined;
  }

  return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
}

function gather(octokit, results, iterator, mapFn) {
  return iterator.next().then(result => {
    if (result.done) {
      return results;
    }

    let earlyExit = false;

    function done() {
      earlyExit = true;
    }

    results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);

    if (earlyExit) {
      return results;
    }

    return gather(octokit, results, iterator, mapFn);
  });
}

const composePaginateRest = Object.assign(paginate, {
  iterator
});

/**
 * @param octokit Octokit instance
 * @param options Options passed to Octokit constructor
 */

function paginateRest(octokit) {
  return {
    paginate: Object.assign(paginate.bind(null, octokit), {
      iterator: iterator.bind(null, octokit)
    })
  };
}
paginateRest.VERSION = VERSION;

exports.composePaginateRest = composePaginateRest;
exports.paginateRest = paginateRest;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 356:
/***/ (function(__unusedmodule, exports) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */

function isObject(o) {
  return Object.prototype.toString.call(o) === '[object Object]';
}

function isPlainObject(o) {
  var ctor,prot;

  if (isObject(o) === false) return false;

  // If has modified constructor
  ctor = o.constructor;
  if (ctor === undefined) return true;

  // If has modified prototype
  prot = ctor.prototype;
  if (isObject(prot) === false) return false;

  // If constructor does not have an Object-specific method
  if (prot.hasOwnProperty('isPrototypeOf') === false) {
    return false;
  }

  // Most likely a plain Object
  return true;
}

exports.isPlainObject = isPlainObject;


/***/ }),

/***/ 357:
/***/ (function(module) {

module.exports = require("assert");

/***/ }),

/***/ 385:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var isPlainObject = __webpack_require__(356);
var universalUserAgent = __webpack_require__(796);

function lowercaseKeys(object) {
  if (!object) {
    return {};
  }

  return Object.keys(object).reduce((newObj, key) => {
    newObj[key.toLowerCase()] = object[key];
    return newObj;
  }, {});
}

function mergeDeep(defaults, options) {
  const result = Object.assign({}, defaults);
  Object.keys(options).forEach(key => {
    if (isPlainObject.isPlainObject(options[key])) {
      if (!(key in defaults)) Object.assign(result, {
        [key]: options[key]
      });else result[key] = mergeDeep(defaults[key], options[key]);
    } else {
      Object.assign(result, {
        [key]: options[key]
      });
    }
  });
  return result;
}

function removeUndefinedProperties(obj) {
  for (const key in obj) {
    if (obj[key] === undefined) {
      delete obj[key];
    }
  }

  return obj;
}

function merge(defaults, route, options) {
  if (typeof route === "string") {
    let [method, url] = route.split(" ");
    options = Object.assign(url ? {
      method,
      url
    } : {
      url: method
    }, options);
  } else {
    options = Object.assign({}, route);
  } // lowercase header names before merging with defaults to avoid duplicates


  options.headers = lowercaseKeys(options.headers); // remove properties with undefined values before merging

  removeUndefinedProperties(options);
  removeUndefinedProperties(options.headers);
  const mergedOptions = mergeDeep(defaults || {}, options); // mediaType.previews arrays are merged, instead of overwritten

  if (defaults && defaults.mediaType.previews.length) {
    mergedOptions.mediaType.previews = defaults.mediaType.previews.filter(preview => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
  }

  mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map(preview => preview.replace(/-preview/, ""));
  return mergedOptions;
}

function addQueryParameters(url, parameters) {
  const separator = /\?/.test(url) ? "&" : "?";
  const names = Object.keys(parameters);

  if (names.length === 0) {
    return url;
  }

  return url + separator + names.map(name => {
    if (name === "q") {
      return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
    }

    return `${name}=${encodeURIComponent(parameters[name])}`;
  }).join("&");
}

const urlVariableRegex = /\{[^}]+\}/g;

function removeNonChars(variableName) {
  return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
}

function extractUrlVariableNames(url) {
  const matches = url.match(urlVariableRegex);

  if (!matches) {
    return [];
  }

  return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
}

function omit(object, keysToOmit) {
  return Object.keys(object).filter(option => !keysToOmit.includes(option)).reduce((obj, key) => {
    obj[key] = object[key];
    return obj;
  }, {});
}

// Based on https://github.com/bramstein/url-template, licensed under BSD
// TODO: create separate package.
//
// Copyright (c) 2012-2014, Bram Stein
// All rights reserved.
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
//  1. Redistributions of source code must retain the above copyright
//     notice, this list of conditions and the following disclaimer.
//  2. Redistributions in binary form must reproduce the above copyright
//     notice, this list of conditions and the following disclaimer in the
//     documentation and/or other materials provided with the distribution.
//  3. The name of the author may not be used to endorse or promote products
//     derived from this software without specific prior written permission.
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
// EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
// INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
// BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
// NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* istanbul ignore file */
function encodeReserved(str) {
  return str.split(/(%[0-9A-Fa-f]{2})/g).map(function (part) {
    if (!/%[0-9A-Fa-f]/.test(part)) {
      part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
    }

    return part;
  }).join("");
}

function encodeUnreserved(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
    return "%" + c.charCodeAt(0).toString(16).toUpperCase();
  });
}

function encodeValue(operator, value, key) {
  value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);

  if (key) {
    return encodeUnreserved(key) + "=" + value;
  } else {
    return value;
  }
}

function isDefined(value) {
  return value !== undefined && value !== null;
}

function isKeyOperator(operator) {
  return operator === ";" || operator === "&" || operator === "?";
}

function getValues(context, operator, key, modifier) {
  var value = context[key],
      result = [];

  if (isDefined(value) && value !== "") {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      value = value.toString();

      if (modifier && modifier !== "*") {
        value = value.substring(0, parseInt(modifier, 10));
      }

      result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
    } else {
      if (modifier === "*") {
        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function (value) {
            result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
          });
        } else {
          Object.keys(value).forEach(function (k) {
            if (isDefined(value[k])) {
              result.push(encodeValue(operator, value[k], k));
            }
          });
        }
      } else {
        const tmp = [];

        if (Array.isArray(value)) {
          value.filter(isDefined).forEach(function (value) {
            tmp.push(encodeValue(operator, value));
          });
        } else {
          Object.keys(value).forEach(function (k) {
            if (isDefined(value[k])) {
              tmp.push(encodeUnreserved(k));
              tmp.push(encodeValue(operator, value[k].toString()));
            }
          });
        }

        if (isKeyOperator(operator)) {
          result.push(encodeUnreserved(key) + "=" + tmp.join(","));
        } else if (tmp.length !== 0) {
          result.push(tmp.join(","));
        }
      }
    }
  } else {
    if (operator === ";") {
      if (isDefined(value)) {
        result.push(encodeUnreserved(key));
      }
    } else if (value === "" && (operator === "&" || operator === "?")) {
      result.push(encodeUnreserved(key) + "=");
    } else if (value === "") {
      result.push("");
    }
  }

  return result;
}

function parseUrl(template) {
  return {
    expand: expand.bind(null, template)
  };
}

function expand(template, context) {
  var operators = ["+", "#", ".", "/", ";", "?", "&"];
  return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (_, expression, literal) {
    if (expression) {
      let operator = "";
      const values = [];

      if (operators.indexOf(expression.charAt(0)) !== -1) {
        operator = expression.charAt(0);
        expression = expression.substr(1);
      }

      expression.split(/,/g).forEach(function (variable) {
        var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
        values.push(getValues(context, operator, tmp[1], tmp[2] || tmp[3]));
      });

      if (operator && operator !== "+") {
        var separator = ",";

        if (operator === "?") {
          separator = "&";
        } else if (operator !== "#") {
          separator = operator;
        }

        return (values.length !== 0 ? operator : "") + values.join(separator);
      } else {
        return values.join(",");
      }
    } else {
      return encodeReserved(literal);
    }
  });
}

function parse(options) {
  // https://fetch.spec.whatwg.org/#methods
  let method = options.method.toUpperCase(); // replace :varname with {varname} to make it RFC 6570 compatible

  let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
  let headers = Object.assign({}, options.headers);
  let body;
  let parameters = omit(options, ["method", "baseUrl", "url", "headers", "request", "mediaType"]); // extract variable names from URL to calculate remaining variables later

  const urlVariableNames = extractUrlVariableNames(url);
  url = parseUrl(url).expand(parameters);

  if (!/^http/.test(url)) {
    url = options.baseUrl + url;
  }

  const omittedParameters = Object.keys(options).filter(option => urlVariableNames.includes(option)).concat("baseUrl");
  const remainingParameters = omit(parameters, omittedParameters);
  const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);

  if (!isBinaryRequest) {
    if (options.mediaType.format) {
      // e.g. application/vnd.github.v3+json => application/vnd.github.v3.raw
      headers.accept = headers.accept.split(/,/).map(preview => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
    }

    if (options.mediaType.previews.length) {
      const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
      headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map(preview => {
        const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
        return `application/vnd.github.${preview}-preview${format}`;
      }).join(",");
    }
  } // for GET/HEAD requests, set URL query parameters from remaining parameters
  // for PATCH/POST/PUT/DELETE requests, set request body from remaining parameters


  if (["GET", "HEAD"].includes(method)) {
    url = addQueryParameters(url, remainingParameters);
  } else {
    if ("data" in remainingParameters) {
      body = remainingParameters.data;
    } else {
      if (Object.keys(remainingParameters).length) {
        body = remainingParameters;
      } else {
        headers["content-length"] = 0;
      }
    }
  } // default content-type for JSON if body is set


  if (!headers["content-type"] && typeof body !== "undefined") {
    headers["content-type"] = "application/json; charset=utf-8";
  } // GitHub expects 'content-length: 0' header for PUT/PATCH requests without body.
  // fetch does not allow to set `content-length` header, but we can set body to an empty string


  if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
    body = "";
  } // Only return body/request keys if present


  return Object.assign({
    method,
    url,
    headers
  }, typeof body !== "undefined" ? {
    body
  } : null, options.request ? {
    request: options.request
  } : null);
}

function endpointWithDefaults(defaults, route, options) {
  return parse(merge(defaults, route, options));
}

function withDefaults(oldDefaults, newDefaults) {
  const DEFAULTS = merge(oldDefaults, newDefaults);
  const endpoint = endpointWithDefaults.bind(null, DEFAULTS);
  return Object.assign(endpoint, {
    DEFAULTS,
    defaults: withDefaults.bind(null, DEFAULTS),
    merge: merge.bind(null, DEFAULTS),
    parse
  });
}

const VERSION = "6.0.11";

const userAgent = `octokit-endpoint.js/${VERSION} ${universalUserAgent.getUserAgent()}`; // DEFAULTS has all properties set that EndpointOptions has, except url.
// So we use RequestParameters and add method as additional required property.

const DEFAULTS = {
  method: "GET",
  baseUrl: "https://api.github.com",
  headers: {
    accept: "application/vnd.github.v3+json",
    "user-agent": userAgent
  },
  mediaType: {
    format: "",
    previews: []
  }
};

const endpoint = withDefaults(null, DEFAULTS);

exports.endpoint = endpoint;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 413:
/***/ (function(module, __unusedexports, __webpack_require__) {

module.exports = __webpack_require__(141);


/***/ }),

/***/ 431:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const os = __importStar(__webpack_require__(87));
const utils_1 = __webpack_require__(82);
/**
 * Commands
 *
 * Command Format:
 *   ::name key=value,key=value::message
 *
 * Examples:
 *   ::warning::This is the message
 *   ::set-env name=MY_VAR::some value
 */
function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
}
exports.issueCommand = issueCommand;
function issue(name, message = '') {
    issueCommand(name, {}, message);
}
exports.issue = issue;
const CMD_STRING = '::';
class Command {
    constructor(command, properties, message) {
        if (!command) {
            command = 'missing.command';
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
    }
    toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
            cmdStr += ' ';
            let first = true;
            for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                    const val = this.properties[key];
                    if (val) {
                        if (first) {
                            first = false;
                        }
                        else {
                            cmdStr += ',';
                        }
                        cmdStr += `${key}=${escapeProperty(val)}`;
                    }
                }
            }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
    }
}
function escapeData(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A');
}
function escapeProperty(s) {
    return utils_1.toCommandValue(s)
        .replace(/%/g, '%25')
        .replace(/\r/g, '%0D')
        .replace(/\n/g, '%0A')
        .replace(/:/g, '%3A')
        .replace(/,/g, '%2C');
}
//# sourceMappingURL=command.js.map

/***/ }),

/***/ 448:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var universalUserAgent = __webpack_require__(796);
var beforeAfterHook = __webpack_require__(523);
var request = __webpack_require__(753);
var graphql = __webpack_require__(898);
var authToken = __webpack_require__(813);

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

const VERSION = "3.2.5";

class Octokit {
  constructor(options = {}) {
    const hook = new beforeAfterHook.Collection();
    const requestDefaults = {
      baseUrl: request.request.endpoint.DEFAULTS.baseUrl,
      headers: {},
      request: Object.assign({}, options.request, {
        hook: hook.bind(null, "request")
      }),
      mediaType: {
        previews: [],
        format: ""
      }
    }; // prepend default user agent with `options.userAgent` if set

    requestDefaults.headers["user-agent"] = [options.userAgent, `octokit-core.js/${VERSION} ${universalUserAgent.getUserAgent()}`].filter(Boolean).join(" ");

    if (options.baseUrl) {
      requestDefaults.baseUrl = options.baseUrl;
    }

    if (options.previews) {
      requestDefaults.mediaType.previews = options.previews;
    }

    if (options.timeZone) {
      requestDefaults.headers["time-zone"] = options.timeZone;
    }

    this.request = request.request.defaults(requestDefaults);
    this.graphql = graphql.withCustomRequest(this.request).defaults(requestDefaults);
    this.log = Object.assign({
      debug: () => {},
      info: () => {},
      warn: console.warn.bind(console),
      error: console.error.bind(console)
    }, options.log);
    this.hook = hook; // (1) If neither `options.authStrategy` nor `options.auth` are set, the `octokit` instance
    //     is unauthenticated. The `this.auth()` method is a no-op and no request hook is registered.
    // (2) If only `options.auth` is set, use the default token authentication strategy.
    // (3) If `options.authStrategy` is set then use it and pass in `options.auth`. Always pass own request as many strategies accept a custom request instance.
    // TODO: type `options.auth` based on `options.authStrategy`.

    if (!options.authStrategy) {
      if (!options.auth) {
        // (1)
        this.auth = async () => ({
          type: "unauthenticated"
        });
      } else {
        // (2)
        const auth = authToken.createTokenAuth(options.auth); // @ts-ignore  ¯\_(ツ)_/¯

        hook.wrap("request", auth.hook);
        this.auth = auth;
      }
    } else {
      const {
        authStrategy
      } = options,
            otherOptions = _objectWithoutProperties(options, ["authStrategy"]);

      const auth = authStrategy(Object.assign({
        request: this.request,
        log: this.log,
        // we pass the current octokit instance as well as its constructor options
        // to allow for authentication strategies that return a new octokit instance
        // that shares the same internal state as the current one. The original
        // requirement for this was the "event-octokit" authentication strategy
        // of https://github.com/probot/octokit-auth-probot.
        octokit: this,
        octokitOptions: otherOptions
      }, options.auth)); // @ts-ignore  ¯\_(ツ)_/¯

      hook.wrap("request", auth.hook);
      this.auth = auth;
    } // apply plugins
    // https://stackoverflow.com/a/16345172


    const classConstructor = this.constructor;
    classConstructor.plugins.forEach(plugin => {
      Object.assign(this, plugin(this, options));
    });
  }

  static defaults(defaults) {
    const OctokitWithDefaults = class extends this {
      constructor(...args) {
        const options = args[0] || {};

        if (typeof defaults === "function") {
          super(defaults(options));
          return;
        }

        super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
          userAgent: `${options.userAgent} ${defaults.userAgent}`
        } : null));
      }

    };
    return OctokitWithDefaults;
  }
  /**
   * Attach a plugin (or many) to your Octokit instance.
   *
   * @example
   * const API = Octokit.plugin(plugin1, plugin2, plugin3, ...)
   */


  static plugin(...newPlugins) {
    var _a;

    const currentPlugins = this.plugins;
    const NewOctokit = (_a = class extends this {}, _a.plugins = currentPlugins.concat(newPlugins.filter(plugin => !currentPlugins.includes(plugin))), _a);
    return NewOctokit;
  }

}
Octokit.VERSION = VERSION;
Octokit.plugins = [];

exports.Octokit = Octokit;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 454:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var Stream = _interopDefault(__webpack_require__(794));
var http = _interopDefault(__webpack_require__(605));
var Url = _interopDefault(__webpack_require__(835));
var https = _interopDefault(__webpack_require__(211));
var zlib = _interopDefault(__webpack_require__(761));

// Based on https://github.com/tmpvar/jsdom/blob/aa85b2abf07766ff7bf5c1f6daafb3726f2f2db5/lib/jsdom/living/blob.js

// fix for "Readable" isn't a named export issue
const Readable = Stream.Readable;

const BUFFER = Symbol('buffer');
const TYPE = Symbol('type');

class Blob {
	constructor() {
		this[TYPE] = '';

		const blobParts = arguments[0];
		const options = arguments[1];

		const buffers = [];
		let size = 0;

		if (blobParts) {
			const a = blobParts;
			const length = Number(a.length);
			for (let i = 0; i < length; i++) {
				const element = a[i];
				let buffer;
				if (element instanceof Buffer) {
					buffer = element;
				} else if (ArrayBuffer.isView(element)) {
					buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
				} else if (element instanceof ArrayBuffer) {
					buffer = Buffer.from(element);
				} else if (element instanceof Blob) {
					buffer = element[BUFFER];
				} else {
					buffer = Buffer.from(typeof element === 'string' ? element : String(element));
				}
				size += buffer.length;
				buffers.push(buffer);
			}
		}

		this[BUFFER] = Buffer.concat(buffers);

		let type = options && options.type !== undefined && String(options.type).toLowerCase();
		if (type && !/[^\u0020-\u007E]/.test(type)) {
			this[TYPE] = type;
		}
	}
	get size() {
		return this[BUFFER].length;
	}
	get type() {
		return this[TYPE];
	}
	text() {
		return Promise.resolve(this[BUFFER].toString());
	}
	arrayBuffer() {
		const buf = this[BUFFER];
		const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		return Promise.resolve(ab);
	}
	stream() {
		const readable = new Readable();
		readable._read = function () {};
		readable.push(this[BUFFER]);
		readable.push(null);
		return readable;
	}
	toString() {
		return '[object Blob]';
	}
	slice() {
		const size = this.size;

		const start = arguments[0];
		const end = arguments[1];
		let relativeStart, relativeEnd;
		if (start === undefined) {
			relativeStart = 0;
		} else if (start < 0) {
			relativeStart = Math.max(size + start, 0);
		} else {
			relativeStart = Math.min(start, size);
		}
		if (end === undefined) {
			relativeEnd = size;
		} else if (end < 0) {
			relativeEnd = Math.max(size + end, 0);
		} else {
			relativeEnd = Math.min(end, size);
		}
		const span = Math.max(relativeEnd - relativeStart, 0);

		const buffer = this[BUFFER];
		const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
		const blob = new Blob([], { type: arguments[2] });
		blob[BUFFER] = slicedBuffer;
		return blob;
	}
}

Object.defineProperties(Blob.prototype, {
	size: { enumerable: true },
	type: { enumerable: true },
	slice: { enumerable: true }
});

Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
	value: 'Blob',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * fetch-error.js
 *
 * FetchError interface for operational errors
 */

/**
 * Create FetchError instance
 *
 * @param   String      message      Error message for human
 * @param   String      type         Error type for machine
 * @param   String      systemError  For Node.js system error
 * @return  FetchError
 */
function FetchError(message, type, systemError) {
  Error.call(this, message);

  this.message = message;
  this.type = type;

  // when err.type is `system`, err.code contains system error code
  if (systemError) {
    this.code = this.errno = systemError.code;
  }

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

FetchError.prototype = Object.create(Error.prototype);
FetchError.prototype.constructor = FetchError;
FetchError.prototype.name = 'FetchError';

let convert;
try {
	convert = __webpack_require__(18).convert;
} catch (e) {}

const INTERNALS = Symbol('Body internals');

// fix an issue where "PassThrough" isn't a named export for node <10
const PassThrough = Stream.PassThrough;

/**
 * Body mixin
 *
 * Ref: https://fetch.spec.whatwg.org/#body
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
function Body(body) {
	var _this = this;

	var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	    _ref$size = _ref.size;

	let size = _ref$size === undefined ? 0 : _ref$size;
	var _ref$timeout = _ref.timeout;
	let timeout = _ref$timeout === undefined ? 0 : _ref$timeout;

	if (body == null) {
		// body is undefined or null
		body = null;
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		body = Buffer.from(body.toString());
	} else if (isBlob(body)) ; else if (Buffer.isBuffer(body)) ; else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		body = Buffer.from(body);
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
	} else if (body instanceof Stream) ; else {
		// none of the above
		// coerce to string then buffer
		body = Buffer.from(String(body));
	}
	this[INTERNALS] = {
		body,
		disturbed: false,
		error: null
	};
	this.size = size;
	this.timeout = timeout;

	if (body instanceof Stream) {
		body.on('error', function (err) {
			const error = err.name === 'AbortError' ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, 'system', err);
			_this[INTERNALS].error = error;
		});
	}
}

Body.prototype = {
	get body() {
		return this[INTERNALS].body;
	},

	get bodyUsed() {
		return this[INTERNALS].disturbed;
	},

	/**
  * Decode response as ArrayBuffer
  *
  * @return  Promise
  */
	arrayBuffer() {
		return consumeBody.call(this).then(function (buf) {
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
		});
	},

	/**
  * Return raw response as Blob
  *
  * @return Promise
  */
	blob() {
		let ct = this.headers && this.headers.get('content-type') || '';
		return consumeBody.call(this).then(function (buf) {
			return Object.assign(
			// Prevent copying
			new Blob([], {
				type: ct.toLowerCase()
			}), {
				[BUFFER]: buf
			});
		});
	},

	/**
  * Decode response as json
  *
  * @return  Promise
  */
	json() {
		var _this2 = this;

		return consumeBody.call(this).then(function (buffer) {
			try {
				return JSON.parse(buffer.toString());
			} catch (err) {
				return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, 'invalid-json'));
			}
		});
	},

	/**
  * Decode response as text
  *
  * @return  Promise
  */
	text() {
		return consumeBody.call(this).then(function (buffer) {
			return buffer.toString();
		});
	},

	/**
  * Decode response as buffer (non-spec api)
  *
  * @return  Promise
  */
	buffer() {
		return consumeBody.call(this);
	},

	/**
  * Decode response as text, while automatically detecting the encoding and
  * trying to decode to UTF-8 (non-spec api)
  *
  * @return  Promise
  */
	textConverted() {
		var _this3 = this;

		return consumeBody.call(this).then(function (buffer) {
			return convertBody(buffer, _this3.headers);
		});
	}
};

// In browsers, all properties are enumerable.
Object.defineProperties(Body.prototype, {
	body: { enumerable: true },
	bodyUsed: { enumerable: true },
	arrayBuffer: { enumerable: true },
	blob: { enumerable: true },
	json: { enumerable: true },
	text: { enumerable: true }
});

Body.mixIn = function (proto) {
	for (const name of Object.getOwnPropertyNames(Body.prototype)) {
		// istanbul ignore else: future proof
		if (!(name in proto)) {
			const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
			Object.defineProperty(proto, name, desc);
		}
	}
};

/**
 * Consume and convert an entire Body to a Buffer.
 *
 * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
 *
 * @return  Promise
 */
function consumeBody() {
	var _this4 = this;

	if (this[INTERNALS].disturbed) {
		return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
	}

	this[INTERNALS].disturbed = true;

	if (this[INTERNALS].error) {
		return Body.Promise.reject(this[INTERNALS].error);
	}

	let body = this.body;

	// body is null
	if (body === null) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is blob
	if (isBlob(body)) {
		body = body.stream();
	}

	// body is buffer
	if (Buffer.isBuffer(body)) {
		return Body.Promise.resolve(body);
	}

	// istanbul ignore if: should never happen
	if (!(body instanceof Stream)) {
		return Body.Promise.resolve(Buffer.alloc(0));
	}

	// body is stream
	// get ready to actually consume the body
	let accum = [];
	let accumBytes = 0;
	let abort = false;

	return new Body.Promise(function (resolve, reject) {
		let resTimeout;

		// allow timeout on slow response body
		if (_this4.timeout) {
			resTimeout = setTimeout(function () {
				abort = true;
				reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, 'body-timeout'));
			}, _this4.timeout);
		}

		// handle stream errors
		body.on('error', function (err) {
			if (err.name === 'AbortError') {
				// if the request was aborted, reject with this Error
				abort = true;
				reject(err);
			} else {
				// other errors, such as incorrect content-encoding
				reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, 'system', err));
			}
		});

		body.on('data', function (chunk) {
			if (abort || chunk === null) {
				return;
			}

			if (_this4.size && accumBytes + chunk.length > _this4.size) {
				abort = true;
				reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, 'max-size'));
				return;
			}

			accumBytes += chunk.length;
			accum.push(chunk);
		});

		body.on('end', function () {
			if (abort) {
				return;
			}

			clearTimeout(resTimeout);

			try {
				resolve(Buffer.concat(accum, accumBytes));
			} catch (err) {
				// handle streams that have accumulated too much data (issue #414)
				reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, 'system', err));
			}
		});
	});
}

/**
 * Detect buffer encoding and convert to target encoding
 * ref: http://www.w3.org/TR/2011/WD-html5-20110113/parsing.html#determining-the-character-encoding
 *
 * @param   Buffer  buffer    Incoming buffer
 * @param   String  encoding  Target encoding
 * @return  String
 */
function convertBody(buffer, headers) {
	if (typeof convert !== 'function') {
		throw new Error('The package `encoding` must be installed to use the textConverted() function');
	}

	const ct = headers.get('content-type');
	let charset = 'utf-8';
	let res, str;

	// header
	if (ct) {
		res = /charset=([^;]*)/i.exec(ct);
	}

	// no charset in content type, peek at response body for at most 1024 bytes
	str = buffer.slice(0, 1024).toString();

	// html5
	if (!res && str) {
		res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
	}

	// html4
	if (!res && str) {
		res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
		if (!res) {
			res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
			if (res) {
				res.pop(); // drop last quote
			}
		}

		if (res) {
			res = /charset=(.*)/i.exec(res.pop());
		}
	}

	// xml
	if (!res && str) {
		res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
	}

	// found charset
	if (res) {
		charset = res.pop();

		// prevent decode issues when sites use incorrect encoding
		// ref: https://hsivonen.fi/encoding-menu/
		if (charset === 'gb2312' || charset === 'gbk') {
			charset = 'gb18030';
		}
	}

	// turn raw buffers into a single utf-8 buffer
	return convert(buffer, 'UTF-8', charset).toString();
}

/**
 * Detect a URLSearchParams object
 * ref: https://github.com/bitinn/node-fetch/issues/296#issuecomment-307598143
 *
 * @param   Object  obj     Object to detect by type or brand
 * @return  String
 */
function isURLSearchParams(obj) {
	// Duck-typing as a necessary condition.
	if (typeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function') {
		return false;
	}

	// Brand-checking and more duck-typing as optional condition.
	return obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';
}

/**
 * Check if `obj` is a W3C `Blob` object (which `File` inherits from)
 * @param  {*} obj
 * @return {boolean}
 */
function isBlob(obj) {
	return typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
}

/**
 * Clone body given Res/Req instance
 *
 * @param   Mixed  instance  Response or Request instance
 * @return  Mixed
 */
function clone(instance) {
	let p1, p2;
	let body = instance.body;

	// don't allow cloning a used body
	if (instance.bodyUsed) {
		throw new Error('cannot clone body after it is used');
	}

	// check that body is a stream and not form-data object
	// note: we can't clone the form-data object without having it as a dependency
	if (body instanceof Stream && typeof body.getBoundary !== 'function') {
		// tee instance body
		p1 = new PassThrough();
		p2 = new PassThrough();
		body.pipe(p1);
		body.pipe(p2);
		// set instance body to teed body and return the other teed body
		instance[INTERNALS].body = p1;
		body = p2;
	}

	return body;
}

/**
 * Performs the operation "extract a `Content-Type` value from |object|" as
 * specified in the specification:
 * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
 *
 * This function assumes that instance.body is present.
 *
 * @param   Mixed  instance  Any options.body input
 */
function extractContentType(body) {
	if (body === null) {
		// body is null
		return null;
	} else if (typeof body === 'string') {
		// body is string
		return 'text/plain;charset=UTF-8';
	} else if (isURLSearchParams(body)) {
		// body is a URLSearchParams
		return 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (isBlob(body)) {
		// body is blob
		return body.type || null;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return null;
	} else if (Object.prototype.toString.call(body) === '[object ArrayBuffer]') {
		// body is ArrayBuffer
		return null;
	} else if (ArrayBuffer.isView(body)) {
		// body is ArrayBufferView
		return null;
	} else if (typeof body.getBoundary === 'function') {
		// detect form data input from form-data module
		return `multipart/form-data;boundary=${body.getBoundary()}`;
	} else if (body instanceof Stream) {
		// body is stream
		// can't really do much about this
		return null;
	} else {
		// Body constructor defaults other things to string
		return 'text/plain;charset=UTF-8';
	}
}

/**
 * The Fetch Standard treats this as if "total bytes" is a property on the body.
 * For us, we have to explicitly get it with a function.
 *
 * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
 *
 * @param   Body    instance   Instance of Body
 * @return  Number?            Number of bytes, or null if not possible
 */
function getTotalBytes(instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		return 0;
	} else if (isBlob(body)) {
		return body.size;
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		return body.length;
	} else if (body && typeof body.getLengthSync === 'function') {
		// detect form data input from form-data module
		if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
		body.hasKnownLength && body.hasKnownLength()) {
			// 2.x
			return body.getLengthSync();
		}
		return null;
	} else {
		// body is stream
		return null;
	}
}

/**
 * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
 *
 * @param   Body    instance   Instance of Body
 * @return  Void
 */
function writeToStream(dest, instance) {
	const body = instance.body;


	if (body === null) {
		// body is null
		dest.end();
	} else if (isBlob(body)) {
		body.stream().pipe(dest);
	} else if (Buffer.isBuffer(body)) {
		// body is buffer
		dest.write(body);
		dest.end();
	} else {
		// body is stream
		body.pipe(dest);
	}
}

// expose Promise
Body.Promise = global.Promise;

/**
 * headers.js
 *
 * Headers class offers convenient helpers
 */

const invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;

function validateName(name) {
	name = `${name}`;
	if (invalidTokenRegex.test(name) || name === '') {
		throw new TypeError(`${name} is not a legal HTTP header name`);
	}
}

function validateValue(value) {
	value = `${value}`;
	if (invalidHeaderCharRegex.test(value)) {
		throw new TypeError(`${value} is not a legal HTTP header value`);
	}
}

/**
 * Find the key in the map object given a header name.
 *
 * Returns undefined if not found.
 *
 * @param   String  name  Header name
 * @return  String|Undefined
 */
function find(map, name) {
	name = name.toLowerCase();
	for (const key in map) {
		if (key.toLowerCase() === name) {
			return key;
		}
	}
	return undefined;
}

const MAP = Symbol('map');
class Headers {
	/**
  * Headers class
  *
  * @param   Object  headers  Response headers
  * @return  Void
  */
	constructor() {
		let init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;

		this[MAP] = Object.create(null);

		if (init instanceof Headers) {
			const rawHeaders = init.raw();
			const headerNames = Object.keys(rawHeaders);

			for (const headerName of headerNames) {
				for (const value of rawHeaders[headerName]) {
					this.append(headerName, value);
				}
			}

			return;
		}

		// We don't worry about converting prop to ByteString here as append()
		// will handle it.
		if (init == null) ; else if (typeof init === 'object') {
			const method = init[Symbol.iterator];
			if (method != null) {
				if (typeof method !== 'function') {
					throw new TypeError('Header pairs must be iterable');
				}

				// sequence<sequence<ByteString>>
				// Note: per spec we have to first exhaust the lists then process them
				const pairs = [];
				for (const pair of init) {
					if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {
						throw new TypeError('Each header pair must be iterable');
					}
					pairs.push(Array.from(pair));
				}

				for (const pair of pairs) {
					if (pair.length !== 2) {
						throw new TypeError('Each header pair must be a name/value tuple');
					}
					this.append(pair[0], pair[1]);
				}
			} else {
				// record<ByteString, ByteString>
				for (const key of Object.keys(init)) {
					const value = init[key];
					this.append(key, value);
				}
			}
		} else {
			throw new TypeError('Provided initializer must be an object');
		}
	}

	/**
  * Return combined header value given name
  *
  * @param   String  name  Header name
  * @return  Mixed
  */
	get(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key === undefined) {
			return null;
		}

		return this[MAP][key].join(', ');
	}

	/**
  * Iterate over all headers
  *
  * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
  * @param   Boolean   thisArg   `this` context for callback function
  * @return  Void
  */
	forEach(callback) {
		let thisArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

		let pairs = getHeaders(this);
		let i = 0;
		while (i < pairs.length) {
			var _pairs$i = pairs[i];
			const name = _pairs$i[0],
			      value = _pairs$i[1];

			callback.call(thisArg, value, name, this);
			pairs = getHeaders(this);
			i++;
		}
	}

	/**
  * Overwrite header values given name
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	set(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		this[MAP][key !== undefined ? key : name] = [value];
	}

	/**
  * Append a value onto existing header
  *
  * @param   String  name   Header name
  * @param   String  value  Header value
  * @return  Void
  */
	append(name, value) {
		name = `${name}`;
		value = `${value}`;
		validateName(name);
		validateValue(value);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			this[MAP][key].push(value);
		} else {
			this[MAP][name] = [value];
		}
	}

	/**
  * Check for header name existence
  *
  * @param   String   name  Header name
  * @return  Boolean
  */
	has(name) {
		name = `${name}`;
		validateName(name);
		return find(this[MAP], name) !== undefined;
	}

	/**
  * Delete all header values given name
  *
  * @param   String  name  Header name
  * @return  Void
  */
	delete(name) {
		name = `${name}`;
		validateName(name);
		const key = find(this[MAP], name);
		if (key !== undefined) {
			delete this[MAP][key];
		}
	}

	/**
  * Return raw headers (non-spec api)
  *
  * @return  Object
  */
	raw() {
		return this[MAP];
	}

	/**
  * Get an iterator on keys.
  *
  * @return  Iterator
  */
	keys() {
		return createHeadersIterator(this, 'key');
	}

	/**
  * Get an iterator on values.
  *
  * @return  Iterator
  */
	values() {
		return createHeadersIterator(this, 'value');
	}

	/**
  * Get an iterator on entries.
  *
  * This is the default iterator of the Headers object.
  *
  * @return  Iterator
  */
	[Symbol.iterator]() {
		return createHeadersIterator(this, 'key+value');
	}
}
Headers.prototype.entries = Headers.prototype[Symbol.iterator];

Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
	value: 'Headers',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Headers.prototype, {
	get: { enumerable: true },
	forEach: { enumerable: true },
	set: { enumerable: true },
	append: { enumerable: true },
	has: { enumerable: true },
	delete: { enumerable: true },
	keys: { enumerable: true },
	values: { enumerable: true },
	entries: { enumerable: true }
});

function getHeaders(headers) {
	let kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'key+value';

	const keys = Object.keys(headers[MAP]).sort();
	return keys.map(kind === 'key' ? function (k) {
		return k.toLowerCase();
	} : kind === 'value' ? function (k) {
		return headers[MAP][k].join(', ');
	} : function (k) {
		return [k.toLowerCase(), headers[MAP][k].join(', ')];
	});
}

const INTERNAL = Symbol('internal');

function createHeadersIterator(target, kind) {
	const iterator = Object.create(HeadersIteratorPrototype);
	iterator[INTERNAL] = {
		target,
		kind,
		index: 0
	};
	return iterator;
}

const HeadersIteratorPrototype = Object.setPrototypeOf({
	next() {
		// istanbul ignore if
		if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
			throw new TypeError('Value of `this` is not a HeadersIterator');
		}

		var _INTERNAL = this[INTERNAL];
		const target = _INTERNAL.target,
		      kind = _INTERNAL.kind,
		      index = _INTERNAL.index;

		const values = getHeaders(target, kind);
		const len = values.length;
		if (index >= len) {
			return {
				value: undefined,
				done: true
			};
		}

		this[INTERNAL].index = index + 1;

		return {
			value: values[index],
			done: false
		};
	}
}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));

Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
	value: 'HeadersIterator',
	writable: false,
	enumerable: false,
	configurable: true
});

/**
 * Export the Headers object in a form that Node.js can consume.
 *
 * @param   Headers  headers
 * @return  Object
 */
function exportNodeCompatibleHeaders(headers) {
	const obj = Object.assign({ __proto__: null }, headers[MAP]);

	// http.request() only supports string as Host header. This hack makes
	// specifying custom Host header possible.
	const hostHeaderKey = find(headers[MAP], 'Host');
	if (hostHeaderKey !== undefined) {
		obj[hostHeaderKey] = obj[hostHeaderKey][0];
	}

	return obj;
}

/**
 * Create a Headers object from an object of headers, ignoring those that do
 * not conform to HTTP grammar productions.
 *
 * @param   Object  obj  Object of headers
 * @return  Headers
 */
function createHeadersLenient(obj) {
	const headers = new Headers();
	for (const name of Object.keys(obj)) {
		if (invalidTokenRegex.test(name)) {
			continue;
		}
		if (Array.isArray(obj[name])) {
			for (const val of obj[name]) {
				if (invalidHeaderCharRegex.test(val)) {
					continue;
				}
				if (headers[MAP][name] === undefined) {
					headers[MAP][name] = [val];
				} else {
					headers[MAP][name].push(val);
				}
			}
		} else if (!invalidHeaderCharRegex.test(obj[name])) {
			headers[MAP][name] = [obj[name]];
		}
	}
	return headers;
}

const INTERNALS$1 = Symbol('Response internals');

// fix an issue where "STATUS_CODES" aren't a named export for node <10
const STATUS_CODES = http.STATUS_CODES;

/**
 * Response class
 *
 * @param   Stream  body  Readable stream
 * @param   Object  opts  Response options
 * @return  Void
 */
class Response {
	constructor() {
		let body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
		let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		Body.call(this, body, opts);

		const status = opts.status || 200;
		const headers = new Headers(opts.headers);

		if (body != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(body);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		this[INTERNALS$1] = {
			url: opts.url,
			status,
			statusText: opts.statusText || STATUS_CODES[status],
			headers,
			counter: opts.counter
		};
	}

	get url() {
		return this[INTERNALS$1].url || '';
	}

	get status() {
		return this[INTERNALS$1].status;
	}

	/**
  * Convenience property representing if the request ended normally
  */
	get ok() {
		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
	}

	get redirected() {
		return this[INTERNALS$1].counter > 0;
	}

	get statusText() {
		return this[INTERNALS$1].statusText;
	}

	get headers() {
		return this[INTERNALS$1].headers;
	}

	/**
  * Clone this response
  *
  * @return  Response
  */
	clone() {
		return new Response(clone(this), {
			url: this.url,
			status: this.status,
			statusText: this.statusText,
			headers: this.headers,
			ok: this.ok,
			redirected: this.redirected
		});
	}
}

Body.mixIn(Response.prototype);

Object.defineProperties(Response.prototype, {
	url: { enumerable: true },
	status: { enumerable: true },
	ok: { enumerable: true },
	redirected: { enumerable: true },
	statusText: { enumerable: true },
	headers: { enumerable: true },
	clone: { enumerable: true }
});

Object.defineProperty(Response.prototype, Symbol.toStringTag, {
	value: 'Response',
	writable: false,
	enumerable: false,
	configurable: true
});

const INTERNALS$2 = Symbol('Request internals');

// fix an issue where "format", "parse" aren't a named export for node <10
const parse_url = Url.parse;
const format_url = Url.format;

const streamDestructionSupported = 'destroy' in Stream.Readable.prototype;

/**
 * Check if a value is an instance of Request.
 *
 * @param   Mixed   input
 * @return  Boolean
 */
function isRequest(input) {
	return typeof input === 'object' && typeof input[INTERNALS$2] === 'object';
}

function isAbortSignal(signal) {
	const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);
	return !!(proto && proto.constructor.name === 'AbortSignal');
}

/**
 * Request class
 *
 * @param   Mixed   input  Url or Request instance
 * @param   Object  init   Custom options
 * @return  Void
 */
class Request {
	constructor(input) {
		let init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

		let parsedURL;

		// normalize input
		if (!isRequest(input)) {
			if (input && input.href) {
				// in order to support Node.js' Url objects; though WHATWG's URL objects
				// will fall into this branch also (since their `toString()` will return
				// `href` property anyway)
				parsedURL = parse_url(input.href);
			} else {
				// coerce input to a string before attempting to parse
				parsedURL = parse_url(`${input}`);
			}
			input = {};
		} else {
			parsedURL = parse_url(input.url);
		}

		let method = init.method || input.method || 'GET';
		method = method.toUpperCase();

		if ((init.body != null || isRequest(input) && input.body !== null) && (method === 'GET' || method === 'HEAD')) {
			throw new TypeError('Request with GET/HEAD method cannot have body');
		}

		let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;

		Body.call(this, inputBody, {
			timeout: init.timeout || input.timeout || 0,
			size: init.size || input.size || 0
		});

		const headers = new Headers(init.headers || input.headers || {});

		if (inputBody != null && !headers.has('Content-Type')) {
			const contentType = extractContentType(inputBody);
			if (contentType) {
				headers.append('Content-Type', contentType);
			}
		}

		let signal = isRequest(input) ? input.signal : null;
		if ('signal' in init) signal = init.signal;

		if (signal != null && !isAbortSignal(signal)) {
			throw new TypeError('Expected signal to be an instanceof AbortSignal');
		}

		this[INTERNALS$2] = {
			method,
			redirect: init.redirect || input.redirect || 'follow',
			headers,
			parsedURL,
			signal
		};

		// node-fetch-only options
		this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;
		this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;
		this.counter = init.counter || input.counter || 0;
		this.agent = init.agent || input.agent;
	}

	get method() {
		return this[INTERNALS$2].method;
	}

	get url() {
		return format_url(this[INTERNALS$2].parsedURL);
	}

	get headers() {
		return this[INTERNALS$2].headers;
	}

	get redirect() {
		return this[INTERNALS$2].redirect;
	}

	get signal() {
		return this[INTERNALS$2].signal;
	}

	/**
  * Clone this request
  *
  * @return  Request
  */
	clone() {
		return new Request(this);
	}
}

Body.mixIn(Request.prototype);

Object.defineProperty(Request.prototype, Symbol.toStringTag, {
	value: 'Request',
	writable: false,
	enumerable: false,
	configurable: true
});

Object.defineProperties(Request.prototype, {
	method: { enumerable: true },
	url: { enumerable: true },
	headers: { enumerable: true },
	redirect: { enumerable: true },
	clone: { enumerable: true },
	signal: { enumerable: true }
});

/**
 * Convert a Request to Node.js http request options.
 *
 * @param   Request  A Request instance
 * @return  Object   The options object to be passed to http.request
 */
function getNodeRequestOptions(request) {
	const parsedURL = request[INTERNALS$2].parsedURL;
	const headers = new Headers(request[INTERNALS$2].headers);

	// fetch step 1.3
	if (!headers.has('Accept')) {
		headers.set('Accept', '*/*');
	}

	// Basic fetch
	if (!parsedURL.protocol || !parsedURL.hostname) {
		throw new TypeError('Only absolute URLs are supported');
	}

	if (!/^https?:$/.test(parsedURL.protocol)) {
		throw new TypeError('Only HTTP(S) protocols are supported');
	}

	if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
		throw new Error('Cancellation of streamed requests with AbortSignal is not supported in node < 8');
	}

	// HTTP-network-or-cache fetch steps 2.4-2.7
	let contentLengthValue = null;
	if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
		contentLengthValue = '0';
	}
	if (request.body != null) {
		const totalBytes = getTotalBytes(request);
		if (typeof totalBytes === 'number') {
			contentLengthValue = String(totalBytes);
		}
	}
	if (contentLengthValue) {
		headers.set('Content-Length', contentLengthValue);
	}

	// HTTP-network-or-cache fetch step 2.11
	if (!headers.has('User-Agent')) {
		headers.set('User-Agent', 'node-fetch/1.0 (+https://github.com/bitinn/node-fetch)');
	}

	// HTTP-network-or-cache fetch step 2.15
	if (request.compress && !headers.has('Accept-Encoding')) {
		headers.set('Accept-Encoding', 'gzip,deflate');
	}

	let agent = request.agent;
	if (typeof agent === 'function') {
		agent = agent(parsedURL);
	}

	if (!headers.has('Connection') && !agent) {
		headers.set('Connection', 'close');
	}

	// HTTP-network fetch step 4.2
	// chunked encoding is handled by Node.js

	return Object.assign({}, parsedURL, {
		method: request.method,
		headers: exportNodeCompatibleHeaders(headers),
		agent
	});
}

/**
 * abort-error.js
 *
 * AbortError interface for cancelled requests
 */

/**
 * Create AbortError instance
 *
 * @param   String      message      Error message for human
 * @return  AbortError
 */
function AbortError(message) {
  Error.call(this, message);

  this.type = 'aborted';
  this.message = message;

  // hide custom error implementation details from end-users
  Error.captureStackTrace(this, this.constructor);
}

AbortError.prototype = Object.create(Error.prototype);
AbortError.prototype.constructor = AbortError;
AbortError.prototype.name = 'AbortError';

// fix an issue where "PassThrough", "resolve" aren't a named export for node <10
const PassThrough$1 = Stream.PassThrough;
const resolve_url = Url.resolve;

/**
 * Fetch function
 *
 * @param   Mixed    url   Absolute url or Request instance
 * @param   Object   opts  Fetch options
 * @return  Promise
 */
function fetch(url, opts) {

	// allow custom promise
	if (!fetch.Promise) {
		throw new Error('native promise missing, set fetch.Promise to your favorite alternative');
	}

	Body.Promise = fetch.Promise;

	// wrap http.request into fetch
	return new fetch.Promise(function (resolve, reject) {
		// build request object
		const request = new Request(url, opts);
		const options = getNodeRequestOptions(request);

		const send = (options.protocol === 'https:' ? https : http).request;
		const signal = request.signal;

		let response = null;

		const abort = function abort() {
			let error = new AbortError('The user aborted a request.');
			reject(error);
			if (request.body && request.body instanceof Stream.Readable) {
				request.body.destroy(error);
			}
			if (!response || !response.body) return;
			response.body.emit('error', error);
		};

		if (signal && signal.aborted) {
			abort();
			return;
		}

		const abortAndFinalize = function abortAndFinalize() {
			abort();
			finalize();
		};

		// send request
		const req = send(options);
		let reqTimeout;

		if (signal) {
			signal.addEventListener('abort', abortAndFinalize);
		}

		function finalize() {
			req.abort();
			if (signal) signal.removeEventListener('abort', abortAndFinalize);
			clearTimeout(reqTimeout);
		}

		if (request.timeout) {
			req.once('socket', function (socket) {
				reqTimeout = setTimeout(function () {
					reject(new FetchError(`network timeout at: ${request.url}`, 'request-timeout'));
					finalize();
				}, request.timeout);
			});
		}

		req.on('error', function (err) {
			reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, 'system', err));
			finalize();
		});

		req.on('response', function (res) {
			clearTimeout(reqTimeout);

			const headers = createHeadersLenient(res.headers);

			// HTTP fetch step 5
			if (fetch.isRedirect(res.statusCode)) {
				// HTTP fetch step 5.2
				const location = headers.get('Location');

				// HTTP fetch step 5.3
				const locationURL = location === null ? null : resolve_url(request.url, location);

				// HTTP fetch step 5.5
				switch (request.redirect) {
					case 'error':
						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
						finalize();
						return;
					case 'manual':
						// node-fetch-specific step: make manual redirect a bit easier to use by setting the Location header value to the resolved URL.
						if (locationURL !== null) {
							// handle corrupted header
							try {
								headers.set('Location', locationURL);
							} catch (err) {
								// istanbul ignore next: nodejs server prevent invalid response headers, we can't test this through normal request
								reject(err);
							}
						}
						break;
					case 'follow':
						// HTTP-redirect fetch step 2
						if (locationURL === null) {
							break;
						}

						// HTTP-redirect fetch step 5
						if (request.counter >= request.follow) {
							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 6 (counter increment)
						// Create a new Request object.
						const requestOpts = {
							headers: new Headers(request.headers),
							follow: request.follow,
							counter: request.counter + 1,
							agent: request.agent,
							compress: request.compress,
							method: request.method,
							body: request.body,
							signal: request.signal,
							timeout: request.timeout,
							size: request.size
						};

						// HTTP-redirect fetch step 9
						if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
							finalize();
							return;
						}

						// HTTP-redirect fetch step 11
						if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === 'POST') {
							requestOpts.method = 'GET';
							requestOpts.body = undefined;
							requestOpts.headers.delete('content-length');
						}

						// HTTP-redirect fetch step 15
						resolve(fetch(new Request(locationURL, requestOpts)));
						finalize();
						return;
				}
			}

			// prepare response
			res.once('end', function () {
				if (signal) signal.removeEventListener('abort', abortAndFinalize);
			});
			let body = res.pipe(new PassThrough$1());

			const response_options = {
				url: request.url,
				status: res.statusCode,
				statusText: res.statusMessage,
				headers: headers,
				size: request.size,
				timeout: request.timeout,
				counter: request.counter
			};

			// HTTP-network fetch step 12.1.1.3
			const codings = headers.get('Content-Encoding');

			// HTTP-network fetch step 12.1.1.4: handle content codings

			// in following scenarios we ignore compression support
			// 1. compression support is disabled
			// 2. HEAD request
			// 3. no Content-Encoding header
			// 4. no content response (204)
			// 5. content not modified response (304)
			if (!request.compress || request.method === 'HEAD' || codings === null || res.statusCode === 204 || res.statusCode === 304) {
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// For Node v6+
			// Be less strict when decoding compressed responses, since sometimes
			// servers send slightly invalid responses that are still accepted
			// by common browsers.
			// Always using Z_SYNC_FLUSH is what cURL does.
			const zlibOptions = {
				flush: zlib.Z_SYNC_FLUSH,
				finishFlush: zlib.Z_SYNC_FLUSH
			};

			// for gzip
			if (codings == 'gzip' || codings == 'x-gzip') {
				body = body.pipe(zlib.createGunzip(zlibOptions));
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// for deflate
			if (codings == 'deflate' || codings == 'x-deflate') {
				// handle the infamous raw deflate response from old servers
				// a hack for old IIS and Apache servers
				const raw = res.pipe(new PassThrough$1());
				raw.once('data', function (chunk) {
					// see http://stackoverflow.com/questions/37519828
					if ((chunk[0] & 0x0F) === 0x08) {
						body = body.pipe(zlib.createInflate());
					} else {
						body = body.pipe(zlib.createInflateRaw());
					}
					response = new Response(body, response_options);
					resolve(response);
				});
				return;
			}

			// for br
			if (codings == 'br' && typeof zlib.createBrotliDecompress === 'function') {
				body = body.pipe(zlib.createBrotliDecompress());
				response = new Response(body, response_options);
				resolve(response);
				return;
			}

			// otherwise, use response as-is
			response = new Response(body, response_options);
			resolve(response);
		});

		writeToStream(req, request);
	});
}
/**
 * Redirect code matching
 *
 * @param   Number   code  Status code
 * @return  Boolean
 */
fetch.isRedirect = function (code) {
	return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
};

// expose Promise
fetch.Promise = global.Promise;

module.exports = exports = fetch;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports;
exports.Headers = Headers;
exports.Request = Request;
exports.Response = Response;
exports.FetchError = FetchError;


/***/ }),

/***/ 463:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var deprecation = __webpack_require__(692);
var once = _interopDefault(__webpack_require__(49));

const logOnce = once(deprecation => console.warn(deprecation));
/**
 * Error with extra properties to help with debugging
 */

class RequestError extends Error {
  constructor(message, statusCode, options) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = "HttpError";
    this.status = statusCode;
    Object.defineProperty(this, "code", {
      get() {
        logOnce(new deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
        return statusCode;
      }

    });
    this.headers = options.headers || {}; // redact request credentials without mutating original request options

    const requestCopy = Object.assign({}, options.request);

    if (options.request.headers.authorization) {
      requestCopy.headers = Object.assign({}, options.request.headers, {
        authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
      });
    }

    requestCopy.url = requestCopy.url // client_id & client_secret can be passed as URL query parameters to increase rate limit
    // see https://developer.github.com/v3/#increasing-the-unauthenticated-rate-limit-for-oauth-applications
    .replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]") // OAuth tokens can be passed as URL query parameters, although it is not recommended
    // see https://developer.github.com/v3/#oauth2-token-sent-in-a-header
    .replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
    this.request = requestCopy;
  }

}

exports.RequestError = RequestError;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 469:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOctokit = exports.context = void 0;
const Context = __importStar(__webpack_require__(262));
const utils_1 = __webpack_require__(521);
exports.context = new Context.Context();
/**
 * Returns a hydrated octokit ready to use for GitHub Actions
 *
 * @param     token    the repo PAT or GITHUB_TOKEN
 * @param     options  other options to set
 */
function getOctokit(token, options) {
    return new utils_1.GitHub(utils_1.getOctokitOptions(token, options));
}
exports.getOctokit = getOctokit;
//# sourceMappingURL=github.js.map

/***/ }),

/***/ 470:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = __webpack_require__(431);
const file_command_1 = __webpack_require__(102);
const utils_1 = __webpack_require__(82);
const os = __importStar(__webpack_require__(87));
const path = __importStar(__webpack_require__(622));
/**
 * The code to exit an action
 */
var ExitCode;
(function (ExitCode) {
    /**
     * A code indicating that the action was successful
     */
    ExitCode[ExitCode["Success"] = 0] = "Success";
    /**
     * A code indicating that the action was a failure
     */
    ExitCode[ExitCode["Failure"] = 1] = "Failure";
})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
//-----------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------
/**
 * Sets env variable for this action and future actions in the job
 * @param name the name of the variable to set
 * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env['GITHUB_ENV'] || '';
    if (filePath) {
        const delimiter = '_GitHubActionsFileCommandDelimeter_';
        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
        file_command_1.issueCommand('ENV', commandValue);
    }
    else {
        command_1.issueCommand('set-env', { name }, convertedVal);
    }
}
exports.exportVariable = exportVariable;
/**
 * Registers a secret which will get masked from logs
 * @param secret value of the secret
 */
function setSecret(secret) {
    command_1.issueCommand('add-mask', {}, secret);
}
exports.setSecret = setSecret;
/**
 * Prepends inputPath to the PATH (for this action and future actions)
 * @param inputPath
 */
function addPath(inputPath) {
    const filePath = process.env['GITHUB_PATH'] || '';
    if (filePath) {
        file_command_1.issueCommand('PATH', inputPath);
    }
    else {
        command_1.issueCommand('add-path', {}, inputPath);
    }
    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
}
exports.addPath = addPath;
/**
 * Gets the value of an input.  The value is also trimmed.
 *
 * @param     name     name of the input to get
 * @param     options  optional. See InputOptions.
 * @returns   string
 */
function getInput(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
    if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
    }
    return val.trim();
}
exports.getInput = getInput;
/**
 * Sets the value of an output.
 *
 * @param     name     name of the output to set
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function setOutput(name, value) {
    command_1.issueCommand('set-output', { name }, value);
}
exports.setOutput = setOutput;
/**
 * Enables or disables the echoing of commands into stdout for the rest of the step.
 * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
 *
 */
function setCommandEcho(enabled) {
    command_1.issue('echo', enabled ? 'on' : 'off');
}
exports.setCommandEcho = setCommandEcho;
//-----------------------------------------------------------------------
// Results
//-----------------------------------------------------------------------
/**
 * Sets the action status to failed.
 * When the action exits it will be with an exit code of 1
 * @param message add error issue message
 */
function setFailed(message) {
    process.exitCode = ExitCode.Failure;
    error(message);
}
exports.setFailed = setFailed;
//-----------------------------------------------------------------------
// Logging Commands
//-----------------------------------------------------------------------
/**
 * Gets whether Actions Step Debug is on or not
 */
function isDebug() {
    return process.env['RUNNER_DEBUG'] === '1';
}
exports.isDebug = isDebug;
/**
 * Writes debug message to user log
 * @param message debug message
 */
function debug(message) {
    command_1.issueCommand('debug', {}, message);
}
exports.debug = debug;
/**
 * Adds an error issue
 * @param message error issue message. Errors will be converted to string via toString()
 */
function error(message) {
    command_1.issue('error', message instanceof Error ? message.toString() : message);
}
exports.error = error;
/**
 * Adds an warning issue
 * @param message warning issue message. Errors will be converted to string via toString()
 */
function warning(message) {
    command_1.issue('warning', message instanceof Error ? message.toString() : message);
}
exports.warning = warning;
/**
 * Writes info to log with console.log.
 * @param message info message
 */
function info(message) {
    process.stdout.write(message + os.EOL);
}
exports.info = info;
/**
 * Begin an output group.
 *
 * Output until the next `groupEnd` will be foldable in this group
 *
 * @param name The name of the output group
 */
function startGroup(name) {
    command_1.issue('group', name);
}
exports.startGroup = startGroup;
/**
 * End an output group.
 */
function endGroup() {
    command_1.issue('endgroup');
}
exports.endGroup = endGroup;
/**
 * Wrap an asynchronous function call in a group.
 *
 * Returns the same type as the function itself.
 *
 * @param name The name of the group
 * @param fn The function to wrap in the group
 */
function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
            result = yield fn();
        }
        finally {
            endGroup();
        }
        return result;
    });
}
exports.group = group;
//-----------------------------------------------------------------------
// Wrapper action state
//-----------------------------------------------------------------------
/**
 * Saves state for current action, the state can only be retrieved by this action's post job execution.
 *
 * @param     name     name of the state to store
 * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function saveState(name, value) {
    command_1.issueCommand('save-state', { name }, value);
}
exports.saveState = saveState;
/**
 * Gets the value of an state set by this action's main execution.
 *
 * @param     name     name of the state to get
 * @returns   string
 */
function getState(name) {
    return process.env[`STATE_${name}`] || '';
}
exports.getState = getState;
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 510:
/***/ (function(module) {

module.exports = addHook;

function addHook(state, kind, name, hook) {
  var orig = hook;
  if (!state.registry[name]) {
    state.registry[name] = [];
  }

  if (kind === "before") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(orig.bind(null, options))
        .then(method.bind(null, options));
    };
  }

  if (kind === "after") {
    hook = function (method, options) {
      var result;
      return Promise.resolve()
        .then(method.bind(null, options))
        .then(function (result_) {
          result = result_;
          return orig(result, options);
        })
        .then(function () {
          return result;
        });
    };
  }

  if (kind === "error") {
    hook = function (method, options) {
      return Promise.resolve()
        .then(method.bind(null, options))
        .catch(function (error) {
          return orig(error, options);
        });
    };
  }

  state.registry[name].push({
    hook: hook,
    orig: orig,
  });
}


/***/ }),

/***/ 521:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOctokitOptions = exports.GitHub = exports.context = void 0;
const Context = __importStar(__webpack_require__(262));
const Utils = __importStar(__webpack_require__(127));
// octokit + plugins
const core_1 = __webpack_require__(448);
const plugin_rest_endpoint_methods_1 = __webpack_require__(842);
const plugin_paginate_rest_1 = __webpack_require__(299);
exports.context = new Context.Context();
const baseUrl = Utils.getApiBaseUrl();
const defaults = {
    baseUrl,
    request: {
        agent: Utils.getProxyAgent(baseUrl)
    }
};
exports.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(defaults);
/**
 * Convience function to correctly format Octokit Options to pass into the constructor.
 *
 * @param     token    the repo PAT or GITHUB_TOKEN
 * @param     options  other options to set
 */
function getOctokitOptions(token, options) {
    const opts = Object.assign({}, options || {}); // Shallow clone - don't mutate the object provided by the caller
    // Auth
    const auth = Utils.getAuthString(token, opts);
    if (auth) {
        opts.auth = auth;
    }
    return opts;
}
exports.getOctokitOptions = getOctokitOptions;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 523:
/***/ (function(module, __unusedexports, __webpack_require__) {

var register = __webpack_require__(280)
var addHook = __webpack_require__(510)
var removeHook = __webpack_require__(866)

// bind with array of arguments: https://stackoverflow.com/a/21792913
var bind = Function.bind
var bindable = bind.bind(bind)

function bindApi (hook, state, name) {
  var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state])
  hook.api = { remove: removeHookRef }
  hook.remove = removeHookRef

  ;['before', 'error', 'after', 'wrap'].forEach(function (kind) {
    var args = name ? [state, kind, name] : [state, kind]
    hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args)
  })
}

function HookSingular () {
  var singularHookName = 'h'
  var singularHookState = {
    registry: {}
  }
  var singularHook = register.bind(null, singularHookState, singularHookName)
  bindApi(singularHook, singularHookState, singularHookName)
  return singularHook
}

function HookCollection () {
  var state = {
    registry: {}
  }

  var hook = register.bind(null, state)
  bindApi(hook, state)

  return hook
}

var collectionHookDeprecationMessageDisplayed = false
function Hook () {
  if (!collectionHookDeprecationMessageDisplayed) {
    console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4')
    collectionHookDeprecationMessageDisplayed = true
  }
  return HookCollection()
}

Hook.Singular = HookSingular.bind()
Hook.Collection = HookCollection.bind()

module.exports = Hook
// expose constructors as a named property for TypeScript
module.exports.Hook = Hook
module.exports.Singular = Hook.Singular
module.exports.Collection = Hook.Collection


/***/ }),

/***/ 539:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const http = __webpack_require__(605);
const https = __webpack_require__(211);
const pm = __webpack_require__(950);
let tunnel;
var HttpCodes;
(function (HttpCodes) {
    HttpCodes[HttpCodes["OK"] = 200] = "OK";
    HttpCodes[HttpCodes["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes[HttpCodes["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes[HttpCodes["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes[HttpCodes["SeeOther"] = 303] = "SeeOther";
    HttpCodes[HttpCodes["NotModified"] = 304] = "NotModified";
    HttpCodes[HttpCodes["UseProxy"] = 305] = "UseProxy";
    HttpCodes[HttpCodes["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes[HttpCodes["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes[HttpCodes["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes[HttpCodes["BadRequest"] = 400] = "BadRequest";
    HttpCodes[HttpCodes["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes[HttpCodes["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes[HttpCodes["Forbidden"] = 403] = "Forbidden";
    HttpCodes[HttpCodes["NotFound"] = 404] = "NotFound";
    HttpCodes[HttpCodes["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes[HttpCodes["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes[HttpCodes["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes[HttpCodes["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes[HttpCodes["Conflict"] = 409] = "Conflict";
    HttpCodes[HttpCodes["Gone"] = 410] = "Gone";
    HttpCodes[HttpCodes["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes[HttpCodes["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes[HttpCodes["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes[HttpCodes["BadGateway"] = 502] = "BadGateway";
    HttpCodes[HttpCodes["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes[HttpCodes["GatewayTimeout"] = 504] = "GatewayTimeout";
})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));
var Headers;
(function (Headers) {
    Headers["Accept"] = "accept";
    Headers["ContentType"] = "content-type";
})(Headers = exports.Headers || (exports.Headers = {}));
var MediaTypes;
(function (MediaTypes) {
    MediaTypes["ApplicationJson"] = "application/json";
})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));
/**
 * Returns the proxy URL, depending upon the supplied url and proxy environment variables.
 * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
 */
function getProxyUrl(serverUrl) {
    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : '';
}
exports.getProxyUrl = getProxyUrl;
const HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
];
const HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
];
const RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];
const ExponentialBackoffCeiling = 10;
const ExponentialBackoffTimeSlice = 5;
class HttpClientError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.name = 'HttpClientError';
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, HttpClientError.prototype);
    }
}
exports.HttpClientError = HttpClientError;
class HttpClientResponse {
    constructor(message) {
        this.message = message;
    }
    readBody() {
        return new Promise(async (resolve, reject) => {
            let output = Buffer.alloc(0);
            this.message.on('data', (chunk) => {
                output = Buffer.concat([output, chunk]);
            });
            this.message.on('end', () => {
                resolve(output.toString());
            });
        });
    }
}
exports.HttpClientResponse = HttpClientResponse;
function isHttps(requestUrl) {
    let parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === 'https:';
}
exports.isHttps = isHttps;
class HttpClient {
    constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
            if (requestOptions.ignoreSslError != null) {
                this._ignoreSslError = requestOptions.ignoreSslError;
            }
            this._socketTimeout = requestOptions.socketTimeout;
            if (requestOptions.allowRedirects != null) {
                this._allowRedirects = requestOptions.allowRedirects;
            }
            if (requestOptions.allowRedirectDowngrade != null) {
                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
            }
            if (requestOptions.maxRedirects != null) {
                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
            }
            if (requestOptions.keepAlive != null) {
                this._keepAlive = requestOptions.keepAlive;
            }
            if (requestOptions.allowRetries != null) {
                this._allowRetries = requestOptions.allowRetries;
            }
            if (requestOptions.maxRetries != null) {
                this._maxRetries = requestOptions.maxRetries;
            }
        }
    }
    options(requestUrl, additionalHeaders) {
        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});
    }
    get(requestUrl, additionalHeaders) {
        return this.request('GET', requestUrl, null, additionalHeaders || {});
    }
    del(requestUrl, additionalHeaders) {
        return this.request('DELETE', requestUrl, null, additionalHeaders || {});
    }
    post(requestUrl, data, additionalHeaders) {
        return this.request('POST', requestUrl, data, additionalHeaders || {});
    }
    patch(requestUrl, data, additionalHeaders) {
        return this.request('PATCH', requestUrl, data, additionalHeaders || {});
    }
    put(requestUrl, data, additionalHeaders) {
        return this.request('PUT', requestUrl, data, additionalHeaders || {});
    }
    head(requestUrl, additionalHeaders) {
        return this.request('HEAD', requestUrl, null, additionalHeaders || {});
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
        return this.request(verb, requestUrl, stream, additionalHeaders);
    }
    /**
     * Gets a typed object from an endpoint
     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
     */
    async getJson(requestUrl, additionalHeaders = {}) {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        let res = await this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    async postJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = await this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    async putJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = await this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    async patchJson(requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = await this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
    }
    /**
     * Makes a raw http request.
     * All other methods such as get, post, patch, and request ultimately call this.
     * Prefer get, del, post and patch
     */
    async request(verb, requestUrl, data, headers) {
        if (this._disposed) {
            throw new Error('Client has already been disposed.');
        }
        let parsedUrl = new URL(requestUrl);
        let info = this._prepareRequest(verb, parsedUrl, headers);
        // Only perform retries on reads since writes may not be idempotent.
        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1
            ? this._maxRetries + 1
            : 1;
        let numTries = 0;
        let response;
        while (numTries < maxTries) {
            response = await this.requestRaw(info, data);
            // Check if it's an authentication challenge
            if (response &&
                response.message &&
                response.message.statusCode === HttpCodes.Unauthorized) {
                let authenticationHandler;
                for (let i = 0; i < this.handlers.length; i++) {
                    if (this.handlers[i].canHandleAuthentication(response)) {
                        authenticationHandler = this.handlers[i];
                        break;
                    }
                }
                if (authenticationHandler) {
                    return authenticationHandler.handleAuthentication(this, info, data);
                }
                else {
                    // We have received an unauthorized response but have no handlers to handle it.
                    // Let the response return to the caller.
                    return response;
                }
            }
            let redirectsRemaining = this._maxRedirects;
            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&
                this._allowRedirects &&
                redirectsRemaining > 0) {
                const redirectUrl = response.message.headers['location'];
                if (!redirectUrl) {
                    // if there's no location to redirect to, we won't
                    break;
                }
                let parsedRedirectUrl = new URL(redirectUrl);
                if (parsedUrl.protocol == 'https:' &&
                    parsedUrl.protocol != parsedRedirectUrl.protocol &&
                    !this._allowRedirectDowngrade) {
                    throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');
                }
                // we need to finish reading the response before reassigning response
                // which will leak the open socket.
                await response.readBody();
                // strip authorization header if redirected to a different hostname
                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                    for (let header in headers) {
                        // header names are case insensitive
                        if (header.toLowerCase() === 'authorization') {
                            delete headers[header];
                        }
                    }
                }
                // let's make the request with the new redirectUrl
                info = this._prepareRequest(verb, parsedRedirectUrl, headers);
                response = await this.requestRaw(info, data);
                redirectsRemaining--;
            }
            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {
                // If not a retry code, return immediately instead of retrying
                return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
                await response.readBody();
                await this._performExponentialBackoff(numTries);
            }
        }
        return response;
    }
    /**
     * Needs to be called if keepAlive is set to true in request options.
     */
    dispose() {
        if (this._agent) {
            this._agent.destroy();
        }
        this._disposed = true;
    }
    /**
     * Raw request.
     * @param info
     * @param data
     */
    requestRaw(info, data) {
        return new Promise((resolve, reject) => {
            let callbackForResult = function (err, res) {
                if (err) {
                    reject(err);
                }
                resolve(res);
            };
            this.requestRawWithCallback(info, data, callbackForResult);
        });
    }
    /**
     * Raw request with callback.
     * @param info
     * @param data
     * @param onResult
     */
    requestRawWithCallback(info, data, onResult) {
        let socket;
        if (typeof data === 'string') {
            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');
        }
        let callbackCalled = false;
        let handleResult = (err, res) => {
            if (!callbackCalled) {
                callbackCalled = true;
                onResult(err, res);
            }
        };
        let req = info.httpModule.request(info.options, (msg) => {
            let res = new HttpClientResponse(msg);
            handleResult(null, res);
        });
        req.on('socket', sock => {
            socket = sock;
        });
        // If we ever get disconnected, we want the socket to timeout eventually
        req.setTimeout(this._socketTimeout || 3 * 60000, () => {
            if (socket) {
                socket.end();
            }
            handleResult(new Error('Request timeout: ' + info.options.path), null);
        });
        req.on('error', function (err) {
            // err has statusCode property
            // res should have headers
            handleResult(err, null);
        });
        if (data && typeof data === 'string') {
            req.write(data, 'utf8');
        }
        if (data && typeof data !== 'string') {
            data.on('close', function () {
                req.end();
            });
            data.pipe(req);
        }
        else {
            req.end();
        }
    }
    /**
     * Gets an http agent. This function is useful when you need an http agent that handles
     * routing through a proxy server - depending upon the url and proxy environment variables.
     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
     */
    getAgent(serverUrl) {
        let parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === 'https:';
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port
            ? parseInt(info.parsedUrl.port)
            : defaultPort;
        info.options.path =
            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
            info.options.headers['user-agent'] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        // gives handlers an opportunity to participate
        if (this.handlers) {
            this.handlers.forEach(handler => {
                handler.prepareRequest(info.options);
            });
        }
        return info;
    }
    _mergeHeaders(headers) {
        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
        if (this.requestOptions && this.requestOptions.headers) {
            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));
        }
        return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
        let agent;
        let proxyUrl = pm.getProxyUrl(parsedUrl);
        let useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
            agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
            agent = this._agent;
        }
        // if agent is already assigned use that agent.
        if (!!agent) {
            return agent;
        }
        const usingSsl = parsedUrl.protocol === 'https:';
        let maxSockets = 100;
        if (!!this.requestOptions) {
            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (useProxy) {
            // If using proxy, need tunnel
            if (!tunnel) {
                tunnel = __webpack_require__(413);
            }
            const agentOptions = {
                maxSockets: maxSockets,
                keepAlive: this._keepAlive,
                proxy: {
                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`,
                    host: proxyUrl.hostname,
                    port: proxyUrl.port
                }
            };
            let tunnelAgent;
            const overHttps = proxyUrl.protocol === 'https:';
            if (usingSsl) {
                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
            }
            else {
                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
            }
            agent = tunnelAgent(agentOptions);
            this._proxyAgent = agent;
        }
        // if reusing agent across request and tunneling agent isn't assigned create a new agent
        if (this._keepAlive && !agent) {
            const options = { keepAlive: this._keepAlive, maxSockets: maxSockets };
            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
            this._agent = agent;
        }
        // if not using private agent and tunnel agent isn't setup then use global agent
        if (!agent) {
            agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process
            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options
            // we have to cast it to any and change it directly
            agent.options = Object.assign(agent.options || {}, {
                rejectUnauthorized: false
            });
        }
        return agent;
    }
    _performExponentialBackoff(retryNumber) {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise(resolve => setTimeout(() => resolve(), ms));
    }
    static dateTimeDeserializer(key, value) {
        if (typeof value === 'string') {
            let a = new Date(value);
            if (!isNaN(a.valueOf())) {
                return a;
            }
        }
        return value;
    }
    async _processResponse(res, options) {
        return new Promise(async (resolve, reject) => {
            const statusCode = res.message.statusCode;
            const response = {
                statusCode: statusCode,
                result: null,
                headers: {}
            };
            // not found leads to null obj returned
            if (statusCode == HttpCodes.NotFound) {
                resolve(response);
            }
            let obj;
            let contents;
            // get the result from the body
            try {
                contents = await res.readBody();
                if (contents && contents.length > 0) {
                    if (options && options.deserializeDates) {
                        obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);
                    }
                    else {
                        obj = JSON.parse(contents);
                    }
                    response.result = obj;
                }
                response.headers = res.message.headers;
            }
            catch (err) {
                // Invalid resource (contents not json);  leaving result obj null
            }
            // note that 3xx redirects are handled by the http layer.
            if (statusCode > 299) {
                let msg;
                // if exception/error in body, attempt to get better error
                if (obj && obj.message) {
                    msg = obj.message;
                }
                else if (contents && contents.length > 0) {
                    // it may be the case that the exception is in the body message as string
                    msg = contents;
                }
                else {
                    msg = 'Failed request: (' + statusCode + ')';
                }
                let err = new HttpClientError(msg, statusCode);
                err.result = response.result;
                reject(err);
            }
            else {
                resolve(response);
            }
        });
    }
}
exports.HttpClient = HttpClient;


/***/ }),

/***/ 605:
/***/ (function(module) {

module.exports = require("http");

/***/ }),

/***/ 614:
/***/ (function(module) {

module.exports = require("events");

/***/ }),

/***/ 622:
/***/ (function(module) {

module.exports = require("path");

/***/ }),

/***/ 631:
/***/ (function(module) {

module.exports = require("net");

/***/ }),

/***/ 669:
/***/ (function(module) {

module.exports = require("util");

/***/ }),

/***/ 692:
/***/ (function(__unusedmodule, exports) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

class Deprecation extends Error {
  constructor(message) {
    super(message); // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }

    this.name = 'Deprecation';
  }

}

exports.Deprecation = Deprecation;


/***/ }),

/***/ 747:
/***/ (function(module) {

module.exports = require("fs");

/***/ }),

/***/ 753:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var endpoint = __webpack_require__(385);
var universalUserAgent = __webpack_require__(796);
var isPlainObject = __webpack_require__(356);
var nodeFetch = _interopDefault(__webpack_require__(454));
var requestError = __webpack_require__(463);

const VERSION = "5.4.14";

function getBufferResponse(response) {
  return response.arrayBuffer();
}

function fetchWrapper(requestOptions) {
  if (isPlainObject.isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
    requestOptions.body = JSON.stringify(requestOptions.body);
  }

  let headers = {};
  let status;
  let url;
  const fetch = requestOptions.request && requestOptions.request.fetch || nodeFetch;
  return fetch(requestOptions.url, Object.assign({
    method: requestOptions.method,
    body: requestOptions.body,
    headers: requestOptions.headers,
    redirect: requestOptions.redirect
  }, requestOptions.request)).then(response => {
    url = response.url;
    status = response.status;

    for (const keyAndValue of response.headers) {
      headers[keyAndValue[0]] = keyAndValue[1];
    }

    if (status === 204 || status === 205) {
      return;
    } // GitHub API returns 200 for HEAD requests


    if (requestOptions.method === "HEAD") {
      if (status < 400) {
        return;
      }

      throw new requestError.RequestError(response.statusText, status, {
        headers,
        request: requestOptions
      });
    }

    if (status === 304) {
      throw new requestError.RequestError("Not modified", status, {
        headers,
        request: requestOptions
      });
    }

    if (status >= 400) {
      return response.text().then(message => {
        const error = new requestError.RequestError(message, status, {
          headers,
          request: requestOptions
        });

        try {
          let responseBody = JSON.parse(error.message);
          Object.assign(error, responseBody);
          let errors = responseBody.errors; // Assumption `errors` would always be in Array format

          error.message = error.message + ": " + errors.map(JSON.stringify).join(", ");
        } catch (e) {// ignore, see octokit/rest.js#684
        }

        throw error;
      });
    }

    const contentType = response.headers.get("content-type");

    if (/application\/json/.test(contentType)) {
      return response.json();
    }

    if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
      return response.text();
    }

    return getBufferResponse(response);
  }).then(data => {
    return {
      status,
      url,
      headers,
      data
    };
  }).catch(error => {
    if (error instanceof requestError.RequestError) {
      throw error;
    }

    throw new requestError.RequestError(error.message, 500, {
      headers,
      request: requestOptions
    });
  });
}

function withDefaults(oldEndpoint, newDefaults) {
  const endpoint = oldEndpoint.defaults(newDefaults);

  const newApi = function (route, parameters) {
    const endpointOptions = endpoint.merge(route, parameters);

    if (!endpointOptions.request || !endpointOptions.request.hook) {
      return fetchWrapper(endpoint.parse(endpointOptions));
    }

    const request = (route, parameters) => {
      return fetchWrapper(endpoint.parse(endpoint.merge(route, parameters)));
    };

    Object.assign(request, {
      endpoint,
      defaults: withDefaults.bind(null, endpoint)
    });
    return endpointOptions.request.hook(request, endpointOptions);
  };

  return Object.assign(newApi, {
    endpoint,
    defaults: withDefaults.bind(null, endpoint)
  });
}

const request = withDefaults(endpoint.endpoint, {
  headers: {
    "user-agent": `octokit-request.js/${VERSION} ${universalUserAgent.getUserAgent()}`
  }
});

exports.request = request;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 761:
/***/ (function(module) {

module.exports = require("zlib");

/***/ }),

/***/ 794:
/***/ (function(module) {

module.exports = require("stream");

/***/ }),

/***/ 796:
/***/ (function(__unusedmodule, exports) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

function getUserAgent() {
  if (typeof navigator === "object" && "userAgent" in navigator) {
    return navigator.userAgent;
  }

  if (typeof process === "object" && "version" in process) {
    return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
  }

  return "<environment undetectable>";
}

exports.getUserAgent = getUserAgent;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 813:
/***/ (function(__unusedmodule, exports) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

async function auth(token) {
  const tokenType = token.split(/\./).length === 3 ? "app" : /^v\d+\./.test(token) ? "installation" : "oauth";
  return {
    type: "token",
    token: token,
    tokenType
  };
}

/**
 * Prefix token for usage in the Authorization header
 *
 * @param token OAuth token or JSON Web Token
 */
function withAuthorizationPrefix(token) {
  if (token.split(/\./).length === 3) {
    return `bearer ${token}`;
  }

  return `token ${token}`;
}

async function hook(token, request, route, parameters) {
  const endpoint = request.endpoint.merge(route, parameters);
  endpoint.headers.authorization = withAuthorizationPrefix(token);
  return request(endpoint);
}

const createTokenAuth = function createTokenAuth(token) {
  if (!token) {
    throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
  }

  if (typeof token !== "string") {
    throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
  }

  token = token.replace(/^(token|bearer) +/i, "");
  return Object.assign(auth.bind(null, token), {
    hook: hook.bind(null, token)
  });
};

exports.createTokenAuth = createTokenAuth;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 835:
/***/ (function(module) {

module.exports = require("url");

/***/ }),

/***/ 842:
/***/ (function(__unusedmodule, exports) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

const Endpoints = {
  actions: {
    addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
    cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
    createOrUpdateEnvironmentSecret: ["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
    createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
    createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
    createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
    createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
    createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
    createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
    deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    deleteEnvironmentSecret: ["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
    deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
    deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
    deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
    deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
    deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
    disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
    disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
    downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
    downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
    downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
    enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
    enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
    getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
    getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
    getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
    getEnvironmentPublicKey: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],
    getEnvironmentSecret: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
    getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
    getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
    getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
    getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
    getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
    getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
    getRepoPermissions: ["GET /repos/{owner}/{repo}/actions/permissions", {}, {
      renamed: ["actions", "getGithubActionsPermissionsRepository"]
    }],
    getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
    getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
    getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
    getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
    getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
    getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
    getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
    getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
    getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
    listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
    listEnvironmentSecrets: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],
    listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
    listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
    listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
    listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
    listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
    listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
    listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
    listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
    listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
    listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
    listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
    listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
    listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
    reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
    removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
    reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
    setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
    setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
    setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
    setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
    setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
    setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"]
  },
  activity: {
    checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
    deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
    deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
    getFeeds: ["GET /feeds"],
    getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
    getThread: ["GET /notifications/threads/{thread_id}"],
    getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
    listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
    listNotificationsForAuthenticatedUser: ["GET /notifications"],
    listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
    listPublicEvents: ["GET /events"],
    listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
    listPublicEventsForUser: ["GET /users/{username}/events/public"],
    listPublicOrgEvents: ["GET /orgs/{org}/events"],
    listReceivedEventsForUser: ["GET /users/{username}/received_events"],
    listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
    listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
    listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
    listReposStarredByAuthenticatedUser: ["GET /user/starred"],
    listReposStarredByUser: ["GET /users/{username}/starred"],
    listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
    listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
    listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
    listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
    markNotificationsAsRead: ["PUT /notifications"],
    markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
    markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
    setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
    setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
    starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
    unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
  },
  apps: {
    addRepoToInstallation: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
    checkToken: ["POST /applications/{client_id}/token"],
    createContentAttachment: ["POST /content_references/{content_reference_id}/attachments", {
      mediaType: {
        previews: ["corsair"]
      }
    }],
    createFromManifest: ["POST /app-manifests/{code}/conversions"],
    createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
    deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
    deleteInstallation: ["DELETE /app/installations/{installation_id}"],
    deleteToken: ["DELETE /applications/{client_id}/token"],
    getAuthenticated: ["GET /app"],
    getBySlug: ["GET /apps/{app_slug}"],
    getInstallation: ["GET /app/installations/{installation_id}"],
    getOrgInstallation: ["GET /orgs/{org}/installation"],
    getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
    getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
    getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
    getUserInstallation: ["GET /users/{username}/installation"],
    getWebhookConfigForApp: ["GET /app/hook/config"],
    listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
    listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
    listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
    listInstallations: ["GET /app/installations"],
    listInstallationsForAuthenticatedUser: ["GET /user/installations"],
    listPlans: ["GET /marketplace_listing/plans"],
    listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
    listReposAccessibleToInstallation: ["GET /installation/repositories"],
    listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
    listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
    removeRepoFromInstallation: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
    resetToken: ["PATCH /applications/{client_id}/token"],
    revokeInstallationAccessToken: ["DELETE /installation/token"],
    scopeToken: ["POST /applications/{client_id}/token/scoped"],
    suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
    unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
    updateWebhookConfigForApp: ["PATCH /app/hook/config"]
  },
  billing: {
    getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
    getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
    getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
    getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
    getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
    getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
  },
  checks: {
    create: ["POST /repos/{owner}/{repo}/check-runs"],
    createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
    get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
    getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
    listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
    listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
    listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
    listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
    rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
    setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
    update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]
  },
  codeScanning: {
    deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
    getAlert: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}", {}, {
      renamedParameters: {
        alert_id: "alert_number"
      }
    }],
    getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
    getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
    listAlertsInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
    listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
    updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
    uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
  },
  codesOfConduct: {
    getAllCodesOfConduct: ["GET /codes_of_conduct", {
      mediaType: {
        previews: ["scarlet-witch"]
      }
    }],
    getConductCode: ["GET /codes_of_conduct/{key}", {
      mediaType: {
        previews: ["scarlet-witch"]
      }
    }],
    getForRepo: ["GET /repos/{owner}/{repo}/community/code_of_conduct", {
      mediaType: {
        previews: ["scarlet-witch"]
      }
    }]
  },
  emojis: {
    get: ["GET /emojis"]
  },
  enterpriseAdmin: {
    disableSelectedOrganizationGithubActionsEnterprise: ["DELETE /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
    enableSelectedOrganizationGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations/{org_id}"],
    getAllowedActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/selected-actions"],
    getGithubActionsPermissionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions"],
    listSelectedOrganizationsEnabledGithubActionsEnterprise: ["GET /enterprises/{enterprise}/actions/permissions/organizations"],
    setAllowedActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/selected-actions"],
    setGithubActionsPermissionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions"],
    setSelectedOrganizationsEnabledGithubActionsEnterprise: ["PUT /enterprises/{enterprise}/actions/permissions/organizations"]
  },
  gists: {
    checkIsStarred: ["GET /gists/{gist_id}/star"],
    create: ["POST /gists"],
    createComment: ["POST /gists/{gist_id}/comments"],
    delete: ["DELETE /gists/{gist_id}"],
    deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
    fork: ["POST /gists/{gist_id}/forks"],
    get: ["GET /gists/{gist_id}"],
    getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
    getRevision: ["GET /gists/{gist_id}/{sha}"],
    list: ["GET /gists"],
    listComments: ["GET /gists/{gist_id}/comments"],
    listCommits: ["GET /gists/{gist_id}/commits"],
    listForUser: ["GET /users/{username}/gists"],
    listForks: ["GET /gists/{gist_id}/forks"],
    listPublic: ["GET /gists/public"],
    listStarred: ["GET /gists/starred"],
    star: ["PUT /gists/{gist_id}/star"],
    unstar: ["DELETE /gists/{gist_id}/star"],
    update: ["PATCH /gists/{gist_id}"],
    updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
  },
  git: {
    createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
    createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
    createRef: ["POST /repos/{owner}/{repo}/git/refs"],
    createTag: ["POST /repos/{owner}/{repo}/git/tags"],
    createTree: ["POST /repos/{owner}/{repo}/git/trees"],
    deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
    getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
    getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
    getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
    getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
    getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
    listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
    updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
  },
  gitignore: {
    getAllTemplates: ["GET /gitignore/templates"],
    getTemplate: ["GET /gitignore/templates/{name}"]
  },
  interactions: {
    getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
    getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
    getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
    getRestrictionsForYourPublicRepos: ["GET /user/interaction-limits", {}, {
      renamed: ["interactions", "getRestrictionsForAuthenticatedUser"]
    }],
    removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
    removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
    removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
    removeRestrictionsForYourPublicRepos: ["DELETE /user/interaction-limits", {}, {
      renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"]
    }],
    setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
    setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
    setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
    setRestrictionsForYourPublicRepos: ["PUT /user/interaction-limits", {}, {
      renamed: ["interactions", "setRestrictionsForAuthenticatedUser"]
    }]
  },
  issues: {
    addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
    addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
    create: ["POST /repos/{owner}/{repo}/issues"],
    createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    createLabel: ["POST /repos/{owner}/{repo}/labels"],
    createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
    deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
    deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
    get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
    getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
    getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
    getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
    list: ["GET /issues"],
    listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
    listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
    listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
    listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
    listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
    listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline", {
      mediaType: {
        previews: ["mockingbird"]
      }
    }],
    listForAuthenticatedUser: ["GET /user/issues"],
    listForOrg: ["GET /orgs/{org}/issues"],
    listForRepo: ["GET /repos/{owner}/{repo}/issues"],
    listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
    listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
    listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
    lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
    removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
    setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
    unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
    update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
    updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
    updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
    updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
  },
  licenses: {
    get: ["GET /licenses/{license}"],
    getAllCommonlyUsed: ["GET /licenses"],
    getForRepo: ["GET /repos/{owner}/{repo}/license"]
  },
  markdown: {
    render: ["POST /markdown"],
    renderRaw: ["POST /markdown/raw", {
      headers: {
        "content-type": "text/plain; charset=utf-8"
      }
    }]
  },
  meta: {
    get: ["GET /meta"],
    getOctocat: ["GET /octocat"],
    getZen: ["GET /zen"],
    root: ["GET /"]
  },
  migrations: {
    cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
    deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
    getImportStatus: ["GET /repos/{owner}/{repo}/import"],
    getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
    getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    listForAuthenticatedUser: ["GET /user/migrations", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    listForOrg: ["GET /orgs/{org}/migrations", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    listReposForUser: ["GET /user/migrations/{migration_id}/repositories", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
    setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
    startForAuthenticatedUser: ["POST /user/migrations"],
    startForOrg: ["POST /orgs/{org}/migrations"],
    startImport: ["PUT /repos/{owner}/{repo}/import"],
    unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock", {
      mediaType: {
        previews: ["wyandotte"]
      }
    }],
    updateImport: ["PATCH /repos/{owner}/{repo}/import"]
  },
  orgs: {
    blockUser: ["PUT /orgs/{org}/blocks/{username}"],
    cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
    checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
    checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
    checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
    convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
    createInvitation: ["POST /orgs/{org}/invitations"],
    createWebhook: ["POST /orgs/{org}/hooks"],
    deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
    get: ["GET /orgs/{org}"],
    getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
    getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
    getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
    getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
    list: ["GET /organizations"],
    listAppInstallations: ["GET /orgs/{org}/installations"],
    listBlockedUsers: ["GET /orgs/{org}/blocks"],
    listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
    listForAuthenticatedUser: ["GET /user/orgs"],
    listForUser: ["GET /users/{username}/orgs"],
    listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
    listMembers: ["GET /orgs/{org}/members"],
    listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
    listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
    listPendingInvitations: ["GET /orgs/{org}/invitations"],
    listPublicMembers: ["GET /orgs/{org}/public_members"],
    listWebhooks: ["GET /orgs/{org}/hooks"],
    pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
    removeMember: ["DELETE /orgs/{org}/members/{username}"],
    removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
    removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
    removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
    setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
    setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
    unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
    update: ["PATCH /orgs/{org}"],
    updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
    updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
    updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"]
  },
  packages: {
    deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
    deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
    deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    getAllPackageVersionsForAPackageOwnedByAnOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
    getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
    getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
    getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
    getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
    getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
    getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
    restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore"],
    restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore"],
    restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
    restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]
  },
  projects: {
    addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createCard: ["POST /projects/columns/{column_id}/cards", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createColumn: ["POST /projects/{project_id}/columns", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createForAuthenticatedUser: ["POST /user/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createForOrg: ["POST /orgs/{org}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    createForRepo: ["POST /repos/{owner}/{repo}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    delete: ["DELETE /projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    deleteCard: ["DELETE /projects/columns/cards/{card_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    deleteColumn: ["DELETE /projects/columns/{column_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    get: ["GET /projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    getCard: ["GET /projects/columns/cards/{card_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    getColumn: ["GET /projects/columns/{column_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listCards: ["GET /projects/columns/{column_id}/cards", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listCollaborators: ["GET /projects/{project_id}/collaborators", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listColumns: ["GET /projects/{project_id}/columns", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listForOrg: ["GET /orgs/{org}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listForRepo: ["GET /repos/{owner}/{repo}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listForUser: ["GET /users/{username}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    moveCard: ["POST /projects/columns/cards/{card_id}/moves", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    moveColumn: ["POST /projects/columns/{column_id}/moves", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    update: ["PATCH /projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    updateCard: ["PATCH /projects/columns/cards/{card_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    updateColumn: ["PATCH /projects/columns/{column_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }]
  },
  pulls: {
    checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    create: ["POST /repos/{owner}/{repo}/pulls"],
    createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
    createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
    deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
    deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
    get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
    getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
    getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
    list: ["GET /repos/{owner}/{repo}/pulls"],
    listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
    listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
    listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
    listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
    listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
    listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
    listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
    merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
    removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
    requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
    submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
    update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
    updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch", {
      mediaType: {
        previews: ["lydian"]
      }
    }],
    updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
    updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
  },
  rateLimit: {
    get: ["GET /rate_limit"]
  },
  reactions: {
    createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    deleteLegacy: ["DELETE /reactions/{reaction_id}", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }, {
      deprecated: "octokit.reactions.deleteLegacy() is deprecated, see https://docs.github.com/rest/reference/reactions/#delete-a-reaction-legacy"
    }],
    listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }],
    listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", {
      mediaType: {
        previews: ["squirrel-girl"]
      }
    }]
  },
  repos: {
    acceptInvitation: ["PATCH /user/repository_invitations/{invitation_id}"],
    addAppAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
      mapToData: "apps"
    }],
    addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
    addStatusCheckContexts: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
      mapToData: "contexts"
    }],
    addTeamAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
      mapToData: "teams"
    }],
    addUserAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
      mapToData: "users"
    }],
    checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
    checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts", {
      mediaType: {
        previews: ["dorian"]
      }
    }],
    compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
    createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
    createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
      mediaType: {
        previews: ["zzzax"]
      }
    }],
    createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
    createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
    createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
    createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
    createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
    createForAuthenticatedUser: ["POST /user/repos"],
    createFork: ["POST /repos/{owner}/{repo}/forks"],
    createInOrg: ["POST /orgs/{org}/repos"],
    createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
    createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
    createPagesSite: ["POST /repos/{owner}/{repo}/pages", {
      mediaType: {
        previews: ["switcheroo"]
      }
    }],
    createRelease: ["POST /repos/{owner}/{repo}/releases"],
    createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate", {
      mediaType: {
        previews: ["baptiste"]
      }
    }],
    createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
    declineInvitation: ["DELETE /user/repository_invitations/{invitation_id}"],
    delete: ["DELETE /repos/{owner}/{repo}"],
    deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
    deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
    deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
    deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
    deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
    deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
      mediaType: {
        previews: ["zzzax"]
      }
    }],
    deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
    deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
    deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
    deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
    deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages", {
      mediaType: {
        previews: ["switcheroo"]
      }
    }],
    deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
    deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
    deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
    disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes", {
      mediaType: {
        previews: ["london"]
      }
    }],
    disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts", {
      mediaType: {
        previews: ["dorian"]
      }
    }],
    downloadArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}", {}, {
      renamed: ["repos", "downloadZipballArchive"]
    }],
    downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
    downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
    enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes", {
      mediaType: {
        previews: ["london"]
      }
    }],
    enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts", {
      mediaType: {
        previews: ["dorian"]
      }
    }],
    get: ["GET /repos/{owner}/{repo}"],
    getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
    getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
    getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
    getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
    getAllTopics: ["GET /repos/{owner}/{repo}/topics", {
      mediaType: {
        previews: ["mercy"]
      }
    }],
    getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
    getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
    getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
    getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
    getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
    getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
    getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
    getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
    getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
    getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
    getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
      mediaType: {
        previews: ["zzzax"]
      }
    }],
    getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
    getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
    getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
    getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
    getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
    getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
    getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
    getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
    getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
    getPages: ["GET /repos/{owner}/{repo}/pages"],
    getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
    getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
    getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
    getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
    getReadme: ["GET /repos/{owner}/{repo}/readme"],
    getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
    getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
    getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
    getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
    getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
    getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
    getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
    getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
    getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
    getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
    listBranches: ["GET /repos/{owner}/{repo}/branches"],
    listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head", {
      mediaType: {
        previews: ["groot"]
      }
    }],
    listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
    listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
    listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
    listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
    listCommits: ["GET /repos/{owner}/{repo}/commits"],
    listContributors: ["GET /repos/{owner}/{repo}/contributors"],
    listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
    listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
    listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
    listForAuthenticatedUser: ["GET /user/repos"],
    listForOrg: ["GET /orgs/{org}/repos"],
    listForUser: ["GET /users/{username}/repos"],
    listForks: ["GET /repos/{owner}/{repo}/forks"],
    listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
    listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
    listLanguages: ["GET /repos/{owner}/{repo}/languages"],
    listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
    listPublic: ["GET /repositories"],
    listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls", {
      mediaType: {
        previews: ["groot"]
      }
    }],
    listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
    listReleases: ["GET /repos/{owner}/{repo}/releases"],
    listTags: ["GET /repos/{owner}/{repo}/tags"],
    listTeams: ["GET /repos/{owner}/{repo}/teams"],
    listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
    merge: ["POST /repos/{owner}/{repo}/merges"],
    pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
    removeAppAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
      mapToData: "apps"
    }],
    removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
    removeStatusCheckContexts: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
      mapToData: "contexts"
    }],
    removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
    removeTeamAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
      mapToData: "teams"
    }],
    removeUserAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
      mapToData: "users"
    }],
    renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
    replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics", {
      mediaType: {
        previews: ["mercy"]
      }
    }],
    requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
    setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
    setAppAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
      mapToData: "apps"
    }],
    setStatusCheckContexts: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
      mapToData: "contexts"
    }],
    setTeamAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
      mapToData: "teams"
    }],
    setUserAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
      mapToData: "users"
    }],
    testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
    transfer: ["POST /repos/{owner}/{repo}/transfer"],
    update: ["PATCH /repos/{owner}/{repo}"],
    updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
    updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
    updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
    updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
    updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
    updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
    updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
    updateStatusCheckPotection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks", {}, {
      renamed: ["repos", "updateStatusCheckProtection"]
    }],
    updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
    updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
    updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
    uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", {
      baseUrl: "https://uploads.github.com"
    }]
  },
  search: {
    code: ["GET /search/code"],
    commits: ["GET /search/commits", {
      mediaType: {
        previews: ["cloak"]
      }
    }],
    issuesAndPullRequests: ["GET /search/issues"],
    labels: ["GET /search/labels"],
    repos: ["GET /search/repositories"],
    topics: ["GET /search/topics", {
      mediaType: {
        previews: ["mercy"]
      }
    }],
    users: ["GET /search/users"]
  },
  secretScanning: {
    getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
    listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
    updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]
  },
  teams: {
    addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
    addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
    checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
    create: ["POST /orgs/{org}/teams"],
    createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
    createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
    deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
    deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
    deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
    getByName: ["GET /orgs/{org}/teams/{team_slug}"],
    getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
    getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
    getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
    list: ["GET /orgs/{org}/teams"],
    listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
    listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
    listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
    listForAuthenticatedUser: ["GET /user/teams"],
    listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
    listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
    listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects", {
      mediaType: {
        previews: ["inertia"]
      }
    }],
    listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
    removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
    removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
    removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
    updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
    updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
    updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
  },
  users: {
    addEmailForAuthenticated: ["POST /user/emails"],
    block: ["PUT /user/blocks/{username}"],
    checkBlocked: ["GET /user/blocks/{username}"],
    checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
    checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
    createGpgKeyForAuthenticated: ["POST /user/gpg_keys"],
    createPublicSshKeyForAuthenticated: ["POST /user/keys"],
    deleteEmailForAuthenticated: ["DELETE /user/emails"],
    deleteGpgKeyForAuthenticated: ["DELETE /user/gpg_keys/{gpg_key_id}"],
    deletePublicSshKeyForAuthenticated: ["DELETE /user/keys/{key_id}"],
    follow: ["PUT /user/following/{username}"],
    getAuthenticated: ["GET /user"],
    getByUsername: ["GET /users/{username}"],
    getContextForUser: ["GET /users/{username}/hovercard"],
    getGpgKeyForAuthenticated: ["GET /user/gpg_keys/{gpg_key_id}"],
    getPublicSshKeyForAuthenticated: ["GET /user/keys/{key_id}"],
    list: ["GET /users"],
    listBlockedByAuthenticated: ["GET /user/blocks"],
    listEmailsForAuthenticated: ["GET /user/emails"],
    listFollowedByAuthenticated: ["GET /user/following"],
    listFollowersForAuthenticatedUser: ["GET /user/followers"],
    listFollowersForUser: ["GET /users/{username}/followers"],
    listFollowingForUser: ["GET /users/{username}/following"],
    listGpgKeysForAuthenticated: ["GET /user/gpg_keys"],
    listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
    listPublicEmailsForAuthenticated: ["GET /user/public_emails"],
    listPublicKeysForUser: ["GET /users/{username}/keys"],
    listPublicSshKeysForAuthenticated: ["GET /user/keys"],
    setPrimaryEmailVisibilityForAuthenticated: ["PATCH /user/email/visibility"],
    unblock: ["DELETE /user/blocks/{username}"],
    unfollow: ["DELETE /user/following/{username}"],
    updateAuthenticated: ["PATCH /user"]
  }
};

const VERSION = "4.13.4";

function endpointsToMethods(octokit, endpointsMap) {
  const newMethods = {};

  for (const [scope, endpoints] of Object.entries(endpointsMap)) {
    for (const [methodName, endpoint] of Object.entries(endpoints)) {
      const [route, defaults, decorations] = endpoint;
      const [method, url] = route.split(/ /);
      const endpointDefaults = Object.assign({
        method,
        url
      }, defaults);

      if (!newMethods[scope]) {
        newMethods[scope] = {};
      }

      const scopeMethods = newMethods[scope];

      if (decorations) {
        scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
        continue;
      }

      scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);
    }
  }

  return newMethods;
}

function decorate(octokit, scope, methodName, defaults, decorations) {
  const requestWithDefaults = octokit.request.defaults(defaults);
  /* istanbul ignore next */

  function withDecorations(...args) {
    // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
    let options = requestWithDefaults.endpoint.merge(...args); // There are currently no other decorations than `.mapToData`

    if (decorations.mapToData) {
      options = Object.assign({}, options, {
        data: options[decorations.mapToData],
        [decorations.mapToData]: undefined
      });
      return requestWithDefaults(options);
    }

    if (decorations.renamed) {
      const [newScope, newMethodName] = decorations.renamed;
      octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
    }

    if (decorations.deprecated) {
      octokit.log.warn(decorations.deprecated);
    }

    if (decorations.renamedParameters) {
      // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488
      const options = requestWithDefaults.endpoint.merge(...args);

      for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
        if (name in options) {
          octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);

          if (!(alias in options)) {
            options[alias] = options[name];
          }

          delete options[name];
        }
      }

      return requestWithDefaults(options);
    } // @ts-ignore https://github.com/microsoft/TypeScript/issues/25488


    return requestWithDefaults(...args);
  }

  return Object.assign(withDecorations, requestWithDefaults);
}

function restEndpointMethods(octokit) {
  return endpointsToMethods(octokit, Endpoints);
}
restEndpointMethods.VERSION = VERSION;

exports.restEndpointMethods = restEndpointMethods;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 866:
/***/ (function(module) {

module.exports = removeHook;

function removeHook(state, name, method) {
  if (!state.registry[name]) {
    return;
  }

  var index = state.registry[name]
    .map(function (registered) {
      return registered.orig;
    })
    .indexOf(method);

  if (index === -1) {
    return;
  }

  state.registry[name].splice(index, 1);
}


/***/ }),

/***/ 898:
/***/ (function(__unusedmodule, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var request = __webpack_require__(753);
var universalUserAgent = __webpack_require__(796);

const VERSION = "4.6.0";

class GraphqlError extends Error {
  constructor(request, response) {
    const message = response.data.errors[0].message;
    super(message);
    Object.assign(this, response.data);
    Object.assign(this, {
      headers: response.headers
    });
    this.name = "GraphqlError";
    this.request = request; // Maintains proper stack trace (only available on V8)

    /* istanbul ignore next */

    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }

}

const NON_VARIABLE_OPTIONS = ["method", "baseUrl", "url", "headers", "request", "query", "mediaType"];
const GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
function graphql(request, query, options) {
  if (typeof query === "string" && options && "query" in options) {
    return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
  }

  const parsedOptions = typeof query === "string" ? Object.assign({
    query
  }, options) : query;
  const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
    if (NON_VARIABLE_OPTIONS.includes(key)) {
      result[key] = parsedOptions[key];
      return result;
    }

    if (!result.variables) {
      result.variables = {};
    }

    result.variables[key] = parsedOptions[key];
    return result;
  }, {}); // workaround for GitHub Enterprise baseUrl set with /api/v3 suffix
  // https://github.com/octokit/auth-app.js/issues/111#issuecomment-657610451

  const baseUrl = parsedOptions.baseUrl || request.endpoint.DEFAULTS.baseUrl;

  if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
    requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
  }

  return request(requestOptions).then(response => {
    if (response.data.errors) {
      const headers = {};

      for (const key of Object.keys(response.headers)) {
        headers[key] = response.headers[key];
      }

      throw new GraphqlError(requestOptions, {
        headers,
        data: response.data
      });
    }

    return response.data.data;
  });
}

function withDefaults(request$1, newDefaults) {
  const newRequest = request$1.defaults(newDefaults);

  const newApi = (query, options) => {
    return graphql(newRequest, query, options);
  };

  return Object.assign(newApi, {
    defaults: withDefaults.bind(null, newRequest),
    endpoint: request.request.endpoint
  });
}

const graphql$1 = withDefaults(request.request, {
  headers: {
    "user-agent": `octokit-graphql.js/${VERSION} ${universalUserAgent.getUserAgent()}`
  },
  method: "POST",
  url: "/graphql"
});
function withCustomRequest(customRequest) {
  return withDefaults(customRequest, {
    method: "POST",
    url: "/graphql"
  });
}

exports.graphql = graphql$1;
exports.withCustomRequest = withCustomRequest;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ 950:
/***/ (function(__unusedmodule, exports) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function getProxyUrl(reqUrl) {
    let usingSsl = reqUrl.protocol === 'https:';
    let proxyUrl;
    if (checkBypass(reqUrl)) {
        return proxyUrl;
    }
    let proxyVar;
    if (usingSsl) {
        proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];
    }
    else {
        proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];
    }
    if (proxyVar) {
        proxyUrl = new URL(proxyVar);
    }
    return proxyUrl;
}
exports.getProxyUrl = getProxyUrl;
function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
        return false;
    }
    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';
    if (!noProxy) {
        return false;
    }
    // Determine the request port
    let reqPort;
    if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
    }
    else if (reqUrl.protocol === 'http:') {
        reqPort = 80;
    }
    else if (reqUrl.protocol === 'https:') {
        reqPort = 443;
    }
    // Format the request hostname and hostname with port
    let upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === 'number') {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    // Compare request host against noproxy
    for (let upperNoProxyItem of noProxy
        .split(',')
        .map(x => x.trim().toUpperCase())
        .filter(x => x)) {
        if (upperReqHosts.some(x => x === upperNoProxyItem)) {
            return true;
        }
    }
    return false;
}
exports.checkBypass = checkBypass;


/***/ })

/******/ });
```

`instructions.md`:

```md
# Sensum: Setup instructions
Instuctions written by [@mniafi](https://github.com/mniafi/),
Sensum by [@martinjanas](https://github.com/martinjanas/).

__Disclaimer:__<br>
The software is distributed as __source code only__

From Installing Tools to Building DLL's<br>
Host OS: Windows 10 Version 2004 _(19041.928)_
## Step 1 - Installing Visual Studio

Download [Visual Studio 2022 Community](https://visualstudio.microsoft.com/cs/thank-you-downloading-visual-studio/?sku=Community&channel=Release&version=VS2022&source=VSLandingPage&cid=2030&passive=false).

>![Screen#1](https://snipboard.io/wM78Pg.jpg)

Open the installer and wait until the installer shows up:

>![screenshot#2](https://snipboard.io/A3SNfe.jpg)

After some time you will see something like this:

>![screenshot#3](https://snipboard.io/yMQNC1.jpg)

Select __Desktop development with C++__ and click __Install__ : (You can unclick everything except Windows 10 SDK, MSVC and IntelliCode to save space)

>![screenshot#4](https://snipboard.io/L6Pvwp.jpg)

Now wait for installation...
>![screenshot#5](https://snipboard.io/YpVBtJ.jpg)

After installing You will get this window:
>![screenshot#6](https://snipboard.io/BI7vnx.jpg)

if you have Microsoft account u can __Sign In__.
if not just click __Not now, maybe later__

(Optional) Next step, select _color theme_ , i use dark one. Click on __Start Visual Studio__ :
>![screenshot#7](https://snipboard.io/NxjFWY.jpg)

After some time, VS will appear, you can close the window.
>![screenshot#8](https://snipboard.io/qjckoI.jpg)
 
## Step 2 - Downloading DirectX SDK
 
 Just download this package [DXSDK_Jun10.exe](https://sensum.page.link/directxsdk). _(572MB)_

 After downloading, run the installer:
 >![screenshot#8](https://snipboard.io/Vhp59A.jpg)

 Click __Next__ , Accept Terms in the license agreement:
>![screenshot#9](https://snipboard.io/0IQyV1.jpg)

Click  __Next__ and Select one of the options:
>![screenshot#10](https://snipboard.io/gAE36P.jpg)

Click __Next__ Select Destination Folder (_dont change this_) and click __Next__ again.
Dont change here anything, just click __Next__

>![screenshot#10](https://snipboard.io/cC2YeR.jpg)

Finish installation.

Or you can use light version, created by [@mniafi](https://github.com/mniafi/), [DirectX SDK Installer](https://github.com/mniafi/directxsdk/releases/latest)<br>
Just Extracts Lib and Include folders and DirectX Redist Installation.<br>

## Step 3 - Sensum

First of all, go to the original [Sensum Github](https://github.com/martinjanas/Sensum) for latest version.

_version history on my [Github](https://github.com/mniafi/sensum) page_

MartiN's Github page:
>![screenshot#13](https://snipboard.io/acGg0j.jpg)

click on Green __code__ button and select __Download ZIP__
>![screenshot#14](https://snipboard.io/nSU9q6.jpg)

You will get file named: _Sensum-master.zip_ , extract it to _Desktop_:
>![screenshot#15](https://snipboard.io/5Q4n3N.jpg)

Run __sensum.sln__ from folder you extracted:
>![screenshot#16](https://snipboard.io/9cLGiY.jpg)

Select Second one here:
>![screenshot#16](https://snipboard.io/V47fya.jpg)

Here just click __OK__
>![screenshot#17](https://snipboard.io/8ATHIz.jpg)

Here change __Debug x86__
>![screenshot#18](https://snipboard.io/H1fL6r.jpg)

to __Release x86__
>![screenshot#19](https://snipboard.io/GHQ4pt.jpg)

### CPU Instruction Set

By default, Sensum is configured for __SSE2__ Instruction set.<br>
It's not neccessary to change but if you want to gain more performance or if you **keep crashing on inject**,
You can change it to __AVX, AVX2 or AVX512__.<br>
Every CPU has __different instruction set__.<br>
Google your CPU to see what instruction set it supports.

For example, host has __i7 3770 CPU__

__Google__: i7 3770 and click on __intel's webpage__

looks like this:
>![screenshot#20](https://snipboard.io/GfRDlL.jpg)

lookup for something like this:
>![screenshot#21](https://snipboard.io/V3ZdU0.jpg)

here you can see, that my CPU is using __SSE__ and __AVX__

### Project Configuration
So I can enable __AVX__ in Source;
Go to __Project__ > __Properties__
>![screenshot#22](https://snipboard.io/TJUYoX.jpg)

Next go to __C++__ > __Code Generation__
>![screenshot#23](https://snipboard.io/vBWmjV.jpg)

Selecting __AVX__ because my CPU __SUPPORTS__ this
>![screenshot#24](https://snipboard.io/6BDQb8.jpg)

Click __OK__ button and window will close.

Done! Few steps to get __DLL__!

### Building Sensum.dll
Now Go to __Build__ > __Build Solution__
>![screenshot#25](https://snipboard.io/BuT5n2.jpg)

Wait for build...
>![screenshot#26](https://snipboard.io/Ensq4F.jpg)

After Succesful build you will get this:

```
1>Sensum.vcxproj -> C:\Users\user\Desktop\Sensum-master\bin\Release\Sensum.dll
1>Done building project "Sensum.vcxproj".
========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========

```
Congrats! __Sensum.dll__ builded!

## FAQ

1. DirectX SDK S1023 error: Just click continue.
 
2. Config location: __C:\Sensum\configs__


```

`lib/main.js`:

```js
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const core = __importStar(require("@actions/core"));
const github = __importStar(require("@actions/github"));
function run() {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const issueCloseMessage = core.getInput('issue-close-message');
            if (!issueCloseMessage) {
                throw new Error('Action must have at least one of issue-close-message set');
            }
            const issueBodyPattern = core.getInput('issue-body-pattern');
            const issueTitlePattern = core.getInput('issue-title-pattern');
            if (!issueBodyPattern && !issueBodyPattern) {
                throw new Error('Action must have at least one of issue-body-pattern or issue-title-pattern set');
            }
            // Get client and context
            const client = new github.GitHub(core.getInput('repo-token', { required: true }));
            const context = github.context;
            const payload = context.payload;
            // Do nothing if it's wasn't being opened or it's not an issue
            if (payload.action !== 'opened' || !payload.issue) {
                return;
            }
            if (!payload.sender) {
                throw new Error('Internal error, no sender provided by GitHub');
            }
            const issue = context.issue;
            const bodyMatches = check(issueBodyPattern, (_a = payload === null || payload === void 0 ? void 0 : payload.issue) === null || _a === void 0 ? void 0 : _a.body);
            const titleMatches = check(issueTitlePattern, (_b = payload === null || payload === void 0 ? void 0 : payload.issue) === null || _b === void 0 ? void 0 : _b.title);
            // Do nothing if no match
            if (!bodyMatches && !titleMatches) {
                return;
            }
            // Comment and close
            yield client.issues.createComment({
                owner: issue.owner,
                repo: issue.repo,
                issue_number: issue.number,
                body: evalTemplate(issueCloseMessage, payload)
            });
            yield client.issues.update({
                owner: issue.owner,
                repo: issue.repo,
                issue_number: issue.number,
                state: 'closed'
            });
        }
        catch (error) {
            core.setFailed(error.message);
            return;
        }
    });
}
function check(patternString, text) {
    const pattern = new RegExp(patternString);
    if (text === null || text === void 0 ? void 0 : text.match(pattern)) {
        return true;
    }
    else {
        return false;
    }
}
function evalTemplate(template, params) {
    return Function(...Object.keys(params), `return \`${template}\``)(...Object.values(params));
}
run();

```

`src/Sensum.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{F3E42845-8D56-4BB3-821D-8163AB1337F0}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>Sensum</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
    <ProjectName>Sensum</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
    <EnableASAN>false</EnableASAN>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <EnableASAN>false</EnableASAN>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(ProjectName)\$(Configuration)\</IntDir>
    <IncludePath>C:\Windows SDK\Include;$(VC_IncludePath);$(WindowsSDK_IncludePath);$(DXSDK_DIR)Include</IncludePath>
    <TargetName>Sensum</TargetName>
    <LibraryPath>C:\Windows SDK\Lib\x86;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)bin\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)build\$(ProjectName)\$(Configuration)\</IntDir>
    <IncludePath>C:\Windows SDK\Include;$(VC_IncludePath);$(WindowsSDK_IncludePath);$(DXSDK_DIR)Include</IncludePath>
    <TargetName>Sensum</TargetName>
    <LibraryPath>C:\Windows SDK\Lib\x86;C:\Program Files %28x86%29\Microsoft DirectX SDK %28June 2010%29\Lib\x86;$(LibraryPath)</LibraryPath>
    <EmbedManifest>false</EmbedManifest>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;CSGOSIMPLE_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <EnableParallelCodeGeneration>true</EnableParallelCodeGeneration>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <MinimalRebuild>false</MinimalRebuild>
      <ExceptionHandling>Async</ExceptionHandling>
      <EnableEnhancedInstructionSet>StreamingSIMDExtensions2</EnableEnhancedInstructionSet>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <AdditionalOptions>/D_ITERATOR_DEBUG_LEVEL=0 %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>DebugFastLink</GenerateDebugInformation>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>true</BufferSecurityCheck>
      <DebugInformationFormat>None</DebugInformationFormat>
      <SDLCheck>true</SDLCheck>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <MinimalRebuild>false</MinimalRebuild>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <ExceptionHandling>Async</ExceptionHandling>
      <EnableEnhancedInstructionSet>AdvancedVectorExtensions2</EnableEnhancedInstructionSet>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <OutputFile>$(OutDir)$(TargetName)$(TargetExt)</OutputFile>
      <ImportLibrary>$(OutDir)$(TargetName).lib</ImportLibrary>
    </Link>
    <Manifest>
      <VerboseOutput>false</VerboseOutput>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="features\auto_strafe.cpp" />
    <ClCompile Include="features\bhop.cpp" />
    <ClCompile Include="features\bomb_event_info.cpp" />
    <ClCompile Include="features\buylogger.cpp" />
    <ClCompile Include="features\lefthand_knife.cpp" />
    <ClCompile Include="features\player_infobox.cpp" />
    <ClCompile Include="features\selfnade.cpp" />
    <ClCompile Include="features\thirdperson.cpp" />
    <ClCompile Include="hooks\hooked_functions\draw_model_execute.cpp" />
    <ClCompile Include="hooks\hooked_functions\game_event_listener.cpp" />
    <ClCompile Include="hooks\hooked_functions\get_color_modulation.cpp" />
    <ClCompile Include="hooks\hooked_functions\is_using_static_debug_prop_modes.cpp" />
    <ClCompile Include="hooks\hooked_functions\override_view.cpp" />
    <ClCompile Include="hooks\hooked_functions\paint_traverse.cpp" />
    <ClCompile Include="valve_sdk\classids.cpp" />
    <ClCompile Include="features\aimbot.cpp" />
    <ClCompile Include="features\chams.cpp" />
    <ClCompile Include="features\color_modulate.cpp" />
    <ClCompile Include="features\fast_stop.cpp" />
    <ClCompile Include="features\grenade_prediction.cpp" />
    <ClCompile Include="features\nade_helper.cpp" />
    <ClCompile Include="features\popflash_helper.cpp" />
    <ClCompile Include="helpers\autowall.cpp" />
    <ClCompile Include="helpers\console.cpp" />
    <ClCompile Include="helpers\entities.cpp" />
    <ClCompile Include="helpers\imdraw.cpp" />
    <ClCompile Include="helpers\input.cpp" />
    <ClCompile Include="helpers\notifies.cpp" />
    <ClCompile Include="helpers\utils.cpp" />
    <ClCompile Include="hooks\hooked_functions\create_move.cpp" />
    <ClCompile Include="hooks\hooked_functions\frame_stage_notify.cpp" />
    <ClCompile Include="hooks\hooks.cpp" />
    <ClCompile Include="hooks\hooked_functions\present.cpp" />
    <ClCompile Include="hooks\hooked_functions\reset.cpp" />
    <ClCompile Include="hooks\hooked_functions\sequence.cpp" />
    <ClCompile Include="minhook\buffer.c" />
    <ClCompile Include="minhook\hde\hde32.c" />
    <ClCompile Include="minhook\hook.c" />
    <ClCompile Include="minhook\trampoline.c" />
    <ClCompile Include="render\fonts\droidsans.hpp" />
    <ClCompile Include="render\tabs\aimbot_tab.cpp" />
    <ClCompile Include="render\tabs\colors_tab.cpp" />
    <ClCompile Include="render\tabs\configs_tab.cpp" />
    <ClCompile Include="render\tabs\misc_tab.cpp" />
    <ClCompile Include="render\tabs\players_tab.cpp" />
    <ClCompile Include="render\tabs\skins_tab.cpp" />
    <ClCompile Include="render\tabs\visuals_tab.cpp" />
    <ClCompile Include="render\timers.cpp" />
    <ClCompile Include="render\menu.cpp" />
    <ClCompile Include="render\render.cpp" />
    <ClCompile Include="render\spectators.cpp" />
    <ClCompile Include="security\xor.h" />
    <ClCompile Include="features\esp.cpp" />
    <ClCompile Include="features\skins.cpp" />
    <ClCompile Include="features\visuals.cpp" />
    <ClCompile Include="helpers\math.cpp" />
    <ClCompile Include="imgui\directx9\imgui_impl_dx9.cpp" />
    <ClCompile Include="imgui\imgui.cpp" />
    <ClCompile Include="imgui\imgui_draw.cpp" />
    <ClCompile Include="jsoncpp\jsoncpp.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="settings\config.cpp" />
    <ClCompile Include="settings\globals.cpp" />
    <ClCompile Include="settings\options.cpp" />
    <ClCompile Include="settings\settings.cpp" />
    <ClCompile Include="valve_sdk\csgostructs.cpp" />
    <ClCompile Include="valve_sdk\kit_parser.cpp" />
    <ClCompile Include="valve_sdk\math\Vectors.cpp" />
    <ClCompile Include="valve_sdk\misc\checksum_crc.cpp" />
    <ClCompile Include="valve_sdk\patterns.cpp" />
    <ClCompile Include="valve_sdk\sdk.cpp" />
    <ClCompile Include="valve_sdk\math\VMatrix.cpp" />
    <ClCompile Include="valve_sdk\misc\characterset.cpp" />
    <ClCompile Include="valve_sdk\misc\Color.cpp" />
    <ClCompile Include="valve_sdk\misc\Convar.cpp" />
    <ClCompile Include="valve_sdk\misc\UtlBuffer.cpp" />
    <ClCompile Include="valve_sdk\misc\UtlString.cpp" />
    <ClCompile Include="valve_sdk\netvars.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="hooks\hooked_functions\game_event_listener.h" />
    <ClInclude Include="render\menu_strings.h" />
    <ClInclude Include="valve_sdk\classids.h" />
    <ClInclude Include="features\nade_helper.h" />
    <ClInclude Include="features\popflash_helper.h" />
    <ClInclude Include="helpers\autowall.h" />
    <ClInclude Include="helpers\console.h" />
    <ClInclude Include="helpers\entities.h" />
    <ClInclude Include="helpers\fnv.h" />
    <ClInclude Include="helpers\imdraw.h" />
    <ClInclude Include="helpers\input.h" />
    <ClInclude Include="helpers\notifies.h" />
    <ClInclude Include="helpers\utils.h" />
    <ClInclude Include="hooks\hooks.h" />
    <ClInclude Include="imgui\stb_rect_pack.h" />
    <ClInclude Include="imgui\stb_textedit.h" />
    <ClInclude Include="imgui\stb_truetype.h" />
    <ClInclude Include="valve_sdk\interfaces\INetMessage.h" />
    <ClInclude Include="minhook\buffer.h" />
    <ClInclude Include="minhook\hde\hde32.h" />
    <ClInclude Include="minhook\hde\pstdint.h" />
    <ClInclude Include="minhook\hde\table32.h" />
    <ClInclude Include="minhook\minhook.h" />
    <ClInclude Include="minhook\trampoline.h" />
    <ClInclude Include="render\fonts\undefeated.hpp" />
    <ClInclude Include="render\render.h" />
    <ClInclude Include="security\importer.h" />
    <ClInclude Include="features\features.h" />
    <ClInclude Include="helpers\math.h" />
    <ClInclude Include="imgui\directx9\imgui_impl_dx9.h" />
    <ClInclude Include="imgui\imgui.h" />
    <ClInclude Include="imgui\imgui_internal.h" />
    <ClInclude Include="jsoncpp\json-forwards.h" />
    <ClInclude Include="jsoncpp\json.h" />
    <ClInclude Include="settings\config.h" />
    <ClInclude Include="settings\globals.h" />
    <ClInclude Include="settings\options.hpp" />
    <ClInclude Include="settings\settings.h" />
    <ClInclude Include="valve_sdk\csgostructs.hpp" />
    <ClInclude Include="valve_sdk\interfaces\CClientState.h" />
    <ClInclude Include="valve_sdk\interfaces\CFireBullets.h" />
    <ClInclude Include="valve_sdk\interfaces\CGlobalVarsBase.h" />
    <ClInclude Include="valve_sdk\interfaces\CGlowObjectManager.h" />
    <ClInclude Include="valve_sdk\interfaces\CHud.h" />
    <ClInclude Include="valve_sdk\interfaces\CHudChat.h" />
    <ClInclude Include="valve_sdk\interfaces\IAppSystem.h" />
    <ClInclude Include="valve_sdk\interfaces\IBaseClientDLL.h" />
    <ClInclude Include="valve_sdk\interfaces\ICvar.h" />
    <ClInclude Include="valve_sdk\interfaces\IEngineSound.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IFileSystem.h" />
    <ClInclude Include="valve_sdk\interfaces\IInputSystem.h" />
    <ClInclude Include="valve_sdk\interfaces\ILocalize.h" />
    <ClInclude Include="valve_sdk\interfaces\IMaterial.h" />
    <ClInclude Include="valve_sdk\interfaces\IMaterialVar.h" />
    <ClInclude Include="valve_sdk\interfaces\IMemAlloc.h" />
    <ClInclude Include="valve_sdk\interfaces\IRefCounted.h" />
    <ClInclude Include="valve_sdk\interfaces\IStudioRender.h" />
    <ClInclude Include="valve_sdk\interfaces\ISurface.h" />
    <ClInclude Include="valve_sdk\interfaces\IVDebugOverlay.h" />
    <ClInclude Include="valve_sdk\interfaces\IViewRenderBeams.h" />
    <ClInclude Include="valve_sdk\interfaces\IVModelInfo.h" />
    <ClInclude Include="valve_sdk\interfaces\IVModelRender.h" />
    <ClInclude Include="valve_sdk\interfaces\IVRenderView.h" />
    <ClInclude Include="valve_sdk\interfaces\ServerClass.h" />
    <ClInclude Include="valve_sdk\kit_parser.hpp" />
    <ClInclude Include="valve_sdk\math\Vectors.hpp" />
    <ClInclude Include="valve_sdk\misc\checksum_crc.hpp" />
    <ClInclude Include="valve_sdk\misc\vfunc.hpp" />
    <ClInclude Include="valve_sdk\patterns.h" />
    <ClInclude Include="valve_sdk\sdk.hpp" />
    <ClInclude Include="valve_sdk\interfaces\CInput.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientEntity.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientEntityList.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientMode.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientNetworkable.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientRenderable.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientThinkable.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IClientUnknown.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IConVar.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IEngineTrace.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IGameEvent.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IMaterialSystem.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IMDLCache.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IMoveHelper.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IPanel.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IPhysics.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IPrediction.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IVEngineClient.hpp" />
    <ClInclude Include="valve_sdk\interfaces\IViewRender.hpp" />
    <ClInclude Include="valve_sdk\math\QAngle.hpp" />
    <ClInclude Include="valve_sdk\math\VMatrix.hpp" />
    <ClInclude Include="valve_sdk\misc\BaseHandle.hpp" />
    <ClInclude Include="valve_sdk\misc\characterset.hpp" />
    <ClInclude Include="valve_sdk\misc\ClientClass.hpp" />
    <ClInclude Include="valve_sdk\misc\Color.hpp" />
    <ClInclude Include="valve_sdk\misc\Convar.hpp" />
    <ClInclude Include="valve_sdk\misc\CUserCmd.hpp" />
    <ClInclude Include="valve_sdk\misc\EHandle.hpp" />
    <ClInclude Include="valve_sdk\misc\Enums.hpp" />
    <ClInclude Include="valve_sdk\misc\IHandleEntity.hpp" />
    <ClInclude Include="valve_sdk\misc\platform.hpp" />
    <ClInclude Include="valve_sdk\misc\Recv.hpp" />
    <ClInclude Include="valve_sdk\misc\Studio.hpp" />
    <ClInclude Include="valve_sdk\misc\UtlBuffer.hpp" />
    <ClInclude Include="valve_sdk\misc\UtlMemory.hpp" />
    <ClInclude Include="valve_sdk\misc\UtlString.hpp" />
    <ClInclude Include="valve_sdk\misc\UtlVector.hpp" />
    <ClInclude Include="valve_sdk\netvars.hpp" />
    <ClInclude Include="valve_sdk\steam.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/Sensum.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="features">
      <UniqueIdentifier>{96110a9e-6a7c-4f81-8439-0098de2376a8}</UniqueIdentifier>
    </Filter>
    <Filter Include="features\misc">
      <UniqueIdentifier>{349a7a67-ab42-4d6e-924e-4c373046a9c8}</UniqueIdentifier>
    </Filter>
    <Filter Include="render">
      <UniqueIdentifier>{6702b6cf-3aab-4b19-a204-73fca927030d}</UniqueIdentifier>
    </Filter>
    <Filter Include="hooks">
      <UniqueIdentifier>{358b31a5-4b06-4738-a8ce-1f92e00b3c0d}</UniqueIdentifier>
    </Filter>
    <Filter Include="render\fonts">
      <UniqueIdentifier>{16f626b5-04a9-48f7-aa6e-65788ad04b55}</UniqueIdentifier>
    </Filter>
    <Filter Include="features\visuals">
      <UniqueIdentifier>{74267e1a-7998-414b-886e-d71f52514088}</UniqueIdentifier>
    </Filter>
    <Filter Include="features\movement">
      <UniqueIdentifier>{e76a48bf-21ba-49dd-a1b3-c71e16e87ecf}</UniqueIdentifier>
    </Filter>
    <Filter Include="valve_sdk">
      <UniqueIdentifier>{7c1dc5a2-67bd-44d2-85a8-d72978e0971a}</UniqueIdentifier>
    </Filter>
    <Filter Include="valve_sdk\interfaces">
      <UniqueIdentifier>{62d9e389-6f5d-431b-a47a-e6152d85df84}</UniqueIdentifier>
    </Filter>
    <Filter Include="valve_sdk\math">
      <UniqueIdentifier>{2656ef91-fef8-4898-a01e-7a2728ea194e}</UniqueIdentifier>
    </Filter>
    <Filter Include="valve_sdk\misc">
      <UniqueIdentifier>{9de931ed-b6a8-42dd-bdfc-39e509a442d3}</UniqueIdentifier>
    </Filter>
    <Filter Include="render\tabs">
      <UniqueIdentifier>{dcb7f1c4-aed0-4904-a508-99f9b426819b}</UniqueIdentifier>
    </Filter>
    <Filter Include="security">
      <UniqueIdentifier>{bf2b8af1-74b2-484c-8e4a-737cf672c13b}</UniqueIdentifier>
    </Filter>
    <Filter Include="helpers">
      <UniqueIdentifier>{aeae5db0-75a8-4cb2-b337-374a068dc2fb}</UniqueIdentifier>
    </Filter>
    <Filter Include="dependencies">
      <UniqueIdentifier>{14f0176c-ba3f-4a98-8b85-3aeb63269705}</UniqueIdentifier>
    </Filter>
    <Filter Include="dependencies\imgui">
      <UniqueIdentifier>{be04c48c-66c1-4221-ac11-38f6bab82130}</UniqueIdentifier>
    </Filter>
    <Filter Include="dependencies\jsoncpp">
      <UniqueIdentifier>{c5f1c7ee-cbc0-43fb-9cd7-aec2fa44fd55}</UniqueIdentifier>
    </Filter>
    <Filter Include="dependencies\minhook">
      <UniqueIdentifier>{e97dbaba-3b31-4440-8e0a-501aaec77939}</UniqueIdentifier>
    </Filter>
    <Filter Include="dependencies\minhook\hde">
      <UniqueIdentifier>{7e578ba7-ca02-45dd-bf8d-51dfc9e9ec20}</UniqueIdentifier>
    </Filter>
    <Filter Include="settings">
      <UniqueIdentifier>{a9d718e4-2001-444f-b3bb-120e3851551e}</UniqueIdentifier>
    </Filter>
    <Filter Include="hooks\hooked_functions">
      <UniqueIdentifier>{761b9c90-a11e-4bba-9d25-a6c7b6b3a8c2}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="valve_sdk\csgostructs.cpp">
      <Filter>valve_sdk</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\netvars.cpp">
      <Filter>valve_sdk</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\sdk.cpp">
      <Filter>valve_sdk</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\characterset.cpp">
      <Filter>valve_sdk\misc</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\Color.cpp">
      <Filter>valve_sdk\misc</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\Convar.cpp">
      <Filter>valve_sdk\misc</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\UtlBuffer.cpp">
      <Filter>valve_sdk\misc</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\UtlString.cpp">
      <Filter>valve_sdk\misc</Filter>
    </ClCompile>
    <ClCompile Include="helpers\math.cpp">
      <Filter>helpers</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\math\VMatrix.cpp">
      <Filter>valve_sdk\math</Filter>
    </ClCompile>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="imgui\imgui.cpp">
      <Filter>dependencies\imgui</Filter>
    </ClCompile>
    <ClCompile Include="imgui\imgui_draw.cpp">
      <Filter>dependencies\imgui</Filter>
    </ClCompile>
    <ClCompile Include="imgui\directx9\imgui_impl_dx9.cpp">
      <Filter>dependencies\imgui</Filter>
    </ClCompile>
    <ClCompile Include="jsoncpp\jsoncpp.cpp">
      <Filter>dependencies\jsoncpp</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\math\Vectors.cpp">
      <Filter>valve_sdk\math</Filter>
    </ClCompile>
    <ClCompile Include="helpers\console.cpp">
      <Filter>helpers</Filter>
    </ClCompile>
    <ClCompile Include="helpers\utils.cpp">
      <Filter>helpers</Filter>
    </ClCompile>
    <ClCompile Include="helpers\input.cpp">
      <Filter>helpers</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\misc\checksum_crc.cpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClCompile>
    <ClCompile Include="render\render.cpp">
      <Filter>render</Filter>
    </ClCompile>
    <ClCompile Include="render\menu.cpp">
      <Filter>render</Filter>
    </ClCompile>
    <ClCompile Include="render\spectators.cpp">
      <Filter>render</Filter>
    </ClCompile>
    <ClCompile Include="render\timers.cpp">
      <Filter>render</Filter>
    </ClCompile>
    <ClCompile Include="render\fonts\droidsans.hpp">
      <Filter>render\fonts</Filter>
    </ClCompile>
    <ClCompile Include="features\skins.cpp">
      <Filter>features\misc</Filter>
    </ClCompile>
    <ClCompile Include="features\color_modulate.cpp">
      <Filter>features\visuals</Filter>
    </ClCompile>
    <ClCompile Include="helpers\notifies.cpp">
      <Filter>helpers</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooks.cpp">
      <Filter>hooks</Filter>
    </ClCompile>
    <ClCompile Include="render\tabs\visuals_tab.cpp">
      <Filter>render\tabs</Filter>
    </ClCompile>
    <ClCompile Include="render\tabs\configs_tab.cpp">
      <Filter>render\tabs</Filter>
    </ClCompile>
    <ClCompile Include="render\tabs\aimbot_tab.cpp">
      <Filter>render\tabs</Filter>
    </ClCompile>
    <ClCompile Include="render\tabs\players_tab.cpp">
      <Filter>render\tabs</Filter>
    </ClCompile>
    <ClCompile Include="render\tabs\misc_tab.cpp">
      <Filter>render\tabs</Filter>
    </ClCompile>
    <ClCompile Include="render\tabs\skins_tab.cpp">
      <Filter>render\tabs</Filter>
    </ClCompile>
    <ClCompile Include="helpers\entities.cpp">
      <Filter>helpers</Filter>
    </ClCompile>
    <ClCompile Include="helpers\imdraw.cpp">
      <Filter>helpers</Filter>
    </ClCompile>
    <ClCompile Include="helpers\autowall.cpp">
      <Filter>helpers</Filter>
    </ClCompile>
    <ClCompile Include="features\esp.cpp">
      <Filter>features\visuals</Filter>
    </ClCompile>
    <ClCompile Include="features\grenade_prediction.cpp">
      <Filter>features\visuals</Filter>
    </ClCompile>
    <ClCompile Include="features\visuals.cpp">
      <Filter>features\visuals</Filter>
    </ClCompile>
    <ClCompile Include="security\xor.h">
      <Filter>valve_sdk</Filter>
    </ClCompile>
    <ClCompile Include="minhook\buffer.c">
      <Filter>dependencies\minhook</Filter>
    </ClCompile>
    <ClCompile Include="minhook\hook.c">
      <Filter>dependencies\minhook</Filter>
    </ClCompile>
    <ClCompile Include="minhook\trampoline.c">
      <Filter>dependencies\minhook</Filter>
    </ClCompile>
    <ClCompile Include="minhook\hde\hde32.c">
      <Filter>dependencies\minhook\hde</Filter>
    </ClCompile>
    <ClCompile Include="features\chams.cpp">
      <Filter>features\visuals</Filter>
    </ClCompile>
    <ClCompile Include="features\fast_stop.cpp">
      <Filter>features\movement</Filter>
    </ClCompile>
    <ClCompile Include="features\nade_helper.cpp">
      <Filter>features\misc</Filter>
    </ClCompile>
    <ClCompile Include="settings\config.cpp">
      <Filter>settings</Filter>
    </ClCompile>
    <ClCompile Include="settings\globals.cpp">
      <Filter>settings</Filter>
    </ClCompile>
    <ClCompile Include="settings\options.cpp">
      <Filter>settings</Filter>
    </ClCompile>
    <ClCompile Include="settings\settings.cpp">
      <Filter>settings</Filter>
    </ClCompile>
    <ClCompile Include="render\tabs\colors_tab.cpp">
      <Filter>render\tabs</Filter>
    </ClCompile>
    <ClCompile Include="features\aimbot.cpp">
      <Filter>features\movement</Filter>
    </ClCompile>
    <ClCompile Include="features\popflash_helper.cpp">
      <Filter>features\misc</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\kit_parser.cpp">
      <Filter>valve_sdk</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\classids.cpp">
      <Filter>valve_sdk</Filter>
    </ClCompile>
    <ClCompile Include="features\bomb_event_info.cpp">
      <Filter>features\misc</Filter>
    </ClCompile>
    <ClCompile Include="features\lefthand_knife.cpp">
      <Filter>features\misc</Filter>
    </ClCompile>
    <ClCompile Include="valve_sdk\patterns.cpp">
      <Filter>valve_sdk</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked_functions\create_move.cpp">
      <Filter>hooks\hooked_functions</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked_functions\draw_model_execute.cpp">
      <Filter>hooks\hooked_functions</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked_functions\frame_stage_notify.cpp">
      <Filter>hooks\hooked_functions</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked_functions\get_color_modulation.cpp">
      <Filter>hooks\hooked_functions</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked_functions\is_using_static_debug_prop_modes.cpp">
      <Filter>hooks\hooked_functions</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked_functions\override_view.cpp">
      <Filter>hooks\hooked_functions</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked_functions\paint_traverse.cpp">
      <Filter>hooks\hooked_functions</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked_functions\present.cpp">
      <Filter>hooks\hooked_functions</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked_functions\reset.cpp">
      <Filter>hooks\hooked_functions</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked_functions\sequence.cpp">
      <Filter>hooks\hooked_functions</Filter>
    </ClCompile>
    <ClCompile Include="features\thirdperson.cpp">
      <Filter>features\misc</Filter>
    </ClCompile>
    <ClCompile Include="hooks\hooked_functions\game_event_listener.cpp">
      <Filter>hooks\hooked_functions</Filter>
    </ClCompile>
    <ClCompile Include="features\player_infobox.cpp">
      <Filter>features\misc</Filter>
    </ClCompile>
    <ClCompile Include="features\bhop.cpp" />
    <ClCompile Include="features\auto_strafe.cpp" />
    <ClCompile Include="features\selfnade.cpp" />
    <ClCompile Include="features\buylogger.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="imgui\directx9\imgui_impl_dx9.h">
      <Filter>dependencies\imgui</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imgui_internal.h">
      <Filter>dependencies\imgui</Filter>
    </ClInclude>
    <ClInclude Include="imgui\imgui.h">
      <Filter>dependencies\imgui</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IViewRender.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IVEngineClient.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IPrediction.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IPhysics.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IPanel.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IMoveHelper.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IMDLCache.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IMaterialSystem.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IEngineTrace.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IConVar.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientThinkable.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientRenderable.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientUnknown.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientEntityList.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientNetworkable.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientMode.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IClientEntity.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\CInput.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\math\VMatrix.hpp">
      <Filter>valve_sdk\math</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\BaseHandle.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\ClientClass.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\Color.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\Convar.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\characterset.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\CUserCmd.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\EHandle.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\Enums.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\IHandleEntity.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\platform.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\Recv.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\Studio.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\UtlBuffer.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\UtlMemory.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\UtlString.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\UtlVector.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\vfunc.hpp">
      <Filter>valve_sdk\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\csgostructs.hpp">
      <Filter>valve_sdk</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\netvars.hpp">
      <Filter>valve_sdk</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\sdk.hpp">
      <Filter>valve_sdk</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IRefCounted.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="jsoncpp\json.h">
      <Filter>dependencies\jsoncpp</Filter>
    </ClInclude>
    <ClInclude Include="jsoncpp\json-forwards.h">
      <Filter>dependencies\jsoncpp</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\math\QAngle.hpp">
      <Filter>valve_sdk\math</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\math\Vectors.hpp">
      <Filter>valve_sdk\math</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IGameEvent.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IAppSystem.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\ICvar.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IVModelInfo.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\ISurface.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IVRenderView.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IBaseClientDLL.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\CGlobalVarsBase.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IMaterial.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IVModelRender.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\CClientState.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="helpers\console.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="helpers\input.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="imgui\stb_rect_pack.h">
      <Filter>dependencies\imgui</Filter>
    </ClInclude>
    <ClInclude Include="imgui\stb_textedit.h">
      <Filter>dependencies\imgui</Filter>
    </ClInclude>
    <ClInclude Include="imgui\stb_truetype.h">
      <Filter>dependencies\imgui</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\misc\checksum_crc.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="render\render.h">
      <Filter>render</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\steam.h">
      <Filter>valve_sdk</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\ILocalize.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="helpers\notifies.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="hooks\hooks.h">
      <Filter>hooks</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IMemAlloc.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IFileSystem.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\patterns.h">
      <Filter>valve_sdk</Filter>
    </ClInclude>
    <ClInclude Include="helpers\entities.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IViewRenderBeams.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="helpers\imdraw.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="security\importer.h">
      <Filter>security</Filter>
    </ClInclude>
    <ClInclude Include="helpers\autowall.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="helpers\math.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="helpers\utils.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="render\fonts\undefeated.hpp">
      <Filter>render\fonts</Filter>
    </ClInclude>
    <ClInclude Include="features\features.h">
      <Filter>features</Filter>
    </ClInclude>
    <ClInclude Include="minhook\buffer.h">
      <Filter>dependencies\minhook</Filter>
    </ClInclude>
    <ClInclude Include="minhook\minhook.h">
      <Filter>dependencies\minhook</Filter>
    </ClInclude>
    <ClInclude Include="minhook\trampoline.h">
      <Filter>dependencies\minhook</Filter>
    </ClInclude>
    <ClInclude Include="minhook\hde\hde32.h">
      <Filter>dependencies\minhook\hde</Filter>
    </ClInclude>
    <ClInclude Include="minhook\hde\pstdint.h">
      <Filter>dependencies\minhook\hde</Filter>
    </ClInclude>
    <ClInclude Include="minhook\hde\table32.h">
      <Filter>dependencies\minhook\hde</Filter>
    </ClInclude>
    <ClInclude Include="helpers\fnv.h">
      <Filter>helpers</Filter>
    </ClInclude>
    <ClInclude Include="features\nade_helper.h">
      <Filter>features\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IStudioRender.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="settings\config.h">
      <Filter>settings</Filter>
    </ClInclude>
    <ClInclude Include="settings\globals.h">
      <Filter>settings</Filter>
    </ClInclude>
    <ClInclude Include="settings\options.hpp">
      <Filter>settings</Filter>
    </ClInclude>
    <ClInclude Include="settings\settings.h">
      <Filter>settings</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IEngineSound.hpp">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IMaterialVar.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="features\popflash_helper.h">
      <Filter>features\misc</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\kit_parser.hpp">
      <Filter>valve_sdk</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\classids.h">
      <Filter>valve_sdk</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\INetMessage.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\CFireBullets.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\CGlowObjectManager.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\CHud.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\CHudChat.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IInputSystem.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\IVDebugOverlay.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="valve_sdk\interfaces\ServerClass.h">
      <Filter>valve_sdk\interfaces</Filter>
    </ClInclude>
    <ClInclude Include="render\menu_strings.h">
      <Filter>render</Filter>
    </ClInclude>
    <ClInclude Include="hooks\hooked_functions\game_event_listener.h">
      <Filter>hooks\hooked_functions</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`src/features/Chams.cpp`:

```cpp
#include "../settings/settings.h"
#include "../features/features.h"
#include "../hooks/hooks.h"

#include "../settings/globals.h"
#include "../valve_sdk/classids.h"

#include "../helpers/fnv.h"

namespace chams
{
	void initialize_materials()
	{
		material_debug = g::mat_system->FindMaterial("debug/debugambientcube", TEXTURE_GROUP_MODEL, true, 0);
	}

	static auto render_players = [](const bool& ignorez, const bool& health_chams, const Color& visible_color, const Color& occluded_color, const Color& health_color)
	{
		const auto color = ignorez ? occluded_color : (health_chams ? health_color : visible_color);
		material_debug->ColorModulate(color.r() / 255.0f, color.g() / 255.0f, color.b() / 255.0f);
		material_debug->AlphaModulate(color.a() / 255.0f);
		material_debug->SetMaterialVarFlag(MATERIAL_VAR_IGNOREZ, ignorez);

		g::mdl_render->ForcedMaterialOverride(material_debug);
	};

	void on_draw_model_execute(IMatRenderContext* ctx, const DrawModelState_t& state, const ModelRenderInfo_t& info, matrix3x4_t* bone, decltype(hooks::draw_model_execute::original)& original)
	{
		c_base_player* player = reinterpret_cast<c_base_player*>(info.pRenderable->GetIClientUnknown()->GetBaseEntity());

		if (!player || !g::local_player)
			return;

		if (!player->IsPlayer())
			return;

		if (player->IsDormant())
			return;

		if (player->m_iTeamNum() != g::local_player->m_iTeamNum()) //enemy chams
		{
			if (!settings::chams::enemy::enabled)
				return;

			Color vis = settings::chams::enemy::color_visible;
			Color not_vis = settings::chams::enemy::color_not_visible;

			float r, g, b;

			int entity_health = player->m_iHealth();

			utils::scale_color_to_health(std::clamp(entity_health / 100.0f, 0.0f, 1.0f), r, g, b);

			Color health_color = Color(r, g, b, 1.0f);

			if (!settings::chams::enemy::visible_only)
			{
				render_players(true, false, vis, not_vis, health_color);
				original(g::mdl_render, ctx, &state, &info, bone);
			}
			render_players(false, settings::chams::enemy::health_chams, vis, not_vis, health_color);
		}
		else if (player->m_iTeamNum() == g::local_player->m_iTeamNum() && player != g::local_player)
		{
			if (!settings::chams::teammates::enabled)
				return;

			Color vis = settings::chams::teammates::color_visible;
			Color not_vis = settings::chams::teammates::color_not_visible;

			float r, g, b;

			int entity_health = player->m_iHealth();

			utils::scale_color_to_health(std::clamp(entity_health / 100.0f, 0.0f, 1.0f), r, g, b);

			Color health_color = Color(r, g, b, 1.0f);

			if (!settings::chams::enemy::visible_only)
			{
				render_players(true, false, vis, not_vis, health_color);
				original(g::mdl_render, ctx, &state, &info, bone);
			}
			render_players(false, settings::chams::teammates::health_chams, vis, not_vis, health_color);
		}
	}
}
```

`src/features/aimbot.cpp`:

```cpp
#include "features.h"
#include "../helpers/autowall.h"
#include "../settings/globals.h"
#include "../helpers/input.h"
#include "../helpers/console.h"
#include "../helpers/entities.h"
#include "..\\hooks\hooks.h"
#include "..//helpers/notifies.h"

namespace aimbot
{
	bool using_trigger = false;
	weapon_setting a_setting;

	Ray_t ray;
	CGameTrace tr;
	CCSWeaponInfo* weapon_data;
	c_base_combat_weapon* weapon;
	c_base_player* target = nullptr;

	namespace punches
	{
		QAngle current = { 0, 0, 0 };

		QAngle last = { 0, 0, 0 };
	}

	struct player_t
	{
		int index;
		int hitbox;

		float fov;
		float sim_time;

		Vector origin;
		QAngle angles;
		QAngle aim_angle;
		entities::hitbox_t point;
		
		c_base_player* player;

		float damage = 0.f;

		const bool operator<(const player_t& other)
		{
			if (!a_setting.backtrack.legit || (using_trigger && !a_setting.trigger.magnet))
				return fov < other.fov;

			const auto a = TIME_TO_TICKS(sim_time);
			const auto b = TIME_TO_TICKS(other.sim_time);

			if (a == b)
				return fov < other.fov;

			return a > b;
		}
	};

	struct player_pos_t
	{
		int id;
		float sim_time;

		Vector origin;
		Vector eye_pos;
	};

	namespace delays
	{
		ULONGLONG last_scope_time = 0;
		ULONGLONG last_aiming_time = 0;

		auto reaction_pause = false;
		ULONGLONG reaction_end_time = 0;
	}

	namespace network
	{
		float out_delay = 0.f;
		float network_delay = 0.f;
		float latency_delay = 0.f;
		float next_server_time = 0.f;
		float interpolation_time = 0.f;

		const float get_interpolation_time()
		{
			static const auto cl_interp = g::cvar->find(xorstr_("cl_interp"));
			static const auto c_min_ratio = g::cvar->find(xorstr_("sv_client_min_interp_ratio"));
			static const auto c_max_ratio = g::cvar->find(xorstr_("sv_client_max_interp_ratio"));

			static const auto max_ud_rate = g::cvar->find(xorstr_("sv_maxupdaterate"));
			const auto ud_rate = max_ud_rate->GetInt();

			static const auto cl_interp_ratio = g::cvar->find(xorstr_("cl_interp_ratio"));
			float ratio = cl_interp_ratio->GetFloat();

			if (ratio == 0)
				ratio = 1.0f;

			if (c_min_ratio && c_max_ratio && c_min_ratio->GetFloat() != 1)
				ratio = std::clamp(ratio, c_min_ratio->GetFloat(), c_max_ratio->GetFloat());

			return std::max(cl_interp->GetFloat(), (ratio / ud_rate));
		}

		void fetch_delays(const int& tick_count)
		{
			const auto nci = g::engine_client->GetNetChannelInfo();

			static const auto sv_maxunlag = g::cvar->find(xorstr_("sv_maxunlag"));

			const auto unlag = sv_maxunlag->GetFloat();
			interpolation_time = get_interpolation_time();

			latency_delay = nci->GetLatency(FLOW_OUTGOING) + nci->GetLatency(FLOW_INCOMING);
			network_delay = std::clamp(latency_delay + interpolation_time, 0.f, unlag);
			out_delay = std::clamp(nci->GetLatency(FLOW_OUTGOING) + interpolation_time, 0.f, unlag);

			next_server_time = TICKS_TO_TIME(tick_count + 1) + network_delay;
		}
	}

	void reset_vars()
	{
		target = nullptr;

		delays::reaction_pause = false;

		delays::last_aiming_time = 0;
		delays::last_scope_time = 0;
		delays::reaction_end_time = 0;

		punches::last = { 0, 0, 0 };
		punches::current = { 0, 0, 0 };
	}

	void slow_move(CUserCmd* cmd, const float& amount)
	{
		Vector forward;
		QAngle direction;

		const auto& velocity = g::local_player->m_vecVelocity();
		const auto& speed = velocity.Length2D();

		math::vector2angles(velocity, direction);

		direction.yaw = cmd->viewangles.yaw - direction.yaw;

		math::angle2vectors(direction, forward);
		const auto source = forward * -speed;

		const auto max_speed = 250.f;
		if (speed >= max_speed * 0.0034f * amount)
		{
			cmd->forwardmove = source.x;
			cmd->sidemove = source.y;
		}
	}

	void autopistol(CUserCmd* cmd)
	{
		if (weapon_data->WeaponType == WEAPONTYPE_PISTOL && a_setting.autopistol)
			if (!weapon->CanFire())
				cmd->buttons &= ~IN_ATTACK;
	}

	bool is_enabled(CUserCmd* cmd)
	{
		using_trigger = false;

		if (!g::local_player || !g::local_player->IsAlive())
			return false;

		weapon = g::local_player->m_hActiveWeapon();
		if (!weapon || !weapon->IsWeapon() || !weapon->HasBullets())
			return false;

		weapon_data = weapon->GetWeaponData();
		if (weapon_data->WeaponType == WEAPONTYPE_SNIPER_RIFLE)
		{
			if (!g::local_player->m_bIsScoped())
				delays::last_scope_time = GetTickCount64();
		}

		int index = 0;
		if (settings::aimbot::setting_type == settings_type_t::separately)
			index = weapon->m_iItemDefinitionIndex();
		else if (settings::aimbot::setting_type == settings_type_t::subgroups)
		{
			switch (weapon->m_iItemDefinitionIndex())
			{
			case WEAPON_AWP:
			case WEAPON_SSG08:
			case WEAPON_DEAGLE:
				index = 200 + weapon->m_iItemDefinitionIndex();
				break;
			default:
				index = weapon->GetWeaponData()->WeaponType;
			}
		}
		else if (settings::aimbot::setting_type == settings_type_t::groups)
		{
			int group_index = -1;
			for (size_t k = 0; k < settings::aimbot::m_groups.size(); k++)
			{
				const auto& group = settings::aimbot::m_groups[k];
				if (std::find(group.weapons.begin(), group.weapons.end(), weapon->m_iItemDefinitionIndex()) != group.weapons.end())
				{
					group_index = k;
					break;
				}
			}

			if (group_index == -1)
				return false;
		}

		a_setting = settings::aimbot::m_items[index];
		if (!a_setting.enabled)
			return false;

		const auto is_recoil_enabled = a_setting.recoil.enabled && (a_setting.recoil.pitch > 0.f || a_setting.recoil.yaw > 0.f);
		if (a_setting.fov <= 0.f)
		{
			if ((!a_setting.trigger.enabled || a_setting.trigger.magnet) && !is_recoil_enabled)
				return false;
		}

		if (!(cmd->buttons & IN_ATTACK))
		{
			using_trigger = a_setting.trigger.enabled && globals::binds::trigger != 0 && (GetAsyncKeyState(globals::binds::trigger) & 0x8000);
			if (!using_trigger)
				return false;
		}

		if (a_setting.check_zoom && weapon_data->WeaponType == WEAPONTYPE_SNIPER_RIFLE)
			return g::local_player->m_bIsScoped() && delays::last_scope_time + 60 <= GetTickCount64();

		return true;
	}

	int get_hitgroup(const int& hitbox)
	{
		switch (hitbox)
		{
		case HITBOX_HEAD:
		case HITBOX_NECK:
			return 1;

		case HITBOX_THORAX:
		case HITBOX_LOWER_CHEST:
		case HITBOX_UPPER_CHEST:
			return 2;

		case HITBOX_PELVIS:
		case HITBOX_BELLY:
			return 3;

		case HITBOX_RIGHT_HAND:
		case HITBOX_RIGHT_UPPER_ARM:
		case HITBOX_RIGHT_FOREARM:
			//return 4;

		case HITBOX_LEFT_HAND:
		case HITBOX_LEFT_UPPER_ARM:
		case HITBOX_LEFT_FOREARM:
			return 5;

		case HITBOX_RIGHT_THIGH:
		case HITBOX_RIGHT_CALF:
		case HITBOX_RIGHT_FOOT:
			//return 6;

		case HITBOX_LEFT_THIGH:
		case HITBOX_LEFT_CALF:
		case HITBOX_LEFT_FOOT:
			return 7;
		}

		return -1;
	}

	bool is_suitable_by_min_damage(c_base_player* entity, const int& hitbox, const int& min_damage)
	{
		if (min_damage < 1.f || min_damage > 100.f)
			return true;

		const auto hitgroup = get_hitgroup(hitbox);
		if (hitgroup == -1)
			return false;

		auto damage = float(weapon_data->iDamage);
		autowall::scale_damage(hitgroup, entity, weapon_data->flArmorRatio, weapon_data->fHeadshotMultiplier, damage);
		
		return damage >= min_damage || damage >= entity->m_iHealth();
	}

	Vector sphere_ray_intersection(const Vector& start, const Vector& end, const Vector& center, const float& radius)
	{
		const auto direction = (end - start).Normalized();

		const auto q = center - start;
		const auto v = q.Dot(direction);
		const auto d = radius * radius - (q.LengthSqr() - v * v);

		return d < FLT_EPSILON ? Vector{} : start + direction * (v - std::sqrt(d));
	}

	bool intersects_point(const Vector& start, const Vector& end, const Vector& mins, const Vector& maxs, float radius)
	{
		const auto delta = (maxs - mins).Normalized();
		if (sphere_ray_intersection(start, end, maxs, radius).IsValid())
			return true;

		for (size_t i{}; i < std::floor(mins.DistTo(maxs)); ++i)
		{
			if (sphere_ray_intersection(start, end, mins + delta * float(i), radius).IsValid())
				return true;
		}

		return false;
	}

	bool is_spraying()
	{
		return a_setting.recoil.enabled && ((a_setting.recoil.pitch > 0.f || a_setting.recoil.yaw > 0.f)) && g::local_player->m_iShotsFired() > (a_setting.recoil.first_bullet ? 0 : 1);
	}

	bool search_target(const QAngle& view_angles, const Vector& eye_pos, int& tick_count, const int& min_damage, player_t& result)
	{
		if (a_setting.check_flash && g::local_player->IsFlashed())
		{
			//target = nullptr;

			return false;
		}

		if (a_setting.check_air && g::local_player->InAir())
		{
			//target = nullptr; 

			return false;
		}

		target = nullptr;

		static std::vector<player_t> targets;
		targets.clear();

		static std::vector<player_pos_t> duplicates;
		duplicates.clear();

		a_setting.backtrack.time = std::clamp<int>(a_setting.backtrack.time, 1, 200);

		float max_time = static_cast<float>(a_setting.backtrack.time) / 1000.f;

		max_time = std::clamp<float>(max_time, 0.1f, 2.0f);

		QAngle aim_angles;
		for (const auto& tick : entities::m_items)
		{
			for (const auto& entity : tick.players)
			{
				if (entity.index == 0 || entity.index == g::local_player->GetIndex())
					continue;

				const auto delta_time = fabsf(network::out_delay - (network::next_server_time - entity.m_flSimulationTime - network::interpolation_time));
				if (delta_time > 0.2f || delta_time > max_time)
					continue;

				const auto result_of_duplicates = std::find_if(duplicates.begin(), duplicates.end(), [entity](player_pos_t const& c)
				{
					const auto is_the_same = c.sim_time == entity.m_flSimulationTime || (c.eye_pos == entity.eye_pos && c.origin == entity.origin);

					return c.id == entity.index && is_the_same;
				});

				if (result_of_duplicates != duplicates.end())
					continue;

				auto* player = c_base_player::GetPlayerByIndex(entity.index);
				if (!player || !player->IsPlayer() || !player->IsAlive() || player->m_bGunGameImmunity() || player->IsDormant())
					continue;

				if (using_trigger && !globals::is_visible[player->GetIndex()])
					continue;

				auto hitbox_ids = player->hitboxes();
				if (hitbox_ids.empty())
					continue;

				duplicates.push_back({ entity.index, entity.m_flSimulationTime, entity.eye_pos, entity.origin });

				for (const auto& hitbox_id : hitbox_ids)
				{
					if (!is_suitable_by_min_damage(player, hitbox_id, min_damage) && a_setting.by_damage)
						continue;

					const auto& hitbox = entity.hitboxes[hitbox_id];
					if (!hitbox.points[0].IsValid())
						continue;
					
					math::vector2angles(hitbox.points[0] - eye_pos, aim_angles);

					auto fov = a_setting.dynamic_fov ? math::GetRealDistanceFOV(eye_pos.DistTo(hitbox.points[0]), view_angles, aim_angles) :
						math::GetFovToPlayer(view_angles, aim_angles);

					if (a_setting.fov_smooth_override)
					{
						float old_fov = a_setting.fov;
						float old_smooth = a_setting.smooth;

						if (g::local_player->m_iShotsFired() >= a_setting.min_shots_fired)
						{
							a_setting.fov = a_setting.extended_fov;
							a_setting.smooth = a_setting.extended_smooth;
						}
						else if (g::local_player->m_iShotsFired() < a_setting.min_shots_fired)
						{
							a_setting.fov = old_fov;
							a_setting.smooth = old_smooth;
						}
					}

					if ((!using_trigger || a_setting.trigger.magnet) && fov > a_setting.fov)
						continue;

					targets.push_back({ entity.index, hitbox_id, fov, entity.m_flSimulationTime, entity.origin, entity.angles, aim_angles, hitbox, player });
				}
			}
		}

		if (targets.empty())
			return false;
			
		std::sort(targets.begin(), targets.end());

		Vector end_pos;
		math::angle2vectors(view_angles, end_pos);
		end_pos = eye_pos + (end_pos * weapon_data->flRange);

		QAngle old_angles;
		Vector old_origin;

		bool pos_changed = false;

		static auto update_poses = [](c_base_player* player, const QAngle& angles, const Vector& origin)
		{
			player->SetAbsOrigin(origin);
			player->SetAbsAngles(angles);

			player->InvalidateBoneCache();
		};

		const auto awall_damage = std::clamp<float>(a_setting.autowall.min_damage, 0.f, 100.f);

		const auto awall_enabled = a_setting.autowall.enabled;

		for (auto& entity : targets)
		{
			if (a_setting.check_smoke && utils::is_line_goes_through_smoke(eye_pos, entity.point.points[0]))
				continue;

			if (a_setting.check_flash && g::local_player->IsFlashed())
				continue;

			if (a_setting.check_air && g::local_player->InAir())
				continue;

			if (using_trigger && !a_setting.trigger.magnet)
			{
				if (!globals::is_visible[entity.player->GetIndex()])
					continue;

				if (intersects_point(eye_pos, end_pos, entity.point.min, entity.point.max, entity.point.radius * 0.6f))
				{
					tick_count = TIME_TO_TICKS(entity.sim_time + network::interpolation_time);

					result = entity;

					target = entity.player;

					return true;
				}

				continue;
			}

			pos_changed = false;

			old_origin = entity.player->GetAbsOrigin();
			old_angles = entity.player->GetAbsAngles();

			CTraceFilterSkipTwoEntities filter(g::local_player, entity.player);

			for (const auto& point : entity.point.points)
			{
				if (!point.IsValid())
					continue;

				if (!awall_enabled && a_setting.by_damage && !is_suitable_by_min_damage(entity.player, entity.hitbox, min_damage))
					continue;

				ray.Init(eye_pos, point);
				g::engine_trace->trace_ray(ray, CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_DEBRIS | CONTENTS_HITBOX, &filter, &tr);
			
				if (eye_pos.DistTo(tr.endpos) != eye_pos.DistTo(point))
				{
					if (!awall_enabled || !is_suitable_by_min_damage(entity.player, entity.hitbox, min_damage))
						continue;

					if (pos_changed)
						continue;

					pos_changed = true;

					update_poses(entity.player, QAngle(0.f, entity.angles.yaw, 0.f), entity.origin);

					const auto damage = autowall::get_damage(point);
					if (damage < 1.f)
						continue;

					if (a_setting.by_damage && damage < min_damage && damage < entity.player->m_iHealth())
						continue;

					entity.damage = damage;
				}

				QAngle final_aim_angle;
				math::vector2angles(point - eye_pos, final_aim_angle);
				final_aim_angle.NormalizeClamp();

				tick_count = TIME_TO_TICKS(entity.sim_time + network::interpolation_time);

				if (pos_changed)
					update_poses(entity.player, old_angles, old_origin);

				result = entity;
				result.aim_angle = final_aim_angle;

				target = entity.player;

				return true;
			}

			if (pos_changed)
				update_poses(entity.player, old_angles, old_origin);
		}

		return false;
	}

	auto hitchance(c_base_player* player, const QAngle& angles, const float& chance) -> bool
	{
		Vector forward, right, up;
		Vector src = g::local_player->GetEyePos();
		math::angle2vectors(angles, forward, right, up);

		const auto hit_count = 150.f;

		int cHits = 0;
		int cNeededHits = static_cast<int>(hit_count * (chance * 0.01f));

		weapon->UpdateAccuracyPenalty();
		float weap_spread = weapon->GetSpread();
		float weap_inaccuracy = weapon->GetInaccuracy();

		CTraceFilterPlayersOnlySkipOne filter(g::local_player);

		QAngle viewAnglesSpread;
		Vector direction, viewForward;
		for (int i = 0; i < hit_count; i++)
		{
			auto a = utils::random(0.f, 1.f);
			const auto c = utils::random(0.f, 1.f);

			if (weapon->m_iItemDefinitionIndex() == WEAPON_REVOLVER)
			{
				a = 1.f - a * a;
				a = 1.f - c * c;
			}

			const auto b = utils::random(0.f, 2.f * PI);
			const auto d = utils::random(0.f, 2.f * PI);

			const auto spread = c * weap_spread;
			const auto inaccuracy = a * weap_inaccuracy;

			Vector spreadView((cos(b) * inaccuracy) + (cos(d) * spread), (sin(b) * inaccuracy) + (sin(d) * spread), 0);

			direction.x = forward.x + (spreadView.x * right.x) + (spreadView.y * up.x);
			direction.y = forward.y + (spreadView.x * right.y) + (spreadView.y * up.y);
			direction.z = forward.z + (spreadView.x * right.z) + (spreadView.y * up.z);
			direction.Normalized();

			math::vector2angles(direction, up, viewAnglesSpread);
			viewAnglesSpread.NormalizeClamp();

			math::angle2vectors(viewAnglesSpread, viewForward);
			viewForward.NormalizeInPlace();

			viewForward = src + (viewForward * weapon_data->flRange);

			ray.Init(src, viewForward);
			g::engine_trace->trace_ray(ray, CONTENTS_SOLID | CONTENTS_HITBOX, &filter, &tr);

			if (tr.hit_entity == player)
				++cHits;

			const auto ch = int((float(cHits) / hit_count) * 100.f);
			if (ch >= chance)
				return true;

			if ((hit_count - i + cHits) < cNeededHits)
				return false;
		}

		return false;
	}

	bool able_to_rcs()
	{
		const auto& nci = g::engine_client->GetNetChannelInfo();

		if (!nci)
			return false;

		float ping = std::round((nci->GetAvgLatency(FLOW_INCOMING) + nci->GetAvgLatency(FLOW_OUTGOING)) * 1000.f);

		if (ping >= 120.f)
			return false;

		return true;
	}

	bool recoil(QAngle& angles, c_base_player* target, const QAngle& current)
	{
		if (!is_spraying() || !able_to_rcs())
			return false;

		float x = a_setting.recoil.pitch;
		float y = a_setting.recoil.yaw;

		static auto weapon_recoil_scale = g::cvar->find("weapon_recoil_scale");
		float scale = weapon_recoil_scale->GetFloat();
		
		if (scale != 2.f)
		{
			x *= scale / 2.f;
			y *= scale / 2.f;
		}

		if (a_setting.recoil.humanized)
		{
			x -= utils::random(0.1f, 0.5f);
			y -= utils::random(0.1f, 0.6f);
		}

		if (x == 0.f && y == 0.f)
			return false;

		QAngle punch = { };

		if (target)
			punch = QAngle(punches::current.pitch * x, punches::current.yaw * y, 0.f);
		else if (true)
			punch = QAngle((punches::current.pitch - punches::last.pitch) * x, (punches::current.yaw - punches::last.yaw) * y, 0.f);

		if (g::local_player->m_aimPunchAngle().roll == 0.f)
			angles -= punch;

		angles.NormalizeClamp();

		if (target)
			g::engine_client->SetViewAngles(angles);

		return true;
	}

	void handle(CUserCmd* cmd)
	{
		if (!is_enabled(cmd))
		{
			reset_vars();
			
			return;
		}

		player_t result;
		
		auto angles = cmd->viewangles;
		const auto current = angles;

		const auto eye_pos = g::local_player->GetEyePos();
		const auto min_damage = std::clamp<int>(a_setting.min_damage, 0, 100);

		network::fetch_delays(cmd->tick_count);
		
		int tick_count = cmd->tick_count;
		
		static auto weapon_recoil_scale = g::cvar->find("weapon_recoil_scale");
		float recoil_scale = weapon_recoil_scale->GetFloat();

		QAngle aim_punch = weapon->RequiresRecoilControl() ? (g::local_player->m_aimPunchAngle() * recoil_scale) : QAngle();
		aim_punch.NormalizeClamp();

		if (search_target(angles - aim_punch, eye_pos, tick_count, min_damage, result))
		{
			angles = result.aim_angle;
			
			if (!a_setting.by_damage)
			{
				if (result.damage > 0.f)
				{
					if (result.damage < min_damage && result.damage < result.player->m_iHealth())
						return;
				}
				else if (!is_suitable_by_min_damage(result.player, result.hitbox, min_damage))
					return;
			}

			if (using_trigger)
			{
				if (!a_setting.trigger.magnet)
				{
					if (!globals::is_visible[result.player->GetIndex()])
						return;

					Vector end_pos;
					math::angle2vectors(angles, end_pos);
					end_pos = eye_pos + (end_pos * weapon_data->flRange);

					ray.Init(eye_pos, end_pos);

					CTraceFilterSkipTwoEntities filter(g::local_player, result.player);
					g::engine_trace->trace_ray(ray, CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_DEBRIS | CONTENTS_HITBOX, &filter, &tr);

					if (eye_pos.DistTo(tr.endpos) < eye_pos.DistTo(result.point.points[0]))
						return;
				}

				if (delays::reaction_pause)
				{
					if (delays::reaction_end_time > GetTickCount64())
						return;
				}
				else if (a_setting.trigger.delay > 0)
				{
					delays::reaction_pause = true;
					delays::reaction_end_time = GetTickCount64() + a_setting.trigger.delay;
					return;
				}

				if (a_setting.trigger.delay_btw_shots > 0 && delays::last_aiming_time + a_setting.trigger.delay_btw_shots > GetTickCount64())
					return;

				if (!weapon->CanFire())
					return;
			}

			static auto last_entity = -1;
			if (result.index != last_entity)
			{
				if (delays::last_aiming_time + a_setting.delays.target_switch > GetTickCount64()) // && !is_spraying()
					return;
			}

			const auto hit_chance = std::clamp<int>(using_trigger ? a_setting.trigger.hitchance : a_setting.min_hitchance, 0, 100);
			if (hit_chance > 0)
			{
				const auto& old_origin = result.player->GetAbsOrigin();
				const auto& old_angles = result.player->GetAbsAngles();

				result.player->SetAbsOrigin(result.origin);
				result.player->SetAbsAngles(QAngle(0.f, result.angles.yaw, 0.f));
				result.player->InvalidateBoneCache();

				const auto state = hitchance(result.player, angles, (float)hit_chance);

				result.player->SetAbsAngles(old_angles);
				result.player->SetAbsOrigin(old_origin);
				result.player->InvalidateBoneCache();

				if (!state)
				{
					if (a_setting.auto_stop)
						slow_move(cmd, 35.f);

					return;
				}
			}
			else if (a_setting.auto_stop)
			{
				slow_move(cmd, 44.f);
			}

			last_entity = result.index;
			delays::last_aiming_time = GetTickCount64();
		}

		punches::current = g::local_player->m_aimPunchAngle();
		{
			recoil(angles, target, current);

			angles.NormalizeClamp();
		}
		punches::last = punches::current;

		angles.NormalizeClamp();

		if (target)
			math::smooth(a_setting.smooth, current, angles, angles, a_setting.recoil.humanized);

		math::correct_movement(cmd, current);

		cmd->viewangles = angles;
		g::engine_client->SetViewAngles(angles);

		if (target && using_trigger)
			cmd->buttons |= IN_ATTACK;

		autopistol(cmd);

		if (cmd->buttons & IN_ATTACK)
			cmd->tick_count = tick_count;
	}
}
```

`src/features/auto_strafe.cpp`:

```cpp
#include "features.h"

bool backward_style = false;

void features::auto_strafe(CUserCmd* cmd)
{
	if (cmd->buttons & IN_FORWARD)
		backward_style = false;
	else if (cmd->buttons & IN_BACK)
		backward_style = true;

	if (!g::local_player || !g::local_player->IsAlive())
		return;

	if (cmd->buttons & IN_FORWARD || cmd->buttons & IN_BACK || cmd->buttons & IN_MOVELEFT || cmd->buttons & IN_MOVERIGHT)
		return;

	if (cmd->mousedx <= 1 && cmd->mousedx >= -1)
		return;

	if (g::local_player->m_fFlags() & FL_ONGROUND)
		return;

	if (g::local_player->m_nMoveType() == MOVETYPE_NOCLIP)
		return;

	if (g::local_player->m_nMoveType() == MOVETYPE_LADDER)
		return;

	if (backward_style)
		cmd->sidemove = cmd->mousedx < 0.f ? 450.f : -450.f;
	else
		cmd->sidemove = cmd->mousedx < 0 ? -450.0f : 450.0f;
}
```

`src/features/bhop.cpp`:

```cpp
#include "features.h"

auto jumped_last_tick = false;
auto should_fake_jump = false;

void features::bhop(CUserCmd* cmd)
{
	if (!g::local_player || !g::local_player->IsAlive())
		return;

	if (g::local_player->m_nMoveType() == MOVETYPE_LADDER)
		return;

	if (!jumped_last_tick && should_fake_jump)
	{
		should_fake_jump = false;
		cmd->buttons |= IN_JUMP;
	}
	else if (cmd->buttons & IN_JUMP)
	{
		if (g::local_player->m_fFlags() & FL_ONGROUND)
		{
			jumped_last_tick = true;
			should_fake_jump = true;
		}
		else
		{
			cmd->buttons &= ~IN_JUMP;
			jumped_last_tick = false;
		}
	}
	else
	{
		jumped_last_tick = false;
		should_fake_jump = false;
	}
}
```

`src/features/bomb_event_info.cpp`:

```cpp
#include "features.h"
#include "../helpers/notifies.h"
#include "../settings/globals.h"

namespace features
{
	void on_bomb_begindefuse(IGameEvent* event)
	{
		auto entity = c_base_player::GetPlayerByUserId(event->GetInt("userid"));
		if (!entity || !g::local_player || entity == g::local_player)
			return;

		float dist_to_a = entity->GetAbsOrigin().DistTo((*g::player_resource)->m_bombsiteCenterA());
		float dist_to_b = entity->GetAbsOrigin().DistTo((*g::player_resource)->m_bombsiteCenterB());

		static std::string site;

		if (dist_to_a < dist_to_b)
			site = "A";

		if (dist_to_b < dist_to_a)
			site = "B";

		notifies::push(std::format("{:.5s} is defusing on {:s} {:s}", entity->GetPlayerInfo().szName, site, event->GetBool("haskit") ? "(kit)" : ""));
	}
}
```

`src/features/buylogger.cpp`:

```cpp
#include "features.h"
#include "../helpers/console.h"

#include <format>

namespace features
{
	static std::map<const char*, const char*> weapon_names =
	{
		{ "weapon_ak47", "AK47" },
		{ "weapon_aug", "AUG" },
		{ "weapon_famas", "FAMAS" },
		{ "weapon_galilar", "Galil AR" },
		{ "weapon_m4a1", "M4A4" },
		{ "weapon_m4a1_silencer", "M4A1-S" },
		{ "weapon_sg556", "SG 556" },

		{ "weapon_awp", "AWP" },
		{ "weapon_g3sg1", "G3SG1" },
		{ "weapon_scar20", "SCAR20" },
		{ "weapon_ssg08", "SSG 08" },

		{ "weapon_mac10", "MAC10" },
		{ "weapon_mp7", "MP7" },
		{ "weapon_mp9", "MP9" },
		{ "weapon_bizon", "PP-Bizon" },
		{ "weapon_p90", "P90" },
		{ "weapon_ump45", "UMP-45" },
		{ "weapon_mp5sd", "MP5-SD" },

		{ "weapon_m249", "M249" },
		{ "weapon_negev", "Negev" },

		{ "weapon_hkp2000", "P2000" },
		{ "weapon_usp_silencer", "USP-S" },
		{ "weapon_p250", "P250" },
		{ "weapon_elite", "Dual Berettas" },
		{ "weapon_fiveseven", "Five-Seven" },
		{ "weapon_glock", "Glock" },
		{ "weapon_tec9", "Tec-9" },
		{ "weapon_deagle", "Deagle" },
		{ "weapon_cz75a", "CZ75-A" },
		{ "weapon_revolver", "Revolver" },

		{ "weapon_mag7", "MAG-7" },
		{ "weapon_nova", "Nova" },
		{ "weapon_sawedoff", "Sawed Off" },
		{ "weapon_xm1014", "XM1014" },

		{ "item_defuser", "Defuse Kit" },
		{ "item_kevlar", "Kevlar" },
		{ "item_assaultsuit", "Kevlar + Helmet" },

		{ "weapon_hegrenade", "HE" },
		{ "weapon_flashbang", "Flashbang" },
		{ "weapon_molotov", "Molotov" },
		{ "weapon_smokegrenade", "Smoke" },
		{ "weapon_incgrenade", "Molotov" },
		{ "weapon_decoy", "Decoy" },
		{ "weapon_taser", "Zeus x27" }
	};

	void format_names(const char* weapon, c_base_player* player)
	{
		static std::string output;

		static auto green = " \x04";
		static auto yellow = " \x10";
		static auto white = " \x01";

		for (auto& it : weapon_names) //TODO: Convert weapon_names to hash for better performance.
		{
			/*for (auto& hash : weapon_names_hashes)
			{
				auto weapon_hash = fnv::hash_runtime(weapon);
				if (hash == weapon_hash)
				{
					if (hash == item_defuser_blacklisted_hash) //TODO: Probably loop thru array of blacklisted hashes.
						continue;
					output = std::format("{:s}[Buy] {:s}Player {:s}{:.8s} {:s}bought {:s}{:s}", yellow, green, white, player->GetPlayerInfo().szName, green, white, it.second);
					g::hud_chat->ChatPrintf(0, 0, output.c_str());
				}
			}*/

			if (strstr(it.first, weapon))
			{
				if (!strcmp(it.first, "item_defuser") || !strcmp(it.first, "item_kevlar") //TODO: Convert to hash.
					|| !strcmp(it.first, "item_assaultsuit") || !strcmp(it.first, "weapon_taser")
					|| !strcmp(it.first, "weapon_decoy") || !strcmp(it.first, "weapon_incgrenade")
					|| !strcmp(it.first, "weapon_molotov") || !strcmp(it.first, "weapon_hegrenade")
					|| !strcmp(it.first, "weapon_smokegrenade") || !strcmp(it.first, "weapon_flashbang"))
					continue;

				output = std::format("{:s}[Buy] {:s}{:.8s} {:s}bought {:s}{:s}", yellow, white, player->GetPlayerInfo().szName, green, white, it.second);
				g::hud_chat->ChatPrintf(0, 0, output.c_str());
			}
		}
	}

	void buy_logger(IGameEvent* event)
	{
		if (!settings::esp::buylog)
			return;

		if (!utils::IsPlayingMM())
			return;

		c_base_player* enemy = c_base_player::GetPlayerByUserId(event->GetInt("userid"));

		if (!enemy || !g::local_player || enemy->m_iTeamNum() == g::local_player->m_iTeamNum())
			return;

		format_names(event->GetString("weapon"), enemy);
	}
}
```

`src/features/color_modulate.cpp`:

```cpp
#include "features.h"
#include "../settings/globals.h"
#include "../settings/options.hpp"
#include "../helpers/console.h"
#include "../helpers/notifies.h"

#include <string>

namespace color_modulation
{
	auto post_processing = false;
	auto night_mode_state = false;
	
	auto debug_crosshair = -1.f;
	auto view_model_fov = -1.f;
	auto debug_model_fov = -1.f;

	ConVar* viewmodel_fov = nullptr;
	ConVar* mat_postprocess_enable = nullptr;
	
	void night_mode()
	{
		reinterpret_cast<void(__fastcall*)(const char*)>(patterns::set_sky_addr)(xorstr_("sky_csgo_night02"));
	}

	void event()
	{
		if (night_mode_state && !settings::visuals::night_mode)
			reinterpret_cast<void(__fastcall*)(const char*)>(patterns::set_sky_addr)(xorstr_("vertigoblue_hdr"));

		night_mode_state = !night_mode_state;
		debug_crosshair = -1;
	}

	bool is_vars_changed()
	{
		if (night_mode_state != settings::visuals::night_mode)
			return true;

		if (post_processing != globals::post_processing)
			return true;

		if (view_model_fov != settings::misc::viewmodel_fov)
			return true;

		return false;
	}

	void set_convars()
	{
		if (!viewmodel_fov)
		{
			viewmodel_fov = g::cvar->find(xorstr_("viewmodel_fov"));
			viewmodel_fov->m_fnChangeCallbacks.m_Size = 0;
		}

		if (!mat_postprocess_enable)
		{
			mat_postprocess_enable = g::cvar->find(xorstr_("mat_postprocess_enable"));
			mat_postprocess_enable->m_fnChangeCallbacks.m_Size = 0;
		}

		g::cvar->find(xorstr_("engine_no_focus_sleep"))->SetValue(0);
		g::cvar->find(xorstr_("violence_ablood"))->SetValue(0);
		g::cvar->find(xorstr_("violence_hblood"))->SetValue(0);

		viewmodel_fov->SetValue(settings::misc::viewmodel_fov);
		mat_postprocess_enable->SetValue(post_processing ? 1 : 0);
	}

	void sniper_crosshair()
	{
		if (!g::local_player)
			return;

		bool is_scoped = g::local_player->m_bIsScoped();
		if (!g::local_player->IsAlive() && g::local_player->m_hObserverTarget())
		{
			auto observer = (c_base_player*)c_base_player::GetEntityFromHandle(g::local_player->m_hObserverTarget());
			if (observer && observer->IsPlayer())
				is_scoped = observer->m_bIsScoped();
		}

		static auto weapon_debug_spread_show = g::cvar->find(xorstr_("weapon_debug_spread_show"));

		if (settings::visuals::sniper_crosshair)
		{
			if (debug_crosshair != 0 && is_scoped)
			{
				debug_crosshair = 0;
				weapon_debug_spread_show->SetValue(0);
			}

			if (debug_crosshair != 3 && !is_scoped)
			{
				debug_crosshair = 3;
				weapon_debug_spread_show->SetValue(3);
			}
		}
		else if (debug_crosshair != 0)
		{
			debug_crosshair = 0;
			weapon_debug_spread_show->SetValue(0);
		}
	}

	void handle()
	{
		sniper_crosshair();

		if (!is_vars_changed())
			return;

		post_processing = globals::post_processing;
		view_model_fov = settings::misc::viewmodel_fov;
		night_mode_state = settings::visuals::night_mode;
			
		set_convars();
		
		if (settings::visuals::night_mode)
			night_mode();
	}
}
```

`src/features/esp.cpp`:

```cpp
#include <algorithm>

#include "features.h"
#include "../settings/globals.h"
#include "../render/render.h"
#include "../helpers/imdraw.h"
#include "../helpers/console.h"
#include "../helpers/entities.h"
#include "../helpers/autowall.h"
#include "../valve_sdk/interfaces/ISurface.h"
#include "../render/fonts/undefeated.hpp"
#include "../helpers/entities.h"

namespace esp
{
	decltype(entities::m_local) m_local;
	entities::player_data_t m_entities[MAX_PLAYERS];

	static std::string output;

	float last_time = 0.f;

	Vector origin, in_parent, in_child, out_parent, out_child, breast_bone;

	bool is_enabled()
	{
		if (!render::fonts::visuals || g::engine_client->IsConsoleVisible() || g::engine_client->IsDrawingLoadingImage() || (!globals::esp_menu_opened && render::menu::is_visible()))
			return false;

		return g::engine_client->IsInGame() && g::local_player && settings::esp::enabled;
	}

	void render_helpers()
	{
		if (settings::misc::smoke_helper)
		{
			visuals::RenderInfo();
			visuals::RenderCircle();
			visuals::drawring_3d();
		}

		if (settings::misc::flash_helper)
		{
			visuals::RenderCirclePopflash();
			visuals::drawring_3d_popflash();
		}
	}

	void render(ImDrawList* draw_list)
	{
		if (!is_enabled())
			return;

		if (entities::locker.try_lock())
		{
			memcpy(m_entities, entities::m_items.front().players, sizeof(m_entities));
			entities::locker.unlock();
		}

		if (entities::local_mutex.try_lock())
		{
			m_local = entities::m_local;
			entities::local_mutex.unlock();
		}

		int x, y;

		g::engine_client->GetScreenSize(x, y);

		int xx = x / 2;
		int yy = y / 2;

		QAngle viewangles;
		g::engine_client->GetViewAngles(viewangles);

		static const auto white_color = ImGui::GetColorU32(ImVec4::White);
		static const auto smoke_color = ImGui::GetColorU32(ImVec4(1.f, 1.f, 1.f, 0.4f));
		static const auto orange_color = ImGui::GetColorU32(ImVec4::Orange);
		static const auto green_color = ImGui::GetColorU32(ImVec4::Green);
		static const auto black_color = ImGui::GetColorU32(ImVec4::Black);
		static const auto yellow_color = ImGui::GetColorU32(ImVec4::Yellow);
		static const auto red_color = ImGui::GetColorU32(ImVec4::Red);

		ImGui::PushFont(render::fonts::visuals);
		
		for (const auto& data : m_entities)
		{
			if (data.index == 0 || !data.hitboxes->points[0].IsValid())
				continue; 

			const auto bbox = utils::get_box(data.points);
		
			const auto on_screen = (bbox.left > 0 || bbox.right > 0) && (bbox.top > 0 || bbox.bottom > 0);
			
			if (!on_screen)
				continue;

			if (settings::esp::offscreen && !render::menu::is_visible() && !data.is_dormant)
			{
				if (!on_screen && utils::is_entity_audible(data.index, data.origin))
				{
					utils::render_dot(draw_list, data.origin, viewangles, IM_COL32(0, 255, 0, 255));
				}
				else if (m_local.is_scoped)
				{
					utils::render_dot(draw_list, data.origin, viewangles, IM_COL32(255, 0, 50, 255));
				}
				else utils::render_dot(draw_list, data.origin, viewangles, utils::is_entity_audible(data.index, data.origin) ? IM_COL32(0, 255, 0, 255) : IM_COL32(255, 0, 50, 255));
			}

			if (settings::esp::visible_on_sound)
			{
				if (settings::esp::visible_only)
				{
					if (utils::is_entity_audible(data.index, data.origin) && (m_local.is_flashed || data.in_smoke))
						continue;
					else if (!utils::is_entity_audible(data.index, data.origin) && (!data.is_visible || m_local.is_flashed || data.in_smoke))
						continue;
				}
			}
			else 
			{
				if (settings::esp::visible_only && (!data.is_visible || data.in_smoke || m_local.is_flashed))
				    continue;
			}

			const auto visible_color = utils::to_im32(settings::esp::visible_color);
			const auto occluded_color = utils::to_im32(settings::esp::occluded_color);

			const auto width = bbox.right - bbox.left;
			const auto height = bbox.bottom - bbox.top;

			const auto box_color = data.is_dormant ? smoke_color : data.is_visible && !data.in_smoke && !m_local.is_flashed ? visible_color : occluded_color;

			if (settings::esp::bone_esp)
			{
				for (int j = 0; j < data.hdr->numbones; j++)
				{
					mstudiobone_t* bone = data.hdr->GetBone(j);

					if (!bone)
						continue;

					if (!(bone->flags & BONE_USED_BY_HITBOX))
						continue;

					if (bone->parent != -1)
					{
						in_child = data.player->get_bone_position(j);
						in_parent = data.player->get_bone_position(bone->parent);

						Vector upper_dir = data.player->get_bone_position(6 + 1) - data.player->get_bone_position(6); //6 = chest bone
						breast_bone = data.player->get_bone_position(6) + upper_dir / 2;
						Vector delta_child = in_child - breast_bone;
						Vector delta_parent = in_parent - breast_bone;

						if ((delta_parent.Length() < 9 && delta_child.Length() < 9))
							in_parent = breast_bone;

						if (j == 6 - 1)
							in_child = breast_bone;

						if (std::abs(delta_child.z) < 5 && (delta_parent.Length() < 5 && delta_child.Length() < 5) || j == 6)
							continue;

						if ((bone->flags & BONE_USED_BY_HITBOX ^ BONE_USED_BY_HITBOX) && (delta_parent.Length() < 19 && delta_child.Length() < 19))
							continue;

						if (math::world2screen(in_parent, out_parent) && math::world2screen(in_child, out_child))
							globals::draw_list->AddLine(ImVec2(out_parent.x, out_parent.y), ImVec2(out_child.x, out_child.y), utils::to_im32(settings::esp::bone_esp_color));
					}
				}
			}

			if (settings::esp::names)
			{
				const auto name_size = ImGui::CalcTextSize(data.name.c_str());
				auto x = bbox.left + width / 2.f - name_size.x / 2.f;

				imdraw::outlined_text( data.name.c_str(), ImVec2(x, bbox.top - name_size.y), data.is_dormant ? smoke_color : white_color);
			}

			if (settings::esp::is_scoped && data.is_scoped)
			{
				static const auto scoped_text_size = ImGui::CalcTextSize("Scoped");
				auto x = bbox.left + width / 2.f - scoped_text_size.x / 2.f;

				imdraw::outlined_text("Scoped", ImVec2(x, bbox.top - scoped_text_size.y - 20.f), white_color);
			}

			if (settings::esp::is_flashed && data.is_flashed)
			{
				static const auto flashed_text_size = ImGui::CalcTextSize("Flashed");
				auto x = bbox.left + width / 2.f - flashed_text_size.x / 2.f;

				imdraw::outlined_text("Flashed", ImVec2(x, bbox.top - flashed_text_size.y - 12.f), yellow_color);
			}

			if (settings::esp::bomb_esp && data.is_c4_carrier)
			{
				static const auto defusing_text_size = ImGui::CalcTextSize("C4");

				imdraw::outlined_text("C4", ImVec2(bbox.right + 2.f, bbox.top - defusing_text_size.y + 2.f), green_color);
			}

			if (settings::esp::ammo && !data.is_knife_or_grenade)
			{
				static char buf[16];
				sprintf_s(buf, "(%i/%i)", data.m_iAmmo, data.m_MaxAmmo);

				const auto weapon_size = ImGui::CalcTextSize(buf);

				auto y_pos = bbox.bottom + 12.f;
				if (settings::esp::health && settings::esp::health_position == 2)
					y_pos += 7.f;

				if (settings::esp::armour && settings::esp::armour_position == 2)
					y_pos += 7.f;

				imdraw::outlined_text(buf, ImVec2(bbox.left + width / 2.f - weapon_size.x / 2.f, y_pos), white_color);
			}

			auto render_line = [bbox, draw_list](const Color& color, const int& value, const int& position, const bool& with_offset = false, const int& offset_position = 0)
			{
				const auto im_color = utils::to_im32(color);

				const auto width = (float(fabs(bbox.right - bbox.left))) / 100.f * (100.f - value);
				const auto height = (float(fabs(bbox.bottom - bbox.top))) / 100.f * (100.f - value);

				//black width + offset between lines
				const auto offset = with_offset && position == offset_position ? 7.f : 0.f;
				if (position == 0)
				{
					draw_list->AddRectFilled(ImVec2(bbox.left - 2.f - offset, bbox.top), ImVec2(bbox.left - 7.f - offset, bbox.bottom), black_color);
					draw_list->AddRectFilled(ImVec2(bbox.left - 3.f - offset, bbox.top + height), ImVec2(bbox.left - 6.f - offset, bbox.bottom), im_color);
				}
				else if (position == 1)
				{
					draw_list->AddRectFilled(ImVec2(bbox.right + 2.f + offset, bbox.top), ImVec2(bbox.right + 7.f + offset, bbox.bottom), black_color);
					draw_list->AddRectFilled(ImVec2(bbox.right + 3.f + offset, bbox.top + height), ImVec2(bbox.right + 6.f + offset, bbox.bottom), im_color);
				}
				else if (position == 2)
				{
					draw_list->AddRectFilled(ImVec2(bbox.left, bbox.bottom + 2.f + offset), ImVec2(bbox.right, bbox.bottom + 7.f + offset), black_color);
					draw_list->AddRectFilled(ImVec2(bbox.left, bbox.bottom + 3.f + offset), ImVec2(bbox.right - width, bbox.bottom + 6.f + offset), im_color);
				}
			};

			if (settings::esp::health)
			{
				float r, g, b;

				utils::scale_color_to_health(std::clamp(data.m_iHealth / 100.0f, 0.0f, 1.0f), r, g, b);

				render_line(Color(r, g, b, 1.0f), data.m_iHealth, settings::esp::health_position, false);
			}

			if (settings::esp::armour)
			{
				render_line(Color(0, 50, 255, 255), data.m_ArmorValue, settings::esp::armour_position, settings::esp::health, settings::esp::health_position);
			}

			if (settings::esp::weapons && !data.weapon.empty())
			{
				const auto weapon_size = ImGui::CalcTextSize(data.weapon.c_str());

				const auto icon_size = ImGui::CalcTextSize(data.icon.c_str());

				if (!render::fonts::weapon_icon)
					return;

				auto y_pos = bbox.bottom + 2.f;
				if (settings::esp::health && settings::esp::health_position == 2)
					y_pos += 7.f;

				if (settings::esp::armour && settings::esp::armour_position == 2)
					y_pos += 7.f;

				switch (settings::esp::weapon_mode)
				{
				case 0:
					imdraw::outlined_text(data.weapon.c_str(), ImVec2(bbox.left + width / 2.f - weapon_size.x / 2.f, y_pos), data.is_dormant ? smoke_color : orange_color);
					break;
				case 1:
					ImGui::PushFont(render::fonts::weapon_icon);
					imdraw::outlined_text(data.icon.c_str(), ImVec2(bbox.left + width / 2.f - data.wep_str_size / 2.f, y_pos), white_color);
					ImGui::PopFont();
					break;
				}
			}

			if (settings::esp::boxes)
			{
				static const auto thickness = 1.f;
				if (settings::esp::box_type == EBoxType::Normal)
					draw_list->AddRect(ImVec2(bbox.left, bbox.top), ImVec2(bbox.right, bbox.bottom), box_color, thickness, 15, 1.5f);
				else
				{
					static const auto delta = 5.f;

					std::pair<ImVec2, ImVec2> points[] =
					{
						{ImVec2(bbox.left, bbox.top), ImVec2(bbox.left + width / delta, bbox.top)}, //left top
						{ImVec2(bbox.left, bbox.bottom), ImVec2(bbox.left + width / delta, bbox.bottom)}, //left bottom

						{ImVec2(bbox.right, bbox.top), ImVec2(bbox.right - width / delta, bbox.top) }, //right top
						{ImVec2(bbox.right, bbox.bottom), ImVec2(bbox.right - width / delta, bbox.bottom)}, //right bottom

						{ImVec2(bbox.left, bbox.top), ImVec2(bbox.left, bbox.top + height / delta)}, //left top-bottom
						{ImVec2(bbox.left, bbox.bottom), ImVec2(bbox.left, bbox.bottom - height / delta)}, //left bottom-top

						{ImVec2(bbox.right, bbox.top), ImVec2(bbox.right, bbox.top + height / delta)}, //right top-bottom
						{ImVec2(bbox.right, bbox.bottom), ImVec2(bbox.right, bbox.bottom - height / delta)} //right bottom-top
					};

					for (const auto& point : points)
						draw_list->AddLine(point.first, point.second, box_color, thickness);
				}
			}
		}
		ImGui::PopFont();
	}
}

```

`src/features/fast_stop.cpp`:

```cpp
#include "../settings/settings.h"
#include "../valve_sdk/csgostructs.hpp"
#include "../helpers/math.h"

#include <format>

namespace features
{
	void fast_stop(CUserCmd* cmd)
	{
		if (!settings::misc::fast_stop)
			return;

		if (!g::local_player)
			return;

		if (g::local_player->IsDead())
			return;

		if (g::local_player->m_nMoveType() == MOVETYPE_NOCLIP || g::local_player->m_nMoveType() == MOVETYPE_LADDER ||
			g::local_player->InAir() || cmd->buttons & IN_JUMP)
			return;

		if (cmd->buttons & (IN_MOVELEFT | IN_MOVERIGHT | IN_FORWARD | IN_BACK))
			return;

		const Vector& velocity = g::local_player->m_vecVelocity();
		const float speed = velocity.Length2D();
		
		if (speed <= 15.f)	
			return;

		QAngle direction;
		math::vector2angles(velocity, direction);
		direction.yaw -= cmd->viewangles.yaw;

		Vector final_dir;
		math::angle2vectors(direction * -speed, final_dir);

		final_dir.x = std::clamp(final_dir.x, -450.0f, 450.0f);
		final_dir.y = std::clamp(final_dir.y, -450.0f, 450.0f);

		cmd->forwardmove = final_dir.x;
		cmd->sidemove = final_dir.y;
	}
}
```

`src/features/features.h`:

```h
#pragma once

#include "../settings/settings.h"
#include "../helpers/math.h"
#include "../valve_sdk/csgostructs.hpp"
#include "../helpers/entities.h"
#include "../hooks/hooks.h"

#include <vector>
#include <map>
#include <deque>
#include <unordered_map>

namespace features
{
	void bhop(CUserCmd* cmd);
	void auto_strafe(CUserCmd* cmd);
	void thirdperson();
	void fast_stop(CUserCmd* cmd);
	void lefthand_knife();
	void selfnade(CUserCmd* cmd);
	void on_bomb_begindefuse(IGameEvent* event);
	void player_infobox();
	void buy_logger(IGameEvent* event);
}

namespace color_modulation
{
	void night_mode();
	void event();
	void handle();
}

namespace visuals
{
	void fetch_entities();
	void render(ImDrawList* draw_list);
	void drawring_3d();
	void drawring_3d_popflash();
	void RenderInfo();
	void RenderCircle();
	void RenderCirclePopflash();
	void SmokeHelperAimbot(CUserCmd* cmd);
	void PopflashHelperAimbot(CUserCmd* cmd);
}

namespace chams
{
	void on_draw_model_execute(IMatRenderContext* ctx, const DrawModelState_t& state, const ModelRenderInfo_t& pInfo, matrix3x4_t* pCustomBoneToWorld, decltype(hooks::draw_model_execute::original)& original);

	void initialize_materials();

	inline extern IMaterial* material_debug = 0;
}

namespace esp
{
	void render(ImDrawList* draw_list);
	void render_helpers();
}

namespace aimbot
{
	void handle(CUserCmd* cmd);

	namespace punches
	{
		extern QAngle current;

		extern QAngle last;
	}
}

namespace skins
{
	extern std::map<short, item_setting> m_items;
	extern std::unordered_map<std::string, std::string> m_icon_overrides;

	extern std::vector<weapon_name_t> knife_names;
	extern std::vector<weapon_name_t> glove_names;

	void save();
	void load();
	
	void handle();

	const weapon_info_t* get_weapon_info(const short& defindex);
	const char* get_icon_override(const std::string& original);
	bool is_knife(const short& i);
}

namespace grenade_prediction
{
	void fetch_points(CUserCmd* cmd);
	void render(ImDrawList* draw_list);

	int  PhysicsClipVelocity(const Vector& in, const Vector& normal, Vector& out, float overbounce);
	void PushEntity(Vector& src, const Vector& move, trace_t& tr);
	void TraceHull(Vector& src, Vector& end, trace_t& tr);
	void AddGravityMove(Vector& move, Vector& vel, float frametime, bool onground);
	void ResolveFlyCollisionCustom(trace_t& tr, Vector& vecVelocity, float interval);
	void Setup(Vector& vecSrc, Vector& vecThrow, QAngle viewangles);
}




```

`src/features/grenade_prediction.cpp`:

```cpp
#include "features.h"
#include "../settings/options.hpp"
#include "../render/render.h"
#include "../helpers/math.h"
#include "../helpers/utils.h"
#include "../helpers/console.h"
#include "../helpers/imdraw.h"

#include <mutex>

enum ACT
{
	ACT_NONE,
	ACT_THROW,
	ACT_LOB,
	ACT_DROP,
};

namespace grenade_prediction
{
	int act = 0;
	bool has_grenade = false;
	bool was_flashed = false;

	std::vector<std::pair<Vector, Vector>> screen_points;
	std::vector<std::pair<Vector, Vector>> saved_points;

	c_base_player* player = nullptr;
	c_base_combat_weapon* weapon = nullptr;

	std::mutex render_mutex;

	void Tick(int buttons)
	{
		if (!settings::visuals::grenade_prediction)
			return;

		bool in_attack = buttons & IN_ATTACK;
		bool in_attack2 = buttons & IN_ATTACK2;

		act = (in_attack && in_attack2) ? ACT_LOB :
			(in_attack2) ? ACT_DROP :
			(in_attack) ? ACT_THROW :
			ACT_NONE;
	}

	bool is_enabled(CUserCmd* cmd)
	{
		if (!g::local_player)
			return false;

		player = g::local_player;
		if (player->IsAlive())
			Tick(cmd->buttons);
		else if (player->m_hObserverTarget())
		{
			player = (c_base_player*)c_base_player::GetEntityFromHandle(player->m_hObserverTarget());
			act = 0;
		}
		else
			return false;

		if (player->m_nMoveType() == MOVETYPE_NOCLIP)
			return false;

		weapon = player->m_hActiveWeapon();
		if (!weapon || !weapon->IsGrenade())
			return false;

		return true;
	}

	void fetch_points(CUserCmd* cmd)
	{
		render_mutex.lock();

		screen_points.clear();

		if (!is_enabled(cmd))
		{
			render_mutex.unlock();
			return;
		}

		was_flashed = player->IsFlashed();

		Vector vecSrc, vecThrow;
		Setup(vecSrc, vecThrow, cmd->viewangles);

		float interval = g::global_vars->interval_per_tick;
		int logstep = static_cast<int>(0.05f / interval);
		int logtimer = 0;

		std::vector<Vector> path;

		for (unsigned int i = 0; i < path.max_size() - 1; ++i)
		{
			if (!logtimer)
				path.emplace_back(vecSrc);

			Vector move;
			AddGravityMove(move, vecThrow, interval, false);

			// Push entity
			trace_t tr;
			PushEntity(vecSrc, move, tr);

			int result = 0;
			if (weapon->check_detonate(vecThrow, tr, i, interval))
				result |= 1;

			if (tr.fraction != 1.0f)
			{
				result |= 2; // Collision!
				ResolveFlyCollisionCustom(tr, vecThrow, interval);
			}

			vecSrc = tr.endpos;

			if (result & 1)
				break;

			if ((result & 2) || logtimer >= logstep)
				logtimer = 0;
			else
				++logtimer;
		}

		path.emplace_back(vecSrc);

		Vector prev = path[0];
		Vector nadeStart, nadeEnd;

		for (auto& nade : path)
		{
			if (math::world2screen(prev, nadeStart) && math::world2screen(nade, nadeEnd))
			{
				screen_points.emplace_back(std::pair<Vector, Vector>{ nadeStart, nadeEnd });
				prev = nade;
			}
		}

		render_mutex.unlock();
	}

	void Setup(Vector& vecSrc, Vector& vecThrow, QAngle viewangles)
	{
		QAngle angThrow = viewangles;
		float pitch = angThrow.pitch;

		if (pitch <= 90.0f)
		{
			if (pitch < -90.0f)
			{
				pitch += 360.0f;
			}
		}
		else
		{
			pitch -= 360.0f;
		}

		float a = pitch - (90.0f - fabs(pitch)) * 10.0f / 90.0f;
		angThrow.pitch = a;

		float flVel = 750.0f * 0.9f;

		static const float power[] = { 1.0f, 1.0f, 0.5f, 0.0f };
		float b = power[act];
		b = b * 0.7f;
		b = b + 0.3f;
		flVel *= b;

		Vector vForward, vRight, vUp;
		math::angle2vectors(angThrow, &vForward, &vRight, &vUp);

		vecSrc = g::local_player->GetEyePos();
		float off = (power[act] * 12.0f) - 12.0f;
		vecSrc.z += off;

		trace_t tr;
		Vector vecDest = vecSrc;
		vecDest += vForward * 22.0f;

		TraceHull(vecSrc, vecDest, tr);

		Vector vecBack = vForward; vecBack *= 6.0f;
		vecSrc = tr.endpos;
		vecSrc -= vecBack;

		vecThrow = g::local_player->m_vecVelocity(); vecThrow *= 1.25f;
		vecThrow += vForward * flVel;
	}

	void ResolveFlyCollisionCustom(trace_t& tr, Vector& vecVelocity, float interval)
	{
		if (!settings::visuals::grenade_prediction)
			return;

		// Calculate elasticity
		float flSurfaceElasticity = 1.0;
		float flGrenadeElasticity = 0.45f;
		float flTotalElasticity = flGrenadeElasticity * flSurfaceElasticity;
		if (flTotalElasticity > 0.9f) flTotalElasticity = 0.9f;
		if (flTotalElasticity < 0.0f) flTotalElasticity = 0.0f;

		// Calculate bounce
		Vector vecAbsVelocity;
		PhysicsClipVelocity(vecVelocity, tr.plane.normal, vecAbsVelocity, 2.0f);
		vecAbsVelocity *= flTotalElasticity;

		float flSpeedSqr = vecAbsVelocity.LengthSqr();
		static const float flMinSpeedSqr = 20.0f * 20.0f;

		if (flSpeedSqr < flMinSpeedSqr)
		{
			vecAbsVelocity.x = 0.0f;
			vecAbsVelocity.y = 0.0f;
			vecAbsVelocity.z = 0.0f;
		}

		if (tr.plane.normal.z > 0.7f)
		{
			vecVelocity = vecAbsVelocity;
			vecAbsVelocity *= ((1.0f - tr.fraction) * interval);
			PushEntity(tr.endpos, vecAbsVelocity, tr);
		}
		else
		{
			vecVelocity = vecAbsVelocity;
		}
	}

	void TraceHull(Vector& src, Vector& end, trace_t& tr)
	{
		if (!settings::visuals::grenade_prediction)
			return;

		Ray_t ray;
		ray.Init(src, end, Vector(-2.0f, -2.0f, -2.0f), Vector(2.0f, 2.0f, 2.0f));

		CTraceFilterWorldAndPropsOnly filter;

		g::engine_trace->trace_ray(ray, 0x200400B, &filter, &tr);
	}

	void PushEntity(Vector& src, const Vector& move, trace_t& tr)
	{
		if (!settings::visuals::grenade_prediction)
			return;

		Vector vecAbsEnd = src;
		vecAbsEnd += move;
		TraceHull(src, vecAbsEnd, tr);
	}

	void AddGravityMove(Vector& move, Vector& vel, float frametime, bool onground)
	{
		if (!settings::visuals::grenade_prediction)
			return;

		Vector basevel(0.0f, 0.0f, 0.0f);

		move.x = (vel.x + basevel.x) * frametime;
		move.y = (vel.y + basevel.y) * frametime;

		if (onground)
		{
			move.z = (vel.z + basevel.z) * frametime;
		}
		else
		{
			float gravity = 800.0f * 0.4f;
			float newZ = vel.z - (gravity * frametime);
			move.z = ((vel.z + newZ) / 2.0f + basevel.z) * frametime;
			vel.z = newZ;
		}
	}

	int PhysicsClipVelocity(const Vector& in, const Vector& normal, Vector& out, float overbounce)
	{
		static const float STOP_EPSILON = 0.1f;

		float    backoff;
		float    change;
		float    angle;
		int        i, blocked;

		blocked = 0;

		angle = normal[2];

		if (angle > 0)
		{
			blocked |= 1;        // floor
		}
		if (!angle)
		{
			blocked |= 2;        // step
		}

		backoff = in.Dot(normal) * overbounce;

		for (i = 0; i < 3; i++)
		{
			change = normal[i] * backoff;
			out[i] = in[i] - change;
			if (out[i] > -STOP_EPSILON && out[i] < STOP_EPSILON)
			{
				out[i] = 0;
			}
		}

		return blocked;
	}

	void render(ImDrawList* draw_list)
	{
		if (render::menu::is_visible() || !g::engine_client->IsInGame() || !g::engine_client->IsConnected() || g::engine_client->IsConsoleVisible())
			return;

		if (render_mutex.try_lock())
		{
			saved_points = screen_points;

			render_mutex.unlock();
		}

		if (saved_points.empty())
			return;

		static const auto red_color = ImGui::GetColorU32(ImVec4::Red);
		static const auto white_color = ImGui::GetColorU32(ImVec4::White);
		static const auto black_color = ImGui::GetColorU32(ImVec4::Black);
		static const auto blue_color = ImGui::GetColorU32(ImVec4(0.25f, 0.25f, 0.8f, 1.f));

		for (auto& point : saved_points)
		{
			draw_list->AddLine(ImVec2(point.first.x, point.first.y), ImVec2(point.second.x, point.second.y), was_flashed ? black_color : white_color, 1.5f);
		}

		const auto last_point = saved_points[saved_points.size() - 1].second;
		draw_list->AddCircle(ImVec2(last_point.x, last_point.y), 5.f, red_color);

		const auto& first_point = saved_points.at(0);
		draw_list->AddRectFilled(ImVec2(first_point.first.x - 5.f, first_point.first.y - 5.f), ImVec2(first_point.second.x + 5.f, first_point.second.y + 5.f), was_flashed ? black_color : white_color);
	}
}
```

`src/features/lefthand_knife.cpp`:

```cpp
#include "features.h"

namespace features
{
	void lefthand_knife()
	{
		static auto left_knife = g::cvar->find("cl_righthand");

		if (!g::local_player || !g::local_player->IsAlive())
		{
			left_knife->SetValue(1);
			return;
		}

		const auto& weapon = g::local_player->m_hActiveWeapon();

		if (!weapon)
			return;

		left_knife->SetValue(!weapon->IsKnife());
	}
}
```

`src/features/nade_helper.cpp`:

```cpp
#include "nade_helper.h"
#include "../render/render.h"
#include "../helpers/imdraw.h"

#include <map>

std::unordered_map<std::string, std::vector<grenade_data_t>> data =
{
	{ "mirage", grenade_data_mirage },
	{ "inferno", grenade_data_inferno },
	{ "dust2", grenade_data_dust2 },
	{ "nuke", grenade_data_nuke },
	{ "overpass", grenade_data_overpass },
	{ "train", grenade_data_train },
	{ "cache", grenade_data_cache },
	{ "cbble", grenade_data_cobblestone }
};

namespace visuals
{
	void SmokeHelperAimbot(CUserCmd* cmd)
	{
		if (!g::local_player)
			return;

		for (auto& x : data)
		{
			if (strstr(g::engine_client->GetLevelName(), x.first.c_str())) //TODO: Convert to hash.
			{
				for (auto& it : x.second)
				{
					if (g::local_player->m_hActiveWeapon())
					{
						auto dist = g::local_player->m_vecOrigin().DistTo(it.pos);
						if (g::local_player->m_hActiveWeapon()->IsSmoke() && dist <= 70)
						{
							QAngle angle = QAngle(it.ang.x, it.ang.y, it.ang.z);
							float fov = math::GetFovToPlayer(cmd->viewangles, angle);

							math::smooth(16.f, cmd->viewangles, angle, angle, false);

							angle.NormalizeClamp();

							if (fov <= 2.f)
							{
								if (cmd->buttons & (IN_ATTACK | IN_ATTACK2))
									g::engine_client->SetViewAngles(angle);
							}
						}
					}
				}
			}
		}
	}

	void RenderCircle()
	{
		if (!g::engine_client->IsInGame() || !g::engine_client->IsConnected() || !g::local_player)
			return;

		if (!settings::misc::smoke_helper)
			return;

		if (g::engine_client->IsConsoleVisible())
			return;

		static Vector out;

		int x, y;
		g::engine_client->GetScreenSize(x, y);

		int cy = y / 2;
		int cx = x / 2;

		for (auto& x : data)
		{
			if (strstr(g::engine_client->GetLevelName(), x.first.c_str())) //TODO: Convert to hash.
			{
				for (auto& it : x.second)
				{
					if (!g::local_player->m_hActiveWeapon())
						continue;

					if (!g::local_player->m_hActiveWeapon()->IsSmoke())
						continue;

					float distance = g::local_player->m_vecOrigin().DistTo(it.pos);

					if (distance > 70.f)
						continue;
			
					Vector crosshair_pos = g::local_player->GetEyePos() + (utils::CalcDir(it.ang) * 250.f);
					Vector circle_pos = utils::CalcHelpPos(it.pos);

					if (!math::world2screen(crosshair_pos, out))
						continue;

					globals::draw_list->AddCircle(ImVec2(out.x, out.y), 9.f, IM_COL32(255, 255, 255, 255));
					globals::draw_list->AddCircleFilled(ImVec2(out.x, out.y), 8.f, IM_COL32(255, 255, 0, 255));
					globals::draw_list->AddCircleFilled(ImVec2(out.x - circle_pos.x, out.y - circle_pos.y), 2.f, IM_COL32(0, 0, 0, 255));
					imdraw::outlined_text(it.info.c_str(), ImVec2(out.x + 12.f, out.y - 7.f), IM_COL32(255, 255, 255, 255));
					globals::draw_list->AddLine(ImVec2(cx, cy), ImVec2(out.x, out.y), IM_COL32(0, 0, 0, 127), 2.f);
					globals::draw_list->AddCircle(ImVec2(cx, cy), 10.f, utils::to_im32(Color::White), 255);
				}
            }
		}
	}

	void drawring_3d()
	{
		if (!g::engine_client->IsInGame() || !g::engine_client->IsConnected() || !g::local_player)
			return;

		if (!settings::misc::smoke_helper)
			return;

		if (g::engine_client->IsConsoleVisible())
			return;

		for (auto& x : data)
		{
			if (strstr(g::engine_client->GetLevelName(), x.first.c_str())) //TODO: Conver to hash.
			{
				for (auto& it : x.second)
				{
					Vector ppos = it.pos;

					auto dist = g::local_player->m_vecOrigin().DistTo(it.pos);

					if (g::local_player->m_hActiveWeapon())
					{
						if (g::local_player->m_hActiveWeapon()->IsSmoke() && dist <= 500.f)
						{
							globals::draw_list->AddRing3D(Vector(ppos.x, ppos.y, ppos.z - it.ring_height), 15.f, 255, IM_COL32_WHITE, 1.0f);
						}
					}
				}
			}
		}
	}

	void RenderInfo()
	{
		if (!g::engine_client->IsInGame() || !g::engine_client->IsConnected() || !g::local_player)
			return;

		if (!settings::misc::smoke_helper)
			return;

		if (g::engine_client->IsConsoleVisible())
			return;

		Vector InfoPosScreen;

		for (auto& x : data)
		{
			if (strstr(g::engine_client->GetLevelName(), x.first.c_str())) //TODO: Convert to hash.
			{
				for (auto& it : x.second)
				{
					Vector InfoPos = it.pos;

					float dist = g::local_player->m_vecOrigin().DistTo(it.pos);
					auto size = ImGui::CalcTextSize(it.info.c_str());

					if (g::local_player->m_hActiveWeapon())
					{
						if (g::local_player->m_hActiveWeapon()->IsSmoke() && dist <= 500.f && math::world2screen(InfoPos, InfoPosScreen))
						{
							imdraw::outlined_text(it.info.c_str(), ImVec2(InfoPosScreen.x - it.info.length() - 15.f, InfoPosScreen.y - 75.f), IM_COL32(255, 255, 255, 255));
						}
					}
				}
			}
		}
	}
}
```

`src/features/nade_helper.h`:

```h
#pragma once
#include <string>
#include "../valve_sdk/csgostructs.hpp"
#include "../features/features.h"
#include "../settings/globals.h"

struct grenade_data_t
{
	std::string info;
	std::string type;
	Vector pos;
	Vector ang;
	float ring_height;
};

std::vector<grenade_data_t> grenade_data_mirage = {

	{ "Connector J", "JUMP", Vector(1135.99f, 647.98f, -197.32f), Vector(-28.93f, -140.63f, 0.0f), 60.f },
	{ "Jungle LC", "LCLICK", Vector(815.f, -1416.f, -44.f), Vector(-28.29f, -173.14f, 0.f), 60.f },
	{ "Window Mid J", "JUMP", Vector(1423.964355f, -248.026840f, -167.906188f), Vector(-25.723558f, -170.518921f, 0.f), 0.f },
	{ "Catwalk LC", "LCLICK", Vector(1423.997803f, 71.985359f, -112.840103f), Vector(-32.653351f, -163.530762f, 0.f), 0.f },
	{ "One-way Mid RC", "RCLICK", Vector(369.960144f, -720.522705f, -162.412476f), Vector(35.376301f, 124.135780f, 0.f), 0.f },
	{ "Short R", "RUN", Vector(399.998444f, 4.656666f, -203.571350f), Vector(-22.060497f, -134.482208f, 0.f), 0.f },
	{ "Window Mid LC", "LCLICK", Vector(-624.243530f, 615.992065f, -78.914246f), Vector(-51.595604f, -109.421127f, 0.f), 0.f },
	{ "Kitchen Door LC", "LCLICK", Vector(-2325.227783f, 811.800659f, -119.773079f), Vector(-14.883981f, -94.343178f, 0.f), 0.f },
	{ "Short LC", "LCLICK", Vector(-160.031250f, 887.968750f, -135.265563f), Vector(-44.269619f, -134.435654f, 0.f), 0.f },
	{ "Kitchen Window LC", "LCLICK", Vector(-835.001404f, 615.070190f, -79.065735f), Vector(-63.789238f, -146.581238f, 0.f), 0.f },
	{ "Short LC", "LCLICK", Vector(341.836212f, -620.153992f, -163.282486f), Vector(-23.134167f, 164.957458f, 0.f), 0.f },
	{ "Stairs LC", "LCLICK", Vector(1148.225586f, -1183.999756f, -205.509155f), Vector(-41.168613f, -165.354019f, 0.f), 0.f },
	{ "Window Mid R", "RUN", Vector(1391.968750f, -1011.236084f, -167.906188f), Vector(-42.603077f, 172.188919f, 0.f), 0.f },
	{ "Stairs J", "JUMP", Vector(-90.864479f, -1418.000244f, -115.906189f), Vector(-31.895834f, -62.464306f, 0.f), 0.f },
	{ "Fireboxes J", "JUMP", Vector(1391.968750f, -930.076294f, -167.906188f), Vector(-21.037338f, -151.204865f, 0.f), 0.f },
	{ "One-way LC", "LCLICK", Vector(457.968750f, -1711.996582f, -240.886871f), Vector(-10.477256f, 133.144836f, 0.f), 0.f },
	{ "Bombsite A LC", "LCLICK", Vector(815.998718f, -1272.017944f, -108.906189f), Vector(-32.654591f, -149.503601f, 0.f), 0.f },
	{ "CT Spawn J", "JUMP", Vector(1257.861938f, -871.968750f, -143.906188f), Vector(-21.318205f, -144.344666f, 0.f), 0.f },
	{ "One-way LC", "LCLICK", Vector(-1209.077515f, -873.270447f, -167.906188f), Vector(-48.526600f, 67.790833f, 0.f), 0.f },
	{ "One-way RC", "RCLICK", Vector(-964.056885f, -2489.520264f, -167.913391f), Vector(-41.926632f, -10.765607f, 0.f), 0.f },
	{ "Ramp J", "JUMP", Vector(-2026.397583f, -2029.968750f, -299.060150f), Vector(-15.312100f, 12.573707f, 0.f), 0.f },
	{ "One-way Kitchen LC", "LCLICK", Vector(-2600.019287f, 535.973022f, -159.906188f), Vector(-16.582365f, -50.818062f, 0.f), 0.f },
	{ "B Short Leftside J&LC", "JUMP & LCLICK", Vector(-752.031250f, -57.039669f, -98.207809f), Vector(2.328622f, 138.313522f, 0.f), 60.f},
	{ "CT Spawn J", "JUMP", Vector(344.09f, -622.41f, -99.41f), Vector(-20.42f, -116.26f, 0.f), 0.f },
	{ "CT Spawn LC", "LCLICK", Vector(-264.03f, -1504.03f, -99.91f), Vector(-20.26f, -108.16f, 0.f), 60.f },
	{ "CT Spawn LC", "LCLICK", Vector(-493.03f, -1309.03f, -95.91f), Vector(-6.74f, -108.59f, 0.f), 60.f },
	{ "CT Spawn LC", "LCLICK", Vector(-129.52f, -2413.97f, -99.91f), Vector(-2.67f, 166.37f, 0.f), 60.f },
	{ "CT Spawn LC", "LCLICK", Vector(-31.92f, -1418.03f, -103.91f), Vector(-35.24f, -116.29f, 0.f), 60.f },
	{ "CT Spawn J", "JUMP", Vector(1087.09f, -1016.95f, -194.16f), Vector(-29.63f, -144.91f, 0.f), 60.f },
	{ "B Door R", "RUN", Vector(-161.00f, 497.64f, -4.74f), Vector(-43.04f, -159.03f, 0.0f), 60.f },
	{ "Connector LC", "LCLICK", Vector(-972.03f, -374.03f, -284.89f), Vector(-57.60f, -75.98f, 0.0f), 60.f }
};

std::vector<grenade_data_t> grenade_data_inferno = {

	{ "CT Spawn", "LCLICK", Vector(116.294136f, 1580.581055f, 185.121933f), Vector(-32.574593f, 58.334656f, 0.f), 60.f },
	{ "Bombsite B", "LCLICK", Vector(1971.687988f, 2636.702393f, 128.093811f), Vector(-39.996227f, 175.975357f, 0.f), -10.f },
	{ "Mid", "RUN", Vector(-857.968750f, 449.902283f, -31.604805f),  Vector(-44.401531f, 1.405892f, 0.f), -10.f},
	{ "Coffins", "LCLICK", Vector(338.871887f, 1650.802856f, 122.093810f),  Vector(-50.093639f, 84.572739f, 0.f), -10.f },
	{ "B Entrance", "LCLICK", Vector(460.464905f, 1828.470825f, 136.182693f),  Vector(-25.443281f, 86.280159f, 0.f), -10.f },
	{ "Long", "RUN", Vector(274.681335f, -224.627777f, 88.093810f),  Vector(-41.052132f, 31.799410f, 0.f), -10.f },
	{ "Pit", "LCLICK", Vector(704.160339f, 11.968750f, 88.797089f),  Vector(-52.337799f, -2.135024f, 0.f), -10.f },
	{ "Short", "LCLICK", Vector(697.511902f, -242.261810f, 91.093810f),  Vector(-53.097946f, 16.442726f, 0.f), -10.f },
	{ "Library to A", "LCLICK", Vector(960.900330f, 434.006409f, 88.093810f),  Vector(-49.863846f, 13.159984f, 0.f), -10.f },
	{ "Pit to Hay", "LCLICK", Vector(726.031250f, 220.962921f, 94.029999f),  Vector(-55.241890f, -8.699924f, 0.f), -10.f },
	{ "Long", "LCLICK", Vector(491.936829f, -267.968750f, 88.093810f),  Vector(-42.024933f, 45.854645f, 0.f), -10.f },
	{ "Connector", "LCLICK", Vector(726.031250f, 288.680084f, 96.093810f),  Vector(-43.560978f, 41.450943f, 0.f), -10.f },
	{ "One-way", "LCLICK", Vector(2631.968750f, -16.031250f, 84.093810f),  Vector(-5.692367f, -179.128860f, 0.f), -10.f },
	{ "Balcony", "LCLICK", Vector(1913.227295f, 1225.968750f, 174.093811f),  Vector(-46.497322f, -87.005005f, 0.f), 0.f }
};

std::vector<grenade_data_t> grenade_data_dust2 = {

	{ "B Entrance", "LCLICK", Vector(-1846.553223f, 1232.569824f, 32.496025f), Vector(-8.613732f, 118.773392f, 0.f), 0.f },
	{ "CT Mid", "LCLICK", Vector(-538.606567f, 1382.031250f, -111.957108f), Vector(-35.360550f, 53.845985f, 0.f), 0.f },
	{ "Xbox", "LCLICK", Vector(229.130554f, 112.497559f, 5.215744f), Vector(-40.624023f, 108.758316f, 0.f), 0.f },
	{ "Long Corner", "LCLICK", Vector(222.664124f, -87.978210f, 9.093811f), Vector(-46.250572f, 48.164497f, 0.f), 0.f },
	{ "CT Spawn", "RUN", Vector(860.031250f, 790.031250f, 3.900847f), Vector(-23.414322f, 43.616291f, 0.f), 0.f },
	{ "Short", "LCLICK", Vector(489.998535f, 1446.031250f, 2.660506f), Vector(-5.677320f, 88.280685f, 0.f), 0.f },
	{ "Long Gate", "LCLICK", Vector(1752.049561f, 2046.932739f, 0.365111f), Vector(-33.430305f, -130.546280f, 0.f), 0.f },
	{ "Lower Mid", "LCLICK", Vector(-242.031250f, 2278.887695f, -119.931587f), Vector(-32.687481f, -123.649094f, 0.f), 0.f },
	{ "Upper Tunnel", "LCLICK", Vector(-985.452942f, 2553.223877f, 1.318862f), Vector(-26.764244f, -143.848251f, 0.f), 0.f }
};

std::vector<grenade_data_t> grenade_data_nuke = {

	{ "Hangar", "LCLICK", Vector(-164.092941f, -1954.733765f, -415.916107f), Vector(-13.613587f, 1.278547f, 0.f), 0.f },
	{ "Red Container", "LCLICK", Vector(-533.003357f, -833.215759f, -193.634827f), Vector(-30.904673f, -43.816589f, 0.f), 0.f },
	{ "Between Containers", "RUN", Vector(-423.996399f, -1753.002075f, -415.914856f), Vector(-2.624159f, -50.804165f, 0.f), 0.f },
	{ "T Outside", "JUMP", Vector(1664.031250f, -280.002014f, -351.906250f), Vector(-25.048063f, -135.212463f, 0.f), 0.f }
};

std::vector<grenade_data_t> grenade_data_overpass = {

	{ "Toilet Entrance", "RUN", Vector(-730.031250f, -2225.143799f, 240.093811f), Vector(-51.612926f, 149.045975f, 0.f), 0.f },
	{ "B Bridge", "LCLICK", Vector(-617.486389f, -1509.028809f, 144.093811f), Vector(-48.988934f, 113.071342f, 0.f), 0.f },
	{ "B Center", "LCLICK", Vector(-525.982300f, -1551.984375f, 144.093811f), Vector(-43.807911f, 110.431473f, 0.f), 0.f },
	{ "Barrels to Pillar", "LCLICK", Vector(-613.014099f, -1082.017212f, 42.160416f), Vector(-29.337307f, 99.340714f, 0.f), 0.f },
	{ "B Center", "LCLICK", Vector(-1567.968750f, -1087.984619f, 0.093811f), Vector(-30.278185f, 74.646019f, 0.f), 0.f },
	{ "Monster to Pillar", "LCLICK", Vector(-1645.986938f, -1087.982300f, 96.093810f), Vector(-20.015800f, 55.835869f, 0.f), 0.f },
	{ "Heaven", "LCLICK", Vector(-1559.968750f, -728.785583f, 52.574355f), Vector(-33.446209f, 96.293686f, 0.f), 0.f },
	{ "B Bridge", "LCLICK", Vector(-1559.999390f, -361.285339f, 32.421722f), Vector(-43.693123f, 21.193089f, 0.f), 0.f },
	{ "Heaven", "LCLICK", Vector(-2174.002441f, -1151.968750f, 398.197235f), Vector(-26.368107f, 71.543701f, 0.f), 0.f },
	{ "Long to Boxes", "LCLICK", Vector(-2025.534058f, -865.001343f, 395.427856f), Vector(-28.313963f, 114.564102f, 0.f), 0.f },
	{ "Bank", "LCLICK", Vector(-2162.000488f, -519.968750f, 391.460358f), Vector(-29.749702f, 100.836487f, 0.f), 0.f },
	{ "Truck to Bank", "LCLICK", Vector(-3612.545654f, -177.626740f, 512.791992f), Vector(-40.392601f, 51.259613f, 0.f), 0.f },
	{ "Boxes to Truck", "LCLICK", Vector(-3540.031250f, -381.968750f, 528.080200f), Vector(-14.256992f, 41.849758f, 0.f), 0.f },
	{ "Truck", "LCLICK", Vector(-2351.968750f, -815.968750f, 391.089905f), Vector(-34.683971f, 81.500427f, 0.f), 0.f },
	{ "Trash", "LCLICK", Vector(-2351.968750f, -414.031250f, 388.562317f), Vector(-60.588089f, 73.825958f, 0.f), 0.f },
	{ "Trash", "LCLICK", Vector(-3383.369629f, 35.247875f, 516.906006f), Vector(-18.035419f, 31.699080f, 0.f), 0.f },
	{ "Long", "DUCK", Vector(-1993.398926f, 537.698242f, 475.093810f), Vector(-28.677984f, -169.596695f, 0.f), 0.f },
	{ "Monster", "LCLICK", Vector(-1926.860962f, 1311.968750f, 355.030579f), Vector(-46.200985f, -40.010532f, 0.f), 0.f },
	{ "One-way", "LCLICK", Vector(-2191.968750f, 1311.968750f, 356.093811f), Vector(-8.861760f, -55.390415f, 0.f), 0.f },
	{ "One-way", "RCLICK", Vector(-1826.375610f, 629.178894f, 256.093811f), Vector(26.580435f, -17.457275f, 0.f), 0.f },
	{ "One-way", "LCLICK", Vector(-2012.968750f, -1231.968750f, 240.093811f), Vector(16.218643f, 63.144173f, 0.f), 0.f },
	{ "Short B", "LCLICK", Vector(-2115.841309f, 992.920288f, 480.093810f), Vector(-22.936214f, -57.690578f, 0.f), 0.f }
};

std::vector<grenade_data_t> grenade_data_train = {

	{ "B Upper", "LCLICK", Vector(-1055.968750f, -1607.969116f, -151.906188f), Vector(-9.076089f, -21.028521f, 0.f), 0.f },
	{ "B Lower", "LCLICK", Vector(-1159.978027f, -1088.112549f, -95.909508f), Vector(-9.122071f, 13.307947f, 0.f), 0.f },
	{ "Blue to Bombsite", "RUN", Vector(-1155.979004f, -1301.504395f, -95.906189f), Vector(-15.857571f, 38.882820f, 0.f), 0.f },
	{ "Connector", "RUN", Vector(-1159.999634f, -1048.001709f, -95.906189f), Vector(-11.023086f, 5.091055f, 0.f), 0.f },
	{ "Ivy - Right", "LCLICK", Vector(1388.426270f, 1446.000488f, -223.906189f), Vector(-6.188282f, -95.524574f, 0.f), 0.f },
	{ "Ivy - Left", "RUN", Vector(1535.968750f, 1775.968750f, -223.906189f), Vector(-9.818258f, -112.486588f, 0.f), 0.f },
	{ "Bombsite A to Connector", "LCLICK & RCLICK", Vector(-655.968750f, -399.892731f, 16.093811f), Vector(-46.002502f, 10.890710f, 0.f), 0.f },
	{ "Blue to Red Train", "LCLICK", Vector(-645.479370f, 1697.721924f, -209.906189f), Vector(-41.564690f, -65.086685f, 0.f), 0.f },
	{ "Electric Box", "LCLICK", Vector(-481.865631f, 1725.011597f, -209.906189f), Vector(-45.937080f, -78.790627f, 0.f), 0.f },
	{ "Blue Train - Left", "LCLICK", Vector(-555.031250f, 1262.031250f, -212.532227f), Vector(-68.096550f, -50.974125f, 0.f), 0.f },
	{ "Green to Red Train", "LCLICK", Vector(-838.162292f, 1268.024414f, -222.906189f), Vector(-37.604507f, -42.064575f, 0.f), 0.f },
	{ "Green Train", "LCLICK", Vector(-640.027832f, -583.969666f, 16.093811f), Vector(-44.699406f, 32.218452f, 0.f), 0.f },
	{ "Red Train", "LCLICK", Vector(-453.358459f, 1286.284668f, -86.490753f), Vector(-25.130558f, -58.731426f, 0.f), 0.f },
	{ "Main", "LCLICK", Vector(1021.096924f, -254.988556f, -215.906189f), Vector(-38.494926f, 154.562332f, 0.f), 0.f }
};

std::vector<grenade_data_t> grenade_data_cache = {

	{ "B Center", "LCLICK", Vector(827.971313f, -1463.968750f, 1614.093750f), Vector(-21.995483f, 162.191437f, 0.f), 0.f },
	{ "Mid Center", "LCLICK", Vector(1711.974121f, 463.987732f, 1614.093750f), Vector(-10.675973f, -167.299591f, 0.f), 0.f },
	{ "One-way", "LCLICK", Vector(1037.031250f, 513.031250f, 1613.550293f), Vector(-49.137814f, 104.639671f, 0.f), 0.f },
	{ "Mid", "LCLICK", Vector(1711.968750f, -71.968750f, 1614.093750f), Vector(-10.560504f, 161.185349f, 0.f), 0.f },
	{ "Bombsite A", "DUCK", Vector(154.413376f, 2096.080566f, 1688.093750f), Vector(9.370919f, -29.337667f, 0.f), 0.f },
	{ "Short", "RUN", Vector(139.031250f, 2197.968750f, 1688.093750f), Vector(-6.040052f, -60.836231f, 0.f), 0.f },
	{ "Bombsite A", "LCLICK", Vector(1319.968750f, 1520.395508f, 1701.093750f), Vector(-57.767025f, 161.424835f, 0.f), 0.f },
	{ "Main", "LCLICK", Vector(-782.198059f, 1110.000366f, 1689.439697f), Vector(-9.703021f, 24.963852f, 0.f), 0.f },
	{ "Main", "LCLICK", Vector(-429.968750f, 2244.968750f, 1687.093750f), Vector(-66.017174f, -31.140173f, 0.f), 0.f },
	{ "Main", "LCLICK", Vector(-50.012558f, 2261.968750f, 1687.093750f), Vector(-18.612713f, -64.612831f, 0.f), 0.f },
	{ "Vents", "RUN", Vector(-996.979553f, 1440.231689f, 1691.182373f), Vector(-33.181599f, -46.326721f, 0.f), 0.f },
	{ "CT", "RUN", Vector(389.29f, -810.36f, 1678.09f), Vector(-12.47f, 138.20f, 0.f), 60.f },
	{ "Forklift", "RUN", Vector(761.97f, 1297.22f, 1766.09f), Vector(-4.16f, 127.43f, 0.f), 60.f }
};

std::vector<grenade_data_t> grenade_data_cobblestone = {

	{ "One-way Long", "DUCK & RCLICK", Vector(272.031250f, -291.031250f, -63.906189f), Vector(-30.971577f, 17.418360f, 0.f), 0.f },
	{ "B Long", "JUMP", Vector(-1540.973389f, -1226.978027f, -25.199188f), Vector(-50.672855f, 41.294445f, 0.f), 0.f },
	{ "Matrix", "LCLICK", Vector(-1864.968750f, -1611.968750f, 96.093810f), Vector(-11.221231f, 136.023499f, 0.f), 0.f },
	{ "B Long", "LCLICK", Vector(-288.031250f, 1020.970520f, 128.093811f), Vector(-51.547066f, -53.167721f, 0.f), 0.f },
	{ "Truck - Front", "LCLICK", Vector(-3295.975586f, 79.968750f, -29.906188f), Vector(-36.680634f, -52.524323f, 0.f), 0.f },
	{ "Truck - Right", "LCLICK", Vector(-3168.031250f, 79.968750f, -29.906188f), Vector(-47.158157f, -65.556221f, 0.f), 0.f },
	{ "Grass", "LCLICK", Vector(-3167.270508f, 584.685120f, 0.093811f), Vector(-55.144222f, -61.434193f, 0.f), 0.f },
	{ "Skyfall", "LCLICK", Vector(-752.031250f, -80.031250f, 128.093811f), Vector(5.361639f, -119.332336f, 0.f), 0.f },
	{ "Hut - Right", "LCLICK", Vector(-155.970673f, -16.010778f, -31.906188f), Vector(-50.869473f, -69.637550f, 0.f), 0.f },
	{ "Hut - LefT", "LCLICK", Vector(-340.020111f, -80.031250f, -31.907466f), Vector(-53.921837f, -52.166801f, 0.f), 0.f },
	{ "Sandwich", "LCLICK", Vector(47.968750f, -16.031250f, -23.114716f), Vector(-81.378204f, -89.289169f, 0.f), 0.f },
	{ "Fountain", "LCLICK", Vector(-418.514893f, -95.749924f, -32.562836f), Vector(-75.323563f, -61.343159f, 0.f), 0.f },
	{ "B Door", "LCLICK", Vector(-558.031250f, -42.535999f, 0.093811f), Vector(-62.173512f, -100.720726f, 0.f), 0.f },
	{ "Balcony", "JUMP", Vector(-2534.005371f, -272.031250f, -184.407272f), Vector(-17.127037f, -65.392319f, 0.f), 0.f },
	{ "A Door", "WALK & LCLICK", Vector(-3346.178711f, 455.572449f, 0.093811f), Vector(-40.327240f, -45.610413f, 0.f), 0.f },
	{ "A Door", "RUN", Vector(-2989.968750f, -944.371948f, 32.093811f), Vector(-12.160514f, -4.402364f, 0.f), 0.f }
};



```

`src/features/player_infobox.cpp`:

```cpp
#include "../render/render.h"
#include "features.h"
#include "../settings/globals.h"
#include "../helpers/imdraw.h"
#include "../helpers/entities.h"

namespace features
{
	std::mutex render_mutex;
	entities::player_data_t entities[MAX_PLAYERS];

	ImVec4 color;

	float per_x = 43.f;
	float per_y = 26.f;

	int index = 1;

	Vector origin;

	bool is_enabled()
	{
		if (!render::fonts::low_size || g::engine_client->IsConsoleVisible() || g::engine_client->IsDrawingLoadingImage())
			return false;

		return g::engine_client->IsInGame() && g::local_player && settings::visuals::player_info_box;
	}

	void player_infobox()
	{
		if (!is_enabled())
			return;

		if (entities::locker.try_lock())
		{
			memcpy(entities, entities::m_items.front().players, sizeof(entities));
			entities::locker.unlock();
		}

		auto player_resource = *g::player_resource;
		
		ImGuiStyle style = ImGui::GetStyle();

		ImVec2 old_minsize = style.WindowMinSize;
		style.WindowMinSize = ImVec2(0.f, 0.f);

		for (const auto& data : entities)
		{
			if (data.index == 0 || data.index == g::local_player->GetIndex())
				continue;

			if (data.team_num == g::local_player->m_iTeamNum() && !settings::misc::deathmatch)
				continue;

			if (index < 5)
			{
				if (data.is_alive)
					index += 1;
				else index -= 1;

				ImGui::SetNextWindowSize(ImVec2(215.f, per_y * index));
			}

			
		}
		ImGui::SetNextWindowBgAlpha(settings::visuals::player_info_box_alpha);

		ImGui::PushFont(render::fonts::low_size);
		{
			//ImGuiWindowFlags_AlwaysAutoResize
			if (ImGui::Begin("Player Info Box", &settings::visuals::player_info_box, ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar))
			{
				render::columns(5);
				{
					ImGui::SetColumnWidth(-1, 40.f);
					ImGui::Text("Name");

					ImGui::NextColumn();

					ImGui::SetColumnWidth(-1, 25.f); //48
					ImGui::Text(" HP");

					ImGui::NextColumn();

					ImGui::SetColumnWidth(-1, 30.f); //45
					ImGui::Text("Level");

					ImGui::NextColumn();

					ImGui::SetColumnWidth(-1, 30.f);
					ImGui::Text("Wins");

					ImGui::NextColumn();

					ImGui::SetColumnWidth(-1, 30.f);
					ImGui::Text("Dist");
				}
				render::columns(1);

				for (const auto& data : entities)
				{
					if (data.index == 0 || data.index == g::local_player->GetIndex())
						continue;

					if (data.team_num == g::local_player->m_iTeamNum() && !settings::misc::deathmatch)
						continue;

					if (!player_resource)
						continue;

					render::columns(5);
					{
						if (data.is_alive)
							color = ImVec4(0.0f, 1.0f, 0.0f, 1.f);
						else color = ImVec4(1.0f, 0.f, 0.f, 1.f);

						ImGui::PushStyleColor(ImGuiCol_Text, color);

						ImGui::SetColumnWidth(-1, 40.f);
						ImGui::Text("%s", data.name.c_str());

						ImGui::PushStyleColor(ImGuiCol_Text, ImVec4(ImVec4::White));

						ImGui::NextColumn();

						ImGui::SetColumnWidth(-1, 25.f);
						ImGui::Text("%i", data.m_iHealth);

						ImGui::NextColumn();

						ImGui::SetColumnWidth(-1, 30.f);
						ImGui::Text("%i", player_resource->GetLevel()[data.index] == -1 ? 0 : player_resource->GetLevel()[data.index]);

						ImGui::NextColumn();

						ImGui::SetColumnWidth(-1, 30.f);
						ImGui::Text("%i", player_resource->GetWins()[data.index]);

						ImGui::NextColumn();

						ImGui::SetColumnWidth(-1, 30.f);
						ImGui::Text("%1.f", data.origin.DistTo(g::local_player->m_vecOrigin()));
					}
					render::columns(1);
					ImGui::PopStyleColor(2);
				}
			}
			ImGui::End();
			style.WindowMinSize = old_minsize;
		}
		ImGui::PopFont();
	}
}
```

`src/features/popflash_helper.cpp`:

```cpp
#include "popflash_helper.h"
#include "../render/render.h"

std::unordered_map<std::string, std::vector<popflash_data_t>> popflash_data =
{
	{ "mirage", popflash_data_mirage },
	{ "inferno", popflash_data_inferno },
	{ "dust2", popflash_data_dust2 },
	{ "nuke", popflash_data_nuke },
	{ "overpass", popflash_data_overpass },
	{ "train", popflash_data_train },
	{ "cache", popflash_data_cache },
	{ "cbble", popflash_data_cobblestone }
};

namespace visuals
{
	void PopflashHelperAimbot(CUserCmd* cmd)
	{
		if (!g::local_player)
			return;

		for (auto& x : popflash_data)
		{
			if (strstr(g::engine_client->GetLevelName(), x.first.c_str()))
			{
				for (auto& it : x.second)
				{
					if (g::local_player->m_hActiveWeapon())
					{
						auto dist = g::local_player->m_vecOrigin().DistTo(it.pos);
						if (g::local_player->m_hActiveWeapon()->IsFlash() && dist <= 70)
						{
							QAngle angle = QAngle(it.ang.x, it.ang.y, it.ang.z);
							float fov = math::GetFovToPlayer(cmd->viewangles, angle);

							math::smooth(16.f, cmd->viewangles, angle, angle, false);

							angle.NormalizeClamp();

							if (fov <= 2.f)
							{
								if (cmd->buttons & (IN_ATTACK | IN_ATTACK2))
									g::engine_client->SetViewAngles(angle);
							}
						}
					}
				}
			}
		}
	}

	void RenderCirclePopflash()
	{
		if (!g::engine_client->IsInGame() || !g::engine_client->IsConnected() || !g::local_player)
			return;

		if (!settings::misc::flash_helper)
			return;

		if (g::engine_client->IsConsoleVisible())
			return;

		Vector CrosshairScreen;

		int x, y;
		g::engine_client->GetScreenSize(x, y);

		int cy = y / 2;
		int cx = x / 2;

		for (auto& x : popflash_data)
		{
			if (strstr(g::engine_client->GetLevelName(), x.first.c_str()))
			{
				for (auto& it : x.second)
				{
					Vector Crosshair = g::local_player->GetEyePos() + (utils::CalcDir(it.ang) * 250.f);
					Vector TCircleOfst = utils::CalcHelpPos(it.pos);

					auto dist = g::local_player->m_vecOrigin().DistTo(it.pos);
					auto size = ImGui::CalcTextSize(it.info.c_str());
					auto _size = ImGui::CalcTextSize(it.type.c_str());

					if (g::local_player->m_hActiveWeapon())
					{
						if (g::local_player->m_hActiveWeapon()->IsFlash() && dist <= 70 && math::world2screen(Crosshair, CrosshairScreen))
						{
							//globals::draw_list->AddRectFilled(ImVec2(CrosshairScreen.x - 20.f, CrosshairScreen.y - 10.f), ImVec2(CrosshairScreen.x + size.x + 25.f, CrosshairScreen.y + 12.f), IM_COL32(0, 0, 0, 255));
							//globals::draw_list->AddRectFilled(ImVec2(CrosshairScreen.x + 8.f, CrosshairScreen.y - -10.f), ImVec2(CrosshairScreen.x + _size.x + 15.f, CrosshairScreen.y + 22.f), IM_COL32(0, 0, 0, 255));
							globals::draw_list->AddCircle(ImVec2(CrosshairScreen.x, CrosshairScreen.y), 9.f, IM_COL32(0, 0, 0, 255));
							globals::draw_list->AddCircleFilled(ImVec2(CrosshairScreen.x, CrosshairScreen.y), 8.f, IM_COL32(255, 255, 0, 255));
							globals::draw_list->AddCircleFilled(ImVec2(CrosshairScreen.x - TCircleOfst.x, CrosshairScreen.y - TCircleOfst.y), 2.f, IM_COL32(0, 0, 0, 255));
							globals::draw_list->AddText(ImVec2(CrosshairScreen.x + 12.f, CrosshairScreen.y - 7.f), IM_COL32(255, 255, 255, 255), it.info.c_str());
							globals::draw_list->AddText(ImVec2(CrosshairScreen.x + 12.f, CrosshairScreen.y - -7.f), IM_COL32(255, 255, 255, 255), it.type.c_str());
							globals::draw_list->AddLine(ImVec2(cx, cy), ImVec2(CrosshairScreen.x, CrosshairScreen.y), IM_COL32(0, 0, 0, 255), 2.f);
							globals::draw_list->AddCircle(ImVec2(cx, cy), 10.f, utils::to_im32(Color::White), 255);
						}
					}
				}
			}
		}
	}

	void drawring_3d_popflash()
	{
		if (!g::engine_client->IsInGame() || !g::engine_client->IsConnected() || !g::local_player)
			return;

		if (!settings::misc::flash_helper)
			return;

		if (g::engine_client->IsConsoleVisible())
			return;

		for (auto& x : popflash_data)
		{
			if (strstr(g::engine_client->GetLevelName(), x.first.c_str()))
			{
				for (auto& it : x.second)
				{
					Vector ppos = it.pos;
					
					auto dist = g::local_player->m_vecOrigin().DistTo(it.pos);

					if (g::local_player->m_hActiveWeapon())
					{
						if (g::local_player->m_hActiveWeapon()->IsFlash() && dist <= 1000.f)
						{
							ppos = Vector(ppos.x, ppos.y, ppos.z - it.ring_height);
							globals::draw_list->AddRing3D(ppos, 15.f, 255, IM_COL32(255, 0, 0, 255), 1.0f);
						}
					}
				}
			}
		}
	}
}
```

`src/features/popflash_helper.h`:

```h
#pragma once
#include <string>
#include "../valve_sdk/csgostructs.hpp"
#include "../features/features.h"
#include "../settings/globals.h"

struct popflash_data_t
{
	std::string info;
	std::string type;
	Vector pos;
	Vector ang;
	float ring_height;
};

std::vector<popflash_data_t> popflash_data_mirage = {

	{ "Popflash", "LClick", Vector(150.96f, -1914.03f, -103.90f), Vector(-38.69f, -111.75f, 0.f), 60.f },
	{ "Popflash", "L + R", Vector(-496.03f, -1309.13f, -95.90f), Vector(-26.32f, -89.92f, 0.f), 60.f },
	{ "Popflash", "LClick", Vector(-2318.40f, -695.97f, -103.90f), Vector(-21.92f, 87.76f, 0.f), 60.f },
	{ "Popflash", "LClick", Vector(-197.42f, -344.03f, -99.90f), Vector(-52.44f, -176.65f, 0.f), 60.f },
	{ "Popflash", "LClick", Vector(399.922f, 55.97f, -149.65f), Vector(-47.07f, -155.03f, 0.f), 60.f },
	{ "Popflash", "LClick", Vector(-1017.02f, -2232.03f, -48.84f), Vector(-75.05f, 73.20f, 0.f), 60.f },
	{ "Popflash", "LClick", Vector(-1471.96f, 664.03f, 16.09f), Vector(-7.69f, 109.26f, 0.f), 60.f },
	{ "Popflash", "RUN + L", Vector(-1372.03f, -1095.96f, -103.90f), Vector(-15.90f, 171.88f, 0.f), 60.f },
	{ "Popflash", "LClick", Vector(-2199.78f, 88.03f, -95.90f), Vector(-24.23f, 7.79f, 0.f), 60.f }
};

std::vector<popflash_data_t> popflash_data_inferno = {

	{ "Popflash", "LClick", Vector(1275.96f, -111.96f, 320.09f), Vector(7.75f, 116.85f, 0.f), 60.f },
	{ "Popflash", "LClick", Vector(2150.16f, 313.98f, 224.09f), Vector(-38.77f, -156.95f, 0.f), 60.f },
	{ "Popflash", "RClick", Vector(1821.03f, 184.03f, 286.09f), Vector(-49.09f, 43.95f, 0.f), 60.f },
	{ "Popflash", "LClick", Vector(1764.70f, 1303.34f, 224.08f), Vector(-46.25f, 61.56f, 0.f), 60.f },
	{ "Popflash", "LClick", Vector(2194.03f, 955.03f, 224.46f), Vector(-24.79f, -104.66f, 0.f), 60.f },
	{ "Popflash", "LClick", Vector(2485.03f, 1311.96f, 224.09f), Vector(-0.74f, -23.81f, 0.f), 60.f }
};

std::vector<popflash_data_t> popflash_data_dust2 = {

	{ "Popflash", "LClick", Vector(150.96f, -1914.03f, -103.90f), Vector(-38.69f, -111.75f, 0.f), 60.f }
};

std::vector<popflash_data_t> popflash_data_nuke = {

	{ "Popflash", "LClick", Vector(150.96f, -1914.03f, -103.90f), Vector(-38.69f, -111.75f, 0.f), 60.f }
};

std::vector<popflash_data_t> popflash_data_overpass = {

	{ "Popflash", "LClick", Vector(150.96f, -1914.03f, -103.90f), Vector(-38.69f, -111.75f, 0.f), 60.f }
};

std::vector<popflash_data_t> popflash_data_train = {

	{ "Popflash", "LClick", Vector(150.96f, -1914.03f, -103.90f), Vector(-38.69f, -111.75f, 0.f), 60.f }
};

std::vector<popflash_data_t> popflash_data_cache = {

	{ "Popflash", "LClick", Vector(150.96f, -1914.03f, -103.90f), Vector(-38.69f, -111.75f, 0.f), 60.f }
};

std::vector<popflash_data_t> popflash_data_cobblestone = {

	{ "Popflash", "LClick", Vector(150.96f, -1914.03f, -103.90f), Vector(-38.69f, -111.75f, 0.f), 60.f }
};

```

`src/features/remove_skin_patches.cpp`:

```cpp
#include "features.h"
#include "../helpers/entities.h"

namespace features
{
	entities::player_data_t m_entities[MAX_PLAYERS];

	void remove_skin_patches()
	{
		if (!settings::chams::enemy::enabled)
			return;

		if (!g::local_player)
			return;

		if (entities::locker.try_lock())
		{
			memcpy(m_entities, entities::m_items.front().players, sizeof(m_entities));
			entities::locker.unlock();
		}

		for (auto& data : m_entities)
		{
			if (!data.player)
				continue;

			if (!data.is_player)
				continue;

			if (!data.is_alive)
				continue;

			for (int i = 0; i < MAX_PATCHES; i++)
			{
				data.player->m_vecPlayerPatchEconIndices()[i] = NULL;
			}
		}
	}
}
```

`src/features/selfnade.cpp`:

```cpp
#include "features.h"

void features::selfnade(CUserCmd* cmd)
{
	if (!g::local_player)
		return;

	if (!g::engine_client->IsInGame() || !g::engine_client->IsConnected())
		return;

	if (!g::local_player->IsAlive())
		return;

	const auto& active_wpn = g::local_player->m_hActiveWeapon();
	
	if (!active_wpn)
		return;

	if (!active_wpn->IsGrenade())
		return;

	if (active_wpn->m_flThrowStrength() >= 0.11f || active_wpn->m_flThrowStrength() <= 0.10f || cmd->viewangles.pitch > -88.0f)
		return;

	cmd->buttons &= ~IN_ATTACK;
	cmd->buttons &= ~IN_ATTACK2;
}
```

`src/features/skins.cpp`:

```cpp
#include "features.h"
#include "../settings/config.h"
#include "../settings/globals.h"
#include "../settings/options.hpp"
#include "../helpers/console.h"
#include "../valve_sdk/classids.h"

namespace skins
{
	std::map<short, item_setting> m_items = { };
	std::unordered_map<std::string, std::string> m_icon_overrides = { };

	std::map<short, weapon_info_t> info =
	{
		{ WEAPON_KNIFE,{ "models/weapons/v_knife_default_ct.mdl", "knife_default_ct" } },
		{ WEAPON_KNIFE_T,{ "models/weapons/v_knife_default_t.mdl", "knife_t" } },
		{ WEAPON_KNIFE_BAYONET,{ "models/weapons/v_knife_bayonet.mdl", "bayonet" } },
		{ WEAPON_KNIFE_FLIP,{ "models/weapons/v_knife_flip.mdl", "knife_flip" } },
		{ WEAPON_KNIFE_GUT,{ "models/weapons/v_knife_gut.mdl", "knife_gut" } },
		{ WEAPON_KNIFE_KARAMBIT,{ "models/weapons/v_knife_karam.mdl", "knife_karambit" } },
		{ WEAPON_KNIFE_M9_BAYONET,{ "models/weapons/v_knife_m9_bay.mdl", "knife_m9_bayonet" } },
		{ WEAPON_KNIFE_TACTICAL,{ "models/weapons/v_knife_tactical.mdl", "knife_tactical" } },
		{ WEAPON_KNIFE_FALCHION,{ "models/weapons/v_knife_falchion_advanced.mdl", "knife_falchion" } },
		{ WEAPON_KNIFE_SURVIVAL_BOWIE,{ "models/weapons/v_knife_survival_bowie.mdl", "knife_survival_bowie" } },
		{ WEAPON_KNIFE_BUTTERFLY,{ "models/weapons/v_knife_butterfly.mdl", "knife_butterfly" } },
		{ WEAPON_KNIFE_PUSH,{ "models/weapons/v_knife_push.mdl", "knife_push" } },
		{ WEAPON_KNIFE_URSUS,{ "models/weapons/v_knife_ursus.mdl", "knife_ursus" } },
		{ WEAPON_KNIFE_GYPSY_JACKKNIFE,{ "models/weapons/v_knife_gypsy_jackknife.mdl", "knife_gypsy_jackknife" } },
		{ WEAPON_KNIFE_STILETTO,{ "models/weapons/v_knife_stiletto.mdl", "knife_stiletto" } },
		{ WEAPON_KNIFE_WIDOWMAKER,{ "models/weapons/v_knife_widowmaker.mdl", "knife_widowmaker" } },
		{ WEAPON_KNIFE_CSS,{ "models/weapons/v_knife_css.mdl", "knife_css" } },
		{ WEAPON_KNIFE_CORD,{ "models/weapons/v_knife_cord.mdl", "knife_cord" } },
		{ WEAPON_KNIFE_CANIS,{ "models/weapons/v_knife_canis.mdl", "knife_canis" } },
		{ WEAPON_KNIFE_OUTDOOR,{ "models/weapons/v_knife_outdoor.mdl", "knife_outdoor" } },
		{ WEAPON_KNIFE_SKELETON,{ "models/weapons/v_knife_skeleton.mdl", "knife_skeleton" } },
		{ GLOVE_STUDDED_BLOODHOUND,{ "models/weapons/v_models/arms/glove_bloodhound/v_glove_bloodhound.mdl" } },
		{ GLOVE_T_SIDE,{ "models/weapons/v_models/arms/glove_fingerless/v_glove_fingerless.mdl" } },
		{ GLOVE_CT_SIDE,{ "models/weapons/v_models/arms/glove_hardknuckle/v_glove_hardknuckle.mdl" } },
		{ GLOVE_SPORTY,{ "models/weapons/v_models/arms/glove_sporty/v_glove_sporty.mdl" } },
		{ GLOVE_SLICK,{ "models/weapons/v_models/arms/glove_slick/v_glove_slick.mdl" } },
		{ GLOVE_LEATHER_WRAP,{ "models/weapons/v_models/arms/glove_handwrap_leathery/v_glove_handwrap_leathery.mdl" } },
		{ GLOVE_MOTORCYCLE,{ "models/weapons/v_models/arms/glove_motorcycle/v_glove_motorcycle.mdl" } },
		{ GLOVE_SPECIALIST,{ "models/weapons/v_models/arms/glove_specialist/v_glove_specialist.mdl" } },
		{ GLOVE_HYDRA,{ "models/weapons/v_models/arms/glove_bloodhound/v_glove_bloodhound_hydra.mdl" } },
		{ GLOVE_BROKEN_FANG,{ "models/weapons/v_models/arms/glove_bloodhound/v_glove_bloodhound_brokenfang.mdl" } }
	};

	std::vector<weapon_name_t> knife_names =
	{
		{ 0, "Default" },
		{ WEAPON_KNIFE_BAYONET, "Bayonet" },
		{ WEAPON_KNIFE_FLIP, "Flip Knife" },
		{ WEAPON_KNIFE_GUT, "Gut Knife" },
		{ WEAPON_KNIFE_KARAMBIT, "Karambit" },
		{ WEAPON_KNIFE_M9_BAYONET, "M9 Bayonet" },
		{ WEAPON_KNIFE_TACTICAL, "Huntsman Knife" },
		{ WEAPON_KNIFE_FALCHION, "Falchion Knife" },
		{ WEAPON_KNIFE_SURVIVAL_BOWIE, "Bowie Knife" },
		{ WEAPON_KNIFE_BUTTERFLY, "Butterfly Knife" },
		{ WEAPON_KNIFE_PUSH, "Shadow Daggers" },
		{ WEAPON_KNIFE_URSUS, "Ursus Knife" },
		{ WEAPON_KNIFE_GYPSY_JACKKNIFE, "Navaja Knife" },
		{ WEAPON_KNIFE_STILETTO, "Stiletto Knife" },
		{ WEAPON_KNIFE_WIDOWMAKER, "Talon Knife" },
		{ WEAPON_KNIFE_CSS, "Classic Knife" },
		{ WEAPON_KNIFE_CORD, "Paracord Knife" },
		{ WEAPON_KNIFE_CANIS, "Survival Knife" },
		{ WEAPON_KNIFE_OUTDOOR, "Nomad Knife" },
		{ WEAPON_KNIFE_SKELETON, "Skeleton Knife" }
	};

	std::vector<weapon_name_t> glove_names =
	{
		{ 0, "Default" },
		{ GLOVE_T_SIDE, "Default (Terrorists)" },
		{ GLOVE_CT_SIDE, "Default (Counter-Terrorists)" },
		{ GLOVE_STUDDED_BLOODHOUND, "Bloodhound" },
		{ GLOVE_SPORTY, "Sporty" },
		{ GLOVE_SLICK, "Slick" },
		{ GLOVE_LEATHER_WRAP, "Handwrap" },
		{ GLOVE_MOTORCYCLE, "Motorcycle" },
		{ GLOVE_SPECIALIST, "Specialist" },
		{ GLOVE_HYDRA, "Hydra" },
		{ GLOVE_BROKEN_FANG, "Broken Fang" }
	};

	const weapon_info_t* get_weapon_info(const short& defindex)
	{
		const auto entry = info.find(defindex);

		return entry == end(info) ? nullptr : &entry->second;
	}

	bool is_knife(const short& i)
	{
		return (i >= WEAPON_KNIFE_BAYONET && i < GLOVE_STUDDED_BLOODHOUND) || i == WEAPON_KNIFE_T || i == WEAPON_KNIFE;
	}

	const char* get_icon_override(const std::string& original)
	{
		return m_icon_overrides.count(original) > 0 ? m_icon_overrides.at(original).data() : nullptr;
	}

	void erase_override_if_exists_by_index(const short definition_index)
	{
		if (const auto original_item = get_weapon_info(definition_index))
		{
			if (!original_item->icon)
				return;

			const auto override_entry = m_icon_overrides.find(original_item->icon);
			if (override_entry != end(m_icon_overrides))
				m_icon_overrides.erase(override_entry);
		}
	}

	void apply_config_on_attributable_item(c_base_attributable_item* item, const item_setting config, const unsigned xuid_low)
	{
		auto _item = reinterpret_cast<c_base_combat_weapon*>(item);

		if (_item)
			_item->m_iWorldModelIndex() = -1;

		item->m_iItemIDHigh() = -1;

		item->m_iAccountID() = xuid_low;

		if (config.custom_name[0])
			strcpy_s(item->m_iCustomName(), config.custom_name);

		if (config.paint_kit_index)
			item->m_nFallbackPaintKit() = config.paint_kit_index;

		if (config.seed)
			item->m_nFallbackSeed() = config.seed;

		item->m_iEntityQuality() = is_knife(config.definition_index) ? 3 : 0;

		item->m_flFallbackWear() = config.wear;

		auto& definition_index = item->m_iItemDefinitionIndex();
		if (!config.definition_override_index || (short)config.definition_override_index == definition_index)
		{
			erase_override_if_exists_by_index(definition_index);
			return;
		}

		const auto replacement_item = get_weapon_info((short)config.definition_override_index);
		if (!replacement_item)
			return;

		const auto old_definition_index = definition_index;
		definition_index = (short)config.definition_override_index;

		// Set the weapon model index -- required for paint kits to work on replacement items after the 29/11/2016 update.
		item->m_nModelIndex() = g::mdl_info->GetModelIndex(replacement_item->model);
		item->SetModelIndex(g::mdl_info->GetModelIndex(replacement_item->model));
		item->GetClientNetworkable()->PreDataUpdate(0);

		// We didn't override 0, but some actual weapon, that we have data for
		if (!old_definition_index)
			return;

		const auto original_item = get_weapon_info(old_definition_index);
		if (original_item && original_item->icon && replacement_item->icon)
			m_icon_overrides[original_item->icon] = replacement_item->icon;
	}

	template <typename T>
	T* get_entity_from_handle(CBaseHandle h)
	{
		if (h == INVALID_EHANDLE_INDEX)
			return nullptr;

		return static_cast<T*>(g::entity_list->GetClientEntityFromHandle(h));
	}

	CreateClientClassFn get_wearable_create_fn()
	{
		for (auto clazz = g::base_client->GetAllClasses(); clazz; clazz = clazz->m_pNext)
		{
			if (clazz->m_ClassID == classids::CEconWearable)
				return clazz->m_pCreateFn;
		}
	}

	auto make_glove(int entry, int serial) -> c_base_attributable_item*
	{
		static auto create_wearable_fn = get_wearable_create_fn();

		create_wearable_fn(entry, serial);

		const auto glove = static_cast<c_base_attributable_item*>(g::entity_list->GetClientEntity(entry));
		assert(glove);

		static constexpr std::array<float, 3> new_pos = { 10000.f, 10000.f, 10000.f };

		if (patterns::set_abs_origin_addr)
		{
			const auto set_abs_origin_fn = reinterpret_cast<void(__thiscall*)(void*, const std::array<float, 3>&)>(patterns::set_abs_origin_addr);
			set_abs_origin_fn(glove, new_pos);
		}

		return glove;
	}

	bool handle_glove_config(player_info_t player_info)
	{
		const auto wearables = g::local_player->m_hMyWearables();
		const auto glove_config = m_items[g::local_player->m_iTeamNum() == team::team_ct ? GLOVE_CT_SIDE : GLOVE_T_SIDE];
		static auto glove_handle = CBaseHandle(0);

		auto glove = get_entity_from_handle<c_base_attributable_item>(wearables[0]);
		if (!glove) // There is no glove
		{
			// Try to get our last created glove
			const auto our_glove = get_entity_from_handle<c_base_attributable_item>(glove_handle);
			if (our_glove) // Our glove still exists
			{
				wearables[0] = glove_handle;
				glove = our_glove;
			}
		}

		if (!g::local_player->IsAlive())
		{
			// We are dead but we have a glove, destroy it
			if (glove)
			{
				glove->GetClientNetworkable()->SetDestroyedOnRecreateEntities();
				glove->GetClientNetworkable()->Release();
			}

			return false;
		}

		if (glove_config.definition_override_index)
		{
			// We don't have a glove, but we should
			if (!glove)
			{
				const auto entry = g::entity_list->GetHighestEntityIndex() + 1;
				const auto serial = rand() % 0x1000;

				glove = make_glove(entry, serial);

				wearables[0] = entry | serial << 16;

				// Let's store it in case we somehow lose it.
				glove_handle = wearables[0];
			}

			//Thanks, Beakers
			glove->SetModelIndex(-1);

			apply_config_on_attributable_item(glove, glove_config, player_info.xuid_low);
		}

		return true;
	}

	void handle()
	{
		if (!g::local_player)
			return;

		const auto player_info = g::local_player->GetPlayerInfo();
		if (!handle_glove_config(player_info))
			return;

		const auto weapons = g::local_player->m_hMyWeapons();
		for (size_t i = 0; weapons[i].IsValid(); i++)
		{
			auto* weapon = (c_base_attributable_item*)g::entity_list->GetClientEntityFromHandle(weapons[i]);
			if (!weapon)
				continue;

			const auto knife_index = g::local_player->m_iTeamNum() == team::team_ct ? WEAPON_KNIFE : WEAPON_KNIFE_T;

			auto& definition_index = weapon->m_iItemDefinitionIndex();
			const short defined_index = is_knife(definition_index) ? knife_index : definition_index;
			const auto& active_conf = m_items[defined_index];
			if (active_conf.enabled)
			{
				apply_config_on_attributable_item(weapon, active_conf, player_info.xuid_low);
			}
			else
				erase_override_if_exists_by_index(definition_index);
		}

		const auto view_model = get_entity_from_handle<c_base_view_model>(g::local_player->m_hViewModel());
		if (!view_model)
			return;

		const auto view_model_weapon = get_entity_from_handle<c_base_combat_weapon>(view_model->m_hWeapon());
		if (!view_model_weapon)
			return;

		const auto override_info = get_weapon_info(view_model_weapon->m_iItemDefinitionIndex());
		if (!override_info)
			return;

		const auto override_model_index = g::mdl_info->GetModelIndex(override_info->model);
		view_model->m_nModelIndex() = override_model_index;

		const auto world_model = get_entity_from_handle<c_base_weapon_world_model>(view_model_weapon->m_hWeaponWorldModel());
		if (!world_model)
			return;

		world_model->m_nModelIndex() = override_model_index + 1;
	}

	void load()
	{
		config::load("skins.json", "", false, [](Json::Value root)
		{
			m_items.clear();

			Json::Value items = root["skins"];
			if (items.isNull())
				return;

			for (auto& item : items)
			{
				auto skin_data = &m_items[item["definition_index"].asInt()];
				strcpy(skin_data->custom_name, item["custom_name"].asString().c_str());

				Option::Load(item["enabled"], skin_data->enabled);
				Option::Load(item["definition_index"], skin_data->definition_index);
				Option::Load(item["definition_override_index"], skin_data->definition_override_index);
				Option::Load(item["paint_kit_index"], skin_data->paint_kit_index);
				Option::Load(item["wear"], skin_data->wear);
				Option::Load(item["seed"], skin_data->seed);
			}
		});

		utils::force_full_update();
	}

	void save()
	{
		config::save("skins.json", "", false, []()
		{
			Json::Value config;

			Json::Value items;
			for (auto& m_item : m_items)
			{
				Json::Value item;

				item["enabled"] = m_item.second.enabled;
				item["custom_name"] = std::string(m_item.second.custom_name);
				item["definition_index"] = m_item.first;
				item["definition_override_index"] = m_item.second.definition_override_index;
				item["paint_kit_index"] = m_item.second.paint_kit_index;
				item["seed"] = m_item.second.seed;
				item["wear"] = m_item.second.wear;

				items.append(item);
			}
			config["skins"] = items;

			return config;
		});
	}
}
```

`src/features/thirdperson.cpp`:

```cpp
#include "features.h"
#include "../settings/globals.h"
#include "../render/render.h"

void features::thirdperson()
{
	if (!g::local_player)
		return;

	g::input->m_fCameraInThirdPerson = globals::binds::thirdperson::enabled && g::local_player->IsAlive() && !render::menu::is_visible();
	if (!g::input->m_fCameraInThirdPerson)
		return;

	auto& weapon = g::local_player->m_hActiveWeapon();

	if (!weapon)
		return;

	const auto weapon_type = weapon->GetWeaponData()->WeaponType;

	if (weapon_type == WEAPONTYPE_GRENADE)
		g::input->m_fCameraInThirdPerson = false;

	//if ((weapon_type == WEAPONTYPE_PISTOL || weapon_type == WEAPONTYPE_MACHINEGUN || weapon_type == WEAPONTYPE_RIFLE || weapon_type == WEAPONTYPE_SHOTGUN || weapon_type == WEAPONTYPE_SNIPER_RIFLE || weapon_type == WEAPONTYPE_SUBMACHINEGUN) && settings::misc::disable_on_weapon)
		//g::input->m_fCameraInThirdPerson = false;

	QAngle angles;
	g::engine_client->GetViewAngles(angles);

	QAngle backward(angles.pitch, angles.yaw + 180.f, angles.roll);
	backward.NormalizeClamp();

	Vector range;
	math::angle2vectors(backward, range);
	range *= 8192.f;

	const auto start = g::local_player->GetEyePos();

	CTraceFilter filter;
	filter.pSkip = g::local_player;

	Ray_t ray;
	ray.Init(start, start + range);

	trace_t tr;
	g::engine_trace->trace_ray(ray, MASK_SHOT | CONTENTS_GRATE, &filter, &tr);

	angles.roll = std::min<int>(start.DistTo(tr.endpos), 150);

	g::input->m_vecCameraOffset = angles;

	if (g::input->m_fCameraInThirdPerson)
	    g::local_player->UpdateVisibilityAllEntities();
}
```

`src/features/visuals.cpp`:

```cpp
#include "features.h"
#include "../settings/globals.h"
#include "../render/render.h"
#include "../helpers/imdraw.h"
#include "../helpers/console.h"
#include "../hooks/hooks.h"
#include "../render/render.h"
#include "../helpers/autowall.h"
#include "../helpers/entities.h"
#include "../valve_sdk/classids.h"
#include "../helpers/notifies.h"

#include <mutex>
#include <algorithm>

namespace visuals
{
	std::mutex render_mutex;
	decltype(entities::m_local) m_local;

	int x, y;
	int xx, yy;

	struct entity_data_t
	{
		std::string text;
		std::string text2;
		Vector origin;
		Color color;
		bool is_grenade;
	};

	struct grenade_info_t
	{
		std::string name;
		Color color;
	};

	RECT GetBBox(c_base_entity* ent)
	{
		RECT rect{};
		auto collideable = ent->GetCollideable();

		if (!collideable)
			return rect;

		const auto& min = collideable->OBBMins();
		const auto& max = collideable->OBBMaxs();

		const matrix3x4_t& trans = ent->m_rgflCoordinateFrame();

		Vector points[] =
		{
			Vector(min.x, min.y, min.z),
			Vector(min.x, max.y, min.z),
			Vector(max.x, max.y, min.z),
			Vector(max.x, min.y, min.z),
			Vector(max.x, max.y, max.z),
			Vector(min.x, max.y, max.z),
			Vector(min.x, min.y, max.z),
			Vector(max.x, min.y, max.z)
		};

		Vector pointsTransformed[8];

		for (int i = 0; i < 8; i++)
			math::VectorTransform(points[i], trans, pointsTransformed[i]);

		Vector screen_points[8] = {};

		for (int i = 0; i < 8; i++)
		{
			if (!math::world2screen(pointsTransformed[i], screen_points[i]))
				return rect;
		}

		auto left = screen_points[0].x;
		auto top = screen_points[0].y;
		auto right = screen_points[0].x;
		auto bottom = screen_points[0].y;

		for (int i = 1; i < 8; i++)
		{
			if (left > screen_points[i].x)
				left = screen_points[i].x;

			if (top < screen_points[i].y)
				top = screen_points[i].y;

			if (right < screen_points[i].x)
				right = screen_points[i].x;

			if (bottom > screen_points[i].y)
				bottom = screen_points[i].y;
		}

		return RECT{ (long)left, (long)top, (long)right, (long)bottom };
	}

	std::vector<entity_data_t> entities;
	std::vector<entity_data_t> saved_entities;

	bool is_enabled()
	{
		return g::engine_client->IsConnected() && g::local_player && !render::menu::is_visible();
	}

	void push_entity(c_base_entity* entity, const std::string& text, const std::string& text2, bool is_grenade, const Color& color = Color::White)
	{
		entities.emplace_back(entity_data_t{ text, text2, entity->m_vecOrigin(), color, is_grenade });
	}

	void world_grenades(c_base_player* entity)
	{
		if (!g::local_player || !g::local_player->IsAlive())
			return;

		if (g::local_player->IsFlashed())
			return;

		if (utils::is_line_goes_through_smoke(g::local_player->GetEyePos(), entity->GetRenderOrigin()))
			return;

		auto bbox = GetBBox(entity);
		auto class_id = entity->GetClientClass()->m_ClassID;

		std::string name;

		auto grenade = reinterpret_cast<c_base_combat_weapon*>(entity);

		if (!grenade)
			return;

		if (class_id == classids::CBaseCSGrenadeProjectile || class_id == classids::CMolotovProjectile || class_id == classids::CDecoyProjectile 
			|| class_id == classids::CSmokeGrenadeProjectile || class_id == classids::CSensorGrenadeProjectile) 
		{
			if (entity->m_hOwnerEntity())
				name = entity->m_hOwnerEntity().Get()->GetPlayerInfo().szName;
		}

		grenade_info_t info;
		const auto model_name = fnv::hash_runtime(g::mdl_info->GetModelName(entity->GetModel()));
		if (model_name == FNV("models/Weapons/w_eq_smokegrenade_thrown.mdl"))
			info = { "Smoke", Color::White };
		else if (model_name == FNV("models/Weapons/w_eq_flashbang_dropped.mdl"))
			info = { "Flash", Color::Yellow };
		else if (model_name == FNV("models/Weapons/w_eq_fraggrenade_dropped.mdl"))
			info = { "Grenade", Color::Red };
		else if (model_name == FNV("models/Weapons/w_eq_molotov_dropped.mdl") || model_name == FNV("models/Weapons/w_eq_incendiarygrenade_dropped.mdl"))
			info = { "Molly", Color::Orange };
		else if (model_name == FNV("models/Weapons/w_eq_decoy_dropped.mdl"))
			info = { "Decoy", Color::Green };

		if (!info.name.empty() && (grenade->m_nExplodeEffectTickBegin() < 1))
			push_entity(entity, info.name, name, true, info.color);
	}

	void rcs_cross(ImDrawList* draw_list, entities::local_data_t& local)
	{
		if (!g::local_player)
			return;

		if (!local.local)
			return;

		if (local.local->GetIndex() != g::local_player->GetIndex())
			return;

		if (!local.is_alive)
			return;

		if (local.shots_fired <= 1 && local.punch_angle.pitch >= -0.46f)
			return;
		
		static auto weapon_recoil_scale = g::cvar->find("weapon_recoil_scale");
		float scale = weapon_recoil_scale->GetFloat();

		QAngle viewangles;
		g::engine_client->GetViewAngles(viewangles);

		viewangles += local.punch_angle * scale;

		Vector forward;
		math::angle2vectors(viewangles, forward);
		forward *= 10000;

		Vector start = local.eye_pos;
		Vector end = start + forward, out;

		if (!math::world2screen(end, out))
			return;
		
		switch (settings::visuals::rcs_cross_mode)
		{
		case 0:
			draw_list->AddRectFilled(ImVec2{ out.x - 11, out.y - 1 }, ImVec2{ out.x - 4.f, out.y + 1 }, ImGui::GetColorU32(settings::visuals::recoil_color));
 			draw_list->AddRectFilled(ImVec2{ out.x - 10, out.y }, ImVec2{ out.x - 5.f, out.y + 0.5f }, ImGui::GetColorU32(settings::visuals::recoil_color));
 
 			// right
 			draw_list->AddRectFilled(ImVec2{ out.x + 4, out.y - 1 }, ImVec2{ out.x + 10.5f, out.y + 1 }, ImGui::GetColorU32(settings::visuals::recoil_color));
 			draw_list->AddRectFilled(ImVec2{ out.x + 5, out.y }, ImVec2{ out.x + 9.5f, out.y + 0.5f }, ImGui::GetColorU32(settings::visuals::recoil_color));
 
 			// top (left with swapped x/y offsets)
 			draw_list->AddRectFilled(ImVec2{ out.x - 1, out.y - 11 }, ImVec2{ out.x + 1.f, out.y - 4.f }, ImGui::GetColorU32(settings::visuals::recoil_color));
 			draw_list->AddRectFilled(ImVec2{ out.x, out.y - 10 }, ImVec2{ out.x, out.y - 5.f }, ImGui::GetColorU32(settings::visuals::recoil_color));
 
 			// bottom (right with swapped x/y offsets)
 			draw_list->AddRectFilled(ImVec2{ out.x - 1, out.y + 4 }, ImVec2{ out.x + 1.f, out.y + 10.5f }, ImGui::GetColorU32(settings::visuals::recoil_color));
 			draw_list->AddRectFilled(ImVec2{ out.x, out.y + 5 }, ImVec2{ out.x, out.y + 9.5f }, ImGui::GetColorU32(settings::visuals::recoil_color));
			break;
		case 1:
			draw_list->AddCircle(ImVec2(out.x, out.y), settings::visuals::radius, ImGui::GetColorU32(settings::visuals::recoil_color), 255);
			break;
		}
	}

	void noscope(ImDrawList* draw_list, entities::local_data_t& local, int xx, int yy)
	{
		if (!g::local_player)
			return;

		if (!local.local)
			return;

		if (local.local->GetIndex() != g::local_player->GetIndex())
			return;

		if (!local.is_alive)
			return;

		auto& active_wpn = local.active_weapon;

		if (!active_wpn)
			return;

		static const ImVec4 black = ImVec4(0.f, 0.f, 0.f, 1.0f);

		if (local.is_scoped && active_wpn->IsSniper())
		{
			draw_list->AddLine(ImVec2(0, yy), ImVec2((xx * 2), yy), ImGui::GetColorU32(black));
			draw_list->AddLine(ImVec2(xx, 0), ImVec2(xx, (yy * 2)), ImGui::GetColorU32(black));
			draw_list->AddCircle(ImVec2(xx, yy), 255, ImGui::GetColorU32(black), 255);
		}
	}

	void fetch_entities()
	{
		render_mutex.lock();

		entities.clear();

		if (!is_enabled())
		{
			render_mutex.unlock();
			return;
		}

		const auto highest_entity_index = g::entity_list->GetHighestEntityIndex();
		for (auto i = 1; i <= highest_entity_index; ++i)
		{
			auto* entity = c_base_player::GetPlayerByIndex(i);

			if (!entity || entity->IsPlayer() || entity->IsDormant() || entity == g::local_player)
				continue;

			auto* bomb = reinterpret_cast<c_base_planted_c4*>(entity);

			float dist = g::local_player->m_vecOrigin().DistTo(entity->m_vecOrigin());
	
			const auto classid = entity->GetClientClass()->m_ClassID;
			if (settings::visuals::world_grenades && (classid == classids::CBaseCSGrenadeProjectile || classid == classids::CMolotovProjectile || classid == classids::CSmokeGrenadeProjectile || classid == classids::CDecoyProjectile))
				world_grenades(entity);
			else if (settings::visuals::planted_c4 && entity->IsPlantedC4() && bomb->m_bBombTicking())
				push_entity(entity, "Bomb", "", false, Color::Green);
			else if (settings::visuals::dropped_weapons && entity->IsWeapon() && !entity->m_hOwnerEntity().IsValid() && dist <= 1000.f)
				push_entity(entity, utils::get_weapon_name(entity), "", false, Color::White);
		}

		render_mutex.unlock();
	}

	void render(ImDrawList* draw_list)
	{
		if (!is_enabled() || !render::fonts::visuals || g::engine_client->IsConsoleVisible())
			return;
		
		if (entities::local_mutex.try_lock())
		{
			m_local = entities::m_local;
			entities::local_mutex.unlock();
		}

		if (render_mutex.try_lock())
		{
			saved_entities = entities;
			render_mutex.unlock();
		}

		g::engine_client->GetScreenSize(x, y);

		xx = x / 2;
		yy = y / 2;

		ImGui::PushFont(render::fonts::visuals);
		{
			Vector origin;
			for (const auto& entity : saved_entities)
			{
				if (math::world2screen(entity.origin, origin))
				{
					const auto text_size = ImGui::CalcTextSize(entity.text.c_str());
					imdraw::outlined_text(entity.text.c_str(), ImVec2(origin.x - text_size.x / 2.f, origin.y + 7.f), utils::to_im32(entity.color));

					const auto text_size2 = ImGui::CalcTextSize(entity.text2.c_str());
					imdraw::outlined_text(entity.text2.c_str(), ImVec2(origin.x - text_size2.x / 2.f, origin.y + 15.f), utils::to_im32(Color::White));

					if (entity.is_grenade)
						draw_list->AddRect(ImVec2(origin.x + 7.f, origin.y + 7.f), ImVec2(origin.x - 7.f, origin.y - 7.f), utils::to_im32(entity.color));
				}
			}
		}
		ImGui::PopFont();
		
		if (settings::visuals::rcs_cross)
			rcs_cross(draw_list, m_local);

		if (settings::misc::noscope)
			noscope(draw_list, m_local, xx, yy);
	}
}
```

`src/helpers/autowall.cpp`:

```cpp
#include "math.h"
#include "utils.h"
#include "console.h"
#include "autowall.h"
#include "../settings/settings.h"
#include "../valve_sdk/interfaces/IEngineTrace.hpp"

#include <math.h>

#define HITGROUP_GENERIC	0
#define HITGROUP_HEAD		1
#define HITGROUP_CHEST		2
#define HITGROUP_STOMACH	3
#define HITGROUP_LEFTARM	4
#define HITGROUP_RIGHTARM	5
#define HITGROUP_LEFTLEG	6
#define HITGROUP_RIGHTLEG	7
#define HITGROUP_NECK		8
#define HITGROUP_GEAR		10

namespace autowall
{
	/*void scale_damage(const int& hit_group, const float& weapon_armor_ratio, const bool& has_helmet, const float& armor_value, float& current_damage)
	{
		switch (hit_group)
		{
		case HITGROUP_HEAD:
			current_damage *= 4.f;
			break;
		case HITGROUP_STOMACH:
			current_damage *= 1.25f;
			break;
		case HITGROUP_LEFTLEG:
		case HITGROUP_RIGHTLEG:
			current_damage *= 0.75f;
			break;
		}

		const auto armor = armor_value;
		if (armor > 0)
		{
			float ratio = 0.f;
			switch (hit_group)
			{
			case HITGROUP_HEAD:
				if (has_helmet)
				{
					ratio = (weapon_armor_ratio * 0.5) * current_damage;
					if (((current_damage - ratio) * 0.5) > armor)
					{
						ratio = current_damage - (armor * 2.0);
					}
					current_damage = ratio;
				}

				break;
			case HITGROUP_GENERIC:
			case HITGROUP_CHEST:
			case HITGROUP_STOMACH:
			case HITGROUP_LEFTARM:
			case HITGROUP_RIGHTARM:
				ratio = (weapon_armor_ratio * 0.5) * current_damage;
				if (((current_damage - ratio) * 0.5) > armor)
				{
					ratio = current_damage - (armor * 2.0);
				}
				current_damage = ratio;
				break;
			}
		}
	}*/

	inline bool IsArmored(c_base_player* player, const int iHitGroup)
	{
		bool bIsArmored = false;

		if (player->m_ArmorValue() > 0)
		{
			switch (iHitGroup)
			{
			case HITGROUP_GENERIC:
			case HITGROUP_CHEST:
			case HITGROUP_STOMACH:
			case HITGROUP_LEFTARM:
			case HITGROUP_RIGHTARM:
			case HITGROUP_NECK:
				bIsArmored = true;
				break;
			case HITGROUP_HEAD:
				if (player->m_bHasHelmet())
					bIsArmored = true;
				[[fallthrough]];
			case HITGROUP_LEFTLEG:
			case HITGROUP_RIGHTLEG:
				if (player->m_bHasHeavyArmor())
					bIsArmored = true;
				break;
			default:
				break;
			}
		}

		return bIsArmored;
	}

	void scale_damage(const int iHitGroup, c_base_player* pEntity, const float flWeaponArmorRatio, const float flWeaponHeadShotMultiplier, float& flDamage)
	{
		const bool bHeavyArmor = pEntity->m_bHasHeavyArmor();

		static auto mp_damage_scale_ct_head = g::cvar->find(xorstr_("mp_damage_scale_ct_head"));
		static auto mp_damage_scale_t_head = g::cvar->find(xorstr_("mp_damage_scale_t_head"));

		static auto mp_damage_scale_ct_body = g::cvar->find(xorstr_("mp_damage_scale_ct_body"));
		static auto mp_damage_scale_t_body = g::cvar->find(xorstr_("mp_damage_scale_t_body"));

		float flHeadDamageScale = pEntity->m_iTeamNum() == team_ct ? mp_damage_scale_ct_head->GetFloat() : pEntity->m_iTeamNum() == team_t ? mp_damage_scale_t_head->GetFloat() : 1.0f;
		const float flBodyDamageScale = pEntity->m_iTeamNum() == team_ct ? mp_damage_scale_ct_body->GetFloat() : pEntity->m_iTeamNum() == team_t ? mp_damage_scale_t_body->GetFloat() : 1.0f;

		if (bHeavyArmor)
			flHeadDamageScale *= 0.5f;

		switch (iHitGroup)
		{
		case HITGROUP_HEAD:
			flDamage *= flWeaponHeadShotMultiplier * flHeadDamageScale;
			break;
		case HITGROUP_CHEST:
		case HITGROUP_LEFTARM:
		case HITGROUP_RIGHTARM:
		case HITGROUP_NECK:
			flDamage *= flBodyDamageScale;
			break;
		case HITGROUP_STOMACH:
			flDamage *= 1.25f * flBodyDamageScale;
			break;
		case HITGROUP_LEFTLEG:
		case HITGROUP_RIGHTLEG:
			flDamage *= 0.75f * flBodyDamageScale;
			break;
		default:
			break;
		}

		if (IsArmored(pEntity, iHitGroup))
		{
			const int iArmor = pEntity->m_ArmorValue();
			float flHeavyArmorBonus = 1.0f, flArmorBonus = 0.5f, flArmorRatio = flWeaponArmorRatio * 0.5f;

			if (bHeavyArmor)
			{
				flHeavyArmorBonus = 0.25f;
				flArmorBonus = 0.33f;
				flArmorRatio *= 0.20f;
			}

			float flDamageToHealth = flDamage * flArmorRatio;
			if (const float flDamageToArmor = (flDamage - flDamageToHealth) * (flHeavyArmorBonus * flArmorBonus); flDamageToArmor > static_cast<float>(iArmor))
				flDamageToHealth = flDamage - static_cast<float>(iArmor) / flArmorBonus;

			flDamage = flDamageToHealth;
		}
	}

	/*void scale_damage(int hit_group, c_base_player* enemy, float weapon_armor_ratio, float headshot_multiplier, float& current_damage)
	{
		scale_damage(hit_group, enemy, weapon_armor_ratio, headshot_multiplier, current_damage);
		//scale_damage(hit_group, weapon_armor_ratio, enemy->m_bHasHelmet(), enemy->m_ArmorValue(), current_damage);
	}*/

	bool trace_to_exit(Vector& end, trace_t* enter_trace, Vector start, Vector dir, trace_t* exit_trace)
	{
		float distance = 0.0f;

		while (distance <= 90.0f)
		{
			distance += 4.0f;
			end = start + dir * distance;

			auto point_contents = g::engine_trace->GetPointContents(end, MASK_SHOT_HULL | CONTENTS_HITBOX, NULL);

			if (point_contents & MASK_SHOT_HULL && !(point_contents & CONTENTS_HITBOX))
				continue;

			auto new_end = end - (dir * 4.0f);

			Ray_t ray;
			ray.Init(end, new_end);
			g::engine_trace->trace_ray(ray, MASK_SHOT, 0, exit_trace);

			if (exit_trace->startsolid && exit_trace->surface.flags & SURF_HITBOX)
			{
				ray.Init(end, start);

				CTraceFilter filter;
				filter.pSkip = exit_trace->hit_entity;

				g::engine_trace->trace_ray(ray, 0x600400B, &filter, exit_trace);

				if ((exit_trace->fraction < 1.0f || exit_trace->allsolid) && !exit_trace->startsolid)
				{
					end = exit_trace->endpos;
					return true;
				}

				continue;
			}

			if (!(exit_trace->fraction < 1.0 || exit_trace->allsolid || exit_trace->startsolid) || exit_trace->startsolid)
			{
				if (exit_trace->hit_entity)
				{
					if (enter_trace->hit_entity && enter_trace->hit_entity == g::entity_list->GetClientEntity(0))
						return true;
				}

				continue;
			}

			if (exit_trace->surface.flags >> 7 & 1 && !(enter_trace->surface.flags >> 7 & 1))
				continue;

			if (exit_trace->plane.normal.Dot(dir) <= 1.0f)
			{
				auto fraction = exit_trace->fraction * 4.0f;
				end = end - dir * fraction;

				return true;
			}
		}

		return false;
	}

	bool handle_bullet_penetration(CCSWeaponInfo* weapon_data, fire_bullet_data& data)
	{
		surfacedata_t* enter_surface_data = g::physics_surface->GetSurfaceData(data.enter_trace.surface.surfaceProps);

		if (!enter_surface_data)
			return false;

		int enter_material = enter_surface_data->game.material;
		float enter_surf_penetration_mod = enter_surface_data->game.flPenetrationModifier;

		data.trace_length += data.enter_trace.fraction * data.trace_length_remaining;
		data.current_damage *= powf(weapon_data->flRangeModifier, data.trace_length * 0.002f);

		if (data.trace_length > 3000.f || enter_surf_penetration_mod < 0.1f)
			data.penetrate_count = 0;

		if (data.penetrate_count <= 0)
			return false;

		Vector dummy;
		trace_t trace_exit;

		if (!trace_to_exit(dummy, &data.enter_trace, data.enter_trace.endpos, data.direction, &trace_exit))
			return false;

		surfacedata_t* exit_surface_data = g::physics_surface->GetSurfaceData(trace_exit.surface.surfaceProps);

		if (!exit_surface_data)
			return false;

		int exit_material = exit_surface_data->game.material;

		float exit_surf_penetration_mod = *(float*)((uint8_t*)exit_surface_data + 76);
		float final_damage_modifier = 0.16f;
		float combined_penetration_modifier = 0.0f;

		if ((data.enter_trace.contents & CONTENTS_GRATE) != 0 || enter_material == 89 || enter_material == 71)
		{
			combined_penetration_modifier = 3.0f;
			final_damage_modifier = 0.05f;
		}
		else
			combined_penetration_modifier = (enter_surf_penetration_mod + exit_surf_penetration_mod) * 0.5f;

		if (enter_material == exit_material)
		{
			if (exit_material == 87 || exit_material == 85)
				combined_penetration_modifier = 3.0f;
			else if (exit_material == 76)
				combined_penetration_modifier = 2.0f;
		}

		float v34 = fmaxf(0.f, 1.0f / combined_penetration_modifier);
		float v35 = (data.current_damage * final_damage_modifier) + v34 * 3.0f * fmaxf(0.0f, (3.0f / weapon_data->flPenetration) * 1.25f);
		float thickness = (trace_exit.endpos - data.enter_trace.endpos).Length();

		thickness *= thickness;
		thickness *= v34;
		thickness /= 24.0f;

		float lost_damage = fmaxf(0.0f, v35 + thickness);

		if (lost_damage > data.current_damage)
			return false;

		if (lost_damage >= 0.0f)
			data.current_damage -= lost_damage;

		if (data.current_damage < 1.0f)
			return false;

		data.src = trace_exit.endpos;
		data.penetrate_count--;

		return true;
	}

	void trace_line(const Vector& start, const Vector& end, unsigned int mask, c_base_player* ignore, trace_t* ptr)
	{
		Ray_t ray;
		ray.Init(start, end);
		CTraceFilter filter;
		filter.pSkip = ignore;

		g::engine_trace->trace_ray(ray, mask, &filter, ptr);
	}

	bool simulate_fire_bullet(c_base_player* ignore, c_base_combat_weapon* weapon, fire_bullet_data& data)
	{
		auto weapon_data = weapon->GetWeaponData();

		if (!weapon_data)
			return false;

		Ray_t ray;
		CTraceFilter filter;
		filter.pSkip = ignore;

		data.penetrate_count = 4; 
		data.trace_length = 0.0f;
		data.current_damage = float(weapon_data->iDamage);

		while (data.current_damage >= 1.0f && data.penetrate_count)
		{
			data.trace_length_remaining = weapon_data->flRange - data.trace_length;
			Vector end = data.src + data.direction * data.trace_length_remaining;

			ray.Init(data.src, end + data.direction * 40.f);
			g::engine_trace->trace_ray(ray, MASK_SHOT, &filter, &data.enter_trace);

			auto player = (c_base_player*)data.enter_trace.hit_entity;

			if (!player)
				break;

			if (player->m_iTeamNum() == ignore->m_iTeamNum() && !settings::misc::deathmatch)
				return false;

			if (!player->IsPlayer())
				break;

			if (data.enter_trace.fraction == 1.0f)
				break;

			if (data.enter_trace.hitgroup > HITGROUP_GENERIC && data.enter_trace.hitgroup <= HITGROUP_RIGHTLEG)
			{
				data.trace_length += data.enter_trace.fraction * data.trace_length_remaining;
				data.current_damage *= powf(weapon_data->flRangeModifier, data.trace_length * 0.002f);

				scale_damage(data.enter_trace.hitgroup, player, weapon_data->flArmorRatio, weapon_data->fHeadshotMultiplier, data.current_damage);

				return true;
			}

			const auto surface_data = g::physics_surface->GetSurfaceData(data.enter_trace.surface.surfaceProps);

			if (surface_data->game.flPenetrationModifier < 0.1f)
				break;

			if (!handle_bullet_penetration(weapon_data, data))
				return false;

			data.penetrate_count--;
		}

		return false;
	}

	float get_damage(const Vector& point)
	{
		return get_damage(g::local_player, point);
	}

	float get_damage(c_base_player* player, const Vector& point)
	{
		float damage = 0.f;

		auto weapon = player->m_hActiveWeapon();
		if (!weapon || !weapon->IsWeapon())
			return -1.0f;

		fire_bullet_data data;

		data.src = player->GetEyePos();
		data.filter.pSkip = player;

		data.direction = point - data.src;
		data.direction.NormalizeInPlace();

		if (simulate_fire_bullet(player, weapon, data))
			damage = data.current_damage;

		return damage;
	}
}
```

`src/helpers/autowall.h`:

```h
#pragma once

#include "../valve_sdk/sdk.hpp"
#include "../valve_sdk/csgostructs.hpp"

namespace autowall
{
	struct fire_bullet_data
	{
		Vector src;
		trace_t enter_trace;
		Vector direction;
		CTraceFilter filter;
		float trace_length;
		float trace_length_remaining;
		float current_damage;
		int penetrate_count;
	};

	float get_damage(const Vector& point);
	float get_damage(c_base_player* player, const Vector& vecPoint);
	bool simulate_fire_bullet(c_base_player* ignore, c_base_combat_weapon* pWeapon, fire_bullet_data& data);
	bool handle_bullet_penetration(CCSWeaponInfo* weaponInfo, fire_bullet_data& data);
	bool trace_to_exit(Vector& end, trace_t* enter_trace, Vector start, Vector dir, trace_t* exit_trace);
	//void scale_damage(int hitbox, c_base_player* enemy, float weapon_armor_ratio, float& current_damage);
	void scale_damage(int hit_group, c_base_player* enemy, float weapon_armor_ratio, float headshot_multiplier, float& current_damage);
	//void scale_damage(const int iHitGroup, c_base_player* pEntity, const float flWeaponArmorRatio, const float flWeaponHeadShotMultiplier, float& flDamage);
	//void scale_damage(const int& hit_group, const float& weapon_armor_ratio, const bool& has_helmet, const float& armor_value, float& current_damage);
	void trace_line(const Vector& start, const Vector& end, unsigned int mask, c_base_player* ignore, trace_t* ptr);
}
```

`src/helpers/console.cpp`:

```cpp
#include "console.h"
#include "../security/importer.h"

#include <cstdio>
#include <Windows.h>

namespace console
{
	HANDLE out, old_out;

	void attach()
	{
		old_out = LI_FN(GetStdHandle)(STD_OUTPUT_HANDLE);

		LI_FN(AllocConsole)();
		LI_FN(AttachConsole)(LI_FN(GetCurrentProcessId)());

		out = LI_FN(GetStdHandle)(STD_OUTPUT_HANDLE);

		LI_FN(SetConsoleMode)(out, ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT);
	}

	void detach()
	{
		if (out) {
			LI_FN(FreeConsole)();

			if (old_out)
				LI_FN(SetStdHandle)(STD_OUTPUT_HANDLE, old_out);
		}
	}

	void print(Vector pos)
	{
		print("%.2f; %.2f; %.2f", pos.x, pos.y, pos.z);
	}

	void print(QAngle angles)
	{
		print("%.2f; %.2f; %.2f", angles.pitch, angles.yaw, angles.roll);
	}

	void print(const char* format, ...)
	{
//#ifdef _DEBUG
		if (!out)
			return;
		char buffer[1024 * 16];

		va_list argptr;
		va_start(argptr, format);
		vsnprintf(buffer, sizeof(buffer), format, argptr);
		va_end(argptr);

		strcat_s(buffer, sizeof(buffer), "\n");

		WriteConsoleA(out, buffer, strlen(buffer), nullptr, nullptr);
//#endif // _DEBUG
	}
}
```

`src/helpers/console.h`:

```h
#pragma once

#include "../valve_sdk/csgostructs.hpp"

namespace console
{
	void attach();
	void detach();

	void print(Vector pos);
	void print(QAngle angles);
	void print(const char* fmt, ...);
}
```

`src/helpers/entities.cpp`:

```cpp
#include "math.h"
#include "console.h"
#include "entities.h"
#include "../settings/settings.h"
#include "../settings/globals.h"

namespace entities
{
	const auto point_scale = 0.5f;

	ConVar* game_type = nullptr;
	ConVar* game_mode = nullptr;

	std::mutex locker;
	std::mutex local_mutex;

	local_data_t m_local;
	std::list<tick_data_t> m_items(24);
	player_data_t entity_data[MAX_PLAYERS];

	matrix3x4_t bone_matrix[MAXSTUDIOBONES];

	QAngle aim_angles;
	Vector top = Vector(0, 0, 1.f);
	Vector bot = Vector(0, 0, -1.f);
	Vector min, max, forward, origin, head_screen;

	Ray_t ray;
	CGameTrace tr;

	bool is_hitbox_has_multipoints(const int& hitbox)
	{
		switch (hitbox)
		{
		case HITBOX_HEAD:
		case HITBOX_NECK:
		case HITBOX_BELLY:
		case HITBOX_UPPER_CHEST:
			return true;
		default:
			return false;
		}
	}

// 	bool is_hitbox_for_visible_check(const int& hitbox)
// 	{
// 		switch (hitbox) {
// 		case HITBOX_HEAD:
// 		case HITBOX_UPPER_CHEST:
// 		case HITBOX_RIGHT_CALF:
// 		case HITBOX_LEFT_CALF:
// 		case HITBOX_RIGHT_HAND:
// 		case HITBOX_LEFT_HAND:
// 			return true;
// 		default:
// 			return false;
// 		}
// 	}

	bool is_hitbox_for_visible_check(const int& hitbox)
	{
		switch (hitbox) {
		case HITBOX_HEAD:
		case HITBOX_NECK:
		case HITBOX_PELVIS:
		case HITBOX_BELLY:
		case HITBOX_THORAX:
		case HITBOX_LOWER_CHEST:
		case HITBOX_UPPER_CHEST:
		case HITBOX_RIGHT_THIGH:
		case HITBOX_LEFT_THIGH:
		case HITBOX_RIGHT_CALF:
		case HITBOX_LEFT_CALF:
		case HITBOX_RIGHT_FOOT:
		case HITBOX_LEFT_FOOT:
		case HITBOX_RIGHT_HAND:
		case HITBOX_LEFT_HAND:
		case HITBOX_RIGHT_UPPER_ARM:
		case HITBOX_RIGHT_FOREARM:
		case HITBOX_LEFT_UPPER_ARM:
		case HITBOX_LEFT_FOREARM:
			return true;
		default:
			return false;
		}
	}

	RECT GetBBox(c_base_entity* ent, Vector* pointsTransformed)
	{
		auto collideable = ent->GetCollideable();
		if (!collideable)
			return {};

		auto& min = collideable->OBBMins();
		auto& max = collideable->OBBMaxs();

		const matrix3x4_t& trans = ent->m_rgflCoordinateFrame();

		Vector points[] =
		{
			Vector(min.x, min.y, min.z),
			Vector(min.x, max.y, min.z),
			Vector(max.x, max.y, min.z),
			Vector(max.x, min.y, min.z),
			Vector(max.x, max.y, max.z),
			Vector(min.x, max.y, max.z),
			Vector(min.x, min.y, max.z),
			Vector(max.x, min.y, max.z)
		};

		for (int i = 0; i < 8; i++)
			math::VectorTransform(points[i], trans, pointsTransformed[i]);

		return {};
	}

	float curtime(const int& tick_base)
	{
		return g::global_vars->interval_per_tick * tick_base;
	}

	float damage_for_armor(const float& damage, const int& armor_value) 
	{
		if (armor_value <= 0.f)
			return damage;

		float new_damage = damage * 0.5f;
		float armor = (damage - new_damage) * 0.5f;
		if (armor > static_cast<float>(armor_value))
		{
			armor = static_cast<float>(armor_value) * (1.f / 0.5f);
			new_damage = (damage - armor);
		}

		return new_damage;
	}

	int get_health(c_base_player* local, c_base_planted_c4* bomb)
	{
		float damage;
		float hp_remaining = local->m_iHealth();
		auto distance = local->GetEyePos().DistTo(bomb->m_vecOrigin());
		auto a = 450.7f;
		auto b = 75.68f;
		auto c = 789.2f;
		auto d = ((distance - b) / c);
		auto fl_damage = a * exp(-d * d);
		damage = damage_for_armor(fl_damage, local->m_ArmorValue());
		hp_remaining -= damage;

		return hp_remaining < 0 ? 0 : (hp_remaining + 1);
	}

	float get_bomb_time(c_base_planted_c4* bomb, const int& tick_base)
	{
		if (!bomb->m_bBombTicking())
			return 0;

		const auto bomb_time = bomb->m_flC4Blow() - curtime(tick_base);

		return bomb_time >= 0.f ? bomb_time : 0;
	}

	float get_defuse_time(c_base_planted_c4* bomb, const int& tick_base)
	{
		static float defuse_time = -1.f;

		if (!bomb->m_hBombDefuser())
			defuse_time = -1.f;
		else if (defuse_time == -1.f)
			defuse_time = curtime(tick_base) + bomb->m_flDefuseLength();

		if (defuse_time > -1.f && bomb->m_hBombDefuser())
			return defuse_time - curtime(tick_base);

		return 0.f;
	}

	c_base_planted_c4* get_bomb()
	{
		c_base_entity* entity;

		const auto max_entities = g::entity_list->GetMaxEntities();
		for (auto i = 1; i <= max_entities; ++i)
		{
			entity = c_base_entity::GetEntityByIndex(i);
			if (entity && !entity->IsDormant() && entity->IsPlantedC4())
				return reinterpret_cast<c_base_planted_c4*>(entity);
		}

		return nullptr;
	}

	void destroy()
	{
		local_mutex.lock();
		{
			m_local = local_data_t{};
		}
		local_mutex.unlock();

		locker.lock();
		{
			m_items.clear();
		}
		locker.unlock();
	}

	bool is_matchmaking()
	{
		if (!game_type)
			game_type = g::cvar->find("game_type");

		if (!game_mode)
			game_mode = g::cvar->find("game_mode");

		if (game_type->GetInt() != 0) //classic
			return false;

		if (game_mode->GetInt() != 0 && game_mode->GetInt() != 1 && game_mode->GetInt() != 2) //casual, mm, wingman
			return false;

		return true;
	}

	void fetch_hp(local_data_t& tick_data)
	{
		tick_data.is_matchmaking = is_matchmaking();
		if (!tick_data.is_matchmaking || !tick_data.local)
			return;

		tick_data.hp = tick_data.is_alive ? tick_data.health : 0;

		const auto bomb = get_bomb();

		if (!bomb)
		{
			tick_data.is_bomb_planted = false;
			tick_data.bomb_has_been_planted = false;
		}

		if (bomb && !bomb->m_bBombTicking())
		{
			tick_data.bombsite_index = bomb->m_nBombSite();
			tick_data.is_bomb_planted = bomb->IsPlantedC4();
			tick_data.bomb_has_been_planted = false;
		}

		if (bomb && bomb->m_bBombTicking())
		{
			tick_data.bomb_time = get_bomb_time(bomb, tick_data.tick_base);
			tick_data.defuse_time = get_defuse_time(bomb, tick_data.tick_base);
			tick_data.bombsite_index = bomb->m_nBombSite();
			tick_data.is_bomb_planted = bomb->IsPlantedC4();
			tick_data.bomb_has_been_planted = true;

			tick_data.hp = get_health(tick_data.local, bomb);
		}
	}

	void set_local(c_base_player* local, local_data_t& tick_data, const int& tick_base)
	{
		tick_data.local = local;
		tick_data.angles = local->m_angEyeAngles();
		tick_data.eye_pos = local->GetEyePos();
		tick_data.is_alive = local->IsAlive();
		tick_data.is_flashed = local->IsFlashed();
		tick_data.is_scoped = local->m_bIsScoped();

		tick_data.tick_base = tick_base;

		tick_data.health = local->m_iHealth();
		tick_data.armor_value = local->m_ArmorValue();
		tick_data.shots_fired = local->m_iShotsFired();

		tick_data.has_sniper = tick_data.is_alive && local->m_hActiveWeapon() && local->m_hActiveWeapon()->IsSniper();

		tick_data.world_pos = local->m_vecOrigin();
		math::world2screen(tick_data.world_pos, tick_data.local_pos);

		tick_data.hp = 0;
		tick_data.bomb_time = 0.f;
		tick_data.defuse_time = 0.f;

		tick_data.punch_angle = local->m_aimPunchAngle();
		tick_data.active_weapon = local->m_hActiveWeapon();

		if (tick_data.active_weapon)
			tick_data.weapon_data = tick_data.active_weapon->GetWeaponData();

		fetch_hp(tick_data);
	}

	void get_hitboxes(c_base_player* local, c_base_player* player, studiohdr_t* hdr, const bool& on_screen, bool& in_smoke, bool& is_visible, entities::player_data_t* entity)
	{
		GetBBox(player, entity->points);

		QAngle aim_angles;

		Vector forward;
		Vector top = Vector(0, 0, 1.f);
		Vector bot = Vector(0, 0, -1.f);

		const auto eye_pos = local->GetEyePos();
		CTraceFilterSkipTwoEntities filter(local, player);

		for (int k = HITBOX_HEAD; k < HITBOX_MAX; k++)
		{
			const auto hitbox = hdr->GetHitboxSet(0)->GetHitbox(k);
			if (!hitbox)
				continue;

			const auto bone = bone_matrix[hitbox->bone];
			const auto mod = hitbox->m_flRadius != -1.f ? hitbox->m_flRadius : 0.f;

			math::VectorTransform(hitbox->bbmax + mod, bone, max);
			math::VectorTransform(hitbox->bbmin - mod, bone, min);

			auto& pos = entity->hitboxes[k] = { mod, min, max, { (min + max) * 0.5f } };

			if (is_hitbox_has_multipoints(k))
			{
				math::vector2angles(pos.points[0] - eye_pos, aim_angles);
				aim_angles.NormalizeClamp();

				math::angle2vectors(aim_angles, forward);

				Vector right = forward.Cross(Vector(0, 0, 1));
				Vector left = Vector(-right.x, -right.y, right.z);

				const auto index = k == HITBOX_HEAD ? 2 : 1;
				const auto custom_scale = k == HITBOX_HEAD ? 0.7f : point_scale;

				if (k == HITBOX_HEAD)
					pos.points[1] = pos.points[0] + top * (mod * custom_scale);

				pos.points[index] = pos.points[0] + right * (mod * custom_scale);
				pos.points[index + 1] = pos.points[0] + left * (mod * custom_scale);
			}

			if (!on_screen || !is_hitbox_for_visible_check(k))
				continue;

			if (!is_visible)
			{
				ray.Init(eye_pos, pos.points[0]);
				g::engine_trace->trace_ray(ray, CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_DEBRIS | CONTENTS_HITBOX, &filter, &tr);

				is_visible = tr.endpos.DistTo(eye_pos) == pos.points[0].DistTo(eye_pos);
			}
			
			if (!utils::is_line_goes_through_smoke(eye_pos, pos.points[0]))
				in_smoke = false;
		}
	}

	void fetch_targets(CUserCmd* cmd)
	{
		c_base_player* local = g::local_player;
		if (!local)
		{
			destroy();
			return;
		}

 		if (!g::local_player->IsAlive() && g::local_player->m_hObserverTarget())
 		{
 			const auto observer = (c_base_player*)c_base_player::GetEntityFromHandle(g::local_player->m_hObserverTarget());
 			if (observer && observer->IsPlayer())
 				local = observer;
 		}

		local_mutex.lock();
		set_local(local, m_local, g::local_player->m_nTickBase());
		local_mutex.unlock();
		
		std::unique_ptr<tick_data_t> tick_data = std::unique_ptr<tick_data_t>(new tick_data_t());
		tick_data->tick_count = cmd->tick_count;

		const auto eye_pos = local->GetEyePos();

		bool in_smoke;
		bool is_visible;

		c_base_player* player;

		const auto max_clients = g::engine_client->GetMaxClients();
		for (int i = 1; i <= max_clients; i++)
		{
			player = c_base_player::GetPlayerByIndex(i);
			if (!player || player == local)
				continue;

			if (settings::misc::radar && !player->m_bSpotted())
				player->m_bSpotted() = true;
			else if (!settings::misc::radar && !player->m_bSpotted() && utils::is_entity_audible(player->GetIndex(), player->m_vecOrigin()) || player->HasC4())
				player->m_bSpotted() = true;

			if (!player->IsPlayer() || player->IsDormant() || player->m_iHealth() <= 0 || !player->IsAlive())
				continue;

			if (player->m_fFlags() & FL_FROZEN || player->m_bGunGameImmunity())
				continue;

			const auto is_enemy = player->m_iTeamNum() != local->m_iTeamNum();
			if (!is_enemy && !settings::misc::deathmatch)
				continue;

			auto studio_model = g::mdl_info->GetStudiomodel(player->GetModel());
			if (!studio_model)
				continue;

			std::unique_ptr<player_data_t> player_data = std::unique_ptr<player_data_t>(new player_data_t());
			player_data->index = player->GetIndex();
			player_data->world_pos = player->m_vecOrigin();
			player_data->eye_pos = player->GetEyePos();

			player_data->name = std::string(player->GetPlayerInfo().szName).substr(0, 12);

			auto& active_wpn = player->m_hActiveWeapon();

			if (!active_wpn)
				continue;

			player_data->weapon = utils::get_weapon_name(active_wpn);
			player_data->icon = active_wpn.Get()->GetGunIcon();
			player_data->wep_str_size = active_wpn.Get()->GetGunStringSize();
			player_data->is_knife_or_grenade = (active_wpn->IsKnifeOrGrenade());

			player_data->is_dormant = player->IsDormant();
			player_data->is_scoped = player->m_bIsScoped();
			player_data->is_flashed = player->IsFlashed();
			player_data->is_defusing = player->m_bIsDefusing();
			player_data->has_helmet = player->m_bHasHelmet();
			player_data->has_kevlar = player->m_ArmorValue() > 0;
			player_data->is_c4_carrier = player->HasC4();
			player_data->has_defkit = player->m_bHasDefuser();
			player_data->player = player;
			player_data->model = player->GetModel();
			player_data->is_player = player->IsPlayer();
			player_data->team_num = player->m_iTeamNum();
			player_data->hdr = g::mdl_info->GetStudiomodel(player_data->model);
			player_data->is_alive = player->IsAlive();
		
			player_data->is_enemy = true;
			player_data->m_iMoney = player->m_iAccount();
			player_data->m_iHealth = player->m_iHealth();
			player_data->m_ArmorValue = player->m_ArmorValue();
			player_data->m_flSimulationTime = player->m_flSimulationTime();
			player_data->m_iAmmo = active_wpn.Get()->m_iClip1();

			player_data->m_MaxAmmo = active_wpn.Get()->m_iPrimaryReserveAmmoCount();
			const auto tick_offset = player->m_vecVelocity() * g::global_vars->interval_per_tick;
			
			in_smoke = true;
			is_visible = false;

			const auto on_screen = math::world2screen(player->m_vecOrigin(), origin);

			const auto& abs_origin = player->GetAbsOrigin();
			
			player->SetAbsOrigin(player_data->world_pos);

			player->InvalidateBoneCache();
			
			if (!player->SetupBones(bone_matrix, MAXSTUDIOBONES, BONE_USED_BY_HITBOX, g::global_vars->curtime))
			{
				player->SetAbsOrigin(abs_origin);
				player->InvalidateBoneCache();

				continue;
			}
			
			get_hitboxes(local, player, studio_model, on_screen, in_smoke, is_visible, player_data.get());
			
			/*CTraceFilterSkipTwoEntities filter(local, player);
			for (int k = HITBOX_HEAD; k < HITBOX_MAX; k++)
			{
				const auto hitbox = studio_model->GetHitboxSet(0)->GetHitbox(k);
				if (!hitbox)
					continue;

				const auto bone = bone_matrix[hitbox->bone];
				const auto mod = hitbox->m_flRadius != -1.f ? hitbox->m_flRadius : 0.f;

				math::VectorTransform(hitbox->bbmax + mod, bone, max);
				math::VectorTransform(hitbox->bbmin - mod, bone, min);

				auto& pos = player_data->hitboxes[k] = { mod, min, max, { (min + max) * 0.5f } };

				if (is_hitbox_has_multipoints(k))
				{
					math::vector2angles(pos.points[0] - eye_pos, aim_angles);
					aim_angles.NormalizeClamp();

					math::angle2vectors(aim_angles, forward);

					Vector right = forward.Cross(Vector(0, 0, 1));
					Vector left = Vector(-right.x, -right.y, right.z);

					const auto index = k == HITBOX_HEAD ? 2 : 1;
					const auto custom_scale = k == HITBOX_HEAD ? 0.7f : point_scale;

					if (k == HITBOX_HEAD)
						pos.points[1] = pos.points[0] + top * (mod * custom_scale);

					pos.points[index] = pos.points[0] + right * (mod * custom_scale);
					pos.points[index + 1] = pos.points[0] + left * (mod * custom_scale);
				}

				if (!on_screen || !is_hitbox_for_visible_check(k))
					continue;

				if (!is_visible)
				{
					ray.Init(eye_pos, pos.points[0]);
					g::engine_trace->trace_ray(ray, CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_DEBRIS | CONTENTS_HITBOX, &filter, &tr);

					is_visible = tr.endpos.DistTo(eye_pos) == pos.points[0].DistTo(eye_pos);
				}

				if (is_visible && in_smoke && !utils::is_line_goes_through_smoke(eye_pos, pos.points[0]))
					in_smoke = false;
			}*/

			player->SetAbsOrigin(abs_origin);

			player_data->in_smoke = in_smoke;
			player_data->is_visible = is_visible;

			globals::is_visible[player->GetIndex()] = player_data->is_visible;
			globals::in_smoke[player->GetIndex()] = player_data->in_smoke;

			player_data->box = GetBBox(player, player_data->points);
			player_data->origin = player->m_vecOrigin();
			player_data->old_origin = origin;
			player_data->offset = tick_offset;
			player_data->angles = player->m_angEyeAngles();

			tick_data->players[i] = *player_data;
		}

		locker.lock();
		{
			m_items.push_front(*tick_data);
			m_items.resize(13);
		}
		locker.unlock();
	}
}
```

`src/helpers/entities.h`:

```h
#pragma once

#include "../valve_sdk/csgostructs.hpp"

#include <list>
#include <mutex>

namespace entities
{
	struct hitbox_t
	{
		float radius;

		Vector min;
		Vector max;

		Vector points[4];
	};

	struct local_data_t
	{
		Vector local_pos;
		Vector world_pos;
		Vector eye_pos;
		QAngle angles;
		QAngle punch_angle;

		CHandle<c_base_combat_weapon> active_weapon;
		CCSWeaponInfo* weapon_data;
		
		int tick_base;
		int health;
		int armor_value;
		int hp = 0;
		int damage;
		int bombsite_index;
		int shots_fired;

		float bomb_time = 0.f;
		float defuse_time = 0.f;

		bool has_sniper;
		bool is_scoped;
		bool is_defusing;
		bool is_flashed;
		bool is_alive;
		bool is_bomb_planted;
		bool bomb_has_been_planted;
		bool is_matchmaking = false;

		c_base_player* local;
	};

	struct player_data_t
	{
		int index = 0;
		int m_iHealth;
		int m_iMoney;
		int m_ArmorValue;
		int m_iAmmo;
		int m_MaxAmmo;

		std::string name;
		std::string weapon;
		std::string icon;
		
		float wep_str_size;

		bool is_shooting = false;
		Vector shot_origin;
	
		bool is_enemy;
		bool is_scoped;
		bool is_flashed;
		bool is_defusing;
		bool is_dormant;
		bool is_reloading;
		bool has_helmet;
		bool has_kevlar;
		bool is_c4_carrier;
		bool has_defkit;
		bool is_knife_or_grenade;
		bool is_player;
		bool in_smoke;
		bool is_visible;
		bool is_alive;
		
		int team_num;
		int patches[MAX_PATCHES];

		c_base_player* player;

		float m_flShotTime;
		float m_flSimulationTime;
		
		Vector points[8];

		RECT box;
		Vector eye_pos;
		Vector offset;
		Vector origin;
		Vector old_origin;
		Vector world_pos;
		QAngle angles;

		const model_t* model;
		studiohdr_t* hdr;
	
		hitbox_t hitboxes[HITBOX_MAX];
	};

	struct tick_data_t
	{
		int tick_count;

		player_data_t players[MAX_PLAYERS];
	};

	extern std::mutex locker;
	extern std::mutex local_mutex;

	extern local_data_t m_local;
	extern std::list<tick_data_t> m_items;

	void fetch_targets(CUserCmd* cmd);
}
```

`src/helpers/fnv.h`:

```h
#pragma once
#define NOMINMAX

#include <Windows.h>
#include <cstdint>
#include <stdexcept>
#include <assert.h>
#include "../security/importer.h"

namespace detail
{
	class protect_guard
	{
	public:
		protect_guard(void* base, size_t len, std::uint32_t flags)
		{
			_base = base;
			_length = len;

			if (!LI_FN(VirtualProtect).cached()(base, len, flags, PDWORD(&_old)))
				throw std::runtime_error("Failed to protect region.");
		}
		~protect_guard()
		{
			LI_FN(VirtualProtect).cached()(_base, _length, _old, PDWORD(&_old));
		}

	private:
		void* _base;
		size_t        _length;
		std::uint32_t _old;
	};

	template <typename Type, Type OffsetBasis, Type Prime>
	struct size_dependant_data
	{
		using type = Type;
		constexpr static auto k_offset_basis = OffsetBasis;
		constexpr static auto k_prime = Prime;
	};

	template <size_t Bits>
	struct size_selector;

	template <>
	struct size_selector<32>
	{
		using type = size_dependant_data<std::uint32_t, 0x811c9dc5ul, 16777619ul>;
	};

	template <>
	struct size_selector<64>
	{
		using type = size_dependant_data<std::uint64_t, 0xcbf29ce484222325ull, 1099511628211ull>;
	};

	// Implements FNV-1a hash algorithm
	template <std::size_t Size>
	class fnv_hash
	{
	private:
		using data_t = typename size_selector<Size>::type;

	public:
		using hash = typename data_t::type;

	private:
		constexpr static auto k_offset_basis = data_t::k_offset_basis;
		constexpr static auto k_prime = data_t::k_prime;

	public:
		template <std::size_t N>
		static __forceinline constexpr auto hash_constexpr(const char(&str)[N], const std::size_t size = N) -> hash
		{
			return static_cast<hash>(1ull * (size == 1
				? (k_offset_basis ^ str[0])
				: (hash_constexpr(str, size - 1) ^ str[size - 1])) * k_prime);
		}

		static auto __forceinline hash_runtime(const char* str) -> hash
		{
			auto result = k_offset_basis;
			do
			{
				result ^= *str++;
				result *= k_prime;
			} while (*(str - 1) != '\0');

			return result;
		}
	};
}

using fnv = ::detail::fnv_hash<sizeof(void*) * 8>;

#define FNV(str) (std::integral_constant<fnv::hash, fnv::hash_constexpr(str)>::value)


```

`src/helpers/imdraw.cpp`:

```cpp
#include "imdraw.h"
#include "../settings/globals.h"

namespace imdraw
{
	void apply_style()
	{
		auto& style = ImGui::GetStyle();
		auto& colors = style.Colors;

		colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
		colors[ImGuiCol_Border] = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);
		colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
		colors[ImGuiCol_TitleBg] = ImVec4(0.06f, 0.06f, 0.06f, 1.00f);
		colors[ImGuiCol_TitleText] = ImVec4(1.f, 1.f, 1.f, 1.f);
		colors[ImGuiCol_TitleBgActive] = ImVec4(0.06f, 0.06f, 0.06f, 1.00f);
		colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.06f, 0.06f, 0.06f, 1.00f);
		colors[ImGuiCol_Separator] = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
		colors[ImGuiCol_SeparatorHovered] = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);
		colors[ImGuiCol_SeparatorActive] = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);
		colors[ImGuiCol_ResizeGrip] = ImVec4(0.80f, 0.80f, 0.80f, 0.56f);
		colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
		colors[ImGuiCol_ResizeGripActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
		colors[ImGuiCol_PlotLines] = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
		colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
		colors[ImGuiCol_PlotHistogram] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
		colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);
		colors[ImGuiCol_TextSelectedBg] = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
		colors[ImGuiCol_ModalWindowDarkening] = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
		colors[ImGuiCol_DragDropTarget] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
		colors[ImGuiCol_MenuBarBg] = ImVec4(0.12f, 0.12f, 0.12f, 1.00f);
		colors[ImGuiCol_Triangle] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);

		colors[ImGuiCol_Button] = ImVec4(0.f, 0.f, 0.f, 0.f);
		colors[ImGuiCol_ButtonText] = ImVec4(0.f, 0.f, 0.f, 1.00f);

		colors[ImGuiCol_ScrollbarBg] = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);
		colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.09f, 0.09f, 0.09f, 1.0f);
		colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.8f, 0.1f, 0.1f, 1.0f);
		colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.8f, 0.1f, 0.1f, 1.0f);
		colors[ImGuiCol_MenuBarText] = ImVec4(1.f, 1.f, 1.f, 1.f);
		colors[ImGuiCol_MenuItemHovered] = ImVec4(0.8f, 0.1f, 0.1f, 1.f);
		colors[ImGuiCol_MenuItemActive] = ImVec4(0.8f, 0.1f, 0.1f, 1.f);
		colors[ImGuiCol_Header] = ImVec4(0.8f, 0.1f, 0.1f, 0.50f);
		colors[ImGuiCol_HeaderHovered] = ImVec4(0.8f, 0.1f, 0.1f, 0.40f);
		colors[ImGuiCol_HeaderActive] = ImVec4(0.8f, 0.1f, 0.1f, 0.67f);

		style.Alpha = 0.95f;
		colors[ImGuiCol_WindowBg] = ImVec4(0.12f, 0.12f, 0.12f, 0.98f);

		colors[ImGuiCol_Text] = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);
		colors[ImGuiCol_TextDisabled] = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);

		colors[ImGuiCol_ButtonText] = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);

		colors[ImGuiCol_ButtonHovered] = ImVec4(0.8f, 0.8f, 0.8f, 0.2f);
		colors[ImGuiCol_ButtonActive] = ImVec4(0.8f, 0.8f, 0.8f, 0.2f);
		colors[ImGuiCol_ButtonOutline] = ImVec4(0.8f, 0.8f, 0.8f, 0.8f);

		colors[ImGuiCol_CheckMark] = ImVec4(0.65f, 0.1f, 0.1f, 1.f);
		colors[ImGuiCol_CheckBg] = ImVec4(0.16f, 0.16f, 0.16f, 1.f);
		colors[ImGuiCol_CheckBgActive] = ImVec4(0.16f, 0.16f, 0.16f, 1.f);
		colors[ImGuiCol_CheckBgHovered] = ImVec4(0.16f, 0.16f, 0.16f, 1.f);

		colors[ImGuiCol_FrameBg] = ImVec4(0.16f, 0.16f, 0.16f, 1.00f);
		colors[ImGuiCol_FrameBgHovered] = ImVec4(0.2f, 0.2f, 0.2f, 0.40f);
		colors[ImGuiCol_FrameBgActive] = ImVec4(0.26f, 0.26f, 0.26f, 0.67f);

		colors[ImGuiCol_SliderBg] = ImVec4(0.16f, 0.16f, 0.16f, 1.f);
		colors[ImGuiCol_SliderBgActive] = ImVec4(0.2f, 0.2f, 0.2f, 1.f);
		colors[ImGuiCol_SliderBgHovered] = ImVec4(0.16f, 0.16f, 0.16f, 1.f);
		colors[ImGuiCol_SliderGrab] = ImVec4(0.26f, 0.26f, 0.26f, 0.8f);
		colors[ImGuiCol_SliderGrabActive] = ImVec4(0.26f, 0.26f, 0.26f, 1.f);

		colors[ImGuiCol_ListBoxItem] = ImVec4(0.1f, 0.1f, 0.1f, 1.f);
		colors[ImGuiCol_ListBoxItemActive] = ImVec4(0.2f, 0.2f, 0.2f, 1.f);
		colors[ImGuiCol_ListBoxItemHovered] = ImVec4(0.26f, 0.26f, 0.26f, 1.f);

		colors[ImGuiCol_PopupBg] = ImVec4(0.2f, 0.2f, 0.2f, 0.98f);
	}

	void outlined_text(const char* text, const ImVec2& pos, const ImU32& color)
	{
		outlined_text(text, pos, color, ImGui::GetColorU32(ImVec4::Black));
	}

	void outlined_text(const char* text, const ImVec2& pos, const ImU32& color, const ImU32& outlined_color)
	{
		globals::draw_list->AddText(ImVec2((pos.x) + 1.f, (pos.y) + 1.f), outlined_color, text);
		//globals::draw_list->AddText(ImVec2((pos.x) - 1.f, (pos.y) - 1.f), outlined_color, text);
		globals::draw_list->AddText(ImVec2((pos.x) + 1.f, (pos.y) - 1.f), outlined_color, text);
		//globals::draw_list->AddText(ImVec2((pos.x) - 1.f, (pos.y) + 1.f), outlined_color, text);

		globals::draw_list->AddText(pos, color, text);
	}
}
```

`src/helpers/imdraw.h`:

```h
#pragma once

#include "../imgui/imgui.h"

namespace imdraw
{
	void apply_style();

	void outlined_text(const char* text, const ImVec2& pos, const ImU32& color);
	void outlined_text(const char* text, const ImVec2& pos, const ImU32& color, const ImU32& outlined_color);
}
```

`src/helpers/input.cpp`:

```cpp
#include "input.h"
#include "console.h"

#include "../settings/globals.h"
#include "../imgui/imgui.h"
#include "../render/render.h"
#include "../valve_sdk/sdk.hpp"
#include "../security/importer.h"

HWND m_hTargetWindow;
LONG_PTR m_ulOldWndProc;
KeyState m_iKeyMap[256];

std::function<void(void)> m_Hotkeys[256];

LRESULT ImGui_ImplDX9_WndProcHandler(HWND, UINT msg, WPARAM wParam, LPARAM lParam)
{
	auto& io = ImGui::GetIO();
	switch (msg) {
	case WM_LBUTTONDOWN:
		io.MouseDown[0] = true;
		return true;
	case WM_LBUTTONUP:
		io.MouseDown[0] = false;
		return true;
	case WM_RBUTTONDOWN:
		io.MouseDown[1] = true;
		return true;
	case WM_RBUTTONUP:
		io.MouseDown[1] = false;
		return true;
	case WM_MBUTTONDOWN:
		io.MouseDown[2] = true;
		return true;
	case WM_MBUTTONUP:
		io.MouseDown[2] = false;
		return true;
	case WM_XBUTTONDOWN:
		if ((GET_KEYSTATE_WPARAM(wParam) & MK_XBUTTON1) == MK_XBUTTON1)
			io.MouseDown[3] = true;
		else if ((GET_KEYSTATE_WPARAM(wParam) & MK_XBUTTON2) == MK_XBUTTON2)
			io.MouseDown[4] = true;
		return true;
	case WM_XBUTTONUP:
		if ((GET_KEYSTATE_WPARAM(wParam) & MK_XBUTTON1) == MK_XBUTTON1)
			io.MouseDown[3] = false;
		else if ((GET_KEYSTATE_WPARAM(wParam) & MK_XBUTTON2) == MK_XBUTTON2)
			io.MouseDown[4] = false;
		return true;
	case WM_MOUSEWHEEL:
		io.MouseWheel += GET_WHEEL_DELTA_WPARAM(wParam) > 0 ? +1.0f : -1.0f;
		return true;
	case WM_MOUSEMOVE:
		io.MousePos.x = static_cast<signed short>(lParam);
		io.MousePos.y = static_cast<signed short>(lParam >> 16);
		return true;
	case WM_KEYDOWN:
		if (wParam < 512) //was 256
			io.KeysDown[wParam] = 1;
		return true;
	case WM_KEYUP:
		if (wParam < 512) //256
			io.KeysDown[wParam] = 0;
		return true;
	case WM_CHAR:
		// You can also use ToAscii()+GetKeyboardState() to retrieve characters.
		if (wParam > 0 && wParam < 0x10000)
			io.AddInputCharacter(static_cast<unsigned short>(wParam));
		return true;
	default: return 0;
	}
}

bool ProcessKeybdMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	auto key = wParam;
	auto state = KeyState::None;

	switch (uMsg) {
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		state = KeyState::Down;
		break;
	case WM_KEYUP:
	case WM_SYSKEYUP:
		state = KeyState::Up;
		break;
	default:
		return false;
	}

	if (state == KeyState::Up && m_iKeyMap[int(key)] == KeyState::Down)
	{
		m_iKeyMap[int(key)] = KeyState::Pressed;

		auto& hotkey_callback = m_Hotkeys[key];
		if (hotkey_callback)
			hotkey_callback();
	}
	else
		m_iKeyMap[int(key)] = state;

	if (m_iKeyMap[int(key)] == KeyState::Down)
		globals::binds::handle(int(key));

	return true;
}

bool ProcessMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	auto key = VK_LBUTTON;
	auto state = KeyState::None;
	switch (uMsg) {
	case WM_MBUTTONDOWN:
	case WM_MBUTTONUP:
		state = uMsg == WM_MBUTTONUP ? KeyState::Up : KeyState::Down;
		key = VK_MBUTTON;
		break;
	case WM_RBUTTONDOWN:
	case WM_RBUTTONUP:
		state = uMsg == WM_RBUTTONUP ? KeyState::Up : KeyState::Down;
		key = VK_RBUTTON;
		break;
	case WM_LBUTTONDOWN:
	case WM_LBUTTONUP:
		state = uMsg == WM_LBUTTONUP ? KeyState::Up : KeyState::Down;
		key = VK_LBUTTON;
		break;
	case WM_XBUTTONDOWN:
	case WM_XBUTTONUP:
		state = uMsg == WM_XBUTTONUP ? KeyState::Up : KeyState::Down;
		key = (HIWORD(wParam) == XBUTTON1 ? VK_XBUTTON1 : VK_XBUTTON2);
		break;
	default:
		return false;
	}

	if (state == KeyState::Up && m_iKeyMap[key] == KeyState::Down)
		m_iKeyMap[key] = KeyState::Pressed;
	else
		m_iKeyMap[key] = state;

	if (m_iKeyMap[int(key)] == KeyState::Down)
		globals::binds::handle(int(key));

	return true;
}

bool ProcessMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	switch (uMsg) {
	case WM_MBUTTONDBLCLK:
	case WM_RBUTTONDBLCLK:
	case WM_LBUTTONDBLCLK:
	case WM_XBUTTONDBLCLK:
	case WM_MBUTTONDOWN:
	case WM_RBUTTONDOWN:
	case WM_LBUTTONDOWN:
	case WM_XBUTTONDOWN:
	case WM_MBUTTONUP:
	case WM_RBUTTONUP:
	case WM_LBUTTONUP:
	case WM_XBUTTONUP:
		return ProcessMouseMessage(uMsg, wParam, lParam);
	case WM_KEYDOWN:
	case WM_KEYUP:
	case WM_SYSKEYDOWN:
	case WM_SYSKEYUP:
		return ProcessKeybdMessage(uMsg, wParam, lParam);
	default:
		return false;
	}
}

LRESULT __stdcall WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	ProcessMessage(msg, wParam, lParam);

	if (render::menu::is_visible() && ImGui_ImplDX9_WndProcHandler(hWnd, msg, wParam, lParam))
		return true;

	return CallWindowProcW(WNDPROC(m_ulOldWndProc), hWnd, msg, wParam, lParam);
}

void input_system::initialize()
{
	m_hTargetWindow = HWND(g::input_system->GetWindow());
	m_ulOldWndProc = 0;

	D3DDEVICE_CREATION_PARAMETERS params;

	if (FAILED(g::d3_device->GetCreationParameters(&params)))
		throw std::runtime_error("[InputSys] GetCreationParameters failed.");

	//m_hTargetWindow = params.hFocusWindow;
	m_ulOldWndProc = SetWindowLongPtr(m_hTargetWindow, GWLP_WNDPROC, LONG_PTR(WndProc));
}

void input_system::destroy()
{
	if (m_ulOldWndProc)
		SetWindowLongPtr(m_hTargetWindow, GWLP_WNDPROC, m_ulOldWndProc);

	m_ulOldWndProc = 0;
}

HWND input_system::get_main_window()
{
	return m_hTargetWindow;
}

KeyState input_system::get_key_state(std::uint32_t vk)
{
	return m_iKeyMap[vk];
}

bool input_system::is_key_down(std::uint32_t vk)
{
	return m_iKeyMap[vk] == KeyState::Down;
}

bool input_system::was_key_pressed(std::uint32_t vk)
{
	if (m_iKeyMap[vk] == KeyState::Pressed) {
		m_iKeyMap[vk] = KeyState::Up;
		return true;
	}
	return false;
}

void input_system::register_hotkey(std::uint32_t vk, std::function<void(void)> f)
{
	m_Hotkeys[vk] = f;
}

void input_system::remove_hotkey(std::uint32_t vk)
{
	m_Hotkeys[vk] = nullptr;
}
```

`src/helpers/input.h`:

```h
#pragma once

#define NOMINMAX
#include <Windows.h>
#include <cstdint>
#include <functional>

enum class KeyState
{
	None = 1,
	Down,
	Up,
	Pressed
};

DEFINE_ENUM_FLAG_OPERATORS(KeyState);

namespace input_system
{
	void initialize();
	void destroy();

	HWND get_main_window();
	KeyState get_key_state(uint32_t vk);

	bool is_key_down(uint32_t vk);
	bool was_key_pressed(uint32_t vk);

	void register_hotkey(uint32_t vk, std::function<void(void)> f);
	void remove_hotkey(uint32_t vk);
}
```

`src/helpers/math.cpp`:

```cpp
#include "math.h"
#include "utils.h"
#include "console.h"
#include "../settings/globals.h"
#include "../valve_sdk/csgostructs.hpp"
#include "../features/features.h"

#include <d3dx9.h>
#include <D3dx9math.h>
#include <algorithm>
#include <cmath>

void math::correct_movement(CUserCmd* cmd, const QAngle& old_angles)
{
	correct_movement(cmd, old_angles, cmd->forwardmove, cmd->sidemove);
}

void math::correct_movement(CUserCmd* cmd, const QAngle& old_angles, const float& old_forward, const float& old_sidemove)
{
	// side/forward move correction
	float f1, f2, deltaView;
	if (old_angles.yaw < 0.f)
		f1 = 360.0f + old_angles.yaw;
	else
		f1 = old_angles.yaw;

	if (cmd->viewangles.yaw < 0.0f)
		f2 = 360.0f + cmd->viewangles.yaw;
	else
		f2 = cmd->viewangles.yaw;

	if (f2 < f1)
		deltaView = abs(f2 - f1);
	else
		deltaView = 360.0f - abs(f1 - f2);

	deltaView = 360.0f - deltaView;

	cmd->forwardmove = cos(DEG2RAD(deltaView)) * old_forward + cos(DEG2RAD(deltaView + 90.f)) * old_sidemove;
	cmd->sidemove = sin(DEG2RAD(deltaView)) * old_forward + sin(DEG2RAD(deltaView + 90.f)) * old_sidemove;
}

void math::VectorTransform(const Vector& in1, const matrix3x4_t& in2, Vector& out)
{
	out[0] = in1.Dot(in2[0]) + in2[0][3];
	out[1] = in1.Dot(in2[1]) + in2[1][3];
	out[2] = in1.Dot(in2[2]) + in2[2][3];
}

void math::angle2vectors(const QAngle& angles, Vector& forward)
{
	float	sp, sy, cp, cy;

	DirectX::XMScalarSinCos(&sp, &cp, DEG2RAD(angles[0]));
	DirectX::XMScalarSinCos(&sy, &cy, DEG2RAD(angles[1]));

	forward.x = cp * cy;
	forward.y = cp * sy;
	forward.z = -sp;
}

void math::AngleVectors(const float& angles, Vector& forward)
{
	float	sp, sy, cp, cy;

	DirectX::XMScalarSinCos(&sp, &cp, DEG2RAD(angles));
	DirectX::XMScalarSinCos(&sy, &cy, DEG2RAD(angles));

	forward.x = cp * cy;
	forward.y = cp * sy;
	forward.z = -sp;
}

void math::angle2vectors(const QAngle& angles, Vector& forward, Vector& right, Vector& up)
{
	float sr, sp, sy, cr, cp, cy;

	DirectX::XMScalarSinCos(&sp, &cp, DEG2RAD(angles[0]));
	DirectX::XMScalarSinCos(&sy, &cy, DEG2RAD(angles[1]));
	DirectX::XMScalarSinCos(&sr, &cr, DEG2RAD(angles[2]));

	forward.x = (cp * cy);
	forward.y = (cp * sy);
	forward.z = (-sp);
	right.x = (-1 * sr * sp * cy + -1 * cr * -sy);
	right.y = (-1 * sr * sp * sy + -1 * cr * cy);
	right.z = (-1 * sr * cp);
	up.x = (cr * sp * cy + -sr * -sy);
	up.y = (cr * sp * sy + -sr * cy);
	up.z = (cr * cp);
}

void math::vector2angles(const Vector& forward, QAngle& angles)
{
	float yaw, pitch;

	if (forward[1] == 0 && forward[0] == 0) {
		yaw = 0;
		if (forward[2] > 0)
			pitch = 270;
		else
			pitch = 90;
	}
	else {
		yaw = (atan2(forward[1], forward[0]) * 180 / DirectX::XM_PI);
		if (yaw < 0)
			yaw += 360;

		const auto tmp = sqrt(forward[0] * forward[0] + forward[1] * forward[1]);
		pitch = (atan2(-forward[2], tmp) * 180 / DirectX::XM_PI);
		if (pitch < 0)
			pitch += 360;
	}

	angles[0] = pitch;
	angles[1] = yaw;
	angles[2] = 0;
}

Vector math::CrossProduct(const Vector& a, const Vector& b)
{
	return Vector(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}

void math::vector2angles(const Vector& forward, Vector& up, QAngle& angles)
{
	Vector left = CrossProduct(up, forward);
	left.NormalizeInPlace();

	float forwardDist = forward.Length2D();

	if (forwardDist > 0.001f)
	{
		angles.pitch = atan2f(-forward.z, forwardDist) * 180 / M_PI;
		angles.yaw = atan2f(forward.y, forward.x) * 180 / M_PI;

		float upZ = (left.y * forward.x) - (left.x * forward.y);
		angles.roll = atan2f(left.z, upZ) * 180 / M_PI;
	}
	else
	{
		angles.pitch = atan2f(-forward.z, forwardDist) * 180 / M_PI;
		angles.yaw = atan2f(-left.x, left.y) * 180 / M_PI;
		angles.roll = 0;
	}
}

bool math::screen_transform(const Vector& in, Vector& out)
{
	auto exception_filter = [](int code, PEXCEPTION_POINTERS ex)
	{
		return EXCEPTION_EXECUTE_HANDLER;
	};

	__try
	{
		auto result = *(PDWORD)(globals::view_matrix::offset) + 988;
		if (!result)
		{
			out.x *= 100000;
			out.y *= 100000;
			return false;
		}

		const auto& world_matrix = *(_D3DMATRIX*)result;

		const auto w = world_matrix.m[3][0] * in.x + world_matrix.m[3][1] * in.y + world_matrix.m[3][2] * in.z + world_matrix.m[3][3];
		if (w < 0.001f)
		{
			out.x *= 100000;
			out.y *= 100000;
			return false;
		}

		out.x = world_matrix.m[0][0] * in.x + world_matrix.m[0][1] * in.y + world_matrix.m[0][2] * in.z + world_matrix.m[0][3];
		out.y = world_matrix.m[1][0] * in.x + world_matrix.m[1][1] * in.y + world_matrix.m[1][2] * in.z + world_matrix.m[1][3];
		out.z = 0.0f;

		out.x /= w;
		out.y /= w;

		return true;
	}
	__except (exception_filter(GetExceptionCode(), GetExceptionInformation()))
	{
		out.x *= 100000;
		out.y *= 100000;
		return false;
	}
}

bool math::world2screen(const Vector& in, Vector& out)
{
	if (!globals::view_matrix::has_offset)
		return false;

	if (!screen_transform(in, out))
		return false;

	int w, h;
	g::engine_client->GetScreenSize(w, h);

	out.x = (w / 2.0f) + (out.x * w) / 2.0f;
	out.y = (h / 2.0f) - (out.y * h) / 2.0f;

	return true;
}

float math::DotProduct(const float* v1, const float* v2)
{
	return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
}

void math::VectorRotate(const float* in1, const matrix3x4_t& in2, float* out)
{
	out[0] = DotProduct(in1, in2[0]);
	out[1] = DotProduct(in1, in2[1]);
	out[2] = DotProduct(in1, in2[2]);
}

void math::VectorRotate(const Vector& in1, const matrix3x4_t& in2, Vector& out)
{
	VectorRotate(&in1.x, in2, &out.x);
}

void math::VectorRotate(const Vector& in1, const QAngle& in2, Vector& out)
{
	matrix3x4_t matRotate;
	AngleMatrix(in2, matRotate);
	VectorRotate(in1, matRotate, out);
}

void math::MatrixCopy(const matrix3x4_t& source, matrix3x4_t& target)
{
	for (int i = 0; i < 3; i++) {
		for (int j = 0; j < 4; j++) {
			target[i][j] = source[i][j];
		}
	}
}

void math::MatrixMultiply(matrix3x4_t& in1, const matrix3x4_t& in2)
{
	matrix3x4_t out;
	if (&in1 == &out)
	{
		matrix3x4_t in1b;
		MatrixCopy(in1, in1b);
		MatrixMultiply(in1b, in2);
		return;
	}
	if (&in2 == &out)
	{
		matrix3x4_t in2b;
		MatrixCopy(in2, in2b);
		MatrixMultiply(in1, in2b);
		return;
	}
	out[0][0] = in1[0][0] * in2[0][0] + in1[0][1] * in2[1][0] +
		in1[0][2] * in2[2][0];
	out[0][1] = in1[0][0] * in2[0][1] + in1[0][1] * in2[1][1] +
		in1[0][2] * in2[2][1];
	out[0][2] = in1[0][0] * in2[0][2] + in1[0][1] * in2[1][2] +
		in1[0][2] * in2[2][2];
	out[0][3] = in1[0][0] * in2[0][3] + in1[0][1] * in2[1][3] +
		in1[0][2] * in2[2][3] + in1[0][3];
	out[1][0] = in1[1][0] * in2[0][0] + in1[1][1] * in2[1][0] +
		in1[1][2] * in2[2][0];
	out[1][1] = in1[1][0] * in2[0][1] + in1[1][1] * in2[1][1] +
		in1[1][2] * in2[2][1];
	out[1][2] = in1[1][0] * in2[0][2] + in1[1][1] * in2[1][2] +
		in1[1][2] * in2[2][2];
	out[1][3] = in1[1][0] * in2[0][3] + in1[1][1] * in2[1][3] +
		in1[1][2] * in2[2][3] + in1[1][3];
	out[2][0] = in1[2][0] * in2[0][0] + in1[2][1] * in2[1][0] +
		in1[2][2] * in2[2][0];
	out[2][1] = in1[2][0] * in2[0][1] + in1[2][1] * in2[1][1] +
		in1[2][2] * in2[2][1];
	out[2][2] = in1[2][0] * in2[0][2] + in1[2][1] * in2[1][2] +
		in1[2][2] * in2[2][2];
	out[2][3] = in1[2][0] * in2[0][3] + in1[2][1] * in2[1][3] +
		in1[2][2] * in2[2][3] + in1[2][3];

	in1 = out;
}

void inline math::SinCos(float radians, float* sine, float* cosine)
{
	_asm
	{
		fld DWORD PTR[radians]
		fsincos

		mov edx, DWORD PTR[cosine]
		mov eax, DWORD PTR[sine]

		fstp DWORD PTR[edx]
		fstp DWORD PTR[eax]
	}
}

void math::MatrixSetColumn(const Vector& in, int column, matrix3x4_t& out)
{
	out[0][column] = in.x;
	out[1][column] = in.y;
	out[2][column] = in.z;
}

void math::AngleMatrix(const QAngle& angles, matrix3x4_t& matrix)
{
	float sr, sp, sy, cr, cp, cy;

	SinCos(DEG2RAD(angles[1]), &sy, &cy);
	SinCos(DEG2RAD(angles[0]), &sp, &cp);
	SinCos(DEG2RAD(angles[2]), &sr, &cr);

	// matrix = (YAW * PITCH) * ROLL
	matrix[0][0] = cp * cy;
	matrix[1][0] = cp * sy;
	matrix[2][0] = -sp;

	float crcy = cr * cy;
	float crsy = cr * sy;
	float srcy = sr * cy;
	float srsy = sr * sy;
	matrix[0][1] = sp * srcy - crsy;
	matrix[1][1] = sp * srsy + crcy;
	matrix[2][1] = sr * cp;

	matrix[0][2] = (sp * crcy + srsy);
	matrix[1][2] = (sp * crsy - srcy);
	matrix[2][2] = cr * cp;

	matrix[0][3] = 0.0f;
	matrix[1][3] = 0.0f;
	matrix[2][3] = 0.0f;
}

void math::AngleMatrix(const QAngle& angles, const Vector& position, matrix3x4_t& matrix)
{
	AngleMatrix(angles, matrix);
	MatrixSetColumn(position, 3, matrix);
}

float math::GetRealDistanceFOV(const float& distance, const QAngle& current, const QAngle& aim)
{
	QAngle delta = aim - current;
	delta.NormalizeClamp();
	
	Vector v_aim, v_current;

	math::angle2vectors(aim, v_aim);
	math::angle2vectors(current, v_current);

	float fov = v_current.DistTo(v_aim) * distance;

	fov /= 7.2f; //Scaling fov to match the slider

	if (settings::misc::print_fov)
		g::hud_chat->ChatPrintf(0, 0, std::format("fov: {:.1f}, distance: {:.1f}", fov, distance).c_str());

	return fov;
}

float math::GetFovToPlayer(const QAngle& current_angles, const QAngle& aim_angles)
{
	QAngle delta = aim_angles - current_angles;
	delta.NormalizeClamp();

	return std::hypotf(delta.pitch, delta.yaw);;
}

void math::angle2vectors(const QAngle& angles, Vector* forward, Vector* right, Vector* up)
{
	float sr, sp, sy, cr, cp, cy;

	sp = static_cast<float>(sin(double(angles.pitch) * PIRAD));
	cp = static_cast<float>(cos(double(angles.pitch) * PIRAD));
	sy = static_cast<float>(sin(double(angles.yaw) * PIRAD));
	cy = static_cast<float>(cos(double(angles.yaw) * PIRAD));
	sr = static_cast<float>(sin(double(angles.roll) * PIRAD));
	cr = static_cast<float>(cos(double(angles.roll) * PIRAD));

	if (forward)
	{
		forward->x = cp * cy;
		forward->y = cp * sy;
		forward->z = -sp;
	}

	if (right)
	{
		right->x = (-1 * sr * sp * cy + -1 * cr * -sy);
		right->y = (-1 * sr * sp * sy + -1 * cr * cy);
		right->z = -1 * sr * cp;
	}

	if (up)
	{
		up->x = (cr * sp * cy + -sr * -sy);
		up->y = (cr * sp * sy + -sr * cy);
		up->z = cr * cp;
	}
}

void math::smooth(const float& amount, const QAngle& current_angles, const QAngle& aim_angles, QAngle& angles, const bool& humanize)
{
	angles = aim_angles;
	angles.NormalizeClamp();

	auto corrected_amount = amount;
	auto tickrate = 1.0f / g::global_vars->interval_per_tick;

	corrected_amount = tickrate * amount / 64.f;

	if (corrected_amount < 1.1f)
		return;

	Vector aim_vector;
	angle2vectors(aim_angles, aim_vector);

	Vector current_vector;
	angle2vectors(current_angles, current_vector);

	auto delta = aim_vector - current_vector;
	if (humanize)
	{
		delta.x += utils::random(-0.02f, 0.02f);
		delta.y += utils::random(-0.01f, 0.01f);		
	}

	const auto smoothed = current_vector + delta / corrected_amount;

	vector2angles(smoothed, angles);
	angles.NormalizeClamp();
}

```

`src/helpers/math.h`:

```h
#pragma once

#include "../valve_sdk/sdk.hpp"

#include <DirectXMath.h>

#define CHECK_VALID( _v) 0

#define RAD2DEG(x) DirectX::XMConvertToDegrees(x)
#define DEG2RAD(x) DirectX::XMConvertToRadians(x)

#define PIRAD 0.01745329251f
#define PI 3.14159265358979323846f

#define _USE_MATH_DEFINES
#include <math.h>

namespace math
{
	void VectorTransform(const Vector& in1, const matrix3x4_t& in2, Vector& out);
	void angle2vectors(const QAngle& angles, Vector& forward);
	void AngleVectors(const float& angles, Vector& forward);
	void angle2vectors(const QAngle& angles, Vector& forward, Vector& right, Vector& up);
	Vector CrossProduct(const Vector& a, const Vector& b);
	void vector2angles(const Vector& forward, QAngle& angles);
	void vector2angles(const Vector& forward, Vector& up, QAngle& angles);
	bool screen_transform(const Vector& in, Vector& out);
	bool world2screen(const Vector& in, Vector& out);
	void correct_movement(CUserCmd* cmd, const QAngle& old_angles);
	void correct_movement(CUserCmd* cmd, const QAngle& old_angles, const float& old_forward, const float& old_sidemove);
	float DotProduct(const float* v1, const float* v2);
	void VectorRotate(const float* in1, const matrix3x4_t& in2, float* out);
	void VectorRotate(const Vector& in1, const matrix3x4_t& in2, Vector& out);
	void VectorRotate(const Vector& in1, const QAngle& in2, Vector& out);
	void MatrixCopy(const matrix3x4_t& source, matrix3x4_t& target);
	void MatrixMultiply(matrix3x4_t& in1, const matrix3x4_t& in2);
	void AngleMatrix(const QAngle& angles, const Vector& position, matrix3x4_t& matrix);
	void AngleMatrix(const QAngle& angles, matrix3x4_t& matrix);
	void MatrixSetColumn(const Vector& in, int column, matrix3x4_t& out);
	void inline SinCos(float radians, float* sine, float* cosine);
	float GetRealDistanceFOV(const float& distance, const QAngle& current, const QAngle& aim);
	float GetFovToPlayer(const QAngle& viewAngle, const QAngle& aimAngle);
	void angle2vectors(const QAngle& angles, Vector* forward, Vector* right, Vector* up);
	void smooth(const float& amount, const QAngle& current_angles, const QAngle& aim_angles, QAngle& angle, const bool& humanize = false);
}
```

`src/helpers/notifies.cpp`:

```cpp
#include "notifies.h"
#include "../settings/globals.h"
#include "../render/render.h"

namespace notifies
{
	std::vector<notify_data_t> items;

	int in = 200;
	int out = 500;
	int duration = 3000;

	ImVec2 block_pos;
	ImVec2 debug_pos;
	ImVec2 notify_size = ImVec2(200.f, 0.f);

	const ImVec4 text_color = ImVec4(0.1f, 0.1f, 0.1f, 1.f);
	const ImVec4 background_color = ImVec4(0.8f, 0.8f, 0.8f, 1.f);

	const ImVec4 info = ImVec4(0.1f, 0.25f, 0.45f, 1.f);
	const ImVec4 success = ImVec4(0.1f, 0.4f, 0.2f, 1.f);
	const ImVec4 danger = ImVec4(0.45f, 0.04f, 0.15f, 1.f);
	const ImVec4 warning = ImVec4(0.85f, 0.6f, 0.05f, 1.f);

	void push(const std::string& message, notify_state_s state)
	{
		duration = state == warning_state ? 1200 : 3000;
		const auto end_time = (state == debug_state ? 2500 : 0) + GetTickCount64() + duration;

		items.emplace_back(notify_data_t{ message, state, end_time });
	}

	ImU32 alpha_modulate(const ImVec4& color, const float& alpha = 1.f)
	{
		return ImGui::GetColorU32(ImVec4(color.x, color.y, color.z, alpha));
	}

	void show_block(ImDrawList* draw_list, const notify_data_t& notify)
	{
		float alpha = 1.f;
		if (notify.end_time - out <= GetTickCount64())
		{
			const auto delta = std::clamp<float>(notify.end_time - GetTickCount64(), 0.f, out);
			alpha = std::clamp<float>(delta / out, 0.f, 1.f);
		}

		if (alpha == 0)
			return;

		const auto notify_end_pos = ImVec2(block_pos.x + notify_size.x, block_pos.y + notify_size.y);
		draw_list->AddRectFilled(block_pos, notify_end_pos, alpha_modulate(background_color, alpha), 2.f);

		static ImVec4 color;

		color = info;
		if (notify.state == notify_state_s::danger_state)
			color = danger;
		else if (notify.state == notify_state_s::success_state)
			color = success;
		else if (notify.state == notify_state_s::warning_state)
			color = warning;

		draw_list->AddRectFilled(block_pos, ImVec2(block_pos.x + 5.f, block_pos.y + notify_size.y), alpha_modulate(color, alpha), 1.f);

		const auto text_size = ImGui::CalcTextSize(notify.message.c_str());
		const auto text_pos = ImVec2(block_pos.x + 5.f + 10.f, block_pos.y + notify_size.y / 2.f - text_size.y / 2.f);

		draw_list->AddText(text_pos, alpha_modulate(text_color, alpha), text_size.x > notify_size.x + 10.f ? notify.message.substr(0, 25).c_str() : notify.message.c_str());

		block_pos.y -= notify_size.y + 10.f;
	}

	void show_text(ImDrawList* draw_list, const notify_data_t& data)
	{
		ImGui::PushFont(render::fonts::notifies);
		draw_list->AddText(debug_pos, ImGui::GetColorU32(ImVec4::White), data.message.c_str());
		ImGui::PopFont();

		debug_pos.y += 12.f;
	}

	void handle(ImDrawList* draw_list)
	{
		if (items.empty())
			return;

		if (notify_size.y == 0.f)
			notify_size.y = ImGui::CalcTextSize("W").y + 14.f;

		const auto screen_size = ImGui::GetIO().DisplaySize;

		debug_pos = ImVec2(2.f, 2.f);
		block_pos = ImVec2(screen_size.x - notify_size.x - 20.f, screen_size.y - notify_size.y - 20.f);

		ImGui::PushFont(render::fonts::configs_list);

		for (auto k = items.size(); k > 0; k--)
		{
			const auto& notify = items[k - 1];
			if (notify.end_time < GetTickCount64())
				continue;

			if (notify.state == notify_state_s::debug_state)
				show_text(draw_list, notify);
			else
				show_block(draw_list, notify);
		}

		ImGui::PopFont();
	}
}
```

`src/helpers/notifies.h`:

```h
#pragma once
#include <vector>
#include <string>
#include "../imgui/imgui.h"

enum notify_state_s : int
{
	info_state = 0,
	success_state,
	warning_state,
	danger_state,
	debug_state
};

struct notify_data_t
{
	std::string message;
	notify_state_s state;
	unsigned __int64 end_time;
};

namespace notifies
{
	void handle(ImDrawList* draw_list);
	void push(const std::string& message, notify_state_s state = notify_state_s::info_state);
}
```

`src/helpers/utils.cpp`:

```cpp
#include "utils.h"
#include "math.h"
#define NOMINMAX
#include <Windows.h>
#include <string>
#include <vector>
#include <chrono>
#include <cmath>

#include "input.h"
#include "console.h"
#include "../settings/globals.h"
#include "../security/importer.h"
#include "../features/features.h"
#include "../imgui/imgui_internal.h"
#include "../valve_sdk/csgostructs.hpp"
#include "..//render/render.h"

namespace utils
{
	void render_dot(ImDrawList* draw_list, const Vector& origin, const QAngle& angles, const ImU32& color)
	{
		auto rotate_points = [](Vector* points, float rotation)->void
		{
			const auto points_center = (points[0] + points[1] + points[2]) / 3;
			for (int k = 0; k < 3; k++)
			{
				auto& point = points[k];
				point -= points_center;

				const auto temp_x = point.x;
				const auto temp_y = point.y;

				const auto theta = DEG2RAD(rotation);
				const auto c = cos(theta);
				const auto s = sin(theta);

				point.x = temp_x * c - temp_y * s;
				point.y = temp_x * s + temp_y * c;

				point += points_center;
			}
		};


		const auto display_size = ImGui::GetIO().DisplaySize;
		const auto screen_center = Vector(display_size.x * .5f, display_size.y * .5f);

		QAngle aim_angles;
		math::vector2angles(origin - g::local_player->m_vecOrigin(), aim_angles);

		const auto angle_yaw_rad = DEG2RAD(angles.yaw - aim_angles.yaw - 90);

		const auto size = 10;
		const auto radius = 45;

		const auto new_point_x = screen_center.x + ((((display_size.x - (size * 3)) * .5f) * (radius / 100.0f)) * cos(angle_yaw_rad)) + (int)(6.0f * (((float)size - 4.f) / 16.0f));
		const auto new_point_y = screen_center.y + ((((display_size.y - (size * 3)) * .5f) * (radius / 100.0f)) * sin(angle_yaw_rad));

		Vector points[3] =
		{
			Vector(new_point_x - size, new_point_y - size),
			Vector(new_point_x + size, new_point_y),
			Vector(new_point_x - size, new_point_y + size)
		};

		rotate_points(points, angles.yaw - aim_angles.yaw - 90.f);

		draw_list->AddTriangleFilled({ points[0].x + 1.f, points[0].y + 1.f }, { points[1].x + 1.f, points[1].y + 1.f }, { points[2].x + 1.f, points[2].y + 1.f }, IM_COL32_BLACK);
		draw_list->AddTriangleFilled({ points[0].x, points[0].y }, { points[1].x, points[1].y }, { points[2].x, points[2].y }, color);
	}

	RECT get_box(const Vector* transformed_points)
	{
		static Vector screen_points[8];
		for (int i = 0; i < 8; i++)
		{
			if (!math::world2screen(transformed_points[i], screen_points[i]))
				return {};
		}

		auto top = screen_points[0].y;
		auto left = screen_points[0].x;
		auto right = screen_points[0].x;
		auto bottom = screen_points[0].y;

		for (int i = 1; i < 8; i++)
		{
			if (left > screen_points[i].x)
				left = screen_points[i].x;
			if (top > screen_points[i].y)
				top = screen_points[i].y;
			if (right < screen_points[i].x)
				right = screen_points[i].x;
			if (bottom < screen_points[i].y)
				bottom = screen_points[i].y;
		}

		return RECT{ (long)left, (long)top, (long)right, (long)bottom };
	}

	void scale_color_to_health(float fraction, float& outR, float& outG, float& outB)
	{
		constexpr auto greenHue = 1.0f / 3.0f;
		constexpr auto redHue = 0.0f;
		ImGui::ColorConvertHSVtoRGB(std::lerp(redHue, greenHue, fraction), 1.0f, 1.0f, outR, outG, outB);
	}

	float get_interpolation_compensation()
	{
		static const auto cl_interp = g::cvar->find("cl_interp");
		static const auto max_ud_rate = g::cvar->find("sv_maxupdaterate");
		static const auto cl_interp_ratio = g::cvar->find("cl_interp_ratio");
		static const auto c_min_ratio = g::cvar->find("sv_client_min_interp_ratio");
		static const auto c_max_ratio = g::cvar->find("sv_client_max_interp_ratio");

		float ratio = cl_interp_ratio->GetFloat();
		if (ratio == 0)
			ratio = 1.0f;

		if (c_min_ratio && c_max_ratio && c_min_ratio->GetFloat() != 1)
			ratio = std::clamp(ratio, c_min_ratio->GetFloat(), c_max_ratio->GetFloat());

		const auto ud_rate = max_ud_rate->GetInt();

		return std::max(cl_interp->GetFloat(), (ratio / ud_rate));
	}

	Vector CalcHelpPos(Vector target)
	{
		if (!g::local_player)
			return Vector{};

		QAngle viewangles;

		g::engine_client->GetViewAngles(viewangles);

		float range = 5.f;

		float r_1, r_2;
		float x_1, y_1;

		Vector eye_pos = g::local_player->GetEyePos();

		r_1 = -(target.y - eye_pos.y);
		r_2 =   target.x - eye_pos.x;

		float yaw = (viewangles.yaw - 90.0f) * (float)(M_PI / 180.0F);

		x_1 = (r_2 * std::cosf(yaw) - r_1 * std::sinf(yaw)) / 20.f;
		y_1 = (r_2 * std::sinf(yaw) + r_1 * std::cosf(yaw)) / 20.f;

		x_1 *= range;
		y_1 *= range;

		return Vector(x_1, y_1, 0);
	}

	Vector CalcDir(const Vector& vAngles)
	{
		Vector vForward;
		float  sp, sy, cp, cy;

		sy = sin(DEG2RAD(vAngles[1]));
		cy = cos(DEG2RAD(vAngles[1]));

		sp = sin(DEG2RAD(vAngles[0]));
		cp = cos(DEG2RAD(vAngles[0]));

		vForward.x = cp * cy;
		vForward.y = cp * sy;
		vForward.z = -sp;

		return vForward;
	}

	bool is_entity_audible(int entity_index, const Vector& origin)
	{
		for (int i = 0; i < g::active_channel->count; ++i)
		{
			float dist = g::local_player->m_vecOrigin().DistTo(origin);

			if (g::channels[g::active_channel->list[i]].sound_source == entity_index && dist <= 1064.f)
				return true;
		}

		return false;
	};

	bool Insecure()
	{
		return std::strstr(GetCommandLineA(), "-insecure");
	}

	bool IsPlayingMM()
	{
		ConVar* type = nullptr;
		ConVar* mode = nullptr;

		if (!mode)
			mode = g::cvar->find("game_mode");

		if (!type)
			type = g::cvar->find("game_type");

		if ((type->GetInt() == 0 && mode->GetInt() == 0)) //casual
			return false;

		if ((type->GetInt() == 1 && mode->GetInt() == 1)) //demolition
			return false;

		if ((type->GetInt() == 1 && mode->GetInt() == 0)) //arms race
			return false;

		if ((type->GetInt() == 1 && mode->GetInt() == 2)) //deathmatch
			return false;

		if (type->GetInt() == 0 && mode->GetInt() == 1) //competitive
			return true;

		if (type->GetInt() == 0 && mode->GetInt() == 2) //wingman
			return true;

		if (type->GetInt() == 6 && mode->GetInt() == 0) //dangerzone
			return true;

		if (type->GetInt() == 6 && mode->GetInt() == 0) //scrimmage
			return true;

		return false;
	}

	bool IsPlayingMM_AND_IsValveServer() //returns true if server has mm gamemodes set (5v5, 2v2, scrimmage, dangerzone) and true if server is Valve official server.
	{
		ConVar* type = nullptr;
		ConVar* mode = nullptr;

		const char* server = "";

		if (g::engine_client->IsInGame())
		{
			auto nci = g::engine_client->GetNetChannelInfo();

			if (nci)
			{
				server = nci->GetAddress();

				if (!strcmp(server, "loopback")) //TODO: Convert to hash.
					server = "Local server";
				else if (g::game_rules_proxy->m_bIsValveDS())
					server = "Valve server";
			}
		}

		if (!mode)
			mode = g::cvar->find("game_mode");

		if (!type)
			type = g::cvar->find("game_type");

		if ((type->GetInt() == 0 && mode->GetInt() == 0) && server == "Valve server") //casual
			return false;

		if ((type->GetInt() == 1 && mode->GetInt() == 1) && server == "Valve server") //demolition
			return false;

		if ((type->GetInt() == 1 && mode->GetInt() == 0) && server == "Valve server") //arms race
			return false;

		if ((type->GetInt() == 1 && mode->GetInt() == 2) && server == "Valve server") //deathmatch
			return false;

		/* ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */

		if ((type->GetInt() == 0 && mode->GetInt() == 0) && server != "Valve server") //casual
			return true;

		if ((type->GetInt() == 1 && mode->GetInt() == 1) && server != "Valve server") //demolition
			return true;

		if ((type->GetInt() == 1 && mode->GetInt() == 0) && server != "Valve server") //arms race
			return true;

		if ((type->GetInt() == 1 && mode->GetInt() == 2) && server != "Valve server") //deathmatch
			return true;

		if (type->GetInt() == 0 && mode->GetInt() == 1) //competitive
			return true;

		if (type->GetInt() == 0 && mode->GetInt() == 2) //wingman
			return true;

		if (type->GetInt() == 6 && mode->GetInt() == 0) //dangerzone
			return true;

		if (type->GetInt() == 6 && mode->GetInt() == 0) //scrimmage
			return true;

		return false;
	}

	void create_beam(const int& user_id, const Vector& end_pos)
	{
		if (!end_pos.IsValid())
			return;

		c_base_player* player = c_base_player::GetPlayerByUserId(user_id);
		if (!player || !player->IsPlayer() || player == g::local_player)
			return;

		if (player->m_iTeamNum() == g::local_player->m_iTeamNum() && !settings::misc::deathmatch)
			return;

		if (player->GetEyePos().DistTo(end_pos) < 0.1f)
			return;

		BeamInfo_t beamInfo;
		beamInfo.m_nType = TE_BEAMPOINTS;
		beamInfo.m_pszModelName = "sprites/physbeam.vmt";
		beamInfo.m_nModelIndex = -1;
		beamInfo.m_flHaloScale = 0.0f;
		beamInfo.m_flLife = 1.f;
		beamInfo.m_flWidth = 2.0f;
		beamInfo.m_flEndWidth = 2.0f;
		beamInfo.m_flFadeLength = 0.0f;
		beamInfo.m_flAmplitude = 2.0f;
		beamInfo.m_flBrightness = 255.f;
		beamInfo.m_flSpeed = 0.2f;
		beamInfo.m_nStartFrame = 0;
		beamInfo.m_flFrameRate = 0.f;
		beamInfo.m_flRed = player->m_iTeamNum() == team::team_ct ? 0.f : 240.f;
		beamInfo.m_flGreen = 50.f;
		beamInfo.m_flBlue = player->m_iTeamNum() == team::team_ct ? 240.f : 0.f;
		beamInfo.m_nSegments = 2;
		beamInfo.m_bRenderable = true;
		beamInfo.m_nFlags = FBEAM_FADEIN | FBEAM_FADEOUT;
		beamInfo.m_vecStart = player->GetEyePos();
		beamInfo.m_vecEnd = end_pos;

		Beam_t* beam = g::view_render_beams->CreateBeamPoints(beamInfo);
		if (beam)
			g::view_render_beams->DrawBeam(beam);
	}

	ImU32 to_im32(const Color& color, const float& alpha)
	{
		return ImGui::GetColorU32(ImVec4(color.r() / 255.f, color.g() / 255.f, color.b() / 255.f, alpha));
	}

	void* get_export(const char* module_name, const char* export_name)
	{
		HMODULE mod;
		while (!((mod = LI_FN(GetModuleHandleA).cached()(module_name))))
			LI_FN(Sleep).cached()(100);

		return reinterpret_cast<void*>(GetProcAddress(mod, export_name));
	}

	unsigned int get_virtual(void* class_, unsigned int index) {
		return (unsigned int)(*(int**)class_)[index];
	}

	std::string get_weapon_name(void* weapon)
	{
		static const auto V_UCS2ToUTF8 = static_cast<int(*)(const wchar_t* ucs2, char* utf8, int len)>(get_export("vstdlib.dll", "V_UCS2ToUTF8"));

		if (!weapon)
			return "";

		const auto wide_name = g::localize->Find(((c_base_combat_weapon*)weapon)->GetWeaponData()->szHudName);

		char weapon_name[256];
		V_UCS2ToUTF8(wide_name, weapon_name, sizeof(weapon_name));

		return weapon_name;
	}

	wchar_t* to_wstring(const char* str)
	{
		const auto size = strlen(str) + 1;

		auto* wc = new wchar_t[size];
		MultiByteToWideChar(CP_UTF8, 0, str, -1, wc, size);

		return wc;

		delete[] wc; //Edit: Added delete
	}

	int get_active_key()
	{
		ImGuiContext& g = *GImGui;
		ImGuiIO& io = g.IO;
		for (auto i = 0; i < 5; i++)
		{
			if (io.MouseDown[i])
			{
				switch (i)
				{
				case 0:
					return VK_LBUTTON;
				case 1:
					return VK_RBUTTON;
				case 2:
					return VK_MBUTTON;
				case 3:
					return VK_XBUTTON1;
				case 4:
					return VK_XBUTTON2;
				}
			}
		}

		for (auto i = VK_BACK; i <= VK_RMENU; i++)
		{
			if (io.KeysDown[i])
				return i;
		}

		if (input_system::is_key_down(ImGuiKey_Escape))
			return 0;

		return -1;
	}

	int random(const int& min, const int& max)
	{
		return rand() % (max - min + 1) + min;
	}

	float random(const float& min, const float& max)
	{
		return ((max - min) * ((float)rand() / RAND_MAX)) + min;
	}

	bool is_sniper(int iItemDefinitionIndex)
	{
		return iItemDefinitionIndex == WEAPON_AWP || iItemDefinitionIndex == WEAPON_SSG08 ||
			iItemDefinitionIndex == WEAPON_SCAR20 || iItemDefinitionIndex == WEAPON_G3SG1;
	}

	bool is_connected()
	{
		return g::engine_client->IsInGame() && g::local_player && g::local_player->IsAlive();
	}

	struct hud_weapons_t
	{
		std::int32_t* get_weapon_count()
		{
			return reinterpret_cast<std::int32_t*>(std::uintptr_t(this) + 0x20); //was 0x80
		}
	};

	void force_full_update()
	{
		static const auto full_update_fn = reinterpret_cast<void(*)(void)>(pattern_scan(FORCE_FULL_UPDATE));
		full_update_fn();

		if (!g::local_player || !g::local_player->IsAlive())
			return;

 		static auto clear_hud_weapon_icon_ptr = utils::pattern_scan(CLEAR_HUD_WEAPON_ICON);
 		static auto clear_hud_weapon_icon_fn = reinterpret_cast<std::int32_t(__thiscall*)(void*, std::int32_t)>(clear_hud_weapon_icon_ptr);
 
		auto element = g::hud_system->FindHudElement<std::uintptr_t*>("CCSGO_HudWeaponSelection");
 		auto hud_weapons = reinterpret_cast<hud_weapons_t*>(std::uintptr_t(element) - 0x9c); //was 0x9c //0x28

 		if (!hud_weapons || *hud_weapons->get_weapon_count() == 0)
 			return;
 
 		for (std::int32_t i = 0; i < *hud_weapons->get_weapon_count(); i++)
 			i = clear_hud_weapon_icon_fn(hud_weapons, i);
	}

	bool is_line_goes_through_smoke(Vector vStartPos, Vector vEndPos)
	{
		static auto fn = reinterpret_cast<bool(*)(Vector, Vector)>(patterns::is_line_goes_through_smoke_fn_addr);

		return fn(vStartPos, vEndPos);
	}

	std::map<std::string, HMODULE> modules = {};

	HMODULE get_module(const std::string& name)
	{
		if (modules.count(name) == 0 || !modules[name])
			modules[name] = LI_FN(GetModuleHandleA).cached()(name.c_str());

		return modules[name];
	}

	std::uint8_t* pattern_scan(const char* moduleName, const char* signature)
	{
		return pattern_scan(get_module(moduleName), signature);
	}

	std::uint8_t* pattern_scan(void* module, const char* signature)
	{
		static auto pattern_to_byte = [](const char* pattern) {
			auto bytes = std::vector<int>{};
			auto start = const_cast<char*>(pattern);
			auto end = const_cast<char*>(pattern) + strlen(pattern);

			for (auto current = start; current < end; ++current)
			{
				if (*current == '?')
				{
					++current;
					if (*current == '?')
						++current;
					bytes.emplace_back(-1);
				}
				else
					bytes.emplace_back(strtoul(current, &current, 16));
			}
			return bytes;
		};

		auto dosHeader = (PIMAGE_DOS_HEADER)module;
		auto ntHeaders = (PIMAGE_NT_HEADERS)((std::uint8_t*)module + dosHeader->e_lfanew);

		auto sizeOfImage = ntHeaders->OptionalHeader.SizeOfImage;
		auto patternBytes = pattern_to_byte(signature);
		auto scanBytes = reinterpret_cast<std::uint8_t*>(module);

		auto s = patternBytes.size();
		auto d = patternBytes.data();

		for (auto i = 0ul; i < sizeOfImage - s; ++i)
		{
			bool found = true;
			for (auto j = 0ul; j < s; ++j)
			{
				if (scanBytes[i + j] != d[j] && d[j] != -1) {
					found = false;
					break;
				}
			}

			if (found)
				return &scanBytes[i];
		}
		return nullptr;
	}
}
```

`src/helpers/utils.h`:

```h
#pragma once

#define NOMINMAX
#include <string>
#include <Windows.h>
#include <functional>
#include <initializer_list>

#include "../imgui/imgui.h"
#include "../valve_sdk/sdk.hpp"

#define TIME_TO_TICKS( dt )	( ( int )( 0.5f + ( float )( dt ) / g::global_vars->interval_per_tick ) )
#define TICKS_TO_TIME(t) ( g::global_vars->interval_per_tick * (t) )

namespace utils
{
	int random(const int& min, const int& max);
	float random(const float& min, const float& max);

	void render_dot(ImDrawList* draw_list, const Vector& origin, const QAngle& angles, const ImU32& color);
	RECT get_box(const Vector* transformed_points);
	void scale_color_to_health(float fraction, float& outR, float& outG, float& outB);
	float get_interpolation_compensation();
	Vector CalcHelpPos(Vector target);
	Vector CalcDir(const Vector& vAngles);

	bool is_entity_audible(int entity_index, const Vector& origin);
	bool is_connected();
	bool is_sniper(int iItemDefinitionIndex);
	bool IsPlayingMM();
	bool IsPlayingMM_AND_IsValveServer();
	bool Insecure();

	std::string get_weapon_name(void* weapon);

	HMODULE get_module(const std::string& name);
	void* get_export(const char* module_name, const char* export_name);
	unsigned int get_virtual(void* class_, unsigned int index);
	std::uint8_t* pattern_scan(void* module, const char* signature);
	std::uint8_t* pattern_scan(const char* moduleName, const char* signature);

	void force_full_update();
	void create_beam(const int& user_id, const Vector& end_pos);
	bool is_line_goes_through_smoke(Vector vStartPos, Vector vEndPos);
	
	int get_active_key();
	ImU32 to_im32(const Color& color, const float& alpha = 1.f);
	wchar_t* to_wstring(const char* str);
}

```

`src/hooks/hooked_functions/create_move.cpp`:

```cpp
#include "../hooks.h"
#include "../../settings/globals.h"
#include "../../settings/options.hpp"
#include "../../helpers/input.h"
#include "../../helpers/console.h"
#include "../../helpers/entities.h"
#include "../../features/features.h"
#include "../../valve_sdk/classids.h"

#include <algorithm>

namespace hooks
{
	bool __fastcall create_move::hooked(void* ecx, void* edx, float input_sample_frametime, CUserCmd* cmd)
	{
		bool ret = original(ecx, input_sample_frametime, cmd);

		if (!cmd || !cmd->command_number || !g::local_player)
			return ret;

		if (ret)
		{
			cmd->viewangles.NormalizeClamp();

			g::engine_client->SetViewAngles(cmd->viewangles);
			g::prediction->SetLocalViewAngles(cmd->viewangles);
		}

		entities::fetch_targets(cmd);

		if (settings::visuals::grenade_prediction)
			grenade_prediction::fetch_points(cmd);

		if (settings::misc::fast_stop)
			features::fast_stop(cmd);

		if (settings::misc::bhop)
			features::bhop(cmd);

		if (settings::misc::auto_strafe)
			features::auto_strafe(cmd);

		if (settings::misc::selfnade)
			features::selfnade(cmd);

		if (cmd->weaponselect == 0)
		{
			aimbot::handle(cmd);

			if (settings::misc::smoke_helper)
				visuals::SmokeHelperAimbot(cmd);

			if (settings::misc::flash_helper)
				visuals::PopflashHelperAimbot(cmd);
		}

		cmd->viewangles.NormalizeClamp();

		cmd->forwardmove = std::clamp(cmd->forwardmove, -450.0f, 450.0f);
		cmd->sidemove = std::clamp(cmd->sidemove, -450.0f, 450.0f);
		cmd->upmove = std::clamp(cmd->upmove, -320.0f, 320.0f);

		return false;
	}
}
```

`src/hooks/hooked_functions/draw_model_execute.cpp`:

```cpp
#include "../hooks.h"
#include "../../features/features.h"

namespace hooks
{
	std::once_flag once_flag_dme;

	void __stdcall draw_model_execute::hooked(IMatRenderContext* context, const DrawModelState_t& state, const ModelRenderInfo_t& info, matrix3x4_t* bone)
	{
		original(g::mdl_render, context, &state, &info, bone);

		std::call_once(once_flag_dme, [] { chams::initialize_materials(); });

		chams::on_draw_model_execute(context, state, info, bone, original);
		
		original(g::mdl_render, context, &state, &info, bone);

		g::mdl_render->ForcedMaterialOverride(nullptr);
	}
}
```

`src/hooks/hooked_functions/frame_stage_notify.cpp`:

```cpp
#include "../hooks.h"
#include "../../settings/globals.h"
#include "../../settings/options.hpp"
#include "../../helpers/utils.h"
#include "../../helpers/console.h"
#include "../../features/features.h"

namespace hooks
{
	void __stdcall hooks::frame_stage_notify::hooked(EClientFrameStage stage) 
	{	
		const bool& is_in_game = g::engine_client->IsInGame();

		visuals::fetch_entities();
		
		if (settings::misc::lefthandknife)
			features::lefthand_knife();
		
		if (stage == FRAME_NET_UPDATE_POSTDATAUPDATE_START) 
		{
			skins::handle();
		}
		
		if (stage == FRAME_NET_UPDATE_START && is_in_game)
		{
			
		}

		if (stage == FRAME_NET_UPDATE_END && is_in_game)
		{

		}

		original(g::base_client, stage);
	}
}
```

`src/hooks/hooked_functions/game_event_listener.cpp`:

```cpp
#include "../hooked_functions/game_event_listener.h"

std::once_flag get_class_ids_flag;
void CGameEventListener::FireGameEvent(IGameEvent* context)
{
	const auto name = fnv::hash_runtime(context->GetName());

	if (name == FNV("game_newmap"))
	{
		std::call_once(get_class_ids_flag, []() { g::get_class_ids(); });

		color_modulation::event();
		globals::team_damage.clear();
	}
	else if (name == FNV("player_hurt"))
	{
		auto attacker = c_base_player::GetPlayerByUserId(context->GetInt("attacker"));
		auto target = c_base_player::GetPlayerByUserId(context->GetInt("userid"));

		if (!attacker || !target)
			return;

		if (attacker->m_iTeamNum() == target->m_iTeamNum())
			globals::team_damage[context->GetInt("attacker")] += context->GetInt("dmg_health");
	}
	else if (name == FNV("bomb_begindefuse"))
		features::on_bomb_begindefuse(context);
	else if (name == FNV("item_purchase"))
		features::buy_logger(context);
}
```

`src/hooks/hooked_functions/game_event_listener.h`:

```h
#pragma once

#include "../../valve_sdk/csgostructs.hpp"
#include "../../settings/globals.h"
#include "../../features/features.h"

class CGameEventListener final : public IGameEventListener2
{
	void FireGameEvent(IGameEvent* context) override;

	int GetEventDebugID(void) override
	{
		return EVENT_DEBUG_ID_INIT;
	}
};

```

`src/hooks/hooked_functions/get_color_modulation.cpp`:

```cpp
#include "../hooks.h"
#include "../../settings/settings.h"

namespace hooks
{
	static const char* blacklist_materials[]
	{
		"effects/flashbang", "effects/flashbang_white", "dev/scope_bluroverlay",
		"effects/overlaysmoke", "weapon", "glow"
	};

	void __fastcall get_color_modulation::hooked(IMaterial* ecx, void* edx, float* r, float* g, float* b)
	{
		original(ecx, r, g, b);

		if (!settings::visuals::night_mode)
			return original(ecx, r, g, b);

		const auto material = reinterpret_cast<IMaterial*>(ecx);

		if (!material)
			return original(ecx, r, g, b);

		const auto group_name = fnv::hash_runtime(material->GetTextureGroupName());
		const auto material_name = fnv::hash_runtime(material->GetName());

		if (group_name == FNV(TEXTURE_GROUP_VGUI) || group_name == FNV(TEXTURE_GROUP_OTHER) || group_name == FNV(TEXTURE_GROUP_MODEL))
			return original(ecx, r, g, b);

		for (const auto& mat : blacklist_materials)
		{
			if (material_name == fnv::hash_runtime(mat))
				return original(ecx, r, g, b);
		}

		switch (group_name)
		{
			case FNV(TEXTURE_GROUP_WORLD):
			case FNV(TEXTURE_GROUP_SKYBOX):
				*r *= 0.15f; *g *= 0.15f; *b *= 0.15f; 
				break;
			case FNV(TEXTURE_GROUP_STATIC_PROPS):
				*r *= 0.45f; *g *= 0.45f; *b *= 0.45f;
				break;
		}

	}
}
```

`src/hooks/hooked_functions/is_using_static_debug_prop_modes.cpp`:

```cpp
#include "../hooks.h"
#include "../../settings/settings.h"

namespace hooks
{
	bool _stdcall is_using_static_prop_debug_modes::hooked()
	{
		return settings::visuals::night_mode;
	}
}
```

`src/hooks/hooked_functions/override_view.cpp`:

```cpp
#include "../hooks.h"
#include "../../features/features.h"
#include "../../settings/globals.h"

namespace hooks
{
	void __stdcall override_view::hooked(CViewSetup* view)
	{
		original(g::client_mode, view);

		color_modulation::handle();

		features::thirdperson();

		if (!globals::view_matrix::has_offset)
		{
			globals::view_matrix::has_offset = true;
			globals::view_matrix::offset = (reinterpret_cast<DWORD>(&g::engine_client->WorldToScreenMatrix()) + 0x40);
		}

		if (g::local_player && !g::local_player->m_bIsScoped() && g::local_player->IsAlive())
			view->fov = settings::misc::debug_fov;
	}
}
```

`src/hooks/hooked_functions/paint_traverse.cpp`:

```cpp
#include "../hooks.h"
#include "../../settings/settings.h"
#include "../../helpers/input.h"

namespace hooks
{
	void __stdcall paint_traverse::hooked(vgui::VPANEL panel, bool forceRepaint, bool allowForce)
	{
		original(g::vgui_panel, panel, forceRepaint, allowForce);

		auto panel_id = fnv::hash_runtime(g::vgui_panel->GetName(panel));

		if (settings::misc::noscope)
		{
			if (g::engine_client->IsInGame() && g::engine_client->IsConnected() && g::local_player->IsAlive() && panel_id == FNV("HudZoom"))
				return;
		}
	}
}
```

`src/hooks/hooked_functions/present.cpp`:

```cpp
#include "../hooks.h"
#include "../../settings/globals.h"
#include "../../settings/options.hpp"
#include "../../imgui/imgui.h"
#include "../../render/render.h"
#include "../../helpers/console.h"
#include "../../helpers/notifies.h"
#include "../../features/features.h"

#include <intrin.h>

namespace hooks
{
	static IDirect3DVertexDeclaration9* vert_dec = nullptr;
	static IDirect3DVertexShader9* vert_shader = nullptr;
	static DWORD old_color_writeenable = 0;



	void handle(IDirect3DDevice9* device)
	{
		if (!render::is_ready())
			return;

		ImGui_ImplDX9_NewFrame();

		auto& io = ImGui::GetIO();

		io.MouseDrawCursor = render::menu::is_visible();

		globals::draw_list = ImGui::GetOverlayDrawList();

		render::menu::show();
		render::timers::show();
		notifies::handle(globals::draw_list);
		render::spectators::show();
		grenade_prediction::render(globals::draw_list);
		esp::render_helpers();
		esp::render(globals::draw_list);
		visuals::render(globals::draw_list);
		features::player_infobox();

		ImGui::Render();

		ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
	}
	
	long __stdcall end_scene::hooked(IDirect3DDevice9* device)
	{
		device->GetRenderState(D3DRS_COLORWRITEENABLE, &old_color_writeenable);
		device->GetVertexDeclaration(&vert_dec);
		device->GetVertexShader(&vert_shader);
		device->SetRenderState(D3DRS_COLORWRITEENABLE, 0xffffffff);
		device->SetRenderState(D3DRS_SRGBWRITEENABLE, false);
		device->SetSamplerState(NULL, D3DSAMP_ADDRESSU, D3DTADDRESS_WRAP);
		device->SetSamplerState(NULL, D3DSAMP_ADDRESSV, D3DTADDRESS_WRAP);
		device->SetSamplerState(NULL, D3DSAMP_ADDRESSW, D3DTADDRESS_WRAP);
		device->SetSamplerState(NULL, D3DSAMP_SRGBTEXTURE, NULL);

		handle(device);

		device->SetRenderState(D3DRS_COLORWRITEENABLE, old_color_writeenable);
		device->SetRenderState(D3DRS_SRGBWRITEENABLE, true);
		device->SetVertexDeclaration(vert_dec);
		device->SetVertexShader(vert_shader);

		return original(device);
	}
}
```

`src/hooks/hooked_functions/reset.cpp`:

```cpp
#include "../hooks.h"
#include "../../render/render.h"
#include "../../settings/settings.h"

namespace hooks
{
	long __stdcall reset::hooked(IDirect3DDevice9* device, D3DPRESENT_PARAMETERS* params)
	{
		if (render::is_ready())
			render::device_lost();

		const auto hr = original(device, params);
		if (hr >= 0 && render::is_ready())
			render::device_reset();

		return hr;
	}
}
```

`src/hooks/hooked_functions/sequence.cpp`:

```cpp
#include <functional>

#include "../hooks.h"
#include "../../settings/globals.h"
#include "../../helpers/utils.h"
#include "../../helpers/console.h"
#include "../../features/features.h"
#include "../../valve_sdk/misc/Recv.hpp"

namespace hooks
{
	recv_prop_hook* sequence::hook;
	int get_new_animation(const fnv::hash model, const int sequence)
	{
		switch (model)
		{
		case FNV("models/weapons/v_pist_deagle.mdl"):
		{
			switch (sequence)
			{
			case 7:
				return 8; break;
			default:
				return sequence; break;
			}
		}
		case FNV("models/weapons/v_knife_butterfly.mdl"):
		{
			switch (sequence)
			{
			case SEQUENCE_DEFAULT_DRAW:
				return utils::random(SEQUENCE_BUTTERFLY_DRAW, SEQUENCE_BUTTERFLY_DRAW2); break;
			case SEQUENCE_DEFAULT_LOOKAT01:
				return utils::random(SEQUENCE_BUTTERFLY_LOOKAT01, SEQUENCE_BUTTERFLY_LOOKAT03); break;
			default:
				return sequence + 1; break;
			}
		}
		case FNV("models/weapons/v_knife_falchion_advanced.mdl"):
		{
			switch (sequence)
			{
			case SEQUENCE_DEFAULT_IDLE2:
				return SEQUENCE_FALCHION_IDLE1;
			case SEQUENCE_DEFAULT_HEAVY_MISS1:
				return utils::random(SEQUENCE_FALCHION_HEAVY_MISS1, SEQUENCE_FALCHION_HEAVY_MISS1_NOFLIP); break;
			case SEQUENCE_DEFAULT_LOOKAT01:
				return utils::random(SEQUENCE_FALCHION_LOOKAT01, SEQUENCE_FALCHION_LOOKAT02); break;
			case SEQUENCE_DEFAULT_DRAW:
			case SEQUENCE_DEFAULT_IDLE1:
				return sequence; break;
			default:
				return sequence - 1; break;
			}
		}
		case FNV("models/weapons/v_knife_push.mdl"):
		{
			switch (sequence)
			{
			case SEQUENCE_DEFAULT_IDLE2:
				return SEQUENCE_DAGGERS_IDLE1;
			case SEQUENCE_DEFAULT_LIGHT_MISS1:
			case SEQUENCE_DEFAULT_LIGHT_MISS2:
				return utils::random(SEQUENCE_DAGGERS_LIGHT_MISS1, SEQUENCE_DAGGERS_LIGHT_MISS5); break;
			case SEQUENCE_DEFAULT_HEAVY_MISS1:
				return utils::random(SEQUENCE_DAGGERS_HEAVY_MISS2, SEQUENCE_DAGGERS_HEAVY_MISS1); break;
			case SEQUENCE_DEFAULT_HEAVY_HIT1:
			case SEQUENCE_DEFAULT_HEAVY_BACKSTAB:
			case SEQUENCE_DEFAULT_LOOKAT01:
				return sequence + 3; break;
			case SEQUENCE_DEFAULT_DRAW:
			case SEQUENCE_DEFAULT_IDLE1:
				return sequence; break;
			default:
				return sequence + 2; break;
			}
		}
		case FNV("models/weapons/v_knife_survival_bowie.mdl"):
		{
			switch (sequence)
			{
			case SEQUENCE_DEFAULT_DRAW:
			case SEQUENCE_DEFAULT_IDLE1:
				return sequence; break;
			case SEQUENCE_DEFAULT_IDLE2:
				return SEQUENCE_BOWIE_IDLE1; break;
			default:
				return sequence - 1;
			}
		}
		case FNV("models/weapons/v_knife_ursus.mdl"):
		case FNV("models/weapons/v_knife_cord.mdl"):
		case FNV("models/weapons/v_knife_canis.mdl"):
		case FNV("models/weapons/v_knife_outdoor.mdl"):
		case FNV("models/weapons/v_knife_skeleton.mdl"):
		{
			switch (sequence)
			{
			case SEQUENCE_DEFAULT_DRAW:
				return utils::random(SEQUENCE_BUTTERFLY_DRAW, SEQUENCE_BUTTERFLY_DRAW2); break;
			case SEQUENCE_DEFAULT_LOOKAT01:
				return utils::random(SEQUENCE_BUTTERFLY_LOOKAT01, 14); break;
			default:
				return sequence + 1;
			}
		}
		case FNV("models/weapons/v_knife_stiletto.mdl"):
		{
			switch (sequence)
			{
			case SEQUENCE_DEFAULT_LOOKAT01:
				return utils::random(12, 13); break;
			}
		}
		case FNV("models/weapons/v_knife_widowmaker.mdl"):
		{
			switch (sequence)
			{
			case SEQUENCE_DEFAULT_LOOKAT01: 
				return utils::random(14, 15); break;
			case SEQUENCE_DEFAULT_HEAVY_BACKSTAB:
				return sequence - 1; break;
			}
		}
		case FNV("models/weapons/v_knife_css.mdl"):
		{
			switch (sequence)
			{
			case SEQUENCE_DEFAULT_LOOKAT01:
				return utils::random(SEQUENCE_CSS_LOOKAT02, SEQUENCE_CSS_LOOKAT02); break;
			default:
				return sequence;
			}
		}
		default:
			return sequence;
		}
	}

	void remapping(CRecvProxyData* data, c_base_view_model* entity)
	{
		if (!g::local_player || !g::local_player->IsAlive())
			return;

		const auto owner = (c_base_player*)g::entity_list->GetClientEntityFromHandle(entity->m_hOwner());
		if (owner != g::local_player)
			return;

		const auto view_model_weapon = (c_base_attributable_item*)g::entity_list->GetClientEntityFromHandle(entity->m_hWeapon());
		if (!view_model_weapon)
			return;

		if (skins::get_weapon_info(view_model_weapon->m_iItemDefinitionIndex()) == nullptr)
			return;

		const auto weapon_info = skins::get_weapon_info(view_model_weapon->m_iItemDefinitionIndex());
		auto& sequence = data->m_Value.m_Int;
		sequence = get_new_animation(fnv::hash_runtime(weapon_info->model), sequence);
	}

	void sequence::hooked(const CRecvProxyData* data, void* entity, void* output)
	{
		static auto original = hook->get_original_function();

		const auto proxy_data = const_cast<CRecvProxyData*>(data);
		const auto view_model = static_cast<c_base_view_model*>(entity);

		remapping(proxy_data, view_model);

		original(data, entity, output);
	}
}
```

`src/hooks/hooks.cpp`:

```cpp
#pragma warning(disable : 26812)

#include <format>

#include "hooks.h"
#include "../settings/globals.h"
#include "../helpers/console.h"
#include "../hooks/hooked_functions/game_event_listener.h"

namespace hooks
{	
	CGameEventListener event_listener = CGameEventListener();

	bool init()
	{
		sequence::hook = new recv_prop_hook(c_base_view_model::m_nSequence(), sequence::hooked);
		end_scene::setup = reinterpret_cast<void*>(utils::get_virtual(g::d3_device, end_scene::index));
		create_move::setup = reinterpret_cast<void*>(utils::get_virtual(g::client_mode, create_move::index));
		reset::setup = reinterpret_cast<void*>(utils::get_virtual(g::d3_device, reset::index));
		paint_traverse::setup = reinterpret_cast<void*>(utils::get_virtual(g::vgui_panel, paint_traverse::index));
		override_view::setup = reinterpret_cast<void*>(utils::get_virtual(g::client_mode, override_view::index));
		frame_stage_notify::setup = reinterpret_cast<void*>(utils::get_virtual(g::base_client, frame_stage_notify::index));
		draw_model_execute::setup = reinterpret_cast<void*>(utils::get_virtual(g::mdl_render, draw_model_execute::index));
		get_color_modulation::setup = reinterpret_cast<void*>(utils::pattern_scan("materialsystem.dll", "55 8B EC 83 EC ? 56 8B F1 8A 46"));
		is_using_static_prop_debug_modes::setup = reinterpret_cast<void*>(utils::pattern_scan("engine.dll", "8B 0D ? ? ? ? 81 F9 ? ? ? ? 75 ? A1 ? ? ? ? 35 ? ? ? ? EB ? 8B 01 FF 50 ? 83 F8 ? 0F 85 ? ? ? ? 8B 0D"));
		
		if (MH_CreateHook(get_color_modulation::setup, &get_color_modulation::hooked, reinterpret_cast<void**>(&get_color_modulation::original)) != MH_OK)
			return false;

		if (MH_CreateHook(is_using_static_prop_debug_modes::setup, &is_using_static_prop_debug_modes::hooked, reinterpret_cast<void**>(&is_using_static_prop_debug_modes::original)) != MH_OK)
			return false;
		
		if (MH_CreateHook(end_scene::setup, &end_scene::hooked, reinterpret_cast<void**>(&end_scene::original)) != MH_OK)
			return false;
			
		if (MH_CreateHook(create_move::setup, &create_move::hooked, reinterpret_cast<void**>(&create_move::original)) != MH_OK)
			return false;

		if (MH_CreateHook(reset::setup, &reset::hooked, reinterpret_cast<void**>(&reset::original)) != MH_OK)
			return false;
		
		if (MH_CreateHook(paint_traverse::setup, &paint_traverse::hooked, reinterpret_cast<void**>(&paint_traverse::original)) != MH_OK)
			return false;
		
		if (MH_CreateHook(override_view::setup, &override_view::hooked, reinterpret_cast<void**>(&override_view::original)) != MH_OK)
			return false;
			
		if (MH_CreateHook(frame_stage_notify::setup, &frame_stage_notify::hooked, reinterpret_cast<void**>(&frame_stage_notify::original)) != MH_OK)
			return false;
		
		if (MH_CreateHook(draw_model_execute::setup, &draw_model_execute::hooked, reinterpret_cast<void**>(&draw_model_execute::original)) != MH_OK)
			return false;

		if (MH_EnableHook(MH_ALL_HOOKS) != MH_OK)
			return false;

		g::game_events->add_listener(&event_listener, xorstr_("game_newmap"), false);
		g::game_events->add_listener(&event_listener, xorstr_("player_hurt"), false);
		g::game_events->add_listener(&event_listener, xorstr_("bomb_begindefuse"), false);
		g::game_events->add_listener(&event_listener, xorstr_("item_purchase"), false);
		
		
		return true;
	}

	void destroy()
	{
		//static auto weapon_debug_spread_show = g::cvar->find(xorstr_("weapon_debug_spread_show"));
		//weapon_debug_spread_show->SetValue(0);

		//static auto engine_no_focus_sleep = g::cvar->find(xorstr_("engine_no_focus_sleep"));
		//engine_no_focus_sleep->SetValue(50);

		g::game_events->remove_listener(&event_listener);
		
		MH_DisableHook(MH_ALL_HOOKS);
		MH_RemoveHook(MH_ALL_HOOKS);

		MH_Uninitialize();

		sequence::hook->~recv_prop_hook();
	}
}
```

`src/hooks/hooks.h`:

```h
#pragma once

#include "../valve_sdk/csgostructs.hpp"
#include "../minhook/minhook.h"
#include "../valve_sdk/interfaces/IStudioRender.h"

#include <d3dx9.h>
#include <type_traits>

#pragma comment(lib, "d3dx9.lib")

namespace hooks
{
	bool init();
	void destroy();

	struct end_scene
	{
		static const int index = 42;
		using fn = long(__stdcall*)(IDirect3DDevice9*);
		static long __stdcall hooked(IDirect3DDevice9*);

		inline static fn original;
		inline static void* setup;
	};

	struct create_move
	{
		static const int index = 24;
		using fn = bool(__thiscall*)(void*, float, CUserCmd*);
		static bool __fastcall hooked(void* ecx, void* edx, float input_sample_frametime, CUserCmd* cmd);

		inline static fn original;
		inline static void* setup;
	};

	struct reset
	{
		static const int index = 16;
		using fn = long(__stdcall*)(IDirect3DDevice9*, D3DPRESENT_PARAMETERS*);
		static long __stdcall hooked(IDirect3DDevice9*, D3DPRESENT_PARAMETERS*);

		inline static fn original;
		inline static void* setup;
	};

	struct paint_traverse
	{
		static const int index = 41;
		using fn = void(__thiscall*)(IPanel*, vgui::VPANEL, bool, bool);
		static void __stdcall hooked(vgui::VPANEL, bool forceRepaint, bool allowForce);

		inline static fn original;
		inline static void* setup;
	};

	struct override_view
	{
		static const int index = 18;
		using fn = void(__thiscall*)(IClientMode*, CViewSetup*);
		static void __stdcall hooked(CViewSetup*);

		inline static fn original;
		inline static void* setup;
	};

	struct draw_model_execute
	{
		static const int index = 21;
		using fn = void(__thiscall*)(IVModelRender*, IMatRenderContext*, const DrawModelState_t*, const ModelRenderInfo_t*, matrix3x4_t*);
		static void __stdcall hooked(IMatRenderContext* context, const DrawModelState_t& state, const ModelRenderInfo_t& info, matrix3x4_t* bone);

		inline static fn original;
		inline static void* setup;
	};

	struct frame_stage_notify
	{
		static const int index = 37;
		using fn = void(__thiscall*)(IBaseClientDLL*, EClientFrameStage);
		static void __stdcall hooked(EClientFrameStage stage);

		inline static fn original;
		inline static void* setup;
	};

	struct sequence
	{
		static recv_prop_hook* hook;
		using fn = void(__thiscall*)(const CRecvProxyData* data, void* entity, void* output);
		static void hooked(const CRecvProxyData* data, void* entity, void* output);
	};

	struct get_color_modulation
	{
		using fn = void(__thiscall*)(void*, float*, float*, float*);
		static void __fastcall hooked(IMaterial* ecx, void* edx, float* r, float* g, float* b);

		inline static fn original;
		inline static void* setup;
	};

	struct is_using_static_prop_debug_modes
	{
		using fn = bool(__thiscall*)();
		static bool __stdcall hooked();

		inline static fn original;
		inline static void* setup;
	};
};
```

`src/imgui/directx9/imgui_impl_dx9.cpp`:

```cpp
// ImGui Win32 + DirectX9 binding

// Implemented features:
//  [X] User texture binding. Use 'LPDIRECT3DTEXTURE9' as ImTextureID. Read the FAQ about ImTextureID in imgui.cpp.

// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.
// If you use this binding you'll need to call 4 functions: ImGui_ImplXXXX_Init(), ImGui_ImplXXXX_NewFrame(), ImGui::Render() and ImGui_ImplXXXX_Shutdown().
// If you are new to ImGui, see examples/README.txt and documentation at the top of imgui.cpp.
// https://github.com/ocornut/imgui

// CHANGELOG
// (minor and older changes stripped away, please see git history for details)
//  2018-03-20: Misc: Setup io.BackendFlags ImGuiBackendFlags_HasMouseCursors and ImGuiBackendFlags_HasSetMousePos flags + honor ImGuiConfigFlags_NoMouseCursorChange flag.
//  2018-02-20: Inputs: Added support for mouse cursors (ImGui::GetMouseCursor() value and WM_SETCURSOR message handling).
//  2018-02-16: Misc: Obsoleted the io.RenderDrawListsFn callback and exposed ImGui_ImplDX9_RenderDrawData() in the .h file so you can call it yourself.
//  2018-02-06: Misc: Removed call to ImGui::Shutdown() which is not available from 1.60 WIP, user needs to call CreateContext/DestroyContext themselves.
//  2018-02-06: Inputs: Honoring the io.WantSetMousePos by repositioning the mouse (when using navigation and ImGuiConfigFlags_NavEnableSetMousePos is set).
//  2018-02-06: Inputs: Added mapping for ImGuiKey_Space.

#include "../imgui.h"
#include "imgui_impl_dx9.h"

// DirectX
#include <d3d9.h>
#define DIRECTINPUT_VERSION 0x0800
#include <dinput.h>

// Win32 data
static HWND                     g_hWnd = 0;
static INT64                    g_Time = 0;
static INT64                    g_TicksPerSecond = 0;
static ImGuiMouseCursor         g_LastMouseCursor = ImGuiMouseCursor_COUNT;

// DirectX data
static LPDIRECT3DDEVICE9        g_pd3dDevice = NULL;
static LPDIRECT3DVERTEXBUFFER9  g_pVB = NULL;
static LPDIRECT3DINDEXBUFFER9   g_pIB = NULL;
static LPDIRECT3DTEXTURE9       g_FontTexture = NULL;
static int                      g_VertexBufferSize = 5000, g_IndexBufferSize = 10000;

struct CUSTOMVERTEX
{
	float    pos[3];
	D3DCOLOR col;
	float    uv[2];
};
#define D3DFVF_CUSTOMVERTEX (D3DFVF_XYZ|D3DFVF_DIFFUSE|D3DFVF_TEX1)

// Render function.
// (this used to be set in io.RenderDrawListsFn and called by ImGui::Render(), but you can now call this directly from your main loop)
void ImGui_ImplDX9_RenderDrawData(ImDrawData* draw_data, ImDrawList* draw_list)
{
	// Avoid rendering when minimized
	ImGuiIO& io = ImGui::GetIO();
	if (io.DisplaySize.x <= 0.0f || io.DisplaySize.y <= 0.0f)
		return;

	// Create and grow buffers if needed
	if (!g_pVB || g_VertexBufferSize < draw_data->TotalVtxCount)
	{
		if (g_pVB) { g_pVB->Release(); g_pVB = NULL; }
		g_VertexBufferSize = draw_data->TotalVtxCount + 5000;
		if (g_pd3dDevice->CreateVertexBuffer(g_VertexBufferSize * sizeof(CUSTOMVERTEX), D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, D3DFVF_CUSTOMVERTEX, D3DPOOL_DEFAULT, &g_pVB, NULL) < 0)
			return;
	}
	if (!g_pIB || g_IndexBufferSize < draw_data->TotalIdxCount)
	{
		if (g_pIB) { g_pIB->Release(); g_pIB = NULL; }
		g_IndexBufferSize = draw_data->TotalIdxCount + 10000;
		if (g_pd3dDevice->CreateIndexBuffer(g_IndexBufferSize * sizeof(ImDrawIdx), D3DUSAGE_DYNAMIC | D3DUSAGE_WRITEONLY, sizeof(ImDrawIdx) == 2 ? D3DFMT_INDEX16 : D3DFMT_INDEX32, D3DPOOL_DEFAULT, &g_pIB, NULL) < 0)
			return;
	}

	// Backup the DX9 state
	IDirect3DStateBlock9* d3d9_state_block = NULL;
	if (g_pd3dDevice->CreateStateBlock(D3DSBT_PIXELSTATE, &d3d9_state_block) < 0)
		return;

	d3d9_state_block->Capture();

	// Copy and convert all vertices into a single contiguous buffer
	CUSTOMVERTEX* vtx_dst;
	ImDrawIdx* idx_dst;
	if (g_pVB->Lock(0, (UINT)(draw_data->TotalVtxCount * sizeof(CUSTOMVERTEX)), (void**)&vtx_dst, D3DLOCK_DISCARD) < 0)
		return;
	if (g_pIB->Lock(0, (UINT)(draw_data->TotalIdxCount * sizeof(ImDrawIdx)), (void**)&idx_dst, D3DLOCK_DISCARD) < 0)
		return;

	if (draw_list && !draw_list->VtxBuffer.empty()) {
		const ImDrawList* cmd_draw_list = draw_list;
		const ImDrawVert* vtx_src_esp = cmd_draw_list->VtxBuffer.Data;

		for (int i = 0; i < cmd_draw_list->VtxBuffer.Size; i++)
		{
			vtx_dst->pos[0] = vtx_src_esp->pos.x;
			vtx_dst->pos[1] = vtx_src_esp->pos.y;
			vtx_dst->pos[2] = 0.0f;
			vtx_dst->col = (vtx_src_esp->col & 0xFF00FF00) | ((vtx_src_esp->col & 0xFF0000) >> 16) | ((vtx_src_esp->col & 0xFF) << 16);     // RGBA --> ARGB for DirectX9
			vtx_dst->uv[0] = vtx_src_esp->uv.x;
			vtx_dst->uv[1] = vtx_src_esp->uv.y;
			vtx_dst++;
			vtx_src_esp++;
		}
		memcpy(idx_dst, cmd_draw_list->IdxBuffer.Data, cmd_draw_list->IdxBuffer.Size * sizeof(ImDrawIdx));
		idx_dst += cmd_draw_list->IdxBuffer.Size;
	}

	for (int n = 0; n < draw_data->CmdListsCount; n++)
	{
		const ImDrawList* cmd_list = draw_data->CmdLists[n];
		const ImDrawVert* vtx_src = cmd_list->VtxBuffer.Data;
		for (int i = 0; i < cmd_list->VtxBuffer.Size; i++)
		{
			vtx_dst->pos[0] = vtx_src->pos.x;
			vtx_dst->pos[1] = vtx_src->pos.y;
			vtx_dst->pos[2] = 0.0f;
			vtx_dst->col = (vtx_src->col & 0xFF00FF00) | ((vtx_src->col & 0xFF0000) >> 16) | ((vtx_src->col & 0xFF) << 16);     // RGBA --> ARGB for DirectX9
			vtx_dst->uv[0] = vtx_src->uv.x;
			vtx_dst->uv[1] = vtx_src->uv.y;
			vtx_dst++;
			vtx_src++;
		}
		memcpy(idx_dst, cmd_list->IdxBuffer.Data, cmd_list->IdxBuffer.Size * sizeof(ImDrawIdx));
		idx_dst += cmd_list->IdxBuffer.Size;
	}
	g_pVB->Unlock();
	g_pIB->Unlock();
	g_pd3dDevice->SetStreamSource(0, g_pVB, 0, sizeof(CUSTOMVERTEX));
	g_pd3dDevice->SetIndices(g_pIB);
	g_pd3dDevice->SetFVF(D3DFVF_CUSTOMVERTEX);

	// Setup viewport
	D3DVIEWPORT9 vp;
	vp.X = vp.Y = 0;
	vp.Width = (DWORD)io.DisplaySize.x;
	vp.Height = (DWORD)io.DisplaySize.y;
	vp.MinZ = 0.0f;
	vp.MaxZ = 1.0f;
	g_pd3dDevice->SetViewport(&vp);

	// Setup render state: fixed-pipeline, alpha-blending, no face culling, no depth testing
	g_pd3dDevice->SetPixelShader(NULL);
	g_pd3dDevice->SetVertexShader(NULL);
	g_pd3dDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
	g_pd3dDevice->SetRenderState(D3DRS_LIGHTING, false);
	g_pd3dDevice->SetRenderState(D3DRS_ZENABLE, false);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHABLENDENABLE, true);
	g_pd3dDevice->SetRenderState(D3DRS_ALPHATESTENABLE, false);
	g_pd3dDevice->SetRenderState(D3DRS_BLENDOP, D3DBLENDOP_ADD);
	g_pd3dDevice->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
	g_pd3dDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, true);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP, D3DTOP_MODULATE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE);
	g_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG2, D3DTA_DIFFUSE);
	g_pd3dDevice->SetSamplerState(0, D3DSAMP_MINFILTER, D3DTEXF_LINEAR);
	g_pd3dDevice->SetSamplerState(0, D3DSAMP_MAGFILTER, D3DTEXF_LINEAR);

	// Setup orthographic projection matrix
	// Being agnostic of whether <d3dx9.h> or <DirectXMath.h> can be used, we aren't relying on D3DXMatrixIdentity()/D3DXMatrixOrthoOffCenterLH() or DirectX::XMMatrixIdentity()/DirectX::XMMatrixOrthographicOffCenterLH()
	{
		const float L = 0.5f, R = io.DisplaySize.x + 0.5f, T = 0.5f, B = io.DisplaySize.y + 0.5f;
		D3DMATRIX mat_identity = { { 1.0f, 0.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f, 0.0f,  0.0f, 0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 0.0f, 1.0f } };
		D3DMATRIX mat_projection =
		{
			2.0f / (R - L),   0.0f,         0.0f,  0.0f,
			0.0f,         2.0f / (T - B),   0.0f,  0.0f,
			0.0f,         0.0f,         0.5f,  0.0f,
			(L + R) / (L - R),  (T + B) / (B - T),  0.5f,  1.0f,
		};
		g_pd3dDevice->SetTransform(D3DTS_WORLD, &mat_identity);
		g_pd3dDevice->SetTransform(D3DTS_VIEW, &mat_identity);
		g_pd3dDevice->SetTransform(D3DTS_PROJECTION, &mat_projection);
	}

	// Render command lists
	int vtx_offset = 0;
	int idx_offset = 0;

	if (draw_list)
	{
		const ImDrawList* cmd_draw_list = draw_list;
		for (int cmd_i = 0; cmd_i < cmd_draw_list->CmdBuffer.Size; cmd_i++)
		{
			const ImDrawCmd* pcmd = &cmd_draw_list->CmdBuffer[cmd_i];
			if (pcmd->UserCallback)
			{
				pcmd->UserCallback(cmd_draw_list, pcmd);
			}
			else
			{
				const RECT r = { (LONG)pcmd->ClipRect.x, (LONG)pcmd->ClipRect.y, (LONG)pcmd->ClipRect.z, (LONG)pcmd->ClipRect.w };
				g_pd3dDevice->SetTexture(0, (LPDIRECT3DTEXTURE9)pcmd->TextureId);
				g_pd3dDevice->SetScissorRect(&r);
				g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, vtx_offset, 0, (UINT)cmd_draw_list->VtxBuffer.Size, idx_offset, pcmd->ElemCount / 3);
			}
			idx_offset += pcmd->ElemCount;
		}
		vtx_offset += cmd_draw_list->VtxBuffer.Size;
	}

	for (int n = 0; n < draw_data->CmdListsCount; n++)
	{
		const ImDrawList* cmd_list = draw_data->CmdLists[n];
		for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
		{
			const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
			if (pcmd->UserCallback)
			{
				pcmd->UserCallback(cmd_list, pcmd);
			}
			else
			{
				const RECT r = { (LONG)pcmd->ClipRect.x, (LONG)pcmd->ClipRect.y, (LONG)pcmd->ClipRect.z, (LONG)pcmd->ClipRect.w };
				g_pd3dDevice->SetTexture(0, (LPDIRECT3DTEXTURE9)pcmd->TextureId);
				g_pd3dDevice->SetScissorRect(&r);
				g_pd3dDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, vtx_offset, 0, (UINT)cmd_list->VtxBuffer.Size, idx_offset, pcmd->ElemCount / 3);
			}
			idx_offset += pcmd->ElemCount;
		}
		vtx_offset += cmd_list->VtxBuffer.Size;
	}

	// Restore the DX9 state
	d3d9_state_block->Apply();
	d3d9_state_block->Release();
}

static bool ImGui_ImplWin32_UpdateMouseCursor()
{
	ImGuiIO& io = ImGui::GetIO();
	if (io.ConfigFlags & ImGuiConfigFlags_NoMouseCursorChange)
		return false;

	ImGuiMouseCursor imgui_cursor = ImGui::GetMouseCursor();
	if (imgui_cursor == ImGuiMouseCursor_None || io.MouseDrawCursor)
	{
		// Hide OS mouse cursor if imgui is drawing it or if it wants no cursor
		::SetCursor(NULL);
	}
	else
	{
		// Show OS mouse cursor
		LPTSTR win32_cursor = IDC_ARROW;
		switch (imgui_cursor)
		{
		case ImGuiMouseCursor_Arrow:        win32_cursor = IDC_ARROW; break;
		case ImGuiMouseCursor_TextInput:    win32_cursor = IDC_IBEAM; break;
		case ImGuiMouseCursor_ResizeAll:    win32_cursor = IDC_SIZEALL; break;
		case ImGuiMouseCursor_ResizeEW:     win32_cursor = IDC_SIZEWE; break;
		case ImGuiMouseCursor_ResizeNS:     win32_cursor = IDC_SIZENS; break;
		case ImGuiMouseCursor_ResizeNESW:   win32_cursor = IDC_SIZENESW; break;
		case ImGuiMouseCursor_ResizeNWSE:   win32_cursor = IDC_SIZENWSE; break;
		}
		::SetCursor(::LoadCursor(NULL, win32_cursor));
	}
	return true;
}

// Allow compilation with old Windows SDK. MinGW doesn't have default _WIN32_WINNT/WINVER versions.
#ifndef WM_MOUSEHWHEEL
#define WM_MOUSEHWHEEL 0x020E
#endif

// Process Win32 mouse/keyboard inputs.
// You can read the io.WantCaptureMouse, io.WantCaptureKeyboard flags to tell if dear imgui wants to use your inputs.
// - When io.WantCaptureMouse is true, do not dispatch mouse input data to your main application.
// - When io.WantCaptureKeyboard is true, do not dispatch keyboard input data to your main application.
// Generally you may always pass all inputs to dear imgui, and hide them from your application based on those two flags.
// PS: In this Win32 handler, we use the capture API (GetCapture/SetCapture/ReleaseCapture) to be able to read mouse coordinations when dragging mouse outside of our window bounds.
// PS: We treat DBLCLK messages as regular mouse down messages, so this code will work on windows classes that have the CS_DBLCLKS flag set. Our own example app code doesn't set this flag.
IMGUI_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	if (ImGui::GetCurrentContext() == NULL)
		return 0;

	ImGuiIO& io = ImGui::GetIO();
	switch (msg)
	{
	case WM_LBUTTONDOWN: case WM_LBUTTONDBLCLK:
	case WM_RBUTTONDOWN: case WM_RBUTTONDBLCLK:
	case WM_MBUTTONDOWN: case WM_MBUTTONDBLCLK:
	case WM_XBUTTONDOWN: case WM_XBUTTONDBLCLK:
	{
		int button = 0;
		if (msg == WM_LBUTTONDOWN || msg == WM_LBUTTONDBLCLK) button = 0;
		if (msg == WM_RBUTTONDOWN || msg == WM_RBUTTONDBLCLK) button = 1;
		if (msg == WM_MBUTTONDOWN || msg == WM_MBUTTONDBLCLK) button = 2;
		if (msg == WM_XBUTTONDOWN || msg == WM_XBUTTONDBLCLK) button = (HIWORD(wParam) == XBUTTON1) ? 3 : 4;
		if (!ImGui::IsAnyMouseDown() && ::GetCapture() == NULL)
			::SetCapture(hwnd);
		io.MouseDown[button] = true;
		return 1;
	}
	case WM_LBUTTONUP:
	case WM_RBUTTONUP:
	case WM_MBUTTONUP:
	case WM_XBUTTONUP:
	{
		int button = 0;
		if (msg == WM_LBUTTONUP) button = 0;
		if (msg == WM_RBUTTONUP) button = 1;
		if (msg == WM_MBUTTONUP) button = 2;
		if (msg == WM_XBUTTONUP) button = (HIWORD(wParam) == XBUTTON1) ? 3 : 4;
		io.MouseDown[button] = false;
		if (!ImGui::IsAnyMouseDown() && ::GetCapture() == hwnd)
			::ReleaseCapture();
		return 1;
	}
	case WM_MOUSEWHEEL:
		io.MouseWheel += GET_WHEEL_DELTA_WPARAM(wParam) > 0 ? +1.0f : -1.0f;
		return 1;
	case WM_MOUSEMOVE:
		io.MousePos.x = (signed short)(lParam);
		io.MousePos.y = (signed short)(lParam >> 16);
		return 1;
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		if (wParam < 256)
			io.KeysDown[wParam] = 1;
		return 1;
	case WM_KEYUP:
	case WM_SYSKEYUP:
		if (wParam < 256)
			io.KeysDown[wParam] = 0;
		return 1;
	case WM_CHAR:
		// You can also use ToAscii()+GetKeyboardState() to retrieve characters.
		if (wParam > 0 && wParam < 0x10000)
			io.AddInputCharacter((unsigned short)wParam);
		return 1;
	}
	return 0;
}

bool    ImGui_ImplDX9_Init(void* hwnd, IDirect3DDevice9* device)
{
	g_hWnd = (HWND)hwnd;
	g_pd3dDevice = device;

	if (!QueryPerformanceFrequency((LARGE_INTEGER*)&g_TicksPerSecond))
		return false;

	if (!QueryPerformanceCounter((LARGE_INTEGER*)&g_Time))
		return false;

	// Setup back-end capabilities flags
	ImGuiIO& io = ImGui::GetIO();
	io.BackendFlags |= ImGuiBackendFlags_HasMouseCursors;   // We can honor GetMouseCursor() values (optional)
	io.BackendFlags |= ImGuiBackendFlags_HasSetMousePos;    // We can honor io.WantSetMousePos requests (optional, rarely used)

															// Keyboard mapping. ImGui will use those indices to peek into the io.KeyDown[] array that we will update during the application lifetime.
	io.KeyMap[ImGuiKey_Tab] = VK_TAB;
	io.KeyMap[ImGuiKey_LeftArrow] = VK_LEFT;
	io.KeyMap[ImGuiKey_RightArrow] = VK_RIGHT;
	io.KeyMap[ImGuiKey_UpArrow] = VK_UP;
	io.KeyMap[ImGuiKey_DownArrow] = VK_DOWN;
	io.KeyMap[ImGuiKey_PageUp] = VK_PRIOR;
	io.KeyMap[ImGuiKey_PageDown] = VK_NEXT;
	io.KeyMap[ImGuiKey_Home] = VK_HOME;
	io.KeyMap[ImGuiKey_End] = VK_END;
	io.KeyMap[ImGuiKey_Insert] = VK_INSERT;
	io.KeyMap[ImGuiKey_Delete] = VK_DELETE;
	io.KeyMap[ImGuiKey_Backspace] = VK_BACK;
	io.KeyMap[ImGuiKey_Space] = VK_SPACE;
	io.KeyMap[ImGuiKey_Enter] = VK_RETURN;
	io.KeyMap[ImGuiKey_Escape] = VK_ESCAPE;
	io.KeyMap[ImGuiKey_A] = 'A';
	io.KeyMap[ImGuiKey_C] = 'C';
	io.KeyMap[ImGuiKey_V] = 'V';
	io.KeyMap[ImGuiKey_X] = 'X';
	io.KeyMap[ImGuiKey_Y] = 'Y';
	io.KeyMap[ImGuiKey_Z] = 'Z';

	io.ImeWindowHandle = g_hWnd;

	return true;
}

void ImGui_ImplDX9_Shutdown()
{
	ImGui_ImplDX9_InvalidateDeviceObjects();
	g_pd3dDevice = NULL;
	g_hWnd = 0;
}

static bool ImGui_ImplDX9_CreateFontsTexture()
{
	// Build texture atlas
	ImGuiIO& io = ImGui::GetIO();
	unsigned char* pixels;
	int width, height, bytes_per_pixel;
	io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height, &bytes_per_pixel);

	// Upload texture to graphics system
	g_FontTexture = NULL;
	if (g_pd3dDevice->CreateTexture(width, height, 1, D3DUSAGE_DYNAMIC, D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &g_FontTexture, NULL) < 0)
		return false;
	D3DLOCKED_RECT tex_locked_rect;
	if (g_FontTexture->LockRect(0, &tex_locked_rect, NULL, 0) != D3D_OK)
		return false;
	for (int y = 0; y < height; y++)
		memcpy((unsigned char*)tex_locked_rect.pBits + tex_locked_rect.Pitch * y, pixels + (width * bytes_per_pixel) * y, (width * bytes_per_pixel));
	g_FontTexture->UnlockRect(0);

	// Store our identifier
	io.Fonts->TexID = (void*)g_FontTexture;

	return true;
}

bool ImGui_ImplDX9_CreateDeviceObjects()
{
	if (!g_pd3dDevice)
		return false;
	if (!ImGui_ImplDX9_CreateFontsTexture())
		return false;
	return true;
}

void ImGui_ImplDX9_InvalidateDeviceObjects()
{
	if (!g_pd3dDevice)
		return;
	if (g_pVB)
	{
		g_pVB->Release();
		g_pVB = NULL;
	}
	if (g_pIB)
	{
		g_pIB->Release();
		g_pIB = NULL;
	}

	// At this point note that we set ImGui::GetIO().Fonts->TexID to be == g_FontTexture, so clear both.
	ImGuiIO& io = ImGui::GetIO();
	IM_ASSERT(g_FontTexture == io.Fonts->TexID);
	if (g_FontTexture)
		g_FontTexture->Release();
	g_FontTexture = NULL;
	io.Fonts->TexID = NULL;
}

void ImGui_ImplDX9_NewFrame()
{
	if (!g_FontTexture)
		ImGui_ImplDX9_CreateDeviceObjects();

	ImGuiIO& io = ImGui::GetIO();

	// Setup display size (every frame to accommodate for window resizing)
	RECT rect;
	GetClientRect(g_hWnd, &rect);
	io.DisplaySize = ImVec2((float)(rect.right - rect.left), (float)(rect.bottom - rect.top));

	// Setup time step
	INT64 current_time;
	QueryPerformanceCounter((LARGE_INTEGER*)&current_time);
	io.DeltaTime = (float)(current_time - g_Time) / g_TicksPerSecond;
	g_Time = current_time;

	// Read keyboard modifiers inputs
	io.KeyCtrl = (GetKeyState(VK_CONTROL) & 0x8000) != 0;
	io.KeyShift = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
	io.KeyAlt = (GetKeyState(VK_MENU) & 0x8000) != 0;
	io.KeySuper = false;
	// io.KeysDown : filled by WM_KEYDOWN/WM_KEYUP events
	// io.MousePos : filled by WM_MOUSEMOVE events
	// io.MouseDown : filled by WM_*BUTTON* events
	// io.MouseWheel : filled by WM_MOUSEWHEEL events

	// Set OS mouse position if requested (only used when ImGuiConfigFlags_NavEnableSetMousePos is enabled by user)
	if (io.WantSetMousePos)
	{
		POINT pos = { (int)io.MousePos.x, (int)io.MousePos.y };
		ClientToScreen(g_hWnd, &pos);
		SetCursorPos(pos.x, pos.y);
	}

	// Update OS mouse cursor with the cursor requested by imgui
	ImGuiMouseCursor mouse_cursor = io.MouseDrawCursor ? ImGuiMouseCursor_None : ImGui::GetMouseCursor();
	if (g_LastMouseCursor != mouse_cursor)
	{
		g_LastMouseCursor = mouse_cursor;
		ImGui_ImplWin32_UpdateMouseCursor();
	}

	// Start the frame. This call will update the io.WantCaptureMouse, io.WantCaptureKeyboard flag that you can use to dispatch inputs (or not) to your application.
	ImGui::NewFrame();
}
```

`src/imgui/directx9/imgui_impl_dx9.h`:

```h
// ImGui Win32 + DirectX9 binding

// Implemented features:
//  [X] User texture binding. Use 'LPDIRECT3DTEXTURE9' as ImTextureID. Read the FAQ about ImTextureID in imgui.cpp.

// You can copy and use unmodified imgui_impl_* files in your project. See main.cpp for an example of using this.
// If you use this binding you'll need to call 4 functions: ImGui_ImplXXXX_Init(), ImGui_ImplXXXX_NewFrame(), ImGui::Render() and ImGui_ImplXXXX_Shutdown().
// If you are new to ImGui, see examples/README.txt and documentation at the top of imgui.cpp.
// https://github.com/ocornut/imgui

#include <d3d9.h>

struct IDirect3DDevice9;

IMGUI_API bool        ImGui_ImplDX9_Init(void* hwnd, IDirect3DDevice9* device);
IMGUI_API void        ImGui_ImplDX9_Shutdown();
IMGUI_API void        ImGui_ImplDX9_NewFrame();
IMGUI_API void        ImGui_ImplDX9_RenderDrawData(ImDrawData* draw_data, ImDrawList* draw_list = nullptr);

// Use if you want to reset your rendering device without losing ImGui state.
IMGUI_API void        ImGui_ImplDX9_InvalidateDeviceObjects();
IMGUI_API bool        ImGui_ImplDX9_CreateDeviceObjects();

// Handler for Win32 messages, update mouse/keyboard data.
// You may or not need this for your implementation, but it can serve as reference for handling inputs.
// Commented out to avoid dragging dependencies on <windows.h> types. You can copy the extern declaration in your code.
#include <Windows.h>
IMGUI_API LRESULT   ImGui_ImplWin32_WndProcHandler(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

```

`src/imgui/imgui.cpp`:

```cpp
// dear imgui, v1.60
// (main code and documentation)

// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.
// Newcomers, read 'Programmer guide' below for notes on how to setup Dear ImGui in your codebase.
// Get latest version at https://github.com/ocornut/imgui
// Releases change-log at https://github.com/ocornut/imgui/releases
// Gallery (please post your screenshots/video there!): https://github.com/ocornut/imgui/issues/1269
// Developed by Omar Cornut and every direct or indirect contributors to the GitHub.
// This library is free but I need your support to sustain development and maintenance.
// If you work for a company, please consider financial support, see README. For individuals: https://www.patreon.com/imgui

// It is recommended that you don't modify imgui.cpp! It will become difficult for you to update the library.
// Note that 'ImGui::' being a namespace, you can add functions into the namespace from your own source files, without
// modifying imgui.h or imgui.cpp. You may include imgui_internal.h to access internal data structures, but it doesn't
// come with any guarantee of forward compatibility. Discussing your changes on the GitHub Issue Tracker may lead you
// to a better solution or official support for them.

/*

Index
- MISSION STATEMENT
- END-USER GUIDE
- PROGRAMMER GUIDE (read me!)
- Read first
- How to update to a newer version of Dear ImGui
- Getting started with integrating Dear ImGui in your code/engine
- Using gamepad/keyboard navigation controls [BETA]
- API BREAKING CHANGES (read me when you update!)
- ISSUES & TODO LIST
- FREQUENTLY ASKED QUESTIONS (FAQ), TIPS
- How can I tell whether to dispatch mouse/keyboard to imgui or to my application?
- How can I display an image? What is ImTextureID, how does it works?
- How can I have multiple widgets with the same label or without a label? A primer on labels and the ID Stack.
- How can I load a different font than the default?
- How can I easily use icons in my application?
- How can I load multiple fonts?
- How can I display and input non-latin characters such as Chinese, Japanese, Korean, Cyrillic?
- How can I use the drawing facilities without an ImGui window? (using ImDrawList API)
- I integrated Dear ImGui in my engine and the text or lines are blurry..
- I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..
- How can I help?
- ISSUES & TODO-LIST
- CODE

MISSION STATEMENT
=================

- Easy to use to create code-driven and data-driven tools
- Easy to use to create ad hoc short-lived tools and long-lived, more elaborate tools
- Easy to hack and improve
- Minimize screen real-estate usage
- Minimize setup and maintenance
- Minimize state storage on user side
- Portable, minimize dependencies, run on target (consoles, phones, etc.)
- Efficient runtime and memory consumption (NB- we do allocate when "growing" content e.g. creating a window,
opening a tree node for the first time, etc. but a typical frame should not allocate anything)

Designed for developers and content-creators, not the typical end-user! Some of the weaknesses includes:
- Doesn't look fancy, doesn't animate
- Limited layout features, intricate layouts are typically crafted in code

END-USER GUIDE
==============

- Double-click on title bar to collapse window.
- Click upper right corner to close a window, available when 'bool* p_open' is passed to ImGui::Begin().
- Click and drag on lower right corner to resize window (double-click to auto fit window to its contents).
- Click and drag on any empty space to move window.
- TAB/SHIFT+TAB to cycle through keyboard editable fields.
- CTRL+Click on a slider or drag box to input value as text.
- Use mouse wheel to scroll.
- Text editor:
- Hold SHIFT or use mouse to select text.
- CTRL+Left/Right to word jump.
- CTRL+Shift+Left/Right to select words.
- CTRL+A our Double-Click to select all.
- CTRL+X,CTRL+C,CTRL+V to use OS clipboard/
- CTRL+Z,CTRL+Y to undo/redo.
- ESCAPE to revert text to its original value.
- You can apply arithmetic operators +,*,/ on numerical values. Use +- to subtract (because - would set a negative value!)
- Controls are automatically adjusted for OSX to match standard OSX text editing operations.
- General Keyboard controls: enable with ImGuiConfigFlags_NavEnableKeyboard.
- General Gamepad controls: enable with ImGuiConfigFlags_NavEnableGamepad. See suggested mappings in imgui.h ImGuiNavInput_ + download PNG/PSD at http://goo.gl/9LgVZW

PROGRAMMER GUIDE
================

READ FIRST

- Read the FAQ below this section!
- Your code creates the UI, if your code doesn't run the UI is gone! The UI can be highly dynamic, there are no construction
or destruction steps, less data retention on your side, less state duplication, less state synchronization, less bugs.
- Call and read ImGui::ShowDemoWindow() for demo code demonstrating most features.
- You can learn about immediate-mode gui principles at http://www.johno.se/book/imgui.html or watch http://mollyrocket.com/861

HOW TO UPDATE TO A NEWER VERSION OF DEAR IMGUI

- Overwrite all the sources files except for imconfig.h (if you have made modification to your copy of imconfig.h)
- Read the "API BREAKING CHANGES" section (below). This is where we list occasional API breaking changes.
If a function/type has been renamed / or marked obsolete, try to fix the name in your code before it is permanently removed
from the public API. If you have a problem with a missing function/symbols, search for its name in the code, there will
likely be a comment about it. Please report any issue to the GitHub page!
- Try to keep your copy of dear imgui reasonably up to date.

GETTING STARTED WITH INTEGRATING DEAR IMGUI IN YOUR CODE/ENGINE

- Run and study the examples and demo to get acquainted with the library.
- Add the Dear ImGui source files to your projects, using your preferred build system.
It is recommended you build the .cpp files as part of your project and not as a library.
- You can later customize the imconfig.h file to tweak some compilation time behavior, such as integrating imgui types with your own maths types.
- You may be able to grab and copy a ready made imgui_impl_*** file from the examples/ folder.
- When using Dear ImGui, your programming IDE is your friend: follow the declaration of variables, functions and types to find comments about them.

- Init: retrieve the ImGuiIO structure with ImGui::GetIO() and fill the fields marked 'Settings': at minimum you need to set io.DisplaySize
(application resolution). Later on you will fill your keyboard mapping, clipboard handlers, and other advanced features but for a basic
integration you don't need to worry about it all.
- Init: call io.Fonts->GetTexDataAsRGBA32(...), it will build the font atlas texture, then load the texture pixels into graphics memory.
- Every frame:
- In your main loop as early a possible, fill the IO fields marked 'Input' (e.g. mouse position, buttons, keyboard info, etc.)
- Call ImGui::NewFrame() to begin the frame
- You can use any ImGui function you want between NewFrame() and Render()
- Call ImGui::Render() as late as you can to end the frame and finalize render data. it will call your io.RenderDrawListFn handler.
(Even if you don't render, call Render() and ignore the callback, or call EndFrame() instead. Otherwhise some features will break)
- All rendering information are stored into command-lists until ImGui::Render() is called.
- Dear ImGui never touches or knows about your GPU state. the only function that knows about GPU is the RenderDrawListFn handler that you provide.
- Effectively it means you can create widgets at any time in your code, regardless of considerations of being in "update" vs "render" phases
of your own application.
- Refer to the examples applications in the examples/ folder for instruction on how to setup your code.
- A minimal application skeleton may be:

// Application init
ImGui::CreateContext();
ImGuiIO& io = ImGui::GetIO();
io.DisplaySize.x = 1920.0f;
io.DisplaySize.y = 1280.0f;
// TODO: Fill others settings of the io structure later.

// Load texture atlas (there is a default font so you don't need to care about choosing a font yet)
unsigned char* pixels;
int width, height;
io.Fonts->GetTexDataAsRGBA32(pixels, &width, &height);
// TODO: At this points you've got the texture data and you need to upload that your your graphic system:
MyTexture* texture = MyEngine::CreateTextureFromMemoryPixels(pixels, width, height, TEXTURE_TYPE_RGBA)
// TODO: Store your texture pointer/identifier (whatever your engine uses) in 'io.Fonts->TexID'. This will be passed back to your via the renderer.
io.Fonts->TexID = (void*)texture;

// Application main loop
while (true)
{
// Setup low-level inputs (e.g. on Win32, GetKeyboardState(), or write to those fields from your Windows message loop handlers, etc.)
ImGuiIO& io = ImGui::GetIO();
io.DeltaTime = 1.0f/60.0f;
io.MousePos = mouse_pos;
io.MouseDown[0] = mouse_button_0;
io.MouseDown[1] = mouse_button_1;

// Call NewFrame(), after this point you can use ImGui::* functions anytime
ImGui::NewFrame();

// Most of your application code here
MyGameUpdate(); // may use any ImGui functions, e.g. ImGui::Begin("My window"); ImGui::Text("Hello, world!"); ImGui::End();
MyGameRender(); // may use any ImGui functions as well!

// Render & swap video buffers
ImGui::Render();
MyImGuiRenderFunction(ImGui::GetDrawData());
SwapBuffers();
}

// Shutdown
ImGui::DestroyContext();

- A minimal render function skeleton may be:

void void MyRenderFunction(ImDrawData* draw_data)
{
// TODO: Setup render state: alpha-blending enabled, no face culling, no depth testing, scissor enabled
// TODO: Setup viewport, orthographic projection matrix
// TODO: Setup shader: vertex { float2 pos, float2 uv, u32 color }, fragment shader sample color from 1 texture, multiply by vertex color.
for (int n = 0; n < draw_data->CmdListsCount; n++)
{
const ImDrawVert* vtx_buffer = cmd_list->VtxBuffer.Data;  // vertex buffer generated by ImGui
const ImDrawIdx* idx_buffer = cmd_list->IdxBuffer.Data;   // index buffer generated by ImGui
for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
{
const ImDrawCmd* pcmd = &cmd_list->CmdBuffer[cmd_i];
if (pcmd->UserCallback)
{
pcmd->UserCallback(cmd_list, pcmd);
}
else
{
// The texture for the draw call is specified by pcmd->TextureId.
// The vast majority of draw calls with use the imgui texture atlas, which value you have set yourself during initialization.
MyEngineBindTexture(pcmd->TextureId);

// We are using scissoring to clip some objects. All low-level graphics API supports it.
// If your engine doesn't support scissoring yet, you may ignore this at first. You will get some small glitches
// (some elements visible outside their bounds) but you can fix that once everywhere else works!
MyEngineScissor((int)pcmd->ClipRect.x, (int)pcmd->ClipRect.y, (int)(pcmd->ClipRect.z - pcmd->ClipRect.x), (int)(pcmd->ClipRect.w - pcmd->ClipRect.y));

// Render 'pcmd->ElemCount/3' indexed triangles.
// By default the indices ImDrawIdx are 16-bits, you can change them to 32-bits if your engine doesn't support 16-bits indices.
MyEngineDrawIndexedTriangles(pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer, vtx_buffer);
}
idx_buffer += pcmd->ElemCount;
}
}
}

- The examples/ folders contains many functional implementation of the pseudo-code above.
- When calling NewFrame(), the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags are updated.
They tell you if ImGui intends to use your inputs. When a flag is set you want to hide the corresponding inputs from the rest of your application.
However, in both cases you need to pass on the inputs to imgui. Read the FAQ below for more information about those flags.
- Please read the FAQ above. Amusingly, it is called a FAQ because people frequently have the same issues!

USING GAMEPAD/KEYBOARD NAVIGATION CONTROLS [BETA]

- The gamepad/keyboard navigation is in Beta. Ask questions and report issues at https://github.com/ocornut/imgui/issues/787
- The initial focus was to support game controllers, but keyboard is becoming increasingly and decently usable.
- Gamepad:
- Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable.
- Backend: Set io.BackendFlags |= ImGuiBackendFlags_HasGamepad + fill the io.NavInputs[] fields before calling NewFrame().
Note that io.NavInputs[] is cleared by EndFrame().
- See 'enum ImGuiNavInput_' in imgui.h for a description of inputs. For each entry of io.NavInputs[], set the following values:
0.0f= not held. 1.0f= fully held. Pass intermediate 0.0f..1.0f values for analog triggers/sticks.
- We uses a simple >0.0f test for activation testing, and won't attempt to test for a dead-zone.
Your code will probably need to transform your raw inputs (such as e.g. remapping your 0.2..0.9 raw input range to 0.0..1.0 imgui range, etc.).
- You can download PNG/PSD files depicting the gamepad controls for common controllers at: goo.gl/9LgVZW.
- If you need to share inputs between your game and the imgui parts, the easiest approach is to go all-or-nothing, with a buttons combo
to toggle the target. Please reach out if you think the game vs navigation input sharing could be improved.
- Keyboard:
- Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable.
NewFrame() will automatically fill io.NavInputs[] based on your io.KeyDown[] + io.KeyMap[] arrays.
- When keyboard navigation is active (io.NavActive + ImGuiConfigFlags_NavEnableKeyboard), the io.WantCaptureKeyboard flag
will be set. For more advanced uses, you may want to read from:
- io.NavActive: true when a window is focused and it doesn't have the ImGuiWindowFlags_NoNavInputs flag set.
- io.NavVisible: true when the navigation cursor is visible (and usually goes false when mouse is used).
- or query focus information with e.g. IsWindowFocused(ImGuiFocusedFlags_AnyWindow), IsItemFocused() etc. functions.
Please reach out if you think the game vs navigation input sharing could be improved.
- Mouse:
- PS4 users: Consider emulating a mouse cursor with DualShock4 touch pad or a spare analog stick as a mouse-emulation fallback.
- Consoles/Tablet/Phone users: Consider using a Synergy 1.x server (on your PC) + uSynergy.c (on your console/tablet/phone app) to share your PC mouse/keyboard.
- On a TV/console system where readability may be lower or mouse inputs may be awkward, you may want to set the ImGuiConfigFlags_NavEnableSetMousePos flag.
Enabling ImGuiConfigFlags_NavEnableSetMousePos + ImGuiBackendFlags_HasSetMousePos instructs dear imgui to move your mouse cursor along with navigation movements.
When enabled, the NewFrame() function may alter 'io.MousePos' and set 'io.WantSetMousePos' to notify you that it wants the mouse cursor to be moved.
When that happens your back-end NEEDS to move the OS or underlying mouse cursor on the next frame. Some of the binding in examples/ do that.
(If you set the NavEnableSetMousePos flag but don't honor 'io.WantSetMousePos' properly, imgui will misbehave as it will see your mouse as moving back and forth!)
(In a setup when you may not have easy control over the mouse cursor, e.g. uSynergy.c doesn't expose moving remote mouse cursor, you may want
to set a boolean to ignore your other external mouse positions until the external source is moved again.)

API BREAKING CHANGES
====================

Occasionally introducing changes that are breaking the API. The breakage are generally minor and easy to fix.
Here is a change-log of API breaking changes, if you are using one of the functions listed, expect to have to fix some code.
Also read releases logs https://github.com/ocornut/imgui/releases for more details.

- 2018/03/20 (1.60) - Renamed io.WantMoveMouse to io.WantSetMousePos for consistency and ease of understanding (was added in 1.52, _not_ used by core and only honored by some binding ahead of merging the Nav branch).
- 2018/03/12 (1.60) - Removed ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered as the closing cross uses regular button colors now.
- 2018/03/08 (1.60) - Changed ImFont::DisplayOffset.y to default to 0 instead of +1. Fixed rounding of Ascent/Descent to match TrueType renderer. If you were adding or subtracting to ImFont::DisplayOffset check if your fonts are correctly aligned vertically.
- 2018/03/03 (1.60) - Renamed ImGuiStyleVar_Count_ to ImGuiStyleVar_COUNT and ImGuiMouseCursor_Count_ to ImGuiMouseCursor_COUNT for consistency with other public enums.
- 2018/02/18 (1.60) - BeginDragDropSource(): temporarily removed the optional mouse_button=0 parameter because it is not really usable in many situations at the moment.
- 2018/02/16 (1.60) - obsoleted the io.RenderDrawListsFn callback, you can call your graphics engine render function after ImGui::Render(). Use ImGui::GetDrawData() to retrieve the ImDrawData* to display.
- 2018/02/07 (1.60) - reorganized context handling to be more explicit,
- YOU NOW NEED TO CALL ImGui::CreateContext() AT THE BEGINNING OF YOUR APP, AND CALL ImGui::DestroyContext() AT THE END.
- removed Shutdown() function, as DestroyContext() serve this purpose.
- you may pass a ImFontAtlas* pointer to CreateContext() to share a font atlas between contexts. Otherwhise CreateContext() will create its own font atlas instance.
- removed allocator parameters from CreateContext(), they are now setup with SetAllocatorFunctions(), and shared by all contexts.
- removed the default global context and font atlas instance, which were confusing for users of DLL reloading and users of multiple contexts.
- 2018/01/31 (1.60) - moved sample TTF files from extra_fonts/ to misc/fonts/. If you loaded files directly from the imgui repo you may need to update your paths.
- 2018/01/11 (1.60) - obsoleted IsAnyWindowHovered() in favor of IsWindowHovered(ImGuiHoveredFlags_AnyWindow). Kept redirection function (will obsolete).
- 2018/01/11 (1.60) - obsoleted IsAnyWindowFocused() in favor of IsWindowFocused(ImGuiFocusedFlags_AnyWindow). Kept redirection function (will obsolete).
- 2018/01/03 (1.60) - renamed ImGuiSizeConstraintCallback to ImGuiSizeCallback, ImGuiSizeConstraintCallbackData to ImGuiSizeCallbackData.
- 2017/12/29 (1.60) - removed CalcItemRectClosestPoint() which was weird and not really used by anyone except demo code. If you need it it's easy to replicate on your side.
- 2017/12/24 (1.53) - renamed the emblematic ShowTestWindow() function to ShowDemoWindow(). Kept redirection function (will obsolete).
- 2017/12/21 (1.53) - ImDrawList: renamed style.AntiAliasedShapes to style.AntiAliasedFill for consistency and as a way to explicitly break code that manipulate those flag at runtime. You can now manipulate ImDrawList::Flags
- 2017/12/21 (1.53) - ImDrawList: removed 'bool anti_aliased = true' final parameter of ImDrawList::AddPolyline() and ImDrawList::AddConvexPolyFilled(). Prefer manipulating ImDrawList::Flags if you need to toggle them during the frame.
- 2017/12/14 (1.53) - using the ImGuiWindowFlags_NoScrollWithMouse flag on a child window forwards the mouse wheel event to the parent window, unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set.
- 2017/12/13 (1.53) - renamed GetItemsLineHeightWithSpacing() to GetFrameHeightWithSpacing(). Kept redirection function (will obsolete).
- 2017/12/13 (1.53) - obsoleted IsRootWindowFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootWindow). Kept redirection function (will obsolete).
- obsoleted IsRootWindowOrAnyChildFocused() in favor of using IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows). Kept redirection function (will obsolete).
- 2017/12/12 (1.53) - renamed ImGuiTreeNodeFlags_AllowOverlapMode to ImGuiTreeNodeFlags_AllowItemOverlap. Kept redirection enum (will obsolete).
- 2017/12/10 (1.53) - removed SetNextWindowContentWidth(), prefer using SetNextWindowContentSize(). Kept redirection function (will obsolete).
- 2017/11/27 (1.53) - renamed ImGuiTextBuffer::append() helper to appendf(), appendv() to appendfv(). If you copied the 'Log' demo in your code, it uses appendv() so that needs to be renamed.
- 2017/11/18 (1.53) - Style, Begin: removed ImGuiWindowFlags_ShowBorders window flag. Borders are now fully set up in the ImGuiStyle structure (see e.g. style.FrameBorderSize, style.WindowBorderSize). Use ImGui::ShowStyleEditor() to look them up.
Please note that the style system will keep evolving (hopefully stabilizing in Q1 2018), and so custom styles will probably subtly break over time. It is recommended you use the StyleColorsClassic(), StyleColorsDark(), StyleColorsLight() functions.
- 2017/11/18 (1.53) - Style: removed ImGuiCol_ComboBg in favor of combo boxes using ImGuiCol_PopupBg for consistency.
- 2017/11/18 (1.53) - Style: renamed ImGuiCol_ChildWindowBg to ImGuiCol_ChildBg.
- 2017/11/18 (1.53) - Style: renamed style.ChildWindowRounding to style.ChildRounding, ImGuiStyleVar_ChildWindowRounding to ImGuiStyleVar_ChildRounding.
- 2017/11/02 (1.53) - obsoleted IsRootWindowOrAnyChildHovered() in favor of using IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows);
- 2017/10/24 (1.52) - renamed IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCS to IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS/IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS for consistency.
- 2017/10/20 (1.52) - changed IsWindowHovered() default parameters behavior to return false if an item is active in another window (e.g. click-dragging item from another window to this window). You can use the newly introduced IsWindowHovered() flags to requests this specific behavior if you need it.
- 2017/10/20 (1.52) - marked IsItemHoveredRect()/IsMouseHoveringWindow() as obsolete, in favor of using the newly introduced flags for IsItemHovered() and IsWindowHovered(). See https://github.com/ocornut/imgui/issues/1382 for details.
removed the IsItemRectHovered()/IsWindowRectHovered() names introduced in 1.51 since they were merely more consistent names for the two functions we are now obsoleting.
- 2017/10/17 (1.52) - marked the old 5-parameters version of Begin() as obsolete (still available). Use SetNextWindowSize()+Begin() instead!
- 2017/10/11 (1.52) - renamed AlignFirstTextHeightToWidgets() to AlignTextToFramePadding(). Kept inline redirection function (will obsolete).
- 2017/09/25 (1.52) - removed SetNextWindowPosCenter() because SetNextWindowPos() now has the optional pivot information to do the same and more. Kept redirection function (will obsolete).
- 2017/08/25 (1.52) - io.MousePos needs to be set to ImVec2(-FLT_MAX,-FLT_MAX) when mouse is unavailable/missing. Previously ImVec2(-1,-1) was enough but we now accept negative mouse coordinates. In your binding if you need to support unavailable mouse, make sure to replace "io.MousePos = ImVec2(-1,-1)" with "io.MousePos = ImVec2(-FLT_MAX,-FLT_MAX)".
- 2017/08/22 (1.51) - renamed IsItemHoveredRect() to IsItemRectHovered(). Kept inline redirection function (will obsolete). -> (1.52) use IsItemHovered(ImGuiHoveredFlags_RectOnly)!
- renamed IsMouseHoveringAnyWindow() to IsAnyWindowHovered() for consistency. Kept inline redirection function (will obsolete).
- renamed IsMouseHoveringWindow() to IsWindowRectHovered() for consistency. Kept inline redirection function (will obsolete).
- 2017/08/20 (1.51) - renamed GetStyleColName() to GetStyleColorName() for consistency.
- 2017/08/20 (1.51) - added PushStyleColor(ImGuiCol idx, ImU32 col) overload, which _might_ cause an "ambiguous call" compilation error if you are using ImColor() with implicit cast. Cast to ImU32 or ImVec4 explicily to fix.
- 2017/08/15 (1.51) - marked the weird IMGUI_ONCE_UPON_A_FRAME helper macro as obsolete. prefer using the more explicit ImGuiOnceUponAFrame.
- 2017/08/15 (1.51) - changed parameter order for BeginPopupContextWindow() from (const char*,int buttons,bool also_over_items) to (const char*,int buttons,bool also_over_items). Note that most calls relied on default parameters completely.
- 2017/08/13 (1.51) - renamed ImGuiCol_Columns*** to ImGuiCol_Separator***. Kept redirection enums (will obsolete).
- 2017/08/11 (1.51) - renamed ImGuiSetCond_*** types and flags to ImGuiCond_***. Kept redirection enums (will obsolete).
- 2017/08/09 (1.51) - removed ValueColor() helpers, they are equivalent to calling Text(label) + SameLine() + ColorButton().
- 2017/08/08 (1.51) - removed ColorEditMode() and ImGuiColorEditMode in favor of ImGuiColorEditFlags and parameters to the various Color*() functions. The SetColorEditOptions() allows to initialize default but the user can still change them with right-click context menu.
- changed prototype of 'ColorEdit4(const char* label, float col[4], bool show_alpha = true)' to 'ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0)', where passing flags = 0x01 is a safe no-op (hello dodgy backward compatibility!). - check and run the demo window, under "Color/Picker Widgets", to understand the various new options.
- changed prototype of rarely used 'ColorButton(ImVec4 col, bool small_height = false, bool outline_border = true)' to 'ColorButton(const char* desc_id, ImVec4 col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0,0))'
- 2017/07/20 (1.51) - removed IsPosHoveringAnyWindow(ImVec2), which was partly broken and misleading. ASSERT + redirect user to io.WantCaptureMouse
- 2017/05/26 (1.50) - removed ImFontConfig::MergeGlyphCenterV in favor of a more multipurpose ImFontConfig::GlyphOffset.
- 2017/05/01 (1.50) - renamed ImDrawList::PathFill() (rarely used directly) to ImDrawList::PathFillConvex() for clarity.
- 2016/11/06 (1.50) - BeginChild(const char*) now applies the stack id to the provided label, consistently with other functions as it should always have been. It shouldn't affect you unless (extremely unlikely) you were appending multiple times to a same child from different locations of the stack id. If that's the case, generate an id with GetId() and use it instead of passing string to BeginChild().
- 2016/10/15 (1.50) - avoid 'void* user_data' parameter to io.SetClipboardTextFn/io.GetClipboardTextFn pointers. We pass io.ClipboardUserData to it.
- 2016/09/25 (1.50) - style.WindowTitleAlign is now a ImVec2 (ImGuiAlign enum was removed). set to (0.5f,0.5f) for horizontal+vertical centering, (0.0f,0.0f) for upper-left, etc.
- 2016/07/30 (1.50) - SameLine(x) with x>0.0f is now relative to left of column/group if any, and not always to left of window. This was sort of always the intent and hopefully breakage should be minimal.
- 2016/05/12 (1.49) - title bar (using ImGuiCol_TitleBg/ImGuiCol_TitleBgActive colors) isn't rendered over a window background (ImGuiCol_WindowBg color) anymore.
If your TitleBg/TitleBgActive alpha was 1.0f or you are using the default theme it will not affect you.
However if your TitleBg/TitleBgActive alpha was <1.0f you need to tweak your custom theme to readjust for the fact that we don't draw a WindowBg background behind the title bar.
This helper function will convert an old TitleBg/TitleBgActive color into a new one with the same visual output, given the OLD color and the OLD WindowBg color.
ImVec4 ConvertTitleBgCol(const ImVec4& win_bg_col, const ImVec4& title_bg_col)
{
float new_a = 1.0f - ((1.0f - win_bg_col.w) * (1.0f - title_bg_col.w)), k = title_bg_col.w / new_a;
return ImVec4((win_bg_col.x * win_bg_col.w + title_bg_col.x) * k, (win_bg_col.y * win_bg_col.w + title_bg_col.y) * k, (win_bg_col.z * win_bg_col.w + title_bg_col.z) * k, new_a);
}
If this is confusing, pick the RGB value from title bar from an old screenshot and apply this as TitleBg/TitleBgActive. Or you may just create TitleBgActive from a tweaked TitleBg color.
- 2016/05/07 (1.49) - removed confusing set of GetInternalState(), GetInternalStateSize(), SetInternalState() functions. Now using CreateContext(), DestroyContext(), GetCurrentContext(), SetCurrentContext().
- 2016/05/02 (1.49) - renamed SetNextTreeNodeOpened() to SetNextTreeNodeOpen(), no redirection.
- 2016/05/01 (1.49) - obsoleted old signature of CollapsingHeader(const char* label, const char* str_id = NULL, bool display_frame = true, bool default_open = false) as extra parameters were badly designed and rarely used. You can replace the "default_open = true" flag in new API with CollapsingHeader(label, ImGuiTreeNodeFlags_DefaultOpen).
- 2016/04/26 (1.49) - changed ImDrawList::PushClipRect(ImVec4 rect) to ImDraw::PushClipRect(Imvec2 min,ImVec2 max,bool intersect_with_current_clip_rect=false). Note that higher-level ImGui::PushClipRect() is preferable because it will clip at logic/widget level, whereas ImDrawList::PushClipRect() only affect your renderer.
- 2016/04/03 (1.48) - removed style.WindowFillAlphaDefault setting which was redundant. Bake default BG alpha inside style.Colors[ImGuiCol_WindowBg] and all other Bg color values. (ref github issue #337).
- 2016/04/03 (1.48) - renamed ImGuiCol_TooltipBg to ImGuiCol_PopupBg, used by popups/menus and tooltips. popups/menus were previously using ImGuiCol_WindowBg. (ref github issue #337)
- 2016/03/21 (1.48) - renamed GetWindowFont() to GetFont(), GetWindowFontSize() to GetFontSize(). Kept inline redirection function (will obsolete).
- 2016/03/02 (1.48) - InputText() completion/history/always callbacks: if you modify the text buffer manually (without using DeleteChars()/InsertChars() helper) you need to maintain the BufTextLen field. added an assert.
- 2016/01/23 (1.48) - fixed not honoring exact width passed to PushItemWidth(), previously it would add extra FramePadding.x*2 over that width. if you had manual pixel-perfect alignment in place it might affect you.
- 2015/12/27 (1.48) - fixed ImDrawList::AddRect() which used to render a rectangle 1 px too large on each axis.
- 2015/12/04 (1.47) - renamed Color() helpers to ValueColor() - dangerously named, rarely used and probably to be made obsolete.
- 2015/08/29 (1.45) - with the addition of horizontal scrollbar we made various fixes to inconsistencies with dealing with cursor position.
GetCursorPos()/SetCursorPos() functions now include the scrolled amount. It shouldn't affect the majority of users, but take note that SetCursorPosX(100.0f) puts you at +100 from the starting x position which may include scrolling, not at +100 from the window left side.
GetContentRegionMax()/GetWindowContentRegionMin()/GetWindowContentRegionMax() functions allow include the scrolled amount. Typically those were used in cases where no scrolling would happen so it may not be a problem, but watch out!
- 2015/08/29 (1.45) - renamed style.ScrollbarWidth to style.ScrollbarSize
- 2015/08/05 (1.44) - split imgui.cpp into extra files: imgui_demo.cpp imgui_draw.cpp imgui_internal.h that you need to add to your project.
- 2015/07/18 (1.44) - fixed angles in ImDrawList::PathArcTo(), PathArcToFast() (introduced in 1.43) being off by an extra PI for no justifiable reason
- 2015/07/14 (1.43) - add new ImFontAtlas::AddFont() API. For the old AddFont***, moved the 'font_no' parameter of ImFontAtlas::AddFont** functions to the ImFontConfig structure.
you need to render your textured triangles with bilinear filtering to benefit from sub-pixel positioning of text.
- 2015/07/08 (1.43) - switched rendering data to use indexed rendering. this is saving a fair amount of CPU/GPU and enables us to get anti-aliasing for a marginal cost.
this necessary change will break your rendering function! the fix should be very easy. sorry for that :(
- if you are using a vanilla copy of one of the imgui_impl_XXXX.cpp provided in the example, you just need to update your copy and you can ignore the rest.
- the signature of the io.RenderDrawListsFn handler has changed!
old: ImGui_XXXX_RenderDrawLists(ImDrawList** const cmd_lists, int cmd_lists_count)
new: ImGui_XXXX_RenderDrawLists(ImDrawData* draw_data).
argument:   'cmd_lists' becomes 'draw_data->CmdLists', 'cmd_lists_count' becomes 'draw_data->CmdListsCount'
ImDrawList: 'commands' becomes 'CmdBuffer', 'vtx_buffer' becomes 'VtxBuffer', 'IdxBuffer' is new.
ImDrawCmd:  'vtx_count' becomes 'ElemCount', 'clip_rect' becomes 'ClipRect', 'user_callback' becomes 'UserCallback', 'texture_id' becomes 'TextureId'.
- each ImDrawList now contains both a vertex buffer and an index buffer. For each command, render ElemCount/3 triangles using indices from the index buffer.
- if you REALLY cannot render indexed primitives, you can call the draw_data->DeIndexAllBuffers() method to de-index the buffers. This is slow and a waste of CPU/GPU. Prefer using indexed rendering!
- refer to code in the examples/ folder or ask on the GitHub if you are unsure of how to upgrade. please upgrade!
- 2015/07/10 (1.43) - changed SameLine() parameters from int to float.
- 2015/07/02 (1.42) - renamed SetScrollPosHere() to SetScrollFromCursorPos(). Kept inline redirection function (will obsolete).
- 2015/07/02 (1.42) - renamed GetScrollPosY() to GetScrollY(). Necessary to reduce confusion along with other scrolling functions, because positions (e.g. cursor position) are not equivalent to scrolling amount.
- 2015/06/14 (1.41) - changed ImageButton() default bg_col parameter from (0,0,0,1) (black) to (0,0,0,0) (transparent) - makes a difference when texture have transparence
- 2015/06/14 (1.41) - changed Selectable() API from (label, selected, size) to (label, selected, flags, size). Size override should have been rarely be used. Sorry!
- 2015/05/31 (1.40) - renamed GetWindowCollapsed() to IsWindowCollapsed() for consistency. Kept inline redirection function (will obsolete).
- 2015/05/31 (1.40) - renamed IsRectClipped() to IsRectVisible() for consistency. Note that return value is opposite! Kept inline redirection function (will obsolete).
- 2015/05/27 (1.40) - removed the third 'repeat_if_held' parameter from Button() - sorry! it was rarely used and inconsistent. Use PushButtonRepeat(true) / PopButtonRepeat() to enable repeat on desired buttons.
- 2015/05/11 (1.40) - changed BeginPopup() API, takes a string identifier instead of a bool. ImGui needs to manage the open/closed state of popups. Call OpenPopup() to actually set the "open" state of a popup. BeginPopup() returns true if the popup is opened.
- 2015/05/03 (1.40) - removed style.AutoFitPadding, using style.WindowPadding makes more sense (the default values were already the same).
- 2015/04/13 (1.38) - renamed IsClipped() to IsRectClipped(). Kept inline redirection function until 1.50.
- 2015/04/09 (1.38) - renamed ImDrawList::AddArc() to ImDrawList::AddArcFast() for compatibility with future API
- 2015/04/03 (1.38) - removed ImGuiCol_CheckHovered, ImGuiCol_CheckActive, replaced with the more general ImGuiCol_FrameBgHovered, ImGuiCol_FrameBgActive.
- 2014/04/03 (1.38) - removed support for passing -FLT_MAX..+FLT_MAX as the range for a SliderFloat(). Use DragFloat() or Inputfloat() instead.
- 2015/03/17 (1.36) - renamed GetItemBoxMin()/GetItemBoxMax()/IsMouseHoveringBox() to GetItemRectMin()/GetItemRectMax()/IsMouseHoveringRect(). Kept inline redirection function until 1.50.
- 2015/03/15 (1.36) - renamed style.TreeNodeSpacing to style.IndentSpacing, ImGuiStyleVar_TreeNodeSpacing to ImGuiStyleVar_IndentSpacing
- 2015/03/13 (1.36) - renamed GetWindowIsFocused() to IsWindowFocused(). Kept inline redirection function until 1.50.
- 2015/03/08 (1.35) - renamed style.ScrollBarWidth to style.ScrollbarWidth (casing)
- 2015/02/27 (1.34) - renamed OpenNextNode(bool) to SetNextTreeNodeOpened(bool, ImGuiSetCond). Kept inline redirection function until 1.50.
- 2015/02/27 (1.34) - renamed ImGuiSetCondition_*** to ImGuiSetCond_***, and _FirstUseThisSession becomes _Once.
- 2015/02/11 (1.32) - changed text input callback ImGuiTextEditCallback return type from void-->int. reserved for future use, return 0 for now.
- 2015/02/10 (1.32) - renamed GetItemWidth() to CalcItemWidth() to clarify its evolving behavior
- 2015/02/08 (1.31) - renamed GetTextLineSpacing() to GetTextLineHeightWithSpacing()
- 2015/02/01 (1.31) - removed IO.MemReallocFn (unused)
- 2015/01/19 (1.30) - renamed ImGuiStorage::GetIntPtr()/GetFloatPtr() to GetIntRef()/GetIntRef() because Ptr was conflicting with actual pointer storage functions.
- 2015/01/11 (1.30) - big font/image API change! now loads TTF file. allow for multiple fonts. no need for a PNG loader.
(1.30) - removed GetDefaultFontData(). uses io.Fonts->GetTextureData*() API to retrieve uncompressed pixels.
font init:  const void* png_data; unsigned int png_size; ImGui::GetDefaultFontData(NULL, NULL, &png_data, &png_size); <..Upload texture to GPU..>
became:     unsigned char* pixels; int width, height; io.Fonts->GetTexDataAsRGBA32(&pixels, &width, &height); <..Upload texture to GPU>; io.Fonts->TexId = YourTextureIdentifier;
you now more flexibility to load multiple TTF fonts and manage the texture buffer for internal needs.
it is now recommended that you sample the font texture with bilinear interpolation.
(1.30) - added texture identifier in ImDrawCmd passed to your render function (we can now render images). make sure to set io.Fonts->TexID.
(1.30) - removed IO.PixelCenterOffset (unnecessary, can be handled in user projection matrix)
(1.30) - removed ImGui::IsItemFocused() in favor of ImGui::IsItemActive() which handles all widgets
- 2014/12/10 (1.18) - removed SetNewWindowDefaultPos() in favor of new generic API SetNextWindowPos(pos, ImGuiSetCondition_FirstUseEver)
- 2014/11/28 (1.17) - moved IO.Font*** options to inside the IO.Font-> structure (FontYOffset, FontTexUvForWhite, FontBaseScale, FontFallbackGlyph)
- 2014/11/26 (1.17) - reworked syntax of IMGUI_ONCE_UPON_A_FRAME helper macro to increase compiler compatibility
- 2014/11/07 (1.15) - renamed IsHovered() to IsItemHovered()
- 2014/10/02 (1.14) - renamed IMGUI_INCLUDE_IMGUI_USER_CPP to IMGUI_INCLUDE_IMGUI_USER_INL and imgui_user.cpp to imgui_user.inl (more IDE friendly)
- 2014/09/25 (1.13) - removed 'text_end' parameter from IO.SetClipboardTextFn (the string is now always zero-terminated for simplicity)
- 2014/09/24 (1.12) - renamed SetFontScale() to SetWindowFontScale()
- 2014/09/24 (1.12) - moved IM_MALLOC/IM_REALLOC/IM_FREE preprocessor defines to IO.MemAllocFn/IO.MemReallocFn/IO.MemFreeFn
- 2014/08/30 (1.09) - removed IO.FontHeight (now computed automatically)
- 2014/08/30 (1.09) - moved IMGUI_FONT_TEX_UV_FOR_WHITE preprocessor define to IO.FontTexUvForWhite
- 2014/08/28 (1.09) - changed the behavior of IO.PixelCenterOffset following various rendering fixes

ISSUES & TODO-LIST
==================
See TODO.txt

FREQUENTLY ASKED QUESTIONS (FAQ), TIPS
======================================

Q: How can I tell whether to dispatch mouse/keyboard to imgui or to my application?
A: You can read the 'io.WantCaptureMouse', 'io.WantCaptureKeyboard' and 'io.WantTextInput' flags from the ImGuiIO structure.
- When 'io.WantCaptureMouse' is set, imgui wants to use your mouse state, and you may want to discard/hide the inputs from the rest of your application.
- When 'io.WantCaptureKeyboard' is set, imgui wants to use your keyboard state, and you may want to discard/hide the inputs from the rest of your application.
- When 'io.WantTextInput' is set to may want to notify your OS to popup an on-screen keyboard, if available (e.g. on a mobile phone, or console OS).
Note: you should always pass your mouse/keyboard inputs to imgui, even when the io.WantCaptureXXX flag are set false.
This is because imgui needs to detect that you clicked in the void to unfocus its windows.
Note: The 'io.WantCaptureMouse' is more accurate that any attempt to "check if the mouse is hovering a window" (don't do that!).
It handle mouse dragging correctly (both dragging that started over your application or over an imgui window) and handle e.g. modal windows blocking inputs.
Those flags are updated by ImGui::NewFrame(). Preferably read the flags after calling NewFrame() if you can afford it, but reading them before is also
perfectly fine, as the bool toggle fairly rarely. If you have on a touch device, you might find use for an early call to NewFrameUpdateHoveredWindowAndCaptureFlags().
Note: Text input widget releases focus on "Return KeyDown", so the subsequent "Return KeyUp" event that your application receive will typically
have 'io.WantCaptureKeyboard=false'. Depending on your application logic it may or not be inconvenient. You might want to track which key-downs
were targetted for Dear ImGui, e.g. with an array of bool, and filter out the corresponding key-ups.)

Q: How can I display an image? What is ImTextureID, how does it works?
A: ImTextureID is a void* used to pass renderer-agnostic texture references around until it hits your render function.
Dear ImGui knows nothing about what those bits represent, it just passes them around. It is up to you to decide what you want the void* to carry!
It could be an identifier to your OpenGL texture (cast GLuint to void*), a pointer to your custom engine material (cast MyMaterial* to void*), etc.
At the end of the chain, your renderer takes this void* to cast it back into whatever it needs to select a current texture to render.
Refer to examples applications, where each renderer (in a imgui_impl_xxxx.cpp file) is treating ImTextureID as a different thing.
(C++ tip: OpenGL uses integers to identify textures. You can safely store an integer into a void*, just cast it to void*, don't take it's address!)
To display a custom image/texture within an ImGui window, you may use ImGui::Image(), ImGui::ImageButton(), ImDrawList::AddImage() functions.
Dear ImGui will generate the geometry and draw calls using the ImTextureID that you passed and which your renderer can use.
You may call ImGui::ShowMetricsWindow() to explore active draw lists and visualize/understand how the draw data is generated.
It is your responsibility to get textures uploaded to your GPU.

Q: How can I have multiple widgets with the same label or without a label?
A: A primer on labels and the ID Stack...

- Elements that are typically not clickable, such as Text() items don't need an ID.

- Interactive widgets require state to be carried over multiple frames (most typically Dear ImGui
often needs to remember what is the "active" widget). To do so they need a unique ID. Unique ID
are typically derived from a string label, an integer index or a pointer.

Button("OK");          // Label = "OK",     ID = top of id stack + hash of "OK"
Button("Cancel");      // Label = "Cancel", ID = top of id stack + hash of "Cancel"

- ID are uniquely scoped within windows, tree nodes, etc. which all pushes to the ID stack. Having
two buttons labeled "OK" in different windows or different tree locations is fine.

- If you have a same ID twice in the same location, you'll have a conflict:

Button("OK");
Button("OK");          // ID collision! Interacting with either button will trigger the first one.

Fear not! this is easy to solve and there are many ways to solve it!

- Solving ID conflict in a simple/local context:
When passing a label you can optionally specify extra ID information within string itself.
Use "##" to pass a complement to the ID that won't be visible to the end-user.
This helps solving the simple collision cases when you know e.g. at compilation time which items
are going to be created:

Button("Play");        // Label = "Play",   ID = top of id stack + hash of "Play"
Button("Play##foo1");  // Label = "Play",   ID = top of id stack + hash of "Play##foo1" (different from above)
Button("Play##foo2");  // Label = "Play",   ID = top of id stack + hash of "Play##foo2" (different from above)

- If you want to completely hide the label, but still need an ID:

Checkbox("##On", &b);  // Label = "",       ID = top of id stack + hash of "##On" (no label!)

- Occasionally/rarely you might want change a label while preserving a constant ID. This allows
you to animate labels. For example you may want to include varying information in a window title bar,
but windows are uniquely identified by their ID. Use "###" to pass a label that isn't part of ID:

Button("Hello###ID";   // Label = "Hello",  ID = top of id stack + hash of "ID"
Button("World###ID";   // Label = "World",  ID = top of id stack + hash of "ID" (same as above)

sprintf(buf, "My game (%f FPS)###MyGame", fps);
Begin(buf);            // Variable label,   ID = hash of "MyGame"

- Solving ID conflict in a more general manner:
Use PushID() / PopID() to create scopes and manipulate the ID stack, as to avoid ID conflicts
within the same window. This is the most convenient way of distinguishing ID when iterating and
creating many UI elements programmatically.
You can push a pointer, a string or an integer value into the ID stack.
Remember that ID are formed from the concatenation of _everything_ in the ID stack!

for (int i = 0; i < 100; i++)
{
PushID(i);
Button("Click");   // Label = "Click",  ID = top of id stack + hash of integer + hash of "Click"
PopID();
}

for (int i = 0; i < 100; i++)
{
MyObject* obj = Objects[i];
PushID(obj);
Button("Click");   // Label = "Click",  ID = top of id stack + hash of pointer + hash of "Click"
PopID();
}

for (int i = 0; i < 100; i++)
{
MyObject* obj = Objects[i];
PushID(obj->Name);
Button("Click");   // Label = "Click",  ID = top of id stack + hash of string + hash of "Click"
PopID();
}

- More example showing that you can stack multiple prefixes into the ID stack:

Button("Click");     // Label = "Click",  ID = top of id stack + hash of "Click"
PushID("node");
Button("Click");     // Label = "Click",  ID = top of id stack + hash of "node" + hash of "Click"
PushID(my_ptr);
Button("Click"); // Label = "Click",  ID = top of id stack + hash of "node" + hash of ptr + hash of "Click"
PopID();
PopID();

- Tree nodes implicitly creates a scope for you by calling PushID().

Button("Click");     // Label = "Click",  ID = top of id stack + hash of "Click"
if (TreeNode("node"))
{
Button("Click");   // Label = "Click",  ID = top of id stack + hash of "node" + hash of "Click"
TreePop();
}

- When working with trees, ID are used to preserve the open/close state of each tree node.
Depending on your use cases you may want to use strings, indices or pointers as ID.
e.g. when following a single pointer that may change over time, using a static string as ID
will preserve your node open/closed state when the targeted object change.
e.g. when displaying a list of objects, using indices or pointers as ID will preserve the
node open/closed state differently. See what makes more sense in your situation!

Q: How can I load a different font than the default?
A: Use the font atlas to load the TTF/OTF file you want:
ImGuiIO& io = ImGui::GetIO();
io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);
io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()
(default is ProggyClean.ttf, rendered at size 13, embedded in dear imgui's source code)

New programmers: remember that in C/C++ and most programming languages if you want to use a
backslash \ within a string literal, you need to write it double backslash "\\":
io.Fonts->AddFontFromFileTTF("MyDataFolder\MyFontFile.ttf", size_in_pixels);   // WRONG (you are escape the M here!)
io.Fonts->AddFontFromFileTTF("MyDataFolder\\MyFontFile.ttf", size_in_pixels);  // CORRECT
io.Fonts->AddFontFromFileTTF("MyDataFolder/MyFontFile.ttf", size_in_pixels);   // ALSO CORRECT

Q: How can I easily use icons in my application?
A: The most convenient and practical way is to merge an icon font such as FontAwesome inside you
main font. Then you can refer to icons within your strings. Read 'How can I load multiple fonts?'
and the file 'misc/fonts/README.txt' for instructions and useful header files.

Q: How can I load multiple fonts?
A: Use the font atlas to pack them into a single texture:
(Read misc/fonts/README.txt and the code in ImFontAtlas for more details.)

ImGuiIO& io = ImGui::GetIO();
ImFont* font0 = io.Fonts->AddFontDefault();
ImFont* font1 = io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels);
ImFont* font2 = io.Fonts->AddFontFromFileTTF("myfontfile2.ttf", size_in_pixels);
io.Fonts->GetTexDataAsRGBA32() or GetTexDataAsAlpha8()
// the first loaded font gets used by default
// use ImGui::PushFont()/ImGui::PopFont() to change the font at runtime

// Options
ImFontConfig config;
config.OversampleH = 3;
config.OversampleV = 1;
config.GlyphOffset.y -= 2.0f;      // Move everything by 2 pixels up
config.GlyphExtraSpacing.x = 1.0f; // Increase spacing between characters
io.Fonts->LoadFromFileTTF("myfontfile.ttf", size_pixels, &config);

// Combine multiple fonts into one (e.g. for icon fonts)
ImWchar ranges[] = { 0xf000, 0xf3ff, 0 };
ImFontConfig config;
config.MergeMode = true;
io.Fonts->AddFontDefault();
io.Fonts->LoadFromFileTTF("fontawesome-webfont.ttf", 16.0f, &config, ranges); // Merge icon font
io.Fonts->LoadFromFileTTF("myfontfile.ttf", size_pixels, NULL, &config, io.Fonts->GetGlyphRangesJapanese()); // Merge japanese glyphs

Q: How can I display and input non-Latin characters such as Chinese, Japanese, Korean, Cyrillic?
A: When loading a font, pass custom Unicode ranges to specify the glyphs to load.

// Add default Japanese ranges
io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, io.Fonts->GetGlyphRangesJapanese());

// Or create your own custom ranges (e.g. for a game you can feed your entire game script and only build the characters the game need)
ImVector<ImWchar> ranges;
ImFontAtlas::GlyphRangesBuilder builder;
builder.AddText("Hello world");                        // Add a string (here "Hello world" contains 7 unique characters)
builder.AddChar(0x7262);                               // Add a specific character
builder.AddRanges(io.Fonts->GetGlyphRangesJapanese()); // Add one of the default ranges
builder.BuildRanges(&ranges);                          // Build the final result (ordered ranges with all the unique characters submitted)
io.Fonts->AddFontFromFileTTF("myfontfile.ttf", size_in_pixels, NULL, ranges.Data);

All your strings needs to use UTF-8 encoding. In C++11 you can encode a string literal in UTF-8
by using the u8"hello" syntax. Specifying literal in your source code using a local code page
(such as CP-923 for Japanese or CP-1251 for Cyrillic) will NOT work!
Otherwise you can convert yourself to UTF-8 or load text data from file already saved as UTF-8.

Text input: it is up to your application to pass the right character code by calling
io.AddInputCharacter(). The applications in examples/ are doing that. For languages relying
on an Input Method Editor (IME), on Windows you can copy the Hwnd of your application in the
io.ImeWindowHandle field. The default implementation of io.ImeSetInputScreenPosFn() will set
your Microsoft IME position correctly.

Q: How can I use the drawing facilities without an ImGui window? (using ImDrawList API)
A: - You can create a dummy window. Call SetNextWindowBgAlpha(0.0f), call Begin() with NoTitleBar|NoResize|NoMove|NoScrollbar|NoSavedSettings|NoInputs flags.
Then you can retrieve the ImDrawList* via GetWindowDrawList() and draw to it in any way you like.
- You can call ImGui::GetOverlayDrawList() and use this draw list to display contents over every other imgui windows.
- You can create your own ImDrawList instance. You'll need to initialize them ImGui::GetDrawListSharedData(), or create your own ImDrawListSharedData.

Q: I integrated Dear ImGui in my engine and the text or lines are blurry..
A: In your Render function, try translating your projection matrix by (0.5f,0.5f) or (0.375f,0.375f).
Also make sure your orthographic projection matrix and io.DisplaySize matches your actual framebuffer dimension.

Q: I integrated Dear ImGui in my engine and some elements are clipping or disappearing when I move windows around..
A: You are probably mishandling the clipping rectangles in your render function.
Rectangles provided by ImGui are defined as (x1=left,y1=top,x2=right,y2=bottom) and NOT as (x1,y1,width,height).

Q: How can I help?
A: - If you are experienced with Dear ImGui and C++, look at the github issues, or TODO.txt and see how you want/can help!
- Convince your company to fund development time! Individual users: you can also become a Patron (patreon.com/imgui) or donate on PayPal! See README.
- Disclose your usage of dear imgui via a dev blog post, a tweet, a screenshot, a mention somewhere etc.
You may post screenshot or links in the gallery threads (github.com/ocornut/imgui/issues/1269). Visuals are ideal as they inspire other programmers.
But even without visuals, disclosing your use of dear imgui help the library grow credibility, and help other teams and programmers with taking decisions.
- If you have issues or if you need to hack into the library, even if you don't expect any support it is useful that you share your issues (on github or privately).

- tip: you can call Begin() multiple times with the same name during the same frame, it will keep appending to the same window.
this is also useful to set yourself in the context of another window (to get/set other settings)
- tip: you can create widgets without a Begin()/End() block, they will go in an implicit window called "Debug".
- tip: the ImGuiOnceUponAFrame helper will allow run the block of code only once a frame. You can use it to quickly add custom UI in the middle
of a deep nested inner loop in your code.
- tip: you can call Render() multiple times (e.g for VR renders).
- tip: call and read the ShowDemoWindow() code in imgui_demo.cpp for more example of how to use ImGui!

*/

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#define IMGUI_DEFINE_MATH_OPERATORS
#include "imgui_internal.h"
#include "..//valve_sdk/misc/Color.hpp"

#include <ctype.h>      // toupper, isprint
#include <stdlib.h>     // NULL, malloc, free, qsort, atoi
#include <stdio.h>      // vsnprintf, sscanf, printf
#if defined(_MSC_VER) && _MSC_VER <= 1500 // MSVC 2008 or earlier
#include <stddef.h>     // intptr_t
#else
#include <stdint.h>     // intptr_t
#endif

#define IMGUI_DEBUG_NAV_SCORING     0
#define IMGUI_DEBUG_NAV_RECTS       0

// Visual Studio warnings
#ifdef _MSC_VER
#pragma warning (disable: 4127) // condition expression is constant
#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

// Clang warnings with -Weverything
#ifdef __clang__
#pragma clang diagnostic ignored "-Wunknown-pragmas"        // warning : unknown warning group '-Wformat-pedantic *'        // not all warnings are known by all clang versions.. so ignoring warnings triggers new warnings on some configuration. great!
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants (typically 0.0f) is ok.
#pragma clang diagnostic ignored "-Wformat-nonliteral"      // warning : format string is not a string literal              // passing non-literal to vsnformat(). yes, user passing incorrect format strings can crash the code.
#pragma clang diagnostic ignored "-Wexit-time-destructors"  // warning : declaration requires an exit-time destructor       // exit-time destruction order is undefined. if MemFree() leads to users code that has been disabled before exit it might cause problems. ImGui coding style welcomes static/globals.
#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference it.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#pragma clang diagnostic ignored "-Wformat-pedantic"        // warning : format specifies type 'void *' but the argument has type 'xxxx *' // unreasonable, would lead to casting every %p arg to void*. probably enabled by -pedantic.
#pragma clang diagnostic ignored "-Wint-to-void-pointer-cast" // warning : cast to 'void *' from smaller integer type 'int'
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wint-to-pointer-cast"      // warning: cast to pointer from integer of different size
#pragma GCC diagnostic ignored "-Wformat"                   // warning: format '%p' expects argument of type 'void*', but argument 6 has type 'ImGuiWindow*'
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#pragma GCC diagnostic ignored "-Wformat-nonliteral"        // warning: format not a string literal, format string not checked
#pragma GCC diagnostic ignored "-Wstrict-overflow"          // warning: assuming signed overflow does not occur when assuming that (X - c) > X is always false
#endif

// Enforce cdecl calling convention for functions called by the standard library, in case compilation settings changed the default to e.g. __vectorcall
#ifdef _MSC_VER
#define IMGUI_CDECL __cdecl
#else
#define IMGUI_CDECL
#endif

//-------------------------------------------------------------------------
// Forward Declarations
//-------------------------------------------------------------------------

static bool             IsKeyPressedMap(ImGuiKey key, bool repeat = true);

static ImFont* GetDefaultFont();
static void             SetCurrentWindow(ImGuiWindow* window);
static void             SetWindowScrollX(ImGuiWindow* window, float new_scroll_x);
static void             SetWindowScrollY(ImGuiWindow* window, float new_scroll_y);
static void             SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond);
static void             SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond);
static void             SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond);
static ImGuiWindow* FindHoveredWindow();
static ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags);
static void             CheckStacksSize(ImGuiWindow* window, bool write);
static ImVec2           CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window);

static void             AddDrawListToDrawData(ImVector<ImDrawList*>* out_list, ImDrawList* draw_list);
static void             AddWindowToDrawData(ImVector<ImDrawList*>* out_list, ImGuiWindow* window);
static void             AddWindowToSortedBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window);

static ImGuiWindowSettings* AddWindowSettings(const char* name);

static void             LoadIniSettingsFromDisk(const char* ini_filename);
static void             LoadIniSettingsFromMemory(const char* buf);
static void             SaveIniSettingsToDisk(const char* ini_filename);
static void             SaveIniSettingsToMemory(ImVector<char>& out_buf);
static void             MarkIniSettingsDirty(ImGuiWindow* window);

static ImRect           GetViewportRect();

static void             ClosePopupToLevel(int remaining);
static ImGuiWindow* GetFrontMostModalRootWindow();

static bool             InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data);
static int              InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end);
static ImVec2           InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining = NULL, ImVec2* out_offset = NULL, bool stop_on_new_line = false);

static inline void      DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, const char* display_format, char* buf, int buf_size);
static inline void      DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, int decimal_precision, char* buf, int buf_size);
static void             DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg_1, const void* arg_2);
static bool             DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* scalar_format);

namespace ImGui
{
	static void             NavUpdate();
	static void             NavUpdateWindowing();
	static void             NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id);

	static void             NewFrameUpdateMovingWindow();
	static void             NewFrameUpdateMouseInputs();
	static void             UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4]);
	static void             FocusFrontMostActiveWindow(ImGuiWindow* ignore_window);
}

//-----------------------------------------------------------------------------
// Platform dependent default implementations
//-----------------------------------------------------------------------------

static const char* GetClipboardTextFn_DefaultImpl(void* user_data);
static void             SetClipboardTextFn_DefaultImpl(void* user_data, const char* text);
static void             ImeSetInputScreenPosFn_DefaultImpl(int x, int y);

//-----------------------------------------------------------------------------
// Context
//-----------------------------------------------------------------------------

// Current context pointer. Implicitely used by all ImGui functions. Always assumed to be != NULL.
// CreateContext() will automatically set this pointer if it is NULL. Change to a different context by calling ImGui::SetCurrentContext().
// If you use DLL hotreloading you might need to call SetCurrentContext() after reloading code from this file.
// ImGui functions are not thread-safe because of this pointer. If you want thread-safety to allow N threads to access N different contexts, you can:
// - Change this variable to use thread local storage. You may #define GImGui in imconfig.h for that purpose. Future development aim to make this context pointer explicit to all calls. Also read https://github.com/ocornut/imgui/issues/586
// - Having multiple instances of the ImGui code compiled inside different namespace (easiest/safest, if you have a finite number of contexts)
#ifndef GImGui
ImGuiContext* GImGui = NULL;
#endif

ImVec4 ImVec4::White = ImVec4(1.f, 1.f, 1.f, 1.f);
ImVec4 ImVec4::Black = ImVec4(0.f, 0.f, 0.f, 1.f);
ImVec4 ImVec4::Green = ImVec4(0.f, 1.f, 0.f, 1.f);
ImVec4 ImVec4::Red = ImVec4(1.f, 0.f, 0.f, 1.f);
ImVec4 ImVec4::Yellow = ImVec4(1.f, 1.f, 0.f, 1.f);
ImVec4 ImVec4::Orange = ImVec4(1.f, 0.5f, 0.1f, 1.f);

// Memory Allocator functions. Use SetAllocatorFunctions() to change them.
// If you use DLL hotreloading you might need to call SetAllocatorFunctions() after reloading code from this file.
// Otherwise, you probably don't want to modify them mid-program, and if you use global/static e.g. ImVector<> instances you may need to keep them accessible during program destruction.
#ifndef IMGUI_DISABLE_DEFAULT_ALLOCATORS
static void* MallocWrapper(size_t size, void* user_data) { (void)user_data; return malloc(size); }
static void    FreeWrapper(void* ptr, void* user_data) { (void)user_data; free(ptr); }
#else
static void* MallocWrapper(size_t size, void* user_data) { (void)user_data; (void)size; IM_ASSERT(0); return NULL; }
static void    FreeWrapper(void* ptr, void* user_data) { (void)user_data; (void)ptr; IM_ASSERT(0); }
#endif

static void* (*GImAllocatorAllocFunc)(size_t size, void* user_data) = MallocWrapper;
static void(*GImAllocatorFreeFunc)(void* ptr, void* user_data) = FreeWrapper;
static void* GImAllocatorUserData = NULL;
static size_t   GImAllocatorActiveAllocationsCount = 0;

//-----------------------------------------------------------------------------
// User facing structures
//-----------------------------------------------------------------------------

ImGuiStyle::ImGuiStyle()
{
	Alpha = 1.0f;             // Global alpha applies to everything in ImGui
	WindowPadding = ImVec2(8, 8);      // Padding within a window
	WindowRounding = 7.0f;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows
	WindowBorderSize = 1.0f;             // Thickness of border around windows. Generally set to 0.0f or 1.0f. Other values not well tested.
	WindowMinSize = ImVec2(32, 32);    // Minimum window size
	WindowTitleAlign = ImVec2(0.0f, 0.5f);// Alignment for title bar text
	ChildRounding = 0.0f;             // Radius of child window corners rounding. Set to 0.0f to have rectangular child windows
	ChildBorderSize = 1.0f;             // Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
	PopupRounding = 0.0f;             // Radius of popup window corners rounding. Set to 0.0f to have rectangular child windows
	PopupBorderSize = 1.0f;             // Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
	FramePadding = ImVec2(4, 3);      // Padding within a framed rectangle (used by most widgets)
	FrameRounding = 0.0f;             // Radius of frame corners rounding. Set to 0.0f to have rectangular frames (used by most widgets).
	FrameBorderSize = 0.0f;             // Thickness of border around frames. Generally set to 0.0f or 1.0f. Other values not well tested.
	ItemSpacing = ImVec2(8, 4);      // Horizontal and vertical spacing between widgets/lines
	ItemInnerSpacing = ImVec2(4, 4);      // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label)
	TouchExtraPadding = ImVec2(0, 0);      // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
	IndentSpacing = 21.0f;            // Horizontal spacing when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
	ColumnsMinSpacing = 6.0f;             // Minimum horizontal spacing between two columns
	ScrollbarSize = 16.0f;            // Width of the vertical scrollbar, Height of the horizontal scrollbar
	ScrollbarRounding = 9.0f;             // Radius of grab corners rounding for scrollbar
	GrabMinSize = 10.0f;            // Minimum width/height of a grab box for slider/scrollbar
	GrabRounding = 0.0f;             // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
	ButtonTextAlign = ImVec2(0.5f, 0.5f);// Alignment of button text when button is larger than text.
	DisplayWindowPadding = ImVec2(22, 22);    // Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.
	DisplaySafeAreaPadding = ImVec2(4, 4);      // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
	MouseCursorScale = 1.0f;             // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
	AntiAliasedLines = true;             // Enable anti-aliasing on lines/borders. Disable if you are really short on CPU/GPU.
	AntiAliasedFill = true;             // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
	CurveTessellationTol = 1.25f;            // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.

											 // Default theme
	ImGui::StyleColorsDark(this);
}

// To scale your entire UI (e.g. if you want your app to use High DPI or generally be DPI aware) you may use this helper function. Scaling the fonts is done separately and is up to you.
// Important: This operation is lossy because we round all sizes to integer. If you need to change your scale multiples, call this over a freshly initialized ImGuiStyle structure rather than scaling multiple times.
void ImGuiStyle::ScaleAllSizes(float scale_factor)
{
	WindowPadding = ImFloor(WindowPadding * scale_factor);
	WindowRounding = ImFloor(WindowRounding * scale_factor);
	WindowMinSize = ImFloor(WindowMinSize * scale_factor);
	ChildRounding = ImFloor(ChildRounding * scale_factor);
	PopupRounding = ImFloor(PopupRounding * scale_factor);
	FramePadding = ImFloor(FramePadding * scale_factor);
	FrameRounding = ImFloor(FrameRounding * scale_factor);
	ItemSpacing = ImFloor(ItemSpacing * scale_factor);
	ItemInnerSpacing = ImFloor(ItemInnerSpacing * scale_factor);
	TouchExtraPadding = ImFloor(TouchExtraPadding * scale_factor);
	IndentSpacing = ImFloor(IndentSpacing * scale_factor);
	ColumnsMinSpacing = ImFloor(ColumnsMinSpacing * scale_factor);
	ScrollbarSize = ImFloor(ScrollbarSize * scale_factor);
	ScrollbarRounding = ImFloor(ScrollbarRounding * scale_factor);
	GrabMinSize = ImFloor(GrabMinSize * scale_factor);
	GrabRounding = ImFloor(GrabRounding * scale_factor);
	DisplayWindowPadding = ImFloor(DisplayWindowPadding * scale_factor);
	DisplaySafeAreaPadding = ImFloor(DisplaySafeAreaPadding * scale_factor);
	MouseCursorScale = ImFloor(MouseCursorScale * scale_factor);
}

ImGuiIO::ImGuiIO()
{
	// Most fields are initialized with zero
	memset(this, 0, sizeof(*this));

	// Settings
	ConfigFlags = 0x00;
	BackendFlags = 0x00;
	DisplaySize = ImVec2(-1.0f, -1.0f);
	DeltaTime = 1.0f / 60.0f;
	IniSavingRate = 5.0f;
	IniFilename = "C:\\Sensum/imgui.ini";//"imgui.ini";
	LogFilename = "imgui_log.txt";
	MouseDoubleClickTime = 0.30f;
	MouseDoubleClickMaxDist = 6.0f;
	for (int i = 0; i < ImGuiKey_COUNT; i++)
		KeyMap[i] = -1;
	KeyRepeatDelay = 0.250f;
	KeyRepeatRate = 0.050f;
	UserData = NULL;

	Fonts = NULL;
	FontGlobalScale = 1.0f;
	FontDefault = NULL;
	FontAllowUserScaling = false;
	DisplayFramebufferScale = ImVec2(1.0f, 1.0f);
	DisplayVisibleMin = DisplayVisibleMax = ImVec2(0.0f, 0.0f);

	// Advanced/subtle behaviors
#ifdef __APPLE__
	OptMacOSXBehaviors = true;  // Set Mac OS X style defaults based on __APPLE__ compile time flag
#else
	OptMacOSXBehaviors = false;
#endif
	OptCursorBlink = true;

	// Settings (User Functions)
	GetClipboardTextFn = GetClipboardTextFn_DefaultImpl;   // Platform dependent default implementations
	SetClipboardTextFn = SetClipboardTextFn_DefaultImpl;
	ClipboardUserData = NULL;
	ImeSetInputScreenPosFn = ImeSetInputScreenPosFn_DefaultImpl;
	ImeWindowHandle = NULL;

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	RenderDrawListsFn = NULL;
#endif

	// Input (NB: we already have memset zero the entire structure)
	MousePos = ImVec2(-FLT_MAX, -FLT_MAX);
	MousePosPrev = ImVec2(-FLT_MAX, -FLT_MAX);
	MouseDragThreshold = 6.0f;
	for (int i = 0; i < IM_ARRAYSIZE(MouseDownDuration); i++) MouseDownDuration[i] = MouseDownDurationPrev[i] = -1.0f;
	for (int i = 0; i < IM_ARRAYSIZE(KeysDownDuration); i++) KeysDownDuration[i] = KeysDownDurationPrev[i] = -1.0f;
	for (int i = 0; i < IM_ARRAYSIZE(NavInputsDownDuration); i++) NavInputsDownDuration[i] = -1.0f;
}

// Pass in translated ASCII characters for text input.
// - with glfw you can get those from the callback set in glfwSetCharCallback()
// - on Windows you can get those using ToAscii+keyboard state, or via the WM_CHAR message
void ImGuiIO::AddInputCharacter(ImWchar c)
{
	const int n = ImStrlenW(InputCharacters);
	if (n + 1 < IM_ARRAYSIZE(InputCharacters))
	{
		InputCharacters[n] = c;
		InputCharacters[n + 1] = '\0';
	}
}

void ImGuiIO::AddInputCharactersUTF8(const char* utf8_chars)
{
	// We can't pass more wchars than ImGuiIO::InputCharacters[] can hold so don't convert more
	const int wchars_buf_len = sizeof(ImGuiIO::InputCharacters) / sizeof(ImWchar);
	ImWchar wchars[wchars_buf_len];
	ImTextStrFromUtf8(wchars, wchars_buf_len, utf8_chars, NULL);
	for (int i = 0; i < wchars_buf_len && wchars[i] != 0; i++)
		AddInputCharacter(wchars[i]);
}

//-----------------------------------------------------------------------------
// HELPERS
//-----------------------------------------------------------------------------

#define IM_F32_TO_INT8_UNBOUND(_VAL)    ((int)((_VAL) * 255.0f + ((_VAL)>=0 ? 0.5f : -0.5f)))   // Unsaturated, for display purpose
#define IM_F32_TO_INT8_SAT(_VAL)        ((int)(ImSaturate(_VAL) * 255.0f + 0.5f))               // Saturated, always output 0..255

ImVec2 ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p)
{
	ImVec2 ap = p - a;
	ImVec2 ab_dir = b - a;
	float dot = ap.x * ab_dir.x + ap.y * ab_dir.y;
	if (dot < 0.0f)
		return a;
	float ab_len_sqr = ab_dir.x * ab_dir.x + ab_dir.y * ab_dir.y;
	if (dot > ab_len_sqr)
		return b;
	return a + ab_dir * dot / ab_len_sqr;
}

bool ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
	bool b1 = ((p.x - b.x) * (a.y - b.y) - (p.y - b.y) * (a.x - b.x)) < 0.0f;
	bool b2 = ((p.x - c.x) * (b.y - c.y) - (p.y - c.y) * (b.x - c.x)) < 0.0f;
	bool b3 = ((p.x - a.x) * (c.y - a.y) - (p.y - a.y) * (c.x - a.x)) < 0.0f;
	return ((b1 == b2) && (b2 == b3));
}

void ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w)
{
	ImVec2 v0 = b - a;
	ImVec2 v1 = c - a;
	ImVec2 v2 = p - a;
	const float denom = v0.x * v1.y - v1.x * v0.y;
	out_v = (v2.x * v1.y - v1.x * v2.y) / denom;
	out_w = (v0.x * v2.y - v2.x * v0.y) / denom;
	out_u = 1.0f - out_v - out_w;
}

ImVec2 ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p)
{
	ImVec2 proj_ab = ImLineClosestPoint(a, b, p);
	ImVec2 proj_bc = ImLineClosestPoint(b, c, p);
	ImVec2 proj_ca = ImLineClosestPoint(c, a, p);
	float dist2_ab = ImLengthSqr(p - proj_ab);
	float dist2_bc = ImLengthSqr(p - proj_bc);
	float dist2_ca = ImLengthSqr(p - proj_ca);
	float m = ImMin(dist2_ab, ImMin(dist2_bc, dist2_ca));
	if (m == dist2_ab)
		return proj_ab;
	if (m == dist2_bc)
		return proj_bc;
	return proj_ca;
}

int ImStricmp(const char* str1, const char* str2)
{
	int d;
	while ((d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; }
	return d;
}

int ImStrnicmp(const char* str1, const char* str2, size_t count)
{
	int d = 0;
	while (count > 0 && (d = toupper(*str2) - toupper(*str1)) == 0 && *str1) { str1++; str2++; count--; }
	return d;
}

void ImStrncpy(char* dst, const char* src, size_t count)
{
	if (count < 1) return;
	strncpy(dst, src, count);
	dst[count - 1] = 0;
}

char* ImStrdup(const char* str)
{
	size_t len = strlen(str) + 1;
	void* buf = ImGui::MemAlloc(len);
	return (char*)memcpy(buf, (const void*)str, len);
}

const char* ImStrchrRange(const char* str, const char* str_end, char c)
{
	for (; str < str_end; str++)
		if (*str == c)
			return str;
	return NULL;
}

int ImStrlenW(const ImWchar* str)
{
	int n = 0;
	while (*str++) n++;
	return n;
}

const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin) // find beginning-of-line
{
	while (buf_mid_line > buf_begin && buf_mid_line[-1] != '\n')
		buf_mid_line--;
	return buf_mid_line;
}

const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end)
{
	if (!needle_end)
		needle_end = needle + strlen(needle);

	const char un0 = (char)toupper(*needle);
	while ((!haystack_end && *haystack) || (haystack_end && haystack < haystack_end))
	{
		if (toupper(*haystack) == un0)
		{
			const char* b = needle + 1;
			for (const char* a = haystack + 1; b < needle_end; a++, b++)
				if (toupper(*a) != toupper(*b))
					break;
			if (b == needle_end)
				return haystack;
		}
		haystack++;
	}
	return NULL;
}

static const char* ImAtoi(const char* src, int* output)
{
	int negative = 0;
	if (*src == '-') { negative = 1; src++; }
	if (*src == '+') { src++; }
	int v = 0;
	while (*src >= '0' && *src <= '9')
		v = (v * 10) + (*src++ - '0');
	*output = negative ? -v : v;
	return src;
}

// A) MSVC version appears to return -1 on overflow, whereas glibc appears to return total count (which may be >= buf_size).
// Ideally we would test for only one of those limits at runtime depending on the behavior the vsnprintf(), but trying to deduct it at compile time sounds like a pandora can of worm.
// B) When buf==NULL vsnprintf() will return the output size.
#ifndef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS
int ImFormatString(char* buf, size_t buf_size, const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	int w = vsnprintf(buf, buf_size, fmt, args);
	va_end(args);
	if (buf == NULL)
		return w;
	if (w == -1 || w >= (int)buf_size)
		w = (int)buf_size - 1;
	buf[w] = 0;
	return w;
}

int ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args)
{
	int w = vsnprintf(buf, buf_size, fmt, args);
	if (buf == NULL)
		return w;
	if (w == -1 || w >= (int)buf_size)
		w = (int)buf_size - 1;
	buf[w] = 0;
	return w;
}
#endif // #ifdef IMGUI_DISABLE_FORMAT_STRING_FUNCTIONS

// Pass data_size==0 for zero-terminated strings
// FIXME-OPT: Replace with e.g. FNV1a hash? CRC32 pretty much randomly access 1KB. Need to do proper measurements.
ImU32 ImHash(const void* data, int data_size, ImU32 seed)
{
	static ImU32 crc32_lut[256] = { 0 };
	if (!crc32_lut[1])
	{
		const ImU32 polynomial = 0xEDB88320;
		for (ImU32 i = 0; i < 256; i++)
		{
			ImU32 crc = i;
			for (ImU32 j = 0; j < 8; j++)
				crc = (crc >> 1) ^ (ImU32(-int(crc & 1)) & polynomial);
			crc32_lut[i] = crc;
		}
	}

	seed = ~seed;
	ImU32 crc = seed;
	const unsigned char* current = (const unsigned char*)data;

	if (data_size > 0)
	{
		// Known size
		while (data_size--)
			crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ *current++];
	}
	else
	{
		// Zero-terminated string
		while (unsigned char c = *current++)
		{
			// We support a syntax of "label###id" where only "###id" is included in the hash, and only "label" gets displayed.
			// Because this syntax is rarely used we are optimizing for the common case.
			// - If we reach ### in the string we discard the hash so far and reset to the seed.
			// - We don't do 'current += 2; continue;' after handling ### to keep the code smaller.
			if (c == '#' && current[0] == '#' && current[1] == '#')
				crc = seed;
			crc = (crc >> 8) ^ crc32_lut[(crc & 0xFF) ^ c];
		}
	}
	return ~crc;
}

//-----------------------------------------------------------------------------
// ImText* helpers
//-----------------------------------------------------------------------------

// Convert UTF-8 to 32-bits character, process single character input.
// Based on stb_from_utf8() from github.com/nothings/stb/
// We handle UTF-8 decoding error by skipping forward.
int ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end)
{
	unsigned int c = (unsigned int)-1;
	const unsigned char* str = (const unsigned char*)in_text;
	if (!(*str & 0x80))
	{
		c = (unsigned int)(*str++);
		*out_char = c;
		return 1;
	}
	if ((*str & 0xe0) == 0xc0)
	{
		*out_char = 0xFFFD; // will be invalid but not end of string
		if (in_text_end && in_text_end - (const char*)str < 2) return 1;
		if (*str < 0xc2) return 2;
		c = (unsigned int)((*str++ & 0x1f) << 6);
		if ((*str & 0xc0) != 0x80) return 2;
		c += (*str++ & 0x3f);
		*out_char = c;
		return 2;
	}
	if ((*str & 0xf0) == 0xe0)
	{
		*out_char = 0xFFFD; // will be invalid but not end of string
		if (in_text_end && in_text_end - (const char*)str < 3) return 1;
		if (*str == 0xe0 && (str[1] < 0xa0 || str[1] > 0xbf)) return 3;
		if (*str == 0xed && str[1] > 0x9f) return 3; // str[1] < 0x80 is checked below
		c = (unsigned int)((*str++ & 0x0f) << 12);
		if ((*str & 0xc0) != 0x80) return 3;
		c += (unsigned int)((*str++ & 0x3f) << 6);
		if ((*str & 0xc0) != 0x80) return 3;
		c += (*str++ & 0x3f);
		*out_char = c;
		return 3;
	}
	if ((*str & 0xf8) == 0xf0)
	{
		*out_char = 0xFFFD; // will be invalid but not end of string
		if (in_text_end && in_text_end - (const char*)str < 4) return 1;
		if (*str > 0xf4) return 4;
		if (*str == 0xf0 && (str[1] < 0x90 || str[1] > 0xbf)) return 4;
		if (*str == 0xf4 && str[1] > 0x8f) return 4; // str[1] < 0x80 is checked below
		c = (unsigned int)((*str++ & 0x07) << 18);
		if ((*str & 0xc0) != 0x80) return 4;
		c += (unsigned int)((*str++ & 0x3f) << 12);
		if ((*str & 0xc0) != 0x80) return 4;
		c += (unsigned int)((*str++ & 0x3f) << 6);
		if ((*str & 0xc0) != 0x80) return 4;
		c += (*str++ & 0x3f);
		// utf-8 encodings of values used in surrogate pairs are invalid
		if ((c & 0xFFFFF800) == 0xD800) return 4;
		*out_char = c;
		return 4;
	}
	*out_char = 0;
	return 0;
}

int ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_text_remaining)
{
	ImWchar* buf_out = buf;
	ImWchar* buf_end = buf + buf_size;
	while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)
	{
		unsigned int c;
		in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
		if (c == 0)
			break;
		if (c < 0x10000)    // FIXME: Losing characters that don't fit in 2 bytes
			*buf_out++ = (ImWchar)c;
	}
	*buf_out = 0;
	if (in_text_remaining)
		*in_text_remaining = in_text;
	return (int)(buf_out - buf);
}

int ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end)
{
	int char_count = 0;
	while ((!in_text_end || in_text < in_text_end) && *in_text)
	{
		unsigned int c;
		in_text += ImTextCharFromUtf8(&c, in_text, in_text_end);
		if (c == 0)
			break;
		if (c < 0x10000)
			char_count++;
	}
	return char_count;
}

// Based on stb_to_utf8() from github.com/nothings/stb/
static inline int ImTextCharToUtf8(char* buf, int buf_size, unsigned int c)
{
	if (c < 0x80)
	{
		buf[0] = (char)c;
		return 1;
	}
	if (c < 0x800)
	{
		if (buf_size < 2) return 0;
		buf[0] = (char)(0xc0 + (c >> 6));
		buf[1] = (char)(0x80 + (c & 0x3f));
		return 2;
	}
	if (c >= 0xdc00 && c < 0xe000)
	{
		return 0;
	}
	if (c >= 0xd800 && c < 0xdc00)
	{
		if (buf_size < 4) return 0;
		buf[0] = (char)(0xf0 + (c >> 18));
		buf[1] = (char)(0x80 + ((c >> 12) & 0x3f));
		buf[2] = (char)(0x80 + ((c >> 6) & 0x3f));
		buf[3] = (char)(0x80 + ((c) & 0x3f));
		return 4;
	}
	//else if (c < 0x10000)
	{
		if (buf_size < 3) return 0;
		buf[0] = (char)(0xe0 + (c >> 12));
		buf[1] = (char)(0x80 + ((c >> 6) & 0x3f));
		buf[2] = (char)(0x80 + ((c) & 0x3f));
		return 3;
	}
}

static inline int ImTextCountUtf8BytesFromChar(unsigned int c)
{
	if (c < 0x80) return 1;
	if (c < 0x800) return 2;
	if (c >= 0xdc00 && c < 0xe000) return 0;
	if (c >= 0xd800 && c < 0xdc00) return 4;
	return 3;
}

int ImTextStrToUtf8(char* buf, int buf_size, const ImWchar* in_text, const ImWchar* in_text_end)
{
	char* buf_out = buf;
	const char* buf_end = buf + buf_size;
	while (buf_out < buf_end - 1 && (!in_text_end || in_text < in_text_end) && *in_text)
	{
		unsigned int c = (unsigned int)(*in_text++);
		if (c < 0x80)
			*buf_out++ = (char)c;
		else
			buf_out += ImTextCharToUtf8(buf_out, (int)(buf_end - buf_out - 1), c);
	}
	*buf_out = 0;
	return (int)(buf_out - buf);
}

int ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end)
{
	int bytes_count = 0;
	while ((!in_text_end || in_text < in_text_end) && *in_text)
	{
		unsigned int c = (unsigned int)(*in_text++);
		if (c < 0x80)
			bytes_count++;
		else
			bytes_count += ImTextCountUtf8BytesFromChar(c);
	}
	return bytes_count;
}

ImVec4 ImGui::ColorConvertU32ToFloat4(ImU32 in)
{
	float s = 1.0f / 255.0f;
	return ImVec4(
		((in >> IM_COL32_R_SHIFT) & 0xFF) * s,
		((in >> IM_COL32_G_SHIFT) & 0xFF) * s,
		((in >> IM_COL32_B_SHIFT) & 0xFF) * s,
		((in >> IM_COL32_A_SHIFT) & 0xFF) * s);
}

ImU32 ImGui::ColorConvertFloat4ToU32(const ImVec4& in)
{
	ImU32 out;
	out = ((ImU32)IM_F32_TO_INT8_SAT(in.x)) << IM_COL32_R_SHIFT;
	out |= ((ImU32)IM_F32_TO_INT8_SAT(in.y)) << IM_COL32_G_SHIFT;
	out |= ((ImU32)IM_F32_TO_INT8_SAT(in.z)) << IM_COL32_B_SHIFT;
	out |= ((ImU32)IM_F32_TO_INT8_SAT(in.w)) << IM_COL32_A_SHIFT;
	return out;
}

ImU32 ImGui::GetColorU32(ImGuiCol idx, float alpha_mul)
{
	ImGuiStyle& style = GImGui->Style;
	ImVec4 c = style.Colors[idx];
	c.w *= style.Alpha * alpha_mul;
	return ColorConvertFloat4ToU32(c);
}

ImU32 ImGui::GetColorU32(const ImVec4& col)
{
	ImGuiStyle& style = GImGui->Style;
	ImVec4 c = col;
	c.w *= style.Alpha;
	return ColorConvertFloat4ToU32(c);
}

const ImVec4& ImGui::GetStyleColorVec4(ImGuiCol idx)
{
	ImGuiStyle& style = GImGui->Style;
	return style.Colors[idx];
}

ImU32 ImGui::GetColorU32(ImU32 col)
{
	float style_alpha = GImGui->Style.Alpha;
	if (style_alpha >= 1.0f)
		return col;
	ImU32 a = (col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT;
	a = (ImU32)(a * style_alpha); // We don't need to clamp 0..255 because Style.Alpha is in 0..1 range.
	return (col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);
}

// Convert rgb floats ([0-1],[0-1],[0-1]) to hsv floats ([0-1],[0-1],[0-1]), from Foley & van Dam p592
// Optimized http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv
void ImGui::ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v)
{
	float K = 0.f;
	if (g < b)
	{
		ImSwap(g, b);
		K = -1.f;
	}
	if (r < g)
	{
		ImSwap(r, g);
		K = -2.f / 6.f - K;
	}

	const float chroma = r - (g < b ? g : b);
	out_h = fabsf(K + (g - b) / (6.f * chroma + 1e-20f));
	out_s = chroma / (r + 1e-20f);
	out_v = r;
}

// Convert hsv floats ([0-1],[0-1],[0-1]) to rgb floats ([0-1],[0-1],[0-1]), from Foley & van Dam p593
// also http://en.wikipedia.org/wiki/HSL_and_HSV
void ImGui::ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b)
{
	if (s == 0.0f)
	{
		// gray
		out_r = out_g = out_b = v;
		return;
	}

	h = fmodf(h, 1.0f) / (60.0f / 360.0f);
	int   i = (int)h;
	float f = h - (float)i;
	float p = v * (1.0f - s);
	float q = v * (1.0f - s * f);
	float t = v * (1.0f - s * (1.0f - f));

	switch (i)
	{
	case 0: out_r = v; out_g = t; out_b = p; break;
	case 1: out_r = q; out_g = v; out_b = p; break;
	case 2: out_r = p; out_g = v; out_b = t; break;
	case 3: out_r = p; out_g = q; out_b = v; break;
	case 4: out_r = t; out_g = p; out_b = v; break;
	case 5: default: out_r = v; out_g = p; out_b = q; break;
	}
}

FILE* ImFileOpen(const char* filename, const char* mode)
{
#if defined(_WIN32) && !defined(__CYGWIN__)
	// We need a fopen() wrapper because MSVC/Windows fopen doesn't handle UTF-8 filenames. Converting both strings from UTF-8 to wchar format (using a single allocation, because we can)
	const int filename_wsize = ImTextCountCharsFromUtf8(filename, NULL) + 1;
	const int mode_wsize = ImTextCountCharsFromUtf8(mode, NULL) + 1;
	ImVector<ImWchar> buf;
	buf.resize(filename_wsize + mode_wsize);
	ImTextStrFromUtf8(&buf[0], filename_wsize, filename, NULL);
	ImTextStrFromUtf8(&buf[filename_wsize], mode_wsize, mode, NULL);
	return _wfopen((wchar_t*)&buf[0], (wchar_t*)&buf[filename_wsize]);
#else
	return fopen(filename, mode);
#endif
}

// Load file content into memory
// Memory allocated with ImGui::MemAlloc(), must be freed by user using ImGui::MemFree()
void* ImFileLoadToMemory(const char* filename, const char* file_open_mode, int* out_file_size, int padding_bytes)
{
	IM_ASSERT(filename && file_open_mode);
	if (out_file_size)
		*out_file_size = 0;

	FILE* f;
	if ((f = ImFileOpen(filename, file_open_mode)) == NULL)
		return NULL;

	long file_size_signed;
	if (fseek(f, 0, SEEK_END) || (file_size_signed = ftell(f)) == -1 || fseek(f, 0, SEEK_SET))
	{
		fclose(f);
		return NULL;
	}

	int file_size = (int)file_size_signed;
	void* file_data = ImGui::MemAlloc((size_t)(file_size + padding_bytes));
	if (file_data == NULL)
	{
		fclose(f);
		return NULL;
	}
	if (fread(file_data, 1, (size_t)file_size, f) != (size_t)file_size)
	{
		fclose(f);
		ImGui::MemFree(file_data);
		return NULL;
	}
	if (padding_bytes > 0)
		memset((void*)(((char*)file_data) + file_size), 0, (size_t)padding_bytes);

	fclose(f);
	if (out_file_size)
		*out_file_size = file_size;

	return file_data;
}

//-----------------------------------------------------------------------------
// ImGuiStorage
// Helper: Key->value storage
//-----------------------------------------------------------------------------

// std::lower_bound but without the bullshit
static ImVector<ImGuiStorage::Pair>::iterator LowerBound(ImVector<ImGuiStorage::Pair>& data, ImGuiID key)
{
	ImVector<ImGuiStorage::Pair>::iterator first = data.begin();
	ImVector<ImGuiStorage::Pair>::iterator last = data.end();
	size_t count = (size_t)(last - first);
	while (count > 0)
	{
		size_t count2 = count >> 1;
		ImVector<ImGuiStorage::Pair>::iterator mid = first + count2;
		if (mid->key < key)
		{
			first = ++mid;
			count -= count2 + 1;
		}
		else
		{
			count = count2;
		}
	}
	return first;
}

// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
void ImGuiStorage::BuildSortByKey()
{
	struct StaticFunc
	{
		static int IMGUI_CDECL PairCompareByID(const void* lhs, const void* rhs)
		{
			// We can't just do a subtraction because qsort uses signed integers and subtracting our ID doesn't play well with that.
			if (((const Pair*)lhs)->key > ((const Pair*)rhs)->key) return +1;
			if (((const Pair*)lhs)->key < ((const Pair*)rhs)->key) return -1;
			return 0;
		}
	};
	if (Data.Size > 1)
		qsort(Data.Data, (size_t)Data.Size, sizeof(Pair), StaticFunc::PairCompareByID);
}

int ImGuiStorage::GetInt(ImGuiID key, int default_val) const
{
	ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
	if (it == Data.end() || it->key != key)
		return default_val;
	return it->val_i;
}

bool ImGuiStorage::GetBool(ImGuiID key, bool default_val) const
{
	return GetInt(key, default_val ? 1 : 0) != 0;
}

float ImGuiStorage::GetFloat(ImGuiID key, float default_val) const
{
	ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
	if (it == Data.end() || it->key != key)
		return default_val;
	return it->val_f;
}

void* ImGuiStorage::GetVoidPtr(ImGuiID key) const
{
	ImVector<Pair>::iterator it = LowerBound(const_cast<ImVector<ImGuiStorage::Pair>&>(Data), key);
	if (it == Data.end() || it->key != key)
		return NULL;
	return it->val_p;
}

// References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
int* ImGuiStorage::GetIntRef(ImGuiID key, int default_val)
{
	ImVector<Pair>::iterator it = LowerBound(Data, key);
	if (it == Data.end() || it->key != key)
		it = Data.insert(it, Pair(key, default_val));
	return &it->val_i;
}

bool* ImGuiStorage::GetBoolRef(ImGuiID key, bool default_val)
{
	return (bool*)GetIntRef(key, default_val ? 1 : 0);
}

float* ImGuiStorage::GetFloatRef(ImGuiID key, float default_val)
{
	ImVector<Pair>::iterator it = LowerBound(Data, key);
	if (it == Data.end() || it->key != key)
		it = Data.insert(it, Pair(key, default_val));
	return &it->val_f;
}

void** ImGuiStorage::GetVoidPtrRef(ImGuiID key, void* default_val)
{
	ImVector<Pair>::iterator it = LowerBound(Data, key);
	if (it == Data.end() || it->key != key)
		it = Data.insert(it, Pair(key, default_val));
	return &it->val_p;
}

// FIXME-OPT: Need a way to reuse the result of lower_bound when doing GetInt()/SetInt() - not too bad because it only happens on explicit interaction (maximum one a frame)
void ImGuiStorage::SetInt(ImGuiID key, int val)
{
	ImVector<Pair>::iterator it = LowerBound(Data, key);
	if (it == Data.end() || it->key != key)
	{
		Data.insert(it, Pair(key, val));
		return;
	}
	it->val_i = val;
}

void ImGuiStorage::SetBool(ImGuiID key, bool val)
{
	SetInt(key, val ? 1 : 0);
}

void ImGuiStorage::SetFloat(ImGuiID key, float val)
{
	ImVector<Pair>::iterator it = LowerBound(Data, key);
	if (it == Data.end() || it->key != key)
	{
		Data.insert(it, Pair(key, val));
		return;
	}
	it->val_f = val;
}

void ImGuiStorage::SetVoidPtr(ImGuiID key, void* val)
{
	ImVector<Pair>::iterator it = LowerBound(Data, key);
	if (it == Data.end() || it->key != key)
	{
		Data.insert(it, Pair(key, val));
		return;
	}
	it->val_p = val;
}

void ImGuiStorage::SetAllInt(int v)
{
	for (int i = 0; i < Data.Size; i++)
		Data[i].val_i = v;
}

//-----------------------------------------------------------------------------
// ImGuiTextFilter
//-----------------------------------------------------------------------------

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
ImGuiTextFilter::ImGuiTextFilter(const char* default_filter)
{
	if (default_filter)
	{
		ImStrncpy(InputBuf, default_filter, IM_ARRAYSIZE(InputBuf));
		Build();
	}
	else
	{
		InputBuf[0] = 0;
		CountGrep = 0;
	}
}

bool ImGuiTextFilter::Draw(const char* label, float width)
{
	if (width != 0.0f)
		ImGui::PushItemWidth(width);
	bool value_changed = ImGui::InputText(label, InputBuf, IM_ARRAYSIZE(InputBuf));
	if (width != 0.0f)
		ImGui::PopItemWidth();
	if (value_changed)
		Build();
	return value_changed;
}

void ImGuiTextFilter::TextRange::split(char separator, ImVector<TextRange>& out)
{
	out.resize(0);
	const char* wb = b;
	const char* we = wb;
	while (we < e)
	{
		if (*we == separator)
		{
			out.push_back(TextRange(wb, we));
			wb = we + 1;
		}
		we++;
	}
	if (wb != we)
		out.push_back(TextRange(wb, we));
}

void ImGuiTextFilter::Build()
{
	Filters.resize(0);
	TextRange input_range(InputBuf, InputBuf + strlen(InputBuf));
	input_range.split(',', Filters);

	CountGrep = 0;
	for (int i = 0; i != Filters.Size; i++)
	{
		Filters[i].trim_blanks();
		if (Filters[i].empty())
			continue;
		if (Filters[i].front() != '-')
			CountGrep += 1;
	}
}

bool ImGuiTextFilter::PassFilter(const char* text, const char* text_end) const
{
	if (Filters.empty())
		return true;

	if (text == NULL)
		text = "";

	for (int i = 0; i != Filters.Size; i++)
	{
		const TextRange& f = Filters[i];
		if (f.empty())
			continue;
		if (f.front() == '-')
		{
			// Subtract
			if (ImStristr(text, text_end, f.begin() + 1, f.end()) != NULL)
				return false;
		}
		else
		{
			// Grep
			if (ImStristr(text, text_end, f.begin(), f.end()) != NULL)
				return true;
		}
	}

	// Implicit * grep
	if (CountGrep == 0)
		return true;

	return false;
}

//-----------------------------------------------------------------------------
// ImGuiTextBuffer
//-----------------------------------------------------------------------------

// On some platform vsnprintf() takes va_list by reference and modifies it.
// va_copy is the 'correct' way to copy a va_list but Visual Studio prior to 2013 doesn't have it.
#ifndef va_copy
#define va_copy(dest, src) (dest = src)
#endif

// Helper: Text buffer for logging/accumulating text
void ImGuiTextBuffer::appendfv(const char* fmt, va_list args)
{
	va_list args_copy;
	va_copy(args_copy, args);

	int len = ImFormatStringV(NULL, 0, fmt, args);         // FIXME-OPT: could do a first pass write attempt, likely successful on first pass.
	if (len <= 0)
		return;

	const int write_off = Buf.Size;
	const int needed_sz = write_off + len;
	if (write_off + len >= Buf.Capacity)
	{
		int double_capacity = Buf.Capacity * 2;
		Buf.reserve(needed_sz > double_capacity ? needed_sz : double_capacity);
	}

	Buf.resize(needed_sz);
	ImFormatStringV(&Buf[write_off - 1], (size_t)len + 1, fmt, args_copy);
}

void ImGuiTextBuffer::appendf(const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	appendfv(fmt, args);
	va_end(args);
}

//-----------------------------------------------------------------------------
// ImGuiSimpleColumns (internal use only)
//-----------------------------------------------------------------------------

ImGuiMenuColumns::ImGuiMenuColumns()
{
	Count = 0;
	Spacing = Width = NextWidth = 0.0f;
	memset(Pos, 0, sizeof(Pos));
	memset(NextWidths, 0, sizeof(NextWidths));
}

void ImGuiMenuColumns::Update(int count, float spacing, bool clear)
{
	IM_ASSERT(Count <= IM_ARRAYSIZE(Pos));
	Count = count;
	Width = NextWidth = 0.0f;
	Spacing = spacing;
	if (clear) memset(NextWidths, 0, sizeof(NextWidths));
	for (int i = 0; i < Count; i++)
	{
		if (i > 0 && NextWidths[i] > 0.0f)
			Width += Spacing;
		Pos[i] = (float)(int)Width;
		Width += NextWidths[i];
		NextWidths[i] = 0.0f;
	}
}

float ImGuiMenuColumns::DeclColumns(float w0, float w1, float w2) // not using va_arg because they promote float to double
{
	NextWidth = 0.0f;
	NextWidths[0] = ImMax(NextWidths[0], w0);
	NextWidths[1] = ImMax(NextWidths[1], w1);
	NextWidths[2] = ImMax(NextWidths[2], w2);
	for (int i = 0; i < 3; i++)
		NextWidth += NextWidths[i] + ((i > 0 && NextWidths[i] > 0.0f) ? Spacing : 0.0f);
	return ImMax(Width, NextWidth);
}

float ImGuiMenuColumns::CalcExtraSpace(float avail_w)
{
	return ImMax(0.0f, avail_w - Width);
}

//-----------------------------------------------------------------------------
// ImGuiListClipper
//-----------------------------------------------------------------------------

static void SetCursorPosYAndSetupDummyPrevLine(float pos_y, float line_height)
{
	// Set cursor position and a few other things so that SetScrollHere() and Columns() can work when seeking cursor.
	// FIXME: It is problematic that we have to do that here, because custom/equivalent end-user code would stumble on the same issue.
	// The clipper should probably have a 4th step to display the last item in a regular manner.
	ImGui::SetCursorPosY(pos_y);
	ImGuiWindow* window = ImGui::GetCurrentWindow();
	window->DC.CursorPosPrevLine.y = window->DC.CursorPos.y - line_height;      // Setting those fields so that SetScrollHere() can properly function after the end of our clipper usage.
	window->DC.PrevLineHeight = (line_height - GImGui->Style.ItemSpacing.y);    // If we end up needing more accurate data (to e.g. use SameLine) we may as well make the clipper have a fourth step to let user process and display the last item in their list.
	if (window->DC.ColumnsSet)
		window->DC.ColumnsSet->LineMinY = window->DC.CursorPos.y;           // Setting this so that cell Y position are set properly
}

// Use case A: Begin() called from constructor with items_height<0, then called again from Sync() in StepNo 1
// Use case B: Begin() called from constructor with items_height>0
// FIXME-LEGACY: Ideally we should remove the Begin/End functions but they are part of the legacy API we still support. This is why some of the code in Step() calling Begin() and reassign some fields, spaghetti style.
void ImGuiListClipper::Begin(int count, float items_height)
{
	StartPosY = ImGui::GetCursorPosY();
	ItemsHeight = items_height;
	ItemsCount = count;
	StepNo = 0;
	DisplayEnd = DisplayStart = -1;
	if (ItemsHeight > 0.0f)
	{
		ImGui::CalcListClipping(ItemsCount, ItemsHeight, &DisplayStart, &DisplayEnd); // calculate how many to clip/display
		if (DisplayStart > 0)
			SetCursorPosYAndSetupDummyPrevLine(StartPosY + DisplayStart * ItemsHeight, ItemsHeight); // advance cursor
		StepNo = 2;
	}
}

void ImGuiListClipper::End()
{
	if (ItemsCount < 0)
		return;
	// In theory here we should assert that ImGui::GetCursorPosY() == StartPosY + DisplayEnd * ItemsHeight, but it feels saner to just seek at the end and not assert/crash the user.
	if (ItemsCount < INT_MAX)
		SetCursorPosYAndSetupDummyPrevLine(StartPosY + ItemsCount * ItemsHeight, ItemsHeight); // advance cursor
	ItemsCount = -1;
	StepNo = 3;
}

bool ImGuiListClipper::Step()
{
	if (ItemsCount == 0 || ImGui::GetCurrentWindowRead()->SkipItems)
	{
		ItemsCount = -1;
		return false;
	}
	if (StepNo == 0) // Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height.
	{
		DisplayStart = 0;
		DisplayEnd = 1;
		StartPosY = ImGui::GetCursorPosY();
		StepNo = 1;
		return true;
	}
	if (StepNo == 1) // Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
	{
		if (ItemsCount == 1) { ItemsCount = -1; return false; }
		float items_height = ImGui::GetCursorPosY() - StartPosY;
		IM_ASSERT(items_height > 0.0f);   // If this triggers, it means Item 0 hasn't moved the cursor vertically
		Begin(ItemsCount - 1, items_height);
		DisplayStart++;
		DisplayEnd++;
		StepNo = 3;
		return true;
	}
	if (StepNo == 2) // Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user still call Step(). Does nothing and switch to Step 3.
	{
		IM_ASSERT(DisplayStart >= 0 && DisplayEnd >= 0);
		StepNo = 3;
		return true;
	}
	if (StepNo == 3) // Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
		End();
	return false;
}

//-----------------------------------------------------------------------------
// ImGuiWindow
//-----------------------------------------------------------------------------

ImGuiWindow::ImGuiWindow(ImGuiContext* context, const char* name)
{
	Name = ImStrdup(name);
	ID = ImHash(name, 0);
	IDStack.push_back(ID);
	Flags = 0;
	PosFloat = Pos = ImVec2(0.0f, 0.0f);
	Size = SizeFull = ImVec2(0.0f, 0.0f);
	SizeContents = SizeContentsExplicit = ImVec2(0.0f, 0.0f);
	WindowPadding = ImVec2(0.0f, 0.0f);
	WindowRounding = 0.0f;
	WindowBorderSize = 0.0f;
	MoveId = GetID("#MOVE");
	ChildId = 0;
	Scroll = ImVec2(0.0f, 0.0f);
	ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);
	ScrollTargetCenterRatio = ImVec2(0.5f, 0.5f);
	ScrollbarX = ScrollbarY = false;
	ScrollbarSizes = ImVec2(0.0f, 0.0f);
	Active = WasActive = false;
	WriteAccessed = false;
	Collapsed = false;
	CollapseToggleWanted = false;
	SkipItems = false;
	Appearing = false;
	CloseButton = false;
	BeginOrderWithinParent = -1;
	BeginOrderWithinContext = -1;
	BeginCount = 0;
	PopupId = 0;
	AutoFitFramesX = AutoFitFramesY = -1;
	AutoFitOnlyGrows = false;
	AutoFitChildAxises = 0x00;
	AutoPosLastDirection = ImGuiDir_None;
	HiddenFrames = 0;
	SetWindowPosAllowFlags = SetWindowSizeAllowFlags = SetWindowCollapsedAllowFlags = ImGuiCond_Always | ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing;
	SetWindowPosVal = SetWindowPosPivot = ImVec2(FLT_MAX, FLT_MAX);

	LastFrameActive = -1;
	ItemWidthDefault = 0.0f;
	FontWindowScale = 1.0f;

	DrawList = IM_NEW(ImDrawList)(&context->DrawListSharedData);
	DrawList->_OwnerName = Name;
	ParentWindow = NULL;
	RootWindow = NULL;
	RootWindowForTitleBarHighlight = NULL;
	RootWindowForTabbing = NULL;
	RootWindowForNav = NULL;

	NavLastIds[0] = NavLastIds[1] = 0;
	NavRectRel[0] = NavRectRel[1] = ImRect();
	NavLastChildNavWindow = NULL;

	FocusIdxAllCounter = FocusIdxTabCounter = -1;
	FocusIdxAllRequestCurrent = FocusIdxTabRequestCurrent = INT_MAX;
	FocusIdxAllRequestNext = FocusIdxTabRequestNext = INT_MAX;
}

ImGuiWindow::~ImGuiWindow()
{
	IM_DELETE(DrawList);
	IM_DELETE(Name);
	for (int i = 0; i != ColumnsStorage.Size; i++)
		ColumnsStorage[i].~ImGuiColumnsSet();
}

ImGuiID ImGuiWindow::GetID(const char* str, const char* str_end)
{
	ImGuiID seed = IDStack.back();
	ImGuiID id = ImHash(str, str_end ? (int)(str_end - str) : 0, seed);
	ImGui::KeepAliveID(id);
	return id;
}

ImGuiID ImGuiWindow::GetID(const void* ptr)
{
	ImGuiID seed = IDStack.back();
	ImGuiID id = ImHash(&ptr, sizeof(void*), seed);
	ImGui::KeepAliveID(id);
	return id;
}

ImGuiID ImGuiWindow::GetIDNoKeepAlive(const char* str, const char* str_end)
{
	ImGuiID seed = IDStack.back();
	return ImHash(str, str_end ? (int)(str_end - str) : 0, seed);
}

// This is only used in rare/specific situations to manufacture an ID out of nowhere.
ImGuiID ImGuiWindow::GetIDFromRectangle(const ImRect& r_abs)
{
	ImGuiID seed = IDStack.back();
	const int r_rel[4] = { (int)(r_abs.Min.x - Pos.x), (int)(r_abs.Min.y - Pos.y), (int)(r_abs.Max.x - Pos.x), (int)(r_abs.Max.y - Pos.y) };
	ImGuiID id = ImHash(&r_rel, sizeof(r_rel), seed);
	ImGui::KeepAliveID(id);
	return id;
}

//-----------------------------------------------------------------------------
// Internal API exposed in imgui_internal.h
//-----------------------------------------------------------------------------

static void SetCurrentWindow(ImGuiWindow* window)
{
	ImGuiContext& g = *GImGui;
	g.CurrentWindow = window;
	if (window)
		g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

static void SetNavID(ImGuiID id, int nav_layer)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(g.NavWindow);
	IM_ASSERT(nav_layer == 0 || nav_layer == 1);
	g.NavId = id;
	g.NavWindow->NavLastIds[nav_layer] = id;
}

static void SetNavIDWithRectRel(ImGuiID id, int nav_layer, const ImRect& rect_rel)
{
	ImGuiContext& g = *GImGui;
	SetNavID(id, nav_layer);
	g.NavWindow->NavRectRel[nav_layer] = rect_rel;
	g.NavMousePosDirty = true;
	g.NavDisableHighlight = false;
	g.NavDisableMouseHover = true;
}

void ImGui::SetActiveID(ImGuiID id, ImGuiWindow* window)
{
	ImGuiContext& g = *GImGui;
	g.ActiveIdIsJustActivated = (g.ActiveId != id);
	if (g.ActiveIdIsJustActivated)
		g.ActiveIdTimer = 0.0f;
	g.ActiveId = id;
	g.ActiveIdAllowNavDirFlags = 0;
	g.ActiveIdAllowOverlap = false;
	g.ActiveIdWindow = window;
	if (id)
	{
		g.ActiveIdIsAlive = true;
		g.ActiveIdSource = (g.NavActivateId == id || g.NavInputId == id || g.NavJustTabbedId == id || g.NavJustMovedToId == id) ? ImGuiInputSource_Nav : ImGuiInputSource_Mouse;
	}
}

ImGuiID ImGui::GetActiveID()
{
	ImGuiContext& g = *GImGui;
	return g.ActiveId;
}

void ImGui::SetFocusID(ImGuiID id, ImGuiWindow* window)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(id != 0);

	// Assume that SetFocusID() is called in the context where its NavLayer is the current layer, which is the case everywhere we call it.
	const int nav_layer = window->DC.NavLayerCurrent;
	if (g.NavWindow != window)
		g.NavInitRequest = false;
	g.NavId = id;
	g.NavWindow = window;
	g.NavLayer = nav_layer;
	window->NavLastIds[nav_layer] = id;
	if (window->DC.LastItemId == id)
		window->NavRectRel[nav_layer] = ImRect(window->DC.LastItemRect.Min - window->Pos, window->DC.LastItemRect.Max - window->Pos);

	if (g.ActiveIdSource == ImGuiInputSource_Nav)
		g.NavDisableMouseHover = true;
	else
		g.NavDisableHighlight = true;
}

void ImGui::ClearActiveID()
{
	SetActiveID(0, NULL);
}

void ImGui::SetHoveredID(ImGuiID id)
{
	ImGuiContext& g = *GImGui;
	g.HoveredId = id;
	g.HoveredIdAllowOverlap = false;
	g.HoveredIdTimer = (id != 0 && g.HoveredIdPreviousFrame == id) ? (g.HoveredIdTimer + g.IO.DeltaTime) : 0.0f;
}

ImGuiID ImGui::GetHoveredID()
{
	ImGuiContext& g = *GImGui;
	return g.HoveredId ? g.HoveredId : g.HoveredIdPreviousFrame;
}

void ImGui::KeepAliveID(ImGuiID id)
{
	ImGuiContext& g = *GImGui;
	if (g.ActiveId == id)
		g.ActiveIdIsAlive = true;
}

static inline bool IsWindowContentHoverable(ImGuiWindow* window, ImGuiHoveredFlags flags)
{
	// An active popup disable hovering on other windows (apart from its own children)
	// FIXME-OPT: This could be cached/stored within the window.
	ImGuiContext& g = *GImGui;
	if (g.NavWindow)
		if (ImGuiWindow* focused_root_window = g.NavWindow->RootWindow)
			if (focused_root_window->WasActive && focused_root_window != window->RootWindow)
			{
				// For the purpose of those flags we differentiate "standard popup" from "modal popup"
				// NB: The order of those two tests is important because Modal windows are also Popups.
				if (focused_root_window->Flags & ImGuiWindowFlags_Modal)
					return false;
				if ((focused_root_window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiHoveredFlags_AllowWhenBlockedByPopup))
					return false;
			}

	return true;
}

// Advance cursor given item size for layout.
void ImGui::ItemSize(const ImVec2& size, float text_offset_y)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if (window->SkipItems)
		return;

	// Always align ourselves on pixel boundaries
	const float line_height = ImMax(window->DC.CurrentLineHeight, size.y);
	const float text_base_offset = ImMax(window->DC.CurrentLineTextBaseOffset, text_offset_y);
	//if (g.IO.KeyAlt) window->DrawList->AddRect(window->DC.CursorPos, window->DC.CursorPos + ImVec2(size.x, line_height), IM_COL32(255,0,0,200)); // [DEBUG]
	window->DC.CursorPosPrevLine = ImVec2(window->DC.CursorPos.x + size.x, window->DC.CursorPos.y);
	window->DC.CursorPos = ImVec2((float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX), (float)(int)(window->DC.CursorPos.y + line_height + g.Style.ItemSpacing.y));
	window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPosPrevLine.x);
	window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y - g.Style.ItemSpacing.y);
	//if (g.IO.KeyAlt) window->DrawList->AddCircle(window->DC.CursorMaxPos, 3.0f, IM_COL32(255,0,0,255), 4); // [DEBUG]

	window->DC.PrevLineHeight = line_height;
	window->DC.PrevLineTextBaseOffset = text_base_offset;
	window->DC.CurrentLineHeight = window->DC.CurrentLineTextBaseOffset = 0.0f;

	// Horizontal layout mode
	if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
		SameLine();
}

void ImGui::ItemSize(const ImRect& bb, float text_offset_y)
{
	ItemSize(bb.GetSize(), text_offset_y);
}

static ImGuiDir NavScoreItemGetQuadrant(float dx, float dy)
{
	if (fabsf(dx) > fabsf(dy))
		return (dx > 0.0f) ? ImGuiDir_Right : ImGuiDir_Left;
	return (dy > 0.0f) ? ImGuiDir_Down : ImGuiDir_Up;
}

static float NavScoreItemDistInterval(float a0, float a1, float b0, float b1)
{
	if (a1 < b0)
		return a1 - b0;
	if (b1 < a0)
		return a0 - b1;
	return 0.0f;
}

// Scoring function for directional navigation. Based on https://gist.github.com/rygorous/6981057
static bool NavScoreItem(ImGuiNavMoveResult* result, ImRect cand)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if (g.NavLayer != window->DC.NavLayerCurrent)
		return false;

	const ImRect& curr = g.NavScoringRectScreen; // Current modified source rect (NB: we've applied Max.x = Min.x in NavUpdate() to inhibit the effect of having varied item width)
	g.NavScoringCount++;

	// We perform scoring on items bounding box clipped by their parent window on the other axis (clipping on our movement axis would give us equal scores for all clipped items)
	if (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right)
	{
		cand.Min.y = ImClamp(cand.Min.y, window->ClipRect.Min.y, window->ClipRect.Max.y);
		cand.Max.y = ImClamp(cand.Max.y, window->ClipRect.Min.y, window->ClipRect.Max.y);
	}
	else
	{
		cand.Min.x = ImClamp(cand.Min.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
		cand.Max.x = ImClamp(cand.Max.x, window->ClipRect.Min.x, window->ClipRect.Max.x);
	}

	// Compute distance between boxes
	// FIXME-NAV: Introducing biases for vertical navigation, needs to be removed.
	float dbx = NavScoreItemDistInterval(cand.Min.x, cand.Max.x, curr.Min.x, curr.Max.x);
	float dby = NavScoreItemDistInterval(ImLerp(cand.Min.y, cand.Max.y, 0.2f), ImLerp(cand.Min.y, cand.Max.y, 0.8f), ImLerp(curr.Min.y, curr.Max.y, 0.2f), ImLerp(curr.Min.y, curr.Max.y, 0.8f)); // Scale down on Y to keep using box-distance for vertically touching items
	if (dby != 0.0f && dbx != 0.0f)
		dbx = (dbx / 1000.0f) + ((dbx > 0.0f) ? +1.0f : -1.0f);
	float dist_box = fabsf(dbx) + fabsf(dby);

	// Compute distance between centers (this is off by a factor of 2, but we only compare center distances with each other so it doesn't matter)
	float dcx = (cand.Min.x + cand.Max.x) - (curr.Min.x + curr.Max.x);
	float dcy = (cand.Min.y + cand.Max.y) - (curr.Min.y + curr.Max.y);
	float dist_center = fabsf(dcx) + fabsf(dcy); // L1 metric (need this for our connectedness guarantee)

												 // Determine which quadrant of 'curr' our candidate item 'cand' lies in based on distance
	ImGuiDir quadrant;
	float dax = 0.0f, day = 0.0f, dist_axial = 0.0f;
	if (dbx != 0.0f || dby != 0.0f)
	{
		// For non-overlapping boxes, use distance between boxes
		dax = dbx;
		day = dby;
		dist_axial = dist_box;
		quadrant = NavScoreItemGetQuadrant(dbx, dby);
	}
	else if (dcx != 0.0f || dcy != 0.0f)
	{
		// For overlapping boxes with different centers, use distance between centers
		dax = dcx;
		day = dcy;
		dist_axial = dist_center;
		quadrant = NavScoreItemGetQuadrant(dcx, dcy);
	}
	else
	{
		// Degenerate case: two overlapping buttons with same center, break ties arbitrarily (note that LastItemId here is really the _previous_ item order, but it doesn't matter)
		quadrant = (window->DC.LastItemId < g.NavId) ? ImGuiDir_Left : ImGuiDir_Right;
	}

#if IMGUI_DEBUG_NAV_SCORING
	char buf[128];
	if (ImGui::IsMouseHoveringRect(cand.Min, cand.Max))
	{
		ImFormatString(buf, IM_ARRAYSIZE(buf), "dbox (%.2f,%.2f->%.4f)\ndcen (%.2f,%.2f->%.4f)\nd (%.2f,%.2f->%.4f)\nnav %c, quadrant %c", dbx, dby, dist_box, dcx, dcy, dist_center, dax, day, dist_axial, "WENS"[g.NavMoveDir], "WENS"[quadrant]);
		g.OverlayDrawList.AddRect(curr.Min, curr.Max, IM_COL32(255, 200, 0, 100));
		g.OverlayDrawList.AddRect(cand.Min, cand.Max, IM_COL32(255, 255, 0, 200));
		g.OverlayDrawList.AddRectFilled(cand.Max - ImVec2(4, 4), cand.Max + ImGui::CalcTextSize(buf) + ImVec2(4, 4), IM_COL32(40, 0, 0, 150));
		g.OverlayDrawList.AddText(g.IO.FontDefault, 13.0f, cand.Max, ~0U, buf);
	}
	else if (g.IO.KeyCtrl) // Hold to preview score in matching quadrant. Press C to rotate.
	{
		if (IsKeyPressedMap(ImGuiKey_C)) { g.NavMoveDirLast = (ImGuiDir)((g.NavMoveDirLast + 1) & 3); g.IO.KeysDownDuration[g.IO.KeyMap[ImGuiKey_C]] = 0.01f; }
		if (quadrant == g.NavMoveDir)
		{
			ImFormatString(buf, IM_ARRAYSIZE(buf), "%.0f/%.0f", dist_box, dist_center);
			g.OverlayDrawList.AddRectFilled(cand.Min, cand.Max, IM_COL32(255, 0, 0, 200));
			g.OverlayDrawList.AddText(g.IO.FontDefault, 13.0f, cand.Min, IM_COL32(255, 255, 255, 255), buf);
		}
	}
#endif

	// Is it in the quadrant we're interesting in moving to?
	bool new_best = false;
	if (quadrant == g.NavMoveDir)
	{
		// Does it beat the current best candidate?
		if (dist_box < result->DistBox)
		{
			result->DistBox = dist_box;
			result->DistCenter = dist_center;
			return true;
		}
		if (dist_box == result->DistBox)
		{
			// Try using distance between center points to break ties
			if (dist_center < result->DistCenter)
			{
				result->DistCenter = dist_center;
				new_best = true;
			}
			else if (dist_center == result->DistCenter)
			{
				// Still tied! we need to be extra-careful to make sure everything gets linked properly. We consistently break ties by symbolically moving "later" items
				// (with higher index) to the right/downwards by an infinitesimal amount since we the current "best" button already (so it must have a lower index),
				// this is fairly easy. This rule ensures that all buttons with dx==dy==0 will end up being linked in order of appearance along the x axis.
				if (((g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) ? dby : dbx) < 0.0f) // moving bj to the right/down decreases distance
					new_best = true;
			}
		}
	}

	// Axial check: if 'curr' has no link at all in some direction and 'cand' lies roughly in that direction, add a tentative link. This will only be kept if no "real" matches
	// are found, so it only augments the graph produced by the above method using extra links. (important, since it doesn't guarantee strong connectedness)
	// This is just to avoid buttons having no links in a particular direction when there's a suitable neighbor. you get good graphs without this too.
	// 2017/09/29: FIXME: This now currently only enabled inside menu bars, ideally we'd disable it everywhere. Menus in particular need to catch failure. For general navigation it feels awkward.
	// Disabling it may however lead to disconnected graphs when nodes are very spaced out on different axis. Perhaps consider offering this as an option?
	if (result->DistBox == FLT_MAX && dist_axial < result->DistAxial)  // Check axial match
		if (g.NavLayer == 1 && !(g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
			if ((g.NavMoveDir == ImGuiDir_Left && dax < 0.0f) || (g.NavMoveDir == ImGuiDir_Right && dax > 0.0f) || (g.NavMoveDir == ImGuiDir_Up && day < 0.0f) || (g.NavMoveDir == ImGuiDir_Down && day > 0.0f))
			{
				result->DistAxial = dist_axial;
				new_best = true;
			}

	return new_best;
}

static void NavSaveLastChildNavWindow(ImGuiWindow* child_window)
{
	ImGuiWindow* parent_window = child_window;
	while (parent_window && (parent_window->Flags & ImGuiWindowFlags_ChildWindow) != 0 && (parent_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
		parent_window = parent_window->ParentWindow;
	if (parent_window && parent_window != child_window)
		parent_window->NavLastChildNavWindow = child_window;
}

// Call when we are expected to land on Layer 0 after FocusWindow()
static ImGuiWindow* NavRestoreLastChildNavWindow(ImGuiWindow* window)
{
	return window->NavLastChildNavWindow ? window->NavLastChildNavWindow : window;
}

static void NavRestoreLayer(int layer)
{
	ImGuiContext& g = *GImGui;
	g.NavLayer = layer;
	if (layer == 0)
		g.NavWindow = NavRestoreLastChildNavWindow(g.NavWindow);
	if (layer == 0 && g.NavWindow->NavLastIds[0] != 0)
		SetNavIDWithRectRel(g.NavWindow->NavLastIds[0], layer, g.NavWindow->NavRectRel[0]);
	else
		ImGui::NavInitWindow(g.NavWindow, true);
}

static inline void NavUpdateAnyRequestFlag()
{
	ImGuiContext& g = *GImGui;
	g.NavAnyRequest = g.NavMoveRequest || g.NavInitRequest || (IMGUI_DEBUG_NAV_SCORING && g.NavWindow != NULL);
	if (g.NavAnyRequest)
		IM_ASSERT(g.NavWindow != NULL);
}

static bool NavMoveRequestButNoResultYet()
{
	ImGuiContext& g = *GImGui;
	return g.NavMoveRequest && g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0;
}

void ImGui::NavMoveRequestCancel()
{
	ImGuiContext& g = *GImGui;
	g.NavMoveRequest = false;
	NavUpdateAnyRequestFlag();
}

// We get there when either NavId == id, or when g.NavAnyRequest is set (which is updated by NavUpdateAnyRequestFlag above)
static void ImGui::NavProcessItem(ImGuiWindow* window, const ImRect& nav_bb, const ImGuiID id)
{
	ImGuiContext& g = *GImGui;
	//if (!g.IO.NavActive)  // [2017/10/06] Removed this possibly redundant test but I am not sure of all the side-effects yet. Some of the feature here will need to work regardless of using a _NoNavInputs flag.
	//    return;

	const ImGuiItemFlags item_flags = window->DC.ItemFlags;
	const ImRect nav_bb_rel(nav_bb.Min - window->Pos, nav_bb.Max - window->Pos);
	if (g.NavInitRequest && g.NavLayer == window->DC.NavLayerCurrent)
	{
		// Even if 'ImGuiItemFlags_NoNavDefaultFocus' is on (typically collapse/close button) we record the first ResultId so they can be used as a fallback
		if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus) || g.NavInitResultId == 0)
		{
			g.NavInitResultId = id;
			g.NavInitResultRectRel = nav_bb_rel;
		}
		if (!(item_flags & ImGuiItemFlags_NoNavDefaultFocus))
		{
			g.NavInitRequest = false; // Found a match, clear request
			NavUpdateAnyRequestFlag();
		}
	}

	// Scoring for navigation
	if (g.NavId != id && !(item_flags & ImGuiItemFlags_NoNav))
	{
		ImGuiNavMoveResult* result = (window == g.NavWindow) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
#if IMGUI_DEBUG_NAV_SCORING
		// [DEBUG] Score all items in NavWindow at all times
		if (!g.NavMoveRequest)
			g.NavMoveDir = g.NavMoveDirLast;
		bool new_best = NavScoreItem(result, nav_bb) && g.NavMoveRequest;
#else
		bool new_best = g.NavMoveRequest && NavScoreItem(result, nav_bb);
#endif
		if (new_best)
		{
			result->ID = id;
			result->ParentID = window->IDStack.back();
			result->Window = window;
			result->RectRel = nav_bb_rel;
		}
	}

	// Update window-relative bounding box of navigated item
	if (g.NavId == id)
	{
		g.NavWindow = window;                                           // Always refresh g.NavWindow, because some operations such as FocusItem() don't have a window.
		g.NavLayer = window->DC.NavLayerCurrent;
		g.NavIdIsAlive = true;
		g.NavIdTabCounter = window->FocusIdxTabCounter;
		window->NavRectRel[window->DC.NavLayerCurrent] = nav_bb_rel;    // Store item bounding box (relative to window position)
	}
}

// Declare item bounding box for clipping and interaction.
// Note that the size can be different than the one provided to ItemSize(). Typically, widgets that spread over available surface
// declare their minimum size requirement to ItemSize() and then use a larger region for drawing/interaction, which is passed to ItemAdd().
bool ImGui::ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb_arg)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	if (id != 0)
	{
		// Navigation processing runs prior to clipping early-out
		//  (a) So that NavInitRequest can be honored, for newly opened windows to select a default widget
		//  (b) So that we can scroll up/down past clipped items. This adds a small O(N) cost to regular navigation requests unfortunately, but it is still limited to one window.
		//      it may not scale very well for windows with ten of thousands of item, but at least NavMoveRequest is only set on user interaction, aka maximum once a frame.
		//      We could early out with "if (is_clipped && !g.NavInitRequest) return false;" but when we wouldn't be able to reach unclipped widgets. This would work if user had explicit scrolling control (e.g. mapped on a stick)
		window->DC.NavLayerActiveMaskNext |= window->DC.NavLayerCurrentMask;
		if (g.NavId == id || g.NavAnyRequest)
			if (g.NavWindow->RootWindowForNav == window->RootWindowForNav)
				if (window == g.NavWindow || ((window->Flags | g.NavWindow->Flags) & ImGuiWindowFlags_NavFlattened))
					NavProcessItem(window, nav_bb_arg ? *nav_bb_arg : bb, id);
	}

	window->DC.LastItemId = id;
	window->DC.LastItemRect = bb;
	window->DC.LastItemStatusFlags = 0;

	// Clipping test
	const bool is_clipped = IsClippedEx(bb, id, false);
	if (is_clipped)
		return false;
	//if (g.IO.KeyAlt) window->DrawList->AddRect(bb.Min, bb.Max, IM_COL32(255,255,0,120)); // [DEBUG]

	// We need to calculate this now to take account of the current clipping rectangle (as items like Selectable may change them)
	if (IsMouseHoveringRect(bb.Min, bb.Max))
		window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HoveredRect;
	return true;
}

// This is roughly matching the behavior of internal-facing ItemHoverable()
// - we allow hovering to be true when ActiveId==window->MoveID, so that clicking on non-interactive items such as a Text() item still returns true with IsItemHovered()
// - this should work even for non-interactive items that have no ID, so we cannot use LastItemId
bool ImGui::IsItemHovered(ImGuiHoveredFlags flags)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if (g.NavDisableMouseHover && !g.NavDisableHighlight)
		return IsItemFocused();

	// Test for bounding box overlap, as updated as ItemAdd()
	if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))
		return false;
	IM_ASSERT((flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows)) == 0);   // Flags not supported by this function

																								 // Test if we are hovering the right window (our window could be behind another window)
																								 // [2017/10/16] Reverted commit 344d48be3 and testing RootWindow instead. I believe it is correct to NOT test for RootWindow but this leaves us unable to use IsItemHovered() after EndChild() itself.
																								 // Until a solution is found I believe reverting to the test from 2017/09/27 is safe since this was the test that has been running for a long while.
																								 //if (g.HoveredWindow != window)
																								 //    return false;
	if (g.HoveredRootWindow != window->RootWindow && !(flags & ImGuiHoveredFlags_AllowWhenOverlapped))
		return false;

	// Test if another item is active (e.g. being dragged)
	if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
		if (g.ActiveId != 0 && g.ActiveId != window->DC.LastItemId && !g.ActiveIdAllowOverlap && g.ActiveId != window->MoveId)
			return false;

	// Test if interactions on this window are blocked by an active popup or modal
	if (!IsWindowContentHoverable(window, flags))
		return false;

	// Test if the item is disabled
	if (window->DC.ItemFlags & ImGuiItemFlags_Disabled)
		return false;

	// Special handling for the 1st item after Begin() which represent the title bar. When the window is collapsed (SkipItems==true) that last item will never be overwritten so we need to detect tht case.
	if (window->DC.LastItemId == window->MoveId && window->WriteAccessed)
		return false;
	return true;
}

// Internal facing ItemHoverable() used when submitting widgets. Differs slightly from IsItemHovered().
bool ImGui::ItemHoverable(const ImRect& bb, ImGuiID id)
{
	ImGuiContext& g = *GImGui;
	if (g.HoveredId != 0 && g.HoveredId != id && !g.HoveredIdAllowOverlap)
		return false;

	ImGuiWindow* window = g.CurrentWindow;
	if (g.HoveredWindow != window)
		return false;
	if (g.ActiveId != 0 && g.ActiveId != id && !g.ActiveIdAllowOverlap)
		return false;
	if (!IsMouseHoveringRect(bb.Min, bb.Max))
		return false;
	if (g.NavDisableMouseHover || !IsWindowContentHoverable(window, ImGuiHoveredFlags_Default))
		return false;
	if (window->DC.ItemFlags & ImGuiItemFlags_Disabled)
		return false;

	SetHoveredID(id);
	return true;
}

bool ImGui::IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if (!bb.Overlaps(window->ClipRect))
		if (id == 0 || id != g.ActiveId)
			if (clip_even_when_logged || !g.LogEnabled)
				return true;
	return false;
}

bool ImGui::FocusableItemRegister(ImGuiWindow* window, ImGuiID id, bool tab_stop)
{
	ImGuiContext& g = *GImGui;

	const bool allow_keyboard_focus = (window->DC.ItemFlags & (ImGuiItemFlags_AllowKeyboardFocus | ImGuiItemFlags_Disabled)) == ImGuiItemFlags_AllowKeyboardFocus;
	window->FocusIdxAllCounter++;
	if (allow_keyboard_focus)
		window->FocusIdxTabCounter++;

	// Process keyboard input at this point: TAB/Shift-TAB to tab out of the currently focused item.
	// Note that we can always TAB out of a widget that doesn't allow tabbing in.
	if (tab_stop && (g.ActiveId == id) && window->FocusIdxAllRequestNext == INT_MAX && window->FocusIdxTabRequestNext == INT_MAX && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab))
		window->FocusIdxTabRequestNext = window->FocusIdxTabCounter + (g.IO.KeyShift ? (allow_keyboard_focus ? -1 : 0) : +1); // Modulo on index will be applied at the end of frame once we've got the total counter of items.

	if (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent)
		return true;
	if (allow_keyboard_focus && window->FocusIdxTabCounter == window->FocusIdxTabRequestCurrent)
	{
		g.NavJustTabbedId = id;
		return true;
	}

	return false;
}

void ImGui::FocusableItemUnregister(ImGuiWindow* window)
{
	window->FocusIdxAllCounter--;
	window->FocusIdxTabCounter--;
}

ImVec2 ImGui::CalcItemSize(ImVec2 size, float default_x, float default_y)
{
	ImGuiContext& g = *GImGui;
	ImVec2 content_max;
	if (size.x < 0.0f || size.y < 0.0f)
		content_max = g.CurrentWindow->Pos + GetContentRegionMax();
	if (size.x <= 0.0f)
		size.x = (size.x == 0.0f) ? default_x : ImMax(content_max.x - g.CurrentWindow->DC.CursorPos.x, 4.0f) + size.x;
	if (size.y <= 0.0f)
		size.y = (size.y == 0.0f) ? default_y : ImMax(content_max.y - g.CurrentWindow->DC.CursorPos.y, 4.0f) + size.y;
	return size;
}

float ImGui::CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x)
{
	if (wrap_pos_x < 0.0f)
		return 0.0f;

	ImGuiWindow* window = GetCurrentWindowRead();
	if (wrap_pos_x == 0.0f)
		wrap_pos_x = GetContentRegionMax().x + window->Pos.x;
	else if (wrap_pos_x > 0.0f)
		wrap_pos_x += window->Pos.x - window->Scroll.x; // wrap_pos_x is provided is window local space

	return ImMax(wrap_pos_x - pos.x, 1.0f);
}

//-----------------------------------------------------------------------------

void* ImGui::MemAlloc(size_t sz)
{
	GImAllocatorActiveAllocationsCount++;
	return GImAllocatorAllocFunc(sz, GImAllocatorUserData);
}

void ImGui::MemFree(void* ptr)
{
	if (ptr) GImAllocatorActiveAllocationsCount--;
	return GImAllocatorFreeFunc(ptr, GImAllocatorUserData);
}

const char* ImGui::GetClipboardText()
{
	return GImGui->IO.GetClipboardTextFn ? GImGui->IO.GetClipboardTextFn(GImGui->IO.ClipboardUserData) : "";
}

void ImGui::SetClipboardText(const char* text)
{
	if (GImGui->IO.SetClipboardTextFn)
		GImGui->IO.SetClipboardTextFn(GImGui->IO.ClipboardUserData, text);
}

const char* ImGui::GetVersion()
{
	return IMGUI_VERSION;
}

// Internal state access - if you want to share ImGui state between modules (e.g. DLL) or allocate it yourself
// Note that we still point to some static data and members (such as GFontAtlas), so the state instance you end up using will point to the static data within its module
ImGuiContext* ImGui::GetCurrentContext()
{
	return GImGui;
}

void ImGui::SetCurrentContext(ImGuiContext* ctx)
{
#ifdef IMGUI_SET_CURRENT_CONTEXT_FUNC
	IMGUI_SET_CURRENT_CONTEXT_FUNC(ctx); // For custom thread-based hackery you may want to have control over this.
#else
	GImGui = ctx;
#endif
}

void ImGui::SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void(*free_func)(void* ptr, void* user_data), void* user_data)
{
	GImAllocatorAllocFunc = alloc_func;
	GImAllocatorFreeFunc = free_func;
	GImAllocatorUserData = user_data;
}

ImGuiContext* ImGui::CreateContext(ImFontAtlas* shared_font_atlas)
{
	ImGuiContext* ctx = IM_NEW(ImGuiContext)(shared_font_atlas);
	if (GImGui == NULL)
		SetCurrentContext(ctx);
	Initialize(ctx);
	return ctx;
}

void ImGui::DestroyContext(ImGuiContext* ctx)
{
	if (ctx == NULL)
		ctx = GImGui;
	Shutdown(ctx);
	if (GImGui == ctx)
		SetCurrentContext(NULL);
	IM_DELETE(ctx);
}

ImGuiIO& ImGui::GetIO()
{
	IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
	return GImGui->IO;
}

ImGuiStyle& ImGui::GetStyle()
{
	IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
	return GImGui->Style;
}

// Same value as passed to the old io.RenderDrawListsFn function. Valid after Render() and until the next call to NewFrame()
ImDrawData* ImGui::GetDrawData()
{
	ImGuiContext& g = *GImGui;
	return g.DrawData.Valid ? &g.DrawData : NULL;
}

float ImGui::GetTime()
{
	return GImGui->Time;
}

int ImGui::GetFrameCount()
{
	return GImGui->FrameCount;
}

ImDrawList* ImGui::GetOverlayDrawList()
{
	return &GImGui->OverlayDrawList;
}

ImDrawListSharedData* ImGui::GetDrawListSharedData()
{
	return &GImGui->DrawListSharedData;
}

// This needs to be called before we submit any widget (aka in or before Begin)
void ImGui::NavInitWindow(ImGuiWindow* window, bool force_reinit)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(window == g.NavWindow);
	bool init_for_nav = false;
	if (!(window->Flags & ImGuiWindowFlags_NoNavInputs))
		if (!(window->Flags & ImGuiWindowFlags_ChildWindow) || (window->Flags & ImGuiWindowFlags_Popup) || (window->NavLastIds[0] == 0) || force_reinit)
			init_for_nav = true;
	if (init_for_nav)
	{
		SetNavID(0, g.NavLayer);
		g.NavInitRequest = true;
		g.NavInitRequestFromMove = false;
		g.NavInitResultId = 0;
		g.NavInitResultRectRel = ImRect();
		NavUpdateAnyRequestFlag();
	}
	else
	{
		g.NavId = window->NavLastIds[0];
	}
}

static ImVec2 NavCalcPreferredMousePos()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.NavWindow;
	if (!window)
		return g.IO.MousePos;
	const ImRect& rect_rel = window->NavRectRel[g.NavLayer];
	ImVec2 pos = g.NavWindow->Pos + ImVec2(rect_rel.Min.x + ImMin(g.Style.FramePadding.x * 4, rect_rel.GetWidth()), rect_rel.Max.y - ImMin(g.Style.FramePadding.y, rect_rel.GetHeight()));
	ImRect visible_rect = GetViewportRect();
	return ImFloor(ImClamp(pos, visible_rect.Min, visible_rect.Max));   // ImFloor() is important because non-integer mouse position application in back-end might be lossy and result in undesirable non-zero delta.
}

static int FindWindowIndex(ImGuiWindow* window) // FIXME-OPT O(N)
{
	ImGuiContext& g = *GImGui;
	for (int i = g.Windows.Size - 1; i >= 0; i--)
		if (g.Windows[i] == window)
			return i;
	return -1;
}

static ImGuiWindow* FindWindowNavigable(int i_start, int i_stop, int dir) // FIXME-OPT O(N)
{
	ImGuiContext& g = *GImGui;
	for (int i = i_start; i >= 0 && i < g.Windows.Size && i != i_stop; i += dir)
		if (ImGui::IsWindowNavFocusable(g.Windows[i]))
			return g.Windows[i];
	return NULL;
}

float ImGui::GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode)
{
	ImGuiContext& g = *GImGui;
	if (mode == ImGuiInputReadMode_Down)
		return g.IO.NavInputs[n];                         // Instant, read analog input (0.0f..1.0f, as provided by user)

	const float t = g.IO.NavInputsDownDuration[n];
	if (t < 0.0f && mode == ImGuiInputReadMode_Released)  // Return 1.0f when just released, no repeat, ignore analog input.
		return (g.IO.NavInputsDownDurationPrev[n] >= 0.0f ? 1.0f : 0.0f);
	if (t < 0.0f)
		return 0.0f;
	if (mode == ImGuiInputReadMode_Pressed)               // Return 1.0f when just pressed, no repeat, ignore analog input.
		return (t == 0.0f) ? 1.0f : 0.0f;
	if (mode == ImGuiInputReadMode_Repeat)
		return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.80f);
	if (mode == ImGuiInputReadMode_RepeatSlow)
		return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 1.00f, g.IO.KeyRepeatRate * 2.00f);
	if (mode == ImGuiInputReadMode_RepeatFast)
		return (float)CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, g.IO.KeyRepeatDelay * 0.80f, g.IO.KeyRepeatRate * 0.30f);
	return 0.0f;
}

// Equivalent of IsKeyDown() for NavInputs[]
static bool IsNavInputDown(ImGuiNavInput n)
{
	return GImGui->IO.NavInputs[n] > 0.0f;
}

// Equivalent of IsKeyPressed() for NavInputs[]
static bool IsNavInputPressed(ImGuiNavInput n, ImGuiInputReadMode mode)
{
	return ImGui::GetNavInputAmount(n, mode) > 0.0f;
}

static bool IsNavInputPressedAnyOfTwo(ImGuiNavInput n1, ImGuiNavInput n2, ImGuiInputReadMode mode)
{
	return (ImGui::GetNavInputAmount(n1, mode) + ImGui::GetNavInputAmount(n2, mode)) > 0.0f;
}

ImVec2 ImGui::GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor, float fast_factor)
{
	ImVec2 delta(0.0f, 0.0f);
	if (dir_sources & ImGuiNavDirSourceFlags_Keyboard)
		delta += ImVec2(GetNavInputAmount(ImGuiNavInput_KeyRight_, mode) - GetNavInputAmount(ImGuiNavInput_KeyLeft_, mode), GetNavInputAmount(ImGuiNavInput_KeyDown_, mode) - GetNavInputAmount(ImGuiNavInput_KeyUp_, mode));
	if (dir_sources & ImGuiNavDirSourceFlags_PadDPad)
		delta += ImVec2(GetNavInputAmount(ImGuiNavInput_DpadRight, mode) - GetNavInputAmount(ImGuiNavInput_DpadLeft, mode), GetNavInputAmount(ImGuiNavInput_DpadDown, mode) - GetNavInputAmount(ImGuiNavInput_DpadUp, mode));
	if (dir_sources & ImGuiNavDirSourceFlags_PadLStick)
		delta += ImVec2(GetNavInputAmount(ImGuiNavInput_LStickRight, mode) - GetNavInputAmount(ImGuiNavInput_LStickLeft, mode), GetNavInputAmount(ImGuiNavInput_LStickDown, mode) - GetNavInputAmount(ImGuiNavInput_LStickUp, mode));
	if (slow_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakSlow))
		delta *= slow_factor;
	if (fast_factor != 0.0f && IsNavInputDown(ImGuiNavInput_TweakFast))
		delta *= fast_factor;
	return delta;
}

static void NavUpdateWindowingHighlightWindow(int focus_change_dir)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(g.NavWindowingTarget);
	if (g.NavWindowingTarget->Flags & ImGuiWindowFlags_Modal)
		return;

	const int i_current = FindWindowIndex(g.NavWindowingTarget);
	ImGuiWindow* window_target = FindWindowNavigable(i_current + focus_change_dir, -INT_MAX, focus_change_dir);
	if (!window_target)
		window_target = FindWindowNavigable((focus_change_dir < 0) ? (g.Windows.Size - 1) : 0, i_current, focus_change_dir);
	g.NavWindowingTarget = window_target;
	g.NavWindowingToggleLayer = false;
}

// Window management mode (hold to: change focus/move/resize, tap to: toggle menu layer)
static void ImGui::NavUpdateWindowing()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* apply_focus_window = NULL;
	bool apply_toggle_layer = false;

	bool start_windowing_with_gamepad = !g.NavWindowingTarget && IsNavInputPressed(ImGuiNavInput_Menu, ImGuiInputReadMode_Pressed);
	bool start_windowing_with_keyboard = !g.NavWindowingTarget && g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab) && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard);
	if (start_windowing_with_gamepad || start_windowing_with_keyboard)
		if (ImGuiWindow* window = g.NavWindow ? g.NavWindow : FindWindowNavigable(g.Windows.Size - 1, -INT_MAX, -1))
		{
			g.NavWindowingTarget = window->RootWindowForTabbing;
			g.NavWindowingHighlightTimer = g.NavWindowingHighlightAlpha = 0.0f;
			g.NavWindowingToggleLayer = start_windowing_with_keyboard ? false : true;
			g.NavInputSource = start_windowing_with_keyboard ? ImGuiInputSource_NavKeyboard : ImGuiInputSource_NavGamepad;
		}

	// Gamepad update
	g.NavWindowingHighlightTimer += g.IO.DeltaTime;
	if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavGamepad)
	{
		// Highlight only appears after a brief time holding the button, so that a fast tap on PadMenu (to toggle NavLayer) doesn't add visual noise
		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingHighlightTimer - 0.20f) / 0.05f));

		// Select window to focus
		const int focus_change_dir = (int)IsNavInputPressed(ImGuiNavInput_FocusPrev, ImGuiInputReadMode_RepeatSlow) - (int)IsNavInputPressed(ImGuiNavInput_FocusNext, ImGuiInputReadMode_RepeatSlow);
		if (focus_change_dir != 0)
		{
			NavUpdateWindowingHighlightWindow(focus_change_dir);
			g.NavWindowingHighlightAlpha = 1.0f;
		}

		// Single press toggles NavLayer, long press with L/R apply actual focus on release (until then the window was merely rendered front-most)
		if (!IsNavInputDown(ImGuiNavInput_Menu))
		{
			g.NavWindowingToggleLayer &= (g.NavWindowingHighlightAlpha < 1.0f); // Once button was held long enough we don't consider it a tap-to-toggle-layer press anymore.
			if (g.NavWindowingToggleLayer && g.NavWindow)
				apply_toggle_layer = true;
			else if (!g.NavWindowingToggleLayer)
				apply_focus_window = g.NavWindowingTarget;
			g.NavWindowingTarget = NULL;
		}
	}

	// Keyboard: Focus
	if (g.NavWindowingTarget && g.NavInputSource == ImGuiInputSource_NavKeyboard)
	{
		// Visuals only appears after a brief time after pressing TAB the first time, so that a fast CTRL+TAB doesn't add visual noise
		g.NavWindowingHighlightAlpha = ImMax(g.NavWindowingHighlightAlpha, ImSaturate((g.NavWindowingHighlightTimer - 0.15f) / 0.04f)); // 1.0f
		if (IsKeyPressedMap(ImGuiKey_Tab, true))
			NavUpdateWindowingHighlightWindow(g.IO.KeyShift ? +1 : -1);
		if (!g.IO.KeyCtrl)
			apply_focus_window = g.NavWindowingTarget;
	}

	// Keyboard: Press and Release ALT to toggle menu layer
	// FIXME: We lack an explicit IO variable for "is the imgui window focused", so compare mouse validity to detect the common case of back-end clearing releases all keys on ALT-TAB
	if ((g.ActiveId == 0 || g.ActiveIdAllowOverlap) && IsNavInputPressed(ImGuiNavInput_KeyMenu_, ImGuiInputReadMode_Released))
		if (IsMousePosValid(&g.IO.MousePos) == IsMousePosValid(&g.IO.MousePosPrev))
			apply_toggle_layer = true;

	// Move window
	if (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoMove))
	{
		ImVec2 move_delta;
		if (g.NavInputSource == ImGuiInputSource_NavKeyboard && !g.IO.KeyShift)
			move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);
		if (g.NavInputSource == ImGuiInputSource_NavGamepad)
			move_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down);
		if (move_delta.x != 0.0f || move_delta.y != 0.0f)
		{
			const float NAV_MOVE_SPEED = 800.0f;
			const float move_speed = ImFloor(NAV_MOVE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));
			g.NavWindowingTarget->PosFloat += move_delta * move_speed;
			g.NavDisableMouseHover = true;
			MarkIniSettingsDirty(g.NavWindowingTarget);
		}
	}

	// Apply final focus
	if (apply_focus_window && (g.NavWindow == NULL || apply_focus_window != g.NavWindow->RootWindowForTabbing))
	{
		g.NavDisableHighlight = false;
		g.NavDisableMouseHover = true;
		apply_focus_window = NavRestoreLastChildNavWindow(apply_focus_window);
		ClosePopupsOverWindow(apply_focus_window);
		FocusWindow(apply_focus_window);
		if (apply_focus_window->NavLastIds[0] == 0)
			NavInitWindow(apply_focus_window, false);

		// If the window only has a menu layer, select it directly
		if (apply_focus_window->DC.NavLayerActiveMask == (1 << 1))
			g.NavLayer = 1;
	}
	if (apply_focus_window)
		g.NavWindowingTarget = NULL;

	// Apply menu/layer toggle
	if (apply_toggle_layer && g.NavWindow)
	{
		ImGuiWindow* new_nav_window = g.NavWindow;
		while ((new_nav_window->DC.NavLayerActiveMask & (1 << 1)) == 0 && (new_nav_window->Flags & ImGuiWindowFlags_ChildWindow) != 0 && (new_nav_window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) == 0)
			new_nav_window = new_nav_window->ParentWindow;
		if (new_nav_window != g.NavWindow)
		{
			ImGuiWindow* old_nav_window = g.NavWindow;
			FocusWindow(new_nav_window);
			new_nav_window->NavLastChildNavWindow = old_nav_window;
		}
		g.NavDisableHighlight = false;
		g.NavDisableMouseHover = true;
		NavRestoreLayer((g.NavWindow->DC.NavLayerActiveMask & (1 << 1)) ? (g.NavLayer ^ 1) : 0);
	}
}

// NB: We modify rect_rel by the amount we scrolled for, so it is immediately updated.
static void NavScrollToBringItemIntoView(ImGuiWindow* window, ImRect& item_rect_rel)
{
	// Scroll to keep newly navigated item fully into view
	ImRect window_rect_rel(window->InnerRect.Min - window->Pos - ImVec2(1, 1), window->InnerRect.Max - window->Pos + ImVec2(1, 1));
	//g.OverlayDrawList.AddRect(window->Pos + window_rect_rel.Min, window->Pos + window_rect_rel.Max, IM_COL32_WHITE); // [DEBUG]
	if (window_rect_rel.Contains(item_rect_rel))
		return;

	ImGuiContext& g = *GImGui;
	if (window->ScrollbarX && item_rect_rel.Min.x < window_rect_rel.Min.x)
	{
		window->ScrollTarget.x = item_rect_rel.Min.x + window->Scroll.x - g.Style.ItemSpacing.x;
		window->ScrollTargetCenterRatio.x = 0.0f;
	}
	else if (window->ScrollbarX && item_rect_rel.Max.x >= window_rect_rel.Max.x)
	{
		window->ScrollTarget.x = item_rect_rel.Max.x + window->Scroll.x + g.Style.ItemSpacing.x;
		window->ScrollTargetCenterRatio.x = 1.0f;
	}
	if (item_rect_rel.Min.y < window_rect_rel.Min.y)
	{
		window->ScrollTarget.y = item_rect_rel.Min.y + window->Scroll.y - g.Style.ItemSpacing.y;
		window->ScrollTargetCenterRatio.y = 0.0f;
	}
	else if (item_rect_rel.Max.y >= window_rect_rel.Max.y)
	{
		window->ScrollTarget.y = item_rect_rel.Max.y + window->Scroll.y + g.Style.ItemSpacing.y;
		window->ScrollTargetCenterRatio.y = 1.0f;
	}

	// Estimate upcoming scroll so we can offset our relative mouse position so mouse position can be applied immediately (under this block)
	ImVec2 next_scroll = CalcNextScrollFromScrollTargetAndClamp(window);
	item_rect_rel.Translate(window->Scroll - next_scroll);
}

static void ImGui::NavUpdate()
{
	ImGuiContext& g = *GImGui;
	g.IO.WantSetMousePos = false;

#if 0
	if (g.NavScoringCount > 0) printf("[%05d] NavScoringCount %d for '%s' layer %d (Init:%d, Move:%d)\n", g.FrameCount, g.NavScoringCount, g.NavWindow ? g.NavWindow->Name : "NULL", g.NavLayer, g.NavInitRequest || g.NavInitResultId != 0, g.NavMoveRequest);
#endif

	if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad))
		if (g.IO.NavInputs[ImGuiNavInput_Activate] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Input] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Cancel] > 0.0f || g.IO.NavInputs[ImGuiNavInput_Menu] > 0.0f)
			g.NavInputSource = ImGuiInputSource_NavGamepad;

	// Update Keyboard->Nav inputs mapping
	if (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)
	{
#define NAV_MAP_KEY(_KEY, _NAV_INPUT) if (IsKeyDown(g.IO.KeyMap[_KEY])) { g.IO.NavInputs[_NAV_INPUT] = 1.0f; g.NavInputSource = ImGuiInputSource_NavKeyboard; }
		NAV_MAP_KEY(ImGuiKey_Space, ImGuiNavInput_Activate);
		NAV_MAP_KEY(ImGuiKey_Enter, ImGuiNavInput_Input);
		NAV_MAP_KEY(ImGuiKey_Escape, ImGuiNavInput_Cancel);
		NAV_MAP_KEY(ImGuiKey_LeftArrow, ImGuiNavInput_KeyLeft_);
		NAV_MAP_KEY(ImGuiKey_RightArrow, ImGuiNavInput_KeyRight_);
		NAV_MAP_KEY(ImGuiKey_UpArrow, ImGuiNavInput_KeyUp_);
		NAV_MAP_KEY(ImGuiKey_DownArrow, ImGuiNavInput_KeyDown_);
		if (g.IO.KeyCtrl)   g.IO.NavInputs[ImGuiNavInput_TweakSlow] = 1.0f;
		if (g.IO.KeyShift)  g.IO.NavInputs[ImGuiNavInput_TweakFast] = 1.0f;
		if (g.IO.KeyAlt)    g.IO.NavInputs[ImGuiNavInput_KeyMenu_] = 1.0f;
#undef NAV_MAP_KEY
	}

	memcpy(g.IO.NavInputsDownDurationPrev, g.IO.NavInputsDownDuration, sizeof(g.IO.NavInputsDownDuration));
	for (int i = 0; i < IM_ARRAYSIZE(g.IO.NavInputs); i++)
		g.IO.NavInputsDownDuration[i] = (g.IO.NavInputs[i] > 0.0f) ? (g.IO.NavInputsDownDuration[i] < 0.0f ? 0.0f : g.IO.NavInputsDownDuration[i] + g.IO.DeltaTime) : -1.0f;

	// Process navigation init request (select first/default focus)
	if (g.NavInitResultId != 0 && (!g.NavDisableHighlight || g.NavInitRequestFromMove))
	{
		// Apply result from previous navigation init request (will typically select the first item, unless SetItemDefaultFocus() has been called)
		IM_ASSERT(g.NavWindow);
		if (g.NavInitRequestFromMove)
			SetNavIDWithRectRel(g.NavInitResultId, g.NavLayer, g.NavInitResultRectRel);
		else
			SetNavID(g.NavInitResultId, g.NavLayer);
		g.NavWindow->NavRectRel[g.NavLayer] = g.NavInitResultRectRel;
	}
	g.NavInitRequest = false;
	g.NavInitRequestFromMove = false;
	g.NavInitResultId = 0;
	g.NavJustMovedToId = 0;

	// Process navigation move request
	if (g.NavMoveRequest && (g.NavMoveResultLocal.ID != 0 || g.NavMoveResultOther.ID != 0))
	{
		// Select which result to use
		ImGuiNavMoveResult* result = (g.NavMoveResultLocal.ID != 0) ? &g.NavMoveResultLocal : &g.NavMoveResultOther;
		if (g.NavMoveResultOther.ID != 0 && g.NavMoveResultOther.Window->ParentWindow == g.NavWindow) // Maybe entering a flattened child? In this case solve the tie using the regular scoring rules
			if ((g.NavMoveResultOther.DistBox < g.NavMoveResultLocal.DistBox) || (g.NavMoveResultOther.DistBox == g.NavMoveResultLocal.DistBox && g.NavMoveResultOther.DistCenter < g.NavMoveResultLocal.DistCenter))
				result = &g.NavMoveResultOther;

		IM_ASSERT(g.NavWindow && result->Window);

		// Scroll to keep newly navigated item fully into view
		if (g.NavLayer == 0)
			NavScrollToBringItemIntoView(result->Window, result->RectRel);

		// Apply result from previous frame navigation directional move request
		ClearActiveID();
		g.NavWindow = result->Window;
		SetNavIDWithRectRel(result->ID, g.NavLayer, result->RectRel);
		g.NavJustMovedToId = result->ID;
		g.NavMoveFromClampedRefRect = false;
	}

	// When a forwarded move request failed, we restore the highlight that we disabled during the forward frame
	if (g.NavMoveRequestForward == ImGuiNavForward_ForwardActive)
	{
		IM_ASSERT(g.NavMoveRequest);
		if (g.NavMoveResultLocal.ID == 0 && g.NavMoveResultOther.ID == 0)
			g.NavDisableHighlight = false;
		g.NavMoveRequestForward = ImGuiNavForward_None;
	}

	// Apply application mouse position movement, after we had a chance to process move request result.
	if (g.NavMousePosDirty && g.NavIdIsAlive)
	{
		// Set mouse position given our knowledge of the nav widget position from last frame
		if ((g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) && (g.IO.BackendFlags & ImGuiBackendFlags_HasSetMousePos))
		{
			g.IO.MousePos = g.IO.MousePosPrev = NavCalcPreferredMousePos();
			g.IO.WantSetMousePos = true;
		}
		g.NavMousePosDirty = false;
	}
	g.NavIdIsAlive = false;
	g.NavJustTabbedId = 0;
	IM_ASSERT(g.NavLayer == 0 || g.NavLayer == 1);

	// Store our return window (for returning from Layer 1 to Layer 0) and clear it as soon as we step back in our own Layer 0
	if (g.NavWindow)
		NavSaveLastChildNavWindow(g.NavWindow);
	if (g.NavWindow && g.NavWindow->NavLastChildNavWindow != NULL && g.NavLayer == 0)
		g.NavWindow->NavLastChildNavWindow = NULL;

	NavUpdateWindowing();

	// Set output flags for user application
	bool nav_keyboard_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) != 0;
	bool nav_gamepad_active = (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableGamepad) != 0 && (g.IO.BackendFlags & ImGuiBackendFlags_HasGamepad) != 0;
	g.IO.NavActive = (nav_keyboard_active || nav_gamepad_active) && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs);
	g.IO.NavVisible = (g.IO.NavActive && g.NavId != 0 && !g.NavDisableHighlight) || (g.NavWindowingTarget != NULL) || g.NavInitRequest;

	// Process NavCancel input (to close a popup, get back to parent, clear focus)
	if (IsNavInputPressed(ImGuiNavInput_Cancel, ImGuiInputReadMode_Pressed))
	{
		if (g.ActiveId != 0)
		{
			ClearActiveID();
		}
		else if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow) && !(g.NavWindow->Flags & ImGuiWindowFlags_Popup) && g.NavWindow->ParentWindow)
		{
			// Exit child window
			ImGuiWindow* child_window = g.NavWindow;
			ImGuiWindow* parent_window = g.NavWindow->ParentWindow;
			IM_ASSERT(child_window->ChildId != 0);
			FocusWindow(parent_window);
			SetNavID(child_window->ChildId, 0);
			g.NavIdIsAlive = false;
			if (g.NavDisableMouseHover)
				g.NavMousePosDirty = true;
		}
		else if (g.OpenPopupStack.Size > 0)
		{
			// Close open popup/menu
			if (!(g.OpenPopupStack.back().Window->Flags & ImGuiWindowFlags_Modal))
				ClosePopupToLevel(g.OpenPopupStack.Size - 1);
		}
		else if (g.NavLayer != 0)
		{
			// Leave the "menu" layer
			NavRestoreLayer(0);
		}
		else
		{
			// Clear NavLastId for popups but keep it for regular child window so we can leave one and come back where we were
			if (g.NavWindow && ((g.NavWindow->Flags & ImGuiWindowFlags_Popup) || !(g.NavWindow->Flags & ImGuiWindowFlags_ChildWindow)))
				g.NavWindow->NavLastIds[0] = 0;
			g.NavId = 0;
		}
	}

	// Process manual activation request
	g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = 0;
	if (g.NavId != 0 && !g.NavDisableHighlight && !g.NavWindowingTarget && g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
	{
		bool activate_down = IsNavInputDown(ImGuiNavInput_Activate);
		bool activate_pressed = activate_down && IsNavInputPressed(ImGuiNavInput_Activate, ImGuiInputReadMode_Pressed);
		if (g.ActiveId == 0 && activate_pressed)
			g.NavActivateId = g.NavId;
		if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_down)
			g.NavActivateDownId = g.NavId;
		if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && activate_pressed)
			g.NavActivatePressedId = g.NavId;
		if ((g.ActiveId == 0 || g.ActiveId == g.NavId) && IsNavInputPressed(ImGuiNavInput_Input, ImGuiInputReadMode_Pressed))
			g.NavInputId = g.NavId;
	}
	if (g.NavWindow && (g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
		g.NavDisableHighlight = true;
	if (g.NavActivateId != 0)
		IM_ASSERT(g.NavActivateDownId == g.NavActivateId);
	g.NavMoveRequest = false;

	// Process programmatic activation request
	if (g.NavNextActivateId != 0)
		g.NavActivateId = g.NavActivateDownId = g.NavActivatePressedId = g.NavInputId = g.NavNextActivateId;
	g.NavNextActivateId = 0;

	// Initiate directional inputs request
	const int allowed_dir_flags = (g.ActiveId == 0) ? ~0 : g.ActiveIdAllowNavDirFlags;
	if (g.NavMoveRequestForward == ImGuiNavForward_None)
	{
		g.NavMoveDir = ImGuiDir_None;
		if (g.NavWindow && !g.NavWindowingTarget && allowed_dir_flags && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs))
		{
			if ((allowed_dir_flags & (1 << ImGuiDir_Left)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadLeft, ImGuiNavInput_KeyLeft_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Left;
			if ((allowed_dir_flags & (1 << ImGuiDir_Right)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadRight, ImGuiNavInput_KeyRight_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Right;
			if ((allowed_dir_flags & (1 << ImGuiDir_Up)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadUp, ImGuiNavInput_KeyUp_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Up;
			if ((allowed_dir_flags & (1 << ImGuiDir_Down)) && IsNavInputPressedAnyOfTwo(ImGuiNavInput_DpadDown, ImGuiNavInput_KeyDown_, ImGuiInputReadMode_Repeat)) g.NavMoveDir = ImGuiDir_Down;
		}
	}
	else
	{
		// Forwarding previous request (which has been modified, e.g. wrap around menus rewrite the requests with a starting rectangle at the other side of the window)
		IM_ASSERT(g.NavMoveDir != ImGuiDir_None);
		IM_ASSERT(g.NavMoveRequestForward == ImGuiNavForward_ForwardQueued);
		g.NavMoveRequestForward = ImGuiNavForward_ForwardActive;
	}

	if (g.NavMoveDir != ImGuiDir_None)
	{
		g.NavMoveRequest = true;
		g.NavMoveDirLast = g.NavMoveDir;
	}

	// If we initiate a movement request and have no current NavId, we initiate a InitDefautRequest that will be used as a fallback if the direction fails to find a match
	if (g.NavMoveRequest && g.NavId == 0)
	{
		g.NavInitRequest = g.NavInitRequestFromMove = true;
		g.NavInitResultId = 0;
		g.NavDisableHighlight = false;
	}

	NavUpdateAnyRequestFlag();

	// Scrolling
	if (g.NavWindow && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.NavWindowingTarget)
	{
		// *Fallback* manual-scroll with NavUp/NavDown when window has no navigable item
		ImGuiWindow* window = g.NavWindow;
		const float scroll_speed = ImFloor(window->CalcFontSize() * 100 * g.IO.DeltaTime + 0.5f); // We need round the scrolling speed because sub-pixel scroll isn't reliably supported.
		if (window->DC.NavLayerActiveMask == 0x00 && window->DC.NavHasScroll && g.NavMoveRequest)
		{
			if (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right)
				SetWindowScrollX(window, ImFloor(window->Scroll.x + ((g.NavMoveDir == ImGuiDir_Left) ? -1.0f : +1.0f) * scroll_speed));
			if (g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down)
				SetWindowScrollY(window, ImFloor(window->Scroll.y + ((g.NavMoveDir == ImGuiDir_Up) ? -1.0f : +1.0f) * scroll_speed));
		}

		// *Normal* Manual scroll with NavScrollXXX keys
		// Next movement request will clamp the NavId reference rectangle to the visible area, so navigation will resume within those bounds.
		ImVec2 scroll_dir = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadLStick, ImGuiInputReadMode_Down, 1.0f / 10.0f, 10.0f);
		if (scroll_dir.x != 0.0f && window->ScrollbarX)
		{
			SetWindowScrollX(window, ImFloor(window->Scroll.x + scroll_dir.x * scroll_speed));
			g.NavMoveFromClampedRefRect = true;
		}
		if (scroll_dir.y != 0.0f)
		{
			SetWindowScrollY(window, ImFloor(window->Scroll.y + scroll_dir.y * scroll_speed));
			g.NavMoveFromClampedRefRect = true;
		}
	}

	// Reset search results
	g.NavMoveResultLocal.Clear();
	g.NavMoveResultOther.Clear();

	// When we have manually scrolled (without using navigation) and NavId becomes out of bounds, we project its bounding box to the visible area to restart navigation within visible items
	if (g.NavMoveRequest && g.NavMoveFromClampedRefRect && g.NavLayer == 0)
	{
		ImGuiWindow* window = g.NavWindow;
		ImRect window_rect_rel(window->InnerRect.Min - window->Pos - ImVec2(1, 1), window->InnerRect.Max - window->Pos + ImVec2(1, 1));
		if (!window_rect_rel.Contains(window->NavRectRel[g.NavLayer]))
		{
			float pad = window->CalcFontSize() * 0.5f;
			window_rect_rel.Expand(ImVec2(-ImMin(window_rect_rel.GetWidth(), pad), -ImMin(window_rect_rel.GetHeight(), pad))); // Terrible approximation for the intent of starting navigation from first fully visible item
			window->NavRectRel[g.NavLayer].ClipWith(window_rect_rel);
			g.NavId = 0;
		}
		g.NavMoveFromClampedRefRect = false;
	}

	// For scoring we use a single segment on the left side our current item bounding box (not touching the edge to avoid box overlap with zero-spaced items)
	ImRect nav_rect_rel = (g.NavWindow && !g.NavWindow->NavRectRel[g.NavLayer].IsInverted()) ? g.NavWindow->NavRectRel[g.NavLayer] : ImRect(0, 0, 0, 0);
	g.NavScoringRectScreen = g.NavWindow ? ImRect(g.NavWindow->Pos + nav_rect_rel.Min, g.NavWindow->Pos + nav_rect_rel.Max) : GetViewportRect();
	g.NavScoringRectScreen.Min.x = ImMin(g.NavScoringRectScreen.Min.x + 1.0f, g.NavScoringRectScreen.Max.x);
	g.NavScoringRectScreen.Max.x = g.NavScoringRectScreen.Min.x;
	IM_ASSERT(!g.NavScoringRectScreen.IsInverted()); // Ensure if we have a finite, non-inverted bounding box here will allows us to remove extraneous fabsf() calls in NavScoreItem().
													 //g.OverlayDrawList.AddRect(g.NavScoringRectScreen.Min, g.NavScoringRectScreen.Max, IM_COL32(255,200,0,255)); // [DEBUG]
	g.NavScoringCount = 0;
#if IMGUI_DEBUG_NAV_RECTS
	if (g.NavWindow) { for (int layer = 0; layer < 2; layer++) g.OverlayDrawList.AddRect(g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Min, g.NavWindow->Pos + g.NavWindow->NavRectRel[layer].Max, IM_COL32(255, 200, 0, 255)); } // [DEBUG]
	if (g.NavWindow) { ImU32 col = (g.NavWindow->HiddenFrames == 0) ? IM_COL32(255, 0, 255, 255) : IM_COL32(255, 0, 0, 255); ImVec2 p = NavCalcPreferredMousePos(); char buf[32]; ImFormatString(buf, 32, "%d", g.NavLayer); g.OverlayDrawList.AddCircleFilled(p, 3.0f, col); g.OverlayDrawList.AddText(NULL, 13.0f, p + ImVec2(8, -4), col, buf); }
#endif
}

static void ImGui::NewFrameUpdateMovingWindow()
{
	ImGuiContext& g = *GImGui;
	if (g.MovingWindow && g.MovingWindow->MoveId == g.ActiveId && g.ActiveIdSource == ImGuiInputSource_Mouse)
	{
		// We actually want to move the root window. g.MovingWindow == window we clicked on (could be a child window).
		// We track it to preserve Focus and so that ActiveIdWindow == MovingWindow and ActiveId == MovingWindow->MoveId for consistency.
		KeepAliveID(g.ActiveId);
		IM_ASSERT(g.MovingWindow && g.MovingWindow->RootWindow);
		ImGuiWindow* moving_window = g.MovingWindow->RootWindow;
		if (g.IO.MouseDown[0])
		{
			ImVec2 pos = g.IO.MousePos - g.ActiveIdClickOffset;
			if (moving_window->PosFloat.x != pos.x || moving_window->PosFloat.y != pos.y)
			{
				MarkIniSettingsDirty(moving_window);
				moving_window->PosFloat = pos;
			}
			FocusWindow(g.MovingWindow);
		}
		else
		{
			ClearActiveID();
			g.MovingWindow = NULL;
		}
	}
	else
	{
		// When clicking/dragging from a window that has the _NoMove flag, we still set the ActiveId in order to prevent hovering others.
		if (g.ActiveIdWindow && g.ActiveIdWindow->MoveId == g.ActiveId)
		{
			KeepAliveID(g.ActiveId);
			if (!g.IO.MouseDown[0])
				ClearActiveID();
		}
		g.MovingWindow = NULL;
	}
}

static void ImGui::NewFrameUpdateMouseInputs()
{
	ImGuiContext& g = *GImGui;

	// If mouse just appeared or disappeared (usually denoted by -FLT_MAX component, but in reality we test for -256000.0f) we cancel out movement in MouseDelta
	if (ImGui::IsMousePosValid(&g.IO.MousePos) && ImGui::IsMousePosValid(&g.IO.MousePosPrev))
		g.IO.MouseDelta = g.IO.MousePos - g.IO.MousePosPrev;
	else
		g.IO.MouseDelta = ImVec2(0.0f, 0.0f);
	if (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f)
		g.NavDisableMouseHover = false;

	g.IO.MousePosPrev = g.IO.MousePos;
	for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
	{
		g.IO.MouseClicked[i] = g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] < 0.0f;
		g.IO.MouseReleased[i] = !g.IO.MouseDown[i] && g.IO.MouseDownDuration[i] >= 0.0f;
		g.IO.MouseDownDurationPrev[i] = g.IO.MouseDownDuration[i];
		g.IO.MouseDownDuration[i] = g.IO.MouseDown[i] ? (g.IO.MouseDownDuration[i] < 0.0f ? 0.0f : g.IO.MouseDownDuration[i] + g.IO.DeltaTime) : -1.0f;
		g.IO.MouseDoubleClicked[i] = false;
		if (g.IO.MouseClicked[i])
		{
			if (g.Time - g.IO.MouseClickedTime[i] < g.IO.MouseDoubleClickTime)
			{
				if (ImLengthSqr(g.IO.MousePos - g.IO.MouseClickedPos[i]) < g.IO.MouseDoubleClickMaxDist * g.IO.MouseDoubleClickMaxDist)
					g.IO.MouseDoubleClicked[i] = true;
				g.IO.MouseClickedTime[i] = -FLT_MAX;    // so the third click isn't turned into a double-click
			}
			else
			{
				g.IO.MouseClickedTime[i] = g.Time;
			}
			g.IO.MouseClickedPos[i] = g.IO.MousePos;
			g.IO.MouseDragMaxDistanceAbs[i] = ImVec2(0.0f, 0.0f);
			g.IO.MouseDragMaxDistanceSqr[i] = 0.0f;
		}
		else if (g.IO.MouseDown[i])
		{
			ImVec2 mouse_delta = g.IO.MousePos - g.IO.MouseClickedPos[i];
			g.IO.MouseDragMaxDistanceAbs[i].x = ImMax(g.IO.MouseDragMaxDistanceAbs[i].x, mouse_delta.x < 0.0f ? -mouse_delta.x : mouse_delta.x);
			g.IO.MouseDragMaxDistanceAbs[i].y = ImMax(g.IO.MouseDragMaxDistanceAbs[i].y, mouse_delta.y < 0.0f ? -mouse_delta.y : mouse_delta.y);
			g.IO.MouseDragMaxDistanceSqr[i] = ImMax(g.IO.MouseDragMaxDistanceSqr[i], ImLengthSqr(mouse_delta));
		}
		if (g.IO.MouseClicked[i]) // Clicking any mouse button reactivate mouse hovering which may have been deactivated by gamepad/keyboard navigation
			g.NavDisableMouseHover = false;
	}
}

// The reason this is exposed in imgui_internal.h is: on touch-based system that don't have hovering, we want to dispatch inputs to the right target (imgui vs imgui+app)
void ImGui::NewFrameUpdateHoveredWindowAndCaptureFlags()
{
	ImGuiContext& g = *GImGui;

	// Find the window hovered by mouse:
	// - Child windows can extend beyond the limit of their parent so we need to derive HoveredRootWindow from HoveredWindow.
	// - When moving a window we can skip the search, which also conveniently bypasses the fact that window->WindowRectClipped is lagging as this point of the frame.
	// - We also support the moved window toggling the NoInputs flag after moving has started in order to be able to detect windows below it, which is useful for e.g. docking mechanisms.
	g.HoveredWindow = (g.MovingWindow && !(g.MovingWindow->Flags & ImGuiWindowFlags_NoInputs)) ? g.MovingWindow : FindHoveredWindow();
	g.HoveredRootWindow = g.HoveredWindow ? g.HoveredWindow->RootWindow : NULL;

	// Modal windows prevents cursor from hovering behind them.
	ImGuiWindow* modal_window = GetFrontMostModalRootWindow();
	if (modal_window)
		if (g.HoveredRootWindow && !IsWindowChildOf(g.HoveredRootWindow, modal_window))
			g.HoveredRootWindow = g.HoveredWindow = NULL;

	// Disabled mouse?
	if (g.IO.ConfigFlags & ImGuiConfigFlags_NoMouse)
		g.HoveredWindow = g.HoveredRootWindow = NULL;

	// We track click ownership. When clicked outside of a window the click is owned by the application and won't report hovering nor request capture even while dragging over our windows afterward.
	int mouse_earliest_button_down = -1;
	bool mouse_any_down = false;
	for (int i = 0; i < IM_ARRAYSIZE(g.IO.MouseDown); i++)
	{
		if (g.IO.MouseClicked[i])
			g.IO.MouseDownOwned[i] = (g.HoveredWindow != NULL) || (!g.OpenPopupStack.empty());
		mouse_any_down |= g.IO.MouseDown[i];
		if (g.IO.MouseDown[i])
			if (mouse_earliest_button_down == -1 || g.IO.MouseClickedTime[i] < g.IO.MouseClickedTime[mouse_earliest_button_down])
				mouse_earliest_button_down = i;
	}
	const bool mouse_avail_to_imgui = (mouse_earliest_button_down == -1) || g.IO.MouseDownOwned[mouse_earliest_button_down];

	// If mouse was first clicked outside of ImGui bounds we also cancel out hovering.
	// FIXME: For patterns of drag and drop across OS windows, we may need to rework/remove this test (first committed 311c0ca9 on 2015/02)
	const bool mouse_dragging_extern_payload = g.DragDropActive && (g.DragDropSourceFlags & ImGuiDragDropFlags_SourceExtern) != 0;
	if (!mouse_avail_to_imgui && !mouse_dragging_extern_payload)
		g.HoveredWindow = g.HoveredRootWindow = NULL;

	// Update io.WantCaptureMouse for the user application (true = dispatch mouse info to imgui, false = dispatch mouse info to imgui + app)
	if (g.WantCaptureMouseNextFrame != -1)
		g.IO.WantCaptureMouse = (g.WantCaptureMouseNextFrame != 0);
	else
		g.IO.WantCaptureMouse = (mouse_avail_to_imgui && (g.HoveredWindow != NULL || mouse_any_down)) || (!g.OpenPopupStack.empty());

	// Update io.WantCaptureKeyboard for the user application (true = dispatch keyboard info to imgui, false = dispatch keyboard info to imgui + app)
	if (g.WantCaptureKeyboardNextFrame != -1)
		g.IO.WantCaptureKeyboard = (g.WantCaptureKeyboardNextFrame != 0);
	else
		g.IO.WantCaptureKeyboard = (g.ActiveId != 0) || (modal_window != NULL);
	if (g.IO.NavActive && (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard) && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavNoCaptureKeyboard))
		g.IO.WantCaptureKeyboard = true;

	// Update io.WantTextInput flag, this is to allow systems without a keyboard (e.g. mobile, hand-held) to show a software keyboard if possible
	g.IO.WantTextInput = (g.WantTextInputNextFrame != -1) ? (g.WantTextInputNextFrame != 0) : 0;
}

void ImGui::NewFrame()
{
	IM_ASSERT(GImGui != NULL && "No current context. Did you call ImGui::CreateContext() or ImGui::SetCurrentContext()?");
	ImGuiContext& g = *GImGui;

	// Check user data
	// (We pass an error message in the assert expression as a trick to get it visible to programmers who are not using a debugger, as most assert handlers display their argument)
	IM_ASSERT(g.Initialized);
	IM_ASSERT(g.IO.DeltaTime >= 0.0f && "Need a positive DeltaTime (zero is tolerated but will cause some timing issues)");
	IM_ASSERT(g.IO.DisplaySize.x >= 0.0f && g.IO.DisplaySize.y >= 0.0f && "Invalid DisplaySize value");
	IM_ASSERT(g.IO.Fonts->Fonts.Size > 0 && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
	IM_ASSERT(g.IO.Fonts->Fonts[0]->IsLoaded() && "Font Atlas not built. Did you call io.Fonts->GetTexDataAsRGBA32() / GetTexDataAsAlpha8() ?");
	IM_ASSERT(g.Style.CurveTessellationTol > 0.0f && "Invalid style setting");
	IM_ASSERT(g.Style.Alpha >= 0.0f && g.Style.Alpha <= 1.0f && "Invalid style setting. Alpha cannot be negative (allows us to avoid a few clamps in color computations)");
	IM_ASSERT((g.FrameCount == 0 || g.FrameCountEnded == g.FrameCount) && "Forgot to call Render() or EndFrame() at the end of the previous frame?");
	for (int n = 0; n < ImGuiKey_COUNT; n++)
		IM_ASSERT(g.IO.KeyMap[n] >= -1 && g.IO.KeyMap[n] < IM_ARRAYSIZE(g.IO.KeysDown) && "io.KeyMap[] contains an out of bound value (need to be 0..512, or -1 for unmapped key)");

	// Do a simple check for required key mapping (we intentionally do NOT check all keys to not pressure user into setting up everything, but Space is required and was super recently added in 1.60 WIP)
	if (g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableKeyboard)
		IM_ASSERT(g.IO.KeyMap[ImGuiKey_Space] != -1 && "ImGuiKey_Space is not mapped, required for keyboard navigation.");

	// Load settings on first frame
	if (!g.SettingsLoaded)
	{
		IM_ASSERT(g.SettingsWindows.empty());
		LoadIniSettingsFromDisk(g.IO.IniFilename);
		g.SettingsLoaded = true;
	}

	// Save settings (with a delay so we don't spam disk too much)
	if (g.SettingsDirtyTimer > 0.0f)
	{
		g.SettingsDirtyTimer -= g.IO.DeltaTime;
		if (g.SettingsDirtyTimer <= 0.0f)
			SaveIniSettingsToDisk(g.IO.IniFilename);
	}

	g.Time += g.IO.DeltaTime;
	g.FrameCount += 1;
	g.TooltipOverrideCount = 0;
	g.WindowsActiveCount = 0;

	SetCurrentFont(GetDefaultFont());
	IM_ASSERT(g.Font->IsLoaded());
	g.DrawListSharedData.ClipRectFullscreen = ImVec4(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
	g.DrawListSharedData.CurveTessellationTol = g.Style.CurveTessellationTol;

	g.OverlayDrawList.Clear();
	g.OverlayDrawList.PushTextureID(g.IO.Fonts->TexID);
	g.OverlayDrawList.PushClipRectFullScreen();
	g.OverlayDrawList.Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);

	// Mark rendering data as invalid to prevent user who may have a handle on it to use it
	g.DrawData.Clear();

	// Clear reference to active widget if the widget isn't alive anymore
	if (!g.HoveredIdPreviousFrame)
		g.HoveredIdTimer = 0.0f;
	g.HoveredIdPreviousFrame = g.HoveredId;
	g.HoveredId = 0;
	g.HoveredIdAllowOverlap = false;
	if (!g.ActiveIdIsAlive && g.ActiveIdPreviousFrame == g.ActiveId && g.ActiveId != 0)
		ClearActiveID();
	if (g.ActiveId)
		g.ActiveIdTimer += g.IO.DeltaTime;
	g.ActiveIdPreviousFrame = g.ActiveId;
	g.ActiveIdIsAlive = false;
	g.ActiveIdIsJustActivated = false;
	if (g.ScalarAsInputTextId && g.ActiveId != g.ScalarAsInputTextId)
		g.ScalarAsInputTextId = 0;

	// Elapse drag & drop payload
	if (g.DragDropActive && g.DragDropPayload.DataFrameCount + 1 < g.FrameCount)
	{
		ClearDragDrop();
		g.DragDropPayloadBufHeap.clear();
		memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
	}
	g.DragDropAcceptIdPrev = g.DragDropAcceptIdCurr;
	g.DragDropAcceptIdCurr = 0;
	g.DragDropAcceptIdCurrRectSurface = FLT_MAX;

	// Update keyboard input state
	memcpy(g.IO.KeysDownDurationPrev, g.IO.KeysDownDuration, sizeof(g.IO.KeysDownDuration));
	for (int i = 0; i < IM_ARRAYSIZE(g.IO.KeysDown); i++)
		g.IO.KeysDownDuration[i] = g.IO.KeysDown[i] ? (g.IO.KeysDownDuration[i] < 0.0f ? 0.0f : g.IO.KeysDownDuration[i] + g.IO.DeltaTime) : -1.0f;

	// Update gamepad/keyboard directional navigation
	NavUpdate();

	// Update mouse input state
	NewFrameUpdateMouseInputs();

	// Calculate frame-rate for the user, as a purely luxurious feature
	g.FramerateSecPerFrameAccum += g.IO.DeltaTime - g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx];
	g.FramerateSecPerFrame[g.FramerateSecPerFrameIdx] = g.IO.DeltaTime;
	g.FramerateSecPerFrameIdx = (g.FramerateSecPerFrameIdx + 1) % IM_ARRAYSIZE(g.FramerateSecPerFrame);
	g.IO.Framerate = 1.0f / (g.FramerateSecPerFrameAccum / (float)IM_ARRAYSIZE(g.FramerateSecPerFrame));

	// Handle user moving window with mouse (at the beginning of the frame to avoid input lag or sheering)
	NewFrameUpdateMovingWindow();
	NewFrameUpdateHoveredWindowAndCaptureFlags();

	if (GetFrontMostModalRootWindow() != NULL)
		g.ModalWindowDarkeningRatio = ImMin(g.ModalWindowDarkeningRatio + g.IO.DeltaTime * 6.0f, 1.0f);
	else
		g.ModalWindowDarkeningRatio = 0.0f;

	g.MouseCursor = ImGuiMouseCursor_Arrow;
	g.WantCaptureMouseNextFrame = g.WantCaptureKeyboardNextFrame = g.WantTextInputNextFrame = -1;
	g.OsImePosRequest = ImVec2(1.0f, 1.0f); // OS Input Method Editor showing on top-left of our window by default

											// Mouse wheel scrolling, scale
	if (g.HoveredWindow && !g.HoveredWindow->Collapsed && (g.IO.MouseWheel != 0.0f || g.IO.MouseWheelH != 0.0f))
	{
		// If a child window has the ImGuiWindowFlags_NoScrollWithMouse flag, we give a chance to scroll its parent (unless either ImGuiWindowFlags_NoInputs or ImGuiWindowFlags_NoScrollbar are also set).
		ImGuiWindow* window = g.HoveredWindow;
		ImGuiWindow* scroll_window = window;
		while ((scroll_window->Flags & ImGuiWindowFlags_ChildWindow) && (scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoScrollbar) && !(scroll_window->Flags & ImGuiWindowFlags_NoInputs) && scroll_window->ParentWindow)
			scroll_window = scroll_window->ParentWindow;
		const bool scroll_allowed = !(scroll_window->Flags & ImGuiWindowFlags_NoScrollWithMouse) && !(scroll_window->Flags & ImGuiWindowFlags_NoInputs);

		if (g.IO.MouseWheel != 0.0f)
		{
			if (g.IO.KeyCtrl && g.IO.FontAllowUserScaling)
			{
				// Zoom / Scale window
				const float new_font_scale = ImClamp(window->FontWindowScale + g.IO.MouseWheel * 0.10f, 0.50f, 2.50f);
				const float scale = new_font_scale / window->FontWindowScale;
				window->FontWindowScale = new_font_scale;

				const ImVec2 offset = window->Size * (1.0f - scale) * (g.IO.MousePos - window->Pos) / window->Size;
				window->Pos += offset;
				window->PosFloat += offset;
				window->Size *= scale;
				window->SizeFull *= scale;
			}
			else if (!g.IO.KeyCtrl && scroll_allowed)
			{
				// Mouse wheel vertical scrolling
				float scroll_amount = 5 * scroll_window->CalcFontSize();
				scroll_amount = (float)(int)ImMin(scroll_amount, (scroll_window->ContentsRegionRect.GetHeight() + scroll_window->WindowPadding.y * 2.0f) * 0.67f);
				SetWindowScrollY(scroll_window, scroll_window->Scroll.y - g.IO.MouseWheel * scroll_amount);
			}
		}
		if (g.IO.MouseWheelH != 0.0f && scroll_allowed)
		{
			// Mouse wheel horizontal scrolling (for hardware that supports it)
			float scroll_amount = scroll_window->CalcFontSize();
			if (!g.IO.KeyCtrl && !(window->Flags & ImGuiWindowFlags_NoScrollWithMouse))
				SetWindowScrollX(window, window->Scroll.x - g.IO.MouseWheelH * scroll_amount);
		}
	}

	// Pressing TAB activate widget focus
	if (g.ActiveId == 0 && g.NavWindow != NULL && g.NavWindow->Active && !(g.NavWindow->Flags & ImGuiWindowFlags_NoNavInputs) && !g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_Tab, false))
	{
		if (g.NavId != 0 && g.NavIdTabCounter != INT_MAX)
			g.NavWindow->FocusIdxTabRequestNext = g.NavIdTabCounter + 1 + (g.IO.KeyShift ? -1 : 1);
		else
			g.NavWindow->FocusIdxTabRequestNext = g.IO.KeyShift ? -1 : 0;
	}
	g.NavIdTabCounter = INT_MAX;

	// Mark all windows as not visible
	for (int i = 0; i != g.Windows.Size; i++)
	{
		ImGuiWindow* window = g.Windows[i];
		window->WasActive = window->Active;
		window->Active = false;
		window->WriteAccessed = false;
	}

	// Closing the focused window restore focus to the first active root window in descending z-order
	if (g.NavWindow && !g.NavWindow->WasActive)
		FocusFrontMostActiveWindow(NULL);

	// No window should be open at the beginning of the frame.
	// But in order to allow the user to call NewFrame() multiple times without calling Render(), we are doing an explicit clear.
	g.CurrentWindowStack.resize(0);
	g.CurrentPopupStack.resize(0);
	ClosePopupsOverWindow(g.NavWindow);

	// Create implicit window - we will only render it if the user has added something to it.
	// We don't use "Debug" to avoid colliding with user trying to create a "Debug" window with custom flags.
	SetNextWindowSize(ImVec2(400, 400), ImGuiCond_FirstUseEver);
	Begin("Debug##Default");
}

static void* SettingsHandlerWindow_ReadOpen(ImGuiContext*, ImGuiSettingsHandler*, const char* name)
{
	ImGuiWindowSettings* settings = ImGui::FindWindowSettings(ImHash(name, 0));
	if (!settings)
		settings = AddWindowSettings(name);
	return (void*)settings;
}

static void SettingsHandlerWindow_ReadLine(ImGuiContext*, ImGuiSettingsHandler*, void* entry, const char* line)
{
	ImGuiWindowSettings* settings = (ImGuiWindowSettings*)entry;
	float x, y;
	int i;
	if (sscanf(line, "Pos=%f,%f", &x, &y) == 2)         settings->Pos = ImVec2(x, y);
	else if (sscanf(line, "Size=%f,%f", &x, &y) == 2)   settings->Size = ImMax(ImVec2(x, y), GImGui->Style.WindowMinSize);
	else if (sscanf(line, "Collapsed=%d", &i) == 1)     settings->Collapsed = (i != 0);
}

static void SettingsHandlerWindow_WriteAll(ImGuiContext* imgui_ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* buf)
{
	// Gather data from windows that were active during this session
	ImGuiContext& g = *imgui_ctx;
	for (int i = 0; i != g.Windows.Size; i++)
	{
		ImGuiWindow* window = g.Windows[i];
		if (window->Flags & ImGuiWindowFlags_NoSavedSettings)
			continue;
		ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID);
		if (!settings)
			settings = AddWindowSettings(window->Name);
		settings->Pos = window->Pos;
		settings->Size = window->SizeFull;
		settings->Collapsed = window->Collapsed;
	}

	// Write a buffer
	// If a window wasn't opened in this session we preserve its settings
	buf->reserve(buf->size() + g.SettingsWindows.Size * 96); // ballpark reserve
	for (int i = 0; i != g.SettingsWindows.Size; i++)
	{
		const ImGuiWindowSettings* settings = &g.SettingsWindows[i];
		if (settings->Pos.x == FLT_MAX)
			continue;
		const char* name = settings->Name;
		if (const char* p = strstr(name, "###"))  // Skip to the "###" marker if any. We don't skip past to match the behavior of GetID()
			name = p;
		buf->appendf("[%s][%s]\n", handler->TypeName, name);
		buf->appendf("Pos=%d,%d\n", (int)settings->Pos.x, (int)settings->Pos.y);
		buf->appendf("Size=%d,%d\n", (int)settings->Size.x, (int)settings->Size.y);
		buf->appendf("Collapsed=%d\n", settings->Collapsed);
		buf->appendf("\n");
	}
}

void ImGui::Initialize(ImGuiContext* context)
{
	ImGuiContext& g = *context;
	IM_ASSERT(!g.Initialized && !g.SettingsLoaded);
	g.LogClipboard = IM_NEW(ImGuiTextBuffer)();

	// Add .ini handle for ImGuiWindow type
	ImGuiSettingsHandler ini_handler;
	ini_handler.TypeName = "Window";
	ini_handler.TypeHash = ImHash("Window", 0, 0);
	ini_handler.ReadOpenFn = SettingsHandlerWindow_ReadOpen;
	ini_handler.ReadLineFn = SettingsHandlerWindow_ReadLine;
	ini_handler.WriteAllFn = SettingsHandlerWindow_WriteAll;
	g.SettingsHandlers.push_front(ini_handler);

	g.Initialized = true;
}

// This function is merely here to free heap allocations.
void ImGui::Shutdown(ImGuiContext* context)
{
	ImGuiContext& g = *context;

	// The fonts atlas can be used prior to calling NewFrame(), so we clear it even if g.Initialized is FALSE (which would happen if we never called NewFrame)
	if (g.IO.Fonts && g.FontAtlasOwnedByContext)
		IM_DELETE(g.IO.Fonts);

	// Cleanup of other data are conditional on actually having initialize ImGui.
	if (!g.Initialized)
		return;

	SaveIniSettingsToDisk(g.IO.IniFilename);

	// Clear everything else
	for (int i = 0; i < g.Windows.Size; i++)
		IM_DELETE(g.Windows[i]);
	g.Windows.clear();
	g.WindowsSortBuffer.clear();
	g.CurrentWindow = NULL;
	g.CurrentWindowStack.clear();
	g.WindowsById.Clear();
	g.NavWindow = NULL;
	g.HoveredWindow = NULL;
	g.HoveredRootWindow = NULL;
	g.ActiveIdWindow = NULL;
	g.MovingWindow = NULL;
	for (int i = 0; i < g.SettingsWindows.Size; i++)
		IM_DELETE(g.SettingsWindows[i].Name);
	g.ColorModifiers.clear();
	g.StyleModifiers.clear();
	g.FontStack.clear();
	g.OpenPopupStack.clear();
	g.CurrentPopupStack.clear();
	g.DrawDataBuilder.ClearFreeMemory();
	g.OverlayDrawList.ClearFreeMemory();
	g.PrivateClipboard.clear();
	g.InputTextState.Text.clear();
	g.InputTextState.InitialText.clear();
	g.InputTextState.TempTextBuffer.clear();

	g.SettingsWindows.clear();
	g.SettingsHandlers.clear();

	if (g.LogFile && g.LogFile != stdout)
	{
		fclose(g.LogFile);
		g.LogFile = NULL;
	}
	if (g.LogClipboard)
		IM_DELETE(g.LogClipboard);

	g.Initialized = false;
}

ImGuiWindowSettings* ImGui::FindWindowSettings(ImGuiID id)
{
	ImGuiContext& g = *GImGui;
	for (int i = 0; i != g.SettingsWindows.Size; i++)
		if (g.SettingsWindows[i].Id == id)
			return &g.SettingsWindows[i];
	return NULL;
}

static ImGuiWindowSettings* AddWindowSettings(const char* name)
{
	ImGuiContext& g = *GImGui;
	g.SettingsWindows.push_back(ImGuiWindowSettings());
	ImGuiWindowSettings* settings = &g.SettingsWindows.back();
	settings->Name = ImStrdup(name);
	settings->Id = ImHash(name, 0);
	return settings;
}

static void LoadIniSettingsFromDisk(const char* ini_filename)
{
	if (!ini_filename)
		return;
	char* file_data = (char*)ImFileLoadToMemory(ini_filename, "rb", NULL, +1);
	if (!file_data)
		return;
	LoadIniSettingsFromMemory(file_data);
	ImGui::MemFree(file_data);
}

ImGuiSettingsHandler* ImGui::FindSettingsHandler(const char* type_name)
{
	ImGuiContext& g = *GImGui;
	const ImGuiID type_hash = ImHash(type_name, 0, 0);
	for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
		if (g.SettingsHandlers[handler_n].TypeHash == type_hash)
			return &g.SettingsHandlers[handler_n];
	return NULL;
}

// Zero-tolerance, no error reporting, cheap .ini parsing
static void LoadIniSettingsFromMemory(const char* buf_readonly)
{
	// For convenience and to make the code simpler, we'll write zero terminators inside the buffer. So let's create a writable copy.
	char* buf = ImStrdup(buf_readonly);
	char* buf_end = buf + strlen(buf);

	ImGuiContext& g = *GImGui;
	void* entry_data = NULL;
	ImGuiSettingsHandler* entry_handler = NULL;

	char* line_end = NULL;
	for (char* line = buf; line < buf_end; line = line_end + 1)
	{
		// Skip new lines markers, then find end of the line
		while (*line == '\n' || *line == '\r')
			line++;
		line_end = line;
		while (line_end < buf_end && *line_end != '\n' && *line_end != '\r')
			line_end++;
		line_end[0] = 0;

		if (line[0] == '[' && line_end > line && line_end[-1] == ']')
		{
			// Parse "[Type][Name]". Note that 'Name' can itself contains [] characters, which is acceptable with the current format and parsing code.
			line_end[-1] = 0;
			const char* name_end = line_end - 1;
			const char* type_start = line + 1;
			char* type_end = (char*)(intptr_t)ImStrchrRange(type_start, name_end, ']');
			const char* name_start = type_end ? ImStrchrRange(type_end + 1, name_end, '[') : NULL;
			if (!type_end || !name_start)
			{
				name_start = type_start; // Import legacy entries that have no type
				type_start = "Window";
			}
			else
			{
				*type_end = 0; // Overwrite first ']'
				name_start++;  // Skip second '['
			}
			entry_handler = ImGui::FindSettingsHandler(type_start);
			entry_data = entry_handler ? entry_handler->ReadOpenFn(&g, entry_handler, name_start) : NULL;
		}
		else if (entry_handler != NULL && entry_data != NULL)
		{
			// Let type handler parse the line
			entry_handler->ReadLineFn(&g, entry_handler, entry_data, line);
		}
	}
	ImGui::MemFree(buf);
	g.SettingsLoaded = true;
}

static void SaveIniSettingsToDisk(const char* ini_filename)
{
	ImGuiContext& g = *GImGui;
	g.SettingsDirtyTimer = 0.0f;
	if (!ini_filename)
		return;

	ImVector<char> buf;
	SaveIniSettingsToMemory(buf);

	FILE* f = ImFileOpen(ini_filename, "wt");
	if (!f)
		return;
	fwrite(buf.Data, sizeof(char), (size_t)buf.Size, f);
	fclose(f);
}

static void SaveIniSettingsToMemory(ImVector<char>& out_buf)
{
	ImGuiContext& g = *GImGui;
	g.SettingsDirtyTimer = 0.0f;

	ImGuiTextBuffer buf;
	for (int handler_n = 0; handler_n < g.SettingsHandlers.Size; handler_n++)
	{
		ImGuiSettingsHandler* handler = &g.SettingsHandlers[handler_n];
		handler->WriteAllFn(&g, handler, &buf);
	}

	buf.Buf.pop_back(); // Remove extra zero-terminator used by ImGuiTextBuffer
	out_buf.swap(buf.Buf);
}

void ImGui::MarkIniSettingsDirty()
{
	ImGuiContext& g = *GImGui;
	if (g.SettingsDirtyTimer <= 0.0f)
		g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

static void MarkIniSettingsDirty(ImGuiWindow* window)
{
	ImGuiContext& g = *GImGui;
	if (!(window->Flags & ImGuiWindowFlags_NoSavedSettings))
		if (g.SettingsDirtyTimer <= 0.0f)
			g.SettingsDirtyTimer = g.IO.IniSavingRate;
}

// FIXME: Add a more explicit sort order in the window structure.
static int IMGUI_CDECL ChildWindowComparer(const void* lhs, const void* rhs)
{
	const ImGuiWindow* const a = *(const ImGuiWindow* const*)lhs;
	const ImGuiWindow* const b = *(const ImGuiWindow* const*)rhs;
	if (int d = (a->Flags & ImGuiWindowFlags_Popup) - (b->Flags & ImGuiWindowFlags_Popup))
		return d;
	if (int d = (a->Flags & ImGuiWindowFlags_Tooltip) - (b->Flags & ImGuiWindowFlags_Tooltip))
		return d;
	return (a->BeginOrderWithinParent - b->BeginOrderWithinParent);
}

static void AddWindowToSortedBuffer(ImVector<ImGuiWindow*>* out_sorted_windows, ImGuiWindow* window)
{
	out_sorted_windows->push_back(window);
	if (window->Active)
	{
		int count = window->DC.ChildWindows.Size;
		if (count > 1)
			qsort(window->DC.ChildWindows.begin(), (size_t)count, sizeof(ImGuiWindow*), ChildWindowComparer);
		for (int i = 0; i < count; i++)
		{
			ImGuiWindow* child = window->DC.ChildWindows[i];
			if (child->Active)
				AddWindowToSortedBuffer(out_sorted_windows, child);
		}
	}
}

static void AddDrawListToDrawData(ImVector<ImDrawList*>* out_render_list, ImDrawList* draw_list)
{
	if (draw_list->CmdBuffer.empty())
		return;

	// Remove trailing command if unused
	ImDrawCmd& last_cmd = draw_list->CmdBuffer.back();
	if (last_cmd.ElemCount == 0 && last_cmd.UserCallback == NULL)
	{
		draw_list->CmdBuffer.pop_back();
		if (draw_list->CmdBuffer.empty())
			return;
	}

	// Draw list sanity check. Detect mismatch between PrimReserve() calls and incrementing _VtxCurrentIdx, _VtxWritePtr etc. May trigger for you if you are using PrimXXX functions incorrectly.
	IM_ASSERT(draw_list->VtxBuffer.Size == 0 || draw_list->_VtxWritePtr == draw_list->VtxBuffer.Data + draw_list->VtxBuffer.Size);
	IM_ASSERT(draw_list->IdxBuffer.Size == 0 || draw_list->_IdxWritePtr == draw_list->IdxBuffer.Data + draw_list->IdxBuffer.Size);
	IM_ASSERT((int)draw_list->_VtxCurrentIdx == draw_list->VtxBuffer.Size);

	// Check that draw_list doesn't use more vertices than indexable (default ImDrawIdx = unsigned short = 2 bytes = 64K vertices per ImDrawList = per window)
	// If this assert triggers because you are drawing lots of stuff manually:
	// A) Make sure you are coarse clipping, because ImDrawList let all your vertices pass. You can use the Metrics window to inspect draw list contents.
	// B) If you need/want meshes with more than 64K vertices, uncomment the '#define ImDrawIdx unsigned int' line in imconfig.h to set the index size to 4 bytes.
	//    You'll need to handle the 4-bytes indices to your renderer. For example, the OpenGL example code detect index size at compile-time by doing:
	//      glDrawElements(GL_TRIANGLES, (GLsizei)pcmd->ElemCount, sizeof(ImDrawIdx) == 2 ? GL_UNSIGNED_SHORT : GL_UNSIGNED_INT, idx_buffer_offset);
	//    Your own engine or render API may use different parameters or function calls to specify index sizes. 2 and 4 bytes indices are generally supported by most API.
	// C) If for some reason you cannot use 4 bytes indices or don't want to, a workaround is to call BeginChild()/EndChild() before reaching the 64K limit to split your draw commands in multiple draw lists.
	if (sizeof(ImDrawIdx) == 2)
		IM_ASSERT(draw_list->_VtxCurrentIdx < (1 << 16) && "Too many vertices in ImDrawList using 16-bit indices. Read comment above");

	out_render_list->push_back(draw_list);
}

static void AddWindowToDrawData(ImVector<ImDrawList*>* out_render_list, ImGuiWindow* window)
{
	AddDrawListToDrawData(out_render_list, window->DrawList);
	for (int i = 0; i < window->DC.ChildWindows.Size; i++)
	{
		ImGuiWindow* child = window->DC.ChildWindows[i];
		if (child->Active && child->HiddenFrames == 0) // clipped children may have been marked not active
			AddWindowToDrawData(out_render_list, child);
	}
}

static void AddWindowToDrawDataSelectLayer(ImGuiWindow* window)
{
	ImGuiContext& g = *GImGui;
	g.IO.MetricsActiveWindows++;
	if (window->Flags & ImGuiWindowFlags_Tooltip)
		AddWindowToDrawData(&g.DrawDataBuilder.Layers[1], window);
	else
		AddWindowToDrawData(&g.DrawDataBuilder.Layers[0], window);
}

void ImDrawDataBuilder::FlattenIntoSingleLayer()
{
	int n = Layers[0].Size;
	int size = n;
	for (int i = 1; i < IM_ARRAYSIZE(Layers); i++)
		size += Layers[i].Size;
	Layers[0].resize(size);
	for (int layer_n = 1; layer_n < IM_ARRAYSIZE(Layers); layer_n++)
	{
		ImVector<ImDrawList*>& layer = Layers[layer_n];
		if (layer.empty())
			continue;
		memcpy(&Layers[0][n], &layer[0], layer.Size * sizeof(ImDrawList*));
		n += layer.Size;
		layer.resize(0);
	}
}

static void SetupDrawData(ImVector<ImDrawList*>* draw_lists, ImDrawData* out_draw_data)
{
	out_draw_data->Valid = true;
	out_draw_data->CmdLists = (draw_lists->Size > 0) ? draw_lists->Data : NULL;
	out_draw_data->CmdListsCount = draw_lists->Size;
	out_draw_data->TotalVtxCount = out_draw_data->TotalIdxCount = 0;
	for (int n = 0; n < draw_lists->Size; n++)
	{
		out_draw_data->TotalVtxCount += draw_lists->Data[n]->VtxBuffer.Size;
		out_draw_data->TotalIdxCount += draw_lists->Data[n]->IdxBuffer.Size;
	}
}

// When using this function it is sane to ensure that float are perfectly rounded to integer values, to that e.g. (int)(max.x-min.x) in user's render produce correct result.
void ImGui::PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect)
{
	ImGuiWindow* window = GetCurrentWindow();
	window->DrawList->PushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
	window->ClipRect = window->DrawList->_ClipRectStack.back();
}

void ImGui::PopClipRect()
{
	ImGuiWindow* window = GetCurrentWindow();
	window->DrawList->PopClipRect();
	window->ClipRect = window->DrawList->_ClipRectStack.back();
}

// This is normally called by Render(). You may want to call it directly if you want to avoid calling Render() but the gain will be very minimal.
void ImGui::EndFrame()
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(g.Initialized);                       // Forgot to call ImGui::NewFrame()
	if (g.FrameCountEnded == g.FrameCount)          // Don't process EndFrame() multiple times.
		return;

	// Notify OS when our Input Method Editor cursor has moved (e.g. CJK inputs using Microsoft IME)
	if (g.IO.ImeSetInputScreenPosFn && ImLengthSqr(g.OsImePosRequest - g.OsImePosSet) > 0.0001f)
	{
		g.IO.ImeSetInputScreenPosFn((int)g.OsImePosRequest.x, (int)g.OsImePosRequest.y);
		g.OsImePosSet = g.OsImePosRequest;
	}

	// Hide implicit "Debug" window if it hasn't been used
	IM_ASSERT(g.CurrentWindowStack.Size == 1);    // Mismatched Begin()/End() calls
	if (g.CurrentWindow && !g.CurrentWindow->WriteAccessed)
		g.CurrentWindow->Active = false;
	End();

	if (g.ActiveId == 0 && g.HoveredId == 0)
	{
		if (!g.NavWindow || !g.NavWindow->Appearing) // Unless we just made a window/popup appear
		{
			// Click to focus window and start moving (after we're done with all our widgets)
			if (g.IO.MouseClicked[0])
			{
				if (g.HoveredRootWindow != NULL)
				{
					// Set ActiveId even if the _NoMove flag is set, without it dragging away from a window with _NoMove would activate hover on other windows.
					FocusWindow(g.HoveredWindow);
					SetActiveID(g.HoveredWindow->MoveId, g.HoveredWindow);
					g.NavDisableHighlight = true;
					g.ActiveIdClickOffset = g.IO.MousePos - g.HoveredRootWindow->Pos;
					if (!(g.HoveredWindow->Flags & ImGuiWindowFlags_NoMove) && !(g.HoveredRootWindow->Flags & ImGuiWindowFlags_NoMove))
						g.MovingWindow = g.HoveredWindow;
				}
				else if (g.NavWindow != NULL && GetFrontMostModalRootWindow() == NULL)
				{
					// Clicking on void disable focus
					FocusWindow(NULL);
				}
			}

			// With right mouse button we close popups without changing focus
			// (The left mouse button path calls FocusWindow which will lead NewFrame->ClosePopupsOverWindow to trigger)
			if (g.IO.MouseClicked[1])
			{
				// Find the top-most window between HoveredWindow and the front most Modal Window.
				// This is where we can trim the popup stack.
				ImGuiWindow* modal = GetFrontMostModalRootWindow();
				bool hovered_window_above_modal = false;
				if (modal == NULL)
					hovered_window_above_modal = true;
				for (int i = g.Windows.Size - 1; i >= 0 && hovered_window_above_modal == false; i--)
				{
					ImGuiWindow* window = g.Windows[i];
					if (window == modal)
						break;
					if (window == g.HoveredWindow)
						hovered_window_above_modal = true;
				}
				ClosePopupsOverWindow(hovered_window_above_modal ? g.HoveredWindow : modal);
			}
		}
	}

	// Sort the window list so that all child windows are after their parent
	// We cannot do that on FocusWindow() because childs may not exist yet
	g.WindowsSortBuffer.resize(0);
	g.WindowsSortBuffer.reserve(g.Windows.Size);
	for (int i = 0; i != g.Windows.Size; i++)
	{
		ImGuiWindow* window = g.Windows[i];
		if (window->Active && (window->Flags & ImGuiWindowFlags_ChildWindow))       // if a child is active its parent will add it
			continue;
		AddWindowToSortedBuffer(&g.WindowsSortBuffer, window);
	}

	IM_ASSERT(g.Windows.Size == g.WindowsSortBuffer.Size);  // we done something wrong
	g.Windows.swap(g.WindowsSortBuffer);

	// Clear Input data for next frame
	g.IO.MouseWheel = g.IO.MouseWheelH = 0.0f;
	memset(g.IO.InputCharacters, 0, sizeof(g.IO.InputCharacters));
	memset(g.IO.NavInputs, 0, sizeof(g.IO.NavInputs));

	g.FrameCountEnded = g.FrameCount;
}

void ImGui::Render()
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(g.Initialized);   // Forgot to call ImGui::NewFrame()

	if (g.FrameCountEnded != g.FrameCount)
		ImGui::EndFrame();
	g.FrameCountRendered = g.FrameCount;

	// Gather windows to render
	g.IO.MetricsRenderVertices = g.IO.MetricsRenderIndices = g.IO.MetricsActiveWindows = 0;
	g.DrawDataBuilder.Clear();
	ImGuiWindow* window_to_render_front_most = (g.NavWindowingTarget && !(g.NavWindowingTarget->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus)) ? g.NavWindowingTarget : NULL;
	for (int n = 0; n != g.Windows.Size; n++)
	{
		ImGuiWindow* window = g.Windows[n];
		if (window->Active && window->HiddenFrames == 0 && (window->Flags & ImGuiWindowFlags_ChildWindow) == 0 && window != window_to_render_front_most)
			AddWindowToDrawDataSelectLayer(window);
	}
	if (window_to_render_front_most && window_to_render_front_most->Active && window_to_render_front_most->HiddenFrames == 0) // NavWindowingTarget is always temporarily displayed as the front-most window
		AddWindowToDrawDataSelectLayer(window_to_render_front_most);
	g.DrawDataBuilder.FlattenIntoSingleLayer();

	// Draw software mouse cursor if requested
	ImVec2 offset, size, uv[4];
	if (g.IO.MouseDrawCursor && g.IO.Fonts->GetMouseCursorTexData(g.MouseCursor, &offset, &size, &uv[0], &uv[2]))
	{
		const ImVec2 pos = g.IO.MousePos - offset;
		const ImTextureID tex_id = g.IO.Fonts->TexID;
		const float sc = g.Style.MouseCursorScale;
		g.OverlayDrawList.PushTextureID(tex_id);
		g.OverlayDrawList.AddImage(tex_id, pos + ImVec2(1, 0) * sc, pos + ImVec2(1, 0) * sc + size * sc, uv[2], uv[3], IM_COL32(0, 0, 0, 48));        // Shadow
		g.OverlayDrawList.AddImage(tex_id, pos + ImVec2(2, 0) * sc, pos + ImVec2(2, 0) * sc + size * sc, uv[2], uv[3], IM_COL32(0, 0, 0, 48));        // Shadow
		g.OverlayDrawList.AddImage(tex_id, pos, pos + size * sc, uv[2], uv[3], IM_COL32(0, 0, 0, 255));       // Black border
		g.OverlayDrawList.AddImage(tex_id, pos, pos + size * sc, uv[0], uv[1], IM_COL32(255, 255, 255, 255)); // White fill
		g.OverlayDrawList.PopTextureID();
	}
	if (!g.OverlayDrawList.VtxBuffer.empty())
		AddDrawListToDrawData(&g.DrawDataBuilder.Layers[0], &g.OverlayDrawList);

	// Setup ImDrawData structure for end-user
	SetupDrawData(&g.DrawDataBuilder.Layers[0], &g.DrawData);
	g.IO.MetricsRenderVertices = g.DrawData.TotalVtxCount;
	g.IO.MetricsRenderIndices = g.DrawData.TotalIdxCount;

	// Render. If user hasn't set a callback then they may retrieve the draw data via GetDrawData()
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	if (g.DrawData.CmdListsCount > 0 && g.IO.RenderDrawListsFn != NULL)
		g.IO.RenderDrawListsFn(&g.DrawData);
#endif
}

const char* ImGui::FindRenderedTextEnd(const char* text, const char* text_end)
{
	const char* text_display_end = text;
	if (!text_end)
		text_end = (const char*)-1;

	while (text_display_end < text_end && *text_display_end != '\0' && (text_display_end[0] != '#' || text_display_end[1] != '#'))
		text_display_end++;
	return text_display_end;
}

// Pass text data straight to log (without being displayed)
void ImGui::LogText(const char* fmt, ...)
{
	ImGuiContext& g = *GImGui;
	if (!g.LogEnabled)
		return;

	va_list args;
	va_start(args, fmt);
	if (g.LogFile)
	{
		vfprintf(g.LogFile, fmt, args);
	}
	else
	{
		g.LogClipboard->appendfv(fmt, args);
	}
	va_end(args);
}

// Internal version that takes a position to decide on newline placement and pad items according to their depth.
// We split text into individual lines to add current tree level padding
static void LogRenderedText(const ImVec2* ref_pos, const char* text, const char* text_end = NULL)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	if (!text_end)
		text_end = ImGui::FindRenderedTextEnd(text, text_end);

	const bool log_new_line = ref_pos && (ref_pos->y > window->DC.LogLinePosY + 1);
	if (ref_pos)
		window->DC.LogLinePosY = ref_pos->y;

	const char* text_remaining = text;
	if (g.LogStartDepth > window->DC.TreeDepth)  // Re-adjust padding if we have popped out of our starting depth
		g.LogStartDepth = window->DC.TreeDepth;
	const int tree_depth = (window->DC.TreeDepth - g.LogStartDepth);
	for (;;)
	{
		// Split the string. Each new line (after a '\n') is followed by spacing corresponding to the current depth of our log entry.
		const char* line_end = text_remaining;
		while (line_end < text_end)
			if (*line_end == '\n')
				break;
			else
				line_end++;
		if (line_end >= text_end)
			line_end = NULL;

		const bool is_first_line = (text == text_remaining);
		bool is_last_line = false;
		if (line_end == NULL)
		{
			is_last_line = true;
			line_end = text_end;
		}
		if (line_end != NULL && !(is_last_line && (line_end - text_remaining) == 0))
		{
			const int char_count = (int)(line_end - text_remaining);
			if (log_new_line || !is_first_line)
				ImGui::LogText(IM_NEWLINE "%*s%.*s", tree_depth * 4, "", char_count, text_remaining);
			else
				ImGui::LogText(" %.*s", char_count, text_remaining);
		}

		if (is_last_line)
			break;
		text_remaining = line_end + 1;
	}
}

// Internal ImGui functions to render text
// RenderText***() functions calls ImDrawList::AddText() calls ImBitmapFont::RenderText()
void ImGui::RenderText(ImVec2 pos, const char* text, const char* text_end, bool hide_text_after_hash)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	// Hide anything after a '##' string
	const char* text_display_end;
	if (hide_text_after_hash)
	{
		text_display_end = FindRenderedTextEnd(text, text_end);
	}
	else
	{
		if (!text_end)
			text_end = text + strlen(text); // FIXME-OPT
		text_display_end = text_end;
	}

	const int text_len = (int)(text_display_end - text);
	if (text_len > 0)
	{
		window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end);
		if (g.LogEnabled)
			LogRenderedText(&pos, text, text_display_end);
	}
}

void ImGui::RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	if (!text_end)
		text_end = text + strlen(text); // FIXME-OPT

	const int text_len = (int)(text_end - text);
	if (text_len > 0)
	{
		window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_end, wrap_width);
		if (g.LogEnabled)
			LogRenderedText(&pos, text, text_end);
	}
}

// Default clip_rect uses (pos_min,pos_max)
// Handle clipping on CPU immediately (vs typically let the GPU clip the triangles that are overlapping the clipping rectangle edges)
void ImGui::RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align, const ImRect* clip_rect)
{
	// Hide anything after a '##' string
	const char* text_display_end = FindRenderedTextEnd(text, text_end);
	const int text_len = (int)(text_display_end - text);
	if (text_len == 0)
		return;

	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	// Perform CPU side clipping for single clipped element to avoid using scissor state
	ImVec2 pos = pos_min;
	const ImVec2 text_size = text_size_if_known ? *text_size_if_known : CalcTextSize(text, text_display_end, false, 0.0f);

	const ImVec2* clip_min = clip_rect ? &clip_rect->Min : &pos_min;
	const ImVec2* clip_max = clip_rect ? &clip_rect->Max : &pos_max;
	bool need_clipping = (pos.x + text_size.x >= clip_max->x) || (pos.y + text_size.y >= clip_max->y);
	if (clip_rect) // If we had no explicit clipping rectangle then pos==clip_min
		need_clipping |= (pos.x < clip_min->x) || (pos.y < clip_min->y);

	// Align whole block. We should defer that to the better rendering function when we'll have support for individual line alignment.
	if (align.x > 0.0f) pos.x = ImMax(pos.x, pos.x + (pos_max.x - pos.x - text_size.x) * align.x);
	if (align.y > 0.0f) pos.y = ImMax(pos.y, pos.y + (pos_max.y - pos.y - text_size.y) * align.y);

	// Render
	if (need_clipping)
	{
		ImVec4 fine_clip_rect(clip_min->x, clip_min->y, clip_max->x, clip_max->y);
		window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, &fine_clip_rect);
	}
	else
	{
		window->DrawList->AddText(g.Font, g.FontSize, pos, GetColorU32(ImGuiCol_Text), text, text_display_end, 0.0f, NULL);
	}
	if (g.LogEnabled)
		LogRenderedText(&pos, text, text_display_end);
}

// Render a rectangle shaped with optional rounding and borders
void ImGui::RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border, float rounding)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	window->DrawList->AddRectFilled(p_min, p_max, fill_col, rounding);
	const float border_size = g.Style.FrameBorderSize;
	if (border && border_size > 0.0f)
	{
		window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);
		window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);
	}
}

void ImGui::RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	const float border_size = g.Style.FrameBorderSize;
	if (border_size > 0.0f)
	{
		window->DrawList->AddRect(p_min + ImVec2(1, 1), p_max + ImVec2(1, 1), GetColorU32(ImGuiCol_BorderShadow), rounding, ImDrawCornerFlags_All, border_size);
		window->DrawList->AddRect(p_min, p_max, GetColorU32(ImGuiCol_Border), rounding, ImDrawCornerFlags_All, border_size);
	}
}

// Render a triangle to denote expanded/collapsed state
void ImGui::RenderArrow(ImVec2 p_min, ImGuiDir dir, float scale)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	const float h = g.FontSize * 1.00f;
	float r = h * 0.40f * scale;
	ImVec2 center = p_min + ImVec2(h * 0.50f, h * 0.50f * scale);

	ImVec2 a, b, c;
	switch (dir)
	{
	case ImGuiDir_Up:
	case ImGuiDir_Down:
		if (dir == ImGuiDir_Up) r = -r;
		center.y -= r * 0.25f;
		a = ImVec2(0, 1) * r;
		b = ImVec2(-0.866f, -0.5f) * r;
		c = ImVec2(+0.866f, -0.5f) * r;
		break;
	case ImGuiDir_Left:
	case ImGuiDir_Right:
		if (dir == ImGuiDir_Left) r = -r;
		center.x -= r * 0.25f;
		a = ImVec2(1, 0) * r;
		b = ImVec2(-0.500f, +0.866f) * r;
		c = ImVec2(-0.500f, -0.866f) * r;
		break;
	case ImGuiDir_None:
	case ImGuiDir_COUNT:
		IM_ASSERT(0);
		break;
	}

	window->DrawList->AddTriangleFilled(center + a, center + b, center + c, GetColorU32(ImGuiCol_Triangle));
}

void ImGui::RenderBullet(ImVec2 pos)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	window->DrawList->AddCircleFilled(pos, GImGui->FontSize * 0.20f, GetColorU32(ImGuiCol_Text), 8);
}

void ImGui::RenderCheckMark(ImVec2 pos, ImU32 col, float sz)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	float thickness = ImMax(sz / 5.0f, 1.0f);
	sz -= thickness * 0.5f;
	pos += ImVec2(thickness * 0.25f, thickness * 0.25f);

	float third = sz / 3.0f;
	float bx = pos.x + third;
	float by = pos.y + sz - third * 0.5f;
	window->DrawList->PathLineTo(ImVec2(bx - third, by - third));
	window->DrawList->PathLineTo(ImVec2(bx, by));
	window->DrawList->PathLineTo(ImVec2(bx + third * 2, by - third * 2));
	window->DrawList->PathStroke(col, false, thickness);
}

void ImGui::RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags)
{
	ImGuiContext& g = *GImGui;
	if (id != g.NavId)
		return;
	if (g.NavDisableHighlight && !(flags & ImGuiNavHighlightFlags_AlwaysDraw))
		return;
	ImGuiWindow* window = ImGui::GetCurrentWindow();
	if (window->DC.NavHideHighlightOneFrame)
		return;

	float rounding = (flags & ImGuiNavHighlightFlags_NoRounding) ? 0.0f : g.Style.FrameRounding;
	ImRect display_rect = bb;
	display_rect.ClipWith(window->ClipRect);
	if (flags & ImGuiNavHighlightFlags_TypeDefault)
	{
		const float THICKNESS = 2.0f;
		const float DISTANCE = 3.0f + THICKNESS * 0.5f;
		display_rect.Expand(ImVec2(DISTANCE, DISTANCE));
		bool fully_visible = window->ClipRect.Contains(display_rect);
		if (!fully_visible)
			window->DrawList->PushClipRect(display_rect.Min, display_rect.Max);
		window->DrawList->AddRect(display_rect.Min + ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), display_rect.Max - ImVec2(THICKNESS * 0.5f, THICKNESS * 0.5f), GetColorU32(ImGuiCol_NavHighlight), rounding, ImDrawCornerFlags_All, THICKNESS);
		if (!fully_visible)
			window->DrawList->PopClipRect();
	}
	if (flags & ImGuiNavHighlightFlags_TypeThin)
	{
		window->DrawList->AddRect(display_rect.Min, display_rect.Max, GetColorU32(ImGuiCol_NavHighlight), rounding, ~0, 1.0f);
	}
}

// Calculate text size. Text can be multi-line. Optionally ignore text after a ## marker.
// CalcTextSize("") should return ImVec2(0.0f, GImGui->FontSize)
ImVec2 ImGui::CalcTextSize(const char* text, const char* text_end, bool hide_text_after_double_hash, float wrap_width)
{
	ImGuiContext& g = *GImGui;

	const char* text_display_end;
	if (hide_text_after_double_hash)
		text_display_end = FindRenderedTextEnd(text, text_end);      // Hide anything after a '##' string
	else
		text_display_end = text_end;

	ImFont* font = g.Font;
	const float font_size = g.FontSize;
	if (text == text_display_end)
		return ImVec2(0.0f, font_size);
	ImVec2 text_size = font->CalcTextSizeA(font_size, FLT_MAX, wrap_width, text, text_display_end, NULL);

	// Cancel out character spacing for the last character of a line (it is baked into glyph->AdvanceX field)
	const float font_scale = font_size / font->FontSize;
	const float character_spacing_x = 1.0f * font_scale;
	if (text_size.x > 0.0f)
		text_size.x -= character_spacing_x;
	text_size.x = (float)(int)(text_size.x + 0.95f);

	return text_size;
}

// Helper to calculate coarse clipping of large list of evenly sized items.
// NB: Prefer using the ImGuiListClipper higher-level helper if you can! Read comments and instructions there on how those use this sort of pattern.
// NB: 'items_count' is only used to clamp the result, if you don't know your count you can use INT_MAX
void ImGui::CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if (g.LogEnabled)
	{
		// If logging is active, do not perform any clipping
		*out_items_display_start = 0;
		*out_items_display_end = items_count;
		return;
	}
	if (window->SkipItems)
	{
		*out_items_display_start = *out_items_display_end = 0;
		return;
	}

	const ImVec2 pos = window->DC.CursorPos;
	int start = (int)((window->ClipRect.Min.y - pos.y) / items_height);
	int end = (int)((window->ClipRect.Max.y - pos.y) / items_height);
	if (g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Up) // When performing a navigation request, ensure we have one item extra in the direction we are moving to
		start--;
	if (g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Down)
		end++;

	start = ImClamp(start, 0, items_count);
	end = ImClamp(end + 1, start, items_count);
	*out_items_display_start = start;
	*out_items_display_end = end;
}

// Find window given position, search front-to-back
// FIXME: Note that we have a lag here because WindowRectClipped is updated in Begin() so windows moved by user via SetWindowPos() and not SetNextWindowPos() will have that rectangle lagging by a frame at the time FindHoveredWindow() is called, aka before the next Begin(). Moving window thankfully isn't affected.
static ImGuiWindow* FindHoveredWindow()
{
	ImGuiContext& g = *GImGui;
	for (int i = g.Windows.Size - 1; i >= 0; i--)
	{
		ImGuiWindow* window = g.Windows[i];
		if (!window->Active)
			continue;
		if (window->Flags & ImGuiWindowFlags_NoInputs)
			continue;

		// Using the clipped AABB, a child window will typically be clipped by its parent (not always)
		ImRect bb(window->WindowRectClipped.Min - g.Style.TouchExtraPadding, window->WindowRectClipped.Max + g.Style.TouchExtraPadding);
		if (bb.Contains(g.IO.MousePos))
			return window;
	}
	return NULL;
}

// Test if mouse cursor is hovering given rectangle
// NB- Rectangle is clipped by our current clip setting
// NB- Expand the rectangle to be generous on imprecise inputs systems (g.Style.TouchExtraPadding)
bool ImGui::IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	// Clip
	ImRect rect_clipped(r_min, r_max);
	if (clip)
		rect_clipped.ClipWith(window->ClipRect);

	// Expand for touch input
	const ImRect rect_for_touch(rect_clipped.Min - g.Style.TouchExtraPadding, rect_clipped.Max + g.Style.TouchExtraPadding);
	return rect_for_touch.Contains(g.IO.MousePos);
}

static bool IsKeyPressedMap(ImGuiKey key, bool repeat)
{
	const int key_index = GImGui->IO.KeyMap[key];
	return (key_index >= 0) ? ImGui::IsKeyPressed(key_index, repeat) : false;
}

int ImGui::GetKeyIndex(ImGuiKey imgui_key)
{
	IM_ASSERT(imgui_key >= 0 && imgui_key < ImGuiKey_COUNT);
	return GImGui->IO.KeyMap[imgui_key];
}

// Note that imgui doesn't know the semantic of each entry of io.KeyDown[]. Use your own indices/enums according to how your back-end/engine stored them into KeyDown[]!
bool ImGui::IsKeyDown(int user_key_index)
{
	if (user_key_index < 0) return false;
	IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(GImGui->IO.KeysDown));
	return GImGui->IO.KeysDown[user_key_index];
}

int ImGui::CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate)
{
	if (t == 0.0f)
		return 1;
	if (t <= repeat_delay || repeat_rate <= 0.0f)
		return 0;
	const int count = (int)((t - repeat_delay) / repeat_rate) - (int)((t_prev - repeat_delay) / repeat_rate);
	return (count > 0) ? count : 0;
}

int ImGui::GetKeyPressedAmount(int key_index, float repeat_delay, float repeat_rate)
{
	ImGuiContext& g = *GImGui;
	if (key_index < 0) return false;
	IM_ASSERT(key_index >= 0 && key_index < IM_ARRAYSIZE(g.IO.KeysDown));
	const float t = g.IO.KeysDownDuration[key_index];
	return CalcTypematicPressedRepeatAmount(t, t - g.IO.DeltaTime, repeat_delay, repeat_rate);
}

bool ImGui::IsKeyPressed(int user_key_index, bool repeat)
{
	ImGuiContext& g = *GImGui;
	if (user_key_index < 0) return false;
	IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
	const float t = g.IO.KeysDownDuration[user_key_index];
	if (t == 0.0f)
		return true;
	if (repeat && t > g.IO.KeyRepeatDelay)
		return GetKeyPressedAmount(user_key_index, g.IO.KeyRepeatDelay, g.IO.KeyRepeatRate) > 0;
	return false;
}

bool ImGui::IsKeyReleased(int user_key_index)
{
	ImGuiContext& g = *GImGui;
	if (user_key_index < 0) return false;
	IM_ASSERT(user_key_index >= 0 && user_key_index < IM_ARRAYSIZE(g.IO.KeysDown));
	return g.IO.KeysDownDurationPrev[user_key_index] >= 0.0f && !g.IO.KeysDown[user_key_index];
}

bool ImGui::IsMouseDown(int button)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	return g.IO.MouseDown[button];
}

bool ImGui::IsAnyMouseDown()
{
	ImGuiContext& g = *GImGui;
	for (int n = 0; n < IM_ARRAYSIZE(g.IO.MouseDown); n++)
		if (g.IO.MouseDown[n])
			return true;
	return false;
}

bool ImGui::IsMouseClicked(int button, bool repeat)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	const float t = g.IO.MouseDownDuration[button];
	if (t == 0.0f)
		return true;

	if (repeat && t > g.IO.KeyRepeatDelay)
	{
		float delay = g.IO.KeyRepeatDelay, rate = g.IO.KeyRepeatRate;
		if ((fmodf(t - delay, rate) > rate * 0.5f) != (fmodf(t - delay - g.IO.DeltaTime, rate) > rate * 0.5f))
			return true;
	}

	return false;
}

bool ImGui::IsMouseReleased(int button)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	return g.IO.MouseReleased[button];
}

bool ImGui::IsMouseDoubleClicked(int button)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	return g.IO.MouseDoubleClicked[button];
}

bool ImGui::IsMouseDragging(int button, float lock_threshold)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	if (!g.IO.MouseDown[button])
		return false;
	if (lock_threshold < 0.0f)
		lock_threshold = g.IO.MouseDragThreshold;
	return g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold;
}

ImVec2 ImGui::GetMousePos()
{
	return GImGui->IO.MousePos;
}

// NB: prefer to call right after BeginPopup(). At the time Selectable/MenuItem is activated, the popup is already closed!
ImVec2 ImGui::GetMousePosOnOpeningCurrentPopup()
{
	ImGuiContext& g = *GImGui;
	if (g.CurrentPopupStack.Size > 0)
		return g.OpenPopupStack[g.CurrentPopupStack.Size - 1].OpenMousePos;
	return g.IO.MousePos;
}

// We typically use ImVec2(-FLT_MAX,-FLT_MAX) to denote an invalid mouse position
bool ImGui::IsMousePosValid(const ImVec2* mouse_pos)
{
	if (mouse_pos == NULL)
		mouse_pos = &GImGui->IO.MousePos;
	const float MOUSE_INVALID = -256000.0f;
	return mouse_pos->x >= MOUSE_INVALID && mouse_pos->y >= MOUSE_INVALID;
}

// NB: This is only valid if IsMousePosValid(). Back-ends in theory should always keep mouse position valid when dragging even outside the client window.
ImVec2 ImGui::GetMouseDragDelta(int button, float lock_threshold)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	if (lock_threshold < 0.0f)
		lock_threshold = g.IO.MouseDragThreshold;
	if (g.IO.MouseDown[button])
		if (g.IO.MouseDragMaxDistanceSqr[button] >= lock_threshold * lock_threshold)
			return g.IO.MousePos - g.IO.MouseClickedPos[button];     // Assume we can only get active with left-mouse button (at the moment).
	return ImVec2(0.0f, 0.0f);
}

void ImGui::ResetMouseDragDelta(int button)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(button >= 0 && button < IM_ARRAYSIZE(g.IO.MouseDown));
	// NB: We don't need to reset g.IO.MouseDragMaxDistanceSqr
	g.IO.MouseClickedPos[button] = g.IO.MousePos;
}

ImGuiMouseCursor ImGui::GetMouseCursor()
{
	return GImGui->MouseCursor;
}

void ImGui::SetMouseCursor(ImGuiMouseCursor cursor_type)
{
	GImGui->MouseCursor = cursor_type;
}

void ImGui::CaptureKeyboardFromApp(bool capture)
{
	GImGui->WantCaptureKeyboardNextFrame = capture ? 1 : 0;
}

void ImGui::CaptureMouseFromApp(bool capture)
{
	GImGui->WantCaptureMouseNextFrame = capture ? 1 : 0;
}

bool ImGui::IsItemActive()
{
	ImGuiContext& g = *GImGui;
	if (g.ActiveId)
	{
		ImGuiWindow* window = g.CurrentWindow;
		return g.ActiveId == window->DC.LastItemId;
	}
	return false;
}

bool ImGui::IsItemFocused()
{
	ImGuiContext& g = *GImGui;
	return g.NavId && !g.NavDisableHighlight && g.NavId == g.CurrentWindow->DC.LastItemId;
}

bool ImGui::IsItemClicked(int mouse_button)
{
	return IsMouseClicked(mouse_button) && IsItemHovered(ImGuiHoveredFlags_Default);
}

bool ImGui::IsAnyItemHovered()
{
	ImGuiContext& g = *GImGui;
	return g.HoveredId != 0 || g.HoveredIdPreviousFrame != 0;
}

bool ImGui::IsAnyItemActive()
{
	ImGuiContext& g = *GImGui;
	return g.ActiveId != 0;
}

bool ImGui::IsAnyItemFocused()
{
	ImGuiContext& g = *GImGui;
	return g.NavId != 0 && !g.NavDisableHighlight;
}

bool ImGui::IsItemVisible()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->ClipRect.Overlaps(window->DC.LastItemRect);
}

// Allow last item to be overlapped by a subsequent item. Both may be activated during the same frame before the later one takes priority.
void ImGui::SetItemAllowOverlap()
{
	ImGuiContext& g = *GImGui;
	if (g.HoveredId == g.CurrentWindow->DC.LastItemId)
		g.HoveredIdAllowOverlap = true;
	if (g.ActiveId == g.CurrentWindow->DC.LastItemId)
		g.ActiveIdAllowOverlap = true;
}

ImVec2 ImGui::GetItemRectMin()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.LastItemRect.Min;
}

ImVec2 ImGui::GetItemRectMax()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.LastItemRect.Max;
}

ImVec2 ImGui::GetItemRectSize()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.LastItemRect.GetSize();
}

static ImRect GetViewportRect()
{
	ImGuiContext& g = *GImGui;
	if (g.IO.DisplayVisibleMin.x != g.IO.DisplayVisibleMax.x && g.IO.DisplayVisibleMin.y != g.IO.DisplayVisibleMax.y)
		return ImRect(g.IO.DisplayVisibleMin, g.IO.DisplayVisibleMax);
	return ImRect(0.0f, 0.0f, g.IO.DisplaySize.x, g.IO.DisplaySize.y);
}

// Not exposed publicly as BeginTooltip() because bool parameters are evil. Let's see if other needs arise first.
void ImGui::BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip)
{
	ImGuiContext& g = *GImGui;
	char window_name[16];
	ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", g.TooltipOverrideCount);
	if (override_previous_tooltip)
		if (ImGuiWindow* window = FindWindowByName(window_name))
			if (window->Active)
			{
				// Hide previous tooltip from being displayed. We can't easily "reset" the content of a window so we create a new one.
				window->HiddenFrames = 1;
				ImFormatString(window_name, IM_ARRAYSIZE(window_name), "##Tooltip_%02d", ++g.TooltipOverrideCount);
			}
	ImGuiWindowFlags flags = ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_NoInputs | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoNav;
	Begin(window_name, NULL, flags | extra_flags);
}

void ImGui::SetTooltipV(const char* fmt, va_list args)
{
	BeginTooltipEx(0, true);
	TextV(fmt, args);
	EndTooltip();
}

void ImGui::SetTooltip(const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	SetTooltipV(fmt, args);
	va_end(args);
}

void ImGui::BeginTooltip()
{
	BeginTooltipEx(0, false);
}

void ImGui::EndTooltip()
{
	IM_ASSERT(GetCurrentWindowRead()->Flags & ImGuiWindowFlags_Tooltip);   // Mismatched BeginTooltip()/EndTooltip() calls
	End();
}

// Mark popup as open (toggle toward open state).
// Popups are closed when user click outside, or activate a pressable item, or CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block.
// Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
// One open popup per level of the popup hierarchy (NB: when assigning we reset the Window member of ImGuiPopupRef to NULL)
void ImGui::OpenPopupEx(ImGuiID id)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* parent_window = g.CurrentWindow;
	int current_stack_size = g.CurrentPopupStack.Size;
	ImGuiPopupRef popup_ref; // Tagged as new ref as Window will be set back to NULL if we write this into OpenPopupStack.
	popup_ref.PopupId = id;
	popup_ref.Window = NULL;
	popup_ref.ParentWindow = parent_window;
	popup_ref.OpenFrameCount = g.FrameCount;
	popup_ref.OpenParentId = parent_window->IDStack.back();
	popup_ref.OpenMousePos = g.IO.MousePos;
	popup_ref.OpenPopupPos = (!g.NavDisableHighlight && g.NavDisableMouseHover) ? NavCalcPreferredMousePos() : g.IO.MousePos;

	//printf("[%05d] OpenPopupEx(0x%08X)\n", g.FrameCount, id);
	if (g.OpenPopupStack.Size < current_stack_size + 1)
	{
		g.OpenPopupStack.push_back(popup_ref);
	}
	else
	{
		// Close child popups if any
		g.OpenPopupStack.resize(current_stack_size + 1);

		// Gently handle the user mistakenly calling OpenPopup() every frame. It is a programming mistake! However, if we were to run the regular code path, the ui
		// would become completely unusable because the popup will always be in hidden-while-calculating-size state _while_ claiming focus. Which would be a very confusing
		// situation for the programmer. Instead, we silently allow the popup to proceed, it will keep reappearing and the programming error will be more obvious to understand.
		if (g.OpenPopupStack[current_stack_size].PopupId == id && g.OpenPopupStack[current_stack_size].OpenFrameCount == g.FrameCount - 1)
			g.OpenPopupStack[current_stack_size].OpenFrameCount = popup_ref.OpenFrameCount;
		else
			g.OpenPopupStack[current_stack_size] = popup_ref;

		// When reopening a popup we first refocus its parent, otherwise if its parent is itself a popup it would get closed by ClosePopupsOverWindow().
		// This is equivalent to what ClosePopupToLevel() does.
		//if (g.OpenPopupStack[current_stack_size].PopupId == id)
		//    FocusWindow(parent_window);
	}
}

void ImGui::OpenPopup(const char* str_id)
{
	ImGuiContext& g = *GImGui;
	OpenPopupEx(g.CurrentWindow->GetID(str_id));
}

void ImGui::ClosePopupsOverWindow(ImGuiWindow* ref_window)
{
	ImGuiContext& g = *GImGui;
	if (g.OpenPopupStack.empty())
		return;

	// When popups are stacked, clicking on a lower level popups puts focus back to it and close popups above it.
	// Don't close our own child popup windows.
	int n = 0;
	if (ref_window)
	{
		for (n = 0; n < g.OpenPopupStack.Size; n++)
		{
			ImGuiPopupRef& popup = g.OpenPopupStack[n];
			if (!popup.Window)
				continue;
			IM_ASSERT((popup.Window->Flags & ImGuiWindowFlags_Popup) != 0);
			if (popup.Window->Flags & ImGuiWindowFlags_ChildWindow)
				continue;

			// Trim the stack if popups are not direct descendant of the reference window (which is often the NavWindow)
			bool has_focus = false;
			for (int m = n; m < g.OpenPopupStack.Size && !has_focus; m++)
				has_focus = (g.OpenPopupStack[m].Window && g.OpenPopupStack[m].Window->RootWindow == ref_window->RootWindow);
			if (!has_focus)
				break;
		}
	}
	if (n < g.OpenPopupStack.Size) // This test is not required but it allows to set a convenient breakpoint on the block below
		ClosePopupToLevel(n);
}

static ImGuiWindow* GetFrontMostModalRootWindow()
{
	ImGuiContext& g = *GImGui;
	for (int n = g.OpenPopupStack.Size - 1; n >= 0; n--)
		if (ImGuiWindow* popup = g.OpenPopupStack.Data[n].Window)
			if (popup->Flags & ImGuiWindowFlags_Modal)
				return popup;
	return NULL;
}

static void ClosePopupToLevel(int remaining)
{
	IM_ASSERT(remaining >= 0);
	ImGuiContext& g = *GImGui;
	ImGuiWindow* focus_window = (remaining > 0) ? g.OpenPopupStack[remaining - 1].Window : g.OpenPopupStack[0].ParentWindow;
	if (g.NavLayer == 0)
		focus_window = NavRestoreLastChildNavWindow(focus_window);
	ImGui::FocusWindow(focus_window);
	focus_window->DC.NavHideHighlightOneFrame = true;
	g.OpenPopupStack.resize(remaining);
}

void ImGui::ClosePopup(ImGuiID id)
{
	if (!IsPopupOpen(id))
		return;
	ImGuiContext& g = *GImGui;
	ClosePopupToLevel(g.OpenPopupStack.Size - 1);
}

// Close the popup we have begin-ed into.
void ImGui::CloseCurrentPopup()
{
	ImGuiContext& g = *GImGui;
	int popup_idx = g.CurrentPopupStack.Size - 1;
	if (popup_idx < 0 || popup_idx >= g.OpenPopupStack.Size || g.CurrentPopupStack[popup_idx].PopupId != g.OpenPopupStack[popup_idx].PopupId)
		return;
	while (popup_idx > 0 && g.OpenPopupStack[popup_idx].Window && (g.OpenPopupStack[popup_idx].Window->Flags & ImGuiWindowFlags_ChildMenu))
		popup_idx--;
	ClosePopupToLevel(popup_idx);
}

bool ImGui::BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags)
{
	ImGuiContext& g = *GImGui;
	if (!IsPopupOpen(id))
	{
		g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
		return false;
	}

	char name[20];
	if (extra_flags & ImGuiWindowFlags_ChildMenu)
		ImFormatString(name, IM_ARRAYSIZE(name), "##Menu_%02d", g.CurrentPopupStack.Size);    // Recycle windows based on depth
	else
		ImFormatString(name, IM_ARRAYSIZE(name), "##Popup_%08x", id); // Not recycling, so we can close/open during the same frame

	bool is_open = Begin(name, NULL, extra_flags | ImGuiWindowFlags_Popup);
	if (!is_open) // NB: Begin can return false when the popup is completely clipped (e.g. zero size display)
		EndPopup();

	return is_open;
}

bool ImGui::BeginPopup(const char* str_id, ImGuiWindowFlags flags)
{
	ImGuiContext& g = *GImGui;
	if (g.OpenPopupStack.Size <= g.CurrentPopupStack.Size) // Early out for performance
	{
		g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
		return false;
	}
	return BeginPopupEx(g.CurrentWindow->GetID(str_id), flags | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::IsPopupOpen(ImGuiID id)
{
	ImGuiContext& g = *GImGui;
	return g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].PopupId == id;
}

bool ImGui::IsPopupOpen(const char* str_id)
{
	ImGuiContext& g = *GImGui;
	return g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].PopupId == g.CurrentWindow->GetID(str_id);
}

bool ImGui::BeginPopupModal(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	const ImGuiID id = window->GetID(name);
	if (!IsPopupOpen(id))
	{
		g.NextWindowData.Clear(); // We behave like Begin() and need to consume those values
		return false;
	}

	// Center modal windows by default
	// FIXME: Should test for (PosCond & window->SetWindowPosAllowFlags) with the upcoming window.
	if (g.NextWindowData.PosCond == 0)
		SetNextWindowPos(g.IO.DisplaySize * 0.5f, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

	bool is_open = Begin(name, p_open, flags | ImGuiWindowFlags_Popup | ImGuiWindowFlags_Modal | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoSavedSettings);
	if (!is_open || (p_open && !*p_open)) // NB: is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
	{
		EndPopup();
		if (is_open)
			ClosePopup(id);
		return false;
	}

	return is_open;
}

static void NavProcessMoveRequestWrapAround(ImGuiWindow* window)
{
	ImGuiContext& g = *GImGui;
	if (g.NavWindow == window && NavMoveRequestButNoResultYet())
		if ((g.NavMoveDir == ImGuiDir_Up || g.NavMoveDir == ImGuiDir_Down) && g.NavMoveRequestForward == ImGuiNavForward_None && g.NavLayer == 0)
		{
			g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
			ImGui::NavMoveRequestCancel();
			g.NavWindow->NavRectRel[0].Min.y = g.NavWindow->NavRectRel[0].Max.y = ((g.NavMoveDir == ImGuiDir_Up) ? ImMax(window->SizeFull.y, window->SizeContents.y) : 0.0f) - window->Scroll.y;
		}
}

void ImGui::EndPopup()
{
	ImGuiContext& g = *GImGui; (void)g;
	IM_ASSERT(g.CurrentWindow->Flags & ImGuiWindowFlags_Popup);  // Mismatched BeginPopup()/EndPopup() calls
	IM_ASSERT(g.CurrentPopupStack.Size > 0);

	// Make all menus and popups wrap around for now, may need to expose that policy.
	NavProcessMoveRequestWrapAround(g.CurrentWindow);

	End();
}

bool ImGui::OpenPopupOnItemClick(const char* str_id, int mouse_button)
{
	ImGuiWindow* window = GImGui->CurrentWindow;
	if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
	{
		ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
		IM_ASSERT(id != 0);                                                  // However, you cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
		OpenPopupEx(id);
		return true;
	}
	return false;
}

// This is a helper to handle the simplest case of associating one named popup to one given widget.
// You may want to handle this on user side if you have specific needs (e.g. tweaking IsItemHovered() parameters).
// You can pass a NULL str_id to use the identifier of the last item.
bool ImGui::BeginPopupContextItem(const char* str_id, int mouse_button)
{
	ImGuiWindow* window = GImGui->CurrentWindow;
	ImGuiID id = str_id ? window->GetID(str_id) : window->DC.LastItemId; // If user hasn't passed an ID, we can use the LastItemID. Using LastItemID as a Popup ID won't conflict!
	IM_ASSERT(id != 0);                                                  // However, you cannot pass a NULL str_id if the last item has no identifier (e.g. a Text() item)
	if (IsMouseReleased(mouse_button) && IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
		OpenPopupEx(id);
	return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextWindow(const char* str_id, int mouse_button, bool also_over_items)
{
	if (!str_id)
		str_id = "window_context";
	ImGuiID id = GImGui->CurrentWindow->GetID(str_id);
	if (IsMouseReleased(mouse_button) && IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup))
		if (also_over_items || !IsAnyItemHovered())
			OpenPopupEx(id);
	return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

bool ImGui::BeginPopupContextVoid(const char* str_id, int mouse_button)
{
	if (!str_id)
		str_id = "void_context";
	ImGuiID id = GImGui->CurrentWindow->GetID(str_id);
	if (IsMouseReleased(mouse_button) && !IsWindowHovered(ImGuiHoveredFlags_AnyWindow))
		OpenPopupEx(id);
	return BeginPopupEx(id, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings);
}

static bool BeginChildEx(const char* name, ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* parent_window = ImGui::GetCurrentWindow();
	ImGuiWindowFlags flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_ChildWindow;
	flags |= (parent_window->Flags & ImGuiWindowFlags_NoMove);  // Inherit the NoMove flag

	const ImVec2 content_avail = ImGui::GetContentRegionAvail();
	ImVec2 size = ImFloor(size_arg);
	const int auto_fit_axises = ((size.x == 0.0f) ? (1 << ImGuiAxis_X) : 0x00) | ((size.y == 0.0f) ? (1 << ImGuiAxis_Y) : 0x00);
	if (size.x <= 0.0f)
		size.x = ImMax(content_avail.x + size.x, 4.0f); // Arbitrary minimum child size (0.0f causing too much issues)
	if (size.y <= 0.0f)
		size.y = ImMax(content_avail.y + size.y, 4.0f);

	const float backup_border_size = g.Style.ChildBorderSize;
	if (!border)
		g.Style.ChildBorderSize = 0.0f;
	flags |= extra_flags;

	char title[256];
	if (name)
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%s", parent_window->Name, name);
	else
		ImFormatString(title, IM_ARRAYSIZE(title), "%s/%08X", parent_window->Name, id);

	ImGui::SetNextWindowSize(size);
	bool ret = ImGui::Begin(title, NULL, flags);
	ImGuiWindow* child_window = ImGui::GetCurrentWindow();
	child_window->ChildId = id;
	child_window->AutoFitChildAxises = auto_fit_axises;
	g.Style.ChildBorderSize = backup_border_size;

	// Process navigation-in immediately so NavInit can run on first frame
	if (!(flags & ImGuiWindowFlags_NavFlattened) && (child_window->DC.NavLayerActiveMask != 0 || child_window->DC.NavHasScroll) && g.NavActivateId == id)
	{
		ImGui::FocusWindow(child_window);
		ImGui::NavInitWindow(child_window, false);
		ImGui::SetActiveID(id + 1, child_window); // Steal ActiveId with a dummy id so that key-press won't activate child item
		g.ActiveIdSource = ImGuiInputSource_Nav;
	}

	return ret;
}

bool ImGui::BeginChild(const char* str_id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
	ImGuiWindow* window = GetCurrentWindow();
	return BeginChildEx(str_id, window->GetID(str_id), size_arg, border, extra_flags);
}

bool ImGui::BeginChild(ImGuiID id, const ImVec2& size_arg, bool border, ImGuiWindowFlags extra_flags)
{
	IM_ASSERT(id != 0);
	return BeginChildEx(NULL, id, size_arg, border, extra_flags);
}

void ImGui::EndChild()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	IM_ASSERT(window->Flags & ImGuiWindowFlags_ChildWindow);   // Mismatched BeginChild()/EndChild() callss
	if (window->BeginCount > 1)
	{
		End();
	}
	else
	{
		// When using auto-filling child window, we don't provide full width/height to ItemSize so that it doesn't feed back into automatic size-fitting.
		ImVec2 sz = GetWindowSize();
		if (window->AutoFitChildAxises & (1 << ImGuiAxis_X)) // Arbitrary minimum zero-ish child size of 4.0f causes less trouble than a 0.0f
			sz.x = ImMax(4.0f, sz.x);
		if (window->AutoFitChildAxises & (1 << ImGuiAxis_Y))
			sz.y = ImMax(4.0f, sz.y);
		End();

		ImGuiWindow* parent_window = g.CurrentWindow;
		ImRect bb(parent_window->DC.CursorPos, parent_window->DC.CursorPos + sz);
		ItemSize(sz);
		if ((window->DC.NavLayerActiveMask != 0 || window->DC.NavHasScroll) && !(window->Flags & ImGuiWindowFlags_NavFlattened))
		{
			ItemAdd(bb, window->ChildId);
			RenderNavHighlight(bb, window->ChildId);

			// When browsing a window that has no activable items (scroll only) we keep a highlight on the child
			if (window->DC.NavLayerActiveMask == 0 && window == g.NavWindow)
				RenderNavHighlight(ImRect(bb.Min - ImVec2(2, 2), bb.Max + ImVec2(2, 2)), g.NavId, ImGuiNavHighlightFlags_TypeThin);
		}
		else
		{
			// Not navigable into
			ItemAdd(bb, 0);
		}
	}
}

// Helper to create a child window / scrolling region that looks like a normal widget frame.
bool ImGui::BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags extra_flags)
{
	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	PushStyleColor(ImGuiCol_ChildBg, style.Colors[ImGuiCol_FrameBg]);
	PushStyleVar(ImGuiStyleVar_ChildRounding, style.FrameRounding);
	PushStyleVar(ImGuiStyleVar_ChildBorderSize, style.FrameBorderSize);
	PushStyleVar(ImGuiStyleVar_WindowPadding, style.FramePadding);
	return BeginChild(id, size, true, ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysUseWindowPadding | extra_flags);
}

void ImGui::EndChildFrame()
{
	EndChild();
	PopStyleVar(3);
	PopStyleColor();
}

// Save and compare stack sizes on Begin()/End() to detect usage errors
static void CheckStacksSize(ImGuiWindow* window, bool write)
{
	// NOT checking: DC.ItemWidth, DC.AllowKeyboardFocus, DC.ButtonRepeat, DC.TextWrapPos (per window) to allow user to conveniently push once and not pop (they are cleared on Begin)
	ImGuiContext& g = *GImGui;
	int* p_backup = &window->DC.StackSizesBackup[0];
	{ int current = window->IDStack.Size;       if (write)*p_backup = current; else IM_ASSERT(*p_backup == current && "PushID/PopID or TreeNode/TreePop Mismatch!"); p_backup++; }    // Too few or too many PopID()/TreePop()
	{ int current = window->DC.GroupStack.Size; if (write)*p_backup = current; else IM_ASSERT(*p_backup == current && "BeginGroup/EndGroup Mismatch!");              p_backup++; }    // Too few or too many EndGroup()
	{ int current = g.CurrentPopupStack.Size;   if (write)*p_backup = current; else IM_ASSERT(*p_backup == current && "BeginMenu/EndMenu or BeginPopup/EndPopup Mismatch"); p_backup++; }// Too few or too many EndMenu()/EndPopup()
	{ int current = g.ColorModifiers.Size;      if (write)*p_backup = current; else IM_ASSERT(*p_backup >= current && "PushStyleColor/PopStyleColor Mismatch!");     p_backup++; }    // Too few or too many PopStyleColor()
	{ int current = g.StyleModifiers.Size;      if (write)*p_backup = current; else IM_ASSERT(*p_backup >= current && "PushStyleVar/PopStyleVar Mismatch!");         p_backup++; }    // Too few or too many PopStyleVar()
	{ int current = g.FontStack.Size;           if (write)*p_backup = current; else IM_ASSERT(*p_backup >= current && "PushFont/PopFont Mismatch!");                 p_backup++; }    // Too few or too many PopFont()
	IM_ASSERT(p_backup == window->DC.StackSizesBackup + IM_ARRAYSIZE(window->DC.StackSizesBackup));
}

enum ImGuiPopupPositionPolicy
{
	ImGuiPopupPositionPolicy_Default,
	ImGuiPopupPositionPolicy_ComboBox
};

static ImVec2 FindBestWindowPosForPopup(const ImVec2& ref_pos, const ImVec2& size, ImGuiDir* last_dir, const ImRect& r_avoid, ImGuiPopupPositionPolicy policy = ImGuiPopupPositionPolicy_Default)
{
	const ImGuiStyle& style = GImGui->Style;

	// r_avoid = the rectangle to avoid (e.g. for tooltip it is a rectangle around the mouse cursor which we want to avoid. for popups it's a small point around the cursor.)
	// r_outer = the visible area rectangle, minus safe area padding. If our popup size won't fit because of safe area padding we ignore it.
	ImVec2 safe_padding = style.DisplaySafeAreaPadding;
	ImRect r_outer(GetViewportRect());
	r_outer.Expand(ImVec2((size.x - r_outer.GetWidth() > safe_padding.x * 2) ? -safe_padding.x : 0.0f, (size.y - r_outer.GetHeight() > safe_padding.y * 2) ? -safe_padding.y : 0.0f));
	ImVec2 base_pos_clamped = ImClamp(ref_pos, r_outer.Min, r_outer.Max - size);
	//GImGui->OverlayDrawList.AddRect(r_avoid.Min, r_avoid.Max, IM_COL32(255,0,0,255));
	//GImGui->OverlayDrawList.AddRect(r_outer.Min, r_outer.Max, IM_COL32(0,255,0,255));

	// Combo Box policy (we want a connecting edge)
	if (policy == ImGuiPopupPositionPolicy_ComboBox)
	{
		const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Down, ImGuiDir_Right, ImGuiDir_Left, ImGuiDir_Up };
		for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
		{
			const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
			if (n != -1 && dir == *last_dir) // Already tried this direction?
				continue;
			ImVec2 pos;
			if (dir == ImGuiDir_Down)  pos = ImVec2(r_avoid.Min.x, r_avoid.Max.y);          // Below, Toward Right (default)
			if (dir == ImGuiDir_Right) pos = ImVec2(r_avoid.Min.x, r_avoid.Min.y - size.y); // Above, Toward Right
			if (dir == ImGuiDir_Left)  pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Max.y); // Below, Toward Left
			if (dir == ImGuiDir_Up)    pos = ImVec2(r_avoid.Max.x - size.x, r_avoid.Min.y - size.y); // Above, Toward Left
			if (!r_outer.Contains(ImRect(pos, pos + size)))
				continue;
			*last_dir = dir;
			return pos;
		}
	}

	// Default popup policy
	const ImGuiDir dir_prefered_order[ImGuiDir_COUNT] = { ImGuiDir_Right, ImGuiDir_Down, ImGuiDir_Up, ImGuiDir_Left };
	for (int n = (*last_dir != ImGuiDir_None) ? -1 : 0; n < ImGuiDir_COUNT; n++)
	{
		const ImGuiDir dir = (n == -1) ? *last_dir : dir_prefered_order[n];
		if (n != -1 && dir == *last_dir) // Already tried this direction?
			continue;
		float avail_w = (dir == ImGuiDir_Left ? r_avoid.Min.x : r_outer.Max.x) - (dir == ImGuiDir_Right ? r_avoid.Max.x : r_outer.Min.x);
		float avail_h = (dir == ImGuiDir_Up ? r_avoid.Min.y : r_outer.Max.y) - (dir == ImGuiDir_Down ? r_avoid.Max.y : r_outer.Min.y);
		if (avail_w < size.x || avail_h < size.y)
			continue;
		ImVec2 pos;
		pos.x = (dir == ImGuiDir_Left) ? r_avoid.Min.x - size.x : (dir == ImGuiDir_Right) ? r_avoid.Max.x : base_pos_clamped.x;
		pos.y = (dir == ImGuiDir_Up) ? r_avoid.Min.y - size.y : (dir == ImGuiDir_Down) ? r_avoid.Max.y : base_pos_clamped.y;
		*last_dir = dir;
		return pos;
	}

	// Fallback, try to keep within display
	*last_dir = ImGuiDir_None;
	ImVec2 pos = ref_pos;
	pos.x = ImMax(ImMin(pos.x + size.x, r_outer.Max.x) - size.x, r_outer.Min.x);
	pos.y = ImMax(ImMin(pos.y + size.y, r_outer.Max.y) - size.y, r_outer.Min.y);
	return pos;
}

static void SetWindowConditionAllowFlags(ImGuiWindow* window, ImGuiCond flags, bool enabled)
{
	window->SetWindowPosAllowFlags = enabled ? (window->SetWindowPosAllowFlags | flags) : (window->SetWindowPosAllowFlags & ~flags);
	window->SetWindowSizeAllowFlags = enabled ? (window->SetWindowSizeAllowFlags | flags) : (window->SetWindowSizeAllowFlags & ~flags);
	window->SetWindowCollapsedAllowFlags = enabled ? (window->SetWindowCollapsedAllowFlags | flags) : (window->SetWindowCollapsedAllowFlags & ~flags);
}

ImGuiWindow* ImGui::FindWindowByName(const char* name)
{
	ImGuiContext& g = *GImGui;
	ImGuiID id = ImHash(name, 0);
	return (ImGuiWindow*)g.WindowsById.GetVoidPtr(id);
}

static ImGuiWindow* CreateNewWindow(const char* name, ImVec2 size, ImGuiWindowFlags flags)
{
	ImGuiContext& g = *GImGui;

	// Create window the first time
	ImGuiWindow* window = IM_NEW(ImGuiWindow)(&g, name);
	window->Flags = flags;
	g.WindowsById.SetVoidPtr(window->ID, window);

	// User can disable loading and saving of settings. Tooltip and child windows also don't store settings.
	if (!(flags & ImGuiWindowFlags_NoSavedSettings))
	{
		// Retrieve settings from .ini file
		// Use SetWindowPos() or SetNextWindowPos() with the appropriate condition flag to change the initial position of a window.
		window->Pos = window->PosFloat = ImVec2(60, 60);

		if (ImGuiWindowSettings* settings = ImGui::FindWindowSettings(window->ID))
		{
			SetWindowConditionAllowFlags(window, ImGuiCond_FirstUseEver, false);
			window->PosFloat = settings->Pos;
			window->Pos = ImFloor(window->PosFloat);
			window->Collapsed = settings->Collapsed;
			if (ImLengthSqr(settings->Size) > 0.00001f)
				size = settings->Size;
		}
	}
	window->Size = window->SizeFull = window->SizeFullAtLastBegin = size;

	if ((flags & ImGuiWindowFlags_AlwaysAutoResize) != 0)
	{
		window->AutoFitFramesX = window->AutoFitFramesY = 2;
		window->AutoFitOnlyGrows = false;
	}
	else
	{
		if (window->Size.x <= 0.0f)
			window->AutoFitFramesX = 2;
		if (window->Size.y <= 0.0f)
			window->AutoFitFramesY = 2;
		window->AutoFitOnlyGrows = (window->AutoFitFramesX > 0) || (window->AutoFitFramesY > 0);
	}

	if (flags & ImGuiWindowFlags_NoBringToFrontOnFocus)
		g.Windows.insert(g.Windows.begin(), window); // Quite slow but rare and only once
	else
		g.Windows.push_back(window);
	return window;
}

static ImVec2 CalcSizeAfterConstraint(ImGuiWindow* window, ImVec2 new_size)
{
	ImGuiContext& g = *GImGui;
	if (g.NextWindowData.SizeConstraintCond != 0)
	{
		// Using -1,-1 on either X/Y axis to preserve the current size.
		ImRect cr = g.NextWindowData.SizeConstraintRect;
		new_size.x = (cr.Min.x >= 0 && cr.Max.x >= 0) ? ImClamp(new_size.x, cr.Min.x, cr.Max.x) : window->SizeFull.x;
		new_size.y = (cr.Min.y >= 0 && cr.Max.y >= 0) ? ImClamp(new_size.y, cr.Min.y, cr.Max.y) : window->SizeFull.y;
		if (g.NextWindowData.SizeCallback)
		{
			ImGuiSizeCallbackData data;
			data.UserData = g.NextWindowData.SizeCallbackUserData;
			data.Pos = window->Pos;
			data.CurrentSize = window->SizeFull;
			data.DesiredSize = new_size;
			g.NextWindowData.SizeCallback(&data);
			new_size = data.DesiredSize;
		}
	}

	// Minimum size
	if (!(window->Flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_AlwaysAutoResize)))
	{
		new_size = ImMax(new_size, g.Style.WindowMinSize);
		new_size.y = ImMax(new_size.y, window->TitleBarHeight() + window->MenuBarHeight() + ImMax(0.0f, g.Style.WindowRounding - 1.0f)); // Reduce artifacts with very small windows
	}
	return new_size;
}

static ImVec2 CalcSizeContents(ImGuiWindow* window)
{
	ImVec2 sz;
	sz.x = (float)(int)((window->SizeContentsExplicit.x != 0.0f) ? window->SizeContentsExplicit.x : (window->DC.CursorMaxPos.x - window->Pos.x + window->Scroll.x));
	sz.y = (float)(int)((window->SizeContentsExplicit.y != 0.0f) ? window->SizeContentsExplicit.y : (window->DC.CursorMaxPos.y - window->Pos.y + window->Scroll.y));
	return sz + window->WindowPadding;
}

static ImVec2 CalcSizeAutoFit(ImGuiWindow* window, const ImVec2& size_contents)
{
	ImGuiContext& g = *GImGui;
	ImGuiStyle& style = g.Style;
	ImGuiWindowFlags flags = window->Flags;
	ImVec2 size_auto_fit;
	if ((flags & ImGuiWindowFlags_Tooltip) != 0)
	{
		// Tooltip always resize. We keep the spacing symmetric on both axises for aesthetic purpose.
		size_auto_fit = size_contents;
	}
	else
	{
		// When the window cannot fit all contents (either because of constraints, either because screen is too small): we are growing the size on the other axis to compensate for expected scrollbar. FIXME: Might turn bigger than DisplaySize-WindowPadding.
		size_auto_fit = ImClamp(size_contents, style.WindowMinSize, ImMax(style.WindowMinSize, g.IO.DisplaySize - g.Style.DisplaySafeAreaPadding));
		ImVec2 size_auto_fit_after_constraint = CalcSizeAfterConstraint(window, size_auto_fit);
		if (size_auto_fit_after_constraint.x < size_contents.x && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar))
			size_auto_fit.y += style.ScrollbarSize;
		if (size_auto_fit_after_constraint.y < size_contents.y && !(flags & ImGuiWindowFlags_NoScrollbar))
			size_auto_fit.x += style.ScrollbarSize;
	}
	return size_auto_fit;
}

static float GetScrollMaxX(ImGuiWindow* window)
{
	return ImMax(0.0f, window->SizeContents.x - (window->SizeFull.x - window->ScrollbarSizes.x));
}

static float GetScrollMaxY(ImGuiWindow* window)
{
	return ImMax(0.0f, window->SizeContents.y - (window->SizeFull.y - window->ScrollbarSizes.y));
}

static ImVec2 CalcNextScrollFromScrollTargetAndClamp(ImGuiWindow* window)
{
	ImVec2 scroll = window->Scroll;
	float cr_x = window->ScrollTargetCenterRatio.x;
	float cr_y = window->ScrollTargetCenterRatio.y;
	if (window->ScrollTarget.x < FLT_MAX)
		scroll.x = window->ScrollTarget.x - cr_x * (window->SizeFull.x - window->ScrollbarSizes.x);
	if (window->ScrollTarget.y < FLT_MAX)
		scroll.y = window->ScrollTarget.y - (1.0f - cr_y) * (window->TitleBarHeight() + window->MenuBarHeight()) - cr_y * (window->SizeFull.y - window->ScrollbarSizes.y);
	scroll = ImMax(scroll, ImVec2(0.0f, 0.0f));
	if (!window->Collapsed && !window->SkipItems)
	{
		scroll.x = ImMin(scroll.x, GetScrollMaxX(window));
		scroll.y = ImMin(scroll.y, GetScrollMaxY(window));
	}
	return scroll;
}

static ImGuiCol GetWindowBgColorIdxFromFlags(ImGuiWindowFlags flags)
{
	if (flags & (ImGuiWindowFlags_Tooltip | ImGuiWindowFlags_Popup))
		return ImGuiCol_PopupBg;
	if (flags & ImGuiWindowFlags_ChildWindow)
		return ImGuiCol_ChildBg;
	return ImGuiCol_WindowBg;
}

static void CalcResizePosSizeFromAnyCorner(ImGuiWindow* window, const ImVec2& corner_target, const ImVec2& corner_norm, ImVec2* out_pos, ImVec2* out_size)
{
	ImVec2 pos_min = ImLerp(corner_target, window->Pos, corner_norm);                // Expected window upper-left
	ImVec2 pos_max = ImLerp(window->Pos + window->Size, corner_target, corner_norm); // Expected window lower-right
	ImVec2 size_expected = pos_max - pos_min;
	ImVec2 size_constrained = CalcSizeAfterConstraint(window, size_expected);
	*out_pos = pos_min;
	if (corner_norm.x == 0.0f)
		out_pos->x -= (size_constrained.x - size_expected.x);
	if (corner_norm.y == 0.0f)
		out_pos->y -= (size_constrained.y - size_expected.y);
	*out_size = size_constrained;
}

struct ImGuiResizeGripDef
{
	ImVec2           CornerPos;
	ImVec2           InnerDir;
	int              AngleMin12, AngleMax12;
};

const ImGuiResizeGripDef resize_grip_def[4] =
{
	{ ImVec2(1,1), ImVec2(-1,-1), 0, 3 }, // Lower right
{ ImVec2(0,1), ImVec2(+1,-1), 3, 6 }, // Lower left
{ ImVec2(0,0), ImVec2(+1,+1), 6, 9 }, // Upper left
{ ImVec2(1,0), ImVec2(-1,+1), 9,12 }, // Upper right
};

static ImRect GetBorderRect(ImGuiWindow* window, int border_n, float perp_padding, float thickness)
{
	ImRect rect = window->Rect();
	if (thickness == 0.0f) rect.Max -= ImVec2(1, 1);
	if (border_n == 0) return ImRect(rect.Min.x + perp_padding, rect.Min.y, rect.Max.x - perp_padding, rect.Min.y + thickness);
	if (border_n == 1) return ImRect(rect.Max.x - thickness, rect.Min.y + perp_padding, rect.Max.x, rect.Max.y - perp_padding);
	if (border_n == 2) return ImRect(rect.Min.x + perp_padding, rect.Max.y - thickness, rect.Max.x - perp_padding, rect.Max.y);
	if (border_n == 3) return ImRect(rect.Min.x, rect.Min.y + perp_padding, rect.Min.x + thickness, rect.Max.y - perp_padding);
	IM_ASSERT(0);
	return ImRect();
}

// Handle resize for: Resize Grips, Borders, Gamepad
static void ImGui::UpdateManualResize(ImGuiWindow* window, const ImVec2& size_auto_fit, int* border_held, int resize_grip_count, ImU32 resize_grip_col[4])
{
	ImGuiContext& g = *GImGui;
	ImGuiWindowFlags flags = window->Flags;
	if ((flags & ImGuiWindowFlags_NoResize) || (flags & ImGuiWindowFlags_AlwaysAutoResize) || window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
		return;

	const int resize_border_count = (flags & ImGuiWindowFlags_ResizeFromAnySide) ? 4 : 0;
	const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);
	const float grip_hover_size = (float)(int)(grip_draw_size * 0.75f);

	ImVec2 pos_target(FLT_MAX, FLT_MAX);
	ImVec2 size_target(FLT_MAX, FLT_MAX);

	// Manual resize grips
	PushID("#RESIZE");
	for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
	{
		const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
		const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPos);

		// Using the FlattenChilds button flag we make the resize button accessible even if we are hovering over a child window
		ImRect resize_rect(corner, corner + grip.InnerDir * grip_hover_size);
		resize_rect.FixInverted();
		bool hovered, held;
		ButtonBehavior(resize_rect, window->GetID((void*)(intptr_t)resize_grip_n), &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_NoNavFocus);
		if (hovered || held)
			g.MouseCursor = (resize_grip_n & 1) ? ImGuiMouseCursor_ResizeNESW : ImGuiMouseCursor_ResizeNWSE;

		if (g.HoveredWindow == window && held && g.IO.MouseDoubleClicked[0] && resize_grip_n == 0)
		{
			// Manual auto-fit when double-clicking
			size_target = CalcSizeAfterConstraint(window, size_auto_fit);
			ClearActiveID();
		}
		else if (held)
		{
			// Resize from any of the four corners
			// We don't use an incremental MouseDelta but rather compute an absolute target size based on mouse position
			ImVec2 corner_target = g.IO.MousePos - g.ActiveIdClickOffset + resize_rect.GetSize() * grip.CornerPos; // Corner of the window corresponding to our corner grip
			CalcResizePosSizeFromAnyCorner(window, corner_target, grip.CornerPos, &pos_target, &size_target);
		}
		if (resize_grip_n == 0 || held || hovered)
			resize_grip_col[resize_grip_n] = GetColorU32(held ? ImGuiCol_ResizeGripActive : hovered ? ImGuiCol_ResizeGripHovered : ImGuiCol_ResizeGrip);
	}
	for (int border_n = 0; border_n < resize_border_count; border_n++)
	{
		const float BORDER_SIZE = 5.0f;          // FIXME: Only works _inside_ window because of HoveredWindow check.
		const float BORDER_APPEAR_TIMER = 0.05f; // Reduce visual noise
		bool hovered, held;
		ImRect border_rect = GetBorderRect(window, border_n, grip_hover_size, BORDER_SIZE);
		ButtonBehavior(border_rect, window->GetID((void*)(intptr_t)(border_n + 4)), &hovered, &held, ImGuiButtonFlags_FlattenChildren);
		if ((hovered && g.HoveredIdTimer > BORDER_APPEAR_TIMER) || held)
		{
			g.MouseCursor = (border_n & 1) ? ImGuiMouseCursor_ResizeEW : ImGuiMouseCursor_ResizeNS;
			if (held)*border_held = border_n;
		}
		if (held)
		{
			ImVec2 border_target = window->Pos;
			ImVec2 border_posn;
			if (border_n == 0) { border_posn = ImVec2(0, 0); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y); }
			if (border_n == 1) { border_posn = ImVec2(1, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x + BORDER_SIZE); }
			if (border_n == 2) { border_posn = ImVec2(0, 1); border_target.y = (g.IO.MousePos.y - g.ActiveIdClickOffset.y + BORDER_SIZE); }
			if (border_n == 3) { border_posn = ImVec2(0, 0); border_target.x = (g.IO.MousePos.x - g.ActiveIdClickOffset.x); }
			CalcResizePosSizeFromAnyCorner(window, border_target, border_posn, &pos_target, &size_target);
		}
	}
	PopID();

	// Navigation resize (keyboard/gamepad)
	if (g.NavWindowingTarget == window)
	{
		ImVec2 nav_resize_delta;
		if (g.NavInputSource == ImGuiInputSource_NavKeyboard && g.IO.KeyShift)
			nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard, ImGuiInputReadMode_Down);
		if (g.NavInputSource == ImGuiInputSource_NavGamepad)
			nav_resize_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_Down);
		if (nav_resize_delta.x != 0.0f || nav_resize_delta.y != 0.0f)
		{
			const float NAV_RESIZE_SPEED = 600.0f;
			nav_resize_delta *= ImFloor(NAV_RESIZE_SPEED * g.IO.DeltaTime * ImMin(g.IO.DisplayFramebufferScale.x, g.IO.DisplayFramebufferScale.y));
			g.NavWindowingToggleLayer = false;
			g.NavDisableMouseHover = true;
			resize_grip_col[0] = GetColorU32(ImGuiCol_ResizeGripActive);
			// FIXME-NAV: Should store and accumulate into a separate size buffer to handle sizing constraints properly, right now a constraint will make us stuck.
			size_target = CalcSizeAfterConstraint(window, window->SizeFull + nav_resize_delta);
		}
	}

	// Apply back modified position/size to window
	if (size_target.x != FLT_MAX)
	{
		window->SizeFull = size_target;
		MarkIniSettingsDirty(window);
	}
	if (pos_target.x != FLT_MAX)
	{
		window->Pos = window->PosFloat = ImFloor(pos_target);
		MarkIniSettingsDirty(window);
	}

	window->Size = window->SizeFull;
}

// Push a new ImGui window to add widgets to.
// - A default window called "Debug" is automatically stacked at the beginning of every frame so you can use widgets without explicitly calling a Begin/End pair.
// - Begin/End can be called multiple times during the frame with the same window name to append content.
// - The window name is used as a unique identifier to preserve window information across frames (and save rudimentary information to the .ini file).
//   You can use the "##" or "###" markers to use the same label with different id, or same id with different label. See documentation at the top of this file.
// - Return false when window is collapsed, so you can early out in your code. You always need to call ImGui::End() even if false is returned.
// - Passing 'bool* p_open' displays a Close button on the upper-right corner of the window, the pointed value will be set to false when the button is pressed.
bool ImGui::Begin(const char* name, bool* p_open, ImGuiWindowFlags flags)
{
	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	IM_ASSERT(name != NULL);                        // Window name required
	IM_ASSERT(g.Initialized);                       // Forgot to call ImGui::NewFrame()
	IM_ASSERT(g.FrameCountEnded != g.FrameCount);   // Called ImGui::Render() or ImGui::EndFrame() and haven't called ImGui::NewFrame() again yet

													// Find or create
	ImGuiWindow* window = FindWindowByName(name);
	const bool window_just_created = (window == NULL);
	if (window_just_created)
	{
		ImVec2 size_on_first_use = (g.NextWindowData.SizeCond != 0) ? g.NextWindowData.SizeVal : ImVec2(0.0f, 0.0f); // Any condition flag will do since we are creating a new window here.
		window = CreateNewWindow(name, size_on_first_use, flags);
	}

	// Automatically disable manual moving/resizing when NoInputs is set
	if (flags & ImGuiWindowFlags_NoInputs)
		flags |= ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize;

	if (flags & ImGuiWindowFlags_NavFlattened)
		IM_ASSERT(flags & ImGuiWindowFlags_ChildWindow);

	const int current_frame = g.FrameCount;
	const bool first_begin_of_the_frame = (window->LastFrameActive != current_frame);
	if (first_begin_of_the_frame)
		window->Flags = (ImGuiWindowFlags)flags;
	else
		flags = window->Flags;

	// Update the Appearing flag
	bool window_just_activated_by_user = (window->LastFrameActive < current_frame - 1);   // Not using !WasActive because the implicit "Debug" window would always toggle off->on
	const bool window_just_appearing_after_hidden_for_resize = (window->HiddenFrames > 0);
	if (flags & ImGuiWindowFlags_Popup)
	{
		ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.CurrentPopupStack.Size];
		window_just_activated_by_user |= (window->PopupId != popup_ref.PopupId); // We recycle popups so treat window as activated if popup id changed
		window_just_activated_by_user |= (window != popup_ref.Window);
	}
	window->Appearing = (window_just_activated_by_user || window_just_appearing_after_hidden_for_resize);
	window->CloseButton = (p_open != NULL);
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, true);

	// Parent window is latched only on the first call to Begin() of the frame, so further append-calls can be done from a different window stack
	ImGuiWindow* parent_window_in_stack = g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back();
	ImGuiWindow* parent_window = first_begin_of_the_frame ? ((flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)) ? parent_window_in_stack : NULL) : window->ParentWindow;
	IM_ASSERT(parent_window != NULL || !(flags & ImGuiWindowFlags_ChildWindow));

	// Add to stack
	g.CurrentWindowStack.push_back(window);
	SetCurrentWindow(window);
	CheckStacksSize(window, true);
	if (flags & ImGuiWindowFlags_Popup)
	{
		ImGuiPopupRef& popup_ref = g.OpenPopupStack[g.CurrentPopupStack.Size];
		popup_ref.Window = window;
		g.CurrentPopupStack.push_back(popup_ref);
		window->PopupId = popup_ref.PopupId;
	}

	if (window_just_appearing_after_hidden_for_resize && !(flags & ImGuiWindowFlags_ChildWindow))
		window->NavLastIds[0] = 0;

	// Process SetNextWindow***() calls
	bool window_pos_set_by_api = false;
	bool window_size_x_set_by_api = false, window_size_y_set_by_api = false;
	if (g.NextWindowData.PosCond)
	{
		window_pos_set_by_api = (window->SetWindowPosAllowFlags & g.NextWindowData.PosCond) != 0;
		if (window_pos_set_by_api && ImLengthSqr(g.NextWindowData.PosPivotVal) > 0.00001f)
		{
			// May be processed on the next frame if this is our first frame and we are measuring size
			// FIXME: Look into removing the branch so everything can go through this same code path for consistency.
			window->SetWindowPosVal = g.NextWindowData.PosVal;
			window->SetWindowPosPivot = g.NextWindowData.PosPivotVal;
			window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
		}
		else
		{
			SetWindowPos(window, g.NextWindowData.PosVal, g.NextWindowData.PosCond);
		}
		g.NextWindowData.PosCond = 0;
	}
	if (g.NextWindowData.SizeCond)
	{
		window_size_x_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.x > 0.0f);
		window_size_y_set_by_api = (window->SetWindowSizeAllowFlags & g.NextWindowData.SizeCond) != 0 && (g.NextWindowData.SizeVal.y > 0.0f);
		SetWindowSize(window, g.NextWindowData.SizeVal, g.NextWindowData.SizeCond);
		g.NextWindowData.SizeCond = 0;
	}
	if (g.NextWindowData.ContentSizeCond)
	{
		// Adjust passed "client size" to become a "window size"
		window->SizeContentsExplicit = g.NextWindowData.ContentSizeVal;
		if (window->SizeContentsExplicit.y != 0.0f)
			window->SizeContentsExplicit.y += window->TitleBarHeight() + window->MenuBarHeight();
		g.NextWindowData.ContentSizeCond = 0;
	}
	else if (first_begin_of_the_frame)
	{
		window->SizeContentsExplicit = ImVec2(0.0f, 0.0f);
	}
	if (g.NextWindowData.CollapsedCond)
	{
		SetWindowCollapsed(window, g.NextWindowData.CollapsedVal, g.NextWindowData.CollapsedCond);
		g.NextWindowData.CollapsedCond = 0;
	}
	if (g.NextWindowData.FocusCond)
	{
		SetWindowFocus();
		g.NextWindowData.FocusCond = 0;
	}
	if (window->Appearing)
		SetWindowConditionAllowFlags(window, ImGuiCond_Appearing, false);

	// When reusing window again multiple times a frame, just append content (don't need to setup again)
	if (first_begin_of_the_frame)
	{
		const bool window_is_child_tooltip = (flags & ImGuiWindowFlags_ChildWindow) && (flags & ImGuiWindowFlags_Tooltip); // FIXME-WIP: Undocumented behavior of Child+Tooltip for pinned tooltip (#1345)

																														   // Initialize
		window->ParentWindow = parent_window;
		window->RootWindow = window->RootWindowForTitleBarHighlight = window->RootWindowForTabbing = window->RootWindowForNav = window;
		if (parent_window && (flags & ImGuiWindowFlags_ChildWindow) && !window_is_child_tooltip)
			window->RootWindow = parent_window->RootWindow;
		if (parent_window && !(flags & ImGuiWindowFlags_Modal) && (flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Popup)))
			window->RootWindowForTitleBarHighlight = window->RootWindowForTabbing = parent_window->RootWindowForTitleBarHighlight; // Same value in master branch, will differ for docking
		while (window->RootWindowForNav->Flags & ImGuiWindowFlags_NavFlattened)
			window->RootWindowForNav = window->RootWindowForNav->ParentWindow;

		window->Active = true;
		window->BeginOrderWithinParent = 0;
		window->BeginOrderWithinContext = g.WindowsActiveCount++;
		window->BeginCount = 0;
		window->ClipRect = ImVec4(-FLT_MAX, -FLT_MAX, +FLT_MAX, +FLT_MAX);
		window->LastFrameActive = current_frame;
		window->IDStack.resize(1);

		// Lock window rounding, border size and rounding so that altering the border sizes for children doesn't have side-effects.
		window->WindowRounding = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildRounding : ((flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupRounding : style.WindowRounding;
		window->WindowBorderSize = (flags & ImGuiWindowFlags_ChildWindow) ? style.ChildBorderSize : ((flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) && !(flags & ImGuiWindowFlags_Modal)) ? style.PopupBorderSize : style.WindowBorderSize;
		window->WindowPadding = style.WindowPadding;
		if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & (ImGuiWindowFlags_AlwaysUseWindowPadding | ImGuiWindowFlags_Popup)) && window->WindowBorderSize == 0.0f)
			window->WindowPadding = ImVec2(0.0f, (flags & ImGuiWindowFlags_MenuBar) ? style.WindowPadding.y : 0.0f);

		// Collapse window by double-clicking on title bar
		// At this point we don't have a clipping rectangle setup yet, so we can use the title bar area for hit detection and drawing
		if (!(flags & ImGuiWindowFlags_NoTitleBar) && !(flags & ImGuiWindowFlags_NoCollapse))
		{
			ImRect title_bar_rect = window->TitleBarRect();
			if (window->CollapseToggleWanted || (g.HoveredWindow == window && IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max) && g.IO.MouseDoubleClicked[0]))
			{
				window->Collapsed = !window->Collapsed;
				MarkIniSettingsDirty(window);
				FocusWindow(window);
			}
		}
		else
		{
			window->Collapsed = false;
		}
		window->CollapseToggleWanted = false;

		// SIZE

		// Update contents size from last frame for auto-fitting (unless explicitly specified)
		window->SizeContents = CalcSizeContents(window);

		// Hide popup/tooltip window when re-opening while we measure size (because we recycle the windows)
		if (window->HiddenFrames > 0)
			window->HiddenFrames--;
		if (window_just_activated_by_user && (flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_Tooltip)) != 0)
		{
			window->HiddenFrames = 1;
			if (flags & ImGuiWindowFlags_AlwaysAutoResize)
			{
				if (!window_size_x_set_by_api)
					window->Size.x = window->SizeFull.x = 0.f;
				if (!window_size_y_set_by_api)
					window->Size.y = window->SizeFull.y = 0.f;
				window->SizeContents = ImVec2(0.f, 0.f);
			}
		}

		// Hide new windows for one frame until they calculate their size
		if (window_just_created && (!window_size_x_set_by_api || !window_size_y_set_by_api))
			window->HiddenFrames = 1;

		// Calculate auto-fit size, handle automatic resize
		const ImVec2 size_auto_fit = CalcSizeAutoFit(window, window->SizeContents);
		ImVec2 size_full_modified(FLT_MAX, FLT_MAX);
		if ((flags & ImGuiWindowFlags_AlwaysAutoResize) && !window->Collapsed)
		{
			// Using SetNextWindowSize() overrides ImGuiWindowFlags_AlwaysAutoResize, so it can be used on tooltips/popups, etc.
			if (!window_size_x_set_by_api)
				window->SizeFull.x = size_full_modified.x = size_auto_fit.x;
			if (!window_size_y_set_by_api)
				window->SizeFull.y = size_full_modified.y = size_auto_fit.y;
		}
		else if (window->AutoFitFramesX > 0 || window->AutoFitFramesY > 0)
		{
			// Auto-fit may only grow window during the first few frames
			// We still process initial auto-fit on collapsed windows to get a window width, but otherwise don't honor ImGuiWindowFlags_AlwaysAutoResize when collapsed.
			if (!window_size_x_set_by_api && window->AutoFitFramesX > 0)
				window->SizeFull.x = size_full_modified.x = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.x, size_auto_fit.x) : size_auto_fit.x;
			if (!window_size_y_set_by_api && window->AutoFitFramesY > 0)
				window->SizeFull.y = size_full_modified.y = window->AutoFitOnlyGrows ? ImMax(window->SizeFull.y, size_auto_fit.y) : size_auto_fit.y;
			if (!window->Collapsed)
				MarkIniSettingsDirty(window);
		}

		// Apply minimum/maximum window size constraints and final size
		window->SizeFull = CalcSizeAfterConstraint(window, window->SizeFull);
		window->Size = window->Collapsed && !(flags & ImGuiWindowFlags_ChildWindow) ? window->TitleBarRect().GetSize() : window->SizeFull;

		// SCROLLBAR STATUS

		// Update scrollbar status (based on the Size that was effective during last frame or the auto-resized Size).
		if (!window->Collapsed)
		{
			// When reading the current size we need to read it after size constraints have been applied
			float size_x_for_scrollbars = size_full_modified.x != FLT_MAX ? window->SizeFull.x : window->SizeFullAtLastBegin.x;
			float size_y_for_scrollbars = size_full_modified.y != FLT_MAX ? window->SizeFull.y : window->SizeFullAtLastBegin.y;
			window->ScrollbarY = (flags & ImGuiWindowFlags_AlwaysVerticalScrollbar) || ((window->SizeContents.y > size_y_for_scrollbars) && !(flags & ImGuiWindowFlags_NoScrollbar));
			window->ScrollbarX = (flags & ImGuiWindowFlags_AlwaysHorizontalScrollbar) || ((window->SizeContents.x > size_x_for_scrollbars - (window->ScrollbarY ? style.ScrollbarSize : 0.0f)) && !(flags & ImGuiWindowFlags_NoScrollbar) && (flags & ImGuiWindowFlags_HorizontalScrollbar));
			if (window->ScrollbarX && !window->ScrollbarY)
				window->ScrollbarY = (window->SizeContents.y > size_y_for_scrollbars - style.ScrollbarSize) && !(flags & ImGuiWindowFlags_NoScrollbar);
			window->ScrollbarSizes = ImVec2(window->ScrollbarY ? style.ScrollbarSize : 0.0f, window->ScrollbarX ? style.ScrollbarSize : 0.0f);
		}

		// POSITION

		// Popup latch its initial position, will position itself when it appears next frame
		if (window_just_activated_by_user)
		{
			window->AutoPosLastDirection = ImGuiDir_None;
			if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api)
				window->Pos = window->PosFloat = g.CurrentPopupStack.back().OpenPopupPos;
		}

		// Position child window
		if (flags & ImGuiWindowFlags_ChildWindow)
		{
			window->BeginOrderWithinParent = parent_window->DC.ChildWindows.Size;
			parent_window->DC.ChildWindows.push_back(window);
			if (!(flags & ImGuiWindowFlags_Popup) && !window_pos_set_by_api && !window_is_child_tooltip)
				window->Pos = window->PosFloat = parent_window->DC.CursorPos;
		}

		const bool window_pos_with_pivot = (window->SetWindowPosVal.x != FLT_MAX && window->HiddenFrames == 0);
		if (window_pos_with_pivot)
		{
			// Position given a pivot (e.g. for centering)
			SetWindowPos(window, ImMax(style.DisplaySafeAreaPadding, window->SetWindowPosVal - window->SizeFull * window->SetWindowPosPivot), 0);
		}
		else if (flags & ImGuiWindowFlags_ChildMenu)
		{
			// Child menus typically request _any_ position within the parent menu item, and then our FindBestPopupWindowPos() function will move the new menu outside the parent bounds.
			// This is how we end up with child menus appearing (most-commonly) on the right of the parent menu.
			IM_ASSERT(window_pos_set_by_api);
			float horizontal_overlap = style.ItemSpacing.x; // We want some overlap to convey the relative depth of each popup (currently the amount of overlap it is hard-coded to style.ItemSpacing.x, may need to introduce another style value).
			ImGuiWindow* parent_menu = parent_window_in_stack;
			ImRect rect_to_avoid;
			if (parent_menu->DC.MenuBarAppending)
				rect_to_avoid = ImRect(-FLT_MAX, parent_menu->Pos.y + parent_menu->TitleBarHeight(), FLT_MAX, parent_menu->Pos.y + parent_menu->TitleBarHeight() + parent_menu->MenuBarHeight());
			else
				rect_to_avoid = ImRect(parent_menu->Pos.x + horizontal_overlap, -FLT_MAX, parent_menu->Pos.x + parent_menu->Size.x - horizontal_overlap - parent_menu->ScrollbarSizes.x, FLT_MAX);
			window->PosFloat = FindBestWindowPosForPopup(window->PosFloat, window->Size, &window->AutoPosLastDirection, rect_to_avoid);
		}
		else if ((flags & ImGuiWindowFlags_Popup) != 0 && !window_pos_set_by_api && window_just_appearing_after_hidden_for_resize)
		{
			ImRect rect_to_avoid(window->PosFloat.x - 1, window->PosFloat.y - 1, window->PosFloat.x + 1, window->PosFloat.y + 1);
			window->PosFloat = FindBestWindowPosForPopup(window->PosFloat, window->Size, &window->AutoPosLastDirection, rect_to_avoid);
		}

		// Position tooltip (always follows mouse)
		if ((flags & ImGuiWindowFlags_Tooltip) != 0 && !window_pos_set_by_api && !window_is_child_tooltip)
		{
			float sc = g.Style.MouseCursorScale;
			ImVec2 ref_pos = (!g.NavDisableHighlight && g.NavDisableMouseHover) ? NavCalcPreferredMousePos() : g.IO.MousePos;
			ImRect rect_to_avoid;
			if (!g.NavDisableHighlight && g.NavDisableMouseHover && !(g.IO.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos))
				rect_to_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 16, ref_pos.y + 8);
			else
				rect_to_avoid = ImRect(ref_pos.x - 16, ref_pos.y - 8, ref_pos.x + 24 * sc, ref_pos.y + 24 * sc); // FIXME: Hard-coded based on mouse cursor shape expectation. Exact dimension not very important.
			window->PosFloat = FindBestWindowPosForPopup(ref_pos, window->Size, &window->AutoPosLastDirection, rect_to_avoid);
			if (window->AutoPosLastDirection == ImGuiDir_None)
				window->PosFloat = ref_pos + ImVec2(2, 2); // If there's not enough room, for tooltip we prefer avoiding the cursor at all cost even if it means that part of the tooltip won't be visible.
		}

		// Clamp position so it stays visible
		if (!(flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Tooltip))
		{
			if (!window_pos_set_by_api && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0 && g.IO.DisplaySize.x > 0.0f && g.IO.DisplaySize.y > 0.0f) // Ignore zero-sized display explicitly to avoid losing positions if a window manager reports zero-sized window when initializing or minimizing.
			{
				ImVec2 padding = ImMax(style.DisplayWindowPadding, style.DisplaySafeAreaPadding);
				window->PosFloat = ImMax(window->PosFloat + window->Size, padding) - window->Size;
				window->PosFloat = ImMin(window->PosFloat, g.IO.DisplaySize - padding);
			}
		}
		window->Pos = ImFloor(window->PosFloat);

		// Default item width. Make it proportional to window size if window manually resizes
		if (window->Size.x > 0.0f && !(flags & ImGuiWindowFlags_Tooltip) && !(flags & ImGuiWindowFlags_AlwaysAutoResize))
			window->ItemWidthDefault = (float)(int)(window->Size.x * 0.65f);
		else
			window->ItemWidthDefault = (float)(int)(g.FontSize * 16.0f);

		// Prepare for focus requests
		window->FocusIdxAllRequestCurrent = (window->FocusIdxAllRequestNext == INT_MAX || window->FocusIdxAllCounter == -1) ? INT_MAX : (window->FocusIdxAllRequestNext + (window->FocusIdxAllCounter + 1)) % (window->FocusIdxAllCounter + 1);
		window->FocusIdxTabRequestCurrent = (window->FocusIdxTabRequestNext == INT_MAX || window->FocusIdxTabCounter == -1) ? INT_MAX : (window->FocusIdxTabRequestNext + (window->FocusIdxTabCounter + 1)) % (window->FocusIdxTabCounter + 1);
		window->FocusIdxAllCounter = window->FocusIdxTabCounter = -1;
		window->FocusIdxAllRequestNext = window->FocusIdxTabRequestNext = INT_MAX;

		// Apply scrolling
		window->Scroll = CalcNextScrollFromScrollTargetAndClamp(window);
		window->ScrollTarget = ImVec2(FLT_MAX, FLT_MAX);

		// Apply focus, new windows appears in front
		bool want_focus = false;
		if (window_just_activated_by_user && !(flags & ImGuiWindowFlags_NoFocusOnAppearing))
			if (!(flags & (ImGuiWindowFlags_ChildWindow | ImGuiWindowFlags_Tooltip)) || (flags & ImGuiWindowFlags_Popup))
				want_focus = true;

		// Handle manual resize: Resize Grips, Borders, Gamepad
		int border_held = -1;
		ImU32 resize_grip_col[4] = { 0 };
		const int resize_grip_count = (flags & ImGuiWindowFlags_ResizeFromAnySide) ? 2 : 1; // 4
		const float grip_draw_size = (float)(int)ImMax(g.FontSize * 1.35f, window->WindowRounding + 1.0f + g.FontSize * 0.2f);
		if (!window->Collapsed)
			UpdateManualResize(window, size_auto_fit, &border_held, resize_grip_count, &resize_grip_col[0]);

		// DRAWING

		// Setup draw list and outer clipping rectangle
		window->DrawList->Clear();
		window->DrawList->Flags = (g.Style.AntiAliasedLines ? ImDrawListFlags_AntiAliasedLines : 0) | (g.Style.AntiAliasedFill ? ImDrawListFlags_AntiAliasedFill : 0);
		window->DrawList->PushTextureID(g.Font->ContainerAtlas->TexID);
		ImRect viewport_rect(GetViewportRect());
		if ((flags & ImGuiWindowFlags_ChildWindow) && !(flags & ImGuiWindowFlags_Popup) && !window_is_child_tooltip)
			PushClipRect(parent_window->ClipRect.Min, parent_window->ClipRect.Max, true);
		else
			PushClipRect(viewport_rect.Min, viewport_rect.Max, true);

		// Draw modal window background (darkens what is behind them)
		if ((flags & ImGuiWindowFlags_Modal) != 0 && window == GetFrontMostModalRootWindow())
			window->DrawList->AddRectFilled(viewport_rect.Min, viewport_rect.Max, GetColorU32(ImGuiCol_ModalWindowDarkening, g.ModalWindowDarkeningRatio));

		// Draw navigation selection/windowing rectangle background
		if (g.NavWindowingTarget == window)
		{
			ImRect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (!bb.Contains(viewport_rect)) // Avoid drawing if the window covers all the viewport anyway
				window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha * 0.25f), g.Style.WindowRounding);
		}

		// Draw window + handle manual resize
		const float window_rounding = window->WindowRounding;
		const float window_border_size = window->WindowBorderSize;
		const bool title_bar_is_highlight = want_focus || (g.NavWindow && window->RootWindowForTitleBarHighlight == g.NavWindow->RootWindowForTitleBarHighlight);
		const ImRect title_bar_rect = window->TitleBarRect();
		if (window->Collapsed)
		{
			// Title bar only
			float backup_border_size = style.FrameBorderSize;
			g.Style.FrameBorderSize = window->WindowBorderSize;
			ImU32 title_bar_col = GetColorU32((title_bar_is_highlight && !g.NavDisableHighlight) ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBgCollapsed);
			RenderFrame(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, true, window_rounding);
			g.Style.FrameBorderSize = backup_border_size;
		}
		else
		{
			// Window background
			ImU32 bg_col = GetColorU32(GetWindowBgColorIdxFromFlags(flags));
			if (g.NextWindowData.BgAlphaCond != 0)
			{
				bg_col = (bg_col & ~IM_COL32_A_MASK) | (IM_F32_TO_INT8_SAT(g.NextWindowData.BgAlphaVal) << IM_COL32_A_SHIFT);
				g.NextWindowData.BgAlphaCond = 0;
			}
			window->DrawList->AddRectFilled(window->Pos + ImVec2(0, window->TitleBarHeight()), window->Pos + window->Size, bg_col, window_rounding, (flags & ImGuiWindowFlags_NoTitleBar) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Bot);

			// Title bar
			ImU32 title_bar_col = GetColorU32(window->Collapsed ? ImGuiCol_TitleBgCollapsed : title_bar_is_highlight ? ImGuiCol_TitleBgActive : ImGuiCol_TitleBg);
			if (!(flags & ImGuiWindowFlags_NoTitleBar))
				window->DrawList->AddRectFilled(title_bar_rect.Min, title_bar_rect.Max, title_bar_col, window_rounding, ImDrawCornerFlags_Top);

			// Menu bar
			if (flags & ImGuiWindowFlags_MenuBar)
			{
				ImRect menu_bar_rect = window->MenuBarRect();
				menu_bar_rect.ClipWith(window->Rect());  // Soft clipping, in particular child window don't have minimum size covering the menu bar so this is useful for them.
				window->DrawList->AddRectFilled(menu_bar_rect.Min, menu_bar_rect.Max, GetColorU32(ImGuiCol_MenuBarBg), (flags & ImGuiWindowFlags_NoTitleBar) ? window_rounding : 0.0f, ImDrawCornerFlags_Top);
				if (style.FrameBorderSize > 0.0f && menu_bar_rect.Max.y < window->Pos.y + window->Size.y)
					window->DrawList->AddLine(menu_bar_rect.GetBL(), menu_bar_rect.GetBR(), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
			}

			// Scrollbars
			if (window->ScrollbarX)
				Scrollbar(ImGuiLayoutType_Horizontal);
			if (window->ScrollbarY)
				Scrollbar(ImGuiLayoutType_Vertical);

			// Render resize grips (after their input handling so we don't have a frame of latency)
			if (!(flags & ImGuiWindowFlags_NoResize))
			{
				for (int resize_grip_n = 0; resize_grip_n < resize_grip_count; resize_grip_n++)
				{
					const ImGuiResizeGripDef& grip = resize_grip_def[resize_grip_n];
					const ImVec2 corner = ImLerp(window->Pos, window->Pos + window->Size, grip.CornerPos);
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(window_border_size, grip_draw_size) : ImVec2(grip_draw_size, window_border_size)));
					window->DrawList->PathLineTo(corner + grip.InnerDir * ((resize_grip_n & 1) ? ImVec2(grip_draw_size, window_border_size) : ImVec2(window_border_size, grip_draw_size)));
					window->DrawList->PathArcToFast(ImVec2(corner.x + grip.InnerDir.x * (window_rounding + window_border_size), corner.y + grip.InnerDir.y * (window_rounding + window_border_size)), window_rounding, grip.AngleMin12, grip.AngleMax12);
					window->DrawList->PathFillConvex(resize_grip_col[resize_grip_n]);
				}
			}

			// Borders
			if (window_border_size > 0.0f)
				window->DrawList->AddRect(window->Pos, window->Pos + window->Size, GetColorU32(ImGuiCol_Border), window_rounding, ImDrawCornerFlags_All, window_border_size);
			if (border_held != -1)
			{
				ImRect border = GetBorderRect(window, border_held, grip_draw_size, 0.0f);
				window->DrawList->AddLine(border.Min, border.Max, GetColorU32(ImGuiCol_SeparatorActive), ImMax(1.0f, window_border_size));
			}
			if (style.FrameBorderSize > 0 && !(flags & ImGuiWindowFlags_NoTitleBar))
				window->DrawList->AddLine(title_bar_rect.GetBL() + ImVec2(style.WindowBorderSize, -1), title_bar_rect.GetBR() + ImVec2(-style.WindowBorderSize, -1), GetColorU32(ImGuiCol_Border), style.FrameBorderSize);
		}

		// Draw navigation selection/windowing rectangle border
		if (g.NavWindowingTarget == window)
		{
			float rounding = ImMax(window->WindowRounding, g.Style.WindowRounding);
			ImRect bb = window->Rect();
			bb.Expand(g.FontSize);
			if (bb.Contains(viewport_rect)) // If a window fits the entire viewport, adjust its highlight inward
			{
				bb.Expand(-g.FontSize - 1.0f);
				rounding = window->WindowRounding;
			}
			window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_NavWindowingHighlight, g.NavWindowingHighlightAlpha), rounding, ~0, 3.0f);
		}

		// Store a backup of SizeFull which we will use next frame to decide if we need scrollbars.
		window->SizeFullAtLastBegin = window->SizeFull;

		// Update ContentsRegionMax. All the variable it depends on are set above in this function.
		window->ContentsRegionRect.Min.x = -window->Scroll.x + window->WindowPadding.x;
		window->ContentsRegionRect.Min.y = -window->Scroll.y + window->WindowPadding.y + window->TitleBarHeight() + window->MenuBarHeight();
		window->ContentsRegionRect.Max.x = -window->Scroll.x - window->WindowPadding.x + (window->SizeContentsExplicit.x != 0.0f ? window->SizeContentsExplicit.x : (window->Size.x - window->ScrollbarSizes.x));
		window->ContentsRegionRect.Max.y = -window->Scroll.y - window->WindowPadding.y + (window->SizeContentsExplicit.y != 0.0f ? window->SizeContentsExplicit.y : (window->Size.y - window->ScrollbarSizes.y));

		// Setup drawing context
		// (NB: That term "drawing context / DC" lost its meaning a long time ago. Initially was meant to hold transient data only. Nowadays difference between window-> and window->DC-> is dubious.)
		window->DC.IndentX = 0.0f + window->WindowPadding.x - window->Scroll.x;
		window->DC.GroupOffsetX = 0.0f;
		window->DC.ColumnsOffsetX = 0.0f;
		window->DC.CursorStartPos = window->Pos + ImVec2(window->DC.IndentX + window->DC.ColumnsOffsetX, window->TitleBarHeight() + window->MenuBarHeight() + window->WindowPadding.y - window->Scroll.y);
		window->DC.CursorPos = window->DC.CursorStartPos;
		window->DC.CursorPosPrevLine = window->DC.CursorPos;
		window->DC.CursorMaxPos = window->DC.CursorStartPos;
		window->DC.CurrentLineHeight = window->DC.PrevLineHeight = 0.0f;
		window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset = 0.0f;
		window->DC.NavHideHighlightOneFrame = false;
		window->DC.NavHasScroll = (GetScrollMaxY() > 0.0f);
		window->DC.NavLayerActiveMask = window->DC.NavLayerActiveMaskNext;
		window->DC.NavLayerActiveMaskNext = 0x00;
		window->DC.MenuBarAppending = false;
		window->DC.MenuBarOffsetX = ImMax(window->WindowPadding.x, style.ItemSpacing.x);
		window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;
		window->DC.ChildWindows.resize(0);
		window->DC.LayoutType = ImGuiLayoutType_Vertical;
		window->DC.ParentLayoutType = parent_window ? parent_window->DC.LayoutType : ImGuiLayoutType_Vertical;
		window->DC.ItemFlags = ImGuiItemFlags_Default_;
		window->DC.ItemWidth = window->ItemWidthDefault;
		window->DC.TextWrapPos = -1.0f; // disabled
		window->DC.ItemFlagsStack.resize(0);
		window->DC.ItemWidthStack.resize(0);
		window->DC.TextWrapPosStack.resize(0);
		window->DC.ColumnsSet = NULL;
		window->DC.TreeDepth = 0;
		window->DC.TreeDepthMayJumpToParentOnPop = 0x00;
		window->DC.StateStorage = &window->StateStorage;
		window->DC.GroupStack.resize(0);
		window->MenuColumns.Update(3, style.ItemSpacing.x, window_just_activated_by_user);

		if ((flags & ImGuiWindowFlags_ChildWindow) && (window->DC.ItemFlags != parent_window->DC.ItemFlags))
		{
			window->DC.ItemFlags = parent_window->DC.ItemFlags;
			window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
		}

		if (window->AutoFitFramesX > 0)
			window->AutoFitFramesX--;
		if (window->AutoFitFramesY > 0)
			window->AutoFitFramesY--;

		// Apply focus (we need to call FocusWindow() AFTER setting DC.CursorStartPos so our initial navigation reference rectangle can start around there)
		if (want_focus)
		{
			FocusWindow(window);
			NavInitWindow(window, false);
		}

		// Title bar
		if (!(flags & ImGuiWindowFlags_NoTitleBar))
		{
			// Close & collapse button are on layer 1 (same as menus) and don't default focus
			const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;
			window->DC.ItemFlags |= ImGuiItemFlags_NoNavDefaultFocus;
			window->DC.NavLayerCurrent++;
			window->DC.NavLayerCurrentMask <<= 1;

			// Collapse button
			if (!(flags & ImGuiWindowFlags_NoCollapse))
			{
				ImGuiID id = window->GetID("#COLLAPSE");
				ImRect bb(window->Pos + style.FramePadding + ImVec2(1, 1), window->Pos + style.FramePadding + ImVec2(g.FontSize, g.FontSize) - ImVec2(1, 1));
				ItemAdd(bb, id); // To allow navigation
				if (ButtonBehavior(bb, id, NULL, NULL))
					window->CollapseToggleWanted = true; // Defer collapsing to next frame as we are too far in the Begin() function
				RenderNavHighlight(bb, id);
				RenderArrow(window->Pos + style.FramePadding, window->Collapsed ? ImGuiDir_Right : ImGuiDir_Down, 1.0f);
			}

			// Close button
			if (p_open != NULL)
			{
				const float pad = style.FramePadding.y;
				const float rad = g.FontSize * 0.5f;
				if (CloseButton(window->GetID("#CLOSE"), window->Rect().GetTR() + ImVec2(-pad - rad, pad + rad), rad + 1))
					*p_open = false;
			}

			window->DC.NavLayerCurrent--;
			window->DC.NavLayerCurrentMask >>= 1;
			window->DC.ItemFlags = item_flags_backup;

			// Title text (FIXME: refactor text alignment facilities along with RenderText helpers)
			ImVec2 text_size = CalcTextSize(name, NULL, true);
			ImRect text_r = title_bar_rect;
			float pad_left = (flags & ImGuiWindowFlags_NoCollapse) == 0 ? (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x) : style.FramePadding.x;
			float pad_right = (p_open != NULL) ? (style.FramePadding.x + g.FontSize + style.ItemInnerSpacing.x) : style.FramePadding.x;
			if (style.WindowTitleAlign.x > 0.0f) pad_right = ImLerp(pad_right, pad_left, style.WindowTitleAlign.x);
			text_r.Min.x += pad_left;
			text_r.Max.x -= pad_right;
			ImRect clip_rect = text_r;
			clip_rect.Max.x = window->Pos.x + window->Size.x - (p_open ? title_bar_rect.GetHeight() - 3 : style.FramePadding.x); // Match the size of CloseButton()
			PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_TitleText));
			RenderTextClipped(text_r.Min, text_r.Max, name, NULL, &text_size, style.WindowTitleAlign, &clip_rect);
			PopStyleColor();
		}

		// Save clipped aabb so we can access it in constant-time in FindHoveredWindow()
		window->WindowRectClipped = window->Rect();
		window->WindowRectClipped.ClipWith(window->ClipRect);

		// Pressing CTRL+C while holding on a window copy its content to the clipboard
		// This works but 1. doesn't handle multiple Begin/End pairs, 2. recursing into another Begin/End pair - so we need to work that out and add better logging scope.
		// Maybe we can support CTRL+C on every element?
		/*
		if (g.ActiveId == move_id)
		if (g.IO.KeyCtrl && IsKeyPressedMap(ImGuiKey_C))
		ImGui::LogToClipboard();
		*/

		// Inner rectangle
		// We set this up after processing the resize grip so that our clip rectangle doesn't lag by a frame
		// Note that if our window is collapsed we will end up with a null clipping rectangle which is the correct behavior.
		window->InnerRect.Min.x = title_bar_rect.Min.x + window->WindowBorderSize;
		window->InnerRect.Min.y = title_bar_rect.Max.y + window->MenuBarHeight() + (((flags & ImGuiWindowFlags_MenuBar) || !(flags & ImGuiWindowFlags_NoTitleBar)) ? style.FrameBorderSize : window->WindowBorderSize);
		window->InnerRect.Max.x = window->Pos.x + window->Size.x - window->ScrollbarSizes.x - window->WindowBorderSize;
		window->InnerRect.Max.y = window->Pos.y + window->Size.y - window->ScrollbarSizes.y - window->WindowBorderSize;
		//window->DrawList->AddRect(window->InnerRect.Min, window->InnerRect.Max, IM_COL32_WHITE);

		// Inner clipping rectangle
		// Force round operator last to ensure that e.g. (int)(max.x-min.x) in user's render code produce correct result.
		window->InnerClipRect.Min.x = ImFloor(0.5f + window->InnerRect.Min.x + ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Min.y = ImFloor(0.5f + window->InnerRect.Min.y);
		window->InnerClipRect.Max.x = ImFloor(0.5f + window->InnerRect.Max.x - ImMax(0.0f, ImFloor(window->WindowPadding.x * 0.5f - window->WindowBorderSize)));
		window->InnerClipRect.Max.y = ImFloor(0.5f + window->InnerRect.Max.y);

		// After Begin() we fill the last item / hovered data using the title bar data. Make that a standard behavior (to allow usage of context menus on title bar only, etc.).
		window->DC.LastItemId = window->MoveId;
		window->DC.LastItemStatusFlags = IsMouseHoveringRect(title_bar_rect.Min, title_bar_rect.Max, false) ? ImGuiItemStatusFlags_HoveredRect : 0;
		window->DC.LastItemRect = title_bar_rect;
	}

	PushClipRect(window->InnerClipRect.Min, window->InnerClipRect.Max, true);

	// Clear 'accessed' flag last thing (After PushClipRect which will set the flag. We want the flag to stay false when the default "Debug" window is unused)
	if (first_begin_of_the_frame)
		window->WriteAccessed = false;

	window->BeginCount++;
	g.NextWindowData.SizeConstraintCond = 0;

	// Child window can be out of sight and have "negative" clip windows.
	// Mark them as collapsed so commands are skipped earlier (we can't manually collapse because they have no title bar).
	if (flags & ImGuiWindowFlags_ChildWindow)
	{
		IM_ASSERT((flags & ImGuiWindowFlags_NoTitleBar) != 0);
		window->Collapsed = parent_window && parent_window->Collapsed;

		if (!(flags & ImGuiWindowFlags_AlwaysAutoResize) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0)
			window->Collapsed |= (window->WindowRectClipped.Min.x >= window->WindowRectClipped.Max.x || window->WindowRectClipped.Min.y >= window->WindowRectClipped.Max.y);

		// We also hide the window from rendering because we've already added its border to the command list.
		// (we could perform the check earlier in the function but it is simpler at this point)
		if (window->Collapsed)
			window->Active = false;
	}
	if (style.Alpha <= 0.0f)
		window->Active = false;

	// Return false if we don't intend to display anything to allow user to perform an early out optimization
	window->SkipItems = (window->Collapsed || !window->Active) && window->AutoFitFramesX <= 0 && window->AutoFitFramesY <= 0;
	return !window->SkipItems;
}

// Old Begin() API with 5 parameters, avoid calling this version directly! Use SetNextWindowSize()/SetNextWindowBgAlpha() + Begin() instead.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
bool ImGui::Begin(const char* name, bool* p_open, const ImVec2& size_first_use, float bg_alpha_override, ImGuiWindowFlags flags)
{
	// Old API feature: we could pass the initial window size as a parameter. This was misleading because it only had an effect if the window didn't have data in the .ini file.
	if (size_first_use.x != 0.0f || size_first_use.y != 0.0f)
		ImGui::SetNextWindowSize(size_first_use, ImGuiCond_FirstUseEver);

	// Old API feature: override the window background alpha with a parameter.
	if (bg_alpha_override >= 0.0f)
		ImGui::SetNextWindowBgAlpha(bg_alpha_override);

	return ImGui::Begin(name, p_open, flags);
}
#endif // IMGUI_DISABLE_OBSOLETE_FUNCTIONS

void ImGui::End()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	if (window->DC.ColumnsSet != NULL)
		EndColumns();
	PopClipRect();   // Inner window clip rectangle

					 // Stop logging
	if (!(window->Flags & ImGuiWindowFlags_ChildWindow))    // FIXME: add more options for scope of logging
		LogFinish();

	// Pop from window stack
	g.CurrentWindowStack.pop_back();
	if (window->Flags & ImGuiWindowFlags_Popup)
		g.CurrentPopupStack.pop_back();
	CheckStacksSize(window, false);
	SetCurrentWindow(g.CurrentWindowStack.empty() ? NULL : g.CurrentWindowStack.back());
}

// Vertical scrollbar
// The entire piece of code below is rather confusing because:
// - We handle absolute seeking (when first clicking outside the grab) and relative manipulation (afterward or when clicking inside the grab)
// - We store values as normalized ratio and in a form that allows the window content to change while we are holding on a scrollbar
// - We handle both horizontal and vertical scrollbars, which makes the terminology not ideal.
void ImGui::Scrollbar(ImGuiLayoutType direction)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	const bool horizontal = (direction == ImGuiLayoutType_Horizontal);
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(horizontal ? "#SCROLLX" : "#SCROLLY");

	// Render background
	bool other_scrollbar = (horizontal ? window->ScrollbarY : window->ScrollbarX);
	float other_scrollbar_size_w = other_scrollbar ? style.ScrollbarSize : 0.0f;
	const ImRect window_rect = window->Rect();
	const float border_size = window->WindowBorderSize;
	ImRect bb = horizontal
		? ImRect(window->Pos.x + border_size, window_rect.Max.y - style.ScrollbarSize, window_rect.Max.x - other_scrollbar_size_w - border_size, window_rect.Max.y - border_size)
		: ImRect(window_rect.Max.x - style.ScrollbarSize, window->Pos.y + border_size, window_rect.Max.x - border_size, window_rect.Max.y - other_scrollbar_size_w - border_size);
	if (!horizontal)
		bb.Min.y += window->TitleBarHeight() + ((window->Flags & ImGuiWindowFlags_MenuBar) ? window->MenuBarHeight() : 0.0f);
	if (bb.GetWidth() <= 0.0f || bb.GetHeight() <= 0.0f)
		return;

	int window_rounding_corners;
	if (horizontal)
		window_rounding_corners = ImDrawCornerFlags_BotLeft | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);
	else
		window_rounding_corners = (((window->Flags & ImGuiWindowFlags_NoTitleBar) && !(window->Flags & ImGuiWindowFlags_MenuBar)) ? ImDrawCornerFlags_TopRight : 0) | (other_scrollbar ? 0 : ImDrawCornerFlags_BotRight);
	window->DrawList->AddRectFilled(bb.Min, bb.Max, GetColorU32(ImGuiCol_ScrollbarBg), window->WindowRounding, window_rounding_corners);
	bb.Expand(ImVec2(-ImClamp((float)(int)((bb.Max.x - bb.Min.x - 2.0f) * 0.5f), 0.0f, 3.0f), -ImClamp((float)(int)((bb.Max.y - bb.Min.y - 2.0f) * 0.5f), 0.0f, 3.0f)));

	// V denote the main, longer axis of the scrollbar (= height for a vertical scrollbar)
	float scrollbar_size_v = horizontal ? bb.GetWidth() : bb.GetHeight();
	float scroll_v = horizontal ? window->Scroll.x : window->Scroll.y;
	float win_size_avail_v = (horizontal ? window->SizeFull.x : window->SizeFull.y) - other_scrollbar_size_w;
	float win_size_contents_v = horizontal ? window->SizeContents.x : window->SizeContents.y;

	// Calculate the height of our grabbable box. It generally represent the amount visible (vs the total scrollable amount)
	// But we maintain a minimum size in pixel to allow for the user to still aim inside.
	IM_ASSERT(ImMax(win_size_contents_v, win_size_avail_v) > 0.0f); // Adding this assert to check if the ImMax(XXX,1.0f) is still needed. PLEASE CONTACT ME if this triggers.
	const float win_size_v = ImMax(ImMax(win_size_contents_v, win_size_avail_v), 1.0f);
	const float grab_h_pixels = ImClamp(scrollbar_size_v * (win_size_avail_v / win_size_v), style.GrabMinSize, scrollbar_size_v);
	const float grab_h_norm = grab_h_pixels / scrollbar_size_v;

	// Handle input right away. None of the code of Begin() is relying on scrolling position before calling Scrollbar().
	bool held = false;
	bool hovered = false;
	const bool previously_held = (g.ActiveId == id);
	ButtonBehavior(bb, id, &hovered, &held, ImGuiButtonFlags_NoNavFocus);

	float scroll_max = ImMax(1.0f, win_size_contents_v - win_size_avail_v);
	float scroll_ratio = ImSaturate(scroll_v / scroll_max);
	float grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;
	if (held && grab_h_norm < 1.0f)
	{
		float scrollbar_pos_v = horizontal ? bb.Min.x : bb.Min.y;
		float mouse_pos_v = horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;
		float* click_delta_to_grab_center_v = horizontal ? &g.ScrollbarClickDeltaToGrabCenter.x : &g.ScrollbarClickDeltaToGrabCenter.y;

		// Click position in scrollbar normalized space (0.0f->1.0f)
		const float clicked_v_norm = ImSaturate((mouse_pos_v - scrollbar_pos_v) / scrollbar_size_v);
		SetHoveredID(id);

		bool seek_absolute = false;
		if (!previously_held)
		{
			// On initial click calculate the distance between mouse and the center of the grab
			if (clicked_v_norm >= grab_v_norm && clicked_v_norm <= grab_v_norm + grab_h_norm)
			{
				*click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
			}
			else
			{
				seek_absolute = true;
				*click_delta_to_grab_center_v = 0.0f;
			}
		}

		// Apply scroll
		// It is ok to modify Scroll here because we are being called in Begin() after the calculation of SizeContents and before setting up our starting position
		const float scroll_v_norm = ImSaturate((clicked_v_norm - *click_delta_to_grab_center_v - grab_h_norm * 0.5f) / (1.0f - grab_h_norm));
		scroll_v = (float)(int)(0.5f + scroll_v_norm * scroll_max);//(win_size_contents_v - win_size_v));
		if (horizontal)
			window->Scroll.x = scroll_v;
		else
			window->Scroll.y = scroll_v;

		// Update values for rendering
		scroll_ratio = ImSaturate(scroll_v / scroll_max);
		grab_v_norm = scroll_ratio * (scrollbar_size_v - grab_h_pixels) / scrollbar_size_v;

		// Update distance to grab now that we have seeked and saturated
		if (seek_absolute)
			*click_delta_to_grab_center_v = clicked_v_norm - grab_v_norm - grab_h_norm * 0.5f;
	}

	// Render
	const ImU32 grab_col = GetColorU32(held ? ImGuiCol_ScrollbarGrabActive : hovered ? ImGuiCol_ScrollbarGrabHovered : ImGuiCol_ScrollbarGrab);
	ImRect grab_rect;
	if (horizontal)
		grab_rect = ImRect(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm), bb.Min.y, ImMin(ImLerp(bb.Min.x, bb.Max.x, grab_v_norm) + grab_h_pixels, window_rect.Max.x), bb.Max.y);
	else
		grab_rect = ImRect(bb.Min.x, ImLerp(bb.Min.y, bb.Max.y, grab_v_norm), bb.Max.x, ImMin(ImLerp(bb.Min.y, bb.Max.y, grab_v_norm) + grab_h_pixels, window_rect.Max.y));
	window->DrawList->AddRectFilled(grab_rect.Min, grab_rect.Max, grab_col, style.ScrollbarRounding);
}

void ImGui::BringWindowToFront(ImGuiWindow* window)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* current_front_window = g.Windows.back();
	if (current_front_window == window || current_front_window->RootWindow == window)
		return;
	for (int i = g.Windows.Size - 2; i >= 0; i--) // We can ignore the front most window
		if (g.Windows[i] == window)
		{
			g.Windows.erase(g.Windows.Data + i);
			g.Windows.push_back(window);
			break;
		}
}

void ImGui::BringWindowToBack(ImGuiWindow* window)
{
	ImGuiContext& g = *GImGui;
	if (g.Windows[0] == window)
		return;
	for (int i = 0; i < g.Windows.Size; i++)
		if (g.Windows[i] == window)
		{
			memmove(&g.Windows[1], &g.Windows[0], (size_t)i * sizeof(ImGuiWindow*));
			g.Windows[0] = window;
			break;
		}
}

// Moving window to front of display and set focus (which happens to be back of our sorted list)
void ImGui::FocusWindow(ImGuiWindow* window)
{
	ImGuiContext& g = *GImGui;

	if (g.NavWindow != window)
	{
		g.NavWindow = window;
		if (window && g.NavDisableMouseHover)
			g.NavMousePosDirty = true;
		g.NavInitRequest = false;
		g.NavId = window ? window->NavLastIds[0] : 0; // Restore NavId
		g.NavIdIsAlive = false;
		g.NavLayer = 0;
		//printf("[%05d] FocusWindow(\"%s\")\n", g.FrameCount, window ? window->Name : NULL);
	}

	// Passing NULL allow to disable keyboard focus
	if (!window)
		return;

	// Move the root window to the top of the pile
	if (window->RootWindow)
		window = window->RootWindow;

	// Steal focus on active widgets
	if (window->Flags & ImGuiWindowFlags_Popup) // FIXME: This statement should be unnecessary. Need further testing before removing it..
		if (g.ActiveId != 0 && g.ActiveIdWindow && g.ActiveIdWindow->RootWindow != window)
			ClearActiveID();

	// Bring to front
	if (!(window->Flags & ImGuiWindowFlags_NoBringToFrontOnFocus))
		BringWindowToFront(window);
}

void ImGui::FocusFrontMostActiveWindow(ImGuiWindow* ignore_window)
{
	ImGuiContext& g = *GImGui;
	for (int i = g.Windows.Size - 1; i >= 0; i--)
		if (g.Windows[i] != ignore_window && g.Windows[i]->WasActive && !(g.Windows[i]->Flags & ImGuiWindowFlags_ChildWindow))
		{
			ImGuiWindow* focus_window = NavRestoreLastChildNavWindow(g.Windows[i]);
			FocusWindow(focus_window);
			return;
		}
}

void ImGui::PushItemWidth(float item_width)
{
	ImGuiWindow* window = GetCurrentWindow();
	window->DC.ItemWidth = (item_width == 0.0f ? window->ItemWidthDefault : item_width);
	window->DC.ItemWidthStack.push_back(window->DC.ItemWidth);
}

void ImGui::PushMultiItemsWidths(int components, float w_full)
{
	ImGuiWindow* window = GetCurrentWindow();
	const ImGuiStyle& style = GImGui->Style;
	if (w_full <= 0.0f)
		w_full = CalcItemWidth();
	const float w_item_one = ImMax(1.0f, (float)(int)((w_full - (style.ItemInnerSpacing.x) * (components - 1)) / (float)components));
	const float w_item_last = ImMax(1.0f, (float)(int)(w_full - (w_item_one + style.ItemInnerSpacing.x) * (components - 1)));
	window->DC.ItemWidthStack.push_back(w_item_last);
	for (int i = 0; i < components - 1; i++)
		window->DC.ItemWidthStack.push_back(w_item_one);
	window->DC.ItemWidth = window->DC.ItemWidthStack.back();
}

void ImGui::PopItemWidth()
{
	ImGuiWindow* window = GetCurrentWindow();
	window->DC.ItemWidthStack.pop_back();
	window->DC.ItemWidth = window->DC.ItemWidthStack.empty() ? window->ItemWidthDefault : window->DC.ItemWidthStack.back();
}

float ImGui::CalcItemWidth()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	float w = window->DC.ItemWidth;
	if (w < 0.0f)
	{
		// Align to a right-side limit. We include 1 frame padding in the calculation because this is how the width is always used (we add 2 frame padding to it), but we could move that responsibility to the widget as well.
		float width_to_right_edge = GetContentRegionAvail().x;
		w = ImMax(1.0f, width_to_right_edge + w);
	}
	w = (float)(int)w;
	return w;
}

static ImFont* GetDefaultFont()
{
	ImGuiContext& g = *GImGui;
	return g.IO.FontDefault ? g.IO.FontDefault : g.IO.Fonts->Fonts[0];
}

void ImGui::SetCurrentFont(ImFont* font)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(font && font->IsLoaded());    // Font Atlas not created. Did you call io.Fonts->GetTexDataAsRGBA32 / GetTexDataAsAlpha8 ?
	IM_ASSERT(font->Scale > 0.0f);
	g.Font = font;
	g.FontBaseSize = g.IO.FontGlobalScale * g.Font->FontSize * g.Font->Scale;
	g.FontSize = g.CurrentWindow ? g.CurrentWindow->CalcFontSize() : 0.0f;

	ImFontAtlas* atlas = g.Font->ContainerAtlas;
	g.DrawListSharedData.TexUvWhitePixel = atlas->TexUvWhitePixel;
	g.DrawListSharedData.Font = g.Font;
	g.DrawListSharedData.FontSize = g.FontSize;
}

void ImGui::PushFont(ImFont* font)
{
	ImGuiContext& g = *GImGui;
	if (!font)
		font = GetDefaultFont();
	SetCurrentFont(font);
	g.FontStack.push_back(font);
	g.CurrentWindow->DrawList->PushTextureID(font->ContainerAtlas->TexID);
}

void  ImGui::PopFont()
{
	ImGuiContext& g = *GImGui;
	g.CurrentWindow->DrawList->PopTextureID();
	g.FontStack.pop_back();
	SetCurrentFont(g.FontStack.empty() ? GetDefaultFont() : g.FontStack.back());
}

void ImGui::PushItemFlag(ImGuiItemFlags option, bool enabled)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (enabled)
		window->DC.ItemFlags |= option;
	else
		window->DC.ItemFlags &= ~option;
	window->DC.ItemFlagsStack.push_back(window->DC.ItemFlags);
}

void ImGui::PopItemFlag()
{
	ImGuiWindow* window = GetCurrentWindow();
	window->DC.ItemFlagsStack.pop_back();
	window->DC.ItemFlags = window->DC.ItemFlagsStack.empty() ? ImGuiItemFlags_Default_ : window->DC.ItemFlagsStack.back();
}

void ImGui::PushAllowKeyboardFocus(bool allow_keyboard_focus)
{
	PushItemFlag(ImGuiItemFlags_AllowKeyboardFocus, allow_keyboard_focus);
}

void ImGui::PopAllowKeyboardFocus()
{
	PopItemFlag();
}

void ImGui::PushButtonRepeat(bool repeat)
{
	PushItemFlag(ImGuiItemFlags_ButtonRepeat, repeat);
}

void ImGui::PopButtonRepeat()
{
	PopItemFlag();
}

void ImGui::PushTextWrapPos(float wrap_pos_x)
{
	ImGuiWindow* window = GetCurrentWindow();
	window->DC.TextWrapPos = wrap_pos_x;
	window->DC.TextWrapPosStack.push_back(wrap_pos_x);
}

void ImGui::PopTextWrapPos()
{
	ImGuiWindow* window = GetCurrentWindow();
	window->DC.TextWrapPosStack.pop_back();
	window->DC.TextWrapPos = window->DC.TextWrapPosStack.empty() ? -1.0f : window->DC.TextWrapPosStack.back();
}

// FIXME: This may incur a round-trip (if the end user got their data from a float4) but eventually we aim to store the in-flight colors as ImU32
void ImGui::PushStyleColor(ImGuiCol idx, ImU32 col)
{
	ImGuiContext& g = *GImGui;
	ImGuiColMod backup;
	backup.Col = idx;
	backup.BackupValue = g.Style.Colors[idx];
	g.ColorModifiers.push_back(backup);
	g.Style.Colors[idx] = ColorConvertU32ToFloat4(col);
}

void ImGui::PushStyleColor(ImGuiCol idx, const ImVec4& col)
{
	ImGuiContext& g = *GImGui;
	ImGuiColMod backup;
	backup.Col = idx;
	backup.BackupValue = g.Style.Colors[idx];
	g.ColorModifiers.push_back(backup);
	g.Style.Colors[idx] = col;
}

void ImGui::PopStyleColor(int count)
{
	ImGuiContext& g = *GImGui;
	while (count > 0)
	{
		ImGuiColMod& backup = g.ColorModifiers.back();
		g.Style.Colors[backup.Col] = backup.BackupValue;
		g.ColorModifiers.pop_back();
		count--;
	}
}

struct ImGuiStyleVarInfo
{
	ImGuiDataType   Type;
	ImU32           Count;
	ImU32           Offset;
	void* GetVarPtr(ImGuiStyle* style) const { return (void*)((unsigned char*)style + Offset); }
};

static const ImGuiStyleVarInfo GStyleVarInfo[] =
{
	{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, Alpha) },              // ImGuiStyleVar_Alpha
{ ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowPadding) },      // ImGuiStyleVar_WindowPadding
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowRounding) },     // ImGuiStyleVar_WindowRounding
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowBorderSize) },   // ImGuiStyleVar_WindowBorderSize
{ ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowMinSize) },      // ImGuiStyleVar_WindowMinSize
{ ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, WindowTitleAlign) },   // ImGuiStyleVar_WindowTitleAlign
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildRounding) },      // ImGuiStyleVar_ChildRounding
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ChildBorderSize) },    // ImGuiStyleVar_ChildBorderSize
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupRounding) },      // ImGuiStyleVar_PopupRounding
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, PopupBorderSize) },    // ImGuiStyleVar_PopupBorderSize
{ ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, FramePadding) },       // ImGuiStyleVar_FramePadding
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameRounding) },      // ImGuiStyleVar_FrameRounding
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, FrameBorderSize) },    // ImGuiStyleVar_FrameBorderSize
{ ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemSpacing) },        // ImGuiStyleVar_ItemSpacing
{ ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ItemInnerSpacing) },   // ImGuiStyleVar_ItemInnerSpacing
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, IndentSpacing) },      // ImGuiStyleVar_IndentSpacing
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarSize) },      // ImGuiStyleVar_ScrollbarSize
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, ScrollbarRounding) },  // ImGuiStyleVar_ScrollbarRounding
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabMinSize) },        // ImGuiStyleVar_GrabMinSize
{ ImGuiDataType_Float, 1, (ImU32)IM_OFFSETOF(ImGuiStyle, GrabRounding) },       // ImGuiStyleVar_GrabRounding
{ ImGuiDataType_Float, 2, (ImU32)IM_OFFSETOF(ImGuiStyle, ButtonTextAlign) },    // ImGuiStyleVar_ButtonTextAlign
};

static const ImGuiStyleVarInfo* GetStyleVarInfo(ImGuiStyleVar idx)
{
	IM_ASSERT(idx >= 0 && idx < ImGuiStyleVar_COUNT);
	IM_ASSERT(IM_ARRAYSIZE(GStyleVarInfo) == ImGuiStyleVar_COUNT);
	return &GStyleVarInfo[idx];
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, float val)
{
	const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
	if (var_info->Type == ImGuiDataType_Float && var_info->Count == 1)
	{
		ImGuiContext& g = *GImGui;
		float* pvar = (float*)var_info->GetVarPtr(&g.Style);
		g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));
		*pvar = val;
		return;
	}
	IM_ASSERT(0); // Called function with wrong-type? Variable is not a float.
}

void ImGui::PushStyleVar(ImGuiStyleVar idx, const ImVec2& val)
{
	const ImGuiStyleVarInfo* var_info = GetStyleVarInfo(idx);
	if (var_info->Type == ImGuiDataType_Float && var_info->Count == 2)
	{
		ImGuiContext& g = *GImGui;
		ImVec2* pvar = (ImVec2*)var_info->GetVarPtr(&g.Style);
		g.StyleModifiers.push_back(ImGuiStyleMod(idx, *pvar));
		*pvar = val;
		return;
	}
	IM_ASSERT(0); // Called function with wrong-type? Variable is not a ImVec2.
}

void ImGui::PopStyleVar(int count)
{
	ImGuiContext& g = *GImGui;
	while (count > 0)
	{
		// We avoid a generic memcpy(data, &backup.Backup.., GDataTypeSize[info->Type] * info->Count), the overhead in Debug is not worth it.
		ImGuiStyleMod& backup = g.StyleModifiers.back();
		const ImGuiStyleVarInfo* info = GetStyleVarInfo(backup.VarIdx);
		void* data = info->GetVarPtr(&g.Style);
		if (info->Type == ImGuiDataType_Float && info->Count == 1) { ((float*)data)[0] = backup.BackupFloat[0]; }
		else if (info->Type == ImGuiDataType_Float && info->Count == 2) { ((float*)data)[0] = backup.BackupFloat[0]; ((float*)data)[1] = backup.BackupFloat[1]; }
		g.StyleModifiers.pop_back();
		count--;
	}
}

const char* ImGui::GetStyleColorName(ImGuiCol idx)
{
	// Create switch-case from enum with regexp: ImGuiCol_{.*}, --> case ImGuiCol_\1: return "\1";
	switch (idx)
	{
	case ImGuiCol_Text: return "Text";
	case ImGuiCol_TextDisabled: return "TextDisabled";
	case ImGuiCol_WindowBg: return "WindowBg";
	case ImGuiCol_ChildBg: return "ChildBg";
	case ImGuiCol_PopupBg: return "PopupBg";
	case ImGuiCol_Border: return "Border";
	case ImGuiCol_BorderShadow: return "BorderShadow";
	case ImGuiCol_FrameBg: return "FrameBg";
	case ImGuiCol_FrameBgHovered: return "FrameBgHovered";
	case ImGuiCol_FrameBgActive: return "FrameBgActive";
	case ImGuiCol_TitleBg: return "TitleBg";
	case ImGuiCol_TitleBgActive: return "TitleBgActive";
	case ImGuiCol_TitleBgCollapsed: return "TitleBgCollapsed";
	case ImGuiCol_MenuBarBg: return "MenuBarBg";
	case ImGuiCol_ScrollbarBg: return "ScrollbarBg";
	case ImGuiCol_ScrollbarGrab: return "ScrollbarGrab";
	case ImGuiCol_ScrollbarGrabHovered: return "ScrollbarGrabHovered";
	case ImGuiCol_ScrollbarGrabActive: return "ScrollbarGrabActive";
	case ImGuiCol_CheckMark: return "CheckMark";
	case ImGuiCol_SliderGrab: return "SliderGrab";
	case ImGuiCol_SliderGrabActive: return "SliderGrabActive";
	case ImGuiCol_Button: return "Button";
	case ImGuiCol_ButtonHovered: return "ButtonHovered";
	case ImGuiCol_ButtonActive: return "ButtonActive";
	case ImGuiCol_Header: return "Header";
	case ImGuiCol_HeaderHovered: return "HeaderHovered";
	case ImGuiCol_HeaderActive: return "HeaderActive";
	case ImGuiCol_Separator: return "Separator";
	case ImGuiCol_SeparatorHovered: return "SeparatorHovered";
	case ImGuiCol_SeparatorActive: return "SeparatorActive";
	case ImGuiCol_ResizeGrip: return "ResizeGrip";
	case ImGuiCol_ResizeGripHovered: return "ResizeGripHovered";
	case ImGuiCol_ResizeGripActive: return "ResizeGripActive";
	case ImGuiCol_PlotLines: return "PlotLines";
	case ImGuiCol_PlotLinesHovered: return "PlotLinesHovered";
	case ImGuiCol_PlotHistogram: return "PlotHistogram";
	case ImGuiCol_PlotHistogramHovered: return "PlotHistogramHovered";
	case ImGuiCol_TextSelectedBg: return "TextSelectedBg";
	case ImGuiCol_ModalWindowDarkening: return "ModalWindowDarkening";
	case ImGuiCol_DragDropTarget: return "DragDropTarget";
	case ImGuiCol_NavHighlight: return "NavHighlight";
	case ImGuiCol_NavWindowingHighlight: return "NavWindowingHighlight";
	}
	IM_ASSERT(0);
	return "Unknown";
}

bool ImGui::IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent)
{
	if (window->RootWindow == potential_parent)
		return true;
	while (window != NULL)
	{
		if (window == potential_parent)
			return true;
		window = window->ParentWindow;
	}
	return false;
}

bool ImGui::IsWindowHovered(ImGuiHoveredFlags flags)
{
	IM_ASSERT((flags & ImGuiHoveredFlags_AllowWhenOverlapped) == 0);   // Flags not supported by this function
	ImGuiContext& g = *GImGui;

	if (flags & ImGuiHoveredFlags_AnyWindow)
	{
		if (g.HoveredWindow == NULL)
			return false;
	}
	else
	{
		switch (flags & (ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows))
		{
		case ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows:
			if (g.HoveredRootWindow != g.CurrentWindow->RootWindow)
				return false;
			break;
		case ImGuiHoveredFlags_RootWindow:
			if (g.HoveredWindow != g.CurrentWindow->RootWindow)
				return false;
			break;
		case ImGuiHoveredFlags_ChildWindows:
			if (g.HoveredWindow == NULL || !IsWindowChildOf(g.HoveredWindow, g.CurrentWindow))
				return false;
			break;
		default:
			if (g.HoveredWindow != g.CurrentWindow)
				return false;
			break;
		}
	}

	if (!IsWindowContentHoverable(g.HoveredRootWindow, flags))
		return false;
	if (!(flags & ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
		if (g.ActiveId != 0 && !g.ActiveIdAllowOverlap && g.ActiveId != g.HoveredWindow->MoveId)
			return false;
	return true;
}

bool ImGui::IsWindowFocused(ImGuiFocusedFlags flags)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(g.CurrentWindow);     // Not inside a Begin()/End()

	if (flags & ImGuiFocusedFlags_AnyWindow)
		return g.NavWindow != NULL;

	switch (flags & (ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows))
	{
	case ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows:
		return g.NavWindow && g.NavWindow->RootWindow == g.CurrentWindow->RootWindow;
	case ImGuiFocusedFlags_RootWindow:
		return g.NavWindow == g.CurrentWindow->RootWindow;
	case ImGuiFocusedFlags_ChildWindows:
		return g.NavWindow && IsWindowChildOf(g.NavWindow, g.CurrentWindow);
	default:
		return g.NavWindow == g.CurrentWindow;
	}
}

// Can we focus this window with CTRL+TAB (or PadMenu + PadFocusPrev/PadFocusNext)
bool ImGui::IsWindowNavFocusable(ImGuiWindow* window)
{
	ImGuiContext& g = *GImGui;
	return window->Active && window == window->RootWindowForTabbing && (!(window->Flags & ImGuiWindowFlags_NoNavFocus) || window == g.NavWindow);
}

float ImGui::GetWindowWidth()
{
	ImGuiWindow* window = GImGui->CurrentWindow;
	return window->Size.x;
}

float ImGui::GetWindowHeight()
{
	ImGuiWindow* window = GImGui->CurrentWindow;
	return window->Size.y;
}

ImVec2 ImGui::GetWindowPos()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	return window->Pos;
}

static void SetWindowScrollX(ImGuiWindow* window, float new_scroll_x)
{
	window->DC.CursorMaxPos.x += window->Scroll.x; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.
	window->Scroll.x = new_scroll_x;
	window->DC.CursorMaxPos.x -= window->Scroll.x;
}

static void SetWindowScrollY(ImGuiWindow* window, float new_scroll_y)
{
	window->DC.CursorMaxPos.y += window->Scroll.y; // SizeContents is generally computed based on CursorMaxPos which is affected by scroll position, so we need to apply our change to it.
	window->Scroll.y = new_scroll_y;
	window->DC.CursorMaxPos.y -= window->Scroll.y;
}

static void SetWindowPos(ImGuiWindow* window, const ImVec2& pos, ImGuiCond cond)
{
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if (cond && (window->SetWindowPosAllowFlags & cond) == 0)
		return;

	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	window->SetWindowPosAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);
	window->SetWindowPosVal = ImVec2(FLT_MAX, FLT_MAX);

	// Set
	const ImVec2 old_pos = window->Pos;
	window->PosFloat = pos;
	window->Pos = ImFloor(pos);
	window->DC.CursorPos += (window->Pos - old_pos);    // As we happen to move the window while it is being appended to (which is a bad idea - will smear) let's at least offset the cursor
	window->DC.CursorMaxPos += (window->Pos - old_pos); // And more importantly we need to adjust this so size calculation doesn't get affected.
}

void ImGui::SetWindowPos(const ImVec2& pos, ImGuiCond cond)
{
	ImGuiWindow* window = GetCurrentWindowRead();
	SetWindowPos(window, pos, cond);
}

void ImGui::SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond)
{
	if (ImGuiWindow* window = FindWindowByName(name))
		SetWindowPos(window, pos, cond);
}

ImVec2 ImGui::GetWindowSize()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->Size;
}

static void SetWindowSize(ImGuiWindow* window, const ImVec2& size, ImGuiCond cond)
{
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if (cond && (window->SetWindowSizeAllowFlags & cond) == 0)
		return;

	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	window->SetWindowSizeAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

	// Set
	if (size.x > 0.0f)
	{
		window->AutoFitFramesX = 0;
		window->SizeFull.x = size.x;
	}
	else
	{
		window->AutoFitFramesX = 2;
		window->AutoFitOnlyGrows = false;
	}
	if (size.y > 0.0f)
	{
		window->AutoFitFramesY = 0;
		window->SizeFull.y = size.y;
	}
	else
	{
		window->AutoFitFramesY = 2;
		window->AutoFitOnlyGrows = false;
	}
}

void ImGui::SetWindowSize(const ImVec2& size, ImGuiCond cond)
{
	SetWindowSize(GImGui->CurrentWindow, size, cond);
}

void ImGui::SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond)
{
	if (ImGuiWindow* window = FindWindowByName(name))
		SetWindowSize(window, size, cond);
}

static void SetWindowCollapsed(ImGuiWindow* window, bool collapsed, ImGuiCond cond)
{
	// Test condition (NB: bit 0 is always true) and clear flags for next time
	if (cond && (window->SetWindowCollapsedAllowFlags & cond) == 0)
		return;
	window->SetWindowCollapsedAllowFlags &= ~(ImGuiCond_Once | ImGuiCond_FirstUseEver | ImGuiCond_Appearing);

	// Set
	window->Collapsed = collapsed;
}

void ImGui::SetWindowCollapsed(bool collapsed, ImGuiCond cond)
{
	SetWindowCollapsed(GImGui->CurrentWindow, collapsed, cond);
}

bool ImGui::IsWindowCollapsed()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->Collapsed;
}

bool ImGui::IsWindowAppearing()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->Appearing;
}

void ImGui::SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond)
{
	if (ImGuiWindow* window = FindWindowByName(name))
		SetWindowCollapsed(window, collapsed, cond);
}

void ImGui::SetWindowFocus()
{
	FocusWindow(GImGui->CurrentWindow);
}

void ImGui::SetWindowFocus(const char* name)
{
	if (name)
	{
		if (ImGuiWindow* window = FindWindowByName(name))
			FocusWindow(window);
	}
	else
	{
		FocusWindow(NULL);
	}
}

void ImGui::SetNextWindowPos(const ImVec2& pos, ImGuiCond cond, const ImVec2& pivot)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	g.NextWindowData.PosVal = pos;
	g.NextWindowData.PosPivotVal = pivot;
	g.NextWindowData.PosCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSize(const ImVec2& size, ImGuiCond cond)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	g.NextWindowData.SizeVal = size;
	g.NextWindowData.SizeCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback, void* custom_callback_user_data)
{
	ImGuiContext& g = *GImGui;
	g.NextWindowData.SizeConstraintCond = ImGuiCond_Always;
	g.NextWindowData.SizeConstraintRect = ImRect(size_min, size_max);
	g.NextWindowData.SizeCallback = custom_callback;
	g.NextWindowData.SizeCallbackUserData = custom_callback_user_data;
}

void ImGui::SetNextWindowContentSize(const ImVec2& size)
{
	ImGuiContext& g = *GImGui;
	g.NextWindowData.ContentSizeVal = size;  // In Begin() we will add the size of window decorations (title bar, menu etc.) to that to form a SizeContents value.
	g.NextWindowData.ContentSizeCond = ImGuiCond_Always;
}

void ImGui::SetNextWindowCollapsed(bool collapsed, ImGuiCond cond)
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(cond == 0 || ImIsPowerOfTwo(cond)); // Make sure the user doesn't attempt to combine multiple condition flags.
	g.NextWindowData.CollapsedVal = collapsed;
	g.NextWindowData.CollapsedCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::SetNextWindowFocus()
{
	ImGuiContext& g = *GImGui;
	g.NextWindowData.FocusCond = ImGuiCond_Always;   // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)
}

void ImGui::SetNextWindowBgAlpha(float alpha)
{
	ImGuiContext& g = *GImGui;
	g.NextWindowData.BgAlphaVal = alpha;
	g.NextWindowData.BgAlphaCond = ImGuiCond_Always; // Using a Cond member for consistency (may transition all of them to single flag set for fast Clear() op)
}

// In window space (not screen space!)
ImVec2 ImGui::GetContentRegionMax()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	ImVec2 mx = window->ContentsRegionRect.Max;
	if (window->DC.ColumnsSet)
		mx.x = GetColumnOffset(window->DC.ColumnsSet->Current + 1) - window->WindowPadding.x;
	return mx;
}

ImVec2 ImGui::GetContentRegionAvail()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return GetContentRegionMax() - (window->DC.CursorPos - window->Pos);
}

float ImGui::GetContentRegionAvailWidth()
{
	return GetContentRegionAvail().x;
}

// In window space (not screen space!)
ImVec2 ImGui::GetWindowContentRegionMin()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->ContentsRegionRect.Min;
}

ImVec2 ImGui::GetWindowContentRegionMax()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->ContentsRegionRect.Max;
}

float ImGui::GetWindowContentRegionWidth()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->ContentsRegionRect.Max.x - window->ContentsRegionRect.Min.x;
}

float ImGui::GetTextLineHeight()
{
	ImGuiContext& g = *GImGui;
	return g.FontSize;
}

float ImGui::GetTextLineHeightWithSpacing()
{
	ImGuiContext& g = *GImGui;
	return g.FontSize + g.Style.ItemSpacing.y;
}

float ImGui::GetFrameHeight()
{
	ImGuiContext& g = *GImGui;
	return g.FontSize + g.Style.FramePadding.y * 2.0f;
}

float ImGui::GetFrameHeightWithSpacing()
{
	ImGuiContext& g = *GImGui;
	return g.FontSize + g.Style.FramePadding.y * 2.0f + g.Style.ItemSpacing.y;
}

ImDrawList* ImGui::GetWindowDrawList()
{
	ImGuiWindow* window = GetCurrentWindow();
	return window->DrawList;
}

ImFont* ImGui::GetFont()
{
	return GImGui->Font;
}

float ImGui::GetFontSize()
{
	return GImGui->FontSize;
}

ImVec2 ImGui::GetFontTexUvWhitePixel()
{
	return GImGui->DrawListSharedData.TexUvWhitePixel;
}

void ImGui::SetWindowFontScale(float scale)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();
	window->FontWindowScale = scale;
	g.FontSize = g.DrawListSharedData.FontSize = window->CalcFontSize();
}

// User generally sees positions in window coordinates. Internally we store CursorPos in absolute screen coordinates because it is more convenient.
// Conversion happens as we pass the value to user, but it makes our naming convention confusing because GetCursorPos() == (DC.CursorPos - window.Pos). May want to rename 'DC.CursorPos'.
ImVec2 ImGui::GetCursorPos()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.CursorPos - window->Pos + window->Scroll;
}

float ImGui::GetCursorPosX()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.CursorPos.x - window->Pos.x + window->Scroll.x;
}

float ImGui::GetCursorPosY()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.CursorPos.y - window->Pos.y + window->Scroll.y;
}

void ImGui::SetCursorPos(const ImVec2& local_pos)
{
	ImGuiWindow* window = GetCurrentWindow();
	window->DC.CursorPos = window->Pos - window->Scroll + local_pos;
	window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

void ImGui::SetCursorPosX(float x)
{
	ImGuiWindow* window = GetCurrentWindow();
	window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + x;
	window->DC.CursorMaxPos.x = ImMax(window->DC.CursorMaxPos.x, window->DC.CursorPos.x);
}

void ImGui::SetCursorPosY(float y)
{
	ImGuiWindow* window = GetCurrentWindow();
	window->DC.CursorPos.y = window->Pos.y - window->Scroll.y + y;
	window->DC.CursorMaxPos.y = ImMax(window->DC.CursorMaxPos.y, window->DC.CursorPos.y);
}

ImVec2 ImGui::GetCursorStartPos()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.CursorStartPos - window->Pos;
}

ImVec2 ImGui::GetCursorScreenPos()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.CursorPos;
}

void ImGui::SetCursorScreenPos(const ImVec2& screen_pos)
{
	ImGuiWindow* window = GetCurrentWindow();
	window->DC.CursorPos = screen_pos;
	window->DC.CursorMaxPos = ImMax(window->DC.CursorMaxPos, window->DC.CursorPos);
}

float ImGui::GetScrollX()
{
	return GImGui->CurrentWindow->Scroll.x;
}

float ImGui::GetScrollY()
{
	return GImGui->CurrentWindow->Scroll.y;
}

float ImGui::GetScrollMaxX()
{
	return GetScrollMaxX(GImGui->CurrentWindow);
}

float ImGui::GetScrollMaxY()
{
	return GetScrollMaxY(GImGui->CurrentWindow);
}

void ImGui::SetScrollX(float scroll_x)
{
	ImGuiWindow* window = GetCurrentWindow();
	window->ScrollTarget.x = scroll_x;
	window->ScrollTargetCenterRatio.x = 0.0f;
}

void ImGui::SetScrollY(float scroll_y)
{
	ImGuiWindow* window = GetCurrentWindow();
	window->ScrollTarget.y = scroll_y + window->TitleBarHeight() + window->MenuBarHeight(); // title bar height canceled out when using ScrollTargetRelY
	window->ScrollTargetCenterRatio.y = 0.0f;
}

void ImGui::SetScrollFromPosY(float pos_y, float center_y_ratio)
{
	// We store a target position so centering can occur on the next frame when we are guaranteed to have a known window size
	ImGuiWindow* window = GetCurrentWindow();
	IM_ASSERT(center_y_ratio >= 0.0f && center_y_ratio <= 1.0f);
	window->ScrollTarget.y = (float)(int)(pos_y + window->Scroll.y);
	window->ScrollTargetCenterRatio.y = center_y_ratio;

	// Minor hack to to make scrolling to top/bottom of window take account of WindowPadding, it looks more right to the user this way
	if (center_y_ratio <= 0.0f && window->ScrollTarget.y <= window->WindowPadding.y)
		window->ScrollTarget.y = 0.0f;
	else if (center_y_ratio >= 1.0f && window->ScrollTarget.y >= window->SizeContents.y - window->WindowPadding.y + GImGui->Style.ItemSpacing.y)
		window->ScrollTarget.y = window->SizeContents.y;
}

// center_y_ratio: 0.0f top of last item, 0.5f vertical center of last item, 1.0f bottom of last item.
void ImGui::SetScrollHere(float center_y_ratio)
{
	ImGuiWindow* window = GetCurrentWindow();
	float target_y = window->DC.CursorPosPrevLine.y - window->Pos.y; // Top of last item, in window space
	target_y += (window->DC.PrevLineHeight * center_y_ratio) + (GImGui->Style.ItemSpacing.y * (center_y_ratio - 0.5f) * 2.0f); // Precisely aim above, in the middle or below the last line.
	SetScrollFromPosY(target_y, center_y_ratio);
}

void ImGui::ActivateItem(ImGuiID id)
{
	ImGuiContext& g = *GImGui;
	g.NavNextActivateId = id;
}

void ImGui::SetKeyboardFocusHere(int offset)
{
	IM_ASSERT(offset >= -1);    // -1 is allowed but not below
	ImGuiWindow* window = GetCurrentWindow();
	window->FocusIdxAllRequestNext = window->FocusIdxAllCounter + 1 + offset;
	window->FocusIdxTabRequestNext = INT_MAX;
}

void ImGui::SetItemDefaultFocus()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if (!window->Appearing)
		return;
	if (g.NavWindow == window->RootWindowForNav && (g.NavInitRequest || g.NavInitResultId != 0) && g.NavLayer == g.NavWindow->DC.NavLayerCurrent)
	{
		g.NavInitRequest = false;
		g.NavInitResultId = g.NavWindow->DC.LastItemId;
		g.NavInitResultRectRel = ImRect(g.NavWindow->DC.LastItemRect.Min - g.NavWindow->Pos, g.NavWindow->DC.LastItemRect.Max - g.NavWindow->Pos);
		NavUpdateAnyRequestFlag();
		if (!IsItemVisible())
			SetScrollHere();
	}
}

void ImGui::SetStateStorage(ImGuiStorage* tree)
{
	ImGuiWindow* window = GetCurrentWindow();
	window->DC.StateStorage = tree ? tree : &window->StateStorage;
}

ImGuiStorage* ImGui::GetStateStorage()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.StateStorage;
}

void ImGui::TextV(const char* fmt, va_list args)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext& g = *GImGui;
	const char* text_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
	TextUnformatted(g.TempBuffer, text_end);
}

void ImGui::Text(const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	TextV(fmt, args);
	va_end(args);
}

void ImGui::TextColoredV(const ImVec4& col, const char* fmt, va_list args)
{
	PushStyleColor(ImGuiCol_Text, col);
	TextV(fmt, args);
	PopStyleColor();
}

void ImGui::TextColored(const ImVec4& col, const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	TextColoredV(col, fmt, args);
	va_end(args);
}

void ImGui::TextDisabledV(const char* fmt, va_list args)
{
	PushStyleColor(ImGuiCol_Text, GImGui->Style.Colors[ImGuiCol_TextDisabled]);
	TextV(fmt, args);
	PopStyleColor();
}

void ImGui::TextDisabled(const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	TextDisabledV(fmt, args);
	va_end(args);
}

void ImGui::TextWrappedV(const char* fmt, va_list args)
{
	bool need_wrap = (GImGui->CurrentWindow->DC.TextWrapPos < 0.0f);    // Keep existing wrap position is one ia already set
	if (need_wrap) PushTextWrapPos(0.0f);
	TextV(fmt, args);
	if (need_wrap) PopTextWrapPos();
}

void ImGui::TextWrapped(const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	TextWrappedV(fmt, args);
	va_end(args);
}

void ImGui::TextUnformatted(const char* text, const char* text_end)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext& g = *GImGui;
	IM_ASSERT(text != NULL);
	const char* text_begin = text;
	if (text_end == NULL)
		text_end = text + strlen(text); // FIXME-OPT

	const ImVec2 text_pos(window->DC.CursorPos.x, window->DC.CursorPos.y + window->DC.CurrentLineTextBaseOffset);
	const float wrap_pos_x = window->DC.TextWrapPos;
	const bool wrap_enabled = wrap_pos_x >= 0.0f;
	if (text_end - text > 2000 && !wrap_enabled)
	{
		// Long text!
		// Perform manual coarse clipping to optimize for long multi-line text
		// From this point we will only compute the width of lines that are visible. Optimization only available when word-wrapping is disabled.
		// We also don't vertically center the text within the line full height, which is unlikely to matter because we are likely the biggest and only item on the line.
		const char* line = text;
		const float line_height = GetTextLineHeight();
		const ImRect clip_rect = window->ClipRect;
		ImVec2 text_size(0, 0);

		if (text_pos.y <= clip_rect.Max.y)
		{
			ImVec2 pos = text_pos;

			// Lines to skip (can't skip when logging text)
			if (!g.LogEnabled)
			{
				int lines_skippable = (int)((clip_rect.Min.y - text_pos.y) / line_height);
				if (lines_skippable > 0)
				{
					int lines_skipped = 0;
					while (line < text_end && lines_skipped < lines_skippable)
					{
						const char* line_end = strchr(line, '\n');
						if (!line_end)
							line_end = text_end;
						line = line_end + 1;
						lines_skipped++;
					}
					pos.y += lines_skipped * line_height;
				}
			}

			// Lines to render
			if (line < text_end)
			{
				ImRect line_rect(pos, pos + ImVec2(FLT_MAX, line_height));
				while (line < text_end)
				{
					const char* line_end = strchr(line, '\n');
					if (IsClippedEx(line_rect, 0, false))
						break;

					const ImVec2 line_size = CalcTextSize(line, line_end, false);
					text_size.x = ImMax(text_size.x, line_size.x);
					RenderText(pos, line, line_end, false);
					if (!line_end)
						line_end = text_end;
					line = line_end + 1;
					line_rect.Min.y += line_height;
					line_rect.Max.y += line_height;
					pos.y += line_height;
				}

				// Count remaining lines
				int lines_skipped = 0;
				while (line < text_end)
				{
					const char* line_end = strchr(line, '\n');
					if (!line_end)
						line_end = text_end;
					line = line_end + 1;
					lines_skipped++;
				}
				pos.y += lines_skipped * line_height;
			}

			text_size.y += (pos - text_pos).y;
		}

		ImRect bb(text_pos, text_pos + text_size);
		ItemSize(bb);
		ItemAdd(bb, 0);
	}
	else
	{
		const float wrap_width = wrap_enabled ? CalcWrapWidthForPos(window->DC.CursorPos, wrap_pos_x) : 0.0f;
		const ImVec2 text_size = CalcTextSize(text_begin, text_end, false, wrap_width);

		// Account of baseline offset
		ImRect bb(text_pos, text_pos + text_size);
		ItemSize(text_size);
		if (!ItemAdd(bb, 0))
			return;

		// Render (we don't hide text after ## in this end-user function)
		RenderTextWrapped(bb.Min, text_begin, text_end, wrap_width);
	}
}

void ImGui::AlignTextToFramePadding()
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext& g = *GImGui;
	window->DC.CurrentLineHeight = ImMax(window->DC.CurrentLineHeight, g.FontSize + g.Style.FramePadding.y * 2);
	window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.CurrentLineTextBaseOffset, g.Style.FramePadding.y);
}

// Add a label+text combo aligned to other label+value widgets
void ImGui::LabelTextV(const char* label, const char* fmt, va_list args)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const float w = CalcItemWidth();

	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const ImRect value_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2));
	const ImRect total_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w + (label_size.x > 0.0f ? style.ItemInnerSpacing.x : 0.0f), style.FramePadding.y * 2) + label_size);
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, 0))
		return;

	// Render
	const char* value_text_begin = &g.TempBuffer[0];
	const char* value_text_end = value_text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
	RenderTextClipped(value_bb.Min, value_bb.Max, value_text_begin, value_text_end, NULL, ImVec2(0.0f, 0.5f));
	if (label_size.x > 0.0f)
		RenderText(ImVec2(value_bb.Max.x + style.ItemInnerSpacing.x, value_bb.Min.y + style.FramePadding.y), label);
}

void ImGui::LabelText(const char* label, const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	LabelTextV(label, fmt, args);
	va_end(args);
}

bool ImGui::ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();

	if (flags & ImGuiButtonFlags_Disabled)
	{
		if (out_hovered)*out_hovered = false;
		if (out_held)*out_held = false;
		if (g.ActiveId == id) ClearActiveID();
		return false;
	}

	// Default behavior requires click+release on same spot
	if ((flags & (ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_PressedOnRelease | ImGuiButtonFlags_PressedOnDoubleClick)) == 0)
		flags |= ImGuiButtonFlags_PressedOnClickRelease;

	ImGuiWindow* backup_hovered_window = g.HoveredWindow;
	if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)
		g.HoveredWindow = window;

	bool pressed = false;
	bool hovered = ItemHoverable(bb, id);

	// Special mode for Drag and Drop where holding button pressed for a long time while dragging another item triggers the button
	if ((flags & ImGuiButtonFlags_PressedOnDragDropHold) && g.DragDropActive && !(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoHoldToOpenOthers))
		if (IsItemHovered(ImGuiHoveredFlags_AllowWhenBlockedByActiveItem))
		{
			hovered = true;
			SetHoveredID(id);
			if (CalcTypematicPressedRepeatAmount(g.HoveredIdTimer + 0.0001f, g.HoveredIdTimer + 0.0001f - g.IO.DeltaTime, 0.01f, 0.70f)) // FIXME: Our formula for CalcTypematicPressedRepeatAmount() is fishy
			{
				pressed = true;
				FocusWindow(window);
			}
		}

	if ((flags & ImGuiButtonFlags_FlattenChildren) && g.HoveredRootWindow == window)
		g.HoveredWindow = backup_hovered_window;

	// AllowOverlap mode (rarely used) requires previous frame HoveredId to be null or to match. This allows using patterns where a later submitted widget overlaps a previous one.
	if (hovered && (flags & ImGuiButtonFlags_AllowItemOverlap) && (g.HoveredIdPreviousFrame != id && g.HoveredIdPreviousFrame != 0))
		hovered = false;

	// Mouse
	if (hovered)
	{
		if (!(flags & ImGuiButtonFlags_NoKeyModifiers) || (!g.IO.KeyCtrl && !g.IO.KeyShift && !g.IO.KeyAlt))
		{
			//                        | CLICKING        | HOLDING with ImGuiButtonFlags_Repeat
			// PressedOnClickRelease  |  <on release>*  |  <on repeat> <on repeat> .. (NOT on release)  <-- MOST COMMON! (*) only if both click/release were over bounds
			// PressedOnClick         |  <on click>     |  <on click> <on repeat> <on repeat> ..
			// PressedOnRelease       |  <on release>   |  <on repeat> <on repeat> .. (NOT on release)
			// PressedOnDoubleClick   |  <on dclick>    |  <on dclick> <on repeat> <on repeat> ..
			// FIXME-NAV: We don't honor those different behaviors.
			if ((flags & ImGuiButtonFlags_PressedOnClickRelease) && g.IO.MouseClicked[0])
			{
				SetActiveID(id, window);
				if (!(flags & ImGuiButtonFlags_NoNavFocus))
					SetFocusID(id, window);
				FocusWindow(window);
			}
			if (((flags & ImGuiButtonFlags_PressedOnClick) && g.IO.MouseClicked[0]) || ((flags & ImGuiButtonFlags_PressedOnDoubleClick) && g.IO.MouseDoubleClicked[0]))
			{
				pressed = true;
				if (flags & ImGuiButtonFlags_NoHoldingActiveID)
					ClearActiveID();
				else
					SetActiveID(id, window); // Hold on ID
				FocusWindow(window);
			}
			if ((flags & ImGuiButtonFlags_PressedOnRelease) && g.IO.MouseReleased[0])
			{
				if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>
					pressed = true;
				ClearActiveID();
			}

			// 'Repeat' mode acts when held regardless of _PressedOn flags (see table above).
			// Relies on repeat logic of IsMouseClicked() but we may as well do it ourselves if we end up exposing finer RepeatDelay/RepeatRate settings.
			if ((flags & ImGuiButtonFlags_Repeat) && g.ActiveId == id && g.IO.MouseDownDuration[0] > 0.0f && IsMouseClicked(0, true))
				pressed = true;
		}

		if (pressed)
			g.NavDisableHighlight = true;
	}

	// Gamepad/Keyboard navigation
	// We report navigated item as hovered but we don't set g.HoveredId to not interfere with mouse.
	if (g.NavId == id && !g.NavDisableHighlight && g.NavDisableMouseHover && (g.ActiveId == 0 || g.ActiveId == id || g.ActiveId == window->MoveId))
		hovered = true;

	if (g.NavActivateDownId == id)
	{
		bool nav_activated_by_code = (g.NavActivateId == id);
		bool nav_activated_by_inputs = IsNavInputPressed(ImGuiNavInput_Activate, (flags & ImGuiButtonFlags_Repeat) ? ImGuiInputReadMode_Repeat : ImGuiInputReadMode_Pressed);
		if (nav_activated_by_code || nav_activated_by_inputs)
			pressed = true;
		if (nav_activated_by_code || nav_activated_by_inputs || g.ActiveId == id)
		{
			// Set active id so it can be queried by user via IsItemActive(), equivalent of holding the mouse button.
			g.NavActivateId = id; // This is so SetActiveId assign a Nav source
			SetActiveID(id, window);
			if (!(flags & ImGuiButtonFlags_NoNavFocus))
				SetFocusID(id, window);
			g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right) | (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
		}
	}

	bool held = false;
	if (g.ActiveId == id)
	{
		if (g.ActiveIdSource == ImGuiInputSource_Mouse)
		{
			if (g.ActiveIdIsJustActivated)
				g.ActiveIdClickOffset = g.IO.MousePos - bb.Min;
			if (g.IO.MouseDown[0])
			{
				held = true;
			}
			else
			{
				if (hovered && (flags & ImGuiButtonFlags_PressedOnClickRelease))
					if (!((flags & ImGuiButtonFlags_Repeat) && g.IO.MouseDownDurationPrev[0] >= g.IO.KeyRepeatDelay))  // Repeat mode trumps <on release>
						if (!g.DragDropActive)
							pressed = true;
				ClearActiveID();
			}
			if (!(flags & ImGuiButtonFlags_NoNavFocus))
				g.NavDisableHighlight = true;
		}
		else if (g.ActiveIdSource == ImGuiInputSource_Nav)
		{
			if (g.NavActivateDownId != id)
				ClearActiveID();
		}
	}

	if (out_hovered)*out_hovered = hovered;
	if (out_held)*out_held = held;

	return pressed;
}

bool ImGui::ButtonEx(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	ImVec2 pos = window->DC.CursorPos;
	if ((flags & ImGuiButtonFlags_AlignTextBaseLine) && style.FramePadding.y < window->DC.CurrentLineTextBaseOffset) // Try to vertically align buttons that are smaller/have no padding so that text baseline matches (bit hacky, since it shouldn't be a flag)
		pos.y += window->DC.CurrentLineTextBaseOffset - style.FramePadding.y;

	const auto button_size = size_arg;
	ImVec2 size = CalcItemSize(size_arg, label_size.x + style.FramePadding.x * 2.0f, label_size.y + style.FramePadding.y * 2.0f);

	if (button_size.x == 0)
		size.x += 6.f;

	if (button_size.y == 0.f)
		size.y += 2.f;

	const ImRect bb(pos, pos + size);
	ItemSize(bb, style.FramePadding.y);
	if (!ItemAdd(bb, id))
		return false;

	if (window->DC.ItemFlags & ImGuiItemFlags_ButtonRepeat)
		flags |= ImGuiButtonFlags_Repeat;
	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held, flags);

	// Render
	RenderNavHighlight(bb, id);
	RenderFrame(bb.Min, bb.Max, GetColorU32((hovered && held) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button), true, style.FrameRounding);

	window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(GetStyleColorVec4(ImGuiCol_ButtonOutline)), 0, 15, style.Alpha);

	ImGui::PushStyleColor(ImGuiCol_Text, ImGui::GetStyleColorVec4(ImGuiCol_ButtonText));
	RenderTextClipped(bb.Min + style.FramePadding, bb.Max - style.FramePadding, label, NULL, &label_size, style.ButtonTextAlign, &bb);
	ImGui::PopStyleColor();

	// Automatically close popups
	//if (pressed && !(flags & ImGuiButtonFlags_DontClosePopups) && (window->Flags & ImGuiWindowFlags_Popup))
	//    CloseCurrentPopup();

	return pressed;
}

bool ImGui::Button(const char* label, const ImVec2& size_arg, ImGuiButtonFlags flags)
{
	return ButtonEx(label, size_arg, flags);
}

// Small buttons fits within text without additional vertical spacing.
bool ImGui::SmallButton(const char* label)
{
	ImGuiContext& g = *GImGui;
	float backup_padding_y = g.Style.FramePadding.y;
	g.Style.FramePadding.y = 0.0f;
	bool pressed = ButtonEx(label, ImVec2(0, 0), ImGuiButtonFlags_AlignTextBaseLine);
	g.Style.FramePadding.y = backup_padding_y;
	return pressed;
}

bool ImGui::ArrowButton(const char* str_id, ImGuiDir dir)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiID id = window->GetID(str_id);
	float sz = ImGui::GetFrameHeight();
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(sz, sz));
	ItemSize(bb);
	if (!ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	// Render
	const ImU32 col = GetColorU32((hovered && held) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
	RenderNavHighlight(bb, id);
	RenderFrame(bb.Min, bb.Max, col, true, g.Style.FrameRounding);
	RenderArrow(bb.Min + g.Style.FramePadding, dir);

	return pressed;
}

// Tip: use ImGui::PushID()/PopID() to push indices or pointers in the ID stack.
// Then you can keep 'str_id' empty or the same for all your buttons (instead of creating a string based on a non-string id)
bool ImGui::InvisibleButton(const char* str_id, const ImVec2& size_arg)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	const ImGuiID id = window->GetID(str_id);
	ImVec2 size = CalcItemSize(size_arg, 0.0f, 0.0f);
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
	ItemSize(bb);
	if (!ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	return pressed;
}

// Button to close a window
bool ImGui::CloseButton(ImGuiID id, const ImVec2& pos, float radius)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	// We intentionally allow interaction when clipped so that a mechanical Alt,Right,Validate sequence close a window.
	// (this isn't the regular behavior of buttons, but it doesn't affect the user much because navigation tends to keep items visible).
	const ImRect bb(pos - ImVec2(radius, radius), pos + ImVec2(radius, radius));
	bool is_clipped = !ItemAdd(bb, id);

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held);
	if (is_clipped)
		return pressed;

	// Render
	ImVec2 center = bb.GetCenter();
	if (hovered)
		window->DrawList->AddCircleFilled(center, ImMax(2.0f, radius), GetColorU32((held && hovered) ? ImGuiCol_ButtonActive : ImGuiCol_ButtonHovered), 9);

	float cross_extent = (radius * 0.7071f) - 1.0f;
	ImU32 cross_col = GetColorU32(ImGuiCol_Text);
	center -= ImVec2(0.5f, 0.5f);
	window->DrawList->AddLine(center + ImVec2(+cross_extent, +cross_extent), center + ImVec2(-cross_extent, -cross_extent), cross_col, 1.0f);
	window->DrawList->AddLine(center + ImVec2(+cross_extent, -cross_extent), center + ImVec2(-cross_extent, +cross_extent), cross_col, 1.0f);

	return pressed;
}

void ImGui::Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, const ImVec4& tint_col, const ImVec4& border_col)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
	if (border_col.w > 0.0f)
		bb.Max += ImVec2(2, 2);
	ItemSize(bb);
	if (!ItemAdd(bb, 0))
		return;

	if (border_col.w > 0.0f)
	{
		window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(border_col), 0.0f);
		window->DrawList->AddImage(user_texture_id, bb.Min + ImVec2(1, 1), bb.Max - ImVec2(1, 1), uv0, uv1, GetColorU32(tint_col));
	}
	else
	{
		window->DrawList->AddImage(user_texture_id, bb.Min, bb.Max, uv0, uv1, GetColorU32(tint_col));
	}
}

// frame_padding < 0: uses FramePadding from style (default)
// frame_padding = 0: no framing
// frame_padding > 0: set framing size
// The color used are the button colors.
bool ImGui::ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0, const ImVec2& uv1, int frame_padding, const ImVec4& bg_col, const ImVec4& tint_col)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;

	// Default to using texture ID as ID. User can still push string/integer prefixes.
	// We could hash the size/uv to create a unique ID but that would prevent the user from animating UV.
	PushID((void*)user_texture_id);
	const ImGuiID id = window->GetID("#image");
	PopID();

	const ImVec2 padding = (frame_padding >= 0) ? ImVec2((float)frame_padding, (float)frame_padding) : style.FramePadding;
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size + padding * 2);
	const ImRect image_bb(window->DC.CursorPos + padding, window->DC.CursorPos + padding + size);
	ItemSize(bb);
	if (!ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	// Render
	const ImU32 col = GetColorU32((hovered && held) ? ImGuiCol_ButtonActive : hovered ? ImGuiCol_ButtonHovered : ImGuiCol_Button);
	RenderNavHighlight(bb, id);
	RenderFrame(bb.Min, bb.Max, col, true, ImClamp((float)ImMin(padding.x, padding.y), 0.0f, style.FrameRounding));
	if (bg_col.w > 0.0f)
		window->DrawList->AddRectFilled(image_bb.Min, image_bb.Max, GetColorU32(bg_col));
	window->DrawList->AddImage(user_texture_id, image_bb.Min, image_bb.Max, uv0, uv1, GetColorU32(tint_col));

	return pressed;
}

// Start logging ImGui output to TTY
void ImGui::LogToTTY(int max_depth)
{
	ImGuiContext& g = *GImGui;
	if (g.LogEnabled)
		return;
	ImGuiWindow* window = g.CurrentWindow;

	IM_ASSERT(g.LogFile == NULL);
	g.LogFile = stdout;
	g.LogEnabled = true;
	g.LogStartDepth = window->DC.TreeDepth;
	if (max_depth >= 0)
		g.LogAutoExpandMaxDepth = max_depth;
}

// Start logging ImGui output to given file
void ImGui::LogToFile(int max_depth, const char* filename)
{
	ImGuiContext& g = *GImGui;
	if (g.LogEnabled)
		return;
	ImGuiWindow* window = g.CurrentWindow;

	if (!filename)
	{
		filename = g.IO.LogFilename;
		if (!filename)
			return;
	}

	IM_ASSERT(g.LogFile == NULL);
	g.LogFile = ImFileOpen(filename, "ab");
	if (!g.LogFile)
	{
		IM_ASSERT(g.LogFile != NULL); // Consider this an error
		return;
	}
	g.LogEnabled = true;
	g.LogStartDepth = window->DC.TreeDepth;
	if (max_depth >= 0)
		g.LogAutoExpandMaxDepth = max_depth;
}

// Start logging ImGui output to clipboard
void ImGui::LogToClipboard(int max_depth)
{
	ImGuiContext& g = *GImGui;
	if (g.LogEnabled)
		return;
	ImGuiWindow* window = g.CurrentWindow;

	IM_ASSERT(g.LogFile == NULL);
	g.LogFile = NULL;
	g.LogEnabled = true;
	g.LogStartDepth = window->DC.TreeDepth;
	if (max_depth >= 0)
		g.LogAutoExpandMaxDepth = max_depth;
}

void ImGui::LogFinish()
{
	ImGuiContext& g = *GImGui;
	if (!g.LogEnabled)
		return;

	LogText(IM_NEWLINE);
	if (g.LogFile != NULL)
	{
		if (g.LogFile == stdout)
			fflush(g.LogFile);
		else
			fclose(g.LogFile);
		g.LogFile = NULL;
	}
	if (g.LogClipboard->size() > 1)
	{
		SetClipboardText(g.LogClipboard->begin());
		g.LogClipboard->clear();
	}
	g.LogEnabled = false;
}

// Helper to display logging buttons
void ImGui::LogButtons()
{
	ImGuiContext& g = *GImGui;

	PushID("LogButtons");
	const bool log_to_tty = Button("Log To TTY"); SameLine();
	const bool log_to_file = Button("Log To File"); SameLine();
	const bool log_to_clipboard = Button("Log To Clipboard"); SameLine();
	PushItemWidth(80.0f);
	PushAllowKeyboardFocus(false);
	SliderInt("Depth", &g.LogAutoExpandMaxDepth, 0, 9, NULL);
	PopAllowKeyboardFocus();
	PopItemWidth();
	PopID();

	// Start logging at the end of the function so that the buttons don't appear in the log
	if (log_to_tty)
		LogToTTY(g.LogAutoExpandMaxDepth);
	if (log_to_file)
		LogToFile(g.LogAutoExpandMaxDepth, g.IO.LogFilename);
	if (log_to_clipboard)
		LogToClipboard(g.LogAutoExpandMaxDepth);
}

bool ImGui::TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags)
{
	if (flags & ImGuiTreeNodeFlags_Leaf)
		return true;

	// We only write to the tree storage if the user clicks (or explicitely use SetNextTreeNode*** functions)
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	ImGuiStorage* storage = window->DC.StateStorage;

	bool is_open;
	if (g.NextTreeNodeOpenCond != 0)
	{
		if (g.NextTreeNodeOpenCond & ImGuiCond_Always)
		{
			is_open = g.NextTreeNodeOpenVal;
			storage->SetInt(id, is_open);
		}
		else
		{
			// We treat ImGuiCond_Once and ImGuiCond_FirstUseEver the same because tree node state are not saved persistently.
			const int stored_value = storage->GetInt(id, -1);
			if (stored_value == -1)
			{
				is_open = g.NextTreeNodeOpenVal;
				storage->SetInt(id, is_open);
			}
			else
			{
				is_open = stored_value != 0;
			}
		}
		g.NextTreeNodeOpenCond = 0;
	}
	else
	{
		is_open = storage->GetInt(id, (flags & ImGuiTreeNodeFlags_DefaultOpen) ? 1 : 0) != 0;
	}

	// When logging is enabled, we automatically expand tree nodes (but *NOT* collapsing headers.. seems like sensible behavior).
	// NB- If we are above max depth we still allow manually opened nodes to be logged.
	if (g.LogEnabled && !(flags & ImGuiTreeNodeFlags_NoAutoOpenOnLog) && window->DC.TreeDepth < g.LogAutoExpandMaxDepth)
		is_open = true;

	return is_open;
}

bool ImGui::TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const bool display_frame = (flags & ImGuiTreeNodeFlags_Framed) != 0;
	const ImVec2 padding = (display_frame || (flags & ImGuiTreeNodeFlags_FramePadding)) ? style.FramePadding : ImVec2(style.FramePadding.x, 0.0f);

	if (!label_end)
		label_end = FindRenderedTextEnd(label);
	const ImVec2 label_size = CalcTextSize(label, label_end, false);

	// We vertically grow up to current line height up the typical widget height.
	const float text_base_offset_y = ImMax(padding.y, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it
	const float frame_height = ImMax(ImMin(window->DC.CurrentLineHeight, g.FontSize + style.FramePadding.y * 2), label_size.y + padding.y * 2);
	ImRect frame_bb = ImRect(window->DC.CursorPos, ImVec2(window->Pos.x + GetContentRegionMax().x, window->DC.CursorPos.y + frame_height));
	if (display_frame)
	{
		// Framed header expand a little outside the default padding
		frame_bb.Min.x -= (float)(int)(window->WindowPadding.x * 0.5f) - 1;
		frame_bb.Max.x += (float)(int)(window->WindowPadding.x * 0.5f) - 1;
	}

	const float text_offset_x = (g.FontSize + (display_frame ? padding.x * 3 : padding.x * 2));   // Collapser arrow width + Spacing
	const float text_width = g.FontSize + (label_size.x > 0.0f ? label_size.x + padding.x * 2 : 0.0f);   // Include collapser
	ItemSize(ImVec2(text_width, frame_height), text_base_offset_y);

	// For regular tree nodes, we arbitrary allow to click past 2 worth of ItemSpacing
	// (Ideally we'd want to add a flag for the user to specify if we want the hit test to be done up to the right side of the content or not)
	const ImRect interact_bb = display_frame ? frame_bb : ImRect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + text_width + style.ItemSpacing.x * 2, frame_bb.Max.y);
	bool is_open = TreeNodeBehaviorIsOpen(id, flags);

	// Store a flag for the current depth to tell if we will allow closing this node when navigating one of its child.
	// For this purpose we essentially compare if g.NavIdIsAlive went from 0 to 1 between TreeNode() and TreePop().
	// This is currently only support 32 level deep and we are fine with (1 << Depth) overflowing into a zero.
	if (is_open && !g.NavIdIsAlive && (flags & ImGuiTreeNodeFlags_NavLeftJumpsBackHere) && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
		window->DC.TreeDepthMayJumpToParentOnPop |= (1 << window->DC.TreeDepth);

	bool item_add = ItemAdd(interact_bb, id);
	window->DC.LastItemStatusFlags |= ImGuiItemStatusFlags_HasDisplayRect;
	window->DC.LastItemDisplayRect = frame_bb;

	if (!item_add)
	{
		if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
			TreePushRawID(id);
		return is_open;
	}

	// Flags that affects opening behavior:
	// - 0(default) ..................... single-click anywhere to open
	// - OpenOnDoubleClick .............. double-click anywhere to open
	// - OpenOnArrow .................... single-click on arrow to open
	// - OpenOnDoubleClick|OpenOnArrow .. single-click on arrow or double-click anywhere to open
	ImGuiButtonFlags button_flags = ImGuiButtonFlags_NoKeyModifiers | ((flags & ImGuiTreeNodeFlags_AllowItemOverlap) ? ImGuiButtonFlags_AllowItemOverlap : 0);
	if (!(flags & ImGuiTreeNodeFlags_Leaf))
		button_flags |= ImGuiButtonFlags_PressedOnDragDropHold;
	if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)
		button_flags |= ImGuiButtonFlags_PressedOnDoubleClick | ((flags & ImGuiTreeNodeFlags_OpenOnArrow) ? ImGuiButtonFlags_PressedOnClickRelease : 0);

	bool hovered, held, pressed = ButtonBehavior(interact_bb, id, &hovered, &held, button_flags);
	if (!(flags & ImGuiTreeNodeFlags_Leaf))
	{
		bool toggled = false;
		if (pressed)
		{
			toggled = !(flags & (ImGuiTreeNodeFlags_OpenOnArrow | ImGuiTreeNodeFlags_OpenOnDoubleClick)) || (g.NavActivateId == id);
			if (flags & ImGuiTreeNodeFlags_OpenOnArrow)
				toggled |= IsMouseHoveringRect(interact_bb.Min, ImVec2(interact_bb.Min.x + text_offset_x, interact_bb.Max.y)) && (!g.NavDisableMouseHover);
			if (flags & ImGuiTreeNodeFlags_OpenOnDoubleClick)
				toggled |= g.IO.MouseDoubleClicked[0];
			if (g.DragDropActive && is_open) // When using Drag and Drop "hold to open" we keep the node highlighted after opening, but never close it again.
				toggled = false;
		}

		if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Left && is_open)
		{
			toggled = true;
			NavMoveRequestCancel();
		}
		if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right && !is_open) // If there's something upcoming on the line we may want to give it the priority?
		{
			toggled = true;
			NavMoveRequestCancel();
		}

		if (toggled)
		{
			is_open = !is_open;
			window->DC.StateStorage->SetInt(id, is_open);
		}
	}
	if (flags & ImGuiTreeNodeFlags_AllowItemOverlap)
		SetItemAllowOverlap();

	// Render
	const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
	const ImVec2 text_pos = frame_bb.Min + ImVec2(text_offset_x, text_base_offset_y);
	if (display_frame)
	{
		// Framed type
		RenderFrame(frame_bb.Min, frame_bb.Max, col, true, style.FrameRounding);
		RenderNavHighlight(frame_bb, id, ImGuiNavHighlightFlags_TypeThin);
		RenderArrow(frame_bb.Min + ImVec2(padding.x, text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 1.0f);
		if (g.LogEnabled)
		{
			// NB: '##' is normally used to hide text (as a library-wide feature), so we need to specify the text range to make sure the ## aren't stripped out here.
			const char log_prefix[] = "\n##";
			const char log_suffix[] = "##";
			LogRenderedText(&text_pos, log_prefix, log_prefix + 3);
			RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
			LogRenderedText(&text_pos, log_suffix + 1, log_suffix + 3);
		}
		else
		{
			RenderTextClipped(text_pos, frame_bb.Max, label, label_end, &label_size);
		}
	}
	else
	{
		// Unframed typed for tree nodes
		if (hovered || (flags & ImGuiTreeNodeFlags_Selected))
		{
			RenderFrame(frame_bb.Min, frame_bb.Max, col, false);
			RenderNavHighlight(frame_bb, id, ImGuiNavHighlightFlags_TypeThin);
		}

		if (flags & ImGuiTreeNodeFlags_Bullet)
			RenderBullet(frame_bb.Min + ImVec2(text_offset_x * 0.5f, g.FontSize * 0.50f + text_base_offset_y));
		else if (!(flags & ImGuiTreeNodeFlags_Leaf))
			RenderArrow(frame_bb.Min + ImVec2(padding.x, g.FontSize * 0.15f + text_base_offset_y), is_open ? ImGuiDir_Down : ImGuiDir_Right, 0.70f);
		if (g.LogEnabled)
			LogRenderedText(&text_pos, ">");
		RenderText(text_pos, label, label_end, false);
	}

	if (is_open && !(flags & ImGuiTreeNodeFlags_NoTreePushOnOpen))
		TreePushRawID(id);
	return is_open;
}

// CollapsingHeader returns true when opened but do not indent nor push into the ID stack (because of the ImGuiTreeNodeFlags_NoTreePushOnOpen flag).
// This is basically the same as calling TreeNodeEx(label, ImGuiTreeNodeFlags_CollapsingHeader | ImGuiTreeNodeFlags_NoTreePushOnOpen). You can remove the _NoTreePushOnOpen flag if you want behavior closer to normal TreeNode().
bool ImGui::CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	return TreeNodeBehavior(window->GetID(label), flags | ImGuiTreeNodeFlags_CollapsingHeader | ImGuiTreeNodeFlags_NoTreePushOnOpen, label);
}

bool ImGui::CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	if (p_open && !*p_open)
		return false;

	ImGuiID id = window->GetID(label);
	bool is_open = TreeNodeBehavior(id, flags | ImGuiTreeNodeFlags_CollapsingHeader | ImGuiTreeNodeFlags_NoTreePushOnOpen | (p_open ? ImGuiTreeNodeFlags_AllowItemOverlap : 0), label);
	if (p_open)
	{
		// Create a small overlapping close button // FIXME: We can evolve this into user accessible helpers to add extra buttons on title bars, headers, etc.
		ImGuiContext& g = *GImGui;
		float button_sz = g.FontSize * 0.5f;
		ImGuiItemHoveredDataBackup last_item_backup;
		if (CloseButton(window->GetID((void*)(intptr_t)(id + 1)), ImVec2(ImMin(window->DC.LastItemRect.Max.x, window->ClipRect.Max.x) - g.Style.FramePadding.x - button_sz, window->DC.LastItemRect.Min.y + g.Style.FramePadding.y + button_sz), button_sz))
			*p_open = false;
		last_item_backup.Restore();
	}

	return is_open;
}

bool ImGui::TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	return TreeNodeBehavior(window->GetID(label), flags, label, NULL);
}

bool ImGui::TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
	return TreeNodeBehavior(window->GetID(str_id), flags, g.TempBuffer, label_end);
}

bool ImGui::TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const char* label_end = g.TempBuffer + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
	return TreeNodeBehavior(window->GetID(ptr_id), flags, g.TempBuffer, label_end);
}

bool ImGui::TreeNodeV(const char* str_id, const char* fmt, va_list args)
{
	return TreeNodeExV(str_id, 0, fmt, args);
}

bool ImGui::TreeNodeV(const void* ptr_id, const char* fmt, va_list args)
{
	return TreeNodeExV(ptr_id, 0, fmt, args);
}

bool ImGui::TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	bool is_open = TreeNodeExV(str_id, flags, fmt, args);
	va_end(args);
	return is_open;
}

bool ImGui::TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	bool is_open = TreeNodeExV(ptr_id, flags, fmt, args);
	va_end(args);
	return is_open;
}

bool ImGui::TreeNode(const char* str_id, const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	bool is_open = TreeNodeExV(str_id, 0, fmt, args);
	va_end(args);
	return is_open;
}

bool ImGui::TreeNode(const void* ptr_id, const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	bool is_open = TreeNodeExV(ptr_id, 0, fmt, args);
	va_end(args);
	return is_open;
}

bool ImGui::TreeNode(const char* label)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;
	return TreeNodeBehavior(window->GetID(label), 0, label, NULL);
}

void ImGui::TreeAdvanceToLabelPos()
{
	ImGuiContext& g = *GImGui;
	g.CurrentWindow->DC.CursorPos.x += GetTreeNodeToLabelSpacing();
}

// Horizontal distance preceding label when using TreeNode() or Bullet()
float ImGui::GetTreeNodeToLabelSpacing()
{
	ImGuiContext& g = *GImGui;
	return g.FontSize + (g.Style.FramePadding.x * 2.0f);
}

void ImGui::SetNextTreeNodeOpen(bool is_open, ImGuiCond cond)
{
	ImGuiContext& g = *GImGui;
	if (g.CurrentWindow->SkipItems)
		return;
	g.NextTreeNodeOpenVal = is_open;
	g.NextTreeNodeOpenCond = cond ? cond : ImGuiCond_Always;
}

void ImGui::PushID(const char* str_id)
{
	ImGuiWindow* window = GetCurrentWindowRead();
	window->IDStack.push_back(window->GetID(str_id));
}

void ImGui::PushID(const char* str_id_begin, const char* str_id_end)
{
	ImGuiWindow* window = GetCurrentWindowRead();
	window->IDStack.push_back(window->GetID(str_id_begin, str_id_end));
}

void ImGui::PushID(const void* ptr_id)
{
	ImGuiWindow* window = GetCurrentWindowRead();
	window->IDStack.push_back(window->GetID(ptr_id));
}

void ImGui::PushID(int int_id)
{
	const void* ptr_id = (void*)(intptr_t)int_id;
	ImGuiWindow* window = GetCurrentWindowRead();
	window->IDStack.push_back(window->GetID(ptr_id));
}

void ImGui::PopID()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	window->IDStack.pop_back();
}

ImGuiID ImGui::GetID(const char* str_id)
{
	return GImGui->CurrentWindow->GetID(str_id);
}

ImGuiID ImGui::GetID(const char* str_id_begin, const char* str_id_end)
{
	return GImGui->CurrentWindow->GetID(str_id_begin, str_id_end);
}

ImGuiID ImGui::GetID(const void* ptr_id)
{
	return GImGui->CurrentWindow->GetID(ptr_id);
}

void ImGui::Bullet()
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const float line_height = ImMax(ImMin(window->DC.CurrentLineHeight, g.FontSize + g.Style.FramePadding.y * 2), g.FontSize);
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize, line_height));
	ItemSize(bb);
	if (!ItemAdd(bb, 0))
	{
		SameLine(0, style.FramePadding.x * 2);
		return;
	}

	// Render and stay on same line
	RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize * 0.5f, line_height * 0.5f));
	SameLine(0, style.FramePadding.x * 2);
}

// Text with a little bullet aligned to the typical tree node.
void ImGui::BulletTextV(const char* fmt, va_list args)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;

	const char* text_begin = g.TempBuffer;
	const char* text_end = text_begin + ImFormatStringV(g.TempBuffer, IM_ARRAYSIZE(g.TempBuffer), fmt, args);
	const ImVec2 label_size = CalcTextSize(text_begin, text_end, false);
	const float text_base_offset_y = ImMax(0.0f, window->DC.CurrentLineTextBaseOffset); // Latch before ItemSize changes it
	const float line_height = ImMax(ImMin(window->DC.CurrentLineHeight, g.FontSize + g.Style.FramePadding.y * 2), g.FontSize);
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(g.FontSize + (label_size.x > 0.0f ? (label_size.x + style.FramePadding.x * 2) : 0.0f), ImMax(line_height, label_size.y)));  // Empty text doesn't add padding
	ItemSize(bb);
	if (!ItemAdd(bb, 0))
		return;

	// Render
	RenderBullet(bb.Min + ImVec2(style.FramePadding.x + g.FontSize * 0.5f, line_height * 0.5f));
	RenderText(bb.Min + ImVec2(g.FontSize + style.FramePadding.x * 2, text_base_offset_y), text_begin, text_end, false);
}

void ImGui::BulletText(const char* fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	BulletTextV(fmt, args);
	va_end(args);
}

static inline void DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, const char* display_format, char* buf, int buf_size)
{
	if (data_type == ImGuiDataType_Int)
		ImFormatString(buf, buf_size, display_format, *(int*)data_ptr);
	else if (data_type == ImGuiDataType_Float)
		ImFormatString(buf, buf_size, display_format, *(float*)data_ptr);
	else if (data_type == ImGuiDataType_Double)
		ImFormatString(buf, buf_size, display_format, *(double*)data_ptr);
}

static inline void DataTypeFormatString(ImGuiDataType data_type, void* data_ptr, int decimal_precision, char* buf, int buf_size)
{
	if (data_type == ImGuiDataType_Int)
	{
		if (decimal_precision < 0)
			ImFormatString(buf, buf_size, "%d", *(int*)data_ptr);
		else
			ImFormatString(buf, buf_size, "%.*d", decimal_precision, *(int*)data_ptr);
	}
	else if (data_type == ImGuiDataType_Float)
	{
		if (decimal_precision < 0)
			ImFormatString(buf, buf_size, "%f", *(float*)data_ptr);     // Ideally we'd have a minimum decimal precision of 1 to visually denote that it is a float, while hiding non-significant digits?
		else
			ImFormatString(buf, buf_size, "%.*f", decimal_precision, *(float*)data_ptr);
	}
	else if (data_type == ImGuiDataType_Double)
	{
		if (decimal_precision < 0)
			ImFormatString(buf, buf_size, "%f", *(double*)data_ptr);
		else
			ImFormatString(buf, buf_size, "%.*f", decimal_precision, *(double*)data_ptr);
	}
}

static void DataTypeApplyOp(ImGuiDataType data_type, int op, void* output, void* arg1, const void* arg2)
{
	IM_ASSERT(op == '+' || op == '-');
	if (data_type == ImGuiDataType_Int)
	{
		if (op == '+')*(int*)output = *(int*)arg1 + *(const int*)arg2;
		else if (op == '-')*(int*)output = *(int*)arg1 - *(const int*)arg2;
	}
	else if (data_type == ImGuiDataType_Float)
	{
		if (op == '+')*(float*)output = *(float*)arg1 + *(const float*)arg2;
		else if (op == '-')*(float*)output = *(float*)arg1 - *(const float*)arg2;
	}
	else if (data_type == ImGuiDataType_Double)
	{
		if (op == '+')*(double*)output = *(double*)arg1 + *(const double*)arg2;
		else if (op == '-')*(double*)output = *(double*)arg1 - *(const double*)arg2;
	}
}

static size_t GDataTypeSize[ImGuiDataType_COUNT] =
{
	sizeof(int),
	sizeof(float),
	sizeof(double)
};

// User can input math operators (e.g. +100) to edit a numerical values.
// NB: This is _not_ a full expression evaluator. We should probably add one though..
static bool DataTypeApplyOpFromText(const char* buf, const char* initial_value_buf, ImGuiDataType data_type, void* data_ptr, const char* scalar_format)
{
	while (ImCharIsSpace((unsigned int)*buf))
		buf++;

	// We don't support '-' op because it would conflict with inputing negative value.
	// Instead you can use +-100 to subtract from an existing value
	char op = buf[0];
	if (op == '+' || op == '*' || op == '/')
	{
		buf++;
		while (ImCharIsSpace((unsigned int)*buf))
			buf++;
	}
	else
	{
		op = 0;
	}
	if (!buf[0])
		return false;

	IM_ASSERT(data_type < ImGuiDataType_COUNT);
	int data_backup[2];
	IM_ASSERT(GDataTypeSize[data_type] <= sizeof(data_backup));
	memcpy(data_backup, data_ptr, GDataTypeSize[data_type]);

	if (data_type == ImGuiDataType_Int)
	{
		if (!scalar_format)
			scalar_format = "%d";
		int* v = (int*)data_ptr;
		int arg0i = *v;
		if (op && sscanf(initial_value_buf, scalar_format, &arg0i) < 1)
			return false;
		// Store operand in a float so we can use fractional value for multipliers (*1.1), but constant always parsed as integer so we can fit big integers (e.g. 2000000003) past float precision
		float arg1f = 0.0f;
		if (op == '+') { if (sscanf(buf, "%f", &arg1f) == 1)*v = (int)(arg0i + arg1f); }                 // Add (use "+-" to subtract)
		else if (op == '*') { if (sscanf(buf, "%f", &arg1f) == 1)*v = (int)(arg0i * arg1f); }                 // Multiply
		else if (op == '/') { if (sscanf(buf, "%f", &arg1f) == 1 && arg1f != 0.0f)*v = (int)(arg0i / arg1f); }// Divide
		else { if (sscanf(buf, scalar_format, &arg0i) == 1)*v = arg0i; }                       // Assign integer constant
	}
	else if (data_type == ImGuiDataType_Float)
	{
		// For floats we have to ignore format with precision (e.g. "%.2f") because sscanf doesn't take them in
		scalar_format = "%f";
		float* v = (float*)data_ptr;
		float arg0f = *v, arg1f = 0.0f;
		if (op && sscanf(initial_value_buf, scalar_format, &arg0f) < 1)
			return false;
		if (sscanf(buf, scalar_format, &arg1f) < 1)
			return false;
		if (op == '+') { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)
		else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply
		else if (op == '/') { if (arg1f != 0.0f)*v = arg0f / arg1f; } // Divide
		else { *v = arg1f; }                            // Assign constant
	}
	else if (data_type == ImGuiDataType_Double)
	{
		scalar_format = "%lf";
		double* v = (double*)data_ptr;
		double arg0f = *v, arg1f = 0.0f;
		if (op && sscanf(initial_value_buf, scalar_format, &arg0f) < 1)
			return false;
		if (sscanf(buf, scalar_format, &arg1f) < 1)
			return false;
		if (op == '+') { *v = arg0f + arg1f; }                    // Add (use "+-" to subtract)
		else if (op == '*') { *v = arg0f * arg1f; }                    // Multiply
		else if (op == '/') { if (arg1f != 0.0f)*v = arg0f / arg1f; } // Divide
		else { *v = arg1f; }                            // Assign constant
	}
	return memcmp(data_backup, data_ptr, GDataTypeSize[data_type]) != 0;
}

// Create text input in place of a slider (when CTRL+Clicking on slider)
// FIXME: Logic is messy and confusing.
bool ImGui::InputScalarAsWidgetReplacement(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();

	// Our replacement widget will override the focus ID (registered previously to allow for a TAB focus to happen)
	// On the first frame, g.ScalarAsInputTextId == 0, then on subsequent frames it becomes == id
	SetActiveID(g.ScalarAsInputTextId, window);
	g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
	SetHoveredID(0);
	FocusableItemUnregister(window);

	char buf[32];
	DataTypeFormatString(data_type, data_ptr, decimal_precision, buf, IM_ARRAYSIZE(buf));
	bool text_value_changed = InputTextEx(label, buf, IM_ARRAYSIZE(buf), aabb.GetSize(), ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_AutoSelectAll);
	if (g.ScalarAsInputTextId == 0)     // First frame we started displaying the InputText widget
	{
		IM_ASSERT(g.ActiveId == id);    // InputText ID expected to match the Slider ID (else we'd need to store them both, which is also possible)
		g.ScalarAsInputTextId = g.ActiveId;
		SetHoveredID(id);
	}
	if (text_value_changed)
		return DataTypeApplyOpFromText(buf, GImGui->InputTextState.InitialText.begin(), data_type, data_ptr, NULL);
	return false;
}

// Parse display precision back from the display format string
int ImGui::ParseFormatPrecision(const char* fmt, int default_precision)
{
	int precision = default_precision;
	while ((fmt = strchr(fmt, '%')) != NULL)
	{
		fmt++;
		if (fmt[0] == '%') { fmt++; continue; } // Ignore "%%"
		while (*fmt >= '0' && *fmt <= '9')
			fmt++;
		if (*fmt == '.')
		{
			fmt = ImAtoi(fmt + 1, &precision);
			if (precision < 0 || precision > 10)
				precision = default_precision;
		}
		if (*fmt == 'e' || *fmt == 'E') // Maximum precision with scientific notation
			precision = -1;
		break;
	}
	return precision;
}

static float GetMinimumStepAtDecimalPrecision(int decimal_precision)
{
	static const float min_steps[10] = { 1.0f, 0.1f, 0.01f, 0.001f, 0.0001f, 0.00001f, 0.000001f, 0.0000001f, 0.00000001f, 0.000000001f };
	return (decimal_precision >= 0 && decimal_precision < 10) ? min_steps[decimal_precision] : powf(10.0f, (float)-decimal_precision);
}

float ImGui::RoundScalar(float value, int decimal_precision)
{
	// Round past decimal precision
	// So when our value is 1.99999 with a precision of 0.001 we'll end up rounding to 2.0
	// FIXME: Investigate better rounding methods
	if (decimal_precision < 0)
		return value;
	const float min_step = GetMinimumStepAtDecimalPrecision(decimal_precision);
	bool negative = value < 0.0f;
	value = fabsf(value);
	float remainder = fmodf(value, min_step);
	if (remainder <= min_step * 0.5f)
		value -= remainder;
	else
		value += (min_step - remainder);
	return negative ? -value : value;
}

static inline float SliderBehaviorCalcRatioFromValue(float v, float v_min, float v_max, float power, float linear_zero_pos)
{
	if (v_min == v_max)
		return 0.0f;

	const bool is_non_linear = (power < 1.0f - 0.00001f) || (power > 1.0f + 0.00001f);
	const float v_clamped = (v_min < v_max) ? ImClamp(v, v_min, v_max) : ImClamp(v, v_max, v_min);
	if (is_non_linear)
	{
		if (v_clamped < 0.0f)
		{
			const float f = 1.0f - (v_clamped - v_min) / (ImMin(0.0f, v_max) - v_min);
			return (1.0f - powf(f, 1.0f / power)) * linear_zero_pos;
		}
		else
		{
			const float f = (v_clamped - ImMax(0.0f, v_min)) / (v_max - ImMax(0.0f, v_min));
			return linear_zero_pos + powf(f, 1.0f / power) * (1.0f - linear_zero_pos);
		}
	}

	// Linear slider
	return (v_clamped - v_min) / (v_max - v_min);
}

bool ImGui::SliderBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();
	const ImGuiStyle& style = g.Style;

	// Draw frame
	const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_SliderBgActive : g.HoveredId == id ? ImGuiCol_SliderBgHovered : ImGuiCol_SliderBg);
	RenderNavHighlight(frame_bb, id);
	RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

	const bool is_non_linear = (power < 1.0f - 0.00001f) || (power > 1.0f + 0.00001f);
	const bool is_horizontal = (flags & ImGuiSliderFlags_Vertical) == 0;

	const float grab_padding = 2.0f;
	const float slider_sz = is_horizontal ? (frame_bb.GetWidth() - grab_padding * 2.0f) : (frame_bb.GetHeight() - grab_padding * 2.0f);
	float grab_sz;
	if (decimal_precision != 0)
		grab_sz = ImMin(style.GrabMinSize, slider_sz);
	else
		grab_sz = ImMin(ImMax(1.0f * (slider_sz / ((v_min < v_max ? v_max - v_min : v_min - v_max) + 1.0f)), style.GrabMinSize), slider_sz);  // Integer sliders, if possible have the grab size represent 1 unit
	const float slider_usable_sz = slider_sz - grab_sz;
	const float slider_usable_pos_min = (is_horizontal ? frame_bb.Min.x : frame_bb.Min.y) + grab_padding + grab_sz * 0.5f;
	const float slider_usable_pos_max = (is_horizontal ? frame_bb.Max.x : frame_bb.Max.y) - grab_padding - grab_sz * 0.5f;

	// For logarithmic sliders that cross over sign boundary we want the exponential increase to be symmetric around 0.0f
	float linear_zero_pos = 0.0f;   // 0.0->1.0f
	if (v_min * v_max < 0.0f)
	{
		// Different sign
		const float linear_dist_min_to_0 = powf(fabsf(0.0f - v_min), 1.0f / power);
		const float linear_dist_max_to_0 = powf(fabsf(v_max - 0.0f), 1.0f / power);
		linear_zero_pos = linear_dist_min_to_0 / (linear_dist_min_to_0 + linear_dist_max_to_0);
	}
	else
	{
		// Same sign
		linear_zero_pos = v_min < 0.0f ? 1.0f : 0.0f;
	}

	// Process interacting with the slider
	bool value_changed = false;
	if (g.ActiveId == id)
	{
		bool set_new_value = false;
		float clicked_t = 0.0f;
		if (g.ActiveIdSource == ImGuiInputSource_Mouse)
		{
			if (!g.IO.MouseDown[0])
			{
				ClearActiveID();
			}
			else
			{
				const float mouse_abs_pos = is_horizontal ? g.IO.MousePos.x : g.IO.MousePos.y;
				clicked_t = (slider_usable_sz > 0.0f) ? ImClamp((mouse_abs_pos - slider_usable_pos_min) / slider_usable_sz, 0.0f, 1.0f) : 0.0f;
				if (!is_horizontal)
					clicked_t = 1.0f - clicked_t;
				set_new_value = true;
			}
		}
		else if (g.ActiveIdSource == ImGuiInputSource_Nav)
		{
			const ImVec2 delta2 = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 0.0f, 0.0f);
			float delta = is_horizontal ? delta2.x : -delta2.y;
			if (g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
			{
				ClearActiveID();
			}
			else if (delta != 0.0f)
			{
				clicked_t = SliderBehaviorCalcRatioFromValue(*v, v_min, v_max, power, linear_zero_pos);
				if (decimal_precision == 0 && !is_non_linear)
				{
					if (fabsf(v_max - v_min) <= 100.0f || IsNavInputDown(ImGuiNavInput_TweakSlow))
						delta = ((delta < 0.0f) ? -1.0f : +1.0f) / (v_max - v_min); // Gamepad/keyboard tweak speeds in integer steps
					else
						delta /= 100.0f;
				}
				else
				{
					delta /= 100.0f;    // Gamepad/keyboard tweak speeds in % of slider bounds
					if (IsNavInputDown(ImGuiNavInput_TweakSlow))
						delta /= 10.0f;
				}
				if (IsNavInputDown(ImGuiNavInput_TweakFast))
					delta *= 10.0f;
				set_new_value = true;
				if ((clicked_t >= 1.0f && delta > 0.0f) || (clicked_t <= 0.0f && delta < 0.0f)) // This is to avoid applying the saturation when already past the limits
					set_new_value = false;
				else
					clicked_t = ImSaturate(clicked_t + delta);
			}
		}

		if (set_new_value)
		{
			float new_value;
			if (is_non_linear)
			{
				// Account for logarithmic scale on both sides of the zero
				if (clicked_t < linear_zero_pos)
				{
					// Negative: rescale to the negative range before powering
					float a = 1.0f - (clicked_t / linear_zero_pos);
					a = powf(a, power);
					new_value = ImLerp(ImMin(v_max, 0.0f), v_min, a);
				}
				else
				{
					// Positive: rescale to the positive range before powering
					float a;
					if (fabsf(linear_zero_pos - 1.0f) > 1.e-6f)
						a = (clicked_t - linear_zero_pos) / (1.0f - linear_zero_pos);
					else
						a = clicked_t;
					a = powf(a, power);
					new_value = ImLerp(ImMax(v_min, 0.0f), v_max, a);
				}
			}
			else
			{
				// Linear slider
				new_value = ImLerp(v_min, v_max, clicked_t);
			}

			// Round past decimal precision
			new_value = RoundScalar(new_value, decimal_precision);
			if (*v != new_value)
			{
				*v = new_value;
				value_changed = true;
			}
		}
	}

	// Draw
	float grab_t = SliderBehaviorCalcRatioFromValue(*v, v_min, v_max, power, linear_zero_pos);
	if (!is_horizontal)
		grab_t = 1.0f - grab_t;
	const float grab_pos = ImLerp(slider_usable_pos_min, slider_usable_pos_max, grab_t);
	ImRect grab_bb;
	if (is_horizontal)
		grab_bb = ImRect(ImVec2(grab_pos - grab_sz * 0.5f, frame_bb.Min.y), ImVec2(grab_pos + grab_sz * 0.5f, frame_bb.Max.y));
	else
		grab_bb = ImRect(ImVec2(frame_bb.Min.x, grab_pos - grab_sz * 0.5f), ImVec2(frame_bb.Max.x, grab_pos + grab_sz * 0.5f));

	const auto grab_col = GetColorU32(g.ActiveId == id ? ImGuiCol_SliderGrabActive : ImGuiCol_SliderGrab);
	if (*v == v_max)
		window->DrawList->AddRectFilled(frame_bb.Min, frame_bb.Max, grab_col, style.FrameRounding);
	else
		window->DrawList->AddRectFilled(frame_bb.Min, grab_bb.Max, grab_col, style.GrabRounding);

	return value_changed;
}

// Use power!=1.0 for logarithmic sliders.
// Adjust display_format to decorate the value with a prefix or a suffix.
//   "%.3f"         1.234
//   "%5.2f secs"   01.23 secs
//   "Gold: %.0f"   Gold: 1
bool ImGui::SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format, float power)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const float w = CalcItemWidth();

	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	// NB- we don't call ItemSize() yet because we may turn into a text edit box below
	if (!ItemAdd(total_bb, id, &frame_bb))
	{
		ItemSize(total_bb, style.FramePadding.y);
		return false;
	}
	const bool hovered = ItemHoverable(frame_bb, id);

	if (!display_format)
		display_format = "%.3f";
	int decimal_precision = ParseFormatPrecision(display_format, 3);

	// Tabbing or CTRL-clicking on Slider turns it into an input box
	bool start_text_input = false;
	const bool tab_focus_requested = FocusableItemRegister(window, id);
	if (tab_focus_requested || (hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))
	{
		SetActiveID(id, window);
		SetFocusID(id, window);
		FocusWindow(window);
		g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
		if (tab_focus_requested || g.IO.KeyCtrl || g.NavInputId == id)
		{
			start_text_input = true;
			g.ScalarAsInputTextId = 0;
		}
	}
	if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))
		return InputScalarAsWidgetReplacement(frame_bb, label, ImGuiDataType_Float, v, id, decimal_precision);

	// Actual slider behavior + render grab
	ItemSize(total_bb, style.FramePadding.y);
	const bool value_changed = SliderBehavior(frame_bb, id, v, v_min, v_max, power, decimal_precision);

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	char value_buf[64];
	const char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);
	RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

	if (label_size.x > 0.0f)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	return value_changed;
}

bool ImGui::SliderFloatLeftAlignedCustom(const char* label, float* v, float v_min, float v_max, const char* display_format, float* v2)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const float w = CalcItemWidth();

	const ImVec2 label_size = CalcTextSize("label", NULL, true);
	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	// NB- we don't call ItemSize() yet because we may turn into a text edit box below
	if (!ItemAdd(total_bb, id, &frame_bb))
	{
		ItemSize(total_bb, style.FramePadding.y);
		return false;
	}
	const bool hovered = ItemHoverable(frame_bb, id);

	if (!display_format)
		display_format = "%.3f";
	int decimal_precision = ParseFormatPrecision(display_format, 3);

	// Tabbing or CTRL-clicking on Slider turns it into an input box
	bool start_text_input = false;
	const bool tab_focus_requested = FocusableItemRegister(window, id);
	if (tab_focus_requested || (hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))
	{
		SetActiveID(id, window);
		SetFocusID(id, window);
		FocusWindow(window);
		g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
		if (tab_focus_requested || g.IO.KeyCtrl || g.NavInputId == id)
		{
			start_text_input = true;
			g.ScalarAsInputTextId = 0;
		}
	}
	if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))
		return InputScalarAsWidgetReplacement(frame_bb, label, ImGuiDataType_Float, v, id, decimal_precision);

	// Actual slider behavior + render grab
	ItemSize(total_bb, style.FramePadding.y);
	const bool value_changed = SliderBehavior(frame_bb, id, v, v_min, v_max, 1.f, decimal_precision);

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	char value_buf[64];
	const char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v2);
	RenderTextClipped(frame_bb.Min, frame_bb.Max, label, NULL, NULL, ImVec2(0.05f, 0.5f));
	RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.95f, 0.5f));

	return value_changed;
}

bool ImGui::SliderFloatLeftAligned(const char* label, float* v, float v_min, float v_max, const char* display_format)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const float w = CalcItemWidth();

	const ImVec2 label_size = CalcTextSize("label", NULL, true);
	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	// NB- we don't call ItemSize() yet because we may turn into a text edit box below
	if (!ItemAdd(total_bb, id, &frame_bb))
	{
		ItemSize(total_bb, style.FramePadding.y);
		return false;
	}
	const bool hovered = ItemHoverable(frame_bb, id);

	if (!display_format)
		display_format = "%.3f";
	int decimal_precision = ParseFormatPrecision(display_format, 3);

	// Tabbing or CTRL-clicking on Slider turns it into an input box
	bool start_text_input = false;
	const bool tab_focus_requested = FocusableItemRegister(window, id);
	if (tab_focus_requested || (hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))
	{
		SetActiveID(id, window);
		SetFocusID(id, window);
		FocusWindow(window);
		g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
		if (tab_focus_requested || g.IO.KeyCtrl || g.NavInputId == id)
		{
			start_text_input = true;
			g.ScalarAsInputTextId = 0;
		}
	}
	if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))
		return InputScalarAsWidgetReplacement(frame_bb, label, ImGuiDataType_Float, v, id, decimal_precision);

	// Actual slider behavior + render grab
	ItemSize(total_bb, style.FramePadding.y);
	const bool value_changed = SliderBehavior(frame_bb, id, v, v_min, v_max, 1.f, decimal_precision);

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	char value_buf[64];
	const char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);
	RenderTextClipped(frame_bb.Min, frame_bb.Max, label, NULL, NULL, ImVec2(0.05f, 0.5f));
	RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.95f, 0.5f));

	return value_changed;
}

bool ImGui::VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format, float power)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);

	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);
	const ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	ItemSize(bb, style.FramePadding.y);
	if (!ItemAdd(frame_bb, id))
		return false;
	const bool hovered = ItemHoverable(frame_bb, id);

	if (!display_format)
		display_format = "%.3f";
	int decimal_precision = ParseFormatPrecision(display_format, 3);

	if ((hovered && g.IO.MouseClicked[0]) || g.NavActivateId == id || g.NavInputId == id)
	{
		SetActiveID(id, window);
		SetFocusID(id, window);
		FocusWindow(window);
		g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Left) | (1 << ImGuiDir_Right);
	}

	// Actual slider behavior + render grab
	bool value_changed = SliderBehavior(frame_bb, id, v, v_min, v_max, power, decimal_precision, ImGuiSliderFlags_Vertical);

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	// For the vertical slider we allow centered text to overlap the frame padding
	char value_buf[64];
	char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);
	RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.0f));
	if (label_size.x > 0.0f)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	return value_changed;
}

bool ImGui::SliderAngle(const char* label, float* v_rad, float v_degrees_min, float v_degrees_max)
{
	float v_deg = (*v_rad) * 360.0f / (2 * IM_PI);
	bool value_changed = SliderFloat(label, &v_deg, v_degrees_min, v_degrees_max, "%.0f deg", 1.0f);
	*v_rad = v_deg * (2 * IM_PI) / 360.0f;
	return value_changed;
}

bool ImGui::SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format)
{
	if (!display_format)
		display_format = "%.0f";
	float v_f = (float)*v;
	bool value_changed = SliderFloat(label, &v_f, (float)v_min, (float)v_max, display_format, 1.0f);
	*v = (int)v_f;
	return value_changed;
}

bool ImGui::SliderIntLeftAligned(const char* label, int* v, int v_min, int v_max, const char* display_format)
{
	if (!display_format)
		display_format = "%.0f";
	float v_f = (float)*v;
	bool value_changed = SliderFloatLeftAligned(label, &v_f, (float)v_min, (float)v_max, display_format);
	*v = (int)v_f;
	return value_changed;
}

bool ImGui::VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format)
{
	if (!display_format)
		display_format = "%.0f";
	float v_f = (float)*v;
	bool value_changed = VSliderFloat(label, size, &v_f, (float)v_min, (float)v_max, display_format, 1.0f);
	*v = (int)v_f;
	return value_changed;
}

// Add multiple sliders on 1 line for compact edition of multiple components
bool ImGui::SliderFloatN(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	bool value_changed = false;
	BeginGroup();
	PushID(label);
	PushMultiItemsWidths(components);
	for (int i = 0; i < components; i++)
	{
		PushID(i);
		value_changed |= SliderFloat("##v", &v[i], v_min, v_max, display_format, power);
		SameLine(0, g.Style.ItemInnerSpacing.x);
		PopID();
		PopItemWidth();
	}
	PopID();

	TextUnformatted(label, FindRenderedTextEnd(label));
	EndGroup();

	return value_changed;
}

bool ImGui::SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format, float power)
{
	return SliderFloatN(label, v, 2, v_min, v_max, display_format, power);
}

bool ImGui::SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format, float power)
{
	return SliderFloatN(label, v, 3, v_min, v_max, display_format, power);
}

bool ImGui::SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format, float power)
{
	return SliderFloatN(label, v, 4, v_min, v_max, display_format, power);
}

bool ImGui::SliderIntN(const char* label, int* v, int components, int v_min, int v_max, const char* display_format)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	bool value_changed = false;
	BeginGroup();
	PushID(label);
	PushMultiItemsWidths(components);
	for (int i = 0; i < components; i++)
	{
		PushID(i);
		value_changed |= SliderInt("##v", &v[i], v_min, v_max, display_format);
		SameLine(0, g.Style.ItemInnerSpacing.x);
		PopID();
		PopItemWidth();
	}
	PopID();

	TextUnformatted(label, FindRenderedTextEnd(label));
	EndGroup();

	return value_changed;
}

bool ImGui::SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format)
{
	return SliderIntN(label, v, 2, v_min, v_max, display_format);
}

bool ImGui::SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format)
{
	return SliderIntN(label, v, 3, v_min, v_max, display_format);
}

bool ImGui::SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format)
{
	return SliderIntN(label, v, 4, v_min, v_max, display_format);
}

bool ImGui::DragBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power)
{
	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;

	// Draw frame
	const ImU32 frame_col = GetColorU32(g.ActiveId == id ? ImGuiCol_FrameBgActive : g.HoveredId == id ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
	RenderNavHighlight(frame_bb, id);
	RenderFrame(frame_bb.Min, frame_bb.Max, frame_col, true, style.FrameRounding);

	bool value_changed = false;

	// Process interacting with the drag
	if (g.ActiveId == id)
	{
		if (g.ActiveIdSource == ImGuiInputSource_Mouse && !g.IO.MouseDown[0])
			ClearActiveID();
		else if (g.ActiveIdSource == ImGuiInputSource_Nav && g.NavActivatePressedId == id && !g.ActiveIdIsJustActivated)
			ClearActiveID();
	}
	if (g.ActiveId == id)
	{
		if (g.ActiveIdIsJustActivated)
		{
			// Lock current value on click
			g.DragCurrentValue = *v;
			g.DragLastMouseDelta = ImVec2(0.f, 0.f);
		}

		if (v_speed == 0.0f && (v_max - v_min) != 0.0f && (v_max - v_min) < FLT_MAX)
			v_speed = (v_max - v_min) * g.DragSpeedDefaultRatio;

		float v_cur = g.DragCurrentValue;
		const ImVec2 mouse_drag_delta = GetMouseDragDelta(0, 1.0f);
		float adjust_delta = 0.0f;
		if (g.ActiveIdSource == ImGuiInputSource_Mouse && IsMousePosValid())
		{
			adjust_delta = mouse_drag_delta.x - g.DragLastMouseDelta.x;
			if (g.IO.KeyShift && g.DragSpeedScaleFast >= 0.0f)
				adjust_delta *= g.DragSpeedScaleFast;
			if (g.IO.KeyAlt && g.DragSpeedScaleSlow >= 0.0f)
				adjust_delta *= g.DragSpeedScaleSlow;
			g.DragLastMouseDelta.x = mouse_drag_delta.x;
		}
		if (g.ActiveIdSource == ImGuiInputSource_Nav)
		{
			adjust_delta = GetNavInputAmount2d(ImGuiNavDirSourceFlags_Keyboard | ImGuiNavDirSourceFlags_PadDPad, ImGuiInputReadMode_RepeatFast, 1.0f / 10.0f, 10.0f).x;
			if (v_min < v_max && ((v_cur >= v_max && adjust_delta > 0.0f) || (v_cur <= v_min && adjust_delta < 0.0f))) // This is to avoid applying the saturation when already past the limits
				adjust_delta = 0.0f;
			v_speed = ImMax(v_speed, GetMinimumStepAtDecimalPrecision(decimal_precision));
		}
		adjust_delta *= v_speed;

		if (fabsf(adjust_delta) > 0.0f)
		{
			if (fabsf(power - 1.0f) > 0.001f)
			{
				// Logarithmic curve on both side of 0.0
				float v0_abs = v_cur >= 0.0f ? v_cur : -v_cur;
				float v0_sign = v_cur >= 0.0f ? 1.0f : -1.0f;
				float v1 = powf(v0_abs, 1.0f / power) + (adjust_delta * v0_sign);
				float v1_abs = v1 >= 0.0f ? v1 : -v1;
				float v1_sign = v1 >= 0.0f ? 1.0f : -1.0f;          // Crossed sign line
				v_cur = powf(v1_abs, power) * v0_sign * v1_sign;    // Reapply sign
			}
			else
			{
				v_cur += adjust_delta;
			}

			// Clamp
			if (v_min < v_max)
				v_cur = ImClamp(v_cur, v_min, v_max);
			g.DragCurrentValue = v_cur;
		}

		// Round to user desired precision, then apply
		v_cur = RoundScalar(v_cur, decimal_precision);
		if (*v != v_cur)
		{
			*v = v_cur;
			value_changed = true;
		}
	}

	return value_changed;
}

bool ImGui::DragFloat(const char* label, float* v, float v_speed, float v_min, float v_max, const char* display_format, float power)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const float w = CalcItemWidth();

	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
	const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);
	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));

	// NB- we don't call ItemSize() yet because we may turn into a text edit box below
	if (!ItemAdd(total_bb, id, &frame_bb))
	{
		ItemSize(total_bb, style.FramePadding.y);
		return false;
	}
	const bool hovered = ItemHoverable(frame_bb, id);

	if (!display_format)
		display_format = "%.3f";
	int decimal_precision = ParseFormatPrecision(display_format, 3);

	// Tabbing or CTRL-clicking on Drag turns it into an input box
	bool start_text_input = false;
	const bool tab_focus_requested = FocusableItemRegister(window, id);
	if (tab_focus_requested || (hovered && (g.IO.MouseClicked[0] || g.IO.MouseDoubleClicked[0])) || g.NavActivateId == id || (g.NavInputId == id && g.ScalarAsInputTextId != id))
	{
		SetActiveID(id, window);
		SetFocusID(id, window);
		FocusWindow(window);
		g.ActiveIdAllowNavDirFlags = (1 << ImGuiDir_Up) | (1 << ImGuiDir_Down);
		if (tab_focus_requested || g.IO.KeyCtrl || g.IO.MouseDoubleClicked[0] || g.NavInputId == id)
		{
			start_text_input = true;
			g.ScalarAsInputTextId = 0;
		}
	}
	if (start_text_input || (g.ActiveId == id && g.ScalarAsInputTextId == id))
		return InputScalarAsWidgetReplacement(frame_bb, label, ImGuiDataType_Float, v, id, decimal_precision);

	// Actual drag behavior
	ItemSize(total_bb, style.FramePadding.y);
	const bool value_changed = DragBehavior(frame_bb, id, v, v_speed, v_min, v_max, decimal_precision, power);

	// Display value using user-provided display format so user can add prefix/suffix/decorations to the value.
	char value_buf[64];
	const char* value_buf_end = value_buf + ImFormatString(value_buf, IM_ARRAYSIZE(value_buf), display_format, *v);
	RenderTextClipped(frame_bb.Min, frame_bb.Max, value_buf, value_buf_end, NULL, ImVec2(0.5f, 0.5f));

	if (label_size.x > 0.0f)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);

	return value_changed;
}

bool ImGui::DragFloatN(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	bool value_changed = false;
	BeginGroup();
	PushID(label);
	PushMultiItemsWidths(components);
	for (int i = 0; i < components; i++)
	{
		PushID(i);
		value_changed |= DragFloat("##v", &v[i], v_speed, v_min, v_max, display_format, power);
		SameLine(0, g.Style.ItemInnerSpacing.x);
		PopID();
		PopItemWidth();
	}
	PopID();

	TextUnformatted(label, FindRenderedTextEnd(label));
	EndGroup();

	return value_changed;
}

bool ImGui::DragFloat2(const char* label, float v[2], float v_speed, float v_min, float v_max, const char* display_format, float power)
{
	return DragFloatN(label, v, 2, v_speed, v_min, v_max, display_format, power);
}

bool ImGui::DragFloat3(const char* label, float v[3], float v_speed, float v_min, float v_max, const char* display_format, float power)
{
	return DragFloatN(label, v, 3, v_speed, v_min, v_max, display_format, power);
}

bool ImGui::DragFloat4(const char* label, float v[4], float v_speed, float v_min, float v_max, const char* display_format, float power)
{
	return DragFloatN(label, v, 4, v_speed, v_min, v_max, display_format, power);
}

bool ImGui::DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, const char* display_format, const char* display_format_max, float power)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	PushID(label);
	BeginGroup();
	PushMultiItemsWidths(2);

	bool value_changed = DragFloat("##min", v_current_min, v_speed, (v_min >= v_max) ? -FLT_MAX : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), display_format, power);
	PopItemWidth();
	SameLine(0, g.Style.ItemInnerSpacing.x);
	value_changed |= DragFloat("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? FLT_MAX : v_max, display_format_max ? display_format_max : display_format, power);
	PopItemWidth();
	SameLine(0, g.Style.ItemInnerSpacing.x);

	TextUnformatted(label, FindRenderedTextEnd(label));
	EndGroup();
	PopID();

	return value_changed;
}

// NB: v_speed is float to allow adjusting the drag speed with more precision
bool ImGui::DragInt(const char* label, int* v, float v_speed, int v_min, int v_max, const char* display_format)
{
	if (!display_format)
		display_format = "%.0f";
	float v_f = (float)*v;
	bool value_changed = DragFloat(label, &v_f, v_speed, (float)v_min, (float)v_max, display_format);
	*v = (int)v_f;
	return value_changed;
}

bool ImGui::DragIntN(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	bool value_changed = false;
	BeginGroup();
	PushID(label);
	PushMultiItemsWidths(components);
	for (int i = 0; i < components; i++)
	{
		PushID(i);
		value_changed |= DragInt("##v", &v[i], v_speed, v_min, v_max, display_format);
		SameLine(0, g.Style.ItemInnerSpacing.x);
		PopID();
		PopItemWidth();
	}
	PopID();

	TextUnformatted(label, FindRenderedTextEnd(label));
	EndGroup();

	return value_changed;
}

bool ImGui::DragInt2(const char* label, int v[2], float v_speed, int v_min, int v_max, const char* display_format)
{
	return DragIntN(label, v, 2, v_speed, v_min, v_max, display_format);
}

bool ImGui::DragInt3(const char* label, int v[3], float v_speed, int v_min, int v_max, const char* display_format)
{
	return DragIntN(label, v, 3, v_speed, v_min, v_max, display_format);
}

bool ImGui::DragInt4(const char* label, int v[4], float v_speed, int v_min, int v_max, const char* display_format)
{
	return DragIntN(label, v, 4, v_speed, v_min, v_max, display_format);
}

bool ImGui::DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, const char* display_format, const char* display_format_max)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	PushID(label);
	BeginGroup();
	PushMultiItemsWidths(2);

	bool value_changed = DragInt("##min", v_current_min, v_speed, (v_min >= v_max) ? INT_MIN : v_min, (v_min >= v_max) ? *v_current_max : ImMin(v_max, *v_current_max), display_format);
	PopItemWidth();
	SameLine(0, g.Style.ItemInnerSpacing.x);
	value_changed |= DragInt("##max", v_current_max, v_speed, (v_min >= v_max) ? *v_current_min : ImMax(v_min, *v_current_min), (v_min >= v_max) ? INT_MAX : v_max, display_format_max ? display_format_max : display_format);
	PopItemWidth();
	SameLine(0, g.Style.ItemInnerSpacing.x);

	TextUnformatted(label, FindRenderedTextEnd(label));
	EndGroup();
	PopID();

	return value_changed;
}

void ImGui::PlotEx(ImGuiPlotType plot_type, const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;

	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	if (graph_size.x == 0.0f)
		graph_size.x = CalcItemWidth();
	if (graph_size.y == 0.0f)
		graph_size.y = label_size.y + (style.FramePadding.y * 2);

	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(graph_size.x, graph_size.y));
	const ImRect inner_bb(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding);
	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0));
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, 0, &frame_bb))
		return;
	const bool hovered = ItemHoverable(inner_bb, 0);

	// Determine scale from values if not specified
	if (scale_min == FLT_MAX || scale_max == FLT_MAX)
	{
		float v_min = FLT_MAX;
		float v_max = -FLT_MAX;
		for (int i = 0; i < values_count; i++)
		{
			const float v = values_getter(data, i);
			v_min = ImMin(v_min, v);
			v_max = ImMax(v_max, v);
		}
		if (scale_min == FLT_MAX)
			scale_min = v_min;
		if (scale_max == FLT_MAX)
			scale_max = v_max;
	}

	RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

	if (values_count > 0)
	{
		int res_w = ImMin((int)graph_size.x, values_count) + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);
		int item_count = values_count + ((plot_type == ImGuiPlotType_Lines) ? -1 : 0);

		// Tooltip on hover
		int v_hovered = -1;
		if (hovered)
		{
			const float t = ImClamp((g.IO.MousePos.x - inner_bb.Min.x) / (inner_bb.Max.x - inner_bb.Min.x), 0.0f, 0.9999f);
			const int v_idx = (int)(t * item_count);
			IM_ASSERT(v_idx >= 0 && v_idx < values_count);

			const float v0 = values_getter(data, (v_idx + values_offset) % values_count);
			const float v1 = values_getter(data, (v_idx + 1 + values_offset) % values_count);
			if (plot_type == ImGuiPlotType_Lines)
				SetTooltip("%d: %8.4g\n%d: %8.4g", v_idx, v0, v_idx + 1, v1);
			else if (plot_type == ImGuiPlotType_Histogram)
				SetTooltip("%d: %8.4g", v_idx, v0);
			v_hovered = v_idx;
		}

		const float t_step = 1.0f / (float)res_w;
		const float inv_scale = (scale_min == scale_max) ? 0.0f : (1.0f / (scale_max - scale_min));

		float v0 = values_getter(data, (0 + values_offset) % values_count);
		float t0 = 0.0f;
		ImVec2 tp0 = ImVec2(t0, 1.0f - ImSaturate((v0 - scale_min) * inv_scale));                       // Point in the normalized space of our target rectangle
		float histogram_zero_line_t = (scale_min * scale_max < 0.0f) ? (-scale_min * inv_scale) : (scale_min < 0.0f ? 0.0f : 1.0f);   // Where does the zero line stands

		const ImU32 col_base = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLines : ImGuiCol_PlotHistogram);
		const ImU32 col_hovered = GetColorU32((plot_type == ImGuiPlotType_Lines) ? ImGuiCol_PlotLinesHovered : ImGuiCol_PlotHistogramHovered);

		for (int n = 0; n < res_w; n++)
		{
			const float t1 = t0 + t_step;
			const int v1_idx = (int)(t0 * item_count + 0.5f);
			IM_ASSERT(v1_idx >= 0 && v1_idx < values_count);
			const float v1 = values_getter(data, (v1_idx + values_offset + 1) % values_count);
			const ImVec2 tp1 = ImVec2(t1, 1.0f - ImSaturate((v1 - scale_min) * inv_scale));

			// NB: Draw calls are merged together by the DrawList system. Still, we should render our batch are lower level to save a bit of CPU.
			ImVec2 pos0 = ImLerp(inner_bb.Min, inner_bb.Max, tp0);
			ImVec2 pos1 = ImLerp(inner_bb.Min, inner_bb.Max, (plot_type == ImGuiPlotType_Lines) ? tp1 : ImVec2(tp1.x, histogram_zero_line_t));
			if (plot_type == ImGuiPlotType_Lines)
			{
				window->DrawList->AddLine(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);
			}
			else if (plot_type == ImGuiPlotType_Histogram)
			{
				if (pos1.x >= pos0.x + 2.0f)
					pos1.x -= 1.0f;
				window->DrawList->AddRectFilled(pos0, pos1, v_hovered == v1_idx ? col_hovered : col_base);
			}

			t0 = t1;
			tp0 = tp1;
		}
	}

	// Text overlay
	if (overlay_text)
		RenderTextClipped(ImVec2(frame_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), frame_bb.Max, overlay_text, NULL, NULL, ImVec2(0.5f, 0.0f));

	if (label_size.x > 0.0f)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, inner_bb.Min.y), label);
}

struct ImGuiPlotArrayGetterData
{
	const float* Values;
	int Stride;

	ImGuiPlotArrayGetterData(const float* values, int stride) { Values = values; Stride = stride; }
};

static float Plot_ArrayGetter(void* data, int idx)
{
	ImGuiPlotArrayGetterData* plot_data = (ImGuiPlotArrayGetterData*)data;
	const float v = *(const float*)(const void*)((const unsigned char*)plot_data->Values + (size_t)idx * plot_data->Stride);
	return v;
}

void ImGui::PlotLines(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
{
	ImGuiPlotArrayGetterData data(values, stride);
	PlotEx(ImGuiPlotType_Lines, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
	PlotEx(ImGuiPlotType_Lines, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotHistogram(const char* label, const float* values, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size, int stride)
{
	ImGuiPlotArrayGetterData data(values, stride);
	PlotEx(ImGuiPlotType_Histogram, label, &Plot_ArrayGetter, (void*)&data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

void ImGui::PlotHistogram(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size)
{
	PlotEx(ImGuiPlotType_Histogram, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);
}

// size_arg (for each axis) < 0.0f: align to end, 0.0f: auto, > 0.0f: specified size
void ImGui::ProgressBar(float fraction, const ImVec2& size_arg, const char* overlay)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;

	ImVec2 pos = window->DC.CursorPos;
	ImRect bb(pos, pos + CalcItemSize(size_arg, CalcItemWidth(), g.FontSize + style.FramePadding.y * 2.0f));
	ItemSize(bb, style.FramePadding.y);
	if (!ItemAdd(bb, 0))
		return;

	// Render
	fraction = ImSaturate(fraction);
	RenderFrame(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);
	bb.Expand(ImVec2(-style.FrameBorderSize, -style.FrameBorderSize));
	const ImVec2 fill_br = ImVec2(ImLerp(bb.Min.x, bb.Max.x, fraction), bb.Max.y);
	RenderRectFilledRangeH(window->DrawList, bb, GetColorU32(ImGuiCol_PlotHistogram), 0.0f, fraction, style.FrameRounding);

	// Default displaying the fraction as percentage string, but user can override it
	char overlay_buf[32];
	if (!overlay)
	{
		ImFormatString(overlay_buf, IM_ARRAYSIZE(overlay_buf), "%.0f%%", fraction * 100 + 0.01f);
		overlay = overlay_buf;
	}

	ImVec2 overlay_size = CalcTextSize(overlay, NULL);
	if (overlay_size.x > 0.0f)
		RenderTextClipped(ImVec2(ImClamp(fill_br.x + style.ItemSpacing.x, bb.Min.x, bb.Max.x - overlay_size.x - style.ItemInnerSpacing.x), bb.Min.y), bb.Max, overlay, NULL, &overlay_size, ImVec2(0.0f, 0.5f), &bb);
}

bool ImGui::Checkbox(const char* label, bool* v)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y * 2, label_size.y + style.FramePadding.y * 2)); // We want a square shape to we use Y twice
	ItemSize(check_bb, style.FramePadding.y);

	ImRect total_bb = check_bb;
	if (label_size.x > 0)
		SameLine(0, style.ItemInnerSpacing.x);
	const ImRect text_bb(window->DC.CursorPos + ImVec2(0, style.FramePadding.y), window->DC.CursorPos + ImVec2(0, style.FramePadding.y) + label_size);
	if (label_size.x > 0)
	{
		ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);
		total_bb = ImRect(ImMin(check_bb.Min, text_bb.Min), ImMax(check_bb.Max, text_bb.Max));
	}

	if (!ItemAdd(total_bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);
	if (pressed)
		*v = !(*v);

	RenderNavHighlight(total_bb, id);
	RenderFrame(check_bb.Min, check_bb.Max, GetColorU32((held && hovered) ? ImGuiCol_CheckBgActive : hovered ? ImGuiCol_CheckBgHovered : ImGuiCol_CheckBg), true, style.FrameRounding);
	if (*v)
	{
		const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());
		const float pad = ImMax(1.0f, (float)(int)(check_sz / 6.0f));
		window->DrawList->AddRectFilled(
			{ check_bb.Min.x, check_bb.Min.y },
			{ check_bb.Max.x, check_bb.Max.y },
			GetColorU32(ImGuiCol_CheckMark),
			2.f
		);

		//RenderCheckMark(check_bb.Min + ImVec2(pad, pad), GetColorU32(ImGuiCol_CheckMark), check_bb.GetWidth() - pad * 2.0f);
	}

	if (g.LogEnabled)
		LogRenderedText(&text_bb.Min, *v ? "[x]" : "[ ]");
	if (label_size.x > 0.0f)
		RenderText(text_bb.Min, label);

	return pressed;
}

bool ImGui::CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value)
{
	bool v = ((*flags & flags_value) == flags_value);
	bool pressed = Checkbox(label, &v);
	if (pressed)
	{
		if (v)
			*flags |= flags_value;
		else
			*flags &= ~flags_value;
	}

	return pressed;
}

bool ImGui::RadioButton(const char* label, bool active)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	const ImRect check_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(label_size.y + style.FramePadding.y * 2 - 1, label_size.y + style.FramePadding.y * 2 - 1));
	ItemSize(check_bb, style.FramePadding.y);

	ImRect total_bb = check_bb;
	if (label_size.x > 0)
		SameLine(0, style.ItemInnerSpacing.x);
	const ImRect text_bb(window->DC.CursorPos + ImVec2(0, style.FramePadding.y), window->DC.CursorPos + ImVec2(0, style.FramePadding.y) + label_size);
	if (label_size.x > 0)
	{
		ItemSize(ImVec2(text_bb.GetWidth(), check_bb.GetHeight()), style.FramePadding.y);
		total_bb.Add(text_bb);
	}

	if (!ItemAdd(total_bb, id))
		return false;

	ImVec2 center = check_bb.GetCenter();
	center.x = (float)(int)center.x + 0.5f;
	center.y = (float)(int)center.y + 0.5f;
	const float radius = check_bb.GetHeight() * 0.5f;

	bool hovered, held;
	bool pressed = ButtonBehavior(total_bb, id, &hovered, &held);

	RenderNavHighlight(total_bb, id);
	window->DrawList->AddCircleFilled(center, radius, GetColorU32((held && hovered) ? ImGuiCol_FrameBgActive : hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg), 16);
	if (active)
	{
		const float check_sz = ImMin(check_bb.GetWidth(), check_bb.GetHeight());
		const float pad = ImMax(1.0f, (float)(int)(check_sz / 6.0f));
		window->DrawList->AddCircleFilled(center, radius - pad, GetColorU32(ImGuiCol_CheckMark), 16);
	}

	if (style.FrameBorderSize > 0.0f)
	{
		window->DrawList->AddCircle(center + ImVec2(1, 1), radius, GetColorU32(ImGuiCol_BorderShadow), 16, style.FrameBorderSize);
		window->DrawList->AddCircle(center, radius, GetColorU32(ImGuiCol_Border), 16, style.FrameBorderSize);
	}

	if (g.LogEnabled)
		LogRenderedText(&text_bb.Min, active ? "(x)" : "( )");
	if (label_size.x > 0.0f)
		RenderText(text_bb.Min, label);

	return pressed;
}

bool ImGui::RadioButton(const char* label, int* v, int v_button)
{
	const bool pressed = RadioButton(label, *v == v_button);
	if (pressed)
	{
		*v = v_button;
	}
	return pressed;
}

static int InputTextCalcTextLenAndLineCount(const char* text_begin, const char** out_text_end)
{
	int line_count = 0;
	const char* s = text_begin;
	while (char c = *s++) // We are only matching for \n so we can ignore UTF-8 decoding
		if (c == '\n')
			line_count++;
	s--;
	if (s[0] != '\n' && s[0] != '\r')
		line_count++;
	*out_text_end = s;
	return line_count;
}

static ImVec2 InputTextCalcTextSizeW(const ImWchar* text_begin, const ImWchar* text_end, const ImWchar** remaining, ImVec2* out_offset, bool stop_on_new_line)
{
	ImFont* font = GImGui->Font;
	const float line_height = GImGui->FontSize;
	const float scale = line_height / font->FontSize;

	ImVec2 text_size = ImVec2(0, 0);
	float line_width = 0.0f;

	const ImWchar* s = text_begin;
	while (s < text_end)
	{
		unsigned int c = (unsigned int)(*s++);
		if (c == '\n')
		{
			text_size.x = ImMax(text_size.x, line_width);
			text_size.y += line_height;
			line_width = 0.0f;
			if (stop_on_new_line)
				break;
			continue;
		}
		if (c == '\r')
			continue;

		const float char_width = font->GetCharAdvance((unsigned short)c) * scale;
		line_width += char_width;
	}

	if (text_size.x < line_width)
		text_size.x = line_width;

	if (out_offset)
		*out_offset = ImVec2(line_width, text_size.y + line_height);  // offset allow for the possibility of sitting after a trailing \n

	if (line_width > 0 || text_size.y == 0.0f)                        // whereas size.y will ignore the trailing \n
		text_size.y += line_height;

	if (remaining)
		*remaining = s;

	return text_size;
}

// Wrapper for stb_textedit.h to edit text (our wrapper is for: statically sized buffer, single-line, wchar characters. InputText converts between UTF-8 and wchar)
namespace ImGuiStb
{
	static int     STB_TEXTEDIT_STRINGLEN(const STB_TEXTEDIT_STRING* obj) { return obj->CurLenW; }
	static ImWchar STB_TEXTEDIT_GETCHAR(const STB_TEXTEDIT_STRING* obj, int idx) { return obj->Text[idx]; }
	static float   STB_TEXTEDIT_GETWIDTH(STB_TEXTEDIT_STRING* obj, int line_start_idx, int char_idx) { ImWchar c = obj->Text[line_start_idx + char_idx]; if (c == '\n') return STB_TEXTEDIT_GETWIDTH_NEWLINE; return GImGui->Font->GetCharAdvance(c) * (GImGui->FontSize / GImGui->Font->FontSize); }
	static int     STB_TEXTEDIT_KEYTOTEXT(int key) { return key >= 0x10000 ? 0 : key; }
	static ImWchar STB_TEXTEDIT_NEWLINE = '\n';
	static void    STB_TEXTEDIT_LAYOUTROW(StbTexteditRow* r, STB_TEXTEDIT_STRING* obj, int line_start_idx)
	{
		const ImWchar* text = obj->Text.Data;
		const ImWchar* text_remaining = NULL;
		const ImVec2 size = InputTextCalcTextSizeW(text + line_start_idx, text + obj->CurLenW, &text_remaining, NULL, true);
		r->x0 = 0.0f;
		r->x1 = size.x;
		r->baseline_y_delta = size.y;
		r->ymin = 0.0f;
		r->ymax = size.y;
		r->num_chars = (int)(text_remaining - (text + line_start_idx));
	}

	static bool is_separator(unsigned int c) { return ImCharIsSpace(c) || c == ',' || c == ';' || c == '(' || c == ')' || c == '{' || c == '}' || c == '[' || c == ']' || c == '|'; }
	static int  is_word_boundary_from_right(STB_TEXTEDIT_STRING* obj, int idx) { return idx > 0 ? (is_separator(obj->Text[idx - 1]) && !is_separator(obj->Text[idx])) : 1; }
	static int  STB_TEXTEDIT_MOVEWORDLEFT_IMPL(STB_TEXTEDIT_STRING* obj, int idx) { idx--; while (idx >= 0 && !is_word_boundary_from_right(obj, idx)) idx--; return idx < 0 ? 0 : idx; }
#ifdef __APPLE__    // FIXME: Move setting to IO structure
	static int  is_word_boundary_from_left(STB_TEXTEDIT_STRING* obj, int idx) { return idx > 0 ? (!is_separator(obj->Text[idx - 1]) && is_separator(obj->Text[idx])) : 1; }
	static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx) { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_left(obj, idx)) idx++; return idx > len ? len : idx; }
#else
	static int  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL(STB_TEXTEDIT_STRING* obj, int idx) { idx++; int len = obj->CurLenW; while (idx < len && !is_word_boundary_from_right(obj, idx)) idx++; return idx > len ? len : idx; }
#endif
#define STB_TEXTEDIT_MOVEWORDLEFT   STB_TEXTEDIT_MOVEWORDLEFT_IMPL    // They need to be #define for stb_textedit.h
#define STB_TEXTEDIT_MOVEWORDRIGHT  STB_TEXTEDIT_MOVEWORDRIGHT_IMPL

	static void STB_TEXTEDIT_DELETECHARS(STB_TEXTEDIT_STRING* obj, int pos, int n)
	{
		ImWchar* dst = obj->Text.Data + pos;

		// We maintain our buffer length in both UTF-8 and wchar formats
		obj->CurLenA -= ImTextCountUtf8BytesFromStr(dst, dst + n);
		obj->CurLenW -= n;

		// Offset remaining text
		const ImWchar* src = obj->Text.Data + pos + n;
		while (ImWchar c = *src++)
			*dst++ = c;
		*dst = '\0';
	}

	static bool STB_TEXTEDIT_INSERTCHARS(STB_TEXTEDIT_STRING* obj, int pos, const ImWchar* new_text, int new_text_len)
	{
		const int text_len = obj->CurLenW;
		IM_ASSERT(pos <= text_len);
		if (new_text_len + text_len + 1 > obj->Text.Size)
			return false;

		const int new_text_len_utf8 = ImTextCountUtf8BytesFromStr(new_text, new_text + new_text_len);
		if (new_text_len_utf8 + obj->CurLenA + 1 > obj->BufSizeA)
			return false;

		ImWchar* text = obj->Text.Data;
		if (pos != text_len)
			memmove(text + pos + new_text_len, text + pos, (size_t)(text_len - pos) * sizeof(ImWchar));
		memcpy(text + pos, new_text, (size_t)new_text_len * sizeof(ImWchar));

		obj->CurLenW += new_text_len;
		obj->CurLenA += new_text_len_utf8;
		obj->Text[obj->CurLenW] = '\0';

		return true;
	}

	// We don't use an enum so we can build even with conflicting symbols (if another user of stb_textedit.h leak their STB_TEXTEDIT_K_* symbols)
#define STB_TEXTEDIT_K_LEFT         0x10000 // keyboard input to move cursor left
#define STB_TEXTEDIT_K_RIGHT        0x10001 // keyboard input to move cursor right
#define STB_TEXTEDIT_K_UP           0x10002 // keyboard input to move cursor up
#define STB_TEXTEDIT_K_DOWN         0x10003 // keyboard input to move cursor down
#define STB_TEXTEDIT_K_LINESTART    0x10004 // keyboard input to move cursor to start of line
#define STB_TEXTEDIT_K_LINEEND      0x10005 // keyboard input to move cursor to end of line
#define STB_TEXTEDIT_K_TEXTSTART    0x10006 // keyboard input to move cursor to start of text
#define STB_TEXTEDIT_K_TEXTEND      0x10007 // keyboard input to move cursor to end of text
#define STB_TEXTEDIT_K_DELETE       0x10008 // keyboard input to delete selection or character under cursor
#define STB_TEXTEDIT_K_BACKSPACE    0x10009 // keyboard input to delete selection or character left of cursor
#define STB_TEXTEDIT_K_UNDO         0x1000A // keyboard input to perform undo
#define STB_TEXTEDIT_K_REDO         0x1000B // keyboard input to perform redo
#define STB_TEXTEDIT_K_WORDLEFT     0x1000C // keyboard input to move cursor left one word
#define STB_TEXTEDIT_K_WORDRIGHT    0x1000D // keyboard input to move cursor right one word
#define STB_TEXTEDIT_K_SHIFT        0x20000

#define STB_TEXTEDIT_IMPLEMENTATION
#include "stb_textedit.h"
}

void ImGuiTextEditState::OnKeyPressed(int key)
{
	stb_textedit_key(this, &StbState, key);
	CursorFollow = true;
	CursorAnimReset();
}

// Public API to manipulate UTF-8 text
// We expose UTF-8 to the user (unlike the STB_TEXTEDIT_* functions which are manipulating wchar)
// FIXME: The existence of this rarely exercised code path is a bit of a nuisance.
void ImGuiTextEditCallbackData::DeleteChars(int pos, int bytes_count)
{
	IM_ASSERT(pos + bytes_count <= BufTextLen);
	char* dst = Buf + pos;
	const char* src = Buf + pos + bytes_count;
	while (char c = *src++)
		*dst++ = c;
	*dst = '\0';

	if (CursorPos + bytes_count >= pos)
		CursorPos -= bytes_count;
	else if (CursorPos >= pos)
		CursorPos = pos;
	SelectionStart = SelectionEnd = CursorPos;
	BufDirty = true;
	BufTextLen -= bytes_count;
}

void ImGuiTextEditCallbackData::InsertChars(int pos, const char* new_text, const char* new_text_end)
{
	const int new_text_len = new_text_end ? (int)(new_text_end - new_text) : (int)strlen(new_text);
	if (new_text_len + BufTextLen + 1 >= BufSize)
		return;

	if (BufTextLen != pos)
		memmove(Buf + pos + new_text_len, Buf + pos, (size_t)(BufTextLen - pos));
	memcpy(Buf + pos, new_text, (size_t)new_text_len * sizeof(char));
	Buf[BufTextLen + new_text_len] = '\0';

	if (CursorPos >= pos)
		CursorPos += new_text_len;
	SelectionStart = SelectionEnd = CursorPos;
	BufDirty = true;
	BufTextLen += new_text_len;
}

// Return false to discard a character.
static bool InputTextFilterCharacter(unsigned int* p_char, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
{
	unsigned int c = *p_char;

	if (c < 128 && c != ' ' && !isprint((int)(c & 0xFF)))
	{
		bool pass = false;
		pass |= (c == '\n' && (flags & ImGuiInputTextFlags_Multiline));
		pass |= (c == '\t' && (flags & ImGuiInputTextFlags_AllowTabInput));
		if (!pass)
			return false;
	}

	if (c >= 0xE000 && c <= 0xF8FF) // Filter private Unicode range. I don't imagine anybody would want to input them. GLFW on OSX seems to send private characters for special keys like arrow keys.
		return false;

	if (flags & (ImGuiInputTextFlags_CharsDecimal | ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase | ImGuiInputTextFlags_CharsNoBlank | ImGuiInputTextFlags_CharsScientific))
	{
		if (flags & ImGuiInputTextFlags_CharsDecimal)
			if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/'))
				return false;

		if (flags & ImGuiInputTextFlags_CharsScientific)
			if (!(c >= '0' && c <= '9') && (c != '.') && (c != '-') && (c != '+') && (c != '*') && (c != '/') && (c != 'e') && (c != 'E'))
				return false;

		if (flags & ImGuiInputTextFlags_CharsHexadecimal)
			if (!(c >= '0' && c <= '9') && !(c >= 'a' && c <= 'f') && !(c >= 'A' && c <= 'F'))
				return false;

		if (flags & ImGuiInputTextFlags_CharsUppercase)
			if (c >= 'a' && c <= 'z')
				*p_char = (c += (unsigned int)('A' - 'a'));

		if (flags & ImGuiInputTextFlags_CharsNoBlank)
			if (ImCharIsSpace(c))
				return false;
	}

	if (flags & ImGuiInputTextFlags_CallbackCharFilter)
	{
		ImGuiTextEditCallbackData callback_data;
		memset(&callback_data, 0, sizeof(ImGuiTextEditCallbackData));
		callback_data.EventFlag = ImGuiInputTextFlags_CallbackCharFilter;
		callback_data.EventChar = (ImWchar)c;
		callback_data.Flags = flags;
		callback_data.UserData = user_data;
		if (callback(&callback_data) != 0)
			return false;
		*p_char = callback_data.EventChar;
		if (!callback_data.EventChar)
			return false;
	}

	return true;
}

// Edit a string of text
// NB: when active, hold on a privately held copy of the text (and apply back to 'buf'). So changing 'buf' while active has no effect.
// FIXME: Rather messy function partly because we are doing UTF8 > u16 > UTF8 conversions on the go to more easily handle stb_textedit calls. Ideally we should stay in UTF-8 all the time. See https://github.com/nothings/stb/issues/188
bool ImGui::InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackHistory) && (flags & ImGuiInputTextFlags_Multiline))); // Can't use both together (they both use up/down keys)
	IM_ASSERT(!((flags & ImGuiInputTextFlags_CallbackCompletion) && (flags & ImGuiInputTextFlags_AllowTabInput))); // Can't use both together (they both use tab key)

	ImGuiContext& g = *GImGui;
	const ImGuiIO& io = g.IO;
	const ImGuiStyle& style = g.Style;

	const bool is_multiline = (flags & ImGuiInputTextFlags_Multiline) != 0;
	const bool is_editable = (flags & ImGuiInputTextFlags_ReadOnly) == 0;
	const bool is_password = (flags & ImGuiInputTextFlags_Password) != 0;
	const bool is_undoable = (flags & ImGuiInputTextFlags_NoUndoRedo) == 0;

	if (is_multiline) // Open group before calling GetID() because groups tracks id created during their spawn
		BeginGroup();
	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), (is_multiline ? GetTextLineHeight() * 8.0f : label_size.y) + style.FramePadding.y * 2.0f); // Arbitrary default of 8 lines high for multi-line
	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + size);
	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? (style.ItemInnerSpacing.x + label_size.x) : 0.0f, 0.0f));

	ImGuiWindow* draw_window = window;
	if (is_multiline)
	{
		ItemAdd(total_bb, id, &frame_bb);
		if (!BeginChildFrame(id, frame_bb.GetSize()))
		{
			EndChildFrame();
			EndGroup();
			return false;
		}
		draw_window = GetCurrentWindow();
		size.x -= draw_window->ScrollbarSizes.x;
	}
	else
	{
		ItemSize(total_bb, style.FramePadding.y);
		if (!ItemAdd(total_bb, id, &frame_bb))
			return false;
	}
	const bool hovered = ItemHoverable(frame_bb, id);
	if (hovered)
		g.MouseCursor = ImGuiMouseCursor_TextInput;

	// Password pushes a temporary font with only a fallback glyph
	if (is_password)
	{
		const ImFontGlyph* glyph = g.Font->FindGlyph('*');
		ImFont* password_font = &g.InputTextPasswordFont;
		password_font->FontSize = g.Font->FontSize;
		password_font->Scale = g.Font->Scale;
		password_font->DisplayOffset = g.Font->DisplayOffset;
		password_font->Ascent = g.Font->Ascent;
		password_font->Descent = g.Font->Descent;
		password_font->ContainerAtlas = g.Font->ContainerAtlas;
		password_font->FallbackGlyph = glyph;
		password_font->FallbackAdvanceX = glyph->AdvanceX;
		IM_ASSERT(password_font->Glyphs.empty() && password_font->IndexAdvanceX.empty() && password_font->IndexLookup.empty());
		PushFont(password_font);
	}

	// NB: we are only allowed to access 'edit_state' if we are the active widget.
	ImGuiTextEditState& edit_state = g.InputTextState;

	const bool focus_requested = FocusableItemRegister(window, id, (flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_AllowTabInput)) == 0);    // Using completion callback disable keyboard tabbing
	const bool focus_requested_by_code = focus_requested && (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent);
	const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;

	const bool user_clicked = hovered && io.MouseClicked[0];
	const bool user_scrolled = is_multiline && g.ActiveId == 0 && edit_state.Id == id && g.ActiveIdPreviousFrame == draw_window->GetIDNoKeepAlive("#SCROLLY");
	const bool user_nav_input_start = (g.ActiveId != id) && ((g.NavInputId == id) || (g.NavActivateId == id && g.NavInputSource == ImGuiInputSource_NavKeyboard));

	bool clear_active_id = false;

	bool select_all = (g.ActiveId != id) && ((flags & ImGuiInputTextFlags_AutoSelectAll) != 0 || user_nav_input_start) && (!is_multiline);
	if (focus_requested || user_clicked || user_scrolled || user_nav_input_start)
	{
		if (g.ActiveId != id)
		{
			// Start edition
			// Take a copy of the initial buffer value (both in original UTF-8 format and converted to wchar)
			// From the moment we focused we are ignoring the content of 'buf' (unless we are in read-only mode)
			const int prev_len_w = edit_state.CurLenW;
			edit_state.Text.resize(buf_size + 1);        // wchar count <= UTF-8 count. we use +1 to make sure that .Data isn't NULL so it doesn't crash.
			edit_state.InitialText.resize(buf_size + 1); // UTF-8. we use +1 to make sure that .Data isn't NULL so it doesn't crash.
			ImStrncpy(edit_state.InitialText.Data, buf, edit_state.InitialText.Size);
			const char* buf_end = NULL;
			edit_state.CurLenW = ImTextStrFromUtf8(edit_state.Text.Data, edit_state.Text.Size, buf, NULL, &buf_end);
			edit_state.CurLenA = (int)(buf_end - buf); // We can't get the result from ImFormatString() above because it is not UTF-8 aware. Here we'll cut off malformed UTF-8.
			edit_state.CursorAnimReset();

			// Preserve cursor position and undo/redo stack if we come back to same widget
			// FIXME: We should probably compare the whole buffer to be on the safety side. Comparing buf (utf8) and edit_state.Text (wchar).
			const bool recycle_state = (edit_state.Id == id) && (prev_len_w == edit_state.CurLenW);
			if (recycle_state)
			{
				// Recycle existing cursor/selection/undo stack but clamp position
				// Note a single mouse click will override the cursor/position immediately by calling stb_textedit_click handler.
				edit_state.CursorClamp();
			}
			else
			{
				edit_state.Id = id;
				edit_state.ScrollX = 0.0f;
				stb_textedit_initialize_state(&edit_state.StbState, !is_multiline);
				if (!is_multiline && focus_requested_by_code)
					select_all = true;
			}
			if (flags & ImGuiInputTextFlags_AlwaysInsertMode)
				edit_state.StbState.insert_mode = true;
			if (!is_multiline && (focus_requested_by_tab || (user_clicked && io.KeyCtrl)))
				select_all = true;
		}
		SetActiveID(id, window);
		SetFocusID(id, window);
		FocusWindow(window);
		if (!is_multiline && !(flags & ImGuiInputTextFlags_CallbackHistory))
			g.ActiveIdAllowNavDirFlags |= ((1 << ImGuiDir_Up) | (1 << ImGuiDir_Down));
	}
	else if (io.MouseClicked[0])
	{
		// Release focus when we click outside
		clear_active_id = true;
	}

	bool value_changed = false;
	bool enter_pressed = false;

	if (g.ActiveId == id)
	{
		if (!is_editable && !g.ActiveIdIsJustActivated)
		{
			// When read-only we always use the live data passed to the function
			edit_state.Text.resize(buf_size + 1);
			const char* buf_end = NULL;
			edit_state.CurLenW = ImTextStrFromUtf8(edit_state.Text.Data, edit_state.Text.Size, buf, NULL, &buf_end);
			edit_state.CurLenA = (int)(buf_end - buf);
			edit_state.CursorClamp();
		}

		edit_state.BufSizeA = buf_size;

		// Although we are active we don't prevent mouse from hovering other elements unless we are interacting right now with the widget.
		// Down the line we should have a cleaner library-wide concept of Selected vs Active.
		g.ActiveIdAllowOverlap = !io.MouseDown[0];
		g.WantTextInputNextFrame = 1;

		// Edit in progress
		const float mouse_x = (io.MousePos.x - frame_bb.Min.x - style.FramePadding.x) + edit_state.ScrollX;
		const float mouse_y = (is_multiline ? (io.MousePos.y - draw_window->DC.CursorPos.y - style.FramePadding.y) : (g.FontSize * 0.5f));

		const bool osx_double_click_selects_words = io.OptMacOSXBehaviors;      // OS X style: Double click selects by word instead of selecting whole text
		if (select_all || (hovered && !osx_double_click_selects_words && io.MouseDoubleClicked[0]))
		{
			edit_state.SelectAll();
			edit_state.SelectedAllMouseLock = true;
		}
		else if (hovered && osx_double_click_selects_words && io.MouseDoubleClicked[0])
		{
			// Select a word only, OS X style (by simulating keystrokes)
			edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT);
			edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT);
		}
		else if (io.MouseClicked[0] && !edit_state.SelectedAllMouseLock)
		{
			if (hovered)
			{
				stb_textedit_click(&edit_state, &edit_state.StbState, mouse_x, mouse_y);
				edit_state.CursorAnimReset();
			}
		}
		else if (io.MouseDown[0] && !edit_state.SelectedAllMouseLock && (io.MouseDelta.x != 0.0f || io.MouseDelta.y != 0.0f))
		{
			stb_textedit_drag(&edit_state, &edit_state.StbState, mouse_x, mouse_y);
			edit_state.CursorAnimReset();
			edit_state.CursorFollow = true;
		}
		if (edit_state.SelectedAllMouseLock && !io.MouseDown[0])
			edit_state.SelectedAllMouseLock = false;

		if (io.InputCharacters[0])
		{
			// Process text input (before we check for Return because using some IME will effectively send a Return?)
			// We ignore CTRL inputs, but need to allow ALT+CTRL as some keyboards (e.g. German) use AltGR (which _is_ Alt+Ctrl) to input certain characters.
			if (!(io.KeyCtrl && !io.KeyAlt) && is_editable && !user_nav_input_start)
				for (int n = 0; n < IM_ARRAYSIZE(io.InputCharacters) && io.InputCharacters[n]; n++)
				{
					// Insert character if they pass filtering
					unsigned int c = (unsigned int)io.InputCharacters[n];
					if (InputTextFilterCharacter(&c, flags, callback, user_data))
						edit_state.OnKeyPressed((int)c);
				}

			// Consume characters
			memset(g.IO.InputCharacters, 0, sizeof(g.IO.InputCharacters));
		}
	}

	bool cancel_edit = false;
	if (g.ActiveId == id && !g.ActiveIdIsJustActivated && !clear_active_id)
	{
		// Handle key-presses
		const int k_mask = (io.KeyShift ? STB_TEXTEDIT_K_SHIFT : 0);
		const bool is_shortcut_key_only = (io.OptMacOSXBehaviors ? (io.KeySuper && !io.KeyCtrl) : (io.KeyCtrl && !io.KeySuper)) && !io.KeyAlt && !io.KeyShift; // OS X style: Shortcuts using Cmd/Super instead of Ctrl
		const bool is_wordmove_key_down = io.OptMacOSXBehaviors ? io.KeyAlt : io.KeyCtrl;                     // OS X style: Text editing cursor movement using Alt instead of Ctrl
		const bool is_startend_key_down = io.OptMacOSXBehaviors && io.KeySuper && !io.KeyCtrl && !io.KeyAlt;  // OS X style: Line/Text Start and End using Cmd+Arrows instead of Home/End
		const bool is_ctrl_key_only = io.KeyCtrl && !io.KeyShift && !io.KeyAlt && !io.KeySuper;
		const bool is_shift_key_only = io.KeyShift && !io.KeyCtrl && !io.KeyAlt && !io.KeySuper;

		const bool is_cut = ((is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_X)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Delete))) && is_editable && !is_password && (!is_multiline || edit_state.HasSelection());
		const bool is_copy = ((is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_C)) || (is_ctrl_key_only && IsKeyPressedMap(ImGuiKey_Insert))) && !is_password && (!is_multiline || edit_state.HasSelection());
		const bool is_paste = ((is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_V)) || (is_shift_key_only && IsKeyPressedMap(ImGuiKey_Insert))) && is_editable;

		if (IsKeyPressedMap(ImGuiKey_LeftArrow)) { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINESTART : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDLEFT : STB_TEXTEDIT_K_LEFT) | k_mask); }
		else if (IsKeyPressedMap(ImGuiKey_RightArrow)) { edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_LINEEND : is_wordmove_key_down ? STB_TEXTEDIT_K_WORDRIGHT : STB_TEXTEDIT_K_RIGHT) | k_mask); }
		else if (IsKeyPressedMap(ImGuiKey_UpArrow) && is_multiline) { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMax(draw_window->Scroll.y - g.FontSize, 0.0f)); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTSTART : STB_TEXTEDIT_K_UP) | k_mask); }
		else if (IsKeyPressedMap(ImGuiKey_DownArrow) && is_multiline) { if (io.KeyCtrl) SetWindowScrollY(draw_window, ImMin(draw_window->Scroll.y + g.FontSize, GetScrollMaxY())); else edit_state.OnKeyPressed((is_startend_key_down ? STB_TEXTEDIT_K_TEXTEND : STB_TEXTEDIT_K_DOWN) | k_mask); }
		else if (IsKeyPressedMap(ImGuiKey_Home)) { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTSTART | k_mask : STB_TEXTEDIT_K_LINESTART | k_mask); }
		else if (IsKeyPressedMap(ImGuiKey_End)) { edit_state.OnKeyPressed(io.KeyCtrl ? STB_TEXTEDIT_K_TEXTEND | k_mask : STB_TEXTEDIT_K_LINEEND | k_mask); }
		else if (IsKeyPressedMap(ImGuiKey_Delete) && is_editable) { edit_state.OnKeyPressed(STB_TEXTEDIT_K_DELETE | k_mask); }
		else if (IsKeyPressedMap(ImGuiKey_Backspace) && is_editable)
		{
			if (!edit_state.HasSelection())
			{
				if (is_wordmove_key_down) edit_state.OnKeyPressed(STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT);
				else if (io.OptMacOSXBehaviors && io.KeySuper && !io.KeyAlt && !io.KeyCtrl) edit_state.OnKeyPressed(STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT);
			}
			edit_state.OnKeyPressed(STB_TEXTEDIT_K_BACKSPACE | k_mask);
		}
		else if (IsKeyPressedMap(ImGuiKey_Enter))
		{
			bool ctrl_enter_for_new_line = (flags & ImGuiInputTextFlags_CtrlEnterForNewLine) != 0;
			if (!is_multiline || (ctrl_enter_for_new_line && !io.KeyCtrl) || (!ctrl_enter_for_new_line && io.KeyCtrl))
			{
				enter_pressed = clear_active_id = true;
			}
			else if (is_editable)
			{
				unsigned int c = '\n'; // Insert new line
				if (InputTextFilterCharacter(&c, flags, callback, user_data))
					edit_state.OnKeyPressed((int)c);
			}
		}
		else if ((flags & ImGuiInputTextFlags_AllowTabInput) && IsKeyPressedMap(ImGuiKey_Tab) && !io.KeyCtrl && !io.KeyShift && !io.KeyAlt && is_editable)
		{
			unsigned int c = '\t'; // Insert TAB
			if (InputTextFilterCharacter(&c, flags, callback, user_data))
				edit_state.OnKeyPressed((int)c);
		}
		else if (IsKeyPressedMap(ImGuiKey_Escape)) { clear_active_id = cancel_edit = true; }
		else if (is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_Z) && is_editable && is_undoable) { edit_state.OnKeyPressed(STB_TEXTEDIT_K_UNDO); edit_state.ClearSelection(); }
		else if (is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_Y) && is_editable && is_undoable) { edit_state.OnKeyPressed(STB_TEXTEDIT_K_REDO); edit_state.ClearSelection(); }
		else if (is_shortcut_key_only && IsKeyPressedMap(ImGuiKey_A)) { edit_state.SelectAll(); edit_state.CursorFollow = true; }
		else if (is_cut || is_copy)
		{
			// Cut, Copy
			if (io.SetClipboardTextFn)
			{
				const int ib = edit_state.HasSelection() ? ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end) : 0;
				const int ie = edit_state.HasSelection() ? ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end) : edit_state.CurLenW;
				edit_state.TempTextBuffer.resize((ie - ib) * 4 + 1);
				ImTextStrToUtf8(edit_state.TempTextBuffer.Data, edit_state.TempTextBuffer.Size, edit_state.Text.Data + ib, edit_state.Text.Data + ie);
				SetClipboardText(edit_state.TempTextBuffer.Data);
			}

			if (is_cut)
			{
				if (!edit_state.HasSelection())
					edit_state.SelectAll();
				edit_state.CursorFollow = true;
				stb_textedit_cut(&edit_state, &edit_state.StbState);
			}
		}
		else if (is_paste)
		{
			// Paste
			if (const char* clipboard = GetClipboardText())
			{
				// Filter pasted buffer
				const int clipboard_len = (int)strlen(clipboard);
				ImWchar* clipboard_filtered = (ImWchar*)ImGui::MemAlloc((clipboard_len + 1) * sizeof(ImWchar));
				int clipboard_filtered_len = 0;
				for (const char* s = clipboard; *s; )
				{
					unsigned int c;
					s += ImTextCharFromUtf8(&c, s, NULL);
					if (c == 0)
						break;
					if (c >= 0x10000 || !InputTextFilterCharacter(&c, flags, callback, user_data))
						continue;
					clipboard_filtered[clipboard_filtered_len++] = (ImWchar)c;
				}
				clipboard_filtered[clipboard_filtered_len] = 0;
				if (clipboard_filtered_len > 0) // If everything was filtered, ignore the pasting operation
				{
					stb_textedit_paste(&edit_state, &edit_state.StbState, clipboard_filtered, clipboard_filtered_len);
					edit_state.CursorFollow = true;
				}
				ImGui::MemFree(clipboard_filtered);
			}
		}
	}

	if (g.ActiveId == id)
	{
		if (cancel_edit)
		{
			// Restore initial value
			if (is_editable)
			{
				ImStrncpy(buf, edit_state.InitialText.Data, buf_size);
				value_changed = true;
			}
		}

		// When using 'ImGuiInputTextFlags_EnterReturnsTrue' as a special case we reapply the live buffer back to the input buffer before clearing ActiveId, even though strictly speaking it wasn't modified on this frame.
		// If we didn't do that, code like InputInt() with ImGuiInputTextFlags_EnterReturnsTrue would fail. Also this allows the user to use InputText() with ImGuiInputTextFlags_EnterReturnsTrue without maintaining any user-side storage.
		bool apply_edit_back_to_user_buffer = !cancel_edit || (enter_pressed && (flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0);
		if (apply_edit_back_to_user_buffer)
		{
			// Apply new value immediately - copy modified buffer back
			// Note that as soon as the input box is active, the in-widget value gets priority over any underlying modification of the input buffer
			// FIXME: We actually always render 'buf' when calling DrawList->AddText, making the comment above incorrect.
			// FIXME-OPT: CPU waste to do this every time the widget is active, should mark dirty state from the stb_textedit callbacks.
			if (is_editable)
			{
				edit_state.TempTextBuffer.resize(edit_state.Text.Size * 4);
				ImTextStrToUtf8(edit_state.TempTextBuffer.Data, edit_state.TempTextBuffer.Size, edit_state.Text.Data, NULL);
			}

			// User callback
			if ((flags & (ImGuiInputTextFlags_CallbackCompletion | ImGuiInputTextFlags_CallbackHistory | ImGuiInputTextFlags_CallbackAlways)) != 0)
			{
				IM_ASSERT(callback != NULL);

				// The reason we specify the usage semantic (Completion/History) is that Completion needs to disable keyboard TABBING at the moment.
				ImGuiInputTextFlags event_flag = 0;
				ImGuiKey event_key = ImGuiKey_COUNT;
				if ((flags & ImGuiInputTextFlags_CallbackCompletion) != 0 && IsKeyPressedMap(ImGuiKey_Tab))
				{
					event_flag = ImGuiInputTextFlags_CallbackCompletion;
					event_key = ImGuiKey_Tab;
				}
				else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_UpArrow))
				{
					event_flag = ImGuiInputTextFlags_CallbackHistory;
					event_key = ImGuiKey_UpArrow;
				}
				else if ((flags & ImGuiInputTextFlags_CallbackHistory) != 0 && IsKeyPressedMap(ImGuiKey_DownArrow))
				{
					event_flag = ImGuiInputTextFlags_CallbackHistory;
					event_key = ImGuiKey_DownArrow;
				}
				else if (flags & ImGuiInputTextFlags_CallbackAlways)
					event_flag = ImGuiInputTextFlags_CallbackAlways;

				if (event_flag)
				{
					ImGuiTextEditCallbackData callback_data;
					memset(&callback_data, 0, sizeof(ImGuiTextEditCallbackData));
					callback_data.EventFlag = event_flag;
					callback_data.Flags = flags;
					callback_data.UserData = user_data;
					callback_data.ReadOnly = !is_editable;

					callback_data.EventKey = event_key;
					callback_data.Buf = edit_state.TempTextBuffer.Data;
					callback_data.BufTextLen = edit_state.CurLenA;
					callback_data.BufSize = edit_state.BufSizeA;
					callback_data.BufDirty = false;

					// We have to convert from wchar-positions to UTF-8-positions, which can be pretty slow (an incentive to ditch the ImWchar buffer, see https://github.com/nothings/stb/issues/188)
					ImWchar* text = edit_state.Text.Data;
					const int utf8_cursor_pos = callback_data.CursorPos = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.cursor);
					const int utf8_selection_start = callback_data.SelectionStart = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_start);
					const int utf8_selection_end = callback_data.SelectionEnd = ImTextCountUtf8BytesFromStr(text, text + edit_state.StbState.select_end);

					// Call user code
					callback(&callback_data);

					// Read back what user may have modified
					IM_ASSERT(callback_data.Buf == edit_state.TempTextBuffer.Data);  // Invalid to modify those fields
					IM_ASSERT(callback_data.BufSize == edit_state.BufSizeA);
					IM_ASSERT(callback_data.Flags == flags);
					if (callback_data.CursorPos != utf8_cursor_pos)            edit_state.StbState.cursor = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.CursorPos);
					if (callback_data.SelectionStart != utf8_selection_start)  edit_state.StbState.select_start = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionStart);
					if (callback_data.SelectionEnd != utf8_selection_end)      edit_state.StbState.select_end = ImTextCountCharsFromUtf8(callback_data.Buf, callback_data.Buf + callback_data.SelectionEnd);
					if (callback_data.BufDirty)
					{
						IM_ASSERT(callback_data.BufTextLen == (int)strlen(callback_data.Buf)); // You need to maintain BufTextLen if you change the text!
						edit_state.CurLenW = ImTextStrFromUtf8(edit_state.Text.Data, edit_state.Text.Size, callback_data.Buf, NULL);
						edit_state.CurLenA = callback_data.BufTextLen;  // Assume correct length and valid UTF-8 from user, saves us an extra strlen()
						edit_state.CursorAnimReset();
					}
				}
			}

			// Copy back to user buffer
			if (is_editable && strcmp(edit_state.TempTextBuffer.Data, buf) != 0)
			{
				ImStrncpy(buf, edit_state.TempTextBuffer.Data, buf_size);
				value_changed = true;
			}
		}
	}

	// Release active ID at the end of the function (so e.g. pressing Return still does a final application of the value)
	if (clear_active_id && g.ActiveId == id)
		ClearActiveID();

	// Render
	// Select which buffer we are going to display. When ImGuiInputTextFlags_NoLiveEdit is set 'buf' might still be the old value. We set buf to NULL to prevent accidental usage from now on.
	const char* buf_display = (g.ActiveId == id && is_editable) ? edit_state.TempTextBuffer.Data : buf; buf = NULL;

	RenderNavHighlight(frame_bb, id);
	if (!is_multiline)
		RenderFrame(frame_bb.Min, frame_bb.Max, GetColorU32(ImGuiCol_FrameBg), true, style.FrameRounding);

	const ImVec4 clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size
	ImVec2 render_pos = is_multiline ? draw_window->DC.CursorPos : frame_bb.Min + style.FramePadding;
	ImVec2 text_size(0.f, 0.f);
	const bool is_currently_scrolling = (edit_state.Id == id && is_multiline && g.ActiveId == draw_window->GetIDNoKeepAlive("#SCROLLY"));
	if (g.ActiveId == id || is_currently_scrolling)
	{
		edit_state.CursorAnim += io.DeltaTime;

		// This is going to be messy. We need to:
		// - Display the text (this alone can be more easily clipped)
		// - Handle scrolling, highlight selection, display cursor (those all requires some form of 1d->2d cursor position calculation)
		// - Measure text height (for scrollbar)
		// We are attempting to do most of that in **one main pass** to minimize the computation cost (non-negligible for large amount of text) + 2nd pass for selection rendering (we could merge them by an extra refactoring effort)
		// FIXME: This should occur on buf_display but we'd need to maintain cursor/select_start/select_end for UTF-8.
		const ImWchar* text_begin = edit_state.Text.Data;
		ImVec2 cursor_offset, select_start_offset;

		{
			// Count lines + find lines numbers straddling 'cursor' and 'select_start' position.
			const ImWchar* searches_input_ptr[2];
			searches_input_ptr[0] = text_begin + edit_state.StbState.cursor;
			searches_input_ptr[1] = NULL;
			int searches_remaining = 1;
			int searches_result_line_number[2] = { -1, -999 };
			if (edit_state.StbState.select_start != edit_state.StbState.select_end)
			{
				searches_input_ptr[1] = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);
				searches_result_line_number[1] = -1;
				searches_remaining++;
			}

			// Iterate all lines to find our line numbers
			// In multi-line mode, we never exit the loop until all lines are counted, so add one extra to the searches_remaining counter.
			searches_remaining += is_multiline ? 1 : 0;
			int line_count = 0;
			for (const ImWchar* s = text_begin; *s != 0; s++)
				if (*s == '\n')
				{
					line_count++;
					if (searches_result_line_number[0] == -1 && s >= searches_input_ptr[0]) { searches_result_line_number[0] = line_count; if (--searches_remaining <= 0) break; }
					if (searches_result_line_number[1] == -1 && s >= searches_input_ptr[1]) { searches_result_line_number[1] = line_count; if (--searches_remaining <= 0) break; }
				}
			line_count++;
			if (searches_result_line_number[0] == -1) searches_result_line_number[0] = line_count;
			if (searches_result_line_number[1] == -1) searches_result_line_number[1] = line_count;

			// Calculate 2d position by finding the beginning of the line and measuring distance
			cursor_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[0], text_begin), searches_input_ptr[0]).x;
			cursor_offset.y = searches_result_line_number[0] * g.FontSize;
			if (searches_result_line_number[1] >= 0)
			{
				select_start_offset.x = InputTextCalcTextSizeW(ImStrbolW(searches_input_ptr[1], text_begin), searches_input_ptr[1]).x;
				select_start_offset.y = searches_result_line_number[1] * g.FontSize;
			}

			// Store text height (note that we haven't calculated text width at all, see GitHub issues #383, #1224)
			if (is_multiline)
				text_size = ImVec2(size.x, line_count * g.FontSize);
		}

		// Scroll
		if (edit_state.CursorFollow)
		{
			// Horizontal scroll in chunks of quarter width
			if (!(flags & ImGuiInputTextFlags_NoHorizontalScroll))
			{
				const float scroll_increment_x = size.x * 0.25f;
				if (cursor_offset.x < edit_state.ScrollX)
					edit_state.ScrollX = (float)(int)ImMax(0.0f, cursor_offset.x - scroll_increment_x);
				else if (cursor_offset.x - size.x >= edit_state.ScrollX)
					edit_state.ScrollX = (float)(int)(cursor_offset.x - size.x + scroll_increment_x);
			}
			else
			{
				edit_state.ScrollX = 0.0f;
			}

			// Vertical scroll
			if (is_multiline)
			{
				float scroll_y = draw_window->Scroll.y;
				if (cursor_offset.y - g.FontSize < scroll_y)
					scroll_y = ImMax(0.0f, cursor_offset.y - g.FontSize);
				else if (cursor_offset.y - size.y >= scroll_y)
					scroll_y = cursor_offset.y - size.y;
				draw_window->DC.CursorPos.y += (draw_window->Scroll.y - scroll_y);   // To avoid a frame of lag
				draw_window->Scroll.y = scroll_y;
				render_pos.y = draw_window->DC.CursorPos.y;
			}
		}
		edit_state.CursorFollow = false;
		const ImVec2 render_scroll = ImVec2(edit_state.ScrollX, 0.0f);

		// Draw selection
		if (edit_state.StbState.select_start != edit_state.StbState.select_end)
		{
			const ImWchar* text_selected_begin = text_begin + ImMin(edit_state.StbState.select_start, edit_state.StbState.select_end);
			const ImWchar* text_selected_end = text_begin + ImMax(edit_state.StbState.select_start, edit_state.StbState.select_end);

			float bg_offy_up = is_multiline ? 0.0f : -1.0f;    // FIXME: those offsets should be part of the style? they don't play so well with multi-line selection.
			float bg_offy_dn = is_multiline ? 0.0f : 2.0f;
			ImU32 bg_color = GetColorU32(ImGuiCol_TextSelectedBg);
			ImVec2 rect_pos = render_pos + select_start_offset - render_scroll;
			for (const ImWchar* p = text_selected_begin; p < text_selected_end; )
			{
				if (rect_pos.y > clip_rect.w + g.FontSize)
					break;
				if (rect_pos.y < clip_rect.y)
				{
					while (p < text_selected_end)
						if (*p++ == '\n')
							break;
				}
				else
				{
					ImVec2 rect_size = InputTextCalcTextSizeW(p, text_selected_end, &p, NULL, true);
					if (rect_size.x <= 0.0f) rect_size.x = (float)(int)(g.Font->GetCharAdvance((unsigned short)' ') * 0.50f); // So we can see selected empty lines
					ImRect rect(rect_pos + ImVec2(0.0f, bg_offy_up - g.FontSize), rect_pos + ImVec2(rect_size.x, bg_offy_dn));
					rect.ClipWith(clip_rect);
					if (rect.Overlaps(clip_rect))
						draw_window->DrawList->AddRectFilled(rect.Min, rect.Max, bg_color);
				}
				rect_pos.x = render_pos.x - render_scroll.x;
				rect_pos.y += g.FontSize;
			}
		}

		draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos - render_scroll, GetColorU32(ImGuiCol_Text), buf_display, buf_display + edit_state.CurLenA, 0.0f, is_multiline ? NULL : &clip_rect);

		// Draw blinking cursor
		bool cursor_is_visible = (!g.IO.OptCursorBlink) || (g.InputTextState.CursorAnim <= 0.0f) || fmodf(g.InputTextState.CursorAnim, 1.20f) <= 0.80f;
		ImVec2 cursor_screen_pos = render_pos + cursor_offset - render_scroll;
		ImRect cursor_screen_rect(cursor_screen_pos.x, cursor_screen_pos.y - g.FontSize + 0.5f, cursor_screen_pos.x + 1.0f, cursor_screen_pos.y - 1.5f);
		if (cursor_is_visible && cursor_screen_rect.Overlaps(clip_rect))
			draw_window->DrawList->AddLine(cursor_screen_rect.Min, cursor_screen_rect.GetBL(), GetColorU32(ImGuiCol_Text));

		// Notify OS of text input position for advanced IME (-1 x offset so that Windows IME can cover our cursor. Bit of an extra nicety.)
		if (is_editable)
			g.OsImePosRequest = ImVec2(cursor_screen_pos.x - 1, cursor_screen_pos.y - g.FontSize);
	}
	else
	{
		// Render text only
		const char* buf_end = NULL;
		if (is_multiline)
			text_size = ImVec2(size.x, InputTextCalcTextLenAndLineCount(buf_display, &buf_end) * g.FontSize); // We don't need width
		draw_window->DrawList->AddText(g.Font, g.FontSize, render_pos, GetColorU32(ImGuiCol_Text), buf_display, buf_end, 0.0f, is_multiline ? NULL : &clip_rect);
	}

	if (is_multiline)
	{
		Dummy(text_size + ImVec2(0.0f, g.FontSize)); // Always add room to scroll an extra line
		EndChildFrame();
		EndGroup();
	}

	if (is_password)
		PopFont();

	// Log as text
	if (g.LogEnabled && !is_password)
		LogRenderedText(&render_pos, buf_display, NULL);

	if (label_size.x > 0)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	if ((flags & ImGuiInputTextFlags_EnterReturnsTrue) != 0)
		return enter_pressed;
	else
		return value_changed;
}

bool ImGui::InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
{
	IM_ASSERT(!(flags & ImGuiInputTextFlags_Multiline)); // call InputTextMultiline()
	return InputTextEx(label, buf, (int)buf_size, ImVec2(0, 0), flags, callback, user_data);
}

bool ImGui::InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback, void* user_data)
{
	return InputTextEx(label, buf, (int)buf_size, size, flags | ImGuiInputTextFlags_Multiline, callback, user_data);
}

// NB: scalar_format here must be a simple "%xx" format string with no prefix/suffix (unlike the Drag/Slider functions "display_format" argument)
bool ImGui::InputScalarEx(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	BeginGroup();
	PushID(label);
	const ImVec2 button_sz = ImVec2(GetFrameHeight(), GetFrameHeight());
	//if (step_ptr)
		//PushItemWidth(ImMax(1.0f, CalcItemWidth() - (button_sz.x + style.ItemInnerSpacing.x) * 2));

	char buf[64];
	DataTypeFormatString(data_type, data_ptr, scalar_format, buf, IM_ARRAYSIZE(buf));

	bool value_changed = false;
	if ((extra_flags & (ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsScientific)) == 0)
		extra_flags |= ImGuiInputTextFlags_CharsDecimal;
	extra_flags |= ImGuiInputTextFlags_AutoSelectAll;
	if (InputText("", buf, IM_ARRAYSIZE(buf), extra_flags)) // PushId(label) + "" gives us the expected ID from outside point of view
		value_changed = DataTypeApplyOpFromText(buf, GImGui->InputTextState.InitialText.begin(), data_type, data_ptr, scalar_format);

	// Step buttons
	if (step_ptr)
	{
		/*
		PopItemWidth();
		SameLine(0, style.ItemInnerSpacing.x);
		if (ButtonEx("-", button_sz, ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups))
		{
			DataTypeApplyOp(data_type, '-', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast_ptr ? step_fast_ptr : step_ptr);
			value_changed = true;
		}
		SameLine(0, style.ItemInnerSpacing.x);
		if (ButtonEx("+", button_sz, ImGuiButtonFlags_Repeat | ImGuiButtonFlags_DontClosePopups))
		{
			DataTypeApplyOp(data_type, '+', data_ptr, data_ptr, g.IO.KeyCtrl && step_fast_ptr ? step_fast_ptr : step_ptr);
			value_changed = true;
		}
		*/
	}
	PopID();

	if (label_size.x > 0)
	{
		SameLine(0, style.ItemInnerSpacing.x);
		RenderText(ImVec2(window->DC.CursorPos.x, window->DC.CursorPos.y + style.FramePadding.y), label);
		ItemSize(label_size, style.FramePadding.y);
	}
	EndGroup();

	return value_changed;
}

bool ImGui::InputFloat(const char* label, float* v, float step, float step_fast, int decimal_precision, ImGuiInputTextFlags extra_flags)
{
	extra_flags |= ImGuiInputTextFlags_CharsScientific;
	if (decimal_precision < 0)
	{
		// Ideally we'd have a minimum decimal precision of 1 to visually denote that this is a float, while hiding non-significant digits? %f doesn't have a minimum of 1
		return InputScalarEx(label, ImGuiDataType_Float, (void*)v, (void*)(step > 0.0f ? &step : NULL), (void*)(step_fast > 0.0f ? &step_fast : NULL), "%f", extra_flags);
	}
	else
	{
		char display_format[16];
		ImFormatString(display_format, IM_ARRAYSIZE(display_format), "%%.%df", decimal_precision);
		return InputScalarEx(label, ImGuiDataType_Float, (void*)v, (void*)(step > 0.0f ? &step : NULL), (void*)(step_fast > 0.0f ? &step_fast : NULL), display_format, extra_flags);
	}
}

bool ImGui::InputDouble(const char* label, double* v, double step, double step_fast, const char* display_format, ImGuiInputTextFlags extra_flags)
{
	extra_flags |= ImGuiInputTextFlags_CharsScientific;
	return InputScalarEx(label, ImGuiDataType_Double, (void*)v, (void*)(step > 0.0 ? &step : NULL), (void*)(step_fast > 0.0 ? &step_fast : NULL), display_format, extra_flags);
}

bool ImGui::InputInt(const char* label, int* v, int step, int step_fast, ImGuiInputTextFlags extra_flags)
{
	// Hexadecimal input provided as a convenience but the flag name is awkward. Typically you'd use InputText() to parse your own data, if you want to handle prefixes.
	const char* scalar_format = (extra_flags & ImGuiInputTextFlags_CharsHexadecimal) ? "%08X" : "%d";
	return InputScalarEx(label, ImGuiDataType_Int, (void*)v, (void*)(step > 0 ? &step : NULL), (void*)(step_fast > 0 ? &step_fast : NULL), scalar_format, extra_flags);
}

bool ImGui::InputFloatN(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	bool value_changed = false;
	BeginGroup();
	PushID(label);
	PushMultiItemsWidths(components);
	for (int i = 0; i < components; i++)
	{
		PushID(i);
		value_changed |= InputFloat("##v", &v[i], 0, 0, decimal_precision, extra_flags);
		SameLine(0, g.Style.ItemInnerSpacing.x);
		PopID();
		PopItemWidth();
	}
	PopID();

	TextUnformatted(label, FindRenderedTextEnd(label));
	EndGroup();

	return value_changed;
}

bool ImGui::InputFloat2(const char* label, float v[2], int decimal_precision, ImGuiInputTextFlags extra_flags)
{
	return InputFloatN(label, v, 2, decimal_precision, extra_flags);
}

bool ImGui::InputFloat3(const char* label, float v[3], int decimal_precision, ImGuiInputTextFlags extra_flags)
{
	return InputFloatN(label, v, 3, decimal_precision, extra_flags);
}

bool ImGui::InputFloat4(const char* label, float v[4], int decimal_precision, ImGuiInputTextFlags extra_flags)
{
	return InputFloatN(label, v, 4, decimal_precision, extra_flags);
}

bool ImGui::InputIntN(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	bool value_changed = false;
	BeginGroup();
	PushID(label);
	PushMultiItemsWidths(components);
	for (int i = 0; i < components; i++)
	{
		PushID(i);
		value_changed |= InputInt("##v", &v[i], 0, 0, extra_flags);
		SameLine(0, g.Style.ItemInnerSpacing.x);
		PopID();
		PopItemWidth();
	}
	PopID();

	TextUnformatted(label, FindRenderedTextEnd(label));
	EndGroup();

	return value_changed;
}

bool ImGui::InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags)
{
	return InputIntN(label, v, 2, extra_flags);
}

bool ImGui::InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags)
{
	return InputIntN(label, v, 3, extra_flags);
}

bool ImGui::InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags)
{
	return InputIntN(label, v, 4, extra_flags);
}

static float CalcMaxPopupHeightFromItemCount(int items_count)
{
	ImGuiContext& g = *GImGui;
	if (items_count <= 0)
		return FLT_MAX;
	return (g.FontSize + g.Style.ItemSpacing.y) * items_count - g.Style.ItemSpacing.y + (g.Style.WindowPadding.y * 2);
}

bool ImGui::BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags)
{
	// Always consume the SetNextWindowSizeConstraint() call in our early return paths
	ImGuiContext& g = *GImGui;
	ImGuiCond backup_next_window_size_constraint = g.NextWindowData.SizeConstraintCond;
	g.NextWindowData.SizeConstraintCond = 0;

	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	IM_ASSERT((flags & (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)) != (ImGuiComboFlags_NoArrowButton | ImGuiComboFlags_NoPreview)); // Can't use both flags together

	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);

	//todo add custom combo method w/ flags
	//if (!(flags & ImGuiComboFlags_NoArrowButton))
		//flags |= ImGuiComboFlags_NoArrowButton;

	const float arrow_size = (flags & ImGuiComboFlags_NoArrowButton) ? 0.0f : GetFrameHeight();
	const ImVec2 label_size = CalcTextSize(label, NULL, true);
	const float w = (flags & ImGuiComboFlags_NoPreview) ? arrow_size : CalcItemWidth();
	const ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + ImVec2(w, label_size.y + style.FramePadding.y * 2.0f));
	const ImRect total_bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
	ItemSize(total_bb, style.FramePadding.y);
	if (!ItemAdd(total_bb, id, &frame_bb))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(frame_bb, id, &hovered, &held);
	bool popup_open = IsPopupOpen(id);

	const ImRect value_bb(frame_bb.Min, frame_bb.Max - ImVec2(arrow_size, 0.0f));
	const ImU32 frame_col = GetColorU32(hovered ? ImGuiCol_FrameBgHovered : ImGuiCol_FrameBg);
	RenderNavHighlight(frame_bb, id);
	if (!(flags & ImGuiComboFlags_NoPreview))
		window->DrawList->AddRectFilled(frame_bb.Min, ImVec2(frame_bb.Max.x - arrow_size, frame_bb.Max.y), frame_col, style.FrameRounding, ImDrawCornerFlags_Left);
	if (!(flags & ImGuiComboFlags_NoArrowButton))
	{
		window->DrawList->AddRectFilled(ImVec2(frame_bb.Max.x - arrow_size, frame_bb.Min.y), frame_bb.Max, GetColorU32((popup_open || hovered) ? ImGuiCol_ButtonHovered : ImGuiCol_Button), style.FrameRounding, (w <= arrow_size) ? ImDrawCornerFlags_All : ImDrawCornerFlags_Right);
		RenderArrow(ImVec2(frame_bb.Max.x - arrow_size + style.FramePadding.y, frame_bb.Min.y + style.FramePadding.y), popup_open ? ImGuiDir_Down : ImGuiDir_Left);
	}
	RenderFrameBorder(frame_bb.Min, frame_bb.Max, style.FrameRounding);
	if (preview_value != NULL && !(flags & ImGuiComboFlags_NoPreview))
		RenderTextClipped(frame_bb.Min + style.FramePadding, value_bb.Max, preview_value, NULL, NULL, ImVec2(0.0f, 0.0f));
	if (label_size.x > 0)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	if ((pressed || g.NavActivateId == id) && !popup_open)
	{
		if (window->DC.NavLayerCurrent == 0)
			window->NavLastIds[0] = id;
		OpenPopupEx(id);
		popup_open = true;
	}

	if (!popup_open)
		return false;

	if (backup_next_window_size_constraint)
	{
		g.NextWindowData.SizeConstraintCond = backup_next_window_size_constraint;
		g.NextWindowData.SizeConstraintRect.Min.x = ImMax(g.NextWindowData.SizeConstraintRect.Min.x, w);
	}
	else
	{
		if ((flags & ImGuiComboFlags_HeightMask_) == 0)
			flags |= ImGuiComboFlags_HeightRegular;
		IM_ASSERT(ImIsPowerOfTwo(flags & ImGuiComboFlags_HeightMask_));    // Only one
		int popup_max_height_in_items = -1;
		if (flags & ImGuiComboFlags_HeightRegular)     popup_max_height_in_items = 8;
		else if (flags & ImGuiComboFlags_HeightSmall)  popup_max_height_in_items = 4;
		else if (flags & ImGuiComboFlags_HeightLarge)  popup_max_height_in_items = 20;
		SetNextWindowSizeConstraints(ImVec2(w, 0.0f), ImVec2(FLT_MAX, CalcMaxPopupHeightFromItemCount(popup_max_height_in_items)));
	}

	char name[16];
	ImFormatString(name, IM_ARRAYSIZE(name), "##Combo_%02d", g.CurrentPopupStack.Size); // Recycle windows based on depth

																						// Peak into expected window size so we can position it
	if (ImGuiWindow* popup_window = FindWindowByName(name))
		if (popup_window->WasActive)
		{
			ImVec2 size_contents = CalcSizeContents(popup_window);
			ImVec2 size_expected = CalcSizeAfterConstraint(popup_window, CalcSizeAutoFit(popup_window, size_contents));
			if (flags & ImGuiComboFlags_PopupAlignLeft)
				popup_window->AutoPosLastDirection = ImGuiDir_Left;
			ImVec2 pos = FindBestWindowPosForPopup(frame_bb.GetBL(), size_expected, &popup_window->AutoPosLastDirection, frame_bb, ImGuiPopupPositionPolicy_ComboBox);
			SetNextWindowPos(pos);
		}

	//const auto old_padding = g.Style.WindowPadding;
	//g.Style.WindowPadding = ImVec2();

	ImGuiWindowFlags window_flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_Popup | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoSavedSettings;
	if (!Begin(name, NULL, window_flags))
	{
		//g.Style.WindowPadding = old_padding;
		EndPopup();
		IM_ASSERT(0);   // This should never happen as we tested for IsPopupOpen() above
		return false;
	}

	//g.Style.WindowPadding = old_padding;

	// Horizontally align ourselves with the framed text
	if (style.FramePadding.x != style.WindowPadding.x)
		Indent(style.FramePadding.x - style.WindowPadding.x);

	return true;
}

void ImGui::EndCombo()
{
	const ImGuiStyle& style = GImGui->Style;
	if (style.FramePadding.x != style.WindowPadding.x)
		Unindent(style.FramePadding.x - style.WindowPadding.x);
	EndPopup();
}

// Old API, prefer using BeginCombo() nowadays if you can.
bool ImGui::Combo(const char* label, int* current_item, bool(*items_getter)(void*, int, const char**), void* data, int items_count, int popup_max_height_in_items)
{
	ImGuiContext& g = *GImGui;

	const char* preview_text = NULL;
	if (*current_item >= 0 && *current_item < items_count)
		items_getter(data, *current_item, &preview_text);

	// The old Combo() API exposed "popup_max_height_in_items", however the new more general BeginCombo() API doesn't, so we emulate it here.
	if (popup_max_height_in_items != -1 && !g.NextWindowData.SizeConstraintCond)
	{
		float popup_max_height = CalcMaxPopupHeightFromItemCount(popup_max_height_in_items);
		SetNextWindowSizeConstraints(ImVec2(0, 0), ImVec2(FLT_MAX, popup_max_height));
	}

	if (!BeginCombo(label, preview_text, 0))
		return false;

	// Display items
	// FIXME-OPT: Use clipper (but we need to disable it on the appearing frame to make sure our call to SetItemDefaultFocus() is processed)
	bool value_changed = false;
	for (int i = 0; i < items_count; i++)
	{
		PushID((void*)(intptr_t)i);
		const bool item_selected = (i == *current_item);
		const char* item_text;
		if (!items_getter(data, i, &item_text))
			item_text = "*Unknown item*";
		if (Selectable(item_text, item_selected))
		{
			value_changed = true;
			*current_item = i;
		}
		if (item_selected)
			SetItemDefaultFocus();
		PopID();
	}

	EndCombo();
	return value_changed;
}

static bool Items_ArrayGetter(void* data, int idx, const char** out_text)
{
	const char* const* items = (const char* const*)data;
	if (out_text)
		*out_text = items[idx];
	return true;
}

static bool Items_SingleStringGetter(void* data, int idx, const char** out_text)
{
	// FIXME-OPT: we could pre-compute the indices to fasten this. But only 1 active combo means the waste is limited.
	const char* items_separated_by_zeros = (const char*)data;
	int items_count = 0;
	const char* p = items_separated_by_zeros;
	while (*p)
	{
		if (idx == items_count)
			break;
		p += strlen(p) + 1;
		items_count++;
	}
	if (!*p)
		return false;
	if (out_text)
		*out_text = p;
	return true;
}

// Combo box helper allowing to pass an array of strings.
bool ImGui::Combo(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items)
{
	const bool value_changed = Combo(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_in_items);
	return value_changed;
}

// Combo box helper allowing to pass all items in a single string.
bool ImGui::Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int height_in_items)
{
	int items_count = 0;
	const char* p = items_separated_by_zeros;       // FIXME-OPT: Avoid computing this, or at least only when combo is open
	while (*p)
	{
		p += strlen(p) + 1;
		items_count++;
	}
	bool value_changed = Combo(label, current_item, Items_SingleStringGetter, (void*)items_separated_by_zeros, items_count, height_in_items);
	return value_changed;
}

// Tip: pass an empty label (e.g. "##dummy") then you can use the space to draw other text or image.
// But you need to make sure the ID is unique, e.g. enclose calls in PushID/PopID.
bool ImGui::Selectable(const char* label, bool selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;

	if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet) // FIXME-OPT: Avoid if vertically clipped.
		PopClipRect();

	ImGuiID id = window->GetID(label);
	ImVec2 label_size = CalcTextSize(label, NULL, true);
	ImVec2 size(size_arg.x != 0.0f ? size_arg.x : label_size.x, size_arg.y != 0.0f ? size_arg.y : label_size.y);
	ImVec2 pos = window->DC.CursorPos;
	pos.y += window->DC.CurrentLineTextBaseOffset;
	ImRect bb(pos, pos + size);
	ItemSize(bb);

	// Fill horizontal space.
	ImVec2 window_padding = window->WindowPadding;
	float max_x = (flags & ImGuiSelectableFlags_SpanAllColumns) ? GetWindowContentRegionMax().x : GetContentRegionMax().x;
	float w_draw = ImMax(label_size.x, window->Pos.x + max_x - window_padding.x - window->DC.CursorPos.x);
	ImVec2 size_draw((size_arg.x != 0 && !(flags & ImGuiSelectableFlags_DrawFillAvailWidth)) ? size_arg.x : w_draw, size_arg.y != 0.0f ? size_arg.y : size.y);
	ImRect bb_with_spacing(pos, pos + size_draw);
	if (size_arg.x == 0.0f || (flags & ImGuiSelectableFlags_DrawFillAvailWidth))
		bb_with_spacing.Max.x += window_padding.x;

	// Selectables are tightly packed together, we extend the box to cover spacing between selectable.
	float spacing_L = (float)(int)(style.ItemSpacing.x * 0.5f);
	float spacing_U = (float)(int)(style.ItemSpacing.y * 0.5f);
	float spacing_R = style.ItemSpacing.x - spacing_L;
	float spacing_D = style.ItemSpacing.y - spacing_U;
	bb_with_spacing.Min.x -= spacing_L;
	bb_with_spacing.Min.y -= spacing_U;
	bb_with_spacing.Max.x += spacing_R;
	bb_with_spacing.Max.y += spacing_D;

	if (!ItemAdd(bb_with_spacing, (flags & ImGuiSelectableFlags_Disabled) ? 0 : id))
	{
		if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)
			PushColumnClipRect();
		return false;
	}

	ImGuiButtonFlags button_flags = 0;
	if (flags & ImGuiSelectableFlags_Menu) button_flags |= ImGuiButtonFlags_PressedOnClick | ImGuiButtonFlags_NoHoldingActiveID;
	if (flags & ImGuiSelectableFlags_MenuItem) button_flags |= ImGuiButtonFlags_PressedOnRelease;
	if (flags & ImGuiSelectableFlags_Disabled) button_flags |= ImGuiButtonFlags_Disabled;
	if (flags & ImGuiSelectableFlags_AllowDoubleClick) button_flags |= ImGuiButtonFlags_PressedOnClickRelease | ImGuiButtonFlags_PressedOnDoubleClick;
	bool hovered, held;
	bool pressed = ButtonBehavior(bb_with_spacing, id, &hovered, &held, button_flags);
	if (flags & ImGuiSelectableFlags_Disabled)
		selected = false;

	// Hovering selectable with mouse updates NavId accordingly so navigation can be resumed with gamepad/keyboard (this doesn't happen on most widgets)
	if (pressed || hovered)// && (g.IO.MouseDelta.x != 0.0f || g.IO.MouseDelta.y != 0.0f))
		if (!g.NavDisableMouseHover && g.NavWindow == window && g.NavLayer == window->DC.NavLayerActiveMask)
		{
			g.NavDisableHighlight = true;
			SetNavID(id, window->DC.NavLayerCurrent);
		}

	// Render
	if (hovered || selected)
	{
		const ImU32 col = GetColorU32((held && hovered) ? ImGuiCol_HeaderActive : hovered ? ImGuiCol_HeaderHovered : ImGuiCol_Header);
		RenderFrame(bb_with_spacing.Min, bb_with_spacing.Max, col, false, 0.0f);
		RenderNavHighlight(bb_with_spacing, id, ImGuiNavHighlightFlags_TypeThin | ImGuiNavHighlightFlags_NoRounding);
	}

	if ((flags & ImGuiSelectableFlags_SpanAllColumns) && window->DC.ColumnsSet)
	{
		PushColumnClipRect();
		bb_with_spacing.Max.x -= (GetContentRegionMax().x - max_x);
	}

	if (flags & ImGuiSelectableFlags_Disabled)
		PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);

	RenderTextClipped({ bb.Min.x += 4.f, bb.Min.y }, bb_with_spacing.Max, label, NULL, &label_size, ImVec2(flags & ImGuiSelectableFlags_AlignCenter ? 0.5f : 0.f, 0.0f));

	if (flags & ImGuiSelectableFlags_Disabled)
		PopStyleColor();

	// Automatically close popups
	if (pressed && (window->Flags & ImGuiWindowFlags_Popup) && !(flags & ImGuiSelectableFlags_DontClosePopups) && !(window->DC.ItemFlags & ImGuiItemFlags_SelectableDontClosePopup))
		CloseCurrentPopup();
	return pressed;
}

bool ImGui::Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags, const ImVec2& size_arg)
{
	if (Selectable(label, *p_selected, flags, size_arg))
	{
		*p_selected = !*p_selected;
		return true;
	}
	return false;
}

// Helper to calculate the size of a listbox and display a label on the right.
// Tip: To have a list filling the entire window width, PushItemWidth(-1) and pass an empty label "##empty"
bool ImGui::ListBoxHeader(const char* label, const ImVec2& size_arg)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	const ImGuiStyle& style = GetStyle();
	const ImGuiID id = GetID(label);
	const ImVec2 label_size = CalcTextSize(label, NULL, true);

	// Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
	ImVec2 size = CalcItemSize(size_arg, CalcItemWidth(), GetTextLineHeightWithSpacing() * 7.4f + style.ItemSpacing.y);
	ImVec2 frame_size = ImVec2(size.x, ImMax(size.y, label_size.y));
	ImRect frame_bb(window->DC.CursorPos, window->DC.CursorPos + frame_size);
	ImRect bb(frame_bb.Min, frame_bb.Max + ImVec2(label_size.x > 0.0f ? style.ItemInnerSpacing.x + label_size.x : 0.0f, 0.0f));
	window->DC.LastItemRect = bb; // Forward storage for ListBoxFooter.. dodgy.

	BeginGroup();
	if (label_size.x > 0)
		RenderText(ImVec2(frame_bb.Max.x + style.ItemInnerSpacing.x, frame_bb.Min.y + style.FramePadding.y), label);

	BeginChildFrame(id, frame_bb.GetSize());
	return true;
}

bool ImGui::ListBoxHeader(const char* label, int items_count, int height_in_items)
{
	// Size default to hold ~7 items. Fractional number of items helps seeing that we can scroll down/up without looking at scrollbar.
	// However we don't add +0.40f if items_count <= height_in_items. It is slightly dodgy, because it means a dynamic list of items will make the widget resize occasionally when it crosses that size.
	// I am expecting that someone will come and complain about this behavior in a remote future, then we can advise on a better solution.
	if (height_in_items < 0)
		height_in_items = ImMin(items_count, 7);
	float height_in_items_f = height_in_items < items_count ? (height_in_items + 0.40f) : (height_in_items + 0.00f);

	// We include ItemSpacing.y so that a list sized for the exact number of items doesn't make a scrollbar appears. We could also enforce that by passing a flag to BeginChild().
	ImVec2 size;
	size.x = 0.0f;
	size.y = GetTextLineHeightWithSpacing() * height_in_items_f + GetStyle().ItemSpacing.y;
	return ListBoxHeader(label, size);
}

void ImGui::ListBoxFooter()
{
	ImGuiWindow* parent_window = GetCurrentWindow()->ParentWindow;
	const ImRect bb = parent_window->DC.LastItemRect;
	const ImGuiStyle& style = GetStyle();

	EndChildFrame();

	// Redeclare item size so that it includes the label (we have stored the full size in LastItemRect)
	// We call SameLine() to restore DC.CurrentLine* data
	SameLine();
	parent_window->DC.CursorPos = bb.Min;
	ItemSize(bb, style.FramePadding.y);
	EndGroup();
}

bool ImGui::ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_items)
{
	const bool value_changed = ListBox(label, current_item, Items_ArrayGetter, (void*)items, items_count, height_items);
	return value_changed;
}

bool ImGui::ListBox(const char* label, int* current_item, bool(*items_getter)(void*, int, const char**), void* data, int items_count, int height_in_items)
{
	if (!ListBoxHeader(label, items_count, height_in_items))
		return false;

	// Assume all items have even height (= 1 line of text). If you need items of different or variable sizes you can create a custom version of ListBox() in your code without using the clipper.
	bool value_changed = false;
	ImGuiListClipper clipper(items_count, GetTextLineHeightWithSpacing()); // We know exactly our line height here so we pass it as a minor optimization, but generally you don't need to.

	PushStyleColor(ImGuiCol_Header, GetStyleColorVec4(ImGuiCol_ListBoxItem));
	PushStyleColor(ImGuiCol_HeaderActive, GetStyleColorVec4(ImGuiCol_ListBoxItemActive));
	PushStyleColor(ImGuiCol_HeaderHovered, GetStyleColorVec4(ImGuiCol_ListBoxItemHovered));

	while (clipper.Step())
		for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
		{
			const bool item_selected = (i == *current_item);
			const char* item_text;
			if (!items_getter(data, i, &item_text))
				item_text = "*Unknown item*";

			PushID(i);
			if (Selectable(item_text, item_selected, ImGuiSelectableFlags_DrawFillAvailWidth))
			{
				*current_item = i;
				value_changed = true;
			}
			if (item_selected)
				SetItemDefaultFocus();
			PopID();
		}

	PopStyleColor(3);

	ListBoxFooter();
	return value_changed;
}

bool ImGui::MenuItem(const char* label, const char* shortcut, bool selected, bool enabled, ImVec2 size)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	ImGuiStyle& style = g.Style;
	ImVec2 pos = window->DC.CursorPos;
	ImVec2 label_size = CalcTextSize(label, NULL, true);

	ImGuiSelectableFlags flags = ImGuiSelectableFlags_MenuItem | (enabled ? 0 : ImGuiSelectableFlags_Disabled) | ImGuiSelectableFlags_AlignCenter;
	bool pressed;
	PushStyleColor(ImGuiCol_Text, GetStyleColorVec4(ImGuiCol_MenuBarText));
	PushStyleColor(ImGuiCol_HeaderHovered, GetStyleColorVec4(ImGuiCol_MenuItemHovered));
	PushStyleColor(ImGuiCol_HeaderActive, GetStyleColorVec4(ImGuiCol_MenuItemActive));
	if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
	{
		// Mimic the exact layout spacing of BeginMenu() to allow MenuItem() inside a menu bar, which is a little misleading but may be useful
		// Note that in this situation we render neither the shortcut neither the selected tick mark
		if (size.x == 0)
			size.x = label_size.x;

		window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);
		PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);

		pressed = Selectable(label, selected, flags, size);
		PopStyleVar();
		window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
	}
	else
	{
		ImVec2 shortcut_size = shortcut ? CalcTextSize(shortcut, NULL) : ImVec2(0.0f, 0.0f);
		float w = window->MenuColumns.DeclColumns(label_size.x, shortcut_size.x, (float)(int)(g.FontSize * 1.20f)); // Feedback for next frame
		float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);
		pressed = Selectable(label, false, flags | ImGuiSelectableFlags_DrawFillAvailWidth, ImVec2(w, 0.0f));
		if (shortcut_size.x > 0.0f)
		{
			PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
			RenderText(pos + ImVec2(window->MenuColumns.Pos[1] + extra_w, 0.0f), shortcut, NULL, false);
			PopStyleColor();
		}
		if (selected)
			RenderCheckMark(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.40f, g.FontSize * 0.134f * 0.5f), GetColorU32(enabled ? ImGuiCol_Text : ImGuiCol_TextDisabled), g.FontSize * 0.866f);
	}
	PopStyleColor(3);
	return pressed;
}

bool ImGui::MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled, ImVec2 size)
{
	if (MenuItem(label, shortcut, p_selected ? *p_selected : false, enabled, size))
	{
		if (p_selected)
			*p_selected = !*p_selected;
		return true;
	}
	return false;
}

bool ImGui::BeginMainMenuBar()
{
	ImGuiContext& g = *GImGui;
	SetNextWindowPos(ImVec2(0.0f, 0.0f));
	SetNextWindowSize(ImVec2(g.IO.DisplaySize.x, g.FontBaseSize + g.Style.FramePadding.y * 2.0f));
	PushStyleVar(ImGuiStyleVar_WindowRounding, 0.0f);
	PushStyleVar(ImGuiStyleVar_WindowMinSize, ImVec2(0, 0));
	if (!Begin("##MainMenuBar", NULL, ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoSavedSettings | ImGuiWindowFlags_MenuBar)
		|| !BeginMenuBar())
	{
		End();
		PopStyleVar(2);
		return false;
	}
	g.CurrentWindow->DC.MenuBarOffsetX += g.Style.DisplaySafeAreaPadding.x;
	return true;
}

void ImGui::EndMainMenuBar()
{
	EndMenuBar();

	// When the user has left the menu layer (typically: closed menus through activation of an item), we restore focus to the previous window
	ImGuiContext& g = *GImGui;
	if (g.CurrentWindow == g.NavWindow && g.NavLayer == 0)
		FocusFrontMostActiveWindow(g.NavWindow);

	End();
	PopStyleVar(2);
}

bool ImGui::BeginMenuBar()
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;
	if (!(window->Flags & ImGuiWindowFlags_MenuBar))
		return false;

	IM_ASSERT(!window->DC.MenuBarAppending);
	BeginGroup(); // Save position
	PushID("##menubar");

	// We don't clip with regular window clipping rectangle as it is already set to the area below. However we clip with window full rect.
	// We remove 1 worth of rounding to Max.x to that text in long menus don't tend to display over the lower-right rounded area, which looks particularly glitchy.
	ImRect bar_rect = window->MenuBarRect();
	ImRect clip_rect(ImFloor(bar_rect.Min.x + 0.5f), ImFloor(bar_rect.Min.y + window->WindowBorderSize + 0.5f), ImFloor(ImMax(bar_rect.Min.x, bar_rect.Max.x - window->WindowRounding) + 0.5f), ImFloor(bar_rect.Max.y + 0.5f));
	clip_rect.ClipWith(window->WindowRectClipped);
	PushClipRect(clip_rect.Min, clip_rect.Max, false);

	window->DC.CursorPos = ImVec2(bar_rect.Min.x + window->DC.MenuBarOffsetX, bar_rect.Min.y);// + g.Style.FramePadding.y);
	window->DC.LayoutType = ImGuiLayoutType_Horizontal;
	window->DC.NavLayerCurrent++;
	window->DC.NavLayerCurrentMask <<= 1;
	window->DC.MenuBarAppending = true;
	AlignTextToFramePadding();
	return true;
}

void ImGui::EndMenuBar()
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;
	ImGuiContext& g = *GImGui;

	// Nav: When a move request within one of our child menu failed, capture the request to navigate among our siblings.
	if (NavMoveRequestButNoResultYet() && (g.NavMoveDir == ImGuiDir_Left || g.NavMoveDir == ImGuiDir_Right) && (g.NavWindow->Flags & ImGuiWindowFlags_ChildMenu))
	{
		ImGuiWindow* nav_earliest_child = g.NavWindow;
		while (nav_earliest_child->ParentWindow && (nav_earliest_child->ParentWindow->Flags & ImGuiWindowFlags_ChildMenu))
			nav_earliest_child = nav_earliest_child->ParentWindow;
		if (nav_earliest_child->ParentWindow == window && nav_earliest_child->DC.ParentLayoutType == ImGuiLayoutType_Horizontal && g.NavMoveRequestForward == ImGuiNavForward_None)
		{
			// To do so we claim focus back, restore NavId and then process the movement request for yet another frame.
			// This involve a one-frame delay which isn't very problematic in this situation. We could remove it by scoring in advance for multiple window (probably not worth the hassle/cost)
			IM_ASSERT(window->DC.NavLayerActiveMaskNext & 0x02); // Sanity check
			FocusWindow(window);
			SetNavIDWithRectRel(window->NavLastIds[1], 1, window->NavRectRel[1]);
			g.NavLayer = 1;
			g.NavDisableHighlight = true; // Hide highlight for the current frame so we don't see the intermediary selection.
			g.NavMoveRequestForward = ImGuiNavForward_ForwardQueued;
			NavMoveRequestCancel();
		}
	}

	IM_ASSERT(window->Flags & ImGuiWindowFlags_MenuBar);
	IM_ASSERT(window->DC.MenuBarAppending);
	PopClipRect();
	PopID();
	window->DC.MenuBarOffsetX = window->DC.CursorPos.x - window->MenuBarRect().Min.x;
	window->DC.GroupStack.back().AdvanceCursor = false;
	EndGroup();
	window->DC.LayoutType = ImGuiLayoutType_Vertical;
	window->DC.NavLayerCurrent--;
	window->DC.NavLayerCurrentMask >>= 1;
	window->DC.MenuBarAppending = false;
}

bool ImGui::BeginMenu(const char* label, bool enabled)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const ImGuiID id = window->GetID(label);

	ImVec2 label_size = CalcTextSize(label, NULL, true);

	bool pressed;
	bool menu_is_open = IsPopupOpen(id);
	bool menuset_is_open = !(window->Flags & ImGuiWindowFlags_Popup) && (g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].OpenParentId == window->IDStack.back());
	ImGuiWindow* backed_nav_window = g.NavWindow;
	if (menuset_is_open)
		g.NavWindow = window;  // Odd hack to allow hovering across menus of a same menu-set (otherwise we wouldn't be able to hover parent)

							   // The reference position stored in popup_pos will be used by Begin() to find a suitable position for the child menu (using FindBestPopupWindowPos).
	ImVec2 popup_pos, pos = window->DC.CursorPos;
	if (window->DC.LayoutType == ImGuiLayoutType_Horizontal)
	{
		// Menu inside an horizontal menu bar
		// Selectable extend their highlight by half ItemSpacing in each direction.
		// For ChildMenu, the popup position will be overwritten by the call to FindBestPopupWindowPos() in Begin()
		popup_pos = ImVec2(pos.x - window->WindowPadding.x, pos.y - style.FramePadding.y + window->MenuBarHeight());
		window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * 0.5f);
		PushStyleVar(ImGuiStyleVar_ItemSpacing, style.ItemSpacing * 2.0f);
		float w = label_size.x;
		pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_Menu | ImGuiSelectableFlags_DontClosePopups | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));
		PopStyleVar();
		window->DC.CursorPos.x += (float)(int)(style.ItemSpacing.x * (-1.0f + 0.5f)); // -1 spacing to compensate the spacing added when Selectable() did a SameLine(). It would also work to call SameLine() ourselves after the PopStyleVar().
	}
	else
	{
		// Menu inside a menu
		popup_pos = ImVec2(pos.x, pos.y - style.WindowPadding.y);
		float w = window->MenuColumns.DeclColumns(label_size.x, 0.0f, (float)(int)(g.FontSize * 1.20f)); // Feedback to next frame
		float extra_w = ImMax(0.0f, GetContentRegionAvail().x - w);
		pressed = Selectable(label, menu_is_open, ImGuiSelectableFlags_Menu | ImGuiSelectableFlags_DontClosePopups | ImGuiSelectableFlags_DrawFillAvailWidth | (!enabled ? ImGuiSelectableFlags_Disabled : 0), ImVec2(w, 0.0f));
		if (!enabled) PushStyleColor(ImGuiCol_Text, g.Style.Colors[ImGuiCol_TextDisabled]);
		RenderArrow(pos + ImVec2(window->MenuColumns.Pos[2] + extra_w + g.FontSize * 0.30f, 0.0f), ImGuiDir_Right);
		if (!enabled) PopStyleColor();
	}

	const bool hovered = enabled && ItemHoverable(window->DC.LastItemRect, id);
	if (menuset_is_open)
		g.NavWindow = backed_nav_window;

	bool want_open = false, want_close = false;
	if (window->DC.LayoutType == ImGuiLayoutType_Vertical) // (window->Flags & (ImGuiWindowFlags_Popup|ImGuiWindowFlags_ChildMenu))
	{
		// Implement http://bjk5.com/post/44698559168/breaking-down-amazons-mega-dropdown to avoid using timers, so menus feels more reactive.
		bool moving_within_opened_triangle = false;
		if (g.HoveredWindow == window && g.OpenPopupStack.Size > g.CurrentPopupStack.Size && g.OpenPopupStack[g.CurrentPopupStack.Size].ParentWindow == window && !(window->Flags & ImGuiWindowFlags_MenuBar))
		{
			if (ImGuiWindow* next_window = g.OpenPopupStack[g.CurrentPopupStack.Size].Window)
			{
				ImRect next_window_rect = next_window->Rect();
				ImVec2 ta = g.IO.MousePos - g.IO.MouseDelta;
				ImVec2 tb = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetTL() : next_window_rect.GetTR();
				ImVec2 tc = (window->Pos.x < next_window->Pos.x) ? next_window_rect.GetBL() : next_window_rect.GetBR();
				float extra = ImClamp(fabsf(ta.x - tb.x) * 0.30f, 5.0f, 30.0f); // add a bit of extra slack.
				ta.x += (window->Pos.x < next_window->Pos.x) ? -0.5f : +0.5f;   // to avoid numerical issues
				tb.y = ta.y + ImMax((tb.y - extra) - ta.y, -100.0f);            // triangle is maximum 200 high to limit the slope and the bias toward large sub-menus // FIXME: Multiply by fb_scale?
				tc.y = ta.y + ImMin((tc.y + extra) - ta.y, +100.0f);
				moving_within_opened_triangle = ImTriangleContainsPoint(ta, tb, tc, g.IO.MousePos);
				//window->DrawList->PushClipRectFullScreen(); window->DrawList->AddTriangleFilled(ta, tb, tc, moving_within_opened_triangle ? IM_COL32(0,128,0,128) : IM_COL32(128,0,0,128)); window->DrawList->PopClipRect(); // Debug
			}
		}

		want_close = (menu_is_open && !hovered && g.HoveredWindow == window && g.HoveredIdPreviousFrame != 0 && g.HoveredIdPreviousFrame != id && !moving_within_opened_triangle);
		want_open = (!menu_is_open && hovered && !moving_within_opened_triangle) || (!menu_is_open && hovered && pressed);

		if (g.NavActivateId == id)
		{
			want_close = menu_is_open;
			want_open = !menu_is_open;
		}
		if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Right) // Nav-Right to open
		{
			want_open = true;
			NavMoveRequestCancel();
		}
	}
	else
	{
		// Menu bar
		if (menu_is_open && pressed && menuset_is_open) // Click an open menu again to close it
		{
			want_close = true;
			want_open = menu_is_open = false;
		}
		else if (pressed || (hovered && menuset_is_open && !menu_is_open)) // First click to open, then hover to open others
		{
			want_open = true;
		}
		else if (g.NavId == id && g.NavMoveRequest && g.NavMoveDir == ImGuiDir_Down) // Nav-Down to open
		{
			want_open = true;
			NavMoveRequestCancel();
		}
	}

	if (!enabled) // explicitly close if an open menu becomes disabled, facilitate users code a lot in pattern such as 'if (BeginMenu("options", has_object)) { ..use object.. }'
		want_close = true;
	if (want_close && IsPopupOpen(id))
		ClosePopupToLevel(g.CurrentPopupStack.Size);

	if (!menu_is_open && want_open && g.OpenPopupStack.Size > g.CurrentPopupStack.Size)
	{
		// Don't recycle same menu level in the same frame, first close the other menu and yield for a frame.
		OpenPopup(label);
		return false;
	}

	menu_is_open |= want_open;
	if (want_open)
		OpenPopup(label);

	if (menu_is_open)
	{
		SetNextWindowPos(popup_pos, ImGuiCond_Always);
		ImGuiWindowFlags flags = ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoSavedSettings | ((window->Flags & (ImGuiWindowFlags_Popup | ImGuiWindowFlags_ChildMenu)) ? ImGuiWindowFlags_ChildMenu | ImGuiWindowFlags_ChildWindow : ImGuiWindowFlags_ChildMenu);
		menu_is_open = BeginPopupEx(id, flags); // menu_is_open can be 'false' when the popup is completely clipped (e.g. zero size display)
	}

	return menu_is_open;
}

void ImGui::EndMenu()
{
	// Nav: When a left move request _within our child menu_ failed, close the menu.
	// A menu doesn't close itself because EndMenuBar() wants the catch the last Left<>Right inputs.
	// However it means that with the current code, a BeginMenu() from outside another menu or a menu-bar won't be closable with the Left direction.
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	if (g.NavWindow && g.NavWindow->ParentWindow == window && g.NavMoveDir == ImGuiDir_Left && NavMoveRequestButNoResultYet() && window->DC.LayoutType == ImGuiLayoutType_Vertical)
	{
		ClosePopupToLevel(g.OpenPopupStack.Size - 1);
		NavMoveRequestCancel();
	}

	EndPopup();
}

// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
void ImGui::ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags)
{
	ImGuiContext& g = *GImGui;

	int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
	BeginTooltipEx(0, true);

	const char* text_end = text ? FindRenderedTextEnd(text, NULL) : text;
	if (text_end > text)
	{
		TextUnformatted(text, text_end);
		Separator();
	}

	ImVec2 sz(g.FontSize * 3 + g.Style.FramePadding.y * 2, g.FontSize * 3 + g.Style.FramePadding.y * 2);
	ColorButton("##preview", ImVec4(col[0], col[1], col[2], col[3]), (flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf)) | ImGuiColorEditFlags_NoTooltip, sz);
	SameLine();
	if (flags & ImGuiColorEditFlags_NoAlpha)
		Text("#%02X%02X%02X\nR: %d, G: %d, B: %d\n(%.3f, %.3f, %.3f)", cr, cg, cb, cr, cg, cb, col[0], col[1], col[2]);
	else
		Text("#%02X%02X%02X%02X\nR:%d, G:%d, B:%d, A:%d\n(%.3f, %.3f, %.3f, %.3f)", cr, cg, cb, ca, cr, cg, cb, ca, col[0], col[1], col[2], col[3]);
	EndTooltip();
}

static inline ImU32 ImAlphaBlendColor(ImU32 col_a, ImU32 col_b)
{
	float t = ((col_b >> IM_COL32_A_SHIFT) & 0xFF) / 255.f;
	int r = ImLerp((int)(col_a >> IM_COL32_R_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_R_SHIFT) & 0xFF, t);
	int g = ImLerp((int)(col_a >> IM_COL32_G_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_G_SHIFT) & 0xFF, t);
	int b = ImLerp((int)(col_a >> IM_COL32_B_SHIFT) & 0xFF, (int)(col_b >> IM_COL32_B_SHIFT) & 0xFF, t);
	return IM_COL32(r, g, b, 0xFF);
}

// NB: This is rather brittle and will show artifact when rounding this enabled if rounded corners overlap multiple cells. Caller currently responsible for avoiding that.
// I spent a non reasonable amount of time trying to getting this right for ColorButton with rounding+anti-aliasing+ImGuiColorEditFlags_HalfAlphaPreview flag + various grid sizes and offsets, and eventually gave up... probably more reasonable to disable rounding alltogether.
void ImGui::RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 col, float grid_step, ImVec2 grid_off, float rounding, int rounding_corners_flags)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (((col & IM_COL32_A_MASK) >> IM_COL32_A_SHIFT) < 0xFF)
	{
		ImU32 col_bg1 = GetColorU32(ImAlphaBlendColor(IM_COL32(204, 204, 204, 255), col));
		ImU32 col_bg2 = GetColorU32(ImAlphaBlendColor(IM_COL32(128, 128, 128, 255), col));
		window->DrawList->AddRectFilled(p_min, p_max, col_bg1, rounding, rounding_corners_flags);

		int yi = 0;
		for (float y = p_min.y + grid_off.y; y < p_max.y; y += grid_step, yi++)
		{
			float y1 = ImClamp(y, p_min.y, p_max.y), y2 = ImMin(y + grid_step, p_max.y);
			if (y2 <= y1)
				continue;
			for (float x = p_min.x + grid_off.x + (yi & 1) * grid_step; x < p_max.x; x += grid_step * 2.0f)
			{
				float x1 = ImClamp(x, p_min.x, p_max.x), x2 = ImMin(x + grid_step, p_max.x);
				if (x2 <= x1)
					continue;
				int rounding_corners_flags_cell = 0;
				if (y1 <= p_min.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_TopRight; }
				if (y2 >= p_max.y) { if (x1 <= p_min.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotLeft; if (x2 >= p_max.x) rounding_corners_flags_cell |= ImDrawCornerFlags_BotRight; }
				rounding_corners_flags_cell &= rounding_corners_flags;
				window->DrawList->AddRectFilled(ImVec2(x1, y1), ImVec2(x2, y2), col_bg2, rounding_corners_flags_cell ? rounding : 0.0f, rounding_corners_flags_cell);
			}
		}
	}
	else
	{
		window->DrawList->AddRectFilled(p_min, p_max, col, rounding, rounding_corners_flags);
	}
}

void ImGui::SetColorEditOptions(ImGuiColorEditFlags flags)
{
	ImGuiContext& g = *GImGui;
	if ((flags & ImGuiColorEditFlags__InputsMask) == 0)
		flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__InputsMask;
	if ((flags & ImGuiColorEditFlags__DataTypeMask) == 0)
		flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__DataTypeMask;
	if ((flags & ImGuiColorEditFlags__PickerMask) == 0)
		flags |= ImGuiColorEditFlags__OptionsDefault & ImGuiColorEditFlags__PickerMask;
	IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__InputsMask)));   // Check only 1 option is selected
	IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__DataTypeMask))); // Check only 1 option is selected
	IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask)));   // Check only 1 option is selected
	g.ColorEditOptions = flags;
}

// A little colored square. Return true when clicked.
// FIXME: May want to display/ignore the alpha component in the color display? Yet show it in the tooltip.
// 'desc_id' is not called 'label' because we don't display it next to the button, but only in the tooltip.
bool ImGui::ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags, ImVec2 size)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiID id = window->GetID(desc_id);
	float default_size = GetFrameHeight();
	if (size.x == 0.0f)
		size.x = default_size;
	if (size.y == 0.0f)
		size.y = default_size;
	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
	ItemSize(bb, (size.y >= default_size) ? g.Style.FramePadding.y : 0.0f);
	if (!ItemAdd(bb, id))
		return false;

	bool hovered, held;
	bool pressed = ButtonBehavior(bb, id, &hovered, &held);

	if (flags & ImGuiColorEditFlags_NoAlpha)
		flags &= ~(ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf);

	ImVec4 col_without_alpha(col.x, col.y, col.z, 1.0f);
	float grid_step = ImMin(size.x, size.y) / 2.99f;
	float rounding = ImMin(g.Style.FrameRounding, grid_step * 0.5f);
	ImRect bb_inner = bb;
	float off = -0.75f; // The border (using Col_FrameBg) tends to look off when color is near-opaque and rounding is enabled. This offset seemed like a good middle ground to reduce those artifacts.
	bb_inner.Expand(off);
	if ((flags & ImGuiColorEditFlags_AlphaPreviewHalf) && col.w < 1.0f)
	{
		float mid_x = (float)(int)((bb_inner.Min.x + bb_inner.Max.x) * 0.5f + 0.5f);
		RenderColorRectWithAlphaCheckerboard(ImVec2(bb_inner.Min.x + grid_step, bb_inner.Min.y), bb_inner.Max, GetColorU32(col), grid_step, ImVec2(-grid_step + off, off), rounding, ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight);
		window->DrawList->AddRectFilled(bb_inner.Min, ImVec2(mid_x, bb_inner.Max.y), GetColorU32(col_without_alpha), rounding, ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft);
	}
	else
	{
		// Because GetColorU32() multiplies by the global style Alpha and we don't want to display a checkerboard if the source code had no alpha
		ImVec4 col_source = (flags & ImGuiColorEditFlags_AlphaPreview) ? col : col_without_alpha;
		if (col_source.w < 1.0f)
			RenderColorRectWithAlphaCheckerboard(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), grid_step, ImVec2(off, off), rounding);
		else
			window->DrawList->AddRectFilled(bb_inner.Min, bb_inner.Max, GetColorU32(col_source), rounding, ImDrawCornerFlags_All);
	}

	RenderNavHighlight(bb, id);
	//if (g.Style.FrameBorderSize > 0.0f)
		//RenderFrameBorder(bb.Min, bb.Max, rounding);
	//else
		//window->DrawList->AddRect(bb.Min, bb.Max, GetColorU32(ImGuiCol_FrameBg), rounding); // Color button are often in need of some sort of border

																							// Drag and Drop Source
	if (g.ActiveId == id && BeginDragDropSource()) // NB: The ActiveId test is merely an optional micro-optimization
	{
		if (flags & ImGuiColorEditFlags_NoAlpha)
			SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F, &col, sizeof(float) * 3, ImGuiCond_Once);
		else
			SetDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F, &col, sizeof(float) * 4, ImGuiCond_Once);
		ColorButton(desc_id, col, flags);
		SameLine();
		TextUnformatted("Color");
		EndDragDropSource();
		hovered = false;
	}

	// Tooltip
	if (!(flags & ImGuiColorEditFlags_NoTooltip) && hovered)
		ColorTooltip(desc_id, &col.x, flags & (ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf));

	return pressed;
}

bool ImGui::ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags)
{
	return ColorEdit4(label, col, flags | ImGuiColorEditFlags_NoAlpha);
}

void ImGui::ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags)
{
	bool allow_opt_inputs = !(flags & ImGuiColorEditFlags__InputsMask);
	bool allow_opt_datatype = !(flags & ImGuiColorEditFlags__DataTypeMask);
	if ((!allow_opt_inputs && !allow_opt_datatype) || !BeginPopup("context"))
		return;
	ImGuiContext& g = *GImGui;
	ImGuiColorEditFlags opts = g.ColorEditOptions;
	if (allow_opt_inputs)
	{
		if (RadioButton("RGB", (opts & ImGuiColorEditFlags_RGB) ? 1 : 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_RGB;
		if (RadioButton("HSV", (opts & ImGuiColorEditFlags_HSV) ? 1 : 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HSV;
		if (RadioButton("HEX", (opts & ImGuiColorEditFlags_HEX) ? 1 : 0)) opts = (opts & ~ImGuiColorEditFlags__InputsMask) | ImGuiColorEditFlags_HEX;
	}
	if (allow_opt_datatype)
	{
		if (allow_opt_inputs) Separator();
		if (RadioButton("0..255", (opts & ImGuiColorEditFlags_Uint8) ? 1 : 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Uint8;
		if (RadioButton("0.00..1.00", (opts & ImGuiColorEditFlags_Float) ? 1 : 0)) opts = (opts & ~ImGuiColorEditFlags__DataTypeMask) | ImGuiColorEditFlags_Float;
	}

	if (allow_opt_inputs || allow_opt_datatype)
		Separator();
	if (Button("Copy as..", ImVec2(-1, 0)))
		OpenPopup("Copy");
	if (BeginPopup("Copy"))
	{
		int cr = IM_F32_TO_INT8_SAT(col[0]), cg = IM_F32_TO_INT8_SAT(col[1]), cb = IM_F32_TO_INT8_SAT(col[2]), ca = (flags & ImGuiColorEditFlags_NoAlpha) ? 255 : IM_F32_TO_INT8_SAT(col[3]);
		char buf[64];
		ImFormatString(buf, IM_ARRAYSIZE(buf), "(%.3ff, %.3ff, %.3ff, %.3ff)", col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
		if (Selectable(buf))
			SetClipboardText(buf);
		ImFormatString(buf, IM_ARRAYSIZE(buf), "(%d,%d,%d,%d)", cr, cg, cb, ca);
		if (Selectable(buf))
			SetClipboardText(buf);
		if (flags & ImGuiColorEditFlags_NoAlpha)
			ImFormatString(buf, IM_ARRAYSIZE(buf), "0x%02X%02X%02X", cr, cg, cb);
		else
			ImFormatString(buf, IM_ARRAYSIZE(buf), "0x%02X%02X%02X%02X", cr, cg, cb, ca);
		if (Selectable(buf))
			SetClipboardText(buf);
		EndPopup();
	}

	g.ColorEditOptions = opts;
	EndPopup();
}

static void ColorPickerOptionsPopup(ImGuiColorEditFlags flags, const float* ref_col)
{
	bool allow_opt_picker = !(flags & ImGuiColorEditFlags__PickerMask);
	bool allow_opt_alpha_bar = !(flags & ImGuiColorEditFlags_NoAlpha) && !(flags & ImGuiColorEditFlags_AlphaBar);
	if ((!allow_opt_picker && !allow_opt_alpha_bar) || !ImGui::BeginPopup("context"))
		return;
	ImGuiContext& g = *GImGui;
	if (allow_opt_picker)
	{
		ImVec2 picker_size(g.FontSize * 8, ImMax(g.FontSize * 8 - (ImGui::GetFrameHeight() + g.Style.ItemInnerSpacing.x), 1.0f)); // FIXME: Picker size copied from main picker function
		ImGui::PushItemWidth(picker_size.x);
		for (int picker_type = 0; picker_type < 2; picker_type++)
		{
			// Draw small/thumbnail version of each picker type (over an invisible button for selection)
			if (picker_type > 0) ImGui::Separator();
			ImGui::PushID(picker_type);
			ImGuiColorEditFlags picker_flags = ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_NoSidePreview | (flags & ImGuiColorEditFlags_NoAlpha);
			if (picker_type == 0) picker_flags |= ImGuiColorEditFlags_PickerHueBar;
			if (picker_type == 1) picker_flags |= ImGuiColorEditFlags_PickerHueWheel;
			ImVec2 backup_pos = ImGui::GetCursorScreenPos();
			if (ImGui::Selectable("##selectable", false, 0, picker_size)) // By default, Selectable() is closing popup
				g.ColorEditOptions = (g.ColorEditOptions & ~ImGuiColorEditFlags__PickerMask) | (picker_flags & ImGuiColorEditFlags__PickerMask);
			ImGui::SetCursorScreenPos(backup_pos);
			ImVec4 dummy_ref_col;
			memcpy(&dummy_ref_col.x, ref_col, sizeof(float) * (picker_flags & ImGuiColorEditFlags_NoAlpha ? 3 : 4));
			ImGui::ColorPicker4("##dummypicker", &dummy_ref_col.x, picker_flags);
			ImGui::PopID();
		}
		ImGui::PopItemWidth();
	}
	if (allow_opt_alpha_bar)
	{
		if (allow_opt_picker) ImGui::Separator();
		ImGui::CheckboxFlags("Alpha Bar", (unsigned int*)&g.ColorEditOptions, ImGuiColorEditFlags_AlphaBar);
	}
	ImGui::EndPopup();
}

// Edit colors components (each component in 0.0f..1.0f range).
// See enum ImGuiColorEditFlags_ for available options. e.g. Only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// With typical options: Left-click on colored square to open color picker. Right-click to open option menu. CTRL-Click over input fields to edit them and TAB to go to next item.
bool ImGui::ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	const ImGuiStyle& style = g.Style;
	const float square_sz = GetFrameHeight();
	const float w_extra = (flags & ImGuiColorEditFlags_NoSmallPreview) ? 0.0f : (square_sz + style.ItemInnerSpacing.x);
	const float w_items_all = CalcItemWidth() - w_extra;
	const char* label_display_end = FindRenderedTextEnd(label);

	const bool alpha = (flags & ImGuiColorEditFlags_NoAlpha) == 0;
	const bool hdr = (flags & ImGuiColorEditFlags_HDR) != 0;
	const int components = alpha ? 4 : 3;
	const ImGuiColorEditFlags flags_untouched = flags;

	BeginGroup();
	PushID(label);

	// If we're not showing any slider there's no point in doing any HSV conversions
	if (flags & ImGuiColorEditFlags_NoInputs)
		flags = (flags & (~ImGuiColorEditFlags__InputsMask)) | ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_NoOptions;

	// Context menu: display and modify options (before defaults are applied)
	if (!(flags & ImGuiColorEditFlags_NoOptions))
		ColorEditOptionsPopup(col, flags);

	// Read stored options
	if (!(flags & ImGuiColorEditFlags__InputsMask))
		flags |= (g.ColorEditOptions & ImGuiColorEditFlags__InputsMask);
	if (!(flags & ImGuiColorEditFlags__DataTypeMask))
		flags |= (g.ColorEditOptions & ImGuiColorEditFlags__DataTypeMask);
	if (!(flags & ImGuiColorEditFlags__PickerMask))
		flags |= (g.ColorEditOptions & ImGuiColorEditFlags__PickerMask);
	flags |= (g.ColorEditOptions & ~(ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask));

	// Convert to the formats we need
	float f[4] = { col[0], col[1], col[2], alpha ? col[3] : 1.0f };
	if (flags & ImGuiColorEditFlags_HSV)
		ColorConvertRGBtoHSV(f[0], f[1], f[2], f[0], f[1], f[2]);
	int i[4] = { IM_F32_TO_INT8_UNBOUND(f[0]), IM_F32_TO_INT8_UNBOUND(f[1]), IM_F32_TO_INT8_UNBOUND(f[2]), IM_F32_TO_INT8_UNBOUND(f[3]) };

	bool value_changed = false;
	bool value_changed_as_float = false;

	if ((flags & (ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_HSV)) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)
	{
		// RGB/HSV 0..255 Sliders
		const float w_item_one = ImMax(1.0f, (float)(int)((w_items_all - (style.ItemInnerSpacing.x) * (components - 1)) / (float)components));
		const float w_item_last = ImMax(1.0f, (float)(int)(w_items_all - (w_item_one + style.ItemInnerSpacing.x) * (components - 1)));

		const bool hide_prefix = (w_item_one <= CalcTextSize((flags & ImGuiColorEditFlags_Float) ? "M:0.000" : "M:000").x);
		const char* ids[4] = { "##X", "##Y", "##Z", "##W" };
		const char* fmt_table_int[3][4] =
		{
			{ "%3.0f",   "%3.0f",   "%3.0f",   "%3.0f" }, // Short display
		{ "R:%3.0f", "G:%3.0f", "B:%3.0f", "A:%3.0f" }, // Long display for RGBA
		{ "H:%3.0f", "S:%3.0f", "V:%3.0f", "A:%3.0f" }  // Long display for HSVA
		};
		const char* fmt_table_float[3][4] =
		{
			{ "%0.3f",   "%0.3f",   "%0.3f",   "%0.3f" }, // Short display
		{ "R:%0.3f", "G:%0.3f", "B:%0.3f", "A:%0.3f" }, // Long display for RGBA
		{ "H:%0.3f", "S:%0.3f", "V:%0.3f", "A:%0.3f" }  // Long display for HSVA
		};
		const int fmt_idx = hide_prefix ? 0 : (flags & ImGuiColorEditFlags_HSV) ? 2 : 1;

		/*
		PushItemWidth(w_item_one);
		for (int n = 0; n < components; n++)
		{
			if (n > 0)
				SameLine(0, style.ItemInnerSpacing.x);
			if (n + 1 == components)
				PushItemWidth(w_item_last);
			if (flags & ImGuiColorEditFlags_Float)
				value_changed = value_changed_as_float = value_changed | DragFloat(ids[n], &f[n], 1.0f / 255.0f, 0.0f, hdr ? 0.0f : 1.0f, fmt_table_float[fmt_idx][n]);
			else
				value_changed |= DragInt(ids[n], &i[n], 1.0f, 0, hdr ? 0 : 255, fmt_table_int[fmt_idx][n]);
			if (!(flags & ImGuiColorEditFlags_NoOptions))
				OpenPopupOnItemClick("context");
		}
		PopItemWidth();
		PopItemWidth();
		*/
	}
	else if ((flags & ImGuiColorEditFlags_HEX) != 0 && (flags & ImGuiColorEditFlags_NoInputs) == 0)
	{
		// RGB Hexadecimal Input
		char buf[64];
		if (alpha)
			ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255), ImClamp(i[3], 0, 255));
		else
			ImFormatString(buf, IM_ARRAYSIZE(buf), "#%02X%02X%02X", ImClamp(i[0], 0, 255), ImClamp(i[1], 0, 255), ImClamp(i[2], 0, 255));
		PushItemWidth(w_items_all);
		if (InputText("##Text", buf, IM_ARRAYSIZE(buf), ImGuiInputTextFlags_CharsHexadecimal | ImGuiInputTextFlags_CharsUppercase))
		{
			value_changed = true;
			char* p = buf;
			while (*p == '#' || ImCharIsSpace((unsigned int)*p))
				p++;
			i[0] = i[1] = i[2] = i[3] = 0;
			if (alpha)
				sscanf(p, "%02X%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2], (unsigned int*)&i[3]); // Treat at unsigned (%X is unsigned)
			else
				sscanf(p, "%02X%02X%02X", (unsigned int*)&i[0], (unsigned int*)&i[1], (unsigned int*)&i[2]);
		}
		if (!(flags & ImGuiColorEditFlags_NoOptions))
			OpenPopupOnItemClick("context");
		PopItemWidth();
	}

	ImGuiWindow* picker_active_window = NULL;
	if (!(flags & ImGuiColorEditFlags_NoSmallPreview))
	{
		//if (!(flags & ImGuiColorEditFlags_NoInputs))
			//SameLine(0, style.ItemInnerSpacing.x);

		const ImVec4 col_v4(col[0], col[1], col[2], alpha ? col[3] : 1.0f);
		if (ColorButton("##ColorButton", col_v4, flags))
		{
			if (!(flags & ImGuiColorEditFlags_NoPicker))
			{
				// Store current color and open a picker
				g.ColorPickerRef = col_v4;
				OpenPopup("picker");
				SetNextWindowPos(window->DC.LastItemRect.GetBL() + ImVec2(-1, style.ItemSpacing.y));
			}
		}
		if (!(flags & ImGuiColorEditFlags_NoOptions))
			OpenPopupOnItemClick("context");

		if (BeginPopup("picker"))
		{
			picker_active_window = g.CurrentWindow;
			if (label != label_display_end)
			{
				TextUnformatted(label, label_display_end);
				Separator();
			}
			ImGuiColorEditFlags picker_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags__PickerMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_AlphaBar;
			ImGuiColorEditFlags picker_flags = (flags_untouched & picker_flags_to_forward) | ImGuiColorEditFlags__InputsMask | ImGuiColorEditFlags_NoLabel | ImGuiColorEditFlags_AlphaPreviewHalf;
			PushItemWidth(square_sz * 12.0f); // Use 256 + bar sizes?
			value_changed |= ColorPicker4("##picker", col, picker_flags, &g.ColorPickerRef.x);
			PopItemWidth();
			EndPopup();
		}
	}

	if (label != label_display_end && !(flags & ImGuiColorEditFlags_NoLabel))
	{
		SameLine(0, style.ItemInnerSpacing.x);
		TextUnformatted(label, label_display_end);
	}

	// Convert back
	if (picker_active_window == NULL)
	{
		if (!value_changed_as_float)
			for (int n = 0; n < 4; n++)
				f[n] = i[n] / 255.0f;
		if (flags & ImGuiColorEditFlags_HSV)
			ColorConvertHSVtoRGB(f[0], f[1], f[2], f[0], f[1], f[2]);
		if (value_changed)
		{
			col[0] = f[0];
			col[1] = f[1];
			col[2] = f[2];
			if (alpha)
				col[3] = f[3];
		}
	}

	PopID();
	EndGroup();

	// Drag and Drop Target
	if ((window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) && BeginDragDropTarget()) // NB: The flag test is merely an optional micro-optimization, BeginDragDropTarget() does the same test.
	{
		if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_3F))
		{
			memcpy((float*)col, payload->Data, sizeof(float) * 3);
			value_changed = true;
		}
		if (const ImGuiPayload* payload = AcceptDragDropPayload(IMGUI_PAYLOAD_TYPE_COLOR_4F))
		{
			memcpy((float*)col, payload->Data, sizeof(float) * components);
			value_changed = true;
		}
		EndDragDropTarget();
	}

	// When picker is being actively used, use its active id so IsItemActive() will function on ColorEdit4().
	if (picker_active_window && g.ActiveId != 0 && g.ActiveIdWindow == picker_active_window)
		window->DC.LastItemId = g.ActiveId;

	return value_changed;
}

bool ImGui::ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags)
{
	float col4[4] = { col[0], col[1], col[2], 1.0f };
	if (!ColorPicker4(label, col4, flags | ImGuiColorEditFlags_NoAlpha))
		return false;
	col[0] = col4[0]; col[1] = col4[1]; col[2] = col4[2];
	return true;
}

// 'pos' is position of the arrow tip. half_sz.x is length from base to tip. half_sz.y is length on each side.
static void RenderArrow(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, ImGuiDir direction, ImU32 col)
{
	switch (direction)
	{
	case ImGuiDir_Left:  draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), pos, col); return;
	case ImGuiDir_Right: draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), pos, col); return;
	case ImGuiDir_Up:    draw_list->AddTriangleFilled(ImVec2(pos.x + half_sz.x, pos.y + half_sz.y), ImVec2(pos.x - half_sz.x, pos.y + half_sz.y), pos, col); return;
	case ImGuiDir_Down:  draw_list->AddTriangleFilled(ImVec2(pos.x - half_sz.x, pos.y - half_sz.y), ImVec2(pos.x + half_sz.x, pos.y - half_sz.y), pos, col); return;
	case ImGuiDir_None: case ImGuiDir_COUNT: break; // Fix warnings
	}
}

static void RenderArrowsForVerticalBar(ImDrawList* draw_list, ImVec2 pos, ImVec2 half_sz, float bar_w)
{
	RenderArrow(draw_list, ImVec2(pos.x + half_sz.x + 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Right, IM_COL32_BLACK);
	RenderArrow(draw_list, ImVec2(pos.x + half_sz.x, pos.y), half_sz, ImGuiDir_Right, IM_COL32_WHITE);
	RenderArrow(draw_list, ImVec2(pos.x + bar_w - half_sz.x - 1, pos.y), ImVec2(half_sz.x + 2, half_sz.y + 1), ImGuiDir_Left, IM_COL32_BLACK);
	RenderArrow(draw_list, ImVec2(pos.x + bar_w - half_sz.x, pos.y), half_sz, ImGuiDir_Left, IM_COL32_WHITE);
}

// ColorPicker
// Note: only access 3 floats if ImGuiColorEditFlags_NoAlpha flag is set.
// FIXME: we adjust the big color square height based on item width, which may cause a flickering feedback loop (if automatic height makes a vertical scrollbar appears, affecting automatic width..)
bool ImGui::ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags, const float* ref_col)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();
	ImDrawList* draw_list = window->DrawList;

	ImGuiStyle& style = g.Style;
	ImGuiIO& io = g.IO;

	PushID(label);
	BeginGroup();

	if (!(flags & ImGuiColorEditFlags_NoSidePreview))
		flags |= ImGuiColorEditFlags_NoSmallPreview;

	// Context menu: display and store options.
	if (!(flags & ImGuiColorEditFlags_NoOptions))
		ColorPickerOptionsPopup(flags, col);

	// Read stored options
	if (!(flags & ImGuiColorEditFlags__PickerMask))
		flags |= ((g.ColorEditOptions & ImGuiColorEditFlags__PickerMask) ? g.ColorEditOptions : ImGuiColorEditFlags__OptionsDefault) & ImGuiColorEditFlags__PickerMask;
	IM_ASSERT(ImIsPowerOfTwo((int)(flags & ImGuiColorEditFlags__PickerMask))); // Check that only 1 is selected
	if (!(flags & ImGuiColorEditFlags_NoOptions))
		flags |= (g.ColorEditOptions & ImGuiColorEditFlags_AlphaBar);

	// Setup
	int components = (flags & ImGuiColorEditFlags_NoAlpha) ? 3 : 4;
	bool alpha_bar = (flags & ImGuiColorEditFlags_AlphaBar) && !(flags & ImGuiColorEditFlags_NoAlpha);
	ImVec2 picker_pos = window->DC.CursorPos;
	float square_sz = GetFrameHeight();
	float bars_width = square_sz; // Arbitrary smallish width of Hue/Alpha picking bars
	float sv_picker_size = ImMax(bars_width * 1, CalcItemWidth() - (alpha_bar ? 2 : 1) * (bars_width + style.ItemInnerSpacing.x)); // Saturation/Value picking box
	float bar0_pos_x = picker_pos.x + sv_picker_size + style.ItemInnerSpacing.x;
	float bar1_pos_x = bar0_pos_x + bars_width + style.ItemInnerSpacing.x;
	float bars_triangles_half_sz = (float)(int)(bars_width * 0.20f);

	float backup_initial_col[4];
	memcpy(backup_initial_col, col, components * sizeof(float));

	float wheel_thickness = sv_picker_size * 0.08f;
	float wheel_r_outer = sv_picker_size * 0.50f;
	float wheel_r_inner = wheel_r_outer - wheel_thickness;
	ImVec2 wheel_center(picker_pos.x + (sv_picker_size + bars_width) * 0.5f, picker_pos.y + sv_picker_size * 0.5f);

	// Note: the triangle is displayed rotated with triangle_pa pointing to Hue, but most coordinates stays unrotated for logic.
	float triangle_r = wheel_r_inner - (int)(sv_picker_size * 0.027f);
	ImVec2 triangle_pa = ImVec2(triangle_r, 0.0f); // Hue point.
	ImVec2 triangle_pb = ImVec2(triangle_r * -0.5f, triangle_r * -0.866025f); // Black point.
	ImVec2 triangle_pc = ImVec2(triangle_r * -0.5f, triangle_r * +0.866025f); // White point.

	float H, S, V;
	ColorConvertRGBtoHSV(col[0], col[1], col[2], H, S, V);

	bool value_changed = false, value_changed_h = false, value_changed_sv = false;

	PushItemFlag(ImGuiItemFlags_NoNav, true);
	if (flags & ImGuiColorEditFlags_PickerHueWheel)
	{
		// Hue wheel + SV triangle logic
		InvisibleButton("hsv", ImVec2(sv_picker_size + style.ItemInnerSpacing.x + bars_width, sv_picker_size));
		if (IsItemActive())
		{
			ImVec2 initial_off = g.IO.MouseClickedPos[0] - wheel_center;
			ImVec2 current_off = g.IO.MousePos - wheel_center;
			float initial_dist2 = ImLengthSqr(initial_off);
			if (initial_dist2 >= (wheel_r_inner - 1) * (wheel_r_inner - 1) && initial_dist2 <= (wheel_r_outer + 1) * (wheel_r_outer + 1))
			{
				// Interactive with Hue wheel
				H = atan2f(current_off.y, current_off.x) / IM_PI * 0.5f;
				if (H < 0.0f)
					H += 1.0f;
				value_changed = value_changed_h = true;
			}
			float cos_hue_angle = cosf(-H * 2.0f * IM_PI);
			float sin_hue_angle = sinf(-H * 2.0f * IM_PI);
			if (ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, ImRotate(initial_off, cos_hue_angle, sin_hue_angle)))
			{
				// Interacting with SV triangle
				ImVec2 current_off_unrotated = ImRotate(current_off, cos_hue_angle, sin_hue_angle);
				if (!ImTriangleContainsPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated))
					current_off_unrotated = ImTriangleClosestPoint(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated);
				float uu, vv, ww;
				ImTriangleBarycentricCoords(triangle_pa, triangle_pb, triangle_pc, current_off_unrotated, uu, vv, ww);
				V = ImClamp(1.0f - vv, 0.0001f, 1.0f);
				S = ImClamp(uu / V, 0.0001f, 1.0f);
				value_changed = value_changed_sv = true;
			}
		}
		if (!(flags & ImGuiColorEditFlags_NoOptions))
			OpenPopupOnItemClick("context");
	}
	else if (flags & ImGuiColorEditFlags_PickerHueBar)
	{
		// SV rectangle logic
		InvisibleButton("sv", ImVec2(sv_picker_size, sv_picker_size));
		if (IsItemActive())
		{
			S = ImSaturate((io.MousePos.x - picker_pos.x) / (sv_picker_size - 1));
			V = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
			value_changed = value_changed_sv = true;
		}
		if (!(flags & ImGuiColorEditFlags_NoOptions))
			OpenPopupOnItemClick("context");

		// Hue bar logic
		SetCursorScreenPos(ImVec2(bar0_pos_x, picker_pos.y));
		InvisibleButton("hue", ImVec2(bars_width, sv_picker_size));
		if (IsItemActive())
		{
			H = ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
			value_changed = value_changed_h = true;
		}
	}

	// Alpha bar logic
	if (alpha_bar)
	{
		SetCursorScreenPos(ImVec2(bar1_pos_x, picker_pos.y));
		InvisibleButton("alpha", ImVec2(bars_width, sv_picker_size));
		if (IsItemActive())
		{
			col[3] = 1.0f - ImSaturate((io.MousePos.y - picker_pos.y) / (sv_picker_size - 1));
			value_changed = true;
		}
	}
	PopItemFlag(); // ImGuiItemFlags_NoNav

	if (!(flags & ImGuiColorEditFlags_NoSidePreview))
	{
		SameLine(0, style.ItemInnerSpacing.x);
		BeginGroup();
	}

	if (!(flags & ImGuiColorEditFlags_NoLabel))
	{
		const char* label_display_end = FindRenderedTextEnd(label);
		if (label != label_display_end)
		{
			if ((flags & ImGuiColorEditFlags_NoSidePreview))
				SameLine(0, style.ItemInnerSpacing.x);
			TextUnformatted(label, label_display_end);
		}
	}

	if (!(flags & ImGuiColorEditFlags_NoSidePreview))
	{
		PushItemFlag(ImGuiItemFlags_NoNavDefaultFocus, true);
		ImVec4 col_v4(col[0], col[1], col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : col[3]);
		if ((flags & ImGuiColorEditFlags_NoLabel))
			Text("Current");
		ColorButton("##current", col_v4, (flags & (ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 3, square_sz * 2));
		if (ref_col != NULL)
		{
			Text("Original");
			ImVec4 ref_col_v4(ref_col[0], ref_col[1], ref_col[2], (flags & ImGuiColorEditFlags_NoAlpha) ? 1.0f : ref_col[3]);
			if (ColorButton("##original", ref_col_v4, (flags & (ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf | ImGuiColorEditFlags_NoTooltip)), ImVec2(square_sz * 3, square_sz * 2)))
			{
				memcpy(col, ref_col, components * sizeof(float));
				value_changed = true;
			}
		}
		PopItemFlag();
		EndGroup();
	}

	// Convert back color to RGB
	if (value_changed_h || value_changed_sv)
		ColorConvertHSVtoRGB(H >= 1.0f ? H - 10 * 1e-6f : H, S > 0.0f ? S : 10 * 1e-6f, V > 0.0f ? V : 1e-6f, col[0], col[1], col[2]);

	// R,G,B and H,S,V slider color editor
	if ((flags & ImGuiColorEditFlags_NoInputs) == 0)
	{
		PushItemWidth((alpha_bar ? bar1_pos_x : bar0_pos_x) + bars_width - picker_pos.x);
		ImGuiColorEditFlags sub_flags_to_forward = ImGuiColorEditFlags__DataTypeMask | ImGuiColorEditFlags_HDR | ImGuiColorEditFlags_NoAlpha | ImGuiColorEditFlags_NoOptions | ImGuiColorEditFlags_NoSmallPreview | ImGuiColorEditFlags_AlphaPreview | ImGuiColorEditFlags_AlphaPreviewHalf;
		ImGuiColorEditFlags sub_flags = (flags & sub_flags_to_forward) | ImGuiColorEditFlags_NoPicker;
		if (flags & ImGuiColorEditFlags_RGB || (flags & ImGuiColorEditFlags__InputsMask) == 0)
			value_changed |= ColorEdit4("##rgb", col, sub_flags | ImGuiColorEditFlags_RGB);
		if (flags & ImGuiColorEditFlags_HSV || (flags & ImGuiColorEditFlags__InputsMask) == 0)
			value_changed |= ColorEdit4("##hsv", col, sub_flags | ImGuiColorEditFlags_HSV);
		if (flags & ImGuiColorEditFlags_HEX || (flags & ImGuiColorEditFlags__InputsMask) == 0)
			value_changed |= ColorEdit4("##hex", col, sub_flags | ImGuiColorEditFlags_HEX);
		PopItemWidth();
	}

	// Try to cancel hue wrap (after ColorEdit), if any
	if (value_changed)
	{
		float new_H, new_S, new_V;
		ColorConvertRGBtoHSV(col[0], col[1], col[2], new_H, new_S, new_V);
		if (new_H <= 0 && H > 0)
		{
			if (new_V <= 0 && V != new_V)
				ColorConvertHSVtoRGB(H, S, new_V <= 0 ? V * 0.5f : new_V, col[0], col[1], col[2]);
			else if (new_S <= 0)
				ColorConvertHSVtoRGB(H, new_S <= 0 ? S * 0.5f : new_S, new_V, col[0], col[1], col[2]);
		}
	}

	ImVec4 hue_color_f(1, 1, 1, 1); ColorConvertHSVtoRGB(H, 1, 1, hue_color_f.x, hue_color_f.y, hue_color_f.z);
	ImU32 hue_color32 = ColorConvertFloat4ToU32(hue_color_f);
	ImU32 col32_no_alpha = ColorConvertFloat4ToU32(ImVec4(col[0], col[1], col[2], 1.0f));

	const ImU32 hue_colors[6 + 1] = { IM_COL32(255,0,0,255), IM_COL32(255,255,0,255), IM_COL32(0,255,0,255), IM_COL32(0,255,255,255), IM_COL32(0,0,255,255), IM_COL32(255,0,255,255), IM_COL32(255,0,0,255) };
	ImVec2 sv_cursor_pos;

	if (flags & ImGuiColorEditFlags_PickerHueWheel)
	{
		// Render Hue Wheel
		const float aeps = 1.5f / wheel_r_outer; // Half a pixel arc length in radians (2pi cancels out).
		const int segment_per_arc = ImMax(4, (int)wheel_r_outer / 12);
		for (int n = 0; n < 6; n++)
		{
			const float a0 = (n) / 6.0f * 2.0f * IM_PI - aeps;
			const float a1 = (n + 1.0f) / 6.0f * 2.0f * IM_PI + aeps;
			const int vert_start_idx = draw_list->VtxBuffer.Size;
			draw_list->PathArcTo(wheel_center, (wheel_r_inner + wheel_r_outer) * 0.5f, a0, a1, segment_per_arc);
			draw_list->PathStroke(IM_COL32_WHITE, false, wheel_thickness);
			const int vert_end_idx = draw_list->VtxBuffer.Size;

			// Paint colors over existing vertices
			ImVec2 gradient_p0(wheel_center.x + cosf(a0) * wheel_r_inner, wheel_center.y + sinf(a0) * wheel_r_inner);
			ImVec2 gradient_p1(wheel_center.x + cosf(a1) * wheel_r_inner, wheel_center.y + sinf(a1) * wheel_r_inner);
			ShadeVertsLinearColorGradientKeepAlpha(draw_list->VtxBuffer.Data + vert_start_idx, draw_list->VtxBuffer.Data + vert_end_idx, gradient_p0, gradient_p1, hue_colors[n], hue_colors[n + 1]);
		}

		// Render Cursor + preview on Hue Wheel
		float cos_hue_angle = cosf(H * 2.0f * IM_PI);
		float sin_hue_angle = sinf(H * 2.0f * IM_PI);
		ImVec2 hue_cursor_pos(wheel_center.x + cos_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f, wheel_center.y + sin_hue_angle * (wheel_r_inner + wheel_r_outer) * 0.5f);
		float hue_cursor_rad = value_changed_h ? wheel_thickness * 0.65f : wheel_thickness * 0.55f;
		int hue_cursor_segments = ImClamp((int)(hue_cursor_rad / 1.4f), 9, 32);
		draw_list->AddCircleFilled(hue_cursor_pos, hue_cursor_rad, hue_color32, hue_cursor_segments);
		draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad + 1, IM_COL32(128, 128, 128, 255), hue_cursor_segments);
		draw_list->AddCircle(hue_cursor_pos, hue_cursor_rad, IM_COL32_WHITE, hue_cursor_segments);

		// Render SV triangle (rotated according to hue)
		ImVec2 tra = wheel_center + ImRotate(triangle_pa, cos_hue_angle, sin_hue_angle);
		ImVec2 trb = wheel_center + ImRotate(triangle_pb, cos_hue_angle, sin_hue_angle);
		ImVec2 trc = wheel_center + ImRotate(triangle_pc, cos_hue_angle, sin_hue_angle);
		ImVec2 uv_white = GetFontTexUvWhitePixel();
		draw_list->PrimReserve(6, 6);
		draw_list->PrimVtx(tra, uv_white, hue_color32);
		draw_list->PrimVtx(trb, uv_white, hue_color32);
		draw_list->PrimVtx(trc, uv_white, IM_COL32_WHITE);
		draw_list->PrimVtx(tra, uv_white, IM_COL32_BLACK_TRANS);
		draw_list->PrimVtx(trb, uv_white, IM_COL32_BLACK);
		draw_list->PrimVtx(trc, uv_white, IM_COL32_BLACK_TRANS);
		draw_list->AddTriangle(tra, trb, trc, IM_COL32(128, 128, 128, 255), 1.5f);
		sv_cursor_pos = ImLerp(ImLerp(trc, tra, ImSaturate(S)), trb, ImSaturate(1 - V));
	}
	else if (flags & ImGuiColorEditFlags_PickerHueBar)
	{
		// Render SV Square
		draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), IM_COL32_WHITE, hue_color32, hue_color32, IM_COL32_WHITE);
		draw_list->AddRectFilledMultiColor(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), IM_COL32_BLACK_TRANS, IM_COL32_BLACK_TRANS, IM_COL32_BLACK, IM_COL32_BLACK);
		RenderFrameBorder(picker_pos, picker_pos + ImVec2(sv_picker_size, sv_picker_size), 0.0f);
		sv_cursor_pos.x = ImClamp((float)(int)(picker_pos.x + ImSaturate(S) * sv_picker_size + 0.5f), picker_pos.x + 2, picker_pos.x + sv_picker_size - 2); // Sneakily prevent the circle to stick out too much
		sv_cursor_pos.y = ImClamp((float)(int)(picker_pos.y + ImSaturate(1 - V) * sv_picker_size + 0.5f), picker_pos.y + 2, picker_pos.y + sv_picker_size - 2);

		// Render Hue Bar
		for (int i = 0; i < 6; ++i)
			draw_list->AddRectFilledMultiColor(ImVec2(bar0_pos_x, picker_pos.y + i * (sv_picker_size / 6)), ImVec2(bar0_pos_x + bars_width, picker_pos.y + (i + 1) * (sv_picker_size / 6)), hue_colors[i], hue_colors[i], hue_colors[i + 1], hue_colors[i + 1]);
		float bar0_line_y = (float)(int)(picker_pos.y + H * sv_picker_size + 0.5f);
		RenderFrameBorder(ImVec2(bar0_pos_x, picker_pos.y), ImVec2(bar0_pos_x + bars_width, picker_pos.y + sv_picker_size), 0.0f);
		RenderArrowsForVerticalBar(draw_list, ImVec2(bar0_pos_x - 1, bar0_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);
	}

	// Render cursor/preview circle (clamp S/V within 0..1 range because floating points colors may lead HSV values to be out of range)
	float sv_cursor_rad = value_changed_sv ? 10.0f : 6.0f;
	draw_list->AddCircleFilled(sv_cursor_pos, sv_cursor_rad, col32_no_alpha, 12);
	draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad + 1, IM_COL32(128, 128, 128, 255), 12);
	draw_list->AddCircle(sv_cursor_pos, sv_cursor_rad, IM_COL32_WHITE, 12);

	// Render alpha bar
	if (alpha_bar)
	{
		float alpha = ImSaturate(col[3]);
		ImRect bar1_bb(bar1_pos_x, picker_pos.y, bar1_pos_x + bars_width, picker_pos.y + sv_picker_size);
		RenderColorRectWithAlphaCheckerboard(bar1_bb.Min, bar1_bb.Max, IM_COL32(0, 0, 0, 0), bar1_bb.GetWidth() / 2.0f, ImVec2(0.0f, 0.0f));
		draw_list->AddRectFilledMultiColor(bar1_bb.Min, bar1_bb.Max, col32_no_alpha, col32_no_alpha, col32_no_alpha & ~IM_COL32_A_MASK, col32_no_alpha & ~IM_COL32_A_MASK);
		float bar1_line_y = (float)(int)(picker_pos.y + (1.0f - alpha) * sv_picker_size + 0.5f);
		RenderFrameBorder(bar1_bb.Min, bar1_bb.Max, 0.0f);
		RenderArrowsForVerticalBar(draw_list, ImVec2(bar1_pos_x - 1, bar1_line_y), ImVec2(bars_triangles_half_sz + 1, bars_triangles_half_sz), bars_width + 2.0f);
	}

	EndGroup();
	PopID();

	return value_changed && memcmp(backup_initial_col, col, components * sizeof(float));
}

// Horizontal separating line.
void ImGui::Separator()
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;
	ImGuiContext& g = *GImGui;

	ImGuiSeparatorFlags flags = 0;
	if ((flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical)) == 0)
		flags |= (window->DC.LayoutType == ImGuiLayoutType_Horizontal) ? ImGuiSeparatorFlags_Vertical : ImGuiSeparatorFlags_Horizontal;
	IM_ASSERT(ImIsPowerOfTwo((int)(flags & (ImGuiSeparatorFlags_Horizontal | ImGuiSeparatorFlags_Vertical))));   // Check that only 1 option is selected
	if (flags & ImGuiSeparatorFlags_Vertical)
	{
		VerticalSeparator();
		return;
	}

	// Horizontal Separator
	if (window->DC.ColumnsSet)
		PopClipRect();

	float x1 = window->Pos.x;
	float x2 = window->Pos.x + window->Size.x;
	if (!window->DC.GroupStack.empty())
		x1 += window->DC.IndentX;

	const ImRect bb(ImVec2(x1, window->DC.CursorPos.y), ImVec2(x2, window->DC.CursorPos.y + 1.0f));
	ItemSize(ImVec2(0.0f, 0.0f)); // NB: we don't provide our width so that it doesn't get feed back into AutoFit, we don't provide height to not alter layout.
	if (!ItemAdd(bb, 0))
	{
		if (window->DC.ColumnsSet)
			PushColumnClipRect();
		return;
	}

	window->DrawList->AddLine(bb.Min, ImVec2(bb.Max.x, bb.Min.y), GetColorU32(ImGuiCol_Separator));

	if (g.LogEnabled)
		LogRenderedText(NULL, IM_NEWLINE "--------------------------------");

	if (window->DC.ColumnsSet)
	{
		PushColumnClipRect();
		window->DC.ColumnsSet->LineMinY = window->DC.CursorPos.y;
	}
}

void ImGui::VerticalSeparator()
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;
	ImGuiContext& g = *GImGui;

	float y1 = window->DC.CursorPos.y;
	float y2 = window->DC.CursorPos.y + window->DC.CurrentLineHeight;
	const ImRect bb(ImVec2(window->DC.CursorPos.x, y1), ImVec2(window->DC.CursorPos.x + 1.0f, y2));
	ItemSize(ImVec2(bb.GetWidth(), 0.0f));
	if (!ItemAdd(bb, 0))
		return;

	window->DrawList->AddLine(ImVec2(bb.Min.x, bb.Min.y), ImVec2(bb.Min.x, bb.Max.y), GetColorU32(ImGuiCol_Separator));
	if (g.LogEnabled)
		LogText(" |");
}

bool ImGui::SplitterBehavior(ImGuiID id, const ImRect& bb, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	const ImGuiItemFlags item_flags_backup = window->DC.ItemFlags;
	window->DC.ItemFlags |= ImGuiItemFlags_NoNav | ImGuiItemFlags_NoNavDefaultFocus;
	bool item_add = ItemAdd(bb, id);
	window->DC.ItemFlags = item_flags_backup;
	if (!item_add)
		return false;

	bool hovered, held;
	ImRect bb_interact = bb;
	bb_interact.Expand(axis == ImGuiAxis_Y ? ImVec2(0.0f, hover_extend) : ImVec2(hover_extend, 0.0f));
	ButtonBehavior(bb_interact, id, &hovered, &held, ImGuiButtonFlags_FlattenChildren | ImGuiButtonFlags_AllowItemOverlap);
	if (g.ActiveId != id)
		SetItemAllowOverlap();

	if (held || (g.HoveredId == id && g.HoveredIdPreviousFrame == id))
		SetMouseCursor(axis == ImGuiAxis_Y ? ImGuiMouseCursor_ResizeNS : ImGuiMouseCursor_ResizeEW);

	ImRect bb_render = bb;
	if (held)
	{
		ImVec2 mouse_delta_2d = g.IO.MousePos - g.ActiveIdClickOffset - bb_interact.Min;
		float mouse_delta = (axis == ImGuiAxis_Y) ? mouse_delta_2d.y : mouse_delta_2d.x;

		// Minimum pane size
		if (mouse_delta < min_size1 - *size1)
			mouse_delta = min_size1 - *size1;
		if (mouse_delta > * size2 - min_size2)
			mouse_delta = *size2 - min_size2;

		// Apply resize
		*size1 += mouse_delta;
		*size2 -= mouse_delta;
		bb_render.Translate((axis == ImGuiAxis_X) ? ImVec2(mouse_delta, 0.0f) : ImVec2(0.0f, mouse_delta));
	}

	// Render
	const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
	window->DrawList->AddRectFilled(bb_render.Min, bb_render.Max, col, g.Style.FrameRounding);

	return held;
}

void ImGui::Spacing()
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;
	ItemSize(ImVec2(0, 0));
}

void ImGui::Dummy(const ImVec2& size)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	const ImRect bb(window->DC.CursorPos, window->DC.CursorPos + size);
	ItemSize(bb);
	ItemAdd(bb, 0);
}

bool ImGui::IsRectVisible(const ImVec2& size)
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->ClipRect.Overlaps(ImRect(window->DC.CursorPos, window->DC.CursorPos + size));
}

bool ImGui::IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max)
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->ClipRect.Overlaps(ImRect(rect_min, rect_max));
}

// Lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
void ImGui::BeginGroup()
{
	ImGuiWindow* window = GetCurrentWindow();

	window->DC.GroupStack.resize(window->DC.GroupStack.Size + 1);
	ImGuiGroupData& group_data = window->DC.GroupStack.back();
	group_data.BackupCursorPos = window->DC.CursorPos;
	group_data.BackupCursorMaxPos = window->DC.CursorMaxPos;
	group_data.BackupIndentX = window->DC.IndentX;
	group_data.BackupGroupOffsetX = window->DC.GroupOffsetX;
	group_data.BackupCurrentLineHeight = window->DC.CurrentLineHeight;
	group_data.BackupCurrentLineTextBaseOffset = window->DC.CurrentLineTextBaseOffset;
	group_data.BackupLogLinePosY = window->DC.LogLinePosY;
	group_data.BackupActiveIdIsAlive = GImGui->ActiveIdIsAlive;
	group_data.AdvanceCursor = true;

	window->DC.GroupOffsetX = window->DC.CursorPos.x - window->Pos.x - window->DC.ColumnsOffsetX;
	window->DC.IndentX = window->DC.GroupOffsetX;
	window->DC.CursorMaxPos = window->DC.CursorPos;
	window->DC.CurrentLineHeight = 0.0f;
	window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;
}

void ImGui::EndGroup()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();

	IM_ASSERT(!window->DC.GroupStack.empty());    // Mismatched BeginGroup()/EndGroup() calls

	ImGuiGroupData& group_data = window->DC.GroupStack.back();

	ImRect group_bb(group_data.BackupCursorPos, window->DC.CursorMaxPos);
	group_bb.Max = ImMax(group_bb.Min, group_bb.Max);

	window->DC.CursorPos = group_data.BackupCursorPos;
	window->DC.CursorMaxPos = ImMax(group_data.BackupCursorMaxPos, window->DC.CursorMaxPos);
	window->DC.CurrentLineHeight = group_data.BackupCurrentLineHeight;
	window->DC.CurrentLineTextBaseOffset = group_data.BackupCurrentLineTextBaseOffset;
	window->DC.IndentX = group_data.BackupIndentX;
	window->DC.GroupOffsetX = group_data.BackupGroupOffsetX;
	window->DC.LogLinePosY = window->DC.CursorPos.y - 9999.0f;

	if (group_data.AdvanceCursor)
	{
		window->DC.CurrentLineTextBaseOffset = ImMax(window->DC.PrevLineTextBaseOffset, group_data.BackupCurrentLineTextBaseOffset);      // FIXME: Incorrect, we should grab the base offset from the *first line* of the group but it is hard to obtain now.
		ItemSize(group_bb.GetSize(), group_data.BackupCurrentLineTextBaseOffset);
		ItemAdd(group_bb, 0);
	}

	// If the current ActiveId was declared within the boundary of our group, we copy it to LastItemId so IsItemActive() will be functional on the entire group.
	// It would be be neater if we replaced window.DC.LastItemId by e.g. 'bool LastItemIsActive', but if you search for LastItemId you'll notice it is only used in that context.
	const bool active_id_within_group = (!group_data.BackupActiveIdIsAlive && g.ActiveIdIsAlive && g.ActiveId && g.ActiveIdWindow->RootWindow == window->RootWindow);
	if (active_id_within_group)
		window->DC.LastItemId = g.ActiveId;
	window->DC.LastItemRect = group_bb;

	window->DC.GroupStack.pop_back();

	//window->DrawList->AddRect(group_bb.Min, group_bb.Max, IM_COL32(255,0,255,255));   // [Debug]
}

// Gets back to previous line and continue with horizontal layout
//      pos_x == 0      : follow right after previous item
//      pos_x != 0      : align to specified x position (relative to window/group left)
//      spacing_w < 0   : use default spacing if pos_x == 0, no spacing if pos_x != 0
//      spacing_w >= 0  : enforce spacing amount
void ImGui::SameLine(float pos_x, float spacing_w)
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext& g = *GImGui;
	if (pos_x != 0.0f)
	{
		if (spacing_w < 0.0f) spacing_w = 0.0f;
		window->DC.CursorPos.x = window->Pos.x - window->Scroll.x + pos_x + spacing_w + window->DC.GroupOffsetX + window->DC.ColumnsOffsetX;
		window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
	}
	else
	{
		if (spacing_w < 0.0f) spacing_w = g.Style.ItemSpacing.x;
		window->DC.CursorPos.x = window->DC.CursorPosPrevLine.x + spacing_w;
		window->DC.CursorPos.y = window->DC.CursorPosPrevLine.y;
	}
	window->DC.CurrentLineHeight = window->DC.PrevLineHeight;
	window->DC.CurrentLineTextBaseOffset = window->DC.PrevLineTextBaseOffset;
}

void ImGui::NewLine()
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems)
		return;

	ImGuiContext& g = *GImGui;
	const ImGuiLayoutType backup_layout_type = window->DC.LayoutType;
	window->DC.LayoutType = ImGuiLayoutType_Vertical;
	if (window->DC.CurrentLineHeight > 0.0f)     // In the event that we are on a line with items that is smaller that FontSize high, we will preserve its height.
		ItemSize(ImVec2(0, 0));
	else
		ItemSize(ImVec2(0.0f, g.FontSize));
	window->DC.LayoutType = backup_layout_type;
}

void ImGui::NextColumn()
{
	ImGuiWindow* window = GetCurrentWindow();
	if (window->SkipItems || window->DC.ColumnsSet == NULL)
		return;

	ImGuiContext& g = *GImGui;
	PopItemWidth();
	PopClipRect();

	ImGuiColumnsSet* columns = window->DC.ColumnsSet;
	columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
	if (++columns->Current < columns->Count)
	{
		// Columns 1+ cancel out IndentX
		window->DC.ColumnsOffsetX = GetColumnOffset(columns->Current) - window->DC.IndentX + g.Style.ItemSpacing.x;
		window->DrawList->ChannelsSetCurrent(columns->Current);
	}
	else
	{
		window->DC.ColumnsOffsetX = 0.0f;
		window->DrawList->ChannelsSetCurrent(0);
		columns->Current = 0;
		columns->LineMinY = columns->LineMaxY;
	}
	window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX);
	window->DC.CursorPos.y = columns->LineMinY;
	window->DC.CurrentLineHeight = 0.0f;
	window->DC.CurrentLineTextBaseOffset = 0.0f;

	PushColumnClipRect();
	PushItemWidth(GetColumnWidth() * 0.65f);  // FIXME: Move on columns setup
}

int ImGui::GetColumnIndex()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.ColumnsSet ? window->DC.ColumnsSet->Current : 0;
}

int ImGui::GetColumnsCount()
{
	ImGuiWindow* window = GetCurrentWindowRead();
	return window->DC.ColumnsSet ? window->DC.ColumnsSet->Count : 1;
}

static float OffsetNormToPixels(const ImGuiColumnsSet* columns, float offset_norm)
{
	return offset_norm * (columns->MaxX - columns->MinX);
}

static float PixelsToOffsetNorm(const ImGuiColumnsSet* columns, float offset)
{
	return offset / (columns->MaxX - columns->MinX);
}

static inline float GetColumnsRectHalfWidth() { return 4.0f; }

static float GetDraggedColumnOffset(ImGuiColumnsSet* columns, int column_index)
{
	// Active (dragged) column always follow mouse. The reason we need this is that dragging a column to the right edge of an auto-resizing
	// window creates a feedback loop because we store normalized positions. So while dragging we enforce absolute positioning.
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	IM_ASSERT(column_index > 0); // We are not supposed to drag column 0.
	IM_ASSERT(g.ActiveId == columns->ID + ImGuiID(column_index));

	float x = g.IO.MousePos.x - g.ActiveIdClickOffset.x + GetColumnsRectHalfWidth() - window->Pos.x;
	x = ImMax(x, ImGui::GetColumnOffset(column_index - 1) + g.Style.ColumnsMinSpacing);
	if ((columns->Flags & ImGuiColumnsFlags_NoPreserveWidths))
		x = ImMin(x, ImGui::GetColumnOffset(column_index + 1) - g.Style.ColumnsMinSpacing);

	return x;
}

float ImGui::GetColumnOffset(int column_index)
{
	ImGuiWindow* window = GetCurrentWindowRead();
	ImGuiColumnsSet* columns = window->DC.ColumnsSet;
	IM_ASSERT(columns != NULL);

	if (column_index < 0)
		column_index = columns->Current;
	IM_ASSERT(column_index < columns->Columns.Size);

	const float t = columns->Columns[column_index].OffsetNorm;
	const float x_offset = ImLerp(columns->MinX, columns->MaxX, t);
	return x_offset;
}

static float GetColumnWidthEx(ImGuiColumnsSet* columns, int column_index, bool before_resize = false)
{
	if (column_index < 0)
		column_index = columns->Current;

	float offset_norm;
	if (before_resize)
		offset_norm = columns->Columns[column_index + 1].OffsetNormBeforeResize - columns->Columns[column_index].OffsetNormBeforeResize;
	else
		offset_norm = columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm;
	return OffsetNormToPixels(columns, offset_norm);
}

float ImGui::GetColumnWidth(int column_index)
{
	ImGuiWindow* window = GetCurrentWindowRead();
	ImGuiColumnsSet* columns = window->DC.ColumnsSet;
	IM_ASSERT(columns != NULL);

	if (column_index < 0)
		column_index = columns->Current;
	return OffsetNormToPixels(columns, columns->Columns[column_index + 1].OffsetNorm - columns->Columns[column_index].OffsetNorm);
}

void ImGui::SetColumnOffset(int column_index, float offset)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	ImGuiColumnsSet* columns = window->DC.ColumnsSet;
	IM_ASSERT(columns != NULL);

	if (column_index < 0)
		column_index = columns->Current;
	IM_ASSERT(column_index < columns->Columns.Size);

	const bool preserve_width = !(columns->Flags & ImGuiColumnsFlags_NoPreserveWidths) && (column_index < columns->Count - 1);
	const float width = preserve_width ? GetColumnWidthEx(columns, column_index, columns->IsBeingResized) : 0.0f;

	if (!(columns->Flags & ImGuiColumnsFlags_NoForceWithinWindow))
		offset = ImMin(offset, columns->MaxX - g.Style.ColumnsMinSpacing * (columns->Count - column_index));
	columns->Columns[column_index].OffsetNorm = PixelsToOffsetNorm(columns, offset - columns->MinX);

	if (preserve_width)
		SetColumnOffset(column_index + 1, offset + ImMax(g.Style.ColumnsMinSpacing, width));
}

void ImGui::SetColumnWidth(int column_index, float width)
{
	ImGuiWindow* window = GetCurrentWindowRead();
	ImGuiColumnsSet* columns = window->DC.ColumnsSet;
	IM_ASSERT(columns != NULL);

	if (column_index < 0)
		column_index = columns->Current;
	SetColumnOffset(column_index + 1, GetColumnOffset(column_index) + width);
}

void ImGui::PushColumnClipRect(int column_index)
{
	ImGuiWindow* window = GetCurrentWindowRead();
	ImGuiColumnsSet* columns = window->DC.ColumnsSet;
	if (column_index < 0)
		column_index = columns->Current;

	PushClipRect(columns->Columns[column_index].ClipRect.Min, columns->Columns[column_index].ClipRect.Max, false);
}

static ImGuiColumnsSet* FindOrAddColumnsSet(ImGuiWindow* window, ImGuiID id)
{
	for (int n = 0; n < window->ColumnsStorage.Size; n++)
		if (window->ColumnsStorage[n].ID == id)
			return &window->ColumnsStorage[n];

	window->ColumnsStorage.push_back(ImGuiColumnsSet());
	ImGuiColumnsSet* columns = &window->ColumnsStorage.back();
	columns->ID = id;
	return columns;
}

void ImGui::BeginColumns(const char* str_id, int columns_count, ImGuiColumnsFlags flags)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();

	IM_ASSERT(columns_count > 1);
	IM_ASSERT(window->DC.ColumnsSet == NULL); // Nested columns are currently not supported

											  // Differentiate column ID with an arbitrary prefix for cases where users name their columns set the same as another widget.
											  // In addition, when an identifier isn't explicitly provided we include the number of columns in the hash to make it uniquer.
	PushID(0x11223347 + (str_id ? 0 : columns_count));
	ImGuiID id = window->GetID(str_id ? str_id : "columns");
	PopID();

	// Acquire storage for the columns set
	ImGuiColumnsSet* columns = FindOrAddColumnsSet(window, id);
	IM_ASSERT(columns->ID == id);
	columns->Current = 0;
	columns->Count = columns_count;
	columns->Flags = flags;
	window->DC.ColumnsSet = columns;

	// Set state for first column
	const float content_region_width = (window->SizeContentsExplicit.x != 0.0f) ? (window->SizeContentsExplicit.x) : (window->InnerClipRect.Max.x - window->Pos.x);
	columns->MinX = window->DC.IndentX - g.Style.ItemSpacing.x; // Lock our horizontal range
	columns->MaxX = ImMax(content_region_width - window->Scroll.x, columns->MinX + 1.0f);
	columns->StartPosY = window->DC.CursorPos.y;
	columns->StartMaxPosX = window->DC.CursorMaxPos.x;
	columns->LineMinY = columns->LineMaxY = window->DC.CursorPos.y;
	window->DC.ColumnsOffsetX = 0.0f;
	window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX);

	// Clear data if columns count changed
	if (columns->Columns.Size != 0 && columns->Columns.Size != columns_count + 1)
		columns->Columns.resize(0);

	// Initialize defaults
	columns->IsFirstFrame = (columns->Columns.Size == 0);
	if (columns->Columns.Size == 0)
	{
		columns->Columns.reserve(columns_count + 1);
		for (int n = 0; n < columns_count + 1; n++)
		{
			ImGuiColumnData column;
			column.OffsetNorm = n / (float)columns_count;
			columns->Columns.push_back(column);
		}
	}

	for (int n = 0; n < columns_count; n++)
	{
		// Compute clipping rectangle
		ImGuiColumnData* column = &columns->Columns[n];
		float clip_x1 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n) - 1.0f);
		float clip_x2 = ImFloor(0.5f + window->Pos.x + GetColumnOffset(n + 1) - 1.0f);
		column->ClipRect = ImRect(clip_x1, -FLT_MAX, clip_x2, +FLT_MAX);
		column->ClipRect.ClipWith(window->ClipRect);
	}

	window->DrawList->ChannelsSplit(columns->Count);
	PushColumnClipRect();
	PushItemWidth(GetColumnWidth() * 0.65f);
}

void ImGui::EndColumns()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();
	ImGuiColumnsSet* columns = window->DC.ColumnsSet;
	IM_ASSERT(columns != NULL);

	PopItemWidth();
	PopClipRect();
	window->DrawList->ChannelsMerge();

	columns->LineMaxY = ImMax(columns->LineMaxY, window->DC.CursorPos.y);
	window->DC.CursorPos.y = columns->LineMaxY;
	if (!(columns->Flags & ImGuiColumnsFlags_GrowParentContentsSize))
		window->DC.CursorMaxPos.x = ImMax(columns->StartMaxPosX, columns->MaxX);  // Restore cursor max pos, as columns don't grow parent

																				  // Draw columns borders and handle resize
	bool is_being_resized = false;
	if (!(columns->Flags & ImGuiColumnsFlags_NoBorder) && !window->SkipItems)
	{
		const float y1 = columns->StartPosY;
		const float y2 = window->DC.CursorPos.y;
		int dragging_column = -1;
		for (int n = 1; n < columns->Count; n++)
		{
			float x = window->Pos.x + GetColumnOffset(n);
			const ImGuiID column_id = columns->ID + ImGuiID(n);
			const float column_hw = GetColumnsRectHalfWidth(); // Half-width for interaction
			const ImRect column_rect(ImVec2(x - column_hw, y1), ImVec2(x + column_hw, y2));
			KeepAliveID(column_id);
			if (IsClippedEx(column_rect, column_id, false))
				continue;

			bool hovered = false, held = false;
			if (!(columns->Flags & ImGuiColumnsFlags_NoResize))
			{
				ButtonBehavior(column_rect, column_id, &hovered, &held);
				if (hovered || held)
					g.MouseCursor = ImGuiMouseCursor_ResizeEW;
				if (held && !(columns->Columns[n].Flags & ImGuiColumnsFlags_NoResize))
					dragging_column = n;
			}

			// Draw column (we clip the Y boundaries CPU side because very long triangles are mishandled by some GPU drivers.)
			const ImU32 col = GetColorU32(held ? ImGuiCol_SeparatorActive : hovered ? ImGuiCol_SeparatorHovered : ImGuiCol_Separator);
			const float xi = (float)(int)x;
			window->DrawList->AddLine(ImVec2(xi, ImMax(y1 + 1.0f, window->ClipRect.Min.y)), ImVec2(xi, ImMin(y2, window->ClipRect.Max.y)), col);
		}

		// Apply dragging after drawing the column lines, so our rendered lines are in sync with how items were displayed during the frame.
		if (dragging_column != -1)
		{
			if (!columns->IsBeingResized)
				for (int n = 0; n < columns->Count + 1; n++)
					columns->Columns[n].OffsetNormBeforeResize = columns->Columns[n].OffsetNorm;
			columns->IsBeingResized = is_being_resized = true;
			float x = GetDraggedColumnOffset(columns, dragging_column);
			SetColumnOffset(dragging_column, x);
		}
	}
	columns->IsBeingResized = is_being_resized;

	window->DC.ColumnsSet = NULL;
	window->DC.ColumnsOffsetX = 0.0f;
	window->DC.CursorPos.x = (float)(int)(window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX);
}

// [2018-03: This is currently the only public API, while we are working on making BeginColumns/EndColumns user-facing]
void ImGui::Columns(int columns_count, const char* id, bool border)
{
	ImGuiWindow* window = GetCurrentWindow();
	IM_ASSERT(columns_count >= 1);

	ImGuiColumnsFlags flags = (border ? 0 : ImGuiColumnsFlags_NoBorder);
	//flags |= ImGuiColumnsFlags_NoPreserveWidths; // NB: Legacy behavior
	if (window->DC.ColumnsSet != NULL && window->DC.ColumnsSet->Count == columns_count && window->DC.ColumnsSet->Flags == flags)
		return;

	if (window->DC.ColumnsSet != NULL)
		EndColumns();

	if (columns_count != 1)
		BeginColumns(id, columns_count, flags);
}

void ImGui::Indent(float indent_w)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();
	window->DC.IndentX += (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
	window->DC.CursorPos.x = window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX;
}

void ImGui::Unindent(float indent_w)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = GetCurrentWindow();
	window->DC.IndentX -= (indent_w != 0.0f) ? indent_w : g.Style.IndentSpacing;
	window->DC.CursorPos.x = window->Pos.x + window->DC.IndentX + window->DC.ColumnsOffsetX;
}

void ImGui::TreePush(const char* str_id)
{
	ImGuiWindow* window = GetCurrentWindow();
	Indent();
	window->DC.TreeDepth++;
	PushID(str_id ? str_id : "#TreePush");
}

void ImGui::TreePush(const void* ptr_id)
{
	ImGuiWindow* window = GetCurrentWindow();
	Indent();
	window->DC.TreeDepth++;
	PushID(ptr_id ? ptr_id : (const void*)"#TreePush");
}

void ImGui::TreePushRawID(ImGuiID id)
{
	ImGuiWindow* window = GetCurrentWindow();
	Indent();
	window->DC.TreeDepth++;
	window->IDStack.push_back(id);
}

void ImGui::TreePop()
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	Unindent();

	window->DC.TreeDepth--;
	if (g.NavMoveDir == ImGuiDir_Left && g.NavWindow == window && NavMoveRequestButNoResultYet())
		if (g.NavIdIsAlive && (window->DC.TreeDepthMayJumpToParentOnPop & (1 << window->DC.TreeDepth)))
		{
			SetNavID(window->IDStack.back(), g.NavLayer);
			NavMoveRequestCancel();
		}
	window->DC.TreeDepthMayJumpToParentOnPop &= (1 << window->DC.TreeDepth) - 1;

	PopID();
}

void ImGui::Value(const char* prefix, bool b)
{
	Text("%s: %s", prefix, (b ? "true" : "false"));
}

void ImGui::Value(const char* prefix, int v)
{
	Text("%s: %d", prefix, v);
}

void ImGui::Value(const char* prefix, unsigned int v)
{
	Text("%s: %d", prefix, v);
}

void ImGui::Value(const char* prefix, float v, const char* float_format)
{
	if (float_format)
	{
		char fmt[64];
		ImFormatString(fmt, IM_ARRAYSIZE(fmt), "%%s: %s", float_format);
		Text(fmt, prefix, v);
	}
	else
	{
		Text("%s: %.3f", prefix, v);
	}
}

//-----------------------------------------------------------------------------
// DRAG AND DROP
//-----------------------------------------------------------------------------

void ImGui::ClearDragDrop()
{
	ImGuiContext& g = *GImGui;
	g.DragDropActive = false;
	g.DragDropPayload.Clear();
	g.DragDropAcceptIdCurr = g.DragDropAcceptIdPrev = 0;
	g.DragDropAcceptIdCurrRectSurface = FLT_MAX;
	g.DragDropAcceptFrameCount = -1;
}

// Call when current ID is active.
// When this returns true you need to: a) call SetDragDropPayload() exactly once, b) you may render the payload visual/description, c) call EndDragDropSource()
bool ImGui::BeginDragDropSource(ImGuiDragDropFlags flags)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;

	bool source_drag_active = false;
	ImGuiID source_id = 0;
	ImGuiID source_parent_id = 0;
	int mouse_button = 0;
	if (!(flags & ImGuiDragDropFlags_SourceExtern))
	{
		source_id = window->DC.LastItemId;
		if (source_id != 0 && g.ActiveId != source_id) // Early out for most common case
			return false;
		if (g.IO.MouseDown[mouse_button] == false)
			return false;

		if (source_id == 0)
		{
			// If you want to use BeginDragDropSource() on an item with no unique identifier for interaction, such as Text() or Image(), you need to:
			// A) Read the explanation below, B) Use the ImGuiDragDropFlags_SourceAllowNullID flag, C) Swallow your programmer pride.
			if (!(flags & ImGuiDragDropFlags_SourceAllowNullID))
			{
				IM_ASSERT(0);
				return false;
			}

			// Magic fallback (=somehow reprehensible) to handle items with no assigned ID, e.g. Text(), Image()
			// We build a throwaway ID based on current ID stack + relative AABB of items in window.
			// THE IDENTIFIER WON'T SURVIVE ANY REPOSITIONING OF THE WIDGET, so if your widget moves your dragging operation will be canceled.
			// We don't need to maintain/call ClearActiveID() as releasing the button will early out this function and trigger !ActiveIdIsAlive.
			bool is_hovered = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect) != 0;
			if (!is_hovered && (g.ActiveId == 0 || g.ActiveIdWindow != window))
				return false;
			source_id = window->DC.LastItemId = window->GetIDFromRectangle(window->DC.LastItemRect);
			if (is_hovered)
				SetHoveredID(source_id);
			if (is_hovered && g.IO.MouseClicked[mouse_button])
			{
				SetActiveID(source_id, window);
				FocusWindow(window);
			}
			if (g.ActiveId == source_id) // Allow the underlying widget to display/return hovered during the mouse release frame, else we would get a flicker.
				g.ActiveIdAllowOverlap = is_hovered;
		}
		if (g.ActiveId != source_id)
			return false;
		source_parent_id = window->IDStack.back();
		source_drag_active = IsMouseDragging(mouse_button);
	}
	else
	{
		window = NULL;
		source_id = ImHash("#SourceExtern", 0);
		source_drag_active = true;
	}

	if (source_drag_active)
	{
		if (!g.DragDropActive)
		{
			IM_ASSERT(source_id != 0);
			ClearDragDrop();
			ImGuiPayload& payload = g.DragDropPayload;
			payload.SourceId = source_id;
			payload.SourceParentId = source_parent_id;
			g.DragDropActive = true;
			g.DragDropSourceFlags = flags;
			g.DragDropMouseButton = mouse_button;
		}

		if (!(flags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
		{
			// FIXME-DRAG
			//SetNextWindowPos(g.IO.MousePos - g.ActiveIdClickOffset - g.Style.WindowPadding);
			//PushStyleVar(ImGuiStyleVar_Alpha, g.Style.Alpha * 0.60f); // This is better but e.g ColorButton with checkboard has issue with transparent colors :(
			SetNextWindowPos(g.IO.MousePos);
			PushStyleColor(ImGuiCol_PopupBg, GetStyleColorVec4(ImGuiCol_PopupBg) * ImVec4(1.0f, 1.0f, 1.0f, 0.6f));
			BeginTooltip();
		}

		if (!(flags & ImGuiDragDropFlags_SourceNoDisableHover) && !(flags & ImGuiDragDropFlags_SourceExtern))
			window->DC.LastItemStatusFlags &= ~ImGuiItemStatusFlags_HoveredRect;

		return true;
	}
	return false;
}

void ImGui::EndDragDropSource()
{
	ImGuiContext& g = *GImGui;
	IM_ASSERT(g.DragDropActive);

	if (!(g.DragDropSourceFlags & ImGuiDragDropFlags_SourceNoPreviewTooltip))
	{
		EndTooltip();
		PopStyleColor();
		//PopStyleVar();
	}

	// Discard the drag if have not called SetDragDropPayload()
	if (g.DragDropPayload.DataFrameCount == -1)
		ClearDragDrop();
}

// Use 'cond' to choose to submit payload on drag start or every frame
bool ImGui::SetDragDropPayload(const char* type, const void* data, size_t data_size, ImGuiCond cond)
{
	ImGuiContext& g = *GImGui;
	ImGuiPayload& payload = g.DragDropPayload;
	if (cond == 0)
		cond = ImGuiCond_Always;

	IM_ASSERT(type != NULL);
	IM_ASSERT(strlen(type) < IM_ARRAYSIZE(payload.DataType) && "Payload type can be at most 12 characters long");
	IM_ASSERT((data != NULL && data_size > 0) || (data == NULL && data_size == 0));
	IM_ASSERT(cond == ImGuiCond_Always || cond == ImGuiCond_Once);
	IM_ASSERT(payload.SourceId != 0);                               // Not called between BeginDragDropSource() and EndDragDropSource()

	if (cond == ImGuiCond_Always || payload.DataFrameCount == -1)
	{
		// Copy payload
		ImStrncpy(payload.DataType, type, IM_ARRAYSIZE(payload.DataType));
		g.DragDropPayloadBufHeap.resize(0);
		if (data_size > sizeof(g.DragDropPayloadBufLocal))
		{
			// Store in heap
			g.DragDropPayloadBufHeap.resize((int)data_size);
			payload.Data = g.DragDropPayloadBufHeap.Data;
			memcpy((void*)(intptr_t)payload.Data, data, data_size);
		}
		else if (data_size > 0)
		{
			// Store locally
			memset(&g.DragDropPayloadBufLocal, 0, sizeof(g.DragDropPayloadBufLocal));
			payload.Data = g.DragDropPayloadBufLocal;
			memcpy((void*)(intptr_t)payload.Data, data, data_size);
		}
		else
		{
			payload.Data = NULL;
		}
		payload.DataSize = (int)data_size;
	}
	payload.DataFrameCount = g.FrameCount;

	return (g.DragDropAcceptFrameCount == g.FrameCount) || (g.DragDropAcceptFrameCount == g.FrameCount - 1);
}

bool ImGui::BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id)
{
	ImGuiContext& g = *GImGui;
	if (!g.DragDropActive)
		return false;

	ImGuiWindow* window = g.CurrentWindow;
	if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)
		return false;
	IM_ASSERT(id != 0);
	if (!IsMouseHoveringRect(bb.Min, bb.Max) || (id == g.DragDropPayload.SourceId))
		return false;

	g.DragDropTargetRect = bb;
	g.DragDropTargetId = id;
	return true;
}

// We don't use BeginDragDropTargetCustom() and duplicate its code because:
// 1) we use LastItemRectHoveredRect which handles items that pushes a temporarily clip rectangle in their code. Calling BeginDragDropTargetCustom(LastItemRect) would not handle them.
// 2) and it's faster. as this code may be very frequently called, we want to early out as fast as we can.
// Also note how the HoveredWindow test is positioned differently in both functions (in both functions we optimize for the cheapest early out case)
bool ImGui::BeginDragDropTarget()
{
	ImGuiContext& g = *GImGui;
	if (!g.DragDropActive)
		return false;

	ImGuiWindow* window = g.CurrentWindow;
	if (!(window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HoveredRect))
		return false;
	if (g.HoveredWindow == NULL || window->RootWindow != g.HoveredWindow->RootWindow)
		return false;

	const ImRect& display_rect = (window->DC.LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect) ? window->DC.LastItemDisplayRect : window->DC.LastItemRect;
	ImGuiID id = window->DC.LastItemId;
	if (id == 0)
		id = window->GetIDFromRectangle(display_rect);
	if (g.DragDropPayload.SourceId == id)
		return false;

	g.DragDropTargetRect = display_rect;
	g.DragDropTargetId = id;
	return true;
}

bool ImGui::IsDragDropPayloadBeingAccepted()
{
	ImGuiContext& g = *GImGui;
	return g.DragDropActive && g.DragDropAcceptIdPrev != 0;
}

const ImGuiPayload* ImGui::AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags)
{
	ImGuiContext& g = *GImGui;
	ImGuiWindow* window = g.CurrentWindow;
	ImGuiPayload& payload = g.DragDropPayload;
	IM_ASSERT(g.DragDropActive);                        // Not called between BeginDragDropTarget() and EndDragDropTarget() ?
	IM_ASSERT(payload.DataFrameCount != -1);            // Forgot to call EndDragDropTarget() ?
	if (type != NULL && !payload.IsDataType(type))
		return NULL;

	// Accept smallest drag target bounding box, this allows us to nest drag targets conveniently without ordering constraints.
	// NB: We currently accept NULL id as target. However, overlapping targets requires a unique ID to function!
	const bool was_accepted_previously = (g.DragDropAcceptIdPrev == g.DragDropTargetId);
	ImRect r = g.DragDropTargetRect;
	float r_surface = r.GetWidth() * r.GetHeight();
	if (r_surface < g.DragDropAcceptIdCurrRectSurface)
	{
		g.DragDropAcceptIdCurr = g.DragDropTargetId;
		g.DragDropAcceptIdCurrRectSurface = r_surface;
	}

	// Render default drop visuals
	payload.Preview = was_accepted_previously;
	flags |= (g.DragDropSourceFlags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect); // Source can also inhibit the preview (useful for external sources that lives for 1 frame)
	if (!(flags & ImGuiDragDropFlags_AcceptNoDrawDefaultRect) && payload.Preview)
	{
		// FIXME-DRAG: Settle on a proper default visuals for drop target.
		r.Expand(3.5f);
		bool push_clip_rect = !window->ClipRect.Contains(r);
		if (push_clip_rect) window->DrawList->PushClipRectFullScreen();
		window->DrawList->AddRect(r.Min, r.Max, GetColorU32(ImGuiCol_DragDropTarget), 0.0f, ~0, 2.0f);
		if (push_clip_rect) window->DrawList->PopClipRect();
	}

	g.DragDropAcceptFrameCount = g.FrameCount;
	payload.Delivery = was_accepted_previously && !IsMouseDown(g.DragDropMouseButton); // For extern drag sources affecting os window focus, it's easier to just test !IsMouseDown() instead of IsMouseReleased()
	if (!payload.Delivery && !(flags & ImGuiDragDropFlags_AcceptBeforeDelivery))
		return NULL;

	return &payload;
}

// We don't really use/need this now, but added it for the sake of consistency and because we might need it later.
void ImGui::EndDragDropTarget()
{
	ImGuiContext& g = *GImGui; (void)g;
	IM_ASSERT(g.DragDropActive);
}

//-----------------------------------------------------------------------------
// PLATFORM DEPENDENT HELPERS
//-----------------------------------------------------------------------------

#if defined(_WIN32) && !defined(_WINDOWS_) && (!defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS) || !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS))
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#ifndef __MINGW32__
#include <Windows.h>
#else
#include <windows.h>
#endif
#endif

// Win32 API clipboard implementation
#if defined(_WIN32) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_CLIPBOARD_FUNCTIONS)

#ifdef _MSC_VER
#pragma comment(lib, "user32")
#endif

static const char* GetClipboardTextFn_DefaultImpl(void*)
{
	static ImVector<char> buf_local;
	buf_local.clear();
	if (!OpenClipboard(NULL))
		return NULL;
	HANDLE wbuf_handle = GetClipboardData(CF_UNICODETEXT);
	if (wbuf_handle == NULL)
	{
		CloseClipboard();
		return NULL;
	}
	if (ImWchar* wbuf_global = (ImWchar*)GlobalLock(wbuf_handle))
	{
		int buf_len = ImTextCountUtf8BytesFromStr(wbuf_global, NULL) + 1;
		buf_local.resize(buf_len);
		ImTextStrToUtf8(buf_local.Data, buf_len, wbuf_global, NULL);
	}
	GlobalUnlock(wbuf_handle);
	CloseClipboard();
	return buf_local.Data;
}

static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
	if (!OpenClipboard(NULL))
		return;
	const int wbuf_length = ImTextCountCharsFromUtf8(text, NULL) + 1;
	HGLOBAL wbuf_handle = GlobalAlloc(GMEM_MOVEABLE, (SIZE_T)wbuf_length * sizeof(ImWchar));
	if (wbuf_handle == NULL)
	{
		CloseClipboard();
		return;
	}
	ImWchar* wbuf_global = (ImWchar*)GlobalLock(wbuf_handle);
	ImTextStrFromUtf8(wbuf_global, wbuf_length, text, NULL);
	GlobalUnlock(wbuf_handle);
	EmptyClipboard();
	SetClipboardData(CF_UNICODETEXT, wbuf_handle);
	CloseClipboard();
}

#else

// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers
static const char* GetClipboardTextFn_DefaultImpl(void*)
{
	ImGuiContext& g = *GImGui;
	return g.PrivateClipboard.empty() ? NULL : g.PrivateClipboard.begin();
}

// Local ImGui-only clipboard implementation, if user hasn't defined better clipboard handlers
static void SetClipboardTextFn_DefaultImpl(void*, const char* text)
{
	ImGuiContext& g = *GImGui;
	g.PrivateClipboard.clear();
	const char* text_end = text + strlen(text);
	g.PrivateClipboard.resize((int)(text_end - text) + 1);
	memcpy(&g.PrivateClipboard[0], text, (size_t)(text_end - text));
	g.PrivateClipboard[(int)(text_end - text)] = 0;
}

#endif

// Win32 API IME support (for Asian languages, etc.)
#if defined(_WIN32) && !defined(__GNUC__) && !defined(IMGUI_DISABLE_WIN32_DEFAULT_IME_FUNCTIONS)

#include <imm.h>
#ifdef _MSC_VER
#pragma comment(lib, "imm32")
#endif

static void ImeSetInputScreenPosFn_DefaultImpl(int x, int y)
{
	// Notify OS Input Method Editor of text input position
	if (HWND hwnd = (HWND)GImGui->IO.ImeWindowHandle)
		if (HIMC himc = ImmGetContext(hwnd))
		{
			COMPOSITIONFORM cf;
			cf.ptCurrentPos.x = x;
			cf.ptCurrentPos.y = y;
			cf.dwStyle = CFS_FORCE_POSITION;
			ImmSetCompositionWindow(himc, &cf);
		}
}

#else

static void ImeSetInputScreenPosFn_DefaultImpl(int, int) {}

#endif

//-----------------------------------------------------------------------------
// HELP
//-----------------------------------------------------------------------------

void ImGui::ShowMetricsWindow(bool* p_open)
{
	if (ImGui::Begin("ImGui Metrics", p_open))
	{
		ImGui::Text("Dear ImGui %s", ImGui::GetVersion());
		ImGui::Text("Application average %.3f ms/frame (%.1f FPS)", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate);
		ImGui::Text("%d vertices, %d indices (%d triangles)", ImGui::GetIO().MetricsRenderVertices, ImGui::GetIO().MetricsRenderIndices, ImGui::GetIO().MetricsRenderIndices / 3);
		ImGui::Text("%d allocations", (int)GImAllocatorActiveAllocationsCount);
		static bool show_clip_rects = true;
		ImGui::Checkbox("Show clipping rectangles when hovering draw commands", &show_clip_rects);
		ImGui::Separator();

		struct Funcs
		{
			static void NodeDrawList(ImGuiWindow* window, ImDrawList* draw_list, const char* label)
			{
				bool node_open = ImGui::TreeNode(draw_list, "%s: '%s' %d vtx, %d indices, %d cmds", label, draw_list->_OwnerName ? draw_list->_OwnerName : "", draw_list->VtxBuffer.Size, draw_list->IdxBuffer.Size, draw_list->CmdBuffer.Size);
				if (draw_list == ImGui::GetWindowDrawList())
				{
					ImGui::SameLine();
					ImGui::TextColored(ImColor(255, 100, 100), "CURRENTLY APPENDING"); // Can't display stats for active draw list! (we don't have the data double-buffered)
					if (node_open) ImGui::TreePop();
					return;
				}

				ImDrawList* overlay_draw_list = ImGui::GetOverlayDrawList(); // Render additional visuals into the top-most draw list
				if (window && ImGui::IsItemHovered())
					overlay_draw_list->AddRect(window->Pos, window->Pos + window->Size, IM_COL32(255, 255, 0, 255));
				if (!node_open)
					return;

				int elem_offset = 0;
				for (const ImDrawCmd* pcmd = draw_list->CmdBuffer.begin(); pcmd < draw_list->CmdBuffer.end(); elem_offset += pcmd->ElemCount, pcmd++)
				{
					if (pcmd->UserCallback == NULL && pcmd->ElemCount == 0)
						continue;
					if (pcmd->UserCallback)
					{
						ImGui::BulletText("Callback %p, user_data %p", pcmd->UserCallback, pcmd->UserCallbackData);
						continue;
					}
					ImDrawIdx* idx_buffer = (draw_list->IdxBuffer.Size > 0) ? draw_list->IdxBuffer.Data : NULL;
					bool pcmd_node_open = ImGui::TreeNode((void*)(pcmd - draw_list->CmdBuffer.begin()), "Draw %4d %s vtx, tex 0x%p, clip_rect (%4.0f,%4.0f)-(%4.0f,%4.0f)", pcmd->ElemCount, draw_list->IdxBuffer.Size > 0 ? "indexed" : "non-indexed", pcmd->TextureId, pcmd->ClipRect.x, pcmd->ClipRect.y, pcmd->ClipRect.z, pcmd->ClipRect.w);
					if (show_clip_rects && ImGui::IsItemHovered())
					{
						ImRect clip_rect = pcmd->ClipRect;
						ImRect vtxs_rect;
						for (int i = elem_offset; i < elem_offset + (int)pcmd->ElemCount; i++)
							vtxs_rect.Add(draw_list->VtxBuffer[idx_buffer ? idx_buffer[i] : i].pos);
						clip_rect.Floor(); overlay_draw_list->AddRect(clip_rect.Min, clip_rect.Max, IM_COL32(255, 255, 0, 255));
						vtxs_rect.Floor(); overlay_draw_list->AddRect(vtxs_rect.Min, vtxs_rect.Max, IM_COL32(255, 0, 255, 255));
					}
					if (!pcmd_node_open)
						continue;

					// Display individual triangles/vertices. Hover on to get the corresponding triangle highlighted.
					ImGuiListClipper clipper(pcmd->ElemCount / 3); // Manually coarse clip our print out of individual vertices to save CPU, only items that may be visible.
					while (clipper.Step())
						for (int prim = clipper.DisplayStart, vtx_i = elem_offset + clipper.DisplayStart * 3; prim < clipper.DisplayEnd; prim++)
						{
							char buf[300];
							char* buf_p = buf, * buf_end = buf + IM_ARRAYSIZE(buf);
							ImVec2 triangles_pos[3];
							for (int n = 0; n < 3; n++, vtx_i++)
							{
								ImDrawVert& v = draw_list->VtxBuffer[idx_buffer ? idx_buffer[vtx_i] : vtx_i];
								triangles_pos[n] = v.pos;
								buf_p += ImFormatString(buf_p, (int)(buf_end - buf_p), "%s %04d: pos (%8.2f,%8.2f), uv (%.6f,%.6f), col %08X\n", (n == 0) ? "vtx" : "   ", vtx_i, v.pos.x, v.pos.y, v.uv.x, v.uv.y, v.col);
							}
							ImGui::Selectable(buf, false);
							if (ImGui::IsItemHovered())
							{
								ImDrawListFlags backup_flags = overlay_draw_list->Flags;
								overlay_draw_list->Flags &= ~ImDrawListFlags_AntiAliasedLines; // Disable AA on triangle outlines at is more readable for very large and thin triangles.
								overlay_draw_list->AddPolyline(triangles_pos, 3, IM_COL32(255, 255, 0, 255), true, 1.0f);
								overlay_draw_list->Flags = backup_flags;
							}
						}
					ImGui::TreePop();
				}
				ImGui::TreePop();
			}

			static void NodeWindows(ImVector<ImGuiWindow*>& windows, const char* label)
			{
				if (!ImGui::TreeNode(label, "%s (%d)", label, windows.Size))
					return;
				for (int i = 0; i < windows.Size; i++)
					Funcs::NodeWindow(windows[i], "Window");
				ImGui::TreePop();
			}

			static void NodeWindow(ImGuiWindow* window, const char* label)
			{
				if (!ImGui::TreeNode(window, "%s '%s', %d @ 0x%p", label, window->Name, window->Active || window->WasActive, window))
					return;
				ImGuiWindowFlags flags = window->Flags;
				NodeDrawList(window, window->DrawList, "DrawList");
				ImGui::BulletText("Pos: (%.1f,%.1f), Size: (%.1f,%.1f), SizeContents (%.1f,%.1f)", window->Pos.x, window->Pos.y, window->Size.x, window->Size.y, window->SizeContents.x, window->SizeContents.y);
				ImGui::BulletText("Flags: 0x%08X (%s%s%s%s%s%s..)", flags,
					(flags & ImGuiWindowFlags_ChildWindow) ? "Child " : "", (flags & ImGuiWindowFlags_Tooltip) ? "Tooltip " : "", (flags & ImGuiWindowFlags_Popup) ? "Popup " : "",
					(flags & ImGuiWindowFlags_Modal) ? "Modal " : "", (flags & ImGuiWindowFlags_ChildMenu) ? "ChildMenu " : "", (flags & ImGuiWindowFlags_NoSavedSettings) ? "NoSavedSettings " : "");
				ImGui::BulletText("Scroll: (%.2f/%.2f,%.2f/%.2f)", window->Scroll.x, GetScrollMaxX(window), window->Scroll.y, GetScrollMaxY(window));
				ImGui::BulletText("Active: %d, WriteAccessed: %d", window->Active, window->WriteAccessed);
				ImGui::BulletText("NavLastIds: 0x%08X,0x%08X, NavLayerActiveMask: %X", window->NavLastIds[0], window->NavLastIds[1], window->DC.NavLayerActiveMask);
				ImGui::BulletText("NavLastChildNavWindow: %s", window->NavLastChildNavWindow ? window->NavLastChildNavWindow->Name : "NULL");
				if (window->NavRectRel[0].IsInverted())
					ImGui::BulletText("NavRectRel[0]: (%.1f,%.1f)(%.1f,%.1f)", window->NavRectRel[0].Min.x, window->NavRectRel[0].Min.y, window->NavRectRel[0].Max.x, window->NavRectRel[0].Max.y);
				else
					ImGui::BulletText("NavRectRel[0]: <None>");
				if (window->RootWindow != window) NodeWindow(window->RootWindow, "RootWindow");
				if (window->DC.ChildWindows.Size > 0) NodeWindows(window->DC.ChildWindows, "ChildWindows");
				if (window->ColumnsStorage.Size > 0 && ImGui::TreeNode("Columns", "Columns sets (%d)", window->ColumnsStorage.Size))
				{
					for (int n = 0; n < window->ColumnsStorage.Size; n++)
					{
						const ImGuiColumnsSet* columns = &window->ColumnsStorage[n];
						if (ImGui::TreeNode((void*)(uintptr_t)columns->ID, "Columns Id: 0x%08X, Count: %d, Flags: 0x%04X", columns->ID, columns->Count, columns->Flags))
						{
							ImGui::BulletText("Width: %.1f (MinX: %.1f, MaxX: %.1f)", columns->MaxX - columns->MinX, columns->MinX, columns->MaxX);
							for (int column_n = 0; column_n < columns->Columns.Size; column_n++)
								ImGui::BulletText("Column %02d: OffsetNorm %.3f (= %.1f px)", column_n, columns->Columns[column_n].OffsetNorm, OffsetNormToPixels(columns, columns->Columns[column_n].OffsetNorm));
							ImGui::TreePop();
						}
					}
					ImGui::TreePop();
				}
				ImGui::BulletText("Storage: %d bytes", window->StateStorage.Data.Size * (int)sizeof(ImGuiStorage::Pair));
				ImGui::TreePop();
			}
		};

		// Access private state, we are going to display the draw lists from last frame
		ImGuiContext& g = *GImGui;
		Funcs::NodeWindows(g.Windows, "Windows");
		if (ImGui::TreeNode("DrawList", "Active DrawLists (%d)", g.DrawDataBuilder.Layers[0].Size))
		{
			for (int i = 0; i < g.DrawDataBuilder.Layers[0].Size; i++)
				Funcs::NodeDrawList(NULL, g.DrawDataBuilder.Layers[0][i], "DrawList");
			ImGui::TreePop();
		}
		if (ImGui::TreeNode("Popups", "Open Popups Stack (%d)", g.OpenPopupStack.Size))
		{
			for (int i = 0; i < g.OpenPopupStack.Size; i++)
			{
				ImGuiWindow* window = g.OpenPopupStack[i].Window;
				ImGui::BulletText("PopupID: %08x, Window: '%s'%s%s", g.OpenPopupStack[i].PopupId, window ? window->Name : "NULL", window && (window->Flags & ImGuiWindowFlags_ChildWindow) ? " ChildWindow" : "", window && (window->Flags & ImGuiWindowFlags_ChildMenu) ? " ChildMenu" : "");
			}
			ImGui::TreePop();
		}
		if (ImGui::TreeNode("Internal state"))
		{
			const char* input_source_names[] = { "None", "Mouse", "Nav", "NavKeyboard", "NavGamepad" }; IM_ASSERT(IM_ARRAYSIZE(input_source_names) == ImGuiInputSource_COUNT);
			ImGui::Text("HoveredWindow: '%s'", g.HoveredWindow ? g.HoveredWindow->Name : "NULL");
			ImGui::Text("HoveredRootWindow: '%s'", g.HoveredRootWindow ? g.HoveredRootWindow->Name : "NULL");
			ImGui::Text("HoveredId: 0x%08X/0x%08X (%.2f sec)", g.HoveredId, g.HoveredIdPreviousFrame, g.HoveredIdTimer); // Data is "in-flight" so depending on when the Metrics window is called we may see current frame information or not
			ImGui::Text("ActiveId: 0x%08X/0x%08X (%.2f sec), ActiveIdSource: %s", g.ActiveId, g.ActiveIdPreviousFrame, g.ActiveIdTimer, input_source_names[g.ActiveIdSource]);
			ImGui::Text("ActiveIdWindow: '%s'", g.ActiveIdWindow ? g.ActiveIdWindow->Name : "NULL");
			ImGui::Text("MovingWindow: '%s'", g.MovingWindow ? g.MovingWindow->Name : "NULL");
			ImGui::Text("NavWindow: '%s'", g.NavWindow ? g.NavWindow->Name : "NULL");
			ImGui::Text("NavId: 0x%08X, NavLayer: %d", g.NavId, g.NavLayer);
			ImGui::Text("NavInputSource: %s", input_source_names[g.NavInputSource]);
			ImGui::Text("NavActive: %d, NavVisible: %d", g.IO.NavActive, g.IO.NavVisible);
			ImGui::Text("NavActivateId: 0x%08X, NavInputId: 0x%08X", g.NavActivateId, g.NavInputId);
			ImGui::Text("NavDisableHighlight: %d, NavDisableMouseHover: %d", g.NavDisableHighlight, g.NavDisableMouseHover);
			ImGui::Text("DragDrop: %d, SourceId = 0x%08X, Payload \"%s\" (%d bytes)", g.DragDropActive, g.DragDropPayload.SourceId, g.DragDropPayload.DataType, g.DragDropPayload.DataSize);
			ImGui::TreePop();
		}
	}
	ImGui::End();
}

//-----------------------------------------------------------------------------

// Include imgui_user.inl at the end of imgui.cpp to access private data/functions that aren't exposed.
// Prefer just including imgui_internal.h from your code rather than using this define. If a declaration is missing from imgui_internal.h add it or request it on the github.
#ifdef IMGUI_INCLUDE_IMGUI_USER_INL
#include "imgui_user.inl"
#endif
```

`src/imgui/imgui.h`:

```h
// dear imgui, v1.60
// (headers)

// See imgui.cpp file for documentation.
// Call and read ImGui::ShowDemoWindow() in imgui_demo.cpp for demo code.
// Read 'Programmer guide' in imgui.cpp for notes on how to setup ImGui in your codebase.
// Get latest version at https://github.com/ocornut/imgui

#pragma once

// Configuration file (edit imconfig.h or define IMGUI_USER_CONFIG to set your own filename)
#ifdef IMGUI_USER_CONFIG
#include IMGUI_USER_CONFIG
#endif

#include <float.h>          // FLT_MAX
#include <stdarg.h>         // va_list
#include <stddef.h>         // ptrdiff_t, NULL
#include <string.h>         // memset, memmove, memcpy, strlen, strchr, strcpy, strcmp

#include "../valve_sdk/math/Vectors.hpp"
#include "../helpers/math.h"

#define IMGUI_VERSION       "1.60"

// Define attributes of all API symbols declarations, e.g. for DLL under Windows.
#ifndef IMGUI_API
#define IMGUI_API
#endif

// Define assertion handler.
#ifndef IM_ASSERT
#include <assert.h>
#define IM_ASSERT(_EXPR)    assert(_EXPR)
#endif

// Helpers
#if defined(__clang__) || defined(__GNUC__)
#define IM_FMTARGS(FMT)             __attribute__((format(printf, FMT, FMT+1))) // Apply printf-style warnings to user functions.
#define IM_FMTLIST(FMT)             __attribute__((format(printf, FMT, 0)))
#else
#define IM_FMTARGS(FMT)
#define IM_FMTLIST(FMT)
#endif
#define IM_ARRAYSIZE(_ARR)          ((int)(sizeof(_ARR)/sizeof(*_ARR)))         // Size of a static C-style array. Don't use on pointers!
#define IM_OFFSETOF(_TYPE,_MEMBER)  ((size_t)&(((_TYPE*)0)->_MEMBER))           // Offset of _MEMBER within _TYPE. Standardized as offsetof() in modern C++.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wold-style-cast"
#endif

// Forward declarations
struct ImDrawChannel;               // Temporary storage for outputting drawing commands out of order, used by ImDrawList::ChannelsSplit()
struct ImDrawCmd;                   // A single draw command within a parent ImDrawList (generally maps to 1 GPU draw call)
struct ImDrawData;                  // All draw command lists required to render the frame
struct ImDrawList;                  // A single draw command list (generally one per window)
struct ImDrawListSharedData;        // Data shared among multiple draw lists (typically owned by parent ImGui context, but you may create one yourself)
struct ImDrawVert;                  // A single vertex (20 bytes by default, override layout with IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT)
struct ImFont;                      // Runtime data for a single font within a parent ImFontAtlas
struct ImFontAtlas;                 // Runtime data for multiple fonts, bake multiple fonts into a single texture, TTF/OTF font loader
struct ImFontConfig;                // Configuration data when adding a font or merging fonts
struct ImColor;                     // Helper functions to create a color that can be converted to either u32 or float4
struct ImGuiIO;                     // Main configuration and I/O between your application and ImGui
struct ImGuiOnceUponAFrame;         // Simple helper for running a block of code not more than once a frame, used by IMGUI_ONCE_UPON_A_FRAME macro
struct ImGuiStorage;                // Simple custom key value storage
struct ImGuiStyle;                  // Runtime data for styling/colors
struct ImGuiTextFilter;             // Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
struct ImGuiTextBuffer;             // Text buffer for logging/accumulating text
struct ImGuiTextEditCallbackData;   // Shared state of ImGui::InputText() when using custom ImGuiTextEditCallback (rare/advanced use)
struct ImGuiSizeCallbackData;       // Structure used to constraint window size in custom ways when using custom ImGuiSizeCallback (rare/advanced use)
struct ImGuiListClipper;            // Helper to manually clip large list of items
struct ImGuiPayload;                // User data payload for drag and drop operations
struct ImGuiContext;                // ImGui context (opaque)

#ifndef ImTextureID
typedef void* ImTextureID;          // User data to identify a texture (this is whatever to you want it to be! read the FAQ about ImTextureID in imgui.cpp)
#endif

									// Typedefs and Enumerations (declared as int for compatibility with old C++ and to not pollute the top of this file)
typedef unsigned int ImU32;         // 32-bit unsigned integer (typically used to store packed colors)
typedef unsigned int ImGuiID;       // Unique ID used by widgets (typically hashed from a stack of string)
typedef unsigned short ImWchar;     // Character for keyboard input/display
typedef int ImGuiCol;               // enum: a color identifier for styling     // enum ImGuiCol_
typedef int ImGuiDir;               // enum: a cardinal direction               // enum ImGuiDir_
typedef int ImGuiCond;              // enum: a condition for Set*()             // enum ImGuiCond_
typedef int ImGuiKey;               // enum: a key identifier (ImGui-side enum) // enum ImGuiKey_
typedef int ImGuiNavInput;          // enum: an input identifier for navigation // enum ImGuiNavInput_
typedef int ImGuiMouseCursor;       // enum: a mouse cursor identifier          // enum ImGuiMouseCursor_
typedef int ImGuiStyleVar;          // enum: a variable identifier for styling  // enum ImGuiStyleVar_
typedef int ImDrawCornerFlags;      // flags: for ImDrawList::AddRect*() etc.   // enum ImDrawCornerFlags_
typedef int ImDrawListFlags;        // flags: for ImDrawList                    // enum ImDrawListFlags_
typedef int ImFontAtlasFlags;       // flags: for ImFontAtlas                   // enum ImFontAtlasFlags_
typedef int ImGuiBackendFlags;      // flags: for io.BackendFlags               // enum ImGuiBackendFlags_
typedef int ImGuiColorEditFlags;    // flags: for ColorEdit*(), ColorPicker*()  // enum ImGuiColorEditFlags_
typedef int ImGuiColumnsFlags;      // flags: for *Columns*()                   // enum ImGuiColumnsFlags_
typedef int ImGuiConfigFlags;       // flags: for io.ConfigFlags                // enum ImGuiConfigFlags_
typedef int ImGuiDragDropFlags;     // flags: for *DragDrop*()                  // enum ImGuiDragDropFlags_
typedef int ImGuiComboFlags;        // flags: for BeginCombo()                  // enum ImGuiComboFlags_
typedef int ImGuiFocusedFlags;      // flags: for IsWindowFocused()             // enum ImGuiFocusedFlags_
typedef int ImGuiHoveredFlags;      // flags: for IsItemHovered() etc.          // enum ImGuiHoveredFlags_
typedef int ImGuiInputTextFlags;    // flags: for InputText*()                  // enum ImGuiInputTextFlags_
typedef int ImGuiSelectableFlags;   // flags: for Selectable()                  // enum ImGuiSelectableFlags_
typedef int ImGuiTreeNodeFlags;     // flags: for TreeNode*(),CollapsingHeader()// enum ImGuiTreeNodeFlags_
typedef int ImGuiWindowFlags;       // flags: for Begin*()                      // enum ImGuiWindowFlags_
typedef int(*ImGuiTextEditCallback)(ImGuiTextEditCallbackData* data);
typedef void(*ImGuiSizeCallback)(ImGuiSizeCallbackData* data);
#if defined(_MSC_VER) && !defined(__clang__)
typedef unsigned __int64 ImU64;     // 64-bit unsigned integer
#else
typedef unsigned long long ImU64;   // 64-bit unsigned integer
#endif

struct ImVec2
{
	float x, y;
	ImVec2() { x = y = 0.0f; }
	ImVec2(float _x, float _y) { x = _x; y = _y; }
	float  operator[] (size_t idx) const { IM_ASSERT(idx <= 1); return (&x)[idx]; }    // We very rarely use this [] operator, the assert overhead is fine.
#ifdef IM_VEC2_CLASS_EXTRA          // Define constructor and implicit cast operators in imconfig.h to convert back<>forth from your math types and ImVec2.
	IM_VEC2_CLASS_EXTRA
#endif
};

struct ImVec4
{
	float x, y, z, w;
	ImVec4() { x = y = z = w = 0.0f; }
	ImVec4(float _x, float _y, float _z, float _w) { x = _x; y = _y; z = _z; w = _w; }
#ifdef IM_VEC4_CLASS_EXTRA          // Define constructor and implicit cast operators in imconfig.h to convert back<>forth from your math types and ImVec4.
	IM_VEC4_CLASS_EXTRA
#endif
		bool operator !=(const ImVec4& other) const
	{
		return x != other.x || y != other.y || z != other.z || w != other.w;
	}

	bool operator ==(const ImVec4& other) const
	{
		return x == other.x && y == other.y && z == other.z && w == other.w;
	}

	static ImVec4 White;
	static ImVec4 Green;
	static ImVec4 Black;
	static ImVec4 Red;
	static ImVec4 Yellow;
	static ImVec4 Orange;
};

// ImGui end-user API
// In a namespace so that user can add extra functions in a separate file (e.g. Value() helpers for your vector or common types)
namespace ImGui
{
	// Context creation and access
	// All contexts share a same ImFontAtlas by default. If you want different font atlas, you can new() them and overwrite the GetIO().Fonts variable of an ImGui context.
	// All those functions are not reliant on the current context.
	IMGUI_API ImGuiContext* CreateContext(ImFontAtlas* shared_font_atlas = NULL);
	IMGUI_API void          DestroyContext(ImGuiContext* ctx = NULL);   // NULL = destroy current context
	IMGUI_API ImGuiContext* GetCurrentContext();
	IMGUI_API void          SetCurrentContext(ImGuiContext* ctx);

	// Main
	IMGUI_API ImGuiIO& GetIO();
	IMGUI_API ImGuiStyle& GetStyle();
	IMGUI_API void          NewFrame();                                 // start a new ImGui frame, you can submit any command from this point until Render()/EndFrame().
	IMGUI_API void          Render();                                   // ends the ImGui frame, finalize the draw data. (Obsolete: optionally call io.RenderDrawListsFn if set. Nowadays, prefer calling your render function yourself.)
	IMGUI_API ImDrawData* GetDrawData();                              // valid after Render() and until the next call to NewFrame(). this is what you have to render. (Obsolete: this used to be passed to your io.RenderDrawListsFn() function.)
	IMGUI_API void          EndFrame();                                 // ends the ImGui frame. automatically called by Render(), so most likely don't need to ever call that yourself directly. If you don't need to render you may call EndFrame() but you'll have wasted CPU already. If you don't need to render, better to not create any imgui windows instead!

																		// Demo, Debug, Information
	IMGUI_API void          ShowDemoWindow(bool* p_open = NULL);        // create demo/test window (previously called ShowTestWindow). demonstrate most ImGui features. call this to learn about the library! try to make it always available in your application!
	IMGUI_API void          ShowMetricsWindow(bool* p_open = NULL);     // create metrics window. display ImGui internals: draw commands (with individual draw calls and vertices), window list, basic internal state, etc.
	IMGUI_API void          ShowStyleEditor(ImGuiStyle* ref = NULL);    // add style editor block (not a window). you can pass in a reference ImGuiStyle structure to compare to, revert to and save to (else it uses the default style)
	IMGUI_API bool          ShowStyleSelector(const char* label);       // add style selector block (not a window), essentially a combo listing the default styles.
	IMGUI_API void          ShowFontSelector(const char* label);        // add font selector block (not a window), essentially a combo listing the loaded fonts.
	IMGUI_API void          ShowUserGuide();                            // add basic help/info block (not a window): how to manipulate ImGui as a end-user (mouse/keyboard controls).
	IMGUI_API const char* GetVersion();                               // get a version string e.g. "1.23"

																		// Styles
	IMGUI_API void          StyleColorsDark(ImGuiStyle* dst = NULL);    // new, recommended style (default)
	IMGUI_API void          StyleColorsClassic(ImGuiStyle* dst = NULL); // classic imgui style
	IMGUI_API void          StyleColorsLight(ImGuiStyle* dst = NULL);   // best used with borders and a custom, thicker font

																		// Windows
																		// (Begin = push window to the stack and start appending to it. End = pop window from the stack. You may append multiple times to the same window during the same frame)
																		// Begin()/BeginChild() return false to indicate the window being collapsed or fully clipped, so you may early out and omit submitting anything to the window.
																		// However you need to always call a matching End()/EndChild() for a Begin()/BeginChild() call, regardless of its return value (this is due to legacy reason and is inconsistent with BeginMenu/EndMenu, BeginPopup/EndPopup and other functions where the End call should only be called if the corresponding Begin function returned true.)
																		// Passing 'bool* p_open != NULL' shows a close widget in the upper-right corner of the window, which when clicking will set the boolean to false.
																		// Use child windows to introduce independent scrolling/clipping regions within a host window. Child windows can embed their own child.
	IMGUI_API bool          Begin(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);
	IMGUI_API void          End();
	IMGUI_API bool          BeginChild(const char* str_id, const ImVec2& size = ImVec2(0, 0), bool border = false, ImGuiWindowFlags flags = 0); // Begin a scrolling region. size==0.0f: use remaining window size, size<0.0f: use remaining window size minus abs(size). size>0.0f: fixed size. each axis can use a different mode, e.g. ImVec2(0,400).
	IMGUI_API bool          BeginChild(ImGuiID id, const ImVec2& size = ImVec2(0, 0), bool border = false, ImGuiWindowFlags flags = 0);
	IMGUI_API void          EndChild();

	// Windows Utilities
	IMGUI_API bool          IsWindowAppearing();
	IMGUI_API bool          IsWindowCollapsed();
	IMGUI_API bool          IsWindowFocused(ImGuiFocusedFlags flags = 0); // is current window focused? or its root/child, depending on flags. see flags for options.
	IMGUI_API bool          IsWindowHovered(ImGuiHoveredFlags flags = 0); // is current window hovered (and typically: not blocked by a popup/modal)? see flags for options. NB: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that! Please read the FAQ!
	IMGUI_API ImDrawList* GetWindowDrawList();                        // get draw list associated to the window, to append your own drawing primitives
	IMGUI_API ImVec2        GetWindowPos();                             // get current window position in screen space (useful if you want to do your own drawing via the DrawList API)
	IMGUI_API ImVec2        GetWindowSize();                            // get current window size
	IMGUI_API float         GetWindowWidth();                           // get current window width (shortcut for GetWindowSize().x)
	IMGUI_API float         GetWindowHeight();                          // get current window height (shortcut for GetWindowSize().y)
	IMGUI_API ImVec2        GetContentRegionMax();                      // current content boundaries (typically window boundaries including scrolling, or current column boundaries), in windows coordinates
	IMGUI_API ImVec2        GetContentRegionAvail();                    // == GetContentRegionMax() - GetCursorPos()
	IMGUI_API float         GetContentRegionAvailWidth();               //
	IMGUI_API ImVec2        GetWindowContentRegionMin();                // content boundaries min (roughly (0,0)-Scroll), in window coordinates
	IMGUI_API ImVec2        GetWindowContentRegionMax();                // content boundaries max (roughly (0,0)+Size-Scroll) where Size can be override with SetNextWindowContentSize(), in window coordinates
	IMGUI_API float         GetWindowContentRegionWidth();              //

	IMGUI_API void          SetNextWindowPos(const ImVec2& pos, ImGuiCond cond = 0, const ImVec2 & pivot = ImVec2(0, 0)); // set next window position. call before Begin(). use pivot=(0.5f,0.5f) to center on given point, etc.
	IMGUI_API void          SetNextWindowSize(const ImVec2& size, ImGuiCond cond = 0);                  // set next window size. set axis to 0.0f to force an auto-fit on this axis. call before Begin()
	IMGUI_API void          SetNextWindowSizeConstraints(const ImVec2& size_min, const ImVec2& size_max, ImGuiSizeCallback custom_callback = NULL, void* custom_callback_data = NULL); // set next window size limits. use -1,-1 on either X/Y axis to preserve the current size. Use callback to apply non-trivial programmatic constraints.
	IMGUI_API void          SetNextWindowContentSize(const ImVec2& size);                               // set next window content size (~ enforce the range of scrollbars). not including window decorations (title bar, menu bar, etc.). set an axis to 0.0f to leave it automatic. call before Begin()
	IMGUI_API void          SetNextWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                 // set next window collapsed state. call before Begin()
	IMGUI_API void          SetNextWindowFocus();                                                       // set next window to be focused / front-most. call before Begin()
	IMGUI_API void          SetNextWindowBgAlpha(float alpha);                                          // set next window background color alpha. helper to easily modify ImGuiCol_WindowBg/ChildBg/PopupBg.
	IMGUI_API void          SetWindowPos(const ImVec2& pos, ImGuiCond cond = 0);                        // (not recommended) set current window position - call within Begin()/End(). prefer using SetNextWindowPos(), as this may incur tearing and side-effects.
	IMGUI_API void          SetWindowSize(const ImVec2& size, ImGuiCond cond = 0);                      // (not recommended) set current window size - call within Begin()/End(). set to ImVec2(0,0) to force an auto-fit. prefer using SetNextWindowSize(), as this may incur tearing and minor side-effects.
	IMGUI_API void          SetWindowCollapsed(bool collapsed, ImGuiCond cond = 0);                     // (not recommended) set current window collapsed state. prefer using SetNextWindowCollapsed().
	IMGUI_API void          SetWindowFocus();                                                           // (not recommended) set current window to be focused / front-most. prefer using SetNextWindowFocus().
	IMGUI_API void          SetWindowFontScale(float scale);                                            // set font scale. Adjust IO.FontGlobalScale if you want to scale all windows
	IMGUI_API void          SetWindowPos(const char* name, const ImVec2& pos, ImGuiCond cond = 0);      // set named window position.
	IMGUI_API void          SetWindowSize(const char* name, const ImVec2& size, ImGuiCond cond = 0);    // set named window size. set axis to 0.0f to force an auto-fit on this axis.
	IMGUI_API void          SetWindowCollapsed(const char* name, bool collapsed, ImGuiCond cond = 0);   // set named window collapsed state
	IMGUI_API void          SetWindowFocus(const char* name);                                           // set named window to be focused / front-most. use NULL to remove focus.

																										// Windows Scrolling
	IMGUI_API float         GetScrollX();                                                   // get scrolling amount [0..GetScrollMaxX()]
	IMGUI_API float         GetScrollY();                                                   // get scrolling amount [0..GetScrollMaxY()]
	IMGUI_API float         GetScrollMaxX();                                                // get maximum scrolling amount ~~ ContentSize.X - WindowSize.X
	IMGUI_API float         GetScrollMaxY();                                                // get maximum scrolling amount ~~ ContentSize.Y - WindowSize.Y
	IMGUI_API void          SetScrollX(float scroll_x);                                     // set scrolling amount [0..GetScrollMaxX()]
	IMGUI_API void          SetScrollY(float scroll_y);                                     // set scrolling amount [0..GetScrollMaxY()]
	IMGUI_API void          SetScrollHere(float center_y_ratio = 0.5f);                     // adjust scrolling amount to make current cursor position visible. center_y_ratio=0.0: top, 0.5: center, 1.0: bottom. When using to make a "default/current item" visible, consider using SetItemDefaultFocus() instead.
	IMGUI_API void          SetScrollFromPosY(float pos_y, float center_y_ratio = 0.5f);    // adjust scrolling amount to make given position valid. use GetCursorPos() or GetCursorStartPos()+offset to get valid positions.

																							// Parameters stacks (shared)
	IMGUI_API void          PushFont(ImFont* font);                                         // use NULL as a shortcut to push default font
	IMGUI_API void          PopFont();
	IMGUI_API void          PushStyleColor(ImGuiCol idx, ImU32 col);
	IMGUI_API void          PushStyleColor(ImGuiCol idx, const ImVec4& col);
	IMGUI_API void          PopStyleColor(int count = 1);
	IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, float val);
	IMGUI_API void          PushStyleVar(ImGuiStyleVar idx, const ImVec2& val);
	IMGUI_API void          PopStyleVar(int count = 1);
	IMGUI_API const ImVec4& GetStyleColorVec4(ImGuiCol idx);                                // retrieve style color as stored in ImGuiStyle structure. use to feed back into PushStyleColor(), otherwhise use GetColorU32() to get style color with style alpha baked in.
	IMGUI_API ImFont* GetFont();                                                      // get current font
	IMGUI_API float         GetFontSize();                                                  // get current font size (= height in pixels) of current font with current scale applied
	IMGUI_API ImVec2        GetFontTexUvWhitePixel();                                       // get UV coordinate for a while pixel, useful to draw custom shapes via the ImDrawList API
	IMGUI_API ImU32         GetColorU32(ImGuiCol idx, float alpha_mul = 1.0f);              // retrieve given style color with style alpha applied and optional extra alpha multiplier
	IMGUI_API ImU32         GetColorU32(const ImVec4& col);									// retrieve given color with style alpha applied
	IMGUI_API ImU32         GetColorU32(ImU32 col);                                         // retrieve given color with style alpha applied

																							// Parameters stacks (current window)
	IMGUI_API void          PushItemWidth(float item_width);                                // width of items for the common item+label case, pixels. 0.0f = default to ~2/3 of windows width, >0.0f: width in pixels, <0.0f align xx pixels to the right of window (so -1.0f always align width to the right side)
	IMGUI_API void          PopItemWidth();
	IMGUI_API float         CalcItemWidth();                                                // width of item given pushed settings and current cursor position
	IMGUI_API void          PushTextWrapPos(float wrap_pos_x = 0.0f);                       // word-wrapping for Text*() commands. < 0.0f: no wrapping; 0.0f: wrap to end of window (or column); > 0.0f: wrap at 'wrap_pos_x' position in window local space
	IMGUI_API void          PopTextWrapPos();
	IMGUI_API void          PushAllowKeyboardFocus(bool allow_keyboard_focus);              // allow focusing using TAB/Shift-TAB, enabled by default but you can disable it for certain widgets
	IMGUI_API void          PopAllowKeyboardFocus();
	IMGUI_API void          PushButtonRepeat(bool repeat);                                  // in 'repeat' mode, Button*() functions return repeated true in a typematic manner (using io.KeyRepeatDelay/io.KeyRepeatRate setting). Note that you can call IsItemActive() after any Button() to tell if the button is held in the current frame.
	IMGUI_API void          PopButtonRepeat();

	// Cursor / Layout
	IMGUI_API void          Separator();                                                    // separator, generally horizontal. inside a menu bar or in horizontal layout mode, this becomes a vertical separator.
	IMGUI_API void          SameLine(float pos_x = 0.0f, float spacing_w = -1.0f);          // call between widgets or groups to layout them horizontally
	IMGUI_API void          NewLine();                                                      // undo a SameLine()
	IMGUI_API void          Spacing();                                                      // add vertical spacing
	IMGUI_API void          Dummy(const ImVec2& size);                                      // add a dummy item of given size
	IMGUI_API void          Indent(float indent_w = 0.0f);                                  // move content position toward the right, by style.IndentSpacing or indent_w if != 0
	IMGUI_API void          Unindent(float indent_w = 0.0f);                                // move content position back to the left, by style.IndentSpacing or indent_w if != 0
	IMGUI_API void          BeginGroup();                                                   // lock horizontal starting position + capture group bounding box into one "item" (so you can use IsItemHovered() or layout primitives such as SameLine() on whole group, etc.)
	IMGUI_API void          EndGroup();
	IMGUI_API ImVec2        GetCursorPos();                                                 // cursor position is relative to window position
	IMGUI_API float         GetCursorPosX();                                                // "
	IMGUI_API float         GetCursorPosY();                                                // "
	IMGUI_API void          SetCursorPos(const ImVec2& local_pos);                          // "
	IMGUI_API void          SetCursorPosX(float x);                                         // "
	IMGUI_API void          SetCursorPosY(float y);                                         // "
	IMGUI_API ImVec2        GetCursorStartPos();                                            // initial cursor position
	IMGUI_API ImVec2        GetCursorScreenPos();                                           // cursor position in absolute screen coordinates [0..io.DisplaySize] (useful to work with ImDrawList API)
	IMGUI_API void          SetCursorScreenPos(const ImVec2& screen_pos);                   // cursor position in absolute screen coordinates [0..io.DisplaySize]
	IMGUI_API void          AlignTextToFramePadding();                                      // vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)
	IMGUI_API float         GetTextLineHeight();                                            // ~ FontSize
	IMGUI_API float         GetTextLineHeightWithSpacing();                                 // ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
	IMGUI_API float         GetFrameHeight();                                               // ~ FontSize + style.FramePadding.y * 2
	IMGUI_API float         GetFrameHeightWithSpacing();                                    // ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)

																							// ID stack/scopes
																							// Read the FAQ for more details about how ID are handled in dear imgui. If you are creating widgets in a loop you most
																							// likely want to push a unique identifier (e.g. object pointer, loop index) to uniquely differentiate them.
																							// You can also use the "##foobar" syntax within widget label to distinguish them from each others.
																							// In this header file we use the "label"/"name" terminology to denote a string that will be displayed and used as an ID,
																							// whereas "str_id" denote a string that is only used as an ID and not aimed to be displayed.
	IMGUI_API void          PushID(const char* str_id);                                     // push identifier into the ID stack. IDs are hash of the entire stack!
	IMGUI_API void          PushID(const char* str_id_begin, const char* str_id_end);
	IMGUI_API void          PushID(const void* ptr_id);
	IMGUI_API void          PushID(int int_id);
	IMGUI_API void          PopID();
	IMGUI_API ImGuiID       GetID(const char* str_id);                                      // calculate unique ID (hash of whole ID stack + given parameter). e.g. if you want to query into ImGuiStorage yourself
	IMGUI_API ImGuiID       GetID(const char* str_id_begin, const char* str_id_end);
	IMGUI_API ImGuiID       GetID(const void* ptr_id);

	// Widgets: Text
	IMGUI_API void          TextUnformatted(const char* text, const char* text_end = NULL);                // raw text without formatting. Roughly equivalent to Text("%s", text) but: A) doesn't require null terminated string if 'text_end' is specified, B) it's faster, no memory copy is done, no buffer size limits, recommended for long chunks of text.
	IMGUI_API void          Text(const char* fmt, ...)                                      IM_FMTARGS(1); // simple formatted text
	IMGUI_API void          TextV(const char* fmt, va_list args)                            IM_FMTLIST(1);
	IMGUI_API void          TextColored(const ImVec4& col, const char* fmt, ...)            IM_FMTARGS(2); // shortcut for PushStyleColor(ImGuiCol_Text, col); Text(fmt, ...); PopStyleColor();
	IMGUI_API void          TextColoredV(const ImVec4& col, const char* fmt, va_list args)  IM_FMTLIST(2);
	IMGUI_API void          TextDisabled(const char* fmt, ...)                              IM_FMTARGS(1); // shortcut for PushStyleColor(ImGuiCol_Text, style.Colors[ImGuiCol_TextDisabled]); Text(fmt, ...); PopStyleColor();
	IMGUI_API void          TextDisabledV(const char* fmt, va_list args)                    IM_FMTLIST(1);
	IMGUI_API void          TextWrapped(const char* fmt, ...)                               IM_FMTARGS(1); // shortcut for PushTextWrapPos(0.0f); Text(fmt, ...); PopTextWrapPos();. Note that this won't work on an auto-resizing window if there's no other widgets to extend the window width, yoy may need to set a size using SetNextWindowSize().
	IMGUI_API void          TextWrappedV(const char* fmt, va_list args)                     IM_FMTLIST(1);
	IMGUI_API void          LabelText(const char* label, const char* fmt, ...)              IM_FMTARGS(2); // display text+label aligned the same way as value+label widgets
	IMGUI_API void          LabelTextV(const char* label, const char* fmt, va_list args)    IM_FMTLIST(2);
	IMGUI_API void          BulletText(const char* fmt, ...)                                IM_FMTARGS(1); // shortcut for Bullet()+Text()
	IMGUI_API void          BulletTextV(const char* fmt, va_list args)                      IM_FMTLIST(1);

	// Widgets: Main
	IMGUI_API bool          SmallButton(const char* label);                                 // button with FramePadding=(0,0) to easily embed within text
	IMGUI_API bool          ArrowButton(const char* str_id, ImGuiDir dir);
	IMGUI_API bool          InvisibleButton(const char* str_id, const ImVec2& size);        // button behavior without the visuals, useful to build custom behaviors using the public api (along with IsItemActive, IsItemHovered, etc.)
	IMGUI_API void          Image(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), const ImVec4& tint_col = ImVec4(1, 1, 1, 1), const ImVec4& border_col = ImVec4(0, 0, 0, 0));
	IMGUI_API bool          ImageButton(ImTextureID user_texture_id, const ImVec2& size, const ImVec2& uv0 = ImVec2(0, 0), const ImVec2& uv1 = ImVec2(1, 1), int frame_padding = -1, const ImVec4 & bg_col = ImVec4(0, 0, 0, 0), const ImVec4 & tint_col = ImVec4(1, 1, 1, 1));    // <0 frame_padding uses default frame padding settings. 0 for no padding
	IMGUI_API bool          Checkbox(const char* label, bool* v);
	IMGUI_API bool          CheckboxFlags(const char* label, unsigned int* flags, unsigned int flags_value);
	IMGUI_API bool          RadioButton(const char* label, bool active);
	IMGUI_API bool          RadioButton(const char* label, int* v, int v_button);
	IMGUI_API void          PlotLines(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
	IMGUI_API void          PlotLines(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));
	IMGUI_API void          PlotHistogram(const char* label, const float* values, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0), int stride = sizeof(float));
	IMGUI_API void          PlotHistogram(const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset = 0, const char* overlay_text = NULL, float scale_min = FLT_MAX, float scale_max = FLT_MAX, ImVec2 graph_size = ImVec2(0, 0));
	IMGUI_API void          ProgressBar(float fraction, const ImVec2& size_arg = ImVec2(-1, 0), const char* overlay = NULL);
	IMGUI_API void          Bullet();                                                       // draw a small circle and keep the cursor on the same line. advance cursor x position by GetTreeNodeToLabelSpacing(), same distance that TreeNode() uses

																							// Widgets: Combo Box
																							// The new BeginCombo()/EndCombo() api allows you to manage your contents and selection state however you want it.
																							// The old Combo() api are helpers over BeginCombo()/EndCombo() which are kept available for convenience purpose.
	IMGUI_API bool          BeginCombo(const char* label, const char* preview_value, ImGuiComboFlags flags = 0);
	IMGUI_API void          EndCombo(); // only call EndCombo() if BeginCombo() returns true!
	IMGUI_API bool          Combo(const char* label, int* current_item, const char* const items[], int items_count, int popup_max_height_in_items = -1);
	IMGUI_API bool          Combo(const char* label, int* current_item, const char* items_separated_by_zeros, int popup_max_height_in_items = -1);      // Separate items with \0 within a string, end item-list with \0\0. e.g. "One\0Two\0Three\0"
	IMGUI_API bool          Combo(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int popup_max_height_in_items = -1);

	// Widgets: Drags (tip: ctrl+click on a drag box to input with keyboard. manually input values aren't clamped, can go off-bounds)
	// For all the Float2/Float3/Float4/Int2/Int3/Int4 versions of every functions, note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can pass address of your first element out of a contiguous set, e.g. &myvector.x
	// Speed are per-pixel of mouse movement (v_speed=0.2f: mouse needs to move by 5 pixels to increase value by 1). For gamepad/keyboard navigation, minimum speed is Max(v_speed, minimum_step_at_given_precision).
	IMGUI_API bool          DragFloat(const char* label, float* v, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);     // If v_min >= v_max we have no bound
	IMGUI_API bool          DragFloat2(const char* label, float v[2], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);
	IMGUI_API bool          DragFloat3(const char* label, float v[3], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);
	IMGUI_API bool          DragFloat4(const char* label, float v[4], float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", float power = 1.0f);
	IMGUI_API bool          DragFloatRange2(const char* label, float* v_current_min, float* v_current_max, float v_speed = 1.0f, float v_min = 0.0f, float v_max = 0.0f, const char* display_format = "%.3f", const char* display_format_max = NULL, float power = 1.0f);
	IMGUI_API bool          DragInt(const char* label, int* v, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");                                       // If v_min >= v_max we have no bound
	IMGUI_API bool          DragInt2(const char* label, int v[2], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");
	IMGUI_API bool          DragInt3(const char* label, int v[3], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");
	IMGUI_API bool          DragInt4(const char* label, int v[4], float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f");
	IMGUI_API bool          DragIntRange2(const char* label, int* v_current_min, int* v_current_max, float v_speed = 1.0f, int v_min = 0, int v_max = 0, const char* display_format = "%.0f", const char* display_format_max = NULL);

	// Widgets: Input with Keyboard
	IMGUI_API bool          InputText(const char* label, char* buf, size_t buf_size, ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);
	IMGUI_API bool          InputTextMultiline(const char* label, char* buf, size_t buf_size, const ImVec2& size = ImVec2(0, 0), ImGuiInputTextFlags flags = 0, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);
	IMGUI_API bool          InputFloat(const char* label, float* v, float step = 0.0f, float step_fast = 0.0f, int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);
	IMGUI_API bool          InputFloat2(const char* label, float v[2], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);
	IMGUI_API bool          InputFloat3(const char* label, float v[3], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);
	IMGUI_API bool          InputFloat4(const char* label, float v[4], int decimal_precision = -1, ImGuiInputTextFlags extra_flags = 0);
	IMGUI_API bool          InputInt(const char* label, int* v, int step = 1, int step_fast = 100, ImGuiInputTextFlags extra_flags = 0);
	IMGUI_API bool          InputInt2(const char* label, int v[2], ImGuiInputTextFlags extra_flags = 0);
	IMGUI_API bool          InputInt3(const char* label, int v[3], ImGuiInputTextFlags extra_flags = 0);
	IMGUI_API bool          InputInt4(const char* label, int v[4], ImGuiInputTextFlags extra_flags = 0);
	IMGUI_API bool          InputDouble(const char* label, double* v, double step = 0.0f, double step_fast = 0.0f, const char* display_format = "%.6f", ImGuiInputTextFlags extra_flags = 0);

	// Widgets: Sliders (tip: ctrl+click on a slider to input with keyboard. manually input values aren't clamped, can go off-bounds)
	IMGUI_API bool          SliderFloat(const char* label, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);     // adjust display_format to decorate the value with a prefix or a suffix for in-slider labels or unit display. Use power!=1.0 for logarithmic sliders
	IMGUI_API bool          SliderFloatLeftAlignedCustom(const char* label, float* v, float v_min, float v_max, const char* display_format, float* v2);
	IMGUI_API bool          SliderFloatLeftAligned(const char* label, float* v, float v_min, float v_max, const char* display_format = "%.3f");
	IMGUI_API bool          SliderFloat2(const char* label, float v[2], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
	IMGUI_API bool          SliderFloat3(const char* label, float v[3], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
	IMGUI_API bool          SliderFloat4(const char* label, float v[4], float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
	IMGUI_API bool          SliderAngle(const char* label, float* v_rad, float v_degrees_min = -360.0f, float v_degrees_max = +360.0f);
	IMGUI_API bool          SliderInt(const char* label, int* v, int v_min, int v_max, const char* display_format = "%.0f");
	IMGUI_API bool          SliderIntLeftAligned(const char* label, int* v, int v_min, int v_max, const char* display_format = "%.0f");
	IMGUI_API bool          SliderInt2(const char* label, int v[2], int v_min, int v_max, const char* display_format = "%.0f");
	IMGUI_API bool          SliderInt3(const char* label, int v[3], int v_min, int v_max, const char* display_format = "%.0f");
	IMGUI_API bool          SliderInt4(const char* label, int v[4], int v_min, int v_max, const char* display_format = "%.0f");
	IMGUI_API bool          VSliderFloat(const char* label, const ImVec2& size, float* v, float v_min, float v_max, const char* display_format = "%.3f", float power = 1.0f);
	IMGUI_API bool          VSliderInt(const char* label, const ImVec2& size, int* v, int v_min, int v_max, const char* display_format = "%.0f");

	// Widgets: Color Editor/Picker (tip: the ColorEdit* functions have a little colored preview square that can be left-clicked to open a picker, and right-clicked to open an option menu.)
	// Note that a 'float v[X]' function argument is the same as 'float* v', the array syntax is just a way to document the number of elements that are expected to be accessible. You can the pass the address of a first float element out of a contiguous structure, e.g. &myvector.x
	IMGUI_API bool          ColorEdit3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
	IMGUI_API bool          ColorEdit4(const char* label, float col[4], ImGuiColorEditFlags flags = 0);
	IMGUI_API bool          ColorPicker3(const char* label, float col[3], ImGuiColorEditFlags flags = 0);
	IMGUI_API bool          ColorPicker4(const char* label, float col[4], ImGuiColorEditFlags flags = 0, const float* ref_col = NULL);
	IMGUI_API bool          ColorButton(const char* desc_id, const ImVec4& col, ImGuiColorEditFlags flags = 0, ImVec2 size = ImVec2(0, 0));  // display a colored square/button, hover for details, return true when pressed.
	IMGUI_API void          SetColorEditOptions(ImGuiColorEditFlags flags);                     // initialize current options (generally on application startup) if you want to select a default format, picker type, etc. User will be able to change many settings, unless you pass the _NoOptions flag to your calls.

																								// Widgets: Trees
	IMGUI_API bool          TreeNode(const char* label);                                        // if returning 'true' the node is open and the tree id is pushed into the id stack. user is responsible for calling TreePop().
	IMGUI_API bool          TreeNode(const char* str_id, const char* fmt, ...) IM_FMTARGS(2);   // read the FAQ about why and how to use ID. to align arbitrary text at the same level as a TreeNode() you can use Bullet().
	IMGUI_API bool          TreeNode(const void* ptr_id, const char* fmt, ...) IM_FMTARGS(2);   // "
	IMGUI_API bool          TreeNodeV(const char* str_id, const char* fmt, va_list args) IM_FMTLIST(2);
	IMGUI_API bool          TreeNodeV(const void* ptr_id, const char* fmt, va_list args) IM_FMTLIST(2);
	IMGUI_API bool          TreeNodeEx(const char* label, ImGuiTreeNodeFlags flags = 0);
	IMGUI_API bool          TreeNodeEx(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);
	IMGUI_API bool          TreeNodeEx(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, ...) IM_FMTARGS(3);
	IMGUI_API bool          TreeNodeExV(const char* str_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);
	IMGUI_API bool          TreeNodeExV(const void* ptr_id, ImGuiTreeNodeFlags flags, const char* fmt, va_list args) IM_FMTLIST(3);
	IMGUI_API void          TreePush(const char* str_id);                                       // ~ Indent()+PushId(). Already called by TreeNode() when returning true, but you can call Push/Pop yourself for layout purpose
	IMGUI_API void          TreePush(const void* ptr_id = NULL);                                // "
	IMGUI_API void          TreePop();                                                          // ~ Unindent()+PopId()
	IMGUI_API void          TreeAdvanceToLabelPos();                                            // advance cursor x position by GetTreeNodeToLabelSpacing()
	IMGUI_API float         GetTreeNodeToLabelSpacing();                                        // horizontal distance preceding label when using TreeNode*() or Bullet() == (g.FontSize + style.FramePadding.x*2) for a regular unframed TreeNode
	IMGUI_API void          SetNextTreeNodeOpen(bool is_open, ImGuiCond cond = 0);              // set next TreeNode/CollapsingHeader open state.
	IMGUI_API bool          CollapsingHeader(const char* label, ImGuiTreeNodeFlags flags = 0);  // if returning 'true' the header is open. doesn't indent nor push on ID stack. user doesn't have to call TreePop().
	IMGUI_API bool          CollapsingHeader(const char* label, bool* p_open, ImGuiTreeNodeFlags flags = 0); // when 'p_open' isn't NULL, display an additional small close button on upper right of the header

																											 // Widgets: Selectable / Lists
	IMGUI_API bool          Selectable(const char* label, bool selected = false, ImGuiSelectableFlags flags = 0, const ImVec2 & size = ImVec2(0, 0));  // "bool selected" carry the selection state (read-only). Selectable() is clicked is returns true so you can modify your selection state. size.x==0.0: use remaining width, size.x>0.0: specify width. size.y==0.0: use label height, size.y>0.0: specify height
	IMGUI_API bool          Selectable(const char* label, bool* p_selected, ImGuiSelectableFlags flags = 0, const ImVec2 & size = ImVec2(0, 0));       // "bool* p_selected" point to the selection state (read-write), as a convenient helper.
	IMGUI_API bool          ListBox(const char* label, int* current_item, const char* const items[], int items_count, int height_in_items = -1);
	IMGUI_API bool          ListBox(const char* label, int* current_item, bool(*items_getter)(void* data, int idx, const char** out_text), void* data, int items_count, int height_in_items = -1);
	IMGUI_API bool          ListBoxHeader(const char* label, const ImVec2& size = ImVec2(0, 0)); // use if you want to reimplement ListBox() will custom data or interactions. make sure to call ListBoxFooter() afterwards.
	IMGUI_API bool          ListBoxHeader(const char* label, int items_count, int height_in_items = -1); // "
	IMGUI_API void          ListBoxFooter();                                                    // terminate the scrolling region

																								// Widgets: Value() Helpers. Output single value in "name: value" format (tip: freely declare more in your code to handle your types. you can add functions to the ImGui namespace)
	IMGUI_API void          Value(const char* prefix, bool b);
	IMGUI_API void          Value(const char* prefix, int v);
	IMGUI_API void          Value(const char* prefix, unsigned int v);
	IMGUI_API void          Value(const char* prefix, float v, const char* float_format = NULL);

	// Tooltips
	IMGUI_API void          SetTooltip(const char* fmt, ...) IM_FMTARGS(1);                     // set text tooltip under mouse-cursor, typically use with ImGui::IsItemHovered(). overidde any previous call to SetTooltip().
	IMGUI_API void          SetTooltipV(const char* fmt, va_list args) IM_FMTLIST(1);
	IMGUI_API void          BeginTooltip();                                                     // begin/append a tooltip window. to create full-featured tooltip (with any kind of contents).
	IMGUI_API void          EndTooltip();

	// Menus
	IMGUI_API bool          BeginMainMenuBar();                                                 // create and append to a full screen menu-bar.
	IMGUI_API void          EndMainMenuBar();                                                   // only call EndMainMenuBar() if BeginMainMenuBar() returns true!
	IMGUI_API bool          BeginMenuBar();                                                     // append to menu-bar of current window (requires ImGuiWindowFlags_MenuBar flag set on parent window).
	IMGUI_API void          EndMenuBar();                                                       // only call EndMenuBar() if BeginMenuBar() returns true!
	IMGUI_API bool          BeginMenu(const char* label, bool enabled = true);                  // create a sub-menu entry. only call EndMenu() if this returns true!
	IMGUI_API void          EndMenu();                                                          // only call EndMenu() if BeginMenu() returns true!
	IMGUI_API bool          MenuItem(const char* label, const char* shortcut = NULL, bool selected = false, bool enabled = true, ImVec2 size = ImVec2(0.f, 0.f));  // return true when activated. shortcuts are displayed for convenience but not processed by ImGui at the moment
	IMGUI_API bool          MenuItem(const char* label, const char* shortcut, bool* p_selected, bool enabled = true, ImVec2 size = ImVec2(0.f, 0.f));              // return true when activated + toggle (*p_selected) if p_selected != NULL

																																   // Popups
	IMGUI_API void          OpenPopup(const char* str_id);                                      // call to mark popup as open (don't call every frame!). popups are closed when user click outside, or if CloseCurrentPopup() is called within a BeginPopup()/EndPopup() block. By default, Selectable()/MenuItem() are calling CloseCurrentPopup(). Popup identifiers are relative to the current ID-stack (so OpenPopup and BeginPopup needs to be at the same level).
	IMGUI_API bool          BeginPopup(const char* str_id, ImGuiWindowFlags flags = 0);                                             // return true if the popup is open, and you can start outputting to it. only call EndPopup() if BeginPopup() returns true!
	IMGUI_API bool          BeginPopupContextItem(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked on last item. if you can pass a NULL str_id only if the previous item had an id. If you want to use that on a non-interactive item such as Text() you need to pass in an explicit ID here. read comments in .cpp!
	IMGUI_API bool          BeginPopupContextWindow(const char* str_id = NULL, int mouse_button = 1, bool also_over_items = true);  // helper to open and begin popup when clicked on current window.
	IMGUI_API bool          BeginPopupContextVoid(const char* str_id = NULL, int mouse_button = 1);                                 // helper to open and begin popup when clicked in void (where there are no imgui windows).
	IMGUI_API bool          BeginPopupModal(const char* name, bool* p_open = NULL, ImGuiWindowFlags flags = 0);                     // modal dialog (regular window with title bar, block interactions behind the modal window, can't close the modal window by clicking outside)
	IMGUI_API void          EndPopup();                                                                                             // only call EndPopup() if BeginPopupXXX() returns true!
	IMGUI_API bool          OpenPopupOnItemClick(const char* str_id = NULL, int mouse_button = 1);                                  // helper to open popup when clicked on last item. return true when just opened.
	IMGUI_API bool          IsPopupOpen(const char* str_id);                                    // return true if the popup is open
	IMGUI_API void          CloseCurrentPopup();                                                // close the popup we have begin-ed into. clicking on a MenuItem or Selectable automatically close the current popup.

																								// Columns
																								// You can also use SameLine(pos_x) for simplified columns. The columns API is still work-in-progress and rather lacking.
	IMGUI_API void          Columns(int count = 1, const char* id = NULL, bool border = true);
	IMGUI_API void          NextColumn();                                                       // next column, defaults to current row or next row if the current row is finished
	IMGUI_API int           GetColumnIndex();                                                   // get current column index
	IMGUI_API float         GetColumnWidth(int column_index = -1);                              // get column width (in pixels). pass -1 to use current column
	IMGUI_API void          SetColumnWidth(int column_index, float width);                      // set column width (in pixels). pass -1 to use current column
	IMGUI_API float         GetColumnOffset(int column_index = -1);                             // get position of column line (in pixels, from the left side of the contents region). pass -1 to use current column, otherwise 0..GetColumnsCount() inclusive. column 0 is typically 0.0f
	IMGUI_API void          SetColumnOffset(int column_index, float offset_x);                  // set position of column line (in pixels, from the left side of the contents region). pass -1 to use current column
	IMGUI_API int           GetColumnsCount();

	// Logging/Capture: all text output from interface is captured to tty/file/clipboard. By default, tree nodes are automatically opened during logging.
	IMGUI_API void          LogToTTY(int max_depth = -1);                                       // start logging to tty
	IMGUI_API void          LogToFile(int max_depth = -1, const char* filename = NULL);         // start logging to file
	IMGUI_API void          LogToClipboard(int max_depth = -1);                                 // start logging to OS clipboard
	IMGUI_API void          LogFinish();                                                        // stop logging (close file, etc.)
	IMGUI_API void          LogButtons();                                                       // helper to display buttons for logging to tty/file/clipboard
	IMGUI_API void          LogText(const char* fmt, ...) IM_FMTARGS(1);                        // pass text data straight to log (without being displayed)

																								// Drag and Drop
																								// [BETA API] Missing Demo code. API may evolve.
	IMGUI_API bool          BeginDragDropSource(ImGuiDragDropFlags flags = 0);                                      // call when the current item is active. If this return true, you can call SetDragDropPayload() + EndDragDropSource()
	IMGUI_API bool          SetDragDropPayload(const char* type, const void* data, size_t size, ImGuiCond cond = 0);// type is a user defined string of maximum 32 characters. Strings starting with '_' are reserved for dear imgui internal types. Data is copied and held by imgui.
	IMGUI_API void          EndDragDropSource();                                                                    // only call EndDragDropSource() if BeginDragDropSource() returns true!
	IMGUI_API bool          BeginDragDropTarget();                                                                  // call after submitting an item that may receive an item. If this returns true, you can call AcceptDragDropPayload() + EndDragDropTarget()
	IMGUI_API const ImGuiPayload* AcceptDragDropPayload(const char* type, ImGuiDragDropFlags flags = 0);            // accept contents of a given type. If ImGuiDragDropFlags_AcceptBeforeDelivery is set you can peek into the payload before the mouse button is released.
	IMGUI_API void          EndDragDropTarget();                                                                    // only call EndDragDropTarget() if BeginDragDropTarget() returns true!

																													// Clipping
	IMGUI_API void          PushClipRect(const ImVec2& clip_rect_min, const ImVec2& clip_rect_max, bool intersect_with_current_clip_rect);
	IMGUI_API void          PopClipRect();

	// Focus, Activation
	// (Prefer using "SetItemDefaultFocus()" over "if (IsWindowAppearing()) SetScrollHere()" when applicable, to make your code more forward compatible when navigation branch is merged)
	IMGUI_API void          SetItemDefaultFocus();                                              // make last item the default focused item of a window. Please use instead of "if (IsWindowAppearing()) SetScrollHere()" to signify "default item".
	IMGUI_API void          SetKeyboardFocusHere(int offset = 0);                               // focus keyboard on the next widget. Use positive 'offset' to access sub components of a multiple component widget. Use -1 to access previous widget.

																								// Utilities
	IMGUI_API bool          IsItemHovered(ImGuiHoveredFlags flags = 0);                         // is the last item hovered? (and usable, aka not blocked by a popup, etc.). See ImGuiHoveredFlags for more options.
	IMGUI_API bool          IsItemActive();                                                     // is the last item active? (e.g. button being held, text field being edited- items that don't interact will always return false)
	IMGUI_API bool          IsItemFocused();                                                    // is the last item focused for keyboard/gamepad navigation?
	IMGUI_API bool          IsItemClicked(int mouse_button = 0);                                // is the last item clicked? (e.g. button/node just clicked on)
	IMGUI_API bool          IsItemVisible();                                                    // is the last item visible? (aka not out of sight due to clipping/scrolling.)
	IMGUI_API bool          IsAnyItemHovered();
	IMGUI_API bool          IsAnyItemActive();
	IMGUI_API bool          IsAnyItemFocused();
	IMGUI_API ImVec2        GetItemRectMin();                                                   // get bounding rectangle of last item, in screen space
	IMGUI_API ImVec2        GetItemRectMax();                                                   // "
	IMGUI_API ImVec2        GetItemRectSize();                                                  // get size of last item, in screen space
	IMGUI_API void          SetItemAllowOverlap();                                              // allow last item to be overlapped by a subsequent item. sometimes useful with invisible buttons, selectables, etc. to catch unused area.
	IMGUI_API bool          IsRectVisible(const ImVec2& size);                                  // test if rectangle (of given size, starting from cursor position) is visible / not clipped.
	IMGUI_API bool          IsRectVisible(const ImVec2& rect_min, const ImVec2& rect_max);      // test if rectangle (in screen space) is visible / not clipped. to perform coarse clipping on user's side.
	IMGUI_API float         GetTime();
	IMGUI_API int           GetFrameCount();
	IMGUI_API ImDrawList* GetOverlayDrawList();                                               // this draw list will be the last rendered one, useful to quickly draw overlays shapes/text
	IMGUI_API ImDrawListSharedData* GetDrawListSharedData();                                    // you may use this when creating your own ImDrawList instances
	IMGUI_API const char* GetStyleColorName(ImGuiCol idx);
	IMGUI_API void          SetStateStorage(ImGuiStorage* storage);                             // replace current window storage with our own (if you want to manipulate it yourself, typically clear subsection of it)
	IMGUI_API ImGuiStorage* GetStateStorage();
	IMGUI_API ImVec2        CalcTextSize(const char* text, const char* text_end = NULL, bool hide_text_after_double_hash = false, float wrap_width = -1.0f);
	IMGUI_API void          CalcListClipping(int items_count, float items_height, int* out_items_display_start, int* out_items_display_end);    // calculate coarse clipping for large list of evenly sized items. Prefer using the ImGuiListClipper higher-level helper if you can.

	IMGUI_API bool          BeginChildFrame(ImGuiID id, const ImVec2& size, ImGuiWindowFlags flags = 0); // helper to create a child window / scrolling region that looks like a normal widget frame
	IMGUI_API void          EndChildFrame();                                                    // always call EndChildFrame() regardless of BeginChildFrame() return values (which indicates a collapsed/clipped window)

	IMGUI_API ImVec4        ColorConvertU32ToFloat4(ImU32 in);
	IMGUI_API ImU32         ColorConvertFloat4ToU32(const ImVec4& in);
	IMGUI_API void          ColorConvertRGBtoHSV(float r, float g, float b, float& out_h, float& out_s, float& out_v);
	IMGUI_API void          ColorConvertHSVtoRGB(float h, float s, float v, float& out_r, float& out_g, float& out_b);

	// Inputs
	IMGUI_API int           GetKeyIndex(ImGuiKey imgui_key);                                    // map ImGuiKey_* values into user's key index. == io.KeyMap[key]
	IMGUI_API bool          IsKeyDown(int user_key_index);                                      // is key being held. == io.KeysDown[user_key_index]. note that imgui doesn't know the semantic of each entry of io.KeyDown[]. Use your own indices/enums according to how your backend/engine stored them into KeyDown[]!
	IMGUI_API bool          IsKeyPressed(int user_key_index, bool repeat = true);               // was key pressed (went from !Down to Down). if repeat=true, uses io.KeyRepeatDelay / KeyRepeatRate
	IMGUI_API bool          IsKeyReleased(int user_key_index);                                  // was key released (went from Down to !Down)..
	IMGUI_API int           GetKeyPressedAmount(int key_index, float repeat_delay, float rate); // uses provided repeat rate/delay. return a count, most often 0 or 1 but might be >1 if RepeatRate is small enough that DeltaTime > RepeatRate
	IMGUI_API bool          IsMouseDown(int button);                                            // is mouse button held
	IMGUI_API bool          IsAnyMouseDown();                                                   // is any mouse button held
	IMGUI_API bool          IsMouseClicked(int button, bool repeat = false);                    // did mouse button clicked (went from !Down to Down)
	IMGUI_API bool          IsMouseDoubleClicked(int button);                                   // did mouse button double-clicked. a double-click returns false in IsMouseClicked(). uses io.MouseDoubleClickTime.
	IMGUI_API bool          IsMouseReleased(int button);                                        // did mouse button released (went from Down to !Down)
	IMGUI_API bool          IsMouseDragging(int button = 0, float lock_threshold = -1.0f);      // is mouse dragging. if lock_threshold < -1.0f uses io.MouseDraggingThreshold
	IMGUI_API bool          IsMouseHoveringRect(const ImVec2& r_min, const ImVec2& r_max, bool clip = true);  // is mouse hovering given bounding rect (in screen space). clipped by current clipping settings. disregarding of consideration of focus/window ordering/blocked by a popup.
	IMGUI_API bool          IsMousePosValid(const ImVec2* mouse_pos = NULL);                    //
	IMGUI_API ImVec2        GetMousePos();                                                      // shortcut to ImGui::GetIO().MousePos provided by user, to be consistent with other calls
	IMGUI_API ImVec2        GetMousePosOnOpeningCurrentPopup();                                 // retrieve backup of mouse position at the time of opening popup we have BeginPopup() into
	IMGUI_API ImVec2        GetMouseDragDelta(int button = 0, float lock_threshold = -1.0f);    // dragging amount since clicking. if lock_threshold < -1.0f uses io.MouseDraggingThreshold
	IMGUI_API void          ResetMouseDragDelta(int button = 0);                                //
	IMGUI_API ImGuiMouseCursor GetMouseCursor();                                                // get desired cursor type, reset in ImGui::NewFrame(), this is updated during the frame. valid before Render(). If you use software rendering by setting io.MouseDrawCursor ImGui will render those for you
	IMGUI_API void          SetMouseCursor(ImGuiMouseCursor type);                              // set desired cursor type
	IMGUI_API void          CaptureKeyboardFromApp(bool capture = true);                        // manually override io.WantCaptureKeyboard flag next frame (said flag is entirely left for your application to handle). e.g. force capture keyboard when your widget is being hovered.
	IMGUI_API void          CaptureMouseFromApp(bool capture = true);                           // manually override io.WantCaptureMouse flag next frame (said flag is entirely left for your application to handle).

																								// Clipboard Utilities (also see the LogToClipboard() function to capture or output text data to the clipboard)
	IMGUI_API const char* GetClipboardText();
	IMGUI_API void          SetClipboardText(const char* text);

	// Memory Utilities
	// All those functions are not reliant on the current context.
	// If you reload the contents of imgui.cpp at runtime, you may need to call SetCurrentContext() + SetAllocatorFunctions() again.
	IMGUI_API void          SetAllocatorFunctions(void* (*alloc_func)(size_t sz, void* user_data), void(*free_func)(void* ptr, void* user_data), void* user_data = NULL);
	IMGUI_API void* MemAlloc(size_t size);
	IMGUI_API void          MemFree(void* ptr);
} // namespace ImGui

  // Flags for ImGui::Begin()
enum ImGuiWindowFlags_
{
	ImGuiWindowFlags_NoTitleBar = 1 << 0,   // Disable title-bar
	ImGuiWindowFlags_NoResize = 1 << 1,   // Disable user resizing with the lower-right grip
	ImGuiWindowFlags_NoMove = 1 << 2,   // Disable user moving the window
	ImGuiWindowFlags_NoScrollbar = 1 << 3,   // Disable scrollbars (window can still scroll with mouse or programatically)
	ImGuiWindowFlags_NoScrollWithMouse = 1 << 4,   // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set.
	ImGuiWindowFlags_NoCollapse = 1 << 5,   // Disable user collapsing window by double-clicking on it
	ImGuiWindowFlags_AlwaysAutoResize = 1 << 6,   // Resize every window to its content every frame
												  //ImGuiWindowFlags_ShowBorders          = 1 << 7,   // Show borders around windows and items (OBSOLETE! Use e.g. style.FrameBorderSize=1.0f to enable borders).
												  ImGuiWindowFlags_NoSavedSettings = 1 << 8,   // Never load/save settings in .ini file
												  ImGuiWindowFlags_NoInputs = 1 << 9,   // Disable catching mouse or keyboard inputs, hovering test with pass through.
												  ImGuiWindowFlags_MenuBar = 1 << 10,  // Has a menu-bar
												  ImGuiWindowFlags_HorizontalScrollbar = 1 << 11,  // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the "Horizontal Scrolling" section.
												  ImGuiWindowFlags_NoFocusOnAppearing = 1 << 12,  // Disable taking focus when transitioning from hidden to visible state
												  ImGuiWindowFlags_NoBringToFrontOnFocus = 1 << 13,  // Disable bringing window to front when taking focus (e.g. clicking on it or programatically giving it focus)
												  ImGuiWindowFlags_AlwaysVerticalScrollbar = 1 << 14,  // Always show vertical scrollbar (even if ContentSize.y < Size.y)
												  ImGuiWindowFlags_AlwaysHorizontalScrollbar = 1 << 15,  // Always show horizontal scrollbar (even if ContentSize.x < Size.x)
												  ImGuiWindowFlags_AlwaysUseWindowPadding = 1 << 16,  // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient)
												  ImGuiWindowFlags_ResizeFromAnySide = 1 << 17,  // [BETA] Enable resize from any corners and borders. Your back-end needs to honor the different values of io.MouseCursor set by imgui.
												  ImGuiWindowFlags_NoNavInputs = 1 << 18,  // No gamepad/keyboard navigation within the window
												  ImGuiWindowFlags_NoNavFocus = 1 << 19,  // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB)
												  ImGuiWindowFlags_NoNav = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus,

												  // [Internal]
												  ImGuiWindowFlags_NavFlattened = 1 << 23,  // [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!)
												  ImGuiWindowFlags_ChildWindow = 1 << 24,  // Don't use! For internal use by BeginChild()
												  ImGuiWindowFlags_Tooltip = 1 << 25,  // Don't use! For internal use by BeginTooltip()
												  ImGuiWindowFlags_Popup = 1 << 26,  // Don't use! For internal use by BeginPopup()
												  ImGuiWindowFlags_Modal = 1 << 27,  // Don't use! For internal use by BeginPopupModal()
												  ImGuiWindowFlags_ChildMenu = 1 << 28   // Don't use! For internal use by BeginMenu()
};

// Flags for ImGui::InputText()
enum ImGuiInputTextFlags_
{
	ImGuiInputTextFlags_CharsDecimal = 1 << 0,   // Allow 0123456789.+-*/
	ImGuiInputTextFlags_CharsHexadecimal = 1 << 1,   // Allow 0123456789ABCDEFabcdef
	ImGuiInputTextFlags_CharsUppercase = 1 << 2,   // Turn a..z into A..Z
	ImGuiInputTextFlags_CharsNoBlank = 1 << 3,   // Filter out spaces, tabs
	ImGuiInputTextFlags_AutoSelectAll = 1 << 4,   // Select entire text when first taking mouse focus
	ImGuiInputTextFlags_EnterReturnsTrue = 1 << 5,   // Return 'true' when Enter is pressed (as opposed to when the value was modified)
	ImGuiInputTextFlags_CallbackCompletion = 1 << 6,   // Call user function on pressing TAB (for completion handling)
	ImGuiInputTextFlags_CallbackHistory = 1 << 7,   // Call user function on pressing Up/Down arrows (for history handling)
	ImGuiInputTextFlags_CallbackAlways = 1 << 8,   // Call user function every time. User code may query cursor position, modify text buffer.
	ImGuiInputTextFlags_CallbackCharFilter = 1 << 9,   // Call user function to filter character. Modify data->EventChar to replace/filter input, or return 1 to discard character.
	ImGuiInputTextFlags_AllowTabInput = 1 << 10,  // Pressing TAB input a '\t' character into the text field
	ImGuiInputTextFlags_CtrlEnterForNewLine = 1 << 11,  // In multi-line mode, unfocus with Enter, add new line with Ctrl+Enter (default is opposite: unfocus with Ctrl+Enter, add line with Enter).
	ImGuiInputTextFlags_NoHorizontalScroll = 1 << 12,  // Disable following the cursor horizontally
	ImGuiInputTextFlags_AlwaysInsertMode = 1 << 13,  // Insert mode
	ImGuiInputTextFlags_ReadOnly = 1 << 14,  // Read-only mode
	ImGuiInputTextFlags_Password = 1 << 15,  // Password mode, display all characters as '*'
	ImGuiInputTextFlags_NoUndoRedo = 1 << 16,  // Disable undo/redo. Note that input text owns the text data while active, if you want to provide your own undo/redo stack you need e.g. to call ClearActiveID().
	ImGuiInputTextFlags_CharsScientific = 1 << 17,  // Allow 0123456789.+-*/eE (Scientific notation input)
													// [Internal]
													ImGuiInputTextFlags_Multiline = 1 << 20   // For internal use by InputTextMultiline()
};

// Flags for ImGui::TreeNodeEx(), ImGui::CollapsingHeader*()
enum ImGuiTreeNodeFlags_
{
	ImGuiTreeNodeFlags_Selected = 1 << 0,   // Draw as selected
	ImGuiTreeNodeFlags_Framed = 1 << 1,   // Full colored frame (e.g. for CollapsingHeader)
	ImGuiTreeNodeFlags_AllowItemOverlap = 1 << 2,   // Hit testing to allow subsequent widgets to overlap this one
	ImGuiTreeNodeFlags_NoTreePushOnOpen = 1 << 3,   // Don't do a TreePush() when open (e.g. for CollapsingHeader) = no extra indent nor pushing on ID stack
	ImGuiTreeNodeFlags_NoAutoOpenOnLog = 1 << 4,   // Don't automatically and temporarily open node when Logging is active (by default logging will automatically open tree nodes)
	ImGuiTreeNodeFlags_DefaultOpen = 1 << 5,   // Default node to be open
	ImGuiTreeNodeFlags_OpenOnDoubleClick = 1 << 6,   // Need double-click to open node
	ImGuiTreeNodeFlags_OpenOnArrow = 1 << 7,   // Only open when clicking on the arrow part. If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set, single-click arrow or double-click all box to open.
	ImGuiTreeNodeFlags_Leaf = 1 << 8,   // No collapsing, no arrow (use as a convenience for leaf nodes).
	ImGuiTreeNodeFlags_Bullet = 1 << 9,   // Display a bullet instead of arrow
	ImGuiTreeNodeFlags_FramePadding = 1 << 10,  // Use FramePadding (even for an unframed text node) to vertically align text baseline to regular widget height. Equivalent to calling AlignTextToFramePadding().
												//ImGuITreeNodeFlags_SpanAllAvailWidth  = 1 << 11,  // FIXME: TODO: Extend hit box horizontally even if not framed
												//ImGuiTreeNodeFlags_NoScrollOnOpen     = 1 << 12,  // FIXME: TODO: Disable automatic scroll on TreePop() if node got just open and contents is not visible
												ImGuiTreeNodeFlags_NavLeftJumpsBackHere = 1 << 13,  // (WIP) Nav: left direction may move to this TreeNode() from any of its child (items submitted between TreeNode and TreePop)
												ImGuiTreeNodeFlags_CollapsingHeader = ImGuiTreeNodeFlags_Framed | ImGuiTreeNodeFlags_NoAutoOpenOnLog

												// Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	, ImGuiTreeNodeFlags_AllowOverlapMode = ImGuiTreeNodeFlags_AllowItemOverlap
#endif
};

// Flags for ImGui::Selectable()
enum ImGuiSelectableFlags_
{
	ImGuiSelectableFlags_DontClosePopups = 1 << 0,   // Clicking this don't close parent popup window
	ImGuiSelectableFlags_SpanAllColumns = 1 << 1,   // Selectable frame can span all columns (text will still fit in current column)
	ImGuiSelectableFlags_AllowDoubleClick = 1 << 2,    // Generate press events on double clicks too
	ImGuiSelectableFlags_AlignCenter = 1 << 3    // Text at center
};

// Flags for ImGui::BeginCombo()
enum ImGuiComboFlags_
{
	ImGuiComboFlags_PopupAlignLeft = 1 << 0,   // Align the popup toward the left by default
	ImGuiComboFlags_HeightSmall = 1 << 1,   // Max ~4 items visible. Tip: If you want your combo popup to be a specific size you can use SetNextWindowSizeConstraints() prior to calling BeginCombo()
	ImGuiComboFlags_HeightRegular = 1 << 2,   // Max ~8 items visible (default)
	ImGuiComboFlags_HeightLarge = 1 << 3,   // Max ~20 items visible
	ImGuiComboFlags_HeightLargest = 1 << 4,   // As many fitting items as possible
	ImGuiComboFlags_NoArrowButton = 1 << 5,   // Display on the preview box without the square arrow button
	ImGuiComboFlags_NoPreview = 1 << 6,   // Display only a square arrow button
	ImGuiComboFlags_HeightMask_ = ImGuiComboFlags_HeightSmall | ImGuiComboFlags_HeightRegular | ImGuiComboFlags_HeightLarge | ImGuiComboFlags_HeightLargest
};

// Flags for ImGui::IsWindowFocused()
enum ImGuiFocusedFlags_
{
	ImGuiFocusedFlags_ChildWindows = 1 << 0,   // IsWindowFocused(): Return true if any children of the window is focused
	ImGuiFocusedFlags_RootWindow = 1 << 1,   // IsWindowFocused(): Test from root window (top most parent of the current hierarchy)
	ImGuiFocusedFlags_AnyWindow = 1 << 2,   // IsWindowFocused(): Return true if any window is focused
	ImGuiFocusedFlags_RootAndChildWindows = ImGuiFocusedFlags_RootWindow | ImGuiFocusedFlags_ChildWindows
};

// Flags for ImGui::IsItemHovered(), ImGui::IsWindowHovered()
// Note: If you are trying to check whether your mouse should be dispatched to imgui or to your app, you should use the 'io.WantCaptureMouse' boolean for that. Please read the FAQ!
enum ImGuiHoveredFlags_
{
	ImGuiHoveredFlags_Default = 0,        // Return true if directly over the item/window, not obstructed by another window, not obstructed by an active popup or modal blocking inputs under them.
	ImGuiHoveredFlags_ChildWindows = 1 << 0,   // IsWindowHovered() only: Return true if any children of the window is hovered
	ImGuiHoveredFlags_RootWindow = 1 << 1,   // IsWindowHovered() only: Test from root window (top most parent of the current hierarchy)
	ImGuiHoveredFlags_AnyWindow = 1 << 2,   // IsWindowHovered() only: Return true if any window is hovered
	ImGuiHoveredFlags_AllowWhenBlockedByPopup = 1 << 3,   // Return true even if a popup window is normally blocking access to this item/window
														  //ImGuiHoveredFlags_AllowWhenBlockedByModal     = 1 << 4,   // Return true even if a modal popup window is normally blocking access to this item/window. FIXME-TODO: Unavailable yet.
														  ImGuiHoveredFlags_AllowWhenBlockedByActiveItem = 1 << 5,   // Return true even if an active item is blocking access to this item/window. Useful for Drag and Drop patterns.
														  ImGuiHoveredFlags_AllowWhenOverlapped = 1 << 6,   // Return true even if the position is overlapped by another window
														  ImGuiHoveredFlags_RectOnly = ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem | ImGuiHoveredFlags_AllowWhenOverlapped,
														  ImGuiHoveredFlags_RootAndChildWindows = ImGuiHoveredFlags_RootWindow | ImGuiHoveredFlags_ChildWindows
};

// Flags for ImGui::BeginDragDropSource(), ImGui::AcceptDragDropPayload()
enum ImGuiDragDropFlags_
{
	// BeginDragDropSource() flags
	ImGuiDragDropFlags_SourceNoPreviewTooltip = 1 << 0,   // By default, a successful call to BeginDragDropSource opens a tooltip so you can display a preview or description of the source contents. This flag disable this behavior.
	ImGuiDragDropFlags_SourceNoDisableHover = 1 << 1,   // By default, when dragging we clear data so that IsItemHovered() will return true, to avoid subsequent user code submitting tooltips. This flag disable this behavior so you can still call IsItemHovered() on the source item.
	ImGuiDragDropFlags_SourceNoHoldToOpenOthers = 1 << 2,   // Disable the behavior that allows to open tree nodes and collapsing header by holding over them while dragging a source item.
	ImGuiDragDropFlags_SourceAllowNullID = 1 << 3,   // Allow items such as Text(), Image() that have no unique identifier to be used as drag source, by manufacturing a temporary identifier based on their window-relative position. This is extremely unusual within the dear imgui ecosystem and so we made it explicit.
	ImGuiDragDropFlags_SourceExtern = 1 << 4,   // External source (from outside of imgui), won't attempt to read current item/window info. Will always return true. Only one Extern source can be active simultaneously.
												// AcceptDragDropPayload() flags
												ImGuiDragDropFlags_AcceptBeforeDelivery = 1 << 10,  // AcceptDragDropPayload() will returns true even before the mouse button is released. You can then call IsDelivery() to test if the payload needs to be delivered.
												ImGuiDragDropFlags_AcceptNoDrawDefaultRect = 1 << 11,  // Do not draw the default highlight rectangle when hovering over target.
												ImGuiDragDropFlags_AcceptPeekOnly = ImGuiDragDropFlags_AcceptBeforeDelivery | ImGuiDragDropFlags_AcceptNoDrawDefaultRect  // For peeking ahead and inspecting the payload before delivery.
};

// Standard Drag and Drop payload types. You can define you own payload types using 12-characters long strings. Types starting with '_' are defined by Dear ImGui.
#define IMGUI_PAYLOAD_TYPE_COLOR_3F     "_COL3F"    // float[3]: Standard type for colors, without alpha. User code may use this type.
#define IMGUI_PAYLOAD_TYPE_COLOR_4F     "_COL4F"    // float[4]: Standard type for colors. User code may use this type.

// A cardinal direction
enum ImGuiDir_
{
	ImGuiDir_None = -1,
	ImGuiDir_Left = 0,
	ImGuiDir_Right = 1,
	ImGuiDir_Up = 2,
	ImGuiDir_Down = 3,
	ImGuiDir_COUNT
};

// User fill ImGuiIO.KeyMap[] array with indices into the ImGuiIO.KeysDown[512] array
enum ImGuiKey_
{
	ImGuiKey_Tab,
	ImGuiKey_LeftArrow,
	ImGuiKey_RightArrow,
	ImGuiKey_UpArrow,
	ImGuiKey_DownArrow,
	ImGuiKey_PageUp,
	ImGuiKey_PageDown,
	ImGuiKey_Home,
	ImGuiKey_End,
	ImGuiKey_Insert,
	ImGuiKey_Delete,
	ImGuiKey_Backspace,
	ImGuiKey_Space,
	ImGuiKey_Enter,
	ImGuiKey_Escape,
	ImGuiKey_A,         // for text edit CTRL+A: select all
	ImGuiKey_C,         // for text edit CTRL+C: copy
	ImGuiKey_V,         // for text edit CTRL+V: paste
	ImGuiKey_X,         // for text edit CTRL+X: cut
	ImGuiKey_Y,         // for text edit CTRL+Y: redo
	ImGuiKey_Z,         // for text edit CTRL+Z: undo
	ImGuiKey_COUNT
};

// [BETA] Gamepad/Keyboard directional navigation
// Keyboard: Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard to enable. NewFrame() will automatically fill io.NavInputs[] based on your io.KeyDown[] + io.KeyMap[] arrays.
// Gamepad:  Set io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad to enable. Back-end: set ImGuiBackendFlags_HasGamepad and fill the io.NavInputs[] fields before calling NewFrame(). Note that io.NavInputs[] is cleared by EndFrame().
// Read instructions in imgui.cpp for more details. Download PNG/PSD at goo.gl/9LgVZW.
enum ImGuiNavInput_
{
	// Gamepad Mapping
	ImGuiNavInput_Activate,      // activate / open / toggle / tweak value       // e.g. Cross  (PS4), A (Xbox), A (Switch), Space (Keyboard)
	ImGuiNavInput_Cancel,        // cancel / close / exit                        // e.g. Circle (PS4), B (Xbox), B (Switch), Escape (Keyboard)
	ImGuiNavInput_Input,         // text input / on-screen keyboard              // e.g. Triang.(PS4), Y (Xbox), X (Switch), Return (Keyboard)
	ImGuiNavInput_Menu,          // tap: toggle menu / hold: focus, move, resize // e.g. Square (PS4), X (Xbox), Y (Switch), Alt (Keyboard)
	ImGuiNavInput_DpadLeft,      // move / tweak / resize window (w/ PadMenu)    // e.g. D-pad Left/Right/Up/Down (Gamepads), Arrow keys (Keyboard)
	ImGuiNavInput_DpadRight,     //
	ImGuiNavInput_DpadUp,        //
	ImGuiNavInput_DpadDown,      //
	ImGuiNavInput_LStickLeft,    // scroll / move window (w/ PadMenu)            // e.g. Left Analog Stick Left/Right/Up/Down
	ImGuiNavInput_LStickRight,   //
	ImGuiNavInput_LStickUp,      //
	ImGuiNavInput_LStickDown,    //
	ImGuiNavInput_FocusPrev,     // next window (w/ PadMenu)                     // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
	ImGuiNavInput_FocusNext,     // prev window (w/ PadMenu)                     // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)
	ImGuiNavInput_TweakSlow,     // slower tweaks                                // e.g. L1 or L2 (PS4), LB or LT (Xbox), L or ZL (Switch)
	ImGuiNavInput_TweakFast,     // faster tweaks                                // e.g. R1 or R2 (PS4), RB or RT (Xbox), R or ZL (Switch)

								 // [Internal] Don't use directly! This is used internally to differentiate keyboard from gamepad inputs for behaviors that require to differentiate them.
								 // Keyboard behavior that have no corresponding gamepad mapping (e.g. CTRL+TAB) will be directly reading from io.KeyDown[] instead of io.NavInputs[].
								 ImGuiNavInput_KeyMenu_,      // toggle menu                                  // = io.KeyAlt
								 ImGuiNavInput_KeyLeft_,      // move left                                    // = Arrow keys
								 ImGuiNavInput_KeyRight_,     // move right
								 ImGuiNavInput_KeyUp_,        // move up
								 ImGuiNavInput_KeyDown_,      // move down
								 ImGuiNavInput_COUNT,
								 ImGuiNavInput_InternalStart_ = ImGuiNavInput_KeyMenu_
};

// Configuration flags stored in io.ConfigFlags. Set by user/application.
enum ImGuiConfigFlags_
{
	ImGuiConfigFlags_NavEnableKeyboard = 1 << 0,   // Master keyboard navigation enable flag. NewFrame() will automatically fill io.NavInputs[] based on io.KeyDown[].
	ImGuiConfigFlags_NavEnableGamepad = 1 << 1,   // Master gamepad navigation enable flag. This is mostly to instruct your imgui back-end to fill io.NavInputs[]. Back-end also needs to set ImGuiBackendFlags_HasGamepad.
	ImGuiConfigFlags_NavEnableSetMousePos = 1 << 2,   // Instruct navigation to move the mouse cursor. May be useful on TV/console systems where moving a virtual mouse is awkward. Will update io.MousePos and set io.WantSetMousePos=true. If enabled you MUST honor io.WantSetMousePos requests in your binding, otherwise ImGui will react as if the mouse is jumping around back and forth.
	ImGuiConfigFlags_NavNoCaptureKeyboard = 1 << 3,   // Instruct navigation to not set the io.WantCaptureKeyboard flag with io.NavActive is set.
	ImGuiConfigFlags_NoMouse = 1 << 4,   // Instruct imgui to clear mouse position/buttons in NewFrame(). This allows ignoring the mouse information back-end
	ImGuiConfigFlags_NoMouseCursorChange = 1 << 5,   // Instruct back-end to not alter mouse cursor shape and visibility.

													 // User storage (to allow your back-end/engine to communicate to code that may be shared between multiple projects. Those flags are not used by core ImGui)
													 ImGuiConfigFlags_IsSRGB = 1 << 20,  // Application is SRGB-aware.
													 ImGuiConfigFlags_IsTouchScreen = 1 << 21   // Application is using a touch screen instead of a mouse.
};

// Back-end capabilities flags stored in io.BackendFlags. Set by imgui_impl_xxx or custom back-end.
enum ImGuiBackendFlags_
{
	ImGuiBackendFlags_HasGamepad = 1 << 0,   // Back-end has a connected gamepad.
	ImGuiBackendFlags_HasMouseCursors = 1 << 1,   // Back-end can honor GetMouseCursor() values and change the OS cursor shape.
	ImGuiBackendFlags_HasSetMousePos = 1 << 2    // Back-end can honor io.WantSetMousePos and reposition the mouse (only used if ImGuiConfigFlags_NavEnableSetMousePos is set).
};

// Enumeration for PushStyleColor() / PopStyleColor()
enum ImGuiCol_
{
	ImGuiCol_Text,
	ImGuiCol_TextDisabled,
	ImGuiCol_WindowBg,              // Background of normal windows
	ImGuiCol_ChildBg,               // Background of child windows
	ImGuiCol_PopupBg,               // Background of popups, menus, tooltips windows
	ImGuiCol_Border,
	ImGuiCol_BorderShadow,
	ImGuiCol_FrameBg,               // Background of checkbox, radio button, plot, slider, text input
	ImGuiCol_FrameBgHovered,
	ImGuiCol_FrameBgActive,
	ImGuiCol_TitleBg,
	ImGuiCol_TitleBgActive,
	ImGuiCol_TitleBgCollapsed,
	ImGuiCol_MenuBarBg,
	ImGuiCol_ScrollbarBg,
	ImGuiCol_ScrollbarGrab,
	ImGuiCol_ScrollbarGrabHovered,
	ImGuiCol_ScrollbarGrabActive,
	ImGuiCol_CheckMark,
	ImGuiCol_CheckBg,
	ImGuiCol_CheckBgHovered,
	ImGuiCol_CheckBgActive,
	ImGuiCol_SliderBg,
	ImGuiCol_SliderBgActive,
	ImGuiCol_SliderBgHovered,
	ImGuiCol_SliderGrab,
	ImGuiCol_SliderGrabActive,
	ImGuiCol_Button,
	ImGuiCol_ButtonHovered,
	ImGuiCol_ButtonActive,
	ImGuiCol_ButtonOutline,
	ImGuiCol_Header,
	ImGuiCol_HeaderHovered,
	ImGuiCol_HeaderActive,
	ImGuiCol_Separator,
	ImGuiCol_SeparatorHovered,
	ImGuiCol_SeparatorActive,
	ImGuiCol_ResizeGrip,
	ImGuiCol_ResizeGripHovered,
	ImGuiCol_ResizeGripActive,
	ImGuiCol_PlotLines,
	ImGuiCol_PlotLinesHovered,
	ImGuiCol_PlotHistogram,
	ImGuiCol_PlotHistogramHovered,
	ImGuiCol_TextSelectedBg,
	ImGuiCol_ModalWindowDarkening,  // darken/colorize entire screen behind a modal window, when one is active
	ImGuiCol_DragDropTarget,
	ImGuiCol_NavHighlight,          // gamepad/keyboard: current highlighted item
	ImGuiCol_NavWindowingHighlight, // gamepad/keyboard: when holding NavMenu to focus/move/resize windows
	ImGuiCol_MenuBarText,
	ImGuiCol_MenuItemHovered,
	ImGuiCol_MenuItemActive,
	ImGuiCol_Triangle,
	ImGuiCol_ButtonText,
	ImGuiCol_TitleText,
	ImGuiCol_ListBoxItem,
	ImGuiCol_ListBoxItemActive,
	ImGuiCol_ListBoxItemHovered,
	ImGuiCol_COUNT

	// Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	, ImGuiCol_ChildWindowBg = ImGuiCol_ChildBg, ImGuiCol_Column = ImGuiCol_Separator, ImGuiCol_ColumnHovered = ImGuiCol_SeparatorHovered, ImGuiCol_ColumnActive = ImGuiCol_SeparatorActive
	//ImGuiCol_CloseButton, ImGuiCol_CloseButtonActive, ImGuiCol_CloseButtonHovered, // [unused since 1.60+] the close button now uses regular button colors.
	//ImGuiCol_ComboBg,                                                              // [unused since 1.53+] ComboBg has been merged with PopupBg, so a redirect isn't accurate.
#endif
};

// Enumeration for PushStyleVar() / PopStyleVar() to temporarily modify the ImGuiStyle structure.
// NB: the enum only refers to fields of ImGuiStyle which makes sense to be pushed/popped inside UI code. During initialization, feel free to just poke into ImGuiStyle directly.
// NB: if changing this enum, you need to update the associated internal table GStyleVarInfo[] accordingly. This is where we link enum values to members offset/type.
enum ImGuiStyleVar_
{
	// Enum name ......................// Member in ImGuiStyle structure (see ImGuiStyle for descriptions)
	ImGuiStyleVar_Alpha,               // float     Alpha
	ImGuiStyleVar_WindowPadding,       // ImVec2    WindowPadding
	ImGuiStyleVar_WindowRounding,      // float     WindowRounding
	ImGuiStyleVar_WindowBorderSize,    // float     WindowBorderSize
	ImGuiStyleVar_WindowMinSize,       // ImVec2    WindowMinSize
	ImGuiStyleVar_WindowTitleAlign,    // ImVec2    WindowTitleAlign
	ImGuiStyleVar_ChildRounding,       // float     ChildRounding
	ImGuiStyleVar_ChildBorderSize,     // float     ChildBorderSize
	ImGuiStyleVar_PopupRounding,       // float     PopupRounding
	ImGuiStyleVar_PopupBorderSize,     // float     PopupBorderSize
	ImGuiStyleVar_FramePadding,        // ImVec2    FramePadding
	ImGuiStyleVar_FrameRounding,       // float     FrameRounding
	ImGuiStyleVar_FrameBorderSize,     // float     FrameBorderSize
	ImGuiStyleVar_ItemSpacing,         // ImVec2    ItemSpacing
	ImGuiStyleVar_ItemInnerSpacing,    // ImVec2    ItemInnerSpacing
	ImGuiStyleVar_IndentSpacing,       // float     IndentSpacing
	ImGuiStyleVar_ScrollbarSize,       // float     ScrollbarSize
	ImGuiStyleVar_ScrollbarRounding,   // float     ScrollbarRounding
	ImGuiStyleVar_GrabMinSize,         // float     GrabMinSize
	ImGuiStyleVar_GrabRounding,        // float     GrabRounding
	ImGuiStyleVar_ButtonTextAlign,     // ImVec2    ButtonTextAlign
	ImGuiStyleVar_COUNT

	// Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	, ImGuiStyleVar_Count_ = ImGuiStyleVar_COUNT, ImGuiStyleVar_ChildWindowRounding = ImGuiStyleVar_ChildRounding
#endif
};

// Enumeration for ColorEdit3() / ColorEdit4() / ColorPicker3() / ColorPicker4() / ColorButton()
enum ImGuiColorEditFlags_
{
	ImGuiColorEditFlags_NoAlpha = 1 << 1,   //              // ColorEdit, ColorPicker, ColorButton: ignore Alpha component (read 3 components from the input pointer).
	ImGuiColorEditFlags_NoPicker = 1 << 2,   //              // ColorEdit: disable picker when clicking on colored square.
	ImGuiColorEditFlags_NoOptions = 1 << 3,   //              // ColorEdit: disable toggling options menu when right-clicking on inputs/small preview.
	ImGuiColorEditFlags_NoSmallPreview = 1 << 4,   //              // ColorEdit, ColorPicker: disable colored square preview next to the inputs. (e.g. to show only the inputs)
	ImGuiColorEditFlags_NoInputs = 1 << 5,   //              // ColorEdit, ColorPicker: disable inputs sliders/text widgets (e.g. to show only the small preview colored square).
	ImGuiColorEditFlags_NoTooltip = 1 << 6,   //              // ColorEdit, ColorPicker, ColorButton: disable tooltip when hovering the preview.
	ImGuiColorEditFlags_NoLabel = 1 << 7,   //              // ColorEdit, ColorPicker: disable display of inline text label (the label is still forwarded to the tooltip and picker).
	ImGuiColorEditFlags_NoSidePreview = 1 << 8,   //              // ColorPicker: disable bigger color preview on right side of the picker, use small colored square preview instead.

												  // User Options (right-click on widget to change some of them). You can set application defaults using SetColorEditOptions(). The idea is that you probably don't want to override them in most of your calls, let the user choose and/or call SetColorEditOptions() during startup.
												  ImGuiColorEditFlags_AlphaBar = 1 << 9,   //              // ColorEdit, ColorPicker: show vertical alpha bar/gradient in picker.
												  ImGuiColorEditFlags_AlphaPreview = 1 << 10,  //              // ColorEdit, ColorPicker, ColorButton: display preview as a transparent color over a checkerboard, instead of opaque.
												  ImGuiColorEditFlags_AlphaPreviewHalf = 1 << 11,  //              // ColorEdit, ColorPicker, ColorButton: display half opaque / half checkerboard, instead of opaque.
												  ImGuiColorEditFlags_HDR = 1 << 12,  //              // (WIP) ColorEdit: Currently only disable 0.0f..1.0f limits in RGBA edition (note: you probably want to use ImGuiColorEditFlags_Float flag as well).
												  ImGuiColorEditFlags_RGB = 1 << 13,  // [Inputs]     // ColorEdit: choose one among RGB/HSV/HEX. ColorPicker: choose any combination using RGB/HSV/HEX.
												  ImGuiColorEditFlags_HSV = 1 << 14,  // [Inputs]     // "
												  ImGuiColorEditFlags_HEX = 1 << 15,  // [Inputs]     // "
												  ImGuiColorEditFlags_Uint8 = 1 << 16,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0..255.
												  ImGuiColorEditFlags_Float = 1 << 17,  // [DataType]   // ColorEdit, ColorPicker, ColorButton: _display_ values formatted as 0.0f..1.0f floats instead of 0..255 integers. No round-trip of value via integers.
												  ImGuiColorEditFlags_PickerHueBar = 1 << 18,  // [PickerMode] // ColorPicker: bar for Hue, rectangle for Sat/Value.
												  ImGuiColorEditFlags_PickerHueWheel = 1 << 19,  // [PickerMode] // ColorPicker: wheel for Hue, triangle for Sat/Value.

																								 // [Internal] Masks
																								 ImGuiColorEditFlags__InputsMask = ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_HSV | ImGuiColorEditFlags_HEX,
																								 ImGuiColorEditFlags__DataTypeMask = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_Float,
																								 ImGuiColorEditFlags__PickerMask = ImGuiColorEditFlags_PickerHueWheel | ImGuiColorEditFlags_PickerHueBar,
																								 ImGuiColorEditFlags__OptionsDefault = ImGuiColorEditFlags_Uint8 | ImGuiColorEditFlags_RGB | ImGuiColorEditFlags_PickerHueBar    // Change application default using SetColorEditOptions()
};

// Enumeration for GetMouseCursor()
// User code may request binding to display given cursor by calling SetMouseCursor(), which is why we have some cursors that are marked unused here
enum ImGuiMouseCursor_
{
	ImGuiMouseCursor_None = -1,
	ImGuiMouseCursor_Arrow = 0,
	ImGuiMouseCursor_TextInput,         // When hovering over InputText, etc.
	ImGuiMouseCursor_ResizeAll,         // Unused by imgui functions
	ImGuiMouseCursor_ResizeNS,          // When hovering over an horizontal border
	ImGuiMouseCursor_ResizeEW,          // When hovering over a vertical border or a column
	ImGuiMouseCursor_ResizeNESW,        // When hovering over the bottom-left corner of a window
	ImGuiMouseCursor_ResizeNWSE,        // When hovering over the bottom-right corner of a window
	ImGuiMouseCursor_COUNT

	// Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	, ImGuiMouseCursor_Count_ = ImGuiMouseCursor_COUNT
#endif
};

// Condition for ImGui::SetWindow***(), SetNextWindow***(), SetNextTreeNode***() functions
// Important: Treat as a regular enum! Do NOT combine multiple values using binary operators! All the functions above treat 0 as a shortcut to ImGuiCond_Always.
enum ImGuiCond_
{
	ImGuiCond_Always = 1 << 0,   // Set the variable
	ImGuiCond_Once = 1 << 1,   // Set the variable once per runtime session (only the first call with succeed)
	ImGuiCond_FirstUseEver = 1 << 2,   // Set the variable if the object/window has no persistently saved data (no entry in .ini file)
	ImGuiCond_Appearing = 1 << 3    // Set the variable if the object/window is appearing after being hidden/inactive (or the first time)

									// Obsolete names (will be removed)
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	, ImGuiSetCond_Always = ImGuiCond_Always, ImGuiSetCond_Once = ImGuiCond_Once, ImGuiSetCond_FirstUseEver = ImGuiCond_FirstUseEver, ImGuiSetCond_Appearing = ImGuiCond_Appearing
#endif
};

// You may modify the ImGui::GetStyle() main instance during initialization and before NewFrame().
// During the frame, use ImGui::PushStyleVar(ImGuiStyleVar_XXXX)/PopStyleVar() to alter the main style values, and ImGui::PushStyleColor(ImGuiCol_XXX)/PopStyleColor() for colors.
struct ImGuiStyle
{
	float       Alpha;                      // Global alpha applies to everything in ImGui.
	ImVec2      WindowPadding;              // Padding within a window.
	float       WindowRounding;             // Radius of window corners rounding. Set to 0.0f to have rectangular windows.
	float       WindowBorderSize;           // Thickness of border around windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	ImVec2      WindowMinSize;              // Minimum window size. This is a global setting. If you want to constraint individual windows, use SetNextWindowSizeConstraints().
	ImVec2      WindowTitleAlign;           // Alignment for title bar text. Defaults to (0.0f,0.5f) for left-aligned,vertically centered.
	float       ChildRounding;              // Radius of child window corners rounding. Set to 0.0f to have rectangular windows.
	float       ChildBorderSize;            // Thickness of border around child windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	float       PopupRounding;              // Radius of popup window corners rounding. (Note that tooltip windows use WindowRounding)
	float       PopupBorderSize;            // Thickness of border around popup/tooltip windows. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	ImVec2      FramePadding;               // Padding within a framed rectangle (used by most widgets).
	float       FrameRounding;              // Radius of frame corners rounding. Set to 0.0f to have rectangular frame (used by most widgets).
	float       FrameBorderSize;            // Thickness of border around frames. Generally set to 0.0f or 1.0f. (Other values are not well tested and more CPU/GPU costly).
	ImVec2      ItemSpacing;                // Horizontal and vertical spacing between widgets/lines.
	ImVec2      ItemInnerSpacing;           // Horizontal and vertical spacing between within elements of a composed widget (e.g. a slider and its label).
	ImVec2      TouchExtraPadding;          // Expand reactive bounding box for touch-based system where touch position is not accurate enough. Unfortunately we don't sort widgets so priority on overlap will always be given to the first widget. So don't grow this too much!
	float       IndentSpacing;              // Horizontal indentation when e.g. entering a tree node. Generally == (FontSize + FramePadding.x*2).
	float       ColumnsMinSpacing;          // Minimum horizontal spacing between two columns.
	float       ScrollbarSize;              // Width of the vertical scrollbar, Height of the horizontal scrollbar.
	float       ScrollbarRounding;          // Radius of grab corners for scrollbar.
	float       GrabMinSize;                // Minimum width/height of a grab box for slider/scrollbar.
	float       GrabRounding;               // Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
	ImVec2      ButtonTextAlign;            // Alignment of button text when button is larger than text. Defaults to (0.5f,0.5f) for horizontally+vertically centered.
	ImVec2      DisplayWindowPadding;       // Window positions are clamped to be visible within the display area by at least this amount. Only covers regular windows.
	ImVec2      DisplaySafeAreaPadding;     // If you cannot see the edge of your screen (e.g. on a TV) increase the safe area padding. Covers popups/tooltips as well regular windows.
	float       MouseCursorScale;           // Scale software rendered mouse cursor (when io.MouseDrawCursor is enabled). May be removed later.
	bool        AntiAliasedLines;           // Enable anti-aliasing on lines/borders. Disable if you are really tight on CPU/GPU.
	bool        AntiAliasedFill;            // Enable anti-aliasing on filled shapes (rounded rectangles, circles, etc.)
	float       CurveTessellationTol;       // Tessellation tolerance when using PathBezierCurveTo() without a specific number of segments. Decrease for highly tessellated curves (higher quality, more polygons), increase to reduce quality.
	ImVec4      Colors[ImGuiCol_COUNT];

	IMGUI_API ImGuiStyle();
	IMGUI_API void ScaleAllSizes(float scale_factor);
};

// This is where your app communicate with ImGui. Access via ImGui::GetIO().
// Read 'Programmer guide' section in .cpp file for general usage.
struct ImGuiIO
{
	//------------------------------------------------------------------
	// Settings (fill once)                 // Default value:
	//------------------------------------------------------------------

	ImGuiConfigFlags   ConfigFlags;         // = 0                  // See ImGuiConfigFlags_ enum. Set by user/application. Gamepad/keyboard navigation options, etc.
	ImGuiBackendFlags  BackendFlags;        // = 0                  // Set ImGuiBackendFlags_ enum. Set by imgui_impl_xxx files or custom back-end.
	ImVec2        DisplaySize;              // <unset>              // Display size, in pixels. For clamping windows positions.
	float         DeltaTime;                // = 1.0f/60.0f         // Time elapsed since last frame, in seconds.
	float         IniSavingRate;            // = 5.0f               // Maximum time between saving positions/sizes to .ini file, in seconds.
	const char* IniFilename;              // = "imgui.ini"        // Path to .ini file. NULL to disable .ini saving.
	const char* LogFilename;              // = "imgui_log.txt"    // Path to .log file (default parameter to ImGui::LogToFile when no file is specified).
	float         MouseDoubleClickTime;     // = 0.30f              // Time for a double-click, in seconds.
	float         MouseDoubleClickMaxDist;  // = 6.0f               // Distance threshold to stay in to validate a double-click, in pixels.
	float         MouseDragThreshold;       // = 6.0f               // Distance threshold before considering we are dragging.
	int           KeyMap[ImGuiKey_COUNT];   // <unset>              // Map of indices into the KeysDown[512] entries array which represent your "native" keyboard state.
	float         KeyRepeatDelay;           // = 0.250f             // When holding a key/button, time before it starts repeating, in seconds (for buttons in Repeat mode, etc.).
	float         KeyRepeatRate;            // = 0.050f             // When holding a key/button, rate at which it repeats, in seconds.
	void* UserData;                 // = NULL               // Store your own data for retrieval by callbacks.

	ImFontAtlas* Fonts;                    // <auto>               // Load and assemble one or more fonts into a single tightly packed texture. Output to Fonts array.
	float         FontGlobalScale;          // = 1.0f               // Global scale all fonts
	bool          FontAllowUserScaling;     // = false              // Allow user scaling text of individual window with CTRL+Wheel.
	ImFont* FontDefault;              // = NULL               // Font to use on NewFrame(). Use NULL to uses Fonts->Fonts[0].
	ImVec2        DisplayFramebufferScale;  // = (1.0f,1.0f)        // For retina display or other situations where window coordinates are different from framebuffer coordinates. User storage only, presently not used by ImGui.
	ImVec2        DisplayVisibleMin;        // <unset> (0.0f,0.0f)  // If you use DisplaySize as a virtual space larger than your screen, set DisplayVisibleMin/Max to the visible area.
	ImVec2        DisplayVisibleMax;        // <unset> (0.0f,0.0f)  // If the values are the same, we defaults to Min=(0.0f) and Max=DisplaySize

											// Advanced/subtle behaviors
	bool          OptMacOSXBehaviors;       // = defined(__APPLE__) // OS X style: Text editing cursor movement using Alt instead of Ctrl, Shortcuts using Cmd/Super instead of Ctrl, Line/Text Start and End using Cmd+Arrows instead of Home/End, Double click selects by word instead of selecting whole text, Multi-selection in lists uses Cmd/Super instead of Ctrl
	bool          OptCursorBlink;           // = true               // Enable blinking cursor, for users who consider it annoying.

											//------------------------------------------------------------------
											// Settings (User Functions)
											//------------------------------------------------------------------

											// Optional: access OS clipboard
											// (default to use native Win32 clipboard on Windows, otherwise uses a private clipboard. Override to access OS clipboard on other architectures)
	const char* (*GetClipboardTextFn)(void* user_data);
	void(*SetClipboardTextFn)(void* user_data, const char* text);
	void* ClipboardUserData;

	// Optional: notify OS Input Method Editor of the screen position of your cursor for text input position (e.g. when using Japanese/Chinese IME in Windows)
	// (default to use native imm32 api on Windows)
	void(*ImeSetInputScreenPosFn)(int x, int y);
	void* ImeWindowHandle;            // (Windows) Set this to your HWND to get automatic IME cursor positioning.

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
											// [OBSOLETE] Rendering function, will be automatically called in Render(). Please call your rendering function yourself now! You can obtain the ImDrawData* by calling ImGui::GetDrawData() after Render().
											// See example applications if you are unsure of how to implement this.
	void(*RenderDrawListsFn)(ImDrawData* data);
#endif

	//------------------------------------------------------------------
	// Input - Fill before calling NewFrame()
	//------------------------------------------------------------------

	ImVec2      MousePos;                       // Mouse position, in pixels. Set to ImVec2(-FLT_MAX,-FLT_MAX) if mouse is unavailable (on another screen, etc.)
	bool        MouseDown[5];                   // Mouse buttons: left, right, middle + extras. ImGui itself mostly only uses left button (BeginPopupContext** are using right button). Others buttons allows us to track if the mouse is being used by your application + available to user as a convenience via IsMouse** API.
	float       MouseWheel;                     // Mouse wheel: 1 unit scrolls about 5 lines text.
	float       MouseWheelH;                    // Mouse wheel (Horizontal). Most users don't have a mouse with an horizontal wheel, may not be filled by all back-ends.
	bool        MouseDrawCursor;                // Request ImGui to draw a mouse cursor for you (if you are on a platform without a mouse cursor).
	bool        KeyCtrl;                        // Keyboard modifier pressed: Control
	bool        KeyShift;                       // Keyboard modifier pressed: Shift
	bool        KeyAlt;                         // Keyboard modifier pressed: Alt
	bool        KeySuper;                       // Keyboard modifier pressed: Cmd/Super/Windows
	bool        KeysDown[512];                  // Keyboard keys that are pressed (ideally left in the "native" order your engine has access to keyboard keys, so you can use your own defines/enums for keys).
	ImWchar     InputCharacters[16 + 1];          // List of characters input (translated by user from keypress+keyboard state). Fill using AddInputCharacter() helper.
	float       NavInputs[ImGuiNavInput_COUNT]; // Gamepad inputs (keyboard keys will be auto-mapped and be written here by ImGui::NewFrame, all values will be cleared back to zero in ImGui::EndFrame)

												// Functions
	IMGUI_API void AddInputCharacter(ImWchar c);                        // Add new character into InputCharacters[]
	IMGUI_API void AddInputCharactersUTF8(const char* utf8_chars);      // Add new characters into InputCharacters[] from an UTF-8 string
	inline void    ClearInputCharacters() { InputCharacters[0] = 0; }   // Clear the text input buffer manually

																		//------------------------------------------------------------------
																		// Output - Retrieve after calling NewFrame()
																		//------------------------------------------------------------------

	bool        WantCaptureMouse;           // When io.WantCaptureMouse is true, imgui will use the mouse inputs, do not dispatch them to your main game/application (in both cases, always pass on mouse inputs to imgui). (e.g. unclicked mouse is hovering over an imgui window, widget is active, mouse was clicked over an imgui window, etc.).
	bool        WantCaptureKeyboard;        // When io.WantCaptureKeyboard is true, imgui will use the keyboard inputs, do not dispatch them to your main game/application (in both cases, always pass keyboard inputs to imgui). (e.g. InputText active, or an imgui window is focused and navigation is enabled, etc.).
	bool        WantTextInput;              // Mobile/console: when io.WantTextInput is true, you may display an on-screen keyboard. This is set by ImGui when it wants textual keyboard input to happen (e.g. when a InputText widget is active).
	bool        WantSetMousePos;            // MousePos has been altered, back-end should reposition mouse on next frame. Set only when ImGuiConfigFlags_NavEnableSetMousePos flag is enabled.
	bool        NavActive;                  // Directional navigation is currently allowed (will handle ImGuiKey_NavXXX events) = a window is focused and it doesn't use the ImGuiWindowFlags_NoNavInputs flag.
	bool        NavVisible;                 // Directional navigation is visible and allowed (will handle ImGuiKey_NavXXX events).
	float       Framerate;                  // Application framerate estimation, in frame per second. Solely for convenience. Rolling average estimation based on IO.DeltaTime over 120 frames
	int         MetricsRenderVertices;      // Vertices output during last call to Render()
	int         MetricsRenderIndices;       // Indices output during last call to Render() = number of triangles * 3
	int         MetricsActiveWindows;       // Number of visible root windows (exclude child windows)
	ImVec2      MouseDelta;                 // Mouse delta. Note that this is zero if either current or previous position are invalid (-FLT_MAX,-FLT_MAX), so a disappearing/reappearing mouse won't have a huge delta.

											//------------------------------------------------------------------
											// [Internal] ImGui will maintain those fields. Forward compatibility not guaranteed!
											//------------------------------------------------------------------

	ImVec2      MousePosPrev;               // Previous mouse position temporary storage (nb: not for public use, set to MousePos in NewFrame())
	ImVec2      MouseClickedPos[5];         // Position at time of clicking
	float       MouseClickedTime[5];        // Time of last click (used to figure out double-click)
	bool        MouseClicked[5];            // Mouse button went from !Down to Down
	bool        MouseDoubleClicked[5];      // Has mouse button been double-clicked?
	bool        MouseReleased[5];           // Mouse button went from Down to !Down
	bool        MouseDownOwned[5];          // Track if button was clicked inside a window. We don't request mouse capture from the application if click started outside ImGui bounds.
	float       MouseDownDuration[5];       // Duration the mouse button has been down (0.0f == just clicked)
	float       MouseDownDurationPrev[5];   // Previous time the mouse button has been down
	ImVec2      MouseDragMaxDistanceAbs[5]; // Maximum distance, absolute, on each axis, of how much mouse has traveled from the clicking point
	float       MouseDragMaxDistanceSqr[5]; // Squared maximum distance of how much mouse has traveled from the clicking point
	float       KeysDownDuration[512];      // Duration the keyboard key has been down (0.0f == just pressed)
	float       KeysDownDurationPrev[512];  // Previous duration the key has been down
	float       NavInputsDownDuration[ImGuiNavInput_COUNT];
	float       NavInputsDownDurationPrev[ImGuiNavInput_COUNT];

	IMGUI_API   ImGuiIO();
};

//-----------------------------------------------------------------------------
// Obsolete functions (Will be removed! Read 'API BREAKING CHANGES' section in imgui.cpp for details)
//-----------------------------------------------------------------------------

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
namespace ImGui
{
	// OBSOLETED in 1.60 (from Dec 2017)
	static inline bool  IsAnyWindowFocused() { return IsWindowFocused(ImGuiFocusedFlags_AnyWindow); }
	static inline bool  IsAnyWindowHovered() { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }
	static inline ImVec2 CalcItemRectClosestPoint(const ImVec2& pos, bool on_edge = false, float outward = 0.f) { (void)on_edge; (void)outward; IM_ASSERT(0); return pos; }
	// OBSOLETED in 1.53 (between Oct 2017 and Dec 2017)
	static inline void  ShowTestWindow() { return ShowDemoWindow(); }
	static inline bool  IsRootWindowFocused() { return IsWindowFocused(ImGuiFocusedFlags_RootWindow); }
	static inline bool  IsRootWindowOrAnyChildFocused() { return IsWindowFocused(ImGuiFocusedFlags_RootAndChildWindows); }
	static inline void  SetNextWindowContentWidth(float w) { SetNextWindowContentSize(ImVec2(w, 0.0f)); }
	static inline float GetItemsLineHeightWithSpacing() { return GetFrameHeightWithSpacing(); }
	// OBSOLETED in 1.52 (between Aug 2017 and Oct 2017)
	bool                Begin(const char* name, bool* p_open, const ImVec2& size_on_first_use, float bg_alpha_override = -1.0f, ImGuiWindowFlags flags = 0); // Use SetNextWindowSize(size, ImGuiCond_FirstUseEver) + SetNextWindowBgAlpha() instead.
	static inline bool  IsRootWindowOrAnyChildHovered() { return IsWindowHovered(ImGuiHoveredFlags_RootAndChildWindows); }
	static inline void  AlignFirstTextHeightToWidgets() { AlignTextToFramePadding(); }
	static inline void  SetNextWindowPosCenter(ImGuiCond c = 0) { ImGuiIO& io = GetIO(); SetNextWindowPos(ImVec2(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f), c, ImVec2(0.5f, 0.5f)); }
	// OBSOLETED in 1.51 (between Jun 2017 and Aug 2017)
	static inline bool  IsItemHoveredRect() { return IsItemHovered(ImGuiHoveredFlags_RectOnly); }
	static inline bool  IsPosHoveringAnyWindow(const ImVec2&) { IM_ASSERT(0); return false; } // This was misleading and partly broken. You probably want to use the ImGui::GetIO().WantCaptureMouse flag instead.
	static inline bool  IsMouseHoveringAnyWindow() { return IsWindowHovered(ImGuiHoveredFlags_AnyWindow); }
	static inline bool  IsMouseHoveringWindow() { return IsWindowHovered(ImGuiHoveredFlags_AllowWhenBlockedByPopup | ImGuiHoveredFlags_AllowWhenBlockedByActiveItem); }
	// OBSOLETED IN 1.49 (between Apr 2016 and May 2016)
	static inline bool  CollapsingHeader(const char* label, const char* str_id, bool framed = true, bool default_open = false) { (void)str_id; (void)framed; ImGuiTreeNodeFlags default_open_flags = 1 << 5; return CollapsingHeader(label, (default_open ? default_open_flags : 0)); }
}
#endif

//-----------------------------------------------------------------------------
// Helpers
//-----------------------------------------------------------------------------

// Helper: Lightweight std::vector<> like class to avoid dragging dependencies (also: Windows implementation of STL with debug enabled is absurdly slow, so let's bypass it so our code runs fast in debug).
// *Important* Our implementation does NOT call C++ constructors/destructors. This is intentional, we do not require it but you have to be mindful of that. Do not use this class as a straight std::vector replacement in your code!
template<typename T>
class ImVector
{
public:
	int                         Size;
	int                         Capacity;
	T* Data;

	typedef T                   value_type;
	typedef value_type* iterator;
	typedef const value_type* const_iterator;

	inline ImVector() { Size = Capacity = 0; Data = NULL; }
	inline ~ImVector() { if (Data) ImGui::MemFree(Data); }
	inline ImVector(const ImVector<T>& src) { Size = Capacity = 0; Data = NULL; operator=(src); }
	inline ImVector& operator=(const ImVector<T>& src) { clear(); resize(src.Size); memcpy(Data, src.Data, (size_t)Size * sizeof(value_type)); return *this; }

	inline bool                 empty() const { return Size == 0; }
	inline int                  size() const { return Size; }
	inline int                  capacity() const { return Capacity; }
	inline value_type& operator[](int i) { IM_ASSERT(i < Size); return Data[i]; }
	inline const value_type& operator[](int i) const { IM_ASSERT(i < Size); return Data[i]; }

	inline void                 clear() { if (Data) { Size = Capacity = 0; ImGui::MemFree(Data); Data = NULL; } }
	inline iterator             begin() { return Data; }
	inline const_iterator       begin() const { return Data; }
	inline iterator             end() { return Data + Size; }
	inline const_iterator       end() const { return Data + Size; }
	inline value_type& front() { IM_ASSERT(Size > 0); return Data[0]; }
	inline const value_type& front() const { IM_ASSERT(Size > 0); return Data[0]; }
	inline value_type& back() { IM_ASSERT(Size > 0); return Data[Size - 1]; }
	inline const value_type& back() const { IM_ASSERT(Size > 0); return Data[Size - 1]; }
	inline void                 swap(ImVector<value_type>& rhs) { int rhs_size = rhs.Size; rhs.Size = Size; Size = rhs_size; int rhs_cap = rhs.Capacity; rhs.Capacity = Capacity; Capacity = rhs_cap; value_type* rhs_data = rhs.Data; rhs.Data = Data; Data = rhs_data; }

	inline int          _grow_capacity(int sz) const { int new_capacity = Capacity ? (Capacity + Capacity / 2) : 8; return new_capacity > sz ? new_capacity : sz; }
	inline void         resize(int new_size) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); Size = new_size; }
	inline void         resize(int new_size, const value_type& v) { if (new_size > Capacity) reserve(_grow_capacity(new_size)); if (new_size > Size) for (int n = Size; n < new_size; n++) memcpy(&Data[n], &v, sizeof(v)); Size = new_size; }
	inline void         reserve(int new_capacity)
	{
		if (new_capacity <= Capacity)
			return;
		value_type* new_data = (value_type*)ImGui::MemAlloc((size_t)new_capacity * sizeof(value_type));
		if (Data)
			memcpy(new_data, Data, (size_t)Size * sizeof(value_type));
		ImGui::MemFree(Data);
		Data = new_data;
		Capacity = new_capacity;
	}

	// NB: &v cannot be pointing inside the ImVector Data itself! e.g. v.push_back(v[10]) is forbidden.
	inline void         push_back(const value_type& v) { if (Size == Capacity) reserve(_grow_capacity(Size + 1)); memcpy(&Data[Size], &v, sizeof(v)); Size++; }
	inline void         pop_back() { IM_ASSERT(Size > 0); Size--; }
	inline void         push_front(const value_type& v) { if (Size == 0) push_back(v); else insert(Data, v); }
	inline iterator     erase(const_iterator it) { IM_ASSERT(it >= Data && it < Data + Size); const ptrdiff_t off = it - Data; memmove(Data + off, Data + off + 1, ((size_t)Size - (size_t)off - 1) * sizeof(value_type)); Size--; return Data + off; }
	inline iterator     insert(const_iterator it, const value_type& v) { IM_ASSERT(it >= Data && it <= Data + Size); const ptrdiff_t off = it - Data; if (Size == Capacity) reserve(_grow_capacity(Size + 1)); if (off < (int)Size) memmove(Data + off + 1, Data + off, ((size_t)Size - (size_t)off) * sizeof(value_type)); memcpy(&Data[off], &v, sizeof(v)); Size++; return Data + off; }
	inline bool         contains(const value_type& v) const { const T* data = Data;  const T* data_end = Data + Size; while (data < data_end) if (*data++ == v) return true; return false; }
};

// Helper: IM_NEW(), IM_PLACEMENT_NEW(), IM_DELETE() macros to call MemAlloc + Placement New, Placement Delete + MemFree
// We call C++ constructor on own allocated memory via the placement "new(ptr) Type()" syntax.
// Defining a custom placement new() with a dummy parameter allows us to bypass including <new> which on some platforms complains when user has disabled exceptions.
struct ImNewDummy {};
inline void* operator new(size_t, ImNewDummy, void* ptr) { return ptr; }
inline void  operator delete(void*, ImNewDummy, void*) {} // This is only required so we can use the symetrical new()
#define IM_PLACEMENT_NEW(_PTR)              new(ImNewDummy(), _PTR)
#define IM_NEW(_TYPE)                       new(ImNewDummy(), ImGui::MemAlloc(sizeof(_TYPE))) _TYPE
template<typename T> void IM_DELETE(T*& p) { if (p) { p->~T(); ImGui::MemFree(p); p = NULL; } }

// Helper: Execute a block of code at maximum once a frame. Convenient if you want to quickly create an UI within deep-nested code that runs multiple times every frame.
// Usage: static ImGuiOnceUponAFrame oaf; if (oaf) ImGui::Text("This will be called only once per frame");
struct ImGuiOnceUponAFrame
{
	ImGuiOnceUponAFrame() { RefFrame = -1; }
	mutable int RefFrame;
	operator bool() const { int current_frame = ImGui::GetFrameCount(); if (RefFrame == current_frame) return false; RefFrame = current_frame; return true; }
};

// Helper: Macro for ImGuiOnceUponAFrame. Attention: The macro expands into 2 statement so make sure you don't use it within e.g. an if() statement without curly braces.
#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS    // Will obsolete
#define IMGUI_ONCE_UPON_A_FRAME     static ImGuiOnceUponAFrame imgui_oaf; if (imgui_oaf)
#endif

// Helper: Parse and apply text filters. In format "aaaaa[,bbbb][,ccccc]"
struct ImGuiTextFilter
{
	struct TextRange
	{
		const char* b;
		const char* e;

		TextRange() { b = e = NULL; }
		TextRange(const char* _b, const char* _e) { b = _b; e = _e; }
		const char* begin() const { return b; }
		const char* end() const { return e; }
		bool empty() const { return b == e; }
		char front() const { return *b; }
		static bool is_blank(char c) { return c == ' ' || c == '\t'; }
		void trim_blanks() { while (b < e && is_blank(*b)) b++; while (e > b && is_blank(*(e - 1))) e--; }
		IMGUI_API void split(char separator, ImVector<TextRange>& out);
	};

	char                InputBuf[256];
	ImVector<TextRange> Filters;
	int                 CountGrep;

	IMGUI_API           ImGuiTextFilter(const char* default_filter = "");
	IMGUI_API bool      Draw(const char* label = "Filter (inc,-exc)", float width = 0.0f);    // Helper calling InputText+Build
	IMGUI_API bool      PassFilter(const char* text, const char* text_end = NULL) const;
	IMGUI_API void      Build();
	void                Clear() { InputBuf[0] = 0; Build(); }
	bool                IsActive() const { return !Filters.empty(); }
};

// Helper: Text buffer for logging/accumulating text
struct ImGuiTextBuffer
{
	ImVector<char>      Buf;

	ImGuiTextBuffer() { Buf.push_back(0); }
	inline char         operator[](int i) { return Buf.Data[i]; }
	const char* begin() const { return &Buf.front(); }
	const char* end() const { return &Buf.back(); }      // Buf is zero-terminated, so end() will point on the zero-terminator
	int                 size() const { return Buf.Size - 1; }
	bool                empty() { return Buf.Size <= 1; }
	void                clear() { Buf.clear(); Buf.push_back(0); }
	void                reserve(int capacity) { Buf.reserve(capacity); }
	const char* c_str() const { return Buf.Data; }
	IMGUI_API void      appendf(const char* fmt, ...) IM_FMTARGS(2);
	IMGUI_API void      appendfv(const char* fmt, va_list args) IM_FMTLIST(2);
};

// Helper: Simple Key->value storage
// Typically you don't have to worry about this since a storage is held within each Window.
// We use it to e.g. store collapse state for a tree (Int 0/1)
// This is optimized for efficient lookup (dichotomy into a contiguous buffer) and rare insertion (typically tied to user interactions aka max once a frame)
// You can use it as custom user storage for temporary values. Declare your own storage if, for example:
// - You want to manipulate the open/close state of a particular sub-tree in your interface (tree node uses Int 0/1 to store their state).
// - You want to store custom debug data easily without adding or editing structures in your code (probably not efficient, but convenient)
// Types are NOT stored, so it is up to you to make sure your Key don't collide with different types.
struct ImGuiStorage
{
	struct Pair
	{
		ImGuiID key;
		union { int val_i; float val_f; void* val_p; };
		Pair(ImGuiID _key, int _val_i) { key = _key; val_i = _val_i; }
		Pair(ImGuiID _key, float _val_f) { key = _key; val_f = _val_f; }
		Pair(ImGuiID _key, void* _val_p) { key = _key; val_p = _val_p; }
	};
	ImVector<Pair>      Data;

	// - Get***() functions find pair, never add/allocate. Pairs are sorted so a query is O(log N)
	// - Set***() functions find pair, insertion on demand if missing.
	// - Sorted insertion is costly, paid once. A typical frame shouldn't need to insert any new pair.
	void                Clear() { Data.clear(); }
	IMGUI_API int       GetInt(ImGuiID key, int default_val = 0) const;
	IMGUI_API void      SetInt(ImGuiID key, int val);
	IMGUI_API bool      GetBool(ImGuiID key, bool default_val = false) const;
	IMGUI_API void      SetBool(ImGuiID key, bool val);
	IMGUI_API float     GetFloat(ImGuiID key, float default_val = 0.0f) const;
	IMGUI_API void      SetFloat(ImGuiID key, float val);
	IMGUI_API void* GetVoidPtr(ImGuiID key) const; // default_val is NULL
	IMGUI_API void      SetVoidPtr(ImGuiID key, void* val);

	// - Get***Ref() functions finds pair, insert on demand if missing, return pointer. Useful if you intend to do Get+Set.
	// - References are only valid until a new value is added to the storage. Calling a Set***() function or a Get***Ref() function invalidates the pointer.
	// - A typical use case where this is convenient for quick hacking (e.g. add storage during a live Edit&Continue session if you can't modify existing struct)
	//      float* pvar = ImGui::GetFloatRef(key); ImGui::SliderFloat("var", pvar, 0, 100.0f); some_var += *pvar;
	IMGUI_API int* GetIntRef(ImGuiID key, int default_val = 0);
	IMGUI_API bool* GetBoolRef(ImGuiID key, bool default_val = false);
	IMGUI_API float* GetFloatRef(ImGuiID key, float default_val = 0.0f);
	IMGUI_API void** GetVoidPtrRef(ImGuiID key, void* default_val = NULL);

	// Use on your own storage if you know only integer are being stored (open/close all tree nodes)
	IMGUI_API void      SetAllInt(int val);

	// For quicker full rebuild of a storage (instead of an incremental one), you may add all your contents and then sort once.
	IMGUI_API void      BuildSortByKey();
};

// Shared state of InputText(), passed to callback when a ImGuiInputTextFlags_Callback* flag is used and the corresponding callback is triggered.
struct ImGuiTextEditCallbackData
{
	ImGuiInputTextFlags EventFlag;      // One of ImGuiInputTextFlags_Callback* // Read-only
	ImGuiInputTextFlags Flags;          // What user passed to InputText()      // Read-only
	void* UserData;       // What user passed to InputText()      // Read-only
	bool                ReadOnly;       // Read-only mode                       // Read-only

										// CharFilter event:
	ImWchar             EventChar;      // Character input                      // Read-write (replace character or set to zero)

										// Completion,History,Always events:
										// If you modify the buffer contents make sure you update 'BufTextLen' and set 'BufDirty' to true.
	ImGuiKey            EventKey;       // Key pressed (Up/Down/TAB)            // Read-only
	char* Buf;            // Current text buffer                  // Read-write (pointed data only, can't replace the actual pointer)
	int                 BufTextLen;     // Current text length in bytes         // Read-write
	int                 BufSize;        // Maximum text length in bytes         // Read-only
	bool                BufDirty;       // Set if you modify Buf/BufTextLen!!   // Write
	int                 CursorPos;      //                                      // Read-write
	int                 SelectionStart; //                                      // Read-write (== to SelectionEnd when no selection)
	int                 SelectionEnd;   //                                      // Read-write

										// NB: Helper functions for text manipulation. Calling those function loses selection.
	IMGUI_API void    DeleteChars(int pos, int bytes_count);
	IMGUI_API void    InsertChars(int pos, const char* text, const char* text_end = NULL);
	bool              HasSelection() const { return SelectionStart != SelectionEnd; }
};

// Resizing callback data to apply custom constraint. As enabled by SetNextWindowSizeConstraints(). Callback is called during the next Begin().
// NB: For basic min/max size constraint on each axis you don't need to use the callback! The SetNextWindowSizeConstraints() parameters are enough.
struct ImGuiSizeCallbackData
{
	void* UserData;       // Read-only.   What user passed to SetNextWindowSizeConstraints()
	ImVec2  Pos;            // Read-only.   Window position, for reference.
	ImVec2  CurrentSize;    // Read-only.   Current window size.
	ImVec2  DesiredSize;    // Read-write.  Desired size, based on user's mouse position. Write to this field to restrain resizing.
};

// Data payload for Drag and Drop operations
struct ImGuiPayload
{
	// Members
	const void* Data;               // Data (copied and owned by dear imgui)
	int             DataSize;           // Data size

										// [Internal]
	ImGuiID         SourceId;           // Source item id
	ImGuiID         SourceParentId;     // Source parent id (if available)
	int             DataFrameCount;     // Data timestamp
	char            DataType[32 + 1];     // Data type tag (short user-supplied string, 32 characters max)
	bool            Preview;            // Set when AcceptDragDropPayload() was called and mouse has been hovering the target item (nb: handle overlapping drag targets)
	bool            Delivery;           // Set when AcceptDragDropPayload() was called and mouse button is released over the target item.

	ImGuiPayload() { Clear(); }
	void Clear() { SourceId = SourceParentId = 0; Data = NULL; DataSize = 0; memset(DataType, 0, sizeof(DataType)); DataFrameCount = -1; Preview = Delivery = false; }
	bool IsDataType(const char* type) const { return DataFrameCount != -1 && strcmp(type, DataType) == 0; }
	bool IsPreview() const { return Preview; }
	bool IsDelivery() const { return Delivery; }
};

// Helpers macros to generate 32-bits encoded colors
#ifdef IMGUI_USE_BGRA_PACKED_COLOR
#define IM_COL32_R_SHIFT    16
#define IM_COL32_G_SHIFT    8
#define IM_COL32_B_SHIFT    0
#define IM_COL32_A_SHIFT    24
#define IM_COL32_A_MASK     0xFF000000
#else
#define IM_COL32_R_SHIFT    0
#define IM_COL32_G_SHIFT    8
#define IM_COL32_B_SHIFT    16
#define IM_COL32_A_SHIFT    24
#define IM_COL32_A_MASK     0xFF000000
#endif
#define IM_COL32(R,G,B,A)    (((ImU32)(A)<<IM_COL32_A_SHIFT) | ((ImU32)(B)<<IM_COL32_B_SHIFT) | ((ImU32)(G)<<IM_COL32_G_SHIFT) | ((ImU32)(R)<<IM_COL32_R_SHIFT))
#define IM_COL32_WHITE       IM_COL32(255,255,255,255)  // Opaque white = 0xFFFFFFFF
#define IM_COL32_BLACK       IM_COL32(0,0,0,255)        // Opaque black
#define IM_COL32_BLACK_TRANS IM_COL32(0,0,0,0)          // Transparent black = 0x00000000

// Helper: ImColor() implicity converts colors to either ImU32 (packed 4x1 byte) or ImVec4 (4x1 float)
// Prefer using IM_COL32() macros if you want a guaranteed compile-time ImU32 for usage with ImDrawList API.
// **Avoid storing ImColor! Store either u32 of ImVec4. This is not a full-featured color class. MAY OBSOLETE.
// **None of the ImGui API are using ImColor directly but you can use it as a convenience to pass colors in either ImU32 or ImVec4 formats. Explicitly cast to ImU32 or ImVec4 if needed.

struct ImColor
{
	ImVec4              Value;

	ImColor() { Value.x = Value.y = Value.z = Value.w = 0.0f; }
	ImColor(int r, int g, int b, int a = 255) { float sc = 1.0f / 255.0f; Value.x = (float)r * sc; Value.y = (float)g * sc; Value.z = (float)b * sc; Value.w = (float)a * sc; }
	ImColor(ImU32 rgba) { float sc = 1.0f / 255.0f; Value.x = (float)((rgba >> IM_COL32_R_SHIFT) & 0xFF) * sc; Value.y = (float)((rgba >> IM_COL32_G_SHIFT) & 0xFF) * sc; Value.z = (float)((rgba >> IM_COL32_B_SHIFT) & 0xFF) * sc; Value.w = (float)((rgba >> IM_COL32_A_SHIFT) & 0xFF) * sc; }
	ImColor(float r, float g, float b, float a = 1.0f) { Value.x = r; Value.y = g; Value.z = b; Value.w = a; }
	ImColor(const ImVec4& col) { Value = col; }
	inline operator ImU32() const { return ImGui::ColorConvertFloat4ToU32(Value); }
	inline operator ImVec4() const { return Value; }

	// FIXME-OBSOLETE: May need to obsolete/cleanup those helpers.
	inline void    SetHSV(float h, float s, float v, float a = 1.0f) { ImGui::ColorConvertHSVtoRGB(h, s, v, Value.x, Value.y, Value.z); Value.w = a; }
	static ImColor HSV(float h, float s, float v, float a = 1.0f) { float r, g, b; ImGui::ColorConvertHSVtoRGB(h, s, v, r, g, b); return ImColor(r, g, b, a); }
};

// Helper: Manually clip large list of items.
// If you are submitting lots of evenly spaced items and you have a random access to the list, you can perform coarse clipping based on visibility to save yourself from processing those items at all.
// The clipper calculates the range of visible items and advance the cursor to compensate for the non-visible items we have skipped.
// ImGui already clip items based on their bounds but it needs to measure text size to do so. Coarse clipping before submission makes this cost and your own data fetching/submission cost null.
// Usage:
//     ImGuiListClipper clipper(1000);  // we have 1000 elements, evenly spaced.
//     while (clipper.Step())
//         for (int i = clipper.DisplayStart; i < clipper.DisplayEnd; i++)
//             ImGui::Text("line number %d", i);
// - Step 0: the clipper let you process the first element, regardless of it being visible or not, so we can measure the element height (step skipped if we passed a known height as second arg to constructor).
// - Step 1: the clipper infer height from first element, calculate the actual range of elements to display, and position the cursor before the first element.
// - (Step 2: dummy step only required if an explicit items_height was passed to constructor or Begin() and user call Step(). Does nothing and switch to Step 3.)
// - Step 3: the clipper validate that we have reached the expected Y position (corresponding to element DisplayEnd), advance the cursor to the end of the list and then returns 'false' to end the loop.
struct ImGuiListClipper
{
	float   StartPosY;
	float   ItemsHeight;
	int     ItemsCount, StepNo, DisplayStart, DisplayEnd;

	// items_count:  Use -1 to ignore (you can call Begin later). Use INT_MAX if you don't know how many items you have (in which case the cursor won't be advanced in the final step).
	// items_height: Use -1.0f to be calculated automatically on first step. Otherwise pass in the distance between your items, typically GetTextLineHeightWithSpacing() or GetFrameHeightWithSpacing().
	// If you don't specify an items_height, you NEED to call Step(). If you specify items_height you may call the old Begin()/End() api directly, but prefer calling Step().
	ImGuiListClipper(int items_count = -1, float items_height = -1.0f) { Begin(items_count, items_height); } // NB: Begin() initialize every fields (as we allow user to call Begin/End multiple times on a same instance if they want).
	~ImGuiListClipper() { IM_ASSERT(ItemsCount == -1); }      // Assert if user forgot to call End() or Step() until false.

	IMGUI_API bool Step();                                              // Call until it returns false. The DisplayStart/DisplayEnd fields will be set and you can process/draw those items.
	IMGUI_API void Begin(int items_count, float items_height = -1.0f);  // Automatically called by constructor if you passed 'items_count' or by Step() in Step 1.
	IMGUI_API void End();                                               // Automatically called on the last call of Step() that returns false.
};

//-----------------------------------------------------------------------------
// Draw List
// Hold a series of drawing commands. The user provides a renderer for ImDrawData which essentially contains an array of ImDrawList.
//-----------------------------------------------------------------------------

// Draw callbacks for advanced uses.
// NB- You most likely do NOT need to use draw callbacks just to create your own widget or customized UI rendering (you can poke into the draw list for that)
// Draw callback may be useful for example, A) Change your GPU render state, B) render a complex 3D scene inside a UI element (without an intermediate texture/render target), etc.
// The expected behavior from your rendering function is 'if (cmd.UserCallback != NULL) cmd.UserCallback(parent_list, cmd); else RenderTriangles()'
typedef void(*ImDrawCallback)(const ImDrawList* parent_list, const ImDrawCmd* cmd);

// Typically, 1 command = 1 GPU draw call (unless command is a callback)
struct ImDrawCmd
{
	unsigned int    ElemCount;              // Number of indices (multiple of 3) to be rendered as triangles. Vertices are stored in the callee ImDrawList's vtx_buffer[] array, indices in idx_buffer[].
	ImVec4          ClipRect;               // Clipping rectangle (x1, y1, x2, y2)
	ImTextureID     TextureId;              // User-provided texture ID. Set by user in ImfontAtlas::SetTexID() for fonts or passed to Image*() functions. Ignore if never using images or multiple fonts atlas.
	ImDrawCallback  UserCallback;           // If != NULL, call the function instead of rendering the vertices. clip_rect and texture_id will be set normally.
	void* UserCallbackData;       // The draw callback code can access this.

	ImDrawCmd() { ElemCount = 0; ClipRect.x = ClipRect.y = ClipRect.z = ClipRect.w = 0.0f; TextureId = NULL; UserCallback = NULL; UserCallbackData = NULL; }
};

// Vertex index (override with '#define ImDrawIdx unsigned int' inside in imconfig.h)
#ifndef ImDrawIdx
typedef unsigned short ImDrawIdx;
#endif

// Vertex layout
#ifndef IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT
struct ImDrawVert
{
	ImVec2  pos;
	ImVec2  uv;
	ImU32   col;
};
#else
// You can override the vertex format layout by defining IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT in imconfig.h
// The code expect ImVec2 pos (8 bytes), ImVec2 uv (8 bytes), ImU32 col (4 bytes), but you can re-order them or add other fields as needed to simplify integration in your engine.
// The type has to be described within the macro (you can either declare the struct or use a typedef)
// NOTE: IMGUI DOESN'T CLEAR THE STRUCTURE AND DOESN'T CALL A CONSTRUCTOR SO ANY CUSTOM FIELD WILL BE UNINITIALIZED. IF YOU ADD EXTRA FIELDS (SUCH AS A 'Z' COORDINATES) YOU WILL NEED TO CLEAR THEM DURING RENDER OR TO IGNORE THEM.
IMGUI_OVERRIDE_DRAWVERT_STRUCT_LAYOUT;
#endif

// Draw channels are used by the Columns API to "split" the render list into different channels while building, so items of each column can be batched together.
// You can also use them to simulate drawing layers and submit primitives in a different order than how they will be rendered.
struct ImDrawChannel
{
	ImVector<ImDrawCmd>     CmdBuffer;
	ImVector<ImDrawIdx>     IdxBuffer;
};

enum ImDrawCornerFlags_
{
	ImDrawCornerFlags_TopLeft = 1 << 0, // 0x1
	ImDrawCornerFlags_TopRight = 1 << 1, // 0x2
	ImDrawCornerFlags_BotLeft = 1 << 2, // 0x4
	ImDrawCornerFlags_BotRight = 1 << 3, // 0x8
	ImDrawCornerFlags_Top = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_TopRight,   // 0x3
	ImDrawCornerFlags_Bot = ImDrawCornerFlags_BotLeft | ImDrawCornerFlags_BotRight,   // 0xC
	ImDrawCornerFlags_Left = ImDrawCornerFlags_TopLeft | ImDrawCornerFlags_BotLeft,    // 0x5
	ImDrawCornerFlags_Right = ImDrawCornerFlags_TopRight | ImDrawCornerFlags_BotRight,  // 0xA
	ImDrawCornerFlags_All = 0xF     // In your function calls you may use ~0 (= all bits sets) instead of ImDrawCornerFlags_All, as a convenience
};

enum ImDrawListFlags_
{
	ImDrawListFlags_AntiAliasedLines = 1 << 0,
	ImDrawListFlags_AntiAliasedFill = 1 << 1
};

// Draw command list
// This is the low-level list of polygons that ImGui functions are filling. At the end of the frame, all command lists are passed to your ImGuiIO::RenderDrawListFn function for rendering.
// Each ImGui window contains its own ImDrawList. You can use ImGui::GetWindowDrawList() to access the current window draw list and draw custom primitives.
// You can interleave normal ImGui:: calls and adding primitives to the current draw list.
// All positions are generally in pixel coordinates (top-left at (0,0), bottom-right at io.DisplaySize), however you are totally free to apply whatever transformation matrix to want to the data (if you apply such transformation you'll want to apply it to ClipRect as well)
// Important: Primitives are always added to the list and not culled (culling is done at higher-level by ImGui:: functions), if you use this API a lot consider coarse culling your drawn objects.
struct ImDrawList
{
	// This is what you have to render
	ImVector<ImDrawCmd>     CmdBuffer;          // Draw commands. Typically 1 command = 1 GPU draw call, unless the command is a callback.
	ImVector<ImDrawIdx>     IdxBuffer;          // Index buffer. Each command consume ImDrawCmd::ElemCount of those
	ImVector<ImDrawVert>    VtxBuffer;          // Vertex buffer.
	ImDrawListFlags         Flags;              // Flags, you may poke into these to adjust anti-aliasing settings per-primitive.

												// [Internal, used while building lists]
	const ImDrawListSharedData* _Data;          // Pointer to shared draw data (you can use ImGui::GetDrawListSharedData() to get the one from current ImGui context)
	const char* _OwnerName;         // Pointer to owner window's name for debugging
	unsigned int            _VtxCurrentIdx;     // [Internal] == VtxBuffer.Size
	ImDrawVert* _VtxWritePtr;       // [Internal] point within VtxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
	ImDrawIdx* _IdxWritePtr;       // [Internal] point within IdxBuffer.Data after each add command (to avoid using the ImVector<> operators too much)
	ImVector<ImVec4>        _ClipRectStack;     // [Internal]
	ImVector<ImTextureID>   _TextureIdStack;    // [Internal]
	ImVector<ImVec2>        _Path;              // [Internal] current path building
	int                     _ChannelsCurrent;   // [Internal] current channel number (0)
	int                     _ChannelsCount;     // [Internal] number of active channels (1+)
	ImVector<ImDrawChannel> _Channels;          // [Internal] draw channels for columns API (not resized down so _ChannelsCount may be smaller than _Channels.Size)

												// If you want to create ImDrawList instances, pass them ImGui::GetDrawListSharedData() or create and use your own ImDrawListSharedData (so you can use ImDrawList without ImGui)
	ImDrawList(const ImDrawListSharedData* shared_data) { _Data = shared_data; _OwnerName = NULL; Clear(); }
	~ImDrawList() { ClearFreeMemory(); }
	IMGUI_API void  PushClipRect(ImVec2 clip_rect_min, ImVec2 clip_rect_max, bool intersect_with_current_clip_rect = false);  // Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
	IMGUI_API void  PushClipRectFullScreen();
	IMGUI_API void  PopClipRect();
	IMGUI_API void  PushTextureID(ImTextureID texture_id);
	IMGUI_API void  PopTextureID();
	inline ImVec2   GetClipRectMin() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.x, cr.y); }
	inline ImVec2   GetClipRectMax() const { const ImVec4& cr = _ClipRectStack.back(); return ImVec2(cr.z, cr.w); }

	// Primitives
	IMGUI_API void  AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness = 1.0f);
	IMGUI_API void  AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All, float thickness = 1.0f);   // a: upper-left, b: lower-right, rounding_corners_flags: 4-bits corresponding to which corner to round
	IMGUI_API void  AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);                     // a: upper-left, b: lower-right
	IMGUI_API void  AddRectFilledMultiColor(const ImVec2& a, const ImVec2& b, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left);
	IMGUI_API void  AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness = 1.0f);
	IMGUI_API void  AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col);
	IMGUI_API void  AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness = 1.0f);
	IMGUI_API void  AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col);
	IMGUI_API void  AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12, float thickness = 1.0f);
	IMGUI_API void  AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments = 12);
	IMGUI_API void  AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL);
	IMGUI_API void  AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end = NULL, float wrap_width = 0.0f, const ImVec4 * cpu_fine_clip_rect = NULL);
	IMGUI_API void  AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a = ImVec2(0, 0), const ImVec2& uv_b = ImVec2(1, 1), ImU32 col = 0xFFFFFFFF);
	IMGUI_API void  AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a = ImVec2(0, 0), const ImVec2& uv_b = ImVec2(1, 0), const ImVec2& uv_c = ImVec2(1, 1), const ImVec2& uv_d = ImVec2(0, 1), ImU32 col = 0xFFFFFFFF);
	IMGUI_API void  AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners = ImDrawCornerFlags_All);
	IMGUI_API void  AddPolyline(const ImVec2* points, const int num_points, ImU32 col, bool closed, float thickness);
	IMGUI_API void  AddConvexPolyFilled(const ImVec2* points, const int num_points, ImU32 col);
	IMGUI_API void  AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments = 0);
	IMGUI_API void  AddRing3D(const Vector& pos, int16_t radius, uint16_t points, ImU32 color, float thickness);

	// Stateful path API, add points then finish with PathFill() or PathStroke()
	inline    void  PathClear() { _Path.resize(0); }
	inline    void  PathLineTo(const ImVec2& pos) { _Path.push_back(pos); }
	inline    void  PathLineToMergeDuplicate(const ImVec2& pos) { if (_Path.Size == 0 || memcmp(&_Path[_Path.Size - 1], &pos, 8) != 0) _Path.push_back(pos); }
	inline    void  PathFillConvex(ImU32 col) { AddConvexPolyFilled(_Path.Data, _Path.Size, col); PathClear(); }
	inline    void  PathStroke(ImU32 col, bool closed, float thickness = 1.0f) { AddPolyline(_Path.Data, _Path.Size, col, closed, thickness); PathClear(); }
	IMGUI_API void  PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments = 10);
	IMGUI_API void  PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12);                                // Use precomputed angles for a 12 steps circle
	IMGUI_API void  PathBezierCurveTo(const ImVec2& p1, const ImVec2& p2, const ImVec2& p3, int num_segments = 0);
	IMGUI_API void  PathRect(const ImVec2& rect_min, const ImVec2& rect_max, float rounding = 0.0f, int rounding_corners_flags = ImDrawCornerFlags_All);

	// Channels
	// - Use to simulate layers. By switching channels to can render out-of-order (e.g. submit foreground primitives before background primitives)
	// - Use to minimize draw calls (e.g. if going back-and-forth between multiple non-overlapping clipping rectangles, prefer to append into separate channels then merge at the end)
	IMGUI_API void  ChannelsSplit(int channels_count);
	IMGUI_API void  ChannelsMerge();
	IMGUI_API void  ChannelsSetCurrent(int channel_index);

	// Advanced
	IMGUI_API void  AddCallback(ImDrawCallback callback, void* callback_data);  // Your rendering function must check for 'UserCallback' in ImDrawCmd and call the function instead of rendering triangles.
	IMGUI_API void  AddDrawCmd();                                               // This is useful if you need to forcefully create a new draw call (to allow for dependent rendering / blending). Otherwise primitives are merged into the same draw-call as much as possible
	IMGUI_API ImDrawList* CloneOutput() const;                                  // Create a clone of the CmdBuffer/IdxBuffer/VtxBuffer.

																				// Internal helpers
																				// NB: all primitives needs to be reserved via PrimReserve() beforehand!
	IMGUI_API void  Clear();
	IMGUI_API void  ClearFreeMemory();
	IMGUI_API void  PrimReserve(int idx_count, int vtx_count);
	IMGUI_API void  PrimRect(const ImVec2& a, const ImVec2& b, ImU32 col);      // Axis aligned rectangle (composed of two triangles)
	IMGUI_API void  PrimRectUV(const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col);
	IMGUI_API void  PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col);
	inline    void  PrimWriteVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col) { _VtxWritePtr->pos = pos; _VtxWritePtr->uv = uv; _VtxWritePtr->col = col; _VtxWritePtr++; _VtxCurrentIdx++; }
	inline    void  PrimWriteIdx(ImDrawIdx idx) { *_IdxWritePtr = idx; _IdxWritePtr++; }
	inline    void  PrimVtx(const ImVec2& pos, const ImVec2& uv, ImU32 col) { PrimWriteIdx((ImDrawIdx)_VtxCurrentIdx); PrimWriteVtx(pos, uv, col); }
	IMGUI_API void  UpdateClipRect();
	IMGUI_API void  UpdateTextureID();
};

// All draw data to render an ImGui frame
// (NB: the style and the naming convention here is a little inconsistent but we preserve them for backward compatibility purpose)
struct ImDrawData
{
	bool            Valid;                  // Only valid after Render() is called and before the next NewFrame() is called.
	ImDrawList** CmdLists;               // Array of ImDrawList* to render. The ImDrawList are owned by ImGuiContext and only pointed to from here.
	int             CmdListsCount;          // Number of ImDrawList* to render
	int             TotalIdxCount;          // For convenience, sum of all ImDrawList's IdxBuffer.Size
	int             TotalVtxCount;          // For convenience, sum of all ImDrawList's VtxBuffer.Size

											// Functions
	ImDrawData() { Valid = false; Clear(); }
	~ImDrawData() { Clear(); }
	void Clear() { Valid = false; CmdLists = NULL; CmdListsCount = TotalVtxCount = TotalIdxCount = 0; } // The ImDrawList are owned by ImGuiContext!
	IMGUI_API void  DeIndexAllBuffers();                // Helper to convert all buffers from indexed to non-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
	IMGUI_API void  ScaleClipRects(const ImVec2& sc);   // Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
};

struct ImFontConfig
{
	void* FontData;               //          // TTF/OTF data
	int             FontDataSize;           //          // TTF/OTF data size
	bool            FontDataOwnedByAtlas;   // true     // TTF/OTF data ownership taken by the container ImFontAtlas (will delete memory itself).
	int             FontNo;                 // 0        // Index of font within TTF/OTF file
	float           SizePixels;             //          // Size in pixels for rasterizer.
	int             OversampleH;            // 3        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
	int             OversampleV;            // 1        // Rasterize at higher quality for sub-pixel positioning. We don't use sub-pixel positions on the Y axis.
	bool            PixelSnapH;             // false    // Align every glyph to pixel boundary. Useful e.g. if you are merging a non-pixel aligned font with the default font. If enabled, you can set OversampleH/V to 1.
	ImVec2          GlyphExtraSpacing;      // 0, 0     // Extra spacing (in pixels) between glyphs. Only X axis is supported for now.
	ImVec2          GlyphOffset;            // 0, 0     // Offset all glyphs from this font input.
	const ImWchar* GlyphRanges;            // NULL     // Pointer to a user-provided list of Unicode range (2 value per range, values are inclusive, zero-terminated list). THE ARRAY DATA NEEDS TO PERSIST AS LONG AS THE FONT IS ALIVE.
	bool            MergeMode;              // false    // Merge into previous ImFont, so you can combine multiple inputs font into one ImFont (e.g. ASCII font + icons + Japanese glyphs). You may want to use GlyphOffset.y when merge font of different heights.
	unsigned int    RasterizerFlags;        // 0x00     // Settings for custom font rasterizer (e.g. ImGuiFreeType). Leave as zero if you aren't using one.
	float           RasterizerMultiply;     // 1.0f     // Brighten (>1.0f) or darken (<1.0f) font output. Brightening small fonts may be a good workaround to make them more readable.

											// [Internal]
	char            Name[40];               // Name (strictly to ease debugging)
	ImFont* DstFont;

	IMGUI_API ImFontConfig();
};

struct ImFontGlyph
{
	ImWchar         Codepoint;          // 0x0000..0xFFFF
	float           AdvanceX;           // Distance to next character (= data from font + ImFontConfig::GlyphExtraSpacing.x baked in)
	float           X0, Y0, X1, Y1;     // Glyph corners
	float           U0, V0, U1, V1;     // Texture coordinates
};

enum ImFontAtlasFlags_
{
	ImFontAtlasFlags_NoPowerOfTwoHeight = 1 << 0,   // Don't round the height to next power of two
	ImFontAtlasFlags_NoMouseCursors = 1 << 1    // Don't build software mouse cursors into the atlas
};

// Load and rasterize multiple TTF/OTF fonts into a same texture.
// Sharing a texture for multiple fonts allows us to reduce the number of draw calls during rendering.
// We also add custom graphic data into the texture that serves for ImGui.
//  1. (Optional) Call AddFont*** functions. If you don't call any, the default font will be loaded for you.
//  2. Call GetTexDataAsAlpha8() or GetTexDataAsRGBA32() to build and retrieve pixels data.
//  3. Upload the pixels data into a texture within your graphics system.
//  4. Call SetTexID(my_tex_id); and pass the pointer/identifier to your texture. This value will be passed back to you during rendering to identify the texture.
// IMPORTANT: If you pass a 'glyph_ranges' array to AddFont*** functions, you need to make sure that your array persist up until the ImFont is build (when calling GetTextData*** or Build()). We only copy the pointer, not the data.
struct ImFontAtlas
{
	IMGUI_API ImFontAtlas();
	IMGUI_API ~ImFontAtlas();
	IMGUI_API ImFont* AddFont(const ImFontConfig* font_cfg);
	IMGUI_API ImFont* AddFontDefault(const ImFontConfig* font_cfg = NULL);
	IMGUI_API ImFont* AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);
	IMGUI_API ImFont* AddFontFromMemoryTTF(void* font_data, int font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // Note: Transfer ownership of 'ttf_data' to ImFontAtlas! Will be deleted after Build(). Set font_cfg->FontDataOwnedByAtlas to false to keep ownership.
	IMGUI_API ImFont* AddFontFromMemoryCompressedTTF(const void* compressed_font_data, int compressed_font_size, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL); // 'compressed_font_data' still owned by caller. Compress with binary_to_compressed_c.cpp.
	IMGUI_API ImFont* AddFontFromMemoryCompressedBase85TTF(const char* compressed_font_data_base85, float size_pixels, const ImFontConfig* font_cfg = NULL, const ImWchar* glyph_ranges = NULL);              // 'compressed_font_data_base85' still owned by caller. Compress with binary_to_compressed_c.cpp with -base85 parameter.
	IMGUI_API void              ClearInputData();           // Clear input data (all ImFontConfig structures including sizes, TTF data, glyph ranges, etc.) = all the data used to build the texture and fonts.
	IMGUI_API void              ClearTexData();             // Clear output texture data (CPU side). Saves RAM once the texture has been copied to graphics memory.
	IMGUI_API void              ClearFonts();               // Clear output font data (glyphs storage, UV coordinates).
	IMGUI_API void              Clear();                    // Clear all input and output.

															// Build atlas, retrieve pixel data.
															// User is in charge of copying the pixels into graphics memory (e.g. create a texture with your engine). Then store your texture handle with SetTexID().
															// RGBA32 format is provided for convenience and compatibility, but note that unless you use CustomRect to draw color data, the RGB pixels emitted from Fonts will all be white (~75% of waste).
															// Pitch = Width * BytesPerPixels
	IMGUI_API bool              Build();                    // Build pixels data. This is called automatically for you by the GetTexData*** functions.
	IMGUI_API void              GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 1 byte per-pixel
	IMGUI_API void              GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel = NULL);  // 4 bytes-per-pixel
	void                        SetTexID(ImTextureID id) { TexID = id; }

	//-------------------------------------------
	// Glyph Ranges
	//-------------------------------------------

	// Helpers to retrieve list of common Unicode ranges (2 value per range, values are inclusive, zero-terminated list)
	// NB: Make sure that your string are UTF-8 and NOT in your local code page. In C++11, you can create UTF-8 string literal using the u8"Hello world" syntax. See FAQ for details.
	IMGUI_API const ImWchar* GetGlyphRangesDefault();    // Basic Latin, Extended Latin
	IMGUI_API const ImWchar* GetGlyphRangesKorean();     // Default + Korean characters
	IMGUI_API const ImWchar* GetGlyphRangesJapanese();   // Default + Hiragana, Katakana, Half-Width, Selection of 1946 Ideographs
	IMGUI_API const ImWchar* GetGlyphRangesChinese();    // Default + Japanese + full set of about 21000 CJK Unified Ideographs
	IMGUI_API const ImWchar* GetGlyphRangesCyrillic();   // Default + about 400 Cyrillic characters
	IMGUI_API const ImWchar* GetGlyphRangesThai();       // Default + Thai characters

															// Helpers to build glyph ranges from text data. Feed your application strings/characters to it then call BuildRanges().
	struct GlyphRangesBuilder
	{
		ImVector<unsigned char> UsedChars;  // Store 1-bit per Unicode code point (0=unused, 1=used)
		GlyphRangesBuilder() { UsedChars.resize(0x10000 / 8); memset(UsedChars.Data, 0, 0x10000 / 8); }
		bool           GetBit(int n) { return (UsedChars[n >> 3] & (1 << (n & 7))) != 0; }
		void           SetBit(int n) { UsedChars[n >> 3] |= 1 << (n & 7); }  // Set bit 'c' in the array
		void           AddChar(ImWchar c) { SetBit(c); }                          // Add character
		IMGUI_API void AddText(const char* text, const char* text_end = NULL);      // Add string (each character of the UTF-8 string are added)
		IMGUI_API void AddRanges(const ImWchar* ranges);                            // Add ranges, e.g. builder.AddRanges(ImFontAtlas::GetGlyphRangesDefault) to force add all of ASCII/Latin+Ext
		IMGUI_API void BuildRanges(ImVector<ImWchar>* out_ranges);                  // Output new ranges
	};

	//-------------------------------------------
	// Custom Rectangles/Glyphs API
	//-------------------------------------------

	// You can request arbitrary rectangles to be packed into the atlas, for your own purposes. After calling Build(), you can query the rectangle position and render your pixels.
	// You can also request your rectangles to be mapped as font glyph (given a font + Unicode point), so you can render e.g. custom colorful icons and use them as regular glyphs.
	struct CustomRect
	{
		unsigned int    ID;             // Input    // User ID. Use <0x10000 to map into a font glyph, >=0x10000 for other/internal/custom texture data.
		unsigned short  Width, Height;  // Input    // Desired rectangle dimension
		unsigned short  X, Y;           // Output   // Packed position in Atlas
		float           GlyphAdvanceX;  // Input    // For custom font glyphs only (ID<0x10000): glyph xadvance
		ImVec2          GlyphOffset;    // Input    // For custom font glyphs only (ID<0x10000): glyph display offset
		ImFont* Font;           // Input    // For custom font glyphs only (ID<0x10000): target font
		CustomRect() { ID = 0xFFFFFFFF; Width = Height = 0; X = Y = 0xFFFF; GlyphAdvanceX = 0.0f; GlyphOffset = ImVec2(0, 0); Font = NULL; }
		bool IsPacked() const { return X != 0xFFFF; }
	};

	IMGUI_API int       AddCustomRectRegular(unsigned int id, int width, int height);                                                                   // Id needs to be >= 0x10000. Id >= 0x80000000 are reserved for ImGui and ImDrawList
	IMGUI_API int       AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset = ImVec2(0, 0));   // Id needs to be < 0x10000 to register a rectangle to map into a specific font.
	const CustomRect* GetCustomRectByIndex(int index) const { if (index < 0) return NULL; return &CustomRects[index]; }

	// [Internal]
	IMGUI_API void      CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max);
	IMGUI_API bool      GetMouseCursorTexData(ImGuiMouseCursor cursor, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2]);

	//-------------------------------------------
	// Members
	//-------------------------------------------

	ImFontAtlasFlags            Flags;              // Build flags (see ImFontAtlasFlags_)
	ImTextureID                 TexID;              // User data to refer to the texture once it has been uploaded to user's graphic systems. It is passed back to you during rendering via the ImDrawCmd structure.
	int                         TexDesiredWidth;    // Texture width desired by user before Build(). Must be a power-of-two. If have many glyphs your graphics API have texture size restrictions you may want to increase texture width to decrease height.
	int                         TexGlyphPadding;    // Padding between glyphs within texture in pixels. Defaults to 1.

													// [Internal]
													// NB: Access texture data via GetTexData*() calls! Which will setup a default font for you.
	unsigned char* TexPixelsAlpha8;    // 1 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight
	unsigned int* TexPixelsRGBA32;    // 4 component per pixel, each component is unsigned 8-bit. Total size = TexWidth * TexHeight * 4
	int                         TexWidth;           // Texture width calculated during Build().
	int                         TexHeight;          // Texture height calculated during Build().
	ImVec2                      TexUvScale;         // = (1.0f/TexWidth, 1.0f/TexHeight)
	ImVec2                      TexUvWhitePixel;    // Texture coordinates to a white pixel
	ImVector<ImFont*>           Fonts;              // Hold all the fonts returned by AddFont*. Fonts[0] is the default font upon calling ImGui::NewFrame(), use ImGui::PushFont()/PopFont() to change the current font.
	ImVector<CustomRect>        CustomRects;        // Rectangles for packing custom texture data into the atlas.
	ImVector<ImFontConfig>      ConfigData;         // Internal data
	int                         CustomRectIds[1];   // Identifiers of custom texture rectangle used by ImFontAtlas/ImDrawList
};

// Font runtime data and rendering
// ImFontAtlas automatically loads a default embedded font for you when you call GetTexDataAsAlpha8() or GetTexDataAsRGBA32().
struct ImFont
{
	// Members: Hot ~62/78 bytes
	float                       FontSize;           // <user set>   // Height of characters, set during loading (don't change after loading)
	float                       Scale;              // = 1.f        // Base font scale, multiplied by the per-window font scale which you can adjust with SetFontScale()
	ImVec2                      DisplayOffset;      // = (0.f,0.f)  // Offset font rendering by xx pixels
	ImVector<ImFontGlyph>       Glyphs;             //              // All glyphs.
	ImVector<float>             IndexAdvanceX;      //              // Sparse. Glyphs->AdvanceX in a directly indexable way (more cache-friendly, for CalcTextSize functions which are often bottleneck in large UI).
	ImVector<unsigned short>    IndexLookup;        //              // Sparse. Index glyphs by Unicode code-point.
	const ImFontGlyph* FallbackGlyph;      // == FindGlyph(FontFallbackChar)
	float                       FallbackAdvanceX;   // == FallbackGlyph->AdvanceX
	ImWchar                     FallbackChar;       // = '?'        // Replacement glyph if one isn't found. Only set via SetFallbackChar()

													// Members: Cold ~18/26 bytes
	short                       ConfigDataCount;    // ~ 1          // Number of ImFontConfig involved in creating this font. Bigger than 1 when merging multiple font sources into one ImFont.
	ImFontConfig* ConfigData;         //              // Pointer within ContainerAtlas->ConfigData
	ImFontAtlas* ContainerAtlas;     //              // What we has been loaded into
	float                       Ascent, Descent;    //              // Ascent: distance from top to bottom of e.g. 'A' [0..FontSize]
	bool                        DirtyLookupTables;
	int                         MetricsTotalSurface;//              // Total surface in pixels to get an idea of the font rasterization/texture cost (not exact, we approximate the cost of padding between glyphs)

													// Methods
	IMGUI_API ImFont();
	IMGUI_API ~ImFont();
	IMGUI_API void              ClearOutputData();
	IMGUI_API void              BuildLookupTable();
	IMGUI_API const ImFontGlyph* FindGlyph(ImWchar c) const;
	IMGUI_API const ImFontGlyph* FindGlyphNoFallback(ImWchar c) const;
	IMGUI_API void              SetFallbackChar(ImWchar c);
	float                       GetCharAdvance(ImWchar c) const { return ((int)c < IndexAdvanceX.Size) ? IndexAdvanceX[(int)c] : FallbackAdvanceX; }
	bool                        IsLoaded() const { return ContainerAtlas != NULL; }
	const char* GetDebugName() const { return ConfigData ? ConfigData->Name : "<unknown>"; }

	// 'max_width' stops rendering after a certain width (could be turned into a 2d size). FLT_MAX to disable.
	// 'wrap_width' enable automatic word-wrapping across multiple lines to fit into given width. 0.0f to disable.
	IMGUI_API ImVec2            CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end = NULL, const char** remaining = NULL) const; // utf8
	IMGUI_API const char* CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const;
	IMGUI_API void              RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const;
	IMGUI_API void              RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width = 0.0f, bool cpu_fine_clip = false) const;

	// [Internal]
	IMGUI_API void              GrowIndex(int new_size);
	IMGUI_API void              AddGlyph(ImWchar c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);
	IMGUI_API void              AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst = true); // Makes 'dst' character/glyph points to 'src' character/glyph. Currently needs to be called AFTER fonts have been built.

#ifndef IMGUI_DISABLE_OBSOLETE_FUNCTIONS
	typedef ImFontGlyph Glyph; // OBSOLETE 1.52+
#endif
};

#if defined(__clang__)
#pragma clang diagnostic pop
#endif

// Include imgui_user.h at the end of imgui.h (convenient for user to only explicitly include vanilla imgui.h)
#ifdef IMGUI_INCLUDE_IMGUI_USER_H
#include "imgui_user.h"
#endif

```

`src/imgui/imgui_draw.cpp`:

```cpp
// dear imgui, v1.60
// (drawing and font code)

// Contains implementation for
// - Default styles
// - ImDrawList
// - ImDrawData
// - ImFontAtlas
// - ImFont
// - Default font data

#if defined(_MSC_VER) && !defined(_CRT_SECURE_NO_WARNINGS)
#define _CRT_SECURE_NO_WARNINGS
#endif

#include "imgui.h"
#define IMGUI_DEFINE_MATH_OPERATORS
#include "imgui_internal.h"

#include <stdio.h>      // vsnprintf, sscanf, printf
#if !defined(alloca)
#ifdef _WIN32
#include <malloc.h>     // alloca
#if !defined(alloca)
#define alloca _alloca  // for clang with MS Codegen
#endif
#elif defined(__GLIBC__) || defined(__sun)
#include <alloca.h>     // alloca
#else
#include <stdlib.h>     // alloca
#endif
#endif

#ifdef _MSC_VER
#pragma warning (disable: 4505) // unreferenced local function has been removed (stb stuff)
#pragma warning (disable: 4996) // 'This function or variable may be unsafe': strcpy, strdup, sprintf, vsnprintf, sscanf, fopen
#endif

#ifdef __clang__
#pragma clang diagnostic ignored "-Wold-style-cast"         // warning : use of old-style cast                              // yes, they are more terse.
#pragma clang diagnostic ignored "-Wfloat-equal"            // warning : comparing floating point with == or != is unsafe   // storing and comparing against same constants ok.
#pragma clang diagnostic ignored "-Wglobal-constructors"    // warning : declaration requires a global destructor           // similar to above, not sure what the exact difference it.
#pragma clang diagnostic ignored "-Wsign-conversion"        // warning : implicit conversion changes signedness             //
#if __has_warning("-Wcomma")
#pragma clang diagnostic ignored "-Wcomma"                  // warning : possible misuse of comma operator here             //
#endif
#if __has_warning("-Wreserved-id-macro")
#pragma clang diagnostic ignored "-Wreserved-id-macro"      // warning : macro name is a reserved identifier                //
#endif
#if __has_warning("-Wdouble-promotion")
#pragma clang diagnostic ignored "-Wdouble-promotion"       // warning: implicit conversion from 'float' to 'double' when passing argument to function
#endif
#elif defined(__GNUC__)
#pragma GCC diagnostic ignored "-Wunused-function"          // warning: 'xxxx' defined but not used
#pragma GCC diagnostic ignored "-Wdouble-promotion"         // warning: implicit conversion from 'float' to 'double' when passing argument to function
#pragma GCC diagnostic ignored "-Wconversion"               // warning: conversion to 'xxxx' from 'xxxx' may alter its value
#endif

//-------------------------------------------------------------------------
// STB libraries implementation
//-------------------------------------------------------------------------

// Compile time options:
//#define IMGUI_STB_NAMESPACE           ImGuiStb
//#define IMGUI_STB_TRUETYPE_FILENAME   "my_folder/stb_truetype.h"
//#define IMGUI_STB_RECT_PACK_FILENAME  "my_folder/stb_rect_pack.h"
//#define IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
//#define IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION

#ifdef IMGUI_STB_NAMESPACE
namespace IMGUI_STB_NAMESPACE
{
#endif

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4456)                             // declaration of 'xx' hides previous local declaration
#endif

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"
#pragma clang diagnostic ignored "-Wmissing-prototypes"
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#pragma clang diagnostic ignored "-Wcast-qual"              // warning : cast from 'const xxxx *' to 'xxx *' drops const qualifier //
#endif

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wtype-limits"              // warning: comparison is always true due to limited range of data type [-Wtype-limits]
#pragma GCC diagnostic ignored "-Wcast-qual"                // warning: cast from type 'const xxxx *' to type 'xxxx *' casts away qualifiers
#endif

#ifndef IMGUI_DISABLE_STB_RECT_PACK_IMPLEMENTATION
#define STBRP_STATIC
#define STBRP_ASSERT(x)    IM_ASSERT(x)
#define STB_RECT_PACK_IMPLEMENTATION
#endif
#ifdef IMGUI_STB_RECT_PACK_FILENAME
#include IMGUI_STB_RECT_PACK_FILENAME
#else
#include "stb_rect_pack.h"
#endif

#ifndef IMGUI_DISABLE_STB_TRUETYPE_IMPLEMENTATION
#define STBTT_malloc(x,u)  ((void)(u), ImGui::MemAlloc(x))
#define STBTT_free(x,u)    ((void)(u), ImGui::MemFree(x))
#define STBTT_assert(x)    IM_ASSERT(x)
#define STBTT_STATIC
#define STB_TRUETYPE_IMPLEMENTATION
#else
#define STBTT_DEF extern
#endif
#ifdef IMGUI_STB_TRUETYPE_FILENAME
#include IMGUI_STB_TRUETYPE_FILENAME
#else
#include "stb_truetype.h"
#endif

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning (pop)
#endif

#ifdef IMGUI_STB_NAMESPACE
} // namespace ImGuiStb
using namespace IMGUI_STB_NAMESPACE;
#endif

#include "../settings/globals.h"

//-----------------------------------------------------------------------------
// Style functions
//-----------------------------------------------------------------------------

void ImGui::StyleColorsDark(ImGuiStyle* dst)
{
	ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
	ImVec4* colors = style->Colors;

	colors[ImGuiCol_Text] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
	colors[ImGuiCol_TextDisabled] = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
	colors[ImGuiCol_WindowBg] = ImVec4(0.06f, 0.06f, 0.06f, 0.94f);
	colors[ImGuiCol_ChildBg] = ImVec4(1.00f, 1.00f, 1.00f, 0.00f);
	colors[ImGuiCol_PopupBg] = ImVec4(0.08f, 0.08f, 0.08f, 0.94f);
	colors[ImGuiCol_Border] = ImVec4(0.43f, 0.43f, 0.50f, 0.50f);
	colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_FrameBg] = ImVec4(0.16f, 0.29f, 0.48f, 0.54f);
	colors[ImGuiCol_FrameBgHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
	colors[ImGuiCol_FrameBgActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
	colors[ImGuiCol_TitleBg] = ImVec4(0.04f, 0.04f, 0.04f, 1.00f);
	colors[ImGuiCol_TitleBgActive] = ImVec4(0.16f, 0.29f, 0.48f, 1.00f);
	colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.00f, 0.00f, 0.00f, 0.51f);
	colors[ImGuiCol_MenuBarBg] = ImVec4(0.14f, 0.14f, 0.14f, 1.00f);
	colors[ImGuiCol_ScrollbarBg] = ImVec4(0.02f, 0.02f, 0.02f, 0.53f);
	colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.31f, 0.31f, 0.31f, 1.00f);
	colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.41f, 0.41f, 0.41f, 1.00f);
	colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.51f, 0.51f, 0.51f, 1.00f);
	colors[ImGuiCol_CheckMark] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_SliderGrab] = ImVec4(0.24f, 0.52f, 0.88f, 1.00f);
	colors[ImGuiCol_SliderGrabActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_Button] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
	colors[ImGuiCol_ButtonHovered] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_ButtonActive] = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
	colors[ImGuiCol_Header] = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
	colors[ImGuiCol_HeaderHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
	colors[ImGuiCol_HeaderActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_Separator] = colors[ImGuiCol_Border];
	colors[ImGuiCol_SeparatorHovered] = ImVec4(0.10f, 0.40f, 0.75f, 0.78f);
	colors[ImGuiCol_SeparatorActive] = ImVec4(0.10f, 0.40f, 0.75f, 1.00f);
	colors[ImGuiCol_ResizeGrip] = ImVec4(0.26f, 0.59f, 0.98f, 0.25f);
	colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
	colors[ImGuiCol_ResizeGripActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
	colors[ImGuiCol_PlotLines] = ImVec4(0.61f, 0.61f, 0.61f, 1.00f);
	colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
	colors[ImGuiCol_PlotHistogram] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
	colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
	colors[ImGuiCol_TextSelectedBg] = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
	colors[ImGuiCol_ModalWindowDarkening] = ImVec4(0.80f, 0.80f, 0.80f, 0.35f);
	colors[ImGuiCol_DragDropTarget] = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
	colors[ImGuiCol_NavHighlight] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
}

void ImGui::StyleColorsClassic(ImGuiStyle* dst)
{
	ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
	ImVec4* colors = style->Colors;

	colors[ImGuiCol_Text] = ImVec4(0.90f, 0.90f, 0.90f, 1.00f);
	colors[ImGuiCol_TextDisabled] = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
	colors[ImGuiCol_WindowBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.70f);
	colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_PopupBg] = ImVec4(0.11f, 0.11f, 0.14f, 0.92f);
	colors[ImGuiCol_Border] = ImVec4(0.50f, 0.50f, 0.50f, 0.50f);
	colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_FrameBg] = ImVec4(0.43f, 0.43f, 0.43f, 0.39f);
	colors[ImGuiCol_FrameBgHovered] = ImVec4(0.47f, 0.47f, 0.69f, 0.40f);
	colors[ImGuiCol_FrameBgActive] = ImVec4(0.42f, 0.41f, 0.64f, 0.69f);
	colors[ImGuiCol_TitleBg] = ImVec4(0.27f, 0.27f, 0.54f, 0.83f);
	colors[ImGuiCol_TitleBgActive] = ImVec4(0.32f, 0.32f, 0.63f, 0.87f);
	colors[ImGuiCol_TitleBgCollapsed] = ImVec4(0.40f, 0.40f, 0.80f, 0.20f);
	colors[ImGuiCol_MenuBarBg] = ImVec4(0.40f, 0.40f, 0.55f, 0.80f);
	colors[ImGuiCol_ScrollbarBg] = ImVec4(0.20f, 0.25f, 0.30f, 0.60f);
	colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.40f, 0.40f, 0.80f, 0.30f);
	colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.40f, 0.40f, 0.80f, 0.40f);
	colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
	colors[ImGuiCol_CheckMark] = ImVec4(0.90f, 0.90f, 0.90f, 0.50f);
	colors[ImGuiCol_SliderGrab] = ImVec4(1.00f, 1.00f, 1.00f, 0.30f);
	colors[ImGuiCol_SliderGrabActive] = ImVec4(0.41f, 0.39f, 0.80f, 0.60f);
	colors[ImGuiCol_Button] = ImVec4(0.35f, 0.40f, 0.61f, 0.62f);
	colors[ImGuiCol_ButtonHovered] = ImVec4(0.40f, 0.48f, 0.71f, 0.79f);
	colors[ImGuiCol_ButtonActive] = ImVec4(0.46f, 0.54f, 0.80f, 1.00f);
	colors[ImGuiCol_Header] = ImVec4(0.40f, 0.40f, 0.90f, 0.45f);
	colors[ImGuiCol_HeaderHovered] = ImVec4(0.45f, 0.45f, 0.90f, 0.80f);
	colors[ImGuiCol_HeaderActive] = ImVec4(0.53f, 0.53f, 0.87f, 0.80f);
	colors[ImGuiCol_Separator] = ImVec4(0.50f, 0.50f, 0.50f, 1.00f);
	colors[ImGuiCol_SeparatorHovered] = ImVec4(0.60f, 0.60f, 0.70f, 1.00f);
	colors[ImGuiCol_SeparatorActive] = ImVec4(0.70f, 0.70f, 0.90f, 1.00f);
	colors[ImGuiCol_ResizeGrip] = ImVec4(1.00f, 1.00f, 1.00f, 0.16f);
	colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.78f, 0.82f, 1.00f, 0.60f);
	colors[ImGuiCol_ResizeGripActive] = ImVec4(0.78f, 0.82f, 1.00f, 0.90f);
	colors[ImGuiCol_PlotLines] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
	colors[ImGuiCol_PlotLinesHovered] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
	colors[ImGuiCol_PlotHistogram] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
	colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.60f, 0.00f, 1.00f);
	colors[ImGuiCol_TextSelectedBg] = ImVec4(0.00f, 0.00f, 1.00f, 0.35f);
	colors[ImGuiCol_ModalWindowDarkening] = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
	colors[ImGuiCol_DragDropTarget] = ImVec4(1.00f, 1.00f, 0.00f, 0.90f);
	colors[ImGuiCol_NavHighlight] = colors[ImGuiCol_HeaderHovered];
	colors[ImGuiCol_NavWindowingHighlight] = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
}

// Those light colors are better suited with a thicker font than the default one + FrameBorder
void ImGui::StyleColorsLight(ImGuiStyle* dst)
{
	ImGuiStyle* style = dst ? dst : &ImGui::GetStyle();
	ImVec4* colors = style->Colors;

	colors[ImGuiCol_Text] = ImVec4(0.00f, 0.00f, 0.00f, 1.00f);
	colors[ImGuiCol_TextDisabled] = ImVec4(0.60f, 0.60f, 0.60f, 1.00f);
	//colors[ImGuiCol_TextHovered]          = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
	//colors[ImGuiCol_TextActive]           = ImVec4(1.00f, 1.00f, 0.00f, 1.00f);
	colors[ImGuiCol_WindowBg] = ImVec4(0.94f, 0.94f, 0.94f, 1.00f);
	colors[ImGuiCol_ChildBg] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_PopupBg] = ImVec4(1.00f, 1.00f, 1.00f, 0.98f);
	colors[ImGuiCol_Border] = ImVec4(0.00f, 0.00f, 0.00f, 0.30f);
	colors[ImGuiCol_BorderShadow] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
	colors[ImGuiCol_FrameBg] = ImVec4(1.00f, 1.00f, 1.00f, 1.00f);
	colors[ImGuiCol_FrameBgHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
	colors[ImGuiCol_FrameBgActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
	colors[ImGuiCol_TitleBg] = ImVec4(0.96f, 0.96f, 0.96f, 1.00f);
	colors[ImGuiCol_TitleBgActive] = ImVec4(0.82f, 0.82f, 0.82f, 1.00f);
	colors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.00f, 1.00f, 1.00f, 0.51f);
	colors[ImGuiCol_MenuBarBg] = ImVec4(0.86f, 0.86f, 0.86f, 1.00f);
	colors[ImGuiCol_ScrollbarBg] = ImVec4(0.98f, 0.98f, 0.98f, 0.53f);
	colors[ImGuiCol_ScrollbarGrab] = ImVec4(0.69f, 0.69f, 0.69f, 0.80f);
	colors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.49f, 0.49f, 0.49f, 0.80f);
	colors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.49f, 0.49f, 0.49f, 1.00f);
	colors[ImGuiCol_CheckMark] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_SliderGrab] = ImVec4(0.26f, 0.59f, 0.98f, 0.78f);
	colors[ImGuiCol_SliderGrabActive] = ImVec4(0.46f, 0.54f, 0.80f, 0.60f);
	colors[ImGuiCol_Button] = ImVec4(0.26f, 0.59f, 0.98f, 0.40f);
	colors[ImGuiCol_ButtonHovered] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_ButtonActive] = ImVec4(0.06f, 0.53f, 0.98f, 1.00f);
	colors[ImGuiCol_Header] = ImVec4(0.26f, 0.59f, 0.98f, 0.31f);
	colors[ImGuiCol_HeaderHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.80f);
	colors[ImGuiCol_HeaderActive] = ImVec4(0.26f, 0.59f, 0.98f, 1.00f);
	colors[ImGuiCol_Separator] = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
	colors[ImGuiCol_SeparatorHovered] = ImVec4(0.14f, 0.44f, 0.80f, 0.78f);
	colors[ImGuiCol_SeparatorActive] = ImVec4(0.14f, 0.44f, 0.80f, 1.00f);
	colors[ImGuiCol_ResizeGrip] = ImVec4(0.80f, 0.80f, 0.80f, 0.56f);
	colors[ImGuiCol_ResizeGripHovered] = ImVec4(0.26f, 0.59f, 0.98f, 0.67f);
	colors[ImGuiCol_ResizeGripActive] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
	colors[ImGuiCol_PlotLines] = ImVec4(0.39f, 0.39f, 0.39f, 1.00f);
	colors[ImGuiCol_PlotLinesHovered] = ImVec4(1.00f, 0.43f, 0.35f, 1.00f);
	colors[ImGuiCol_PlotHistogram] = ImVec4(0.90f, 0.70f, 0.00f, 1.00f);
	colors[ImGuiCol_PlotHistogramHovered] = ImVec4(1.00f, 0.45f, 0.00f, 1.00f);
	colors[ImGuiCol_TextSelectedBg] = ImVec4(0.26f, 0.59f, 0.98f, 0.35f);
	colors[ImGuiCol_ModalWindowDarkening] = ImVec4(0.20f, 0.20f, 0.20f, 0.35f);
	colors[ImGuiCol_DragDropTarget] = ImVec4(0.26f, 0.59f, 0.98f, 0.95f);
	colors[ImGuiCol_NavHighlight] = colors[ImGuiCol_HeaderHovered];
	colors[ImGuiCol_NavWindowingHighlight] = ImVec4(0.70f, 0.70f, 0.70f, 0.70f);
}

//-----------------------------------------------------------------------------
// ImDrawListData
//-----------------------------------------------------------------------------

ImDrawListSharedData::ImDrawListSharedData()
{
	Font = NULL;
	FontSize = 0.0f;
	CurveTessellationTol = 0.0f;
	ClipRectFullscreen = ImVec4(-8192.0f, -8192.0f, +8192.0f, +8192.0f);

	// Const data
	for (int i = 0; i < IM_ARRAYSIZE(CircleVtx12); i++)
	{
		const float a = ((float)i * 2 * IM_PI) / (float)IM_ARRAYSIZE(CircleVtx12);
		CircleVtx12[i] = ImVec2(cosf(a), sinf(a));
	}
}

//-----------------------------------------------------------------------------
// ImDrawList
//-----------------------------------------------------------------------------

void ImDrawList::Clear()
{
	CmdBuffer.resize(0);
	IdxBuffer.resize(0);
	VtxBuffer.resize(0);
	Flags = ImDrawListFlags_AntiAliasedLines | ImDrawListFlags_AntiAliasedFill;
	_VtxCurrentIdx = 0;
	_VtxWritePtr = NULL;
	_IdxWritePtr = NULL;
	_ClipRectStack.resize(0);
	_TextureIdStack.resize(0);
	_Path.resize(0);
	_ChannelsCurrent = 0;
	_ChannelsCount = 1;
	// NB: Do not clear channels so our allocations are re-used after the first frame.
}

void ImDrawList::ClearFreeMemory()
{
	CmdBuffer.clear();
	IdxBuffer.clear();
	VtxBuffer.clear();
	_VtxCurrentIdx = 0;
	_VtxWritePtr = NULL;
	_IdxWritePtr = NULL;
	_ClipRectStack.clear();
	_TextureIdStack.clear();
	_Path.clear();
	_ChannelsCurrent = 0;
	_ChannelsCount = 1;
	for (int i = 0; i < _Channels.Size; i++)
	{
		if (i == 0) memset(&_Channels[0], 0, sizeof(_Channels[0]));  // channel 0 is a copy of CmdBuffer/IdxBuffer, don't destruct again
		_Channels[i].CmdBuffer.clear();
		_Channels[i].IdxBuffer.clear();
	}
	_Channels.clear();
}

ImDrawList* ImDrawList::CloneOutput() const
{
	ImDrawList* dst = IM_NEW(ImDrawList(NULL));
	dst->CmdBuffer = CmdBuffer;
	dst->IdxBuffer = IdxBuffer;
	dst->VtxBuffer = VtxBuffer;
	dst->Flags = Flags;
	return dst;
}

// Using macros because C++ is a terrible language, we want guaranteed inline, no code in header, and no overhead in Debug builds
#define GetCurrentClipRect()    (_ClipRectStack.Size ? _ClipRectStack.Data[_ClipRectStack.Size-1]  : _Data->ClipRectFullscreen)
#define GetCurrentTextureId()   (_TextureIdStack.Size ? _TextureIdStack.Data[_TextureIdStack.Size-1] : NULL)

void ImDrawList::AddDrawCmd()
{
	ImDrawCmd draw_cmd;
	draw_cmd.ClipRect = GetCurrentClipRect();
	draw_cmd.TextureId = GetCurrentTextureId();

	IM_ASSERT(draw_cmd.ClipRect.x <= draw_cmd.ClipRect.z && draw_cmd.ClipRect.y <= draw_cmd.ClipRect.w);
	CmdBuffer.push_back(draw_cmd);
}

void ImDrawList::AddCallback(ImDrawCallback callback, void* callback_data)
{
	ImDrawCmd* current_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;
	if (!current_cmd || current_cmd->ElemCount != 0 || current_cmd->UserCallback != NULL)
	{
		AddDrawCmd();
		current_cmd = &CmdBuffer.back();
	}
	current_cmd->UserCallback = callback;
	current_cmd->UserCallbackData = callback_data;

	AddDrawCmd(); // Force a new command after us (see comment below)
}

// Our scheme may appears a bit unusual, basically we want the most-common calls AddLine AddRect etc. to not have to perform any check so we always have a command ready in the stack.
// The cost of figuring out if a new command has to be added or if we can merge is paid in those Update** functions only.
void ImDrawList::UpdateClipRect()
{
	// If current command is used with different settings we need to add a new command
	const ImVec4 curr_clip_rect = GetCurrentClipRect();
	ImDrawCmd* curr_cmd = CmdBuffer.Size > 0 ? &CmdBuffer.Data[CmdBuffer.Size - 1] : NULL;
	if (!curr_cmd || (curr_cmd->ElemCount != 0 && memcmp(&curr_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) != 0) || curr_cmd->UserCallback != NULL)
	{
		AddDrawCmd();
		return;
	}

	// Try to merge with previous command if it matches, else use current command
	ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;
	if (curr_cmd->ElemCount == 0 && prev_cmd && memcmp(&prev_cmd->ClipRect, &curr_clip_rect, sizeof(ImVec4)) == 0 && prev_cmd->TextureId == GetCurrentTextureId() && prev_cmd->UserCallback == NULL)
		CmdBuffer.pop_back();
	else
		curr_cmd->ClipRect = curr_clip_rect;
}

void ImDrawList::UpdateTextureID()
{
	// If current command is used with different settings we need to add a new command
	const ImTextureID curr_texture_id = GetCurrentTextureId();
	ImDrawCmd* curr_cmd = CmdBuffer.Size ? &CmdBuffer.back() : NULL;
	if (!curr_cmd || (curr_cmd->ElemCount != 0 && curr_cmd->TextureId != curr_texture_id) || curr_cmd->UserCallback != NULL)
	{
		AddDrawCmd();
		return;
	}

	// Try to merge with previous command if it matches, else use current command
	ImDrawCmd* prev_cmd = CmdBuffer.Size > 1 ? curr_cmd - 1 : NULL;
	if (curr_cmd->ElemCount == 0 && prev_cmd && prev_cmd->TextureId == curr_texture_id && memcmp(&prev_cmd->ClipRect, &GetCurrentClipRect(), sizeof(ImVec4)) == 0 && prev_cmd->UserCallback == NULL)
		CmdBuffer.pop_back();
	else
		curr_cmd->TextureId = curr_texture_id;
}

#undef GetCurrentClipRect
#undef GetCurrentTextureId

// Render-level scissoring. This is passed down to your render function but not used for CPU-side coarse clipping. Prefer using higher-level ImGui::PushClipRect() to affect logic (hit-testing and widget culling)
void ImDrawList::PushClipRect(ImVec2 cr_min, ImVec2 cr_max, bool intersect_with_current_clip_rect)
{
	ImVec4 cr(cr_min.x, cr_min.y, cr_max.x, cr_max.y);
	if (intersect_with_current_clip_rect && _ClipRectStack.Size)
	{
		ImVec4 current = _ClipRectStack.Data[_ClipRectStack.Size - 1];
		if (cr.x < current.x) cr.x = current.x;
		if (cr.y < current.y) cr.y = current.y;
		if (cr.z > current.z) cr.z = current.z;
		if (cr.w > current.w) cr.w = current.w;
	}
	cr.z = ImMax(cr.x, cr.z);
	cr.w = ImMax(cr.y, cr.w);

	_ClipRectStack.push_back(cr);
	UpdateClipRect();
}

void ImDrawList::PushClipRectFullScreen()
{
	PushClipRect(ImVec2(_Data->ClipRectFullscreen.x, _Data->ClipRectFullscreen.y), ImVec2(_Data->ClipRectFullscreen.z, _Data->ClipRectFullscreen.w));
}

void ImDrawList::PopClipRect()
{
	IM_ASSERT(_ClipRectStack.Size > 0);
	_ClipRectStack.pop_back();
	UpdateClipRect();
}

void ImDrawList::PushTextureID(ImTextureID texture_id)
{
	_TextureIdStack.push_back(texture_id);
	UpdateTextureID();
}

void ImDrawList::PopTextureID()
{
	IM_ASSERT(_TextureIdStack.Size > 0);
	_TextureIdStack.pop_back();
	UpdateTextureID();
}

void ImDrawList::ChannelsSplit(int channels_count)
{
	IM_ASSERT(_ChannelsCurrent == 0 && _ChannelsCount == 1);
	int old_channels_count = _Channels.Size;
	if (old_channels_count < channels_count)
		_Channels.resize(channels_count);
	_ChannelsCount = channels_count;

	// _Channels[] (24/32 bytes each) hold storage that we'll swap with this->_CmdBuffer/_IdxBuffer
	// The content of _Channels[0] at this point doesn't matter. We clear it to make state tidy in a debugger but we don't strictly need to.
	// When we switch to the next channel, we'll copy _CmdBuffer/_IdxBuffer into _Channels[0] and then _Channels[1] into _CmdBuffer/_IdxBuffer
	memset(&_Channels[0], 0, sizeof(ImDrawChannel));
	for (int i = 1; i < channels_count; i++)
	{
		if (i >= old_channels_count)
		{
			IM_PLACEMENT_NEW(&_Channels[i]) ImDrawChannel();
		}
		else
		{
			_Channels[i].CmdBuffer.resize(0);
			_Channels[i].IdxBuffer.resize(0);
		}
		if (_Channels[i].CmdBuffer.Size == 0)
		{
			ImDrawCmd draw_cmd;
			draw_cmd.ClipRect = _ClipRectStack.back();
			draw_cmd.TextureId = _TextureIdStack.back();
			_Channels[i].CmdBuffer.push_back(draw_cmd);
		}
	}
}

void ImDrawList::ChannelsMerge()
{
	// Note that we never use or rely on channels.Size because it is merely a buffer that we never shrink back to 0 to keep all sub-buffers ready for use.
	if (_ChannelsCount <= 1)
		return;

	ChannelsSetCurrent(0);
	if (CmdBuffer.Size && CmdBuffer.back().ElemCount == 0)
		CmdBuffer.pop_back();

	int new_cmd_buffer_count = 0, new_idx_buffer_count = 0;
	for (int i = 1; i < _ChannelsCount; i++)
	{
		ImDrawChannel& ch = _Channels[i];
		if (ch.CmdBuffer.Size && ch.CmdBuffer.back().ElemCount == 0)
			ch.CmdBuffer.pop_back();
		new_cmd_buffer_count += ch.CmdBuffer.Size;
		new_idx_buffer_count += ch.IdxBuffer.Size;
	}
	CmdBuffer.resize(CmdBuffer.Size + new_cmd_buffer_count);
	IdxBuffer.resize(IdxBuffer.Size + new_idx_buffer_count);

	ImDrawCmd* cmd_write = CmdBuffer.Data + CmdBuffer.Size - new_cmd_buffer_count;
	_IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size - new_idx_buffer_count;
	for (int i = 1; i < _ChannelsCount; i++)
	{
		ImDrawChannel& ch = _Channels[i];
		if (int sz = ch.CmdBuffer.Size) { memcpy(cmd_write, ch.CmdBuffer.Data, sz * sizeof(ImDrawCmd)); cmd_write += sz; }
		if (int sz = ch.IdxBuffer.Size) { memcpy(_IdxWritePtr, ch.IdxBuffer.Data, sz * sizeof(ImDrawIdx)); _IdxWritePtr += sz; }
	}
	UpdateClipRect(); // We call this instead of AddDrawCmd(), so that empty channels won't produce an extra draw call.
	_ChannelsCount = 1;
}

void ImDrawList::ChannelsSetCurrent(int idx)
{
	IM_ASSERT(idx < _ChannelsCount);
	if (_ChannelsCurrent == idx) return;
	memcpy(&_Channels.Data[_ChannelsCurrent].CmdBuffer, &CmdBuffer, sizeof(CmdBuffer)); // copy 12 bytes, four times
	memcpy(&_Channels.Data[_ChannelsCurrent].IdxBuffer, &IdxBuffer, sizeof(IdxBuffer));
	_ChannelsCurrent = idx;
	memcpy(&CmdBuffer, &_Channels.Data[_ChannelsCurrent].CmdBuffer, sizeof(CmdBuffer));
	memcpy(&IdxBuffer, &_Channels.Data[_ChannelsCurrent].IdxBuffer, sizeof(IdxBuffer));
	_IdxWritePtr = IdxBuffer.Data + IdxBuffer.Size;
}

// NB: this can be called with negative count for removing primitives (as long as the result does not underflow)
void ImDrawList::PrimReserve(int idx_count, int vtx_count)
{
	ImDrawCmd& draw_cmd = CmdBuffer.Data[CmdBuffer.Size - 1];
	draw_cmd.ElemCount += idx_count;

	int vtx_buffer_old_size = VtxBuffer.Size;
	VtxBuffer.resize(vtx_buffer_old_size + vtx_count);
	_VtxWritePtr = VtxBuffer.Data + vtx_buffer_old_size;

	int idx_buffer_old_size = IdxBuffer.Size;
	IdxBuffer.resize(idx_buffer_old_size + idx_count);
	_IdxWritePtr = IdxBuffer.Data + idx_buffer_old_size;
}

// Fully unrolled with inline call to keep our debug builds decently fast.
void ImDrawList::PrimRect(const ImVec2& a, const ImVec2& c, ImU32 col)
{
	ImVec2 b(c.x, a.y), d(a.x, c.y), uv(_Data->TexUvWhitePixel);
	ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
	_IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);
	_IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx + 3);
	_VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
	_VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
	_VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
	_VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
	_VtxWritePtr += 4;
	_VtxCurrentIdx += 4;
	_IdxWritePtr += 6;
}

void ImDrawList::PrimRectUV(const ImVec2& a, const ImVec2& c, const ImVec2& uv_a, const ImVec2& uv_c, ImU32 col)
{
	ImVec2 b(c.x, a.y), d(a.x, c.y), uv_b(uv_c.x, uv_a.y), uv_d(uv_a.x, uv_c.y);
	ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
	_IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);
	_IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx + 3);
	_VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
	_VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
	_VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;
	_VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;
	_VtxWritePtr += 4;
	_VtxCurrentIdx += 4;
	_IdxWritePtr += 6;
}

void ImDrawList::PrimQuadUV(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
{
	ImDrawIdx idx = (ImDrawIdx)_VtxCurrentIdx;
	_IdxWritePtr[0] = idx; _IdxWritePtr[1] = (ImDrawIdx)(idx + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx + 2);
	_IdxWritePtr[3] = idx; _IdxWritePtr[4] = (ImDrawIdx)(idx + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx + 3);
	_VtxWritePtr[0].pos = a; _VtxWritePtr[0].uv = uv_a; _VtxWritePtr[0].col = col;
	_VtxWritePtr[1].pos = b; _VtxWritePtr[1].uv = uv_b; _VtxWritePtr[1].col = col;
	_VtxWritePtr[2].pos = c; _VtxWritePtr[2].uv = uv_c; _VtxWritePtr[2].col = col;
	_VtxWritePtr[3].pos = d; _VtxWritePtr[3].uv = uv_d; _VtxWritePtr[3].col = col;
	_VtxWritePtr += 4;
	_VtxCurrentIdx += 4;
	_IdxWritePtr += 6;
}

// TODO: Thickness anti-aliased lines cap are missing their AA fringe.
void ImDrawList::AddPolyline(const ImVec2* points, const int points_count, ImU32 col, bool closed, float thickness)
{
	if (points_count < 2)
		return;

	const ImVec2 uv = _Data->TexUvWhitePixel;

	int count = points_count;
	if (!closed)
		count = points_count - 1;

	const bool thick_line = thickness > 1.0f;
	if (Flags & ImDrawListFlags_AntiAliasedLines)
	{
		// Anti-aliased stroke
		const float AA_SIZE = 1.0f;
		const ImU32 col_trans = col & ~IM_COL32_A_MASK;

		const int idx_count = thick_line ? count * 18 : count * 12;
		const int vtx_count = thick_line ? points_count * 4 : points_count * 3;
		PrimReserve(idx_count, vtx_count);

		// Temporary buffer
		ImVec2* temp_normals = (ImVec2*)alloca(points_count * (thick_line ? 5 : 3) * sizeof(ImVec2));
		ImVec2* temp_points = temp_normals + points_count;

		for (int i1 = 0; i1 < count; i1++)
		{
			const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
			ImVec2 diff = points[i2] - points[i1];
			diff *= ImInvLength(diff, 1.0f);
			temp_normals[i1].x = diff.y;
			temp_normals[i1].y = -diff.x;
		}
		if (!closed)
			temp_normals[points_count - 1] = temp_normals[points_count - 2];

		if (!thick_line)
		{
			if (!closed)
			{
				temp_points[0] = points[0] + temp_normals[0] * AA_SIZE;
				temp_points[1] = points[0] - temp_normals[0] * AA_SIZE;
				temp_points[(points_count - 1) * 2 + 0] = points[points_count - 1] + temp_normals[points_count - 1] * AA_SIZE;
				temp_points[(points_count - 1) * 2 + 1] = points[points_count - 1] - temp_normals[points_count - 1] * AA_SIZE;
			}

			// FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
			unsigned int idx1 = _VtxCurrentIdx;
			for (int i1 = 0; i1 < count; i1++)
			{
				const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
				unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : idx1 + 3;

				// Average normals
				ImVec2 dm = (temp_normals[i1] + temp_normals[i2]) * 0.5f;
				float dmr2 = dm.x * dm.x + dm.y * dm.y;
				if (dmr2 > 0.000001f)
				{
					float scale = 1.0f / dmr2;
					if (scale > 100.0f) scale = 100.0f;
					dm *= scale;
				}
				dm *= AA_SIZE;
				temp_points[i2 * 2 + 0] = points[i2] + dm;
				temp_points[i2 * 2 + 1] = points[i2] - dm;

				// Add indexes
				_IdxWritePtr[0] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2);
				_IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 0);
				_IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0);
				_IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);
				_IdxWritePtr += 12;

				idx1 = idx2;
			}

			// Add vertexes
			for (int i = 0; i < points_count; i++)
			{
				_VtxWritePtr[0].pos = points[i];          _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
				_VtxWritePtr[1].pos = temp_points[i * 2 + 0]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;
				_VtxWritePtr[2].pos = temp_points[i * 2 + 1]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col_trans;
				_VtxWritePtr += 3;
			}
		}
		else
		{
			const float half_inner_thickness = (thickness - AA_SIZE) * 0.5f;
			if (!closed)
			{
				temp_points[0] = points[0] + temp_normals[0] * (half_inner_thickness + AA_SIZE);
				temp_points[1] = points[0] + temp_normals[0] * (half_inner_thickness);
				temp_points[2] = points[0] - temp_normals[0] * (half_inner_thickness);
				temp_points[3] = points[0] - temp_normals[0] * (half_inner_thickness + AA_SIZE);
				temp_points[(points_count - 1) * 4 + 0] = points[points_count - 1] + temp_normals[points_count - 1] * (half_inner_thickness + AA_SIZE);
				temp_points[(points_count - 1) * 4 + 1] = points[points_count - 1] + temp_normals[points_count - 1] * (half_inner_thickness);
				temp_points[(points_count - 1) * 4 + 2] = points[points_count - 1] - temp_normals[points_count - 1] * (half_inner_thickness);
				temp_points[(points_count - 1) * 4 + 3] = points[points_count - 1] - temp_normals[points_count - 1] * (half_inner_thickness + AA_SIZE);
			}

			// FIXME-OPT: Merge the different loops, possibly remove the temporary buffer.
			unsigned int idx1 = _VtxCurrentIdx;
			for (int i1 = 0; i1 < count; i1++)
			{
				const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
				unsigned int idx2 = (i1 + 1) == points_count ? _VtxCurrentIdx : idx1 + 4;

				// Average normals
				ImVec2 dm = (temp_normals[i1] + temp_normals[i2]) * 0.5f;
				float dmr2 = dm.x * dm.x + dm.y * dm.y;
				if (dmr2 > 0.000001f)
				{
					float scale = 1.0f / dmr2;
					if (scale > 100.0f) scale = 100.0f;
					dm *= scale;
				}
				ImVec2 dm_out = dm * (half_inner_thickness + AA_SIZE);
				ImVec2 dm_in = dm * half_inner_thickness;
				temp_points[i2 * 4 + 0] = points[i2] + dm_out;
				temp_points[i2 * 4 + 1] = points[i2] + dm_in;
				temp_points[i2 * 4 + 2] = points[i2] - dm_in;
				temp_points[i2 * 4 + 3] = points[i2] - dm_out;

				// Add indexes
				_IdxWritePtr[0] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[1] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[2] = (ImDrawIdx)(idx1 + 2);
				_IdxWritePtr[3] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[4] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[5] = (ImDrawIdx)(idx2 + 1);
				_IdxWritePtr[6] = (ImDrawIdx)(idx2 + 1); _IdxWritePtr[7] = (ImDrawIdx)(idx1 + 1); _IdxWritePtr[8] = (ImDrawIdx)(idx1 + 0);
				_IdxWritePtr[9] = (ImDrawIdx)(idx1 + 0); _IdxWritePtr[10] = (ImDrawIdx)(idx2 + 0); _IdxWritePtr[11] = (ImDrawIdx)(idx2 + 1);
				_IdxWritePtr[12] = (ImDrawIdx)(idx2 + 2); _IdxWritePtr[13] = (ImDrawIdx)(idx1 + 2); _IdxWritePtr[14] = (ImDrawIdx)(idx1 + 3);
				_IdxWritePtr[15] = (ImDrawIdx)(idx1 + 3); _IdxWritePtr[16] = (ImDrawIdx)(idx2 + 3); _IdxWritePtr[17] = (ImDrawIdx)(idx2 + 2);
				_IdxWritePtr += 18;

				idx1 = idx2;
			}

			// Add vertexes
			for (int i = 0; i < points_count; i++)
			{
				_VtxWritePtr[0].pos = temp_points[i * 4 + 0]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col_trans;
				_VtxWritePtr[1].pos = temp_points[i * 4 + 1]; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
				_VtxWritePtr[2].pos = temp_points[i * 4 + 2]; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
				_VtxWritePtr[3].pos = temp_points[i * 4 + 3]; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col_trans;
				_VtxWritePtr += 4;
			}
		}
		_VtxCurrentIdx += (ImDrawIdx)vtx_count;
	}
	else
	{
		// Non Anti-aliased Stroke
		const int idx_count = count * 6;
		const int vtx_count = count * 4;      // FIXME-OPT: Not sharing edges
		PrimReserve(idx_count, vtx_count);

		for (int i1 = 0; i1 < count; i1++)
		{
			const int i2 = (i1 + 1) == points_count ? 0 : i1 + 1;
			const ImVec2& p1 = points[i1];
			const ImVec2& p2 = points[i2];
			ImVec2 diff = p2 - p1;
			diff *= ImInvLength(diff, 1.0f);

			const float dx = diff.x * (thickness * 0.5f);
			const float dy = diff.y * (thickness * 0.5f);
			_VtxWritePtr[0].pos.x = p1.x + dy; _VtxWritePtr[0].pos.y = p1.y - dx; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
			_VtxWritePtr[1].pos.x = p2.x + dy; _VtxWritePtr[1].pos.y = p2.y - dx; _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col;
			_VtxWritePtr[2].pos.x = p2.x - dy; _VtxWritePtr[2].pos.y = p2.y + dx; _VtxWritePtr[2].uv = uv; _VtxWritePtr[2].col = col;
			_VtxWritePtr[3].pos.x = p1.x - dy; _VtxWritePtr[3].pos.y = p1.y + dx; _VtxWritePtr[3].uv = uv; _VtxWritePtr[3].col = col;
			_VtxWritePtr += 4;

			_IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + 2);
			_IdxWritePtr[3] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[4] = (ImDrawIdx)(_VtxCurrentIdx + 2); _IdxWritePtr[5] = (ImDrawIdx)(_VtxCurrentIdx + 3);
			_IdxWritePtr += 6;
			_VtxCurrentIdx += 4;
		}
	}
}

void ImDrawList::AddConvexPolyFilled(const ImVec2* points, const int points_count, ImU32 col)
{
	const ImVec2 uv = _Data->TexUvWhitePixel;

	if (Flags & ImDrawListFlags_AntiAliasedFill)
	{
		// Anti-aliased Fill
		const float AA_SIZE = 1.0f;
		const ImU32 col_trans = col & ~IM_COL32_A_MASK;
		const int idx_count = (points_count - 2) * 3 + points_count * 6;
		const int vtx_count = (points_count * 2);
		PrimReserve(idx_count, vtx_count);

		// Add indexes for fill
		unsigned int vtx_inner_idx = _VtxCurrentIdx;
		unsigned int vtx_outer_idx = _VtxCurrentIdx + 1;
		for (int i = 2; i < points_count; i++)
		{
			_IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + ((i - 1) << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_inner_idx + (i << 1));
			_IdxWritePtr += 3;
		}

		// Compute normals
		ImVec2* temp_normals = (ImVec2*)alloca(points_count * sizeof(ImVec2));
		for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
		{
			const ImVec2& p0 = points[i0];
			const ImVec2& p1 = points[i1];
			ImVec2 diff = p1 - p0;
			diff *= ImInvLength(diff, 1.0f);
			temp_normals[i0].x = diff.y;
			temp_normals[i0].y = -diff.x;
		}

		for (int i0 = points_count - 1, i1 = 0; i1 < points_count; i0 = i1++)
		{
			// Average normals
			const ImVec2& n0 = temp_normals[i0];
			const ImVec2& n1 = temp_normals[i1];
			ImVec2 dm = (n0 + n1) * 0.5f;
			float dmr2 = dm.x * dm.x + dm.y * dm.y;
			if (dmr2 > 0.000001f)
			{
				float scale = 1.0f / dmr2;
				if (scale > 100.0f) scale = 100.0f;
				dm *= scale;
			}
			dm *= AA_SIZE * 0.5f;

			// Add vertices
			_VtxWritePtr[0].pos = (points[i1] - dm); _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;        // Inner
			_VtxWritePtr[1].pos = (points[i1] + dm); _VtxWritePtr[1].uv = uv; _VtxWritePtr[1].col = col_trans;  // Outer
			_VtxWritePtr += 2;

			// Add indexes for fringes
			_IdxWritePtr[0] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1)); _IdxWritePtr[1] = (ImDrawIdx)(vtx_inner_idx + (i0 << 1)); _IdxWritePtr[2] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1));
			_IdxWritePtr[3] = (ImDrawIdx)(vtx_outer_idx + (i0 << 1)); _IdxWritePtr[4] = (ImDrawIdx)(vtx_outer_idx + (i1 << 1)); _IdxWritePtr[5] = (ImDrawIdx)(vtx_inner_idx + (i1 << 1));
			_IdxWritePtr += 6;
		}
		_VtxCurrentIdx += (ImDrawIdx)vtx_count;
	}
	else
	{
		// Non Anti-aliased Fill
		const int idx_count = (points_count - 2) * 3;
		const int vtx_count = points_count;
		PrimReserve(idx_count, vtx_count);
		for (int i = 0; i < vtx_count; i++)
		{
			_VtxWritePtr[0].pos = points[i]; _VtxWritePtr[0].uv = uv; _VtxWritePtr[0].col = col;
			_VtxWritePtr++;
		}
		for (int i = 2; i < points_count; i++)
		{
			_IdxWritePtr[0] = (ImDrawIdx)(_VtxCurrentIdx); _IdxWritePtr[1] = (ImDrawIdx)(_VtxCurrentIdx + i - 1); _IdxWritePtr[2] = (ImDrawIdx)(_VtxCurrentIdx + i);
			_IdxWritePtr += 3;
		}
		_VtxCurrentIdx += (ImDrawIdx)vtx_count;
	}
}

void ImDrawList::PathArcToFast(const ImVec2& centre, float radius, int a_min_of_12, int a_max_of_12)
{
	if (radius == 0.0f || a_min_of_12 > a_max_of_12)
	{
		_Path.push_back(centre);
		return;
	}
	_Path.reserve(_Path.Size + (a_max_of_12 - a_min_of_12 + 1));
	for (int a = a_min_of_12; a <= a_max_of_12; a++)
	{
		const ImVec2& c = _Data->CircleVtx12[a % IM_ARRAYSIZE(_Data->CircleVtx12)];
		_Path.push_back(ImVec2(centre.x + c.x * radius, centre.y + c.y * radius));
	}
}

void ImDrawList::PathArcTo(const ImVec2& centre, float radius, float a_min, float a_max, int num_segments)
{
	if (radius == 0.0f)
	{
		_Path.push_back(centre);
		return;
	}
	_Path.reserve(_Path.Size + (num_segments + 1));
	for (int i = 0; i <= num_segments; i++)
	{
		const float a = a_min + ((float)i / (float)num_segments) * (a_max - a_min);
		_Path.push_back(ImVec2(centre.x + cosf(a) * radius, centre.y + sinf(a) * radius));
	}
}

static void PathBezierToCasteljau(ImVector<ImVec2>* path, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, float tess_tol, int level)
{
	float dx = x4 - x1;
	float dy = y4 - y1;
	float d2 = ((x2 - x4) * dy - (y2 - y4) * dx);
	float d3 = ((x3 - x4) * dy - (y3 - y4) * dx);
	d2 = (d2 >= 0) ? d2 : -d2;
	d3 = (d3 >= 0) ? d3 : -d3;
	if ((d2 + d3) * (d2 + d3) < tess_tol * (dx * dx + dy * dy))
	{
		path->push_back(ImVec2(x4, y4));
	}
	else if (level < 10)
	{
		float x12 = (x1 + x2) * 0.5f, y12 = (y1 + y2) * 0.5f;
		float x23 = (x2 + x3) * 0.5f, y23 = (y2 + y3) * 0.5f;
		float x34 = (x3 + x4) * 0.5f, y34 = (y3 + y4) * 0.5f;
		float x123 = (x12 + x23) * 0.5f, y123 = (y12 + y23) * 0.5f;
		float x234 = (x23 + x34) * 0.5f, y234 = (y23 + y34) * 0.5f;
		float x1234 = (x123 + x234) * 0.5f, y1234 = (y123 + y234) * 0.5f;

		PathBezierToCasteljau(path, x1, y1, x12, y12, x123, y123, x1234, y1234, tess_tol, level + 1);
		PathBezierToCasteljau(path, x1234, y1234, x234, y234, x34, y34, x4, y4, tess_tol, level + 1);
	}
}

void ImDrawList::PathBezierCurveTo(const ImVec2& p2, const ImVec2& p3, const ImVec2& p4, int num_segments)
{
	ImVec2 p1 = _Path.back();
	if (num_segments == 0)
	{
		// Auto-tessellated
		PathBezierToCasteljau(&_Path, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y, p4.x, p4.y, _Data->CurveTessellationTol, 0);
	}
	else
	{
		float t_step = 1.0f / (float)num_segments;
		for (int i_step = 1; i_step <= num_segments; i_step++)
		{
			float t = t_step * i_step;
			float u = 1.0f - t;
			float w1 = u * u * u;
			float w2 = 3 * u * u * t;
			float w3 = 3 * u * t * t;
			float w4 = t * t * t;
			_Path.push_back(ImVec2(w1 * p1.x + w2 * p2.x + w3 * p3.x + w4 * p4.x, w1 * p1.y + w2 * p2.y + w3 * p3.y + w4 * p4.y));
		}
	}
}

void ImDrawList::PathRect(const ImVec2& a, const ImVec2& b, float rounding, int rounding_corners)
{
	rounding = ImMin(rounding, fabsf(b.x - a.x) * (((rounding_corners & ImDrawCornerFlags_Top) == ImDrawCornerFlags_Top) || ((rounding_corners & ImDrawCornerFlags_Bot) == ImDrawCornerFlags_Bot) ? 0.5f : 1.0f) - 1.0f);
	rounding = ImMin(rounding, fabsf(b.y - a.y) * (((rounding_corners & ImDrawCornerFlags_Left) == ImDrawCornerFlags_Left) || ((rounding_corners & ImDrawCornerFlags_Right) == ImDrawCornerFlags_Right) ? 0.5f : 1.0f) - 1.0f);

	if (rounding <= 0.0f || rounding_corners == 0)
	{
		PathLineTo(a);
		PathLineTo(ImVec2(b.x, a.y));
		PathLineTo(b);
		PathLineTo(ImVec2(a.x, b.y));
	}
	else
	{
		const float rounding_tl = (rounding_corners & ImDrawCornerFlags_TopLeft) ? rounding : 0.0f;
		const float rounding_tr = (rounding_corners & ImDrawCornerFlags_TopRight) ? rounding : 0.0f;
		const float rounding_br = (rounding_corners & ImDrawCornerFlags_BotRight) ? rounding : 0.0f;
		const float rounding_bl = (rounding_corners & ImDrawCornerFlags_BotLeft) ? rounding : 0.0f;
		PathArcToFast(ImVec2(a.x + rounding_tl, a.y + rounding_tl), rounding_tl, 6, 9);
		PathArcToFast(ImVec2(b.x - rounding_tr, a.y + rounding_tr), rounding_tr, 9, 12);
		PathArcToFast(ImVec2(b.x - rounding_br, b.y - rounding_br), rounding_br, 0, 3);
		PathArcToFast(ImVec2(a.x + rounding_bl, b.y - rounding_bl), rounding_bl, 3, 6);
	}
}

void ImDrawList::AddLine(const ImVec2& a, const ImVec2& b, ImU32 col, float thickness)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;
	PathLineTo(a + ImVec2(0.5f, 0.5f));
	PathLineTo(b + ImVec2(0.5f, 0.5f));
	PathStroke(col, false, thickness);
}

// a: upper-left, b: lower-right. we don't render 1 px sized rectangles properly.
void ImDrawList::AddRect(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags, float thickness)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;
	if (Flags & ImDrawListFlags_AntiAliasedLines)
		PathRect(a + ImVec2(0.5f, 0.5f), b - ImVec2(0.50f, 0.50f), rounding, rounding_corners_flags);
	else
		PathRect(a + ImVec2(0.5f, 0.5f), b - ImVec2(0.49f, 0.49f), rounding, rounding_corners_flags); // Better looking lower-right corner and rounded non-AA shapes.
	PathStroke(col, true, thickness);
}

void ImDrawList::AddRectFilled(const ImVec2& a, const ImVec2& b, ImU32 col, float rounding, int rounding_corners_flags)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;
	if (rounding > 0.0f)
	{
		PathRect(a, b, rounding, rounding_corners_flags);
		PathFillConvex(col);
	}
	else
	{
		PrimReserve(6, 4);
		PrimRect(a, b, col);
	}
}

void ImDrawList::AddRectFilledMultiColor(const ImVec2& a, const ImVec2& c, ImU32 col_upr_left, ImU32 col_upr_right, ImU32 col_bot_right, ImU32 col_bot_left)
{
	if (((col_upr_left | col_upr_right | col_bot_right | col_bot_left) & IM_COL32_A_MASK) == 0)
		return;

	const ImVec2 uv = _Data->TexUvWhitePixel;
	PrimReserve(6, 4);
	PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 1)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2));
	PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 2)); PrimWriteIdx((ImDrawIdx)(_VtxCurrentIdx + 3));
	PrimWriteVtx(a, uv, col_upr_left);
	PrimWriteVtx(ImVec2(c.x, a.y), uv, col_upr_right);
	PrimWriteVtx(c, uv, col_bot_right);
	PrimWriteVtx(ImVec2(a.x, c.y), uv, col_bot_left);
}

void ImDrawList::AddQuad(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col, float thickness)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	PathLineTo(a);
	PathLineTo(b);
	PathLineTo(c);
	PathLineTo(d);
	PathStroke(col, true, thickness);
}

void ImDrawList::AddQuadFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, ImU32 col)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	PathLineTo(a);
	PathLineTo(b);
	PathLineTo(c);
	PathLineTo(d);
	PathFillConvex(col);
}

void ImDrawList::AddTriangle(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col, float thickness)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	PathLineTo(a);
	PathLineTo(b);
	PathLineTo(c);
	PathStroke(col, true, thickness);
}

void ImDrawList::AddTriangleFilled(const ImVec2& a, const ImVec2& b, const ImVec2& c, ImU32 col)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	PathLineTo(a);
	PathLineTo(b);
	PathLineTo(c);
	PathFillConvex(col);
}

void ImDrawList::AddCircle(const ImVec2& centre, float radius, ImU32 col, int num_segments, float thickness)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	const float a_max = IM_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
	PathArcTo(centre, radius - 0.5f, 0.0f, a_max, num_segments);
	PathStroke(col, true, thickness);
}

void ImDrawList::AddCircleFilled(const ImVec2& centre, float radius, ImU32 col, int num_segments)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	const float a_max = IM_PI * 2.0f * ((float)num_segments - 1.0f) / (float)num_segments;
	PathArcTo(centre, radius, 0.0f, a_max, num_segments);
	PathFillConvex(col);
}

void ImDrawList::AddBezierCurve(const ImVec2& pos0, const ImVec2& cp0, const ImVec2& cp1, const ImVec2& pos1, ImU32 col, float thickness, int num_segments)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	PathLineTo(pos0);
	PathBezierCurveTo(cp0, cp1, pos1, num_segments);
	PathStroke(col, false, thickness);
}

void ImDrawList::AddRing3D(const Vector& pos, int16_t radius, uint16_t points, ImU32 color, float thickness)
{
	float step = (float)M_PI * 2.0f / points;

	Vector start2d, end2d;

	for (float a = 0; a < (M_PI * 2.0f); a += step)
	{
		Vector start(radius * cosf(a) + pos.x, radius * sinf(a) + pos.y, pos.z);
		Vector end(radius * cosf(a + step) + pos.x, radius * sinf(a + step) + pos.y, pos.z);

		Vector start22d(start2d.x, start2d.y);
		Vector end22d(end2d.x, end2d.y);

		if (math::world2screen(start, start2d) && math::world2screen(end, end2d))
		{
			start22d.x = start2d.x;
			start22d.y = start2d.y;

			end22d.x = end2d.x;
			end22d.y = end2d.y;

			AddLine(ImVec2(start22d.x, start22d.y), ImVec2(end22d.x, end22d.y), color, thickness);
		}
	}
}

void ImDrawList::AddText(const ImFont* font, float font_size, const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end, float wrap_width, const ImVec4* cpu_fine_clip_rect)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	if (text_end == NULL)
		text_end = text_begin + strlen(text_begin);
	if (text_begin == text_end)
		return;

	// Pull default font/size from the shared ImDrawListSharedData instance
	if (font == NULL)
		font = _Data->Font;
	if (font_size == 0.0f)
		font_size = _Data->FontSize;

	IM_ASSERT(font->ContainerAtlas->TexID == _TextureIdStack.back());  // Use high-level ImGui::PushFont() or low-level ImDrawList::PushTextureId() to change font.

	ImVec4 clip_rect = _ClipRectStack.back();
	if (cpu_fine_clip_rect)
	{
		clip_rect.x = ImMax(clip_rect.x, cpu_fine_clip_rect->x);
		clip_rect.y = ImMax(clip_rect.y, cpu_fine_clip_rect->y);
		clip_rect.z = ImMin(clip_rect.z, cpu_fine_clip_rect->z);
		clip_rect.w = ImMin(clip_rect.w, cpu_fine_clip_rect->w);
	}
	font->RenderText(this, font_size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip_rect != NULL);
}

void ImDrawList::AddText(const ImVec2& pos, ImU32 col, const char* text_begin, const char* text_end)
{
	AddText(NULL, 0.0f, pos, col, text_begin, text_end);
}

void ImDrawList::AddImage(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
	if (push_texture_id)
		PushTextureID(user_texture_id);

	PrimReserve(6, 4);
	PrimRectUV(a, b, uv_a, uv_b, col);

	if (push_texture_id)
		PopTextureID();
}

void ImDrawList::AddImageQuad(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& d, const ImVec2& uv_a, const ImVec2& uv_b, const ImVec2& uv_c, const ImVec2& uv_d, ImU32 col)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
	if (push_texture_id)
		PushTextureID(user_texture_id);

	PrimReserve(6, 4);
	PrimQuadUV(a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);

	if (push_texture_id)
		PopTextureID();
}

void ImDrawList::AddImageRounded(ImTextureID user_texture_id, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, ImU32 col, float rounding, int rounding_corners)
{
	if ((col & IM_COL32_A_MASK) == 0)
		return;

	if (rounding <= 0.0f || (rounding_corners & ImDrawCornerFlags_All) == 0)
	{
		AddImage(user_texture_id, a, b, uv_a, uv_b, col);
		return;
	}

	const bool push_texture_id = _TextureIdStack.empty() || user_texture_id != _TextureIdStack.back();
	if (push_texture_id)
		PushTextureID(user_texture_id);

	int vert_start_idx = VtxBuffer.Size;
	PathRect(a, b, rounding, rounding_corners);
	PathFillConvex(col);
	int vert_end_idx = VtxBuffer.Size;
	ImGui::ShadeVertsLinearUV(VtxBuffer.Data + vert_start_idx, VtxBuffer.Data + vert_end_idx, a, b, uv_a, uv_b, true);

	if (push_texture_id)
		PopTextureID();
}

//-----------------------------------------------------------------------------
// ImDrawData
//-----------------------------------------------------------------------------

// For backward compatibility: convert all buffers from indexed to de-indexed, in case you cannot render indexed. Note: this is slow and most likely a waste of resources. Always prefer indexed rendering!
void ImDrawData::DeIndexAllBuffers()
{
	ImVector<ImDrawVert> new_vtx_buffer;
	TotalVtxCount = TotalIdxCount = 0;
	for (int i = 0; i < CmdListsCount; i++)
	{
		ImDrawList* cmd_list = CmdLists[i];
		if (cmd_list->IdxBuffer.empty())
			continue;
		new_vtx_buffer.resize(cmd_list->IdxBuffer.Size);
		for (int j = 0; j < cmd_list->IdxBuffer.Size; j++)
			new_vtx_buffer[j] = cmd_list->VtxBuffer[cmd_list->IdxBuffer[j]];
		cmd_list->VtxBuffer.swap(new_vtx_buffer);
		cmd_list->IdxBuffer.resize(0);
		TotalVtxCount += cmd_list->VtxBuffer.Size;
	}
}

// Helper to scale the ClipRect field of each ImDrawCmd. Use if your final output buffer is at a different scale than ImGui expects, or if there is a difference between your window resolution and framebuffer resolution.
void ImDrawData::ScaleClipRects(const ImVec2& scale)
{
	for (int i = 0; i < CmdListsCount; i++)
	{
		ImDrawList* cmd_list = CmdLists[i];
		for (int cmd_i = 0; cmd_i < cmd_list->CmdBuffer.Size; cmd_i++)
		{
			ImDrawCmd* cmd = &cmd_list->CmdBuffer[cmd_i];
			cmd->ClipRect = ImVec4(cmd->ClipRect.x * scale.x, cmd->ClipRect.y * scale.y, cmd->ClipRect.z * scale.x, cmd->ClipRect.w * scale.y);
		}
	}
}

//-----------------------------------------------------------------------------
// Shade functions
//-----------------------------------------------------------------------------

// Generic linear color gradient, write to RGB fields, leave A untouched.
void ImGui::ShadeVertsLinearColorGradientKeepAlpha(ImDrawVert* vert_start, ImDrawVert* vert_end, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1)
{
	ImVec2 gradient_extent = gradient_p1 - gradient_p0;
	float gradient_inv_length2 = 1.0f / ImLengthSqr(gradient_extent);
	for (ImDrawVert* vert = vert_start; vert < vert_end; vert++)
	{
		float d = ImDot(vert->pos - gradient_p0, gradient_extent);
		float t = ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);
		int r = ImLerp((int)(col0 >> IM_COL32_R_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_R_SHIFT) & 0xFF, t);
		int g = ImLerp((int)(col0 >> IM_COL32_G_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_G_SHIFT) & 0xFF, t);
		int b = ImLerp((int)(col0 >> IM_COL32_B_SHIFT) & 0xFF, (int)(col1 >> IM_COL32_B_SHIFT) & 0xFF, t);
		vert->col = (r << IM_COL32_R_SHIFT) | (g << IM_COL32_G_SHIFT) | (b << IM_COL32_B_SHIFT) | (vert->col & IM_COL32_A_MASK);
	}
}

// Scan and shade backward from the end of given vertices. Assume vertices are text only (= vert_start..vert_end going left to right) so we can break as soon as we are out the gradient bounds.
void ImGui::ShadeVertsLinearAlphaGradientForLeftToRightText(ImDrawVert* vert_start, ImDrawVert* vert_end, float gradient_p0_x, float gradient_p1_x)
{
	float gradient_extent_x = gradient_p1_x - gradient_p0_x;
	float gradient_inv_length2 = 1.0f / (gradient_extent_x * gradient_extent_x);
	int full_alpha_count = 0;
	for (ImDrawVert* vert = vert_end - 1; vert >= vert_start; vert--)
	{
		float d = (vert->pos.x - gradient_p0_x) * (gradient_extent_x);
		float alpha_mul = 1.0f - ImClamp(d * gradient_inv_length2, 0.0f, 1.0f);
		if (alpha_mul >= 1.0f && ++full_alpha_count > 2)
			return; // Early out
		int a = (int)(((vert->col >> IM_COL32_A_SHIFT) & 0xFF) * alpha_mul);
		vert->col = (vert->col & ~IM_COL32_A_MASK) | (a << IM_COL32_A_SHIFT);
	}
}

// Distribute UV over (a, b) rectangle
void ImGui::ShadeVertsLinearUV(ImDrawVert* vert_start, ImDrawVert* vert_end, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp)
{
	const ImVec2 size = b - a;
	const ImVec2 uv_size = uv_b - uv_a;
	const ImVec2 scale = ImVec2(
		size.x != 0.0f ? (uv_size.x / size.x) : 0.0f,
		size.y != 0.0f ? (uv_size.y / size.y) : 0.0f);

	if (clamp)
	{
		const ImVec2 min = ImMin(uv_a, uv_b);
		const ImVec2 max = ImMax(uv_a, uv_b);

		for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
			vertex->uv = ImClamp(uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale), min, max);
	}
	else
	{
		for (ImDrawVert* vertex = vert_start; vertex < vert_end; ++vertex)
			vertex->uv = uv_a + ImMul(ImVec2(vertex->pos.x, vertex->pos.y) - a, scale);
	}
}

//-----------------------------------------------------------------------------
// ImFontConfig
//-----------------------------------------------------------------------------

ImFontConfig::ImFontConfig()
{
	FontData = NULL;
	FontDataSize = 0;
	FontDataOwnedByAtlas = true;
	FontNo = 0;
	SizePixels = 0.0f;
	OversampleH = 3;
	OversampleV = 1;
	PixelSnapH = false;
	GlyphExtraSpacing = ImVec2(0.0f, 0.0f);
	GlyphOffset = ImVec2(0.0f, 0.0f);
	GlyphRanges = NULL;
	MergeMode = false;
	RasterizerFlags = 0x00;
	RasterizerMultiply = 1.0f;
	memset(Name, 0, sizeof(Name));
	DstFont = NULL;
}

//-----------------------------------------------------------------------------
// ImFontAtlas
//-----------------------------------------------------------------------------

// A work of art lies ahead! (. = white layer, X = black layer, others are blank)
// The white texels on the top left are the ones we'll use everywhere in ImGui to render filled shapes.
const int FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF = 90;
const int FONT_ATLAS_DEFAULT_TEX_DATA_H = 27;
const unsigned int FONT_ATLAS_DEFAULT_TEX_DATA_ID = 0x80000000;
static const char FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * FONT_ATLAS_DEFAULT_TEX_DATA_H + 1] =
{
	"..-         -XXXXXXX-    X    -           X           -XXXXXXX          -          XXXXXXX"
	"..-         -X.....X-   X.X   -          X.X          -X.....X          -          X.....X"
	"---         -XXX.XXX-  X...X  -         X...X         -X....X           -           X....X"
	"X           -  X.X  - X.....X -        X.....X        -X...X            -            X...X"
	"XX          -  X.X  -X.......X-       X.......X       -X..X.X           -           X.X..X"
	"X.X         -  X.X  -XXXX.XXXX-       XXXX.XXXX       -X.X X.X          -          X.X X.X"
	"X..X        -  X.X  -   X.X   -          X.X          -XX   X.X         -         X.X   XX"
	"X...X       -  X.X  -   X.X   -    XX    X.X    XX    -      X.X        -        X.X      "
	"X....X      -  X.X  -   X.X   -   X.X    X.X    X.X   -       X.X       -       X.X       "
	"X.....X     -  X.X  -   X.X   -  X..X    X.X    X..X  -        X.X      -      X.X        "
	"X......X    -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -         X.X   XX-XX   X.X         "
	"X.......X   -  X.X  -   X.X   -X.....................X-          X.X X.X-X.X X.X          "
	"X........X  -  X.X  -   X.X   - X...XXXXXX.XXXXXX...X -           X.X..X-X..X.X           "
	"X.........X -XXX.XXX-   X.X   -  X..X    X.X    X..X  -            X...X-X...X            "
	"X..........X-X.....X-   X.X   -   X.X    X.X    X.X   -           X....X-X....X           "
	"X......XXXXX-XXXXXXX-   X.X   -    XX    X.X    XX    -          X.....X-X.....X          "
	"X...X..X    ---------   X.X   -          X.X          -          XXXXXXX-XXXXXXX          "
	"X..X X..X   -       -XXXX.XXXX-       XXXX.XXXX       ------------------------------------"
	"X.X  X..X   -       -X.......X-       X.......X       -    XX           XX    -           "
	"XX    X..X  -       - X.....X -        X.....X        -   X.X           X.X   -           "
	"      X..X          -  X...X  -         X...X         -  X..X           X..X  -           "
	"       XX           -   X.X   -          X.X          - X...XXXXXXXXXXXXX...X -           "
	"------------        -    X    -           X           -X.....................X-           "
	"                    ----------------------------------- X...XXXXXXXXXXXXX...X -           "
	"                                                      -  X..X           X..X  -           "
	"                                                      -   X.X           X.X   -           "
	"                                                      -    XX           XX    -           "
};

static const ImVec2 FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[ImGuiMouseCursor_COUNT][3] =
{
	// Pos ........ Size ......... Offset ......
	{ ImVec2(0,3),  ImVec2(12,19), ImVec2(0, 0) }, // ImGuiMouseCursor_Arrow
{ ImVec2(13,0), ImVec2(7,16),  ImVec2(4, 8) }, // ImGuiMouseCursor_TextInput
{ ImVec2(31,0), ImVec2(23,23), ImVec2(11,11) }, // ImGuiMouseCursor_ResizeAll
{ ImVec2(21,0), ImVec2(9,23), ImVec2(5,11) }, // ImGuiMouseCursor_ResizeNS
{ ImVec2(55,18),ImVec2(23, 9), ImVec2(11, 5) }, // ImGuiMouseCursor_ResizeEW
{ ImVec2(73,0), ImVec2(17,17), ImVec2(9, 9) }, // ImGuiMouseCursor_ResizeNESW
{ ImVec2(55,0), ImVec2(17,17), ImVec2(9, 9) }, // ImGuiMouseCursor_ResizeNWSE
};

ImFontAtlas::ImFontAtlas()
{
	Flags = 0x00;
	TexID = NULL;
	TexDesiredWidth = 0;
	TexGlyphPadding = 1;

	TexPixelsAlpha8 = NULL;
	TexPixelsRGBA32 = NULL;
	TexWidth = TexHeight = 0;
	TexUvScale = ImVec2(0.0f, 0.0f);
	TexUvWhitePixel = ImVec2(0.0f, 0.0f);
	for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)
		CustomRectIds[n] = -1;
}

ImFontAtlas::~ImFontAtlas()
{
	Clear();
}

void    ImFontAtlas::ClearInputData()
{
	for (int i = 0; i < ConfigData.Size; i++)
		if (ConfigData[i].FontData && ConfigData[i].FontDataOwnedByAtlas)
		{
			ImGui::MemFree(ConfigData[i].FontData);
			ConfigData[i].FontData = NULL;
		}

	// When clearing this we lose access to the font name and other information used to build the font.
	for (int i = 0; i < Fonts.Size; i++)
		if (Fonts[i]->ConfigData >= ConfigData.Data && Fonts[i]->ConfigData < ConfigData.Data + ConfigData.Size)
		{
			Fonts[i]->ConfigData = NULL;
			Fonts[i]->ConfigDataCount = 0;
		}
	ConfigData.clear();
	CustomRects.clear();
	for (int n = 0; n < IM_ARRAYSIZE(CustomRectIds); n++)
		CustomRectIds[n] = -1;
}

void    ImFontAtlas::ClearTexData()
{
	if (TexPixelsAlpha8)
		ImGui::MemFree(TexPixelsAlpha8);
	if (TexPixelsRGBA32)
		ImGui::MemFree(TexPixelsRGBA32);
	TexPixelsAlpha8 = NULL;
	TexPixelsRGBA32 = NULL;
}

void    ImFontAtlas::ClearFonts()
{
	for (int i = 0; i < Fonts.Size; i++)
		IM_DELETE(Fonts[i]);
	Fonts.clear();
}

void    ImFontAtlas::Clear()
{
	ClearInputData();
	ClearTexData();
	ClearFonts();
}

void    ImFontAtlas::GetTexDataAsAlpha8(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
{
	// Build atlas on demand
	if (TexPixelsAlpha8 == NULL)
	{
		if (ConfigData.empty())
			AddFontDefault();
		Build();
	}

	*out_pixels = TexPixelsAlpha8;
	if (out_width)*out_width = TexWidth;
	if (out_height)*out_height = TexHeight;
	if (out_bytes_per_pixel)*out_bytes_per_pixel = 1;
}

void    ImFontAtlas::GetTexDataAsRGBA32(unsigned char** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel)
{
	// Convert to RGBA32 format on demand
	// Although it is likely to be the most commonly used format, our font rendering is 1 channel / 8 bpp
	if (!TexPixelsRGBA32)
	{
		unsigned char* pixels = NULL;
		GetTexDataAsAlpha8(&pixels, NULL, NULL);
		if (pixels)
		{
			TexPixelsRGBA32 = (unsigned int*)ImGui::MemAlloc((size_t)(TexWidth * TexHeight * 4));
			const unsigned char* src = pixels;
			unsigned int* dst = TexPixelsRGBA32;
			for (int n = TexWidth * TexHeight; n > 0; n--)
				*dst++ = IM_COL32(255, 255, 255, (unsigned int)(*src++));
		}
	}

	*out_pixels = (unsigned char*)TexPixelsRGBA32;
	if (out_width)*out_width = TexWidth;
	if (out_height)*out_height = TexHeight;
	if (out_bytes_per_pixel)*out_bytes_per_pixel = 4;
}

ImFont* ImFontAtlas::AddFont(const ImFontConfig* font_cfg)
{
	IM_ASSERT(font_cfg->FontData != NULL && font_cfg->FontDataSize > 0);
	IM_ASSERT(font_cfg->SizePixels > 0.0f);

	// Create new font
	if (!font_cfg->MergeMode)
		Fonts.push_back(IM_NEW(ImFont));
	else
		IM_ASSERT(!Fonts.empty()); // When using MergeMode make sure that a font has already been added before. You can use ImGui::GetIO().Fonts->AddFontDefault() to add the default imgui font.

	ConfigData.push_back(*font_cfg);
	ImFontConfig& new_font_cfg = ConfigData.back();
	if (!new_font_cfg.DstFont)
		new_font_cfg.DstFont = Fonts.back();
	if (!new_font_cfg.FontDataOwnedByAtlas)
	{
		new_font_cfg.FontData = ImGui::MemAlloc(new_font_cfg.FontDataSize);
		new_font_cfg.FontDataOwnedByAtlas = true;
		memcpy(new_font_cfg.FontData, font_cfg->FontData, (size_t)new_font_cfg.FontDataSize);
	}

	// Invalidate texture
	ClearTexData();
	return new_font_cfg.DstFont;
}

// Default font TTF is compressed with stb_compress then base85 encoded (see misc/fonts/binary_to_compressed_c.cpp for encoder)
static unsigned int stb_decompress_length(const unsigned char* input);
static unsigned int stb_decompress(unsigned char* output, const unsigned char* input, unsigned int length);
static const char* GetDefaultCompressedFontDataTTFBase85();
static unsigned int Decode85Byte(char c) { return c >= '\\' ? c - 36 : c - 35; }
static void         Decode85(const unsigned char* src, unsigned char* dst)
{
	while (*src)
	{
		unsigned int tmp = Decode85Byte(src[0]) + 85 * (Decode85Byte(src[1]) + 85 * (Decode85Byte(src[2]) + 85 * (Decode85Byte(src[3]) + 85 * Decode85Byte(src[4]))));
		dst[0] = ((tmp >> 0) & 0xFF); dst[1] = ((tmp >> 8) & 0xFF); dst[2] = ((tmp >> 16) & 0xFF); dst[3] = ((tmp >> 24) & 0xFF);   // We can't assume little-endianness.
		src += 5;
		dst += 4;
	}
}

// Load embedded ProggyClean.ttf at size 13, disable oversampling
ImFont* ImFontAtlas::AddFontDefault(const ImFontConfig* font_cfg_template)
{
	ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
	if (!font_cfg_template)
	{
		font_cfg.OversampleH = font_cfg.OversampleV = 1;
		font_cfg.PixelSnapH = true;
	}
	if (font_cfg.Name[0] == '\0') strcpy(font_cfg.Name, "ProggyClean.ttf, 13px");
	if (font_cfg.SizePixels <= 0.0f) font_cfg.SizePixels = 13.0f;

	const char* ttf_compressed_base85 = GetDefaultCompressedFontDataTTFBase85();
	ImFont* font = AddFontFromMemoryCompressedBase85TTF(ttf_compressed_base85, font_cfg.SizePixels, &font_cfg, GetGlyphRangesDefault());
	font->DisplayOffset.y = 1.0f;
	return font;
}

ImFont* ImFontAtlas::AddFontFromFileTTF(const char* filename, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
	int data_size = 0;
	void* data = ImFileLoadToMemory(filename, "rb", &data_size, 0);
	if (!data)
	{
		IM_ASSERT(0); // Could not load file.
		return NULL;
	}
	ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
	if (font_cfg.Name[0] == '\0')
	{
		// Store a short copy of filename into into the font name for convenience
		const char* p;
		for (p = filename + strlen(filename); p > filename && p[-1] != '/' && p[-1] != '\\'; p--) {}
		ImFormatString(font_cfg.Name, IM_ARRAYSIZE(font_cfg.Name), "%s, %.0fpx", p, size_pixels);
	}
	return AddFontFromMemoryTTF(data, data_size, size_pixels, &font_cfg, glyph_ranges);
}

// NB: Transfer ownership of 'ttf_data' to ImFontAtlas, unless font_cfg_template->FontDataOwnedByAtlas == false. Owned TTF buffer will be deleted after Build().
ImFont* ImFontAtlas::AddFontFromMemoryTTF(void* ttf_data, int ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
	ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
	IM_ASSERT(font_cfg.FontData == NULL);
	font_cfg.FontData = ttf_data;
	font_cfg.FontDataSize = ttf_size;
	font_cfg.SizePixels = size_pixels;
	if (glyph_ranges)
		font_cfg.GlyphRanges = glyph_ranges;
	return AddFont(&font_cfg);
}

ImFont* ImFontAtlas::AddFontFromMemoryCompressedTTF(const void* compressed_ttf_data, int compressed_ttf_size, float size_pixels, const ImFontConfig* font_cfg_template, const ImWchar* glyph_ranges)
{
	const unsigned int buf_decompressed_size = stb_decompress_length((const unsigned char*)compressed_ttf_data);
	unsigned char* buf_decompressed_data = (unsigned char*)ImGui::MemAlloc(buf_decompressed_size);
	stb_decompress(buf_decompressed_data, (const unsigned char*)compressed_ttf_data, (unsigned int)compressed_ttf_size);

	ImFontConfig font_cfg = font_cfg_template ? *font_cfg_template : ImFontConfig();
	IM_ASSERT(font_cfg.FontData == NULL);
	font_cfg.FontDataOwnedByAtlas = true;
	return AddFontFromMemoryTTF(buf_decompressed_data, (int)buf_decompressed_size, size_pixels, &font_cfg, glyph_ranges);
}

ImFont* ImFontAtlas::AddFontFromMemoryCompressedBase85TTF(const char* compressed_ttf_data_base85, float size_pixels, const ImFontConfig* font_cfg, const ImWchar* glyph_ranges)
{
	int compressed_ttf_size = (((int)strlen(compressed_ttf_data_base85) + 4) / 5) * 4;
	void* compressed_ttf = ImGui::MemAlloc((size_t)compressed_ttf_size);
	Decode85((const unsigned char*)compressed_ttf_data_base85, (unsigned char*)compressed_ttf);
	ImFont* font = AddFontFromMemoryCompressedTTF(compressed_ttf, compressed_ttf_size, size_pixels, font_cfg, glyph_ranges);
	ImGui::MemFree(compressed_ttf);
	return font;
}

int ImFontAtlas::AddCustomRectRegular(unsigned int id, int width, int height)
{
	IM_ASSERT(id >= 0x10000);
	IM_ASSERT(width > 0 && width <= 0xFFFF);
	IM_ASSERT(height > 0 && height <= 0xFFFF);
	CustomRect r;
	r.ID = id;
	r.Width = (unsigned short)width;
	r.Height = (unsigned short)height;
	CustomRects.push_back(r);
	return CustomRects.Size - 1; // Return index
}

int ImFontAtlas::AddCustomRectFontGlyph(ImFont* font, ImWchar id, int width, int height, float advance_x, const ImVec2& offset)
{
	IM_ASSERT(font != NULL);
	IM_ASSERT(width > 0 && width <= 0xFFFF);
	IM_ASSERT(height > 0 && height <= 0xFFFF);
	CustomRect r;
	r.ID = id;
	r.Width = (unsigned short)width;
	r.Height = (unsigned short)height;
	r.GlyphAdvanceX = advance_x;
	r.GlyphOffset = offset;
	r.Font = font;
	CustomRects.push_back(r);
	return CustomRects.Size - 1; // Return index
}

void ImFontAtlas::CalcCustomRectUV(const CustomRect* rect, ImVec2* out_uv_min, ImVec2* out_uv_max)
{
	IM_ASSERT(TexWidth > 0 && TexHeight > 0);   // Font atlas needs to be built before we can calculate UV coordinates
	IM_ASSERT(rect->IsPacked());                // Make sure the rectangle has been packed
	*out_uv_min = ImVec2((float)rect->X * TexUvScale.x, (float)rect->Y * TexUvScale.y);
	*out_uv_max = ImVec2((float)(rect->X + rect->Width) * TexUvScale.x, (float)(rect->Y + rect->Height) * TexUvScale.y);
}

bool ImFontAtlas::GetMouseCursorTexData(ImGuiMouseCursor cursor_type, ImVec2* out_offset, ImVec2* out_size, ImVec2 out_uv_border[2], ImVec2 out_uv_fill[2])
{
	if (cursor_type <= ImGuiMouseCursor_None || cursor_type >= ImGuiMouseCursor_COUNT)
		return false;
	if (Flags & ImFontAtlasFlags_NoMouseCursors)
		return false;

	IM_ASSERT(CustomRectIds[0] != -1);
	ImFontAtlas::CustomRect& r = CustomRects[CustomRectIds[0]];
	IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);
	ImVec2 pos = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][0] + ImVec2((float)r.X, (float)r.Y);
	ImVec2 size = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][1];
	*out_size = size;
	*out_offset = FONT_ATLAS_DEFAULT_TEX_CURSOR_DATA[cursor_type][2];
	out_uv_border[0] = (pos)*TexUvScale;
	out_uv_border[1] = (pos + size) * TexUvScale;
	pos.x += FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;
	out_uv_fill[0] = (pos)*TexUvScale;
	out_uv_fill[1] = (pos + size) * TexUvScale;
	return true;
}

bool    ImFontAtlas::Build()
{
	return ImFontAtlasBuildWithStbTruetype(this);
}

void    ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_brighten_factor)
{
	for (unsigned int i = 0; i < 256; i++)
	{
		unsigned int value = (unsigned int)(i * in_brighten_factor);
		out_table[i] = value > 255 ? 255 : (value & 0xFF);
	}
}

void    ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride)
{
	unsigned char* data = pixels + x + y * stride;
	for (int j = h; j > 0; j--, data += stride)
		for (int i = 0; i < w; i++)
			data[i] = table[data[i]];
}

bool    ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas)
{
	IM_ASSERT(atlas->ConfigData.Size > 0);

	ImFontAtlasBuildRegisterDefaultCustomRects(atlas);

	atlas->TexID = NULL;
	atlas->TexWidth = atlas->TexHeight = 0;
	atlas->TexUvScale = ImVec2(0.0f, 0.0f);
	atlas->TexUvWhitePixel = ImVec2(0.0f, 0.0f);
	atlas->ClearTexData();

	// Count glyphs/ranges
	int total_glyphs_count = 0;
	int total_ranges_count = 0;
	for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)
	{
		ImFontConfig& cfg = atlas->ConfigData[input_i];
		if (!cfg.GlyphRanges)
			cfg.GlyphRanges = atlas->GetGlyphRangesDefault();
		for (const ImWchar* in_range = cfg.GlyphRanges; in_range[0] && in_range[1]; in_range += 2, total_ranges_count++)
			total_glyphs_count += (in_range[1] - in_range[0]) + 1;
	}

	// We need a width for the skyline algorithm. Using a dumb heuristic here to decide of width. User can override TexDesiredWidth and TexGlyphPadding if they wish.
	// Width doesn't really matter much, but some API/GPU have texture size limitations and increasing width can decrease height.
	atlas->TexWidth = (atlas->TexDesiredWidth > 0) ? atlas->TexDesiredWidth : (total_glyphs_count > 4000) ? 4096 : (total_glyphs_count > 2000) ? 2048 : (total_glyphs_count > 1000) ? 1024 : 512;
	atlas->TexHeight = 0;

	// Start packing
	const int max_tex_height = 1024 * 32;
	stbtt_pack_context spc = {};
	if (!stbtt_PackBegin(&spc, NULL, atlas->TexWidth, max_tex_height, 0, atlas->TexGlyphPadding, NULL))
		return false;
	stbtt_PackSetOversampling(&spc, 1, 1);

	// Pack our extra data rectangles first, so it will be on the upper-left corner of our texture (UV will have small values).
	ImFontAtlasBuildPackCustomRects(atlas, spc.pack_info);

	// Initialize font information (so we can error without any cleanup)
	struct ImFontTempBuildData
	{
		stbtt_fontinfo      FontInfo;
		stbrp_rect* Rects;
		int                 RectsCount;
		stbtt_pack_range* Ranges;
		int                 RangesCount;
	};
	ImFontTempBuildData* tmp_array = (ImFontTempBuildData*)ImGui::MemAlloc((size_t)atlas->ConfigData.Size * sizeof(ImFontTempBuildData));
	for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)
	{
		ImFontConfig& cfg = atlas->ConfigData[input_i];
		ImFontTempBuildData& tmp = tmp_array[input_i];
		IM_ASSERT(cfg.DstFont && (!cfg.DstFont->IsLoaded() || cfg.DstFont->ContainerAtlas == atlas));

		const int font_offset = stbtt_GetFontOffsetForIndex((unsigned char*)cfg.FontData, cfg.FontNo);
		IM_ASSERT(font_offset >= 0);
		if (!stbtt_InitFont(&tmp.FontInfo, (unsigned char*)cfg.FontData, font_offset))
		{
			atlas->TexWidth = atlas->TexHeight = 0; // Reset output on failure
			ImGui::MemFree(tmp_array);
			return false;
		}
	}

	// Allocate packing character data and flag packed characters buffer as non-packed (x0=y0=x1=y1=0)
	int buf_packedchars_n = 0, buf_rects_n = 0, buf_ranges_n = 0;
	stbtt_packedchar* buf_packedchars = (stbtt_packedchar*)ImGui::MemAlloc(total_glyphs_count * sizeof(stbtt_packedchar));
	stbrp_rect* buf_rects = (stbrp_rect*)ImGui::MemAlloc(total_glyphs_count * sizeof(stbrp_rect));
	stbtt_pack_range* buf_ranges = (stbtt_pack_range*)ImGui::MemAlloc(total_ranges_count * sizeof(stbtt_pack_range));
	memset(buf_packedchars, 0, total_glyphs_count * sizeof(stbtt_packedchar));
	memset(buf_rects, 0, total_glyphs_count * sizeof(stbrp_rect));              // Unnecessary but let's clear this for the sake of sanity.
	memset(buf_ranges, 0, total_ranges_count * sizeof(stbtt_pack_range));

	// First font pass: pack all glyphs (no rendering at this point, we are working with rectangles in an infinitely tall texture at this point)
	for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)
	{
		ImFontConfig& cfg = atlas->ConfigData[input_i];
		ImFontTempBuildData& tmp = tmp_array[input_i];

		// Setup ranges
		int font_glyphs_count = 0;
		int font_ranges_count = 0;
		for (const ImWchar* in_range = cfg.GlyphRanges; in_range[0] && in_range[1]; in_range += 2, font_ranges_count++)
			font_glyphs_count += (in_range[1] - in_range[0]) + 1;
		tmp.Ranges = buf_ranges + buf_ranges_n;
		tmp.RangesCount = font_ranges_count;
		buf_ranges_n += font_ranges_count;
		for (int i = 0; i < font_ranges_count; i++)
		{
			const ImWchar* in_range = &cfg.GlyphRanges[i * 2];
			stbtt_pack_range& range = tmp.Ranges[i];
			range.font_size = cfg.SizePixels;
			range.first_unicode_codepoint_in_range = in_range[0];
			range.num_chars = (in_range[1] - in_range[0]) + 1;
			range.chardata_for_range = buf_packedchars + buf_packedchars_n;
			buf_packedchars_n += range.num_chars;
		}

		// Pack
		tmp.Rects = buf_rects + buf_rects_n;
		tmp.RectsCount = font_glyphs_count;
		buf_rects_n += font_glyphs_count;
		stbtt_PackSetOversampling(&spc, cfg.OversampleH, cfg.OversampleV);
		int n = stbtt_PackFontRangesGatherRects(&spc, &tmp.FontInfo, tmp.Ranges, tmp.RangesCount, tmp.Rects);
		IM_ASSERT(n == font_glyphs_count);
		stbrp_pack_rects((stbrp_context*)spc.pack_info, tmp.Rects, n);

		// Extend texture height
		for (int i = 0; i < n; i++)
			if (tmp.Rects[i].was_packed)
				atlas->TexHeight = ImMax(atlas->TexHeight, tmp.Rects[i].y + tmp.Rects[i].h);
	}
	IM_ASSERT(buf_rects_n == total_glyphs_count);
	IM_ASSERT(buf_packedchars_n == total_glyphs_count);
	IM_ASSERT(buf_ranges_n == total_ranges_count);

	// Create texture
	atlas->TexHeight = (atlas->Flags & ImFontAtlasFlags_NoPowerOfTwoHeight) ? (atlas->TexHeight + 1) : ImUpperPowerOfTwo(atlas->TexHeight);
	atlas->TexUvScale = ImVec2(1.0f / atlas->TexWidth, 1.0f / atlas->TexHeight);
	atlas->TexPixelsAlpha8 = (unsigned char*)ImGui::MemAlloc(atlas->TexWidth * atlas->TexHeight);
	memset(atlas->TexPixelsAlpha8, 0, atlas->TexWidth * atlas->TexHeight);
	spc.pixels = atlas->TexPixelsAlpha8;
	spc.height = atlas->TexHeight;

	// Second pass: render font characters
	for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)
	{
		ImFontConfig& cfg = atlas->ConfigData[input_i];
		ImFontTempBuildData& tmp = tmp_array[input_i];
		stbtt_PackSetOversampling(&spc, cfg.OversampleH, cfg.OversampleV);
		stbtt_PackFontRangesRenderIntoRects(&spc, &tmp.FontInfo, tmp.Ranges, tmp.RangesCount, tmp.Rects);
		if (cfg.RasterizerMultiply != 1.0f)
		{
			unsigned char multiply_table[256];
			ImFontAtlasBuildMultiplyCalcLookupTable(multiply_table, cfg.RasterizerMultiply);
			for (const stbrp_rect* r = tmp.Rects; r != tmp.Rects + tmp.RectsCount; r++)
				if (r->was_packed)
					ImFontAtlasBuildMultiplyRectAlpha8(multiply_table, spc.pixels, r->x, r->y, r->w, r->h, spc.stride_in_bytes);
		}
		tmp.Rects = NULL;
	}

	// End packing
	stbtt_PackEnd(&spc);
	ImGui::MemFree(buf_rects);
	buf_rects = NULL;

	// Third pass: setup ImFont and glyphs for runtime
	for (int input_i = 0; input_i < atlas->ConfigData.Size; input_i++)
	{
		ImFontConfig& cfg = atlas->ConfigData[input_i];
		ImFontTempBuildData& tmp = tmp_array[input_i];
		ImFont* dst_font = cfg.DstFont; // We can have multiple input fonts writing into a same destination font (when using MergeMode=true)
		if (cfg.MergeMode)
			dst_font->BuildLookupTable();

		const float font_scale = stbtt_ScaleForPixelHeight(&tmp.FontInfo, cfg.SizePixels);
		int unscaled_ascent, unscaled_descent, unscaled_line_gap;
		stbtt_GetFontVMetrics(&tmp.FontInfo, &unscaled_ascent, &unscaled_descent, &unscaled_line_gap);

		const float ascent = ImFloor(unscaled_ascent * font_scale + ((unscaled_ascent > 0.0f) ? +1 : -1));
		const float descent = ImFloor(unscaled_descent * font_scale + ((unscaled_descent > 0.0f) ? +1 : -1));
		ImFontAtlasBuildSetupFont(atlas, dst_font, &cfg, ascent, descent);
		const float off_x = cfg.GlyphOffset.x;
		const float off_y = cfg.GlyphOffset.y + (float)(int)(dst_font->Ascent + 0.5f);

		for (int i = 0; i < tmp.RangesCount; i++)
		{
			stbtt_pack_range& range = tmp.Ranges[i];
			for (int char_idx = 0; char_idx < range.num_chars; char_idx += 1)
			{
				const stbtt_packedchar& pc = range.chardata_for_range[char_idx];
				if (!pc.x0 && !pc.x1 && !pc.y0 && !pc.y1)
					continue;

				const int codepoint = range.first_unicode_codepoint_in_range + char_idx;
				if (cfg.MergeMode && dst_font->FindGlyphNoFallback((unsigned short)codepoint))
					continue;

				stbtt_aligned_quad q;
				float dummy_x = 0.0f, dummy_y = 0.0f;
				stbtt_GetPackedQuad(range.chardata_for_range, atlas->TexWidth, atlas->TexHeight, char_idx, &dummy_x, &dummy_y, &q, 0);
				dst_font->AddGlyph((ImWchar)codepoint, q.x0 + off_x, q.y0 + off_y, q.x1 + off_x, q.y1 + off_y, q.s0, q.t0, q.s1, q.t1, pc.xadvance);
			}
		}
	}

	// Cleanup temporaries
	ImGui::MemFree(buf_packedchars);
	ImGui::MemFree(buf_ranges);
	ImGui::MemFree(tmp_array);

	ImFontAtlasBuildFinish(atlas);

	return true;
}

void ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas)
{
	if (atlas->CustomRectIds[0] >= 0)
		return;
	if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
		atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * 2 + 1, FONT_ATLAS_DEFAULT_TEX_DATA_H);
	else
		atlas->CustomRectIds[0] = atlas->AddCustomRectRegular(FONT_ATLAS_DEFAULT_TEX_DATA_ID, 2, 2);
}

void ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent)
{
	if (!font_config->MergeMode)
	{
		font->ClearOutputData();
		font->FontSize = font_config->SizePixels;
		font->ConfigData = font_config;
		font->ContainerAtlas = atlas;
		font->Ascent = ascent;
		font->Descent = descent;
	}
	font->ConfigDataCount++;
}

void ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* pack_context_opaque)
{
	stbrp_context* pack_context = (stbrp_context*)pack_context_opaque;

	ImVector<ImFontAtlas::CustomRect>& user_rects = atlas->CustomRects;
	IM_ASSERT(user_rects.Size >= 1); // We expect at least the default custom rects to be registered, else something went wrong.

	ImVector<stbrp_rect> pack_rects;
	pack_rects.resize(user_rects.Size);
	memset(pack_rects.Data, 0, sizeof(stbrp_rect) * user_rects.Size);
	for (int i = 0; i < user_rects.Size; i++)
	{
		pack_rects[i].w = user_rects[i].Width;
		pack_rects[i].h = user_rects[i].Height;
	}
	stbrp_pack_rects(pack_context, &pack_rects[0], pack_rects.Size);
	for (int i = 0; i < pack_rects.Size; i++)
		if (pack_rects[i].was_packed)
		{
			user_rects[i].X = pack_rects[i].x;
			user_rects[i].Y = pack_rects[i].y;
			IM_ASSERT(pack_rects[i].w == user_rects[i].Width && pack_rects[i].h == user_rects[i].Height);
			atlas->TexHeight = ImMax(atlas->TexHeight, pack_rects[i].y + pack_rects[i].h);
		}
}

static void ImFontAtlasBuildRenderDefaultTexData(ImFontAtlas* atlas)
{
	IM_ASSERT(atlas->CustomRectIds[0] >= 0);
	IM_ASSERT(atlas->TexPixelsAlpha8 != NULL);
	ImFontAtlas::CustomRect& r = atlas->CustomRects[atlas->CustomRectIds[0]];
	IM_ASSERT(r.ID == FONT_ATLAS_DEFAULT_TEX_DATA_ID);
	IM_ASSERT(r.IsPacked());

	const int w = atlas->TexWidth;
	if (!(atlas->Flags & ImFontAtlasFlags_NoMouseCursors))
	{
		// Render/copy pixels
		IM_ASSERT(r.Width == FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF * 2 + 1 && r.Height == FONT_ATLAS_DEFAULT_TEX_DATA_H);
		for (int y = 0, n = 0; y < FONT_ATLAS_DEFAULT_TEX_DATA_H; y++)
			for (int x = 0; x < FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF; x++, n++)
			{
				const int offset0 = (int)(r.X + x) + (int)(r.Y + y) * w;
				const int offset1 = offset0 + FONT_ATLAS_DEFAULT_TEX_DATA_W_HALF + 1;
				atlas->TexPixelsAlpha8[offset0] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == '.' ? 0xFF : 0x00;
				atlas->TexPixelsAlpha8[offset1] = FONT_ATLAS_DEFAULT_TEX_DATA_PIXELS[n] == 'X' ? 0xFF : 0x00;
			}
	}
	else
	{
		IM_ASSERT(r.Width == 2 && r.Height == 2);
		const int offset = (int)(r.X) + (int)(r.Y) * w;
		atlas->TexPixelsAlpha8[offset] = atlas->TexPixelsAlpha8[offset + 1] = atlas->TexPixelsAlpha8[offset + w] = atlas->TexPixelsAlpha8[offset + w + 1] = 0xFF;
	}
	atlas->TexUvWhitePixel = ImVec2((r.X + 0.5f) * atlas->TexUvScale.x, (r.Y + 0.5f) * atlas->TexUvScale.y);
}

void ImFontAtlasBuildFinish(ImFontAtlas* atlas)
{
	// Render into our custom data block
	ImFontAtlasBuildRenderDefaultTexData(atlas);

	// Register custom rectangle glyphs
	for (int i = 0; i < atlas->CustomRects.Size; i++)
	{
		const ImFontAtlas::CustomRect& r = atlas->CustomRects[i];
		if (r.Font == NULL || r.ID > 0x10000)
			continue;

		IM_ASSERT(r.Font->ContainerAtlas == atlas);
		ImVec2 uv0, uv1;
		atlas->CalcCustomRectUV(&r, &uv0, &uv1);
		r.Font->AddGlyph((ImWchar)r.ID, r.GlyphOffset.x, r.GlyphOffset.y, r.GlyphOffset.x + r.Width, r.GlyphOffset.y + r.Height, uv0.x, uv0.y, uv1.x, uv1.y, r.GlyphAdvanceX);
	}

	// Build all fonts lookup tables
	for (int i = 0; i < atlas->Fonts.Size; i++)
		if (atlas->Fonts[i]->DirtyLookupTables)
			atlas->Fonts[i]->BuildLookupTable();
}

// Retrieve list of range (2 int per range, values are inclusive)
const ImWchar* ImFontAtlas::GetGlyphRangesDefault()
{
	static const ImWchar ranges[] =
	{
		0x0020, 0x00FF, // Basic Latin + Latin Supplement
		0,
	};
	return &ranges[0];
}

const ImWchar* ImFontAtlas::GetGlyphRangesKorean()
{
	static const ImWchar ranges[] =
	{
		0x0020, 0x00FF, // Basic Latin + Latin Supplement
		0x3131, 0x3163, // Korean alphabets
		0xAC00, 0xD79D, // Korean characters
		0,
	};
	return &ranges[0];
}

const ImWchar* ImFontAtlas::GetGlyphRangesChinese()
{
	static const ImWchar ranges[] =
	{
		0x0020, 0x00FF, // Basic Latin + Latin Supplement
		0x3000, 0x30FF, // Punctuations, Hiragana, Katakana
		0x31F0, 0x31FF, // Katakana Phonetic Extensions
		0xFF00, 0xFFEF, // Half-width characters
		0x4e00, 0x9FAF, // CJK Ideograms
		0,
	};
	return &ranges[0];
}

const ImWchar* ImFontAtlas::GetGlyphRangesJapanese()
{
	// Store the 1946 ideograms code points as successive offsets from the initial unicode codepoint 0x4E00. Each offset has an implicit +1.
	// This encoding is designed to helps us reduce the source code size.
	// FIXME: Source a list of the revised 2136 joyo kanji list from 2010 and rebuild this.
	// The current list was sourced from http://theinstructionlimit.com/author/renaudbedardrenaudbedard/page/3
	// Note that you may use ImFontAtlas::GlyphRangesBuilder to create your own ranges, by merging existing ranges or adding new characters.
	static const short offsets_from_0x4E00[] =
	{
		-1,0,1,3,0,0,0,0,1,0,5,1,1,0,7,4,6,10,0,1,9,9,7,1,3,19,1,10,7,1,0,1,0,5,1,0,6,4,2,6,0,0,12,6,8,0,3,5,0,1,0,9,0,0,8,1,1,3,4,5,13,0,0,8,2,17,
		4,3,1,1,9,6,0,0,0,2,1,3,2,22,1,9,11,1,13,1,3,12,0,5,9,2,0,6,12,5,3,12,4,1,2,16,1,1,4,6,5,3,0,6,13,15,5,12,8,14,0,0,6,15,3,6,0,18,8,1,6,14,1,
		5,4,12,24,3,13,12,10,24,0,0,0,1,0,1,1,2,9,10,2,2,0,0,3,3,1,0,3,8,0,3,2,4,4,1,6,11,10,14,6,15,3,4,15,1,0,0,5,2,2,0,0,1,6,5,5,6,0,3,6,5,0,0,1,0,
		11,2,2,8,4,7,0,10,0,1,2,17,19,3,0,2,5,0,6,2,4,4,6,1,1,11,2,0,3,1,2,1,2,10,7,6,3,16,0,8,24,0,0,3,1,1,3,0,1,6,0,0,0,2,0,1,5,15,0,1,0,0,2,11,19,
		1,4,19,7,6,5,1,0,0,0,0,5,1,0,1,9,0,0,5,0,2,0,1,0,3,0,11,3,0,2,0,0,0,0,0,9,3,6,4,12,0,14,0,0,29,10,8,0,14,37,13,0,31,16,19,0,8,30,1,20,8,3,48,
		21,1,0,12,0,10,44,34,42,54,11,18,82,0,2,1,2,12,1,0,6,2,17,2,12,7,0,7,17,4,2,6,24,23,8,23,39,2,16,23,1,0,5,1,2,15,14,5,6,2,11,0,8,6,2,2,2,14,
		20,4,15,3,4,11,10,10,2,5,2,1,30,2,1,0,0,22,5,5,0,3,1,5,4,1,0,0,2,2,21,1,5,1,2,16,2,1,3,4,0,8,4,0,0,5,14,11,2,16,1,13,1,7,0,22,15,3,1,22,7,14,
		22,19,11,24,18,46,10,20,64,45,3,2,0,4,5,0,1,4,25,1,0,0,2,10,0,0,0,1,0,1,2,0,0,9,1,2,0,0,0,2,5,2,1,1,5,5,8,1,1,1,5,1,4,9,1,3,0,1,0,1,1,2,0,0,
		2,0,1,8,22,8,1,0,0,0,0,4,2,1,0,9,8,5,0,9,1,30,24,2,6,4,39,0,14,5,16,6,26,179,0,2,1,1,0,0,0,5,2,9,6,0,2,5,16,7,5,1,1,0,2,4,4,7,15,13,14,0,0,
		3,0,1,0,0,0,2,1,6,4,5,1,4,9,0,3,1,8,0,0,10,5,0,43,0,2,6,8,4,0,2,0,0,9,6,0,9,3,1,6,20,14,6,1,4,0,7,2,3,0,2,0,5,0,3,1,0,3,9,7,0,3,4,0,4,9,1,6,0,
		9,0,0,2,3,10,9,28,3,6,2,4,1,2,32,4,1,18,2,0,3,1,5,30,10,0,2,2,2,0,7,9,8,11,10,11,7,2,13,7,5,10,0,3,40,2,0,1,6,12,0,4,5,1,5,11,11,21,4,8,3,7,
		8,8,33,5,23,0,0,19,8,8,2,3,0,6,1,1,1,5,1,27,4,2,5,0,3,5,6,3,1,0,3,1,12,5,3,3,2,0,7,7,2,1,0,4,0,1,1,2,0,10,10,6,2,5,9,7,5,15,15,21,6,11,5,20,
		4,3,5,5,2,5,0,2,1,0,1,7,28,0,9,0,5,12,5,5,18,30,0,12,3,3,21,16,25,32,9,3,14,11,24,5,66,9,1,2,0,5,9,1,5,1,8,0,8,3,3,0,1,15,1,4,8,1,2,7,0,7,2,
		8,3,7,5,3,7,10,2,1,0,0,2,25,0,6,4,0,10,0,4,2,4,1,12,5,38,4,0,4,1,10,5,9,4,0,14,4,2,5,18,20,21,1,3,0,5,0,7,0,3,7,1,3,1,1,8,1,0,0,0,3,2,5,2,11,
		6,0,13,1,3,9,1,12,0,16,6,2,1,0,2,1,12,6,13,11,2,0,28,1,7,8,14,13,8,13,0,2,0,5,4,8,10,2,37,42,19,6,6,7,4,14,11,18,14,80,7,6,0,4,72,12,36,27,
		7,7,0,14,17,19,164,27,0,5,10,7,3,13,6,14,0,2,2,5,3,0,6,13,0,0,10,29,0,4,0,3,13,0,3,1,6,51,1,5,28,2,0,8,0,20,2,4,0,25,2,10,13,10,0,16,4,0,1,0,
		2,1,7,0,1,8,11,0,0,1,2,7,2,23,11,6,6,4,16,2,2,2,0,22,9,3,3,5,2,0,15,16,21,2,9,20,15,15,5,3,9,1,0,0,1,7,7,5,4,2,2,2,38,24,14,0,0,15,5,6,24,14,
		5,5,11,0,21,12,0,3,8,4,11,1,8,0,11,27,7,2,4,9,21,59,0,1,39,3,60,62,3,0,12,11,0,3,30,11,0,13,88,4,15,5,28,13,1,4,48,17,17,4,28,32,46,0,16,0,
		18,11,1,8,6,38,11,2,6,11,38,2,0,45,3,11,2,7,8,4,30,14,17,2,1,1,65,18,12,16,4,2,45,123,12,56,33,1,4,3,4,7,0,0,0,3,2,0,16,4,2,4,2,0,7,4,5,2,26,
		2,25,6,11,6,1,16,2,6,17,77,15,3,35,0,1,0,5,1,0,38,16,6,3,12,3,3,3,0,9,3,1,3,5,2,9,0,18,0,25,1,3,32,1,72,46,6,2,7,1,3,14,17,0,28,1,40,13,0,20,
		15,40,6,38,24,12,43,1,1,9,0,12,6,0,6,2,4,19,3,7,1,48,0,9,5,0,5,6,9,6,10,15,2,11,19,3,9,2,0,1,10,1,27,8,1,3,6,1,14,0,26,0,27,16,3,4,9,6,2,23,
		9,10,5,25,2,1,6,1,1,48,15,9,15,14,3,4,26,60,29,13,37,21,1,6,4,0,2,11,22,23,16,16,2,2,1,3,0,5,1,6,4,0,0,4,0,0,8,3,0,2,5,0,7,1,7,3,13,2,4,10,
		3,0,2,31,0,18,3,0,12,10,4,1,0,7,5,7,0,5,4,12,2,22,10,4,2,15,2,8,9,0,23,2,197,51,3,1,1,4,13,4,3,21,4,19,3,10,5,40,0,4,1,1,10,4,1,27,34,7,21,
		2,17,2,9,6,4,2,3,0,4,2,7,8,2,5,1,15,21,3,4,4,2,2,17,22,1,5,22,4,26,7,0,32,1,11,42,15,4,1,2,5,0,19,3,1,8,6,0,10,1,9,2,13,30,8,2,24,17,19,1,4,
		4,25,13,0,10,16,11,39,18,8,5,30,82,1,6,8,18,77,11,13,20,75,11,112,78,33,3,0,0,60,17,84,9,1,1,12,30,10,49,5,32,158,178,5,5,6,3,3,1,3,1,4,7,6,
		19,31,21,0,2,9,5,6,27,4,9,8,1,76,18,12,1,4,0,3,3,6,3,12,2,8,30,16,2,25,1,5,5,4,3,0,6,10,2,3,1,0,5,1,19,3,0,8,1,5,2,6,0,0,0,19,1,2,0,5,1,2,5,
		1,3,7,0,4,12,7,3,10,22,0,9,5,1,0,2,20,1,1,3,23,30,3,9,9,1,4,191,14,3,15,6,8,50,0,1,0,0,4,0,0,1,0,2,4,2,0,2,3,0,2,0,2,2,8,7,0,1,1,1,3,3,17,11,
		91,1,9,3,2,13,4,24,15,41,3,13,3,1,20,4,125,29,30,1,0,4,12,2,21,4,5,5,19,11,0,13,11,86,2,18,0,7,1,8,8,2,2,22,1,2,6,5,2,0,1,2,8,0,2,0,5,2,1,0,
		2,10,2,0,5,9,2,1,2,0,1,0,4,0,0,10,2,5,3,0,6,1,0,1,4,4,33,3,13,17,3,18,6,4,7,1,5,78,0,4,1,13,7,1,8,1,0,35,27,15,3,0,0,0,1,11,5,41,38,15,22,6,
		14,14,2,1,11,6,20,63,5,8,27,7,11,2,2,40,58,23,50,54,56,293,8,8,1,5,1,14,0,1,12,37,89,8,8,8,2,10,6,0,0,0,4,5,2,1,0,1,1,2,7,0,3,3,0,4,6,0,3,2,
		19,3,8,0,0,0,4,4,16,0,4,1,5,1,3,0,3,4,6,2,17,10,10,31,6,4,3,6,10,126,7,3,2,2,0,9,0,0,5,20,13,0,15,0,6,0,2,5,8,64,50,3,2,12,2,9,0,0,11,8,20,
		109,2,18,23,0,0,9,61,3,0,28,41,77,27,19,17,81,5,2,14,5,83,57,252,14,154,263,14,20,8,13,6,57,39,38,
	};
	static ImWchar base_ranges[] =
	{
		0x0020, 0x00FF, // Basic Latin + Latin Supplement
		0x3000, 0x30FF, // Punctuations, Hiragana, Katakana
		0x31F0, 0x31FF, // Katakana Phonetic Extensions
		0xFF00, 0xFFEF, // Half-width characters
	};
	static bool full_ranges_unpacked = false;
	static ImWchar full_ranges[IM_ARRAYSIZE(base_ranges) + IM_ARRAYSIZE(offsets_from_0x4E00) * 2 + 1];
	if (!full_ranges_unpacked)
	{
		// Unpack
		int codepoint = 0x4e00;
		memcpy(full_ranges, base_ranges, sizeof(base_ranges));
		ImWchar* dst = full_ranges + IM_ARRAYSIZE(base_ranges);
		for (int n = 0; n < IM_ARRAYSIZE(offsets_from_0x4E00); n++, dst += 2)
			dst[0] = dst[1] = (ImWchar)(codepoint += (offsets_from_0x4E00[n] + 1));
		dst[0] = 0;
		full_ranges_unpacked = true;
	}
	return &full_ranges[0];
}

const ImWchar* ImFontAtlas::GetGlyphRangesCyrillic()
{
	static const ImWchar ranges[] =
	{
		0x0020, 0x00FF, // Basic Latin + Latin Supplement
		0x0400, 0x052F, // Cyrillic + Cyrillic Supplement
		0x2DE0, 0x2DFF, // Cyrillic Extended-A
		0xA640, 0xA69F, // Cyrillic Extended-B
		0,
	};
	return &ranges[0];
}

const ImWchar* ImFontAtlas::GetGlyphRangesThai()
{
	static const ImWchar ranges[] =
	{
		0x0020, 0x00FF, // Basic Latin
		0x2010, 0x205E, // Punctuations
		0x0E00, 0x0E7F, // Thai
		0,
	};
	return &ranges[0];
}

//-----------------------------------------------------------------------------
// ImFontAtlas::GlyphRangesBuilder
//-----------------------------------------------------------------------------

void ImFontAtlas::GlyphRangesBuilder::AddText(const char* text, const char* text_end)
{
	while (text_end ? (text < text_end) : *text)
	{
		unsigned int c = 0;
		int c_len = ImTextCharFromUtf8(&c, text, text_end);
		text += c_len;
		if (c_len == 0)
			break;
		if (c < 0x10000)
			AddChar((ImWchar)c);
	}
}

void ImFontAtlas::GlyphRangesBuilder::AddRanges(const ImWchar* ranges)
{
	for (; ranges[0]; ranges += 2)
		for (ImWchar c = ranges[0]; c <= ranges[1]; c++)
			AddChar(c);
}

void ImFontAtlas::GlyphRangesBuilder::BuildRanges(ImVector<ImWchar>* out_ranges)
{
	for (int n = 0; n < 0x10000; n++)
		if (GetBit(n))
		{
			out_ranges->push_back((ImWchar)n);
			while (n < 0x10000 && GetBit(n + 1))
				n++;
			out_ranges->push_back((ImWchar)n);
		}
	out_ranges->push_back(0);
}

//-----------------------------------------------------------------------------
// ImFont
//-----------------------------------------------------------------------------

ImFont::ImFont()
{
	Scale = 1.0f;
	FallbackChar = (ImWchar)'?';
	DisplayOffset = ImVec2(0.0f, 0.0f);
	ClearOutputData();
}

ImFont::~ImFont()
{
	// Invalidate active font so that the user gets a clear crash instead of a dangling pointer.
	// If you want to delete fonts you need to do it between Render() and NewFrame().
	// FIXME-CLEANUP
	/*
	ImGuiContext& g = *GImGui;
	if (g.Font == this)
	g.Font = NULL;
	*/
	ClearOutputData();
}

void    ImFont::ClearOutputData()
{
	FontSize = 0.0f;
	Glyphs.clear();
	IndexAdvanceX.clear();
	IndexLookup.clear();
	FallbackGlyph = NULL;
	FallbackAdvanceX = 0.0f;
	ConfigDataCount = 0;
	ConfigData = NULL;
	ContainerAtlas = NULL;
	Ascent = Descent = 0.0f;
	DirtyLookupTables = true;
	MetricsTotalSurface = 0;
}

void ImFont::BuildLookupTable()
{
	int max_codepoint = 0;
	for (int i = 0; i != Glyphs.Size; i++)
		max_codepoint = ImMax(max_codepoint, (int)Glyphs[i].Codepoint);

	IM_ASSERT(Glyphs.Size < 0xFFFF); // -1 is reserved
	IndexAdvanceX.clear();
	IndexLookup.clear();
	DirtyLookupTables = false;
	GrowIndex(max_codepoint + 1);
	for (int i = 0; i < Glyphs.Size; i++)
	{
		int codepoint = (int)Glyphs[i].Codepoint;
		IndexAdvanceX[codepoint] = Glyphs[i].AdvanceX;
		IndexLookup[codepoint] = (unsigned short)i;
	}

	// Create a glyph to handle TAB
	// FIXME: Needs proper TAB handling but it needs to be contextualized (or we could arbitrary say that each string starts at "column 0" ?)
	if (FindGlyph((unsigned short)' '))
	{
		if (Glyphs.back().Codepoint != '\t')   // So we can call this function multiple times
			Glyphs.resize(Glyphs.Size + 1);
		ImFontGlyph& tab_glyph = Glyphs.back();
		tab_glyph = *FindGlyph((unsigned short)' ');
		tab_glyph.Codepoint = '\t';
		tab_glyph.AdvanceX *= 4;
		IndexAdvanceX[(int)tab_glyph.Codepoint] = (float)tab_glyph.AdvanceX;
		IndexLookup[(int)tab_glyph.Codepoint] = (unsigned short)(Glyphs.Size - 1);
	}

	FallbackGlyph = FindGlyphNoFallback(FallbackChar);
	FallbackAdvanceX = FallbackGlyph ? FallbackGlyph->AdvanceX : 0.0f;
	for (int i = 0; i < max_codepoint + 1; i++)
		if (IndexAdvanceX[i] < 0.0f)
			IndexAdvanceX[i] = FallbackAdvanceX;
}

void ImFont::SetFallbackChar(ImWchar c)
{
	FallbackChar = c;
	BuildLookupTable();
}

void ImFont::GrowIndex(int new_size)
{
	IM_ASSERT(IndexAdvanceX.Size == IndexLookup.Size);
	if (new_size <= IndexLookup.Size)
		return;
	IndexAdvanceX.resize(new_size, -1.0f);
	IndexLookup.resize(new_size, (unsigned short)-1);
}

void ImFont::AddGlyph(ImWchar codepoint, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
{
	Glyphs.resize(Glyphs.Size + 1);
	ImFontGlyph& glyph = Glyphs.back();
	glyph.Codepoint = (ImWchar)codepoint;
	glyph.X0 = x0;
	glyph.Y0 = y0;
	glyph.X1 = x1;
	glyph.Y1 = y1;
	glyph.U0 = u0;
	glyph.V0 = v0;
	glyph.U1 = u1;
	glyph.V1 = v1;
	glyph.AdvanceX = advance_x + ConfigData->GlyphExtraSpacing.x;  // Bake spacing into AdvanceX

	if (ConfigData->PixelSnapH)
		glyph.AdvanceX = (float)(int)(glyph.AdvanceX + 0.5f);

	// Compute rough surface usage metrics (+1 to account for average padding, +0.99 to round)
	DirtyLookupTables = true;
	MetricsTotalSurface += (int)((glyph.U1 - glyph.U0) * ContainerAtlas->TexWidth + 1.99f) * (int)((glyph.V1 - glyph.V0) * ContainerAtlas->TexHeight + 1.99f);
}

void ImFont::AddRemapChar(ImWchar dst, ImWchar src, bool overwrite_dst)
{
	IM_ASSERT(IndexLookup.Size > 0);    // Currently this can only be called AFTER the font has been built, aka after calling ImFontAtlas::GetTexDataAs*() function.
	int index_size = IndexLookup.Size;

	if (dst < index_size && IndexLookup.Data[dst] == (unsigned short)-1 && !overwrite_dst) // 'dst' already exists
		return;
	if (src >= index_size && dst >= index_size) // both 'dst' and 'src' don't exist -> no-op
		return;

	GrowIndex(dst + 1);
	IndexLookup[dst] = (src < index_size) ? IndexLookup.Data[src] : (unsigned short)-1;
	IndexAdvanceX[dst] = (src < index_size) ? IndexAdvanceX.Data[src] : 1.0f;
}

const ImFontGlyph* ImFont::FindGlyph(ImWchar c) const
{
	if (c >= IndexLookup.Size)
		return FallbackGlyph;
	const unsigned short i = IndexLookup[c];
	if (i == (unsigned short)-1)
		return FallbackGlyph;
	return &Glyphs.Data[i];
}

const ImFontGlyph* ImFont::FindGlyphNoFallback(ImWchar c) const
{
	if (c >= IndexLookup.Size)
		return NULL;
	const unsigned short i = IndexLookup[c];
	if (i == (unsigned short)-1)
		return NULL;
	return &Glyphs.Data[i];
}

const char* ImFont::CalcWordWrapPositionA(float scale, const char* text, const char* text_end, float wrap_width) const
{
	// Simple word-wrapping for English, not full-featured. Please submit failing cases!
	// FIXME: Much possible improvements (don't cut things like "word !", "word!!!" but cut within "word,,,,", more sensible support for punctuations, support for Unicode punctuations, etc.)

	// For references, possible wrap point marked with ^
	//  "aaa bbb, ccc,ddd. eee   fff. ggg!"
	//      ^    ^    ^   ^   ^__    ^    ^

	// List of hardcoded separators: .,;!?'"

	// Skip extra blanks after a line returns (that includes not counting them in width computation)
	// e.g. "Hello    world" --> "Hello" "World"

	// Cut words that cannot possibly fit within one line.
	// e.g.: "The tropical fish" with ~5 characters worth of width --> "The tr" "opical" "fish"

	float line_width = 0.0f;
	float word_width = 0.0f;
	float blank_width = 0.0f;
	wrap_width /= scale; // We work with unscaled widths to avoid scaling every characters

	const char* word_end = text;
	const char* prev_word_end = NULL;
	bool inside_word = true;

	const char* s = text;
	while (s < text_end)
	{
		unsigned int c = (unsigned int)*s;
		const char* next_s;
		if (c < 0x80)
			next_s = s + 1;
		else
			next_s = s + ImTextCharFromUtf8(&c, s, text_end);
		if (c == 0)
			break;

		if (c < 32)
		{
			if (c == '\n')
			{
				line_width = word_width = blank_width = 0.0f;
				inside_word = true;
				s = next_s;
				continue;
			}
			if (c == '\r')
			{
				s = next_s;
				continue;
			}
		}

		const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX[(int)c] : FallbackAdvanceX);
		if (ImCharIsSpace(c))
		{
			if (inside_word)
			{
				line_width += blank_width;
				blank_width = 0.0f;
				word_end = s;
			}
			blank_width += char_width;
			inside_word = false;
		}
		else
		{
			word_width += char_width;
			if (inside_word)
			{
				word_end = next_s;
			}
			else
			{
				prev_word_end = word_end;
				line_width += word_width + blank_width;
				word_width = blank_width = 0.0f;
			}

			// Allow wrapping after punctuation.
			inside_word = !(c == '.' || c == ',' || c == ';' || c == '!' || c == '?' || c == '\"');
		}

		// We ignore blank width at the end of the line (they can be skipped)
		if (line_width + word_width >= wrap_width)
		{
			// Words that cannot possibly fit within an entire line will be cut anywhere.
			if (word_width < wrap_width)
				s = prev_word_end ? prev_word_end : word_end;
			break;
		}

		s = next_s;
	}

	return s;
}

ImVec2 ImFont::CalcTextSizeA(float size, float max_width, float wrap_width, const char* text_begin, const char* text_end, const char** remaining) const
{
	if (!text_end)
		text_end = text_begin + strlen(text_begin); // FIXME-OPT: Need to avoid this.

	const float line_height = size;
	const float scale = size / FontSize;

	ImVec2 text_size = ImVec2(0, 0);
	float line_width = 0.0f;

	const bool word_wrap_enabled = (wrap_width > 0.0f);
	const char* word_wrap_eol = NULL;

	const char* s = text_begin;
	while (s < text_end)
	{
		if (word_wrap_enabled)
		{
			// Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
			if (!word_wrap_eol)
			{
				word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - line_width);
				if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
					word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below
			}

			if (s >= word_wrap_eol)
			{
				if (text_size.x < line_width)
					text_size.x = line_width;
				text_size.y += line_height;
				line_width = 0.0f;
				word_wrap_eol = NULL;

				// Wrapping skips upcoming blanks
				while (s < text_end)
				{
					const char c = *s;
					if (ImCharIsSpace((unsigned int)c)) { s++; }
					else if (c == '\n') { s++; break; }
					else { break; }
				}
				continue;
			}
		}

		// Decode and advance source
		const char* prev_s = s;
		unsigned int c = (unsigned int)*s;
		if (c < 0x80)
		{
			s += 1;
		}
		else
		{
			s += ImTextCharFromUtf8(&c, s, text_end);
			if (c == 0) // Malformed UTF-8?
				break;
		}

		if (c < 32)
		{
			if (c == '\n')
			{
				text_size.x = ImMax(text_size.x, line_width);
				text_size.y += line_height;
				line_width = 0.0f;
				continue;
			}
			if (c == '\r')
				continue;
		}

		const float char_width = ((int)c < IndexAdvanceX.Size ? IndexAdvanceX[(int)c] : FallbackAdvanceX) * scale;
		if (line_width + char_width >= max_width)
		{
			s = prev_s;
			break;
		}

		line_width += char_width;
	}

	if (text_size.x < line_width)
		text_size.x = line_width;

	if (line_width > 0 || text_size.y == 0.0f)
		text_size.y += line_height;

	if (remaining)
		*remaining = s;

	return text_size;
}

void ImFont::RenderChar(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, unsigned short c) const
{
	if (c == ' ' || c == '\t' || c == '\n' || c == '\r') // Match behavior of RenderText(), those 4 codepoints are hard-coded.
		return;
	if (const ImFontGlyph* glyph = FindGlyph(c))
	{
		float scale = (size >= 0.0f) ? (size / FontSize) : 1.0f;
		pos.x = (float)(int)pos.x + DisplayOffset.x;
		pos.y = (float)(int)pos.y + DisplayOffset.y;
		draw_list->PrimReserve(6, 4);
		draw_list->PrimRectUV(ImVec2(pos.x + glyph->X0 * scale, pos.y + glyph->Y0 * scale), ImVec2(pos.x + glyph->X1 * scale, pos.y + glyph->Y1 * scale), ImVec2(glyph->U0, glyph->V0), ImVec2(glyph->U1, glyph->V1), col);
	}
}

void ImFont::RenderText(ImDrawList* draw_list, float size, ImVec2 pos, ImU32 col, const ImVec4& clip_rect, const char* text_begin, const char* text_end, float wrap_width, bool cpu_fine_clip) const
{
	if (!text_end)
		text_end = text_begin + strlen(text_begin); // ImGui functions generally already provides a valid text_end, so this is merely to handle direct calls.

													// Align to be pixel perfect
	pos.x = (float)(int)pos.x + DisplayOffset.x;
	pos.y = (float)(int)pos.y + DisplayOffset.y;
	float x = pos.x;
	float y = pos.y;
	if (y > clip_rect.w)
		return;

	const float scale = size / FontSize;
	const float line_height = FontSize * scale;
	const bool word_wrap_enabled = (wrap_width > 0.0f);
	const char* word_wrap_eol = NULL;

	// Skip non-visible lines
	const char* s = text_begin;
	if (!word_wrap_enabled && y + line_height < clip_rect.y)
		while (s < text_end && *s != '\n')  // Fast-forward to next line
			s++;

	// Reserve vertices for remaining worse case (over-reserving is useful and easily amortized)
	const int vtx_count_max = (int)(text_end - s) * 4;
	const int idx_count_max = (int)(text_end - s) * 6;
	const int idx_expected_size = draw_list->IdxBuffer.Size + idx_count_max;
	draw_list->PrimReserve(idx_count_max, vtx_count_max);

	ImDrawVert* vtx_write = draw_list->_VtxWritePtr;
	ImDrawIdx* idx_write = draw_list->_IdxWritePtr;
	unsigned int vtx_current_idx = draw_list->_VtxCurrentIdx;

	while (s < text_end)
	{
		if (word_wrap_enabled)
		{
			// Calculate how far we can render. Requires two passes on the string data but keeps the code simple and not intrusive for what's essentially an uncommon feature.
			if (!word_wrap_eol)
			{
				word_wrap_eol = CalcWordWrapPositionA(scale, s, text_end, wrap_width - (x - pos.x));
				if (word_wrap_eol == s) // Wrap_width is too small to fit anything. Force displaying 1 character to minimize the height discontinuity.
					word_wrap_eol++;    // +1 may not be a character start point in UTF-8 but it's ok because we use s >= word_wrap_eol below
			}

			if (s >= word_wrap_eol)
			{
				x = pos.x;
				y += line_height;
				word_wrap_eol = NULL;

				// Wrapping skips upcoming blanks
				while (s < text_end)
				{
					const char c = *s;
					if (ImCharIsSpace((unsigned int)c)) { s++; }
					else if (c == '\n') { s++; break; }
					else { break; }
				}
				continue;
			}
		}

		// Decode and advance source
		unsigned int c = (unsigned int)*s;
		if (c < 0x80)
		{
			s += 1;
		}
		else
		{
			s += ImTextCharFromUtf8(&c, s, text_end);
			if (c == 0) // Malformed UTF-8?
				break;
		}

		if (c < 32)
		{
			if (c == '\n')
			{
				x = pos.x;
				y += line_height;

				if (y > clip_rect.w)
					break;
				if (!word_wrap_enabled && y + line_height < clip_rect.y)
					while (s < text_end && *s != '\n')  // Fast-forward to next line
						s++;
				continue;
			}
			if (c == '\r')
				continue;
		}

		float char_width = 0.0f;
		if (const ImFontGlyph* glyph = FindGlyph((unsigned short)c))
		{
			char_width = glyph->AdvanceX * scale;

			// Arbitrarily assume that both space and tabs are empty glyphs as an optimization
			if (c != ' ' && c != '\t')
			{
				// We don't do a second finer clipping test on the Y axis as we've already skipped anything before clip_rect.y and exit once we pass clip_rect.w
				float x1 = x + glyph->X0 * scale;
				float x2 = x + glyph->X1 * scale;
				float y1 = y + glyph->Y0 * scale;
				float y2 = y + glyph->Y1 * scale;
				if (x1 <= clip_rect.z && x2 >= clip_rect.x)
				{
					// Render a character
					float u1 = glyph->U0;
					float v1 = glyph->V0;
					float u2 = glyph->U1;
					float v2 = glyph->V1;

					// CPU side clipping used to fit text in their frame when the frame is too small. Only does clipping for axis aligned quads.
					if (cpu_fine_clip)
					{
						if (x1 < clip_rect.x)
						{
							u1 = u1 + (1.0f - (x2 - clip_rect.x) / (x2 - x1)) * (u2 - u1);
							x1 = clip_rect.x;
						}
						if (y1 < clip_rect.y)
						{
							v1 = v1 + (1.0f - (y2 - clip_rect.y) / (y2 - y1)) * (v2 - v1);
							y1 = clip_rect.y;
						}
						if (x2 > clip_rect.z)
						{
							u2 = u1 + ((clip_rect.z - x1) / (x2 - x1)) * (u2 - u1);
							x2 = clip_rect.z;
						}
						if (y2 > clip_rect.w)
						{
							v2 = v1 + ((clip_rect.w - y1) / (y2 - y1)) * (v2 - v1);
							y2 = clip_rect.w;
						}
						if (y1 >= y2)
						{
							x += char_width;
							continue;
						}
					}

					// We are NOT calling PrimRectUV() here because non-inlined causes too much overhead in a debug builds. Inlined here:
					{
						idx_write[0] = (ImDrawIdx)(vtx_current_idx); idx_write[1] = (ImDrawIdx)(vtx_current_idx + 1); idx_write[2] = (ImDrawIdx)(vtx_current_idx + 2);
						idx_write[3] = (ImDrawIdx)(vtx_current_idx); idx_write[4] = (ImDrawIdx)(vtx_current_idx + 2); idx_write[5] = (ImDrawIdx)(vtx_current_idx + 3);
						vtx_write[0].pos.x = x1; vtx_write[0].pos.y = y1; vtx_write[0].col = col; vtx_write[0].uv.x = u1; vtx_write[0].uv.y = v1;
						vtx_write[1].pos.x = x2; vtx_write[1].pos.y = y1; vtx_write[1].col = col; vtx_write[1].uv.x = u2; vtx_write[1].uv.y = v1;
						vtx_write[2].pos.x = x2; vtx_write[2].pos.y = y2; vtx_write[2].col = col; vtx_write[2].uv.x = u2; vtx_write[2].uv.y = v2;
						vtx_write[3].pos.x = x1; vtx_write[3].pos.y = y2; vtx_write[3].col = col; vtx_write[3].uv.x = u1; vtx_write[3].uv.y = v2;
						vtx_write += 4;
						vtx_current_idx += 4;
						idx_write += 6;
					}
				}
			}
		}

		x += char_width;
	}

	// Give back unused vertices
	draw_list->VtxBuffer.resize((int)(vtx_write - draw_list->VtxBuffer.Data));
	draw_list->IdxBuffer.resize((int)(idx_write - draw_list->IdxBuffer.Data));
	draw_list->CmdBuffer[draw_list->CmdBuffer.Size - 1].ElemCount -= (idx_expected_size - draw_list->IdxBuffer.Size);
	draw_list->_VtxWritePtr = vtx_write;
	draw_list->_IdxWritePtr = idx_write;
	draw_list->_VtxCurrentIdx = (unsigned int)draw_list->VtxBuffer.Size;
}

//-----------------------------------------------------------------------------
// Internals Drawing Helpers
//-----------------------------------------------------------------------------

static inline float ImAcos01(float x)
{
	if (x <= 0.0f) return IM_PI * 0.5f;
	if (x >= 1.0f) return 0.0f;
	return acosf(x);
	//return (-0.69813170079773212f * x * x - 0.87266462599716477f) * x + 1.5707963267948966f; // Cheap approximation, may be enough for what we do.
}

// FIXME: Cleanup and move code to ImDrawList.
void ImGui::RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding)
{
	if (x_end_norm == x_start_norm)
		return;
	if (x_start_norm > x_end_norm)
		ImSwap(x_start_norm, x_end_norm);

	ImVec2 p0 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_start_norm), rect.Min.y);
	ImVec2 p1 = ImVec2(ImLerp(rect.Min.x, rect.Max.x, x_end_norm), rect.Max.y);
	if (rounding == 0.0f)
	{
		draw_list->AddRectFilled(p0, p1, col, 0.0f);
		return;
	}

	rounding = ImClamp(ImMin((rect.Max.x - rect.Min.x) * 0.5f, (rect.Max.y - rect.Min.y) * 0.5f) - 1.0f, 0.0f, rounding);
	const float inv_rounding = 1.0f / rounding;
	const float arc0_b = ImAcos01(1.0f - (p0.x - rect.Min.x) * inv_rounding);
	const float arc0_e = ImAcos01(1.0f - (p1.x - rect.Min.x) * inv_rounding);
	const float x0 = ImMax(p0.x, rect.Min.x + rounding);
	if (arc0_b == arc0_e)
	{
		draw_list->PathLineTo(ImVec2(x0, p1.y));
		draw_list->PathLineTo(ImVec2(x0, p0.y));
	}
	else if (arc0_b == 0.0f && arc0_e == IM_PI * 0.5f)
	{
		draw_list->PathArcToFast(ImVec2(x0, p1.y - rounding), rounding, 3, 6); // BL
		draw_list->PathArcToFast(ImVec2(x0, p0.y + rounding), rounding, 6, 9); // TR
	}
	else
	{
		draw_list->PathArcTo(ImVec2(x0, p1.y - rounding), rounding, IM_PI - arc0_e, IM_PI - arc0_b, 3); // BL
		draw_list->PathArcTo(ImVec2(x0, p0.y + rounding), rounding, IM_PI + arc0_b, IM_PI + arc0_e, 3); // TR
	}
	if (p1.x > rect.Min.x + rounding)
	{
		const float arc1_b = ImAcos01(1.0f - (rect.Max.x - p1.x) * inv_rounding);
		const float arc1_e = ImAcos01(1.0f - (rect.Max.x - p0.x) * inv_rounding);
		const float x1 = ImMin(p1.x, rect.Max.x - rounding);
		if (arc1_b == arc1_e)
		{
			draw_list->PathLineTo(ImVec2(x1, p0.y));
			draw_list->PathLineTo(ImVec2(x1, p1.y));
		}
		else if (arc1_b == 0.0f && arc1_e == IM_PI * 0.5f)
		{
			draw_list->PathArcToFast(ImVec2(x1, p0.y + rounding), rounding, 9, 12); // TR
			draw_list->PathArcToFast(ImVec2(x1, p1.y - rounding), rounding, 0, 3);  // BR
		}
		else
		{
			draw_list->PathArcTo(ImVec2(x1, p0.y + rounding), rounding, -arc1_e, -arc1_b, 3); // TR
			draw_list->PathArcTo(ImVec2(x1, p1.y - rounding), rounding, +arc1_b, +arc1_e, 3); // BR
		}
	}
	draw_list->PathFillConvex(col);
}

//-----------------------------------------------------------------------------
// DEFAULT FONT DATA
//-----------------------------------------------------------------------------
// Compressed with stb_compress() then converted to a C array.
// Use the program in misc/fonts/binary_to_compressed_c.cpp to create the array from a TTF file.
// Decompression from stb.h (public domain) by Sean Barrett https://github.com/nothings/stb/blob/master/stb.h
//-----------------------------------------------------------------------------

static unsigned int stb_decompress_length(const unsigned char* input)
{
	return (input[8] << 24) + (input[9] << 16) + (input[10] << 8) + input[11];
}

static unsigned char* stb__barrier_out_e, * stb__barrier_out_b;
static const unsigned char* stb__barrier_in_b;
static unsigned char* stb__dout;
static void stb__match(const unsigned char* data, unsigned int length)
{
	// INVERSE of memmove... write each byte before copying the next...
	IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
	if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
	if (data < stb__barrier_out_b) { stb__dout = stb__barrier_out_e + 1; return; }
	while (length--)*stb__dout++ = *data++;
}

static void stb__lit(const unsigned char* data, unsigned int length)
{
	IM_ASSERT(stb__dout + length <= stb__barrier_out_e);
	if (stb__dout + length > stb__barrier_out_e) { stb__dout += length; return; }
	if (data < stb__barrier_in_b) { stb__dout = stb__barrier_out_e + 1; return; }
	memcpy(stb__dout, data, length);
	stb__dout += length;
}

#define stb__in2(x)   ((i[x] << 8) + i[(x)+1])
#define stb__in3(x)   ((i[x] << 16) + stb__in2((x)+1))
#define stb__in4(x)   ((i[x] << 24) + stb__in3((x)+1))

static const unsigned char* stb_decompress_token(const unsigned char* i)
{
	if (*i >= 0x20) { // use fewer if's for cases that expand small
		if (*i >= 0x80)       stb__match(stb__dout - i[1] - 1, i[0] - 0x80 + 1), i += 2;
		else if (*i >= 0x40)  stb__match(stb__dout - (stb__in2(0) - 0x4000 + 1), i[2] + 1), i += 3;
		else /* *i >= 0x20 */ stb__lit(i + 1, i[0] - 0x20 + 1), i += 1 + (i[0] - 0x20 + 1);
	}
	else { // more ifs for cases that expand large, since overhead is amortized
		if (*i >= 0x18)       stb__match(stb__dout - (stb__in3(0) - 0x180000 + 1), i[3] + 1), i += 4;
		else if (*i >= 0x10)  stb__match(stb__dout - (stb__in3(0) - 0x100000 + 1), stb__in2(3) + 1), i += 5;
		else if (*i >= 0x08)  stb__lit(i + 2, stb__in2(0) - 0x0800 + 1), i += 2 + (stb__in2(0) - 0x0800 + 1);
		else if (*i == 0x07)  stb__lit(i + 3, stb__in2(1) + 1), i += 3 + (stb__in2(1) + 1);
		else if (*i == 0x06)  stb__match(stb__dout - (stb__in3(1) + 1), i[4] + 1), i += 5;
		else if (*i == 0x04)  stb__match(stb__dout - (stb__in3(1) + 1), stb__in2(4) + 1), i += 6;
	}
	return i;
}

static unsigned int stb_adler32(unsigned int adler32, unsigned char* buffer, unsigned int buflen)
{
	const unsigned long ADLER_MOD = 65521;
	unsigned long s1 = adler32 & 0xffff, s2 = adler32 >> 16;
	unsigned long blocklen, i;

	blocklen = buflen % 5552;
	while (buflen) {
		for (i = 0; i + 7 < blocklen; i += 8) {
			s1 += buffer[0], s2 += s1;
			s1 += buffer[1], s2 += s1;
			s1 += buffer[2], s2 += s1;
			s1 += buffer[3], s2 += s1;
			s1 += buffer[4], s2 += s1;
			s1 += buffer[5], s2 += s1;
			s1 += buffer[6], s2 += s1;
			s1 += buffer[7], s2 += s1;

			buffer += 8;
		}

		for (; i < blocklen; ++i)
			s1 += *buffer++, s2 += s1;

		s1 %= ADLER_MOD, s2 %= ADLER_MOD;
		buflen -= blocklen;
		blocklen = 5552;
	}
	return (unsigned int)(s2 << 16) + (unsigned int)s1;
}

static unsigned int stb_decompress(unsigned char* output, const unsigned char* i, unsigned int /*length*/)
{
	unsigned int olen;
	if (stb__in4(0) != 0x57bC0000) return 0;
	if (stb__in4(4) != 0)          return 0; // error! stream is > 4GB
	olen = stb_decompress_length(i);
	stb__barrier_in_b = i;
	stb__barrier_out_e = output + olen;
	stb__barrier_out_b = output;
	i += 16;

	stb__dout = output;
	for (;;) {
		const unsigned char* old_i = i;
		i = stb_decompress_token(i);
		if (i == old_i) {
			if (*i == 0x05 && i[1] == 0xfa) {
				IM_ASSERT(stb__dout == output + olen);
				if (stb__dout != output + olen) return 0;
				if (stb_adler32(1, output, olen) != (unsigned int)stb__in4(2))
					return 0;
				return olen;
			}
			else {
				IM_ASSERT(0); /* NOTREACHED */
				return 0;
			}
		}
		IM_ASSERT(stb__dout <= output + olen);
		if (stb__dout > output + olen)
			return 0;
	}
}

//-----------------------------------------------------------------------------
// ProggyClean.ttf
// Copyright (c) 2004, 2005 Tristan Grimmer
// MIT license (see License.txt in http://www.upperbounds.net/download/ProggyClean.ttf.zip)
// Download and more information at http://upperbounds.net
//-----------------------------------------------------------------------------
// File: 'ProggyClean.ttf' (41208 bytes)
// Exported using binary_to_compressed_c.cpp
//-----------------------------------------------------------------------------
static const char proggy_clean_ttf_compressed_data_base85[11980 + 1] =
"7])#######hV0qs'/###[),##/l:$#Q6>##5[n42>c-TH`->>#/e>11NNV=Bv(*:.F?uu#(gRU.o0XGH`$vhLG1hxt9?W`#,5LsCp#-i>.r$<$6pD>Lb';9Crc6tgXmKVeU2cD4Eo3R/"
"2*>]b(MC;$jPfY.;h^`IWM9<Lh2TlS+f-s$o6Q<BWH`YiU.xfLq$N;$0iR/GX:U(jcW2p/W*q?-qmnUCI;jHSAiFWM.R*kU@C=GH?a9wp8f$e.-4^Qg1)Q-GL(lf(r/7GrRgwV%MS=C#"
"`8ND>Qo#t'X#(v#Y9w0#1D$CIf;W'#pWUPXOuxXuU(H9M(1<q-UE31#^-V'8IRUo7Qf./L>=Ke$$'5F%)]0^#0X@U.a<r:QLtFsLcL6##lOj)#.Y5<-R&KgLwqJfLgN&;Q?gI^#DY2uL"
"i@^rMl9t=cWq6##weg>$FBjVQTSDgEKnIS7EM9>ZY9w0#L;>>#Mx&4Mvt//L[MkA#W@lK.N'[0#7RL_&#w+F%HtG9M#XL`N&.,GM4Pg;-<nLENhvx>-VsM.M0rJfLH2eTM`*oJMHRC`N"
"kfimM2J,W-jXS:)r0wK#@Fge$U>`w'N7G#$#fB#$E^$#:9:hk+eOe--6x)F7*E%?76%^GMHePW-Z5l'&GiF#$956:rS?dA#fiK:)Yr+`&#0j@'DbG&#^$PG.Ll+DNa<XCMKEV*N)LN/N"
"*b=%Q6pia-Xg8I$<MR&,VdJe$<(7G;Ckl'&hF;;$<_=X(b.RS%%)###MPBuuE1V:v&cX&#2m#(&cV]`k9OhLMbn%s$G2,B$BfD3X*sp5#l,$R#]x_X1xKX%b5U*[r5iMfUo9U`N99hG)"
"tm+/Us9pG)XPu`<0s-)WTt(gCRxIg(%6sfh=ktMKn3j)<6<b5Sk_/0(^]AaN#(p/L>&VZ>1i%h1S9u5o@YaaW$e+b<TWFn/Z:Oh(Cx2$lNEoN^e)#CFY@@I;BOQ*sRwZtZxRcU7uW6CX"
"ow0i(?$Q[cjOd[P4d)]>ROPOpxTO7Stwi1::iB1q)C_=dV26J;2,]7op$]uQr@_V7$q^%lQwtuHY]=DX,n3L#0PHDO4f9>dC@O>HBuKPpP*E,N+b3L#lpR/MrTEH.IAQk.a>D[.e;mc."
"x]Ip.PH^'/aqUO/$1WxLoW0[iLA<QT;5HKD+@qQ'NQ(3_PLhE48R.qAPSwQ0/WK?Z,[x?-J;jQTWA0X@KJ(_Y8N-:/M74:/-ZpKrUss?d#dZq]DAbkU*JqkL+nwX@@47`5>w=4h(9.`G"
"CRUxHPeR`5Mjol(dUWxZa(>STrPkrJiWx`5U7F#.g*jrohGg`cg:lSTvEY/EV_7H4Q9[Z%cnv;JQYZ5q.l7Zeas:HOIZOB?G<Nald$qs]@]L<J7bR*>gv:[7MI2k).'2($5FNP&EQ(,)"
"U]W]+fh18.vsai00);D3@4ku5P?DP8aJt+;qUM]=+b'8@;mViBKx0DE[-auGl8:PJ&Dj+M6OC]O^((##]`0i)drT;-7X`=-H3[igUnPG-NZlo.#k@h#=Ork$m>a>$-?Tm$UV(?#P6YY#"
"'/###xe7q.73rI3*pP/$1>s9)W,JrM7SN]'/4C#v$U`0#V.[0>xQsH$fEmPMgY2u7Kh(G%siIfLSoS+MK2eTM$=5,M8p`A.;_R%#u[K#$x4AG8.kK/HSB==-'Ie/QTtG?-.*^N-4B/ZM"
"_3YlQC7(p7q)&](`6_c)$/*JL(L-^(]$wIM`dPtOdGA,U3:w2M-0<q-]L_?^)1vw'.,MRsqVr.L;aN&#/EgJ)PBc[-f>+WomX2u7lqM2iEumMTcsF?-aT=Z-97UEnXglEn1K-bnEO`gu"
"Ft(c%=;Am_Qs@jLooI&NX;]0#j4#F14;gl8-GQpgwhrq8'=l_f-b49'UOqkLu7-##oDY2L(te+Mch&gLYtJ,MEtJfLh'x'M=$CS-ZZ%P]8bZ>#S?YY#%Q&q'3^Fw&?D)UDNrocM3A76/"
"/oL?#h7gl85[qW/NDOk%16ij;+:1a'iNIdb-ou8.P*w,v5#EI$TWS>Pot-R*H'-SEpA:g)f+O$%%`kA#G=8RMmG1&O`>to8bC]T&$,n.LoO>29sp3dt-52U%VM#q7'DHpg+#Z9%H[K<L"
"%a2E-grWVM3@2=-k22tL]4$##6We'8UJCKE[d_=%wI;'6X-GsLX4j^SgJ$##R*w,vP3wK#iiW&#*h^D&R?jp7+/u&#(AP##XU8c$fSYW-J95_-Dp[g9wcO&#M-h1OcJlc-*vpw0xUX&#"
"OQFKNX@QI'IoPp7nb,QU//MQ&ZDkKP)X<WSVL(68uVl&#c'[0#(s1X&xm$Y%B7*K:eDA323j998GXbA#pwMs-jgD$9QISB-A_(aN4xoFM^@C58D0+Q+q3n0#3U1InDjF682-SjMXJK)("
"h$hxua_K]ul92%'BOU&#BRRh-slg8KDlr:%L71Ka:.A;%YULjDPmL<LYs8i#XwJOYaKPKc1h:'9Ke,g)b),78=I39B;xiY$bgGw-&.Zi9InXDuYa%G*f2Bq7mn9^#p1vv%#(Wi-;/Z5h"
"o;#2:;%d&#x9v68C5g?ntX0X)pT`;%pB3q7mgGN)3%(P8nTd5L7GeA-GL@+%J3u2:(Yf>et`e;)f#Km8&+DC$I46>#Kr]]u-[=99tts1.qb#q72g1WJO81q+eN'03'eM>&1XxY-caEnO"
"j%2n8)),?ILR5^.Ibn<-X-Mq7[a82Lq:F&#ce+S9wsCK*x`569E8ew'He]h:sI[2LM$[guka3ZRd6:t%IG:;$%YiJ:Nq=?eAw;/:nnDq0(CYcMpG)qLN4$##&J<j$UpK<Q4a1]MupW^-"
"sj_$%[HK%'F####QRZJ::Y3EGl4'@%FkiAOg#p[##O`gukTfBHagL<LHw%q&OV0##F=6/:chIm0@eCP8X]:kFI%hl8hgO@RcBhS-@Qb$%+m=hPDLg*%K8ln(wcf3/'DW-$.lR?n[nCH-"
"eXOONTJlh:.RYF%3'p6sq:UIMA945&^HFS87@$EP2iG<-lCO$%c`uKGD3rC$x0BL8aFn--`ke%#HMP'vh1/R&O_J9'um,.<tx[@%wsJk&bUT2`0uMv7gg#qp/ij.L56'hl;.s5CUrxjO"
"M7-##.l+Au'A&O:-T72L]P`&=;ctp'XScX*rU.>-XTt,%OVU4)S1+R-#dg0/Nn?Ku1^0f$B*P:Rowwm-`0PKjYDDM'3]d39VZHEl4,.j']Pk-M.h^&:0FACm$maq-&sgw0t7/6(^xtk%"
"LuH88Fj-ekm>GA#_>568x6(OFRl-IZp`&b,_P'$M<Jnq79VsJW/mWS*PUiq76;]/NM_>hLbxfc$mj`,O;&%W2m`Zh:/)Uetw:aJ%]K9h:TcF]u_-Sj9,VK3M.*'&0D[Ca]J9gp8,kAW]"
"%(?A%R$f<->Zts'^kn=-^@c4%-pY6qI%J%1IGxfLU9CP8cbPlXv);C=b),<2mOvP8up,UVf3839acAWAW-W?#ao/^#%KYo8fRULNd2.>%m]UK:n%r$'sw]J;5pAoO_#2mO3n,'=H5(et"
"Hg*`+RLgv>=4U8guD$I%D:W>-r5V*%j*W:Kvej.Lp$<M-SGZ':+Q_k+uvOSLiEo(<aD/K<CCc`'Lx>'?;++O'>()jLR-^u68PHm8ZFWe+ej8h:9r6L*0//c&iH&R8pRbA#Kjm%upV1g:"
"a_#Ur7FuA#(tRh#.Y5K+@?3<-8m0$PEn;J:rh6?I6uG<-`wMU'ircp0LaE_OtlMb&1#6T.#FDKu#1Lw%u%+GM+X'e?YLfjM[VO0MbuFp7;>Q&#WIo)0@F%q7c#4XAXN-U&VB<HFF*qL("
"$/V,;(kXZejWO`<[5?\?ewY(*9=%wDc;,u<'9t3W-(H1th3+G]ucQ]kLs7df($/*JL]@*t7Bu_G3_7mp7<iaQjO@.kLg;x3B0lqp7Hf,^Ze7-##@/c58Mo(3;knp0%)A7?-W+eI'o8)b<"
"nKnw'Ho8C=Y>pqB>0ie&jhZ[?iLR@@_AvA-iQC(=ksRZRVp7`.=+NpBC%rh&3]R:8XDmE5^V8O(x<<aG/1N$#FX$0V5Y6x'aErI3I$7x%E`v<-BY,)%-?Psf*l?%C3.mM(=/M0:JxG'?"
"7WhH%o'a<-80g0NBxoO(GH<dM]n.+%q@jH?f.UsJ2Ggs&4<-e47&Kl+f//9@`b+?.TeN_&B8Ss?v;^Trk;f#YvJkl&w$]>-+k?'(<S:68tq*WoDfZu';mM?8X[ma8W%*`-=;D.(nc7/;"
")g:T1=^J$&BRV(-lTmNB6xqB[@0*o.erM*<SWF]u2=st-*(6v>^](H.aREZSi,#1:[IXaZFOm<-ui#qUq2$##Ri;u75OK#(RtaW-K-F`S+cF]uN`-KMQ%rP/Xri.LRcB##=YL3BgM/3M"
"D?@f&1'BW-)Ju<L25gl8uhVm1hL$##*8###'A3/LkKW+(^rWX?5W_8g)a(m&K8P>#bmmWCMkk&#TR`C,5d>g)F;t,4:@_l8G/5h4vUd%&%950:VXD'QdWoY-F$BtUwmfe$YqL'8(PWX("
"P?^@Po3$##`MSs?DWBZ/S>+4%>fX,VWv/w'KD`LP5IbH;rTV>n3cEK8U#bX]l-/V+^lj3;vlMb&[5YQ8#pekX9JP3XUC72L,,?+Ni&co7ApnO*5NK,((W-i:$,kp'UDAO(G0Sq7MVjJs"
"bIu)'Z,*[>br5fX^:FPAWr-m2KgL<LUN098kTF&#lvo58=/vjDo;.;)Ka*hLR#/k=rKbxuV`>Q_nN6'8uTG&#1T5g)uLv:873UpTLgH+#FgpH'_o1780Ph8KmxQJ8#H72L4@768@Tm&Q"
"h4CB/5OvmA&,Q&QbUoi$a_%3M01H)4x7I^&KQVgtFnV+;[Pc>[m4k//,]1?#`VY[Jr*3&&slRfLiVZJ:]?=K3Sw=[$=uRB?3xk48@aeg<Z'<$#4H)6,>e0jT6'N#(q%.O=?2S]u*(m<-"
"V8J'(1)G][68hW$5'q[GC&5j`TE?m'esFGNRM)j,ffZ?-qx8;->g4t*:CIP/[Qap7/9'#(1sao7w-.qNUdkJ)tCF&#B^;xGvn2r9FEPFFFcL@.iFNkTve$m%#QvQS8U@)2Z+3K:AKM5i"
"sZ88+dKQ)W6>J%CL<KE>`.d*(B`-n8D9oK<Up]c$X$(,)M8Zt7/[rdkqTgl-0cuGMv'?>-XV1q['-5k'cAZ69e;D_?$ZPP&s^+7])$*$#@QYi9,5P&#9r+$%CE=68>K8r0=dSC%%(@p7"
".m7jilQ02'0-VWAg<a/''3u.=4L$Y)6k/K:_[3=&jvL<L0C/2'v:^;-DIBW,B4E68:kZ;%?8(Q8BH=kO65BW?xSG&#@uU,DS*,?.+(o(#1vCS8#CHF>TlGW'b)Tq7VT9q^*^$$.:&N@@"
"$&)WHtPm*5_rO0&e%K&#-30j(E4#'Zb.o/(Tpm$>K'f@[PvFl,hfINTNU6u'0pao7%XUp9]5.>%h`8_=VYbxuel.NTSsJfLacFu3B'lQSu/m6-Oqem8T+oE--$0a/k]uj9EwsG>%veR*"
"hv^BFpQj:K'#SJ,sB-'#](j.Lg92rTw-*n%@/;39rrJF,l#qV%OrtBeC6/,;qB3ebNW[?,Hqj2L.1NP&GjUR=1D8QaS3Up&@*9wP?+lo7b?@%'k4`p0Z$22%K3+iCZj?XJN4Nm&+YF]u"
"@-W$U%VEQ/,,>>#)D<h#`)h0:<Q6909ua+&VU%n2:cG3FJ-%@Bj-DgLr`Hw&HAKjKjseK</xKT*)B,N9X3]krc12t'pgTV(Lv-tL[xg_%=M_q7a^x?7Ubd>#%8cY#YZ?=,`Wdxu/ae&#"
"w6)R89tI#6@s'(6Bf7a&?S=^ZI_kS&ai`&=tE72L_D,;^R)7[$s<Eh#c&)q.MXI%#v9ROa5FZO%sF7q7Nwb&#ptUJ:aqJe$Sl68%.D###EC><?-aF&#RNQv>o8lKN%5/$(vdfq7+ebA#"
"u1p]ovUKW&Y%q]'>$1@-[xfn$7ZTp7mM,G,Ko7a&Gu%G[RMxJs[0MM%wci.LFDK)(<c`Q8N)jEIF*+?P2a8g%)$q]o2aH8C&<SibC/q,(e:v;-b#6[$NtDZ84Je2KNvB#$P5?tQ3nt(0"
"d=j.LQf./Ll33+(;q3L-w=8dX$#WF&uIJ@-bfI>%:_i2B5CsR8&9Z&#=mPEnm0f`<&c)QL5uJ#%u%lJj+D-r;BoF&#4DoS97h5g)E#o:&S4weDF,9^Hoe`h*L+_a*NrLW-1pG_&2UdB8"
"6e%B/:=>)N4xeW.*wft-;$'58-ESqr<b?UI(_%@[P46>#U`'6AQ]m&6/`Z>#S?YY#Vc;r7U2&326d=w&H####?TZ`*4?&.MK?LP8Vxg>$[QXc%QJv92.(Db*B)gb*BM9dM*hJMAo*c&#"
"b0v=Pjer]$gG&JXDf->'StvU7505l9$AFvgYRI^&<^b68?j#q9QX4SM'RO#&sL1IM.rJfLUAj221]d##DW=m83u5;'bYx,*Sl0hL(W;;$doB&O/TQ:(Z^xBdLjL<Lni;''X.`$#8+1GD"
":k$YUWsbn8ogh6rxZ2Z9]%nd+>V#*8U_72Lh+2Q8Cj0i:6hp&$C/:p(HK>T8Y[gHQ4`4)'$Ab(Nof%V'8hL&#<NEdtg(n'=S1A(Q1/I&4([%dM`,Iu'1:_hL>SfD07&6D<fp8dHM7/g+"
"tlPN9J*rKaPct&?'uBCem^jn%9_K)<,C5K3s=5g&GmJb*[SYq7K;TRLGCsM-$$;S%:Y@r7AK0pprpL<Lrh,q7e/%KWK:50I^+m'vi`3?%Zp+<-d+$L-Sv:@.o19n$s0&39;kn;S%BSq*"
"$3WoJSCLweV[aZ'MQIjO<7;X-X;&+dMLvu#^UsGEC9WEc[X(wI7#2.(F0jV*eZf<-Qv3J-c+J5AlrB#$p(H68LvEA'q3n0#m,[`*8Ft)FcYgEud]CWfm68,(aLA$@EFTgLXoBq/UPlp7"
":d[/;r_ix=:TF`S5H-b<LI&HY(K=h#)]Lk$K14lVfm:x$H<3^Ql<M`$OhapBnkup'D#L$Pb_`N*g]2e;X/Dtg,bsj&K#2[-:iYr'_wgH)NUIR8a1n#S?Yej'h8^58UbZd+^FKD*T@;6A"
"7aQC[K8d-(v6GI$x:T<&'Gp5Uf>@M.*J:;$-rv29'M]8qMv-tLp,'886iaC=Hb*YJoKJ,(j%K=H`K.v9HggqBIiZu'QvBT.#=)0ukruV&.)3=(^1`o*Pj4<-<aN((^7('#Z0wK#5GX@7"
"u][`*S^43933A4rl][`*O4CgLEl]v$1Q3AeF37dbXk,.)vj#x'd`;qgbQR%FW,2(?LO=s%Sc68%NP'##Aotl8x=BE#j1UD([3$M(]UI2LX3RpKN@;/#f'f/&_mt&F)XdF<9t4)Qa.*kT"
"LwQ'(TTB9.xH'>#MJ+gLq9-##@HuZPN0]u:h7.T..G:;$/Usj(T7`Q8tT72LnYl<-qx8;-HV7Q-&Xdx%1a,hC=0u+HlsV>nuIQL-5<N?)NBS)QN*_I,?&)2'IM%L3I)X((e/dl2&8'<M"
":^#M*Q+[T.Xri.LYS3v%fF`68h;b-X[/En'CR.q7E)p'/kle2HM,u;^%OKC-N+Ll%F9CF<Nf'^#t2L,;27W:0O@6##U6W7:$rJfLWHj$#)woqBefIZ.PK<b*t7ed;p*_m;4ExK#h@&]>"
"_>@kXQtMacfD.m-VAb8;IReM3$wf0''hra*so568'Ip&vRs849'MRYSp%:t:h5qSgwpEr$B>Q,;s(C#$)`svQuF$##-D,##,g68@2[T;.XSdN9Qe)rpt._K-#5wF)sP'##p#C0c%-Gb%"
"hd+<-j'Ai*x&&HMkT]C'OSl##5RG[JXaHN;d'uA#x._U;.`PU@(Z3dt4r152@:v,'R.Sj'w#0<-;kPI)FfJ&#AYJ&#//)>-k=m=*XnK$>=)72L]0I%>.G690a:$##<,);?;72#?x9+d;"
"^V'9;jY@;)br#q^YQpx:X#Te$Z^'=-=bGhLf:D6&bNwZ9-ZD#n^9HhLMr5G;']d&6'wYmTFmL<LD)F^%[tC'8;+9E#C$g%#5Y>q9wI>P(9mI[>kC-ekLC/R&CH+s'B;K-M6$EB%is00:"
"+A4[7xks.LrNk0&E)wILYF@2L'0Nb$+pv<(2.768/FrY&h$^3i&@+G%JT'<-,v`3;_)I9M^AE]CN?Cl2AZg+%4iTpT3<n-&%H%b<FDj2M<hH=&Eh<2Len$b*aTX=-8QxN)k11IM1c^j%"
"9s<L<NFSo)B?+<-(GxsF,^-Eh@$4dXhN$+#rxK8'je'D7k`e;)2pYwPA'_p9&@^18ml1^[@g4t*[JOa*[=Qp7(qJ_oOL^('7fB&Hq-:sf,sNj8xq^>$U4O]GKx'm9)b@p7YsvK3w^YR-"
"CdQ*:Ir<($u&)#(&?L9Rg3H)4fiEp^iI9O8KnTj,]H?D*r7'M;PwZ9K0E^k&-cpI;.p/6_vwoFMV<->#%Xi.LxVnrU(4&8/P+:hLSKj$#U%]49t'I:rgMi'FL@a:0Y-uA[39',(vbma*"
"hU%<-SRF`Tt:542R_VV$p@[p8DV[A,?1839FWdF<TddF<9Ah-6&9tWoDlh]&1SpGMq>Ti1O*H&#(AL8[_P%.M>v^-))qOT*F5Cq0`Ye%+$B6i:7@0IX<N+T+0MlMBPQ*Vj>SsD<U4JHY"
"8kD2)2fU/M#$e.)T4,_=8hLim[&);?UkK'-x?'(:siIfL<$pFM`i<?%W(mGDHM%>iWP,##P`%/L<eXi:@Z9C.7o=@(pXdAO/NLQ8lPl+HPOQa8wD8=^GlPa8TKI1CjhsCTSLJM'/Wl>-"
"S(qw%sf/@%#B6;/U7K]uZbi^Oc^2n<bhPmUkMw>%t<)'mEVE''n`WnJra$^TKvX5B>;_aSEK',(hwa0:i4G?.Bci.(X[?b*($,=-n<.Q%`(X=?+@Am*Js0&=3bh8K]mL<LoNs'6,'85`"
"0?t/'_U59@]ddF<#LdF<eWdF<OuN/45rY<-L@&#+fm>69=Lb,OcZV/);TTm8VI;?%OtJ<(b4mq7M6:u?KRdF<gR@2L=FNU-<b[(9c/ML3m;Z[$oF3g)GAWqpARc=<ROu7cL5l;-[A]%/"
"+fsd;l#SafT/f*W]0=O'$(Tb<[)*@e775R-:Yob%g*>l*:xP?Yb.5)%w_I?7uk5JC+FS(m#i'k.'a0i)9<7b'fs'59hq$*5Uhv##pi^8+hIEBF`nvo`;'l0.^S1<-wUK2/Coh58KKhLj"
"M=SO*rfO`+qC`W-On.=AJ56>>i2@2LH6A:&5q`?9I3@@'04&p2/LVa*T-4<-i3;M9UvZd+N7>b*eIwg:CC)c<>nO&#<IGe;__.thjZl<%w(Wk2xmp4Q@I#I9,DF]u7-P=.-_:YJ]aS@V"
"?6*C()dOp7:WL,b&3Rg/.cmM9&r^>$(>.Z-I&J(Q0Hd5Q%7Co-b`-c<N(6r@ip+AurK<m86QIth*#v;-OBqi+L7wDE-Ir8K['m+DDSLwK&/.?-V%U_%3:qKNu$_b*B-kp7NaD'QdWQPK"
"Yq[@>P)hI;*_F]u`Rb[.j8_Q/<&>uu+VsH$sM9TA%?)(vmJ80),P7E>)tjD%2L=-t#fK[%`v=Q8<FfNkgg^oIbah*#8/Qt$F&:K*-(N/'+1vMB,u()-a.VUU*#[e%gAAO(S>WlA2);Sa"
">gXm8YB`1d@K#n]76-a$U,mF<fX]idqd)<3,]J7JmW4`6]uks=4-72L(jEk+:bJ0M^q-8Dm_Z?0olP1C9Sa&H[d&c$ooQUj]Exd*3ZM@-WGW2%s',B-_M%>%Ul:#/'xoFM9QX-$.QN'>"
"[%$Z$uF6pA6Ki2O5:8w*vP1<-1`[G,)-m#>0`P&#eb#.3i)rtB61(o'$?X3B</R90;eZ]%Ncq;-Tl]#F>2Qft^ae_5tKL9MUe9b*sLEQ95C&`=G?@Mj=wh*'3E>=-<)Gt*Iw)'QG:`@I"
"wOf7&]1i'S01B+Ev/Nac#9S;=;YQpg_6U`*kVY39xK,[/6Aj7:'1Bm-_1EYfa1+o&o4hp7KN_Q(OlIo@S%;jVdn0'1<Vc52=u`3^o-n1'g4v58Hj&6_t7$##?M)c<$bgQ_'SY((-xkA#"
"Y(,p'H9rIVY-b,'%bCPF7.J<Up^,(dU1VY*5#WkTU>h19w,WQhLI)3S#f$2(eb,jr*b;3Vw]*7NH%$c4Vs,eD9>XW8?N]o+(*pgC%/72LV-u<Hp,3@e^9UB1J+ak9-TN/mhKPg+AJYd$"
"MlvAF_jCK*.O-^(63adMT->W%iewS8W6m2rtCpo'RS1R84=@paTKt)>=%&1[)*vp'u+x,VrwN;&]kuO9JDbg=pO$J*.jVe;u'm0dr9l,<*wMK*Oe=g8lV_KEBFkO'oU]^=[-792#ok,)"
"i]lR8qQ2oA8wcRCZ^7w/Njh;?.stX?Q1>S1q4Bn$)K1<-rGdO'$Wr.Lc.CG)$/*JL4tNR/,SVO3,aUw'DJN:)Ss;wGn9A32ijw%FL+Z0Fn.U9;reSq)bmI32U==5ALuG&#Vf1398/pVo"
"1*c-(aY168o<`JsSbk-,1N;$>0:OUas(3:8Z972LSfF8eb=c-;>SPw7.6hn3m`9^Xkn(r.qS[0;T%&Qc=+STRxX'q1BNk3&*eu2;&8q$&x>Q#Q7^Tf+6<(d%ZVmj2bDi%.3L2n+4W'$P"
"iDDG)g,r%+?,$@?uou5tSe2aN_AQU*<h`e-GI7)?OK2A.d7_c)?wQ5AS@DL3r#7fSkgl6-++D:'A,uq7SvlB$pcpH'q3n0#_%dY#xCpr-l<F0NR@-##FEV6NTF6##$l84N1w?AO>'IAO"
"URQ##V^Fv-XFbGM7Fl(N<3DhLGF%q.1rC$#:T__&Pi68%0xi_&[qFJ(77j_&JWoF.V735&T,[R*:xFR*K5>>#`bW-?4Ne_&6Ne_&6Ne_&n`kr-#GJcM6X;uM6X;uM(.a..^2TkL%oR(#"
";u.T%fAr%4tJ8&><1=GHZ_+m9/#H1F^R#SC#*N=BA9(D?v[UiFY>>^8p,KKF.W]L29uLkLlu/+4T<XoIB&hx=T1PcDaB&;HH+-AFr?(m9HZV)FKS8JCw;SD=6[^/DZUL`EUDf]GGlG&>"
"w$)F./^n3+rlo+DB;5sIYGNk+i1t-69Jg--0pao7Sm#K)pdHW&;LuDNH@H>#/X-TI(;P>#,Gc>#0Su>#4`1?#8lC?#<xU?#@.i?#D:%@#HF7@#LRI@#P_[@#Tkn@#Xw*A#]-=A#a9OA#"
"d<F&#*;G##.GY##2Sl##6`($#:l:$#>xL$#B.`$#F:r$#JF.%#NR@%#R_R%#Vke%#Zww%#_-4&#3^Rh%Sflr-k'MS.o?.5/sWel/wpEM0%3'/1)K^f1-d>G21&v(35>V`39V7A4=onx4"
"A1OY5EI0;6Ibgr6M$HS7Q<)58C5w,;WoA*#[%T*#`1g*#d=#+#hI5+#lUG+#pbY+#tnl+#x$),#&1;,#*=M,#.I`,#2Ur,#6b.-#;w[H#iQtA#m^0B#qjBB#uvTB##-hB#'9$C#+E6C#"
"/QHC#3^ZC#7jmC#;v)D#?,<D#C8ND#GDaD#KPsD#O]/E#g1A5#KA*1#gC17#MGd;#8(02#L-d3#rWM4#Hga1#,<w0#T.j<#O#'2#CYN1#qa^:#_4m3#o@/=#eG8=#t8J5#`+78#4uI-#"
"m3B2#SB[8#Q0@8#i[*9#iOn8#1Nm;#^sN9#qh<9#:=x-#P;K2#$%X9#bC+.#Rg;<#mN=.#MTF.#RZO.#2?)4#Y#(/#[)1/#b;L/#dAU/#0Sv;#lY$0#n`-0#sf60#(F24#wrH0#%/e0#"
"TmD<#%JSMFove:CTBEXI:<eh2g)B,3h2^G3i;#d3jD>)4kMYD4lVu`4m`:&5niUA5@(A5BA1]PBB:xlBCC=2CDLXMCEUtiCf&0g2'tN?PGT4CPGT4CPGT4CPGT4CPGT4CPGT4CPGT4CP"
"GT4CPGT4CPGT4CPGT4CPGT4CPGT4CP-qekC`.9kEg^+F$kwViFJTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5KTB&5o,^<-28ZI'O?;xp"
"O?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xpO?;xp;7q-#lLYI:xvD=#";

static const char* GetDefaultCompressedFontDataTTFBase85()
{
	return proggy_clean_ttf_compressed_data_base85;
}
```

`src/imgui/imgui_internal.h`:

```h
// dear imgui, v1.60
// (internals)

// You may use this file to debug, understand or extend ImGui features but we don't provide any guarantee of forward compatibility!
// Set:
//   #define IMGUI_DEFINE_MATH_OPERATORS
// To implement maths operators for ImVec2 (disabled by default to not collide with using IM_VEC2_CLASS_EXTRA along with your own math types+operators)

#pragma once

#ifndef IMGUI_VERSION
#error Must include imgui.h before imgui_internal.h
#endif

#include <stdio.h>      // FILE*
#include <math.h>       // sqrtf, fabsf, fmodf, powf, floorf, ceilf, cosf, sinf
#include <limits.h>     // INT_MIN, INT_MAX

#ifdef _MSC_VER
#pragma warning (push)
#pragma warning (disable: 4251) // class 'xxx' needs to have dll-interface to be used by clients of struct 'xxx' // when IMGUI_API is set to__declspec(dllexport)
#endif

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-function"        // for stb_textedit.h
#pragma clang diagnostic ignored "-Wmissing-prototypes"     // for stb_textedit.h
#pragma clang diagnostic ignored "-Wold-style-cast"
#endif

//-----------------------------------------------------------------------------
// Forward Declarations
//-----------------------------------------------------------------------------

struct ImRect;
struct ImGuiColMod;
struct ImGuiStyleMod;
struct ImGuiGroupData;
struct ImGuiMenuColumns;
struct ImGuiDrawContext;
struct ImGuiTextEditState;
struct ImGuiPopupRef;
struct ImGuiWindow;
struct ImGuiWindowSettings;

typedef int ImGuiLayoutType;        // enum: horizontal or vertical             // enum ImGuiLayoutType_
typedef int ImGuiButtonFlags;       // flags: for ButtonEx(), ButtonBehavior()  // enum ImGuiButtonFlags_
typedef int ImGuiItemFlags;         // flags: for PushItemFlag()                // enum ImGuiItemFlags_
typedef int ImGuiItemStatusFlags;   // flags: storage for DC.LastItemXXX        // enum ImGuiItemStatusFlags_
typedef int ImGuiNavHighlightFlags; // flags: for RenderNavHighlight()          // enum ImGuiNavHighlightFlags_
typedef int ImGuiNavDirSourceFlags; // flags: for GetNavInputAmount2d()         // enum ImGuiNavDirSourceFlags_
typedef int ImGuiSeparatorFlags;    // flags: for Separator() - internal        // enum ImGuiSeparatorFlags_
typedef int ImGuiSliderFlags;       // flags: for SliderBehavior()              // enum ImGuiSliderFlags_

									//-------------------------------------------------------------------------
									// STB libraries
									//-------------------------------------------------------------------------

namespace ImGuiStb
{
#undef STB_TEXTEDIT_STRING
#undef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_STRING             ImGuiTextEditState
#define STB_TEXTEDIT_CHARTYPE           ImWchar
#define STB_TEXTEDIT_GETWIDTH_NEWLINE   -1.0f
#include "stb_textedit.h"
} // namespace ImGuiStb

  //-----------------------------------------------------------------------------
  // Context
  //-----------------------------------------------------------------------------

#ifndef GImGui
extern IMGUI_API ImGuiContext* GImGui;  // Current implicit ImGui context pointer
#endif

										//-----------------------------------------------------------------------------
										// Helpers
										//-----------------------------------------------------------------------------

#define IM_PI           3.14159265358979323846f
#ifdef _WIN32
#define IM_NEWLINE      "\r\n"   // Play it nice with Windows users (2018: Notepad _still_ doesn't display files properly when they use Unix-style carriage returns)
#else
#define IM_NEWLINE      "\n"
#endif

										// Helpers: UTF-8 <> wchar
IMGUI_API int           ImTextStrToUtf8(char* buf, int buf_size, const ImWchar * in_text, const ImWchar * in_text_end);      // return output UTF-8 bytes count
IMGUI_API int           ImTextCharFromUtf8(unsigned int* out_char, const char* in_text, const char* in_text_end);          // return input UTF-8 bytes count
IMGUI_API int           ImTextStrFromUtf8(ImWchar* buf, int buf_size, const char* in_text, const char* in_text_end, const char** in_remaining = NULL);   // return input UTF-8 bytes count
IMGUI_API int           ImTextCountCharsFromUtf8(const char* in_text, const char* in_text_end);                            // return number of UTF-8 code-points (NOT bytes count)
IMGUI_API int           ImTextCountUtf8BytesFromStr(const ImWchar* in_text, const ImWchar* in_text_end);                   // return number of bytes to express string as UTF-8 code-points

																														   // Helpers: Misc
IMGUI_API ImU32         ImHash(const void* data, int data_size, ImU32 seed = 0);    // Pass data_size==0 for zero-terminated strings
IMGUI_API void* ImFileLoadToMemory(const char* filename, const char* file_open_mode, int* out_file_size = NULL, int padding_bytes = 0);
IMGUI_API FILE* ImFileOpen(const char* filename, const char* file_open_mode);
static inline bool      ImCharIsSpace(unsigned int c) { return c == ' ' || c == '\t' || c == 0x3000; }
static inline bool      ImIsPowerOfTwo(int v) { return v != 0 && (v & (v - 1)) == 0; }
static inline int       ImUpperPowerOfTwo(int v) { v--; v |= v >> 1; v |= v >> 2; v |= v >> 4; v |= v >> 8; v |= v >> 16; v++; return v; }

// Helpers: Geometry
IMGUI_API ImVec2        ImLineClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& p);
IMGUI_API bool          ImTriangleContainsPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
IMGUI_API ImVec2        ImTriangleClosestPoint(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p);
IMGUI_API void          ImTriangleBarycentricCoords(const ImVec2& a, const ImVec2& b, const ImVec2& c, const ImVec2& p, float& out_u, float& out_v, float& out_w);

// Helpers: String
IMGUI_API int           ImStricmp(const char* str1, const char* str2);
IMGUI_API int           ImStrnicmp(const char* str1, const char* str2, size_t count);
IMGUI_API void          ImStrncpy(char* dst, const char* src, size_t count);
IMGUI_API char* ImStrdup(const char* str);
IMGUI_API const char* ImStrchrRange(const char* str_begin, const char* str_end, char c);
IMGUI_API int           ImStrlenW(const ImWchar* str);
IMGUI_API const ImWchar* ImStrbolW(const ImWchar* buf_mid_line, const ImWchar* buf_begin); // Find beginning-of-line
IMGUI_API const char* ImStristr(const char* haystack, const char* haystack_end, const char* needle, const char* needle_end);
IMGUI_API int           ImFormatString(char* buf, size_t buf_size, const char* fmt, ...) IM_FMTARGS(3);
IMGUI_API int           ImFormatStringV(char* buf, size_t buf_size, const char* fmt, va_list args) IM_FMTLIST(3);

// Helpers: Math
// We are keeping those not leaking to the user by default, in the case the user has implicit cast operators between ImVec2 and its own types (when IM_VEC2_CLASS_EXTRA is defined)
#ifdef IMGUI_DEFINE_MATH_OPERATORS
static inline ImVec2 operator*(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x * rhs, lhs.y * rhs); }
static inline ImVec2 operator/(const ImVec2& lhs, const float rhs) { return ImVec2(lhs.x / rhs, lhs.y / rhs); }
static inline ImVec2 operator+(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x + rhs.x, lhs.y + rhs.y); }
static inline ImVec2 operator-(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x - rhs.x, lhs.y - rhs.y); }
static inline ImVec2 operator*(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }
static inline ImVec2 operator/(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x / rhs.x, lhs.y / rhs.y); }
static inline ImVec2& operator+=(ImVec2& lhs, const ImVec2& rhs) { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; }
static inline ImVec2& operator-=(ImVec2& lhs, const ImVec2& rhs) { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; }
static inline ImVec2& operator*=(ImVec2& lhs, const float rhs) { lhs.x *= rhs; lhs.y *= rhs; return lhs; }
static inline ImVec2& operator/=(ImVec2& lhs, const float rhs) { lhs.x /= rhs; lhs.y /= rhs; return lhs; }
static inline ImVec4 operator+(const ImVec4& lhs, const ImVec4& rhs) { return ImVec4(lhs.x + rhs.x, lhs.y + rhs.y, lhs.z + rhs.z, lhs.w + rhs.w); }
static inline ImVec4 operator-(const ImVec4& lhs, const ImVec4& rhs) { return ImVec4(lhs.x - rhs.x, lhs.y - rhs.y, lhs.z - rhs.z, lhs.w - rhs.w); }
static inline ImVec4 operator*(const ImVec4& lhs, const ImVec4& rhs) { return ImVec4(lhs.x * rhs.x, lhs.y * rhs.y, lhs.z * rhs.z, lhs.w * rhs.w); }
#endif

static inline int    ImMin(int lhs, int rhs) { return lhs < rhs ? lhs : rhs; }
static inline int    ImMax(int lhs, int rhs) { return lhs >= rhs ? lhs : rhs; }
static inline float  ImMin(float lhs, float rhs) { return lhs < rhs ? lhs : rhs; }
static inline float  ImMax(float lhs, float rhs) { return lhs >= rhs ? lhs : rhs; }
static inline ImVec2 ImMin(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x < rhs.x ? lhs.x : rhs.x, lhs.y < rhs.y ? lhs.y : rhs.y); }
static inline ImVec2 ImMax(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x >= rhs.x ? lhs.x : rhs.x, lhs.y >= rhs.y ? lhs.y : rhs.y); }
static inline int    ImClamp(int v, int mn, int mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }
static inline float  ImClamp(float v, float mn, float mx) { return (v < mn) ? mn : (v > mx) ? mx : v; }
static inline ImVec2 ImClamp(const ImVec2& f, const ImVec2& mn, ImVec2 mx) { return ImVec2(ImClamp(f.x, mn.x, mx.x), ImClamp(f.y, mn.y, mx.y)); }
static inline float  ImSaturate(float f) { return (f < 0.0f) ? 0.0f : (f > 1.0f) ? 1.0f : f; }
static inline void   ImSwap(int& a, int& b) { int tmp = a; a = b; b = tmp; }
static inline void   ImSwap(float& a, float& b) { float tmp = a; a = b; b = tmp; }
static inline int    ImLerp(int a, int b, float t) { return (int)(a + (b - a) * t); }
static inline float  ImLerp(float a, float b, float t) { return a + (b - a) * t; }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, float t) { return ImVec2(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t); }
static inline ImVec2 ImLerp(const ImVec2& a, const ImVec2& b, const ImVec2& t) { return ImVec2(a.x + (b.x - a.x) * t.x, a.y + (b.y - a.y) * t.y); }
static inline ImVec4 ImLerp(const ImVec4& a, const ImVec4& b, float t) { return ImVec4(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t, a.w + (b.w - a.w) * t); }
static inline float  ImLengthSqr(const ImVec2& lhs) { return lhs.x * lhs.x + lhs.y * lhs.y; }
static inline float  ImLengthSqr(const ImVec4& lhs) { return lhs.x * lhs.x + lhs.y * lhs.y + lhs.z * lhs.z + lhs.w * lhs.w; }
static inline float  ImInvLength(const ImVec2& lhs, float fail_value) { float d = lhs.x * lhs.x + lhs.y * lhs.y; if (d > 0.0f) return 1.0f / sqrtf(d); return fail_value; }
static inline float  ImFloor(float f) { return (float)(int)f; }
static inline ImVec2 ImFloor(const ImVec2& v) { return ImVec2((float)(int)v.x, (float)(int)v.y); }
static inline float  ImDot(const ImVec2& a, const ImVec2& b) { return a.x * b.x + a.y * b.y; }
static inline ImVec2 ImRotate(const ImVec2& v, float cos_a, float sin_a) { return ImVec2(v.x * cos_a - v.y * sin_a, v.x * sin_a + v.y * cos_a); }
static inline float  ImLinearSweep(float current, float target, float speed) { if (current < target) return ImMin(current + speed, target); if (current > target) return ImMax(current - speed, target); return current; }
static inline ImVec2 ImMul(const ImVec2& lhs, const ImVec2& rhs) { return ImVec2(lhs.x * rhs.x, lhs.y * rhs.y); }

//-----------------------------------------------------------------------------
// Types
//-----------------------------------------------------------------------------

enum ImGuiButtonFlags_
{
	ImGuiButtonFlags_Repeat = 1 << 0,   // hold to repeat
	ImGuiButtonFlags_PressedOnClickRelease = 1 << 1,   // return true on click + release on same item [DEFAULT if no PressedOn* flag is set]
	ImGuiButtonFlags_PressedOnClick = 1 << 2,   // return true on click (default requires click+release)
	ImGuiButtonFlags_PressedOnRelease = 1 << 3,   // return true on release (default requires click+release)
	ImGuiButtonFlags_PressedOnDoubleClick = 1 << 4,   // return true on double-click (default requires click+release)
	ImGuiButtonFlags_FlattenChildren = 1 << 5,   // allow interactions even if a child window is overlapping
	ImGuiButtonFlags_AllowItemOverlap = 1 << 6,   // require previous frame HoveredId to either match id or be null before being usable, use along with SetItemAllowOverlap()
	ImGuiButtonFlags_DontClosePopups = 1 << 7,   // disable automatically closing parent popup on press // [UNUSED]
	ImGuiButtonFlags_Disabled = 1 << 8,   // disable interactions
	ImGuiButtonFlags_AlignTextBaseLine = 1 << 9,   // vertically align button to match text baseline - ButtonEx() only // FIXME: Should be removed and handled by SmallButton(), not possible currently because of DC.CursorPosPrevLine
	ImGuiButtonFlags_NoKeyModifiers = 1 << 10,  // disable interaction if a key modifier is held
	ImGuiButtonFlags_NoHoldingActiveID = 1 << 11,  // don't set ActiveId while holding the mouse (ImGuiButtonFlags_PressedOnClick only)
	ImGuiButtonFlags_PressedOnDragDropHold = 1 << 12,  // press when held into while we are drag and dropping another item (used by e.g. tree nodes, collapsing headers)
	ImGuiButtonFlags_NoNavFocus = 1 << 13,   // don't override navigation focus when activated
	ImGuiButtonFlags_Outline = 1 << 14
};

enum ImGuiSliderFlags_
{
	ImGuiSliderFlags_Vertical = 1 << 0
};

enum ImGuiColumnsFlags_
{
	// Default: 0
	ImGuiColumnsFlags_NoBorder = 1 << 0,   // Disable column dividers
	ImGuiColumnsFlags_NoResize = 1 << 1,   // Disable resizing columns when clicking on the dividers
	ImGuiColumnsFlags_NoPreserveWidths = 1 << 2,   // Disable column width preservation when adjusting columns
	ImGuiColumnsFlags_NoForceWithinWindow = 1 << 3,   // Disable forcing columns to fit within window
	ImGuiColumnsFlags_GrowParentContentsSize = 1 << 4    // (WIP) Restore pre-1.51 behavior of extending the parent window contents size but _without affecting the columns width at all_. Will eventually remove.
};

enum ImGuiSelectableFlagsPrivate_
{
	// NB: need to be in sync with last value of ImGuiSelectableFlags_
	ImGuiSelectableFlags_Menu = 1 << 3,   // -> PressedOnClick
	ImGuiSelectableFlags_MenuItem = 1 << 4,   // -> PressedOnRelease
	ImGuiSelectableFlags_Disabled = 1 << 5,
	ImGuiSelectableFlags_DrawFillAvailWidth = 1 << 6
};

enum ImGuiSeparatorFlags_
{
	ImGuiSeparatorFlags_Horizontal = 1 << 0,   // Axis default to current layout type, so generally Horizontal unless e.g. in a menu bar
	ImGuiSeparatorFlags_Vertical = 1 << 1
};

// Storage for LastItem data
enum ImGuiItemStatusFlags_
{
	ImGuiItemStatusFlags_HoveredRect = 1 << 0,
	ImGuiItemStatusFlags_HasDisplayRect = 1 << 1
};

// FIXME: this is in development, not exposed/functional as a generic feature yet.
enum ImGuiLayoutType_
{
	ImGuiLayoutType_Vertical,
	ImGuiLayoutType_Horizontal
};

enum ImGuiAxis
{
	ImGuiAxis_None = -1,
	ImGuiAxis_X = 0,
	ImGuiAxis_Y = 1
};

enum ImGuiPlotType
{
	ImGuiPlotType_Lines,
	ImGuiPlotType_Histogram
};

enum ImGuiDataType
{
	ImGuiDataType_Int,
	ImGuiDataType_Float,
	ImGuiDataType_Double,
	ImGuiDataType_COUNT
};

enum ImGuiInputSource
{
	ImGuiInputSource_None = 0,
	ImGuiInputSource_Mouse,
	ImGuiInputSource_Nav,
	ImGuiInputSource_NavKeyboard,   // Only used occasionally for storage, not tested/handled by most code
	ImGuiInputSource_NavGamepad,    // "
	ImGuiInputSource_COUNT
};

// FIXME-NAV: Clarify/expose various repeat delay/rate
enum ImGuiInputReadMode
{
	ImGuiInputReadMode_Down,
	ImGuiInputReadMode_Pressed,
	ImGuiInputReadMode_Released,
	ImGuiInputReadMode_Repeat,
	ImGuiInputReadMode_RepeatSlow,
	ImGuiInputReadMode_RepeatFast
};

enum ImGuiNavHighlightFlags_
{
	ImGuiNavHighlightFlags_TypeDefault = 1 << 0,
	ImGuiNavHighlightFlags_TypeThin = 1 << 1,
	ImGuiNavHighlightFlags_AlwaysDraw = 1 << 2,
	ImGuiNavHighlightFlags_NoRounding = 1 << 3
};

enum ImGuiNavDirSourceFlags_
{
	ImGuiNavDirSourceFlags_Keyboard = 1 << 0,
	ImGuiNavDirSourceFlags_PadDPad = 1 << 1,
	ImGuiNavDirSourceFlags_PadLStick = 1 << 2
};

enum ImGuiNavForward
{
	ImGuiNavForward_None,
	ImGuiNavForward_ForwardQueued,
	ImGuiNavForward_ForwardActive
};

// 2D axis aligned bounding-box
// NB: we can't rely on ImVec2 math operators being available here
struct IMGUI_API ImRect
{
	ImVec2      Min;    // Upper-left
	ImVec2      Max;    // Lower-right

	ImRect() : Min(FLT_MAX, FLT_MAX), Max(-FLT_MAX, -FLT_MAX) {}
	ImRect(const ImVec2& min, const ImVec2& max) : Min(min), Max(max) {}
	ImRect(const ImVec4& v) : Min(v.x, v.y), Max(v.z, v.w) {}
	ImRect(float x1, float y1, float x2, float y2) : Min(x1, y1), Max(x2, y2) {}

	ImVec2      GetCenter() const { return ImVec2((Min.x + Max.x) * 0.5f, (Min.y + Max.y) * 0.5f); }
	ImVec2      GetSize() const { return ImVec2(Max.x - Min.x, Max.y - Min.y); }
	float       GetWidth() const { return Max.x - Min.x; }
	float       GetHeight() const { return Max.y - Min.y; }
	ImVec2      GetTL() const { return Min; }                   // Top-left
	ImVec2      GetTR() const { return ImVec2(Max.x, Min.y); }  // Top-right
	ImVec2      GetBL() const { return ImVec2(Min.x, Max.y); }  // Bottom-left
	ImVec2      GetBR() const { return Max; }                   // Bottom-right
	bool        Contains(const ImVec2& p) const { return p.x >= Min.x && p.y >= Min.y && p.x < Max.x && p.y < Max.y; }
	bool        Contains(const ImRect& r) const { return r.Min.x >= Min.x && r.Min.y >= Min.y && r.Max.x <= Max.x && r.Max.y <= Max.y; }
	bool        Overlaps(const ImRect& r) const { return r.Min.y <  Max.y && r.Max.y >  Min.y && r.Min.x <  Max.x && r.Max.x >  Min.x; }
	void        Add(const ImVec2& p) { if (Min.x > p.x)     Min.x = p.x;     if (Min.y > p.y)     Min.y = p.y;     if (Max.x < p.x)     Max.x = p.x;     if (Max.y < p.y)     Max.y = p.y; }
	void        Add(const ImRect& r) { if (Min.x > r.Min.x) Min.x = r.Min.x; if (Min.y > r.Min.y) Min.y = r.Min.y; if (Max.x < r.Max.x) Max.x = r.Max.x; if (Max.y < r.Max.y) Max.y = r.Max.y; }
	void        Expand(const float amount) { Min.x -= amount;   Min.y -= amount;   Max.x += amount;   Max.y += amount; }
	void        Expand(const ImVec2& amount) { Min.x -= amount.x; Min.y -= amount.y; Max.x += amount.x; Max.y += amount.y; }
	void        Translate(const ImVec2& v) { Min.x += v.x; Min.y += v.y; Max.x += v.x; Max.y += v.y; }
	void        ClipWith(const ImRect& r) { Min = ImMax(Min, r.Min); Max = ImMin(Max, r.Max); }                   // Simple version, may lead to an inverted rectangle, which is fine for Contains/Overlaps test but not for display.
	void        ClipWithFull(const ImRect& r) { Min = ImClamp(Min, r.Min, r.Max); Max = ImClamp(Max, r.Min, r.Max); } // Full version, ensure both points are fully clipped.
	void        Floor() { Min.x = (float)(int)Min.x; Min.y = (float)(int)Min.y; Max.x = (float)(int)Max.x; Max.y = (float)(int)Max.y; }
	void        FixInverted() { if (Min.x > Max.x) ImSwap(Min.x, Max.x); if (Min.y > Max.y) ImSwap(Min.y, Max.y); }
	bool        IsInverted() const { return Min.x > Max.x || Min.y > Max.y; }
};

// Stacked color modifier, backup of modified data so we can restore it
struct ImGuiColMod
{
	ImGuiCol    Col;
	ImVec4      BackupValue;
};

// Stacked style modifier, backup of modified data so we can restore it. Data type inferred from the variable.
struct ImGuiStyleMod
{
	ImGuiStyleVar   VarIdx;
	union { int BackupInt[2]; float BackupFloat[2]; };
	ImGuiStyleMod(ImGuiStyleVar idx, int v) { VarIdx = idx; BackupInt[0] = v; }
	ImGuiStyleMod(ImGuiStyleVar idx, float v) { VarIdx = idx; BackupFloat[0] = v; }
	ImGuiStyleMod(ImGuiStyleVar idx, ImVec2 v) { VarIdx = idx; BackupFloat[0] = v.x; BackupFloat[1] = v.y; }
};

// Stacked data for BeginGroup()/EndGroup()
struct ImGuiGroupData
{
	ImVec2      BackupCursorPos;
	ImVec2      BackupCursorMaxPos;
	float       BackupIndentX;
	float       BackupGroupOffsetX;
	float       BackupCurrentLineHeight;
	float       BackupCurrentLineTextBaseOffset;
	float       BackupLogLinePosY;
	bool        BackupActiveIdIsAlive;
	bool        AdvanceCursor;
};

// Simple column measurement currently used for MenuItem() only. This is very short-sighted/throw-away code and NOT a generic helper.
struct IMGUI_API ImGuiMenuColumns
{
	int         Count;
	float       Spacing;
	float       Width, NextWidth;
	float       Pos[4], NextWidths[4];

	ImGuiMenuColumns();
	void        Update(int count, float spacing, bool clear);
	float       DeclColumns(float w0, float w1, float w2);
	float       CalcExtraSpace(float avail_w);
};

// Internal state of the currently focused/edited text input box
struct IMGUI_API ImGuiTextEditState
{
	ImGuiID             Id;                         // widget id owning the text state
	ImVector<ImWchar>   Text;                       // edit buffer, we need to persist but can't guarantee the persistence of the user-provided buffer. so we copy into own buffer.
	ImVector<char>      InitialText;                // backup of end-user buffer at the time of focus (in UTF-8, unaltered)
	ImVector<char>      TempTextBuffer;
	int                 CurLenA, CurLenW;           // we need to maintain our buffer length in both UTF-8 and wchar format.
	int                 BufSizeA;                   // end-user buffer size
	float               ScrollX;
	ImGuiStb::STB_TexteditState   StbState;
	float               CursorAnim;
	bool                CursorFollow;
	bool                SelectedAllMouseLock;

	ImGuiTextEditState() { memset(this, 0, sizeof(*this)); }
	void                CursorAnimReset() { CursorAnim = -0.30f; }                                   // After a user-input the cursor stays on for a while without blinking
	void                CursorClamp() { StbState.cursor = ImMin(StbState.cursor, CurLenW); StbState.select_start = ImMin(StbState.select_start, CurLenW); StbState.select_end = ImMin(StbState.select_end, CurLenW); }
	bool                HasSelection() const { return StbState.select_start != StbState.select_end; }
	void                ClearSelection() { StbState.select_start = StbState.select_end = StbState.cursor; }
	void                SelectAll() { StbState.select_start = 0; StbState.cursor = StbState.select_end = CurLenW; StbState.has_preferred_x = false; }
	void                OnKeyPressed(int key);
};

// Data saved in imgui.ini file
struct ImGuiWindowSettings
{
	char* Name;
	ImGuiID     Id;
	ImVec2      Pos;
	ImVec2      Size;
	bool        Collapsed;

	ImGuiWindowSettings() { Name = NULL; Id = 0; Pos = Size = ImVec2(0, 0); Collapsed = false; }
};

struct ImGuiSettingsHandler
{
	const char* TypeName;   // Short description stored in .ini file. Disallowed characters: '[' ']'
	ImGuiID     TypeHash;   // == ImHash(TypeName, 0, 0)
	void* (*ReadOpenFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, const char* name);
	void(*ReadLineFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, void* entry, const char* line);
	void(*WriteAllFn)(ImGuiContext* ctx, ImGuiSettingsHandler* handler, ImGuiTextBuffer* out_buf);
	void* UserData;

	ImGuiSettingsHandler() { memset(this, 0, sizeof(*this)); }
};

// Storage for current popup stack
struct ImGuiPopupRef
{
	ImGuiID             PopupId;        // Set on OpenPopup()
	ImGuiWindow* Window;         // Resolved on BeginPopup() - may stay unresolved if user never calls OpenPopup()
	ImGuiWindow* ParentWindow;   // Set on OpenPopup()
	int                 OpenFrameCount; // Set on OpenPopup()
	ImGuiID             OpenParentId;   // Set on OpenPopup(), we need this to differenciate multiple menu sets from each others (e.g. inside menu bar vs loose menu items)
	ImVec2              OpenPopupPos;   // Set on OpenPopup(), preferred popup position (typically == OpenMousePos when using mouse)
	ImVec2              OpenMousePos;   // Set on OpenPopup(), copy of mouse position at the time of opening popup
};

struct ImGuiColumnData
{
	float               OffsetNorm;         // Column start offset, normalized 0.0 (far left) -> 1.0 (far right)
	float               OffsetNormBeforeResize;
	ImGuiColumnsFlags   Flags;              // Not exposed
	ImRect              ClipRect;

	ImGuiColumnData() { OffsetNorm = OffsetNormBeforeResize = 0.0f; Flags = 0; }
};

struct ImGuiColumnsSet
{
	ImGuiID             ID;
	ImGuiColumnsFlags   Flags;
	bool                IsFirstFrame;
	bool                IsBeingResized;
	int                 Current;
	int                 Count;
	float               MinX, MaxX;
	float               LineMinY, LineMaxY;
	float               StartPosY;          // Copy of CursorPos
	float               StartMaxPosX;       // Copy of CursorMaxPos
	ImVector<ImGuiColumnData> Columns;

	ImGuiColumnsSet() { Clear(); }
	void Clear()
	{
		ID = 0;
		Flags = 0;
		IsFirstFrame = false;
		IsBeingResized = false;
		Current = 0;
		Count = 1;
		MinX = MaxX = 0.0f;
		LineMinY = LineMaxY = 0.0f;
		StartPosY = 0.0f;
		StartMaxPosX = 0.0f;
		Columns.clear();
	}
};

struct IMGUI_API ImDrawListSharedData
{
	ImVec2          TexUvWhitePixel;            // UV of white pixel in the atlas
	ImFont* Font;                       // Current/default font (optional, for simplified AddText overload)
	float           FontSize;                   // Current/default font size (optional, for simplified AddText overload)
	float           CurveTessellationTol;
	ImVec4          ClipRectFullscreen;         // Value for PushClipRectFullscreen()

												// Const data
												// FIXME: Bake rounded corners fill/borders in atlas
	ImVec2          CircleVtx12[12];

	ImDrawListSharedData();
};

struct ImDrawDataBuilder
{
	ImVector<ImDrawList*>   Layers[2];           // Global layers for: regular, tooltip

	void Clear() { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].resize(0); }
	void ClearFreeMemory() { for (int n = 0; n < IM_ARRAYSIZE(Layers); n++) Layers[n].clear(); }
	IMGUI_API void FlattenIntoSingleLayer();
};

struct ImGuiNavMoveResult
{
	ImGuiID       ID;           // Best candidate
	ImGuiID       ParentID;     // Best candidate window->IDStack.back() - to compare context
	ImGuiWindow* Window;       // Best candidate window
	float         DistBox;      // Best candidate box distance to current NavId
	float         DistCenter;   // Best candidate center distance to current NavId
	float         DistAxial;
	ImRect        RectRel;      // Best candidate bounding box in window relative space

	ImGuiNavMoveResult() { Clear(); }
	void Clear() { ID = ParentID = 0; Window = NULL; DistBox = DistCenter = DistAxial = FLT_MAX; RectRel = ImRect(); }
};

// Storage for SetNexWindow** functions
struct ImGuiNextWindowData
{
	ImGuiCond               PosCond;
	ImGuiCond               SizeCond;
	ImGuiCond               ContentSizeCond;
	ImGuiCond               CollapsedCond;
	ImGuiCond               SizeConstraintCond;
	ImGuiCond               FocusCond;
	ImGuiCond               BgAlphaCond;
	ImVec2                  PosVal;
	ImVec2                  PosPivotVal;
	ImVec2                  SizeVal;
	ImVec2                  ContentSizeVal;
	bool                    CollapsedVal;
	ImRect                  SizeConstraintRect;                 // Valid if 'SetNextWindowSizeConstraint' is true
	ImGuiSizeCallback       SizeCallback;
	void* SizeCallbackUserData;
	float                   BgAlphaVal;

	ImGuiNextWindowData()
	{
		PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;
		PosVal = PosPivotVal = SizeVal = ImVec2(0.0f, 0.0f);
		ContentSizeVal = ImVec2(0.0f, 0.0f);
		CollapsedVal = false;
		SizeConstraintRect = ImRect();
		SizeCallback = NULL;
		SizeCallbackUserData = NULL;
		BgAlphaVal = FLT_MAX;
	}

	void    Clear()
	{
		PosCond = SizeCond = ContentSizeCond = CollapsedCond = SizeConstraintCond = FocusCond = BgAlphaCond = 0;
	}
};

// Main state for ImGui
struct ImGuiContext
{
	bool                    Initialized;
	bool                    FontAtlasOwnedByContext;            // Io.Fonts-> is owned by the ImGuiContext and will be destructed along with it.
	ImGuiIO                 IO;
	ImGuiStyle              Style;
	ImFont* Font;                               // (Shortcut) == FontStack.empty() ? IO.Font : FontStack.back()
	float                   FontSize;                           // (Shortcut) == FontBaseSize * g.CurrentWindow->FontWindowScale == window->FontSize(). Text height for current window.
	float                   FontBaseSize;                       // (Shortcut) == IO.FontGlobalScale * Font->Scale * Font->FontSize. Base text height.
	ImDrawListSharedData    DrawListSharedData;

	float                   Time;
	int                     FrameCount;
	int                     FrameCountEnded;
	int                     FrameCountRendered;
	ImVector<ImGuiWindow*>  Windows;
	ImVector<ImGuiWindow*>  WindowsSortBuffer;
	ImVector<ImGuiWindow*>  CurrentWindowStack;
	ImGuiStorage            WindowsById;
	int                     WindowsActiveCount;
	ImGuiWindow* CurrentWindow;                      // Being drawn into
	ImGuiWindow* HoveredWindow;                      // Will catch mouse inputs
	ImGuiWindow* HoveredRootWindow;                  // Will catch mouse inputs (for focus/move only)
	ImGuiID                 HoveredId;                          // Hovered widget
	bool                    HoveredIdAllowOverlap;
	ImGuiID                 HoveredIdPreviousFrame;
	float                   HoveredIdTimer;
	ImGuiID                 ActiveId;                           // Active widget
	ImGuiID                 ActiveIdPreviousFrame;
	float                   ActiveIdTimer;
	bool                    ActiveIdIsAlive;                    // Active widget has been seen this frame
	bool                    ActiveIdIsJustActivated;            // Set at the time of activation for one frame
	bool                    ActiveIdAllowOverlap;               // Active widget allows another widget to steal active id (generally for overlapping widgets, but not always)
	int                     ActiveIdAllowNavDirFlags;           // Active widget allows using directional navigation (e.g. can activate a button and move away from it)
	ImVec2                  ActiveIdClickOffset;                // Clicked offset from upper-left corner, if applicable (currently only set by ButtonBehavior)
	ImGuiWindow* ActiveIdWindow;
	ImGuiInputSource        ActiveIdSource;                     // Activating with mouse or nav (gamepad/keyboard)
	ImGuiWindow* MovingWindow;                       // Track the window we clicked on (in order to preserve focus). The actually window that is moved is generally MovingWindow->RootWindow.
	ImVector<ImGuiColMod>   ColorModifiers;                     // Stack for PushStyleColor()/PopStyleColor()
	ImVector<ImGuiStyleMod> StyleModifiers;                     // Stack for PushStyleVar()/PopStyleVar()
	ImVector<ImFont*>       FontStack;                          // Stack for PushFont()/PopFont()
	ImVector<ImGuiPopupRef> OpenPopupStack;                     // Which popups are open (persistent)
	ImVector<ImGuiPopupRef> CurrentPopupStack;                  // Which level of BeginPopup() we are in (reset every frame)
	ImGuiNextWindowData     NextWindowData;                     // Storage for SetNextWindow** functions
	bool                    NextTreeNodeOpenVal;                // Storage for SetNextTreeNode** functions
	ImGuiCond               NextTreeNodeOpenCond;

	// Navigation data (for gamepad/keyboard)
	ImGuiWindow* NavWindow;                          // Focused window for navigation. Could be called 'FocusWindow'
	ImGuiID                 NavId;                              // Focused item for navigation
	ImGuiID                 NavActivateId;                      // ~~ (g.ActiveId == 0) && IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0, also set when calling ActivateItem()
	ImGuiID                 NavActivateDownId;                  // ~~ IsNavInputDown(ImGuiNavInput_Activate) ? NavId : 0
	ImGuiID                 NavActivatePressedId;               // ~~ IsNavInputPressed(ImGuiNavInput_Activate) ? NavId : 0
	ImGuiID                 NavInputId;                         // ~~ IsNavInputPressed(ImGuiNavInput_Input) ? NavId : 0
	ImGuiID                 NavJustTabbedId;                    // Just tabbed to this id.
	ImGuiID                 NavJustMovedToId;                   // Just navigated to this id (result of a successfully MoveRequest)
	ImGuiID                 NavNextActivateId;                  // Set by ActivateItem(), queued until next frame
	ImGuiInputSource        NavInputSource;                     // Keyboard or Gamepad mode?
	ImRect                  NavScoringRectScreen;               // Rectangle used for scoring, in screen space. Based of window->DC.NavRefRectRel[], modified for directional navigation scoring.
	int                     NavScoringCount;                    // Metrics for debugging
	ImGuiWindow* NavWindowingTarget;                 // When selecting a window (holding Menu+FocusPrev/Next, or equivalent of CTRL-TAB) this window is temporarily displayed front-most.
	float                   NavWindowingHighlightTimer;
	float                   NavWindowingHighlightAlpha;
	bool                    NavWindowingToggleLayer;
	int                     NavLayer;                           // Layer we are navigating on. For now the system is hard-coded for 0=main contents and 1=menu/title bar, may expose layers later.
	int                     NavIdTabCounter;                    // == NavWindow->DC.FocusIdxTabCounter at time of NavId processing
	bool                    NavIdIsAlive;                       // Nav widget has been seen this frame ~~ NavRefRectRel is valid
	bool                    NavMousePosDirty;                   // When set we will update mouse position if (io.ConfigFlags & ImGuiConfigFlags_NavEnableSetMousePos) if set (NB: this not enabled by default)
	bool                    NavDisableHighlight;                // When user starts using mouse, we hide gamepad/keyboard highlight (NB: but they are still available, which is why NavDisableHighlight isn't always != NavDisableMouseHover)
	bool                    NavDisableMouseHover;               // When user starts using gamepad/keyboard, we hide mouse hovering highlight until mouse is touched again.
	bool                    NavAnyRequest;                      // ~~ NavMoveRequest || NavInitRequest
	bool                    NavInitRequest;                     // Init request for appearing window to select first item
	bool                    NavInitRequestFromMove;
	ImGuiID                 NavInitResultId;
	ImRect                  NavInitResultRectRel;
	bool                    NavMoveFromClampedRefRect;          // Set by manual scrolling, if we scroll to a point where NavId isn't visible we reset navigation from visible items
	bool                    NavMoveRequest;                     // Move request for this frame
	ImGuiNavForward         NavMoveRequestForward;              // None / ForwardQueued / ForwardActive (this is used to navigate sibling parent menus from a child menu)
	ImGuiDir                NavMoveDir, NavMoveDirLast;         // Direction of the move request (left/right/up/down), direction of the previous move request
	ImGuiNavMoveResult      NavMoveResultLocal;                 // Best move request candidate within NavWindow
	ImGuiNavMoveResult      NavMoveResultOther;                 // Best move request candidate within NavWindow's flattened hierarchy (when using the NavFlattened flag)

																// Render
	ImDrawData              DrawData;                           // Main ImDrawData instance to pass render information to the user
	ImDrawDataBuilder       DrawDataBuilder;
	float                   ModalWindowDarkeningRatio;
	ImDrawList              OverlayDrawList;                    // Optional software render of mouse cursors, if io.MouseDrawCursor is set + a few debug overlays
	ImGuiMouseCursor        MouseCursor;

	// Drag and Drop
	bool                    DragDropActive;
	ImGuiDragDropFlags      DragDropSourceFlags;
	int                     DragDropMouseButton;
	ImGuiPayload            DragDropPayload;
	ImRect                  DragDropTargetRect;
	ImGuiID                 DragDropTargetId;
	float                   DragDropAcceptIdCurrRectSurface;
	ImGuiID                 DragDropAcceptIdCurr;               // Target item id (set at the time of accepting the payload)
	ImGuiID                 DragDropAcceptIdPrev;               // Target item id from previous frame (we need to store this to allow for overlapping drag and drop targets)
	int                     DragDropAcceptFrameCount;           // Last time a target expressed a desire to accept the source
	ImVector<unsigned char> DragDropPayloadBufHeap;             // We don't expose the ImVector<> directly
	unsigned char           DragDropPayloadBufLocal[8];         // Local buffer for small payloads

																// Widget state
	ImGuiTextEditState      InputTextState;
	ImFont                  InputTextPasswordFont;
	ImGuiID                 ScalarAsInputTextId;                // Temporary text input when CTRL+clicking on a slider, etc.
	ImGuiColorEditFlags     ColorEditOptions;                   // Store user options for color edit widgets
	ImVec4                  ColorPickerRef;
	float                   DragCurrentValue;                   // Currently dragged value, always float, not rounded by end-user precision settings
	ImVec2                  DragLastMouseDelta;
	float                   DragSpeedDefaultRatio;              // If speed == 0.0f, uses (max-min) * DragSpeedDefaultRatio
	float                   DragSpeedScaleSlow;
	float                   DragSpeedScaleFast;
	ImVec2                  ScrollbarClickDeltaToGrabCenter;    // Distance between mouse and center of grab box, normalized in parent space. Use storage?
	int                     TooltipOverrideCount;
	ImVector<char>          PrivateClipboard;                   // If no custom clipboard handler is defined
	ImVec2                  OsImePosRequest, OsImePosSet;       // Cursor position request & last passed to the OS Input Method Editor

																// Settings
	bool                           SettingsLoaded;
	float                          SettingsDirtyTimer;          // Save .ini Settings on disk when time reaches zero
	ImVector<ImGuiWindowSettings>  SettingsWindows;             // .ini settings for ImGuiWindow
	ImVector<ImGuiSettingsHandler> SettingsHandlers;            // List of .ini settings handlers

																// Logging
	bool                    LogEnabled;
	FILE* LogFile;                            // If != NULL log to stdout/ file
	ImGuiTextBuffer* LogClipboard;                       // Else log to clipboard. This is pointer so our GImGui static constructor doesn't call heap allocators.
	int                     LogStartDepth;
	int                     LogAutoExpandMaxDepth;

	// Misc
	float                   FramerateSecPerFrame[120];          // calculate estimate of framerate for user
	int                     FramerateSecPerFrameIdx;
	float                   FramerateSecPerFrameAccum;
	int                     WantCaptureMouseNextFrame;          // explicit capture via CaptureInputs() sets those flags
	int                     WantCaptureKeyboardNextFrame;
	int                     WantTextInputNextFrame;
	char                    TempBuffer[1024 * 3 + 1];               // temporary text buffer

	ImGuiContext(ImFontAtlas* shared_font_atlas) : OverlayDrawList(NULL)
	{
		Initialized = false;
		Font = NULL;
		FontSize = FontBaseSize = 0.0f;
		FontAtlasOwnedByContext = shared_font_atlas ? false : true;
		IO.Fonts = shared_font_atlas ? shared_font_atlas : IM_NEW(ImFontAtlas)();

		Time = 0.0f;
		FrameCount = 0;
		FrameCountEnded = FrameCountRendered = -1;
		WindowsActiveCount = 0;
		CurrentWindow = NULL;
		HoveredWindow = NULL;
		HoveredRootWindow = NULL;
		HoveredId = 0;
		HoveredIdAllowOverlap = false;
		HoveredIdPreviousFrame = 0;
		HoveredIdTimer = 0.0f;
		ActiveId = 0;
		ActiveIdPreviousFrame = 0;
		ActiveIdTimer = 0.0f;
		ActiveIdIsAlive = false;
		ActiveIdIsJustActivated = false;
		ActiveIdAllowOverlap = false;
		ActiveIdAllowNavDirFlags = 0;
		ActiveIdClickOffset = ImVec2(-1, -1);
		ActiveIdWindow = NULL;
		ActiveIdSource = ImGuiInputSource_None;
		MovingWindow = NULL;
		NextTreeNodeOpenVal = false;
		NextTreeNodeOpenCond = 0;

		NavWindow = NULL;
		NavId = NavActivateId = NavActivateDownId = NavActivatePressedId = NavInputId = 0;
		NavJustTabbedId = NavJustMovedToId = NavNextActivateId = 0;
		NavInputSource = ImGuiInputSource_None;
		NavScoringRectScreen = ImRect();
		NavScoringCount = 0;
		NavWindowingTarget = NULL;
		NavWindowingHighlightTimer = NavWindowingHighlightAlpha = 0.0f;
		NavWindowingToggleLayer = false;
		NavLayer = 0;
		NavIdTabCounter = INT_MAX;
		NavIdIsAlive = false;
		NavMousePosDirty = false;
		NavDisableHighlight = true;
		NavDisableMouseHover = false;
		NavAnyRequest = false;
		NavInitRequest = false;
		NavInitRequestFromMove = false;
		NavInitResultId = 0;
		NavMoveFromClampedRefRect = false;
		NavMoveRequest = false;
		NavMoveRequestForward = ImGuiNavForward_None;
		NavMoveDir = NavMoveDirLast = ImGuiDir_None;

		ModalWindowDarkeningRatio = 0.0f;
		OverlayDrawList._Data = &DrawListSharedData;
		OverlayDrawList._OwnerName = "##Overlay"; // Give it a name for debugging
		MouseCursor = ImGuiMouseCursor_Arrow;

		DragDropActive = false;
		DragDropSourceFlags = 0;
		DragDropMouseButton = -1;
		DragDropTargetId = 0;
		DragDropAcceptIdCurrRectSurface = 0.0f;
		DragDropAcceptIdPrev = DragDropAcceptIdCurr = 0;
		DragDropAcceptFrameCount = -1;
		memset(DragDropPayloadBufLocal, 0, sizeof(DragDropPayloadBufLocal));

		ScalarAsInputTextId = 0;
		ColorEditOptions = ImGuiColorEditFlags__OptionsDefault;
		DragCurrentValue = 0.0f;
		DragLastMouseDelta = ImVec2(0.0f, 0.0f);
		DragSpeedDefaultRatio = 1.0f / 100.0f;
		DragSpeedScaleSlow = 1.0f / 100.0f;
		DragSpeedScaleFast = 10.0f;
		ScrollbarClickDeltaToGrabCenter = ImVec2(0.0f, 0.0f);
		TooltipOverrideCount = 0;
		OsImePosRequest = OsImePosSet = ImVec2(-1.0f, -1.0f);

		SettingsLoaded = false;
		SettingsDirtyTimer = 0.0f;

		LogEnabled = false;
		LogFile = NULL;
		LogClipboard = NULL;
		LogStartDepth = 0;
		LogAutoExpandMaxDepth = 2;

		memset(FramerateSecPerFrame, 0, sizeof(FramerateSecPerFrame));
		FramerateSecPerFrameIdx = 0;
		FramerateSecPerFrameAccum = 0.0f;
		WantCaptureMouseNextFrame = WantCaptureKeyboardNextFrame = WantTextInputNextFrame = -1;
		memset(TempBuffer, 0, sizeof(TempBuffer));
	}
};

// Transient per-window flags, reset at the beginning of the frame. For child window, inherited from parent on first Begin().
// This is going to be exposed in imgui.h when stabilized enough.
enum ImGuiItemFlags_
{
	ImGuiItemFlags_AllowKeyboardFocus = 1 << 0,  // true
	ImGuiItemFlags_ButtonRepeat = 1 << 1,  // false    // Button() will return true multiple times based on io.KeyRepeatDelay and io.KeyRepeatRate settings.
	ImGuiItemFlags_Disabled = 1 << 2,  // false    // FIXME-WIP: Disable interactions but doesn't affect visuals. Should be: grey out and disable interactions with widgets that affect data + view widgets (WIP)
	ImGuiItemFlags_NoNav = 1 << 3,  // false
	ImGuiItemFlags_NoNavDefaultFocus = 1 << 4,  // false
	ImGuiItemFlags_SelectableDontClosePopup = 1 << 5,  // false    // MenuItem/Selectable() automatically closes current Popup window
	ImGuiItemFlags_Default_ = ImGuiItemFlags_AllowKeyboardFocus
};

// Transient per-window data, reset at the beginning of the frame
// FIXME: That's theory, in practice the delimitation between ImGuiWindow and ImGuiDrawContext is quite tenuous and could be reconsidered.
struct IMGUI_API ImGuiDrawContext
{
	ImVec2                  CursorPos;
	ImVec2                  CursorPosPrevLine;
	ImVec2                  CursorStartPos;
	ImVec2                  CursorMaxPos;           // Used to implicitly calculate the size of our contents, always growing during the frame. Turned into window->SizeContents at the beginning of next frame
	float                   CurrentLineHeight;
	float                   CurrentLineTextBaseOffset;
	float                   PrevLineHeight;
	float                   PrevLineTextBaseOffset;
	float                   LogLinePosY;
	int                     TreeDepth;
	ImU32                   TreeDepthMayJumpToParentOnPop; // Store a copy of !g.NavIdIsAlive for TreeDepth 0..31
	ImGuiID                 LastItemId;
	ImGuiItemStatusFlags    LastItemStatusFlags;
	ImRect                  LastItemRect;           // Interaction rect
	ImRect                  LastItemDisplayRect;    // End-user display rect (only valid if LastItemStatusFlags & ImGuiItemStatusFlags_HasDisplayRect)
	bool                    NavHideHighlightOneFrame;
	bool                    NavHasScroll;           // Set when scrolling can be used (ScrollMax > 0.0f)
	int                     NavLayerCurrent;        // Current layer, 0..31 (we currently only use 0..1)
	int                     NavLayerCurrentMask;    // = (1 << NavLayerCurrent) used by ItemAdd prior to clipping.
	int                     NavLayerActiveMask;     // Which layer have been written to (result from previous frame)
	int                     NavLayerActiveMaskNext; // Which layer have been written to (buffer for current frame)
	bool                    MenuBarAppending;       // FIXME: Remove this
	float                   MenuBarOffsetX;
	ImVector<ImGuiWindow*>  ChildWindows;
	ImGuiStorage* StateStorage;
	ImGuiLayoutType         LayoutType;
	ImGuiLayoutType         ParentLayoutType;       // Layout type of parent window at the time of Begin()

													// We store the current settings outside of the vectors to increase memory locality (reduce cache misses). The vectors are rarely modified. Also it allows us to not heap allocate for short-lived windows which are not using those settings.
	ImGuiItemFlags          ItemFlags;              // == ItemFlagsStack.back() [empty == ImGuiItemFlags_Default]
	float                   ItemWidth;              // == ItemWidthStack.back(). 0.0: default, >0.0: width in pixels, <0.0: align xx pixels to the right of window
	float                   TextWrapPos;            // == TextWrapPosStack.back() [empty == -1.0f]
	ImVector<ImGuiItemFlags>ItemFlagsStack;
	ImVector<float>         ItemWidthStack;
	ImVector<float>         TextWrapPosStack;
	ImVector<ImGuiGroupData>GroupStack;
	int                     StackSizesBackup[6];    // Store size of various stacks for asserting

	float                   IndentX;                // Indentation / start position from left of window (increased by TreePush/TreePop, etc.)
	float                   GroupOffsetX;
	float                   ColumnsOffsetX;         // Offset to the current column (if ColumnsCurrent > 0). FIXME: This and the above should be a stack to allow use cases like Tree->Column->Tree. Need revamp columns API.
	ImGuiColumnsSet* ColumnsSet;             // Current columns set

	ImGuiDrawContext()
	{
		CursorPos = CursorPosPrevLine = CursorStartPos = CursorMaxPos = ImVec2(0.0f, 0.0f);
		CurrentLineHeight = PrevLineHeight = 0.0f;
		CurrentLineTextBaseOffset = PrevLineTextBaseOffset = 0.0f;
		LogLinePosY = -1.0f;
		TreeDepth = 0;
		TreeDepthMayJumpToParentOnPop = 0x00;
		LastItemId = 0;
		LastItemStatusFlags = 0;
		LastItemRect = LastItemDisplayRect = ImRect();
		NavHideHighlightOneFrame = false;
		NavHasScroll = false;
		NavLayerActiveMask = NavLayerActiveMaskNext = 0x00;
		NavLayerCurrent = 0;
		NavLayerCurrentMask = 1 << 0;
		MenuBarAppending = false;
		MenuBarOffsetX = 0.0f;
		StateStorage = NULL;
		LayoutType = ParentLayoutType = ImGuiLayoutType_Vertical;
		ItemWidth = 0.0f;
		ItemFlags = ImGuiItemFlags_Default_;
		TextWrapPos = -1.0f;
		memset(StackSizesBackup, 0, sizeof(StackSizesBackup));

		IndentX = 0.0f;
		GroupOffsetX = 0.0f;
		ColumnsOffsetX = 0.0f;
		ColumnsSet = NULL;
	}
};

// Windows data
struct IMGUI_API ImGuiWindow
{
	char* Name;
	ImGuiID                 ID;                                 // == ImHash(Name)
	ImGuiWindowFlags        Flags;                              // See enum ImGuiWindowFlags_
	ImVec2                  PosFloat;
	ImVec2                  Pos;                                // Position rounded-up to nearest pixel
	ImVec2                  Size;                               // Current size (==SizeFull or collapsed title bar size)
	ImVec2                  SizeFull;                           // Size when non collapsed
	ImVec2                  SizeFullAtLastBegin;                // Copy of SizeFull at the end of Begin. This is the reference value we'll use on the next frame to decide if we need scrollbars.
	ImVec2                  SizeContents;                       // Size of contents (== extents reach of the drawing cursor) from previous frame. Include decoration, window title, border, menu, etc.
	ImVec2                  SizeContentsExplicit;               // Size of contents explicitly set by the user via SetNextWindowContentSize()
	ImRect                  ContentsRegionRect;                 // Maximum visible content position in window coordinates. ~~ (SizeContentsExplicit ? SizeContentsExplicit : Size - ScrollbarSizes) - CursorStartPos, per axis
	ImVec2                  WindowPadding;                      // Window padding at the time of begin.
	float                   WindowRounding;                     // Window rounding at the time of begin.
	float                   WindowBorderSize;                   // Window border size at the time of begin.
	ImGuiID                 MoveId;                             // == window->GetID("#MOVE")
	ImGuiID                 ChildId;                            // Id of corresponding item in parent window (for child windows)
	ImVec2                  Scroll;
	ImVec2                  ScrollTarget;                       // target scroll position. stored as cursor position with scrolling canceled out, so the highest point is always 0.0f. (FLT_MAX for no change)
	ImVec2                  ScrollTargetCenterRatio;            // 0.0f = scroll so that target position is at top, 0.5f = scroll so that target position is centered
	bool                    ScrollbarX, ScrollbarY;
	ImVec2                  ScrollbarSizes;
	bool                    Active;                             // Set to true on Begin(), unless Collapsed
	bool                    WasActive;
	bool                    WriteAccessed;                      // Set to true when any widget access the current window
	bool                    Collapsed;                          // Set when collapsing window to become only title-bar
	bool                    CollapseToggleWanted;
	bool                    SkipItems;                          // Set when items can safely be all clipped (e.g. window not visible or collapsed)
	bool                    Appearing;                          // Set during the frame where the window is appearing (or re-appearing)
	bool                    CloseButton;                        // Set when the window has a close button (p_open != NULL)
	int                     BeginOrderWithinParent;             // Order within immediate parent window, if we are a child window. Otherwise 0.
	int                     BeginOrderWithinContext;            // Order within entire imgui context. This is mostly used for debugging submission order related issues.
	int                     BeginCount;                         // Number of Begin() during the current frame (generally 0 or 1, 1+ if appending via multiple Begin/End pairs)
	ImGuiID                 PopupId;                            // ID in the popup stack when this window is used as a popup/menu (because we use generic Name/ID for recycling)
	int                     AutoFitFramesX, AutoFitFramesY;
	bool                    AutoFitOnlyGrows;
	int                     AutoFitChildAxises;
	ImGuiDir                AutoPosLastDirection;
	int                     HiddenFrames;
	ImGuiCond               SetWindowPosAllowFlags;             // store condition flags for next SetWindowPos() call.
	ImGuiCond               SetWindowSizeAllowFlags;            // store condition flags for next SetWindowSize() call.
	ImGuiCond               SetWindowCollapsedAllowFlags;       // store condition flags for next SetWindowCollapsed() call.
	ImVec2                  SetWindowPosVal;                    // store window position when using a non-zero Pivot (position set needs to be processed when we know the window size)
	ImVec2                  SetWindowPosPivot;                  // store window pivot for positioning. ImVec2(0,0) when positioning from top-left corner; ImVec2(0.5f,0.5f) for centering; ImVec2(1,1) for bottom right.

	ImGuiDrawContext        DC;                                 // Temporary per-window data, reset at the beginning of the frame
	ImVector<ImGuiID>       IDStack;                            // ID stack. ID are hashes seeded with the value at the top of the stack
	ImRect                  ClipRect;                           // = DrawList->clip_rect_stack.back(). Scissoring / clipping rectangle. x1, y1, x2, y2.
	ImRect                  WindowRectClipped;                  // = WindowRect just after setup in Begin(). == window->Rect() for root window.
	ImRect                  InnerRect, InnerClipRect;
	int                     LastFrameActive;
	float                   ItemWidthDefault;
	ImGuiMenuColumns        MenuColumns;                        // Simplified columns storage for menu items
	ImGuiStorage            StateStorage;
	ImVector<ImGuiColumnsSet> ColumnsStorage;
	float                   FontWindowScale;                    // Scale multiplier per-window
	ImDrawList* DrawList;
	ImGuiWindow* ParentWindow;                       // If we are a child _or_ popup window, this is pointing to our parent. Otherwise NULL.
	ImGuiWindow* RootWindow;                         // Point to ourself or first ancestor that is not a child window.
	ImGuiWindow* RootWindowForTitleBarHighlight;     // Point to ourself or first ancestor which will display TitleBgActive color when this window is active.
	ImGuiWindow* RootWindowForTabbing;               // Point to ourself or first ancestor which can be CTRL-Tabbed into.
	ImGuiWindow* RootWindowForNav;                   // Point to ourself or first ancestor which doesn't have the NavFlattened flag.

	ImGuiWindow* NavLastChildNavWindow;              // When going to the menu bar, we remember the child window we came from. (This could probably be made implicit if we kept g.Windows sorted by last focused including child window.)
	ImGuiID                 NavLastIds[2];                      // Last known NavId for this window, per layer (0/1)
	ImRect                  NavRectRel[2];                      // Reference rectangle, in window relative space

																// Navigation / Focus
																// FIXME-NAV: Merge all this with the new Nav system, at least the request variables should be moved to ImGuiContext
	int                     FocusIdxAllCounter;                 // Start at -1 and increase as assigned via FocusItemRegister()
	int                     FocusIdxTabCounter;                 // (same, but only count widgets which you can Tab through)
	int                     FocusIdxAllRequestCurrent;          // Item being requested for focus
	int                     FocusIdxTabRequestCurrent;          // Tab-able item being requested for focus
	int                     FocusIdxAllRequestNext;             // Item being requested for focus, for next update (relies on layout to be stable between the frame pressing TAB and the next frame)
	int                     FocusIdxTabRequestNext;             // "

public:
	ImGuiWindow(ImGuiContext* context, const char* name);
	~ImGuiWindow();

	ImGuiID     GetID(const char* str, const char* str_end = NULL);
	ImGuiID     GetID(const void* ptr);
	ImGuiID     GetIDNoKeepAlive(const char* str, const char* str_end = NULL);
	ImGuiID     GetIDFromRectangle(const ImRect& r_abs);

	// We don't use g.FontSize because the window may be != g.CurrentWidow.
	ImRect      Rect() const { return ImRect(Pos.x, Pos.y, Pos.x + Size.x, Pos.y + Size.y); }
	float       CalcFontSize() const { return GImGui->FontBaseSize * FontWindowScale; }
	float       TitleBarHeight() const { return (Flags & ImGuiWindowFlags_NoTitleBar) ? 0.0f : CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f; }
	ImRect      TitleBarRect() const { return ImRect(Pos, ImVec2(Pos.x + SizeFull.x, Pos.y + TitleBarHeight())); }
	float       MenuBarHeight() const { return (Flags & ImGuiWindowFlags_MenuBar) ? CalcFontSize() + GImGui->Style.FramePadding.y * 2.0f : 0.0f; }
	ImRect      MenuBarRect() const { float y1 = Pos.y + TitleBarHeight(); return ImRect(Pos.x, y1, Pos.x + SizeFull.x, y1 + MenuBarHeight()); }
};

// Backup and restore just enough data to be able to use IsItemHovered() on item A after another B in the same window has overwritten the data.
struct ImGuiItemHoveredDataBackup
{
	ImGuiID                 LastItemId;
	ImGuiItemStatusFlags    LastItemStatusFlags;
	ImRect                  LastItemRect;
	ImRect                  LastItemDisplayRect;

	ImGuiItemHoveredDataBackup() { Backup(); }
	void Backup() { ImGuiWindow* window = GImGui->CurrentWindow; LastItemId = window->DC.LastItemId; LastItemStatusFlags = window->DC.LastItemStatusFlags; LastItemRect = window->DC.LastItemRect; LastItemDisplayRect = window->DC.LastItemDisplayRect; }
	void Restore() const { ImGuiWindow* window = GImGui->CurrentWindow; window->DC.LastItemId = LastItemId; window->DC.LastItemStatusFlags = LastItemStatusFlags; window->DC.LastItemRect = LastItemRect; window->DC.LastItemDisplayRect = LastItemDisplayRect; }
};

//-----------------------------------------------------------------------------
// Internal API
// No guarantee of forward compatibility here.
//-----------------------------------------------------------------------------

namespace ImGui
{
	// We should always have a CurrentWindow in the stack (there is an implicit "Debug" window)
	// If this ever crash because g.CurrentWindow is NULL it means that either
	// - ImGui::NewFrame() has never been called, which is illegal.
	// - You are calling ImGui functions after ImGui::Render() and before the next ImGui::NewFrame(), which is also illegal.
	inline    ImGuiWindow* GetCurrentWindowRead() { ImGuiContext& g = *GImGui; return g.CurrentWindow; }
	inline    ImGuiWindow* GetCurrentWindow() { ImGuiContext& g = *GImGui; g.CurrentWindow->WriteAccessed = true; return g.CurrentWindow; }
	IMGUI_API ImGuiWindow* FindWindowByName(const char* name);
	IMGUI_API void          FocusWindow(ImGuiWindow* window);
	IMGUI_API void          BringWindowToFront(ImGuiWindow* window);
	IMGUI_API void          BringWindowToBack(ImGuiWindow* window);
	IMGUI_API bool          IsWindowChildOf(ImGuiWindow* window, ImGuiWindow* potential_parent);
	IMGUI_API bool          IsWindowNavFocusable(ImGuiWindow* window);

	IMGUI_API void          Initialize(ImGuiContext* context);
	IMGUI_API void          Shutdown(ImGuiContext* context);    // Since 1.60 this is a _private_ function. You can call DestroyContext() to destroy the context created by CreateContext().

	IMGUI_API void          NewFrameUpdateHoveredWindowAndCaptureFlags();

	IMGUI_API void                  MarkIniSettingsDirty();
	IMGUI_API ImGuiSettingsHandler* FindSettingsHandler(const char* type_name);
	IMGUI_API ImGuiWindowSettings* FindWindowSettings(ImGuiID id);

	IMGUI_API void          SetActiveID(ImGuiID id, ImGuiWindow* window);
	IMGUI_API ImGuiID       GetActiveID();
	IMGUI_API void          SetFocusID(ImGuiID id, ImGuiWindow* window);
	IMGUI_API void          ClearActiveID();
	IMGUI_API void          SetHoveredID(ImGuiID id);
	IMGUI_API ImGuiID       GetHoveredID();
	IMGUI_API void          KeepAliveID(ImGuiID id);

	IMGUI_API void          ItemSize(const ImVec2& size, float text_offset_y = 0.0f);
	IMGUI_API void          ItemSize(const ImRect& bb, float text_offset_y = 0.0f);
	IMGUI_API bool          ItemAdd(const ImRect& bb, ImGuiID id, const ImRect* nav_bb = NULL);
	IMGUI_API bool          ItemHoverable(const ImRect& bb, ImGuiID id);
	IMGUI_API bool          IsClippedEx(const ImRect& bb, ImGuiID id, bool clip_even_when_logged);
	IMGUI_API bool          FocusableItemRegister(ImGuiWindow* window, ImGuiID id, bool tab_stop = true);      // Return true if focus is requested
	IMGUI_API void          FocusableItemUnregister(ImGuiWindow* window);
	IMGUI_API ImVec2        CalcItemSize(ImVec2 size, float default_x, float default_y);
	IMGUI_API float         CalcWrapWidthForPos(const ImVec2& pos, float wrap_pos_x);
	IMGUI_API void          PushMultiItemsWidths(int components, float width_full = 0.0f);
	IMGUI_API void          PushItemFlag(ImGuiItemFlags option, bool enabled);
	IMGUI_API void          PopItemFlag();

	IMGUI_API void          SetCurrentFont(ImFont* font);

	IMGUI_API void          OpenPopupEx(ImGuiID id);
	IMGUI_API void          ClosePopup(ImGuiID id);
	IMGUI_API void          ClosePopupsOverWindow(ImGuiWindow* ref_window);
	IMGUI_API bool          IsPopupOpen(ImGuiID id);
	IMGUI_API bool          BeginPopupEx(ImGuiID id, ImGuiWindowFlags extra_flags);
	IMGUI_API void          BeginTooltipEx(ImGuiWindowFlags extra_flags, bool override_previous_tooltip = true);

	IMGUI_API void          NavInitWindow(ImGuiWindow* window, bool force_reinit);
	IMGUI_API void          NavMoveRequestCancel();
	IMGUI_API void          ActivateItem(ImGuiID id);   // Remotely activate a button, checkbox, tree node etc. given its unique ID. activation is queued and processed on the next frame when the item is encountered again.

	IMGUI_API float         GetNavInputAmount(ImGuiNavInput n, ImGuiInputReadMode mode);
	IMGUI_API ImVec2        GetNavInputAmount2d(ImGuiNavDirSourceFlags dir_sources, ImGuiInputReadMode mode, float slow_factor = 0.0f, float fast_factor = 0.0f);
	IMGUI_API int           CalcTypematicPressedRepeatAmount(float t, float t_prev, float repeat_delay, float repeat_rate);

	IMGUI_API void          Scrollbar(ImGuiLayoutType direction);
	IMGUI_API void          VerticalSeparator();        // Vertical separator, for menu bars (use current line height). not exposed because it is misleading what it doesn't have an effect on regular layout.
	IMGUI_API bool          SplitterBehavior(ImGuiID id, const ImRect& bb, ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend = 0.0f);

	IMGUI_API bool          BeginDragDropTargetCustom(const ImRect& bb, ImGuiID id);
	IMGUI_API void          ClearDragDrop();
	IMGUI_API bool          IsDragDropPayloadBeingAccepted();

	// FIXME-WIP: New Columns API
	IMGUI_API void          BeginColumns(const char* str_id, int count, ImGuiColumnsFlags flags = 0); // setup number of columns. use an identifier to distinguish multiple column sets. close with EndColumns().
	IMGUI_API void          EndColumns();                                                             // close columns
	IMGUI_API void          PushColumnClipRect(int column_index = -1);

	// NB: All position are in absolute pixels coordinates (never using window coordinates internally)
	// AVOID USING OUTSIDE OF IMGUI.CPP! NOT FOR PUBLIC CONSUMPTION. THOSE FUNCTIONS ARE A MESS. THEIR SIGNATURE AND BEHAVIOR WILL CHANGE, THEY NEED TO BE REFACTORED INTO SOMETHING DECENT.
	IMGUI_API void          RenderText(ImVec2 pos, const char* text, const char* text_end = NULL, bool hide_text_after_hash = true);
	IMGUI_API void          RenderTextWrapped(ImVec2 pos, const char* text, const char* text_end, float wrap_width);
	IMGUI_API void          RenderTextClipped(const ImVec2& pos_min, const ImVec2& pos_max, const char* text, const char* text_end, const ImVec2* text_size_if_known, const ImVec2& align = ImVec2(0, 0), const ImRect* clip_rect = NULL);
	IMGUI_API void          RenderFrame(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, bool border = true, float rounding = 0.0f);
	IMGUI_API void          RenderFrameBorder(ImVec2 p_min, ImVec2 p_max, float rounding = 0.0f);
	IMGUI_API void          RenderColorRectWithAlphaCheckerboard(ImVec2 p_min, ImVec2 p_max, ImU32 fill_col, float grid_step, ImVec2 grid_off, float rounding = 0.0f, int rounding_corners_flags = ~0);
	IMGUI_API void          RenderArrow(ImVec2 pos, ImGuiDir dir, float scale = 1.0f);
	IMGUI_API void          RenderBullet(ImVec2 pos);
	IMGUI_API void          RenderCheckMark(ImVec2 pos, ImU32 col, float sz);
	IMGUI_API void          RenderNavHighlight(const ImRect& bb, ImGuiID id, ImGuiNavHighlightFlags flags = ImGuiNavHighlightFlags_TypeDefault); // Navigation highlight
	IMGUI_API void          RenderRectFilledRangeH(ImDrawList* draw_list, const ImRect& rect, ImU32 col, float x_start_norm, float x_end_norm, float rounding);
	IMGUI_API const char* FindRenderedTextEnd(const char* text, const char* text_end = NULL); // Find the optional ## from which we stop displaying text.

	IMGUI_API bool          Button(const char* label, const ImVec2& size = ImVec2(0, 0), ImGuiButtonFlags flags = 0);
	IMGUI_API bool          ButtonBehavior(const ImRect& bb, ImGuiID id, bool* out_hovered, bool* out_held, ImGuiButtonFlags flags = 0);
	IMGUI_API bool          ButtonEx(const char* label, const ImVec2& size_arg = ImVec2(0, 0), ImGuiButtonFlags flags = 0);
	IMGUI_API bool          CloseButton(ImGuiID id, const ImVec2& pos, float radius);

	IMGUI_API bool          SliderBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_min, float v_max, float power, int decimal_precision, ImGuiSliderFlags flags = 0);
	IMGUI_API bool          SliderFloatN(const char* label, float* v, int components, float v_min, float v_max, const char* display_format, float power);
	IMGUI_API bool          SliderIntN(const char* label, int* v, int components, int v_min, int v_max, const char* display_format);

	IMGUI_API bool          DragBehavior(const ImRect& frame_bb, ImGuiID id, float* v, float v_speed, float v_min, float v_max, int decimal_precision, float power);
	IMGUI_API bool          DragFloatN(const char* label, float* v, int components, float v_speed, float v_min, float v_max, const char* display_format, float power);
	IMGUI_API bool          DragIntN(const char* label, int* v, int components, float v_speed, int v_min, int v_max, const char* display_format);

	IMGUI_API bool          InputTextEx(const char* label, char* buf, int buf_size, const ImVec2& size_arg, ImGuiInputTextFlags flags, ImGuiTextEditCallback callback = NULL, void* user_data = NULL);
	IMGUI_API bool          InputFloatN(const char* label, float* v, int components, int decimal_precision, ImGuiInputTextFlags extra_flags);
	IMGUI_API bool          InputIntN(const char* label, int* v, int components, ImGuiInputTextFlags extra_flags);
	IMGUI_API bool          InputScalarEx(const char* label, ImGuiDataType data_type, void* data_ptr, void* step_ptr, void* step_fast_ptr, const char* scalar_format, ImGuiInputTextFlags extra_flags);
	IMGUI_API bool          InputScalarAsWidgetReplacement(const ImRect& aabb, const char* label, ImGuiDataType data_type, void* data_ptr, ImGuiID id, int decimal_precision);

	IMGUI_API void          ColorTooltip(const char* text, const float* col, ImGuiColorEditFlags flags);
	IMGUI_API void          ColorEditOptionsPopup(const float* col, ImGuiColorEditFlags flags);

	IMGUI_API bool          TreeNodeBehavior(ImGuiID id, ImGuiTreeNodeFlags flags, const char* label, const char* label_end = NULL);
	IMGUI_API bool          TreeNodeBehaviorIsOpen(ImGuiID id, ImGuiTreeNodeFlags flags = 0);                     // Consume previous SetNextTreeNodeOpened() data, if any. May return true when logging
	IMGUI_API void          TreePushRawID(ImGuiID id);

	IMGUI_API void          PlotEx(ImGuiPlotType plot_type, const char* label, float(*values_getter)(void* data, int idx), void* data, int values_count, int values_offset, const char* overlay_text, float scale_min, float scale_max, ImVec2 graph_size);

	IMGUI_API int           ParseFormatPrecision(const char* fmt, int default_value);
	IMGUI_API float         RoundScalar(float value, int decimal_precision);

	// Shade functions (write over already created vertices)
	IMGUI_API void          ShadeVertsLinearColorGradientKeepAlpha(ImDrawVert* vert_start, ImDrawVert* vert_end, ImVec2 gradient_p0, ImVec2 gradient_p1, ImU32 col0, ImU32 col1);
	IMGUI_API void          ShadeVertsLinearAlphaGradientForLeftToRightText(ImDrawVert* vert_start, ImDrawVert* vert_end, float gradient_p0_x, float gradient_p1_x);
	IMGUI_API void          ShadeVertsLinearUV(ImDrawVert* vert_start, ImDrawVert* vert_end, const ImVec2& a, const ImVec2& b, const ImVec2& uv_a, const ImVec2& uv_b, bool clamp);
} // namespace ImGui

  // ImFontAtlas internals
IMGUI_API bool              ImFontAtlasBuildWithStbTruetype(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildRegisterDefaultCustomRects(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildSetupFont(ImFontAtlas* atlas, ImFont* font, ImFontConfig* font_config, float ascent, float descent);
IMGUI_API void              ImFontAtlasBuildPackCustomRects(ImFontAtlas* atlas, void* spc);
IMGUI_API void              ImFontAtlasBuildFinish(ImFontAtlas* atlas);
IMGUI_API void              ImFontAtlasBuildMultiplyCalcLookupTable(unsigned char out_table[256], float in_multiply_factor);
IMGUI_API void              ImFontAtlasBuildMultiplyRectAlpha8(const unsigned char table[256], unsigned char* pixels, int x, int y, int w, int h, int stride);

#ifdef __clang__
#pragma clang diagnostic pop
#endif

#ifdef _MSC_VER
#pragma warning (pop)
#endif

```

`src/imgui/stb_rect_pack.h`:

```h
// stb_rect_pack.h - v0.10 - public domain - rectangle packing
// Sean Barrett 2014
//
// Useful for e.g. packing rectangular textures into an atlas.
// Does not do rotation.
//
// Not necessarily the awesomest packing method, but better than
// the totally naive one in stb_truetype (which is primarily what
// this is meant to replace).
//
// Has only had a few tests run, may have issues.
//
// More docs to come.
//
// No memory allocations; uses qsort() and assert() from stdlib.
// Can override those by defining STBRP_SORT and STBRP_ASSERT.
//
// This library currently uses the Skyline Bottom-Left algorithm.
//
// Please note: better rectangle packers are welcome! Please
// implement them to the same API, but with a different init
// function.
//
// Credits
//
//  Library
//    Sean Barrett
//  Minor features
//    Martins Mozeiko
//  Bugfixes / warning fixes
//    Jeremy Jaussaud
//
// Version history:
//
//     0.10  (2016-10-25)  remove cast-away-const to avoid warnings
//     0.09  (2016-08-27)  fix compiler warnings
//     0.08  (2015-09-13)  really fix bug with empty rects (w=0 or h=0)
//     0.07  (2015-09-13)  fix bug with empty rects (w=0 or h=0)
//     0.06  (2015-04-15)  added STBRP_SORT to allow replacing qsort
//     0.05:  added STBRP_ASSERT to allow replacing assert
//     0.04:  fixed minor bug in STBRP_LARGE_RECTS support
//     0.01:  initial release
//
// LICENSE
//
//   This software is dual-licensed to the public domain and under the following
//   license: you are granted a perpetual, irrevocable license to copy, modify,
//   publish, and distribute this file as you see fit.

//////////////////////////////////////////////////////////////////////////////
//
//       INCLUDE SECTION
//

#ifndef STB_INCLUDE_STB_RECT_PACK_H
#define STB_INCLUDE_STB_RECT_PACK_H

#define STB_RECT_PACK_VERSION  1

#ifdef STBRP_STATIC
#define STBRP_DEF static
#else
#define STBRP_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

	typedef struct stbrp_context stbrp_context;
	typedef struct stbrp_node    stbrp_node;
	typedef struct stbrp_rect    stbrp_rect;

#ifdef STBRP_LARGE_RECTS
	typedef int            stbrp_coord;
#else
	typedef unsigned short stbrp_coord;
#endif

	STBRP_DEF void stbrp_pack_rects(stbrp_context* context, stbrp_rect* rects, int num_rects);
	// Assign packed locations to rectangles. The rectangles are of type
	// 'stbrp_rect' defined below, stored in the array 'rects', and there
	// are 'num_rects' many of them.
	//
	// Rectangles which are successfully packed have the 'was_packed' flag
	// Set to a non-zero value and 'x' and 'y' store the minimum location
	// on each axis (i.e. bottom-left in cartesian coordinates, top-left
	// if you imagine y increasing downwards). Rectangles which do not fit
	// have the 'was_packed' flag Set to 0.
	//
	// You should not try to access the 'rects' array from another thread
	// while this function is running, as the function temporarily reorders
	// the array while it executes.
	//
	// To pack into another rectangle, you need to call stbrp_init_target
	// again. To continue packing into the same rectangle, you can call
	// this function again. Calling this multiple times with multiple rect
	// arrays will probably produce worse packing results than calling it
	// a single time with the full rectangle array, but the option is
	// available.

	struct stbrp_rect
	{
		// reserved for your use:
		int            id;

		// input:
		stbrp_coord    w, h;

		// output:
		stbrp_coord    x, y;
		int            was_packed;  // non-zero if valid packing
	}; // 16 bytes, nominally

	STBRP_DEF void stbrp_init_target(stbrp_context* context, int width, int height, stbrp_node* nodes, int num_nodes);
	// Initialize a rectangle packer to:
	//    pack a rectangle that is 'width' by 'height' in dimensions
	//    using temporary storage provided by the array 'nodes', which is 'num_nodes' long
	//
	// You must call this function every time you start packing into a new target.
	//
	// There is no "Shutdown" function. The 'nodes' memory must stay valid for
	// the following stbrp_pack_rects() call (or calls), but can be freed after
	// the call (or calls) finish.
	//
	// Note: to guarantee best results, either:
	//       1. make sure 'num_nodes' >= 'width'
	//   or  2. call stbrp_allow_out_of_mem() defined below with 'allow_out_of_mem = 1'
	//
	// If you don't do either of the above things, widths will be quantized to multiples
	// of small integers to guarantee the algorithm doesn't run out of temporary storage.
	//
	// If you do #2, then the non-quantized algorithm will be used, but the algorithm
	// may run out of temporary storage and be unable to pack some rectangles.

	STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context* context, int allow_out_of_mem);
	// Optionally call this function after init but before doing any packing to
	// change the handling of the out-of-temp-memory scenario, described above.
	// If you call init again, this will be reset to the default (false).

	STBRP_DEF void stbrp_setup_heuristic(stbrp_context* context, int heuristic);
	// Optionally select which packing heuristic the library should use. Different
	// heuristics will produce better/worse results for different data sets.
	// If you call init again, this will be reset to the default.

	enum
	{
		STBRP_HEURISTIC_Skyline_default = 0,
		STBRP_HEURISTIC_Skyline_BL_sortHeight = STBRP_HEURISTIC_Skyline_default,
		STBRP_HEURISTIC_Skyline_BF_sortHeight
	};

	//////////////////////////////////////////////////////////////////////////////
	//
	// the details of the following structures don't matter to you, but they must
	// be visible so you can handle the memory allocations for them

	struct stbrp_node
	{
		stbrp_coord  x, y;
		stbrp_node* next;
	};

	struct stbrp_context
	{
		int width;
		int height;
		int align;
		int init_mode;
		int heuristic;
		int num_nodes;
		stbrp_node* active_head;
		stbrp_node* free_head;
		stbrp_node extra[2]; // we allocate two extra nodes so optimal user-node-count is 'width' not 'width+2'
	};

#ifdef __cplusplus
}
#endif

#endif

//////////////////////////////////////////////////////////////////////////////
//
//     IMPLEMENTATION SECTION
//

#ifdef STB_RECT_PACK_IMPLEMENTATION
#ifndef STBRP_SORT
#include <stdlib.h>
#define STBRP_SORT qsort
#endif

#ifndef STBRP_ASSERT
#include <assert.h>
#define STBRP_ASSERT assert
#endif

#ifdef _MSC_VER
#define STBRP__NOTUSED(v)  (void)(v)
#else
#define STBRP__NOTUSED(v)  (void)sizeof(v)
#endif

enum
{
	STBRP__INIT_skyline = 1
};

STBRP_DEF void stbrp_setup_heuristic(stbrp_context* context, int heuristic)
{
	switch (context->init_mode) {
	case STBRP__INIT_skyline:
		STBRP_ASSERT(heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight || heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight);
		context->heuristic = heuristic;
		break;
	default:
		STBRP_ASSERT(0);
	}
}

STBRP_DEF void stbrp_setup_allow_out_of_mem(stbrp_context* context, int allow_out_of_mem)
{
	if (allow_out_of_mem)
		// if it's ok to run out of memory, then don't bother aligning them;
		// this gives better packing, but may fail due to OOM (even though
		// the rectangles easily fit). @TODO a smarter approach would be to only
		// quantize once we've hit OOM, then we could Get rid of this parameter.
		context->align = 1;
	else {
		// if it's not ok to run out of memory, then quantize the widths
		// so that num_nodes is always enough nodes.
		//
		// I.e. num_nodes * align >= width
		//                  align >= width / num_nodes
		//                  align = ceil(width/num_nodes)

		context->align = (context->width + context->num_nodes - 1) / context->num_nodes;
	}
}

STBRP_DEF void stbrp_init_target(stbrp_context* context, int width, int height, stbrp_node* nodes, int num_nodes)
{
	int i;
#ifndef STBRP_LARGE_RECTS
	STBRP_ASSERT(width <= 0xffff && height <= 0xffff);
#endif

	for (i = 0; i < num_nodes - 1; ++i)
		nodes[i].next = &nodes[i + 1];
	nodes[i].next = NULL;
	context->init_mode = STBRP__INIT_skyline;
	context->heuristic = STBRP_HEURISTIC_Skyline_default;
	context->free_head = &nodes[0];
	context->active_head = &context->extra[0];
	context->width = width;
	context->height = height;
	context->num_nodes = num_nodes;
	stbrp_setup_allow_out_of_mem(context, 0);

	// node 0 is the full width, node 1 is the sentinel (lets us not store width explicitly)
	context->extra[0].x = 0;
	context->extra[0].y = 0;
	context->extra[0].next = &context->extra[1];
	context->extra[1].x = (stbrp_coord)width;
#ifdef STBRP_LARGE_RECTS
	context->extra[1].y = (1 << 30);
#else
	context->extra[1].y = 65535;
#endif
	context->extra[1].next = NULL;
}

// GetOffset minimum y position if it starts at x1
static int stbrp__skyline_find_min_y(stbrp_context* c, stbrp_node* first, int x0, int width, int* pwaste)
{
	stbrp_node* node = first;
	int x1 = x0 + width;
	int min_y, visited_width, waste_area;

	STBRP__NOTUSED(c);

	STBRP_ASSERT(first->x <= x0);

#if 0
	// skip in case we're past the node
	while (node->next->x <= x0)
		++node;
#else
	STBRP_ASSERT(node->next->x > x0); // we ended up handling this in the caller for efficiency
#endif

	STBRP_ASSERT(node->x <= x0);

	min_y = 0;
	waste_area = 0;
	visited_width = 0;
	while (node->x < x1) {
		if (node->y > min_y) {
			// raise min_y higher.
			// we've accounted for all waste up to min_y,
			// but we'll now add more waste for everything we've visted
			waste_area += visited_width * (node->y - min_y);
			min_y = node->y;
			// the first time through, visited_width might be reduced
			if (node->x < x0)
				visited_width += node->next->x - x0;
			else
				visited_width += node->next->x - node->x;
		}
		else {
			// add waste area
			int under_width = node->next->x - node->x;
			if (under_width + visited_width > width)
				under_width = width - visited_width;
			waste_area += under_width * (min_y - node->y);
			visited_width += under_width;
		}
		node = node->next;
	}

	*pwaste = waste_area;
	return min_y;
}

typedef struct
{
	int x, y;
	stbrp_node** prev_link;
} stbrp__findresult;

static stbrp__findresult stbrp__skyline_find_best_pos(stbrp_context* c, int width, int height)
{
	int best_waste = (1 << 30), best_x, best_y = (1 << 30);
	stbrp__findresult fr;
	stbrp_node** prev, * node, * tail, ** best = NULL;

	// align to multiple of c->align
	width = (width + c->align - 1);
	width -= width % c->align;
	STBRP_ASSERT(width % c->align == 0);

	node = c->active_head;
	prev = &c->active_head;
	while (node->x + width <= c->width) {
		int y, waste;
		y = stbrp__skyline_find_min_y(c, node, node->x, width, &waste);
		if (c->heuristic == STBRP_HEURISTIC_Skyline_BL_sortHeight) { // actually just want to test BL
		   // bottom left
			if (y < best_y) {
				best_y = y;
				best = prev;
			}
		}
		else {
			// best-fit
			if (y + height <= c->height) {
				// can only use it if it first vertically
				if (y < best_y || (y == best_y && waste < best_waste)) {
					best_y = y;
					best_waste = waste;
					best = prev;
				}
			}
		}
		prev = &node->next;
		node = node->next;
	}

	best_x = (best == NULL) ? 0 : (*best)->x;

	// if doing best-fit (BF), we also have to try aligning right edge to each node position
	//
	// e.g, if fitting
	//
	//     ____________________
	//    |____________________|
	//
	//            into
	//
	//   |                         |
	//   |             ____________|
	//   |____________|
	//
	// then right-aligned reduces waste, but bottom-left BL is always chooses left-aligned
	//
	// This makes BF take about 2x the time

	if (c->heuristic == STBRP_HEURISTIC_Skyline_BF_sortHeight) {
		tail = c->active_head;
		node = c->active_head;
		prev = &c->active_head;
		// GetOffset first node that's admissible
		while (tail->x < width)
			tail = tail->next;
		while (tail) {
			int xpos = tail->x - width;
			int y, waste;
			STBRP_ASSERT(xpos >= 0);
			// GetOffset the left position that matches this
			while (node->next->x <= xpos) {
				prev = &node->next;
				node = node->next;
			}
			STBRP_ASSERT(node->next->x > xpos && node->x <= xpos);
			y = stbrp__skyline_find_min_y(c, node, xpos, width, &waste);
			if (y + height < c->height) {
				if (y <= best_y) {
					if (y < best_y || waste < best_waste || (waste == best_waste && xpos < best_x)) {
						best_x = xpos;
						STBRP_ASSERT(y <= best_y);
						best_y = y;
						best_waste = waste;
						best = prev;
					}
				}
			}
			tail = tail->next;
		}
	}

	fr.prev_link = best;
	fr.x = best_x;
	fr.y = best_y;
	return fr;
}

static stbrp__findresult stbrp__skyline_pack_rectangle(stbrp_context* context, int width, int height)
{
	// GetOffset best position according to heuristic
	stbrp__findresult res = stbrp__skyline_find_best_pos(context, width, height);
	stbrp_node* node, * cur;

	// bail if:
	//    1. it failed
	//    2. the best node doesn't fit (we don't always check this)
	//    3. we're out of memory
	if (res.prev_link == NULL || res.y + height > context->height || context->free_head == NULL) {
		res.prev_link = NULL;
		return res;
	}

	// on success, create new node
	node = context->free_head;
	node->x = (stbrp_coord)res.x;
	node->y = (stbrp_coord)(res.y + height);

	context->free_head = node->next;

	// insert the new node into the right starting point, and
	// let 'cur' point to the remaining nodes needing to be
	// stiched back in

	cur = *res.prev_link;
	if (cur->x < res.x) {
		// preserve the existing one, so start testing with the next one
		stbrp_node* next = cur->next;
		cur->next = node;
		cur = next;
	}
	else {
		*res.prev_link = node;
	}

	// from here, traverse cur and free the nodes, until we Get to one
	// that shouldn't be freed
	while (cur->next && cur->next->x <= res.x + width) {
		stbrp_node* next = cur->next;
		// move the current node to the free list
		cur->next = context->free_head;
		context->free_head = cur;
		cur = next;
	}

	// stitch the list back in
	node->next = cur;

	if (cur->x < res.x + width)
		cur->x = (stbrp_coord)(res.x + width);

#ifdef _DEBUG
	cur = context->active_head;
	while (cur->x < context->width) {
		STBRP_ASSERT(cur->x < cur->next->x);
		cur = cur->next;
	}
	STBRP_ASSERT(cur->next == NULL);

	{
		stbrp_node* L1 = NULL, * L2 = NULL;
		int count = 0;
		cur = context->active_head;
		while (cur) {
			L1 = cur;
			cur = cur->next;
			++count;
		}
		cur = context->free_head;
		while (cur) {
			L2 = cur;
			cur = cur->next;
			++count;
		}
		STBRP_ASSERT(count == context->num_nodes + 2);
	}
#endif

	return res;
}

static int rect_height_compare(const void* a, const void* b)
{
	const stbrp_rect* p = (const stbrp_rect*)a;
	const stbrp_rect* q = (const stbrp_rect*)b;
	if (p->h > q->h)
		return -1;
	if (p->h < q->h)
		return  1;
	return (p->w > q->w) ? -1 : (p->w < q->w);
}

static int rect_width_compare(const void* a, const void* b)
{
	const stbrp_rect* p = (const stbrp_rect*)a;
	const stbrp_rect* q = (const stbrp_rect*)b;
	if (p->w > q->w)
		return -1;
	if (p->w < q->w)
		return  1;
	return (p->h > q->h) ? -1 : (p->h < q->h);
}

static int rect_original_order(const void* a, const void* b)
{
	const stbrp_rect* p = (const stbrp_rect*)a;
	const stbrp_rect* q = (const stbrp_rect*)b;
	return (p->was_packed < q->was_packed) ? -1 : (p->was_packed > q->was_packed);
}

#ifdef STBRP_LARGE_RECTS
#define STBRP__MAXVAL  0xffffffff
#else
#define STBRP__MAXVAL  0xffff
#endif

STBRP_DEF void stbrp_pack_rects(stbrp_context * context, stbrp_rect * rects, int num_rects)
{
	int i;

	// we use the 'was_packed' field internally to allow sorting/unsorting
	for (i = 0; i < num_rects; ++i) {
		rects[i].was_packed = i;
#ifndef STBRP_LARGE_RECTS
		STBRP_ASSERT(rects[i].w <= 0xffff && rects[i].h <= 0xffff);
#endif
	}

	// sort according to heuristic
	STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_height_compare);

	for (i = 0; i < num_rects; ++i) {
		if (rects[i].w == 0 || rects[i].h == 0) {
			rects[i].x = rects[i].y = 0;  // empty rect needs no space
		}
		else {
			stbrp__findresult fr = stbrp__skyline_pack_rectangle(context, rects[i].w, rects[i].h);
			if (fr.prev_link) {
				rects[i].x = (stbrp_coord)fr.x;
				rects[i].y = (stbrp_coord)fr.y;
			}
			else {
				rects[i].x = rects[i].y = STBRP__MAXVAL;
			}
		}
	}

	// unsort
	STBRP_SORT(rects, num_rects, sizeof(rects[0]), rect_original_order);

	// Set was_packed flags
	for (i = 0; i < num_rects; ++i)
		rects[i].was_packed = !(rects[i].x == STBRP__MAXVAL && rects[i].y == STBRP__MAXVAL);
}
#endif

```

`src/imgui/stb_textedit.h`:

```h
// [ImGui] this is a slightly modified version of stb_truetype.h 1.9. Those changes would need to be pushed into nothings/sb
// [ImGui] - fixed linestart handler when over last character of multi-line buffer + simplified existing code (#588, #815)
// [ImGui] - fixed a state corruption/crash bug in stb_text_redo and stb_textedit_discard_redo (#715)
// [ImGui] - fixed a crash bug in stb_textedit_discard_redo (#681)
// [ImGui] - fixed some minor warnings

// stb_textedit.h - v1.9  - public domain - Sean Barrett
// Development of this library was sponsored by RAD Game Tools
//
// This C header file implements the guts of a multi-line text-editing
// widget; you implement display, word-wrapping, and low-level string
// insertion/deletion, and stb_textedit will map user inputs into
// insertions & deletions, plus updates to the cursor position,
// selection state, and undo state.
//
// It is intended for use in games and other systems that need to build
// their own custom widgets and which do not have heavy text-editing
// requirements (this library is not recommended for use for editing large
// texts, as its performance does not scale and it has limited undo).
//
// Non-trivial behaviors are modelled after Windows text controls.
//
//
// LICENSE
//
//   This software is dual-licensed to the public domain and under the following
//   license: you are granted a perpetual, irrevocable license to copy, modify,
//   publish, and distribute this file as you see fit.
//
//
// DEPENDENCIES
//
// Uses the C runtime function 'memmove', which you can override
// by defining STB_TEXTEDIT_memmove before the implementation.
// Uses no other functions. Performs no runtime allocations.
//
//
// VERSION HISTORY
//
//   1.9  (2016-08-27) customizable move-by-word
//   1.8  (2016-04-02) better keyboard handling when mouse button is down
//   1.7  (2015-09-13) change y range handling in case baseline is non-0
//   1.6  (2015-04-15) allow STB_TEXTEDIT_memmove
//   1.5  (2014-09-10) add support for secondary m_iKeyMap for OS X
//   1.4  (2014-08-17) fix signed/unsigned warnings
//   1.3  (2014-06-19) fix mouse clicking to round to nearest char boundary
//   1.2  (2014-05-27) fix some RAD types that had crept into the new code
//   1.1  (2013-12-15) move-by-word (requires STB_TEXTEDIT_IS_SPACE )
//   1.0  (2012-07-26) improve documentation, initial public release
//   0.3  (2012-02-24) bugfixes, single-line mode; insert mode
//   0.2  (2011-11-28) fixes to undo/redo
//   0.1  (2010-07-08) initial version
//
// ADDITIONAL CONTRIBUTORS
//
//   Ulf Winklemann: move-by-word in 1.1
//   Fabian Giesen: secondary key inputs in 1.5
//   Martins Mozeiko: STB_TEXTEDIT_memmove
//
//   Bugfixes:
//      Scott Graham
//      Daniel Keller
//      Omar Cornut
//
// USAGE
//
// This file behaves differently depending on what symbols you define
// before including it.
//
//
// Header-file mode:
//
//   If you do not define STB_TEXTEDIT_IMPLEMENTATION before including this,
//   it will operate in "header file" mode. In this mode, it declares a
//   single public symbol, STB_TexteditState, which encapsulates the current
//   state of a text widget (except for the string, which you will store
//   separately).
//
//   To compile in this mode, you must define STB_TEXTEDIT_CHARTYPE to a
//   primitive type that defines a single character (e.g. char, wchar_t, etc).
//
//   To save space or increase undo-ability, you can optionally define the
//   following things that are used by the undo system:
//
//      STB_TEXTEDIT_POSITIONTYPE         small int type encoding a valid cursor position
//      STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//      STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
//   If you don't define these, they are Set to permissive types and
//   moderate sizes. The undo system does no memory allocations, so
//   it grows STB_TexteditState by the worst-case storage which is (in bytes):
//
//        [4 + sizeof(STB_TEXTEDIT_POSITIONTYPE)] * STB_TEXTEDIT_UNDOSTATE_COUNT
//      +      sizeof(STB_TEXTEDIT_CHARTYPE)      * STB_TEXTEDIT_UNDOCHAR_COUNT
//
//
// Implementation mode:
//
//   If you define STB_TEXTEDIT_IMPLEMENTATION before including this, it
//   will compile the implementation of the text edit widget, depending
//   on a large number of symbols which must be defined before the include.
//
//   The implementation is defined only as static functions. You will then
//   need to provide your own APIs in the same file which will access the
//   static functions.
//
//   The basic concept is that you provide a "string" object which
//   behaves like an array of characters. stb_textedit uses indices to
//   refer to positions in the string, implicitly representing positions
//   in the displayed textedit. This is true for both plain text and
//   rich text; even with rich text stb_truetype interacts with your
//   code as if there was an array of all the displayed characters.
//
// Symbols that must be the same in header-file and implementation mode:
//
//     STB_TEXTEDIT_CHARTYPE             the character type
//     STB_TEXTEDIT_POSITIONTYPE         small type that a valid cursor position
//     STB_TEXTEDIT_UNDOSTATECOUNT       the number of undo states to allow
//     STB_TEXTEDIT_UNDOCHARCOUNT        the number of characters to store in the undo buffer
//
// Symbols you must define for implementation mode:
//
//    STB_TEXTEDIT_STRING               the type of object representing a string being edited,
//                                      typically this is a wrapper object with other data you need
//
//    STB_TEXTEDIT_STRINGLEN(obj)       the length of the string (ideally O(1))
//    STB_TEXTEDIT_LAYOUTROW(&r,obj,n)  returns the results of laying out a line of characters
//                                        starting from character #n (see discussion below)
//    STB_TEXTEDIT_GETWIDTH(obj,n,i)    returns the pixel delta from the xpos of the i'th character
//                                        to the xpos of the i+1'th char for a line of characters
//                                        starting at character #n (i.e. accounts for kerning
//                                        with previous char)
//    STB_TEXTEDIT_KEYTOTEXT(k)         maps a keyboard input to an insertable character
//                                        (return type is int, -1 means not valid to insert)
//    STB_TEXTEDIT_GETCHAR(obj,i)       returns the i'th character of obj, 0-based
//    STB_TEXTEDIT_NEWLINE              the character returned by _GETCHAR() we recognize
//                                        as manually wordwrapping for end-of-line positioning
//
//    STB_TEXTEDIT_DELETECHARS(obj,i,n)      delete n characters starting at i
//    STB_TEXTEDIT_INSERTCHARS(obj,i,c*,n)   insert n characters at i (pointed to by STB_TEXTEDIT_CHARTYPE*)
//
//    STB_TEXTEDIT_K_SHIFT       a power of two that is or'd in to a keyboard input to represent the shift key
//
//    STB_TEXTEDIT_K_LEFT        keyboard input to move cursor left
//    STB_TEXTEDIT_K_RIGHT       keyboard input to move cursor right
//    STB_TEXTEDIT_K_UP          keyboard input to move cursor up
//    STB_TEXTEDIT_K_DOWN        keyboard input to move cursor down
//    STB_TEXTEDIT_K_LINESTART   keyboard input to move cursor to start of line  // e.g. HOME
//    STB_TEXTEDIT_K_LINEEND     keyboard input to move cursor to end of line    // e.g. END
//    STB_TEXTEDIT_K_TEXTSTART   keyboard input to move cursor to start of text  // e.g. ctrl-HOME
//    STB_TEXTEDIT_K_TEXTEND     keyboard input to move cursor to end of text    // e.g. ctrl-END
//    STB_TEXTEDIT_K_DELETE      keyboard input to delete selection or character under cursor
//    STB_TEXTEDIT_K_BACKSPACE   keyboard input to delete selection or character left of cursor
//    STB_TEXTEDIT_K_UNDO        keyboard input to perform undo
//    STB_TEXTEDIT_K_REDO        keyboard input to perform redo
//
// Optional:
//    STB_TEXTEDIT_K_INSERT              keyboard input to Toggle insert mode
//    STB_TEXTEDIT_IS_SPACE(ch)          true if character is whitespace (e.g. 'isspace'),
//                                          required for default WORDLEFT/WORDRIGHT handlers
//    STB_TEXTEDIT_MOVEWORDLEFT(obj,i)   custom handler for WORDLEFT, returns index to move cursor to
//    STB_TEXTEDIT_MOVEWORDRIGHT(obj,i)  custom handler for WORDRIGHT, returns index to move cursor to
//    STB_TEXTEDIT_K_WORDLEFT            keyboard input to move cursor left one word // e.g. ctrl-LEFT
//    STB_TEXTEDIT_K_WORDRIGHT           keyboard input to move cursor right one word // e.g. ctrl-RIGHT
//    STB_TEXTEDIT_K_LINESTART2          secondary keyboard input to move cursor to start of line
//    STB_TEXTEDIT_K_LINEEND2            secondary keyboard input to move cursor to end of line
//    STB_TEXTEDIT_K_TEXTSTART2          secondary keyboard input to move cursor to start of text
//    STB_TEXTEDIT_K_TEXTEND2            secondary keyboard input to move cursor to end of text
//
// Todo:
//    STB_TEXTEDIT_K_PGUP        keyboard input to move cursor up a page
//    STB_TEXTEDIT_K_PGDOWN      keyboard input to move cursor down a page
//
// Keyboard input must be encoded as a single integer value; e.g. a character code
// and some bitflags that represent shift states. to simplify the interface, SHIFT must
// be a bitflag, so we can test the shifted state of cursor movements to allow selection,
// i.e. (STB_TEXTED_K_RIGHT|STB_TEXTEDIT_K_SHIFT) should be shifted right-arrow.
//
// You can encode other things, such as CONTROL or ALT, in additional bits, and
// then test for their presence in e.g. STB_TEXTEDIT_K_WORDLEFT. For example,
// my Windows implementations add an additional CONTROL bit, and an additional KEYDOWN
// bit. Then all of the STB_TEXTEDIT_K_ values bitwise-or in the KEYDOWN bit,
// and I pass both WM_KEYDOWN and WM_CHAR events to the "key" function in the
// API below. The control m_iKeyMap will only match WM_KEYDOWN events because of the
// keydown bit I add, and STB_TEXTEDIT_KEYTOTEXT only tests for the KEYDOWN
// bit so it only decodes WM_CHAR events.
//
// STB_TEXTEDIT_LAYOUTROW returns information about the shape of one displayed
// row of characters assuming they start on the i'th character--the width and
// the height and the number of characters consumed. This allows this library
// to traverse the entire layout incrementally. You need to compute word-wrapping
// here.
//
// Each textfield keeps its own insert mode state, which is not how normal
// applications work. To keep an app-wide insert mode, update/copy the
// "insert_mode" field of STB_TexteditState before/after calling API functions.
//
// API
//
//    void stb_textedit_initialize_state(STB_TexteditState *state, int is_single_line)
//
//    void stb_textedit_click(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    void stb_textedit_drag(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, float x, float y)
//    int  stb_textedit_cut(STB_TEXTEDIT_STRING *str, STB_TexteditState *state)
//    int  stb_textedit_paste(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, STB_TEXTEDIT_CHARTYPE *text, int len)
//    void stb_textedit_key(STB_TEXTEDIT_STRING *str, STB_TexteditState *state, int key)
//
//    Each of these functions potentially updates the string and updates the
//    state.
//
//      initialize_state:
//          Set the textedit state to a known good default state when initially
//          constructing the textedit.
//
//      click:
//          call this with the mouse x,y on a mouse down; it will update the cursor
//          and reset the selection start/end to the cursor point. the x,y must
//          be relative to the text widget, with (0,0) being the top left.
//
//      drag:
//          call this with the mouse x,y on a mouse drag/up; it will update the
//          cursor and the selection end point
//
//      cut:
//          call this to delete the current selection; returns true if there was
//          one. you should FIRST copy the current selection to the system paste buffer.
//          (To copy, just copy the current selection out of the string yourself.)
//
//      paste:
//          call this to paste text at the current cursor point or over the current
//          selection if there is one.
//
//      key:
//          call this for keyboard inputs sent to the textfield. you can use it
//          for "key down" events or for "translated" key events. if you need to
//          do both (as in Win32), or distinguish Unicode characters from control
//          inputs, Set a high bit to distinguish the two; then you can define the
//          various definitions like STB_TEXTEDIT_K_LEFT have the is-key-event bit
//          Set, and make STB_TEXTEDIT_KEYTOCHAR check that the is-key-event bit is
//          clear.
//
//   When rendering, you can read the cursor position and selection state from
//   the STB_TexteditState.
//
//
// Notes:
//
// This is designed to be usable in IMGUI, so it allows for the possibility of
// running in an IMGUI that has NOT cached the multi-line layout. For this
// reason, it provides an interface that is compatible with computing the
// layout incrementally--we try to make sure we make as few passes through
// as possible. (For example, to locate the mouse pointer in the text, we
// could define functions that return the X and Y positions of characters
// and binary search Y and then X, but if we're doing dynamic layout this
// will run the layout algorithm many times, so instead we manually search
// forward in one pass. Similar logic applies to e.g. up-arrow and
// down-arrow movement.)
//
// If it's run in a widget that *has* cached the layout, then this is less
// efficient, but it's not horrible on modern computers. But you wouldn't
// want to edit million-line files with it.

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Header-file mode
////
////

#ifndef INCLUDE_STB_TEXTEDIT_H
#define INCLUDE_STB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////
//
//     STB_TexteditState
//
// Definition of STB_TexteditState which you should store
// per-textfield; it includes cursor position, selection state,
// and undo state.
//

#ifndef STB_TEXTEDIT_UNDOSTATECOUNT
#define STB_TEXTEDIT_UNDOSTATECOUNT   99
#endif
#ifndef STB_TEXTEDIT_UNDOCHARCOUNT
#define STB_TEXTEDIT_UNDOCHARCOUNT   999
#endif
#ifndef STB_TEXTEDIT_CHARTYPE
#define STB_TEXTEDIT_CHARTYPE        int
#endif
#ifndef STB_TEXTEDIT_POSITIONTYPE
#define STB_TEXTEDIT_POSITIONTYPE    int
#endif

typedef struct
{
	// private data
	STB_TEXTEDIT_POSITIONTYPE  where;
	short           insert_length;
	short           delete_length;
	short           char_storage;
} StbUndoRecord;

typedef struct
{
	// private data
	StbUndoRecord          undo_rec[STB_TEXTEDIT_UNDOSTATECOUNT];
	STB_TEXTEDIT_CHARTYPE  undo_char[STB_TEXTEDIT_UNDOCHARCOUNT];
	short undo_point, redo_point;
	short undo_char_point, redo_char_point;
} StbUndoState;

typedef struct
{
	/////////////////////
	//
	// public data
	//

	int cursor;
	// position of the text cursor within the string

	int select_start;          // selection start point
	int select_end;
	// selection start and end point in characters; if equal, no selection.
	// note that start may be less than or greater than end (e.g. when
	// dragging the mouse, start is where the initial click was, and you
	// can drag in either direction)

	unsigned char insert_mode;
	// each textfield keeps its own insert mode state. to keep an app-wide
	// insert mode, copy this value in/out of the app state

	/////////////////////
	//
	// private data
	//
	unsigned char cursor_at_end_of_line; // not implemented yet
	unsigned char initialized;
	unsigned char has_preferred_x;
	unsigned char single_line;
	unsigned char padding1, padding2, padding3;
	float preferred_x; // this determines where the cursor up/down tries to seek to along x
	StbUndoState undostate;
} STB_TexteditState;

////////////////////////////////////////////////////////////////////////
//
//     StbTexteditRow
//
// Result of layout query, used by stb_textedit to determine where
// the text in each row is.

// result of layout query
typedef struct
{
	float x0, x1;             // starting x location, end x location (allows for align=right, etc)
	float baseline_y_delta;  // position of baseline relative to previous row's baseline
	float ymin, ymax;         // height of row above and below baseline
	int num_chars;
} StbTexteditRow;
#endif //INCLUDE_STB_TEXTEDIT_H

////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////
////   Implementation mode
////
////

// implementation isn't include-guarded, since it might have indirectly
// included just the "header" portion
#ifdef STB_TEXTEDIT_IMPLEMENTATION

#ifndef STB_TEXTEDIT_memmove
#include <string.h>
#define STB_TEXTEDIT_memmove memmove
#endif

/////////////////////////////////////////////////////////////////////////////
//
//      Mouse input handling
//

// traverse the layout to locate the nearest character to a display position
static int stb_text_locate_coord(STB_TEXTEDIT_STRING* str, float x, float y)
{
	StbTexteditRow r;
	int n = STB_TEXTEDIT_STRINGLEN(str);
	float base_y = 0, prev_x;
	int i = 0, k;

	r.x0 = r.x1 = 0;
	r.ymin = r.ymax = 0;
	r.num_chars = 0;

	// search rows to GetOffset one that straddles 'y'
	while (i < n) {
		STB_TEXTEDIT_LAYOUTROW(&r, str, i);
		if (r.num_chars <= 0)
			return n;

		if (i == 0 && y < base_y + r.ymin)
			return 0;

		if (y < base_y + r.ymax)
			break;

		i += r.num_chars;
		base_y += r.baseline_y_delta;
	}

	// below all text, return 'after' last character
	if (i >= n)
		return n;

	// check if it's before the beginning of the line
	if (x < r.x0)
		return i;

	// check if it's before the end of the line
	if (x < r.x1) {
		// search characters in row for one that straddles 'x'
		prev_x = r.x0;
		for (k = 0; k < r.num_chars; ++k) {
			float w = STB_TEXTEDIT_GETWIDTH(str, i, k);
			if (x < prev_x + w) {
				if (x < prev_x + w / 2)
					return k + i;
				else
					return k + i + 1;
			}
			prev_x += w;
		}
		// shouldn't happen, but if it does, fall through to end-of-line case
	}

	// if the last character is a newline, return that. otherwise return 'after' the last character
	if (STB_TEXTEDIT_GETCHAR(str, i + r.num_chars - 1) == STB_TEXTEDIT_NEWLINE)
		return i + r.num_chars - 1;
	else
		return i + r.num_chars;
}

// API click: on mouse down, move the cursor to the clicked location, and reset the selection
static void stb_textedit_click(STB_TEXTEDIT_STRING* str, STB_TexteditState* state, float x, float y)
{
	state->cursor = stb_text_locate_coord(str, x, y);
	state->select_start = state->cursor;
	state->select_end = state->cursor;
	state->has_preferred_x = 0;
}

// API drag: on mouse drag, move the cursor and selection endpoint to the clicked location
static void stb_textedit_drag(STB_TEXTEDIT_STRING* str, STB_TexteditState* state, float x, float y)
{
	int p = stb_text_locate_coord(str, x, y);
	if (state->select_start == state->select_end)
		state->select_start = state->cursor;
	state->cursor = state->select_end = p;
}

/////////////////////////////////////////////////////////////////////////////
//
//      Keyboard input handling
//

// forward declarations
static void stb_text_undo(STB_TEXTEDIT_STRING* str, STB_TexteditState* state);
static void stb_text_redo(STB_TEXTEDIT_STRING* str, STB_TexteditState* state);
static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING* str, STB_TexteditState* state, int where, int length);
static void stb_text_makeundo_insert(STB_TexteditState* state, int where, int length);
static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING* str, STB_TexteditState* state, int where, int old_length, int new_length);

typedef struct
{
	float x, y;    // position of n'th character
	float height; // height of line
	int first_char, length; // first char of row, and length
	int prev_first;  // first char of previous row
} StbFindState;

// GetOffset the x/y location of a character, and remember info about the previous row in
// case we Get a move-up event (for page up, we'll have to rescan)
static void stb_textedit_find_charpos(StbFindState* GetOffset, STB_TEXTEDIT_STRING* str, int n, int single_line)
{
	StbTexteditRow r;
	int prev_start = 0;
	int z = STB_TEXTEDIT_STRINGLEN(str);
	int i = 0, first;

	if (n == z) {
		// if it's at the end, then GetOffset the last line -- simpler than trying to
		// explicitly handle this case in the regular code
		if (single_line) {
			STB_TEXTEDIT_LAYOUTROW(&r, str, 0);
			GetOffset->y = 0;
			GetOffset->first_char = 0;
			GetOffset->length = z;
			GetOffset->height = r.ymax - r.ymin;
			GetOffset->x = r.x1;
		}
		else {
			GetOffset->y = 0;
			GetOffset->x = 0;
			GetOffset->height = 1;
			while (i < z) {
				STB_TEXTEDIT_LAYOUTROW(&r, str, i);
				prev_start = i;
				i += r.num_chars;
			}
			GetOffset->first_char = i;
			GetOffset->length = 0;
			GetOffset->prev_first = prev_start;
		}
		return;
	}

	// search rows to GetOffset the one that straddles character n
	GetOffset->y = 0;

	for (;;) {
		STB_TEXTEDIT_LAYOUTROW(&r, str, i);
		if (n < i + r.num_chars)
			break;
		prev_start = i;
		i += r.num_chars;
		GetOffset->y += r.baseline_y_delta;
	}

	GetOffset->first_char = first = i;
	GetOffset->length = r.num_chars;
	GetOffset->height = r.ymax - r.ymin;
	GetOffset->prev_first = prev_start;

	// now scan to GetOffset xpos
	GetOffset->x = r.x0;
	i = 0;
	for (i = 0; first + i < n; ++i)
		GetOffset->x += STB_TEXTEDIT_GETWIDTH(str, first, i);
}

#define STB_TEXT_HAS_SELECTION(s)   ((s)->select_start != (s)->select_end)

// make the selection/cursor state valid if client altered the string
static void stb_textedit_clamp(STB_TEXTEDIT_STRING* str, STB_TexteditState* state)
{
	int n = STB_TEXTEDIT_STRINGLEN(str);
	if (STB_TEXT_HAS_SELECTION(state)) {
		if (state->select_start > n) state->select_start = n;
		if (state->select_end > n) state->select_end = n;
		// if clamping forced them to be equal, move the cursor to match
		if (state->select_start == state->select_end)
			state->cursor = state->select_start;
	}
	if (state->cursor > n) state->cursor = n;
}

// delete characters while updating undo
static void stb_textedit_delete(STB_TEXTEDIT_STRING* str, STB_TexteditState* state, int where, int len)
{
	stb_text_makeundo_delete(str, state, where, len);
	STB_TEXTEDIT_DELETECHARS(str, where, len);
	state->has_preferred_x = 0;
}

// delete the section
static void stb_textedit_delete_selection(STB_TEXTEDIT_STRING* str, STB_TexteditState* state)
{
	stb_textedit_clamp(str, state);
	if (STB_TEXT_HAS_SELECTION(state)) {
		if (state->select_start < state->select_end) {
			stb_textedit_delete(str, state, state->select_start, state->select_end - state->select_start);
			state->select_end = state->cursor = state->select_start;
		}
		else {
			stb_textedit_delete(str, state, state->select_end, state->select_start - state->select_end);
			state->select_start = state->cursor = state->select_end;
		}
		state->has_preferred_x = 0;
	}
}

// canoncialize the selection so start <= end
static void stb_textedit_sortselection(STB_TexteditState* state)
{
	if (state->select_end < state->select_start) {
		int temp = state->select_end;
		state->select_end = state->select_start;
		state->select_start = temp;
	}
}

// move cursor to first character of selection
static void stb_textedit_move_to_first(STB_TexteditState* state)
{
	if (STB_TEXT_HAS_SELECTION(state)) {
		stb_textedit_sortselection(state);
		state->cursor = state->select_start;
		state->select_end = state->select_start;
		state->has_preferred_x = 0;
	}
}

// move cursor to last character of selection
static void stb_textedit_move_to_last(STB_TEXTEDIT_STRING* str, STB_TexteditState* state)
{
	if (STB_TEXT_HAS_SELECTION(state)) {
		stb_textedit_sortselection(state);
		stb_textedit_clamp(str, state);
		state->cursor = state->select_end;
		state->select_start = state->select_end;
		state->has_preferred_x = 0;
	}
}

#ifdef STB_TEXTEDIT_IS_SPACE
static int is_word_boundary(STB_TEXTEDIT_STRING* str, int idx)
{
	return idx > 0 ? (STB_TEXTEDIT_IS_SPACE(STB_TEXTEDIT_GETCHAR(str, idx - 1)) && !STB_TEXTEDIT_IS_SPACE(STB_TEXTEDIT_GETCHAR(str, idx))) : 1;
}

#ifndef STB_TEXTEDIT_MOVEWORDLEFT
static int stb_textedit_move_to_word_previous(STB_TEXTEDIT_STRING* str, int c)
{
	--c; // always move at least one character
	while (c >= 0 && !is_word_boundary(str, c))
		--c;

	if (c < 0)
		c = 0;

	return c;
}
#define STB_TEXTEDIT_MOVEWORDLEFT stb_textedit_move_to_word_previous
#endif

#ifndef STB_TEXTEDIT_MOVEWORDRIGHT
static int stb_textedit_move_to_word_next(STB_TEXTEDIT_STRING* str, int c)
{
	const int len = STB_TEXTEDIT_STRINGLEN(str);
	++c; // always move at least one character
	while (c < len && !is_word_boundary(str, c))
		++c;

	if (c > len)
		c = len;

	return c;
}
#define STB_TEXTEDIT_MOVEWORDRIGHT stb_textedit_move_to_word_next
#endif

#endif

// update selection and cursor to match each other
static void stb_textedit_prep_selection_at_cursor(STB_TexteditState* state)
{
	if (!STB_TEXT_HAS_SELECTION(state))
		state->select_start = state->select_end = state->cursor;
	else
		state->cursor = state->select_end;
}

// API cut: delete selection
static int stb_textedit_cut(STB_TEXTEDIT_STRING* str, STB_TexteditState* state)
{
	if (STB_TEXT_HAS_SELECTION(state)) {
		stb_textedit_delete_selection(str, state); // implicity clamps
		state->has_preferred_x = 0;
		return 1;
	}
	return 0;
}

// API paste: replace existing selection with passed-in text
static int stb_textedit_paste(STB_TEXTEDIT_STRING* str, STB_TexteditState* state, STB_TEXTEDIT_CHARTYPE const* ctext, int len)
{
	STB_TEXTEDIT_CHARTYPE* text = (STB_TEXTEDIT_CHARTYPE*)ctext;
	// if there's a selection, the paste should delete it
	stb_textedit_clamp(str, state);
	stb_textedit_delete_selection(str, state);
	// try to insert the characters
	if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, text, len)) {
		stb_text_makeundo_insert(state, state->cursor, len);
		state->cursor += len;
		state->has_preferred_x = 0;
		return 1;
	}
	// remove the undo since we didn't actually insert the characters
	if (state->undostate.undo_point)
		--state->undostate.undo_point;
	return 0;
}

// API key: process a keyboard input
static void stb_textedit_key(STB_TEXTEDIT_STRING* str, STB_TexteditState* state, int key)
{
retry:
	switch (key) {
	default: {
		int c = STB_TEXTEDIT_KEYTOTEXT(key);
		if (c > 0) {
			STB_TEXTEDIT_CHARTYPE ch = (STB_TEXTEDIT_CHARTYPE)c;

			// can't add newline in single-line mode
			if (c == '\n' && state->single_line)
				break;

			if (state->insert_mode && !STB_TEXT_HAS_SELECTION(state) && state->cursor < STB_TEXTEDIT_STRINGLEN(str)) {
				stb_text_makeundo_replace(str, state, state->cursor, 1, 1);
				STB_TEXTEDIT_DELETECHARS(str, state->cursor, 1);
				if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
					++state->cursor;
					state->has_preferred_x = 0;
				}
			}
			else {
				stb_textedit_delete_selection(str, state); // implicity clamps
				if (STB_TEXTEDIT_INSERTCHARS(str, state->cursor, &ch, 1)) {
					stb_text_makeundo_insert(state, state->cursor, 1);
					++state->cursor;
					state->has_preferred_x = 0;
				}
			}
		}
		break;
	}

#ifdef STB_TEXTEDIT_K_INSERT
	case STB_TEXTEDIT_K_INSERT:
		state->insert_mode = !state->insert_mode;
		break;
#endif

	case STB_TEXTEDIT_K_UNDO:
		stb_text_undo(str, state);
		state->has_preferred_x = 0;
		break;

	case STB_TEXTEDIT_K_REDO:
		stb_text_redo(str, state);
		state->has_preferred_x = 0;
		break;

	case STB_TEXTEDIT_K_LEFT:
		// if currently there's a selection, move cursor to start of selection
		if (STB_TEXT_HAS_SELECTION(state))
			stb_textedit_move_to_first(state);
		else
			if (state->cursor > 0)
				--state->cursor;
		state->has_preferred_x = 0;
		break;

	case STB_TEXTEDIT_K_RIGHT:
		// if currently there's a selection, move cursor to end of selection
		if (STB_TEXT_HAS_SELECTION(state))
			stb_textedit_move_to_last(str, state);
		else
			++state->cursor;
		stb_textedit_clamp(str, state);
		state->has_preferred_x = 0;
		break;

	case STB_TEXTEDIT_K_LEFT | STB_TEXTEDIT_K_SHIFT:
		stb_textedit_clamp(str, state);
		stb_textedit_prep_selection_at_cursor(state);
		// move selection left
		if (state->select_end > 0)
			--state->select_end;
		state->cursor = state->select_end;
		state->has_preferred_x = 0;
		break;

#ifdef STB_TEXTEDIT_MOVEWORDLEFT
	case STB_TEXTEDIT_K_WORDLEFT:
		if (STB_TEXT_HAS_SELECTION(state))
			stb_textedit_move_to_first(state);
		else {
			state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
			stb_textedit_clamp(str, state);
		}
		break;

	case STB_TEXTEDIT_K_WORDLEFT | STB_TEXTEDIT_K_SHIFT:
		if (!STB_TEXT_HAS_SELECTION(state))
			stb_textedit_prep_selection_at_cursor(state);

		state->cursor = STB_TEXTEDIT_MOVEWORDLEFT(str, state->cursor);
		state->select_end = state->cursor;

		stb_textedit_clamp(str, state);
		break;
#endif

#ifdef STB_TEXTEDIT_MOVEWORDRIGHT
	case STB_TEXTEDIT_K_WORDRIGHT:
		if (STB_TEXT_HAS_SELECTION(state))
			stb_textedit_move_to_last(str, state);
		else {
			state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
			stb_textedit_clamp(str, state);
		}
		break;

	case STB_TEXTEDIT_K_WORDRIGHT | STB_TEXTEDIT_K_SHIFT:
		if (!STB_TEXT_HAS_SELECTION(state))
			stb_textedit_prep_selection_at_cursor(state);

		state->cursor = STB_TEXTEDIT_MOVEWORDRIGHT(str, state->cursor);
		state->select_end = state->cursor;

		stb_textedit_clamp(str, state);
		break;
#endif

	case STB_TEXTEDIT_K_RIGHT | STB_TEXTEDIT_K_SHIFT:
		stb_textedit_prep_selection_at_cursor(state);
		// move selection right
		++state->select_end;
		stb_textedit_clamp(str, state);
		state->cursor = state->select_end;
		state->has_preferred_x = 0;
		break;

	case STB_TEXTEDIT_K_DOWN:
	case STB_TEXTEDIT_K_DOWN | STB_TEXTEDIT_K_SHIFT: {
		StbFindState GetOffset;
		StbTexteditRow row;
		int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

		if (state->single_line) {
			// on windows, up&down in single-line behave like left&right
			key = STB_TEXTEDIT_K_RIGHT | (key & STB_TEXTEDIT_K_SHIFT);
			goto retry;
		}

		if (sel)
			stb_textedit_prep_selection_at_cursor(state);
		else if (STB_TEXT_HAS_SELECTION(state))
			stb_textedit_move_to_last(str, state);

		// compute current position of cursor point
		stb_textedit_clamp(str, state);
		stb_textedit_find_charpos(&GetOffset, str, state->cursor, state->single_line);

		// now GetOffset character position down a row
		if (GetOffset.length) {
			float goal_x = state->has_preferred_x ? state->preferred_x : GetOffset.x;
			float x;
			int start = GetOffset.first_char + GetOffset.length;
			state->cursor = start;
			STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
			x = row.x0;
			for (i = 0; i < row.num_chars; ++i) {
				float dx = STB_TEXTEDIT_GETWIDTH(str, start, i);
#ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
				if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
					break;
#endif
				x += dx;
				if (x > goal_x)
					break;
				++state->cursor;
			}
			stb_textedit_clamp(str, state);

			state->has_preferred_x = 1;
			state->preferred_x = goal_x;

			if (sel)
				state->select_end = state->cursor;
		}
		break;
	}

	case STB_TEXTEDIT_K_UP:
	case STB_TEXTEDIT_K_UP | STB_TEXTEDIT_K_SHIFT: {
		StbFindState GetOffset;
		StbTexteditRow row;
		int i, sel = (key & STB_TEXTEDIT_K_SHIFT) != 0;

		if (state->single_line) {
			// on windows, up&down become left&right
			key = STB_TEXTEDIT_K_LEFT | (key & STB_TEXTEDIT_K_SHIFT);
			goto retry;
		}

		if (sel)
			stb_textedit_prep_selection_at_cursor(state);
		else if (STB_TEXT_HAS_SELECTION(state))
			stb_textedit_move_to_first(state);

		// compute current position of cursor point
		stb_textedit_clamp(str, state);
		stb_textedit_find_charpos(&GetOffset, str, state->cursor, state->single_line);

		// can only go up if there's a previous row
		if (GetOffset.prev_first != GetOffset.first_char) {
			// now GetOffset character position up a row
			float goal_x = state->has_preferred_x ? state->preferred_x : GetOffset.x;
			float x;
			state->cursor = GetOffset.prev_first;
			STB_TEXTEDIT_LAYOUTROW(&row, str, state->cursor);
			x = row.x0;
			for (i = 0; i < row.num_chars; ++i) {
				float dx = STB_TEXTEDIT_GETWIDTH(str, GetOffset.prev_first, i);
#ifdef STB_TEXTEDIT_GETWIDTH_NEWLINE
				if (dx == STB_TEXTEDIT_GETWIDTH_NEWLINE)
					break;
#endif
				x += dx;
				if (x > goal_x)
					break;
				++state->cursor;
			}
			stb_textedit_clamp(str, state);

			state->has_preferred_x = 1;
			state->preferred_x = goal_x;

			if (sel)
				state->select_end = state->cursor;
		}
		break;
	}

	case STB_TEXTEDIT_K_DELETE:
	case STB_TEXTEDIT_K_DELETE | STB_TEXTEDIT_K_SHIFT:
		if (STB_TEXT_HAS_SELECTION(state))
			stb_textedit_delete_selection(str, state);
		else {
			int n = STB_TEXTEDIT_STRINGLEN(str);
			if (state->cursor < n)
				stb_textedit_delete(str, state, state->cursor, 1);
		}
		state->has_preferred_x = 0;
		break;

	case STB_TEXTEDIT_K_BACKSPACE:
	case STB_TEXTEDIT_K_BACKSPACE | STB_TEXTEDIT_K_SHIFT:
		if (STB_TEXT_HAS_SELECTION(state))
			stb_textedit_delete_selection(str, state);
		else {
			stb_textedit_clamp(str, state);
			if (state->cursor > 0) {
				stb_textedit_delete(str, state, state->cursor - 1, 1);
				--state->cursor;
			}
		}
		state->has_preferred_x = 0;
		break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
	case STB_TEXTEDIT_K_TEXTSTART2:
#endif
	case STB_TEXTEDIT_K_TEXTSTART:
		state->cursor = state->select_start = state->select_end = 0;
		state->has_preferred_x = 0;
		break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
	case STB_TEXTEDIT_K_TEXTEND2:
#endif
	case STB_TEXTEDIT_K_TEXTEND:
		state->cursor = STB_TEXTEDIT_STRINGLEN(str);
		state->select_start = state->select_end = 0;
		state->has_preferred_x = 0;
		break;

#ifdef STB_TEXTEDIT_K_TEXTSTART2
	case STB_TEXTEDIT_K_TEXTSTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
	case STB_TEXTEDIT_K_TEXTSTART | STB_TEXTEDIT_K_SHIFT:
		stb_textedit_prep_selection_at_cursor(state);
		state->cursor = state->select_end = 0;
		state->has_preferred_x = 0;
		break;

#ifdef STB_TEXTEDIT_K_TEXTEND2
	case STB_TEXTEDIT_K_TEXTEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
	case STB_TEXTEDIT_K_TEXTEND | STB_TEXTEDIT_K_SHIFT:
		stb_textedit_prep_selection_at_cursor(state);
		state->cursor = state->select_end = STB_TEXTEDIT_STRINGLEN(str);
		state->has_preferred_x = 0;
		break;

#ifdef STB_TEXTEDIT_K_LINESTART2
	case STB_TEXTEDIT_K_LINESTART2:
#endif
	case STB_TEXTEDIT_K_LINESTART:
		stb_textedit_clamp(str, state);
		stb_textedit_move_to_first(state);
		if (state->single_line)
			state->cursor = 0;
		else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor - 1) != STB_TEXTEDIT_NEWLINE)
			--state->cursor;
		state->has_preferred_x = 0;
		break;

#ifdef STB_TEXTEDIT_K_LINEEND2
	case STB_TEXTEDIT_K_LINEEND2:
#endif
	case STB_TEXTEDIT_K_LINEEND: {
		int n = STB_TEXTEDIT_STRINGLEN(str);
		stb_textedit_clamp(str, state);
		stb_textedit_move_to_first(state);
		if (state->single_line)
			state->cursor = n;
		else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
			++state->cursor;
		state->has_preferred_x = 0;
		break;
	}

#ifdef STB_TEXTEDIT_K_LINESTART2
	case STB_TEXTEDIT_K_LINESTART2 | STB_TEXTEDIT_K_SHIFT:
#endif
	case STB_TEXTEDIT_K_LINESTART | STB_TEXTEDIT_K_SHIFT:
		stb_textedit_clamp(str, state);
		stb_textedit_prep_selection_at_cursor(state);
		if (state->single_line)
			state->cursor = 0;
		else while (state->cursor > 0 && STB_TEXTEDIT_GETCHAR(str, state->cursor - 1) != STB_TEXTEDIT_NEWLINE)
			--state->cursor;
		state->select_end = state->cursor;
		state->has_preferred_x = 0;
		break;

#ifdef STB_TEXTEDIT_K_LINEEND2
	case STB_TEXTEDIT_K_LINEEND2 | STB_TEXTEDIT_K_SHIFT:
#endif
	case STB_TEXTEDIT_K_LINEEND | STB_TEXTEDIT_K_SHIFT: {
		int n = STB_TEXTEDIT_STRINGLEN(str);
		stb_textedit_clamp(str, state);
		stb_textedit_prep_selection_at_cursor(state);
		if (state->single_line)
			state->cursor = n;
		else while (state->cursor < n && STB_TEXTEDIT_GETCHAR(str, state->cursor) != STB_TEXTEDIT_NEWLINE)
			++state->cursor;
		state->select_end = state->cursor;
		state->has_preferred_x = 0;
		break;
	}

														// @TODO:
														//    STB_TEXTEDIT_K_PGUP      - move cursor up a page
														//    STB_TEXTEDIT_K_PGDOWN    - move cursor down a page
	}
}

/////////////////////////////////////////////////////////////////////////////
//
//      Undo processing
//
// @OPTIMIZE: the undo/redo buffer should be circular

static void stb_textedit_flush_redo(StbUndoState* state)
{
	state->redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
	state->redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
}

// discard the oldest entry in the undo list
static void stb_textedit_discard_undo(StbUndoState* state)
{
	if (state->undo_point > 0) {
		// if the 0th undo state has characters, clean those up
		if (state->undo_rec[0].char_storage >= 0) {
			int n = state->undo_rec[0].insert_length, i;
			// delete n characters from all other records
			state->undo_char_point = state->undo_char_point - (short)n;  // vsnet05
			STB_TEXTEDIT_memmove(state->undo_char, state->undo_char + n, (size_t)((size_t)state->undo_char_point * sizeof(STB_TEXTEDIT_CHARTYPE)));
			for (i = 0; i < state->undo_point; ++i)
				if (state->undo_rec[i].char_storage >= 0)
					state->undo_rec[i].char_storage = state->undo_rec[i].char_storage - (short)n; // vsnet05 // @OPTIMIZE: Get rid of char_storage and infer it
		}
		--state->undo_point;
		STB_TEXTEDIT_memmove(state->undo_rec, state->undo_rec + 1, (size_t)((size_t)state->undo_point * sizeof(state->undo_rec[0])));
	}
}

// discard the oldest entry in the redo list--it's bad if this
// ever happens, but because undo & redo have to store the actual
// characters in different cases, the redo character buffer can
// fill up even though the undo buffer didn't
static void stb_textedit_discard_redo(StbUndoState* state)
{
	int k = STB_TEXTEDIT_UNDOSTATECOUNT - 1;

	if (state->redo_point <= k) {
		// if the k'th undo state has characters, clean those up
		if (state->undo_rec[k].char_storage >= 0) {
			int n = state->undo_rec[k].insert_length, i;
			// delete n characters from all other records
			state->redo_char_point = state->redo_char_point + (short)n; // vsnet05
			STB_TEXTEDIT_memmove(state->undo_char + state->redo_char_point, state->undo_char + state->redo_char_point - n, (size_t)((size_t)(STB_TEXTEDIT_UNDOCHARCOUNT - state->redo_char_point) * sizeof(STB_TEXTEDIT_CHARTYPE)));
			for (i = state->redo_point; i < k; ++i)
				if (state->undo_rec[i].char_storage >= 0)
					state->undo_rec[i].char_storage = state->undo_rec[i].char_storage + (short)n; // vsnet05
		}
		STB_TEXTEDIT_memmove(state->undo_rec + state->redo_point, state->undo_rec + state->redo_point - 1, (size_t)((size_t)(STB_TEXTEDIT_UNDOSTATECOUNT - state->redo_point) * sizeof(state->undo_rec[0])));
		++state->redo_point;
	}
}

static StbUndoRecord* stb_text_create_undo_record(StbUndoState* state, int numchars)
{
	// any time we create a new undo record, we discard redo
	stb_textedit_flush_redo(state);

	// if we have no free records, we have to make room, by sliding the
	// existing records down
	if (state->undo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
		stb_textedit_discard_undo(state);

	// if the characters to store won't possibly fit in the buffer, we can't undo
	if (numchars > STB_TEXTEDIT_UNDOCHARCOUNT) {
		state->undo_point = 0;
		state->undo_char_point = 0;
		return NULL;
	}

	// if we don't have enough free characters in the buffer, we have to make room
	while (state->undo_char_point + numchars > STB_TEXTEDIT_UNDOCHARCOUNT)
		stb_textedit_discard_undo(state);

	return &state->undo_rec[state->undo_point++];
}

static STB_TEXTEDIT_CHARTYPE* stb_text_createundo(StbUndoState* state, int pos, int insert_len, int delete_len)
{
	StbUndoRecord* r = stb_text_create_undo_record(state, insert_len);
	if (r == NULL)
		return NULL;

	r->where = pos;
	r->insert_length = (short)insert_len;
	r->delete_length = (short)delete_len;

	if (insert_len == 0) {
		r->char_storage = -1;
		return NULL;
	}
	else {
		r->char_storage = state->undo_char_point;
		state->undo_char_point = state->undo_char_point + (short)insert_len;
		return &state->undo_char[r->char_storage];
	}
}

static void stb_text_undo(STB_TEXTEDIT_STRING* str, STB_TexteditState* state)
{
	StbUndoState* s = &state->undostate;
	StbUndoRecord u, * r;
	if (s->undo_point == 0)
		return;

	// we need to do two things: apply the undo record, and create a redo record
	u = s->undo_rec[s->undo_point - 1];
	r = &s->undo_rec[s->redo_point - 1];
	r->char_storage = -1;

	r->insert_length = u.delete_length;
	r->delete_length = u.insert_length;
	r->where = u.where;

	if (u.delete_length) {
		// if the undo record says to delete characters, then the redo record will
		// need to re-insert the characters that Get deleted, so we need to store
		// them.

		// there are three cases:
		//    there's enough room to store the characters
		//    characters stored for *redoing* don't leave room for redo
		//    characters stored for *undoing* don't leave room for redo
		// if the last is true, we have to bail

		if (s->undo_char_point + u.delete_length >= STB_TEXTEDIT_UNDOCHARCOUNT) {
			// the undo records take up too much character space; there's no space to store the redo characters
			r->insert_length = 0;
		}
		else {
			int i;

			// there's definitely room to store the characters eventually
			while (s->undo_char_point + u.delete_length > s->redo_char_point) {
				// there's currently not enough room, so discard a redo record
				stb_textedit_discard_redo(s);
				// should never happen:
				if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
					return;
			}
			r = &s->undo_rec[s->redo_point - 1];

			r->char_storage = s->redo_char_point - u.delete_length;
			s->redo_char_point = s->redo_char_point - (short)u.delete_length;

			// now save the characters
			for (i = 0; i < u.delete_length; ++i)
				s->undo_char[r->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u.where + i);
		}

		// now we can carry out the deletion
		STB_TEXTEDIT_DELETECHARS(str, u.where, u.delete_length);
	}

	// check type of recorded action:
	if (u.insert_length) {
		// easy case: was a deletion, so we need to insert n characters
		STB_TEXTEDIT_INSERTCHARS(str, u.where, &s->undo_char[u.char_storage], u.insert_length);
		s->undo_char_point -= u.insert_length;
	}

	state->cursor = u.where + u.insert_length;

	s->undo_point--;
	s->redo_point--;
}

static void stb_text_redo(STB_TEXTEDIT_STRING* str, STB_TexteditState* state)
{
	StbUndoState* s = &state->undostate;
	StbUndoRecord* u, r;
	if (s->redo_point == STB_TEXTEDIT_UNDOSTATECOUNT)
		return;

	// we need to do two things: apply the redo record, and create an undo record
	u = &s->undo_rec[s->undo_point];
	r = s->undo_rec[s->redo_point];

	// we KNOW there must be room for the undo record, because the redo record
	// was derived from an undo record

	u->delete_length = r.insert_length;
	u->insert_length = r.delete_length;
	u->where = r.where;
	u->char_storage = -1;

	if (r.delete_length) {
		// the redo record requires us to delete characters, so the undo record
		// needs to store the characters

		if (s->undo_char_point + u->insert_length > s->redo_char_point) {
			u->insert_length = 0;
			u->delete_length = 0;
		}
		else {
			int i;
			u->char_storage = s->undo_char_point;
			s->undo_char_point = s->undo_char_point + u->insert_length;

			// now save the characters
			for (i = 0; i < u->insert_length; ++i)
				s->undo_char[u->char_storage + i] = STB_TEXTEDIT_GETCHAR(str, u->where + i);
		}

		STB_TEXTEDIT_DELETECHARS(str, r.where, r.delete_length);
	}

	if (r.insert_length) {
		// easy case: need to insert n characters
		STB_TEXTEDIT_INSERTCHARS(str, r.where, &s->undo_char[r.char_storage], r.insert_length);
		s->redo_char_point += r.insert_length;
	}

	state->cursor = r.where + r.insert_length;

	s->undo_point++;
	s->redo_point++;
}

static void stb_text_makeundo_insert(STB_TexteditState* state, int where, int length)
{
	stb_text_createundo(&state->undostate, where, 0, length);
}

static void stb_text_makeundo_delete(STB_TEXTEDIT_STRING* str, STB_TexteditState* state, int where, int length)
{
	int i;
	STB_TEXTEDIT_CHARTYPE* p = stb_text_createundo(&state->undostate, where, length, 0);
	if (p) {
		for (i = 0; i < length; ++i)
			p[i] = STB_TEXTEDIT_GETCHAR(str, where + i);
	}
}

static void stb_text_makeundo_replace(STB_TEXTEDIT_STRING* str, STB_TexteditState* state, int where, int old_length, int new_length)
{
	int i;
	STB_TEXTEDIT_CHARTYPE* p = stb_text_createundo(&state->undostate, where, old_length, new_length);
	if (p) {
		for (i = 0; i < old_length; ++i)
			p[i] = STB_TEXTEDIT_GETCHAR(str, where + i);
	}
}

// reset the state to default
static void stb_textedit_clear_state(STB_TexteditState* state, int is_single_line)
{
	state->undostate.undo_point = 0;
	state->undostate.undo_char_point = 0;
	state->undostate.redo_point = STB_TEXTEDIT_UNDOSTATECOUNT;
	state->undostate.redo_char_point = STB_TEXTEDIT_UNDOCHARCOUNT;
	state->select_end = state->select_start = 0;
	state->cursor = 0;
	state->has_preferred_x = 0;
	state->preferred_x = 0;
	state->cursor_at_end_of_line = 0;
	state->initialized = 1;
	state->single_line = (unsigned char)is_single_line;
	state->insert_mode = 0;
}

// API Initialize
static void stb_textedit_initialize_state(STB_TexteditState* state, int is_single_line)
{
	stb_textedit_clear_state(state, is_single_line);
}
#endif//STB_TEXTEDIT_IMPLEMENTATION

```

`src/imgui/stb_truetype.h`:

```h
// stb_truetype.h - v1.14 - public domain
// authored from 2009-2016 by Sean Barrett / RAD Game Tools
//
//   This library processes TrueType files:
//        parse files
//        extract glyph metrics
//        extract glyph shapes
//        Render glyphs to one-channel bitmaps with antialiasing (box filter)
//
//   Todo:
//        non-MS cmaps
//        crashproof on bad data
//        hinting? (no longer patented)
//        cleartype-style AA?
//        optimize: use simple memory allocator for intermediates
//        optimize: build edge-list directly from curves
//        optimize: rasterize directly from curves?
//
// ADDITIONAL CONTRIBUTORS
//
//   Mikko Mononen: compound shape support, more cmap formats
//   Tor Andersson: kerning, subpixel rendering
//   Dougall Johnson: OpenType / Type 2 font handling
//
//   Misc other:
//       Ryan Gordon
//       Simon Glass
//       github:IntellectualKitty
//
//   Bug/warning reports/fixes:
//       "Zer" on mollyrocket (with fix)
//       Cass Everitt
//       stoiko (Haemimont Games)
//       Brian Hook
//       Walter van Niftrik
//       David Gow
//       David Given
//       Ivan-Assen Ivanov
//       Anthony Pesch
//       Johan Duparc
//       Hou Qiming
//       Fabian "ryg" Giesen
//       Martins Mozeiko
//       Cap Petschulat
//       Omar Cornut
//       github:aloucks
//       Peter LaValle
//       Sergey Popov
//       Giumo X. Clanjor
//       Higor Euripedes
//       Thomas Fields
//       Derek Vinyard
//
// VERSION HISTORY
//
//   1.13 (2017-01-02) support OpenType fonts, certain Apple fonts, num-fonts-in-TTC function
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) user-defined fabs(); rare memory leak; remove duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use allocation userdata properly
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     variant PackFontRanges to pack and Render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//
//   Full history can be found at the end of this file.
//
// LICENSE
//
//   This software is dual-licensed to the public domain and under the following
//   license: you are granted a perpetual, irrevocable license to copy, modify,
//   publish, and distribute this file as you see fit.
//
// USAGE
//
//   Include this file in whatever places neeed to refer to it. In ONE C/C++
//   file, write:
//      #define STB_TRUETYPE_IMPLEMENTATION
//   before the #include of this file. This expands out the actual
//   implementation into that C/C++ file.
//
//   To make the implementation private to the file that generates the implementation,
//      #define STBTT_STATIC
//
//   Simple 3D API (don't ship this, but it's fine for tools and quick start)
//           stbtt_BakeFontBitmap()               -- bake a font to a bitmap for use as texture
//           stbtt_GetBakedQuad()                 -- compute quad to draw for a given char
//
//   Improved 3D API (more shippable):
//           #include "stb_rect_pack.h"           -- optional, but you really want it
//           stbtt_PackBegin()
//           stbtt_PackSetOversample()            -- for improved quality on small fonts
//           stbtt_PackFontRanges()               -- pack and renders
//           stbtt_PackEnd()
//           stbtt_GetPackedQuad()
//
//   "Load" a font file from a memory buffer (you have to keep the buffer loaded)
//           stbtt_InitFont()
//           stbtt_GetFontOffsetForIndex()        -- indexing for TTC font collections
//           stbtt_GetNumberOfFonts()             -- number of fonts for TTC font collections
//
//   Render a unicode codepoint to a bitmap
//           stbtt_GetCodepointBitmap()           -- allocates and returns a bitmap
//           stbtt_MakeCodepointBitmap()          -- renders into bitmap you provide
//           stbtt_GetCodepointBitmapBox()        -- how big the bitmap must be
//
//   Character advance/positioning
//           stbtt_GetCodepointHMetrics()
//           stbtt_GetFontVMetrics()
//           stbtt_GetCodepointKernAdvance()
//
//   Starting with version 1.06, the rasterizer was replaced with a new,
//   faster and generally-more-precise rasterizer. The new rasterizer more
//   accurately measures pixel coverage for anti-aliasing, except in the case
//   where multiple shapes overlap, in which case it overestimates the AA pixel
//   coverage. Thus, anti-aliasing of intersecting shapes may look wrong. If
//   this turns out to be a problem, you can re-enable the old rasterizer with
//        #define STBTT_RASTERIZER_VERSION 1
//   which will incur about a 15% speed hit.
//
// ADDITIONAL DOCUMENTATION
//
//   Immediately after this block comment are a series of sample programs.
//
//   After the sample programs is the "header file" section. This section
//   includes documentation for each API function.
//
//   Some important concepts to understand to use this library:
//
//      Codepoint
//         Characters are defined by unicode codepoints, e.g. 65 is
//         uppercase A, 231 is lowercase c with a cedilla, 0x7e30 is
//         the hiragana for "ma".
//
//      Glyph
//         A visual character shape (every codepoint is rendered as
//         some glyph)
//
//      Glyph index
//         A font-specific integer ID representing a glyph
//
//      Baseline
//         Glyph shapes are defined relative to a baseline, which is the
//         bottom of uppercase characters. Characters extend both above
//         and below the baseline.
//
//      Current Point
//         As you draw text to the screen, you keep track of a "current point"
//         which is the origin of each character. The current point's vertical
//         position is the baseline. Even "baked fonts" use this model.
//
//      Vertical Font Metrics
//         The vertical qualities of the font, used to vertically position
//         and space the characters. See docs for stbtt_GetFontVMetrics.
//
//      Font Size in Pixels or Points
//         The preferred interface for specifying font sizes in stb_truetype
//         is to specify how tall the font's vertical extent should be in pixels.
//         If that sounds good enough, skip the next paragraph.
//
//         Most font APIs instead use "points", which are a common typographic
//         measurement for describing font size, defined as 72 points per inch.
//         stb_truetype provides a point API for compatibility. However, true
//         "per inch" conventions don't make much sense on computer displays
//         since they different monitors have different number of pixels per
//         inch. For example, Windows traditionally uses a convention that
//         there are 96 pixels per inch, thus making 'inch' measurements have
//         nothing to do with inches, and thus effectively defining a point to
//         be 1.333 pixels. Additionally, the TrueType font data provides
//         an explicit scale factor to scale a given font's glyphs to points,
//         but the author has observed that this scale factor is often wrong
//         for non-commercial fonts, thus making fonts scaled in points
//         according to the TrueType spec incoherently sized in practice.
//
// ADVANCED USAGE
//
//   Quality:
//
//    - Use the functions with Subpixel at the end to allow your characters
//      to have subpixel positioning. Since the font is anti-aliased, not
//      hinted, this is very import for quality. (This is not possible with
//      baked fonts.)
//
//    - Kerning is now supported, and if you're supporting subpixel rendering
//      then kerning is worth using to give your text a polished look.
//
//   Performance:
//
//    - Convert Unicode codepoints to glyph indexes and operate on the glyphs;
//      if you don't do this, stb_truetype is forced to do the conversion on
//      every call.
//
//    - There are a lot of memory allocations. We should modify it to take
//      a temp buffer and allocate from the temp buffer (without freeing),
//      should help performance a lot.
//
// NOTES
//
//   The system uses the raw data found in the .ttf file without changing it
//   and without building auxiliary data structures. This is a bit inefficient
//   on little-endian systems (the data is big-endian), but assuming you're
//   caching the bitmaps or glyph shapes this shouldn't be a big deal.
//
//   It appears to be very hard to programmatically determine what font a
//   given file is in a general way. I provide an API for this, but I don't
//   recommend it.
//
//
// SOURCE STATISTICS (based on v0.6c, 2050 LOC)
//
//   Documentation & header file        520 LOC  \___ 660 LOC documentation
//   Sample code                        140 LOC  /
//   Truetype parsing                   620 LOC  ---- 620 LOC TrueType
//   Software rasterization             240 LOC  \                           .
//   Curve tesselation                  120 LOC   \__ 550 LOC Bitmap creation
//   Bitmap management                  100 LOC   /
//   Baked bitmap interface              70 LOC  /
//   Font name matching & access        150 LOC  ---- 150
//   C runtime library abstraction       60 LOC  ----  60
//
//
// PERFORMANCE MEASUREMENTS FOR 1.06:
//
//                      32-bit     64-bit
//   Previous release:  8.83 s     7.68 s
//   Pool allocations:  7.72 s     6.34 s
//   Inline sort     :  6.54 s     5.65 s
//   New rasterizer  :  5.63 s     5.00 s

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////  SAMPLE PROGRAMS
////
//
//  Incomplete text-in-3d-api example, which draws quads properly aligned to be lossless
//
#if 0
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

unsigned char ttf_buffer[1 << 20];
unsigned char temp_bitmap[512 * 512];

stbtt_bakedchar cdata[96]; // ASCII 32..126 is 95 glyphs
GLuint ftex;

void my_stbtt_initfont(void)
{
	fread(ttf_buffer, 1, 1 << 20, fopen("c:/windows/fonts/times.ttf", "rb"));
	stbtt_BakeFontBitmap(ttf_buffer, 0, 32.0, temp_bitmap, 512, 512, 32, 96, cdata); // no guarantee this fits!
	// can free ttf_buffer at this point
	glGenTextures(1, &ftex);
	glBindTexture(GL_TEXTURE_2D, ftex);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, 512, 512, 0, GL_ALPHA, GL_UNSIGNED_BYTE, temp_bitmap);
	// can free temp_bitmap at this point
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
}

void my_stbtt_print(float x, float y, char* text)
{
	// assume orthographic projection with units = screen pixels, origin at top left
	glEnable(GL_TEXTURE_2D);
	glBindTexture(GL_TEXTURE_2D, ftex);
	glBegin(GL_QUADS);
	while (*text) {
		if (*text >= 32 && *text < 128) {
			stbtt_aligned_quad q;
			stbtt_GetBakedQuad(cdata, 512, 512, *text - 32, &x, &y, &q, 1);//1=opengl & d3d10+,0=d3d9
			glTexCoord2f(q.s0, q.t1); glVertex2f(q.x0, q.y0);
			glTexCoord2f(q.s1, q.t1); glVertex2f(q.x1, q.y0);
			glTexCoord2f(q.s1, q.t0); glVertex2f(q.x1, q.y1);
			glTexCoord2f(q.s0, q.t0); glVertex2f(q.x0, q.y1);
		}
		++text;
	}
	glEnd();
}
#endif
//
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program (this compiles): Get a single bitmap, print as ASCII art
//
#if 0
#include <stdio.h>
#define STB_TRUETYPE_IMPLEMENTATION  // force following include to generate implementation
#include "stb_truetype.h"

char ttf_buffer[1 << 25];

int main(int argc, char** argv)
{
	stbtt_fontinfo font;
	unsigned char* bitmap;
	int w, h, i, j, c = (argc > 1 ? atoi(argv[1]) : 'a'), s = (argc > 2 ? atoi(argv[2]) : 20);

	fread(ttf_buffer, 1, 1 << 25, fopen(argc > 3 ? argv[3] : "c:/windows/fonts/arialbd.ttf", "rb"));

	stbtt_InitFont(&font, ttf_buffer, stbtt_GetFontOffsetForIndex(ttf_buffer, 0));
	bitmap = stbtt_GetCodepointBitmap(&font, 0, stbtt_ScaleForPixelHeight(&font, s), c, &w, &h, 0, 0);

	for (j = 0; j < h; ++j) {
		for (i = 0; i < w; ++i)
			putchar(" .:ioVM@"[bitmap[j * w + i] >> 5]);
		putchar('\n');
	}
	return 0;
}
#endif
//
// Output:
//
//     .ii.
//    @@@@@@.
//   V@Mio@@o
//   :i.  V@V
//     :oM@@M
//   :@@@MM@M
//   @@o  o@M
//  :@@.  M@M
//   @@@o@@@@
//   :M@@V:@@.
//
//////////////////////////////////////////////////////////////////////////////
//
// Complete program: print "Hello World!" banner, with bugs
//
#if 0
char buffer[24 << 20];
unsigned char screen[20][79];

int main(int arg, char** argv)
{
	stbtt_fontinfo font;
	int i, j, ascent, baseline, ch = 0;
	float scale, xpos = 2; // leave a little padding in case the character extends left
	char* text = "Heljo World!"; // intentionally misspelled to Show 'lj' brokenness

	fread(buffer, 1, 1000000, fopen("c:/windows/fonts/arialbd.ttf", "rb"));
	stbtt_InitFont(&font, buffer, 0);

	scale = stbtt_ScaleForPixelHeight(&font, 15);
	stbtt_GetFontVMetrics(&font, &ascent, 0, 0);
	baseline = (int)(ascent * scale);

	while (text[ch]) {
		int advance, lsb, x0, y0, x1, y1;
		float x_shift = xpos - (float)floor(xpos);
		stbtt_GetCodepointHMetrics(&font, text[ch], &advance, &lsb);
		stbtt_GetCodepointBitmapBoxSubpixel(&font, text[ch], scale, scale, x_shift, 0, &x0, &y0, &x1, &y1);
		stbtt_MakeCodepointBitmapSubpixel(&font, &screen[baseline + y0][(int)xpos + x0], x1 - x0, y1 - y0, 79, scale, scale, x_shift, 0, text[ch]);
		// note that this stomps the old data, so where character boxes overlap (e.g. 'lj') it's wrong
		// because this API is really for baking character bitmaps into textures. if you want to Render
		// a sequence of characters, you really need to Render each bitmap to a temp buffer, then
		// "alpha blend" that into the working buffer
		xpos += (advance * scale);
		if (text[ch + 1])
			xpos += scale * stbtt_GetCodepointKernAdvance(&font, text[ch], text[ch + 1]);
		++ch;
	}

	for (j = 0; j < 20; ++j) {
		for (i = 0; i < 78; ++i)
			putchar(" .:ioVM@"[screen[j][i] >> 5]);
		putchar('\n');
	}

	return 0;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
////
////   INTEGRATION WITH YOUR CODEBASE
////
////   The following sections allow you to supply alternate definitions
////   of C library functions used by stb_truetype.

#ifdef STB_TRUETYPE_IMPLEMENTATION
   // #define your own (u)stbtt_int8/16/32 before including to override this
#ifndef stbtt_uint8
typedef unsigned char   stbtt_uint8;
typedef signed   char   stbtt_int8;
typedef unsigned short  stbtt_uint16;
typedef signed   short  stbtt_int16;
typedef unsigned int    stbtt_uint32;
typedef signed   int    stbtt_int32;
#endif

typedef char stbtt__check_size32[sizeof(stbtt_int32) == 4 ? 1 : -1];
typedef char stbtt__check_size16[sizeof(stbtt_int16) == 2 ? 1 : -1];

// #define your own STBTT_ifloor/STBTT_iceil() to avoid Math.h
#ifndef STBTT_ifloor
#include <Math.h>
#define STBTT_ifloor(x)   ((int) floor(x))
#define STBTT_iceil(x)    ((int) ceil(x))
#endif

#ifndef STBTT_sqrt
#include <Math.h>
#define STBTT_sqrt(x)      sqrt(x)
#endif

#ifndef STBTT_fabs
#include <Math.h>
#define STBTT_fabs(x)      fabs(x)
#endif

// #define your own functions "STBTT_malloc" / "STBTT_free" to avoid malloc.h
#ifndef STBTT_malloc
#include <stdlib.h>
#define STBTT_malloc(x,u)  ((void)(u),malloc(x))
#define STBTT_free(x,u)    ((void)(u),free(x))
#endif

#ifndef STBTT_assert
#include <assert.h>
#define STBTT_assert(x)    assert(x)
#endif

#ifndef STBTT_strlen
#include <string.h>
#define STBTT_strlen(x)    strlen(x)
#endif

#ifndef STBTT_memcpy
#include <memory.h>
#define STBTT_memcpy       memcpy
#define STBTT_memset       memset
#endif
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   INTERFACE
////
////

#ifndef __STB_INCLUDE_STB_TRUETYPE_H__
#define __STB_INCLUDE_STB_TRUETYPE_H__

#ifdef STBTT_STATIC
#define STBTT_DEF static
#else
#define STBTT_DEF extern
#endif

#ifdef __cplusplus
extern "C" {
#endif

	// private structure
	typedef struct
	{
		unsigned char* data;
		int cursor;
		int size;
	} stbtt__buf;

	//////////////////////////////////////////////////////////////////////////////
	//
	// TEXTURE BAKING API
	//
	// If you use this API, you only have to call two functions ever.
	//

	typedef struct
	{
		unsigned short x0, y0, x1, y1; // coordinates of bbox in bitmap
		float xoff, yoff, xadvance;
	} stbtt_bakedchar;

	STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char* data, int offset,  // font location (use offset=0 for plain .ttf)
		float pixel_height,                     // height of font in pixels
		unsigned char* pixels, int pw, int ph,  // bitmap to be filled in
		int first_char, int num_chars,          // characters to bake
		stbtt_bakedchar* chardata);             // you allocate this, it's num_chars long
// if return is positive, the first unused row of the bitmap
// if return is negative, returns the negative of the number of characters that fit
// if return is 0, no characters fit and no rows were used
// This uses a very crappy packing.

	typedef struct
	{
		float x0, y0, s0, t0; // top-left
		float x1, y1, s1, t1; // bottom-right
	} stbtt_aligned_quad;

	STBTT_DEF void stbtt_GetBakedQuad(stbtt_bakedchar* chardata, int pw, int ph,  // same data as above
		int char_index,             // character to display
		float* xpos, float* ypos,   // pointers to current position in screen pixel space
		stbtt_aligned_quad* q,      // output: quad to draw
		int opengl_fillrule);       // true if opengl fill rule; false if DX9 or earlier
// Call GetBakedQuad with char_index = 'character - first_char', and it
// creates the quad you need to draw and advances the current position.
//
// The coordinate system used assumes y increases downwards.
//
// Characters will extend both above and below the current position;
// see discussion of "BASELINE" above.
//
// It's inefficient; you might want to c&p it and optimize it.

//////////////////////////////////////////////////////////////////////////////
//
// NEW TEXTURE BAKING API
//
// This provides options for packing multiple fonts into one atlas, not
// perfectly but better than nothing.

	typedef struct
	{
		unsigned short x0, y0, x1, y1; // coordinates of bbox in bitmap
		float xoff, yoff, xadvance;
		float xoff2, yoff2;
	} stbtt_packedchar;

	typedef struct stbtt_pack_context stbtt_pack_context;
	typedef struct stbtt_fontinfo stbtt_fontinfo;
#ifndef STB_RECT_PACK_VERSION
	typedef struct stbrp_rect stbrp_rect;
#endif

	STBTT_DEF int  stbtt_PackBegin(stbtt_pack_context* spc, unsigned char* pixels, int width, int height, int stride_in_bytes, int padding, void* alloc_context);
	// Initializes a packing context stored in the passed-in stbtt_pack_context.
	// Future calls using this context will pack characters into the bitmap passed
	// in here: a 1-channel bitmap that is width * height. stride_in_bytes is
	// the distance from one row to the next (or 0 to mean they are packed tightly
	// together). "padding" is the amount of padding to leave between each
	// character (normally you want '1' for bitmaps you'll use as textures with
	// bilinear filtering).
	//
	// Returns 0 on failure, 1 on success.

	STBTT_DEF void stbtt_PackEnd(stbtt_pack_context* spc);
	// Cleans up the packing context and frees all memory.

#define STBTT_POINT_SIZE(x)   (-(x))

	STBTT_DEF int  stbtt_PackFontRange(stbtt_pack_context* spc, unsigned char* fontdata, int font_index, float font_size,
		int first_unicode_char_in_range, int num_chars_in_range, stbtt_packedchar* chardata_for_range);
	// Creates character bitmaps from the font_index'th font found in fontdata (use
	// font_index=0 if you don't know what that is). It creates num_chars_in_range
	// bitmaps for characters with unicode values starting at first_unicode_char_in_range
	// and increasing. Data for how to Render them is stored in chardata_for_range;
	// pass these to stbtt_GetPackedQuad to Get back renderable quads.
	//
	// font_size is the full height of the character from ascender to descender,
	// as computed by stbtt_ScaleForPixelHeight. To use a point size as computed
	// by stbtt_ScaleForMappingEmToPixels, wrap the point size in STBTT_POINT_SIZE()
	// and pass that result as 'font_size':
	//       ...,                  20 , ... // font max minus min y is 20 pixels tall
	//       ..., STBTT_POINT_SIZE(20), ... // 'M' is 20 pixels tall

	typedef struct
	{
		float font_size;
		int first_unicode_codepoint_in_range;  // if non-zero, then the chars are continuous, and this is the first codepoint
		int* array_of_unicode_codepoints;       // if non-zero, then this is an array of unicode codepoints
		int num_chars;
		stbtt_packedchar* chardata_for_range; // output
		unsigned char h_oversample, v_oversample; // don't Set these, they're used internally
	} stbtt_pack_range;

	STBTT_DEF int  stbtt_PackFontRanges(stbtt_pack_context* spc, unsigned char* fontdata, int font_index, stbtt_pack_range* ranges, int num_ranges);
	// Creates character bitmaps from multiple ranges of characters stored in
	// ranges. This will usually create a better-packed bitmap than multiple
	// calls to stbtt_PackFontRange. Note that you can call this multiple
	// times within a single PackBegin/PackEnd.

	STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context* spc, unsigned int h_oversample, unsigned int v_oversample);
	// Oversampling a font increases the quality by allowing higher-quality subpixel
	// positioning, and is especially valuable at smaller text sizes.
	//
	// This function sets the amount of oversampling for all following calls to
	// stbtt_PackFontRange(s) or stbtt_PackFontRangesGatherRects for a given
	// pack context. The default (no oversampling) is achieved by h_oversample=1
	// and v_oversample=1. The total number of pixels required is
	// h_oversample*v_oversample larger than the default; for example, 2x2
	// oversampling requires 4x the storage of 1x1. For best results, Render
	// oversampled textures with bilinear filtering. Look at the readme in
	// stb/tests/oversample for information about oversampled fonts
	//
	// To use with PackFontRangesGather etc., you must Set it before calls
	// call to PackFontRangesGatherRects.

	STBTT_DEF void stbtt_GetPackedQuad(stbtt_packedchar* chardata, int pw, int ph,  // same data as above
		int char_index,             // character to display
		float* xpos, float* ypos,   // pointers to current position in screen pixel space
		stbtt_aligned_quad* q,      // output: quad to draw
		int align_to_integer);

	STBTT_DEF int  stbtt_PackFontRangesGatherRects(stbtt_pack_context* spc, const stbtt_fontinfo* info, stbtt_pack_range* ranges, int num_ranges, stbrp_rect* rects);
	STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context* spc, stbrp_rect* rects, int num_rects);
	STBTT_DEF int  stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context* spc, const stbtt_fontinfo* info, stbtt_pack_range* ranges, int num_ranges, stbrp_rect* rects);
	// Calling these functions in sequence is roughly equivalent to calling
	// stbtt_PackFontRanges(). If you more control over the packing of multiple
	// fonts, or if you want to pack custom data into a font texture, take a look
	// at the source to of stbtt_PackFontRanges() and create a custom version
	// using these functions, e.g. call GatherRects multiple times,
	// building up a single array of rects, then call PackRects once,
	// then call RenderIntoRects repeatedly. This may result in a
	// better packing than calling PackFontRanges multiple times
	// (or it may not).

	// this is an opaque structure that you shouldn't mess with which holds
	// all the context needed from PackBegin to PackEnd.
	struct stbtt_pack_context {
		void* user_allocator_context;
		void* pack_info;
		int   width;
		int   height;
		int   stride_in_bytes;
		int   padding;
		unsigned int   h_oversample, v_oversample;
		unsigned char* pixels;
		void* nodes;
	};

	//////////////////////////////////////////////////////////////////////////////
	//
	// FONT LOADING
	//
	//

	STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char* data);
	// This function will determine the number of fonts in a font file.  TrueType
	// collection (.ttc) files may contain multiple fonts, while TrueType font
	// (.ttf) files only contain one font. The number of fonts can be used for
	// indexing with the previous function where the index is between zero and one
	// less than the total fonts. If an error occurs, -1 is returned.

	STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char* data, int index);
	// Each .ttf/.ttc file may have more than one font. Each font has a sequential
	// index number starting from 0. Call this function to Get the font offset for
	// a given index; it returns -1 if the index is out of range. A regular .ttf
	// file will only define one font and it always be at offset 0, so it will
	// return '0' for index 0, and -1 for all other indices.

	// The following structure is defined publically so you can declare one on
	// the stack or as a global or etc, but you should treat it as opaque.
	struct stbtt_fontinfo
	{
		void* userdata;
		unsigned char* data;              // pointer to .ttf file
		int              fontstart;         // offset of start of font

		int numGlyphs;                     // number of glyphs, needed for range checking

		int loca, head, glyf, hhea, hmtx, kern; // table locations as offset from start of .ttf
		int index_map;                     // a cmap mapping for our chosen character encoding
		int indexToLocFormat;              // format needed to map from glyph index to glyph

		stbtt__buf cff;                    // cff font data
		stbtt__buf charstrings;            // the charstring index
		stbtt__buf gsubrs;                 // global charstring subroutines index
		stbtt__buf subrs;                  // private charstring subroutines index
		stbtt__buf fontdicts;              // array of font dicts
		stbtt__buf fdselect;               // map from glyph to fontdict
	};

	STBTT_DEF int stbtt_InitFont(stbtt_fontinfo* info, const unsigned char* data, int offset);
	// Given an offset into the file that defines a font, this function builds
	// the necessary cached info for the rest of the system. You must allocate
	// the stbtt_fontinfo yourself, and stbtt_InitFont will fill it out. You don't
	// need to do anything special to free it, because the contents are pure
	// value data with no additional data structures. Returns 0 on failure.

	//////////////////////////////////////////////////////////////////////////////
	//
	// CHARACTER TO GLYPH-INDEX CONVERSIOn

	STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo* info, int unicode_codepoint);
	// If you're going to perform multiple operations on the same character
	// and you want a speed-up, call this function with the character you're
	// going to process, then use glyph-based functions instead of the
	// codepoint-based functions.

	//////////////////////////////////////////////////////////////////////////////
	//
	// CHARACTER PROPERTIES
	//

	STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo* info, float pixels);
	// computes a scale factor to produce a font whose "height" is 'pixels' tall.
	// Height is measured as the distance from the highest ascender to the lowest
	// descender; in other words, it's equivalent to calling stbtt_GetFontVMetrics
	// and computing:
	//       scale = pixels / (ascent - descent)
	// so if you prefer to measure height by the ascent only, use a similar calculation.

	STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo* info, float pixels);
	// computes a scale factor to produce a font whose EM size is mapped to
	// 'pixels' tall. This is probably what traditional APIs compute, but
	// I'm not positive.

	STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo* info, int* ascent, int* descent, int* lineGap);
	// ascent is the coordinate above the baseline the font extends; descent
	// is the coordinate below the baseline the font extends (i.e. it is typically negative)
	// lineGap is the spacing between one row's descent and the next row's ascent...
	// so you should advance the vertical position by "*ascent - *descent + *lineGap"
	//   these are expressed in unscaled coordinates, so you must multiply by
	//   the scale factor for a given size

	STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo* info, int* x0, int* y0, int* x1, int* y1);
	// the bounding box around all possible characters

	STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo* info, int codepoint, int* advanceWidth, int* leftSideBearing);
	// leftSideBearing is the offset from the current horizontal position to the left edge of the character
	// advanceWidth is the offset from the current horizontal position to the next horizontal position
	//   these are expressed in unscaled coordinates

	STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo* info, int ch1, int ch2);
	// an additional amount to add to the 'advance' value between ch1 and ch2

	STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo* info, int codepoint, int* x0, int* y0, int* x1, int* y1);
	// Gets the bounding box of the visible part of the glyph, in unscaled coordinates

	STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo* info, int glyph_index, int* advanceWidth, int* leftSideBearing);
	STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo* info, int glyph1, int glyph2);
	STBTT_DEF int  stbtt_GetGlyphBox(const stbtt_fontinfo* info, int glyph_index, int* x0, int* y0, int* x1, int* y1);
	// as above, but takes one or more glyph indices for greater efficiency

	//////////////////////////////////////////////////////////////////////////////
	//
	// GLYPH SHAPES (you probably don't need these, but they have to go before
	// the bitmaps for C declaration-order reasons)
	//

#ifndef STBTT_vmove // you can predefine these to use different values (but why?)
	enum {
		STBTT_vmove = 1,
		STBTT_vline,
		STBTT_vcurve,
		STBTT_vcubic
	};
#endif

#ifndef stbtt_vertex // you can predefine this to use different values
	// (we share this with other code at RAD)
#define stbtt_vertex_type short // can't use stbtt_int16 because that's not visible in the header file
	typedef struct
	{
		stbtt_vertex_type x, y, cx, cy, cx1, cy1;
		unsigned char type, padding;
	} stbtt_vertex;
#endif

	STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo* info, int glyph_index);
	// returns non-zero if nothing is drawn for this glyph

	STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo* info, int unicode_codepoint, stbtt_vertex** vertices);
	STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo* info, int glyph_index, stbtt_vertex** vertices);
	// returns # of vertices and fills *vertices with the pointer to them
	//   these are expressed in "unscaled" coordinates
	//
	// The shape is a series of countours. Each one starts with
	// a STBTT_moveto, then consists of a series of mixed
	// STBTT_lineto and STBTT_curveto segments. A lineto
	// draws a line from previous endpoint to its x,y; a curveto
	// draws a quadratic bezier from previous endpoint to
	// its x,y, using cx,cy as the bezier control point.

	STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo* info, stbtt_vertex* vertices);
	// frees the data allocated above

	//////////////////////////////////////////////////////////////////////////////
	//
	// BITMAP RENDERING
	//

	STBTT_DEF void stbtt_FreeBitmap(unsigned char* bitmap, void* userdata);
	// frees the bitmap allocated below

	STBTT_DEF unsigned char* stbtt_GetCodepointBitmap(const stbtt_fontinfo* info, float scale_x, float scale_y, int codepoint, int* width, int* height, int* xoff, int* yoff);
	// allocates a large-enough single-channel 8bpp bitmap and renders the
	// specified character/glyph at the specified scale into it, with
	// antialiasing. 0 is no coverage (transparent), 255 is fully covered (opaque).
	// *width & *height are filled out with the width & height of the bitmap,
	// which is stored left-to-right, top-to-bottom.
	//
	// xoff/yoff are the offset it pixel space from the glyph origin to the top-left of the bitmap

	STBTT_DEF unsigned char* stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo* info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int* width, int* height, int* xoff, int* yoff);
	// the same as stbtt_GetCodepoitnBitmap, but you can specify a subpixel
	// shift for the character

	STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint);
	// the same as stbtt_GetCodepointBitmap, but you pass in storage for the bitmap
	// in the form of 'output', with row spacing of 'out_stride' bytes. the bitmap
	// is clipped to out_w/out_h bytes. Call stbtt_GetCodepointBitmapBox to Get the
	// width and height and positioning info for it first.

	STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint);
	// same as stbtt_MakeCodepointBitmap, but you can specify a subpixel
	// shift for the character

	STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo* font, int codepoint, float scale_x, float scale_y, int* ix0, int* iy0, int* ix1, int* iy1);
	// Get the bbox of the bitmap centered around the glyph origin; so the
	// bitmap width is ix1-ix0, height is iy1-iy0, and location to place
	// the bitmap top left is (leftSideBearing*scale,iy0).
	// (Note that the bitmap uses y-increases-down, but the shape uses
	// y-increases-up, so CodepointBitmapBox and CodepointBox are inverted.)

	STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo* font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int* ix0, int* iy0, int* ix1, int* iy1);
	// same as stbtt_GetCodepointBitmapBox, but you can specify a subpixel
	// shift for the character

	// the following functions are equivalent to the above functions, but operate
	// on glyph indices instead of Unicode codepoints (for efficiency)
	STBTT_DEF unsigned char* stbtt_GetGlyphBitmap(const stbtt_fontinfo* info, float scale_x, float scale_y, int glyph, int* width, int* height, int* xoff, int* yoff);
	STBTT_DEF unsigned char* stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo* info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int* width, int* height, int* xoff, int* yoff);
	STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph);
	STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph);
	STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo* font, int glyph, float scale_x, float scale_y, int* ix0, int* iy0, int* ix1, int* iy1);
	STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo* font, int glyph, float scale_x, float scale_y, float shift_x, float shift_y, int* ix0, int* iy0, int* ix1, int* iy1);

	// @TODO: don't expose this structure
	typedef struct
	{
		int w, h, stride;
		unsigned char* pixels;
	} stbtt__bitmap;

	// rasterize a shape with quadratic beziers into a bitmap
	STBTT_DEF void stbtt_Rasterize(stbtt__bitmap* result,        // 1-channel bitmap to draw into
		float flatness_in_pixels,     // allowable error of curve in pixels
		stbtt_vertex* vertices,       // array of vertices defining shape
		int num_verts,                // number of vertices in above array
		float scale_x, float scale_y, // scale applied to input vertices
		float shift_x, float shift_y, // translation applied to input vertices
		int x_off, int y_off,         // another translation applied to input
		int invert,                   // if non-zero, vertically flip shape
		void* userdata);              // context for to STBTT_MALLOC

//////////////////////////////////////////////////////////////////////////////
//
// Finding the right font...
//
// You should really just solve this offline, keep your own tables
// of what font is what, and don't try to Get it out of the .ttf file.
// That's because getting it out of the .ttf file is really hard, because
// the names in the file can appear in many possible encodings, in many
// possible languages, and e.g. if you need a case-insensitive comparison,
// the details of that depend on the encoding & language in a complex way
// (actually underspecified in truetype, but also gigantic).
//
// But you can use the provided functions in two possible ways:
//     stbtt_FindMatchingFont() will use *case-sensitive* comparisons on
//             unicode-encoded names to try to GetOffset the font you want;
//             you can run this before calling stbtt_InitFont()
//
//     stbtt_GetFontNameString() lets you Get any of the various strings
//             from the file yourself and do your own comparisons on them.
//             You have to have called stbtt_InitFont() first.

	STBTT_DEF int stbtt_FindMatchingFont(const unsigned char* fontdata, const char* name, int flags);
	// returns the offset (not index) of the font that matches, or -1 if none
	//   if you use STBTT_MACSTYLE_DONTCARE, use a font name like "Arial Bold".
	//   if you use any other flag, use a font name like "Arial"; this checks
	//     the 'macStyle' header field; i don't know if fonts Set this consistently
#define STBTT_MACSTYLE_DONTCARE     0
#define STBTT_MACSTYLE_BOLD         1
#define STBTT_MACSTYLE_ITALIC       2
#define STBTT_MACSTYLE_UNDERSCORE   4
#define STBTT_MACSTYLE_NONE         8   // <= not same as 0, this makes us check the bitfield is 0

	STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char* s1, int len1, const char* s2, int len2);
	// returns 1/0 whether the first string interpreted as utf8 is identical to
	// the second string interpreted as big-endian utf16... useful for strings from next func

	STBTT_DEF const char* stbtt_GetFontNameString(const stbtt_fontinfo* font, int* length, int platformID, int encodingID, int languageID, int nameID);
	// returns the string (which may be big-endian double uint8_t, e.g. for unicode)
	// and puts the length in bytes in *length.
	//
	// some of the values for the IDs are below; for more see the truetype spec:
	//     http://developer.apple.com/textfonts/TTRefMan/RM06/Chap6name.html
	//     http://www.microsoft.com/typography/otspec/name.htm

	enum { // platformID
		STBTT_PLATFORM_ID_UNICODE = 0,
		STBTT_PLATFORM_ID_MAC = 1,
		STBTT_PLATFORM_ID_ISO = 2,
		STBTT_PLATFORM_ID_MICROSOFT = 3
	};

	enum { // encodingID for STBTT_PLATFORM_ID_UNICODE
		STBTT_UNICODE_EID_UNICODE_1_0 = 0,
		STBTT_UNICODE_EID_UNICODE_1_1 = 1,
		STBTT_UNICODE_EID_ISO_10646 = 2,
		STBTT_UNICODE_EID_UNICODE_2_0_BMP = 3,
		STBTT_UNICODE_EID_UNICODE_2_0_FULL = 4
	};

	enum { // encodingID for STBTT_PLATFORM_ID_MICROSOFT
		STBTT_MS_EID_SYMBOL = 0,
		STBTT_MS_EID_UNICODE_BMP = 1,
		STBTT_MS_EID_SHIFTJIS = 2,
		STBTT_MS_EID_UNICODE_FULL = 10
	};

	enum { // encodingID for STBTT_PLATFORM_ID_MAC; same as Script Manager codes
		STBTT_MAC_EID_ROMAN = 0, STBTT_MAC_EID_ARABIC = 4,
		STBTT_MAC_EID_JAPANESE = 1, STBTT_MAC_EID_HEBREW = 5,
		STBTT_MAC_EID_CHINESE_TRAD = 2, STBTT_MAC_EID_GREEK = 6,
		STBTT_MAC_EID_KOREAN = 3, STBTT_MAC_EID_RUSSIAN = 7
	};

	enum { // languageID for STBTT_PLATFORM_ID_MICROSOFT; same as LCID...
		   // problematic because there are e.g. 16 english LCIDs and 16 arabic LCIDs
		STBTT_MS_LANG_ENGLISH = 0x0409, STBTT_MS_LANG_ITALIAN = 0x0410,
		STBTT_MS_LANG_CHINESE = 0x0804, STBTT_MS_LANG_JAPANESE = 0x0411,
		STBTT_MS_LANG_DUTCH = 0x0413, STBTT_MS_LANG_KOREAN = 0x0412,
		STBTT_MS_LANG_FRENCH = 0x040c, STBTT_MS_LANG_RUSSIAN = 0x0419,
		STBTT_MS_LANG_GERMAN = 0x0407, STBTT_MS_LANG_SPANISH = 0x0409,
		STBTT_MS_LANG_HEBREW = 0x040d, STBTT_MS_LANG_SWEDISH = 0x041D
	};

	enum { // languageID for STBTT_PLATFORM_ID_MAC
		STBTT_MAC_LANG_ENGLISH = 0, STBTT_MAC_LANG_JAPANESE = 11,
		STBTT_MAC_LANG_ARABIC = 12, STBTT_MAC_LANG_KOREAN = 23,
		STBTT_MAC_LANG_DUTCH = 4, STBTT_MAC_LANG_RUSSIAN = 32,
		STBTT_MAC_LANG_FRENCH = 1, STBTT_MAC_LANG_SPANISH = 6,
		STBTT_MAC_LANG_GERMAN = 2, STBTT_MAC_LANG_SWEDISH = 5,
		STBTT_MAC_LANG_HEBREW = 10, STBTT_MAC_LANG_CHINESE_SIMPLIFIED = 33,
		STBTT_MAC_LANG_ITALIAN = 3, STBTT_MAC_LANG_CHINESE_TRAD = 19
	};

#ifdef __cplusplus
}
#endif

#endif // __STB_INCLUDE_STB_TRUETYPE_H__

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
////
////   IMPLEMENTATION
////
////

#ifdef STB_TRUETYPE_IMPLEMENTATION

#ifndef STBTT_MAX_OVERSAMPLE
#define STBTT_MAX_OVERSAMPLE   8
#endif

#if STBTT_MAX_OVERSAMPLE > 255
#error "STBTT_MAX_OVERSAMPLE cannot be > 255"
#endif

typedef int stbtt__test_oversample_pow2[(STBTT_MAX_OVERSAMPLE & (STBTT_MAX_OVERSAMPLE - 1)) == 0 ? 1 : -1];

#ifndef STBTT_RASTERIZER_VERSION
#define STBTT_RASTERIZER_VERSION 2
#endif

#ifdef _MSC_VER
#define STBTT__NOTUSED(v)  (void)(v)
#else
#define STBTT__NOTUSED(v)  (void)sizeof(v)
#endif

//////////////////////////////////////////////////////////////////////////
//
// stbtt__buf helpers to parse data from file
//

static stbtt_uint8 stbtt__buf_get8(stbtt__buf * b)
{
	if (b->cursor >= b->size)
		return 0;
	return b->data[b->cursor++];
}

static stbtt_uint8 stbtt__buf_peek8(stbtt__buf* b)
{
	if (b->cursor >= b->size)
		return 0;
	return b->data[b->cursor];
}

static void stbtt__buf_seek(stbtt__buf* b, int o)
{
	STBTT_assert(!(o > b->size || o < 0));
	b->cursor = (o > b->size || o < 0) ? b->size : o;
}

static void stbtt__buf_skip(stbtt__buf* b, int o)
{
	stbtt__buf_seek(b, b->cursor + o);
}

static stbtt_uint32 stbtt__buf_get(stbtt__buf* b, int n)
{
	stbtt_uint32 v = 0;
	int i;
	STBTT_assert(n >= 1 && n <= 4);
	for (i = 0; i < n; i++)
		v = (v << 8) | stbtt__buf_get8(b);
	return v;
}

static stbtt__buf stbtt__new_buf(const void* p, size_t size)
{
	stbtt__buf r;
	STBTT_assert(size < 0x40000000);
	r.data = (stbtt_uint8*)p;
	r.size = (int)size;
	r.cursor = 0;
	return r;
}

#define stbtt__buf_get16(b)  stbtt__buf_get((b), 2)
#define stbtt__buf_get32(b)  stbtt__buf_get((b), 4)

static stbtt__buf stbtt__buf_range(const stbtt__buf* b, int o, int s)
{
	stbtt__buf r = stbtt__new_buf(NULL, 0);
	if (o < 0 || s < 0 || o > b->size || s > b->size - o) return r;
	r.data = b->data + o;
	r.size = s;
	return r;
}

static stbtt__buf stbtt__cff_get_index(stbtt__buf* b)
{
	int count, start, offsize;
	start = b->cursor;
	count = stbtt__buf_get16(b);
	if (count) {
		offsize = stbtt__buf_get8(b);
		STBTT_assert(offsize >= 1 && offsize <= 4);
		stbtt__buf_skip(b, offsize * count);
		stbtt__buf_skip(b, stbtt__buf_get(b, offsize) - 1);
	}
	return stbtt__buf_range(b, start, b->cursor - start);
}

static stbtt_uint32 stbtt__cff_int(stbtt__buf* b)
{
	int b0 = stbtt__buf_get8(b);
	if (b0 >= 32 && b0 <= 246)       return b0 - 139;
	else if (b0 >= 247 && b0 <= 250) return (b0 - 247) * 256 + stbtt__buf_get8(b) + 108;
	else if (b0 >= 251 && b0 <= 254) return -(b0 - 251) * 256 - stbtt__buf_get8(b) - 108;
	else if (b0 == 28)               return stbtt__buf_get16(b);
	else if (b0 == 29)               return stbtt__buf_get32(b);
	STBTT_assert(0);
	return 0;
}

static void stbtt__cff_skip_operand(stbtt__buf* b) {
	int v, b0 = stbtt__buf_peek8(b);
	STBTT_assert(b0 >= 28);
	if (b0 == 30) {
		stbtt__buf_skip(b, 1);
		while (b->cursor < b->size) {
			v = stbtt__buf_get8(b);
			if ((v & 0xF) == 0xF || (v >> 4) == 0xF)
				break;
		}
	}
	else {
		stbtt__cff_int(b);
	}
}

static stbtt__buf stbtt__dict_get(stbtt__buf* b, int key)
{
	stbtt__buf_seek(b, 0);
	while (b->cursor < b->size) {
		int start = b->cursor, end, op;
		while (stbtt__buf_peek8(b) >= 28)
			stbtt__cff_skip_operand(b);
		end = b->cursor;
		op = stbtt__buf_get8(b);
		if (op == 12)  op = stbtt__buf_get8(b) | 0x100;
		if (op == key) return stbtt__buf_range(b, start, end - start);
	}
	return stbtt__buf_range(b, 0, 0);
}

static void stbtt__dict_get_ints(stbtt__buf* b, int key, int outcount, stbtt_uint32* out)
{
	int i;
	stbtt__buf operands = stbtt__dict_get(b, key);
	for (i = 0; i < outcount && operands.cursor < operands.size; i++)
		out[i] = stbtt__cff_int(&operands);
}

static int stbtt__cff_index_count(stbtt__buf* b)
{
	stbtt__buf_seek(b, 0);
	return stbtt__buf_get16(b);
}

static stbtt__buf stbtt__cff_index_get(stbtt__buf b, int i)
{
	int count, offsize, start, end;
	stbtt__buf_seek(&b, 0);
	count = stbtt__buf_get16(&b);
	offsize = stbtt__buf_get8(&b);
	STBTT_assert(i >= 0 && i < count);
	STBTT_assert(offsize >= 1 && offsize <= 4);
	stbtt__buf_skip(&b, i * offsize);
	start = stbtt__buf_get(&b, offsize);
	end = stbtt__buf_get(&b, offsize);
	return stbtt__buf_range(&b, 2 + (count + 1) * offsize + start, end - start);
}

//////////////////////////////////////////////////////////////////////////
//
// accessors to parse data from file
//

// on platforms that don't allow misaligned reads, if we want to allow
// truetype fonts that aren't padded to alignment, define ALLOW_UNALIGNED_TRUETYPE

#define ttBYTE(p)     (* (stbtt_uint8 *) (p))
#define ttCHAR(p)     (* (stbtt_int8 *) (p))
#define ttFixed(p)    ttLONG(p)

static stbtt_uint16 ttUSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }
static stbtt_int16 ttSHORT(stbtt_uint8* p) { return p[0] * 256 + p[1]; }
static stbtt_uint32 ttULONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }
static stbtt_int32 ttLONG(stbtt_uint8* p) { return (p[0] << 24) + (p[1] << 16) + (p[2] << 8) + p[3]; }

#define stbtt_tag4(p,c0,c1,c2,c3) ((p)[0] == (c0) && (p)[1] == (c1) && (p)[2] == (c2) && (p)[3] == (c3))
#define stbtt_tag(p,str)           stbtt_tag4(p,str[0],str[1],str[2],str[3])

static int stbtt__isfont(stbtt_uint8* font)
{
	// check the version number
	if (stbtt_tag4(font, '1', 0, 0, 0))  return 1; // TrueType 1
	if (stbtt_tag(font, "typ1"))   return 1; // TrueType with type 1 font -- we don't support this!
	if (stbtt_tag(font, "OTTO"))   return 1; // OpenType with CFF
	if (stbtt_tag4(font, 0, 1, 0, 0)) return 1; // OpenType 1.0
	if (stbtt_tag(font, "true"))   return 1; // Apple specification for TrueType fonts
	return 0;
}

// @OPTIMIZE: binary search
static stbtt_uint32 stbtt__find_table(stbtt_uint8* data, stbtt_uint32 fontstart, const char* tag)
{
	stbtt_int32 num_tables = ttUSHORT(data + fontstart + 4);
	stbtt_uint32 tabledir = fontstart + 12;
	stbtt_int32 i;
	for (i = 0; i < num_tables; ++i) {
		stbtt_uint32 loc = tabledir + 16 * i;
		if (stbtt_tag(data + loc + 0, tag))
			return ttULONG(data + loc + 8);
	}
	return 0;
}

static int stbtt_GetFontOffsetForIndex_internal(unsigned char* font_collection, int index)
{
	// if it's just a font, there's only one valid index
	if (stbtt__isfont(font_collection))
		return index == 0 ? 0 : -1;

	// check if it's a TTC
	if (stbtt_tag(font_collection, "ttcf")) {
		// version 1?
		if (ttULONG(font_collection + 4) == 0x00010000 || ttULONG(font_collection + 4) == 0x00020000) {
			stbtt_int32 n = ttLONG(font_collection + 8);
			if (index >= n)
				return -1;
			return ttULONG(font_collection + 12 + index * 4);
		}
	}
	return -1;
}

static int stbtt_GetNumberOfFonts_internal(unsigned char* font_collection)
{
	// if it's just a font, there's only one valid font
	if (stbtt__isfont(font_collection))
		return 1;

	// check if it's a TTC
	if (stbtt_tag(font_collection, "ttcf")) {
		// version 1?
		if (ttULONG(font_collection + 4) == 0x00010000 || ttULONG(font_collection + 4) == 0x00020000) {
			return ttLONG(font_collection + 8);
		}
	}
	return 0;
}

static stbtt__buf stbtt__get_subrs(stbtt__buf cff, stbtt__buf fontdict)
{
	stbtt_uint32 subrsoff = 0, private_loc[2] = { 0, 0 };
	stbtt__buf pdict;
	stbtt__dict_get_ints(&fontdict, 18, 2, private_loc);
	if (!private_loc[1] || !private_loc[0]) return stbtt__new_buf(NULL, 0);
	pdict = stbtt__buf_range(&cff, private_loc[1], private_loc[0]);
	stbtt__dict_get_ints(&pdict, 19, 1, &subrsoff);
	if (!subrsoff) return stbtt__new_buf(NULL, 0);
	stbtt__buf_seek(&cff, private_loc[1] + subrsoff);
	return stbtt__cff_get_index(&cff);
}

static int stbtt_InitFont_internal(stbtt_fontinfo* info, unsigned char* data, int fontstart)
{
	stbtt_uint32 cmap, t;
	stbtt_int32 i, numTables;

	info->data = data;
	info->fontstart = fontstart;
	info->cff = stbtt__new_buf(NULL, 0);

	cmap = stbtt__find_table(data, fontstart, "cmap");       // required
	info->loca = stbtt__find_table(data, fontstart, "loca"); // required
	info->head = stbtt__find_table(data, fontstart, "head"); // required
	info->glyf = stbtt__find_table(data, fontstart, "glyf"); // required
	info->hhea = stbtt__find_table(data, fontstart, "hhea"); // required
	info->hmtx = stbtt__find_table(data, fontstart, "hmtx"); // required
	info->kern = stbtt__find_table(data, fontstart, "kern"); // not required

	if (!cmap || !info->head || !info->hhea || !info->hmtx)
		return 0;
	if (info->glyf) {
		// required for truetype
		if (!info->loca) return 0;
	}
	else {
		// initialization for CFF / Type2 fonts (OTF)
		stbtt__buf b, topdict, topdictidx;
		stbtt_uint32 cstype = 2, charstrings = 0, fdarrayoff = 0, fdselectoff = 0;
		stbtt_uint32 cff;

		cff = stbtt__find_table(data, fontstart, "CFF ");
		if (!cff) return 0;

		info->fontdicts = stbtt__new_buf(NULL, 0);
		info->fdselect = stbtt__new_buf(NULL, 0);

		// @TODO this should use size from table (not 512MB)
		info->cff = stbtt__new_buf(data + cff, 512 * 1024 * 1024);
		b = info->cff;

		// read the header
		stbtt__buf_skip(&b, 2);
		stbtt__buf_seek(&b, stbtt__buf_get8(&b)); // hdrsize

		// @TODO the name INDEX could list multiple fonts,
		// but we just use the first one.
		stbtt__cff_get_index(&b);  // name INDEX
		topdictidx = stbtt__cff_get_index(&b);
		topdict = stbtt__cff_index_get(topdictidx, 0);
		stbtt__cff_get_index(&b);  // string INDEX
		info->gsubrs = stbtt__cff_get_index(&b);

		stbtt__dict_get_ints(&topdict, 17, 1, &charstrings);
		stbtt__dict_get_ints(&topdict, 0x100 | 6, 1, &cstype);
		stbtt__dict_get_ints(&topdict, 0x100 | 36, 1, &fdarrayoff);
		stbtt__dict_get_ints(&topdict, 0x100 | 37, 1, &fdselectoff);
		info->subrs = stbtt__get_subrs(b, topdict);

		// we only support Type 2 charstrings
		if (cstype != 2) return 0;
		if (charstrings == 0) return 0;

		if (fdarrayoff) {
			// looks like a CID font
			if (!fdselectoff) return 0;
			stbtt__buf_seek(&b, fdarrayoff);
			info->fontdicts = stbtt__cff_get_index(&b);
			info->fdselect = stbtt__buf_range(&b, fdselectoff, b.size - fdselectoff);
		}

		stbtt__buf_seek(&b, charstrings);
		info->charstrings = stbtt__cff_get_index(&b);
	}

	t = stbtt__find_table(data, fontstart, "maxp");
	if (t)
		info->numGlyphs = ttUSHORT(data + t + 4);
	else
		info->numGlyphs = 0xffff;

	// GetOffset a cmap encoding table we understand *now* to avoid searching
	// later. (todo: could make this installable)
	// the same regardless of glyph.
	numTables = ttUSHORT(data + cmap + 2);
	info->index_map = 0;
	for (i = 0; i < numTables; ++i) {
		stbtt_uint32 encoding_record = cmap + 4 + 8 * i;
		// GetOffset an encoding we understand:
		switch (ttUSHORT(data + encoding_record)) {
		case STBTT_PLATFORM_ID_MICROSOFT:
			switch (ttUSHORT(data + encoding_record + 2)) {
			case STBTT_MS_EID_UNICODE_BMP:
			case STBTT_MS_EID_UNICODE_FULL:
				// MS/Unicode
				info->index_map = cmap + ttULONG(data + encoding_record + 4);
				break;
			}
			break;
		case STBTT_PLATFORM_ID_UNICODE:
			// Mac/iOS has these
			// all the encodingIDs are unicode, so we don't bother to check it
			info->index_map = cmap + ttULONG(data + encoding_record + 4);
			break;
		}
	}
	if (info->index_map == 0)
		return 0;

	info->indexToLocFormat = ttUSHORT(data + info->head + 50);
	return 1;
}

STBTT_DEF int stbtt_FindGlyphIndex(const stbtt_fontinfo* info, int unicode_codepoint)
{
	stbtt_uint8* data = info->data;
	stbtt_uint32 index_map = info->index_map;

	stbtt_uint16 format = ttUSHORT(data + index_map + 0);
	if (format == 0) { // apple uint8_t encoding
		stbtt_int32 bytes = ttUSHORT(data + index_map + 2);
		if (unicode_codepoint < bytes - 6)
			return ttBYTE(data + index_map + 6 + unicode_codepoint);
		return 0;
	}
	else if (format == 6) {
		stbtt_uint32 first = ttUSHORT(data + index_map + 6);
		stbtt_uint32 count = ttUSHORT(data + index_map + 8);
		if ((stbtt_uint32)unicode_codepoint >= first && (stbtt_uint32)unicode_codepoint < first + count)
			return ttUSHORT(data + index_map + 10 + (unicode_codepoint - first) * 2);
		return 0;
	}
	else if (format == 2) {
		STBTT_assert(0); // @TODO: high-uint8_t mapping for japanese/chinese/korean
		return 0;
	}
	else if (format == 4) { // standard mapping for windows fonts: binary search collection of ranges
		stbtt_uint16 segcount = ttUSHORT(data + index_map + 6) >> 1;
		stbtt_uint16 searchRange = ttUSHORT(data + index_map + 8) >> 1;
		stbtt_uint16 entrySelector = ttUSHORT(data + index_map + 10);
		stbtt_uint16 rangeShift = ttUSHORT(data + index_map + 12) >> 1;

		// do a binary search of the segments
		stbtt_uint32 endCount = index_map + 14;
		stbtt_uint32 search = endCount;

		if (unicode_codepoint > 0xffff)
			return 0;

		// they lie from endCount .. endCount + segCount
		// but searchRange is the nearest power of two, so...
		if (unicode_codepoint >= ttUSHORT(data + search + rangeShift * 2))
			search += rangeShift * 2;

		// now decrement to bias correctly to GetOffset smallest
		search -= 2;
		while (entrySelector) {
			stbtt_uint16 end;
			searchRange >>= 1;
			end = ttUSHORT(data + search + searchRange * 2);
			if (unicode_codepoint > end)
				search += searchRange * 2;
			--entrySelector;
		}
		search += 2;

		{
			stbtt_uint16 offset, start;
			stbtt_uint16 item = (stbtt_uint16)((search - endCount) >> 1);

			STBTT_assert(unicode_codepoint <= ttUSHORT(data + endCount + 2 * item));
			start = ttUSHORT(data + index_map + 14 + segcount * 2 + 2 + 2 * item);
			if (unicode_codepoint < start)
				return 0;

			offset = ttUSHORT(data + index_map + 14 + segcount * 6 + 2 + 2 * item);
			if (offset == 0)
				return (stbtt_uint16)(unicode_codepoint + ttSHORT(data + index_map + 14 + segcount * 4 + 2 + 2 * item));

			return ttUSHORT(data + offset + (unicode_codepoint - start) * 2 + index_map + 14 + segcount * 6 + 2 + 2 * item);
		}
	}
	else if (format == 12 || format == 13) {
		stbtt_uint32 ngroups = ttULONG(data + index_map + 12);
		stbtt_int32 low, high;
		low = 0; high = (stbtt_int32)ngroups;
		// Binary search the right group.
		while (low < high) {
			stbtt_int32 mid = low + ((high - low) >> 1); // rounds down, so low <= mid < high
			stbtt_uint32 start_char = ttULONG(data + index_map + 16 + mid * 12);
			stbtt_uint32 end_char = ttULONG(data + index_map + 16 + mid * 12 + 4);
			if ((stbtt_uint32)unicode_codepoint < start_char)
				high = mid;
			else if ((stbtt_uint32)unicode_codepoint > end_char)
				low = mid + 1;
			else {
				stbtt_uint32 start_glyph = ttULONG(data + index_map + 16 + mid * 12 + 8);
				if (format == 12)
					return start_glyph + unicode_codepoint - start_char;
				else // format == 13
					return start_glyph;
			}
		}
		return 0; // not found
	}
	// @TODO
	STBTT_assert(0);
	return 0;
}

STBTT_DEF int stbtt_GetCodepointShape(const stbtt_fontinfo* info, int unicode_codepoint, stbtt_vertex** vertices)
{
	return stbtt_GetGlyphShape(info, stbtt_FindGlyphIndex(info, unicode_codepoint), vertices);
}

static void stbtt_setvertex(stbtt_vertex* v, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy)
{
	v->type = type;
	v->x = (stbtt_int16)x;
	v->y = (stbtt_int16)y;
	v->cx = (stbtt_int16)cx;
	v->cy = (stbtt_int16)cy;
}

static int stbtt__GetGlyfOffset(const stbtt_fontinfo* info, int glyph_index)
{
	int g1, g2;

	STBTT_assert(!info->cff.size);

	if (glyph_index >= info->numGlyphs) return -1; // glyph index out of range
	if (info->indexToLocFormat >= 2)    return -1; // unknown index->glyph map format

	if (info->indexToLocFormat == 0) {
		g1 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2) * 2;
		g2 = info->glyf + ttUSHORT(info->data + info->loca + glyph_index * 2 + 2) * 2;
	}
	else {
		g1 = info->glyf + ttULONG(info->data + info->loca + glyph_index * 4);
		g2 = info->glyf + ttULONG(info->data + info->loca + glyph_index * 4 + 4);
	}

	return g1 == g2 ? -1 : g1; // if length is 0, return -1
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo* info, int glyph_index, int* x0, int* y0, int* x1, int* y1);

STBTT_DEF int stbtt_GetGlyphBox(const stbtt_fontinfo* info, int glyph_index, int* x0, int* y0, int* x1, int* y1)
{
	if (info->cff.size) {
		stbtt__GetGlyphInfoT2(info, glyph_index, x0, y0, x1, y1);
	}
	else {
		int g = stbtt__GetGlyfOffset(info, glyph_index);
		if (g < 0) return 0;

		if (x0)* x0 = ttSHORT(info->data + g + 2);
		if (y0)* y0 = ttSHORT(info->data + g + 4);
		if (x1)* x1 = ttSHORT(info->data + g + 6);
		if (y1)* y1 = ttSHORT(info->data + g + 8);
	}
	return 1;
}

STBTT_DEF int stbtt_GetCodepointBox(const stbtt_fontinfo* info, int codepoint, int* x0, int* y0, int* x1, int* y1)
{
	return stbtt_GetGlyphBox(info, stbtt_FindGlyphIndex(info, codepoint), x0, y0, x1, y1);
}

STBTT_DEF int stbtt_IsGlyphEmpty(const stbtt_fontinfo* info, int glyph_index)
{
	stbtt_int16 numberOfContours;
	int g;
	if (info->cff.size)
		return stbtt__GetGlyphInfoT2(info, glyph_index, NULL, NULL, NULL, NULL) == 0;
	g = stbtt__GetGlyfOffset(info, glyph_index);
	if (g < 0) return 1;
	numberOfContours = ttSHORT(info->data + g);
	return numberOfContours == 0;
}

static int stbtt__close_shape(stbtt_vertex* vertices, int num_vertices, int was_off, int start_off,
	stbtt_int32 sx, stbtt_int32 sy, stbtt_int32 scx, stbtt_int32 scy, stbtt_int32 cx, stbtt_int32 cy)
{
	if (start_off) {
		if (was_off)
			stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + scx) >> 1, (cy + scy) >> 1, cx, cy);
		stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx, sy, scx, scy);
	}
	else {
		if (was_off)
			stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, sx, sy, cx, cy);
		else
			stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, sx, sy, 0, 0);
	}
	return num_vertices;
}

static int stbtt__GetGlyphShapeTT(const stbtt_fontinfo* info, int glyph_index, stbtt_vertex** pvertices)
{
	stbtt_int16 numberOfContours;
	stbtt_uint8* endPtsOfContours;
	stbtt_uint8* data = info->data;
	stbtt_vertex* vertices = 0;
	int num_vertices = 0;
	int g = stbtt__GetGlyfOffset(info, glyph_index);

	*pvertices = NULL;

	if (g < 0) return 0;

	numberOfContours = ttSHORT(data + g);

	if (numberOfContours > 0) {
		stbtt_uint8 flags = 0, flagcount;
		stbtt_int32 ins, i, j = 0, m, n, next_move, was_off = 0, off, start_off = 0;
		stbtt_int32 x, y, cx, cy, sx, sy, scx, scy;
		stbtt_uint8* points;
		endPtsOfContours = (data + g + 10);
		ins = ttUSHORT(data + g + 10 + numberOfContours * 2);
		points = data + g + 10 + numberOfContours * 2 + 2 + ins;

		n = 1 + ttUSHORT(endPtsOfContours + numberOfContours * 2 - 2);

		m = n + 2 * numberOfContours;  // a loose bound on how many vertices we might need
		vertices = (stbtt_vertex*)STBTT_malloc(m * sizeof(vertices[0]), info->userdata);
		if (vertices == 0)
			return 0;

		next_move = 0;
		flagcount = 0;

		// in first pass, we load uninterpreted data into the allocated array
		// above, shifted to the end of the array so we won't overwrite it when
		// we create our final data starting from the front

		off = m - n; // starting offset for uninterpreted data, regardless of how m ends up being calculated

		// first load flags

		for (i = 0; i < n; ++i) {
			if (flagcount == 0) {
				flags = *points++;
				if (flags & 8)
					flagcount = *points++;
			}
			else
				--flagcount;
			vertices[off + i].type = flags;
		}

		// now load x coordinates
		x = 0;
		for (i = 0; i < n; ++i) {
			flags = vertices[off + i].type;
			if (flags & 2) {
				stbtt_int16 dx = *points++;
				x += (flags & 16) ? dx : -dx; // ???
			}
			else {
				if (!(flags & 16)) {
					x = x + (stbtt_int16)(points[0] * 256 + points[1]);
					points += 2;
				}
			}
			vertices[off + i].x = (stbtt_int16)x;
		}

		// now load y coordinates
		y = 0;
		for (i = 0; i < n; ++i) {
			flags = vertices[off + i].type;
			if (flags & 4) {
				stbtt_int16 dy = *points++;
				y += (flags & 32) ? dy : -dy; // ???
			}
			else {
				if (!(flags & 32)) {
					y = y + (stbtt_int16)(points[0] * 256 + points[1]);
					points += 2;
				}
			}
			vertices[off + i].y = (stbtt_int16)y;
		}

		// now convert them to our format
		num_vertices = 0;
		sx = sy = cx = cy = scx = scy = 0;
		for (i = 0; i < n; ++i) {
			flags = vertices[off + i].type;
			x = (stbtt_int16)vertices[off + i].x;
			y = (stbtt_int16)vertices[off + i].y;

			if (next_move == i) {
				if (i != 0)
					num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy);

				// now start the new one
				start_off = !(flags & 1);
				if (start_off) {
					// if we start off with an off-curve point, then when we need to GetOffset a point on the curve
					// where we can start, and we need to save some state for when we wraparound.
					scx = x;
					scy = y;
					if (!(vertices[off + i + 1].type & 1)) {
						// next point is also a curve point, so interpolate an on-point curve
						sx = (x + (stbtt_int32)vertices[off + i + 1].x) >> 1;
						sy = (y + (stbtt_int32)vertices[off + i + 1].y) >> 1;
					}
					else {
						// otherwise just use the next point as our start point
						sx = (stbtt_int32)vertices[off + i + 1].x;
						sy = (stbtt_int32)vertices[off + i + 1].y;
						++i; // we're using point i+1 as the starting point, so skip it
					}
				}
				else {
					sx = x;
					sy = y;
				}
				stbtt_setvertex(&vertices[num_vertices++], STBTT_vmove, sx, sy, 0, 0);
				was_off = 0;
				next_move = 1 + ttUSHORT(endPtsOfContours + j * 2);
				++j;
			}
			else {
				if (!(flags & 1)) { // if it's a curve
					if (was_off) // two off-curve control points in a row means interpolate an on-curve midpoint
						stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, (cx + x) >> 1, (cy + y) >> 1, cx, cy);
					cx = x;
					cy = y;
					was_off = 1;
				}
				else {
					if (was_off)
						stbtt_setvertex(&vertices[num_vertices++], STBTT_vcurve, x, y, cx, cy);
					else
						stbtt_setvertex(&vertices[num_vertices++], STBTT_vline, x, y, 0, 0);
					was_off = 0;
				}
			}
		}
		num_vertices = stbtt__close_shape(vertices, num_vertices, was_off, start_off, sx, sy, scx, scy, cx, cy);
	}
	else if (numberOfContours == -1) {
		// Compound shapes.
		int more = 1;
		stbtt_uint8* comp = data + g + 10;
		num_vertices = 0;
		vertices = 0;
		while (more) {
			stbtt_uint16 flags, gidx;
			int comp_num_verts = 0, i;
			stbtt_vertex* comp_verts = 0, *tmp = 0;
			float mtx[6] = { 1,0,0,1,0,0 }, m, n;

			flags = ttSHORT(comp); comp += 2;
			gidx = ttSHORT(comp); comp += 2;

			if (flags & 2) { // XY values
				if (flags & 1) { // shorts
					mtx[4] = ttSHORT(comp); comp += 2;
					mtx[5] = ttSHORT(comp); comp += 2;
				}
				else {
					mtx[4] = ttCHAR(comp); comp += 1;
					mtx[5] = ttCHAR(comp); comp += 1;
				}
			}
			else {
				// @TODO handle matching point
				STBTT_assert(0);
			}
			if (flags & (1 << 3)) { // WE_HAVE_A_SCALE
				mtx[0] = mtx[3] = ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[1] = mtx[2] = 0;
			}
			else if (flags & (1 << 6)) { // WE_HAVE_AN_X_AND_YSCALE
				mtx[0] = ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[1] = mtx[2] = 0;
				mtx[3] = ttSHORT(comp) / 16384.0f; comp += 2;
			}
			else if (flags & (1 << 7)) { // WE_HAVE_A_TWO_BY_TWO
				mtx[0] = ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[1] = ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[2] = ttSHORT(comp) / 16384.0f; comp += 2;
				mtx[3] = ttSHORT(comp) / 16384.0f; comp += 2;
			}

			// GetOffset transformation scales.
			m = (float)STBTT_sqrt(mtx[0] * mtx[0] + mtx[1] * mtx[1]);
			n = (float)STBTT_sqrt(mtx[2] * mtx[2] + mtx[3] * mtx[3]);

			// Get indexed glyph.
			comp_num_verts = stbtt_GetGlyphShape(info, gidx, &comp_verts);
			if (comp_num_verts > 0) {
				// Transform vertices.
				for (i = 0; i < comp_num_verts; ++i) {
					stbtt_vertex* v = &comp_verts[i];
					stbtt_vertex_type x, y;
					x = v->x; y = v->y;
					v->x = (stbtt_vertex_type)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));
					v->y = (stbtt_vertex_type)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));
					x = v->cx; y = v->cy;
					v->cx = (stbtt_vertex_type)(m * (mtx[0] * x + mtx[2] * y + mtx[4]));
					v->cy = (stbtt_vertex_type)(n * (mtx[1] * x + mtx[3] * y + mtx[5]));
				}
				// Append vertices.
				tmp = (stbtt_vertex*)STBTT_malloc((num_vertices + comp_num_verts) * sizeof(stbtt_vertex), info->userdata);
				if (!tmp) {
					if (vertices) STBTT_free(vertices, info->userdata);
					if (comp_verts) STBTT_free(comp_verts, info->userdata);
					return 0;
				}
				if (num_vertices > 0) STBTT_memcpy(tmp, vertices, num_vertices * sizeof(stbtt_vertex));
				STBTT_memcpy(tmp + num_vertices, comp_verts, comp_num_verts * sizeof(stbtt_vertex));
				if (vertices) STBTT_free(vertices, info->userdata);
				vertices = tmp;
				STBTT_free(comp_verts, info->userdata);
				num_vertices += comp_num_verts;
			}
			// More components ?
			more = flags & (1 << 5);
		}
	}
	else if (numberOfContours < 0) {
		// @TODO other compound variations?
		STBTT_assert(0);
	}
	else {
		// numberOfCounters == 0, do nothing
	}

	*pvertices = vertices;
	return num_vertices;
}

typedef struct
{
	int bounds;
	int started;
	float first_x, first_y;
	float x, y;
	stbtt_int32 min_x, max_x, min_y, max_y;

	stbtt_vertex* pvertices;
	int num_vertices;
} stbtt__csctx;

#define STBTT__CSCTX_INIT(bounds) {bounds,0, 0,0, 0,0, 0,0,0,0, NULL, 0}

static void stbtt__track_vertex(stbtt__csctx* c, stbtt_int32 x, stbtt_int32 y)
{
	if (x > c->max_x || !c->started) c->max_x = x;
	if (y > c->max_y || !c->started) c->max_y = y;
	if (x < c->min_x || !c->started) c->min_x = x;
	if (y < c->min_y || !c->started) c->min_y = y;
	c->started = 1;
}

static void stbtt__csctx_v(stbtt__csctx* c, stbtt_uint8 type, stbtt_int32 x, stbtt_int32 y, stbtt_int32 cx, stbtt_int32 cy, stbtt_int32 cx1, stbtt_int32 cy1)
{
	if (c->bounds) {
		stbtt__track_vertex(c, x, y);
		if (type == STBTT_vcubic) {
			stbtt__track_vertex(c, cx, cy);
			stbtt__track_vertex(c, cx1, cy1);
		}
	}
	else {
		stbtt_setvertex(&c->pvertices[c->num_vertices], type, x, y, cx, cy);
		c->pvertices[c->num_vertices].cx1 = (stbtt_int16)cx1;
		c->pvertices[c->num_vertices].cy1 = (stbtt_int16)cy1;
	}
	c->num_vertices++;
}

static void stbtt__csctx_close_shape(stbtt__csctx* ctx)
{
	if (ctx->first_x != ctx->x || ctx->first_y != ctx->y)
		stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->first_x, (int)ctx->first_y, 0, 0, 0, 0);
}

static void stbtt__csctx_rmove_to(stbtt__csctx* ctx, float dx, float dy)
{
	stbtt__csctx_close_shape(ctx);
	ctx->first_x = ctx->x = ctx->x + dx;
	ctx->first_y = ctx->y = ctx->y + dy;
	stbtt__csctx_v(ctx, STBTT_vmove, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rline_to(stbtt__csctx* ctx, float dx, float dy)
{
	ctx->x += dx;
	ctx->y += dy;
	stbtt__csctx_v(ctx, STBTT_vline, (int)ctx->x, (int)ctx->y, 0, 0, 0, 0);
}

static void stbtt__csctx_rccurve_to(stbtt__csctx* ctx, float dx1, float dy1, float dx2, float dy2, float dx3, float dy3)
{
	float cx1 = ctx->x + dx1;
	float cy1 = ctx->y + dy1;
	float cx2 = cx1 + dx2;
	float cy2 = cy1 + dy2;
	ctx->x = cx2 + dx3;
	ctx->y = cy2 + dy3;
	stbtt__csctx_v(ctx, STBTT_vcubic, (int)ctx->x, (int)ctx->y, (int)cx1, (int)cy1, (int)cx2, (int)cy2);
}

static stbtt__buf stbtt__get_subr(stbtt__buf idx, int n)
{
	int count = stbtt__cff_index_count(&idx);
	int bias = 107;
	if (count >= 33900)
		bias = 32768;
	else if (count >= 1240)
		bias = 1131;
	n += bias;
	if (n < 0 || n >= count)
		return stbtt__new_buf(NULL, 0);
	return stbtt__cff_index_get(idx, n);
}

static stbtt__buf stbtt__cid_get_glyph_subrs(const stbtt_fontinfo* info, int glyph_index)
{
	stbtt__buf fdselect = info->fdselect;
	int nranges, start, end, v, fmt, fdselector = -1, i;

	stbtt__buf_seek(&fdselect, 0);
	fmt = stbtt__buf_get8(&fdselect);
	if (fmt == 0) {
		// untested
		stbtt__buf_skip(&fdselect, glyph_index);
		fdselector = stbtt__buf_get8(&fdselect);
	}
	else if (fmt == 3) {
		nranges = stbtt__buf_get16(&fdselect);
		start = stbtt__buf_get16(&fdselect);
		for (i = 0; i < nranges; i++) {
			v = stbtt__buf_get8(&fdselect);
			end = stbtt__buf_get16(&fdselect);
			if (glyph_index >= start && glyph_index < end) {
				fdselector = v;
				break;
			}
			start = end;
		}
	}
	if (fdselector == -1) stbtt__new_buf(NULL, 0);
	return stbtt__get_subrs(info->cff, stbtt__cff_index_get(info->fontdicts, fdselector));
}

static int stbtt__run_charstring(const stbtt_fontinfo* info, int glyph_index, stbtt__csctx* c)
{
	int in_header = 1, maskbits = 0, subr_stack_height = 0, sp = 0, v, i, b0;
	int has_subrs = 0, clear_stack;
	float s[48];
	stbtt__buf subr_stack[10], subrs = info->subrs, b;
	float f;

#define STBTT__CSERR(s) (0)

	// this currently ignores the initial width value, which isn't needed if we have hmtx
	b = stbtt__cff_index_get(info->charstrings, glyph_index);
	while (b.cursor < b.size) {
		i = 0;
		clear_stack = 1;
		b0 = stbtt__buf_get8(&b);
		switch (b0) {
			// @TODO implement hinting
		case 0x13: // hintmask
		case 0x14: // cntrmask
			if (in_header)
				maskbits += (sp / 2); // implicit "vstem"
			in_header = 0;
			stbtt__buf_skip(&b, (maskbits + 7) / 8);
			break;

		case 0x01: // hstem
		case 0x03: // vstem
		case 0x12: // hstemhm
		case 0x17: // vstemhm
			maskbits += (sp / 2);
			break;

		case 0x15: // rmoveto
			in_header = 0;
			if (sp < 2) return STBTT__CSERR("rmoveto stack");
			stbtt__csctx_rmove_to(c, s[sp - 2], s[sp - 1]);
			break;
		case 0x04: // vmoveto
			in_header = 0;
			if (sp < 1) return STBTT__CSERR("vmoveto stack");
			stbtt__csctx_rmove_to(c, 0, s[sp - 1]);
			break;
		case 0x16: // hmoveto
			in_header = 0;
			if (sp < 1) return STBTT__CSERR("hmoveto stack");
			stbtt__csctx_rmove_to(c, s[sp - 1], 0);
			break;

		case 0x05: // rlineto
			if (sp < 2) return STBTT__CSERR("rlineto stack");
			for (; i + 1 < sp; i += 2)
				stbtt__csctx_rline_to(c, s[i], s[i + 1]);
			break;

			// hlineto/vlineto and vhcurveto/hvcurveto alternate horizontal and vertical
			// starting from a different place.

		case 0x07: // vlineto
			if (sp < 1) return STBTT__CSERR("vlineto stack");
			goto vlineto;
		case 0x06: // hlineto
			if (sp < 1) return STBTT__CSERR("hlineto stack");
			for (;;) {
				if (i >= sp) break;
				stbtt__csctx_rline_to(c, s[i], 0);
				i++;
			vlineto:
				if (i >= sp) break;
				stbtt__csctx_rline_to(c, 0, s[i]);
				i++;
			}
			break;

		case 0x1F: // hvcurveto
			if (sp < 4) return STBTT__CSERR("hvcurveto stack");
			goto hvcurveto;
		case 0x1E: // vhcurveto
			if (sp < 4) return STBTT__CSERR("vhcurveto stack");
			for (;;) {
				if (i + 3 >= sp) break;
				stbtt__csctx_rccurve_to(c, 0, s[i], s[i + 1], s[i + 2], s[i + 3], (sp - i == 5) ? s[i + 4] : 0.0f);
				i += 4;
			hvcurveto:
				if (i + 3 >= sp) break;
				stbtt__csctx_rccurve_to(c, s[i], 0, s[i + 1], s[i + 2], (sp - i == 5) ? s[i + 4] : 0.0f, s[i + 3]);
				i += 4;
			}
			break;

		case 0x08: // rrcurveto
			if (sp < 6) return STBTT__CSERR("rcurveline stack");
			for (; i + 5 < sp; i += 6)
				stbtt__csctx_rccurve_to(c, s[i], s[i + 1], s[i + 2], s[i + 3], s[i + 4], s[i + 5]);
			break;

		case 0x18: // rcurveline
			if (sp < 8) return STBTT__CSERR("rcurveline stack");
			for (; i + 5 < sp - 2; i += 6)
				stbtt__csctx_rccurve_to(c, s[i], s[i + 1], s[i + 2], s[i + 3], s[i + 4], s[i + 5]);
			if (i + 1 >= sp) return STBTT__CSERR("rcurveline stack");
			stbtt__csctx_rline_to(c, s[i], s[i + 1]);
			break;

		case 0x19: // rlinecurve
			if (sp < 8) return STBTT__CSERR("rlinecurve stack");
			for (; i + 1 < sp - 6; i += 2)
				stbtt__csctx_rline_to(c, s[i], s[i + 1]);
			if (i + 5 >= sp) return STBTT__CSERR("rlinecurve stack");
			stbtt__csctx_rccurve_to(c, s[i], s[i + 1], s[i + 2], s[i + 3], s[i + 4], s[i + 5]);
			break;

		case 0x1A: // vvcurveto
		case 0x1B: // hhcurveto
			if (sp < 4) return STBTT__CSERR("(vv|hh)curveto stack");
			f = 0.0;
			if (sp & 1) { f = s[i]; i++; }
			for (; i + 3 < sp; i += 4) {
				if (b0 == 0x1B)
					stbtt__csctx_rccurve_to(c, s[i], f, s[i + 1], s[i + 2], s[i + 3], 0.0);
				else
					stbtt__csctx_rccurve_to(c, f, s[i], s[i + 1], s[i + 2], 0.0, s[i + 3]);
				f = 0.0;
			}
			break;

		case 0x0A: // callsubr
			if (!has_subrs) {
				if (info->fdselect.size)
					subrs = stbtt__cid_get_glyph_subrs(info, glyph_index);
				has_subrs = 1;
			}
			// fallthrough
		case 0x1D: // callgsubr
			if (sp < 1) return STBTT__CSERR("call(g|)subr stack");
			v = (int)s[--sp];
			if (subr_stack_height >= 10) return STBTT__CSERR("recursion limit");
			subr_stack[subr_stack_height++] = b;
			b = stbtt__get_subr(b0 == 0x0A ? subrs : info->gsubrs, v);
			if (b.size == 0) return STBTT__CSERR("subr not found");
			b.cursor = 0;
			clear_stack = 0;
			break;

		case 0x0B: // return
			if (subr_stack_height <= 0) return STBTT__CSERR("return outside subr");
			b = subr_stack[--subr_stack_height];
			clear_stack = 0;
			break;

		case 0x0E: // endchar
			stbtt__csctx_close_shape(c);
			return 1;

		case 0x0C: { // two-uint8_t escape
			float dx1, dx2, dx3, dx4, dx5, dx6, dy1, dy2, dy3, dy4, dy5, dy6;
			float dx, dy;
			int b1 = stbtt__buf_get8(&b);
			switch (b1) {
				// @TODO These "flex" implementations ignore the flex-depth and resolution,
				// and always draw beziers.
			case 0x22: // hflex
				if (sp < 7) return STBTT__CSERR("hflex stack");
				dx1 = s[0];
				dx2 = s[1];
				dy2 = s[2];
				dx3 = s[3];
				dx4 = s[4];
				dx5 = s[5];
				dx6 = s[6];
				stbtt__csctx_rccurve_to(c, dx1, 0, dx2, dy2, dx3, 0);
				stbtt__csctx_rccurve_to(c, dx4, 0, dx5, -dy2, dx6, 0);
				break;

			case 0x23: // flex
				if (sp < 13) return STBTT__CSERR("flex stack");
				dx1 = s[0];
				dy1 = s[1];
				dx2 = s[2];
				dy2 = s[3];
				dx3 = s[4];
				dy3 = s[5];
				dx4 = s[6];
				dy4 = s[7];
				dx5 = s[8];
				dy5 = s[9];
				dx6 = s[10];
				dy6 = s[11];
				//fd is s[12]
				stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
				stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
				break;

			case 0x24: // hflex1
				if (sp < 9) return STBTT__CSERR("hflex1 stack");
				dx1 = s[0];
				dy1 = s[1];
				dx2 = s[2];
				dy2 = s[3];
				dx3 = s[4];
				dx4 = s[5];
				dx5 = s[6];
				dy5 = s[7];
				dx6 = s[8];
				stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, 0);
				stbtt__csctx_rccurve_to(c, dx4, 0, dx5, dy5, dx6, -(dy1 + dy2 + dy5));
				break;

			case 0x25: // flex1
				if (sp < 11) return STBTT__CSERR("flex1 stack");
				dx1 = s[0];
				dy1 = s[1];
				dx2 = s[2];
				dy2 = s[3];
				dx3 = s[4];
				dy3 = s[5];
				dx4 = s[6];
				dy4 = s[7];
				dx5 = s[8];
				dy5 = s[9];
				dx6 = dy6 = s[10];
				dx = dx1 + dx2 + dx3 + dx4 + dx5;
				dy = dy1 + dy2 + dy3 + dy4 + dy5;
				if (STBTT_fabs(dx) > STBTT_fabs(dy))
					dy6 = -dy;
				else
					dx6 = -dx;
				stbtt__csctx_rccurve_to(c, dx1, dy1, dx2, dy2, dx3, dy3);
				stbtt__csctx_rccurve_to(c, dx4, dy4, dx5, dy5, dx6, dy6);
				break;

			default:
				return STBTT__CSERR("unimplemented");
			}
		} break;

		default:
			if (b0 != 255 && b0 != 28 && (b0 < 32 || b0 > 254))
				return STBTT__CSERR("reserved operator");

			// push immediate
			if (b0 == 255) {
				f = (float)stbtt__buf_get32(&b) / 0x10000;
			}
			else {
				stbtt__buf_skip(&b, -1);
				f = (float)(stbtt_int16)stbtt__cff_int(&b);
			}
			if (sp >= 48) return STBTT__CSERR("push stack overflow");
			s[sp++] = f;
			clear_stack = 0;
			break;
		}
		if (clear_stack) sp = 0;
	}
	return STBTT__CSERR("no endchar");

#undef STBTT__CSERR
}

static int stbtt__GetGlyphShapeT2(const stbtt_fontinfo* info, int glyph_index, stbtt_vertex** pvertices)
{
	// runs the charstring twice, once to count and once to output (to avoid realloc)
	stbtt__csctx count_ctx = STBTT__CSCTX_INIT(1);
	stbtt__csctx output_ctx = STBTT__CSCTX_INIT(0);
	if (stbtt__run_charstring(info, glyph_index, &count_ctx)) {
		*pvertices = (stbtt_vertex*)STBTT_malloc(count_ctx.num_vertices * sizeof(stbtt_vertex), info->userdata);
		output_ctx.pvertices = *pvertices;
		if (stbtt__run_charstring(info, glyph_index, &output_ctx)) {
			STBTT_assert(output_ctx.num_vertices == count_ctx.num_vertices);
			return output_ctx.num_vertices;
		}
	}
	*pvertices = NULL;
	return 0;
}

static int stbtt__GetGlyphInfoT2(const stbtt_fontinfo* info, int glyph_index, int* x0, int* y0, int* x1, int* y1)
{
	stbtt__csctx c = STBTT__CSCTX_INIT(1);
	int r = stbtt__run_charstring(info, glyph_index, &c);
	if (x0) {
		*x0 = r ? c.min_x : 0;
		*y0 = r ? c.min_y : 0;
		*x1 = r ? c.max_x : 0;
		*y1 = r ? c.max_y : 0;
	}
	return r ? c.num_vertices : 0;
}

STBTT_DEF int stbtt_GetGlyphShape(const stbtt_fontinfo* info, int glyph_index, stbtt_vertex** pvertices)
{
	if (!info->cff.size)
		return stbtt__GetGlyphShapeTT(info, glyph_index, pvertices);
	else
		return stbtt__GetGlyphShapeT2(info, glyph_index, pvertices);
}

STBTT_DEF void stbtt_GetGlyphHMetrics(const stbtt_fontinfo* info, int glyph_index, int* advanceWidth, int* leftSideBearing)
{
	stbtt_uint16 numOfLongHorMetrics = ttUSHORT(info->data + info->hhea + 34);
	if (glyph_index < numOfLongHorMetrics) {
		if (advanceWidth)* advanceWidth = ttSHORT(info->data + info->hmtx + 4 * glyph_index);
		if (leftSideBearing)* leftSideBearing = ttSHORT(info->data + info->hmtx + 4 * glyph_index + 2);
	}
	else {
		if (advanceWidth)* advanceWidth = ttSHORT(info->data + info->hmtx + 4 * (numOfLongHorMetrics - 1));
		if (leftSideBearing)* leftSideBearing = ttSHORT(info->data + info->hmtx + 4 * numOfLongHorMetrics + 2 * (glyph_index - numOfLongHorMetrics));
	}
}

STBTT_DEF int  stbtt_GetGlyphKernAdvance(const stbtt_fontinfo* info, int glyph1, int glyph2)
{
	stbtt_uint8* data = info->data + info->kern;
	stbtt_uint32 needle, straw;
	int l, r, m;

	// we only look at the first table. it must be 'horizontal' and format 0.
	if (!info->kern)
		return 0;
	if (ttUSHORT(data + 2) < 1) // number of tables, need at least 1
		return 0;
	if (ttUSHORT(data + 8) != 1) // horizontal flag must be Set in format
		return 0;

	l = 0;
	r = ttUSHORT(data + 10) - 1;
	needle = glyph1 << 16 | glyph2;
	while (l <= r) {
		m = (l + r) >> 1;
		straw = ttULONG(data + 18 + (m * 6)); // note: unaligned read
		if (needle < straw)
			r = m - 1;
		else if (needle > straw)
			l = m + 1;
		else
			return ttSHORT(data + 22 + (m * 6));
	}
	return 0;
}

STBTT_DEF int  stbtt_GetCodepointKernAdvance(const stbtt_fontinfo* info, int ch1, int ch2)
{
	if (!info->kern) // if no kerning table, don't waste time looking up both codepoint->glyphs
		return 0;
	return stbtt_GetGlyphKernAdvance(info, stbtt_FindGlyphIndex(info, ch1), stbtt_FindGlyphIndex(info, ch2));
}

STBTT_DEF void stbtt_GetCodepointHMetrics(const stbtt_fontinfo* info, int codepoint, int* advanceWidth, int* leftSideBearing)
{
	stbtt_GetGlyphHMetrics(info, stbtt_FindGlyphIndex(info, codepoint), advanceWidth, leftSideBearing);
}

STBTT_DEF void stbtt_GetFontVMetrics(const stbtt_fontinfo* info, int* ascent, int* descent, int* lineGap)
{
	if (ascent)* ascent = ttSHORT(info->data + info->hhea + 4);
	if (descent)* descent = ttSHORT(info->data + info->hhea + 6);
	if (lineGap)* lineGap = ttSHORT(info->data + info->hhea + 8);
}

STBTT_DEF void stbtt_GetFontBoundingBox(const stbtt_fontinfo* info, int* x0, int* y0, int* x1, int* y1)
{
	*x0 = ttSHORT(info->data + info->head + 36);
	*y0 = ttSHORT(info->data + info->head + 38);
	*x1 = ttSHORT(info->data + info->head + 40);
	*y1 = ttSHORT(info->data + info->head + 42);
}

STBTT_DEF float stbtt_ScaleForPixelHeight(const stbtt_fontinfo* info, float height)
{
	int fheight = ttSHORT(info->data + info->hhea + 4) - ttSHORT(info->data + info->hhea + 6);
	return (float)height / fheight;
}

STBTT_DEF float stbtt_ScaleForMappingEmToPixels(const stbtt_fontinfo* info, float pixels)
{
	int unitsPerEm = ttUSHORT(info->data + info->head + 18);
	return pixels / unitsPerEm;
}

STBTT_DEF void stbtt_FreeShape(const stbtt_fontinfo* info, stbtt_vertex* v)
{
	STBTT_free(v, info->userdata);
}

//////////////////////////////////////////////////////////////////////////////
//
// antialiasing software rasterizer
//

STBTT_DEF void stbtt_GetGlyphBitmapBoxSubpixel(const stbtt_fontinfo* font, int glyph, float scale_x, float scale_y, float shift_x, float shift_y, int* ix0, int* iy0, int* ix1, int* iy1)
{
	int x0 = 0, y0 = 0, x1, y1; // =0 suppresses compiler warning
	if (!stbtt_GetGlyphBox(font, glyph, &x0, &y0, &x1, &y1)) {
		// e.g. space character
		if (ix0)* ix0 = 0;
		if (iy0)* iy0 = 0;
		if (ix1)* ix1 = 0;
		if (iy1)* iy1 = 0;
	}
	else {
		// move to integral bboxes (treating pixels as little squares, what pixels Get touched)?
		if (ix0)* ix0 = STBTT_ifloor(x0 * scale_x + shift_x);
		if (iy0)* iy0 = STBTT_ifloor(-y1 * scale_y + shift_y);
		if (ix1)* ix1 = STBTT_iceil(x1 * scale_x + shift_x);
		if (iy1)* iy1 = STBTT_iceil(-y0 * scale_y + shift_y);
	}
}

STBTT_DEF void stbtt_GetGlyphBitmapBox(const stbtt_fontinfo* font, int glyph, float scale_x, float scale_y, int* ix0, int* iy0, int* ix1, int* iy1)
{
	stbtt_GetGlyphBitmapBoxSubpixel(font, glyph, scale_x, scale_y, 0.0f, 0.0f, ix0, iy0, ix1, iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBoxSubpixel(const stbtt_fontinfo* font, int codepoint, float scale_x, float scale_y, float shift_x, float shift_y, int* ix0, int* iy0, int* ix1, int* iy1)
{
	stbtt_GetGlyphBitmapBoxSubpixel(font, stbtt_FindGlyphIndex(font, codepoint), scale_x, scale_y, shift_x, shift_y, ix0, iy0, ix1, iy1);
}

STBTT_DEF void stbtt_GetCodepointBitmapBox(const stbtt_fontinfo* font, int codepoint, float scale_x, float scale_y, int* ix0, int* iy0, int* ix1, int* iy1)
{
	stbtt_GetCodepointBitmapBoxSubpixel(font, codepoint, scale_x, scale_y, 0.0f, 0.0f, ix0, iy0, ix1, iy1);
}

//////////////////////////////////////////////////////////////////////////////
//
//  Rasterizer

typedef struct stbtt__hheap_chunk
{
	struct stbtt__hheap_chunk* next;
} stbtt__hheap_chunk;

typedef struct stbtt__hheap
{
	struct stbtt__hheap_chunk* head;
	void* first_free;
	int    num_remaining_in_head_chunk;
} stbtt__hheap;

static void* stbtt__hheap_alloc(stbtt__hheap* hh, size_t size, void* userdata)
{
	if (hh->first_free) {
		void* p = hh->first_free;
		hh->first_free = *(void**)p;
		return p;
	}
	else {
		if (hh->num_remaining_in_head_chunk == 0) {
			int count = (size < 32 ? 2000 : size < 128 ? 800 : 100);
			stbtt__hheap_chunk* c = (stbtt__hheap_chunk*)STBTT_malloc(sizeof(stbtt__hheap_chunk) + size * count, userdata);
			if (c == NULL)
				return NULL;
			c->next = hh->head;
			hh->head = c;
			hh->num_remaining_in_head_chunk = count;
		}
		--hh->num_remaining_in_head_chunk;
		return (char*)(hh->head) + size * hh->num_remaining_in_head_chunk;
	}
}

static void stbtt__hheap_free(stbtt__hheap* hh, void* p)
{
	*(void**)p = hh->first_free;
	hh->first_free = p;
}

static void stbtt__hheap_cleanup(stbtt__hheap* hh, void* userdata)
{
	stbtt__hheap_chunk* c = hh->head;
	while (c) {
		stbtt__hheap_chunk* n = c->next;
		STBTT_free(c, userdata);
		c = n;
	}
}

typedef struct stbtt__edge {
	float x0, y0, x1, y1;
	int invert;
} stbtt__edge;

typedef struct stbtt__active_edge
{
	struct stbtt__active_edge* next;
#if STBTT_RASTERIZER_VERSION==1
	int x, dx;
	float ey;
	int direction;
#elif STBTT_RASTERIZER_VERSION==2
	float fx, fdx, fdy;
	float direction;
	float sy;
	float ey;
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
} stbtt__active_edge;

#if STBTT_RASTERIZER_VERSION == 1
#define STBTT_FIXSHIFT   10
#define STBTT_FIX        (1 << STBTT_FIXSHIFT)
#define STBTT_FIXMASK    (STBTT_FIX-1)

static stbtt__active_edge * stbtt__new_active(stbtt__hheap * hh, stbtt__edge * e, int off_x, float start_point, void* userdata)
{
	stbtt__active_edge* z = (stbtt__active_edge*)stbtt__hheap_alloc(hh, sizeof(*z), userdata);
	float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
	STBTT_assert(z != NULL);
	if (!z) return z;

	// round dx down to avoid overshooting
	if (dxdy < 0)
		z->dx = -STBTT_ifloor(STBTT_FIX * -dxdy);
	else
		z->dx = STBTT_ifloor(STBTT_FIX * dxdy);

	z->x = STBTT_ifloor(STBTT_FIX * e->x0 + z->dx * (start_point - e->y0)); // use z->dx so when we offset later it's by the same amount
	z->x -= off_x * STBTT_FIX;

	z->ey = e->y1;
	z->next = 0;
	z->direction = e->invert ? 1 : -1;
	return z;
}
#elif STBTT_RASTERIZER_VERSION == 2
static stbtt__active_edge * stbtt__new_active(stbtt__hheap * hh, stbtt__edge * e, int off_x, float start_point, void* userdata)
{
	stbtt__active_edge* z = (stbtt__active_edge*)stbtt__hheap_alloc(hh, sizeof(*z), userdata);
	float dxdy = (e->x1 - e->x0) / (e->y1 - e->y0);
	STBTT_assert(z != NULL);
	//STBTT_assert(e->y0 <= start_point);
	if (!z) return z;
	z->fdx = dxdy;
	z->fdy = dxdy != 0.0f ? (1.0f / dxdy) : 0.0f;
	z->fx = e->x0 + dxdy * (start_point - e->y0);
	z->fx -= off_x;
	z->direction = e->invert ? 1.0f : -1.0f;
	z->sy = e->y0;
	z->ey = e->y1;
	z->next = 0;
	return z;
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#if STBTT_RASTERIZER_VERSION == 1
// note: this routine clips fills that extend off the edges... ideally this
// wouldn't happen, but it could happen if the truetype glyph bounding boxes
// are wrong, or if the user supplies a too-small bitmap
static void stbtt__fill_active_edges(unsigned char* scanline, int len, stbtt__active_edge * e, int max_weight)
{
	// non-zero winding fill
	int x0 = 0, w = 0;

	while (e) {
		if (w == 0) {
			// if we're currently at zero, we need to record the edge start point
			x0 = e->x; w += e->direction;
		}
		else {
			int x1 = e->x; w += e->direction;
			// if we went to zero, we need to draw
			if (w == 0) {
				int i = x0 >> STBTT_FIXSHIFT;
				int j = x1 >> STBTT_FIXSHIFT;

				if (i < len && j >= 0) {
					if (i == j) {
						// x0,x1 are the same pixel, so compute combined coverage
						scanline[i] = scanline[i] + (stbtt_uint8)((x1 - x0) * max_weight >> STBTT_FIXSHIFT);
					}
					else {
						if (i >= 0) // add antialiasing for x0
							scanline[i] = scanline[i] + (stbtt_uint8)(((STBTT_FIX - (x0 & STBTT_FIXMASK)) * max_weight) >> STBTT_FIXSHIFT);
						else
							i = -1; // clip

						if (j < len) // add antialiasing for x1
							scanline[j] = scanline[j] + (stbtt_uint8)(((x1 & STBTT_FIXMASK) * max_weight) >> STBTT_FIXSHIFT);
						else
							j = len; // clip

						for (++i; i < j; ++i) // fill pixels between x0 and x1
							scanline[i] = scanline[i] + (stbtt_uint8)max_weight;
					}
				}
			}
		}

		e = e->next;
	}
}

static void stbtt__rasterize_sorted_edges(stbtt__bitmap* result, stbtt__edge* e, int n, int vsubsample, int off_x, int off_y, void* userdata)
{
	stbtt__hheap hh = { 0, 0, 0 };
	stbtt__active_edge* active = NULL;
	int y, j = 0;
	int max_weight = (255 / vsubsample);  // weight per vertical scanline
	int s; // vertical subsample index
	unsigned char scanline_data[512], * scanline;

	if (result->w > 512)
		scanline = (unsigned char*)STBTT_malloc(result->w, userdata);
	else
		scanline = scanline_data;

	y = off_y * vsubsample;
	e[n].y0 = (off_y + result->h) * (float)vsubsample + 1;

	while (j < result->h) {
		STBTT_memset(scanline, 0, result->w);
		for (s = 0; s < vsubsample; ++s) {
			// GetOffset center of pixel for this scanline
			float scan_y = y + 0.5f;
			stbtt__active_edge** step = &active;

			// update all active edges;
			// remove all active edges that terminate before the center of this scanline
			while (*step) {
				stbtt__active_edge* z = *step;
				if (z->ey <= scan_y) {
					*step = z->next; // delete from list
					STBTT_assert(z->direction);
					z->direction = 0;
					stbtt__hheap_free(&hh, z);
				}
				else {
					z->x += z->dx; // advance to position for current scanline
					step = &((*step)->next); // advance through list
				}
			}

			// resort the list if needed
			for (;;) {
				int changed = 0;
				step = &active;
				while (*step && (*step)->next) {
					if ((*step)->x > (*step)->next->x) {
						stbtt__active_edge* t = *step;
						stbtt__active_edge* q = t->next;

						t->next = q->next;
						q->next = t;
						*step = q;
						changed = 1;
					}
					step = &(*step)->next;
				}
				if (!changed) break;
			}

			// insert all edges that start before the center of this scanline -- omit ones that also end on this scanline
			while (e->y0 <= scan_y) {
				if (e->y1 > scan_y) {
					stbtt__active_edge* z = stbtt__new_active(&hh, e, off_x, scan_y, userdata);
					if (z != NULL) {
						// GetOffset insertion point
						if (active == NULL)
							active = z;
						else if (z->x < active->x) {
							// insert at front
							z->next = active;
							active = z;
						}
						else {
							// GetOffset thing to insert AFTER
							stbtt__active_edge* p = active;
							while (p->next && p->next->x < z->x)
								p = p->next;
							// at this point, p->next->x is NOT < z->x
							z->next = p->next;
							p->next = z;
						}
					}
				}
				++e;
			}

			// now process all active edges in XOR fashion
			if (active)
				stbtt__fill_active_edges(scanline, result->w, active, max_weight);

			++y;
		}
		STBTT_memcpy(result->pixels + j * result->stride, scanline, result->w);
		++j;
	}

	stbtt__hheap_cleanup(&hh, userdata);

	if (scanline != scanline_data)
		STBTT_free(scanline, userdata);
}

#elif STBTT_RASTERIZER_VERSION == 2

// the edge passed in here does not cross the vertical line at x or the vertical line at x+1
// (i.e. it has already been clipped to those)
static void stbtt__handle_clipped_edge(float* scanline, int x, stbtt__active_edge * e, float x0, float y0, float x1, float y1)
{
	if (y0 == y1) return;
	STBTT_assert(y0 < y1);
	STBTT_assert(e->sy <= e->ey);
	if (y0 > e->ey) return;
	if (y1 < e->sy) return;
	if (y0 < e->sy) {
		x0 += (x1 - x0) * (e->sy - y0) / (y1 - y0);
		y0 = e->sy;
	}
	if (y1 > e->ey) {
		x1 += (x1 - x0) * (e->ey - y1) / (y1 - y0);
		y1 = e->ey;
	}

	if (x0 == x)
		STBTT_assert(x1 <= x + 1);
	else if (x0 == x + 1)
		STBTT_assert(x1 >= x);
	else if (x0 <= x)
		STBTT_assert(x1 <= x);
	else if (x0 >= x + 1)
		STBTT_assert(x1 >= x + 1);
	else
		STBTT_assert(x1 >= x && x1 <= x + 1);

	if (x0 <= x && x1 <= x)
		scanline[x] += e->direction * (y1 - y0);
	else if (x0 >= x + 1 && x1 >= x + 1)
		;
	else {
		STBTT_assert(x0 >= x && x0 <= x + 1 && x1 >= x && x1 <= x + 1);
		scanline[x] += e->direction * (y1 - y0) * (1 - ((x0 - x) + (x1 - x)) / 2); // coverage = 1 - average x position
	}
}

static void stbtt__fill_active_edges_new(float* scanline, float* scanline_fill, int len, stbtt__active_edge* e, float y_top)
{
	float y_bottom = y_top + 1;

	while (e) {
		// brute force every pixel

		// compute intersection points with top & bottom
		STBTT_assert(e->ey >= y_top);

		if (e->fdx == 0) {
			float x0 = e->fx;
			if (x0 < len) {
				if (x0 >= 0) {
					stbtt__handle_clipped_edge(scanline, (int)x0, e, x0, y_top, x0, y_bottom);
					stbtt__handle_clipped_edge(scanline_fill - 1, (int)x0 + 1, e, x0, y_top, x0, y_bottom);
				}
				else {
					stbtt__handle_clipped_edge(scanline_fill - 1, 0, e, x0, y_top, x0, y_bottom);
				}
			}
		}
		else {
			float x0 = e->fx;
			float dx = e->fdx;
			float xb = x0 + dx;
			float x_top, x_bottom;
			float sy0, sy1;
			float dy = e->fdy;
			STBTT_assert(e->sy <= y_bottom && e->ey >= y_top);

			// compute endpoints of line segment clipped to this scanline (if the
			// line segment starts on this scanline. x0 is the intersection of the
			// line with y_top, but that may be off the line segment.
			if (e->sy > y_top) {
				x_top = x0 + dx * (e->sy - y_top);
				sy0 = e->sy;
			}
			else {
				x_top = x0;
				sy0 = y_top;
			}
			if (e->ey < y_bottom) {
				x_bottom = x0 + dx * (e->ey - y_top);
				sy1 = e->ey;
			}
			else {
				x_bottom = xb;
				sy1 = y_bottom;
			}

			if (x_top >= 0 && x_bottom >= 0 && x_top < len && x_bottom < len) {
				// from here on, we don't have to range check x values

				if ((int)x_top == (int)x_bottom) {
					float height;
					// simple case, only spans one pixel
					int x = (int)x_top;
					height = sy1 - sy0;
					STBTT_assert(x >= 0 && x < len);
					scanline[x] += e->direction * (1 - ((x_top - x) + (x_bottom - x)) / 2) * height;
					scanline_fill[x] += e->direction * height; // everything right of this pixel is filled
				}
				else {
					int x, x1, x2;
					float y_crossing, step, sign, area;
					// covers 2+ pixels
					if (x_top > x_bottom) {
						// flip scanline vertically; signed area is the same
						float t;
						sy0 = y_bottom - (sy0 - y_top);
						sy1 = y_bottom - (sy1 - y_top);
						t = sy0, sy0 = sy1, sy1 = t;
						t = x_bottom, x_bottom = x_top, x_top = t;
						dx = -dx;
						dy = -dy;
						t = x0, x0 = xb, xb = t;
					}

					x1 = (int)x_top;
					x2 = (int)x_bottom;
					// compute intersection with y axis at x1+1
					y_crossing = (x1 + 1 - x0) * dy + y_top;

					sign = e->direction;
					// area of the rectangle covered from y0..y_crossing
					area = sign * (y_crossing - sy0);
					// area of the triangle (x_top,y0), (x+1,y0), (x+1,y_crossing)
					scanline[x1] += area * (1 - ((x_top - x1) + (x1 + 1 - x1)) / 2);

					step = sign * dy;
					for (x = x1 + 1; x < x2; ++x) {
						scanline[x] += area + step / 2;
						area += step;
					}
					y_crossing += dy * (x2 - (x1 + 1));

					STBTT_assert(STBTT_fabs(area) <= 1.01f);

					scanline[x2] += area + sign * (1 - ((x2 - x2) + (x_bottom - x2)) / 2) * (sy1 - y_crossing);

					scanline_fill[x2] += sign * (sy1 - sy0);
				}
			}
			else {
				// if edge goes outside of box we're drawing, we require
				// clipping logic. since this does not match the intended use
				// of this library, we use a different, very slow brute
				// force implementation
				int x;
				for (x = 0; x < len; ++x) {
					// cases:
					//
					// there can be up to two intersections with the pixel. any intersection
					// with left or right edges can be handled by splitting into two (or three)
					// regions. intersections with top & bottom do not necessitate case-wise logic.
					//
					// the old way of doing this found the intersections with the left & right edges,
					// then used some simple logic to produce up to three segments in sorted order
					// from top-to-bottom. however, this had a problem: if an x edge was epsilon
					// across the x border, then the corresponding y position might not be distinct
					// from the other y segment, and it might ignored as an empty segment. to avoid
					// that, we need to explicitly produce segments based on x positions.

					// rename variables to clear pairs
					float y0 = y_top;
					float x1 = (float)(x);
					float x2 = (float)(x + 1);
					float x3 = xb;
					float y3 = y_bottom;
					float y1, y2;

					// x = e->x + e->dx * (y-y_top)
					// (y-y_top) = (x - e->x) / e->dx
					// y = (x - e->x) / e->dx + y_top
					y1 = (x - x0) / dx + y_top;
					y2 = (x + 1 - x0) / dx + y_top;

					if (x0 < x1 && x3 > x2) {         // three segments descending down-right
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
						stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x2, y2);
						stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
					}
					else if (x3 < x1 && x0 > x2) {  // three segments descending down-left
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);
						stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x1, y1);
						stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
					}
					else if (x0 < x1 && x3 > x1) {  // two segments across x, down-right
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
						stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
					}
					else if (x3 < x1 && x0 > x1) {  // two segments across x, down-left
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x1, y1);
						stbtt__handle_clipped_edge(scanline, x, e, x1, y1, x3, y3);
					}
					else if (x0 < x2 && x3 > x2) {  // two segments across x+1, down-right
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);
						stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
					}
					else if (x3 < x2 && x0 > x2) {  // two segments across x+1, down-left
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x2, y2);
						stbtt__handle_clipped_edge(scanline, x, e, x2, y2, x3, y3);
					}
					else {  // one segment
						stbtt__handle_clipped_edge(scanline, x, e, x0, y0, x3, y3);
					}
				}
			}
		}
		e = e->next;
	}
}

// directly AA rasterize edges w/o supersampling
static void stbtt__rasterize_sorted_edges(stbtt__bitmap* result, stbtt__edge* e, int n, int vsubsample, int off_x, int off_y, void* userdata)
{
	stbtt__hheap hh = { 0, 0, 0 };
	stbtt__active_edge* active = NULL;
	int y, j = 0, i;
	float scanline_data[129], * scanline, * scanline2;

	STBTT__NOTUSED(vsubsample);

	if (result->w > 64)
		scanline = (float*)STBTT_malloc((result->w * 2 + 1) * sizeof(float), userdata);
	else
		scanline = scanline_data;

	scanline2 = scanline + result->w;

	y = off_y;
	e[n].y0 = (float)(off_y + result->h) + 1;

	while (j < result->h) {
		// GetOffset center of pixel for this scanline
		float scan_y_top = y + 0.0f;
		float scan_y_bottom = y + 1.0f;
		stbtt__active_edge** step = &active;

		STBTT_memset(scanline, 0, result->w * sizeof(scanline[0]));
		STBTT_memset(scanline2, 0, (result->w + 1) * sizeof(scanline[0]));

		// update all active edges;
		// remove all active edges that terminate before the top of this scanline
		while (*step) {
			stbtt__active_edge* z = *step;
			if (z->ey <= scan_y_top) {
				*step = z->next; // delete from list
				STBTT_assert(z->direction);
				z->direction = 0;
				stbtt__hheap_free(&hh, z);
			}
			else {
				step = &((*step)->next); // advance through list
			}
		}

		// insert all edges that start before the bottom of this scanline
		while (e->y0 <= scan_y_bottom) {
			if (e->y0 != e->y1) {
				stbtt__active_edge* z = stbtt__new_active(&hh, e, off_x, scan_y_top, userdata);
				if (z != NULL) {
					STBTT_assert(z->ey >= scan_y_top);
					// insert at front
					z->next = active;
					active = z;
				}
			}
			++e;
		}

		// now process all active edges
		if (active)
			stbtt__fill_active_edges_new(scanline, scanline2 + 1, result->w, active, scan_y_top);

		{
			float sum = 0;
			for (i = 0; i < result->w; ++i) {
				float k;
				int m;
				sum += scanline2[i];
				k = scanline[i] + sum;
				k = (float)STBTT_fabs(k) * 255 + 0.5f;
				m = (int)k;
				if (m > 255) m = 255;
				result->pixels[j * result->stride + i] = (unsigned char)m;
			}
		}
		// advance all the edges
		step = &active;
		while (*step) {
			stbtt__active_edge* z = *step;
			z->fx += z->fdx; // advance to position for current scanline
			step = &((*step)->next); // advance through list
		}

		++y;
		++j;
	}

	stbtt__hheap_cleanup(&hh, userdata);

	if (scanline != scanline_data)
		STBTT_free(scanline, userdata);
}
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif

#define STBTT__COMPARE(a,b)  ((a)->y0 < (b)->y0)

static void stbtt__sort_edges_ins_sort(stbtt__edge* p, int n)
{
	int i, j;
	for (i = 1; i < n; ++i) {
		stbtt__edge t = p[i], * a = &t;
		j = i;
		while (j > 0) {
			stbtt__edge* b = &p[j - 1];
			int c = STBTT__COMPARE(a, b);
			if (!c) break;
			p[j] = p[j - 1];
			--j;
		}
		if (i != j)
			p[j] = t;
	}
}

static void stbtt__sort_edges_quicksort(stbtt__edge* p, int n)
{
	/* threshhold for transitioning to insertion sort */
	while (n > 12) {
		stbtt__edge t;
		int c01, c12, c, m, i, j;

		/* compute median of three */
		m = n >> 1;
		c01 = STBTT__COMPARE(&p[0], &p[m]);
		c12 = STBTT__COMPARE(&p[m], &p[n - 1]);
		/* if 0 >= mid >= end, or 0 < mid < end, then use mid */
		if (c01 != c12) {
			/* otherwise, we'll need to swap something else to middle */
			int z;
			c = STBTT__COMPARE(&p[0], &p[n - 1]);
			/* 0>mid && mid<n:  0>n => n; 0<n => 0 */
			/* 0<mid && mid>n:  0>n => 0; 0<n => n */
			z = (c == c12) ? 0 : n - 1;
			t = p[z];
			p[z] = p[m];
			p[m] = t;
		}
		/* now p[m] is the median-of-three */
		/* swap it to the beginning so it won't move around */
		t = p[0];
		p[0] = p[m];
		p[m] = t;

		/* partition loop */
		i = 1;
		j = n - 1;
		for (;;) {
			/* handling of equality is crucial here */
			/* for sentinels & efficiency with duplicates */
			for (;; ++i) {
				if (!STBTT__COMPARE(&p[i], &p[0])) break;
			}
			for (;; --j) {
				if (!STBTT__COMPARE(&p[0], &p[j])) break;
			}
			/* make sure we haven't crossed */
			if (i >= j) break;
			t = p[i];
			p[i] = p[j];
			p[j] = t;

			++i;
			--j;
		}
		/* recurse on smaller side, iterate on larger */
		if (j < (n - i)) {
			stbtt__sort_edges_quicksort(p, j);
			p = p + i;
			n = n - i;
		}
		else {
			stbtt__sort_edges_quicksort(p + i, n - i);
			n = j;
		}
	}
}

static void stbtt__sort_edges(stbtt__edge* p, int n)
{
	stbtt__sort_edges_quicksort(p, n);
	stbtt__sort_edges_ins_sort(p, n);
}

typedef struct
{
	float x, y;
} stbtt__point;

static void stbtt__rasterize(stbtt__bitmap* result, stbtt__point* pts, int* wcount, int windings, float scale_x, float scale_y, float shift_x, float shift_y, int off_x, int off_y, int invert, void* userdata)
{
	float y_scale_inv = invert ? -scale_y : scale_y;
	stbtt__edge* e;
	int n, i, j, k, m;
#if STBTT_RASTERIZER_VERSION == 1
	int vsubsample = result->h < 8 ? 15 : 5;
#elif STBTT_RASTERIZER_VERSION == 2
	int vsubsample = 1;
#else
#error "Unrecognized value of STBTT_RASTERIZER_VERSION"
#endif
	// vsubsample should divide 255 evenly; otherwise we won't reach full opacity

	// now we have to blow out the windings into explicit edge lists
	n = 0;
	for (i = 0; i < windings; ++i)
		n += wcount[i];

	e = (stbtt__edge*)STBTT_malloc(sizeof(*e) * (n + 1), userdata); // add an extra one as a sentinel
	if (e == 0) return;
	n = 0;

	m = 0;
	for (i = 0; i < windings; ++i) {
		stbtt__point* p = pts + m;
		m += wcount[i];
		j = wcount[i] - 1;
		for (k = 0; k < wcount[i]; j = k++) {
			int a = k, b = j;
			// skip the edge if horizontal
			if (p[j].y == p[k].y)
				continue;
			// add edge from j to k to the list
			e[n].invert = 0;
			if (invert ? p[j].y > p[k].y : p[j].y < p[k].y) {
				e[n].invert = 1;
				a = j, b = k;
			}
			e[n].x0 = p[a].x * scale_x + shift_x;
			e[n].y0 = (p[a].y * y_scale_inv + shift_y) * vsubsample;
			e[n].x1 = p[b].x * scale_x + shift_x;
			e[n].y1 = (p[b].y * y_scale_inv + shift_y) * vsubsample;
			++n;
		}
	}

	// now sort the edges by their highest point (should snap to integer, and then by x)
	//STBTT_sort(e, n, sizeof(e[0]), stbtt__edge_compare);
	stbtt__sort_edges(e, n);

	// now, traverse the scanlines and GetOffset the intersections on each scanline, use xor winding rule
	stbtt__rasterize_sorted_edges(result, e, n, vsubsample, off_x, off_y, userdata);

	STBTT_free(e, userdata);
}

static void stbtt__add_point(stbtt__point* points, int n, float x, float y)
{
	if (!points) return; // during first pass, it's unallocated
	points[n].x = x;
	points[n].y = y;
}

// tesselate until threshhold p is happy... @TODO warped to compensate for non-linear stretching
static int stbtt__tesselate_curve(stbtt__point* points, int* num_points, float x0, float y0, float x1, float y1, float x2, float y2, float objspace_flatness_squared, int n)
{
	// midpoint
	float mx = (x0 + 2 * x1 + x2) / 4;
	float my = (y0 + 2 * y1 + y2) / 4;
	// versus directly drawn line
	float dx = (x0 + x2) / 2 - mx;
	float dy = (y0 + y2) / 2 - my;
	if (n > 16) // 65536 segments on one curve better be enough!
		return 1;
	if (dx * dx + dy * dy > objspace_flatness_squared) { // half-pixel error allowed... need to be smaller if AA
		stbtt__tesselate_curve(points, num_points, x0, y0, (x0 + x1) / 2.0f, (y0 + y1) / 2.0f, mx, my, objspace_flatness_squared, n + 1);
		stbtt__tesselate_curve(points, num_points, mx, my, (x1 + x2) / 2.0f, (y1 + y2) / 2.0f, x2, y2, objspace_flatness_squared, n + 1);
	}
	else {
		stbtt__add_point(points, *num_points, x2, y2);
		*num_points = *num_points + 1;
	}
	return 1;
}

static void stbtt__tesselate_cubic(stbtt__point* points, int* num_points, float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float objspace_flatness_squared, int n)
{
	// @TODO this "flatness" calculation is just made-up nonsense that seems to work well enough
	float dx0 = x1 - x0;
	float dy0 = y1 - y0;
	float dx1 = x2 - x1;
	float dy1 = y2 - y1;
	float dx2 = x3 - x2;
	float dy2 = y3 - y2;
	float dx = x3 - x0;
	float dy = y3 - y0;
	float longlen = (float)(STBTT_sqrt(dx0 * dx0 + dy0 * dy0) + STBTT_sqrt(dx1 * dx1 + dy1 * dy1) + STBTT_sqrt(dx2 * dx2 + dy2 * dy2));
	float shortlen = (float)STBTT_sqrt(dx * dx + dy * dy);
	float flatness_squared = longlen * longlen - shortlen * shortlen;

	if (n > 16) // 65536 segments on one curve better be enough!
		return;

	if (flatness_squared > objspace_flatness_squared) {
		float x01 = (x0 + x1) / 2;
		float y01 = (y0 + y1) / 2;
		float x12 = (x1 + x2) / 2;
		float y12 = (y1 + y2) / 2;
		float x23 = (x2 + x3) / 2;
		float y23 = (y2 + y3) / 2;

		float xa = (x01 + x12) / 2;
		float ya = (y01 + y12) / 2;
		float xb = (x12 + x23) / 2;
		float yb = (y12 + y23) / 2;

		float mx = (xa + xb) / 2;
		float my = (ya + yb) / 2;

		stbtt__tesselate_cubic(points, num_points, x0, y0, x01, y01, xa, ya, mx, my, objspace_flatness_squared, n + 1);
		stbtt__tesselate_cubic(points, num_points, mx, my, xb, yb, x23, y23, x3, y3, objspace_flatness_squared, n + 1);
	}
	else {
		stbtt__add_point(points, *num_points, x3, y3);
		*num_points = *num_points + 1;
	}
}

// returns number of contours
static stbtt__point* stbtt_FlattenCurves(stbtt_vertex* vertices, int num_verts, float objspace_flatness, int** contour_lengths, int* num_contours, void* userdata)
{
	stbtt__point* points = 0;
	int num_points = 0;

	float objspace_flatness_squared = objspace_flatness * objspace_flatness;
	int i, n = 0, start = 0, pass;

	// count how many "moves" there are to Get the contour count
	for (i = 0; i < num_verts; ++i)
		if (vertices[i].type == STBTT_vmove)
			++n;

	*num_contours = n;
	if (n == 0) return 0;

	*contour_lengths = (int*)STBTT_malloc(sizeof(**contour_lengths) * n, userdata);

	if (*contour_lengths == 0) {
		*num_contours = 0;
		return 0;
	}

	// make two passes through the points so we don't need to realloc
	for (pass = 0; pass < 2; ++pass) {
		float x = 0, y = 0;
		if (pass == 1) {
			points = (stbtt__point*)STBTT_malloc(num_points * sizeof(points[0]), userdata);
			if (points == NULL) goto error;
		}
		num_points = 0;
		n = -1;
		for (i = 0; i < num_verts; ++i) {
			switch (vertices[i].type) {
			case STBTT_vmove:
				// start the next contour
				if (n >= 0)
					(*contour_lengths)[n] = num_points - start;
				++n;
				start = num_points;

				x = vertices[i].x, y = vertices[i].y;
				stbtt__add_point(points, num_points++, x, y);
				break;
			case STBTT_vline:
				x = vertices[i].x, y = vertices[i].y;
				stbtt__add_point(points, num_points++, x, y);
				break;
			case STBTT_vcurve:
				stbtt__tesselate_curve(points, &num_points, x, y,
					vertices[i].cx, vertices[i].cy,
					vertices[i].x, vertices[i].y,
					objspace_flatness_squared, 0);
				x = vertices[i].x, y = vertices[i].y;
				break;
			case STBTT_vcubic:
				stbtt__tesselate_cubic(points, &num_points, x, y,
					vertices[i].cx, vertices[i].cy,
					vertices[i].cx1, vertices[i].cy1,
					vertices[i].x, vertices[i].y,
					objspace_flatness_squared, 0);
				x = vertices[i].x, y = vertices[i].y;
				break;
			}
		}
		(*contour_lengths)[n] = num_points - start;
	}

	return points;
error:
	STBTT_free(points, userdata);
	STBTT_free(*contour_lengths, userdata);
	*contour_lengths = 0;
	*num_contours = 0;
	return NULL;
}

STBTT_DEF void stbtt_Rasterize(stbtt__bitmap* result, float flatness_in_pixels, stbtt_vertex* vertices, int num_verts, float scale_x, float scale_y, float shift_x, float shift_y, int x_off, int y_off, int invert, void* userdata)
{
	float scale = scale_x > scale_y ? scale_y : scale_x;
	int winding_count, * winding_lengths;
	stbtt__point* windings = stbtt_FlattenCurves(vertices, num_verts, flatness_in_pixels / scale, &winding_lengths, &winding_count, userdata);
	if (windings) {
		stbtt__rasterize(result, windings, winding_lengths, winding_count, scale_x, scale_y, shift_x, shift_y, x_off, y_off, invert, userdata);
		STBTT_free(winding_lengths, userdata);
		STBTT_free(windings, userdata);
	}
}

STBTT_DEF void stbtt_FreeBitmap(unsigned char* bitmap, void* userdata)
{
	STBTT_free(bitmap, userdata);
}

STBTT_DEF unsigned char* stbtt_GetGlyphBitmapSubpixel(const stbtt_fontinfo* info, float scale_x, float scale_y, float shift_x, float shift_y, int glyph, int* width, int* height, int* xoff, int* yoff)
{
	int ix0, iy0, ix1, iy1;
	stbtt__bitmap gbm;
	stbtt_vertex* vertices;
	int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);

	if (scale_x == 0) scale_x = scale_y;
	if (scale_y == 0) {
		if (scale_x == 0) {
			STBTT_free(vertices, info->userdata);
			return NULL;
		}
		scale_y = scale_x;
	}

	stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0, &iy0, &ix1, &iy1);

	// now we Get the size
	gbm.w = (ix1 - ix0);
	gbm.h = (iy1 - iy0);
	gbm.pixels = NULL; // in case we error

	if (width)* width = gbm.w;
	if (height)* height = gbm.h;
	if (xoff)* xoff = ix0;
	if (yoff)* yoff = iy0;

	if (gbm.w && gbm.h) {
		gbm.pixels = (unsigned char*)STBTT_malloc(gbm.w * gbm.h, info->userdata);
		if (gbm.pixels) {
			gbm.stride = gbm.w;

			stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);
		}
	}
	STBTT_free(vertices, info->userdata);
	return gbm.pixels;
}

STBTT_DEF unsigned char* stbtt_GetGlyphBitmap(const stbtt_fontinfo* info, float scale_x, float scale_y, int glyph, int* width, int* height, int* xoff, int* yoff)
{
	return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, glyph, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeGlyphBitmapSubpixel(const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int glyph)
{
	int ix0, iy0;
	stbtt_vertex* vertices;
	int num_verts = stbtt_GetGlyphShape(info, glyph, &vertices);
	stbtt__bitmap gbm;

	stbtt_GetGlyphBitmapBoxSubpixel(info, glyph, scale_x, scale_y, shift_x, shift_y, &ix0, &iy0, 0, 0);
	gbm.pixels = output;
	gbm.w = out_w;
	gbm.h = out_h;
	gbm.stride = out_stride;

	if (gbm.w && gbm.h)
		stbtt_Rasterize(&gbm, 0.35f, vertices, num_verts, scale_x, scale_y, shift_x, shift_y, ix0, iy0, 1, info->userdata);

	STBTT_free(vertices, info->userdata);
}

STBTT_DEF void stbtt_MakeGlyphBitmap(const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int glyph)
{
	stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f, 0.0f, glyph);
}

STBTT_DEF unsigned char* stbtt_GetCodepointBitmapSubpixel(const stbtt_fontinfo* info, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint, int* width, int* height, int* xoff, int* yoff)
{
	return stbtt_GetGlyphBitmapSubpixel(info, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info, codepoint), width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeCodepointBitmapSubpixel(const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, float shift_x, float shift_y, int codepoint)
{
	stbtt_MakeGlyphBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, shift_x, shift_y, stbtt_FindGlyphIndex(info, codepoint));
}

STBTT_DEF unsigned char* stbtt_GetCodepointBitmap(const stbtt_fontinfo* info, float scale_x, float scale_y, int codepoint, int* width, int* height, int* xoff, int* yoff)
{
	return stbtt_GetCodepointBitmapSubpixel(info, scale_x, scale_y, 0.0f, 0.0f, codepoint, width, height, xoff, yoff);
}

STBTT_DEF void stbtt_MakeCodepointBitmap(const stbtt_fontinfo* info, unsigned char* output, int out_w, int out_h, int out_stride, float scale_x, float scale_y, int codepoint)
{
	stbtt_MakeCodepointBitmapSubpixel(info, output, out_w, out_h, out_stride, scale_x, scale_y, 0.0f, 0.0f, codepoint);
}

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-CRAPPY packing to keep source code small

static int stbtt_BakeFontBitmap_internal(unsigned char* data, int offset,  // font location (use offset=0 for plain .ttf)
	float pixel_height,                     // height of font in pixels
	unsigned char* pixels, int pw, int ph,  // bitmap to be filled in
	int first_char, int num_chars,          // characters to bake
	stbtt_bakedchar* chardata)
{
	float scale;
	int x, y, bottom_y, i;
	stbtt_fontinfo f;
	f.userdata = NULL;
	if (!stbtt_InitFont(&f, data, offset))
		return -1;
	STBTT_memset(pixels, 0, pw * ph); // background of 0 around pixels
	x = y = 1;
	bottom_y = 1;

	scale = stbtt_ScaleForPixelHeight(&f, pixel_height);

	for (i = 0; i < num_chars; ++i) {
		int advance, lsb, x0, y0, x1, y1, gw, gh;
		int g = stbtt_FindGlyphIndex(&f, first_char + i);
		stbtt_GetGlyphHMetrics(&f, g, &advance, &lsb);
		stbtt_GetGlyphBitmapBox(&f, g, scale, scale, &x0, &y0, &x1, &y1);
		gw = x1 - x0;
		gh = y1 - y0;
		if (x + gw + 1 >= pw)
			y = bottom_y, x = 1; // advance to next row
		if (y + gh + 1 >= ph) // check if it fits vertically AFTER potentially moving to next row
			return -i;
		STBTT_assert(x + gw < pw);
		STBTT_assert(y + gh < ph);
		stbtt_MakeGlyphBitmap(&f, pixels + x + y * pw, gw, gh, pw, scale, scale, g);
		chardata[i].x0 = (stbtt_int16)x;
		chardata[i].y0 = (stbtt_int16)y;
		chardata[i].x1 = (stbtt_int16)(x + gw);
		chardata[i].y1 = (stbtt_int16)(y + gh);
		chardata[i].xadvance = scale * advance;
		chardata[i].xoff = (float)x0;
		chardata[i].yoff = (float)y0;
		x = x + gw + 1;
		if (y + gh + 1 > bottom_y)
			bottom_y = y + gh + 1;
	}
	return bottom_y;
}

STBTT_DEF void stbtt_GetBakedQuad(stbtt_bakedchar* chardata, int pw, int ph, int char_index, float* xpos, float* ypos, stbtt_aligned_quad* q, int opengl_fillrule)
{
	float d3d_bias = opengl_fillrule ? 0 : -0.5f;
	float ipw = 1.0f / pw, iph = 1.0f / ph;
	stbtt_bakedchar* b = chardata + char_index;
	int round_x = STBTT_ifloor((*xpos + b->xoff) + 0.5f);
	int round_y = STBTT_ifloor((*ypos + b->yoff) + 0.5f);

	q->x0 = round_x + d3d_bias;
	q->y0 = round_y + d3d_bias;
	q->x1 = round_x + b->x1 - b->x0 + d3d_bias;
	q->y1 = round_y + b->y1 - b->y0 + d3d_bias;

	q->s0 = b->x0 * ipw;
	q->t0 = b->y0 * iph;
	q->s1 = b->x1 * ipw;
	q->t1 = b->y1 * iph;

	*xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// rectangle packing replacement routines if you don't have stb_rect_pack.h
//

#ifndef STB_RECT_PACK_VERSION

typedef int stbrp_coord;

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                                                                                //
// COMPILER WARNING ?!?!?                                                         //
//                                                                                //
//                                                                                //
// if you Get a compile warning due to these symbols being defined more than      //
// once, move #include "stb_rect_pack.h" before #include "stb_truetype.h"         //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

typedef struct
{
	int width, height;
	int x, y, bottom_y;
} stbrp_context;

typedef struct
{
	unsigned char x;
} stbrp_node;

struct stbrp_rect
{
	stbrp_coord x, y;
	int id, w, h, was_packed;
};

static void stbrp_init_target(stbrp_context* con, int pw, int ph, stbrp_node* nodes, int num_nodes)
{
	con->width = pw;
	con->height = ph;
	con->x = 0;
	con->y = 0;
	con->bottom_y = 0;
	STBTT__NOTUSED(nodes);
	STBTT__NOTUSED(num_nodes);
}

static void stbrp_pack_rects(stbrp_context* con, stbrp_rect* rects, int num_rects)
{
	int i;
	for (i = 0; i < num_rects; ++i) {
		if (con->x + rects[i].w > con->width) {
			con->x = 0;
			con->y = con->bottom_y;
		}
		if (con->y + rects[i].h > con->height)
			break;
		rects[i].x = con->x;
		rects[i].y = con->y;
		rects[i].was_packed = 1;
		con->x += rects[i].w;
		if (con->y + rects[i].h > con->bottom_y)
			con->bottom_y = con->y + rects[i].h;
	}
	for (; i < num_rects; ++i)
		rects[i].was_packed = 0;
}
#endif

//////////////////////////////////////////////////////////////////////////////
//
// bitmap baking
//
// This is SUPER-AWESOME (tm Ryan Gordon) packing using stb_rect_pack.h. If
// stb_rect_pack.h isn't available, it uses the BakeFontBitmap strategy.

STBTT_DEF int stbtt_PackBegin(stbtt_pack_context* spc, unsigned char* pixels, int pw, int ph, int stride_in_bytes, int padding, void* alloc_context)
{
	stbrp_context* context = (stbrp_context*)STBTT_malloc(sizeof(*context), alloc_context);
	int            num_nodes = pw - padding;
	stbrp_node* nodes = (stbrp_node*)STBTT_malloc(sizeof(*nodes) * num_nodes, alloc_context);

	if (context == NULL || nodes == NULL) {
		if (context != NULL) STBTT_free(context, alloc_context);
		if (nodes != NULL) STBTT_free(nodes, alloc_context);
		return 0;
	}

	spc->user_allocator_context = alloc_context;
	spc->width = pw;
	spc->height = ph;
	spc->pixels = pixels;
	spc->pack_info = context;
	spc->nodes = nodes;
	spc->padding = padding;
	spc->stride_in_bytes = stride_in_bytes != 0 ? stride_in_bytes : pw;
	spc->h_oversample = 1;
	spc->v_oversample = 1;

	stbrp_init_target(context, pw - padding, ph - padding, nodes, num_nodes);

	if (pixels)
		STBTT_memset(pixels, 0, pw * ph); // background of 0 around pixels

	return 1;
}

STBTT_DEF void stbtt_PackEnd(stbtt_pack_context* spc)
{
	STBTT_free(spc->nodes, spc->user_allocator_context);
	STBTT_free(spc->pack_info, spc->user_allocator_context);
}

STBTT_DEF void stbtt_PackSetOversampling(stbtt_pack_context* spc, unsigned int h_oversample, unsigned int v_oversample)
{
	STBTT_assert(h_oversample <= STBTT_MAX_OVERSAMPLE);
	STBTT_assert(v_oversample <= STBTT_MAX_OVERSAMPLE);
	if (h_oversample <= STBTT_MAX_OVERSAMPLE)
		spc->h_oversample = h_oversample;
	if (v_oversample <= STBTT_MAX_OVERSAMPLE)
		spc->v_oversample = v_oversample;
}

#define STBTT__OVER_MASK  (STBTT_MAX_OVERSAMPLE-1)

static void stbtt__h_prefilter(unsigned char* pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
	unsigned char buffer[STBTT_MAX_OVERSAMPLE];
	int safe_w = w - kernel_width;
	int j;
	STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
	for (j = 0; j < h; ++j) {
		int i;
		unsigned int total;
		STBTT_memset(buffer, 0, kernel_width);

		total = 0;

		// make kernel_width a constant in common cases so compiler can optimize out the divide
		switch (kernel_width) {
		case 2:
			for (i = 0; i <= safe_w; ++i) {
				total += pixels[i] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 2);
			}
			break;
		case 3:
			for (i = 0; i <= safe_w; ++i) {
				total += pixels[i] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 3);
			}
			break;
		case 4:
			for (i = 0; i <= safe_w; ++i) {
				total += pixels[i] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 4);
			}
			break;
		case 5:
			for (i = 0; i <= safe_w; ++i) {
				total += pixels[i] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / 5);
			}
			break;
		default:
			for (i = 0; i <= safe_w; ++i) {
				total += pixels[i] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i];
				pixels[i] = (unsigned char)(total / kernel_width);
			}
			break;
		}

		for (; i < w; ++i) {
			STBTT_assert(pixels[i] == 0);
			total -= buffer[i & STBTT__OVER_MASK];
			pixels[i] = (unsigned char)(total / kernel_width);
		}

		pixels += stride_in_bytes;
	}
}

static void stbtt__v_prefilter(unsigned char* pixels, int w, int h, int stride_in_bytes, unsigned int kernel_width)
{
	unsigned char buffer[STBTT_MAX_OVERSAMPLE];
	int safe_h = h - kernel_width;
	int j;
	STBTT_memset(buffer, 0, STBTT_MAX_OVERSAMPLE); // suppress bogus warning from VS2013 -analyze
	for (j = 0; j < w; ++j) {
		int i;
		unsigned int total;
		STBTT_memset(buffer, 0, kernel_width);

		total = 0;

		// make kernel_width a constant in common cases so compiler can optimize out the divide
		switch (kernel_width) {
		case 2:
			for (i = 0; i <= safe_h; ++i) {
				total += pixels[i * stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / 2);
			}
			break;
		case 3:
			for (i = 0; i <= safe_h; ++i) {
				total += pixels[i * stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / 3);
			}
			break;
		case 4:
			for (i = 0; i <= safe_h; ++i) {
				total += pixels[i * stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / 4);
			}
			break;
		case 5:
			for (i = 0; i <= safe_h; ++i) {
				total += pixels[i * stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / 5);
			}
			break;
		default:
			for (i = 0; i <= safe_h; ++i) {
				total += pixels[i * stride_in_bytes] - buffer[i & STBTT__OVER_MASK];
				buffer[(i + kernel_width) & STBTT__OVER_MASK] = pixels[i * stride_in_bytes];
				pixels[i * stride_in_bytes] = (unsigned char)(total / kernel_width);
			}
			break;
		}

		for (; i < h; ++i) {
			STBTT_assert(pixels[i * stride_in_bytes] == 0);
			total -= buffer[i & STBTT__OVER_MASK];
			pixels[i * stride_in_bytes] = (unsigned char)(total / kernel_width);
		}

		pixels += 1;
	}
}

static float stbtt__oversample_shift(int oversample)
{
	if (!oversample)
		return 0.0f;

	// The prefilter is a box filter of width "oversample",
	// which shifts phase by (oversample - 1)/2 pixels in
	// oversampled space. We want to shift in the opposite
	// direction to counter this.
	return (float)-(oversample - 1) / (2.0f * (float)oversample);
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesGatherRects(stbtt_pack_context* spc, const stbtt_fontinfo* info, stbtt_pack_range* ranges, int num_ranges, stbrp_rect* rects)
{
	int i, j, k;

	k = 0;
	for (i = 0; i < num_ranges; ++i) {
		float fh = ranges[i].font_size;
		float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
		ranges[i].h_oversample = (unsigned char)spc->h_oversample;
		ranges[i].v_oversample = (unsigned char)spc->v_oversample;
		for (j = 0; j < ranges[i].num_chars; ++j) {
			int x0, y0, x1, y1;
			int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
			int glyph = stbtt_FindGlyphIndex(info, codepoint);
			stbtt_GetGlyphBitmapBoxSubpixel(info, glyph,
				scale * spc->h_oversample,
				scale * spc->v_oversample,
				0, 0,
				&x0, &y0, &x1, &y1);
			rects[k].w = (stbrp_coord)(x1 - x0 + spc->padding + spc->h_oversample - 1);
			rects[k].h = (stbrp_coord)(y1 - y0 + spc->padding + spc->v_oversample - 1);
			++k;
		}
	}

	return k;
}

// rects array must be big enough to accommodate all characters in the given ranges
STBTT_DEF int stbtt_PackFontRangesRenderIntoRects(stbtt_pack_context* spc, const stbtt_fontinfo* info, stbtt_pack_range* ranges, int num_ranges, stbrp_rect* rects)
{
	int i, j, k, return_value = 1;

	// save current values
	int old_h_over = spc->h_oversample;
	int old_v_over = spc->v_oversample;

	k = 0;
	for (i = 0; i < num_ranges; ++i) {
		float fh = ranges[i].font_size;
		float scale = fh > 0 ? stbtt_ScaleForPixelHeight(info, fh) : stbtt_ScaleForMappingEmToPixels(info, -fh);
		float recip_h, recip_v, sub_x, sub_y;
		spc->h_oversample = ranges[i].h_oversample;
		spc->v_oversample = ranges[i].v_oversample;
		recip_h = 1.0f / spc->h_oversample;
		recip_v = 1.0f / spc->v_oversample;
		sub_x = stbtt__oversample_shift(spc->h_oversample);
		sub_y = stbtt__oversample_shift(spc->v_oversample);
		for (j = 0; j < ranges[i].num_chars; ++j) {
			stbrp_rect* r = &rects[k];
			if (r->was_packed) {
				stbtt_packedchar* bc = &ranges[i].chardata_for_range[j];
				int advance, lsb, x0, y0, x1, y1;
				int codepoint = ranges[i].array_of_unicode_codepoints == NULL ? ranges[i].first_unicode_codepoint_in_range + j : ranges[i].array_of_unicode_codepoints[j];
				int glyph = stbtt_FindGlyphIndex(info, codepoint);
				stbrp_coord pad = (stbrp_coord)spc->padding;

				// pad on left and top
				r->x += pad;
				r->y += pad;
				r->w -= pad;
				r->h -= pad;
				stbtt_GetGlyphHMetrics(info, glyph, &advance, &lsb);
				stbtt_GetGlyphBitmapBox(info, glyph,
					scale * spc->h_oversample,
					scale * spc->v_oversample,
					&x0, &y0, &x1, &y1);
				stbtt_MakeGlyphBitmapSubpixel(info,
					spc->pixels + r->x + r->y * spc->stride_in_bytes,
					r->w - spc->h_oversample + 1,
					r->h - spc->v_oversample + 1,
					spc->stride_in_bytes,
					scale * spc->h_oversample,
					scale * spc->v_oversample,
					0, 0,
					glyph);

				if (spc->h_oversample > 1)
					stbtt__h_prefilter(spc->pixels + r->x + r->y * spc->stride_in_bytes,
						r->w, r->h, spc->stride_in_bytes,
						spc->h_oversample);

				if (spc->v_oversample > 1)
					stbtt__v_prefilter(spc->pixels + r->x + r->y * spc->stride_in_bytes,
						r->w, r->h, spc->stride_in_bytes,
						spc->v_oversample);

				bc->x0 = (stbtt_int16)r->x;
				bc->y0 = (stbtt_int16)r->y;
				bc->x1 = (stbtt_int16)(r->x + r->w);
				bc->y1 = (stbtt_int16)(r->y + r->h);
				bc->xadvance = scale * advance;
				bc->xoff = (float)x0 * recip_h + sub_x;
				bc->yoff = (float)y0 * recip_v + sub_y;
				bc->xoff2 = (x0 + r->w) * recip_h + sub_x;
				bc->yoff2 = (y0 + r->h) * recip_v + sub_y;
			}
			else {
				return_value = 0; // if any fail, report failure
			}

			++k;
		}
	}

	// restore original values
	spc->h_oversample = old_h_over;
	spc->v_oversample = old_v_over;

	return return_value;
}

STBTT_DEF void stbtt_PackFontRangesPackRects(stbtt_pack_context* spc, stbrp_rect* rects, int num_rects)
{
	stbrp_pack_rects((stbrp_context*)spc->pack_info, rects, num_rects);
}

STBTT_DEF int stbtt_PackFontRanges(stbtt_pack_context* spc, unsigned char* fontdata, int font_index, stbtt_pack_range* ranges, int num_ranges)
{
	stbtt_fontinfo info;
	int i, j, n, return_value = 1;
	//stbrp_context *context = (stbrp_context *) spc->pack_info;
	stbrp_rect* rects;

	// flag all characters as NOT packed
	for (i = 0; i < num_ranges; ++i)
		for (j = 0; j < ranges[i].num_chars; ++j)
			ranges[i].chardata_for_range[j].x0 =
			ranges[i].chardata_for_range[j].y0 =
			ranges[i].chardata_for_range[j].x1 =
			ranges[i].chardata_for_range[j].y1 = 0;

	n = 0;
	for (i = 0; i < num_ranges; ++i)
		n += ranges[i].num_chars;

	rects = (stbrp_rect*)STBTT_malloc(sizeof(*rects) * n, spc->user_allocator_context);
	if (rects == NULL)
		return 0;

	info.userdata = spc->user_allocator_context;
	stbtt_InitFont(&info, fontdata, stbtt_GetFontOffsetForIndex(fontdata, font_index));

	n = stbtt_PackFontRangesGatherRects(spc, &info, ranges, num_ranges, rects);

	stbtt_PackFontRangesPackRects(spc, rects, n);

	return_value = stbtt_PackFontRangesRenderIntoRects(spc, &info, ranges, num_ranges, rects);

	STBTT_free(rects, spc->user_allocator_context);
	return return_value;
}

STBTT_DEF int stbtt_PackFontRange(stbtt_pack_context* spc, unsigned char* fontdata, int font_index, float font_size,
	int first_unicode_codepoint_in_range, int num_chars_in_range, stbtt_packedchar* chardata_for_range)
{
	stbtt_pack_range range;
	range.first_unicode_codepoint_in_range = first_unicode_codepoint_in_range;
	range.array_of_unicode_codepoints = NULL;
	range.num_chars = num_chars_in_range;
	range.chardata_for_range = chardata_for_range;
	range.font_size = font_size;
	return stbtt_PackFontRanges(spc, fontdata, font_index, &range, 1);
}

STBTT_DEF void stbtt_GetPackedQuad(stbtt_packedchar* chardata, int pw, int ph, int char_index, float* xpos, float* ypos, stbtt_aligned_quad* q, int align_to_integer)
{
	float ipw = 1.0f / pw, iph = 1.0f / ph;
	stbtt_packedchar* b = chardata + char_index;

	if (align_to_integer) {
		float x = (float)STBTT_ifloor((*xpos + b->xoff) + 0.5f);
		float y = (float)STBTT_ifloor((*ypos + b->yoff) + 0.5f);
		q->x0 = x;
		q->y0 = y;
		q->x1 = x + b->xoff2 - b->xoff;
		q->y1 = y + b->yoff2 - b->yoff;
	}
	else {
		q->x0 = *xpos + b->xoff;
		q->y0 = *ypos + b->yoff;
		q->x1 = *xpos + b->xoff2;
		q->y1 = *ypos + b->yoff2;
	}

	q->s0 = b->x0 * ipw;
	q->t0 = b->y0 * iph;
	q->s1 = b->x1 * ipw;
	q->t1 = b->y1 * iph;

	*xpos += b->xadvance;
}

//////////////////////////////////////////////////////////////////////////////
//
// font name matching -- recommended not to use this
//

// check if a utf8 string contains a prefix which is the utf16 string; if so return length of matching utf8 string
static stbtt_int32 stbtt__CompareUTF8toUTF16_bigendian_prefix(stbtt_uint8* s1, stbtt_int32 len1, stbtt_uint8* s2, stbtt_int32 len2)
{
	stbtt_int32 i = 0;

	// convert utf16 to utf8 and compare the results while converting
	while (len2) {
		stbtt_uint16 ch = s2[0] * 256 + s2[1];
		if (ch < 0x80) {
			if (i >= len1) return -1;
			if (s1[i++] != ch) return -1;
		}
		else if (ch < 0x800) {
			if (i + 1 >= len1) return -1;
			if (s1[i++] != 0xc0 + (ch >> 6)) return -1;
			if (s1[i++] != 0x80 + (ch & 0x3f)) return -1;
		}
		else if (ch >= 0xd800 && ch < 0xdc00) {
			stbtt_uint32 c;
			stbtt_uint16 ch2 = s2[2] * 256 + s2[3];
			if (i + 3 >= len1) return -1;
			c = ((ch - 0xd800) << 10) + (ch2 - 0xdc00) + 0x10000;
			if (s1[i++] != 0xf0 + (c >> 18)) return -1;
			if (s1[i++] != 0x80 + ((c >> 12) & 0x3f)) return -1;
			if (s1[i++] != 0x80 + ((c >> 6) & 0x3f)) return -1;
			if (s1[i++] != 0x80 + ((c) & 0x3f)) return -1;
			s2 += 2; // plus another 2 below
			len2 -= 2;
		}
		else if (ch >= 0xdc00 && ch < 0xe000) {
			return -1;
		}
		else {
			if (i + 2 >= len1) return -1;
			if (s1[i++] != 0xe0 + (ch >> 12)) return -1;
			if (s1[i++] != 0x80 + ((ch >> 6) & 0x3f)) return -1;
			if (s1[i++] != 0x80 + ((ch) & 0x3f)) return -1;
		}
		s2 += 2;
		len2 -= 2;
	}
	return i;
}

static int stbtt_CompareUTF8toUTF16_bigendian_internal(char* s1, int len1, char* s2, int len2)
{
	return len1 == stbtt__CompareUTF8toUTF16_bigendian_prefix((stbtt_uint8*)s1, len1, (stbtt_uint8*)s2, len2);
}

// returns results in whatever encoding you request... but note that 2-uint8_t encodings
// will be BIG-ENDIAN... use stbtt_CompareUTF8toUTF16_bigendian() to compare
STBTT_DEF const char* stbtt_GetFontNameString(const stbtt_fontinfo* font, int* length, int platformID, int encodingID, int languageID, int nameID)
{
	stbtt_int32 i, count, stringOffset;
	stbtt_uint8* fc = font->data;
	stbtt_uint32 offset = font->fontstart;
	stbtt_uint32 nm = stbtt__find_table(fc, offset, "name");
	if (!nm) return NULL;

	count = ttUSHORT(fc + nm + 2);
	stringOffset = nm + ttUSHORT(fc + nm + 4);
	for (i = 0; i < count; ++i) {
		stbtt_uint32 loc = nm + 6 + 12 * i;
		if (platformID == ttUSHORT(fc + loc + 0) && encodingID == ttUSHORT(fc + loc + 2)
			&& languageID == ttUSHORT(fc + loc + 4) && nameID == ttUSHORT(fc + loc + 6)) {
			*length = ttUSHORT(fc + loc + 8);
			return (const char*)(fc + stringOffset + ttUSHORT(fc + loc + 10));
		}
	}
	return NULL;
}

static int stbtt__matchpair(stbtt_uint8* fc, stbtt_uint32 nm, stbtt_uint8* name, stbtt_int32 nlen, stbtt_int32 target_id, stbtt_int32 next_id)
{
	stbtt_int32 i;
	stbtt_int32 count = ttUSHORT(fc + nm + 2);
	stbtt_int32 stringOffset = nm + ttUSHORT(fc + nm + 4);

	for (i = 0; i < count; ++i) {
		stbtt_uint32 loc = nm + 6 + 12 * i;
		stbtt_int32 id = ttUSHORT(fc + loc + 6);
		if (id == target_id) {
			// GetOffset the encoding
			stbtt_int32 platform = ttUSHORT(fc + loc + 0), encoding = ttUSHORT(fc + loc + 2), language = ttUSHORT(fc + loc + 4);

			// is this a Unicode encoding?
			if (platform == 0 || (platform == 3 && encoding == 1) || (platform == 3 && encoding == 10)) {
				stbtt_int32 slen = ttUSHORT(fc + loc + 8);
				stbtt_int32 off = ttUSHORT(fc + loc + 10);

				// check if there's a prefix match
				stbtt_int32 matchlen = stbtt__CompareUTF8toUTF16_bigendian_prefix(name, nlen, fc + stringOffset + off, slen);
				if (matchlen >= 0) {
					// check for target_id+1 immediately following, with same encoding & language
					if (i + 1 < count && ttUSHORT(fc + loc + 12 + 6) == next_id && ttUSHORT(fc + loc + 12) == platform && ttUSHORT(fc + loc + 12 + 2) == encoding && ttUSHORT(fc + loc + 12 + 4) == language) {
						slen = ttUSHORT(fc + loc + 12 + 8);
						off = ttUSHORT(fc + loc + 12 + 10);
						if (slen == 0) {
							if (matchlen == nlen)
								return 1;
						}
						else if (matchlen < nlen && name[matchlen] == ' ') {
							++matchlen;
							if (stbtt_CompareUTF8toUTF16_bigendian_internal((char*)(name + matchlen), nlen - matchlen, (char*)(fc + stringOffset + off), slen))
								return 1;
						}
					}
					else {
						// if nothing immediately following
						if (matchlen == nlen)
							return 1;
					}
				}
			}

			// @TODO handle other encodings
		}
	}
	return 0;
}

static int stbtt__matches(stbtt_uint8* fc, stbtt_uint32 offset, stbtt_uint8* name, stbtt_int32 flags)
{
	stbtt_int32 nlen = (stbtt_int32)STBTT_strlen((char*)name);
	stbtt_uint32 nm, hd;
	if (!stbtt__isfont(fc + offset)) return 0;

	// check italics/bold/underline flags in macStyle...
	if (flags) {
		hd = stbtt__find_table(fc, offset, "head");
		if ((ttUSHORT(fc + hd + 44) & 7) != (flags & 7)) return 0;
	}

	nm = stbtt__find_table(fc, offset, "name");
	if (!nm) return 0;

	if (flags) {
		// if we checked the macStyle flags, then just check the family and ignore the subfamily
		if (stbtt__matchpair(fc, nm, name, nlen, 16, -1))  return 1;
		if (stbtt__matchpair(fc, nm, name, nlen, 1, -1))  return 1;
		if (stbtt__matchpair(fc, nm, name, nlen, 3, -1))  return 1;
	}
	else {
		if (stbtt__matchpair(fc, nm, name, nlen, 16, 17))  return 1;
		if (stbtt__matchpair(fc, nm, name, nlen, 1, 2))  return 1;
		if (stbtt__matchpair(fc, nm, name, nlen, 3, -1))  return 1;
	}

	return 0;
}

static int stbtt_FindMatchingFont_internal(unsigned char* font_collection, char* name_utf8, stbtt_int32 flags)
{
	stbtt_int32 i;
	for (i = 0;; ++i) {
		stbtt_int32 off = stbtt_GetFontOffsetForIndex(font_collection, i);
		if (off < 0) return off;
		if (stbtt__matches((stbtt_uint8*)font_collection, off, (stbtt_uint8*)name_utf8, flags))
			return off;
	}
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif

STBTT_DEF int stbtt_BakeFontBitmap(const unsigned char* data, int offset,
	float pixel_height, unsigned char* pixels, int pw, int ph,
	int first_char, int num_chars, stbtt_bakedchar* chardata)
{
	return stbtt_BakeFontBitmap_internal((unsigned char*)data, offset, pixel_height, pixels, pw, ph, first_char, num_chars, chardata);
}

STBTT_DEF int stbtt_GetFontOffsetForIndex(const unsigned char* data, int index)
{
	return stbtt_GetFontOffsetForIndex_internal((unsigned char*)data, index);
}

STBTT_DEF int stbtt_GetNumberOfFonts(const unsigned char* data)
{
	return stbtt_GetNumberOfFonts_internal((unsigned char*)data);
}

STBTT_DEF int stbtt_InitFont(stbtt_fontinfo* info, const unsigned char* data, int offset)
{
	return stbtt_InitFont_internal(info, (unsigned char*)data, offset);
}

STBTT_DEF int stbtt_FindMatchingFont(const unsigned char* fontdata, const char* name, int flags)
{
	return stbtt_FindMatchingFont_internal((unsigned char*)fontdata, (char*)name, flags);
}

STBTT_DEF int stbtt_CompareUTF8toUTF16_bigendian(const char* s1, int len1, const char* s2, int len2)
{
	return stbtt_CompareUTF8toUTF16_bigendian_internal((char*)s1, len1, (char*)s2, len2);
}

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif

#endif // STB_TRUETYPE_IMPLEMENTATION

// FULL VERSION HISTORY
//
//   1.12 (2016-10-25) suppress warnings about casting away const with -Wcast-qual
//   1.11 (2016-04-02) fix unused-variable warning
//   1.10 (2016-04-02) allow user-defined fabs() replacement
//                     fix memory leak if fontsize=0.0
//                     fix warning from duplicate typedef
//   1.09 (2016-01-16) warning fix; avoid crash on outofmem; use alloc userdata for PackFontRanges
//   1.08 (2015-09-13) document stbtt_Rasterize(); fixes for vertical & horizontal edges
//   1.07 (2015-08-01) allow PackFontRanges to accept arrays of sparse codepoints;
//                     allow PackFontRanges to pack and Render in separate phases;
//                     fix stbtt_GetFontOFfsetForIndex (never worked for non-0 input?);
//                     fixed an assert() bug in the new rasterizer
//                     replace assert() with STBTT_assert() in new rasterizer
//   1.06 (2015-07-14) performance improvements (~35% faster on x86 and x64 on test machine)
//                     also more precise AA rasterizer, except if shapes overlap
//                     remove need for STBTT_sort
//   1.05 (2015-04-15) fix misplaced definitions for STBTT_STATIC
//   1.04 (2015-04-15) typo in example
//   1.03 (2015-04-12) STBTT_STATIC, fix memory leak in new packing, various fixes
//   1.02 (2014-12-10) fix various warnings & compile issues w/ stb_rect_pack, C++
//   1.01 (2014-12-08) fix subpixel position when oversampling to exactly match
//                        non-oversampled; STBTT_POINT_SIZE for packed case only
//   1.00 (2014-12-06) add new PackBegin etc. API, w/ support for oversampling
//   0.99 (2014-09-18) fix multiple bugs with subpixel rendering (ryg)
//   0.9  (2014-08-07) support certain mac/iOS fonts without an MS platformID
//   0.8b (2014-07-07) fix a warning
//   0.8  (2014-05-25) fix a few more warnings
//   0.7  (2013-09-25) bugfix: subpixel glyph bug fixed in 0.5 had come back
//   0.6c (2012-07-24) improve documentation
//   0.6b (2012-07-20) fix a few more warnings
//   0.6  (2012-07-17) fix warnings; added stbtt_ScaleForMappingEmToPixels,
//                        stbtt_GetFontBoundingBox, stbtt_IsGlyphEmpty
//   0.5  (2011-12-09) bugfixes:
//                        subpixel glyph renderer computed wrong bounding box
//                        first vertex of shape can be off-curve (FreeSans)
//   0.4b (2011-12-03) fixed an error in the font baking example
//   0.4  (2011-12-01) kerning, subpixel rendering (tor)
//                    bugfixes for:
//                        codepoint-to-glyph conversion using table fmt=12
//                        codepoint-to-glyph conversion using table fmt=4
//                        stbtt_GetBakedQuad with non-square texture (Zer)
//                    updated Hello World! sample to use kerning and subpixel
//                    fixed some warnings
//   0.3  (2009-06-24) cmap fmt=12, compound shapes (MM)
//                    userdata, malloc-from-userdata, non-zero fill (stb)
//   0.2  (2009-03-11) Fix unsigned/signed char warnings
//   0.1  (2009-03-09) First public release
//

```

`src/jsoncpp/json-forwards.h`:

```h
/// Json-cpp amalgated forward header (http://jsoncpp.sourceforge.net/).
/// It is intended to be used with #include "json/json-forwards.h"
/// This header provides forward declaration for all JsonCpp types.

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////

/*
The JsonCpp library's source code, including accompanying documentation,
tests and demonstration applications, are licensed under the following
conditions...

The author (Baptiste Lepilleur) explicitly disclaims copyright in all
jurisdictions which recognize such a disclaimer. In such jurisdictions,
this software is released into the Public Domain.

In jurisdictions which do not recognize Public Domain property (e.g. Germany as of
2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur, and is
released under the terms of the MIT License (see below).

In jurisdictions which recognize Public Domain property, the user of this
software may choose to accept it either as 1) Public Domain, 2) under the
conditions of the MIT License (see below), or 3) under the terms of dual
Public Domain/MIT License conditions described here, as they choose.

The MIT License is about as close to Public Domain as a license can get, and is
described in clear, concise terms at:

   http://en.wikipedia.org/wiki/MIT_License

The full text of the MIT License follows:

========================================================================
Copyright (c) 2007-2010 Baptiste Lepilleur

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
========================================================================
(END LICENSE TEXT)

The MIT license is compatible with both the GPL and commercial
software, affording one all of the rights of Public Domain with the
minor nuisance of being required to keep the above copyright notice
and license text in the source code. Note also that by accepting the
Public Domain "license" you can re-license your copy using whatever
license you like.

*/

// //////////////////////////////////////////////////////////////////////
// End of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////

#ifndef JSON_FORWARD_AMALGATED_H_INCLUDED
# define JSON_FORWARD_AMALGATED_H_INCLUDED
/// If defined, indicates that the source file is amalgated
/// to prevent private header inclusion.
#define JSON_IS_AMALGAMATION

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/config.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef JSON_CONFIG_H_INCLUDED
#define JSON_CONFIG_H_INCLUDED
#include <stddef.h>
#include <string> //typedef String
#include <stdint.h> //typedef int64_t, uint64_t

/// If defined, indicates that json library is embedded in CppTL library.
//# define JSON_IN_CPPTL 1

/// If defined, indicates that json may leverage CppTL library
//#  define JSON_USE_CPPTL 1
/// If defined, indicates that cpptl vector based map should be used instead of
/// std::map
/// as Value container.
//#  define JSON_USE_CPPTL_SMALLMAP 1

// If non-zero, the library uses exceptions to report bad input instead of C
// assertion macros. The default is to use exceptions.
#ifndef JSON_USE_EXCEPTION
#define JSON_USE_EXCEPTION 1
#endif

/// If defined, indicates that the source file is amalgated
/// to prevent private header inclusion.
/// Remarks: it is automatically defined in the generated amalgated header.
// #define JSON_IS_AMALGAMATION

#ifdef JSON_IN_CPPTL
#include <cpptl/config.h>
#ifndef JSON_USE_CPPTL
#define JSON_USE_CPPTL 1
#endif
#endif

#ifdef JSON_IN_CPPTL
#define JSON_API CPPTL_API
#elif defined(JSON_DLL_BUILD)
#if defined(_MSC_VER) || defined(__MINGW32__)
#define JSON_API __declspec(dllexport)
#define JSONCPP_DISABLE_DLL_INTERFACE_WARNING
#endif // if defined(_MSC_VER)
#elif defined(JSON_DLL)
#if defined(_MSC_VER) || defined(__MINGW32__)
#define JSON_API __declspec(dllimport)
#define JSONCPP_DISABLE_DLL_INTERFACE_WARNING
#endif // if defined(_MSC_VER)
#endif // ifdef JSON_IN_CPPTL
#if !defined(JSON_API)
#define JSON_API
#endif

// If JSON_NO_INT64 is defined, then Json only support C++ "int" type for
// integer
// Storages, and 64 bits integer support is disabled.
// #define JSON_NO_INT64 1

#if defined(_MSC_VER) // MSVC
#  if _MSC_VER <= 1200 // MSVC 6
	// Microsoft Visual Studio 6 only support conversion from __int64 to double
	// (no conversion from unsigned __int64).
#    define JSON_USE_INT64_DOUBLE_CONVERSION 1
	// Disable warning 4786 for VS6 caused by STL (identifier was truncated to '255'
	// characters in the debug information)
	// All projects I've ever seen with VS6 were using this globally (not bothering
	// with pragma push/pop).
#    pragma warning(disable : 4786)
#  endif // MSVC 6

#  if _MSC_VER >= 1500 // MSVC 2008
	/// Indicates that the following function is deprecated.
#    define JSONCPP_DEPRECATED(message) __declspec(deprecated(message))
#  endif

#endif // defined(_MSC_VER)

// In c++11 the override keyword allows you to explicity define that a function
// is intended to override the base-class version.  This makes the code more
// managable and fixes a set of common hard-to-find bugs.
#if __cplusplus >= 201103L
# define JSONCPP_OVERRIDE override
#elif defined(_MSC_VER) && _MSC_VER > 1600
# define JSONCPP_OVERRIDE override
#else
# define JSONCPP_OVERRIDE
#endif

#ifndef JSON_HAS_RVALUE_REFERENCES

#if defined(_MSC_VER) && _MSC_VER >= 1600 // MSVC >= 2010
#define JSON_HAS_RVALUE_REFERENCES 1
#endif // MSVC >= 2010

#ifdef __clang__
#if __has_feature(cxx_rvalue_references)
#define JSON_HAS_RVALUE_REFERENCES 1
#endif  // has_feature

#elif defined __GNUC__ // not clang (gcc comes later since clang emulates gcc)
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus >= 201103L)
#define JSON_HAS_RVALUE_REFERENCES 1
#endif  // GXX_EXPERIMENTAL

#endif // __clang__ || __GNUC__

#endif // not defined JSON_HAS_RVALUE_REFERENCES

#ifndef JSON_HAS_RVALUE_REFERENCES
#define JSON_HAS_RVALUE_REFERENCES 0
#endif

#ifdef __clang__
#elif defined __GNUC__ // not clang (gcc comes later since clang emulates gcc)
#  if (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
#    define JSONCPP_DEPRECATED(message)  __attribute__ ((deprecated(message)))
#  elif (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))
#    define JSONCPP_DEPRECATED(message)  __attribute__((__deprecated__))
#  endif  // GNUC version
#endif // __clang__ || __GNUC__

#if !defined(JSONCPP_DEPRECATED)
#define JSONCPP_DEPRECATED(message)
#endif // if !defined(JSONCPP_DEPRECATED)

#if __GNUC__ >= 6
#  define JSON_USE_INT64_DOUBLE_CONVERSION 1
#endif

#if !defined(JSON_IS_AMALGAMATION)

# include "version.h"

# if JSONCPP_USING_SECURE_MEMORY
#  include "allocator.h" //typedef Allocator
# endif

#endif // if !defined(JSON_IS_AMALGAMATION)

namespace Json {
	typedef int Int;
	typedef unsigned int UInt;
#if defined(JSON_NO_INT64)
	typedef int LargestInt;
	typedef unsigned int LargestUInt;
#undef JSON_HAS_INT64
#else                 // if defined(JSON_NO_INT64)
	// For Microsoft Visual use specific types as long long is not supported
#if defined(_MSC_VER) // Microsoft Visual Studio
	typedef __int64 Int64;
	typedef unsigned __int64 UInt64;
#else                 // if defined(_MSC_VER) // Other platforms, use long long
	typedef int64_t Int64;
	typedef uint64_t UInt64;
#endif // if defined(_MSC_VER)
	typedef Int64 LargestInt;
	typedef UInt64 LargestUInt;
#define JSON_HAS_INT64
#endif // if defined(JSON_NO_INT64)
#if JSONCPP_USING_SECURE_MEMORY
#define JSONCPP_STRING        std::basic_string<char, std::char_traits<char>, Json::SecureAllocator<char> >
#define JSONCPP_OSTRINGSTREAM std::basic_ostringstream<char, std::char_traits<char>, Json::SecureAllocator<char> >
#define JSONCPP_OSTREAM       std::basic_ostream<char, std::char_traits<char>>
#define JSONCPP_ISTRINGSTREAM std::basic_istringstream<char, std::char_traits<char>, Json::SecureAllocator<char> >
#define JSONCPP_ISTREAM       std::istream
#else
#define JSONCPP_STRING        std::string
#define JSONCPP_OSTRINGSTREAM std::ostringstream
#define JSONCPP_OSTREAM       std::ostream
#define JSONCPP_ISTRINGSTREAM std::istringstream
#define JSONCPP_ISTREAM       std::istream
#endif // if JSONCPP_USING_SECURE_MEMORY
} // end namespace Json

#endif // JSON_CONFIG_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/config.h
// //////////////////////////////////////////////////////////////////////

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/forwards.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef JSON_FORWARDS_H_INCLUDED
#define JSON_FORWARDS_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include "config.h"
#endif // if !defined(JSON_IS_AMALGAMATION)

namespace Json {
	// writer.h
	class FastWriter;
	class StyledWriter;

	// reader.h
	class Reader;

	// features.h
	class Features;

	// value.h
	typedef unsigned int ArrayIndex;
	class StaticString;
	class Path;
	class PathArgument;
	class Value;
	class ValueIteratorBase;
	class ValueIterator;
	class ValueConstIterator;
} // namespace Json

#endif // JSON_FORWARDS_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/forwards.h
// //////////////////////////////////////////////////////////////////////

#endif //ifndef JSON_FORWARD_AMALGATED_H_INCLUDED

```

`src/jsoncpp/json.h`:

```h
/// Json-cpp amalgated header (http://jsoncpp.sourceforge.net/).
/// It is intended to be used with #include "json/json.h"

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////

/*
The JsonCpp library's source code, including accompanying documentation,
tests and demonstration applications, are licensed under the following
conditions...

The author (Baptiste Lepilleur) explicitly disclaims copyright in all
jurisdictions which recognize such a disclaimer. In such jurisdictions,
this software is released into the Public Domain.

In jurisdictions which do not recognize Public Domain property (e.g. Germany as of
2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur, and is
released under the terms of the MIT License (see below).

In jurisdictions which recognize Public Domain property, the user of this
software may choose to accept it either as 1) Public Domain, 2) under the
conditions of the MIT License (see below), or 3) under the terms of dual
Public Domain/MIT License conditions described here, as they choose.

The MIT License is about as close to Public Domain as a license can get, and is
described in clear, concise terms at:

   http://en.wikipedia.org/wiki/MIT_License

The full text of the MIT License follows:

========================================================================
Copyright (c) 2007-2010 Baptiste Lepilleur

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
========================================================================
(END LICENSE TEXT)

The MIT license is compatible with both the GPL and commercial
software, affording one all of the rights of Public Domain with the
minor nuisance of being required to keep the above copyright notice
and license text in the source code. Note also that by accepting the
Public Domain "license" you can re-license your copy using whatever
license you like.

*/

// //////////////////////////////////////////////////////////////////////
// End of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////

#ifndef JSON_AMALGATED_H_INCLUDED
# define JSON_AMALGATED_H_INCLUDED
/// If defined, indicates that the source file is amalgated
/// to prevent private header inclusion.
#define JSON_IS_AMALGAMATION

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/version.h
// //////////////////////////////////////////////////////////////////////

// DO NOT EDIT. This file (and "version") is generated by CMake.
// Run CMake configure step to update it.
#ifndef JSON_VERSION_H_INCLUDED
# define JSON_VERSION_H_INCLUDED

# define JSONCPP_VERSION_STRING "1.7.7"
# define JSONCPP_VERSION_MAJOR 1
# define JSONCPP_VERSION_MINOR 7
# define JSONCPP_VERSION_PATCH 7
# define JSONCPP_VERSION_QUALIFIER
# define JSONCPP_VERSION_HEXA ((JSONCPP_VERSION_MAJOR << 24) | (JSONCPP_VERSION_MINOR << 16) | (JSONCPP_VERSION_PATCH << 8))

#ifdef JSONCPP_USING_SECURE_MEMORY
#undef JSONCPP_USING_SECURE_MEMORY
#endif
#define JSONCPP_USING_SECURE_MEMORY 0
// If non-zero, the library zeroes any memory that it has allocated before
// it frees its memory.

#endif // JSON_VERSION_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/version.h
// //////////////////////////////////////////////////////////////////////

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/config.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef JSON_CONFIG_H_INCLUDED
#define JSON_CONFIG_H_INCLUDED
#include <stddef.h>
#include <string> //typedef String
#include <stdint.h> //typedef int64_t, uint64_t

/// If defined, indicates that json library is embedded in CppTL library.
//# define JSON_IN_CPPTL 1

/// If defined, indicates that json may leverage CppTL library
//#  define JSON_USE_CPPTL 1
/// If defined, indicates that cpptl vector based map should be used instead of
/// std::map
/// as Value container.
//#  define JSON_USE_CPPTL_SMALLMAP 1

// If non-zero, the library uses exceptions to report bad input instead of C
// assertion macros. The default is to use exceptions.
#ifndef JSON_USE_EXCEPTION
#define JSON_USE_EXCEPTION 1
#endif

/// If defined, indicates that the source file is amalgated
/// to prevent private header inclusion.
/// Remarks: it is automatically defined in the generated amalgated header.
// #define JSON_IS_AMALGAMATION

#ifdef JSON_IN_CPPTL
#include <cpptl/config.h>
#ifndef JSON_USE_CPPTL
#define JSON_USE_CPPTL 1
#endif
#endif

#ifdef JSON_IN_CPPTL
#define JSON_API CPPTL_API
#elif defined(JSON_DLL_BUILD)
#if defined(_MSC_VER) || defined(__MINGW32__)
#define JSON_API __declspec(dllexport)
#define JSONCPP_DISABLE_DLL_INTERFACE_WARNING
#endif // if defined(_MSC_VER)
#elif defined(JSON_DLL)
#if defined(_MSC_VER) || defined(__MINGW32__)
#define JSON_API __declspec(dllimport)
#define JSONCPP_DISABLE_DLL_INTERFACE_WARNING
#endif // if defined(_MSC_VER)
#endif // ifdef JSON_IN_CPPTL
#if !defined(JSON_API)
#define JSON_API
#endif

// If JSON_NO_INT64 is defined, then Json only support C++ "int" type for
// integer
// Storages, and 64 bits integer support is disabled.
// #define JSON_NO_INT64 1

#if defined(_MSC_VER) // MSVC
#  if _MSC_VER <= 1200 // MSVC 6
	// Microsoft Visual Studio 6 only support conversion from __int64 to double
	// (no conversion from unsigned __int64).
#    define JSON_USE_INT64_DOUBLE_CONVERSION 1
	// Disable warning 4786 for VS6 caused by STL (identifier was truncated to '255'
	// characters in the debug information)
	// All projects I've ever seen with VS6 were using this globally (not bothering
	// with pragma push/pop).
#    pragma warning(disable : 4786)
#  endif // MSVC 6

#  if _MSC_VER >= 1500 // MSVC 2008
	/// Indicates that the following function is deprecated.
#    define JSONCPP_DEPRECATED(message) __declspec(deprecated(message))
#  endif

#endif // defined(_MSC_VER)

// In c++11 the override keyword allows you to explicity define that a function
// is intended to override the base-class version.  This makes the code more
// managable and fixes a set of common hard-to-find bugs.
#if __cplusplus >= 201103L
# define JSONCPP_OVERRIDE override
#elif defined(_MSC_VER) && _MSC_VER > 1600
# define JSONCPP_OVERRIDE override
#else
# define JSONCPP_OVERRIDE
#endif

#ifndef JSON_HAS_RVALUE_REFERENCES

#if defined(_MSC_VER) && _MSC_VER >= 1600 // MSVC >= 2010
#define JSON_HAS_RVALUE_REFERENCES 1
#endif // MSVC >= 2010

#ifdef __clang__
#if __has_feature(cxx_rvalue_references)
#define JSON_HAS_RVALUE_REFERENCES 1
#endif  // has_feature

#elif defined __GNUC__ // not clang (gcc comes later since clang emulates gcc)
#if defined(__GXX_EXPERIMENTAL_CXX0X__) || (__cplusplus >= 201103L)
#define JSON_HAS_RVALUE_REFERENCES 1
#endif  // GXX_EXPERIMENTAL

#endif // __clang__ || __GNUC__

#endif // not defined JSON_HAS_RVALUE_REFERENCES

#ifndef JSON_HAS_RVALUE_REFERENCES
#define JSON_HAS_RVALUE_REFERENCES 0
#endif

#ifdef __clang__
#elif defined __GNUC__ // not clang (gcc comes later since clang emulates gcc)
#  if (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))
#    define JSONCPP_DEPRECATED(message)  __attribute__ ((deprecated(message)))
#  elif (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))
#    define JSONCPP_DEPRECATED(message)  __attribute__((__deprecated__))
#  endif  // GNUC version
#endif // __clang__ || __GNUC__

#if !defined(JSONCPP_DEPRECATED)
#define JSONCPP_DEPRECATED(message)
#endif // if !defined(JSONCPP_DEPRECATED)

#if __GNUC__ >= 6
#  define JSON_USE_INT64_DOUBLE_CONVERSION 1
#endif

#if !defined(JSON_IS_AMALGAMATION)

# include "version.h"

# if JSONCPP_USING_SECURE_MEMORY
#  include "allocator.h" //typedef Allocator
# endif

#endif // if !defined(JSON_IS_AMALGAMATION)

namespace Json {
	typedef int Int;
	typedef unsigned int UInt;
#if defined(JSON_NO_INT64)
	typedef int LargestInt;
	typedef unsigned int LargestUInt;
#undef JSON_HAS_INT64
#else                 // if defined(JSON_NO_INT64)
	// For Microsoft Visual use specific types as long long is not supported
#if defined(_MSC_VER) // Microsoft Visual Studio
	typedef __int64 Int64;
	typedef unsigned __int64 UInt64;
#else                 // if defined(_MSC_VER) // Other platforms, use long long
	typedef int64_t Int64;
	typedef uint64_t UInt64;
#endif // if defined(_MSC_VER)
	typedef Int64 LargestInt;
	typedef UInt64 LargestUInt;
#define JSON_HAS_INT64
#endif // if defined(JSON_NO_INT64)
#if JSONCPP_USING_SECURE_MEMORY
#define JSONCPP_STRING        std::basic_string<char, std::char_traits<char>, Json::SecureAllocator<char> >
#define JSONCPP_OSTRINGSTREAM std::basic_ostringstream<char, std::char_traits<char>, Json::SecureAllocator<char> >
#define JSONCPP_OSTREAM       std::basic_ostream<char, std::char_traits<char>>
#define JSONCPP_ISTRINGSTREAM std::basic_istringstream<char, std::char_traits<char>, Json::SecureAllocator<char> >
#define JSONCPP_ISTREAM       std::istream
#else
#define JSONCPP_STRING        std::string
#define JSONCPP_OSTRINGSTREAM std::ostringstream
#define JSONCPP_OSTREAM       std::ostream
#define JSONCPP_ISTRINGSTREAM std::istringstream
#define JSONCPP_ISTREAM       std::istream
#endif // if JSONCPP_USING_SECURE_MEMORY
} // end namespace Json

#endif // JSON_CONFIG_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/config.h
// //////////////////////////////////////////////////////////////////////

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/forwards.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef JSON_FORWARDS_H_INCLUDED
#define JSON_FORWARDS_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include "config.h"
#endif // if !defined(JSON_IS_AMALGAMATION)

namespace Json {
	// writer.h
	class FastWriter;
	class StyledWriter;

	// reader.h
	class Reader;

	// features.h
	class Features;

	// value.h
	typedef unsigned int ArrayIndex;
	class StaticString;
	class Path;
	class PathArgument;
	class Value;
	class ValueIteratorBase;
	class ValueIterator;
	class ValueConstIterator;
} // namespace Json

#endif // JSON_FORWARDS_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/forwards.h
// //////////////////////////////////////////////////////////////////////

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/features.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef CPPTL_JSON_FEATURES_H_INCLUDED
#define CPPTL_JSON_FEATURES_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include "forwards.h"
#endif // if !defined(JSON_IS_AMALGAMATION)

namespace Json {
	/** \brief Configuration passed to reader and writer.
	 * This configuration object can be used to force the Reader or Writer
	 * to behave in a standard conforming way.
	 */
	class JSON_API Features {
	public:
		/** \brief A configuration that allows all features and assumes all strings
		 * are UTF-8.
		 * - C & C++ comments are allowed
		 * - Root object can be any JSON value
		 * - Assumes Value strings are encoded in UTF-8
		 */
		static Features all();

		/** \brief A configuration that is strictly compatible with the JSON
		 * specification.
		 * - Comments are forbidden.
		 * - Root object must be either an array or an object value.
		 * - Assumes Value strings are encoded in UTF-8
		 */
		static Features strictMode();

		/** \brief Initialize the configuration like JsonConfig::allFeatures;
		 */
		Features();

		/// \c true if comments are allowed. Default: \c true.
		bool allowComments_;

		/// \c true if root must be either an array or an object value. Default: \c
		/// false.
		bool strictRoot_;

		/// \c true if dropped null placeholders are allowed. Default: \c false.
		bool allowDroppedNullPlaceholders_;

		/// \c true if numeric object key are allowed. Default: \c false.
		bool allowNumericKeys_;
	};
} // namespace Json

#endif // CPPTL_JSON_FEATURES_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/features.h
// //////////////////////////////////////////////////////////////////////

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/value.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef CPPTL_JSON_H_INCLUDED
#define CPPTL_JSON_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include "forwards.h"
#endif // if !defined(JSON_IS_AMALGAMATION)
#include <string>
#include <vector>
#include <exception>

#ifndef JSON_USE_CPPTL_SMALLMAP
#include <map>
#else
#include <cpptl/smallmap.h>
#endif
#ifdef JSON_USE_CPPTL
#include <cpptl/forwards.h>
#endif

//Conditional NORETURN attribute on the throw functions would:
// a) suppress false positives from static code analysis
// b) possibly improve optimization opportunities.
#if !defined(JSONCPP_NORETURN)
#  if defined(_MSC_VER)
#    define JSONCPP_NORETURN __declspec(noreturn)
#  elif defined(__GNUC__)
#    define JSONCPP_NORETURN __attribute__ ((__noreturn__))
#  else
#    define JSONCPP_NORETURN
#  endif
#endif

// Disable warning C4251: <data member>: <type> needs to have dll-interface to
// be used by...
#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
#pragma warning(push)
#pragma warning(disable : 4251)
#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)

/** \brief JSON (JavaScript Object Notation).
 */
namespace Json {
	/** Base class for all exceptions we throw.
	 *
	 * We use nothing but these internally. Of course, STL can throw others.
	 */
	class JSON_API Exception : public std::exception {
	public:
		Exception(JSONCPP_STRING const& msg);
		~Exception() throw() JSONCPP_OVERRIDE;
		char const* what() const throw() JSONCPP_OVERRIDE;
	protected:
		JSONCPP_STRING msg_;
	};

	/** Exceptions which the user cannot easily avoid.
	 *
	 * E.g. out-of-memory (when we use malloc), stack-overflow, malicious input
	 *
	 * \remark derived from Json::Exception
	 */
	class JSON_API RuntimeError : public Exception {
	public:
		RuntimeError(JSONCPP_STRING const& msg);
	};

	/** Exceptions thrown by JSON_ASSERT/JSON_FAIL macros.
	 *
	 * These are precondition-violations (user bugs) and internal errors (our bugs).
	 *
	 * \remark derived from Json::Exception
	 */
	class JSON_API LogicError : public Exception {
	public:
		LogicError(JSONCPP_STRING const& msg);
	};

	/// used internally
	JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg);
	/// used internally
	JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg);

	/** \brief Type of the value held by a Value object.
	 */
	enum ValueType {
		nullValue = 0, ///< 'null' value
		intValue,      ///< signed integer value
		uintValue,     ///< unsigned integer value
		realValue,     ///< double value
		stringValue,   ///< UTF-8 string value
		booleanValue,  ///< bool value
		arrayValue,    ///< array value (ordered list)
		objectValue    ///< object value (collection of name/value pairs).
	};

	enum CommentPlacement {
		commentBefore = 0,      ///< a comment placed on the line before a value
		commentAfterOnSameLine, ///< a comment just after a value on the same line
		commentAfter, ///< a comment on the line after a value (only make sense for
		/// root value)
		numberOfCommentPlacement
	};

	//# ifdef JSON_USE_CPPTL
	//   typedef CppTL::AnyEnumerator<const char *> EnumMemberNames;
	//   typedef CppTL::AnyEnumerator<const Value &> EnumValues;
	//# endif

	/** \brief Lightweight wrapper to tag static string.
	 *
	 * Value constructor and objectValue member assignement takes advantage of the
	 * StaticString and avoid the cost of string duplication when storing the
	 * string or the member name.
	 *
	 * Example of usage:
	 * \code
	 * Json::Value aValue( StaticString("some text") );
	 * Json::Value object;
	 * static const StaticString code("code");
	 * object[code] = 1234;
	 * \endcode
	 */
	class JSON_API StaticString {
	public:
		explicit StaticString(const char* czstring) : c_str_(czstring) {}

		operator const char* () const { return c_str_; }

		const char* c_str() const { return c_str_; }

	private:
		const char* c_str_;
	};

	/** \brief Represents a <a HREF="http://www.json.org">JSON</a> value.
	 *
	 * This class is a discriminated union wrapper that can represents a:
	 * - signed integer [range: Value::minInt - Value::maxInt]
	 * - unsigned integer (range: 0 - Value::maxUInt)
	 * - double
	 * - UTF-8 string
	 * - boolean
	 * - 'null'
	 * - an ordered list of Value
	 * - collection of name/value pairs (javascript object)
	 *
	 * The type of the held value is represented by a #ValueType and
	 * can be obtained using type().
	 *
	 * Values of an #objectValue or #arrayValue can be accessed using operator[]()
	 * methods.
	 * Non-const methods will automatically create the a #nullValue element
	 * if it does not exist.
	 * The sequence of an #arrayValue will be automatically resized and initialized
	 * with #nullValue. resize() can be used to enlarge or truncate an #arrayValue.
	 *
	 * The get() methods can be used to obtain default value in the case the
	 * required element does not exist.
	 *
	 * It is possible to iterate over the list of a #objectValue values using
	 * the getMemberNames() method.
	 *
	 * \note #Value string-length fit in size_t, but keys must be < 2^30.
	 * (The reason is an implementation detail.) A #CharReader will raise an
	 * exception if a bound is exceeded to avoid security holes in your app,
	 * but the Value API does *not* check bounds. That is the responsibility
	 * of the caller.
	 */
	class JSON_API Value {
		friend class ValueIteratorBase;
	public:
		typedef std::vector<JSONCPP_STRING> Members;
		typedef ValueIterator iterator;
		typedef ValueConstIterator const_iterator;
		typedef Json::UInt UInt;
		typedef Json::Int Int;
#if defined(JSON_HAS_INT64)
		typedef Json::UInt64 UInt64;
		typedef Json::Int64 Int64;
#endif // defined(JSON_HAS_INT64)
		typedef Json::LargestInt LargestInt;
		typedef Json::LargestUInt LargestUInt;
		typedef Json::ArrayIndex ArrayIndex;

		static const Value& null;  ///< We regret this reference to a global instance; prefer the simpler Value().
		static const Value& nullRef;  ///< just a kludge for binary-compatibility; same as null
		static Value const& nullSingleton(); ///< Prefer this to null or nullRef.

		/// Minimum signed integer value that can be stored in a Json::Value.
		static const LargestInt minLargestInt;
		/// Maximum signed integer value that can be stored in a Json::Value.
		static const LargestInt maxLargestInt;
		/// Maximum unsigned integer value that can be stored in a Json::Value.
		static const LargestUInt maxLargestUInt;

		/// Minimum signed int value that can be stored in a Json::Value.
		static const Int minInt;
		/// Maximum signed int value that can be stored in a Json::Value.
		static const Int maxInt;
		/// Maximum unsigned int value that can be stored in a Json::Value.
		static const UInt maxUInt;

#if defined(JSON_HAS_INT64)
		/// Minimum signed 64 bits int value that can be stored in a Json::Value.
		static const Int64 minInt64;
		/// Maximum signed 64 bits int value that can be stored in a Json::Value.
		static const Int64 maxInt64;
		/// Maximum unsigned 64 bits int value that can be stored in a Json::Value.
		static const UInt64 maxUInt64;
#endif // defined(JSON_HAS_INT64)

	private:
#ifndef JSONCPP_DOC_EXCLUDE_IMPLEMENTATION
		class CZString {
		public:
			enum DuplicationPolicy {
				noDuplication = 0,
				duplicate,
				duplicateOnCopy
			};
			CZString(ArrayIndex index);
			CZString(char const* str, unsigned length, DuplicationPolicy allocate);
			CZString(CZString const& other);
#if JSON_HAS_RVALUE_REFERENCES
			CZString(CZString&& other);
#endif
			~CZString();
			CZString& operator=(CZString other);
			bool operator<(CZString const& other) const;
			bool operator==(CZString const& other) const;
			ArrayIndex index() const;
			//const char* c_str() const; ///< \deprecated
			char const* data() const;
			unsigned length() const;
			bool isStaticString() const;

		private:
			void swap(CZString& other);

			struct StringStorage {
				unsigned policy_ : 2;
				unsigned length_ : 30; // 1GB max
			};

			char const* cstr_;  // actually, a prefixed string, unless policy is noDup
			union {
				ArrayIndex index_;
				StringStorage storage_;
			};
		};

	public:
#ifndef JSON_USE_CPPTL_SMALLMAP
		typedef std::map<CZString, Value> ObjectValues;
#else
		typedef CppTL::SmallMap<CZString, Value> ObjectValues;
#endif // ifndef JSON_USE_CPPTL_SMALLMAP
#endif // ifndef JSONCPP_DOC_EXCLUDE_IMPLEMENTATION

	public:
		/** \brief Create a default Value of the given type.

		  This is a very useful constructor.
		  To create an empty array, pass arrayValue.
		  To create an empty object, pass objectValue.
		  Another Value can then be set to this one by assignment.
	  This is useful since clear() and resize() will not alter types.

		  Examples:
	  \code
	  Json::Value null_value; // null
	  Json::Value arr_value(Json::arrayValue); // []
	  Json::Value obj_value(Json::objectValue); // {}
	  \endcode
		*/
		Value(ValueType type = nullValue);
		Value(Int value);
		Value(UInt value);
#if defined(JSON_HAS_INT64)
		Value(Int64 value);
		Value(UInt64 value);
#endif // if defined(JSON_HAS_INT64)
		Value(double value);
		Value(const char* value); ///< Copy til first 0. (NULL causes to seg-fault.)
		Value(const char* begin, const char* end); ///< Copy all, incl zeroes.
		/** \brief Constructs a value from a static string.

		 * Like other value string constructor but do not duplicate the string for
		 * internal storage. The given string must remain alive after the call to this
		 * constructor.
		 * \note This works only for null-terminated strings. (We cannot change the
		 *   size of this class, so we have nowhere to store the length,
		 *   which might be computed later for various operations.)
		 *
		 * Example of usage:
		 * \code
		 * static StaticString foo("some text");
		 * Json::Value aValue(foo);
		 * \endcode
		 */
		Value(const StaticString& value);
		Value(const JSONCPP_STRING& value); ///< Copy data() til size(). Embedded zeroes too.
#ifdef JSON_USE_CPPTL
		Value(const CppTL::ConstString& value);
#endif
		Value(bool value);
		/// Deep copy.
		Value(const Value& other);
#if JSON_HAS_RVALUE_REFERENCES
		/// Move constructor
		Value(Value&& other);
#endif
		~Value();

		/// Deep copy, then swap(other).
		/// \note Over-write existing comments. To preserve comments, use #swapPayload().
		Value& operator=(Value other);
		/// Swap everything.
		void swap(Value& other);
		/// Swap values but leave comments and source offsets in place.
		void swapPayload(Value& other);

		ValueType type() const;

		/// Compare payload only, not comments etc.
		bool operator<(const Value& other) const;
		bool operator<=(const Value& other) const;
		bool operator>=(const Value& other) const;
		bool operator>(const Value& other) const;
		bool operator==(const Value& other) const;
		bool operator!=(const Value& other) const;
		int compare(const Value& other) const;

		const char* asCString() const; ///< Embedded zeroes could cause you trouble!
#if JSONCPP_USING_SECURE_MEMORY
		unsigned getCStringLength() const; //Allows you to understand the length of the CString
#endif
		JSONCPP_STRING asString() const; ///< Embedded zeroes are possible.
		/** Get raw char* of string-value.
		 *  \return false if !string. (Seg-fault if str or end are NULL.)
		 */
		bool getString(
			char const** begin, char const** end) const;
#ifdef JSON_USE_CPPTL
		CppTL::ConstString asConstString() const;
#endif
		Int asInt() const;
		UInt asUInt() const;
#if defined(JSON_HAS_INT64)
		Int64 asInt64() const;
		UInt64 asUInt64() const;
#endif // if defined(JSON_HAS_INT64)
		LargestInt asLargestInt() const;
		LargestUInt asLargestUInt() const;
		float asFloat() const;
		double asDouble() const;
		bool asBool() const;

		bool isNull() const;
		bool isBool() const;
		bool isInt() const;
		bool isInt64() const;
		bool isUInt() const;
		bool isUInt64() const;
		bool isIntegral() const;
		bool isDouble() const;
		bool isNumeric() const;
		bool isString() const;
		bool isArray() const;
		bool isObject() const;

		bool isConvertibleTo(ValueType other) const;

		/// Number of values in array or object
		ArrayIndex size() const;

		/// \brief Return true if empty array, empty object, or null;
		/// otherwise, false.
		bool empty() const;

		/// Return isNull()
		bool operator!() const;

		/// Remove all object members and array elements.
		/// \pre type() is arrayValue, objectValue, or nullValue
		/// \post type() is unchanged
		void clear();

		/// Resize the array to size elements.
		/// New elements are initialized to null.
		/// May only be called on nullValue or arrayValue.
		/// \pre type() is arrayValue or nullValue
		/// \post type() is arrayValue
		void resize(ArrayIndex size);

		/// Access an array element (zero based index ).
		/// If the array contains less than index element, then null value are
		/// inserted
		/// in the array so that its size is index+1.
		/// (You may need to say 'value[0u]' to get your compiler to distinguish
		///  this from the operator[] which takes a string.)
		Value& operator[](ArrayIndex index);

		/// Access an array element (zero based index ).
		/// If the array contains less than index element, then null value are
		/// inserted
		/// in the array so that its size is index+1.
		/// (You may need to say 'value[0u]' to get your compiler to distinguish
		///  this from the operator[] which takes a string.)
		Value& operator[](int index);

		/// Access an array element (zero based index )
		/// (You may need to say 'value[0u]' to get your compiler to distinguish
		///  this from the operator[] which takes a string.)
		const Value& operator[](ArrayIndex index) const;

		/// Access an array element (zero based index )
		/// (You may need to say 'value[0u]' to get your compiler to distinguish
		///  this from the operator[] which takes a string.)
		const Value& operator[](int index) const;

		/// If the array contains at least index+1 elements, returns the element
		/// value,
		/// otherwise returns defaultValue.
		Value get(ArrayIndex index, const Value& defaultValue) const;
		/// Return true if index < size().
		bool isValidIndex(ArrayIndex index) const;
		/// \brief Append value to array at the end.
		///
		/// Equivalent to jsonvalue[jsonvalue.size()] = value;
		Value& append(const Value& value);

		/// Access an object value by name, create a null member if it does not exist.
		/// \note Because of our implementation, keys are limited to 2^30 -1 chars.
		///  Exceeding that will cause an exception.
		Value& operator[](const char* key);
		/// Access an object value by name, returns null if there is no member with
		/// that name.
		const Value& operator[](const char* key) const;
		/// Access an object value by name, create a null member if it does not exist.
		/// \param key may contain embedded nulls.
		Value& operator[](const JSONCPP_STRING& key);
		/// Access an object value by name, returns null if there is no member with
		/// that name.
		/// \param key may contain embedded nulls.
		const Value& operator[](const JSONCPP_STRING& key) const;
		/** \brief Access an object value by name, create a null member if it does not
		 exist.

		 * If the object has no entry for that name, then the member name used to store
		 * the new entry is not duplicated.
		 * Example of use:
		 * \code
		 * Json::Value object;
		 * static const StaticString code("code");
		 * object[code] = 1234;
		 * \endcode
		 */
		Value& operator[](const StaticString& key);
#ifdef JSON_USE_CPPTL
		/// Access an object value by name, create a null member if it does not exist.
		Value& operator[](const CppTL::ConstString& key);
		/// Access an object value by name, returns null if there is no member with
		/// that name.
		const Value& operator[](const CppTL::ConstString& key) const;
#endif
		/// Return the member named key if it exist, defaultValue otherwise.
		/// \note deep copy
		Value get(const char* key, const Value& defaultValue) const;
		/// Return the member named key if it exist, defaultValue otherwise.
		/// \note deep copy
		/// \note key may contain embedded nulls.
		Value get(const char* begin, const char* end, const Value& defaultValue) const;
		/// Return the member named key if it exist, defaultValue otherwise.
		/// \note deep copy
		/// \param key may contain embedded nulls.
		Value get(const JSONCPP_STRING& key, const Value& defaultValue) const;
#ifdef JSON_USE_CPPTL
		/// Return the member named key if it exist, defaultValue otherwise.
		/// \note deep copy
		Value get(const CppTL::ConstString& key, const Value& defaultValue) const;
#endif
		/// Most general and efficient version of isMember()const, get()const,
		/// and operator[]const
		/// \note As stated elsewhere, behavior is undefined if (end-begin) >= 2^30
		Value const* find(char const* begin, char const* end) const;
		/// Most general and efficient version of object-mutators.
		/// \note As stated elsewhere, behavior is undefined if (end-begin) >= 2^30
		/// \return non-zero, but JSON_ASSERT if this is neither object nor nullValue.
		Value const* demand(char const* begin, char const* end);
		/// \brief Remove and return the named member.
		///
		/// Do nothing if it did not exist.
		/// \return the removed Value, or null.
		/// \pre type() is objectValue or nullValue
		/// \post type() is unchanged
		/// \deprecated
		Value removeMember(const char* key);
		/// Same as removeMember(const char*)
		/// \param key may contain embedded nulls.
		/// \deprecated
		Value removeMember(const JSONCPP_STRING& key);
		/// Same as removeMember(const char* begin, const char* end, Value* removed),
		/// but 'key' is null-terminated.
		bool removeMember(const char* key, Value* removed);
		/** \brief Remove the named map member.

			Update 'removed' iff removed.
			\param key may contain embedded nulls.
			\return true iff removed (no exceptions)
		*/
		bool removeMember(JSONCPP_STRING const& key, Value* removed);
		/// Same as removeMember(JSONCPP_STRING const& key, Value* removed)
		bool removeMember(const char* begin, const char* end, Value* removed);
		/** \brief Remove the indexed array element.

			O(n) expensive operations.
			Update 'removed' iff removed.
			\return true iff removed (no exceptions)
		*/
		bool removeIndex(ArrayIndex i, Value* removed);

		/// Return true if the object has a member named key.
		/// \note 'key' must be null-terminated.
		bool isMember(const char* key) const;
		/// Return true if the object has a member named key.
		/// \param key may contain embedded nulls.
		bool isMember(const JSONCPP_STRING& key) const;
		/// Same as isMember(JSONCPP_STRING const& key)const
		bool isMember(const char* begin, const char* end) const;
#ifdef JSON_USE_CPPTL
		/// Return true if the object has a member named key.
		bool isMember(const CppTL::ConstString& key) const;
#endif

		/// \brief Return a list of the member names.
		///
		/// If null, return an empty list.
		/// \pre type() is objectValue or nullValue
		/// \post if type() was nullValue, it remains nullValue
		Members getMemberNames() const;

		//# ifdef JSON_USE_CPPTL
		//      EnumMemberNames enumMemberNames() const;
		//      EnumValues enumValues() const;
		//# endif

		/// \deprecated Always pass len.
		JSONCPP_DEPRECATED("Use setComment(JSONCPP_STRING const&) instead.")
			void setComment(const char* comment, CommentPlacement placement);
		/// Comments must be //... or /* ... */
		void setComment(const char* comment, size_t len, CommentPlacement placement);
		/// Comments must be //... or /* ... */
		void setComment(const JSONCPP_STRING& comment, CommentPlacement placement);
		bool hasComment(CommentPlacement placement) const;
		/// Include delimiters and embedded newlines.
		JSONCPP_STRING getComment(CommentPlacement placement) const;

		JSONCPP_STRING toStyledString() const;

		const_iterator begin() const;
		const_iterator end() const;

		iterator begin();
		iterator end();

		// Accessors for the [start, limit) range of bytes within the JSON text from
		// which this value was parsed, if any.
		void setOffsetStart(ptrdiff_t start);
		void setOffsetLimit(ptrdiff_t limit);
		ptrdiff_t getOffsetStart() const;
		ptrdiff_t getOffsetLimit() const;

	private:
		void initBasic(ValueType type, bool allocated = false);

		Value& resolveReference(const char* key);
		Value& resolveReference(const char* key, const char* end);

		struct CommentInfo {
			CommentInfo();
			~CommentInfo();

			void setComment(const char* text, size_t len);

			char* comment_;
		};

		// struct MemberNamesTransform
		//{
		//   typedef const char *result_type;
		//   const char *operator()( const CZString &name ) const
		//   {
		//      return name.c_str();
		//   }
		//};

		union ValueHolder {
			LargestInt int_;
			LargestUInt uint_;
			double real_;
			bool bool_;
			char* string_;  // actually ptr to unsigned, followed by str, unless !allocated_
			ObjectValues* map_;
		} value_;
		ValueType type_ : 8;
		unsigned int allocated_ : 1; // Notes: if declared as bool, bitfield is useless.
									 // If not allocated_, string_ must be null-terminated.
		CommentInfo* comments_;

		// [start, limit) byte offsets in the source JSON text from which this Value
		// was extracted.
		ptrdiff_t start_;
		ptrdiff_t limit_;
	};

	/** \brief Experimental and untested: represents an element of the "path" to
	 * access a node.
	 */
	class JSON_API PathArgument {
	public:
		friend class Path;

		PathArgument();
		PathArgument(ArrayIndex index);
		PathArgument(const char* key);
		PathArgument(const JSONCPP_STRING& key);

	private:
		enum Kind {
			kindNone = 0,
			kindIndex,
			kindKey
		};
		JSONCPP_STRING key_;
		ArrayIndex index_;
		Kind kind_;
	};

	/** \brief Experimental and untested: represents a "path" to access a node.
	 *
	 * Syntax:
	 * - "." => root node
	 * - ".[n]" => elements at index 'n' of root node (an array value)
	 * - ".name" => member named 'name' of root node (an object value)
	 * - ".name1.name2.name3"
	 * - ".[0][1][2].name1[3]"
	 * - ".%" => member name is provided as parameter
	 * - ".[%]" => index is provied as parameter
	 */
	class JSON_API Path {
	public:
		Path(const JSONCPP_STRING& path,
			const PathArgument& a1 = PathArgument(),
			const PathArgument& a2 = PathArgument(),
			const PathArgument& a3 = PathArgument(),
			const PathArgument& a4 = PathArgument(),
			const PathArgument& a5 = PathArgument());

		const Value& resolve(const Value& root) const;
		Value resolve(const Value& root, const Value& defaultValue) const;
		/// Creates the "path" to access the specified node and returns a reference on
		/// the node.
		Value& make(Value& root) const;

	private:
		typedef std::vector<const PathArgument*> InArgs;
		typedef std::vector<PathArgument> Args;

		void makePath(const JSONCPP_STRING& path, const InArgs& in);
		void addPathInArg(const JSONCPP_STRING& path,
			const InArgs& in,
			InArgs::const_iterator& itInArg,
			PathArgument::Kind kind);
		void invalidPath(const JSONCPP_STRING& path, int location);

		Args args_;
	};

	/** \brief base class for Value iterators.
	 *
	 */
	class JSON_API ValueIteratorBase {
	public:
		typedef std::bidirectional_iterator_tag iterator_category;
		typedef unsigned int size_t;
		typedef int difference_type;
		typedef ValueIteratorBase SelfType;

		bool operator==(const SelfType& other) const { return isEqual(other); }

		bool operator!=(const SelfType& other) const { return !isEqual(other); }

		difference_type operator-(const SelfType& other) const {
			return other.computeDistance(*this);
		}

		/// Return either the index or the member name of the referenced value as a
		/// Value.
		Value key() const;

		/// Return the index of the referenced Value, or -1 if it is not an arrayValue.
		UInt index() const;

		/// Return the member name of the referenced Value, or "" if it is not an
		/// objectValue.
		/// \note Avoid `c_str()` on result, as embedded zeroes are possible.
		JSONCPP_STRING name() const;

		/// Return the member name of the referenced Value. "" if it is not an
		/// objectValue.
		/// \deprecated This cannot be used for UTF-8 strings, since there can be embedded nulls.
		JSONCPP_DEPRECATED("Use `key = name();` instead.")
			char const* memberName() const;
		/// Return the member name of the referenced Value, or NULL if it is not an
		/// objectValue.
		/// \note Better version than memberName(). Allows embedded nulls.
		char const* memberName(char const** end) const;

	protected:
		Value& deref() const;

		void increment();

		void decrement();

		difference_type computeDistance(const SelfType& other) const;

		bool isEqual(const SelfType& other) const;

		void copy(const SelfType& other);

	private:
		Value::ObjectValues::iterator current_;
		// Indicates that iterator is for a null value.
		bool isNull_;

	public:
		// For some reason, BORLAND needs these at the end, rather
		// than earlier. No idea why.
		ValueIteratorBase();
		explicit ValueIteratorBase(const Value::ObjectValues::iterator& current);
	};

	/** \brief const iterator for object and array value.
	 *
	 */
	class JSON_API ValueConstIterator : public ValueIteratorBase {
		friend class Value;

	public:
		typedef const Value value_type;
		//typedef unsigned int size_t;
		//typedef int difference_type;
		typedef const Value& reference;
		typedef const Value* pointer;
		typedef ValueConstIterator SelfType;

		ValueConstIterator();
		ValueConstIterator(ValueIterator const& other);

	private:
		/*! \internal Use by Value to create an iterator.
		 */
		explicit ValueConstIterator(const Value::ObjectValues::iterator& current);
	public:
		SelfType& operator=(const ValueIteratorBase& other);

		SelfType operator++(int) {
			SelfType temp(*this);
			++* this;
			return temp;
		}

		SelfType operator--(int) {
			SelfType temp(*this);
			--* this;
			return temp;
		}

		SelfType& operator--() {
			decrement();
			return *this;
		}

		SelfType& operator++() {
			increment();
			return *this;
		}

		reference operator*() const { return deref(); }

		pointer operator->() const { return &deref(); }
	};

	/** \brief Iterator for object and array value.
	 */
	class JSON_API ValueIterator : public ValueIteratorBase {
		friend class Value;

	public:
		typedef Value value_type;
		typedef unsigned int size_t;
		typedef int difference_type;
		typedef Value& reference;
		typedef Value* pointer;
		typedef ValueIterator SelfType;

		ValueIterator();
		explicit ValueIterator(const ValueConstIterator& other);
		ValueIterator(const ValueIterator& other);

	private:
		/*! \internal Use by Value to create an iterator.
		 */
		explicit ValueIterator(const Value::ObjectValues::iterator& current);
	public:
		SelfType& operator=(const SelfType& other);

		SelfType operator++(int) {
			SelfType temp(*this);
			++* this;
			return temp;
		}

		SelfType operator--(int) {
			SelfType temp(*this);
			--* this;
			return temp;
		}

		SelfType& operator--() {
			decrement();
			return *this;
		}

		SelfType& operator++() {
			increment();
			return *this;
		}

		reference operator*() const { return deref(); }

		pointer operator->() const { return &deref(); }
	};
} // namespace Json

namespace std {
	/// Specialize std::swap() for Json::Value.
	template<>
	inline void swap(Json::Value& a, Json::Value& b) noexcept { a.swap(b); }
}

#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
#pragma warning(pop)
#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)

#endif // CPPTL_JSON_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/value.h
// //////////////////////////////////////////////////////////////////////

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/reader.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef CPPTL_JSON_READER_H_INCLUDED
#define CPPTL_JSON_READER_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include "features.h"
#include "value.h"
#endif // if !defined(JSON_IS_AMALGAMATION)
#include <deque>
#include <iosfwd>
#include <stack>
#include <string>
#include <istream>

// Disable warning C4251: <data member>: <type> needs to have dll-interface to
// be used by...
#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
#pragma warning(push)
#pragma warning(disable : 4251)
#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)

namespace Json {
	/** \brief Unserialize a <a HREF="http://www.json.org">JSON</a> document into a
	 *Value.
	 *
	 * \deprecated Use CharReader and CharReaderBuilder.
	 */
	class JSON_API Reader {
	public:
		typedef char Char;
		typedef const Char* Location;

		/** \brief An error tagged with where in the JSON text it was encountered.
		 *
		 * The offsets give the [start, limit) range of bytes within the text. Note
		 * that this is bytes, not codepoints.
		 *
		 */
		struct StructuredError {
			ptrdiff_t offset_start;
			ptrdiff_t offset_limit;
			JSONCPP_STRING message;
		};

		/** \brief Constructs a Reader allowing all features
		 * for parsing.
		 */
		Reader();

		/** \brief Constructs a Reader allowing the specified feature set
		 * for parsing.
		 */
		Reader(const Features& features);

		/** \brief Read a Value from a <a HREF="http://www.json.org">JSON</a>
		 * document.
		 * \param document UTF-8 encoded string containing the document to read.
		 * \param root [out] Contains the root value of the document if it was
		 *             successfully parsed.
		 * \param collectComments \c true to collect comment and allow writing them
		 * back during
		 *                        serialization, \c false to discard comments.
		 *                        This parameter is ignored if
		 * Features::allowComments_
		 *                        is \c false.
		 * \return \c true if the document was successfully parsed, \c false if an
		 * error occurred.
		 */
		bool
			parse(const std::string& document, Value& root, bool collectComments = true);

		/** \brief Read a Value from a <a HREF="http://www.json.org">JSON</a>
		 document.
		 * \param beginDoc Pointer on the beginning of the UTF-8 encoded string of the
		 document to read.
		 * \param endDoc Pointer on the end of the UTF-8 encoded string of the
		 document to read.
		 *               Must be >= beginDoc.
		 * \param root [out] Contains the root value of the document if it was
		 *             successfully parsed.
		 * \param collectComments \c true to collect comment and allow writing them
		 back during
		 *                        serialization, \c false to discard comments.
		 *                        This parameter is ignored if
		 Features::allowComments_
		 *                        is \c false.
		 * \return \c true if the document was successfully parsed, \c false if an
		 error occurred.
		 */
		bool parse(const char* beginDoc,
			const char* endDoc,
			Value& root,
			bool collectComments = true);

		/// \brief Parse from input stream.
		/// \see Json::operator>>(std::istream&, Json::Value&).
		bool parse(JSONCPP_ISTREAM& is, Value& root, bool collectComments = true);

		/** \brief Returns a user friendly string that list errors in the parsed
		 * document.
		 * \return Formatted error message with the list of errors with their location
		 * in
		 *         the parsed document. An empty string is returned if no error
		 * occurred
		 *         during parsing.
		 * \deprecated Use getFormattedErrorMessages() instead (typo fix).
		 */
		JSONCPP_DEPRECATED("Use getFormattedErrorMessages() instead.")
			JSONCPP_STRING getFormatedErrorMessages() const;

		/** \brief Returns a user friendly string that list errors in the parsed
		 * document.
		 * \return Formatted error message with the list of errors with their location
		 * in
		 *         the parsed document. An empty string is returned if no error
		 * occurred
		 *         during parsing.
		 */
		JSONCPP_STRING getFormattedErrorMessages() const;

		/** \brief Returns a vector of structured erros encounted while parsing.
		 * \return A (possibly empty) vector of StructuredError objects. Currently
		 *         only one error can be returned, but the caller should tolerate
		 * multiple
		 *         errors.  This can occur if the parser recovers from a non-fatal
		 *         parse error and then encounters additional errors.
		 */
		std::vector<StructuredError> getStructuredErrors() const;

		/** \brief Add a semantic error message.
		 * \param value JSON Value location associated with the error
		 * \param message The error message.
		 * \return \c true if the error was successfully added, \c false if the
		 * Value offset exceeds the document size.
		 */
		bool pushError(const Value& value, const JSONCPP_STRING& message);

		/** \brief Add a semantic error message with extra context.
		 * \param value JSON Value location associated with the error
		 * \param message The error message.
		 * \param extra Additional JSON Value location to contextualize the error
		 * \return \c true if the error was successfully added, \c false if either
		 * Value offset exceeds the document size.
		 */
		bool pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra);

		/** \brief Return whether there are any errors.
		 * \return \c true if there are no errors to report \c false if
		 * errors have occurred.
		 */
		bool good() const;

	private:
		enum TokenType {
			tokenEndOfStream = 0,
			tokenObjectBegin,
			tokenObjectEnd,
			tokenArrayBegin,
			tokenArrayEnd,
			tokenString,
			tokenNumber,
			tokenTrue,
			tokenFalse,
			tokenNull,
			tokenArraySeparator,
			tokenMemberSeparator,
			tokenComment,
			tokenError
		};

		class Token {
		public:
			TokenType type_;
			Location start_;
			Location end_;
		};

		class ErrorInfo {
		public:
			Token token_;
			JSONCPP_STRING message_;
			Location extra_;
		};

		typedef std::deque<ErrorInfo> Errors;

		bool readToken(Token& token);
		void skipSpaces();
		bool match(Location pattern, int patternLength);
		bool readComment();
		bool readCStyleComment();
		bool readCppStyleComment();
		bool readString();
		void readNumber();
		bool readValue();
		bool readObject(Token& token);
		bool readArray(Token& token);
		bool decodeNumber(Token& token);
		bool decodeNumber(Token& token, Value& decoded);
		bool decodeString(Token& token);
		bool decodeString(Token& token, JSONCPP_STRING& decoded);
		bool decodeDouble(Token& token);
		bool decodeDouble(Token& token, Value& decoded);
		bool decodeUnicodeCodePoint(Token& token,
			Location& current,
			Location end,
			unsigned int& unicode);
		bool decodeUnicodeEscapeSequence(Token& token,
			Location& current,
			Location end,
			unsigned int& unicode);
		bool addError(const JSONCPP_STRING& message, Token& token, Location extra = 0);
		bool recoverFromError(TokenType skipUntilToken);
		bool addErrorAndRecover(const JSONCPP_STRING& message,
			Token& token,
			TokenType skipUntilToken);
		void skipUntilSpace();
		Value& currentValue();
		Char getNextChar();
		void
			getLocationLineAndColumn(Location location, int& line, int& column) const;
		JSONCPP_STRING getLocationLineAndColumn(Location location) const;
		void addComment(Location begin, Location end, CommentPlacement placement);
		void skipCommentTokens(Token& token);

		typedef std::stack<Value*> Nodes;
		Nodes nodes_;
		Errors errors_;
		JSONCPP_STRING document_;
		Location begin_;
		Location end_;
		Location current_;
		Location lastValueEnd_;
		Value* lastValue_;
		JSONCPP_STRING commentsBefore_;
		Features features_;
		bool collectComments_;
	};  // Reader

	/** Interface for reading JSON from a char array.
	 */
	class JSON_API CharReader {
	public:
		virtual ~CharReader() {}
		/** \brief Read a Value from a <a HREF="http://www.json.org">JSON</a>
		 document.
		 * The document must be a UTF-8 encoded string containing the document to read.
		 *
		 * \param beginDoc Pointer on the beginning of the UTF-8 encoded string of the
		 document to read.
		 * \param endDoc Pointer on the end of the UTF-8 encoded string of the
		 document to read.
		 *        Must be >= beginDoc.
		 * \param root [out] Contains the root value of the document if it was
		 *             successfully parsed.
		 * \param errs [out] Formatted error messages (if not NULL)
		 *        a user friendly string that lists errors in the parsed
		 * document.
		 * \return \c true if the document was successfully parsed, \c false if an
		 error occurred.
		 */
		virtual bool parse(
			char const* beginDoc, char const* endDoc,
			Value* root, JSONCPP_STRING* errs) = 0;

		class JSON_API Factory {
		public:
			virtual ~Factory() {}
			/** \brief Allocate a CharReader via operator new().
			 * \throw std::exception if something goes wrong (e.g. invalid settings)
			 */
			virtual CharReader* newCharReader() const = 0;
		};  // Factory
	};  // CharReader

	/** \brief Build a CharReader implementation.

	Usage:
	\code
	  using namespace Json;
	  CharReaderBuilder builder;
	  builder["collectComments"] = false;
	  Value value;
	  JSONCPP_STRING errs;
	  bool ok = parseFromStream(builder, std::cin, &value, &errs);
	\endcode
	*/
	class JSON_API CharReaderBuilder : public CharReader::Factory {
	public:
		// Note: We use a Json::Value so that we can add data-members to this class
		// without a major version bump.
		/** Configuration of this builder.
		  These are case-sensitive.
		  Available settings (case-sensitive):
		  - `"collectComments": false or true`
			- true to collect comment and allow writing them
			  back during serialization, false to discard comments.
			  This parameter is ignored if allowComments is false.
		  - `"allowComments": false or true`
			- true if comments are allowed.
		  - `"strictRoot": false or true`
			- true if root must be either an array or an object value
		  - `"allowDroppedNullPlaceholders": false or true`
			- true if dropped null placeholders are allowed. (See StreamWriterBuilder.)
		  - `"allowNumericKeys": false or true`
			- true if numeric object keys are allowed.
		  - `"allowSingleQuotes": false or true`
			- true if '' are allowed for strings (both keys and values)
		  - `"stackLimit": integer`
			- Exceeding stackLimit (recursive depth of `readValue()`) will
			  cause an exception.
			- This is a security issue (seg-faults caused by deeply nested JSON),
			  so the default is low.
		  - `"failIfExtra": false or true`
			- If true, `parse()` returns false when extra non-whitespace trails
			  the JSON value in the input string.
		  - `"rejectDupKeys": false or true`
			- If true, `parse()` returns false when a key is duplicated within an object.
		  - `"allowSpecialFloats": false or true`
			- If true, special float values (NaNs and infinities) are allowed
			  and their values are lossfree restorable.

		  You can examine 'settings_` yourself
		  to see the defaults. You can also write and read them just like any
		  JSON Value.
		  \sa setDefaults()
		  */
		Json::Value settings_;

		CharReaderBuilder();
		~CharReaderBuilder() JSONCPP_OVERRIDE;

		CharReader* newCharReader() const JSONCPP_OVERRIDE;

		/** \return true if 'settings' are legal and consistent;
		 *   otherwise, indicate bad settings via 'invalid'.
		 */
		bool validate(Json::Value* invalid) const;

		/** A simple way to update a specific setting.
		 */
		Value& operator[](JSONCPP_STRING key);

		/** Called by ctor, but you can use this to reset settings_.
		 * \pre 'settings' != NULL (but Json::null is fine)
		 * \remark Defaults:
		 * \snippet src/lib_json/json_reader.cpp CharReaderBuilderDefaults
		 */
		static void setDefaults(Json::Value* settings);
		/** Same as old Features::strictMode().
		 * \pre 'settings' != NULL (but Json::null is fine)
		 * \remark Defaults:
		 * \snippet src/lib_json/json_reader.cpp CharReaderBuilderStrictMode
		 */
		static void strictMode(Json::Value* settings);
	};

	/** Consume entire stream and use its begin/end.
	  * Someday we might have a real StreamReader, but for now this
	  * is convenient.
	  */
	bool JSON_API parseFromStream(
		CharReader::Factory const&,
		JSONCPP_ISTREAM&,
		Value* root, std::string* errs);

	/** \brief Read from 'sin' into 'root'.

	 Always keep comments from the input JSON.

	 This can be used to read a file into a particular sub-object.
	 For example:
	 \code
	 Json::Value root;
	 cin >> root["dir"]["file"];
	 cout << root;
	 \endcode
	 Result:
	 \verbatim
	 {
	 "dir": {
		 "file": {
		 // The input stream JSON would be nested here.
		 }
	 }
	 }
	 \endverbatim
	 \throw std::exception on parse error.
	 \see Json::operator<<()
	*/
	JSON_API JSONCPP_ISTREAM& operator>>(JSONCPP_ISTREAM&, Value&);
} // namespace Json

#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
#pragma warning(pop)
#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)

#endif // CPPTL_JSON_READER_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/reader.h
// //////////////////////////////////////////////////////////////////////

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/writer.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef JSON_WRITER_H_INCLUDED
#define JSON_WRITER_H_INCLUDED

#if !defined(JSON_IS_AMALGAMATION)
#include "value.h"
#endif // if !defined(JSON_IS_AMALGAMATION)
#include <vector>
#include <string>
#include <ostream>

// Disable warning C4251: <data member>: <type> needs to have dll-interface to
// be used by...
#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
#pragma warning(push)
#pragma warning(disable : 4251)
#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)

namespace Json {
	class Value;

	/**

	Usage:
	\code
	  using namespace Json;
	  void writeToStdout(StreamWriter::Factory const& factory, Value const& value) {
		std::unique_ptr<StreamWriter> const writer(
		  factory.newStreamWriter());
		writer->write(value, &std::cout);
		std::cout << std::endl;  // add lf and flush
	  }
	\endcode
	*/
	class JSON_API StreamWriter {
	protected:
		JSONCPP_OSTREAM* sout_;  // not owned; will not delete
	public:
		StreamWriter();
		virtual ~StreamWriter();
		/** Write Value into document as configured in sub-class.
			Do not take ownership of sout, but maintain a reference during function.
			\pre sout != NULL
			\return zero on success (For now, we always return zero, so check the stream instead.)
			\throw std::exception possibly, depending on configuration
		 */
		virtual int write(Value const& root, JSONCPP_OSTREAM* sout) = 0;

		/** \brief A simple abstract factory.
		 */
		class JSON_API Factory {
		public:
			virtual ~Factory();
			/** \brief Allocate a CharReader via operator new().
			 * \throw std::exception if something goes wrong (e.g. invalid settings)
			 */
			virtual StreamWriter* newStreamWriter() const = 0;
		};  // Factory
	};  // StreamWriter

	/** \brief Write into stringstream, then return string, for convenience.
	 * A StreamWriter will be created from the factory, used, and then deleted.
	 */
	JSONCPP_STRING JSON_API writeString(StreamWriter::Factory const& factory, Value const& root);

	/** \brief Build a StreamWriter implementation.

	Usage:
	\code
	  using namespace Json;
	  Value value = ...;
	  StreamWriterBuilder builder;
	  builder["commentStyle"] = "None";
	  builder["indentation"] = "   ";  // or whatever you like
	  std::unique_ptr<Json::StreamWriter> writer(
		  builder.newStreamWriter());
	  writer->write(value, &std::cout);
	  std::cout << std::endl;  // add lf and flush
	\endcode
	*/
	class JSON_API StreamWriterBuilder : public StreamWriter::Factory {
	public:
		// Note: We use a Json::Value so that we can add data-members to this class
		// without a major version bump.
		/** Configuration of this builder.
		  Available settings (case-sensitive):
		  - "commentStyle": "None" or "All"
		  - "indentation":  "<anything>"
		  - "enableYAMLCompatibility": false or true
			- slightly change the whitespace around colons
		  - "dropNullPlaceholders": false or true
			- Drop the "null" string from the writer's output for nullValues.
			  Strictly speaking, this is not valid JSON. But when the output is being
			  fed to a browser's Javascript, it makes for smaller output and the
			  browser can handle the output just fine.
		  - "useSpecialFloats": false or true
			- If true, outputs non-finite floating point values in the following way:
			  NaN values as "NaN", positive infinity as "Infinity", and negative infinity
			  as "-Infinity".

		  You can examine 'settings_` yourself
		  to see the defaults. You can also write and read them just like any
		  JSON Value.
		  \sa setDefaults()
		  */
		Json::Value settings_;

		StreamWriterBuilder();
		~StreamWriterBuilder() JSONCPP_OVERRIDE;

		/**
		 * \throw std::exception if something goes wrong (e.g. invalid settings)
		 */
		StreamWriter* newStreamWriter() const JSONCPP_OVERRIDE;

		/** \return true if 'settings' are legal and consistent;
		 *   otherwise, indicate bad settings via 'invalid'.
		 */
		bool validate(Json::Value* invalid) const;
		/** A simple way to update a specific setting.
		 */
		Value& operator[](JSONCPP_STRING key);

		/** Called by ctor, but you can use this to reset settings_.
		 * \pre 'settings' != NULL (but Json::null is fine)
		 * \remark Defaults:
		 * \snippet src/lib_json/json_writer.cpp StreamWriterBuilderDefaults
		 */
		static void setDefaults(Json::Value* settings);
	};

	/** \brief Abstract class for writers.
	 * \deprecated Use StreamWriter. (And really, this is an implementation detail.)
	 */
	class JSON_API Writer {
	public:
		virtual ~Writer();

		virtual JSONCPP_STRING write(const Value& root) = 0;
	};

	/** \brief Outputs a Value in <a HREF="http://www.json.org">JSON</a> format
	 *without formatting (not human friendly).
	 *
	 * The JSON document is written in a single line. It is not intended for 'human'
	 *consumption,
	 * but may be usefull to support feature such as RPC where bandwith is limited.
	 * \sa Reader, Value
	 * \deprecated Use StreamWriterBuilder.
	 */
	class JSON_API FastWriter : public Writer {
	public:
		FastWriter();
		~FastWriter() JSONCPP_OVERRIDE {}

		void enableYAMLCompatibility();

		/** \brief Drop the "null" string from the writer's output for nullValues.
		 * Strictly speaking, this is not valid JSON. But when the output is being
		 * fed to a browser's Javascript, it makes for smaller output and the
		 * browser can handle the output just fine.
		 */
		void dropNullPlaceholders();

		void omitEndingLineFeed();

	public: // overridden from Writer
		JSONCPP_STRING write(const Value& root) JSONCPP_OVERRIDE;

	private:
		void writeValue(const Value& value);

		JSONCPP_STRING document_;
		bool yamlCompatiblityEnabled_;
		bool dropNullPlaceholders_;
		bool omitEndingLineFeed_;
	};

	/** \brief Writes a Value in <a HREF="http://www.json.org">JSON</a> format in a
	 *human friendly way.
	 *
	 * The rules for line break and indent are as follow:
	 * - Object value:
	 *     - if empty then print {} without indent and line break
	 *     - if not empty the print '{', line break & indent, print one value per
	 *line
	 *       and then unindent and line break and print '}'.
	 * - Array value:
	 *     - if empty then print [] without indent and line break
	 *     - if the array contains no object value, empty array or some other value
	 *types,
	 *       and all the values fit on one lines, then print the array on a single
	 *line.
	 *     - otherwise, it the values do not fit on one line, or the array contains
	 *       object or non empty array, then print one value per line.
	 *
	 * If the Value have comments then they are outputed according to their
	 *#CommentPlacement.
	 *
	 * \sa Reader, Value, Value::setComment()
	 * \deprecated Use StreamWriterBuilder.
	 */
	class JSON_API StyledWriter : public Writer {
	public:
		StyledWriter();
		~StyledWriter() JSONCPP_OVERRIDE {}

	public: // overridden from Writer
	  /** \brief Serialize a Value in <a HREF="http://www.json.org">JSON</a> format.
	   * \param root Value to serialize.
	   * \return String containing the JSON document that represents the root value.
	   */
		JSONCPP_STRING write(const Value& root) JSONCPP_OVERRIDE;

	private:
		void writeValue(const Value& value);
		void writeArrayValue(const Value& value);
		bool isMultineArray(const Value& value);
		void pushValue(const JSONCPP_STRING& value);
		void writeIndent();
		void writeWithIndent(const JSONCPP_STRING& value);
		void indent();
		void unindent();
		void writeCommentBeforeValue(const Value& root);
		void writeCommentAfterValueOnSameLine(const Value& root);
		bool hasCommentForValue(const Value& value);
		static JSONCPP_STRING normalizeEOL(const JSONCPP_STRING& text);

		typedef std::vector<JSONCPP_STRING> ChildValues;

		ChildValues childValues_;
		JSONCPP_STRING document_;
		JSONCPP_STRING indentString_;
		unsigned int rightMargin_;
		unsigned int indentSize_;
		bool addChildValues_;
	};

	/** \brief Writes a Value in <a HREF="http://www.json.org">JSON</a> format in a
	 human friendly way,
		 to a stream rather than to a string.
	 *
	 * The rules for line break and indent are as follow:
	 * - Object value:
	 *     - if empty then print {} without indent and line break
	 *     - if not empty the print '{', line break & indent, print one value per
	 line
	 *       and then unindent and line break and print '}'.
	 * - Array value:
	 *     - if empty then print [] without indent and line break
	 *     - if the array contains no object value, empty array or some other value
	 types,
	 *       and all the values fit on one lines, then print the array on a single
	 line.
	 *     - otherwise, it the values do not fit on one line, or the array contains
	 *       object or non empty array, then print one value per line.
	 *
	 * If the Value have comments then they are outputed according to their
	 #CommentPlacement.
	 *
	 * \param indentation Each level will be indented by this amount extra.
	 * \sa Reader, Value, Value::setComment()
	 * \deprecated Use StreamWriterBuilder.
	 */
	class JSON_API StyledStreamWriter {
	public:
		StyledStreamWriter(JSONCPP_STRING indentation = "\t");
		~StyledStreamWriter() {}

	public:
		/** \brief Serialize a Value in <a HREF="http://www.json.org">JSON</a> format.
		 * \param out Stream to write to. (Can be ostringstream, e.g.)
		 * \param root Value to serialize.
		 * \note There is no point in deriving from Writer, since write() should not
		 * return a value.
		 */
		void write(JSONCPP_OSTREAM& out, const Value& root);

	private:
		void writeValue(const Value& value);
		void writeArrayValue(const Value& value);
		bool isMultineArray(const Value& value);
		void pushValue(const JSONCPP_STRING& value);
		void writeIndent();
		void writeWithIndent(const JSONCPP_STRING& value);
		void indent();
		void unindent();
		void writeCommentBeforeValue(const Value& root);
		void writeCommentAfterValueOnSameLine(const Value& root);
		bool hasCommentForValue(const Value& value);
		static JSONCPP_STRING normalizeEOL(const JSONCPP_STRING& text);

		typedef std::vector<JSONCPP_STRING> ChildValues;

		ChildValues childValues_;
		JSONCPP_OSTREAM* document_;
		JSONCPP_STRING indentString_;
		unsigned int rightMargin_;
		JSONCPP_STRING indentation_;
		bool addChildValues_ : 1;
		bool indented_ : 1;
	};

#if defined(JSON_HAS_INT64)
	JSONCPP_STRING JSON_API valueToString(Int value);
	JSONCPP_STRING JSON_API valueToString(UInt value);
#endif // if defined(JSON_HAS_INT64)
	JSONCPP_STRING JSON_API valueToString(LargestInt value);
	JSONCPP_STRING JSON_API valueToString(LargestUInt value);
	JSONCPP_STRING JSON_API valueToString(double value);
	JSONCPP_STRING JSON_API valueToString(bool value);
	JSONCPP_STRING JSON_API valueToQuotedString(const char* value);

	/// \brief Output using the StyledStreamWriter.
	/// \see Json::operator>>()
	JSON_API JSONCPP_OSTREAM& operator<<(JSONCPP_OSTREAM&, const Value& root);
} // namespace Json

#if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)
#pragma warning(pop)
#endif // if defined(JSONCPP_DISABLE_DLL_INTERFACE_WARNING)

#endif // JSON_WRITER_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/writer.h
// //////////////////////////////////////////////////////////////////////

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: include/json/assertions.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef CPPTL_JSON_ASSERTIONS_H_INCLUDED
#define CPPTL_JSON_ASSERTIONS_H_INCLUDED

#include <stdlib.h>
#include <sstream>

#if !defined(JSON_IS_AMALGAMATION)
#include "config.h"
#endif // if !defined(JSON_IS_AMALGAMATION)

/** It should not be possible for a maliciously designed file to
 *  cause an abort() or seg-fault, so these macros are used only
 *  for pre-condition violations and internal logic errors.
 */
#if JSON_USE_EXCEPTION

 // @todo <= add detail about condition in exception
# define JSON_ASSERT(condition)                                                \
  {if (!(condition)) {Json::throwLogicError( "assert json failed" );}}

# define JSON_FAIL_MESSAGE(message)                                            \
  {                                                                            \
    JSONCPP_OSTRINGSTREAM oss; oss << message;                                    \
    Json::throwLogicError(oss.str());                                          \
    abort();                                                                   \
  }

#else // JSON_USE_EXCEPTION

# define JSON_ASSERT(condition) assert(condition)

 // The call to assert() will show the failure message in debug builds. In
 // release builds we abort, for a core-dump or debugger.
# define JSON_FAIL_MESSAGE(message)                                            \
  {                                                                            \
    JSONCPP_OSTRINGSTREAM oss; oss << message;                                    \
    assert(false && oss.str().c_str());                                        \
    abort();                                                                   \
  }

#endif

#define JSON_ASSERT_MESSAGE(condition, message)                                \
  if (!(condition)) {                                                          \
    JSON_FAIL_MESSAGE(message);                                                \
  }

#endif // CPPTL_JSON_ASSERTIONS_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: include/json/assertions.h
// //////////////////////////////////////////////////////////////////////

#endif //ifndef JSON_AMALGATED_H_INCLUDED

```

`src/jsoncpp/jsoncpp.cpp`:

```cpp
/// Json-cpp amalgated source (http://jsoncpp.sourceforge.net/).
/// It is intended to be used with #include "json/json.h"

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////

/*
The JsonCpp library's source code, including accompanying documentation,
tests and demonstration applications, are licensed under the following
conditions...

The author (Baptiste Lepilleur) explicitly disclaims copyright in all
jurisdictions which recognize such a disclaimer. In such jurisdictions,
this software is released into the Public Domain.

In jurisdictions which do not recognize Public Domain property (e.g. Germany as of
2010), this software is Copyright (c) 2007-2010 by Baptiste Lepilleur, and is
released under the terms of the MIT License (see below).

In jurisdictions which recognize Public Domain property, the user of this
software may choose to accept it either as 1) Public Domain, 2) under the
conditions of the MIT License (see below), or 3) under the terms of dual
Public Domain/MIT License conditions described here, as they choose.

The MIT License is about as close to Public Domain as a license can get, and is
described in clear, concise terms at:

   http://en.wikipedia.org/wiki/MIT_License

The full text of the MIT License follows:

========================================================================
Copyright (c) 2007-2010 Baptiste Lepilleur

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use, copy,
modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
========================================================================
(END LICENSE TEXT)

The MIT license is compatible with both the GPL and commercial
software, affording one all of the rights of Public Domain with the
minor nuisance of being required to keep the above copyright notice
and license text in the source code. Note also that by accepting the
Public Domain "license" you can re-license your copy using whatever
license you like.

*/

// //////////////////////////////////////////////////////////////////////
// End of content of file: LICENSE
// //////////////////////////////////////////////////////////////////////

#include "json.h"

#ifndef JSON_IS_AMALGAMATION
#error "Compile with -I PATH_TO_JSON_DIRECTORY"
#endif

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_tool.h
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#ifndef LIB_JSONCPP_JSON_TOOL_H_INCLUDED
#define LIB_JSONCPP_JSON_TOOL_H_INCLUDED

#ifndef NO_LOCALE_SUPPORT
#include <clocale>
#endif

/* This header provides common string manipulation support, such as UTF-8,
 * portable conversion from/to string...
 *
 * It is an internal header that must not be exposed.
 */

namespace Json {
	static char getDecimalPoint() {
#ifdef NO_LOCALE_SUPPORT
		return '\0';
#else
		struct lconv* lc = localeconv();
		return lc ? *(lc->decimal_point) : '\0';
#endif
	}

	/// Converts a unicode code-point to UTF-8.
	static inline JSONCPP_STRING codePointToUTF8(unsigned int cp) {
		JSONCPP_STRING result;

		// based on description from http://en.wikipedia.org/wiki/UTF-8

		if (cp <= 0x7f) {
			result.resize(1);
			result[0] = static_cast<char>(cp);
		}
		else if (cp <= 0x7FF) {
			result.resize(2);
			result[1] = static_cast<char>(0x80 | (0x3f & cp));
			result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));
		}
		else if (cp <= 0xFFFF) {
			result.resize(3);
			result[2] = static_cast<char>(0x80 | (0x3f & cp));
			result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));
			result[0] = static_cast<char>(0xE0 | (0xf & (cp >> 12)));
		}
		else if (cp <= 0x10FFFF) {
			result.resize(4);
			result[3] = static_cast<char>(0x80 | (0x3f & cp));
			result[2] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));
			result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 12)));
			result[0] = static_cast<char>(0xF0 | (0x7 & (cp >> 18)));
		}

		return result;
	}

	/// Returns true if ch is a control character (in range [1,31]).
	static inline bool isControlCharacter(char ch) { return ch > 0 && ch <= 0x1F; }

	enum {
		/// Constant that specify the size of the buffer that must be passed to
		/// uintToString.
		uintToStringBufferSize = 3 * sizeof(LargestUInt) + 1
	};

	// Defines a char buffer for use with uintToString().
	typedef char UIntToStringBuffer[uintToStringBufferSize];

	/** Converts an unsigned integer to string.
	 * @param value Unsigned interger to convert to string
	 * @param current Input/Output string buffer.
	 *        Must have at least uintToStringBufferSize chars free.
	 */
	static inline void uintToString(LargestUInt value, char*& current) {
		*--current = 0;
		do {
			*--current = static_cast<char>(value % 10U + static_cast<unsigned>('0'));
			value /= 10;
		} while (value != 0);
	}

	/** Change ',' to '.' everywhere in buffer.
	 *
	 * We had a sophisticated way, but it did not work in WinCE.
	 * @see https://github.com/open-source-parsers/jsoncpp/pull/9
	 */
	static inline void fixNumericLocale(char* begin, char* end) {
		while (begin < end) {
			if (*begin == ',') {
				*begin = '.';
			}
			++begin;
		}
	}

	static inline void fixNumericLocaleInput(char* begin, char* end) {
		char decimalPoint = getDecimalPoint();
		if (decimalPoint != '\0' && decimalPoint != '.') {
			while (begin < end) {
				if (*begin == '.') {
					*begin = decimalPoint;
				}
				++begin;
			}
		}
	}
} // namespace Json {
#endif // LIB_JSONCPP_JSON_TOOL_H_INCLUDED

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_tool.h
// //////////////////////////////////////////////////////////////////////

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_reader.cpp
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2011 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#if !defined(JSON_IS_AMALGAMATION)
#include <json/assertions.h>
#include <json/reader.h>
#include <json/value.h>
#include "json_tool.h"
#endif // if !defined(JSON_IS_AMALGAMATION)
#include <utility>
#include <cstdio>
#include <cassert>
#include <cstring>
#include <istream>
#include <sstream>
#include <memory>
#include <set>
#include <limits>

#if defined(_MSC_VER)
#if !defined(WINCE) && defined(__STDC_SECURE_LIB__) && _MSC_VER >= 1500 // VC++ 9.0 and above
#define snprintf sprintf_s
#elif _MSC_VER >= 1900 // VC++ 14.0 and above
#define snprintf std::snprintf
#else
#define snprintf _snprintf
#endif
#elif defined(__ANDROID__) || defined(__QNXNTO__)
#define snprintf snprintf
#elif __cplusplus >= 201103L
#if !defined(__MINGW32__) && !defined(__CYGWIN__)
#define snprintf std::snprintf
#endif
#endif

#if defined(__QNXNTO__)
#define sscanf std::sscanf
#endif

#if defined(_MSC_VER) && _MSC_VER >= 1400 // VC++ 8.0
// Disable warning about strdup being deprecated.
#pragma warning(disable : 4996)
#endif

static int const stackLimit_g = 1000;
static int       stackDepth_g = 0;  // see readValue()

namespace Json {
#if __cplusplus >= 201103L || (defined(_CPPLIB_VER) && _CPPLIB_VER >= 520)
	typedef std::unique_ptr<CharReader> CharReaderPtr;
#else
	typedef std::auto_ptr<CharReader>   CharReaderPtr;
#endif

	// Implementation of class Features
	// ////////////////////////////////

	Features::Features()
		: allowComments_(true), strictRoot_(false),
		allowDroppedNullPlaceholders_(false), allowNumericKeys_(false) {}

	Features Features::all() { return Features(); }

	Features Features::strictMode() {
		Features features;
		features.allowComments_ = false;
		features.strictRoot_ = true;
		features.allowDroppedNullPlaceholders_ = false;
		features.allowNumericKeys_ = false;
		return features;
	}

	// Implementation of class Reader
	// ////////////////////////////////

	static bool containsNewLine(Reader::Location begin, Reader::Location end) {
		for (; begin < end; ++begin)
			if (*begin == '\n' || *begin == '\r')
				return true;
		return false;
	}

	// Class Reader
	// //////////////////////////////////////////////////////////////////

	Reader::Reader()
		: errors_(), document_(), begin_(), end_(), current_(), lastValueEnd_(),
		lastValue_(), commentsBefore_(), features_(Features::all()),
		collectComments_() {}

	Reader::Reader(const Features& features)
		: errors_(), document_(), begin_(), end_(), current_(), lastValueEnd_(),
		lastValue_(), commentsBefore_(), features_(features), collectComments_() {
	}

	bool
		Reader::parse(const std::string& document, Value& root, bool collectComments) {
		JSONCPP_STRING documentCopy(document.data(), document.data() + document.capacity());
		std::swap(documentCopy, document_);
		const char* begin = document_.c_str();
		const char* end = begin + document_.length();
		return parse(begin, end, root, collectComments);
	}

	bool Reader::parse(std::istream& sin, Value& root, bool collectComments) {
		// std::istream_iterator<char> begin(sin);
		// std::istream_iterator<char> end;
		// Those would allow streamed input from a file, if parse() were a
		// template function.

		// Since JSONCPP_STRING is reference-counted, this at least does not
		// create an extra copy.
		JSONCPP_STRING doc;
		std::getline(sin, doc, (char)EOF);
		return parse(doc.data(), doc.data() + doc.size(), root, collectComments);
	}

	bool Reader::parse(const char* beginDoc,
		const char* endDoc,
		Value& root,
		bool collectComments) {
		if (!features_.allowComments_) {
			collectComments = false;
		}

		begin_ = beginDoc;
		end_ = endDoc;
		collectComments_ = collectComments;
		current_ = begin_;
		lastValueEnd_ = 0;
		lastValue_ = 0;
		commentsBefore_ = "";
		errors_.clear();
		while (!nodes_.empty())
			nodes_.pop();
		nodes_.push(&root);

		stackDepth_g = 0;  // Yes, this is bad coding, but options are limited.
		bool successful = readValue();
		Token token;
		skipCommentTokens(token);
		if (collectComments_ && !commentsBefore_.empty())
			root.setComment(commentsBefore_, commentAfter);
		if (features_.strictRoot_) {
			if (!root.isArray() && !root.isObject()) {
				// Set error location to start of doc, ideally should be first token found
				// in doc
				token.type_ = tokenError;
				token.start_ = beginDoc;
				token.end_ = endDoc;
				addError(
					"A valid JSON document must be either an array or an object value.",
					token);
				return false;
			}
		}
		return successful;
	}

	bool Reader::readValue() {
		// This is a non-reentrant way to support a stackLimit. Terrible!
		// But this deprecated class has a security problem: Bad input can
		// cause a seg-fault. This seems like a fair, binary-compatible way
		// to prevent the problem.
		if (stackDepth_g >= stackLimit_g) throwRuntimeError("Exceeded stackLimit in readValue().");
		++stackDepth_g;

		Token token;
		skipCommentTokens(token);
		bool successful = true;

		if (collectComments_ && !commentsBefore_.empty()) {
			currentValue().setComment(commentsBefore_, commentBefore);
			commentsBefore_ = "";
		}

		switch (token.type_) {
		case tokenObjectBegin:
			successful = readObject(token);
			currentValue().setOffsetLimit(current_ - begin_);
			break;
		case tokenArrayBegin:
			successful = readArray(token);
			currentValue().setOffsetLimit(current_ - begin_);
			break;
		case tokenNumber:
			successful = decodeNumber(token);
			break;
		case tokenString:
			successful = decodeString(token);
			break;
		case tokenTrue:
		{
			Value v(true);
			currentValue().swapPayload(v);
			currentValue().setOffsetStart(token.start_ - begin_);
			currentValue().setOffsetLimit(token.end_ - begin_);
		}
		break;
		case tokenFalse:
		{
			Value v(false);
			currentValue().swapPayload(v);
			currentValue().setOffsetStart(token.start_ - begin_);
			currentValue().setOffsetLimit(token.end_ - begin_);
		}
		break;
		case tokenNull:
		{
			Value v;
			currentValue().swapPayload(v);
			currentValue().setOffsetStart(token.start_ - begin_);
			currentValue().setOffsetLimit(token.end_ - begin_);
		}
		break;
		case tokenArraySeparator:
		case tokenObjectEnd:
		case tokenArrayEnd:
			if (features_.allowDroppedNullPlaceholders_) {
				// "Un-read" the current token and mark the current value as a null
				// token.
				current_--;
				Value v;
				currentValue().swapPayload(v);
				currentValue().setOffsetStart(current_ - begin_ - 1);
				currentValue().setOffsetLimit(current_ - begin_);
				break;
			} // Else, fall through...
		default:
			currentValue().setOffsetStart(token.start_ - begin_);
			currentValue().setOffsetLimit(token.end_ - begin_);
			return addError("Syntax error: value, object or array expected.", token);
		}

		if (collectComments_) {
			lastValueEnd_ = current_;
			lastValue_ = &currentValue();
		}

		--stackDepth_g;
		return successful;
	}

	void Reader::skipCommentTokens(Token& token) {
		if (features_.allowComments_) {
			do {
				readToken(token);
			} while (token.type_ == tokenComment);
		}
		else {
			readToken(token);
		}
	}

	bool Reader::readToken(Token& token) {
		skipSpaces();
		token.start_ = current_;
		Char c = getNextChar();
		bool ok = true;
		switch (c) {
		case '{':
			token.type_ = tokenObjectBegin;
			break;
		case '}':
			token.type_ = tokenObjectEnd;
			break;
		case '[':
			token.type_ = tokenArrayBegin;
			break;
		case ']':
			token.type_ = tokenArrayEnd;
			break;
		case '"':
			token.type_ = tokenString;
			ok = readString();
			break;
		case '/':
			token.type_ = tokenComment;
			ok = readComment();
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		case '-':
			token.type_ = tokenNumber;
			readNumber();
			break;
		case 't':
			token.type_ = tokenTrue;
			ok = match("rue", 3);
			break;
		case 'f':
			token.type_ = tokenFalse;
			ok = match("alse", 4);
			break;
		case 'n':
			token.type_ = tokenNull;
			ok = match("ull", 3);
			break;
		case ',':
			token.type_ = tokenArraySeparator;
			break;
		case ':':
			token.type_ = tokenMemberSeparator;
			break;
		case 0:
			token.type_ = tokenEndOfStream;
			break;
		default:
			ok = false;
			break;
		}
		if (!ok)
			token.type_ = tokenError;
		token.end_ = current_;
		return true;
	}

	void Reader::skipSpaces() {
		while (current_ != end_) {
			Char c = *current_;
			if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
				++current_;
			else
				break;
		}
	}

	bool Reader::match(Location pattern, int patternLength) {
		if (end_ - current_ < patternLength)
			return false;
		int index = patternLength;
		while (index--)
			if (current_[index] != pattern[index])
				return false;
		current_ += patternLength;
		return true;
	}

	bool Reader::readComment() {
		Location commentBegin = current_ - 1;
		Char c = getNextChar();
		bool successful = false;
		if (c == '*')
			successful = readCStyleComment();
		else if (c == '/')
			successful = readCppStyleComment();
		if (!successful)
			return false;

		if (collectComments_) {
			CommentPlacement placement = commentBefore;
			if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
				if (c != '*' || !containsNewLine(commentBegin, current_))
					placement = commentAfterOnSameLine;
			}

			addComment(commentBegin, current_, placement);
		}
		return true;
	}

	static JSONCPP_STRING normalizeEOL(Reader::Location begin, Reader::Location end) {
		JSONCPP_STRING normalized;
		normalized.reserve(static_cast<size_t>(end - begin));
		Reader::Location current = begin;
		while (current != end) {
			char c = *current++;
			if (c == '\r') {
				if (current != end && *current == '\n')
					// convert dos EOL
					++current;
				// convert Mac EOL
				normalized += '\n';
			}
			else {
				normalized += c;
			}
		}
		return normalized;
	}

	void
		Reader::addComment(Location begin, Location end, CommentPlacement placement) {
		assert(collectComments_);
		const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
		if (placement == commentAfterOnSameLine) {
			assert(lastValue_ != 0);
			lastValue_->setComment(normalized, placement);
		}
		else {
			commentsBefore_ += normalized;
		}
	}

	bool Reader::readCStyleComment() {
		while ((current_ + 1) < end_) {
			Char c = getNextChar();
			if (c == '*' && *current_ == '/')
				break;
		}
		return getNextChar() == '/';
	}

	bool Reader::readCppStyleComment() {
		while (current_ != end_) {
			Char c = getNextChar();
			if (c == '\n')
				break;
			if (c == '\r') {
				// Consume DOS EOL. It will be normalized in addComment.
				if (current_ != end_ && *current_ == '\n')
					getNextChar();
				// Break on Moc OS 9 EOL.
				break;
			}
		}
		return true;
	}

	void Reader::readNumber() {
		const char* p = current_;
		char c = '0'; // stopgap for already consumed character
		// integral part
		while (c >= '0' && c <= '9')
			c = (current_ = p) < end_ ? *p++ : '\0';
		// fractional part
		if (c == '.') {
			c = (current_ = p) < end_ ? *p++ : '\0';
			while (c >= '0' && c <= '9')
				c = (current_ = p) < end_ ? *p++ : '\0';
		}
		// exponential part
		if (c == 'e' || c == 'E') {
			c = (current_ = p) < end_ ? *p++ : '\0';
			if (c == '+' || c == '-')
				c = (current_ = p) < end_ ? *p++ : '\0';
			while (c >= '0' && c <= '9')
				c = (current_ = p) < end_ ? *p++ : '\0';
		}
	}

	bool Reader::readString() {
		Char c = '\0';
		while (current_ != end_) {
			c = getNextChar();
			if (c == '\\')
				getNextChar();
			else if (c == '"')
				break;
		}
		return c == '"';
	}

	bool Reader::readObject(Token& tokenStart) {
		Token tokenName;
		JSONCPP_STRING name;
		Value init(objectValue);
		currentValue().swapPayload(init);
		currentValue().setOffsetStart(tokenStart.start_ - begin_);
		while (readToken(tokenName)) {
			bool initialTokenOk = true;
			while (tokenName.type_ == tokenComment && initialTokenOk)
				initialTokenOk = readToken(tokenName);
			if (!initialTokenOk)
				break;
			if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
				return true;
			name = "";
			if (tokenName.type_ == tokenString) {
				if (!decodeString(tokenName, name))
					return recoverFromError(tokenObjectEnd);
			}
			else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
				Value numberName;
				if (!decodeNumber(tokenName, numberName))
					return recoverFromError(tokenObjectEnd);
				name = JSONCPP_STRING(numberName.asCString());
			}
			else {
				break;
			}

			Token colon;
			if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
				return addErrorAndRecover(
					"Missing ':' after object member name", colon, tokenObjectEnd);
			}
			Value& value = currentValue()[name];
			nodes_.push(&value);
			bool ok = readValue();
			nodes_.pop();
			if (!ok) // error already set
				return recoverFromError(tokenObjectEnd);

			Token comma;
			if (!readToken(comma) ||
				(comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
					comma.type_ != tokenComment)) {
				return addErrorAndRecover(
					"Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
			}
			bool finalizeTokenOk = true;
			while (comma.type_ == tokenComment && finalizeTokenOk)
				finalizeTokenOk = readToken(comma);
			if (comma.type_ == tokenObjectEnd)
				return true;
		}
		return addErrorAndRecover(
			"Missing '}' or object member name", tokenName, tokenObjectEnd);
	}

	bool Reader::readArray(Token& tokenStart) {
		Value init(arrayValue);
		currentValue().swapPayload(init);
		currentValue().setOffsetStart(tokenStart.start_ - begin_);
		skipSpaces();
		if (current_ != end_ && *current_ == ']') // empty array
		{
			Token endArray;
			readToken(endArray);
			return true;
		}
		int index = 0;
		for (;;) {
			Value& value = currentValue()[index++];
			nodes_.push(&value);
			bool ok = readValue();
			nodes_.pop();
			if (!ok) // error already set
				return recoverFromError(tokenArrayEnd);

			Token token;
			// Accept Comment after last item in the array.
			ok = readToken(token);
			while (token.type_ == tokenComment && ok) {
				ok = readToken(token);
			}
			bool badTokenType =
				(token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
			if (!ok || badTokenType) {
				return addErrorAndRecover(
					"Missing ',' or ']' in array declaration", token, tokenArrayEnd);
			}
			if (token.type_ == tokenArrayEnd)
				break;
		}
		return true;
	}

	bool Reader::decodeNumber(Token& token) {
		Value decoded;
		if (!decodeNumber(token, decoded))
			return false;
		currentValue().swapPayload(decoded);
		currentValue().setOffsetStart(token.start_ - begin_);
		currentValue().setOffsetLimit(token.end_ - begin_);
		return true;
	}

	bool Reader::decodeNumber(Token& token, Value& decoded) {
		// Attempts to parse the number as an integer. If the number is
		// larger than the maximum supported value of an integer then
		// we decode the number as a double.
		Location current = token.start_;
		bool isNegative = *current == '-';
		if (isNegative)
			++current;
		// TODO: Help the compiler do the div and mod at compile time or get rid of them.
		Value::LargestUInt maxIntegerValue =
			isNegative ? Value::LargestUInt(Value::maxLargestInt) + 1
			: Value::maxLargestUInt;
		Value::LargestUInt threshold = maxIntegerValue / 10;
		Value::LargestUInt value = 0;
		while (current < token.end_) {
			Char c = *current++;
			if (c < '0' || c > '9')
				return decodeDouble(token, decoded);
			Value::UInt digit(static_cast<Value::UInt>(c - '0'));
			if (value >= threshold) {
				// We've hit or exceeded the max value divided by 10 (rounded down). If
				// a) we've only just touched the limit, b) this is the last digit, and
				// c) it's small enough to fit in that rounding delta, we're okay.
				// Otherwise treat this number as a double to avoid overflow.
				if (value > threshold || current != token.end_ ||
					digit > maxIntegerValue % 10) {
					return decodeDouble(token, decoded);
				}
			}
			value = value * 10 + digit;
		}
		if (isNegative && value == maxIntegerValue)
			decoded = Value::minLargestInt;
		else if (isNegative)
			decoded = -Value::LargestInt(value);
		else if (value <= Value::LargestUInt(Value::maxInt))
			decoded = Value::LargestInt(value);
		else
			decoded = value;
		return true;
	}

	bool Reader::decodeDouble(Token& token) {
		Value decoded;
		if (!decodeDouble(token, decoded))
			return false;
		currentValue().swapPayload(decoded);
		currentValue().setOffsetStart(token.start_ - begin_);
		currentValue().setOffsetLimit(token.end_ - begin_);
		return true;
	}

	bool Reader::decodeDouble(Token& token, Value& decoded) {
		double value = 0;
		JSONCPP_STRING buffer(token.start_, token.end_);
		JSONCPP_ISTRINGSTREAM is(buffer);
		if (!(is >> value))
			return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
				"' is not a number.",
				token);
		decoded = value;
		return true;
	}

	bool Reader::decodeString(Token& token) {
		JSONCPP_STRING decoded_string;
		if (!decodeString(token, decoded_string))
			return false;
		Value decoded(decoded_string);
		currentValue().swapPayload(decoded);
		currentValue().setOffsetStart(token.start_ - begin_);
		currentValue().setOffsetLimit(token.end_ - begin_);
		return true;
	}

	bool Reader::decodeString(Token& token, JSONCPP_STRING& decoded) {
		decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
		Location current = token.start_ + 1; // skip '"'
		Location end = token.end_ - 1;       // do not include '"'
		while (current != end) {
			Char c = *current++;
			if (c == '"')
				break;
			else if (c == '\\') {
				if (current == end)
					return addError("Empty escape sequence in string", token, current);
				Char escape = *current++;
				switch (escape) {
				case '"':
					decoded += '"';
					break;
				case '/':
					decoded += '/';
					break;
				case '\\':
					decoded += '\\';
					break;
				case 'b':
					decoded += '\b';
					break;
				case 'f':
					decoded += '\f';
					break;
				case 'n':
					decoded += '\n';
					break;
				case 'r':
					decoded += '\r';
					break;
				case 't':
					decoded += '\t';
					break;
				case 'u': {
					unsigned int unicode;
					if (!decodeUnicodeCodePoint(token, current, end, unicode))
						return false;
					decoded += codePointToUTF8(unicode);
				} break;
				default:
					return addError("Bad escape sequence in string", token, current);
				}
			}
			else {
				decoded += c;
			}
		}
		return true;
	}

	bool Reader::decodeUnicodeCodePoint(Token& token,
		Location& current,
		Location end,
		unsigned int& unicode) {
		if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
			return false;
		if (unicode >= 0xD800 && unicode <= 0xDBFF) {
			// surrogate pairs
			if (end - current < 6)
				return addError(
					"additional six characters expected to parse unicode surrogate pair.",
					token,
					current);
			unsigned int surrogatePair;
			if (*(current++) == '\\' && *(current++) == 'u') {
				if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
					unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
				}
				else
					return false;
			}
			else
				return addError("expecting another \\u token to begin the second half of "
					"a unicode surrogate pair",
					token,
					current);
		}
		return true;
	}

	bool Reader::decodeUnicodeEscapeSequence(Token& token,
		Location& current,
		Location end,
		unsigned int& ret_unicode) {
		if (end - current < 4)
			return addError(
				"Bad unicode escape sequence in string: four digits expected.",
				token,
				current);
		int unicode = 0;
		for (int index = 0; index < 4; ++index) {
			Char c = *current++;
			unicode *= 16;
			if (c >= '0' && c <= '9')
				unicode += c - '0';
			else if (c >= 'a' && c <= 'f')
				unicode += c - 'a' + 10;
			else if (c >= 'A' && c <= 'F')
				unicode += c - 'A' + 10;
			else
				return addError(
					"Bad unicode escape sequence in string: hexadecimal digit expected.",
					token,
					current);
		}
		ret_unicode = static_cast<unsigned int>(unicode);
		return true;
	}

	bool
		Reader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
		ErrorInfo info;
		info.token_ = token;
		info.message_ = message;
		info.extra_ = extra;
		errors_.push_back(info);
		return false;
	}

	bool Reader::recoverFromError(TokenType skipUntilToken) {
		size_t const errorCount = errors_.size();
		Token skip;
		for (;;) {
			if (!readToken(skip))
				errors_.resize(errorCount); // discard errors caused by recovery
			if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
				break;
		}
		errors_.resize(errorCount);
		return false;
	}

	bool Reader::addErrorAndRecover(const JSONCPP_STRING& message,
		Token& token,
		TokenType skipUntilToken) {
		addError(message, token);
		return recoverFromError(skipUntilToken);
	}

	Value& Reader::currentValue() { return *(nodes_.top()); }

	Reader::Char Reader::getNextChar() {
		if (current_ == end_)
			return 0;
		return *current_++;
	}

	void Reader::getLocationLineAndColumn(Location location,
		int& line,
		int& column) const {
		Location current = begin_;
		Location lastLineStart = current;
		line = 0;
		while (current < location && current != end_) {
			Char c = *current++;
			if (c == '\r') {
				if (*current == '\n')
					++current;
				lastLineStart = current;
				++line;
			}
			else if (c == '\n') {
				lastLineStart = current;
				++line;
			}
		}
		// column & line start at 1
		column = int(location - lastLineStart) + 1;
		++line;
	}

	JSONCPP_STRING Reader::getLocationLineAndColumn(Location location) const {
		int line, column;
		getLocationLineAndColumn(location, line, column);
		char buffer[18 + 16 + 16 + 1];
		snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
		return buffer;
	}

	// Deprecated. Preserved for backward compatibility
	JSONCPP_STRING Reader::getFormatedErrorMessages() const {
		return getFormattedErrorMessages();
	}

	JSONCPP_STRING Reader::getFormattedErrorMessages() const {
		JSONCPP_STRING formattedMessage;
		for (Errors::const_iterator itError = errors_.begin();
			itError != errors_.end();
			++itError) {
			const ErrorInfo& error = *itError;
			formattedMessage +=
				"* " + getLocationLineAndColumn(error.token_.start_) + "\n";
			formattedMessage += "  " + error.message_ + "\n";
			if (error.extra_)
				formattedMessage +=
				"See " + getLocationLineAndColumn(error.extra_) + " for detail.\n";
		}
		return formattedMessage;
	}

	std::vector<Reader::StructuredError> Reader::getStructuredErrors() const {
		std::vector<Reader::StructuredError> allErrors;
		for (Errors::const_iterator itError = errors_.begin();
			itError != errors_.end();
			++itError) {
			const ErrorInfo& error = *itError;
			Reader::StructuredError structured;
			structured.offset_start = error.token_.start_ - begin_;
			structured.offset_limit = error.token_.end_ - begin_;
			structured.message = error.message_;
			allErrors.push_back(structured);
		}
		return allErrors;
	}

	bool Reader::pushError(const Value& value, const JSONCPP_STRING& message) {
		ptrdiff_t const length = end_ - begin_;
		if (value.getOffsetStart() > length
			|| value.getOffsetLimit() > length)
			return false;
		Token token;
		token.type_ = tokenError;
		token.start_ = begin_ + value.getOffsetStart();
		token.end_ = end_ + value.getOffsetLimit();
		ErrorInfo info;
		info.token_ = token;
		info.message_ = message;
		info.extra_ = 0;
		errors_.push_back(info);
		return true;
	}

	bool Reader::pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra) {
		ptrdiff_t const length = end_ - begin_;
		if (value.getOffsetStart() > length
			|| value.getOffsetLimit() > length
			|| extra.getOffsetLimit() > length)
			return false;
		Token token;
		token.type_ = tokenError;
		token.start_ = begin_ + value.getOffsetStart();
		token.end_ = begin_ + value.getOffsetLimit();
		ErrorInfo info;
		info.token_ = token;
		info.message_ = message;
		info.extra_ = begin_ + extra.getOffsetStart();
		errors_.push_back(info);
		return true;
	}

	bool Reader::good() const {
		return !errors_.size();
	}

	// exact copy of Features
	class OurFeatures {
	public:
		static OurFeatures all();
		bool allowComments_;
		bool strictRoot_;
		bool allowDroppedNullPlaceholders_;
		bool allowNumericKeys_;
		bool allowSingleQuotes_;
		bool failIfExtra_;
		bool rejectDupKeys_;
		bool allowSpecialFloats_;
		int stackLimit_;
	};  // OurFeatures

	// exact copy of Implementation of class Features
	// ////////////////////////////////

	OurFeatures OurFeatures::all() { return OurFeatures(); }

	// Implementation of class Reader
	// ////////////////////////////////

	// exact copy of Reader, renamed to OurReader
	class OurReader {
	public:
		typedef char Char;
		typedef const Char* Location;
		struct StructuredError {
			ptrdiff_t offset_start;
			ptrdiff_t offset_limit;
			JSONCPP_STRING message;
		};

		OurReader(OurFeatures const& features);
		bool parse(const char* beginDoc,
			const char* endDoc,
			Value& root,
			bool collectComments = true);
		JSONCPP_STRING getFormattedErrorMessages() const;
		std::vector<StructuredError> getStructuredErrors() const;
		bool pushError(const Value& value, const JSONCPP_STRING& message);
		bool pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra);
		bool good() const;

	private:
		OurReader(OurReader const&);  // no impl
		void operator=(OurReader const&);  // no impl

		enum TokenType {
			tokenEndOfStream = 0,
			tokenObjectBegin,
			tokenObjectEnd,
			tokenArrayBegin,
			tokenArrayEnd,
			tokenString,
			tokenNumber,
			tokenTrue,
			tokenFalse,
			tokenNull,
			tokenNaN,
			tokenPosInf,
			tokenNegInf,
			tokenArraySeparator,
			tokenMemberSeparator,
			tokenComment,
			tokenError
		};

		class Token {
		public:
			TokenType type_;
			Location start_;
			Location end_;
		};

		class ErrorInfo {
		public:
			Token token_;
			JSONCPP_STRING message_;
			Location extra_;
		};

		typedef std::deque<ErrorInfo> Errors;

		bool readToken(Token& token);
		void skipSpaces();
		bool match(Location pattern, int patternLength);
		bool readComment();
		bool readCStyleComment();
		bool readCppStyleComment();
		bool readString();
		bool readStringSingleQuote();
		bool readNumber(bool checkInf);
		bool readValue();
		bool readObject(Token& token);
		bool readArray(Token& token);
		bool decodeNumber(Token& token);
		bool decodeNumber(Token& token, Value& decoded);
		bool decodeString(Token& token);
		bool decodeString(Token& token, JSONCPP_STRING& decoded);
		bool decodeDouble(Token& token);
		bool decodeDouble(Token& token, Value& decoded);
		bool decodeUnicodeCodePoint(Token& token,
			Location& current,
			Location end,
			unsigned int& unicode);
		bool decodeUnicodeEscapeSequence(Token& token,
			Location& current,
			Location end,
			unsigned int& unicode);
		bool addError(const JSONCPP_STRING& message, Token& token, Location extra = 0);
		bool recoverFromError(TokenType skipUntilToken);
		bool addErrorAndRecover(const JSONCPP_STRING& message,
			Token& token,
			TokenType skipUntilToken);
		void skipUntilSpace();
		Value& currentValue();
		Char getNextChar();
		void
			getLocationLineAndColumn(Location location, int& line, int& column) const;
		JSONCPP_STRING getLocationLineAndColumn(Location location) const;
		void addComment(Location begin, Location end, CommentPlacement placement);
		void skipCommentTokens(Token& token);

		typedef std::stack<Value*> Nodes;
		Nodes nodes_;
		Errors errors_;
		JSONCPP_STRING document_;
		Location begin_;
		Location end_;
		Location current_;
		Location lastValueEnd_;
		Value* lastValue_;
		JSONCPP_STRING commentsBefore_;
		int stackDepth_;

		OurFeatures const features_;
		bool collectComments_;
	};  // OurReader

	// complete copy of Read impl, for OurReader

	OurReader::OurReader(OurFeatures const& features)
		: errors_(), document_(), begin_(), end_(), current_(), lastValueEnd_(),
		lastValue_(), commentsBefore_(),
		stackDepth_(0),
		features_(features), collectComments_() {
	}

	bool OurReader::parse(const char* beginDoc,
		const char* endDoc,
		Value& root,
		bool collectComments) {
		if (!features_.allowComments_) {
			collectComments = false;
		}

		begin_ = beginDoc;
		end_ = endDoc;
		collectComments_ = collectComments;
		current_ = begin_;
		lastValueEnd_ = 0;
		lastValue_ = 0;
		commentsBefore_ = "";
		errors_.clear();
		while (!nodes_.empty())
			nodes_.pop();
		nodes_.push(&root);

		stackDepth_ = 0;
		bool successful = readValue();
		Token token;
		skipCommentTokens(token);
		if (features_.failIfExtra_) {
			if ((features_.strictRoot_ || token.type_ != tokenError) && token.type_ != tokenEndOfStream) {
				addError("Extra non-whitespace after JSON value.", token);
				return false;
			}
		}
		if (collectComments_ && !commentsBefore_.empty())
			root.setComment(commentsBefore_, commentAfter);
		if (features_.strictRoot_) {
			if (!root.isArray() && !root.isObject()) {
				// Set error location to start of doc, ideally should be first token found
				// in doc
				token.type_ = tokenError;
				token.start_ = beginDoc;
				token.end_ = endDoc;
				addError(
					"A valid JSON document must be either an array or an object value.",
					token);
				return false;
			}
		}
		return successful;
	}

	bool OurReader::readValue() {
		if (stackDepth_ >= features_.stackLimit_) throwRuntimeError("Exceeded stackLimit in readValue().");
		++stackDepth_;
		Token token;
		skipCommentTokens(token);
		bool successful = true;

		if (collectComments_ && !commentsBefore_.empty()) {
			currentValue().setComment(commentsBefore_, commentBefore);
			commentsBefore_ = "";
		}

		switch (token.type_) {
		case tokenObjectBegin:
			successful = readObject(token);
			currentValue().setOffsetLimit(current_ - begin_);
			break;
		case tokenArrayBegin:
			successful = readArray(token);
			currentValue().setOffsetLimit(current_ - begin_);
			break;
		case tokenNumber:
			successful = decodeNumber(token);
			break;
		case tokenString:
			successful = decodeString(token);
			break;
		case tokenTrue:
		{
			Value v(true);
			currentValue().swapPayload(v);
			currentValue().setOffsetStart(token.start_ - begin_);
			currentValue().setOffsetLimit(token.end_ - begin_);
		}
		break;
		case tokenFalse:
		{
			Value v(false);
			currentValue().swapPayload(v);
			currentValue().setOffsetStart(token.start_ - begin_);
			currentValue().setOffsetLimit(token.end_ - begin_);
		}
		break;
		case tokenNull:
		{
			Value v;
			currentValue().swapPayload(v);
			currentValue().setOffsetStart(token.start_ - begin_);
			currentValue().setOffsetLimit(token.end_ - begin_);
		}
		break;
		case tokenNaN:
		{
			Value v(std::numeric_limits<double>::quiet_NaN());
			currentValue().swapPayload(v);
			currentValue().setOffsetStart(token.start_ - begin_);
			currentValue().setOffsetLimit(token.end_ - begin_);
		}
		break;
		case tokenPosInf:
		{
			Value v(std::numeric_limits<double>::infinity());
			currentValue().swapPayload(v);
			currentValue().setOffsetStart(token.start_ - begin_);
			currentValue().setOffsetLimit(token.end_ - begin_);
		}
		break;
		case tokenNegInf:
		{
			Value v(-std::numeric_limits<double>::infinity());
			currentValue().swapPayload(v);
			currentValue().setOffsetStart(token.start_ - begin_);
			currentValue().setOffsetLimit(token.end_ - begin_);
		}
		break;
		case tokenArraySeparator:
		case tokenObjectEnd:
		case tokenArrayEnd:
			if (features_.allowDroppedNullPlaceholders_) {
				// "Un-read" the current token and mark the current value as a null
				// token.
				current_--;
				Value v;
				currentValue().swapPayload(v);
				currentValue().setOffsetStart(current_ - begin_ - 1);
				currentValue().setOffsetLimit(current_ - begin_);
				break;
			} // else, fall through ...
		default:
			currentValue().setOffsetStart(token.start_ - begin_);
			currentValue().setOffsetLimit(token.end_ - begin_);
			return addError("Syntax error: value, object or array expected.", token);
		}

		if (collectComments_) {
			lastValueEnd_ = current_;
			lastValue_ = &currentValue();
		}

		--stackDepth_;
		return successful;
	}

	void OurReader::skipCommentTokens(Token& token) {
		if (features_.allowComments_) {
			do {
				readToken(token);
			} while (token.type_ == tokenComment);
		}
		else {
			readToken(token);
		}
	}

	bool OurReader::readToken(Token& token) {
		skipSpaces();
		token.start_ = current_;
		Char c = getNextChar();
		bool ok = true;
		switch (c) {
		case '{':
			token.type_ = tokenObjectBegin;
			break;
		case '}':
			token.type_ = tokenObjectEnd;
			break;
		case '[':
			token.type_ = tokenArrayBegin;
			break;
		case ']':
			token.type_ = tokenArrayEnd;
			break;
		case '"':
			token.type_ = tokenString;
			ok = readString();
			break;
		case '\'':
			if (features_.allowSingleQuotes_) {
				token.type_ = tokenString;
				ok = readStringSingleQuote();
				break;
			} // else continue
		case '/':
			token.type_ = tokenComment;
			ok = readComment();
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			token.type_ = tokenNumber;
			readNumber(false);
			break;
		case '-':
			if (readNumber(true)) {
				token.type_ = tokenNumber;
			}
			else {
				token.type_ = tokenNegInf;
				ok = features_.allowSpecialFloats_ && match("nfinity", 7);
			}
			break;
		case 't':
			token.type_ = tokenTrue;
			ok = match("rue", 3);
			break;
		case 'f':
			token.type_ = tokenFalse;
			ok = match("alse", 4);
			break;
		case 'n':
			token.type_ = tokenNull;
			ok = match("ull", 3);
			break;
		case 'N':
			if (features_.allowSpecialFloats_) {
				token.type_ = tokenNaN;
				ok = match("aN", 2);
			}
			else {
				ok = false;
			}
			break;
		case 'I':
			if (features_.allowSpecialFloats_) {
				token.type_ = tokenPosInf;
				ok = match("nfinity", 7);
			}
			else {
				ok = false;
			}
			break;
		case ',':
			token.type_ = tokenArraySeparator;
			break;
		case ':':
			token.type_ = tokenMemberSeparator;
			break;
		case 0:
			token.type_ = tokenEndOfStream;
			break;
		default:
			ok = false;
			break;
		}
		if (!ok)
			token.type_ = tokenError;
		token.end_ = current_;
		return true;
	}

	void OurReader::skipSpaces() {
		while (current_ != end_) {
			Char c = *current_;
			if (c == ' ' || c == '\t' || c == '\r' || c == '\n')
				++current_;
			else
				break;
		}
	}

	bool OurReader::match(Location pattern, int patternLength) {
		if (end_ - current_ < patternLength)
			return false;
		int index = patternLength;
		while (index--)
			if (current_[index] != pattern[index])
				return false;
		current_ += patternLength;
		return true;
	}

	bool OurReader::readComment() {
		Location commentBegin = current_ - 1;
		Char c = getNextChar();
		bool successful = false;
		if (c == '*')
			successful = readCStyleComment();
		else if (c == '/')
			successful = readCppStyleComment();
		if (!successful)
			return false;

		if (collectComments_) {
			CommentPlacement placement = commentBefore;
			if (lastValueEnd_ && !containsNewLine(lastValueEnd_, commentBegin)) {
				if (c != '*' || !containsNewLine(commentBegin, current_))
					placement = commentAfterOnSameLine;
			}

			addComment(commentBegin, current_, placement);
		}
		return true;
	}

	void
		OurReader::addComment(Location begin, Location end, CommentPlacement placement) {
		assert(collectComments_);
		const JSONCPP_STRING& normalized = normalizeEOL(begin, end);
		if (placement == commentAfterOnSameLine) {
			assert(lastValue_ != 0);
			lastValue_->setComment(normalized, placement);
		}
		else {
			commentsBefore_ += normalized;
		}
	}

	bool OurReader::readCStyleComment() {
		while ((current_ + 1) < end_) {
			Char c = getNextChar();
			if (c == '*' && *current_ == '/')
				break;
		}
		return getNextChar() == '/';
	}

	bool OurReader::readCppStyleComment() {
		while (current_ != end_) {
			Char c = getNextChar();
			if (c == '\n')
				break;
			if (c == '\r') {
				// Consume DOS EOL. It will be normalized in addComment.
				if (current_ != end_ && *current_ == '\n')
					getNextChar();
				// Break on Moc OS 9 EOL.
				break;
			}
		}
		return true;
	}

	bool OurReader::readNumber(bool checkInf) {
		const char* p = current_;
		if (checkInf && p != end_ && *p == 'I') {
			current_ = ++p;
			return false;
		}
		char c = '0'; // stopgap for already consumed character
		// integral part
		while (c >= '0' && c <= '9')
			c = (current_ = p) < end_ ? *p++ : '\0';
		// fractional part
		if (c == '.') {
			c = (current_ = p) < end_ ? *p++ : '\0';
			while (c >= '0' && c <= '9')
				c = (current_ = p) < end_ ? *p++ : '\0';
		}
		// exponential part
		if (c == 'e' || c == 'E') {
			c = (current_ = p) < end_ ? *p++ : '\0';
			if (c == '+' || c == '-')
				c = (current_ = p) < end_ ? *p++ : '\0';
			while (c >= '0' && c <= '9')
				c = (current_ = p) < end_ ? *p++ : '\0';
		}
		return true;
	}
	bool OurReader::readString() {
		Char c = 0;
		while (current_ != end_) {
			c = getNextChar();
			if (c == '\\')
				getNextChar();
			else if (c == '"')
				break;
		}
		return c == '"';
	}

	bool OurReader::readStringSingleQuote() {
		Char c = 0;
		while (current_ != end_) {
			c = getNextChar();
			if (c == '\\')
				getNextChar();
			else if (c == '\'')
				break;
		}
		return c == '\'';
	}

	bool OurReader::readObject(Token& tokenStart) {
		Token tokenName;
		JSONCPP_STRING name;
		Value init(objectValue);
		currentValue().swapPayload(init);
		currentValue().setOffsetStart(tokenStart.start_ - begin_);
		while (readToken(tokenName)) {
			bool initialTokenOk = true;
			while (tokenName.type_ == tokenComment && initialTokenOk)
				initialTokenOk = readToken(tokenName);
			if (!initialTokenOk)
				break;
			if (tokenName.type_ == tokenObjectEnd && name.empty()) // empty object
				return true;
			name = "";
			if (tokenName.type_ == tokenString) {
				if (!decodeString(tokenName, name))
					return recoverFromError(tokenObjectEnd);
			}
			else if (tokenName.type_ == tokenNumber && features_.allowNumericKeys_) {
				Value numberName;
				if (!decodeNumber(tokenName, numberName))
					return recoverFromError(tokenObjectEnd);
				name = numberName.asString();
			}
			else {
				break;
			}

			Token colon;
			if (!readToken(colon) || colon.type_ != tokenMemberSeparator) {
				return addErrorAndRecover(
					"Missing ':' after object member name", colon, tokenObjectEnd);
			}
			if (name.length() >= (1U << 30)) throwRuntimeError("keylength >= 2^30");
			if (features_.rejectDupKeys_ && currentValue().isMember(name)) {
				JSONCPP_STRING msg = "Duplicate key: '" + name + "'";
				return addErrorAndRecover(
					msg, tokenName, tokenObjectEnd);
			}
			Value& value = currentValue()[name];
			nodes_.push(&value);
			bool ok = readValue();
			nodes_.pop();
			if (!ok) // error already set
				return recoverFromError(tokenObjectEnd);

			Token comma;
			if (!readToken(comma) ||
				(comma.type_ != tokenObjectEnd && comma.type_ != tokenArraySeparator &&
					comma.type_ != tokenComment)) {
				return addErrorAndRecover(
					"Missing ',' or '}' in object declaration", comma, tokenObjectEnd);
			}
			bool finalizeTokenOk = true;
			while (comma.type_ == tokenComment && finalizeTokenOk)
				finalizeTokenOk = readToken(comma);
			if (comma.type_ == tokenObjectEnd)
				return true;
		}
		return addErrorAndRecover(
			"Missing '}' or object member name", tokenName, tokenObjectEnd);
	}

	bool OurReader::readArray(Token& tokenStart) {
		Value init(arrayValue);
		currentValue().swapPayload(init);
		currentValue().setOffsetStart(tokenStart.start_ - begin_);
		skipSpaces();
		if (current_ != end_ && *current_ == ']') // empty array
		{
			Token endArray;
			readToken(endArray);
			return true;
		}
		int index = 0;
		for (;;) {
			Value& value = currentValue()[index++];
			nodes_.push(&value);
			bool ok = readValue();
			nodes_.pop();
			if (!ok) // error already set
				return recoverFromError(tokenArrayEnd);

			Token token;
			// Accept Comment after last item in the array.
			ok = readToken(token);
			while (token.type_ == tokenComment && ok) {
				ok = readToken(token);
			}
			bool badTokenType =
				(token.type_ != tokenArraySeparator && token.type_ != tokenArrayEnd);
			if (!ok || badTokenType) {
				return addErrorAndRecover(
					"Missing ',' or ']' in array declaration", token, tokenArrayEnd);
			}
			if (token.type_ == tokenArrayEnd)
				break;
		}
		return true;
	}

	bool OurReader::decodeNumber(Token& token) {
		Value decoded;
		if (!decodeNumber(token, decoded))
			return false;
		currentValue().swapPayload(decoded);
		currentValue().setOffsetStart(token.start_ - begin_);
		currentValue().setOffsetLimit(token.end_ - begin_);
		return true;
	}

	bool OurReader::decodeNumber(Token& token, Value& decoded) {
		// Attempts to parse the number as an integer. If the number is
		// larger than the maximum supported value of an integer then
		// we decode the number as a double.
		Location current = token.start_;
		bool isNegative = *current == '-';
		if (isNegative)
			++current;
		// TODO: Help the compiler do the div and mod at compile time or get rid of them.
		Value::LargestUInt maxIntegerValue =
			isNegative ? Value::LargestUInt(-Value::minLargestInt)
			: Value::maxLargestUInt;
		Value::LargestUInt threshold = maxIntegerValue / 10;
		Value::LargestUInt value = 0;
		while (current < token.end_) {
			Char c = *current++;
			if (c < '0' || c > '9')
				return decodeDouble(token, decoded);
			Value::UInt digit(static_cast<Value::UInt>(c - '0'));
			if (value >= threshold) {
				// We've hit or exceeded the max value divided by 10 (rounded down). If
				// a) we've only just touched the limit, b) this is the last digit, and
				// c) it's small enough to fit in that rounding delta, we're okay.
				// Otherwise treat this number as a double to avoid overflow.
				if (value > threshold || current != token.end_ ||
					digit > maxIntegerValue % 10) {
					return decodeDouble(token, decoded);
				}
			}
			value = value * 10 + digit;
		}
		if (isNegative)
			decoded = -Value::LargestInt(value);
		else if (value <= Value::LargestUInt(Value::maxInt))
			decoded = Value::LargestInt(value);
		else
			decoded = value;
		return true;
	}

	bool OurReader::decodeDouble(Token& token) {
		Value decoded;
		if (!decodeDouble(token, decoded))
			return false;
		currentValue().swapPayload(decoded);
		currentValue().setOffsetStart(token.start_ - begin_);
		currentValue().setOffsetLimit(token.end_ - begin_);
		return true;
	}

	bool OurReader::decodeDouble(Token& token, Value& decoded) {
		double value = 0;
		const int bufferSize = 32;
		int count;
		ptrdiff_t const length = token.end_ - token.start_;

		// Sanity check to avoid buffer overflow exploits.
		if (length < 0) {
			return addError("Unable to parse token length", token);
		}
		size_t const ulength = static_cast<size_t>(length);

		// Avoid using a string constant for the format control string given to
		// sscanf, as this can cause hard to debug crashes on OS X. See here for more
		// info:
		//
		//     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
		char format[] = "%lf";

		if (length <= bufferSize) {
			Char buffer[bufferSize + 1];
			memcpy(buffer, token.start_, ulength);
			buffer[length] = 0;
			fixNumericLocaleInput(buffer, buffer + length);
			count = sscanf(buffer, format, &value);
		}
		else {
			JSONCPP_STRING buffer(token.start_, token.end_);
			count = sscanf(buffer.c_str(), format, &value);
		}

		if (count != 1)
			return addError("'" + JSONCPP_STRING(token.start_, token.end_) +
				"' is not a number.",
				token);
		decoded = value;
		return true;
	}

	bool OurReader::decodeString(Token& token) {
		JSONCPP_STRING decoded_string;
		if (!decodeString(token, decoded_string))
			return false;
		Value decoded(decoded_string);
		currentValue().swapPayload(decoded);
		currentValue().setOffsetStart(token.start_ - begin_);
		currentValue().setOffsetLimit(token.end_ - begin_);
		return true;
	}

	bool OurReader::decodeString(Token& token, JSONCPP_STRING& decoded) {
		decoded.reserve(static_cast<size_t>(token.end_ - token.start_ - 2));
		Location current = token.start_ + 1; // skip '"'
		Location end = token.end_ - 1;       // do not include '"'
		while (current != end) {
			Char c = *current++;
			if (c == '"')
				break;
			else if (c == '\\') {
				if (current == end)
					return addError("Empty escape sequence in string", token, current);
				Char escape = *current++;
				switch (escape) {
				case '"':
					decoded += '"';
					break;
				case '/':
					decoded += '/';
					break;
				case '\\':
					decoded += '\\';
					break;
				case 'b':
					decoded += '\b';
					break;
				case 'f':
					decoded += '\f';
					break;
				case 'n':
					decoded += '\n';
					break;
				case 'r':
					decoded += '\r';
					break;
				case 't':
					decoded += '\t';
					break;
				case 'u': {
					unsigned int unicode;
					if (!decodeUnicodeCodePoint(token, current, end, unicode))
						return false;
					decoded += codePointToUTF8(unicode);
				} break;
				default:
					return addError("Bad escape sequence in string", token, current);
				}
			}
			else {
				decoded += c;
			}
		}
		return true;
	}

	bool OurReader::decodeUnicodeCodePoint(Token& token,
		Location& current,
		Location end,
		unsigned int& unicode) {
		if (!decodeUnicodeEscapeSequence(token, current, end, unicode))
			return false;
		if (unicode >= 0xD800 && unicode <= 0xDBFF) {
			// surrogate pairs
			if (end - current < 6)
				return addError(
					"additional six characters expected to parse unicode surrogate pair.",
					token,
					current);
			unsigned int surrogatePair;
			if (*(current++) == '\\' && *(current++) == 'u') {
				if (decodeUnicodeEscapeSequence(token, current, end, surrogatePair)) {
					unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);
				}
				else
					return false;
			}
			else
				return addError("expecting another \\u token to begin the second half of "
					"a unicode surrogate pair",
					token,
					current);
		}
		return true;
	}

	bool OurReader::decodeUnicodeEscapeSequence(Token& token,
		Location& current,
		Location end,
		unsigned int& ret_unicode) {
		if (end - current < 4)
			return addError(
				"Bad unicode escape sequence in string: four digits expected.",
				token,
				current);
		int unicode = 0;
		for (int index = 0; index < 4; ++index) {
			Char c = *current++;
			unicode *= 16;
			if (c >= '0' && c <= '9')
				unicode += c - '0';
			else if (c >= 'a' && c <= 'f')
				unicode += c - 'a' + 10;
			else if (c >= 'A' && c <= 'F')
				unicode += c - 'A' + 10;
			else
				return addError(
					"Bad unicode escape sequence in string: hexadecimal digit expected.",
					token,
					current);
		}
		ret_unicode = static_cast<unsigned int>(unicode);
		return true;
	}

	bool
		OurReader::addError(const JSONCPP_STRING& message, Token& token, Location extra) {
		ErrorInfo info;
		info.token_ = token;
		info.message_ = message;
		info.extra_ = extra;
		errors_.push_back(info);
		return false;
	}

	bool OurReader::recoverFromError(TokenType skipUntilToken) {
		size_t errorCount = errors_.size();
		Token skip;
		for (;;) {
			if (!readToken(skip))
				errors_.resize(errorCount); // discard errors caused by recovery
			if (skip.type_ == skipUntilToken || skip.type_ == tokenEndOfStream)
				break;
		}
		errors_.resize(errorCount);
		return false;
	}

	bool OurReader::addErrorAndRecover(const JSONCPP_STRING& message,
		Token& token,
		TokenType skipUntilToken) {
		addError(message, token);
		return recoverFromError(skipUntilToken);
	}

	Value& OurReader::currentValue() { return *(nodes_.top()); }

	OurReader::Char OurReader::getNextChar() {
		if (current_ == end_)
			return 0;
		return *current_++;
	}

	void OurReader::getLocationLineAndColumn(Location location,
		int& line,
		int& column) const {
		Location current = begin_;
		Location lastLineStart = current;
		line = 0;
		while (current < location && current != end_) {
			Char c = *current++;
			if (c == '\r') {
				if (*current == '\n')
					++current;
				lastLineStart = current;
				++line;
			}
			else if (c == '\n') {
				lastLineStart = current;
				++line;
			}
		}
		// column & line start at 1
		column = int(location - lastLineStart) + 1;
		++line;
	}

	JSONCPP_STRING OurReader::getLocationLineAndColumn(Location location) const {
		int line, column;
		getLocationLineAndColumn(location, line, column);
		char buffer[18 + 16 + 16 + 1];
		snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
		return buffer;
	}

	JSONCPP_STRING OurReader::getFormattedErrorMessages() const {
		JSONCPP_STRING formattedMessage;
		for (Errors::const_iterator itError = errors_.begin();
			itError != errors_.end();
			++itError) {
			const ErrorInfo& error = *itError;
			formattedMessage +=
				"* " + getLocationLineAndColumn(error.token_.start_) + "\n";
			formattedMessage += "  " + error.message_ + "\n";
			if (error.extra_)
				formattedMessage +=
				"See " + getLocationLineAndColumn(error.extra_) + " for detail.\n";
		}
		return formattedMessage;
	}

	std::vector<OurReader::StructuredError> OurReader::getStructuredErrors() const {
		std::vector<OurReader::StructuredError> allErrors;
		for (Errors::const_iterator itError = errors_.begin();
			itError != errors_.end();
			++itError) {
			const ErrorInfo& error = *itError;
			OurReader::StructuredError structured;
			structured.offset_start = error.token_.start_ - begin_;
			structured.offset_limit = error.token_.end_ - begin_;
			structured.message = error.message_;
			allErrors.push_back(structured);
		}
		return allErrors;
	}

	bool OurReader::pushError(const Value& value, const JSONCPP_STRING& message) {
		ptrdiff_t length = end_ - begin_;
		if (value.getOffsetStart() > length
			|| value.getOffsetLimit() > length)
			return false;
		Token token;
		token.type_ = tokenError;
		token.start_ = begin_ + value.getOffsetStart();
		token.end_ = end_ + value.getOffsetLimit();
		ErrorInfo info;
		info.token_ = token;
		info.message_ = message;
		info.extra_ = 0;
		errors_.push_back(info);
		return true;
	}

	bool OurReader::pushError(const Value& value, const JSONCPP_STRING& message, const Value& extra) {
		ptrdiff_t length = end_ - begin_;
		if (value.getOffsetStart() > length
			|| value.getOffsetLimit() > length
			|| extra.getOffsetLimit() > length)
			return false;
		Token token;
		token.type_ = tokenError;
		token.start_ = begin_ + value.getOffsetStart();
		token.end_ = begin_ + value.getOffsetLimit();
		ErrorInfo info;
		info.token_ = token;
		info.message_ = message;
		info.extra_ = begin_ + extra.getOffsetStart();
		errors_.push_back(info);
		return true;
	}

	bool OurReader::good() const {
		return !errors_.size();
	}

	class OurCharReader : public CharReader {
		bool const collectComments_;
		OurReader reader_;
	public:
		OurCharReader(
			bool collectComments,
			OurFeatures const& features)
			: collectComments_(collectComments)
			, reader_(features)
		{}
		bool parse(
			char const* beginDoc, char const* endDoc,
			Value* root, JSONCPP_STRING* errs) JSONCPP_OVERRIDE {
			bool ok = reader_.parse(beginDoc, endDoc, *root, collectComments_);
			if (errs) {
				*errs = reader_.getFormattedErrorMessages();
			}
			return ok;
		}
	};

	CharReaderBuilder::CharReaderBuilder()
	{
		setDefaults(&settings_);
	}
	CharReaderBuilder::~CharReaderBuilder()
	{}
	CharReader* CharReaderBuilder::newCharReader() const
	{
		bool collectComments = settings_["collectComments"].asBool();
		OurFeatures features = OurFeatures::all();
		features.allowComments_ = settings_["allowComments"].asBool();
		features.strictRoot_ = settings_["strictRoot"].asBool();
		features.allowDroppedNullPlaceholders_ = settings_["allowDroppedNullPlaceholders"].asBool();
		features.allowNumericKeys_ = settings_["allowNumericKeys"].asBool();
		features.allowSingleQuotes_ = settings_["allowSingleQuotes"].asBool();
		features.stackLimit_ = settings_["stackLimit"].asInt();
		features.failIfExtra_ = settings_["failIfExtra"].asBool();
		features.rejectDupKeys_ = settings_["rejectDupKeys"].asBool();
		features.allowSpecialFloats_ = settings_["allowSpecialFloats"].asBool();
		return new OurCharReader(collectComments, features);
	}
	static void getValidReaderKeys(std::set<JSONCPP_STRING>* valid_keys)
	{
		valid_keys->clear();
		valid_keys->insert("collectComments");
		valid_keys->insert("allowComments");
		valid_keys->insert("strictRoot");
		valid_keys->insert("allowDroppedNullPlaceholders");
		valid_keys->insert("allowNumericKeys");
		valid_keys->insert("allowSingleQuotes");
		valid_keys->insert("stackLimit");
		valid_keys->insert("failIfExtra");
		valid_keys->insert("rejectDupKeys");
		valid_keys->insert("allowSpecialFloats");
	}
	bool CharReaderBuilder::validate(Json::Value* invalid) const
	{
		Json::Value my_invalid;
		if (!invalid) invalid = &my_invalid;  // so we do not need to test for NULL
		Json::Value& inv = *invalid;
		std::set<JSONCPP_STRING> valid_keys;
		getValidReaderKeys(&valid_keys);
		Value::Members keys = settings_.getMemberNames();
		size_t n = keys.size();
		for (size_t i = 0; i < n; ++i) {
			JSONCPP_STRING const& key = keys[i];
			if (valid_keys.find(key) == valid_keys.end()) {
				inv[key] = settings_[key];
			}
		}
		return 0u == inv.size();
	}
	Value& CharReaderBuilder::operator[](JSONCPP_STRING key)
	{
		return settings_[key];
	}
	// static
	void CharReaderBuilder::strictMode(Json::Value* settings)
	{
		//! [CharReaderBuilderStrictMode]
		(*settings)["allowComments"] = false;
		(*settings)["strictRoot"] = true;
		(*settings)["allowDroppedNullPlaceholders"] = false;
		(*settings)["allowNumericKeys"] = false;
		(*settings)["allowSingleQuotes"] = false;
		(*settings)["stackLimit"] = 1000;
		(*settings)["failIfExtra"] = true;
		(*settings)["rejectDupKeys"] = true;
		(*settings)["allowSpecialFloats"] = false;
		//! [CharReaderBuilderStrictMode]
	}
	// static
	void CharReaderBuilder::setDefaults(Json::Value* settings)
	{
		//! [CharReaderBuilderDefaults]
		(*settings)["collectComments"] = true;
		(*settings)["allowComments"] = true;
		(*settings)["strictRoot"] = false;
		(*settings)["allowDroppedNullPlaceholders"] = false;
		(*settings)["allowNumericKeys"] = false;
		(*settings)["allowSingleQuotes"] = false;
		(*settings)["stackLimit"] = 1000;
		(*settings)["failIfExtra"] = false;
		(*settings)["rejectDupKeys"] = false;
		(*settings)["allowSpecialFloats"] = false;
		//! [CharReaderBuilderDefaults]
	}

	//////////////////////////////////
	// global functions

	bool parseFromStream(
		CharReader::Factory const& fact, JSONCPP_ISTREAM& sin,
		Value* root, JSONCPP_STRING* errs)
	{
		JSONCPP_OSTRINGSTREAM ssin;
		ssin << sin.rdbuf();
		JSONCPP_STRING doc = ssin.str();
		char const* begin = doc.data();
		char const* end = begin + doc.size();
		// Note that we do not actually need a null-terminator.
		CharReaderPtr const reader(fact.newCharReader());
		return reader->parse(begin, end, root, errs);
	}

	JSONCPP_ISTREAM& operator>>(JSONCPP_ISTREAM& sin, Value& root) {
		CharReaderBuilder b;
		JSONCPP_STRING errs;
		bool ok = parseFromStream(b, sin, &root, &errs);
		if (!ok) {
			fprintf(stderr,
				"Error from reader: %s",
				errs.c_str());

			throwRuntimeError(errs);
		}
		return sin;
	}
} // namespace Json

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_reader.cpp
// //////////////////////////////////////////////////////////////////////

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_valueiterator.inl
// //////////////////////////////////////////////////////////////////////

// Copyright 2007-2010 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

// included by json_value.cpp

namespace Json {
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// class ValueIteratorBase
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////

	ValueIteratorBase::ValueIteratorBase()
		: current_(), isNull_(true) {
	}

	ValueIteratorBase::ValueIteratorBase(
		const Value::ObjectValues::iterator& current)
		: current_(current), isNull_(false) {}

	Value& ValueIteratorBase::deref() const {
		return current_->second;
	}

	void ValueIteratorBase::increment() {
		++current_;
	}

	void ValueIteratorBase::decrement() {
		--current_;
	}

	ValueIteratorBase::difference_type
		ValueIteratorBase::computeDistance(const SelfType& other) const {
#ifdef JSON_USE_CPPTL_SMALLMAP
		return other.current_ - current_;
#else
		// Iterator for null value are initialized using the default
		// constructor, which initialize current_ to the default
		// std::map::iterator. As begin() and end() are two instance
		// of the default std::map::iterator, they can not be compared.
		// To allow this, we handle this comparison specifically.
		if (isNull_ && other.isNull_) {
			return 0;
		}

		// Usage of std::distance is not portable (does not compile with Sun Studio 12
		// RogueWave STL,
		// which is the one used by default).
		// Using a portable hand-made version for non random iterator instead:
		//   return difference_type( std::distance( current_, other.current_ ) );
		difference_type myDistance = 0;
		for (Value::ObjectValues::iterator it = current_; it != other.current_;
			++it) {
			++myDistance;
		}
		return myDistance;
#endif
	}

	bool ValueIteratorBase::isEqual(const SelfType& other) const {
		if (isNull_) {
			return other.isNull_;
		}
		return current_ == other.current_;
	}

	void ValueIteratorBase::copy(const SelfType& other) {
		current_ = other.current_;
		isNull_ = other.isNull_;
	}

	Value ValueIteratorBase::key() const {
		const Value::CZString czstring = (*current_).first;
		if (czstring.data()) {
			if (czstring.isStaticString())
				return Value(StaticString(czstring.data()));
			return Value(czstring.data(), czstring.data() + czstring.length());
		}
		return Value(czstring.index());
	}

	UInt ValueIteratorBase::index() const {
		const Value::CZString czstring = (*current_).first;
		if (!czstring.data())
			return czstring.index();
		return Value::UInt(-1);
	}

	JSONCPP_STRING ValueIteratorBase::name() const {
		char const* keey;
		char const* end;
		keey = memberName(&end);
		if (!keey) return JSONCPP_STRING();
		return JSONCPP_STRING(keey, end);
	}

	char const* ValueIteratorBase::memberName() const {
		const char* cname = (*current_).first.data();
		return cname ? cname : "";
	}

	char const* ValueIteratorBase::memberName(char const** end) const {
		const char* cname = (*current_).first.data();
		if (!cname) {
			*end = NULL;
			return NULL;
		}
		*end = cname + (*current_).first.length();
		return cname;
	}

	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// class ValueConstIterator
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////

	ValueConstIterator::ValueConstIterator() {}

	ValueConstIterator::ValueConstIterator(
		const Value::ObjectValues::iterator& current)
		: ValueIteratorBase(current) {}

	ValueConstIterator::ValueConstIterator(ValueIterator const& other)
		: ValueIteratorBase(other) {}

	ValueConstIterator& ValueConstIterator::
		operator=(const ValueIteratorBase& other) {
		copy(other);
		return *this;
	}

	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// class ValueIterator
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////

	ValueIterator::ValueIterator() {}

	ValueIterator::ValueIterator(const Value::ObjectValues::iterator& current)
		: ValueIteratorBase(current) {}

	ValueIterator::ValueIterator(const ValueConstIterator& other)
		: ValueIteratorBase(other) {
		throwRuntimeError("ConstIterator to Iterator should never be allowed.");
	}

	ValueIterator::ValueIterator(const ValueIterator& other)
		: ValueIteratorBase(other) {}

	ValueIterator& ValueIterator::operator=(const SelfType& other) {
		copy(other);
		return *this;
	}
} // namespace Json

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_valueiterator.inl
// //////////////////////////////////////////////////////////////////////

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_value.cpp
// //////////////////////////////////////////////////////////////////////

// Copyright 2011 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#if !defined(JSON_IS_AMALGAMATION)
#include <json/assertions.h>
#include <json/value.h>
#include <json/writer.h>
#endif // if !defined(JSON_IS_AMALGAMATION)
#include <math.h>
#include <sstream>
#include <utility>
#include <cstring>
#include <cassert>
#ifdef JSON_USE_CPPTL
#include <cpptl/conststring.h>
#endif
#include <cstddef> // size_t
#include <algorithm> // min()

#define JSON_ASSERT_UNREACHABLE assert(false)

namespace Json {
	// This is a walkaround to avoid the static initialization of Value::null.
	// kNull must be word-aligned to avoid crashing on ARM.  We use an alignment of
	// 8 (instead of 4) as a bit of future-proofing.
#if defined(__ARMEL__)
#define ALIGNAS(byte_alignment) __attribute__((aligned(byte_alignment)))
#else
#define ALIGNAS(byte_alignment)
#endif
//static const unsigned char ALIGNAS(8) kNull[sizeof(Value)] = { 0 };
//const unsigned char& kNullRef = kNull[0];
//const Value& Value::null = reinterpret_cast<const Value&>(kNullRef);
//const Value& Value::nullRef = null;

// static
	Value const& Value::nullSingleton()
	{
		static Value const nullStatic;
		return nullStatic;
	}

	// for backwards compatibility, we'll leave these global references around, but DO NOT
	// use them in JSONCPP library code any more!
	Value const& Value::null = Value::nullSingleton();
	Value const& Value::nullRef = Value::nullSingleton();

	const Int Value::minInt = Int(~(UInt(-1) / 2));
	const Int Value::maxInt = Int(UInt(-1) / 2);
	const UInt Value::maxUInt = UInt(-1);
#if defined(JSON_HAS_INT64)
	const Int64 Value::minInt64 = Int64(~(UInt64(-1) / 2));
	const Int64 Value::maxInt64 = Int64(UInt64(-1) / 2);
	const UInt64 Value::maxUInt64 = UInt64(-1);
	// The constant is hard-coded because some compiler have trouble
	// converting Value::maxUInt64 to a double correctly (AIX/xlC).
	// Assumes that UInt64 is a 64 bits integer.
	static const double maxUInt64AsDouble = 18446744073709551615.0;
#endif // defined(JSON_HAS_INT64)
	const LargestInt Value::minLargestInt = LargestInt(~(LargestUInt(-1) / 2));
	const LargestInt Value::maxLargestInt = LargestInt(LargestUInt(-1) / 2);
	const LargestUInt Value::maxLargestUInt = LargestUInt(-1);

#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
	template <typename T, typename U>
	static inline bool InRange(double d, T min, U max) {
		// The casts can lose precision, but we are looking only for
		// an approximate range. Might fail on edge cases though. ~cdunn
		//return d >= static_cast<double>(min) && d <= static_cast<double>(max);
		return d >= min && d <= max;
	}
#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
	static inline double integerToDouble(Json::UInt64 value) {
		return static_cast<double>(Int64(value / 2)) * 2.0 + static_cast<double>(Int64(value & 1));
	}

	template <typename T> static inline double integerToDouble(T value) {
		return static_cast<double>(value);
	}

	template <typename T, typename U>
	static inline bool InRange(double d, T min, U max) {
		return d >= integerToDouble(min) && d <= integerToDouble(max);
	}
#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)

	/** Duplicates the specified string value.
	 * @param value Pointer to the string to duplicate. Must be zero-terminated if
	 *              length is "unknown".
	 * @param length Length of the value. if equals to unknown, then it will be
	 *               computed using strlen(value).
	 * @return Pointer on the duplicate instance of string.
	 */
	static inline char* duplicateStringValue(const char* value,
		size_t length)
	{
		// Avoid an integer overflow in the call to malloc below by limiting length
		// to a sane value.
		if (length >= static_cast<size_t>(Value::maxInt))
			length = Value::maxInt - 1;

		char* newString = static_cast<char*>(malloc(length + 1));
		if (newString == NULL) {
			throwRuntimeError(
				"in Json::Value::duplicateStringValue(): "
				"Failed to allocate string value buffer");
		}
		memcpy(newString, value, length);
		newString[length] = 0;
		return newString;
	}

	/* Record the length as a prefix.
	 */
	static inline char* duplicateAndPrefixStringValue(
		const char* value,
		unsigned int length)
	{
		// Avoid an integer overflow in the call to malloc below by limiting length
		// to a sane value.
		JSON_ASSERT_MESSAGE(length <= static_cast<unsigned>(Value::maxInt) - sizeof(unsigned) - 1U,
			"in Json::Value::duplicateAndPrefixStringValue(): "
			"length too big for prefixing");
		unsigned actualLength = length + static_cast<unsigned>(sizeof(unsigned)) + 1U;
		char* newString = static_cast<char*>(malloc(actualLength));
		if (newString == 0) {
			throwRuntimeError(
				"in Json::Value::duplicateAndPrefixStringValue(): "
				"Failed to allocate string value buffer");
		}
		*reinterpret_cast<unsigned*>(newString) = length;
		memcpy(newString + sizeof(unsigned), value, length);
		newString[actualLength - 1U] = 0; // to avoid buffer over-run accidents by users later
		return newString;
	}
	inline static void decodePrefixedString(
		bool isPrefixed, char const* prefixed,
		unsigned* length, char const** value)
	{
		if (!isPrefixed) {
			*length = static_cast<unsigned>(strlen(prefixed));
			*value = prefixed;
		}
		else {
			*length = *reinterpret_cast<unsigned const*>(prefixed);
			*value = prefixed + sizeof(unsigned);
		}
	}
	/** Free the string duplicated by duplicateStringValue()/duplicateAndPrefixStringValue().
	 */
#if JSONCPP_USING_SECURE_MEMORY
	static inline void releasePrefixedStringValue(char* value) {
		unsigned length = 0;
		char const* valueDecoded;
		decodePrefixedString(true, value, &length, &valueDecoded);
		size_t const size = sizeof(unsigned) + length + 1U;
		memset(value, 0, size);
		free(value);
	}
	static inline void releaseStringValue(char* value, unsigned length) {
		// length==0 => we allocated the strings memory
		size_t size = (length == 0) ? strlen(value) : length;
		memset(value, 0, size);
		free(value);
	}
#else // !JSONCPP_USING_SECURE_MEMORY
	static inline void releasePrefixedStringValue(char* value) {
		free(value);
	}
	static inline void releaseStringValue(char* value, unsigned) {
		free(value);
	}
#endif // JSONCPP_USING_SECURE_MEMORY
} // namespace Json

// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// ValueInternals...
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
// //////////////////////////////////////////////////////////////////
#if !defined(JSON_IS_AMALGAMATION)

#include "json_valueiterator.inl"
#endif // if !defined(JSON_IS_AMALGAMATION)

namespace Json {
	Exception::Exception(JSONCPP_STRING const& msg)
		: msg_(msg)
	{}
	Exception::~Exception() throw()
	{}
	char const* Exception::what() const throw()
	{
		return msg_.c_str();
	}
	RuntimeError::RuntimeError(JSONCPP_STRING const& msg)
		: Exception(msg)
	{}
	LogicError::LogicError(JSONCPP_STRING const& msg)
		: Exception(msg)
	{}
	JSONCPP_NORETURN void throwRuntimeError(JSONCPP_STRING const& msg)
	{
		throw RuntimeError(msg);
	}
	JSONCPP_NORETURN void throwLogicError(JSONCPP_STRING const& msg)
	{
		throw LogicError(msg);
	}

	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// class Value::CommentInfo
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////

	Value::CommentInfo::CommentInfo() : comment_(0)
	{}

	Value::CommentInfo::~CommentInfo() {
		if (comment_)
			releaseStringValue(comment_, 0u);
	}

	void Value::CommentInfo::setComment(const char* text, size_t len) {
		if (comment_) {
			releaseStringValue(comment_, 0u);
			comment_ = 0;
		}
		JSON_ASSERT(text != 0);
		JSON_ASSERT_MESSAGE(
			text[0] == '\0' || text[0] == '/',
			"in Json::Value::setComment(): Comments must start with /");
		// It seems that /**/ style comments are acceptable as well.
		comment_ = duplicateStringValue(text, len);
	}

	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// class Value::CZString
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////

	// Notes: policy_ indicates if the string was allocated when
	// a string is stored.

	Value::CZString::CZString(ArrayIndex aindex) : cstr_(0), index_(aindex) {}

	Value::CZString::CZString(char const* str, unsigned ulength, DuplicationPolicy allocate)
		: cstr_(str) {
		// allocate != duplicate
		storage_.policy_ = allocate & 0x3;
		storage_.length_ = ulength & 0x3FFFFFFF;
	}

	Value::CZString::CZString(const CZString& other) {
		cstr_ = (other.storage_.policy_ != noDuplication && other.cstr_ != 0
			? duplicateStringValue(other.cstr_, other.storage_.length_)
			: other.cstr_);
		storage_.policy_ = static_cast<unsigned>(other.cstr_
			? (static_cast<DuplicationPolicy>(other.storage_.policy_) == noDuplication
				? noDuplication : duplicate)
			: static_cast<DuplicationPolicy>(other.storage_.policy_)) & 3U;
		storage_.length_ = other.storage_.length_;
	}

#if JSON_HAS_RVALUE_REFERENCES
	Value::CZString::CZString(CZString&& other)
		: cstr_(other.cstr_), index_(other.index_) {
		other.cstr_ = nullptr;
	}
#endif

	Value::CZString::~CZString() {
		if (cstr_ && storage_.policy_ == duplicate) {
			releaseStringValue(const_cast<char*>(cstr_), storage_.length_ + 1u); //+1 for null terminating character for sake of completeness but not actually necessary
		}
	}

	void Value::CZString::swap(CZString& other) {
		std::swap(cstr_, other.cstr_);
		std::swap(index_, other.index_);
	}

	Value::CZString& Value::CZString::operator=(CZString other) {
		swap(other);
		return *this;
	}

	bool Value::CZString::operator<(const CZString& other) const {
		if (!cstr_) return index_ < other.index_;
		//return strcmp(cstr_, other.cstr_) < 0;
		// Assume both are strings.
		unsigned this_len = this->storage_.length_;
		unsigned other_len = other.storage_.length_;
		unsigned min_len = std::min(this_len, other_len);
		JSON_ASSERT(this->cstr_ && other.cstr_);
		int comp = memcmp(this->cstr_, other.cstr_, min_len);
		if (comp < 0) return true;
		if (comp > 0) return false;
		return (this_len < other_len);
	}

	bool Value::CZString::operator==(const CZString& other) const {
		if (!cstr_) return index_ == other.index_;
		//return strcmp(cstr_, other.cstr_) == 0;
		// Assume both are strings.
		unsigned this_len = this->storage_.length_;
		unsigned other_len = other.storage_.length_;
		if (this_len != other_len) return false;
		JSON_ASSERT(this->cstr_ && other.cstr_);
		int comp = memcmp(this->cstr_, other.cstr_, this_len);
		return comp == 0;
	}

	ArrayIndex Value::CZString::index() const { return index_; }

	//const char* Value::CZString::c_str() const { return cstr_; }
	const char* Value::CZString::data() const { return cstr_; }
	unsigned Value::CZString::length() const { return storage_.length_; }
	bool Value::CZString::isStaticString() const { return storage_.policy_ == noDuplication; }

	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// class Value::Value
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////

	/*! \internal Default constructor initialization must be equivalent to:
	 * memset( this, 0, sizeof(Value) )
	 * This optimization is used in ValueInternalMap fast allocator.
	 */
	Value::Value(ValueType vtype) {
		static char const empty[] = "";
		initBasic(vtype);
		switch (vtype) {
		case nullValue:
			break;
		case intValue:
		case uintValue:
			value_.int_ = 0;
			break;
		case realValue:
			value_.real_ = 0.0;
			break;
		case stringValue:
			// allocated_ == false, so this is safe.
			value_.string_ = const_cast<char*>(static_cast<char const*>(empty));
			break;
		case arrayValue:
		case objectValue:
			value_.map_ = new ObjectValues();
			break;
		case booleanValue:
			value_.bool_ = false;
			break;
		default:
			JSON_ASSERT_UNREACHABLE;
		}
	}

	Value::Value(Int value) {
		initBasic(intValue);
		value_.int_ = value;
	}

	Value::Value(UInt value) {
		initBasic(uintValue);
		value_.uint_ = value;
	}
#if defined(JSON_HAS_INT64)
	Value::Value(Int64 value) {
		initBasic(intValue);
		value_.int_ = value;
	}
	Value::Value(UInt64 value) {
		initBasic(uintValue);
		value_.uint_ = value;
	}
#endif // defined(JSON_HAS_INT64)

	Value::Value(double value) {
		initBasic(realValue);
		value_.real_ = value;
	}

	Value::Value(const char* value) {
		initBasic(stringValue, true);
		value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(strlen(value)));
	}

	Value::Value(const char* beginValue, const char* endValue) {
		initBasic(stringValue, true);
		value_.string_ =
			duplicateAndPrefixStringValue(beginValue, static_cast<unsigned>(endValue - beginValue));
	}

	Value::Value(const JSONCPP_STRING& value) {
		initBasic(stringValue, true);
		value_.string_ =
			duplicateAndPrefixStringValue(value.data(), static_cast<unsigned>(value.length()));
	}

	Value::Value(const StaticString& value) {
		initBasic(stringValue);
		value_.string_ = const_cast<char*>(value.c_str());
	}

#ifdef JSON_USE_CPPTL
	Value::Value(const CppTL::ConstString& value) {
		initBasic(stringValue, true);
		value_.string_ = duplicateAndPrefixStringValue(value, static_cast<unsigned>(value.length()));
	}
#endif

	Value::Value(bool value) {
		initBasic(booleanValue);
		value_.bool_ = value;
	}

	Value::Value(Value const& other)
		: type_(other.type_), allocated_(false)
		,
		comments_(0), start_(other.start_), limit_(other.limit_)
	{
		switch (type_) {
		case nullValue:
		case intValue:
		case uintValue:
		case realValue:
		case booleanValue:
			value_ = other.value_;
			break;
		case stringValue:
			if (other.value_.string_ && other.allocated_) {
				unsigned len;
				char const* str;
				decodePrefixedString(other.allocated_, other.value_.string_,
					&len, &str);
				value_.string_ = duplicateAndPrefixStringValue(str, len);
				allocated_ = true;
			}
			else {
				value_.string_ = other.value_.string_;
				allocated_ = false;
			}
			break;
		case arrayValue:
		case objectValue:
			value_.map_ = new ObjectValues(*other.value_.map_);
			break;
		default:
			JSON_ASSERT_UNREACHABLE;
		}
		if (other.comments_) {
			comments_ = new CommentInfo[numberOfCommentPlacement];
			for (int comment = 0; comment < numberOfCommentPlacement; ++comment) {
				const CommentInfo& otherComment = other.comments_[comment];
				if (otherComment.comment_)
					comments_[comment].setComment(
						otherComment.comment_, strlen(otherComment.comment_));
			}
		}
	}

#if JSON_HAS_RVALUE_REFERENCES
	// Move constructor
	Value::Value(Value&& other) {
		initBasic(nullValue);
		swap(other);
	}
#endif

	Value::~Value() {
		switch (type_) {
		case nullValue:
		case intValue:
		case uintValue:
		case realValue:
		case booleanValue:
			break;
		case stringValue:
			if (allocated_)
				releasePrefixedStringValue(value_.string_);
			break;
		case arrayValue:
		case objectValue:
			delete value_.map_;
			break;
		default:
			JSON_ASSERT_UNREACHABLE;
		}

		delete[] comments_;

		value_.uint_ = 0;
	}

	Value& Value::operator=(Value other) {
		swap(other);
		return *this;
	}

	void Value::swapPayload(Value& other) {
		ValueType temp = type_;
		type_ = other.type_;
		other.type_ = temp;
		std::swap(value_, other.value_);
		int temp2 = allocated_;
		allocated_ = other.allocated_;
		other.allocated_ = temp2 & 0x1;
	}

	void Value::swap(Value& other) {
		swapPayload(other);
		std::swap(comments_, other.comments_);
		std::swap(start_, other.start_);
		std::swap(limit_, other.limit_);
	}

	ValueType Value::type() const { return type_; }

	int Value::compare(const Value& other) const {
		if (*this < other)
			return -1;
		if (*this > other)
			return 1;
		return 0;
	}

	bool Value::operator<(const Value& other) const {
		int typeDelta = type_ - other.type_;
		if (typeDelta)
			return typeDelta < 0 ? true : false;
		switch (type_) {
		case nullValue:
			return false;
		case intValue:
			return value_.int_ < other.value_.int_;
		case uintValue:
			return value_.uint_ < other.value_.uint_;
		case realValue:
			return value_.real_ < other.value_.real_;
		case booleanValue:
			return value_.bool_ < other.value_.bool_;
		case stringValue:
		{
			if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
				if (other.value_.string_) return true;
				else return false;
			}
			unsigned this_len;
			unsigned other_len;
			char const* this_str;
			char const* other_str;
			decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
			decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
			unsigned min_len = std::min(this_len, other_len);
			JSON_ASSERT(this_str && other_str);
			int comp = memcmp(this_str, other_str, min_len);
			if (comp < 0) return true;
			if (comp > 0) return false;
			return (this_len < other_len);
		}
		case arrayValue:
		case objectValue: {
			int delta = int(value_.map_->size() - other.value_.map_->size());
			if (delta)
				return delta < 0;
			return (*value_.map_) < (*other.value_.map_);
		}
		default:
			JSON_ASSERT_UNREACHABLE;
		}
		return false; // unreachable
	}

	bool Value::operator<=(const Value& other) const { return !(other < *this); }

	bool Value::operator>=(const Value& other) const { return !(*this < other); }

	bool Value::operator>(const Value& other) const { return other < *this; }

	bool Value::operator==(const Value& other) const {
		// if ( type_ != other.type_ )
		// GCC 2.95.3 says:
		// attempt to take address of bit-field structure member `Json::Value::type_'
		// Beats me, but a temp solves the problem.
		int temp = other.type_;
		if (type_ != temp)
			return false;
		switch (type_) {
		case nullValue:
			return true;
		case intValue:
			return value_.int_ == other.value_.int_;
		case uintValue:
			return value_.uint_ == other.value_.uint_;
		case realValue:
			return value_.real_ == other.value_.real_;
		case booleanValue:
			return value_.bool_ == other.value_.bool_;
		case stringValue:
		{
			if ((value_.string_ == 0) || (other.value_.string_ == 0)) {
				return (value_.string_ == other.value_.string_);
			}
			unsigned this_len;
			unsigned other_len;
			char const* this_str;
			char const* other_str;
			decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
			decodePrefixedString(other.allocated_, other.value_.string_, &other_len, &other_str);
			if (this_len != other_len) return false;
			JSON_ASSERT(this_str && other_str);
			int comp = memcmp(this_str, other_str, this_len);
			return comp == 0;
		}
		case arrayValue:
		case objectValue:
			return value_.map_->size() == other.value_.map_->size() &&
				(*value_.map_) == (*other.value_.map_);
		default:
			JSON_ASSERT_UNREACHABLE;
		}
		return false; // unreachable
	}

	bool Value::operator!=(const Value& other) const { return !(*this == other); }

	const char* Value::asCString() const {
		JSON_ASSERT_MESSAGE(type_ == stringValue,
			"in Json::Value::asCString(): requires stringValue");
		if (value_.string_ == 0) return 0;
		unsigned this_len;
		char const* this_str;
		decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
		return this_str;
	}

#if JSONCPP_USING_SECURE_MEMORY
	unsigned Value::getCStringLength() const {
		JSON_ASSERT_MESSAGE(type_ == stringValue,
			"in Json::Value::asCString(): requires stringValue");
		if (value_.string_ == 0) return 0;
		unsigned this_len;
		char const* this_str;
		decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
		return this_len;
	}
#endif

	bool Value::getString(char const** str, char const** cend) const {
		if (type_ != stringValue) return false;
		if (value_.string_ == 0) return false;
		unsigned length;
		decodePrefixedString(this->allocated_, this->value_.string_, &length, str);
		*cend = *str + length;
		return true;
	}

	JSONCPP_STRING Value::asString() const {
		switch (type_) {
		case nullValue:
			return "";
		case stringValue:
		{
			if (value_.string_ == 0) return "";
			unsigned this_len;
			char const* this_str;
			decodePrefixedString(this->allocated_, this->value_.string_, &this_len, &this_str);
			return JSONCPP_STRING(this_str, this_len);
		}
		case booleanValue:
			return value_.bool_ ? "true" : "false";
		case intValue:
			return valueToString(value_.int_);
		case uintValue:
			return valueToString(value_.uint_);
		case realValue:
			return valueToString(value_.real_);
		default:
			JSON_FAIL_MESSAGE("Type is not convertible to string");
		}
	}

#ifdef JSON_USE_CPPTL
	CppTL::ConstString Value::asConstString() const {
		unsigned len;
		char const* str;
		decodePrefixedString(allocated_, value_.string_,
			&len, &str);
		return CppTL::ConstString(str, len);
	}
#endif

	Value::Int Value::asInt() const {
		switch (type_) {
		case intValue:
			JSON_ASSERT_MESSAGE(isInt(), "LargestInt out of Int range");
			return Int(value_.int_);
		case uintValue:
			JSON_ASSERT_MESSAGE(isInt(), "LargestUInt out of Int range");
			return Int(value_.uint_);
		case realValue:
			JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt, maxInt),
				"double out of Int range");
			return Int(value_.real_);
		case nullValue:
			return 0;
		case booleanValue:
			return value_.bool_ ? 1 : 0;
		default:
			break;
		}
		JSON_FAIL_MESSAGE("Value is not convertible to Int.");
	}

	Value::UInt Value::asUInt() const {
		switch (type_) {
		case intValue:
			JSON_ASSERT_MESSAGE(isUInt(), "LargestInt out of UInt range");
			return UInt(value_.int_);
		case uintValue:
			JSON_ASSERT_MESSAGE(isUInt(), "LargestUInt out of UInt range");
			return UInt(value_.uint_);
		case realValue:
			JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt),
				"double out of UInt range");
			return UInt(value_.real_);
		case nullValue:
			return 0;
		case booleanValue:
			return value_.bool_ ? 1 : 0;
		default:
			break;
		}
		JSON_FAIL_MESSAGE("Value is not convertible to UInt.");
	}

#if defined(JSON_HAS_INT64)

	Value::Int64 Value::asInt64() const {
		switch (type_) {
		case intValue:
			return Int64(value_.int_);
		case uintValue:
			JSON_ASSERT_MESSAGE(isInt64(), "LargestUInt out of Int64 range");
			return Int64(value_.uint_);
		case realValue:
			JSON_ASSERT_MESSAGE(InRange(value_.real_, minInt64, maxInt64),
				"double out of Int64 range");
			return Int64(value_.real_);
		case nullValue:
			return 0;
		case booleanValue:
			return value_.bool_ ? 1 : 0;
		default:
			break;
		}
		JSON_FAIL_MESSAGE("Value is not convertible to Int64.");
	}

	Value::UInt64 Value::asUInt64() const {
		switch (type_) {
		case intValue:
			JSON_ASSERT_MESSAGE(isUInt64(), "LargestInt out of UInt64 range");
			return UInt64(value_.int_);
		case uintValue:
			return UInt64(value_.uint_);
		case realValue:
			JSON_ASSERT_MESSAGE(InRange(value_.real_, 0, maxUInt64),
				"double out of UInt64 range");
			return UInt64(value_.real_);
		case nullValue:
			return 0;
		case booleanValue:
			return value_.bool_ ? 1 : 0;
		default:
			break;
		}
		JSON_FAIL_MESSAGE("Value is not convertible to UInt64.");
	}
#endif // if defined(JSON_HAS_INT64)

	LargestInt Value::asLargestInt() const {
#if defined(JSON_NO_INT64)
		return asInt();
#else
		return asInt64();
#endif
	}

	LargestUInt Value::asLargestUInt() const {
#if defined(JSON_NO_INT64)
		return asUInt();
#else
		return asUInt64();
#endif
	}

	double Value::asDouble() const {
		switch (type_) {
		case intValue:
			return static_cast<double>(value_.int_);
		case uintValue:
#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
			return static_cast<double>(value_.uint_);
#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
			return integerToDouble(value_.uint_);
#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
		case realValue:
			return value_.real_;
		case nullValue:
			return 0.0;
		case booleanValue:
			return value_.bool_ ? 1.0 : 0.0;
		default:
			break;
		}
		JSON_FAIL_MESSAGE("Value is not convertible to double.");
	}

	float Value::asFloat() const {
		switch (type_) {
		case intValue:
			return static_cast<float>(value_.int_);
		case uintValue:
#if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
			return static_cast<float>(value_.uint_);
#else  // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
			// This can fail (silently?) if the value is bigger than MAX_FLOAT.
			return static_cast<float>(integerToDouble(value_.uint_));
#endif // if !defined(JSON_USE_INT64_DOUBLE_CONVERSION)
		case realValue:
			return static_cast<float>(value_.real_);
		case nullValue:
			return 0.0;
		case booleanValue:
			return value_.bool_ ? 1.0f : 0.0f;
		default:
			break;
		}
		JSON_FAIL_MESSAGE("Value is not convertible to float.");
	}

	bool Value::asBool() const {
		switch (type_) {
		case booleanValue:
			return value_.bool_;
		case nullValue:
			return false;
		case intValue:
			return value_.int_ ? true : false;
		case uintValue:
			return value_.uint_ ? true : false;
		case realValue:
			// This is kind of strange. Not recommended.
			return (value_.real_ != 0.0) ? true : false;
		default:
			break;
		}
		JSON_FAIL_MESSAGE("Value is not convertible to bool.");
	}

	bool Value::isConvertibleTo(ValueType other) const {
		switch (other) {
		case nullValue:
			return (isNumeric() && asDouble() == 0.0) ||
				(type_ == booleanValue && value_.bool_ == false) ||
				(type_ == stringValue && asString() == "") ||
				(type_ == arrayValue && value_.map_->size() == 0) ||
				(type_ == objectValue && value_.map_->size() == 0) ||
				type_ == nullValue;
		case intValue:
			return isInt() ||
				(type_ == realValue && InRange(value_.real_, minInt, maxInt)) ||
				type_ == booleanValue || type_ == nullValue;
		case uintValue:
			return isUInt() ||
				(type_ == realValue && InRange(value_.real_, 0, maxUInt)) ||
				type_ == booleanValue || type_ == nullValue;
		case realValue:
			return isNumeric() || type_ == booleanValue || type_ == nullValue;
		case booleanValue:
			return isNumeric() || type_ == booleanValue || type_ == nullValue;
		case stringValue:
			return isNumeric() || type_ == booleanValue || type_ == stringValue ||
				type_ == nullValue;
		case arrayValue:
			return type_ == arrayValue || type_ == nullValue;
		case objectValue:
			return type_ == objectValue || type_ == nullValue;
		}
		JSON_ASSERT_UNREACHABLE;
		return false;
	}

	/// Number of values in array or object
	ArrayIndex Value::size() const {
		switch (type_) {
		case nullValue:
		case intValue:
		case uintValue:
		case realValue:
		case booleanValue:
		case stringValue:
			return 0;
		case arrayValue: // size of the array is highest index + 1
			if (!value_.map_->empty()) {
				ObjectValues::const_iterator itLast = value_.map_->end();
				--itLast;
				return (*itLast).first.index() + 1;
			}
			return 0;
		case objectValue:
			return ArrayIndex(value_.map_->size());
		}
		JSON_ASSERT_UNREACHABLE;
		return 0; // unreachable;
	}

	bool Value::empty() const {
		if (isNull() || isArray() || isObject())
			return size() == 0u;
		else
			return false;
	}

	bool Value::operator!() const { return isNull(); }

	void Value::clear() {
		JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue ||
			type_ == objectValue,
			"in Json::Value::clear(): requires complex value");
		start_ = 0;
		limit_ = 0;
		switch (type_) {
		case arrayValue:
		case objectValue:
			value_.map_->clear();
			break;
		default:
			break;
		}
	}

	void Value::resize(ArrayIndex newSize) {
		JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == arrayValue,
			"in Json::Value::resize(): requires arrayValue");
		if (type_ == nullValue)
			*this = Value(arrayValue);
		ArrayIndex oldSize = size();
		if (newSize == 0)
			clear();
		else if (newSize > oldSize)
			(*this)[newSize - 1];
		else {
			for (ArrayIndex index = newSize; index < oldSize; ++index) {
				value_.map_->erase(index);
			}
			JSON_ASSERT(size() == newSize);
		}
	}

	Value& Value::operator[](ArrayIndex index) {
		JSON_ASSERT_MESSAGE(
			type_ == nullValue || type_ == arrayValue,
			"in Json::Value::operator[](ArrayIndex): requires arrayValue");
		if (type_ == nullValue)
			*this = Value(arrayValue);
		CZString key(index);
		ObjectValues::iterator it = value_.map_->lower_bound(key);
		if (it != value_.map_->end() && (*it).first == key)
			return (*it).second;

		ObjectValues::value_type defaultValue(key, nullSingleton());
		it = value_.map_->insert(it, defaultValue);
		return (*it).second;
	}

	Value& Value::operator[](int index) {
		JSON_ASSERT_MESSAGE(
			index >= 0,
			"in Json::Value::operator[](int index): index cannot be negative");
		return (*this)[ArrayIndex(index)];
	}

	const Value& Value::operator[](ArrayIndex index) const {
		JSON_ASSERT_MESSAGE(
			type_ == nullValue || type_ == arrayValue,
			"in Json::Value::operator[](ArrayIndex)const: requires arrayValue");
		if (type_ == nullValue)
			return nullSingleton();
		CZString key(index);
		ObjectValues::const_iterator it = value_.map_->find(key);
		if (it == value_.map_->end())
			return nullSingleton();
		return (*it).second;
	}

	const Value& Value::operator[](int index) const {
		JSON_ASSERT_MESSAGE(
			index >= 0,
			"in Json::Value::operator[](int index) const: index cannot be negative");
		return (*this)[ArrayIndex(index)];
	}

	void Value::initBasic(ValueType vtype, bool allocated) {
		type_ = vtype;
		allocated_ = allocated;
		comments_ = 0;
		start_ = 0;
		limit_ = 0;
	}

	// Access an object value by name, create a null member if it does not exist.
	// @pre Type of '*this' is object or null.
	// @param key is null-terminated.
	Value& Value::resolveReference(const char* key) {
		JSON_ASSERT_MESSAGE(
			type_ == nullValue || type_ == objectValue,
			"in Json::Value::resolveReference(): requires objectValue");
		if (type_ == nullValue)
			*this = Value(objectValue);
		CZString actualKey(
			key, static_cast<unsigned>(strlen(key)), CZString::noDuplication); // NOTE!
		ObjectValues::iterator it = value_.map_->lower_bound(actualKey);
		if (it != value_.map_->end() && (*it).first == actualKey)
			return (*it).second;

		ObjectValues::value_type defaultValue(actualKey, nullSingleton());
		it = value_.map_->insert(it, defaultValue);
		Value& value = (*it).second;
		return value;
	}

	// @param key is not null-terminated.
	Value& Value::resolveReference(char const* key, char const* cend)
	{
		JSON_ASSERT_MESSAGE(
			type_ == nullValue || type_ == objectValue,
			"in Json::Value::resolveReference(key, end): requires objectValue");
		if (type_ == nullValue)
			*this = Value(objectValue);
		CZString actualKey(
			key, static_cast<unsigned>(cend - key), CZString::duplicateOnCopy);
		ObjectValues::iterator it = value_.map_->lower_bound(actualKey);
		if (it != value_.map_->end() && (*it).first == actualKey)
			return (*it).second;

		ObjectValues::value_type defaultValue(actualKey, nullSingleton());
		it = value_.map_->insert(it, defaultValue);
		Value& value = (*it).second;
		return value;
	}

	Value Value::get(ArrayIndex index, const Value& defaultValue) const {
		const Value* value = &((*this)[index]);
		return value == &nullSingleton() ? defaultValue : *value;
	}

	bool Value::isValidIndex(ArrayIndex index) const { return index < size(); }

	Value const* Value::find(char const* key, char const* cend) const
	{
		JSON_ASSERT_MESSAGE(
			type_ == nullValue || type_ == objectValue,
			"in Json::Value::find(key, end, found): requires objectValue or nullValue");
		if (type_ == nullValue) return NULL;
		CZString actualKey(key, static_cast<unsigned>(cend - key), CZString::noDuplication);
		ObjectValues::const_iterator it = value_.map_->find(actualKey);
		if (it == value_.map_->end()) return NULL;
		return &(*it).second;
	}
	const Value& Value::operator[](const char* key) const
	{
		Value const* found = find(key, key + strlen(key));
		if (!found) return nullSingleton();
		return *found;
	}
	Value const& Value::operator[](JSONCPP_STRING const& key) const
	{
		Value const* found = find(key.data(), key.data() + key.length());
		if (!found) return nullSingleton();
		return *found;
	}

	Value& Value::operator[](const char* key) {
		return resolveReference(key, key + strlen(key));
	}

	Value& Value::operator[](const JSONCPP_STRING& key) {
		return resolveReference(key.data(), key.data() + key.length());
	}

	Value& Value::operator[](const StaticString& key) {
		return resolveReference(key.c_str());
	}

#ifdef JSON_USE_CPPTL
	Value& Value::operator[](const CppTL::ConstString& key) {
		return resolveReference(key.c_str(), key.end_c_str());
	}
	Value const& Value::operator[](CppTL::ConstString const& key) const
	{
		Value const* found = find(key.c_str(), key.end_c_str());
		if (!found) return nullSingleton();
		return *found;
	}
#endif

	Value& Value::append(const Value& value) { return (*this)[size()] = value; }

	Value Value::get(char const* key, char const* cend, Value const& defaultValue) const
	{
		Value const* found = find(key, cend);
		return !found ? defaultValue : *found;
	}
	Value Value::get(char const* key, Value const& defaultValue) const
	{
		return get(key, key + strlen(key), defaultValue);
	}
	Value Value::get(JSONCPP_STRING const& key, Value const& defaultValue) const
	{
		return get(key.data(), key.data() + key.length(), defaultValue);
	}

	bool Value::removeMember(const char* key, const char* cend, Value* removed)
	{
		if (type_ != objectValue) {
			return false;
		}
		CZString actualKey(key, static_cast<unsigned>(cend - key), CZString::noDuplication);
		ObjectValues::iterator it = value_.map_->find(actualKey);
		if (it == value_.map_->end())
			return false;
		*removed = it->second;
		value_.map_->erase(it);
		return true;
	}
	bool Value::removeMember(const char* key, Value* removed)
	{
		return removeMember(key, key + strlen(key), removed);
	}
	bool Value::removeMember(JSONCPP_STRING const& key, Value* removed)
	{
		return removeMember(key.data(), key.data() + key.length(), removed);
	}
	Value Value::removeMember(const char* key)
	{
		JSON_ASSERT_MESSAGE(type_ == nullValue || type_ == objectValue,
			"in Json::Value::removeMember(): requires objectValue");
		if (type_ == nullValue)
			return nullSingleton();

		Value removed;  // null
		removeMember(key, key + strlen(key), &removed);
		return removed; // still null if removeMember() did nothing
	}
	Value Value::removeMember(const JSONCPP_STRING& key)
	{
		return removeMember(key.c_str());
	}

	bool Value::removeIndex(ArrayIndex index, Value* removed) {
		if (type_ != arrayValue) {
			return false;
		}
		CZString key(index);
		ObjectValues::iterator it = value_.map_->find(key);
		if (it == value_.map_->end()) {
			return false;
		}
		*removed = it->second;
		ArrayIndex oldSize = size();
		// shift left all items left, into the place of the "removed"
		for (ArrayIndex i = index; i < (oldSize - 1); ++i) {
			CZString keey(i);
			(*value_.map_)[keey] = (*this)[i + 1];
		}
		// erase the last one ("leftover")
		CZString keyLast(oldSize - 1);
		ObjectValues::iterator itLast = value_.map_->find(keyLast);
		value_.map_->erase(itLast);
		return true;
	}

#ifdef JSON_USE_CPPTL
	Value Value::get(const CppTL::ConstString& key,
		const Value& defaultValue) const {
		return get(key.c_str(), key.end_c_str(), defaultValue);
	}
#endif

	bool Value::isMember(char const* key, char const* cend) const
	{
		Value const* value = find(key, cend);
		return NULL != value;
	}
	bool Value::isMember(char const* key) const
	{
		return isMember(key, key + strlen(key));
	}
	bool Value::isMember(JSONCPP_STRING const& key) const
	{
		return isMember(key.data(), key.data() + key.length());
	}

#ifdef JSON_USE_CPPTL
	bool Value::isMember(const CppTL::ConstString& key) const {
		return isMember(key.c_str(), key.end_c_str());
	}
#endif

	Value::Members Value::getMemberNames() const {
		JSON_ASSERT_MESSAGE(
			type_ == nullValue || type_ == objectValue,
			"in Json::Value::getMemberNames(), value must be objectValue");
		if (type_ == nullValue)
			return Value::Members();
		Members members;
		members.reserve(value_.map_->size());
		ObjectValues::const_iterator it = value_.map_->begin();
		ObjectValues::const_iterator itEnd = value_.map_->end();
		for (; it != itEnd; ++it) {
			members.push_back(JSONCPP_STRING((*it).first.data(),
				(*it).first.length()));
		}
		return members;
	}
	//
	//# ifdef JSON_USE_CPPTL
	// EnumMemberNames
	// Value::enumMemberNames() const
	//{
	//   if ( type_ == objectValue )
	//   {
	//      return CppTL::Enum::any(  CppTL::Enum::transform(
	//         CppTL::Enum::keys( *(value_.map_), CppTL::Type<const CZString &>() ),
	//         MemberNamesTransform() ) );
	//   }
	//   return EnumMemberNames();
	//}
	//
	//
	// EnumValues
	// Value::enumValues() const
	//{
	//   if ( type_ == objectValue  ||  type_ == arrayValue )
	//      return CppTL::Enum::anyValues( *(value_.map_),
	//                                     CppTL::Type<const Value &>() );
	//   return EnumValues();
	//}
	//
	//# endif

	static bool IsIntegral(double d) {
		double integral_part;
		return modf(d, &integral_part) == 0.0;
	}

	bool Value::isNull() const { return type_ == nullValue; }

	bool Value::isBool() const { return type_ == booleanValue; }

	bool Value::isInt() const {
		switch (type_) {
		case intValue:
			return value_.int_ >= minInt && value_.int_ <= maxInt;
		case uintValue:
			return value_.uint_ <= UInt(maxInt);
		case realValue:
			return value_.real_ >= minInt && value_.real_ <= maxInt &&
				IsIntegral(value_.real_);
		default:
			break;
		}
		return false;
	}

	bool Value::isUInt() const {
		switch (type_) {
		case intValue:
			return value_.int_ >= 0 && LargestUInt(value_.int_) <= LargestUInt(maxUInt);
		case uintValue:
			return value_.uint_ <= maxUInt;
		case realValue:
			return value_.real_ >= 0 && value_.real_ <= maxUInt &&
				IsIntegral(value_.real_);
		default:
			break;
		}
		return false;
	}

	bool Value::isInt64() const {
#if defined(JSON_HAS_INT64)
		switch (type_) {
		case intValue:
			return true;
		case uintValue:
			return value_.uint_ <= UInt64(maxInt64);
		case realValue:
			// Note that maxInt64 (= 2^63 - 1) is not exactly representable as a
			// double, so double(maxInt64) will be rounded up to 2^63. Therefore we
			// require the value to be strictly less than the limit.
			return value_.real_ >= double(minInt64) &&
				value_.real_ < double(maxInt64) && IsIntegral(value_.real_);
		default:
			break;
		}
#endif // JSON_HAS_INT64
		return false;
	}

	bool Value::isUInt64() const {
#if defined(JSON_HAS_INT64)
		switch (type_) {
		case intValue:
			return value_.int_ >= 0;
		case uintValue:
			return true;
		case realValue:
			// Note that maxUInt64 (= 2^64 - 1) is not exactly representable as a
			// double, so double(maxUInt64) will be rounded up to 2^64. Therefore we
			// require the value to be strictly less than the limit.
			return value_.real_ >= 0 && value_.real_ < maxUInt64AsDouble&&
				IsIntegral(value_.real_);
		default:
			break;
		}
#endif // JSON_HAS_INT64
		return false;
	}

	bool Value::isIntegral() const {
#if defined(JSON_HAS_INT64)
		return isInt64() || isUInt64();
#else
		return isInt() || isUInt();
#endif
	}

	bool Value::isDouble() const { return type_ == realValue || isIntegral(); }

	bool Value::isNumeric() const { return isIntegral() || isDouble(); }

	bool Value::isString() const { return type_ == stringValue; }

	bool Value::isArray() const { return type_ == arrayValue; }

	bool Value::isObject() const { return type_ == objectValue; }

	void Value::setComment(const char* comment, size_t len, CommentPlacement placement) {
		if (!comments_)
			comments_ = new CommentInfo[numberOfCommentPlacement];
		if ((len > 0) && (comment[len - 1] == '\n')) {
			// Always discard trailing newline, to aid indentation.
			len -= 1;
		}
		comments_[placement].setComment(comment, len);
	}

	void Value::setComment(const char* comment, CommentPlacement placement) {
		setComment(comment, strlen(comment), placement);
	}

	void Value::setComment(const JSONCPP_STRING& comment, CommentPlacement placement) {
		setComment(comment.c_str(), comment.length(), placement);
	}

	bool Value::hasComment(CommentPlacement placement) const {
		return comments_ != 0 && comments_[placement].comment_ != 0;
	}

	JSONCPP_STRING Value::getComment(CommentPlacement placement) const {
		if (hasComment(placement))
			return comments_[placement].comment_;
		return "";
	}

	void Value::setOffsetStart(ptrdiff_t start) { start_ = start; }

	void Value::setOffsetLimit(ptrdiff_t limit) { limit_ = limit; }

	ptrdiff_t Value::getOffsetStart() const { return start_; }

	ptrdiff_t Value::getOffsetLimit() const { return limit_; }

	JSONCPP_STRING Value::toStyledString() const {
		StyledWriter writer;
		return writer.write(*this);
	}

	Value::const_iterator Value::begin() const {
		switch (type_) {
		case arrayValue:
		case objectValue:
			if (value_.map_)
				return const_iterator(value_.map_->begin());
			break;
		default:
			break;
		}
		return const_iterator();
	}

	Value::const_iterator Value::end() const {
		switch (type_) {
		case arrayValue:
		case objectValue:
			if (value_.map_)
				return const_iterator(value_.map_->end());
			break;
		default:
			break;
		}
		return const_iterator();
	}

	Value::iterator Value::begin() {
		switch (type_) {
		case arrayValue:
		case objectValue:
			if (value_.map_)
				return iterator(value_.map_->begin());
			break;
		default:
			break;
		}
		return iterator();
	}

	Value::iterator Value::end() {
		switch (type_) {
		case arrayValue:
		case objectValue:
			if (value_.map_)
				return iterator(value_.map_->end());
			break;
		default:
			break;
		}
		return iterator();
	}

	// class PathArgument
	// //////////////////////////////////////////////////////////////////

	PathArgument::PathArgument() : key_(), index_(), kind_(kindNone) {}

	PathArgument::PathArgument(ArrayIndex index)
		: key_(), index_(index), kind_(kindIndex) {}

	PathArgument::PathArgument(const char* key)
		: key_(key), index_(), kind_(kindKey) {}

	PathArgument::PathArgument(const JSONCPP_STRING& key)
		: key_(key.c_str()), index_(), kind_(kindKey) {}

	// class Path
	// //////////////////////////////////////////////////////////////////

	Path::Path(const JSONCPP_STRING& path,
		const PathArgument& a1,
		const PathArgument& a2,
		const PathArgument& a3,
		const PathArgument& a4,
		const PathArgument& a5) {
		InArgs in;
		in.push_back(&a1);
		in.push_back(&a2);
		in.push_back(&a3);
		in.push_back(&a4);
		in.push_back(&a5);
		makePath(path, in);
	}

	void Path::makePath(const JSONCPP_STRING& path, const InArgs& in) {
		const char* current = path.c_str();
		const char* end = current + path.length();
		InArgs::const_iterator itInArg = in.begin();
		while (current != end) {
			if (*current == '[') {
				++current;
				if (*current == '%')
					addPathInArg(path, in, itInArg, PathArgument::kindIndex);
				else {
					ArrayIndex index = 0;
					for (; current != end && *current >= '0' && *current <= '9'; ++current)
						index = index * 10 + ArrayIndex(*current - '0');
					args_.push_back(index);
				}
				if (current == end || *++current != ']')
					invalidPath(path, int(current - path.c_str()));
			}
			else if (*current == '%') {
				addPathInArg(path, in, itInArg, PathArgument::kindKey);
				++current;
			}
			else if (*current == '.' || *current == ']') {
				++current;
			}
			else {
				const char* beginName = current;
				while (current != end && !strchr("[.", *current))
					++current;
				args_.push_back(JSONCPP_STRING(beginName, current));
			}
		}
	}

	void Path::addPathInArg(const JSONCPP_STRING& /*path*/,
		const InArgs& in,
		InArgs::const_iterator& itInArg,
		PathArgument::Kind kind) {
		if (itInArg == in.end()) {
			// Error: missing argument %d
		}
		else if ((*itInArg)->kind_ != kind) {
			// Error: bad argument type
		}
		else {
			args_.push_back(**itInArg++);
		}
	}

	void Path::invalidPath(const JSONCPP_STRING& /*path*/, int /*location*/) {
		// Error: invalid path.
	}

	const Value& Path::resolve(const Value& root) const {
		const Value* node = &root;
		for (Args::const_iterator it = args_.begin(); it != args_.end(); ++it) {
			const PathArgument& arg = *it;
			if (arg.kind_ == PathArgument::kindIndex) {
				if (!node->isArray() || !node->isValidIndex(arg.index_)) {
					// Error: unable to resolve path (array value expected at position...
					return Value::null;
				}
				node = &((*node)[arg.index_]);
			}
			else if (arg.kind_ == PathArgument::kindKey) {
				if (!node->isObject()) {
					// Error: unable to resolve path (object value expected at position...)
					return Value::null;
				}
				node = &((*node)[arg.key_]);
				if (node == &Value::nullSingleton()) {
					// Error: unable to resolve path (object has no member named '' at
					// position...)
					return Value::null;
				}
			}
		}
		return *node;
	}

	Value Path::resolve(const Value& root, const Value& defaultValue) const {
		const Value* node = &root;
		for (Args::const_iterator it = args_.begin(); it != args_.end(); ++it) {
			const PathArgument& arg = *it;
			if (arg.kind_ == PathArgument::kindIndex) {
				if (!node->isArray() || !node->isValidIndex(arg.index_))
					return defaultValue;
				node = &((*node)[arg.index_]);
			}
			else if (arg.kind_ == PathArgument::kindKey) {
				if (!node->isObject())
					return defaultValue;
				node = &((*node)[arg.key_]);
				if (node == &Value::nullSingleton())
					return defaultValue;
			}
		}
		return *node;
	}

	Value& Path::make(Value& root) const {
		Value* node = &root;
		for (Args::const_iterator it = args_.begin(); it != args_.end(); ++it) {
			const PathArgument& arg = *it;
			if (arg.kind_ == PathArgument::kindIndex) {
				if (!node->isArray()) {
					// Error: node is not an array at position ...
				}
				node = &((*node)[arg.index_]);
			}
			else if (arg.kind_ == PathArgument::kindKey) {
				if (!node->isObject()) {
					// Error: node is not an object at position...
				}
				node = &((*node)[arg.key_]);
			}
		}
		return *node;
	}
} // namespace Json

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_value.cpp
// //////////////////////////////////////////////////////////////////////

// //////////////////////////////////////////////////////////////////////
// Beginning of content of file: src/lib_json/json_writer.cpp
// //////////////////////////////////////////////////////////////////////

// Copyright 2011 Baptiste Lepilleur
// Distributed under MIT license, or public domain if desired and
// recognized in your jurisdiction.
// See file LICENSE for detail or copy at http://jsoncpp.sourceforge.net/LICENSE

#if !defined(JSON_IS_AMALGAMATION)
#include <json/writer.h>
#include "json_tool.h"
#endif // if !defined(JSON_IS_AMALGAMATION)
#include <iomanip>
#include <memory>
#include <sstream>
#include <utility>
#include <set>
#include <cassert>
#include <cstring>
#include <cstdio>

#if defined(_MSC_VER) && _MSC_VER >= 1200 && _MSC_VER < 1800 // Between VC++ 6.0 and VC++ 11.0
#include <float.h>
#define isfinite _finite
#elif defined(__sun) && defined(__SVR4) //Solaris
#if !defined(isfinite)
#include <ieeefp.h>
#define isfinite finite
#endif
#elif defined(_AIX)
#if !defined(isfinite)
#include <math.h>
#define isfinite finite
#endif
#elif defined(__hpux)
#if !defined(isfinite)
#if defined(__ia64) && !defined(finite)
#define isfinite(x) ((sizeof(x) == sizeof(float) ? \
                     _Isfinitef(x) : _IsFinite(x)))
#else
#include <math.h>
#define isfinite finite
#endif
#endif
#else
#include <cmath>
#if !(defined(__QNXNTO__)) // QNX already defines isfinite
#define isfinite std::isfinite
#endif
#endif

#if defined(_MSC_VER)
#if !defined(WINCE) && defined(__STDC_SECURE_LIB__) && _MSC_VER >= 1500 // VC++ 9.0 and above
#define snprintf sprintf_s
#elif _MSC_VER >= 1900 // VC++ 14.0 and above
#define snprintf std::snprintf
#else
#define snprintf _snprintf
#endif
#elif defined(__ANDROID__) || defined(__QNXNTO__)
#define snprintf snprintf
#elif __cplusplus >= 201103L
#if !defined(__MINGW32__) && !defined(__CYGWIN__)
#define snprintf std::snprintf
#endif
#endif

#if defined(__BORLANDC__)
#include <float.h>
#define isfinite _finite
#define snprintf _snprintf
#endif

#if defined(_MSC_VER) && _MSC_VER >= 1400 // VC++ 8.0
// Disable warning about strdup being deprecated.
#pragma warning(disable : 4996)
#endif

namespace Json {
#if __cplusplus >= 201103L || (defined(_CPPLIB_VER) && _CPPLIB_VER >= 520)
	typedef std::unique_ptr<StreamWriter> StreamWriterPtr;
#else
	typedef std::auto_ptr<StreamWriter>   StreamWriterPtr;
#endif

	static bool containsControlCharacter(const char* str) {
		while (*str) {
			if (isControlCharacter(*(str++)))
				return true;
		}
		return false;
	}

	static bool containsControlCharacter0(const char* str, unsigned len) {
		char const* end = str + len;
		while (end != str) {
			if (isControlCharacter(*str) || 0 == *str)
				return true;
			++str;
		}
		return false;
	}

	JSONCPP_STRING valueToString(LargestInt value) {
		UIntToStringBuffer buffer;
		char* current = buffer + sizeof(buffer);
		if (value == Value::minLargestInt) {
			uintToString(LargestUInt(Value::maxLargestInt) + 1, current);
			*--current = '-';
		}
		else if (value < 0) {
			uintToString(LargestUInt(-value), current);
			*--current = '-';
		}
		else {
			uintToString(LargestUInt(value), current);
		}
		assert(current >= buffer);
		return current;
	}

	JSONCPP_STRING valueToString(LargestUInt value) {
		UIntToStringBuffer buffer;
		char* current = buffer + sizeof(buffer);
		uintToString(value, current);
		assert(current >= buffer);
		return current;
	}

#if defined(JSON_HAS_INT64)

	JSONCPP_STRING valueToString(Int value) {
		return valueToString(LargestInt(value));
	}

	JSONCPP_STRING valueToString(UInt value) {
		return valueToString(LargestUInt(value));
	}

#endif // # if defined(JSON_HAS_INT64)

	namespace {
		JSONCPP_STRING valueToString(double value, bool useSpecialFloats, unsigned int precision) {
			// Allocate a buffer that is more than large enough to store the 16 digits of
			// precision requested below.
			char buffer[32];
			int len = -1;

			char formatString[6];
			sprintf(formatString, "%%.%dg", precision);

			// Print into the buffer. We need not request the alternative representation
			// that always has a decimal point because JSON doesn't distingish the
			// concepts of reals and integers.
			if (isfinite(value)) {
				len = snprintf(buffer, sizeof(buffer), formatString, value);
			}
			else {
				// IEEE standard states that NaN values will not compare to themselves
				if (value != value) {
					len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "NaN" : "null");
				}
				else if (value < 0) {
					len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "-Infinity" : "-1e+9999");
				}
				else {
					len = snprintf(buffer, sizeof(buffer), useSpecialFloats ? "Infinity" : "1e+9999");
				}
				// For those, we do not need to call fixNumLoc, but it is fast.
			}
			assert(len >= 0);
			fixNumericLocale(buffer, buffer + len);
			return buffer;
		}
	}

	JSONCPP_STRING valueToString(double value) { return valueToString(value, false, 17); }

	JSONCPP_STRING valueToString(bool value) { return value ? "true" : "false"; }

	JSONCPP_STRING valueToQuotedString(const char* value) {
		if (value == NULL)
			return "";
		// Not sure how to handle unicode...
		if (strpbrk(value, "\"\\\b\f\n\r\t") == NULL &&
			!containsControlCharacter(value))
			return JSONCPP_STRING("\"") + value + "\"";
		// We have to walk value and escape any special characters.
		// Appending to JSONCPP_STRING is not efficient, but this should be rare.
		// (Note: forward slashes are *not* rare, but I am not escaping them.)
		JSONCPP_STRING::size_type maxsize =
			strlen(value) * 2 + 3; // allescaped+quotes+NULL
		JSONCPP_STRING result;
		result.reserve(maxsize); // to avoid lots of mallocs
		result += "\"";
		for (const char* c = value; *c != 0; ++c) {
			switch (*c) {
			case '\"':
				result += "\\\"";
				break;
			case '\\':
				result += "\\\\";
				break;
			case '\b':
				result += "\\b";
				break;
			case '\f':
				result += "\\f";
				break;
			case '\n':
				result += "\\n";
				break;
			case '\r':
				result += "\\r";
				break;
			case '\t':
				result += "\\t";
				break;
				// case '/':
				// Even though \/ is considered a legal escape in JSON, a bare
				// slash is also legal, so I see no reason to escape it.
				// (I hope I am not misunderstanding something.
				// blep notes: actually escaping \/ may be useful in javascript to avoid </
				// sequence.
				// Should add a flag to allow this compatibility mode and prevent this
				// sequence from occurring.
			default:
				if (isControlCharacter(*c)) {
					JSONCPP_OSTRINGSTREAM oss;
					oss << "\\u" << std::hex << std::uppercase << std::setfill('0')
						<< std::setw(4) << static_cast<int>(*c);
					result += oss.str();
				}
				else {
					result += *c;
				}
				break;
			}
		}
		result += "\"";
		return result;
	}

	// https://github.com/upcaste/upcaste/blob/master/src/upcore/src/cstring/strnpbrk.cpp
	static char const* strnpbrk(char const* s, char const* accept, size_t n) {
		assert((s || !n) && accept);

		char const* const end = s + n;
		for (char const* cur = s; cur < end; ++cur) {
			int const c = *cur;
			for (char const* a = accept; *a; ++a) {
				if (*a == c) {
					return cur;
				}
			}
		}
		return NULL;
	}
	static JSONCPP_STRING valueToQuotedStringN(const char* value, unsigned length) {
		if (value == NULL)
			return "";
		// Not sure how to handle unicode...
		if (strnpbrk(value, "\"\\\b\f\n\r\t", length) == NULL &&
			!containsControlCharacter0(value, length))
			return JSONCPP_STRING("\"") + value + "\"";
		// We have to walk value and escape any special characters.
		// Appending to JSONCPP_STRING is not efficient, but this should be rare.
		// (Note: forward slashes are *not* rare, but I am not escaping them.)
		JSONCPP_STRING::size_type maxsize =
			length * 2 + 3; // allescaped+quotes+NULL
		JSONCPP_STRING result;
		result.reserve(maxsize); // to avoid lots of mallocs
		result += "\"";
		char const* end = value + length;
		for (const char* c = value; c != end; ++c) {
			switch (*c) {
			case '\"':
				result += "\\\"";
				break;
			case '\\':
				result += "\\\\";
				break;
			case '\b':
				result += "\\b";
				break;
			case '\f':
				result += "\\f";
				break;
			case '\n':
				result += "\\n";
				break;
			case '\r':
				result += "\\r";
				break;
			case '\t':
				result += "\\t";
				break;
				// case '/':
				// Even though \/ is considered a legal escape in JSON, a bare
				// slash is also legal, so I see no reason to escape it.
				// (I hope I am not misunderstanding something.)
				// blep notes: actually escaping \/ may be useful in javascript to avoid </
				// sequence.
				// Should add a flag to allow this compatibility mode and prevent this
				// sequence from occurring.
			default:
				if ((isControlCharacter(*c)) || (*c == 0)) {
					JSONCPP_OSTRINGSTREAM oss;
					oss << "\\u" << std::hex << std::uppercase << std::setfill('0')
						<< std::setw(4) << static_cast<int>(*c);
					result += oss.str();
				}
				else {
					result += *c;
				}
				break;
			}
		}
		result += "\"";
		return result;
	}

	// Class Writer
	// //////////////////////////////////////////////////////////////////
	Writer::~Writer() {}

	// Class FastWriter
	// //////////////////////////////////////////////////////////////////

	FastWriter::FastWriter()
		: yamlCompatiblityEnabled_(false), dropNullPlaceholders_(false),
		omitEndingLineFeed_(false) {}

	void FastWriter::enableYAMLCompatibility() { yamlCompatiblityEnabled_ = true; }

	void FastWriter::dropNullPlaceholders() { dropNullPlaceholders_ = true; }

	void FastWriter::omitEndingLineFeed() { omitEndingLineFeed_ = true; }

	JSONCPP_STRING FastWriter::write(const Value& root) {
		document_ = "";
		writeValue(root);
		if (!omitEndingLineFeed_)
			document_ += "\n";
		return document_;
	}

	void FastWriter::writeValue(const Value& value) {
		switch (value.type()) {
		case nullValue:
			if (!dropNullPlaceholders_)
				document_ += "null";
			break;
		case intValue:
			document_ += valueToString(value.asLargestInt());
			break;
		case uintValue:
			document_ += valueToString(value.asLargestUInt());
			break;
		case realValue:
			document_ += valueToString(value.asDouble());
			break;
		case stringValue:
		{
			// Is NULL possible for value.string_? No.
			char const* str;
			char const* end;
			bool ok = value.getString(&str, &end);
			if (ok) document_ += valueToQuotedStringN(str, static_cast<unsigned>(end - str));
			break;
		}
		case booleanValue:
			document_ += valueToString(value.asBool());
			break;
		case arrayValue: {
			document_ += '[';
			ArrayIndex size = value.size();
			for (ArrayIndex index = 0; index < size; ++index) {
				if (index > 0)
					document_ += ',';
				writeValue(value[index]);
			}
			document_ += ']';
		} break;
		case objectValue: {
			Value::Members members(value.getMemberNames());
			document_ += '{';
			for (Value::Members::iterator it = members.begin(); it != members.end();
				++it) {
				const JSONCPP_STRING& name = *it;
				if (it != members.begin())
					document_ += ',';
				document_ += valueToQuotedStringN(name.data(), static_cast<unsigned>(name.length()));
				document_ += yamlCompatiblityEnabled_ ? ": " : ":";
				writeValue(value[name]);
			}
			document_ += '}';
		} break;
		}
	}

	// Class StyledWriter
	// //////////////////////////////////////////////////////////////////

	StyledWriter::StyledWriter()
		: rightMargin_(74), indentSize_(3), addChildValues_() {}

	JSONCPP_STRING StyledWriter::write(const Value& root) {
		document_ = "";
		addChildValues_ = false;
		indentString_ = "";
		writeCommentBeforeValue(root);
		writeValue(root);
		writeCommentAfterValueOnSameLine(root);
		document_ += "\n";
		return document_;
	}

	void StyledWriter::writeValue(const Value& value) {
		switch (value.type()) {
		case nullValue:
			pushValue("null");
			break;
		case intValue:
			pushValue(valueToString(value.asLargestInt()));
			break;
		case uintValue:
			pushValue(valueToString(value.asLargestUInt()));
			break;
		case realValue:
			pushValue(valueToString(value.asDouble()));
			break;
		case stringValue:
		{
			// Is NULL possible for value.string_? No.
			char const* str;
			char const* end;
			bool ok = value.getString(&str, &end);
			if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str)));
			else pushValue("");
			break;
		}
		case booleanValue:
			pushValue(valueToString(value.asBool()));
			break;
		case arrayValue:
			writeArrayValue(value);
			break;
		case objectValue: {
			Value::Members members(value.getMemberNames());
			if (members.empty())
				pushValue("{}");
			else {
				writeWithIndent("{");
				indent();
				Value::Members::iterator it = members.begin();
				for (;;) {
					const JSONCPP_STRING& name = *it;
					const Value& childValue = value[name];
					writeCommentBeforeValue(childValue);
					writeWithIndent(valueToQuotedString(name.c_str()));
					document_ += " : ";
					writeValue(childValue);
					if (++it == members.end()) {
						writeCommentAfterValueOnSameLine(childValue);
						break;
					}
					document_ += ',';
					writeCommentAfterValueOnSameLine(childValue);
				}
				unindent();
				writeWithIndent("}");
			}
		} break;
		}
	}

	void StyledWriter::writeArrayValue(const Value& value) {
		unsigned size = value.size();
		if (size == 0)
			pushValue("[]");
		else {
			bool isArrayMultiLine = isMultineArray(value);
			if (isArrayMultiLine) {
				writeWithIndent("[");
				indent();
				bool hasChildValue = !childValues_.empty();
				unsigned index = 0;
				for (;;) {
					const Value& childValue = value[index];
					writeCommentBeforeValue(childValue);
					if (hasChildValue)
						writeWithIndent(childValues_[index]);
					else {
						writeIndent();
						writeValue(childValue);
					}
					if (++index == size) {
						writeCommentAfterValueOnSameLine(childValue);
						break;
					}
					document_ += ',';
					writeCommentAfterValueOnSameLine(childValue);
				}
				unindent();
				writeWithIndent("]");
			}
			else // output on a single line
			{
				assert(childValues_.size() == size);
				document_ += "[ ";
				for (unsigned index = 0; index < size; ++index) {
					if (index > 0)
						document_ += ", ";
					document_ += childValues_[index];
				}
				document_ += " ]";
			}
		}
	}

	bool StyledWriter::isMultineArray(const Value& value) {
		ArrayIndex const size = value.size();
		bool isMultiLine = size * 3 >= rightMargin_;
		childValues_.clear();
		for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
			const Value& childValue = value[index];
			isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
				childValue.size() > 0);
		}
		if (!isMultiLine) // check if line length > max line length
		{
			childValues_.reserve(size);
			addChildValues_ = true;
			ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
			for (ArrayIndex index = 0; index < size; ++index) {
				if (hasCommentForValue(value[index])) {
					isMultiLine = true;
				}
				writeValue(value[index]);
				lineLength += static_cast<ArrayIndex>(childValues_[index].length());
			}
			addChildValues_ = false;
			isMultiLine = isMultiLine || lineLength >= rightMargin_;
		}
		return isMultiLine;
	}

	void StyledWriter::pushValue(const JSONCPP_STRING& value) {
		if (addChildValues_)
			childValues_.push_back(value);
		else
			document_ += value;
	}

	void StyledWriter::writeIndent() {
		if (!document_.empty()) {
			char last = document_[document_.length() - 1];
			if (last == ' ') // already indented
				return;
			if (last != '\n') // Comments may add new-line
				document_ += '\n';
		}
		document_ += indentString_;
	}

	void StyledWriter::writeWithIndent(const JSONCPP_STRING& value) {
		writeIndent();
		document_ += value;
	}

	void StyledWriter::indent() { indentString_ += JSONCPP_STRING(indentSize_, ' '); }

	void StyledWriter::unindent() {
		assert(indentString_.size() >= indentSize_);
		indentString_.resize(indentString_.size() - indentSize_);
	}

	void StyledWriter::writeCommentBeforeValue(const Value& root) {
		if (!root.hasComment(commentBefore))
			return;

		document_ += "\n";
		writeIndent();
		const JSONCPP_STRING& comment = root.getComment(commentBefore);
		JSONCPP_STRING::const_iterator iter = comment.begin();
		while (iter != comment.end()) {
			document_ += *iter;
			if (*iter == '\n' &&
				(iter != comment.end() && *(iter + 1) == '/'))
				writeIndent();
			++iter;
		}

		// Comments are stripped of trailing newlines, so add one here
		document_ += "\n";
	}

	void StyledWriter::writeCommentAfterValueOnSameLine(const Value& root) {
		if (root.hasComment(commentAfterOnSameLine))
			document_ += " " + root.getComment(commentAfterOnSameLine);

		if (root.hasComment(commentAfter)) {
			document_ += "\n";
			document_ += root.getComment(commentAfter);
			document_ += "\n";
		}
	}

	bool StyledWriter::hasCommentForValue(const Value& value) {
		return value.hasComment(commentBefore) ||
			value.hasComment(commentAfterOnSameLine) ||
			value.hasComment(commentAfter);
	}

	// Class StyledStreamWriter
	// //////////////////////////////////////////////////////////////////

	StyledStreamWriter::StyledStreamWriter(JSONCPP_STRING indentation)
		: document_(NULL), rightMargin_(74), indentation_(indentation),
		addChildValues_() {}

	void StyledStreamWriter::write(JSONCPP_OSTREAM& out, const Value& root) {
		document_ = &out;
		addChildValues_ = false;
		indentString_ = "";
		indented_ = true;
		writeCommentBeforeValue(root);
		if (!indented_) writeIndent();
		indented_ = true;
		writeValue(root);
		writeCommentAfterValueOnSameLine(root);
		*document_ << "\n";
		document_ = NULL; // Forget the stream, for safety.
	}

	void StyledStreamWriter::writeValue(const Value& value) {
		switch (value.type()) {
		case nullValue:
			pushValue("null");
			break;
		case intValue:
			pushValue(valueToString(value.asLargestInt()));
			break;
		case uintValue:
			pushValue(valueToString(value.asLargestUInt()));
			break;
		case realValue:
			pushValue(valueToString(value.asDouble()));
			break;
		case stringValue:
		{
			// Is NULL possible for value.string_? No.
			char const* str;
			char const* end;
			bool ok = value.getString(&str, &end);
			if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str)));
			else pushValue("");
			break;
		}
		case booleanValue:
			pushValue(valueToString(value.asBool()));
			break;
		case arrayValue:
			writeArrayValue(value);
			break;
		case objectValue: {
			Value::Members members(value.getMemberNames());
			if (members.empty())
				pushValue("{}");
			else {
				writeWithIndent("{");
				indent();
				Value::Members::iterator it = members.begin();
				for (;;) {
					const JSONCPP_STRING& name = *it;
					const Value& childValue = value[name];
					writeCommentBeforeValue(childValue);
					writeWithIndent(valueToQuotedString(name.c_str()));
					*document_ << " : ";
					writeValue(childValue);
					if (++it == members.end()) {
						writeCommentAfterValueOnSameLine(childValue);
						break;
					}
					*document_ << ",";
					writeCommentAfterValueOnSameLine(childValue);
				}
				unindent();
				writeWithIndent("}");
			}
		} break;
		}
	}

	void StyledStreamWriter::writeArrayValue(const Value& value) {
		unsigned size = value.size();
		if (size == 0)
			pushValue("[]");
		else {
			bool isArrayMultiLine = isMultineArray(value);
			if (isArrayMultiLine) {
				writeWithIndent("[");
				indent();
				bool hasChildValue = !childValues_.empty();
				unsigned index = 0;
				for (;;) {
					const Value& childValue = value[index];
					writeCommentBeforeValue(childValue);
					if (hasChildValue)
						writeWithIndent(childValues_[index]);
					else {
						if (!indented_) writeIndent();
						indented_ = true;
						writeValue(childValue);
						indented_ = false;
					}
					if (++index == size) {
						writeCommentAfterValueOnSameLine(childValue);
						break;
					}
					*document_ << ",";
					writeCommentAfterValueOnSameLine(childValue);
				}
				unindent();
				writeWithIndent("]");
			}
			else // output on a single line
			{
				assert(childValues_.size() == size);
				*document_ << "[ ";
				for (unsigned index = 0; index < size; ++index) {
					if (index > 0)
						*document_ << ", ";
					*document_ << childValues_[index];
				}
				*document_ << " ]";
			}
		}
	}

	bool StyledStreamWriter::isMultineArray(const Value& value) {
		ArrayIndex const size = value.size();
		bool isMultiLine = size * 3 >= rightMargin_;
		childValues_.clear();
		for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
			const Value& childValue = value[index];
			isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
				childValue.size() > 0);
		}
		if (!isMultiLine) // check if line length > max line length
		{
			childValues_.reserve(size);
			addChildValues_ = true;
			ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
			for (ArrayIndex index = 0; index < size; ++index) {
				if (hasCommentForValue(value[index])) {
					isMultiLine = true;
				}
				writeValue(value[index]);
				lineLength += static_cast<ArrayIndex>(childValues_[index].length());
			}
			addChildValues_ = false;
			isMultiLine = isMultiLine || lineLength >= rightMargin_;
		}
		return isMultiLine;
	}

	void StyledStreamWriter::pushValue(const JSONCPP_STRING& value) {
		if (addChildValues_)
			childValues_.push_back(value);
		else
			*document_ << value;
	}

	void StyledStreamWriter::writeIndent() {
		// blep intended this to look at the so-far-written string
		// to determine whether we are already indented, but
		// with a stream we cannot do that. So we rely on some saved state.
		// The caller checks indented_.
		*document_ << '\n' << indentString_;
	}

	void StyledStreamWriter::writeWithIndent(const JSONCPP_STRING& value) {
		if (!indented_) writeIndent();
		*document_ << value;
		indented_ = false;
	}

	void StyledStreamWriter::indent() { indentString_ += indentation_; }

	void StyledStreamWriter::unindent() {
		assert(indentString_.size() >= indentation_.size());
		indentString_.resize(indentString_.size() - indentation_.size());
	}

	void StyledStreamWriter::writeCommentBeforeValue(const Value& root) {
		if (!root.hasComment(commentBefore))
			return;

		if (!indented_) writeIndent();
		const JSONCPP_STRING& comment = root.getComment(commentBefore);
		JSONCPP_STRING::const_iterator iter = comment.begin();
		while (iter != comment.end()) {
			*document_ << *iter;
			if (*iter == '\n' &&
				(iter != comment.end() && *(iter + 1) == '/'))
				// writeIndent();  // would include newline
				*document_ << indentString_;
			++iter;
		}
		indented_ = false;
	}

	void StyledStreamWriter::writeCommentAfterValueOnSameLine(const Value& root) {
		if (root.hasComment(commentAfterOnSameLine))
			*document_ << ' ' << root.getComment(commentAfterOnSameLine);

		if (root.hasComment(commentAfter)) {
			writeIndent();
			*document_ << root.getComment(commentAfter);
		}
		indented_ = false;
	}

	bool StyledStreamWriter::hasCommentForValue(const Value& value) {
		return value.hasComment(commentBefore) ||
			value.hasComment(commentAfterOnSameLine) ||
			value.hasComment(commentAfter);
	}

	//////////////////////////
	// BuiltStyledStreamWriter

	/// Scoped enums are not available until C++11.
	struct CommentStyle {
		/// Decide whether to write comments.
		enum Enum {
			None,  ///< Drop all comments.
			Most,  ///< Recover odd behavior of previous versions (not implemented yet).
			All  ///< Keep all comments.
		};
	};

	struct BuiltStyledStreamWriter : public StreamWriter
	{
		BuiltStyledStreamWriter(
			JSONCPP_STRING const& indentation,
			CommentStyle::Enum cs,
			JSONCPP_STRING const& colonSymbol,
			JSONCPP_STRING const& nullSymbol,
			JSONCPP_STRING const& endingLineFeedSymbol,
			bool useSpecialFloats,
			unsigned int precision);
		int write(Value const& root, JSONCPP_OSTREAM* sout) JSONCPP_OVERRIDE;
	private:
		void writeValue(Value const& value);
		void writeArrayValue(Value const& value);
		bool isMultineArray(Value const& value);
		void pushValue(JSONCPP_STRING const& value);
		void writeIndent();
		void writeWithIndent(JSONCPP_STRING const& value);
		void indent();
		void unindent();
		void writeCommentBeforeValue(Value const& root);
		void writeCommentAfterValueOnSameLine(Value const& root);
		static bool hasCommentForValue(const Value& value);

		typedef std::vector<JSONCPP_STRING> ChildValues;

		ChildValues childValues_;
		JSONCPP_STRING indentString_;
		unsigned int rightMargin_;
		JSONCPP_STRING indentation_;
		CommentStyle::Enum cs_;
		JSONCPP_STRING colonSymbol_;
		JSONCPP_STRING nullSymbol_;
		JSONCPP_STRING endingLineFeedSymbol_;
		bool addChildValues_ : 1;
		bool indented_ : 1;
		bool useSpecialFloats_ : 1;
		unsigned int precision_;
	};
	BuiltStyledStreamWriter::BuiltStyledStreamWriter(
		JSONCPP_STRING const& indentation,
		CommentStyle::Enum cs,
		JSONCPP_STRING const& colonSymbol,
		JSONCPP_STRING const& nullSymbol,
		JSONCPP_STRING const& endingLineFeedSymbol,
		bool useSpecialFloats,
		unsigned int precision)
		: rightMargin_(74)
		, indentation_(indentation)
		, cs_(cs)
		, colonSymbol_(colonSymbol)
		, nullSymbol_(nullSymbol)
		, endingLineFeedSymbol_(endingLineFeedSymbol)
		, addChildValues_(false)
		, indented_(false)
		, useSpecialFloats_(useSpecialFloats)
		, precision_(precision)
	{
	}
	int BuiltStyledStreamWriter::write(Value const& root, JSONCPP_OSTREAM* sout)
	{
		sout_ = sout;
		addChildValues_ = false;
		indented_ = true;
		indentString_ = "";
		writeCommentBeforeValue(root);
		if (!indented_) writeIndent();
		indented_ = true;
		writeValue(root);
		writeCommentAfterValueOnSameLine(root);
		*sout_ << endingLineFeedSymbol_;
		sout_ = NULL;
		return 0;
	}
	void BuiltStyledStreamWriter::writeValue(Value const& value) {
		switch (value.type()) {
		case nullValue:
			pushValue(nullSymbol_);
			break;
		case intValue:
			pushValue(valueToString(value.asLargestInt()));
			break;
		case uintValue:
			pushValue(valueToString(value.asLargestUInt()));
			break;
		case realValue:
			pushValue(valueToString(value.asDouble(), useSpecialFloats_, precision_));
			break;
		case stringValue:
		{
			// Is NULL is possible for value.string_? No.
			char const* str;
			char const* end;
			bool ok = value.getString(&str, &end);
			if (ok) pushValue(valueToQuotedStringN(str, static_cast<unsigned>(end - str)));
			else pushValue("");
			break;
		}
		case booleanValue:
			pushValue(valueToString(value.asBool()));
			break;
		case arrayValue:
			writeArrayValue(value);
			break;
		case objectValue: {
			Value::Members members(value.getMemberNames());
			if (members.empty())
				pushValue("{}");
			else {
				writeWithIndent("{");
				indent();
				Value::Members::iterator it = members.begin();
				for (;;) {
					JSONCPP_STRING const& name = *it;
					Value const& childValue = value[name];
					writeCommentBeforeValue(childValue);
					writeWithIndent(valueToQuotedStringN(name.data(), static_cast<unsigned>(name.length())));
					*sout_ << colonSymbol_;
					writeValue(childValue);
					if (++it == members.end()) {
						writeCommentAfterValueOnSameLine(childValue);
						break;
					}
					*sout_ << ",";
					writeCommentAfterValueOnSameLine(childValue);
				}
				unindent();
				writeWithIndent("}");
			}
		} break;
		}
	}

	void BuiltStyledStreamWriter::writeArrayValue(Value const& value) {
		unsigned size = value.size();
		if (size == 0)
			pushValue("[]");
		else {
			bool isMultiLine = (cs_ == CommentStyle::All) || isMultineArray(value);
			if (isMultiLine) {
				writeWithIndent("[");
				indent();
				bool hasChildValue = !childValues_.empty();
				unsigned index = 0;
				for (;;) {
					Value const& childValue = value[index];
					writeCommentBeforeValue(childValue);
					if (hasChildValue)
						writeWithIndent(childValues_[index]);
					else {
						if (!indented_) writeIndent();
						indented_ = true;
						writeValue(childValue);
						indented_ = false;
					}
					if (++index == size) {
						writeCommentAfterValueOnSameLine(childValue);
						break;
					}
					*sout_ << ",";
					writeCommentAfterValueOnSameLine(childValue);
				}
				unindent();
				writeWithIndent("]");
			}
			else // output on a single line
			{
				assert(childValues_.size() == size);
				*sout_ << "[";
				if (!indentation_.empty())*sout_ << " ";
				for (unsigned index = 0; index < size; ++index) {
					if (index > 0)
						*sout_ << ((!indentation_.empty()) ? ", " : ",");
					*sout_ << childValues_[index];
				}
				if (!indentation_.empty())*sout_ << " ";
				*sout_ << "]";
			}
		}
	}

	bool BuiltStyledStreamWriter::isMultineArray(Value const& value) {
		ArrayIndex const size = value.size();
		bool isMultiLine = size * 3 >= rightMargin_;
		childValues_.clear();
		for (ArrayIndex index = 0; index < size && !isMultiLine; ++index) {
			Value const& childValue = value[index];
			isMultiLine = ((childValue.isArray() || childValue.isObject()) &&
				childValue.size() > 0);
		}
		if (!isMultiLine) // check if line length > max line length
		{
			childValues_.reserve(size);
			addChildValues_ = true;
			ArrayIndex lineLength = 4 + (size - 1) * 2; // '[ ' + ', '*n + ' ]'
			for (ArrayIndex index = 0; index < size; ++index) {
				if (hasCommentForValue(value[index])) {
					isMultiLine = true;
				}
				writeValue(value[index]);
				lineLength += static_cast<ArrayIndex>(childValues_[index].length());
			}
			addChildValues_ = false;
			isMultiLine = isMultiLine || lineLength >= rightMargin_;
		}
		return isMultiLine;
	}

	void BuiltStyledStreamWriter::pushValue(JSONCPP_STRING const& value) {
		if (addChildValues_)
			childValues_.push_back(value);
		else
			*sout_ << value;
	}

	void BuiltStyledStreamWriter::writeIndent() {
		// blep intended this to look at the so-far-written string
		// to determine whether we are already indented, but
		// with a stream we cannot do that. So we rely on some saved state.
		// The caller checks indented_.

		if (!indentation_.empty()) {
			// In this case, drop newlines too.
			*sout_ << '\n' << indentString_;
		}
	}

	void BuiltStyledStreamWriter::writeWithIndent(JSONCPP_STRING const& value) {
		if (!indented_) writeIndent();
		*sout_ << value;
		indented_ = false;
	}

	void BuiltStyledStreamWriter::indent() { indentString_ += indentation_; }

	void BuiltStyledStreamWriter::unindent() {
		assert(indentString_.size() >= indentation_.size());
		indentString_.resize(indentString_.size() - indentation_.size());
	}

	void BuiltStyledStreamWriter::writeCommentBeforeValue(Value const& root) {
		if (cs_ == CommentStyle::None) return;
		if (!root.hasComment(commentBefore))
			return;

		if (!indented_) writeIndent();
		const JSONCPP_STRING& comment = root.getComment(commentBefore);
		JSONCPP_STRING::const_iterator iter = comment.begin();
		while (iter != comment.end()) {
			*sout_ << *iter;
			if (*iter == '\n' &&
				(iter != comment.end() && *(iter + 1) == '/'))
				// writeIndent();  // would write extra newline
				*sout_ << indentString_;
			++iter;
		}
		indented_ = false;
	}

	void BuiltStyledStreamWriter::writeCommentAfterValueOnSameLine(Value const& root) {
		if (cs_ == CommentStyle::None) return;
		if (root.hasComment(commentAfterOnSameLine))
			*sout_ << " " + root.getComment(commentAfterOnSameLine);

		if (root.hasComment(commentAfter)) {
			writeIndent();
			*sout_ << root.getComment(commentAfter);
		}
	}

	// static
	bool BuiltStyledStreamWriter::hasCommentForValue(const Value& value) {
		return value.hasComment(commentBefore) ||
			value.hasComment(commentAfterOnSameLine) ||
			value.hasComment(commentAfter);
	}

	///////////////
	// StreamWriter

	StreamWriter::StreamWriter()
		: sout_(NULL)
	{
	}
	StreamWriter::~StreamWriter()
	{
	}
	StreamWriter::Factory::~Factory()
	{}
	StreamWriterBuilder::StreamWriterBuilder()
	{
		setDefaults(&settings_);
	}
	StreamWriterBuilder::~StreamWriterBuilder()
	{}
	StreamWriter* StreamWriterBuilder::newStreamWriter() const
	{
		JSONCPP_STRING indentation = settings_["indentation"].asString();
		JSONCPP_STRING cs_str = settings_["commentStyle"].asString();
		bool eyc = settings_["enableYAMLCompatibility"].asBool();
		bool dnp = settings_["dropNullPlaceholders"].asBool();
		bool usf = settings_["useSpecialFloats"].asBool();
		unsigned int pre = settings_["precision"].asUInt();
		CommentStyle::Enum cs = CommentStyle::All;
		if (cs_str == "All") {
			cs = CommentStyle::All;
		}
		else if (cs_str == "None") {
			cs = CommentStyle::None;
		}
		else {
			throwRuntimeError("commentStyle must be 'All' or 'None'");
		}
		JSONCPP_STRING colonSymbol = " : ";
		if (eyc) {
			colonSymbol = ": ";
		}
		else if (indentation.empty()) {
			colonSymbol = ":";
		}
		JSONCPP_STRING nullSymbol = "null";
		if (dnp) {
			nullSymbol = "";
		}
		if (pre > 17) pre = 17;
		JSONCPP_STRING endingLineFeedSymbol = "";
		return new BuiltStyledStreamWriter(
			indentation, cs,
			colonSymbol, nullSymbol, endingLineFeedSymbol, usf, pre);
	}
	static void getValidWriterKeys(std::set<JSONCPP_STRING>* valid_keys)
	{
		valid_keys->clear();
		valid_keys->insert("indentation");
		valid_keys->insert("commentStyle");
		valid_keys->insert("enableYAMLCompatibility");
		valid_keys->insert("dropNullPlaceholders");
		valid_keys->insert("useSpecialFloats");
		valid_keys->insert("precision");
	}
	bool StreamWriterBuilder::validate(Json::Value* invalid) const
	{
		Json::Value my_invalid;
		if (!invalid) invalid = &my_invalid;  // so we do not need to test for NULL
		Json::Value& inv = *invalid;
		std::set<JSONCPP_STRING> valid_keys;
		getValidWriterKeys(&valid_keys);
		Value::Members keys = settings_.getMemberNames();
		size_t n = keys.size();
		for (size_t i = 0; i < n; ++i) {
			JSONCPP_STRING const& key = keys[i];
			if (valid_keys.find(key) == valid_keys.end()) {
				inv[key] = settings_[key];
			}
		}
		return 0u == inv.size();
	}
	Value& StreamWriterBuilder::operator[](JSONCPP_STRING key)
	{
		return settings_[key];
	}
	// static
	void StreamWriterBuilder::setDefaults(Json::Value* settings)
	{
		//! [StreamWriterBuilderDefaults]
		(*settings)["commentStyle"] = "All";
		(*settings)["indentation"] = "\t";
		(*settings)["enableYAMLCompatibility"] = false;
		(*settings)["dropNullPlaceholders"] = false;
		(*settings)["useSpecialFloats"] = false;
		(*settings)["precision"] = 17;
		//! [StreamWriterBuilderDefaults]
	}

	JSONCPP_STRING writeString(StreamWriter::Factory const& builder, Value const& root) {
		JSONCPP_OSTRINGSTREAM sout;
		StreamWriterPtr const writer(builder.newStreamWriter());
		writer->write(root, &sout);
		return sout.str();
	}

	JSONCPP_OSTREAM& operator<<(JSONCPP_OSTREAM& sout, Value const& root) {
		StreamWriterBuilder builder;
		StreamWriterPtr const writer(builder.newStreamWriter());
		writer->write(root, &sout);
		return sout;
	}
} // namespace Json

// //////////////////////////////////////////////////////////////////////
// End of content of file: src/lib_json/json_writer.cpp
// //////////////////////////////////////////////////////////////////////
```

`src/main.cpp`:

```cpp
#define NOMINMAX
#include <Windows.h>
#include <chrono>
#include <thread>
#include <functional>
#include <fstream>

#include "settings/config.h"
#include "settings/globals.h"
#include "settings/options.hpp"

#include "helpers/input.h"
#include "helpers/utils.h"
#include "helpers/console.h"
#include "helpers/notifies.h"

#include "hooks/hooks.h"
#include "render/render.h"
#include "valve_sdk/sdk.hpp"
#include "features/features.h"
#include "helpers/imdraw.h"
#include "valve_sdk/netvars.hpp"

#include "valve_sdk/interfaces/ICvar.h"

#include "valve_sdk/kit_parser.hpp"

void setup_hotkeys(void* base)
{
	input_system::register_hotkey(VK_INSERT, []()
	{
			render::menu::toggle();

			render::switch_hwnd();
	});
	
	bool is_active = true;
	input_system::register_hotkey(VK_DELETE, [&is_active]()
	{
		hooks::destroy();
		if (render::menu::is_visible())
		{
			render::menu::toggle();
			render::switch_hwnd();
		}
		is_active = false;
	});

	while (is_active)
		Sleep(500);

	FreeLibraryAndExitThread(static_cast<HMODULE>(base), 1);
}

DWORD __stdcall on_attach(void* base)
{
	while (!utils::get_module("serverbrowser.dll"))
		Sleep(10);

#ifdef _DEBUG
	console::attach();
#endif

	patterns::initialize();
	g::initialize();
	input_system::initialize();
	render::initialize();

	if (MH_Initialize() != MH_OK)
	{
		MessageBoxA(NULL, xorstr_("Unable to initialize Minhook."), MB_OK, MB_ICONERROR);
		Sleep(2000);

		return 0;
	}

	if (!hooks::init())
	{
		MessageBoxA(NULL, xorstr_("One or more hooks failed to initialize."), MB_OK, MB_ICONERROR); 
		Sleep(2000);

		return 0;
	}

	skins::load();
	globals::load();
	game_data::initialize_kits();
	
	config::cache("configs");

	notifies::push("Hello!");

	setup_hotkeys(base);

	return TRUE;
}

void on_detach()
{
#ifdef _DEBUG
	console::detach();
#endif

	render::destroy();
	hooks::destroy();
	input_system::destroy();
}

BOOL __stdcall DllMain(HINSTANCE instance, DWORD fdwReason, void* lpvReserved)
{
	if (fdwReason == DLL_PROCESS_ATTACH)
	{
		if (instance)
			LI_FN(DisableThreadLibraryCalls)(instance);

		auto handle = LI_FN(CreateThread)(nullptr, 0, on_attach, instance, 0, nullptr);

		LI_FN(CloseHandle)(handle);
		
	}
	else if (fdwReason == DLL_PROCESS_DETACH)
		on_detach();

	return TRUE;
}

```

`src/minhook/buffer.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>
#include "buffer.h"

 // Size of each memory block. (= page size of VirtualAlloc)
#define MEMORY_BLOCK_SIZE 0x1000

// Max range for seeking a memory block. (= 1024MB)
#define MAX_MEMORY_RANGE 0x40000000

// Memory protection flags to check the executable address.
#define PAGE_EXECUTE_FLAGS \
    (PAGE_EXECUTE | PAGE_EXECUTE_READ | PAGE_EXECUTE_READWRITE | PAGE_EXECUTE_WRITECOPY)

// Memory slot.
typedef struct _MEMORY_SLOT
{
	union
	{
		struct _MEMORY_SLOT* pNext;
		UINT8 buffer[MEMORY_SLOT_SIZE];
	};
} MEMORY_SLOT, * PMEMORY_SLOT;

// Memory block info. Placed at the head of each block.
typedef struct _MEMORY_BLOCK
{
	struct _MEMORY_BLOCK* pNext;
	PMEMORY_SLOT pFree;         // First element of the free slot list.
	UINT usedCount;
} MEMORY_BLOCK, * PMEMORY_BLOCK;

//-------------------------------------------------------------------------
// Global Variables:
//-------------------------------------------------------------------------

// First element of the memory block list.
PMEMORY_BLOCK g_pMemoryBlocks;

//-------------------------------------------------------------------------
VOID InitializeBuffer(VOID)
{
	// Nothing to do for now.
}

//-------------------------------------------------------------------------
VOID UninitializeBuffer(VOID)
{
	PMEMORY_BLOCK pBlock = g_pMemoryBlocks;
	g_pMemoryBlocks = NULL;

	while (pBlock)
	{
		PMEMORY_BLOCK pNext = pBlock->pNext;
		VirtualFree(pBlock, 0, MEM_RELEASE);
		pBlock = pNext;
	}
}

//-------------------------------------------------------------------------
#if defined(_M_X64) || defined(__x86_64__)
static LPVOID FindPrevFreeRegion(LPVOID pAddress, LPVOID pMinAddr, DWORD dwAllocationGranularity)
{
	ULONG_PTR tryAddr = (ULONG_PTR)pAddress;

	// Round down to the allocation granularity.
	tryAddr -= tryAddr % dwAllocationGranularity;

	// Start from the previous allocation granularity multiply.
	tryAddr -= dwAllocationGranularity;

	while (tryAddr >= (ULONG_PTR)pMinAddr)
	{
		MEMORY_BASIC_INFORMATION mbi;
		if (VirtualQuery((LPVOID)tryAddr, &mbi, sizeof(mbi)) == 0)
			break;

		if (mbi.State == MEM_FREE)
			return (LPVOID)tryAddr;

		if ((ULONG_PTR)mbi.AllocationBase < dwAllocationGranularity)
			break;

		tryAddr = (ULONG_PTR)mbi.AllocationBase - dwAllocationGranularity;
	}

	return NULL;
}
#endif

//-------------------------------------------------------------------------
#if defined(_M_X64) || defined(__x86_64__)
static LPVOID FindNextFreeRegion(LPVOID pAddress, LPVOID pMaxAddr, DWORD dwAllocationGranularity)
{
	ULONG_PTR tryAddr = (ULONG_PTR)pAddress;

	// Round down to the allocation granularity.
	tryAddr -= tryAddr % dwAllocationGranularity;

	// Start from the next allocation granularity multiply.
	tryAddr += dwAllocationGranularity;

	while (tryAddr <= (ULONG_PTR)pMaxAddr)
	{
		MEMORY_BASIC_INFORMATION mbi;
		if (VirtualQuery((LPVOID)tryAddr, &mbi, sizeof(mbi)) == 0)
			break;

		if (mbi.State == MEM_FREE)
			return (LPVOID)tryAddr;

		tryAddr = (ULONG_PTR)mbi.BaseAddress + mbi.RegionSize;

		// Round up to the next allocation granularity.
		tryAddr += dwAllocationGranularity - 1;
		tryAddr -= tryAddr % dwAllocationGranularity;
	}

	return NULL;
}
#endif

//-------------------------------------------------------------------------
static PMEMORY_BLOCK GetMemoryBlock(LPVOID pOrigin)
{
	PMEMORY_BLOCK pBlock;
#if defined(_M_X64) || defined(__x86_64__)
	ULONG_PTR minAddr;
	ULONG_PTR maxAddr;

	SYSTEM_INFO si;
	GetSystemInfo(&si);
	minAddr = (ULONG_PTR)si.lpMinimumApplicationAddress;
	maxAddr = (ULONG_PTR)si.lpMaximumApplicationAddress;

	// pOrigin ą 512MB
	if ((ULONG_PTR)pOrigin > MAX_MEMORY_RANGE && minAddr < (ULONG_PTR)pOrigin - MAX_MEMORY_RANGE)
		minAddr = (ULONG_PTR)pOrigin - MAX_MEMORY_RANGE;

	if (maxAddr > (ULONG_PTR)pOrigin + MAX_MEMORY_RANGE)
		maxAddr = (ULONG_PTR)pOrigin + MAX_MEMORY_RANGE;

	// Make room for MEMORY_BLOCK_SIZE bytes.
	maxAddr -= MEMORY_BLOCK_SIZE - 1;
#endif

	// Look the registered blocks for a reachable one.
	for (pBlock = g_pMemoryBlocks; pBlock != NULL; pBlock = pBlock->pNext)
	{
#if defined(_M_X64) || defined(__x86_64__)
		// Ignore the blocks too far.
		if ((ULONG_PTR)pBlock < minAddr || (ULONG_PTR)pBlock >= maxAddr)
			continue;
#endif
		// The block has at least one unused slot.
		if (pBlock->pFree != NULL)
			return pBlock;
	}

#if defined(_M_X64) || defined(__x86_64__)
	// Alloc a new block above if not found.
	{
		LPVOID pAlloc = pOrigin;
		while ((ULONG_PTR)pAlloc >= minAddr)
		{
			pAlloc = FindPrevFreeRegion(pAlloc, (LPVOID)minAddr, si.dwAllocationGranularity);
			if (pAlloc == NULL)
				break;

			pBlock = (PMEMORY_BLOCK)VirtualAlloc(
				pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
			if (pBlock != NULL)
				break;
		}
	}

	// Alloc a new block below if not found.
	if (pBlock == NULL)
	{
		LPVOID pAlloc = pOrigin;
		while ((ULONG_PTR)pAlloc <= maxAddr)
		{
			pAlloc = FindNextFreeRegion(pAlloc, (LPVOID)maxAddr, si.dwAllocationGranularity);
			if (pAlloc == NULL)
				break;

			pBlock = (PMEMORY_BLOCK)VirtualAlloc(
				pAlloc, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
			if (pBlock != NULL)
				break;
		}
	}
#else
	// In x86 mode, a memory block can be placed anywhere.
	pBlock = (PMEMORY_BLOCK)VirtualAlloc(
		NULL, MEMORY_BLOCK_SIZE, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
#endif

	if (pBlock != NULL)
	{
		// Build a linked list of all the slots.
		PMEMORY_SLOT pSlot = (PMEMORY_SLOT)pBlock + 1;
		pBlock->pFree = NULL;
		pBlock->usedCount = 0;
		do
		{
			pSlot->pNext = pBlock->pFree;
			pBlock->pFree = pSlot;
			pSlot++;
		} while ((ULONG_PTR)pSlot - (ULONG_PTR)pBlock <= MEMORY_BLOCK_SIZE - MEMORY_SLOT_SIZE);

		pBlock->pNext = g_pMemoryBlocks;
		g_pMemoryBlocks = pBlock;
	}

	return pBlock;
}

//-------------------------------------------------------------------------
LPVOID AllocateBuffer(LPVOID pOrigin)
{
	PMEMORY_SLOT  pSlot;
	PMEMORY_BLOCK pBlock = GetMemoryBlock(pOrigin);
	if (pBlock == NULL)
		return NULL;

	// Remove an unused slot from the list.
	pSlot = pBlock->pFree;
	pBlock->pFree = pSlot->pNext;
	pBlock->usedCount++;
#ifdef _DEBUG
	// Fill the slot with INT3 for debugging.
	memset(pSlot, 0xCC, sizeof(MEMORY_SLOT));
#endif
	return pSlot;
}

//-------------------------------------------------------------------------
VOID FreeBuffer(LPVOID pBuffer)
{
	PMEMORY_BLOCK pBlock = g_pMemoryBlocks;
	PMEMORY_BLOCK pPrev = NULL;
	ULONG_PTR pTargetBlock = ((ULONG_PTR)pBuffer / MEMORY_BLOCK_SIZE) * MEMORY_BLOCK_SIZE;

	while (pBlock != NULL)
	{
		if ((ULONG_PTR)pBlock == pTargetBlock)
		{
			PMEMORY_SLOT pSlot = (PMEMORY_SLOT)pBuffer;
#ifdef _DEBUG
			// Clear the released slot for debugging.
			memset(pSlot, 0x00, sizeof(*pSlot));
#endif
			// Restore the released slot to the list.
			pSlot->pNext = pBlock->pFree;
			pBlock->pFree = pSlot;
			pBlock->usedCount--;

			// Free if unused.
			if (pBlock->usedCount == 0)
			{
				if (pPrev)
					pPrev->pNext = pBlock->pNext;
				else
					g_pMemoryBlocks = pBlock->pNext;

				VirtualFree(pBlock, 0, MEM_RELEASE);
			}

			break;
		}

		pPrev = pBlock;
		pBlock = pBlock->pNext;
	}
}

//-------------------------------------------------------------------------
BOOL IsExecutableAddress(LPVOID pAddress)
{
	MEMORY_BASIC_INFORMATION mi;
	VirtualQuery(pAddress, &mi, sizeof(mi));

	return (mi.State == MEM_COMMIT && (mi.Protect & PAGE_EXECUTE_FLAGS));
}
```

`src/minhook/buffer.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

 // Size of each memory slot.
#if defined(_M_X64) || defined(__x86_64__)
#define MEMORY_SLOT_SIZE 64
#else
#define MEMORY_SLOT_SIZE 32
#endif

VOID   InitializeBuffer(VOID);
VOID   UninitializeBuffer(VOID);
LPVOID AllocateBuffer(LPVOID pOrigin);
VOID   FreeBuffer(LPVOID pBuffer);
BOOL   IsExecutableAddress(LPVOID pAddress);

```

`src/minhook/hde/hde32.c`:

```c
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#if defined(_M_IX86) || defined(__i386__)

#include "hde32.h"
#include "table32.h"

unsigned int hde32_disasm(const void* code, hde32s* hs)
{
	uint8_t x, c, * p = (uint8_t*)code, cflags, opcode, pref = 0;
	uint8_t* ht = hde32_table, m_mod, m_reg, m_rm, disp_size = 0;

	// Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
	memset((LPBYTE)hs, 0, sizeof(hde32s));
#else
	__stosb((LPBYTE)hs, 0, sizeof(hde32s));
#endif

	for (x = 16; x; x--)
		switch (c = *p++) {
		case 0xf3:
			hs->p_rep = c;
			pref |= PRE_F3;
			break;
		case 0xf2:
			hs->p_rep = c;
			pref |= PRE_F2;
			break;
		case 0xf0:
			hs->p_lock = c;
			pref |= PRE_LOCK;
			break;
		case 0x26: case 0x2e: case 0x36:
		case 0x3e: case 0x64: case 0x65:
			hs->p_seg = c;
			pref |= PRE_SEG;
			break;
		case 0x66:
			hs->p_66 = c;
			pref |= PRE_66;
			break;
		case 0x67:
			hs->p_67 = c;
			pref |= PRE_67;
			break;
		default:
			goto pref_done;
		}
pref_done:

	hs->flags = (uint32_t)pref << 23;

	if (!pref)
		pref |= PRE_NONE;

	if ((hs->opcode = c) == 0x0f) {
		hs->opcode2 = c = *p++;
		ht += DELTA_OPCODES;
	}
	else if (c >= 0xa0 && c <= 0xa3) {
		if (pref & PRE_67)
			pref |= PRE_66;
		else
			pref &= ~PRE_66;
	}

	opcode = c;
	cflags = ht[ht[opcode / 4] + (opcode % 4)];

	if (cflags == C_ERROR) {
		hs->flags |= F_ERROR | F_ERROR_OPCODE;
		cflags = 0;
		if ((opcode & -3) == 0x24)
			cflags++;
	}

	x = 0;
	if (cflags & C_GROUP) {
		uint16_t t;
		t = *(uint16_t*)(ht + (cflags & 0x7f));
		cflags = (uint8_t)t;
		x = (uint8_t)(t >> 8);
	}

	if (hs->opcode2) {
		ht = hde32_table + DELTA_PREFIXES;
		if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
			hs->flags |= F_ERROR | F_ERROR_OPCODE;
	}

	if (cflags & C_MODRM) {
		hs->flags |= F_MODRM;
		hs->modrm = c = *p++;
		hs->modrm_mod = m_mod = c >> 6;
		hs->modrm_rm = m_rm = c & 7;
		hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

		if (x && ((x << m_reg) & 0x80))
			hs->flags |= F_ERROR | F_ERROR_OPCODE;

		if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
			uint8_t t = opcode - 0xd9;
			if (m_mod == 3) {
				ht = hde32_table + DELTA_FPU_MODRM + t * 8;
				t = ht[m_reg] << m_rm;
			}
			else {
				ht = hde32_table + DELTA_FPU_REG;
				t = ht[t] << m_reg;
			}
			if (t & 0x80)
				hs->flags |= F_ERROR | F_ERROR_OPCODE;
		}

		if (pref & PRE_LOCK) {
			if (m_mod == 3) {
				hs->flags |= F_ERROR | F_ERROR_LOCK;
			}
			else {
				uint8_t* table_end, op = opcode;
				if (hs->opcode2) {
					ht = hde32_table + DELTA_OP2_LOCK_OK;
					table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
				}
				else {
					ht = hde32_table + DELTA_OP_LOCK_OK;
					table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
					op &= -2;
				}
				for (; ht != table_end; ht++)
					if (*ht++ == op) {
						if (!((*ht << m_reg) & 0x80))
							goto no_lock_error;
						else
							break;
					}
				hs->flags |= F_ERROR | F_ERROR_LOCK;
			no_lock_error:
				;
			}
		}

		if (hs->opcode2) {
			switch (opcode) {
			case 0x20: case 0x22:
				m_mod = 3;
				if (m_reg > 4 || m_reg == 1)
					goto error_operand;
				else
					goto no_error_operand;
			case 0x21: case 0x23:
				m_mod = 3;
				if (m_reg == 4 || m_reg == 5)
					goto error_operand;
				else
					goto no_error_operand;
			}
		}
		else {
			switch (opcode) {
			case 0x8c:
				if (m_reg > 5)
					goto error_operand;
				else
					goto no_error_operand;
			case 0x8e:
				if (m_reg == 1 || m_reg > 5)
					goto error_operand;
				else
					goto no_error_operand;
			}
		}

		if (m_mod == 3) {
			uint8_t* table_end;
			if (hs->opcode2) {
				ht = hde32_table + DELTA_OP2_ONLY_MEM;
				table_end = ht + sizeof(hde32_table) - DELTA_OP2_ONLY_MEM;
			}
			else {
				ht = hde32_table + DELTA_OP_ONLY_MEM;
				table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
			}
			for (; ht != table_end; ht += 2)
				if (*ht++ == opcode) {
					if (*ht++ & pref && !((*ht << m_reg) & 0x80))
						goto error_operand;
					else
						break;
				}
			goto no_error_operand;
		}
		else if (hs->opcode2) {
			switch (opcode) {
			case 0x50: case 0xd7: case 0xf7:
				if (pref & (PRE_NONE | PRE_66))
					goto error_operand;
				break;
			case 0xd6:
				if (pref & (PRE_F2 | PRE_F3))
					goto error_operand;
				break;
			case 0xc5:
				goto error_operand;
			}
			goto no_error_operand;
		}
		else
			goto no_error_operand;

	error_operand:
		hs->flags |= F_ERROR | F_ERROR_OPERAND;
	no_error_operand:

		c = *p++;
		if (m_reg <= 1) {
			if (opcode == 0xf6)
				cflags |= C_IMM8;
			else if (opcode == 0xf7)
				cflags |= C_IMM_P66;
		}

		switch (m_mod) {
		case 0:
			if (pref & PRE_67) {
				if (m_rm == 6)
					disp_size = 2;
			}
			else
				if (m_rm == 5)
					disp_size = 4;
			break;
		case 1:
			disp_size = 1;
			break;
		case 2:
			disp_size = 2;
			if (!(pref & PRE_67))
				disp_size <<= 1;
		}

		if (m_mod != 3 && m_rm == 4 && !(pref & PRE_67)) {
			hs->flags |= F_SIB;
			p++;
			hs->sib = c;
			hs->sib_scale = c >> 6;
			hs->sib_index = (c & 0x3f) >> 3;
			if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
				disp_size = 4;
		}

		p--;
		switch (disp_size) {
		case 1:
			hs->flags |= F_DISP8;
			hs->disp.disp8 = *p;
			break;
		case 2:
			hs->flags |= F_DISP16;
			hs->disp.disp16 = *(uint16_t*)p;
			break;
		case 4:
			hs->flags |= F_DISP32;
			hs->disp.disp32 = *(uint32_t*)p;
		}
		p += disp_size;
	}
	else if (pref & PRE_LOCK)
		hs->flags |= F_ERROR | F_ERROR_LOCK;

	if (cflags & C_IMM_P66) {
		if (cflags & C_REL32) {
			if (pref & PRE_66) {
				hs->flags |= F_IMM16 | F_RELATIVE;
				hs->imm.imm16 = *(uint16_t*)p;
				p += 2;
				goto disasm_done;
			}
			goto rel32_ok;
		}
		if (pref & PRE_66) {
			hs->flags |= F_IMM16;
			hs->imm.imm16 = *(uint16_t*)p;
			p += 2;
		}
		else {
			hs->flags |= F_IMM32;
			hs->imm.imm32 = *(uint32_t*)p;
			p += 4;
		}
	}

	if (cflags & C_IMM16) {
		if (hs->flags & F_IMM32) {
			hs->flags |= F_IMM16;
			hs->disp.disp16 = *(uint16_t*)p;
		}
		else if (hs->flags & F_IMM16) {
			hs->flags |= F_2IMM16;
			hs->disp.disp16 = *(uint16_t*)p;
		}
		else {
			hs->flags |= F_IMM16;
			hs->imm.imm16 = *(uint16_t*)p;
		}
		p += 2;
	}
	if (cflags & C_IMM8) {
		hs->flags |= F_IMM8;
		hs->imm.imm8 = *p++;
	}

	if (cflags & C_REL32) {
	rel32_ok:
		hs->flags |= F_IMM32 | F_RELATIVE;
		hs->imm.imm32 = *(uint32_t*)p;
		p += 4;
	}
	else if (cflags & C_REL8) {
		hs->flags |= F_IMM8 | F_RELATIVE;
		hs->imm.imm8 = *p++;
	}

disasm_done:

	if ((hs->len = (uint8_t)(p - (uint8_t*)code)) > 15) {
		hs->flags |= F_ERROR | F_ERROR_LENGTH;
		hs->len = 15;
	}

	return (unsigned int)hs->len;
}

#endif // defined(_M_IX86) || defined(__i386__)
```

`src/minhook/hde/hde32.h`:

```h
/*
 * Hacker Disassembler Engine 32
 * Copyright (c) 2006-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde32.h: C/C++ header file
 *
 */

#ifndef _HDE32_H_
#define _HDE32_H_

 /* stdint.h - C99 standard header
  * http://en.wikipedia.org/wiki/stdint.h
  *
  * if your compiler doesn't contain "stdint.h" header (for
  * example, Microsoft Visual C++), you can download file:
  *   http://www.azillionmonkeys.com/qed/pstdint.h
  * and change next line to:
  *   #include "pstdint.h"
  */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_DISP8         0x00000020
#define F_DISP16        0x00000040
#define F_DISP32        0x00000080
#define F_RELATIVE      0x00000100
#define F_2IMM16        0x00000800
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_ANY    0x3f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
	uint8_t len;
	uint8_t p_rep;
	uint8_t p_lock;
	uint8_t p_seg;
	uint8_t p_66;
	uint8_t p_67;
	uint8_t opcode;
	uint8_t opcode2;
	uint8_t modrm;
	uint8_t modrm_mod;
	uint8_t modrm_reg;
	uint8_t modrm_rm;
	uint8_t sib;
	uint8_t sib_scale;
	uint8_t sib_index;
	uint8_t sib_base;
	union {
		uint8_t imm8;
		uint16_t imm16;
		uint32_t imm32;
	} imm;
	union {
		uint8_t disp8;
		uint16_t disp16;
		uint32_t disp32;
	} disp;
	uint32_t flags;
} hde32s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

	/* __cdecl */
	unsigned int hde32_disasm(const void* code, hde32s* hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE32_H_ */

```

`src/minhook/hde/pstdint.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#include <windows.h>

 // Integer types for HDE.
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

```

`src/minhook/hde/table32.h`:

```h
/*
 * Hacker Disassembler Engine 32 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xf1
#define DELTA_FPU_MODRM    0xf8
#define DELTA_PREFIXES     0x130
#define DELTA_OP_LOCK_OK   0x1a1
#define DELTA_OP2_LOCK_OK  0x1b9
#define DELTA_OP_ONLY_MEM  0x1cb
#define DELTA_OP2_ONLY_MEM 0x1da

unsigned char hde32_table[] = {
  0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,0xa8,0xa3,
  0xa8,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xac,0xaa,0xb2,0xaa,0x9f,0x9f,
  0x9f,0x9f,0xb5,0xa3,0xa3,0xa4,0xaa,0xaa,0xba,0xaa,0x96,0xaa,0xa8,0xaa,0xc3,
  0xc3,0x96,0x96,0xb7,0xae,0xd6,0xbd,0xa3,0xc5,0xa3,0xa3,0x9f,0xc3,0x9c,0xaa,
  0xaa,0xac,0xaa,0xbf,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0x90,
  0x82,0x7d,0x97,0x59,0x59,0x59,0x59,0x59,0x7f,0x59,0x59,0x60,0x7d,0x7f,0x7f,
  0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x9a,0x88,0x7d,
  0x59,0x50,0x50,0x50,0x50,0x59,0x59,0x59,0x59,0x61,0x94,0x61,0x9e,0x59,0x59,
  0x85,0x59,0x92,0xa3,0x60,0x60,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,0x59,
  0x59,0x59,0x9f,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xcc,0x01,0xbc,0x03,0xf0,
  0x10,0x10,0x10,0x10,0x50,0x50,0x50,0x50,0x14,0x20,0x20,0x20,0x20,0x01,0x01,
  0x01,0x01,0xc4,0x02,0x10,0x00,0x00,0x00,0x00,0x01,0x01,0xc0,0xc2,0x10,0x11,
  0x02,0x03,0x11,0x03,0x03,0x04,0x00,0x00,0x14,0x00,0x02,0x00,0x00,0xc6,0xc8,
  0x02,0x02,0x02,0x02,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0xca,
  0x01,0x01,0x01,0x00,0x06,0x00,0x04,0x00,0xc0,0xc2,0x01,0x01,0x03,0x01,0xff,
  0xff,0x01,0x00,0x03,0xc4,0xc4,0xc6,0x03,0x01,0x01,0x01,0xff,0x03,0x03,0x03,
  0xc8,0x40,0x00,0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,
  0x00,0x00,0x00,0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,
  0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xff,0xff,0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x7f,0x00,0x00,0xff,0x4a,0x4a,0x4a,0x4a,0x4b,0x52,0x4a,0x4a,0x4a,0x4a,0x4f,
  0x4c,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x55,0x45,0x40,0x4a,0x4a,0x4a,
  0x45,0x59,0x4d,0x46,0x4a,0x5d,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,0x4a,
  0x4a,0x4a,0x4a,0x4a,0x4a,0x61,0x63,0x67,0x4e,0x4a,0x4a,0x6b,0x6d,0x4a,0x4a,
  0x45,0x6d,0x4a,0x4a,0x44,0x45,0x4a,0x4a,0x00,0x00,0x00,0x02,0x0d,0x06,0x06,
  0x06,0x06,0x0e,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x00,0x06,0x06,0x02,0x06,
  0x00,0x0a,0x0a,0x07,0x07,0x06,0x02,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x00,0x00,0x00,0x0e,0x05,0x06,0x06,0x06,0x01,0x06,0x00,0x00,0x08,
  0x00,0x10,0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,
  0x86,0x00,0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,
  0xf8,0xbb,0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,
  0xc4,0xff,0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,
  0x13,0x09,0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,
  0xb2,0xff,0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,
  0xe7,0x08,0x00,0xf0,0x02,0x00
};

```

`src/minhook/hook.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>
#include <tlhelp32.h>
#include <limits.h>

#include "minhook.h"
#include "buffer.h"
#include "trampoline.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
#endif

 // Initial capacity of the HOOK_ENTRY buffer.
#define INITIAL_HOOK_CAPACITY   32

// Initial capacity of the thread IDs buffer.
#define INITIAL_THREAD_CAPACITY 128

// Special hook position values.
#define INVALID_HOOK_POS UINT_MAX
#define ALL_HOOKS_POS    UINT_MAX

// Freeze() action argument defines.
#define ACTION_DISABLE      0
#define ACTION_ENABLE       1
#define ACTION_APPLY_QUEUED 2

// Thread access rights for suspending/resuming threads.
#define THREAD_ACCESS \
    (THREAD_SUSPEND_RESUME | THREAD_GET_CONTEXT | THREAD_QUERY_INFORMATION | THREAD_SET_CONTEXT)

// Hook information.
typedef struct _HOOK_ENTRY
{
	LPVOID pTarget;             // Address of the target function.
	LPVOID pDetour;             // Address of the detour or relay function.
	LPVOID pTrampoline;         // Address of the trampoline function.
	UINT8  backup[8];           // Original prologue of the target function.

	UINT8  patchAbove : 1;     // Uses the hot patch area.
	UINT8  isEnabled : 1;     // Enabled.
	UINT8  queueEnable : 1;     // Queued for enabling/disabling when != isEnabled.

	UINT   nIP : 4;             // Count of the instruction boundaries.
	UINT8  oldIPs[8];           // Instruction boundaries of the target function.
	UINT8  newIPs[8];           // Instruction boundaries of the trampoline function.
} HOOK_ENTRY, * PHOOK_ENTRY;

// Suspended threads for Freeze()/Unfreeze().
typedef struct _FROZEN_THREADS
{
	LPDWORD pItems;         // Data heap
	UINT    capacity;       // Size of allocated data heap, items
	UINT    size;           // Actual number of data items
} FROZEN_THREADS, * PFROZEN_THREADS;

//-------------------------------------------------------------------------
// Global Variables:
//-------------------------------------------------------------------------

// Spin lock flag for EnterSpinLock()/LeaveSpinLock().
volatile LONG g_isLocked = FALSE;

// Private heap handle. If not NULL, this library is initialized.
HANDLE g_hHeap = NULL;

// Hook entries.
struct
{
	PHOOK_ENTRY pItems;     // Data heap
	UINT        capacity;   // Size of allocated data heap, items
	UINT        size;       // Actual number of data items
} g_hooks;

//-------------------------------------------------------------------------
// Returns INVALID_HOOK_POS if not found.
static UINT FindHookEntry(LPVOID pTarget)
{
	UINT i;
	for (i = 0; i < g_hooks.size; ++i)
	{
		if ((ULONG_PTR)pTarget == (ULONG_PTR)g_hooks.pItems[i].pTarget)
			return i;
	}

	return INVALID_HOOK_POS;
}

//-------------------------------------------------------------------------
static PHOOK_ENTRY AddHookEntry()
{
	if (g_hooks.pItems == NULL)
	{
		g_hooks.capacity = INITIAL_HOOK_CAPACITY;
		g_hooks.pItems = (PHOOK_ENTRY)HeapAlloc(
			g_hHeap, 0, g_hooks.capacity * sizeof(HOOK_ENTRY));
		if (g_hooks.pItems == NULL)
			return NULL;
	}
	else if (g_hooks.size >= g_hooks.capacity)
	{
		PHOOK_ENTRY p = (PHOOK_ENTRY)HeapReAlloc(
			g_hHeap, 0, g_hooks.pItems, (g_hooks.capacity * 2) * sizeof(HOOK_ENTRY));
		if (p == NULL)
			return NULL;

		g_hooks.capacity *= 2;
		g_hooks.pItems = p;
	}

	return &g_hooks.pItems[g_hooks.size++];
}

//-------------------------------------------------------------------------
static void DeleteHookEntry(UINT pos)
{
	if (pos < g_hooks.size - 1)
		g_hooks.pItems[pos] = g_hooks.pItems[g_hooks.size - 1];

	g_hooks.size--;

	if (g_hooks.capacity / 2 >= INITIAL_HOOK_CAPACITY && g_hooks.capacity / 2 >= g_hooks.size)
	{
		PHOOK_ENTRY p = (PHOOK_ENTRY)HeapReAlloc(
			g_hHeap, 0, g_hooks.pItems, (g_hooks.capacity / 2) * sizeof(HOOK_ENTRY));
		if (p == NULL)
			return;

		g_hooks.capacity /= 2;
		g_hooks.pItems = p;
	}
}

//-------------------------------------------------------------------------
static DWORD_PTR FindOldIP(PHOOK_ENTRY pHook, DWORD_PTR ip)
{
	UINT i;

	if (pHook->patchAbove && ip == ((DWORD_PTR)pHook->pTarget - sizeof(JMP_REL)))
		return (DWORD_PTR)pHook->pTarget;

	for (i = 0; i < pHook->nIP; ++i)
	{
		if (ip == ((DWORD_PTR)pHook->pTrampoline + pHook->newIPs[i]))
			return (DWORD_PTR)pHook->pTarget + pHook->oldIPs[i];
	}

#if defined(_M_X64) || defined(__x86_64__)
	// Check relay function.
	if (ip == (DWORD_PTR)pHook->pDetour)
		return (DWORD_PTR)pHook->pTarget;
#endif

	return 0;
}

//-------------------------------------------------------------------------
static DWORD_PTR FindNewIP(PHOOK_ENTRY pHook, DWORD_PTR ip)
{
	UINT i;
	for (i = 0; i < pHook->nIP; ++i)
	{
		if (ip == ((DWORD_PTR)pHook->pTarget + pHook->oldIPs[i]))
			return (DWORD_PTR)pHook->pTrampoline + pHook->newIPs[i];
	}

	return 0;
}

//-------------------------------------------------------------------------
static void ProcessThreadIPs(HANDLE hThread, UINT pos, UINT action)
{
	// If the thread suspended in the overwritten area,
	// move IP to the proper address.

	CONTEXT c;
#if defined(_M_X64) || defined(__x86_64__)
	DWORD64 * pIP = &c.Rip;
#else
	DWORD* pIP = &c.Eip;
#endif
	UINT count;

	c.ContextFlags = CONTEXT_CONTROL;
	if (!GetThreadContext(hThread, &c))
		return;

	if (pos == ALL_HOOKS_POS)
	{
		pos = 0;
		count = g_hooks.size;
	}
	else
	{
		count = pos + 1;
	}

	for (; pos < count; ++pos)
	{
		PHOOK_ENTRY pHook = &g_hooks.pItems[pos];
		BOOL        enable;
		DWORD_PTR   ip;

		switch (action)
		{
		case ACTION_DISABLE:
			enable = FALSE;
			break;

		case ACTION_ENABLE:
			enable = TRUE;
			break;

		default: // ACTION_APPLY_QUEUED
			enable = pHook->queueEnable;
			break;
		}
		if (pHook->isEnabled == enable)
			continue;

		if (enable)
			ip = FindNewIP(pHook, *pIP);
		else
			ip = FindOldIP(pHook, *pIP);

		if (ip != 0)
		{
			*pIP = ip;
			SetThreadContext(hThread, &c);
		}
	}
}

//-------------------------------------------------------------------------
static VOID EnumerateThreads(PFROZEN_THREADS pThreads)
{
	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
	if (hSnapshot != INVALID_HANDLE_VALUE)
	{
		THREADENTRY32 te;
		te.dwSize = sizeof(THREADENTRY32);
		if (Thread32First(hSnapshot, &te))
		{
			do
			{
				if (te.dwSize >= (FIELD_OFFSET(THREADENTRY32, th32OwnerProcessID) + sizeof(DWORD))
					&& te.th32OwnerProcessID == GetCurrentProcessId()
					&& te.th32ThreadID != GetCurrentThreadId())
				{
					if (pThreads->pItems == NULL)
					{
						pThreads->capacity = INITIAL_THREAD_CAPACITY;
						pThreads->pItems
							= (LPDWORD)HeapAlloc(g_hHeap, 0, pThreads->capacity * sizeof(DWORD));
						if (pThreads->pItems == NULL)
							break;
					}
					else if (pThreads->size >= pThreads->capacity)
					{
						LPDWORD p = (LPDWORD)HeapReAlloc(
							g_hHeap, 0, pThreads->pItems, (pThreads->capacity * 2) * sizeof(DWORD));
						if (p == NULL)
							break;

						pThreads->capacity *= 2;
						pThreads->pItems = p;
					}
					pThreads->pItems[pThreads->size++] = te.th32ThreadID;
				}

				te.dwSize = sizeof(THREADENTRY32);
			} while (Thread32Next(hSnapshot, &te));
		}
		CloseHandle(hSnapshot);
	}
}

//-------------------------------------------------------------------------
static VOID Freeze(PFROZEN_THREADS pThreads, UINT pos, UINT action)
{
	pThreads->pItems = NULL;
	pThreads->capacity = 0;
	pThreads->size = 0;
	EnumerateThreads(pThreads);

	if (pThreads->pItems != NULL)
	{
		UINT i;
		for (i = 0; i < pThreads->size; ++i)
		{
			HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads->pItems[i]);
			if (hThread != NULL)
			{
				SuspendThread(hThread);
				ProcessThreadIPs(hThread, pos, action);
				CloseHandle(hThread);
			}
		}
	}
}

//-------------------------------------------------------------------------
static VOID Unfreeze(PFROZEN_THREADS pThreads)
{
	if (pThreads->pItems != NULL)
	{
		UINT i;
		for (i = 0; i < pThreads->size; ++i)
		{
			HANDLE hThread = OpenThread(THREAD_ACCESS, FALSE, pThreads->pItems[i]);
			if (hThread != NULL)
			{
				ResumeThread(hThread);
				CloseHandle(hThread);
			}
		}

		HeapFree(g_hHeap, 0, pThreads->pItems);
	}
}

//-------------------------------------------------------------------------
static MH_STATUS EnableHookLL(UINT pos, BOOL enable)
{
	PHOOK_ENTRY pHook = &g_hooks.pItems[pos];
	DWORD  oldProtect;
	SIZE_T patchSize = sizeof(JMP_REL);
	LPBYTE pPatchTarget = (LPBYTE)pHook->pTarget;

	if (pHook->patchAbove)
	{
		pPatchTarget -= sizeof(JMP_REL);
		patchSize += sizeof(JMP_REL_SHORT);
	}

	if (!VirtualProtect(pPatchTarget, patchSize, PAGE_EXECUTE_READWRITE, &oldProtect))
		return MH_ERROR_MEMORY_PROTECT;

	if (enable)
	{
		PJMP_REL pJmp = (PJMP_REL)pPatchTarget;
		pJmp->opcode = 0xE9;
		pJmp->operand = (UINT32)((LPBYTE)pHook->pDetour - (pPatchTarget + sizeof(JMP_REL)));

		if (pHook->patchAbove)
		{
			PJMP_REL_SHORT pShortJmp = (PJMP_REL_SHORT)pHook->pTarget;
			pShortJmp->opcode = 0xEB;
			pShortJmp->operand = (UINT8)(0 - (sizeof(JMP_REL_SHORT) + sizeof(JMP_REL)));
		}
	}
	else
	{
		if (pHook->patchAbove)
			memcpy(pPatchTarget, pHook->backup, sizeof(JMP_REL) + sizeof(JMP_REL_SHORT));
		else
			memcpy(pPatchTarget, pHook->backup, sizeof(JMP_REL));
	}

	VirtualProtect(pPatchTarget, patchSize, oldProtect, &oldProtect);

	// Just-in-case measure.
	FlushInstructionCache(GetCurrentProcess(), pPatchTarget, patchSize);

	pHook->isEnabled = enable;
	pHook->queueEnable = enable;

	return MH_OK;
}

//-------------------------------------------------------------------------
static MH_STATUS EnableAllHooksLL(BOOL enable)
{
	MH_STATUS status = MH_OK;
	UINT i, first = INVALID_HOOK_POS;

	for (i = 0; i < g_hooks.size; ++i)
	{
		if (g_hooks.pItems[i].isEnabled != enable)
		{
			first = i;
			break;
		}
	}

	if (first != INVALID_HOOK_POS)
	{
		FROZEN_THREADS threads;
		Freeze(&threads, ALL_HOOKS_POS, enable ? ACTION_ENABLE : ACTION_DISABLE);

		for (i = first; i < g_hooks.size; ++i)
		{
			if (g_hooks.pItems[i].isEnabled != enable)
			{
				status = EnableHookLL(i, enable);
				if (status != MH_OK)
					break;
			}
		}

		Unfreeze(&threads);
	}

	return status;
}

//-------------------------------------------------------------------------
static VOID EnterSpinLock(VOID)
{
	SIZE_T spinCount = 0;

	// Wait until the flag is FALSE.
	while (InterlockedCompareExchange(&g_isLocked, TRUE, FALSE) != FALSE)
	{
		// No need to generate a memory barrier here, since InterlockedCompareExchange()
		// generates a full memory barrier itself.

		// Prevent the loop from being too busy.
		if (spinCount < 32)
			Sleep(0);
		else
			Sleep(1);

		spinCount++;
	}
}

//-------------------------------------------------------------------------
static VOID LeaveSpinLock(VOID)
{
	// No need to generate a memory barrier here, since InterlockedExchange()
	// generates a full memory barrier itself.

	InterlockedExchange(&g_isLocked, FALSE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_Initialize(VOID)
{
	MH_STATUS status = MH_OK;

	EnterSpinLock();

	if (g_hHeap == NULL)
	{
		g_hHeap = HeapCreate(0, 0, 0);
		if (g_hHeap != NULL)
		{
			// Initialize the internal function buffer.
			InitializeBuffer();
		}
		else
		{
			status = MH_ERROR_MEMORY_ALLOC;
		}
	}
	else
	{
		status = MH_ERROR_ALREADY_INITIALIZED;
	}

	LeaveSpinLock();

	return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_Uninitialize(VOID)
{
	MH_STATUS status = MH_OK;

	EnterSpinLock();

	if (g_hHeap != NULL)
	{
		status = EnableAllHooksLL(FALSE);
		if (status == MH_OK)
		{
			// Free the internal function buffer.

			// HeapFree is actually not required, but some tools detect a false
			// memory leak without HeapFree.

			UninitializeBuffer();

			HeapFree(g_hHeap, 0, g_hooks.pItems);
			HeapDestroy(g_hHeap);

			g_hHeap = NULL;

			g_hooks.pItems = NULL;
			g_hooks.capacity = 0;
			g_hooks.size = 0;
		}
	}
	else
	{
		status = MH_ERROR_NOT_INITIALIZED;
	}

	LeaveSpinLock();

	return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID * ppOriginal)
{
	MH_STATUS status = MH_OK;

	EnterSpinLock();

	if (g_hHeap != NULL)
	{
		if (IsExecutableAddress(pTarget) && IsExecutableAddress(pDetour))
		{
			UINT pos = FindHookEntry(pTarget);
			if (pos == INVALID_HOOK_POS)
			{
				LPVOID pBuffer = AllocateBuffer(pTarget);
				if (pBuffer != NULL)
				{
					TRAMPOLINE ct;

					ct.pTarget = pTarget;
					ct.pDetour = pDetour;
					ct.pTrampoline = pBuffer;
					if (CreateTrampolineFunction(&ct))
					{
						PHOOK_ENTRY pHook = AddHookEntry();
						if (pHook != NULL)
						{
							pHook->pTarget = ct.pTarget;
#if defined(_M_X64) || defined(__x86_64__)
							pHook->pDetour = ct.pRelay;
#else
							pHook->pDetour = ct.pDetour;
#endif
							pHook->pTrampoline = ct.pTrampoline;
							pHook->patchAbove = ct.patchAbove;
							pHook->isEnabled = FALSE;
							pHook->queueEnable = FALSE;
							pHook->nIP = ct.nIP;
							memcpy(pHook->oldIPs, ct.oldIPs, ARRAYSIZE(ct.oldIPs));
							memcpy(pHook->newIPs, ct.newIPs, ARRAYSIZE(ct.newIPs));

							// Back up the target function.

							if (ct.patchAbove)
							{
								memcpy(
									pHook->backup,
									(LPBYTE)pTarget - sizeof(JMP_REL),
									sizeof(JMP_REL) + sizeof(JMP_REL_SHORT));
							}
							else
							{
								memcpy(pHook->backup, pTarget, sizeof(JMP_REL));
							}

							if (ppOriginal != NULL)
								* ppOriginal = pHook->pTrampoline;
						}
						else
						{
							status = MH_ERROR_MEMORY_ALLOC;
						}
					}
					else
					{
						status = MH_ERROR_UNSUPPORTED_FUNCTION;
					}

					if (status != MH_OK)
					{
						FreeBuffer(pBuffer);
					}
				}
				else
				{
					status = MH_ERROR_MEMORY_ALLOC;
				}
			}
			else
			{
				status = MH_ERROR_ALREADY_CREATED;
			}
		}
		else
		{
			status = MH_ERROR_NOT_EXECUTABLE;
		}
	}
	else
	{
		status = MH_ERROR_NOT_INITIALIZED;
	}

	LeaveSpinLock();

	return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget)
{
	MH_STATUS status = MH_OK;

	EnterSpinLock();

	if (g_hHeap != NULL)
	{
		UINT pos = FindHookEntry(pTarget);
		if (pos != INVALID_HOOK_POS)
		{
			if (g_hooks.pItems[pos].isEnabled)
			{
				FROZEN_THREADS threads;
				Freeze(&threads, pos, ACTION_DISABLE);

				status = EnableHookLL(pos, FALSE);

				Unfreeze(&threads);
			}

			if (status == MH_OK)
			{
				FreeBuffer(g_hooks.pItems[pos].pTrampoline);
				DeleteHookEntry(pos);
			}
		}
		else
		{
			status = MH_ERROR_NOT_CREATED;
		}
	}
	else
	{
		status = MH_ERROR_NOT_INITIALIZED;
	}

	LeaveSpinLock();

	return status;
}

//-------------------------------------------------------------------------
static MH_STATUS EnableHook(LPVOID pTarget, BOOL enable)
{
	MH_STATUS status = MH_OK;

	EnterSpinLock();

	if (g_hHeap != NULL)
	{
		if (pTarget == MH_ALL_HOOKS)
		{
			status = EnableAllHooksLL(enable);
		}
		else
		{
			FROZEN_THREADS threads;
			UINT pos = FindHookEntry(pTarget);
			if (pos != INVALID_HOOK_POS)
			{
				if (g_hooks.pItems[pos].isEnabled != enable)
				{
					Freeze(&threads, pos, ACTION_ENABLE);

					status = EnableHookLL(pos, enable);

					Unfreeze(&threads);
				}
				else
				{
					status = enable ? MH_ERROR_ENABLED : MH_ERROR_DISABLED;
				}
			}
			else
			{
				status = MH_ERROR_NOT_CREATED;
			}
		}
	}
	else
	{
		status = MH_ERROR_NOT_INITIALIZED;
	}

	LeaveSpinLock();

	return status;
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget)
{
	return EnableHook(pTarget, TRUE);
}

//-------------------------------------------------------------------------
MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget)
{
	return EnableHook(pTarget, FALSE);
}

//-------------------------------------------------------------------------
const char* WINAPI MH_StatusToString(MH_STATUS status)
{
#define MH_ST2STR(x)    \
    case x:             \
        return #x;

	switch (status) {
		MH_ST2STR(MH_UNKNOWN)
			MH_ST2STR(MH_OK)
			MH_ST2STR(MH_ERROR_ALREADY_INITIALIZED)
			MH_ST2STR(MH_ERROR_NOT_INITIALIZED)
			MH_ST2STR(MH_ERROR_ALREADY_CREATED)
			MH_ST2STR(MH_ERROR_NOT_CREATED)
			MH_ST2STR(MH_ERROR_ENABLED)
			MH_ST2STR(MH_ERROR_DISABLED)
			MH_ST2STR(MH_ERROR_NOT_EXECUTABLE)
			MH_ST2STR(MH_ERROR_UNSUPPORTED_FUNCTION)
			MH_ST2STR(MH_ERROR_MEMORY_ALLOC)
			MH_ST2STR(MH_ERROR_MEMORY_PROTECT)
			MH_ST2STR(MH_ERROR_MODULE_NOT_FOUND)
			MH_ST2STR(MH_ERROR_FUNCTION_NOT_FOUND)
	}

#undef MH_ST2STR

	return "(unknown)";
}
```

`src/minhook/minhook.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#if !(defined _M_IX86) && !(defined _M_X64) && !(defined __i386__) && !(defined __x86_64__)
#error MinHook supports only x86 and x64 systems.
#endif

#include <windows.h>

 // MinHook Error Codes.
typedef enum MH_STATUS
{
	// Unknown error. Should not be returned.
	MH_UNKNOWN = -1,

	// Successful.
	MH_OK = 0,

	// MinHook is already initialized.
	MH_ERROR_ALREADY_INITIALIZED,

	// MinHook is not initialized yet, or already uninitialized.
	MH_ERROR_NOT_INITIALIZED,

	// The hook for the specified target function is already created.
	MH_ERROR_ALREADY_CREATED,

	// The hook for the specified target function is not created yet.
	MH_ERROR_NOT_CREATED,

	// The hook for the specified target function is already enabled.
	MH_ERROR_ENABLED,

	// The hook for the specified target function is not enabled yet, or already
	// disabled.
	MH_ERROR_DISABLED,

	// The specified pointer is invalid. It points the address of non-allocated
	// and/or non-executable region.
	MH_ERROR_NOT_EXECUTABLE,

	// The specified target function cannot be hooked.
	MH_ERROR_UNSUPPORTED_FUNCTION,

	// Failed to allocate memory.
	MH_ERROR_MEMORY_ALLOC,

	// Failed to change the memory protection.
	MH_ERROR_MEMORY_PROTECT,

	// The specified module is not loaded.
	MH_ERROR_MODULE_NOT_FOUND,

	// The specified function is not found.
	MH_ERROR_FUNCTION_NOT_FOUND
}
MH_STATUS;

// Can be passed as a parameter to MH_EnableHook, MH_DisableHook,
// MH_QueueEnableHook or MH_QueueDisableHook.
#define MH_ALL_HOOKS NULL

#ifdef __cplusplus
extern "C" {
#endif

	// Initialize the MinHook library. You must call this function EXACTLY ONCE
	// at the beginning of your program.
	MH_STATUS WINAPI MH_Initialize(VOID);

	// Uninitialize the MinHook library. You must call this function EXACTLY
	// ONCE at the end of your program.
	MH_STATUS WINAPI MH_Uninitialize(VOID);

	// Creates a Hook for the specified target function, in disabled state.
	// Parameters:
	//   pTarget    [in]  A pointer to the target function, which will be
	//                    overridden by the detour function.
	//   pDetour    [in]  A pointer to the detour function, which will override
	//                    the target function.
	//   ppOriginal [out] A pointer to the trampoline function, which will be
	//                    used to call the original target function.
	//                    This parameter can be NULL.
	MH_STATUS WINAPI MH_CreateHook(LPVOID pTarget, LPVOID pDetour, LPVOID* ppOriginal);

	// Removes an already created hook.
	// Parameters:
	//   pTarget [in] A pointer to the target function.
	MH_STATUS WINAPI MH_RemoveHook(LPVOID pTarget);

	// Enables an already created hook.
	// Parameters:
	//   pTarget [in] A pointer to the target function.
	//                If this parameter is MH_ALL_HOOKS, all created hooks are
	//                enabled in one go.
	MH_STATUS WINAPI MH_EnableHook(LPVOID pTarget);

	// Disables an already created hook.
	// Parameters:
	//   pTarget [in] A pointer to the target function.
	//                If this parameter is MH_ALL_HOOKS, all created hooks are
	//                disabled in one go.
	MH_STATUS WINAPI MH_DisableHook(LPVOID pTarget);

	// Translates the MH_STATUS to its name as a string.
	const char* WINAPI MH_StatusToString(MH_STATUS status);

#ifdef __cplusplus
}
#endif

```

`src/minhook/trampoline.c`:

```c
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <windows.h>

#ifndef ARRAYSIZE
#define ARRAYSIZE(A) (sizeof(A)/sizeof((A)[0]))
#endif

#if defined(_M_X64) || defined(__x86_64__)
#include "./hde/hde64.h"
typedef hde64s HDE;
#define HDE_DISASM(code, hs) hde64_disasm(code, hs)
#else
#include "./hde/hde32.h"
typedef hde32s HDE;
#define HDE_DISASM(code, hs) hde32_disasm(code, hs)
#endif

#include "trampoline.h"
#include "buffer.h"

// Maximum size of a trampoline function.
#if defined(_M_X64) || defined(__x86_64__)
#define TRAMPOLINE_MAX_SIZE (MEMORY_SLOT_SIZE - sizeof(JMP_ABS))
#else
#define TRAMPOLINE_MAX_SIZE MEMORY_SLOT_SIZE
#endif

//-------------------------------------------------------------------------
static BOOL IsCodePadding(LPBYTE pInst, UINT size)
{
	UINT i;

	if (pInst[0] != 0x00 && pInst[0] != 0x90 && pInst[0] != 0xCC)
		return FALSE;

	for (i = 1; i < size; ++i)
	{
		if (pInst[i] != pInst[0])
			return FALSE;
	}
	return TRUE;
}

//-------------------------------------------------------------------------
BOOL CreateTrampolineFunction(PTRAMPOLINE ct)
{
#if defined(_M_X64) || defined(__x86_64__)
	CALL_ABS call = {
		0xFF, 0x15, 0x00000002, // FF15 00000002: CALL [RIP+8]
		0xEB, 0x08,             // EB 08:         JMP +10
		0x0000000000000000ULL   // Absolute destination address
	};
	JMP_ABS jmp = {
		0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6]
		0x0000000000000000ULL   // Absolute destination address
	};
	JCC_ABS jcc = {
		0x70, 0x0E,             // 7* 0E:         J** +16
		0xFF, 0x25, 0x00000000, // FF25 00000000: JMP [RIP+6]
		0x0000000000000000ULL   // Absolute destination address
	};
#else
	CALL_REL call = {
		0xE8,                   // E8 xxxxxxxx: CALL +5+xxxxxxxx
		0x00000000              // Relative destination address
	};
	JMP_REL jmp = {
		0xE9,                   // E9 xxxxxxxx: JMP +5+xxxxxxxx
		0x00000000              // Relative destination address
	};
	JCC_REL jcc = {
		0x0F, 0x80,             // 0F8* xxxxxxxx: J** +6+xxxxxxxx
		0x00000000              // Relative destination address
	};
#endif

	UINT8     oldPos = 0;
	UINT8     newPos = 0;
	ULONG_PTR jmpDest = 0;     // Destination address of an internal jump.
	BOOL      finished = FALSE; // Is the function completed?
#if defined(_M_X64) || defined(__x86_64__)
	UINT8     instBuf[16];
#endif

	ct->patchAbove = FALSE;
	ct->nIP = 0;

	do
	{
		HDE       hs;
		UINT      copySize;
		LPVOID    pCopySrc;
		ULONG_PTR pOldInst = (ULONG_PTR)ct->pTarget + oldPos;
		ULONG_PTR pNewInst = (ULONG_PTR)ct->pTrampoline + newPos;

		copySize = HDE_DISASM((LPVOID)pOldInst, &hs);
		if (hs.flags & F_ERROR)
			return FALSE;

		pCopySrc = (LPVOID)pOldInst;
		if (oldPos >= sizeof(JMP_REL))
		{
			// The trampoline function is long enough.
			// Complete the function with the jump to the target function.
#if defined(_M_X64) || defined(__x86_64__)
			jmp.address = pOldInst;
#else
			jmp.operand = (UINT32)(pOldInst - (pNewInst + sizeof(jmp)));
#endif
			pCopySrc = &jmp;
			copySize = sizeof(jmp);

			finished = TRUE;
		}
#if defined(_M_X64) || defined(__x86_64__)
		else if ((hs.modrm & 0xC7) == 0x05)
		{
			// Instructions using RIP relative addressing. (ModR/M = 00???101B)

			// Modify the RIP relative address.
			PUINT32 pRelAddr;

			// Avoid using memcpy to reduce the footprint.
#ifndef _MSC_VER
			memcpy(instBuf, (LPBYTE)pOldInst, copySize);
#else
			__movsb(instBuf, (LPBYTE)pOldInst, copySize);
#endif
			pCopySrc = instBuf;

			// Relative address is stored at (instruction length - immediate value length - 4).
			pRelAddr = (PUINT32)(instBuf + hs.len - ((hs.flags & 0x3C) >> 2) - 4);
			*pRelAddr
				= (UINT32)((pOldInst + hs.len + (INT32)hs.disp.disp32) - (pNewInst + hs.len));

			// Complete the function if JMP (FF /4).
			if (hs.opcode == 0xFF && hs.modrm_reg == 4)
				finished = TRUE;
		}
#endif
		else if (hs.opcode == 0xE8)
		{
			// Direct relative CALL
			ULONG_PTR dest = pOldInst + hs.len + (INT32)hs.imm.imm32;
#if defined(_M_X64) || defined(__x86_64__)
			call.address = dest;
#else
			call.operand = (UINT32)(dest - (pNewInst + sizeof(call)));
#endif
			pCopySrc = &call;
			copySize = sizeof(call);
		}
		else if ((hs.opcode & 0xFD) == 0xE9)
		{
			// Direct relative JMP (EB or E9)
			ULONG_PTR dest = pOldInst + hs.len;

			if (hs.opcode == 0xEB) // isShort jmp
				dest += (INT8)hs.imm.imm8;
			else
				dest += (INT32)hs.imm.imm32;

			// Simply copy an internal jump.
			if ((ULONG_PTR)ct->pTarget <= dest
				&& dest < ((ULONG_PTR)ct->pTarget + sizeof(JMP_REL)))
			{
				if (jmpDest < dest)
					jmpDest = dest;
			}
			else
			{
#if defined(_M_X64) || defined(__x86_64__)
				jmp.address = dest;
#else
				jmp.operand = (UINT32)(dest - (pNewInst + sizeof(jmp)));
#endif
				pCopySrc = &jmp;
				copySize = sizeof(jmp);

				// Exit the function If it is not in the branch
				finished = (pOldInst >= jmpDest);
			}
		}
		else if ((hs.opcode & 0xF0) == 0x70
			|| (hs.opcode & 0xFC) == 0xE0
			|| (hs.opcode2 & 0xF0) == 0x80)
		{
			// Direct relative Jcc
			ULONG_PTR dest = pOldInst + hs.len;

			if ((hs.opcode & 0xF0) == 0x70      // Jcc
				|| (hs.opcode & 0xFC) == 0xE0)  // LOOPNZ/LOOPZ/LOOP/JECXZ
				dest += (INT8)hs.imm.imm8;
			else
				dest += (INT32)hs.imm.imm32;

			// Simply copy an internal jump.
			if ((ULONG_PTR)ct->pTarget <= dest
				&& dest < ((ULONG_PTR)ct->pTarget + sizeof(JMP_REL)))
			{
				if (jmpDest < dest)
					jmpDest = dest;
			}
			else if ((hs.opcode & 0xFC) == 0xE0)
			{
				// LOOPNZ/LOOPZ/LOOP/JCXZ/JECXZ to the outside are not supported.
				return FALSE;
			}
			else
			{
				UINT8 cond = ((hs.opcode != 0x0F ? hs.opcode : hs.opcode2) & 0x0F);
#if defined(_M_X64) || defined(__x86_64__)
				// Invert the condition in x64 mode to simplify the conditional jump logic.
				jcc.opcode = 0x71 ^ cond;
				jcc.address = dest;
#else
				jcc.opcode1 = 0x80 | cond;
				jcc.operand = (UINT32)(dest - (pNewInst + sizeof(jcc)));
#endif
				pCopySrc = &jcc;
				copySize = sizeof(jcc);
			}
		}
		else if ((hs.opcode & 0xFE) == 0xC2)
		{
			// RET (C2 or C3)

			// Complete the function if not in a branch.
			finished = (pOldInst >= jmpDest);
		}

		// Can't alter the instruction length in a branch.
		if (pOldInst < jmpDest && copySize != hs.len)
			return FALSE;

		// Trampoline function is too large.
		if ((newPos + copySize) > TRAMPOLINE_MAX_SIZE)
			return FALSE;

		// Trampoline function has too many instructions.
		if (ct->nIP >= ARRAYSIZE(ct->oldIPs))
			return FALSE;

		ct->oldIPs[ct->nIP] = oldPos;
		ct->newIPs[ct->nIP] = newPos;
		ct->nIP++;

		// Avoid using memcpy to reduce the footprint.
#ifndef _MSC_VER
		memcpy((LPBYTE)ct->pTrampoline + newPos, pCopySrc, copySize);
#else
		__movsb((LPBYTE)ct->pTrampoline + newPos, pCopySrc, copySize);
#endif
		newPos += copySize;
		oldPos += hs.len;
	} while (!finished);

	// Is there enough place for a long jump?
	if (oldPos < sizeof(JMP_REL)
		&& !IsCodePadding((LPBYTE)ct->pTarget + oldPos, sizeof(JMP_REL) - oldPos))
	{
		// Is there enough place for a short jump?
		if (oldPos < sizeof(JMP_REL_SHORT)
			&& !IsCodePadding((LPBYTE)ct->pTarget + oldPos, sizeof(JMP_REL_SHORT) - oldPos))
		{
			return FALSE;
		}

		// Can we place the long jump above the function?
		if (!IsExecutableAddress((LPBYTE)ct->pTarget - sizeof(JMP_REL)))
			return FALSE;

		if (!IsCodePadding((LPBYTE)ct->pTarget - sizeof(JMP_REL), sizeof(JMP_REL)))
			return FALSE;

		ct->patchAbove = TRUE;
	}

#if defined(_M_X64) || defined(__x86_64__)
	// Create a relay function.
	jmp.address = (ULONG_PTR)ct->pDetour;

	ct->pRelay = (LPBYTE)ct->pTrampoline + newPos;
	memcpy(ct->pRelay, &jmp, sizeof(jmp));
#endif

	return TRUE;
}
```

`src/minhook/trampoline.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2017 Tsuda Kageyu.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *   1. Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 *  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 *  PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
 *  OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 *  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#pragma pack(push, 1)

 // Structs for writing x86/x64 instructions.

 // 8-bit relative jump.
typedef struct _JMP_REL_SHORT
{
	UINT8  opcode;      // EB xx: JMP +2+xx
	UINT8  operand;
} JMP_REL_SHORT, * PJMP_REL_SHORT;

// 32-bit direct relative jump/call.
typedef struct _JMP_REL
{
	UINT8  opcode;      // E9/E8 xxxxxxxx: JMP/CALL +5+xxxxxxxx
	UINT32 operand;     // Relative destination address
} JMP_REL, * PJMP_REL, CALL_REL;

// 64-bit indirect absolute jump.
typedef struct _JMP_ABS
{
	UINT8  opcode0;     // FF25 00000000: JMP [+6]
	UINT8  opcode1;
	UINT32 dummy;
	UINT64 address;     // Absolute destination address
} JMP_ABS, * PJMP_ABS;

// 64-bit indirect absolute call.
typedef struct _CALL_ABS
{
	UINT8  opcode0;     // FF15 00000002: CALL [+6]
	UINT8  opcode1;
	UINT32 dummy0;
	UINT8  dummy1;      // EB 08:         JMP +10
	UINT8  dummy2;
	UINT64 address;     // Absolute destination address
} CALL_ABS;

// 32-bit direct relative conditional jumps.
typedef struct _JCC_REL
{
	UINT8  opcode0;     // 0F8* xxxxxxxx: J** +6+xxxxxxxx
	UINT8  opcode1;
	UINT32 operand;     // Relative destination address
} JCC_REL;

// 64bit indirect absolute conditional jumps that x64 lacks.
typedef struct _JCC_ABS
{
	UINT8  opcode;      // 7* 0E:         J** +16
	UINT8  dummy0;
	UINT8  dummy1;      // FF25 00000000: JMP [+6]
	UINT8  dummy2;
	UINT32 dummy3;
	UINT64 address;     // Absolute destination address
} JCC_ABS;

#pragma pack(pop)

typedef struct _TRAMPOLINE
{
	LPVOID pTarget;         // [In] Address of the target function.
	LPVOID pDetour;         // [In] Address of the detour function.
	LPVOID pTrampoline;     // [In] Buffer address for the trampoline and relay function.

#if defined(_M_X64) || defined(__x86_64__)
	LPVOID pRelay;          // [Out] Address of the relay function.
#endif
	BOOL   patchAbove;      // [Out] Should use the hot patch area?
	UINT   nIP;             // [Out] Number of the instruction boundaries.
	UINT8  oldIPs[8];       // [Out] Instruction boundaries of the target function.
	UINT8  newIPs[8];       // [Out] Instruction boundaries of the trampoline function.
} TRAMPOLINE, * PTRAMPOLINE;

BOOL CreateTrampolineFunction(PTRAMPOLINE ct);

```

`src/render/fonts/droidsans.hpp`:

```hpp
// File: 'C:\Windows\Fonts\DroidSans.ttf' (190776 bytes)
// Exported using binary_to_compressed_c.cpp
static const unsigned int droidsans_compressed_size = 134868;
static const unsigned int droidsans_compressed_data[134868 / 4] =
{
	0x0000bc57, 0x00000000, 0x38e90200, 0x00000400, 0x00010025, 0x82130000, 0x00042e04, 0x45444730, 0x03260046, 0x3f02008a, 0x28158268, 0x4f50471e,
	0xad87f253, 0x300f82a7, 0xa9000088, 0x5553478e, 0x74916c42, 0xe902008f, 0x3c1f8218, 0x53544c20, 0xc49bd848, 0x1000003e, 0x0300002c, 0x2f534f89,
	0x95cba032, 0x0100008b, 0x081f82b8, 0x6d636038, 0x5e027061, 0x00008709, 0x0000d856, 0x76633608, 0x7e392074, 0x00004c3e, 0x00000469, 0x7066fc01,
	0xd3736d67, 0x0000b023, 0x0000105f, 0x61670507, 0x04007073, 0x6f820700, 0x3f825c20, 0x6c670c3b, 0x00966679, 0x000099a9, 0x01000c72, 0x64684ca9,
	0xa195786d, 0x0000af5b, 0x295f8213, 0x65682043, 0x29ef6461, 0x4b82cc74, 0x2f823c20, 0x82683621, 0x530c2310, 0x0f82a909, 0x0f827420, 0x6d68242b,
	0x9ee17874, 0x0000dd2e, 0x2caf8202, 0x6f6c140e, 0x4a5f6163, 0x00002eca, 0x291e826b, 0x616d0c07, 0x39067078, 0x2f828502, 0x10829820, 0x6e202c08,
	0xb5656d61, 0x0056905a, 0x00581b02, 0x70a20600, 0x9b74736f, 0x008c59ef, 0x00fc2102, 0x705d1d00, 0x82706572, 0x001321dc, 0x82186600, 0x00ec2253,
	0x82358201, 0x9fe32b03, 0x0f5f3c08, 0x1900f53c, 0x00830008, 0x339ac122, 0x002c0683, 0x9af67ec9, 0xd5fd89fb, 0x62085a09, 0x06221082, 0x2f820200,
	0x33820283, 0xfe6d072d, 0x0900001d, 0xfe89fb64, 0x845a09a2, 0x86198349, 0x85032103, 0x05821183, 0x1600a026, 0x05007a00, 0x102c3982, 0x5a002f00,
	0x2b020000, 0x03003901, 0x03241d82, 0x90019904, 0x08231982, 0x82059a05, 0x1e01216e, 0x03250785, 0x016600d0, 0x302782f2, 0x0306060b, 0x02020408,
	0x0200e004, 0x200040ef, 0x205a825b, 0x25038228, 0x53413100, 0x10820043, 0x06fdff2f, 0x0014fe1f, 0x016d0784, 0x010020e3, 0x231b839f, 0xb6054a04,
	0x20260782, 0xcd040200, 0x1184c100, 0x00001423, 0x3e038302, 0x03930027, 0x05850037, 0x0433002b, 0x067b0068, 0x0566009a, 0x016d009e, 0x028500cf,
	0x82520068, 0x823d2003, 0x82522017, 0x02662603, 0x023f0000, 0x26138293, 0x02930025, 0x821400fc, 0x82622013, 0x82b22003, 0x86602003, 0x82172023,
	0x82832007, 0x82712003, 0x825a2003, 0x836a2003, 0x83022003, 0x0025222f, 0x200b823f, 0x35038766, 0x25006803, 0x6d00ee06, 0x0000dd04, 0xc700f804,
	0x7d00d304, 0x07827905, 0xc7003928, 0xc700ee03, 0x0f828505, 0xc7009c24, 0x6f82b602, 0x48ff2b24, 0x1785a204, 0x82f60621, 0x82d5201b, 0x00f02303,
	0x1f82047d, 0x07830520, 0x3782b820, 0x68002730, 0x14002704, 0xb8009605, 0x00008b04, 0x9f821207, 0x5b826020, 0x03823720, 0x43825020, 0xa4006d22,
	0x1722b382, 0xe7826d02, 0x29004236, 0xfcff4a03, 0x89019e04, 0x5e003f04, 0xae00b004, 0x7100b403, 0x713a0782, 0x71004804, 0x1d00a202, 0x25002504,
	0xae00b604, 0xa0001202, 0xbcff1202, 0x0b84f803, 0x2b07ae24, 0x1783ae00, 0x849e0421, 0x83ae202f, 0x31032133, 0x9c223f82, 0xab825a00, 0x1b822120,
	0xd503a426, 0xf8050000, 0x00287f82, 0xe9032300, 0x87030a00, 0xd5287f82, 0x68043d00, 0xd502e901, 0x68227f82, 0x7b416600, 0x68042307, 0x0382bc00,
	0x03824420, 0x03827b20, 0x23831d20, 0x00e30323, 0x2b9b8279, 0x00a80633, 0x00a60264, 0x00e50344, 0x22057f41, 0x83520093, 0x00042613, 0x6d03faff,
	0x202f8300, 0x201f8266, 0x20038231, 0x24cb841f, 0x05ae00c1, 0x26bf823d, 0x01930025, 0x822300a4, 0x023f2417, 0x824200cd, 0x0554243f, 0x823f00e5,
	0x822c2003, 0x031f2803, 0x04440068, 0x930000dd, 0xd1062903, 0xd304feff, 0x39047d00, 0x87058b41, 0x20db8207, 0x2003823e, 0x20038252, 0x25038211,
	0x00790540, 0x8741052f, 0xf0052306, 0x038b7d00, 0x8d20c782, 0x96230f84, 0x8a05b800, 0x37042103, 0x9c207382, 0xd1265782, 0x3f04ae00, 0x03935e00,
	0x00aa0629, 0x00b4035e, 0x8d480471, 0x12022703, 0x1202deff, 0x0782ae00, 0x0382bd20, 0x9e04ee24, 0x87416f00, 0x829e2008, 0x22038b2b, 0x82660068,
	0x8273201f, 0x8ba4201f, 0xe9032703, 0xb0040a00, 0x0784ae00, 0x8383ff83, 0xfb82078f, 0x07967f84, 0xc720f782, 0x71204382, 0x2f200782, 0x04210783,
	0x83cf8239, 0x27079eab, 0x7d008505, 0x25002504, 0x9c200798, 0xb62e4782, 0x9c05ae00, 0xb6040000, 0xb6021200, 0xe782f5ff, 0xb602a324, 0x07823d00,
	0x0782eb20, 0x07823020, 0x0782de20, 0x12025224, 0x07864400, 0xe104ae24, 0x57825200, 0x2b02a024, 0x1f8248ff, 0xa204bc26, 0xf803c700, 0x0383e382,
	0xc700ee22, 0xab212b82, 0x20078503, 0x20078666, 0x200784ae, 0x22238266, 0x821d00ee, 0x05f62233, 0x8f7b86d5, 0xff462207, 0x201b88ff, 0x23bf82f0,
	0x0571009e, 0x0724078e, 0x077d001f, 0xb820ff83, 0x31237782, 0x8504ae00, 0x86602007, 0x04722807, 0x03680027, 0x9a5a009c, 0x82142007, 0x822120cb,
	0x27078c1f, 0xb8009605, 0xa400b604, 0x072f07a7, 0x05140012, 0x041400f8, 0x03000037, 0x830a00e9, 0x50042707, 0x87035200, 0x078f5200, 0x824c0221,
	0x006823a7, 0xfb4104cb, 0xd1062706, 0xaa06feff, 0xdb865e00, 0xab887320, 0x02019e23, 0x22038304, 0x821b0175, 0x02212407, 0x82a00012, 0x016d2407,
	0x841f007b, 0x009e2217, 0x200782df, 0x320382f8, 0xffdd0414, 0x002502e9, 0xffc90493, 0xff1706e7, 0x82b203e7, 0xff422407, 0x825405e7, 0xff4a2607,
	0xff9e02e7, 0x206f84e4, 0x05c744f8, 0x008b0427, 0x00390425, 0x209b83c7, 0x06c74405, 0x82b60221, 0x82a220ab, 0x008b2213, 0x07e74400, 0x003f0423,
	0x21978352, 0x17828705, 0x04232782, 0x824e0042, 0x25e7849f, 0x68002306, 0x2b826004, 0x23820782, 0x3f824e20, 0xf7844020, 0x7100b030, 0x5a00a003,
	0xae00b604, 0xa4009e02, 0x0382b804, 0x04221382, 0xfb4200d1, 0x009e2205, 0x231f836f, 0x7100a403, 0x04232383, 0x83710087, 0xf8032927, 0x1704ae00,
	0xc104f2ff, 0x23220782, 0x1f840000, 0x71009e27, 0x19000a05, 0x84478204, 0x82b4200f, 0x0098225b, 0x21538312, 0x3f829605, 0xecff3128, 0xa400ec05,
	0x43840606, 0x6b841520, 0x07833382, 0xe3831383, 0x00a00525, 0x45ee0314, 0xbb8205e3, 0xa7826820, 0x03825220, 0x2b02402c, 0x480748ff, 0x75070000,
	0x2383c700, 0xfb830420, 0x1900ae22, 0xdd20eb84, 0x41062b44, 0x0523062f, 0x830e0033, 0x85062b4b, 0x5c040400, 0xd5054800, 0x0383c900, 0x05223383,
	0x2f41005a, 0x06474105, 0x22082b41, 0x827d00d3, 0x0414216f, 0x2b415382, 0x9a052107, 0x48266b82, 0xfa07a600, 0x0383c700, 0x003d0525, 0x41960614,
	0xc124065b, 0x1d083b00, 0xb8200b82, 0x2008ef82, 0x045e003f, 0x0475008f, 0x03ae0089, 0x04ae0033, 0x04290060, 0x05710048, 0x030400c3, 0x044400ae,
	0x821382e9, 0x26d78203, 0x005e04ae, 0x85be0510, 0x8304200f, 0x82c120fb, 0x46b0200b, 0x03310553, 0x03290087, 0x050a00e9, 0x04710093, 0x04230000,
	0x301b82d1, 0x069a00ac, 0x07ae00f4, 0x05ae0004, 0x0529006d, 0x831382fe, 0x00b22467, 0x82790637, 0x823f200b, 0x236b8227, 0x1200b604, 0x03277b83,
	0x037100b4, 0x465a009c, 0xee2a068b, 0xbcff1202, 0x10008306, 0x2b82e506, 0xee202383, 0x8206d741, 0x208f8277, 0x433383c7, 0x078f070f, 0x23081f43,
	0x08520000, 0x03270386, 0x01fcff4a, 0x83170066, 0x00022303, 0x07823f00, 0xe7021924, 0x03831700, 0x00810329, 0x00e3033f, 0x82f8037b, 0x00023603,
	0x006f0696, 0x005a0993, 0x00cf0166, 0x00370385, 0x004e0285, 0x2f038352, 0x9300f603, 0xa0fe0a01, 0x6a00f802, 0x60006804, 0x44240382, 0x96000006,
	0x3f2c0782, 0x8d006806, 0x77000004, 0xc700e707, 0x252ceb82, 0x4e00f005, 0x6600f404, 0x53000e06, 0x33200382, 0x4f200382, 0x712a0382, 0x6200a604,
	0x29008b04, 0x2782ee05, 0x4a000c32, 0x66006804, 0x25006404, 0x7700a805, 0x10001903, 0x13830f84, 0xaa260387, 0xb4046d00, 0x03841d00, 0xcf009e2a,
	0xbcff1202, 0x87010004, 0x6f200382, 0x7d240382, 0x2500a602, 0x0c200382, 0x3b200382, 0x2f200b86, 0x20062f47, 0x248f8221, 0x00000800, 0x29078700,
	0x0000ab02, 0x00000002, 0x13825501, 0x0b826820, 0x0b822520, 0x10829a20, 0x0382cd20, 0x08230286, 0x83540000, 0x37678303, 0x17006601, 0x0a00cd04,
	0x00005204, 0x1200a006, 0xc700f606, 0xae002b07, 0x2e085344, 0x02d3fe42, 0x037300aa, 0x07930033, 0x831d0056, 0x34f78203, 0x00aa047d, 0x00f40571,
	0x002f05b8, 0xfc0000a4, 0xfd00008f, 0x20078248, 0x20078246, 0x22038204, 0x82390431, 0x00d53cfb, 0x004804c9, 0x00e90471, 0x00db07ae, 0x006f067d,
	0x00250500, 0x00dd0414, 0x82270714, 0x00b6221f, 0x2a3f82ae, 0x00640400, 0x0029070a, 0x821206c7, 0x827f200f, 0x82f0201f, 0x828b200f, 0x82a2200f,
	0x005e2e87, 0x00ae0339, 0x00230617, 0x00ec0568, 0x427b84a4, 0x0022059b, 0xe382dd03, 0x8400c121, 0x64093107, 0x58087d00, 0x3f067100, 0x19057d00,
	0xb2077100, 0x50206f82, 0x77860782, 0x07470420, 0x00df2407, 0x82750468, 0x009e2697, 0x019e04f4, 0x290383e1, 0x2900e907, 0x2900a607, 0x1782e705,
	0x7382fc20, 0x2f009c32, 0x12008904, 0xc7009c04, 0xae00b004, 0x2f00ee03, 0x1222ff82, 0x0f820005, 0xae000826, 0x0400e906, 0x04248f82, 0x48005c04,
	0x44229b82, 0x17820a05, 0x37824a20, 0x0782a220, 0x07842b20, 0xf8032f26, 0x44051200, 0xd120cb82, 0xcd245782, 0xfa04e500, 0x5c283782, 0xac05e500,
	0x4408ae00, 0xb820db82, 0xec26eb82, 0xf2047d00, 0x9b887100, 0x14002728, 0x29008703, 0xd3823704, 0xdb82d520, 0xd3200787, 0x3d280b82, 0x89062300,
	0x8b051400, 0x48274f82, 0xbc04a600, 0x83059a00, 0x84ac2007, 0x04c72107, 0x06275782, 0x053d0077, 0x8733001d, 0xb6022907, 0x85065200, 0xc3050400,
	0x4a200382, 0x2d209b82, 0x6a207382, 0x71244b82, 0x9c051000, 0xe9209382, 0xcb200f82, 0xf3820782, 0x07274b87, 0x05c70006, 0x83ae00d1, 0x0703423b,
	0x200f5f46, 0x06234804, 0x828f0521, 0x004822bb, 0x87078766, 0x0717416b, 0xb8270784, 0xd5051b00, 0x8304c900, 0x4707876b, 0xd3410e7b, 0x033b2c0a,
	0x043700b2, 0x031900ae, 0x8f0a00e9, 0x44a38707, 0x0621071b, 0x20ab8296, 0x099f41fe, 0x82c30421, 0x002f24db, 0x82600423, 0x82002007, 0x009c2c07,
	0x00b00489, 0x00f40671, 0x82fe0689, 0xfc2e0807, 0x46064e00, 0xc5045000, 0x10044e00, 0xa4075000, 0xa4060000, 0xe5071000, 0x2f07c700, 0xc305ae00,
	0xe1047d00, 0x81057100, 0x12051400, 0xbf822900, 0xae036f26, 0x5a055c00, 0x5e224f82, 0x0f411000, 0x200f8e0f, 0x200f8e12, 0x490fb05e, 0x04271e7b,
	0x04270039, 0x49120048, 0x022717ab, 0x025200b6, 0x86620012, 0x489e2007, 0x0f8e0fe3, 0x0f8e3320, 0x200d1349, 0x062349aa, 0xdb48079b, 0x060f440f,
	0x97071744, 0x08bb4507, 0x200ae348, 0x05d34a03, 0x00007128, 0x0000dbfb, 0x07826afc, 0x07858920, 0x8264fc21, 0x8a732007, 0x01642403, 0x823100a4,
	0x83102003, 0xb0042303, 0x73497100, 0x00002e07, 0x01018503, 0x18281a01, 0x010a0101, 0x2504822b, 0x1401160b, 0x00880b05, 0x82141421, 0x1c3d080a,
	0x1422260b, 0x0b12010b, 0x15151915, 0x22191c14, 0x1b162213, 0x1017151b, 0x01122610, 0x01200105, 0x1c0b1101, 0x192a150b, 0x0a0c0c2e, 0x152e180c,
	0x2a120b0b, 0x0b192e0b, 0x1912161a, 0x20068218, 0x2e448228, 0x0115180b, 0x0b271404, 0x10010401, 0x8211110b, 0x0114294d, 0x01270a11, 0x261c0a01,
	0x01210084, 0x21898214, 0x00821901, 0x22190b22, 0x0b220083, 0x00821522, 0x16132623, 0x21008411, 0x0d821c16, 0x820c1521, 0x2e152100, 0x15230983,
	0x822e150b, 0x0b162400, 0x83112616, 0x1c142101, 0x6b830185, 0x87150121, 0x190b2101, 0x33820185, 0x0c192e22, 0x15280187, 0x150c1517, 0x0c140a0a,
	0x24240184, 0x2e190c14, 0x18240183, 0x15222e19, 0x2a230183, 0x83121628, 0x2a1b2101, 0x0b210186, 0x8301821b, 0x25038743, 0x16260b10, 0x00841226,
	0x260b302c, 0x22160111, 0x012a1b15, 0xc3832401, 0x5b080383, 0x2d151426, 0x150d150c, 0x19222616, 0x15120117, 0x19151922, 0x2211191c, 0x1b201315,
	0x19101926, 0x0b261922, 0x12162e16, 0x15160c0b, 0x172e1616, 0x122d0a16, 0x18151818, 0x01181813, 0x13131912, 0x15121618, 0x0e011812, 0x191b1419,
	0x19281519, 0x1530150e, 0x19221326, 0x1218011f, 0x10211082, 0x08a7821c, 0x1b141327, 0x15101930, 0x17191914, 0x24161910, 0x19141116, 0x19151614,
	0x0a19191a, 0x15191316, 0x191c0b12, 0x161a1916, 0x361f8212, 0x19111918, 0x142e1511, 0x0c0c2a1c, 0x2e18180c, 0x1712160a, 0x830b1001, 0x16262101,
	0x1523af83, 0x82151915, 0x82192003, 0x2b143100, 0x0c191918, 0x0b0b1901, 0x01010b11, 0x0122192a, 0x0c293382, 0x2b1e1726, 0x17170101, 0x2200820b,
	0x82141419, 0x01012220, 0x85008511, 0x852e20f3, 0x01012a06, 0x1611150c, 0x26181c18, 0x22108211, 0x82221414, 0x2c1985f7, 0x1d191519, 0x01262017,
	0x18181c01, 0x28938216, 0x191a0114, 0x18152213, 0x2a018216, 0x19151401, 0x14181d01, 0x82240d1c, 0x012e282c, 0x17011916, 0x82120b13, 0x19192515,
	0x01151a12, 0x0a229d82, 0x9782180b, 0x192e1929, 0x1c141312, 0x8226191b, 0x19193301, 0x1613152a, 0x18191214, 0x160a160a, 0x20191819, 0x32821818,
	0x14191823, 0x21cb8212, 0x82821126, 0x82011621, 0x151522d6, 0x21458218, 0xdc821112, 0xe0411920, 0x11162305, 0x01831630, 0x142c3b82, 0x14121810,
	0x1a100116, 0x15170b13, 0x16236282, 0x82271817, 0x171324aa, 0x42101a12, 0x6042065a, 0x42058b05, 0x09850960, 0x190c1923, 0x9159850c, 0x2e152505,
	0x1c192e15, 0x26210187, 0x20018316, 0x0512410b, 0x0b220585, 0x67480b1b, 0x00133505, 0x06880300, 0x03000407, 0x04020202, 0x01040503, 0x03030202,
	0x05820b82, 0x00860320, 0x03201183, 0x04271a82, 0x03030404, 0x82020404, 0x8205201a, 0x210d850b, 0x2e840305, 0x82020321, 0x04032119, 0x1f820683,
	0x1f840220, 0x02030223, 0x82158304, 0x870a8214, 0x82052050, 0x83022008, 0x23388235, 0x01020404, 0x27833984, 0x05215283, 0x84158204, 0x8260847e,
	0x84688862, 0x20378508, 0x8d008202, 0x823f871f, 0x85848207, 0x82bd860d, 0x82158b06, 0x8202863a, 0x8293847c, 0x85a1859b, 0x84ba8452, 0x0405228b,
	0x88018302, 0x85288447, 0x85058524, 0x241f84ad, 0x03040302, 0x843a8205, 0x214e820c, 0x00820301, 0x05263d82, 0x05040503, 0x81830402, 0x70820320,
	0x05040322, 0x06239c87, 0x83040603, 0x8a248235, 0x82f1851e, 0x2228824c, 0x82020605, 0x03062267, 0x820e8205, 0x060621b3, 0x10820882, 0x12834082,
	0xaa850682, 0x06040325, 0x82040403, 0x8206201d, 0x82042005, 0x20d58200, 0x20118204, 0x82428203, 0x2087820d, 0x24068205, 0x05040606, 0x20728203,
	0x20748203, 0x234d8203, 0x03040505, 0x05205783, 0xc7842582, 0x02060627, 0x01020101, 0x233d8202, 0x07060203, 0x02220882, 0x0c820103, 0x05030524,
	0x41820603, 0x00820520, 0x41847d84, 0x04223b82, 0x24420304, 0x8203200a, 0x020223cf, 0x44820301, 0x06000022, 0x04204b82, 0x36833582, 0x82020221,
	0x2038827a, 0x82008300, 0x84042071, 0x823c824c, 0x200b8281, 0x825c8403, 0x070321af, 0x06211882, 0x82048205, 0x21b48224, 0x23820606, 0x03820320,
	0x03040225, 0x85030505, 0x200f8214, 0x82008204, 0x41188224, 0x1d82056b, 0x02831182, 0x0220ca83, 0x2a827282, 0x05221185, 0x17840205, 0x27833d84,
	0xc0413183, 0x052a420a, 0x06256384, 0x04020305, 0x229e8403, 0x83050506, 0x20b584bb, 0x8ae78405, 0x850a8b32, 0x4205897f, 0x31960a96, 0x33851687,
	0x87000421, 0x01013200, 0x02030401, 0x04090700, 0x02020400, 0x06040503, 0x214c8205, 0x04820404, 0x3983f186, 0xcd830220, 0x3e410320, 0x05052306,
	0x62410204, 0x26f18205, 0x06050504, 0x43040404, 0xfc410670, 0x233c8205, 0x04060204, 0x03200082, 0x0423da82, 0x82040406, 0x83022006, 0x23138415,
	0x03020604, 0x032e1f83, 0x04030304, 0x01020504, 0x05030203, 0x03830505, 0x37840682, 0x00830420, 0x00850520, 0xff416182, 0x20158406, 0x93968406,
	0x054f42f0, 0x83077143, 0x090b410d, 0x05851b85, 0x83055b43, 0x85052005, 0x05834393, 0x20850583, 0x06860520, 0x06060422, 0x4108bf43, 0xc48205b0,
	0x8b020421, 0x8221824b, 0x221c8464, 0x82050402, 0x04052130, 0x23056543, 0x04010402, 0x05210082, 0x24be8402, 0x04050206, 0x821a8203, 0x05042259,
	0x82408206, 0x0404230b, 0x4d420406, 0x208a8205, 0x22008204, 0x85040303, 0x84078209, 0x211f8277, 0x18820206, 0x43040621, 0x0222057e, 0x43860707,
	0x6a820320, 0x4b835882, 0x4a860520, 0x08050529, 0x04060508, 0x82040704, 0x20418200, 0x0b874306, 0x04206a82, 0x2405a743, 0x04040603, 0x05384504,
	0x04060624, 0x0b820403, 0x00840620, 0x07261682, 0x01010307, 0x22420102, 0x08062705, 0x02020302, 0x22820103, 0x07206c83, 0x05206782, 0x75830082,
	0x8f860420, 0x00820420, 0x03820220, 0x03203085, 0x072b7a82, 0x04010202, 0x00010102, 0x82070700, 0x06042309, 0xec820606, 0x84030221, 0x00042106,
	0x04210083, 0x23898405, 0x05050604, 0x06220382, 0x0f860704, 0x04212782, 0x820c8209, 0x41062032, 0x04200542, 0xce87ee84, 0x03221485, 0x7e410304,
	0x82072005, 0x20268227, 0x211e8303, 0x0d820404, 0x50845782, 0x41058441, 0x088508c1, 0x1f85ea82, 0xc0414584, 0x82688609, 0x8203201b, 0x840d87a3,
	0x205382b5, 0x05a94107, 0x35897186, 0x7d850989, 0x0220058a, 0x930d1e42, 0x86138533, 0x0c874333, 0x00020426, 0x00050a08, 0x27058743, 0x02020607,
	0x02040402, 0x8605a446, 0x8202202e, 0x24ed8311, 0x04050505, 0x26d48204, 0x08040502, 0x82050606, 0x200d82a7, 0x82598208, 0x0721412e, 0x05040322,
	0x02212e82, 0x212b8208, 0x14830305, 0x04040622, 0x0320e182, 0x8205f342, 0x0705220b, 0x20108203, 0x82f58407, 0x202c8224, 0x20458203, 0x23038306,
	0x07060606, 0x82098d46, 0x8502820d, 0x05ff4117, 0x07203d82, 0x04200382, 0x02214b82, 0x0da74302, 0x82040521, 0x88038241, 0x0bbc43fa, 0x21821b86,
	0x0221b383, 0x20018604, 0x20478205, 0x884f8205, 0x82062010, 0x8603821e, 0x07052406, 0x83030507, 0x08684101, 0xb4820320, 0x1d870320, 0x08240783,
	0x04040406, 0x02207285, 0x07226482, 0x29430607, 0x02052305, 0x80820105, 0x02060522, 0x02205185, 0x06231782, 0x83060504, 0x22338203, 0x82050606,
	0x83062027, 0x8204200f, 0x8202203d, 0x8404202a, 0x04022138, 0x52840785, 0x3f82ae82, 0x82050521, 0x23158307, 0x08080204, 0x3b843782, 0x08040623,
	0x22088204, 0x84060806, 0x8264840e, 0x0507231d, 0x3a820805, 0x04030524, 0xa7430604, 0x84588208, 0x08a7430d, 0x02211e83, 0x06d54302, 0x08030423,
	0x82018306, 0x080821c7, 0x82068743, 0x0603280b, 0x02030209, 0x84010402, 0x826e824a, 0x836b8267, 0x204f82b2, 0x20158206, 0x46608204, 0x2f82066e,
	0x083b0283, 0x02030804, 0x02020401, 0x08000001, 0x05010208, 0x08080704, 0x03060406, 0x82070703, 0x00052138, 0x8a830083, 0x05060831, 0x06060705,
	0x06050704, 0x04070806, 0x82060604, 0x0604261e, 0x06080a04, 0x848b8305, 0x050522fd, 0x200e8208, 0x25008205, 0x04050304, 0x6f820608, 0x85056941,
	0x070622ec, 0x07294206, 0x0c826782, 0x05212882, 0x82018207, 0x0590432a, 0x11820620, 0x06203682, 0x07225882, 0x05820407, 0x0420c583, 0xc0410082,
	0x092c4209, 0x07030423, 0x06c14206, 0x08070529, 0x04040606, 0x84090708, 0x20398255, 0x055a4205, 0x87430591, 0x9b5d8913, 0x41398509, 0x00200512,
	0x02380082, 0x04050202, 0x0c090003, 0x02050005, 0x05060402, 0x03020608, 0x02050603, 0x4205a446, 0x248206eb, 0x83050521, 0x820520e0, 0x20a482dc,
	0x830c8303, 0x20f182f4, 0x22b58206, 0x82030305, 0x202c8212, 0x21268204, 0x2e820505, 0x82080221, 0x8205200d, 0x0505226d, 0x22138206, 0x83030503,
	0x27138415, 0x05040705, 0x05070305, 0x28057142, 0x04020206, 0x07070504, 0x056f4308, 0x37840620, 0x0f823883, 0x00830720, 0x06070522, 0x89860083,
	0x41080521, 0x022005fe, 0x87088743, 0x85052018, 0x090945f6, 0x19880620, 0x14418383, 0x090f4709, 0x03040623, 0x86248202, 0x04032210, 0x08874302,
	0x0723db83, 0x44080905, 0xce820dd0, 0x210cc641, 0x8d440506, 0x050f4906, 0x08200e82, 0x21073746, 0x59830502, 0x02060528, 0x08050706, 0x59820807,
	0x05279f82, 0x05040706, 0x82060806, 0x050521d2, 0x0722ef84, 0x87430604, 0x21108206, 0x34850504, 0x87432382, 0x06062105, 0x83058743, 0x0405273a,
	0x09090304, 0x13820506, 0xcf830520, 0x09820820, 0x08070525, 0x86060706, 0x0806274a, 0x05070708, 0x63410905, 0x06052205, 0x20088304, 0x200d8406,
	0x20408404, 0x222c8208, 0x44070405, 0x0224059f, 0x08080202, 0x3c820a82, 0x82058743, 0x09092229, 0x08674804, 0x0b060334, 0x03030402, 0x05040104,
	0x07050805, 0x07080905, 0x00820806, 0x07217f85, 0x235c8403, 0x02040606, 0x2509ee44, 0x09050905, 0xf8820203, 0x00010227, 0x02090900, 0x29aa8202,
	0x05060808, 0x09040307, 0x82820709, 0x00830020, 0x05280782, 0x05060708, 0x06060608, 0x03820782, 0x06040523, 0x221e8306, 0x820c0506, 0x07082326,
	0xfd820708, 0x05205682, 0xa285ee83, 0x06208382, 0x0c842682, 0x06060624, 0x8f840605, 0x21056044, 0x4c820406, 0x84070721, 0x21ca8315, 0x0a820804,
	0x18824f85, 0x22057a45, 0x82050808, 0x820720c3, 0x215a8274, 0x3f820604, 0x4305e041, 0x062407b0, 0x07040505, 0x09827684, 0xe6820520, 0x05050726,
	0x0809070a, 0x19822983, 0x43065a42, 0x61421157, 0x230a840a, 0x02040204, 0x05915985, 0x6b823d91, 0x00870020, 0x02020222, 0x002dce82, 0x00060c0a,
	0x04020305, 0x07080606, 0x06874302, 0x65890420, 0x05222482, 0xe0820405, 0x87430620, 0x03042117, 0xe582d383, 0x87430283, 0x82042011, 0x02032116,
	0x06265085, 0x05050408, 0x11820803, 0x82040421, 0x0687439c, 0x7b820720, 0x00820620, 0x3a420920, 0x201b8206, 0x33874306, 0x2008b444, 0x22874305,
	0x8743f282, 0x43042009, 0x07220787, 0x87430506, 0x08092336, 0x60430507, 0x06032205, 0x20cc8202, 0x09874306, 0x0520e982, 0x220e8743, 0x43080608,
	0x07222687, 0x87430605, 0x83088205, 0x430e8256, 0xf2820a87, 0x15820820, 0x070a0a22, 0x0a200682, 0x241a8743, 0x04050707, 0x19874308, 0x430a0a21,
	0x09210a87, 0x0a87430c, 0x09050823, 0x07874307, 0x06060723, 0x08874305, 0x87430620, 0x050a2d0b, 0x0203030a, 0x01020306, 0x0a0a0000, 0x20088743,
	0x10874308, 0x43820a20, 0x03830920, 0x06080823, 0x4393830a, 0x0c820787, 0x82080a21, 0x050b421d, 0x060a0a23, 0x256c8205, 0x06040505, 0x87430805,
	0x06072a0c, 0x0607080a, 0x04040406, 0x21018306, 0x87430805, 0x4309201e, 0xa5431687, 0x05062205, 0x21638206, 0x67830708, 0x210a8743, 0x12820908,
	0x43050721, 0x0b306c87, 0x0600070e, 0x07050303, 0x03080906, 0x06060303, 0x2005af4e, 0x83008606, 0x05063411, 0x0707070a, 0x08050608, 0x07030308,
	0x09080a05, 0x82070906, 0x0907240d, 0x82070706, 0x20cd822e, 0x28038306, 0x02060604, 0x0a020502, 0x20008206, 0x072f4704, 0x44840883, 0x0627e782,
	0x06050409, 0x82060904, 0x06042704, 0x02030706, 0x53820404, 0x07050822, 0x09220084, 0x00820607, 0x00820320, 0x09080822, 0x06220083, 0x00820809,
	0x18821584, 0x050a0622, 0x02200583, 0x9b860082, 0x07210688, 0x43018406, 0x08220643, 0x19880806, 0x0b820620, 0x8305f545, 0x090e4e05, 0x03050727,
	0x05050702, 0x82ae8205, 0x05032203, 0x21248602, 0xdb820608, 0x0a230382, 0x8304070a, 0x07ca4401, 0xc6820520, 0x89040521, 0x20278249, 0x43738208,
	0x022005b4, 0x09237e82, 0x8206090a, 0x0606222c, 0x06874306, 0x07030729, 0x08090409, 0x84070409, 0x0908289b, 0x0a070703, 0x82090508, 0x0705219b,
	0x0f826482, 0x76422f82, 0x4a052005, 0x408305b6, 0x71840820, 0x08226882, 0xbc850604, 0x0306072b, 0x0a0a0303, 0x08060708, 0x224b8407, 0x82080609,
	0x080a2109, 0x07214a82, 0x29ab8205, 0x0b0b0808, 0x07070908, 0x3182070c, 0x26820420, 0x48830520, 0xb5430720, 0x43062005, 0x082805a7, 0x09050608,
	0x04060606, 0x0221f282, 0x20ab8202, 0x21238205, 0x43820904, 0x58820920, 0x0b0b0623, 0x060f4705, 0x0505052c, 0x05030d09, 0x01060303, 0x5c820604,
	0x0b060926, 0x09070909, 0x06210082, 0x84298307, 0x07062596, 0x02060606, 0x04200382, 0x06240085, 0x040b060b, 0x2e078743, 0x02020b0b, 0x0a080707,
	0x0906070a, 0x820a0404, 0x0708226b, 0x83008300, 0x840b208a, 0x060723b9, 0x2183080a, 0x08219382, 0x24168209, 0x0b0e0608, 0x82688209, 0x8205201d,
	0x06062155, 0x0784d082, 0x0704052b, 0x06080906, 0x07060705, 0x2d018205, 0x09060807, 0x090a0b07, 0x05050707, 0x85840706, 0x82090a21, 0x82428249,
	0x030721a3, 0x14820b82, 0x2205a541, 0x8303070a, 0x0a092121, 0x4583c585, 0x4105fa4a, 0xd64405e0, 0x23398206, 0x08090406, 0x06206783, 0x09280082,
	0x0609090a, 0x0b090a06, 0x08212e82, 0x84778407, 0x90072067, 0x0a614205, 0x03230a84, 0x85020302, 0x84059159, 0x82072090, 0x850384a7, 0x0006214b,
	0x250a0f47, 0x00040506, 0x87430f0c, 0x07082b05, 0x0403080a, 0x03070704, 0x05820304, 0x00860720, 0x82030321, 0x06874308, 0x08080623, 0x21dc8204,
	0xf483090b, 0x54820720, 0x1b820b20, 0x04040428, 0x07070506, 0x39820607, 0x03070625, 0x83030603, 0x04072815, 0x05070406, 0x82050609, 0x82042006,
	0x274d8415, 0x040a0706, 0x0a040706, 0x04262f82, 0x08070704, 0x3b820203, 0x09090923, 0x231d8405, 0x06070a07, 0x4f820082, 0x86430420, 0x20658205,
	0x85008208, 0x2105821c, 0x0482060b, 0x92844b82, 0xa0411588, 0x410e8405, 0xf083062c, 0x43093741, 0xaf82083b, 0xdd83d982, 0x07210382, 0x82458206,
	0x25ae826d, 0x04060306, 0x6c820306, 0x07090723, 0x23068508, 0x0b0b0709, 0x41058743, 0x04200880, 0x4a410f83, 0x21078307, 0x7982090b, 0x03201e85,
	0x0a207d82, 0x0d820f82, 0x03220982, 0x8d840207, 0x09070323, 0x43dc8206, 0x08820887, 0x09212382, 0x821c8308, 0x05a04366, 0x46821482, 0x07050624,
	0x04820407, 0x82060621, 0x820620a4, 0x83398310, 0x2007821a, 0x221a8206, 0x820b0304, 0x211b823a, 0x72420707, 0x21a98205, 0x4a87080b, 0x0b080829,
	0x070a080b, 0x82070c07, 0x06052100, 0x26827682, 0x0d82cc82, 0x05050623, 0x82408209, 0x0709221f, 0x22228206, 0x82060507, 0x820320f8, 0x226d83dd,
	0x83090b05, 0x21148201, 0x87430c0c, 0x030f2f0b, 0x06040405, 0x07070402, 0x060a070a, 0x87430a0d, 0x07072505, 0x07070808, 0x2207ac41, 0x43030707,
	0x0c2d0a87, 0x03040c06, 0x02030702, 0x0c000001, 0x2109820c, 0x63820907, 0x04090724, 0xb8820b05, 0x00080922, 0x06230083, 0x82070709, 0x2303840d,
	0x07070a0a, 0x062b0382, 0x07090909, 0x05080508, 0x82090d0e, 0x820b2017, 0x070621a5, 0x0c200082, 0x06820982, 0xa5820720, 0x090a0723, 0x21f48207,
	0x05820607, 0x07080726, 0x0b0c0809, 0x07201183, 0x22057445, 0x82080a06, 0x26178240, 0x080a080a, 0x41090904, 0x0b2309a1, 0x82070409, 0x0b0a2400,
	0x83090706, 0x83092001, 0x84098441, 0x06d9430f, 0x82080521, 0x090a2163, 0x5f826782, 0x5b849e82, 0x830a0b21, 0x21ad827f, 0x66420806, 0x43098e09,
	0x04220f98, 0x43420403, 0x87638906, 0x84082009, 0x05f444b7, 0x82056947, 0x870020bd, 0x02023200, 0x04070702, 0x08100d00, 0x04030700, 0x0b070805,
	0x07874309, 0x42061843, 0x058205f6, 0x080b0623, 0x2bef8208, 0x05090906, 0x0b060803, 0x0a070a09, 0x0922a182, 0x1b820b07, 0x04050423, 0x203c8207,
	0x26b38208, 0x03080704, 0x83030603, 0x05082a2c, 0x06080406, 0x0606070a, 0x43738205, 0x062c06d8, 0x06050b08, 0x070b0407, 0x05050706, 0x03285082,
	0x06050503, 0x060a0a0a, 0x02825d82, 0x07080b22, 0x05200082, 0x09210082, 0x20158209, 0x2065820a, 0x21008209, 0x17840707, 0x43070721, 0x2f850987,
	0x0883de82, 0x82080621, 0x200b827a, 0x07714307, 0x3541f083, 0x08164109, 0x08090822, 0x83057b51, 0x06082205, 0x21c98203, 0x87430606, 0x821e8209,
	0x08092238, 0x2301840a, 0x05080c0c, 0x87430183, 0x074a410d, 0x0b200783, 0x0720dc82, 0x04201e85, 0x0b26a182, 0x07080a0b, 0x87820806, 0x02080322,
	0x08299683, 0x060a0803, 0x040a090a, 0x29be8408, 0x08050a09, 0x07090b08, 0x9a83090a, 0x0a22da82, 0xb0820705, 0x2a820420, 0x0624c082, 0x06040808,
	0x06204582, 0x08200e85, 0x0b211f82, 0x220b8204, 0x820a070b, 0x05052615, 0x0a0c0c03, 0x21a18208, 0x0e820808, 0x09070b22, 0x0b218082, 0x824a8209,
	0x070a2a0e, 0x0d0d0909, 0x08080b09, 0x2b0d820d, 0x07070507, 0x08080609, 0x08090706, 0x06240082, 0x07090605, 0x2406a743, 0x07070b06, 0x07874308,
	0x06060827, 0x0b050608, 0x8201830a, 0x0d0d23c4, 0x774f0205, 0x10092108, 0x82058743, 0x247f834a, 0x080a0a0d, 0x2000820a, 0x43528208, 0xac410c87,
	0x05053f06, 0x070d0705, 0x0203040d, 0x01030307, 0x0d0d0000, 0x07080203, 0x080b0b0b, 0x05040a07, 0x3d820b0b, 0x83000921, 0x09072c00, 0x0a0d0807,
	0x090c0808, 0x820c0708, 0x0a0c25bc, 0x0a0a0607, 0x06251082, 0x0e0f0608, 0x821b820a, 0x0806281d, 0x08080807, 0x410a0c0d, 0x052005d1, 0x09214982,
	0x44148307, 0x08240580, 0x0b0d090a, 0x06223382, 0xb6820507, 0x07070624, 0x9441090b, 0x090b2505, 0x0b05090b, 0x0920f482, 0x1283a682, 0x42830e82,
	0x070b0b24, 0x01820a07, 0x45820b20, 0x1a840720, 0x4205e041, 0x0724092c, 0x060a0b05, 0x07256782, 0x0b080707, 0x23ae820c, 0x0d0b0d07, 0x0923a382,
	0x43060708, 0xdc4305e3, 0x43098909, 0x07240e96, 0x03050305, 0x05915985, 0x0a218e83, 0x84018709, 0x080622b7, 0x3c008700, 0x08030303, 0x0e000407,
	0x07000811, 0x09060404, 0x030a0c08, 0x08080404, 0x05040504, 0x83008808, 0x06082611, 0x0809090c, 0x21d0820a, 0x3382050a, 0x0b0a0c23, 0x055f4808,
	0x97820d20, 0x04050423, 0x05084307, 0x07040828, 0x07040408, 0x3c830d04, 0x82070521, 0x820a20da, 0x200883ad, 0x21568204, 0xe7820808, 0x07050c25,
	0x820c0508, 0x05052e2f, 0x04090808, 0x07050503, 0x060a0a0a, 0x20008409, 0x0887430c, 0x0b0a0a22, 0x08210083, 0x211c820b, 0x3983070a, 0x07214882,
	0x8209820c, 0x8504209e, 0x22a1884d, 0x43070807, 0x2441056b, 0x080a2107, 0x8205c441, 0x21128218, 0x0186070a, 0x7b511582, 0x08082309, 0x6e830403,
	0x0725ae82, 0x07050704, 0x063d4104, 0xd9820a20, 0x0c21dd83, 0x0687430d, 0x82076f41, 0x050721c6, 0x210b6241, 0x1a820a0d, 0x04287285, 0x0c070908,
	0x07080b0c, 0x0822a085, 0x00820803, 0x08040929, 0x090b060b, 0x8309040b, 0x0a08279d, 0x0908050b, 0xd2820a0c, 0x27820820, 0x0b226282, 0x3d820705,
	0x29820420, 0x06200782, 0x0720d782, 0x07210782, 0x05664908, 0x26108743, 0x080a0d0d, 0x82090a08, 0x07092568, 0x0a0a080b, 0x0b204b83, 0x07221282,
	0x16820b08, 0x090d0d26, 0x0f08090c, 0xb5824f82, 0x08202382, 0x1c820982, 0x05210682, 0x05874307, 0x080b0922, 0x08293782, 0x07070508, 0x0c040404,
	0x2483820c, 0x0d060708, 0x2601830a, 0x0e070707, 0x8203060e, 0x06063600, 0x06070706, 0x0603110c, 0x02070404, 0x0c080805, 0x0e070b08, 0x24c5820a,
	0x080b0b0b, 0x217f8209, 0x15820a08, 0x08205782, 0x0720b084, 0x3605f64f, 0x070e0705, 0x0204050e, 0x01030408, 0x0e0e0000, 0x08080304, 0x820d0c0b,
	0x060523a9, 0xeb820d0d, 0x30068743, 0x0d08080a, 0x0d08090b, 0x0c07090a, 0x0d09090a, 0x2093820c, 0x2557820a, 0x11070907, 0x1b820b0f, 0x080b0d22,
	0x21053f44, 0xbe840d0e, 0x05070826, 0x0a0b0809, 0x07201484, 0x0a200583, 0x0f210d82, 0x2211830c, 0x82070507, 0x82408300, 0x82082049, 0x05874317,
	0x45080921, 0x09260549, 0x050a0c08, 0x68820709, 0x08070c23, 0x2101830b, 0x35470809, 0x200d8406, 0x460d8308, 0x072505a7, 0x070b0c05, 0x300f8405,
	0x0c0c0c08, 0x0d07080b, 0x0a0c0e0c, 0x08090a08, 0x05704107, 0x2111e146, 0x664a0709, 0x25388408, 0x04050807, 0x59850405, 0x4b820591, 0x7a480820,
	0x42058305, 0x87430551, 0x0005320e, 0x0009120f, 0x07040408, 0x0b0c080a, 0x08050504, 0x46508208, 0x082006a0, 0x04210082, 0x2f048204, 0x0a0a0d06,
	0x08080a09, 0x04060b0a, 0x0b0d0709, 0x5a824e84, 0x08090e28, 0x05060508, 0xaf840608, 0x2a820820, 0x042b4882, 0x0909080d, 0x05070609, 0x430b0708,
	0x09200e87, 0x82058743, 0x05052eba, 0x040a0809, 0x07050503, 0x060b0b0b, 0x2000840a, 0x05c2450d, 0x06060623, 0x8214820a, 0x84082002, 0x204d8206,
	0x20008408, 0x0887430d, 0x09206e82, 0x08200082, 0x07213084, 0x22bb8209, 0x4a0a080a, 0xaa820853, 0x34841884, 0x3b430820, 0x080b2307, 0xc951080b,
	0x09042108, 0x0920f282, 0x87439d82, 0x053d4108, 0x06820a20, 0xdd830920, 0x4b0e0d21, 0x344105e6, 0x07072105, 0x41059543, 0x0e210b62, 0x41c6820b,
	0x04200584, 0x0d266482, 0x07090b0d, 0x99820907, 0x03090422, 0x092a9b82, 0x0c09040a, 0x0c0a0c07, 0x81830a04, 0x0623ca82, 0x820d0a09, 0x830b2040,
	0x2962829b, 0x0908060b, 0x08040807, 0xc0820909, 0x09080728, 0x08070704, 0x39820708, 0x08220e82, 0x3882080b, 0x0c20de82, 0x092a0982, 0x04060607,
	0x090b0f0e, 0xd9820b09, 0x080a0823, 0x244c820c, 0x0b0d0b09, 0x2212820b, 0x820b0908, 0x0e0e2616, 0x090a0d0a, 0x247c8210, 0x08080608, 0x8348830b,
	0x21608238, 0x0d830707, 0x0a0d0d2a, 0x0c07080b, 0x06080808, 0x20058743, 0x0587430d, 0x830b0e21, 0x21c48201, 0x87430f0f, 0x82082007, 0x04122227,
	0x08874307, 0x0f080c23, 0x0587430c, 0x0b0a0923, 0x205c8209, 0x82458206, 0x090922b4, 0x43088204, 0x08330687, 0x050f080f, 0x04080304, 0x00000203,
	0x03040f0f, 0x820c0809, 0x0c082573, 0x0e0e0605, 0x87433d82, 0x0b082205, 0x2e4c8208, 0x0b0d090a, 0x0a0d080a, 0x0c0e090a, 0x820b0708, 0x07092b54,
	0x10120709, 0x0c0d090b, 0x0b820c0f, 0x0f225c83, 0x63840b0e, 0x0a060824, 0xba820c08, 0xca820920, 0x0a070928, 0x0c080b09, 0x3f82100a, 0x41070921,
	0x09210579, 0x05994207, 0x09261782, 0x0c06090c, 0x74430a0b, 0x82082005, 0x820b2061, 0x2106823b, 0x1284080d, 0x6e824583, 0x09200b83, 0x5b439183,
	0x080a2507, 0x0b0d0608, 0x2506c142, 0x0e0e0e09, 0xa482090c, 0x0a20f384, 0xdd462f83, 0x46118511, 0x08860806, 0x06040623, 0x096b4304, 0x0820098e,
	0x83075642, 0x20b98617, 0x0a0f4700, 0x05080926, 0x0a141000, 0x2a058743, 0x040b0d09, 0x09090505, 0x46040504, 0x092006a0, 0x04210082, 0x25048204,
	0x0b0b0e07, 0xd0820b0a, 0x04060b26, 0x0c0e0809, 0x0a204e82, 0x0a270d82, 0x0908090e, 0x82050605, 0x820920d3, 0x04092809, 0x04040908, 0x820e0408,
	0x06092731, 0x08090507, 0xe582080c, 0x82060921, 0x82128315, 0x060d2122, 0x0d323082, 0x06090708, 0x0a090906, 0x06060304, 0x0c0c0c08, 0x00840b07,
	0x080a0e22, 0x06200082, 0x0b210082, 0x2010840c, 0x22058409, 0x840a0908, 0x0e09223d, 0x21908508, 0x0f850404, 0x08210586, 0x066c4409, 0x21087143,
	0xab480b09, 0x43058405, 0x1582083b, 0x21098743, 0x4582080a, 0xae826d82, 0x08040827, 0x0c040806, 0x21018309, 0x25820c0b, 0x0924dd82, 0x060a0f0e,
	0x88480183, 0x08052108, 0x5e410182, 0x0c0e210b, 0x61843e82, 0x82050821, 0x0e0e2134, 0x07207482, 0x8743a084, 0x040b3405, 0x0d070c0a, 0x0b050d0b,
	0x080a080b, 0x060b0b09, 0x820e0a09, 0x090b305e, 0x0d080809, 0x060b0d09, 0x09070908, 0x82090905, 0x0707261c, 0x08050909, 0x20188208, 0x05f34609,
	0x0c080b29, 0x0909050c, 0x83080c09, 0x0606283c, 0x0b0f0f04, 0x820b0a09, 0x224b827f, 0x820c090e, 0x0b0e2147, 0x0a2e0e82, 0x090d0a08, 0x10100a0b,
	0x0a0a0d0b, 0x31820a10, 0x09090625, 0x8209070b, 0x090b2197, 0xbe820082, 0x09080b25, 0x820e0e09, 0x0d0821d8, 0x06271082, 0x04040708, 0x830e0e04,
	0x0608236a, 0x01830c0e, 0x08080825, 0x47071010, 0x082a060f, 0x140c0708, 0x05050704, 0x4a820208, 0x0d090d28, 0x0b0d1008, 0x00820c0a, 0x0b0a0923,
	0x825c820a, 0x23478215, 0x040a0909, 0x06203782, 0x082e0085, 0x05100810, 0x04090304, 0x00000203, 0x09821010, 0x820c0921, 0x0d092173, 0x21068743,
	0x0083000a, 0x090c0827, 0x0b0d1009, 0x29b98209, 0x0b0c0e09, 0x090e0f09, 0x07820d07, 0x0822c482, 0x17821113, 0x0d100d22, 0x5d830b82, 0x820f1021,
	0x2708822b, 0x080b0608, 0x07090b0e, 0x082e7882, 0x0a0b0809, 0x0b0c090b, 0x0a0d0d11, 0x9841080a, 0x08092e05, 0x0a0b0b0d, 0x090b090a, 0x0a0d0a0d,
	0x41598306, 0x0a2005a3, 0x06206582, 0x0e220a83, 0x1d82080e, 0x45825c82, 0x81820920, 0x0d840c20, 0x43090b21, 0x0927085f, 0x0c0d0608, 0x820a0608,
	0x0909245f, 0x820f0e0e, 0x0e102382, 0x3b820e10, 0xb24e0a20, 0x0e534305, 0x2e833f86, 0x8743038b, 0x2033831c, 0x05044c0a, 0xba820b20, 0x00820820,
	0x20059a44, 0x32008200, 0x09030303, 0x11000508, 0x09000a14, 0x0b070404, 0x430c0e09, 0x0f201887, 0x0c2a4582, 0x0c0c0909, 0x080a0506, 0xf4820d0f,
	0x0d820b20, 0x090f0a2b, 0x06050a09, 0x0a070905, 0x21d78209, 0x87430609, 0x090f2a05, 0x060a0a0a, 0x08090608, 0x0e87430d, 0x060e0a37, 0x0e050908,
	0x06090709, 0x0b090a06, 0x06060304, 0x0d0d0d08, 0x822f8207, 0x0a0e2202, 0x20008209, 0x20008206, 0x8214820c, 0x0d092102, 0x4305ff41, 0x6e821087,
	0x00820a20, 0x2005a043, 0x827a8308, 0x085a4111, 0x0c0a0c22, 0x4e823186, 0x080c0922, 0x09220186, 0x8743090c, 0x080b2409, 0x430a0405, 0x0d210b87,
	0x20018309, 0x2004820b, 0x24dd820a, 0x0b0f0f0a, 0x43018306, 0x062108d0, 0x43018209, 0x058505ac, 0x820d0f21, 0x05cd411b, 0x88820520, 0x0d0e0e26,
	0x0a08090a, 0x04228782, 0xcf84030a, 0x0d0a0429, 0x0d0b0d08, 0x820b0a05, 0x0c0a251e, 0x0a0a060d, 0x0d203382, 0x0e289b84, 0x060d0e09, 0x09080a09,
	0x43833a82, 0x0a09082b, 0x09090805, 0x0b0a0808, 0x82cf820a, 0x0d0c21aa, 0x09211a82, 0x2809820d, 0x0606090a, 0x0c100f05, 0x82d6820a, 0x090b294b,
	0x0d0d0a0e, 0x0c0f0b0a, 0x0a2d4a82, 0x090e0a09, 0x11110b0c, 0x0a0b0e0b, 0x21688312, 0xf1820906, 0x38844982, 0x08080a22, 0x092efd82, 0x0b0f0f09,
	0x0e08090c, 0x06090909, 0x87430808, 0x0f072209, 0x8201830d, 0x111121c7, 0x21098743, 0x87430f06, 0x090e230b, 0xc5820e12, 0x72820d20, 0x0b0c0a22,
	0x07205c82, 0x22058543, 0x41040a0a, 0x200806ac, 0x09060606, 0x06110911, 0x05090304, 0x00000203, 0x03041111, 0x0f0d0a0a, 0x0d090a0f, 0x10100706,
	0x20b7820d, 0x82008300, 0x11092acd, 0x0f0a0b0e, 0x0f090a0c, 0x20b5820c, 0x2293820e, 0x830a0d0c, 0x121427f1, 0x0d0f0a0d, 0x0b820e11, 0x0a0a0926,
	0x0e10110a, 0xfa820683, 0x0c22ee82, 0x3743080a, 0x0a0b2705, 0x0b0d090c, 0x43820f12, 0x21470820, 0x08092f05, 0x0a0c0c0d, 0x090c090b, 0x0a0e0a0e,
	0xa1820e06, 0x0c220c83, 0x61820b09, 0x090a0627, 0x0e0e090a, 0x22778209, 0x820e090d, 0x080a2245, 0x210b830d, 0x01820d0a, 0x2009b445, 0x20368209,
	0x2c2b8209, 0x0a0a0809, 0x0d100f0f, 0x0e10090b, 0x212e8211, 0x77840b0d, 0x4d08d74d, 0x098309e1, 0x820c0a46, 0x0406230c, 0xe64b0406, 0x20059105,
	0x219f820c, 0x01870a0c, 0x44055242, 0x8743059a, 0x31e78206, 0x0b161200, 0x04050900, 0x0f0a0c07, 0x0505040d, 0x50820a0a, 0x20061843, 0x2100820a,
	0x04820404, 0x0b100833, 0x0a0c0b0b, 0x060d0c09, 0x10090a05, 0x0d0b0d0d, 0x21de820b, 0x9182100a, 0x05070523, 0x222f820a, 0x820b080b, 0x050b3706,
	0x10050905, 0x0b0b0a0b, 0x0b060907, 0x0a090d0a, 0x060a0608, 0x4483050a, 0x2c820a20, 0x0a060f25, 0x820f060a, 0x060626f1, 0x040c0b0a, 0x22068204,
	0x4a0d0d0d, 0x0b23057f, 0x820a0b0f, 0x0a874300, 0x1b820a20, 0x090d0d23, 0x2417840b, 0x080f0a0a, 0x2000820a, 0x20008205, 0x2111860a, 0x00820b0a,
	0x46086844, 0x0c2207f9, 0x1f870c0b, 0xfe872f82, 0x0620b383, 0x2708965d, 0x05050a0b, 0x0909090a, 0x0382ae82, 0x05090622, 0x03821e83, 0x0a210282,
	0x2301820d, 0x070b1010, 0x6e410183, 0x09062108, 0x24860182, 0x0d22fd82, 0xdc82100b, 0x2006fa43, 0x22828205, 0x820d0f0f, 0x43a0844f, 0x0b280587,
	0x080e0b04, 0x060e0c0e, 0x0b21be82, 0x21ca820a, 0x33820a06, 0x0b200782, 0x0e252782, 0x060d0e0a, 0x82b08209, 0x371c821d, 0x0a0b0808, 0x0b090906,
	0x0c0a0809, 0x080a080b, 0x0c0a0d0b, 0x0a0b060d, 0x0d280782, 0x06090b0a, 0x11100506, 0x0d200882, 0x0c22ed83, 0x44820e0a, 0x100c0a24, 0x0f820d0d,
	0x820b0921, 0x120c270d, 0x0b0f0c12, 0x4982130b, 0x82070a21, 0x0b08256a, 0x0e0a090b, 0x0b393e82, 0x0d0a0808, 0x100b0b09, 0x0a0e0c10, 0x0a0a0f08,
	0x0908070b, 0x0f050505, 0x24208210, 0x1007090b, 0x3901830d, 0x12090a09, 0x03030712, 0x06060304, 0x07080806, 0x0704150f, 0x02090606, 0x6a820a07,
	0x13090e26, 0x0e0b0d0e, 0x8d820082, 0x34456082, 0x820b2005, 0x43052000, 0x20080a87, 0x06120912, 0x050a0305, 0x00000204, 0x03051212, 0x100f0a0b,
	0x0e0a0b10, 0x11110706, 0x0c0d0a0d, 0x20008300, 0x28c2820a, 0x0b0c0e12, 0x0a0b0d10, 0x20078210, 0x23938211, 0x0a0d0c0e, 0x16280083, 0x110a0d13,
	0x0b0e120e, 0x21051350, 0x23821112, 0xc6820b20, 0x090b0725, 0x830a0d0e, 0x0a092414, 0x820b0c09, 0x130c2889, 0x0b0c0d0f, 0x82080908, 0x2313827e,
	0x0b0d0d0f, 0x0f2b1783, 0x060c0f0c, 0x0a0c0d0e, 0x820d0a0c, 0x23658226, 0x0a0b060e, 0x0f218782, 0x2777820a, 0x0d0e0a0d, 0x080a080a, 0x27431a83,
	0x20688305, 0x261f820b, 0x070a0b0c, 0x82090e0f, 0x090a2d67, 0x11100b0b, 0x090b0f10, 0x10130f12, 0x0c232582, 0x420c080a, 0x098e095c, 0x89053a46,
	0x05062305, 0x81430506, 0x82118611, 0x0c0d2190, 0xd8430187, 0x06e26d05, 0x00000038, 0x0b040404, 0x13000609, 0x0a000b17, 0x0c080405, 0x040d100a,
	0x87430606, 0x0c0c3616, 0x090a0d0c, 0x05060e0d, 0x0e110a0b, 0x0c0e0b0e, 0x0b0e0a0a, 0x24878211, 0x0a060706, 0x20d18208, 0x08874309, 0x0d821120,
	0x09080b2c, 0x0e0a0b06, 0x07080a0a, 0x8743070a, 0x0b0a3807, 0x0a0a0710, 0x080a1006, 0x0b06060a, 0x04040c0b, 0x0e0a0706, 0x82080e0e, 0x2102825d,
	0x87430c10, 0x820d2007, 0x83028214, 0x0e0e221b, 0x0787430a, 0x43091021, 0x6b431787, 0x0c092106, 0x0d200184, 0x2041f682, 0x060a4109, 0xb3820a20,
	0x87430b20, 0x090b240d, 0x84050a09, 0x0a062201, 0x221e8305, 0x820d0b0e, 0x25b58206, 0x11110a0e, 0x0183080c, 0x21080445, 0x01820a06, 0x05852485,
	0x830e1121, 0x82082063, 0x050826cb, 0x100a0c0a, 0x210f8210, 0x00820b09, 0x040b0522, 0xdd820582, 0x090e0b2b, 0x060f0d0f, 0x0b0a0c0c, 0x22ca820a,
	0x820c0b06, 0x0e0e2133, 0x62830c82, 0x0a060e22, 0x24098743, 0x060a0b09, 0x28268209, 0x0b0c0a09, 0x0b090a09, 0x242f840d, 0x0a0e0b0a, 0x2a5b820d,
	0x11050606, 0x0b0b0d12, 0x830b0c0e, 0x821020e9, 0x0d0b231c, 0x4a820e11, 0x0e325a82, 0x120c0e0a, 0x0c100c12, 0x0a0c140c, 0x0b070a0a, 0x87430e0a,
	0x09092109, 0x0b2d4082, 0x0d11110b, 0x0f090a0f, 0x070b0a0a, 0x09874309, 0x11080a23, 0x8201830e, 0x13133035, 0x04030308, 0x07070703, 0x0f070808,
	0x43080417, 0x0f260887, 0x0e0e130a, 0x00820e0c, 0x87437f82, 0x0c0c2309, 0x3445050b, 0x06062606, 0x0a130a06, 0x08874313, 0x0513132f, 0x100a0b03,
	0x0a0c1111, 0x1208060f, 0x20a08312, 0x82008300, 0x130b26f5, 0x110b0c0f, 0x2603820e, 0x130d0e0f, 0x82080a11, 0x0b0a2157, 0x16250182, 0x120b0e14,
	0x221d820f, 0x820b0c09, 0x12132200, 0x2905820e, 0x07090b0b, 0x0e100a0c, 0xe782080a, 0x090b092e, 0x0b0e0b0d, 0x10140c0f, 0x090c0c0e, 0x25069841,
	0x0d0d100a, 0x17840c0b, 0x060c0f25, 0x820d0e10, 0x820e20ef, 0x2361820e, 0x0a0c060e, 0x10213d82, 0x2077820a, 0x2145840e, 0x1a83090a, 0x11828f82,
	0x4a090c21, 0x0c280527, 0x10070a0b, 0x0b07090f, 0x0b32cd82, 0x1111110b, 0x13090b0f, 0x0e111410, 0x0a0c0d0a, 0xc5460d08, 0x06624208, 0x87430f88,
	0x92598513, 0x820b2005, 0x4c0c2077, 0x0e210504, 0x4339850c, 0x0a380d87, 0x18140006, 0x050a000c, 0x0b0d0805, 0x06050e11, 0x050b0b06, 0x0b070506,
	0x05210088, 0x380a8205, 0x0c0d1109, 0x0a0b0e0c, 0x06070d0e, 0x0e110a0b, 0x0c100c10, 0x0c0d0b0b, 0x201b8212, 0x2e128206, 0x0c0b0c08, 0x070a0c09,
	0x05050c0b, 0x8213050a, 0x080c280d, 0x0a0c0709, 0x820a0a0f, 0x0b0721e1, 0x0b3b4484, 0x110c090b, 0x060b0a07, 0x0b090a11, 0x0c0c0707, 0x0704050d,
	0x0f0f0a07, 0x840d090f, 0x82112000, 0x820b2053, 0x07072419, 0x83100e0e, 0x100b2100, 0x0b211783, 0x2217840c, 0x43110b0b, 0x0b200887, 0x1a821186,
	0x01450c20, 0x0b0d2107, 0x25058543, 0x0c0e090c, 0x64410c0e, 0x21058305, 0x01850b0e, 0x0d0c0d25, 0x8705070c, 0x0a0d2601, 0x0a0b0506, 0x0a87430a,
	0x23052741, 0x0b100c0e, 0x12230183, 0x83080c12, 0x081c4c01, 0x820b0721, 0x09d44401, 0x0f20fb82, 0x1e855d82, 0x0d0b0631, 0x1011110b, 0x0c090b0b,
	0x050c0b0c, 0x820c040c, 0x050d2900, 0x11090f0d, 0x0d06110d, 0x0b2a1382, 0x07100d0b, 0x0e110c0b, 0x0e82100b, 0x0f0b0b24, 0x0f830f0b, 0x060c0822,
	0x0b2f2982, 0x0c09080b, 0x0a0a060b, 0x0b090a0c, 0x82090c0d, 0x0a0d2446, 0x82060f0f, 0x820f2037, 0x0b0c2bbc, 0x13060707, 0x0c0b0e13, 0x5f820d0d,
	0x0b276a82, 0x0d0b0e0e, 0x83100d11, 0x0f0c2d0e, 0x130d0d0b, 0x0c100d13, 0x0b0c150d, 0x2d084a82, 0x080f0a0b, 0x0b0a0c0c, 0x0c0b0c0e, 0x0a09090c,
	0x0c0c0a0f, 0x100e1111, 0x0b11090b, 0x09080c0a, 0x05050509, 0x0a0c1111, 0x08090c0a, 0x01830f12, 0x0a0a0b26, 0x04081414, 0x08390082, 0x0a0a0808,
	0x05170f08, 0x0a060608, 0x0b0b0703, 0x0a100b0f, 0x0c100f14, 0x2200820f, 0x820e0c0c, 0x080e2160, 0x0b216482, 0x23b6820b, 0x0a0a0a05, 0x0806c652,
	0x0a140a21, 0x03050714, 0x0204050b, 0x14140000, 0x0b0c0405, 0x0d131111, 0x0807100b, 0x0b101212, 0x83000d0f, 0x0e0b2400, 0x82130c0a, 0x0e123db4,
	0x0f120b0d, 0x11130d0f, 0x0f0f080b, 0x0a0c0b10, 0x15180a0c, 0x10120c10, 0x090c1013, 0x0c24b683, 0x0c0e1314, 0x0a270083, 0x110a0c08, 0x82080b0f,
	0x0b0a2e78, 0x0d0c0d0a, 0x150e0f0c, 0x0c0c0f11, 0x053b5209, 0x1d820b20, 0x830d0d21, 0x0d102717, 0x11070d10, 0x7a460d0f, 0x0e112208, 0x240c8307,
	0x0a0b1111, 0x8301820f, 0x090b2245, 0x41c3820e, 0x0d2105e0, 0x05594309, 0x0b0c0d25, 0x83101008, 0x0a0b2567, 0x12120c0c, 0x09282782, 0x12131113,
	0x0e0e0b0f, 0x4905c255, 0x0b890b04, 0x85096042, 0x05072309, 0x59850507, 0xb7840591, 0x860f0d21, 0x482f8501, 0x00200522, 0x043c0082, 0x0b0c0404,
	0x1a150007, 0x050b000d, 0x0c0e0806, 0x06040f11, 0x060c0c06, 0x0c080607, 0x11830088, 0x12090c22, 0x0e2cec82, 0x0f0e0a0b, 0x0a0c0608, 0x0c0f0f12,
	0x0a2df082, 0x0b130c0f, 0x08060b0c, 0x0c090b06, 0x20d5820b, 0x0887430b, 0x08273d82, 0x0b0c0709, 0x820b0b10, 0x0c072206, 0x82568205, 0x0c0a2713,
	0x0c0a0711, 0x2f821107, 0x0c070725, 0x43060e0c, 0x12220d87, 0x00820b0d, 0x00820820, 0x840f0e21, 0x850c2000, 0x430c2005, 0x12210675, 0x211e820a,
	0x0082050b, 0x02894b82, 0x0b0c0b22, 0x20061e41, 0x05fb460a, 0x0e0c0e22, 0x2f833186, 0x21058543, 0xb3820b0e, 0xf5540c20, 0x24058305, 0x05060b0d,
	0x0b87430c, 0x0f221e83, 0x06850e0c, 0x1422d982, 0x0183080d, 0x23056843, 0x070a090b, 0x1d870183, 0x13220783, 0x79820c10, 0x20830920, 0x0d0c0627,
	0x0f12120b, 0x21d7820c, 0x87430c0c, 0x0d062908, 0x0e100a10, 0x0d0d0611, 0x0b272782, 0x0c080f0f, 0x820f120d, 0x0b0c2607, 0x0b100c0a, 0x250f8210,
	0x060c090c, 0x1e820c0c, 0x0c090925, 0x820a060c, 0x0c0a2426, 0x820a0c0d, 0x820f2016, 0x201a821f, 0x822f820c, 0x080829dc, 0x0f141306, 0x0d0f0c0c,
	0x0e222c82, 0x4483120b, 0x0f120e27, 0x0d0c0f0f, 0x284a820a, 0x14140e0f, 0x0d0d110e, 0x24498215, 0x0b0c080b, 0x214d820f, 0x2f820c0a, 0x0a0c0c26,
	0x0b0f0b09, 0x2d068743, 0x0b0b120a, 0x090a080c, 0x11050505, 0x6d820c12, 0x13080a23, 0x25018310, 0x150b0b0c, 0x87430915, 0x12092308, 0x87430419,
	0x0c0c2a05, 0x0b110c10, 0x0d0f1115, 0x20008210, 0x8352840c, 0x0c0c21b6, 0x0c225382, 0x34450b05, 0x07220805, 0x150b0707, 0x0507150b, 0x04060c04,
	0x15000002, 0x0d040515, 0x1312110c, 0x07100b0d, 0x0f131308, 0x8743100c, 0x318a8206, 0x0c0d1114, 0x0b0d0f13, 0x0d0e0f12, 0x090b1114, 0xa7821010,
	0x0b0c0b28, 0x0d10161a, 0x1d821113, 0x0c0d0a22, 0x15220082, 0x05821014, 0x0820bf82, 0x0b352a83, 0x0c0b0d09, 0x0e0a0c0a, 0x110c0f0d, 0x1012160e,
	0x0a0a0d0d, 0x23848209, 0x110b0b0b, 0x0e204882, 0x11249982, 0x080e110e, 0x0b205582, 0x0f250c83, 0x120c0e0c, 0x823b820f, 0x0b12233d, 0x01820f0b,
	0x0b0f1225, 0x410a0b09, 0x0d2309c0, 0x830b0c0a, 0x0c0e2601, 0x1011080b, 0x202b820a, 0x29d4820b, 0x10121212, 0x12140a0c, 0x42821215, 0x090b0e24,
	0x85430c0e, 0x460d2015, 0x088708a7, 0x08050823, 0x915d8905, 0x05024c09, 0x77850583, 0x2a0d8743, 0x1600070a, 0x0b000d1a, 0x83080606, 0x070422b9,
	0x15874307, 0x0e0d132e, 0x0b0c0f0d, 0x06080f0f, 0x10130b0d, 0xde824e83, 0x0c130d38, 0x08070c0c, 0x0d090c07, 0x0d0a0d0c, 0x0d0b070c, 0x060b0606,
	0x00820d14, 0x070a092e, 0x0b100b0d, 0x0c080a0b, 0x06060c08, 0x0c3a2882, 0x120d0b0c, 0x070c0b07, 0x0c090b12, 0x0d0d0707, 0x0705060e, 0x10100b08,
	0x2f820910, 0x13210282, 0x2025830d, 0x20008208, 0x8214820f, 0x100c2202, 0x2100820f, 0x17840d0c, 0x120c0c23, 0x201f830a, 0x85008206, 0x8374822f,
	0x08014508, 0x24058543, 0x0d0f0a0d, 0x8331860f, 0x0b0f212f, 0x15820186, 0x21085b63, 0x93820d06, 0x0b0b0d22, 0x23058c51, 0x060b070b, 0x20052741,
	0x2506850f, 0x15140d10, 0x0183090d, 0x2008f644, 0x20248207, 0x07d24407, 0x13240783, 0x0c0b0c10, 0x2a055345, 0x0c0d0c06, 0x0d101213, 0x820d0a0b,
	0x0d062293, 0x2a9f8404, 0x0a110d06, 0x07110f11, 0x820c0e0d, 0x100f248e, 0x820d0d08, 0x0f102233, 0x2537820d, 0x10100c10, 0xb0820c08, 0xf7820720,
	0x0a0d0b27, 0x070d0d0a, 0x22c8820b, 0x840e0d0a, 0x831f83c5, 0x0c102c1a, 0x0b0d0c0f, 0x14060808, 0x820d0f15, 0x224b82c0, 0x82120c0e, 0x0f0d233c,
	0x4a820f13, 0x0d0b0d22, 0x0f362282, 0x120f1616, 0x0d170d0e, 0x090c0d0c, 0x0a100c0c, 0x0c0b0d0d, 0x00820d10, 0x0b0a0a38, 0x0d0d0b10, 0x110e1414,
	0x0c130a0c, 0x0a090d0c, 0x0606060a, 0xfb821312, 0x090a0d22, 0x08088743, 0x09161620, 0x04050404, 0x0b080808, 0x1a12080b, 0x07070804, 0x0c08030b,
	0x120c110c, 0x1011160b, 0x0082110e, 0x7f820d20, 0x430c0c21, 0x5a820587, 0x43060c21, 0x16240a87, 0x0607160b, 0x34068743, 0x04061616, 0x13120c0d,
	0x110c0d14, 0x14140907, 0x0e100d10, 0x27008300, 0x0d0c100c, 0x0d0e1116, 0x0c2b1182, 0x0e0e1113, 0x0a0c1214, 0x82101010, 0x0b0d29ac, 0x0e11171a,
	0x12161115, 0x0c20fd82, 0x16215c82, 0x22be8415, 0x82090b0d, 0x0c1022ee, 0x050f430a, 0x81820e20, 0x170f1128, 0x0d0e1013, 0x214a0b0a, 0x120b2205,
	0x0594410f, 0x120e1228, 0x1012080e, 0x01820c0f, 0x9f410d20, 0x0d082605, 0x130c0d0c, 0x82b38212, 0x82122014, 0x206e8245, 0x07e0410d, 0x0b216882,
	0x3e01820d, 0x090c0d0f, 0x090b1112, 0x0b0c0c0d, 0x13140d0d, 0x0b0d1114, 0x13161216, 0x0f0f0d10, 0x4d0f0a0c, 0x0a4908d5, 0x200b830b, 0x22008e0c,
	0x42080608, 0x71430643, 0x83098709, 0x0e10218e, 0x87430187, 0x059a4405, 0x00820020, 0x0505053a, 0x00070b0d, 0x000e1c17, 0x0806060c, 0x10130d0f,
	0x0d070704, 0x0607060d, 0x20061843, 0x2100820d, 0x04820606, 0x0e140a38, 0x0c100e0e, 0x0810100b, 0x140b0d06, 0x110d1111, 0x100c0c0e, 0xbd82140d,
	0x43090721, 0x0b2b0587, 0x0c080c0d, 0x0b06060e, 0x820e1406, 0x0a092532, 0x110b0e08, 0x20058743, 0x2044840d, 0x35e8820d, 0x0d0b0813, 0x0a0c1307,
	0x0d08080d, 0x05060f0e, 0x110b0808, 0x074e1111, 0x140e2105, 0x0c225382, 0x0082080c, 0xf07d1020, 0x110d2205, 0x21008210, 0x17840d0c, 0x130c0c23,
	0x0887430b, 0x61820e20, 0x0e200283, 0x0b230082, 0x4a0e0b0d, 0x814a0554, 0x41fe8306, 0x10210925, 0x2201860c, 0x430e100e, 0x0e200987, 0x240c8743,
	0x11060b08, 0x2001830e, 0x20048210, 0x24dd820d, 0x0e15140d, 0x4c018309, 0x08210816, 0x4101820c, 0x1023094c, 0x4311140e, 0x07200887, 0x1423a182,
	0x820d1113, 0x0d0d22d7, 0x0687430d, 0x0e060e32, 0x0f120b12, 0x0e0e0812, 0x0c0c0d0c, 0x0d081110, 0x11213383, 0x3c0c8210, 0x120d120c, 0x0d0c0811,
	0x0e080e0a, 0x0d0b0e0d, 0x0d0e0a0a, 0x0e0c0b08, 0x0f0d0b0b, 0x250e820d, 0x110c100e, 0x1a820810, 0x0e2bba83, 0x0608080c, 0x0d101615, 0x820e100d,
	0x820f2068, 0x1111273c, 0x10140f0d, 0x0e821011, 0x0d120d2b, 0x16160f10, 0x0e0e130f, 0x24688218, 0x0c0d090d, 0x05b74a10, 0x0d372c82, 0x100b0a0b,
	0x140d0e0b, 0x0d121014, 0x0c0c130b, 0x0a0b090e, 0x82060606, 0x0b0b26dd, 0x14090b0e, 0x82018311, 0x171721c7, 0x36078743, 0x120a0a0a, 0x0808041b,
	0x08030b08, 0x0d110d0d, 0x12170c12, 0x82110e11, 0x217f8400, 0x1b42100d, 0x0e0e2405, 0x410c060d, 0x2b8205ac, 0x0c170c35, 0x04060817, 0x0205060d,
	0x17170000, 0x0c0e0406, 0x82141412, 0x09082804, 0x0d111515, 0x83000f11, 0x110c3400, 0x12160e0c, 0x10150d0e, 0x11140c0e, 0x13160e10, 0x82120b0d,
	0x0b0d2fca, 0x181c0b0d, 0x12150f12, 0x0b0e1316, 0x00820d0e, 0x11161722, 0x0b270784, 0x120d0e09, 0x820b0d10, 0x302482d9, 0x0e100d0f, 0x14181012,
	0x0b0e0e11, 0x0b0c0a0c, 0x2313820c, 0x0e0f1013, 0x13261783, 0x080f130f, 0xf2421012, 0x0d0f2607, 0x0e081114, 0x8268820c, 0x0c1023f5, 0x45830c10,
	0x820b0d21, 0x820e20c9, 0x110d238f, 0x3b820e0d, 0x21078743, 0xf9461213, 0x140d2c06, 0x0e131514, 0x1714160c, 0x820d1115, 0x0f0b224b, 0x9343830d,
	0x0e864303, 0x06080c24, 0x59850608, 0x10250591, 0x110e100e, 0x4301870f, 0x0c231387, 0x43180008, 0x0a210587, 0x24b98210, 0x0d070705, 0x4350820d,
	0x20081087, 0x0e0f0f15, 0x110c0d10, 0x0e070911, 0x1212150c, 0x0d0e120e, 0x150e110d, 0x070d0d0d, 0x0a0d0709, 0x2ad7820e, 0x0d080d0e, 0x0c06060e,
	0x820e1606, 0x0b0a2b00, 0x120c0e08, 0x090b0c0c, 0x8743090d, 0x0c0d3a06, 0x0c08140e, 0x0c14080d, 0x08080d0a, 0x06100e0e, 0x0c080805, 0x0a121212,
	0x2100840f, 0x4e820e14, 0x82090d21, 0x12102100, 0x0d220084, 0x00821112, 0x840e0d21, 0x0d0d2317, 0x18440b14, 0x06062105, 0x02835f82, 0x2205ce51,
	0x450c0e0c, 0x814a0512, 0x43f68307, 0x068206a7, 0x24081641, 0x090e110e, 0x27018706, 0x06070c0f, 0x0c0c0c0e, 0x0382ae82, 0x060c0822, 0x1222d283,
	0x0685100e, 0x150e1223, 0x056e4f16, 0x21089648, 0x01820d08, 0x43821120, 0x15240387, 0x0d0c0d12, 0x07291e85, 0x140d0f0d, 0x0d0e1214, 0x24aa820b,
	0x040e060e, 0x3300820e, 0x120e060f, 0x1310130b, 0x0d0f0f08, 0x110d0d0e, 0x0f0e0912, 0x12213382, 0x260c8211, 0x130d130d, 0x820d0912, 0x820820b0,
	0x0e0c2d29, 0x0e0e0b0b, 0x0e0c0c08, 0x0f0e0b0c, 0x1023c584, 0x8312120d, 0x0d12351a, 0x0d0e0d11, 0x16070909, 0x0e0e1117, 0x0f0e0f11, 0x140d100d,
	0x0e341c82, 0x12111510, 0x0d0e0e11, 0x110d130e, 0x10171710, 0x190e0f14, 0x0d290d82, 0x100d0d0a, 0x0c0e0e0b, 0x281c820d, 0x0a0b0e0e, 0x0e0c100c,
	0x0587430e, 0x0d0d1426, 0x0b0b0a0e, 0x83058743, 0x150a226d, 0x08018312, 0x0c0c0d23, 0x040a1818, 0x09040504, 0x0b0b0909, 0x051c120a, 0x0c08080a,
	0x0d0d0803, 0x0c130d12, 0x0f121318, 0x82008212, 0x22ba827f, 0x820d0911, 0x430f2000, 0x18220e87, 0x8743180c, 0x18183108, 0x0d0e0406, 0x0f161514,
	0x0a08130d, 0x0e121616, 0x82068743, 0x170e334d, 0x150e0f13, 0x150d0f11, 0x170e1112, 0x130b0d14, 0xac821212, 0x1c0c0e32, 0x160f1319, 0x0e131713,
	0x0e0d0f0b, 0x17180e0e, 0x07821682, 0x0f0a0c26, 0x0d10140d, 0x2b060f43, 0x0e110e10, 0x15191012, 0x0b0e0f12, 0x0c21e882, 0x2301820d, 0x0e101114,
	0x13291783, 0x090f130f, 0x0d101014, 0x22f98210, 0x82100e11, 0x0f092265, 0x823d820d, 0x0d1122f5, 0x21458411, 0xde410b0d, 0x455d8207, 0x103906bc,
	0x140a0d0e, 0x0e0a0c12, 0x0e0c0d0d, 0x1515150e, 0x170c0d13, 0x11151814, 0x21a5820e, 0xd54d100b, 0x0b0a4908, 0x60420b83, 0x22098509, 0x42090609,
	0x63890643, 0x4b820987, 0x470a8743, 0x22480559, 0x82002005, 0x05052600, 0x080d0e05, 0x20008200, 0x22038603, 0x8401001c, 0x0024220e, 0x24098303,
	0x04002e05, 0x08208303, 0x800092a0, 0x12000600, 0x61017e00, 0x92017f01, 0xb001a101, 0xff01f001, 0xbc021b02, 0xc902c702, 0xf302dd02, 0x03030103,
	0x0f030903, 0x8a032303, 0xa1038c03, 0xd203ce03, 0x0d04d603, 0x5f044f04, 0x91048604, 0x011e1305, 0x851e3f1e, 0xf91ef11e, 0x0b204d1f, 0x1e201520,
	0x26202220, 0x33203020, 0x3c203a20, 0x7f204420, 0xa720a420, 0x0521ac20, 0x16211321, 0x26212221, 0x5e212e21, 0x06220222, 0x12220f22, 0x1e221a22,
	0x48222b22, 0x65226022, 0x04fbca25, 0xfdfffffe, 0x0000ffff, 0xa0002000, 0x93826201, 0xaf01a022, 0xfa229382, 0x93821802, 0x9382c620, 0x9382d820,
	0x93880020, 0x93828420, 0xa3038e24, 0x9382d103, 0x0e040034, 0x60045004, 0x92048804, 0x3e1e001e, 0xa01e801e, 0x9382f21e, 0x13200026, 0x20201720,
	0x32229384, 0x93863920, 0x9382a320, 0x938cab20, 0x93865b20, 0x938a1120, 0x93826420, 0x93820120, 0xfffffc32, 0xc2ffe3ff, 0xb0ff0000, 0xb200bf00,
	0x49ff6100, 0x26080b82, 0xfe85fe96, 0xff76fe84, 0xff63ff68, 0x005dff62, 0xfd44ff67, 0xfdcffdd0, 0xfecdfdce, 0x007ffe82, 0x009afd00, 0x820cfe00,
	0x09550803, 0x18e458e4, 0x7de47ae3, 0x0de30000, 0xefe142e2, 0xede1eee1, 0xe1e1eae1, 0xdbe1e0e1, 0xd3e1dae1, 0x76e199e1, 0x000074e1, 0x0be118e1,
	0xfee009e1, 0xf4e0fbe0, 0x25e0c8e0, 0x1ae022e0, 0x12e019e0, 0x03e00fe0, 0xd0dfe7df, 0x69dccddf, 0x4f030000, 0x01005302, 0x20008300, 0x8604838e,
	0x86be2003, 0x20069907, 0x201a82a4, 0x200382bc, 0x870382d8, 0x87e02002, 0x20079408, 0x8f1594d2, 0x85b02014, 0x03b30810, 0x01840383, 0x01270126,
	0x01290128, 0x012b012a, 0x012d012c, 0x012f012e, 0x01310130, 0x01330132, 0x01350134, 0x01370136, 0x01390138, 0x013b013a, 0x013d013c, 0x013f013e,
	0x01410140, 0x014a0149, 0x02250124, 0x019c0168, 0x019e019d, 0x01a0019f, 0x01a201a1, 0x01a401a3, 0x01a601a5, 0x026902a7, 0x01ea016a, 0x01ec01eb,
	0x01ee01ed, 0x01f001ef, 0x01f201f1, 0x01f401f3, 0x016b02f5, 0x02f701f6, 0x02940293, 0x02960295, 0x02980297, 0x019a0299, 0x02f901f8, 0x03010200,
	0x0370036f, 0x03720371, 0x03740373, 0x021c0275, 0x02350234, 0x005e025d, 0x830a0206, 0x000121b9, 0x83064d41, 0x2203850c, 0x82020001, 0x210b8301,
	0x009d0002, 0x08058741, 0x040003bc, 0x06000500, 0x08000700, 0x0a000900, 0x0c000b00, 0x0e000d00, 0x10000f00, 0x12001100, 0x14001300, 0x16001500,
	0x18001700, 0x1a001900, 0x1c001b00, 0x1e001d00, 0x20001f00, 0x22002100, 0x24002300, 0x26002500, 0x28002700, 0x2a002900, 0x2c002b00, 0x2e002d00,
	0x30002f00, 0x32003100, 0x34003300, 0x36003500, 0x38003700, 0x3a003900, 0x3c003b00, 0x3e003d00, 0x40003f00, 0x42004100, 0x44004300, 0x46004500,
	0x48004700, 0x4a004900, 0x4c004b00, 0x4e004d00, 0x50004f00, 0x52005100, 0x54005300, 0x56005500, 0x58005700, 0x5a005900, 0x5c005b00, 0x5e005d00,
	0x60005f00, 0xe0826100, 0x0086de08, 0x00890087, 0x0093008b, 0x009e0098, 0x00a200a3, 0x00a600a4, 0x00a700a5, 0x00ab00a9, 0x00ac00aa, 0x00af00ad,
	0x00b000ae, 0x00b300b1, 0x00b400b5, 0x00b800b6, 0x00bc00b7, 0x00bd00bb, 0x000d02be, 0x00640072, 0x02690065, 0x0078000f, 0x007000a1, 0x0020026b,
	0x026a0076, 0x00880030, 0x002d029a, 0x02310273, 0x00670032, 0x02270277, 0x0129022a, 0x002e028d, 0x027c006c, 0x00a80021, 0x008100ba, 0x026e0063,
	0x0242012c, 0x0028022f, 0x027d006d, 0x00620010, 0x00850082, 0x01140197, 0x02020215, 0x020a0203, 0x0206020b, 0x02b90007, 0x01c10033, 0x0217023a,
	0x0214021c, 0x02340215, 0x000e0235, 0x02080279, 0x0011020c, 0x008c0084, 0x008d0083, 0x008f008a, 0x00910090, 0x0095008e, 0x3ce18296, 0x009c0094,
	0x009b009d, 0x014b01f3, 0x01710052, 0x014f014e, 0x017a0050, 0x01510153, 0x1105104c, 0x57080803, 0x59454000, 0x53545558, 0x4f505152, 0x4b4c4d4e,
	0x4748494a, 0x43444546, 0x3f404142, 0x3b3c3d3e, 0x3738393a, 0x30313536, 0x2c2d2e2f, 0x25262728, 0x21222324, 0x1114181f, 0x0d0e0f10, 0x08090a0b,
	0x04050607, 0x00010203, 0x4623452c, 0x26b02060, 0x2604b060, 0x2d484823, 0x23210f83, 0x20108261, 0x22108a61, 0x8220b060, 0x8d462012, 0x20b02123,
	0x61203783, 0x298c1a82, 0x29824020, 0x298e6620, 0x29854020, 0x53884020, 0x20100135, 0x2d3c003c, 0x2345202c, 0x44cdb020, 0x01b82023, 0x8258515a,
	0x448d260b, 0xb0205923, 0x200b84ed, 0x210b844d, 0x0c842604, 0x0c820d20, 0x82212121, 0x20230831, 0x44681845, 0x6001b020, 0x46b04520, 0x458a6876,
	0x2c2d4460, 0x0a0bb101, 0x65432343, 0x002c2d0a, 0x820b0ab1, 0x820b200a, 0x28b02809, 0x01b17023, 0x84013e28, 0x28022808, 0x02b13a45, 0x820d0800,
	0xb0453644, 0x61452503, 0x5150b064, 0x1b444558, 0x2d592121, 0x0eb0492c, 0x82498223, 0x43002155, 0xb0245284, 0x07b04306, 0x20225284, 0xba82b069,
	0x208b0037, 0x8ac02cb1, 0x0010b88c, 0x0c2b6062, 0x61642364, 0x03b0585c, 0x3c3b8261, 0x8a45038a, 0x11b0878a, 0x2329b02b, 0x7a29b044, 0x2c2d18e4,
	0x2cb06545, 0xb0454423, 0x2155832b, 0x6788524b, 0x72894b20, 0x05b00129, 0x20231025, 0x8200f58a, 0xed2322ce, 0x8ac782ec, 0x86612011, 0x25062411,
	0x8300f510, 0x4624081c, 0x8a604623, 0x2023468a, 0x8a608a46, 0x80ffb861, 0x10202362, 0x0cb18a23, 0x45708a0c, 0x00b02060, 0x01b05850, 0xba2c1782,
	0x46b01b8b, 0x10b0598c, 0x3a016860, 0x462eec86, 0x13b04b52, 0xb0585b51, 0x20462502, 0xfe826168, 0x3f260282, 0x1b382123, 0xc0821121, 0x0322f582,
	0x3f824625, 0x002b1e95, 0xb04307b0, 0x2d0b4306, 0x8321212c, 0xb88b24f8, 0x82620040, 0x80b0230c, 0x0f855851, 0x6200202c, 0x4000b21b, 0xb0592b2f,
	0x19836002, 0x1987c020, 0x83551521, 0x87802019, 0x083e8819, 0x2123602d, 0x534b2c2d, 0x04b08a58, 0x23644925, 0x40b06945, 0x80b0618b, 0x6120b062,
	0x230eb06a, 0xb0102344, 0x211bf60e, 0x11128a23, 0x822f3920, 0x202b82a3, 0x28b48220, 0x20696449, 0xb02605b0, 0x8b358306, 0x04b02230, 0x20328326,
	0x2104828a, 0x3b824423, 0xb0234483, 0x821bed0e, 0x11262560, 0x23392012, 0x47834682, 0x45234523, 0x22028660, 0x82186876, 0x2d203071, 0x2b48b02c,
	0x45202c2d, 0x585400b0, 0x824440b0, 0x61402108, 0x23061642, 0x2f30b145, 0x61263182, 0x6001b060, 0xb1824469, 0xb0585129, 0xb070232f, 0x42422314,
	0x4b220537, 0x96835851, 0x53694523, 0x85328458, 0xb0452715, 0x00b04314, 0x35866360, 0x452fb022, 0x45253b82, 0x8a452023, 0x20088460, 0x33068345,
	0x5851234b, 0xff3300b9, 0x2034b1e0, 0x0033b31b, 0x44590034, 0x2c081d82, 0x584316b0, 0x452603b0, 0x6664588a, 0x1b601fb0, 0x6020b064, 0x1b582066,
	0x5940b021, 0x596101b0, 0x59655823, 0x442329b0, 0x29b01023, 0x236e82e0, 0x59212121, 0x022bc282, 0x4b585443, 0x514b2353, 0x8238585a, 0x84592015,
	0x83188319, 0x2504224e, 0x22468e45, 0x851b5823, 0x05b03046, 0x2508b025, 0x02582008, 0xb059031b, 0x82102504, 0x46202110, 0x23220882, 0x05823c42,
	0x2507b023, 0x23038208, 0x2506b010, 0xd1821584, 0x20241882, 0x001b0158, 0x86822d87, 0x2029b025, 0x86446545, 0x8c0f8327, 0x230c8254, 0x48432503,
	0x06244d87, 0x2503b025, 0x43244782, 0x59211b48, 0x0283bd82, 0x022c2d22, 0x20201e82, 0x23216284, 0x20828242, 0x21238208, 0x1a874845, 0x20250322,
	0x08221e82, 0x468202b0, 0x24081382, 0x23452c2d, 0x20184520, 0x205000b0, 0x23652358, 0x20682359, 0x585040b0, 0x5940b021, 0x59655823, 0x2d44608a,
	0x060c412c, 0x82452021, 0x0595410d, 0x58544b22, 0x2c410d8b, 0x2c2d240a, 0x822100b0, 0x8538201e, 0x02b02728, 0xb0585443, 0x43412b46, 0x200f8408,
	0x410f8447, 0xb021076b, 0x201e8e48, 0x820f8449, 0x8a202b1e, 0x534b2308, 0x5a514b8a, 0x50862358, 0xb9820020, 0x00b04924, 0xa6825853, 0x82113821,
	0x2c2d2ef6, 0x46234601, 0x61462360, 0x20102023, 0x05cf4346, 0x40b18a35, 0x45708a40, 0x2d3a6860, 0x238a202c, 0x238a6449, 0x843c5853, 0x524b262d,
	0x7a1b7d58, 0x08a78259, 0x4b00122a, 0x42544b01, 0x02b12c2d, 0x23b14200, 0xb1518801, 0x53880140, 0x10b9585a, 0x88200000, 0x02b25854, 0x60430201,
	0x24b15942, 0x58251b82, 0x000020b9, 0x20158440, 0x83158302, 0x20228314, 0x830c8320, 0x82522049, 0x8408202f, 0xb91b252f, 0x80000040, 0x04202a84,
	0x0f841084, 0x01b86323, 0x85138400, 0x24138224, 0xb8630001, 0x20138502, 0x20278710, 0x20138202, 0x20138504, 0x20138440, 0x38008259, 0x18452c2d,
	0x514b2368, 0x45202358, 0x40b06420, 0x597c5850, 0x59608a68, 0x24c58244, 0x02b01600, 0x37028225, 0x2301b001, 0x02b0003e, 0x01b13e23, 0xb00c0602,
	0x4265230a, 0x42230bb0, 0x3f201783, 0x3f201783, 0x06201785, 0x07311783, 0x01b04223, 0x2c2d0116, 0x45108a7a, 0x2d18f523, 0x08db8200, 0xf809105c,
	0x8f1fff03, 0x02f79ff7, 0x6001f37f, 0xffb801f2, 0xeb2b40e8, 0xdf46100c, 0xde55dd33, 0x3055dcff, 0x01dd01dd, 0x03dc5503, 0xc2301ffa, 0xefc06f01,
	0xb6fc02c0, 0xb7301f18, 0x80b76001, 0xffb802b7, 0xb73840c0, 0xe746130f, 0xaf1f01b1, 0xaf3faf2f, 0x5faf4f03, 0x03af6faf, 0x1582af40, 0x51ac3a08,
	0x9c1f1f18, 0xe0029c5f, 0x2b03019b, 0x9a1f019a, 0xa09a9001, 0x9a73029a, 0x05029a83, 0x40eaffb8, 0x0b099a19, 0xbf97af46, 0x2b030297, 0x961f0196,
	0xaf969f01, 0x967c0296, 0x211d8401, 0x1d829685, 0x922f5908, 0x924f923f, 0x0c924003, 0x912f460f, 0x01919f01, 0x1f188687, 0x7c507c40, 0x74100302,
	0x74307420, 0x01740203, 0x0a0174f2, 0x6fff016f, 0x016fa901, 0x75016f97, 0x026f856f, 0x0a016f4b, 0x6eff016e, 0x016ea901, 0x4b016e97, 0x1a06016e,
	0x19551801, 0x071fff13, 0x061fff04, 0x2308fb82, 0x1f01673f, 0x3f672f67, 0x0467ff67, 0x66506640, 0x66b066a0, 0x01653f04, 0x65af650f, 0x64a00502,
	0x030264e0, 0x4e08e483, 0x0a06644f, 0x2b5f6146, 0x475f601f, 0x22505f1f, 0x015bf71f, 0x54015bec, 0x025b845b, 0x3b015b49, 0x5af9015b, 0x015aef01,
	0x4b015a6b, 0x5a3b015a, 0x33130601, 0x01055512, 0x33045503, 0x031f5503, 0x3f030f01, 0x0303af03, 0x571f570f, 0x8303572f, 0x56b32b53, 0xb8461512,
	0x56b3e0ff, 0x07820b07, 0x54b3c022, 0x87080f84, 0x546d40c0, 0x52460b06, 0x3f1f2b50, 0x5f504f50, 0x48fa0350, 0x0148ef01, 0x65014887, 0x48560148,
	0x01483a01, 0xef0147fa, 0x47870147, 0x01473b01, 0xff1b1c06, 0x1533161f, 0x0f011155, 0x0f331055, 0x00010255, 0x00470155, 0x2bfafb55, 0x121bfa1f,
	0x010f0f1f, 0x0fcf0f1f, 0xff0f0f02, 0x6f06020f, 0xaf007f00, 0x0400ef00, 0x80010010, 0x01050116, 0xb19001b8, 0x2b2b5354, 0xff07b84b, 0x06b04b52,
	0x01b05b50, 0x5325b088, 0x22080583, 0xb05a5140, 0x00b08806, 0x585b5a55, 0x8e0101b1, 0x8d8d8559, 0x4b1d4200, 0x585332b0, 0x591d60b0, 0x8264b04b,
	0x83402008, 0x82802008, 0x1d102d08, 0x420016b1, 0x5e737359, 0x2b757473, 0x01220086, 0x0088735f, 0x2b730023, 0x24168301, 0x7300735f, 0x8c088274,
	0x210f831b, 0x3b835f2b, 0x74737323, 0x200d8200, 0x201e852b, 0x203e8474, 0x20318274, 0x20108274, 0x2207822b, 0x8201732b, 0x74732428, 0x85735f74,
	0x82002007, 0x2b012763, 0x74732b00, 0x05837301, 0x06822b20, 0x2b2b7322, 0x01210282, 0x343d822b, 0x5e182b00, 0x0b001406, 0xb6054e00, 0x75001700,
	0xcd05b605, 0x29008c00, 0x14004a04, 0x00008f00, 0x1683ecff, 0xfe220589, 0x1083fe14, 0x082103c8, 0x24008400, 0x00b600ac, 0x200982bc, 0x830382d5,
	0x00552c02, 0x00970083, 0x007d009f, 0x82ae00e5, 0x00712201, 0x23168371, 0xc500ba00, 0x0a830382, 0x1d82a420, 0x08838c20, 0x82c70021, 0x827d2001,
	0x860c8429, 0x00b02404, 0x848a00b9, 0x009b220b, 0x20c782a6, 0x850b8477, 0x85962004, 0x29058406, 0x006e0069, 0x00b40090, 0x798700c1, 0x6600002e,
	0x78006f00, 0xc0009600, 0x4701d500, 0x00242584, 0x3a01fe00, 0x78207982, 0x16220782, 0x1386f601, 0xee20068f, 0x96221082, 0xad828800, 0x89009633,
	0x96000c01, 0x00001801, 0x94001d03, 0x82005a02, 0x21758303, 0xb18400a8, 0x00790231, 0x01b400d9, 0x0100000a, 0x006d0083, 0x82a0007f, 0x82002039,
	0x84882009, 0x20048b07, 0x221b8493, 0x89890082, 0xb6052914, 0x110094fc, 0x8300efff, 0x1683d782, 0x7b006d22, 0x03860683, 0xaa01bc24, 0x0b845403,
	0xb600bc26, 0x9501d701, 0x96300b82, 0xae000001, 0xbcfeb605, 0x83fe6ffe, 0xad026f00, 0x2a211382, 0x08018500, 0xa1006fba, 0xe2012901, 0x29037102,
	0x7c034d03, 0xe203ac03, 0x44040f04, 0x95045b04, 0x0605b404, 0x94053f05, 0x65061206, 0x3f07cc06, 0x11086707, 0xda088208, 0x79093d09, 0xf709bb09,
	0x340b6a0a, 0x170ca00b, 0xb30c740c, 0x390dec0c, 0xcd0d970d, 0x490e100e, 0xb70e970e, 0x7c0f2b0f, 0x2210d50f, 0xf7108610, 0xa2116111, 0x3312e011,
	0x4813e912, 0xcc139913, 0x1214f213, 0x54143614, 0x90146b14, 0x64150315, 0x0916a915, 0xc9166616, 0xde179d17, 0x5a180f18, 0xc318aa18, 0x72193419,
	0x1d1abb19, 0xc41a7e1a, 0x891b341b, 0x221cca1b, 0x601dcf1c, 0x161ec91d, 0x941e701e, 0x431ff01e, 0xbc0b0182, 0x20ef1f8b, 0x21fc2065, 0x229f216f,
	0x239c2258, 0x24af2345, 0x24302403, 0x25072538, 0x2579251e, 0x260526b5, 0x269f267a, 0x272627e9, 0x27a62760, 0x282528dd, 0x289e2875, 0x29f228c3,
	0x29802968, 0x29af2997, 0x2adf29c6, 0x2a6d2a04, 0x2a982a80, 0x2ac72aaf, 0x2bf82ae0, 0x2b262b0f, 0x2ba32b3f, 0x2bd22bba, 0x2c002ce9, 0x2c312c18,
	0x2d172d96, 0x2d462d2f, 0x2d772d5e, 0x2ed82d8e, 0x2e8a2e73, 0x2eb62ea0, 0x2ee42ecc, 0x2fac2ffc, 0x2fd62fbf, 0x300230ec, 0x3032301a, 0x30603049,
	0x31093179, 0x3136311f, 0x3163314c, 0x3293317a, 0x327d3204, 0x32aa3294, 0x32d932c0, 0x335433ef, 0x3384336c, 0x33b1339a, 0x33de33c7, 0x341234fb,
	0x3441342a, 0x34703459, 0x34a03489, 0x34d034b8, 0x35eb34e3, 0x357b3564, 0x35a83591, 0x35d535be, 0x360036ec, 0x36383621, 0x3665364e, 0x3692367b,
	0x36c036a9, 0x37eb36d8, 0x37193701, 0x37873736, 0x38f937e2, 0x38273810, 0x3855383e, 0x387f386c, 0x38aa3893, 0x39ec38c3, 0x39273910, 0x3951393e,
	0x39ad3964, 0x39e239c5, 0x3a093af5, 0x3a393a21, 0x3a6f3a4c, 0x3b093bbc, 0x3b363b20, 0x3b5d3b4a, 0x3b8b3b74, 0x3c0e3cad, 0x3c7e3c67, 0x3cab3c94,
	0x3cdb3cc2, 0x3d643df3, 0x3e0a3ef2, 0x3e333e20, 0x3e5f3e47, 0x3e8e3e77, 0x3ebb3ea4, 0x3ee53ed1, 0x3f0f3ff8, 0x3f383f25, 0x3f633f4c, 0x40cc3f75,
	0x404e4036, 0x407c4064, 0x40a94092, 0x40d840bf, 0x410941f0, 0x41344121, 0x415e4147, 0x418c4175, 0x41bb41a2, 0x41e841d2, 0x421642ff, 0x4243422d,
	0x43da4276, 0x449144bc, 0x44c044a9, 0x45ed44d7, 0x45134500, 0x457f4549, 0x45d24597, 0x464946f9, 0x47bd4676, 0x472d4700, 0x47b7479e, 0x481648f1,
	0x487d483c, 0x49e248ae, 0x4923490a, 0x4933492b, 0x49b14965, 0x49c149b9, 0x4a384ac9, 0x4a484a40, 0x4a9c4a94, 0x4af14aa4, 0x4b244bf9, 0x4b744b2c,
	0x4c844b7c, 0x4c1b4c13, 0x4d0b4d89, 0x4d3d4d24, 0x4d694d53, 0x4d974d7f, 0x4e1e4eac, 0x4fff4ea0, 0x50035087, 0x51a95069, 0x5159511b, 0x52dd5161,
	0x536d522b, 0x5315530d, 0x54c35369, 0x548b5432, 0x551755d5, 0x56295695, 0x5714578a, 0x5746572d, 0x5772575c, 0x58a95790, 0x583a5823, 0x58ad58a5,
	0x58ce58b5, 0x596d59d6, 0x5a2a5acc, 0x5a585a41, 0x5aa95aa1, 0x5b045bfc, 0x5b7f5b0c, 0x5c145c87, 0x5df65c97, 0x5d565d0e, 0x5dc25dba, 0x5dd25dca,
	0x5de25dda, 0x5ef25dea, 0x5e6a5e62, 0x5ea75e72, 0x5f365fee, 0x60e25f8c, 0x60866038, 0x616061e9, 0x62e561dd, 0x62d26260, 0x636063fa, 0x64dd6368,
	0x649f645b, 0x65f064b6, 0x65a0653b, 0x66ee65e6, 0x661f6617, 0x66666627, 0x66eb666e, 0x672d67f3, 0x68b8676d, 0x686e6811, 0x691a69d0, 0x6af76983,
	0x6a666a4e, 0x6beb6ad5, 0x6b4f6b47, 0x6b706b57, 0x6cf06b78, 0x6ca96c4f, 0x6dd56cbf, 0x6d4f6d1a, 0x6d926d7a, 0x6dc06da9, 0x6ef16dd7, 0x6e236e0b,
	0x6e566e3b, 0x6e8c6e71, 0x6fe06eb5, 0x6f3f6f0c, 0x70c96f6d, 0x708f7025, 0x717071ea, 0x735872b3, 0x732d7325, 0x73687335, 0x73af739d, 0x741074cd,
	0x75f2746b, 0x7610767c, 0x773c77be, 0x787978f2, 0x79e47881, 0x793c790d, 0x7a96796b, 0x7a5d7a10, 0x7ad67a8c, 0x7b287bfc, 0x7c157cc4, 0x7d167d9e,
	0x7d9f7d5b, 0x7e0a7eeb, 0x7e6b7e28, 0x7ec47e9e, 0x7f0e7fe9, 0x7f9a7f51, 0x805680f7, 0x81228185, 0x0a01998c, 0x83d68286, 0x83558349, 0x8406845d,
	0x851f8583, 0x854d8536, 0x85758561, 0x86ef85a2, 0x866f8642, 0x8710879b, 0x88d68777, 0x885e8839, 0x89ca8883, 0x89298909, 0x89598941, 0x8a878970,
	0x8bdf8a24, 0x8cd58b60, 0x8db78c46, 0x8ece8d3b, 0x8f128f66, 0x915790b3, 0x92b59105, 0x938e939f, 0x949e9396, 0x946b940b, 0x953395cb, 0x9667954d,
	0x963d9627, 0x984197c3, 0x992e9945, 0x9be19af4, 0x9c929b43, 0x9c969c51, 0x9d089dd9, 0x9e189e39, 0x9f5c9fb6, 0xa03fa0e4, 0xa11fa1a3, 0xa20ca2ad,
	0xa3caa25c, 0xa4cca32e, 0xa497a481, 0xa521a5ad, 0xa6faa58c, 0xa7d3a66d, 0xa789a73f, 0xa829a8db, 0xa9cba882, 0xa984a919, 0xaba8aaf7, 0xab66ab52,
	0xacc9ab7a, 0xac20ac18, 0xadf4ac83, 0xae0aae63, 0xaf31afca, 0xb0eeaf8f, 0xb1b1b04a, 0xb162b114, 0xb22ab2a8, 0xb347b3ba, 0xb4e9b3e1, 0xb417b400,
	0xb5f4b485, 0xb6bfb567, 0xb672b611, 0xb712b7b9, 0xb8b8b76c, 0xb8bcb83c, 0xb8dbb8c4, 0xb90ab9f1, 0xb92ab922, 0xb949b932, 0xbac5b95f, 0xba3dba23,
	0xba6fba56, 0xbaa3ba89, 0xbb27bbbd, 0xbba7bb8f, 0xbbd8bbbe, 0xbc0abcf1, 0xbc2bbc23, 0xbc4cbc33, 0xbc7ebc64, 0xbcb0bc98, 0xbce0bcc6, 0xbd11bdf8,
	0xbd42bd29, 0xbda1bd5a, 0xbef5bddc, 0xbe20be0e, 0xbe4bbe32, 0xbfe2be61, 0xbfdfbf95, 0xc061c0e7, 0xc286c1ed, 0xc39dc218, 0xc4b6c323, 0xc47fc423,
	0xc54ac5e6, 0xc621c6c6, 0xc700c782, 0xc798c784, 0xc7c3c7ac, 0xc8f1c7da, 0xc822c808, 0xc855c83b, 0xc888c86e, 0xc8bbc8a1, 0xc9f8c8d4, 0xc932c919,
	0xc964c94b, 0xc996c97d, 0xc9c8c9af, 0xca03cae1, 0xca3bca24, 0xca69ca52, 0xca98ca80, 0xcac8caae, 0xcbfbcae1, 0xcb2ecb14, 0xcb61cb47, 0xcb9ecb7a,
	0xcbd6cbbf, 0xcc05cced, 0xcc34cc1d, 0xcc63cc4c, 0xcc93cc7a, 0xccc6ccad, 0xcdf9cce0, 0xcd2ccd13, 0xcd68cd46, 0xcda3cd8c, 0xcdd2cdba, 0xce01cee9,
	0xce31ce19, 0xce60ce48, 0xce8fce78, 0xcebecea7, 0xcfedced5, 0xcf1acf02, 0xcf45cf2f, 0xcf73cf5b, 0xcfa0cf88, 0xcfd0cfb8, 0xd0fdcfe6, 0xd02bd014,
	0xd055d041, 0xd1f1d098, 0xd2b5d146, 0xd275d22a, 0xd324d3c3, 0xd3bad38d, 0xd40ad4e2, 0xd492d47f, 0x000200a6, 0x040000c1, 0x00b6050a, 0x00070003,
	0x050b402b, 0x04090202, 0x03800370, 0x2705e94a, 0x48090609, 0x07030403, 0x3f331e82, 0x01332f32, 0x335d2b2f, 0x332f3311, 0x21133031, 0x82372111,
	0x03c13003, 0x68b7fc49, 0x87fd7902, 0x4afab605, 0x82e60468, 0xff932453, 0x849101e3, 0x17300853, 0x00b93a00, 0x40f0ff01, 0x48140a13, 0x19801910,
	0x19a01990, 0x9a0e0304, 0x04020204, 0x40c0ffb8, 0x480a070a, 0x9b090104, 0x00030213, 0xcef52f3f, 0x48086182, 0xe1102f33, 0x30315d32, 0x0323012b,
	0x3e340333, 0x1e323302, 0x0e141502, 0x2e222302, 0x79500102, 0x14f0df33, 0x1a1b2e22, 0x1414222f, 0x1b1a2f22, 0x0114222e, 0xfa18049e, 0x213526b9,
	0x35210f0f, 0x22352526, 0x35221010, 0x24898200, 0x02a60385, 0x3e8984b2, 0x40370007, 0x07980423, 0x09d00907, 0x2f0209e0, 0x7f096f09, 0x98000309,
	0x03100300, 0x82f003e0, 0x020624e4, 0x82030702, 0x82332085, 0x2f0130df, 0x5d5de15d, 0xe12f3912, 0x03013031, 0x82210323, 0x4a012f03, 0x02297329,
	0x2972292d, 0xf0fdb605, 0x03831002, 0x33246383, 0xf8040000, 0x70086382, 0x001f001b, 0x03584099, 0x181a1a03, 0x071d1e16, 0x17170604, 0x01001906,
	0xb1050404, 0x15211818, 0x04081c1f, 0x12141409, 0x040b0e0f, 0x500ab113, 0x10100110, 0x50090c0c, 0x1c0a010a, 0x010d4801, 0x080cae0d, 0x001f0c04,
	0x1911ae10, 0x113f1115, 0x11df114f, 0x0c110c03, 0x13170511, 0x00050a06, 0x333f332f, 0x2f393912, 0x33115d2f, 0x32e11033, 0x22068432, 0x8232325d,
	0x2db383ac, 0xe4105d2f, 0x11323917, 0x11391712, 0x0a832f33, 0x0b863320, 0x832f3321, 0x152121c5, 0x1320c582, 0x35230384, 0x82211321, 0x03332303,
	0x03821321, 0x82011521, 0x0331080e, 0x18013fd7, 0x9352cdfe, 0x52ddfe54, 0xfefe4e90, 0xfe411d01, 0x522b01ee, 0x25015293, 0x01549054, 0x01ebfc06,
	0xddfe4023, 0xb8fe7d03, 0x0154fe89, 0x270383ac, 0x89480189, 0x50feb001, 0x80080383, 0x01b8fe89, 0x00030048, 0x0389ff7b, 0x001206d9, 0x0036002d,
	0x40b4003f, 0x292f3433, 0x212f2901, 0x70062101, 0x3c013c2f, 0x1e011e2f, 0x01072013, 0x2e0d0707, 0x000f246e, 0xff02001f, 0x00000100, 0x41000701,
	0x6e370d0d, 0x190119e0, 0x40c0ffb8, 0x480b0830, 0x14143319, 0x133c3c29, 0x3d08372e, 0x25217328, 0x0e401f21, 0x1f1f4811, 0x0121501e, 0x211f210f,
	0x34210802, 0x0e087313, 0x05060608, 0x33348208, 0x480d0ab3, 0x2b2f0008, 0x112f3333, 0x32e11033, 0x5d5d5e2f, 0x2b200b82, 0x12320c84, 0x39123939,
	0x11333311, 0x2b2f0133, 0x2f33e15d, 0x1e82d610, 0xe1327125, 0x822f3911, 0x335d2525, 0x5d32e15d, 0x28080182, 0x14013031, 0x1507020e, 0x2e223523,
	0x1e352702, 0x2e113303, 0x3e343503, 0x33353702, 0x17161615, 0x27262607, 0x07031e11, 0x081d8234, 0x363611d8, 0x021e1401, 0x06061117, 0x5d32d903,
	0x328a5485, 0x20546066, 0x65605721, 0x5683592f, 0x815b312a, 0xa9648a4f, 0x8c384243, 0x5b87584a, 0x2b14b02e, 0x5b5d3346, 0x281112fe, 0x53593142,
	0x7246be01, 0xe60c3754, 0x1a1209dd, 0x2110ac11, 0xb201111a, 0x6e55421e, 0x536f434a, 0xb0b40935, 0x911f2a05, 0xfe062919, 0x53421f5a, 0x3721486b,
	0xfe12262d, 0x02620e8b, 0x2f3924a3, 0x71011126, 0x00005910, 0xff660005, 0x053306ec, 0x000900cb, 0x0027001d, 0x003f003b, 0x103cb25d, 0xf0ffb83e,
	0x3e3c3340, 0x14283e3c, 0xb532b41e, 0x4128b423, 0x0501410f, 0x00b50ab4, 0x201410b4, 0x03143014, 0x3e063f14, 0x37b62518, 0x2db621b7, 0x0fb60319,
	0x19b607b7, 0xe13f0007, 0x0384e1f4, 0x2f013f23, 0x220b825d, 0x82de105d, 0x12113505, 0x2f2f3939, 0x30313838, 0x33161413, 0x23101132, 0x14050622,
	0x20059643, 0x06a64335, 0x19990120, 0x0123013d, 0x9c5047fa, 0x0147509c, 0x734a24c7, 0x4c70494f, 0x71492326, 0x4d714b4e, 0x86ac0127, 0x23c62119,
	0x4a221982, 0x19864b70, 0x274c2708, 0xd5fc00ff, 0x042c039e, 0x01a5a502, 0xa348014a, 0x76ac6ca5, 0xac763f3f, 0x75aa6c6c, 0xaa753e3e, 0xa4a54afd,
	0x18844901, 0x1883ab20, 0x1887ab20, 0x92035608, 0xb6054afa, 0x00030000, 0x05ecff6d, 0x00cd057d, 0x00210011, 0x40800053, 0x1718274d, 0x2c49044a,
	0x470a4849, 0x42474136, 0x36014220, 0x1d423642, 0x473c3b05, 0x47004804, 0x2c102c00, 0x2c2c0802, 0x01482022, 0x481d5548, 0x22202210, 0x41412202,
	0x4f511231, 0x323b8416, 0x3b3c470f, 0x49310405, 0x31500f15, 0x3fe12f00, 0x82391712, 0xe13f2b02, 0x012f3911, 0x10e15d2f, 0x09825dc6, 0xe15d5e23,
	0x2b178211, 0x2f2f3939, 0x10e1105d, 0x113311e1, 0x31382482, 0x1e140130, 0x033e1702, 0x022e3435, 0x13062223, 0x37023e32, 0x15030e01, 0x25211582,
	0x420b8234, 0xf2440569, 0x07620807, 0x37033e01, 0x07030e33, 0x0e272301, 0x2e222303, 0x10a60102, 0x3b243421, 0x191c3856, 0x562a422f, 0x623a8764,
	0xfe204854, 0x3750347d, 0x6042231c, 0x4d287dfe, 0x3c1f476f, 0x5e321c2d, 0x8353588a, 0x5432305b, 0x60013c6d, 0x1b222b1b, 0x290fb80a, 0x01274135,
	0x31a8e115, 0x4e7c6c60, 0x3d73a769, 0xd9828d04, 0x25436608, 0x46403e23, 0x2c3d2429, 0xaffb5919, 0x1f362817, 0x3f219701, 0x36385548, 0xf024415b,
	0x56647a4e, 0x574d242a, 0x774b3963, 0x532b2b53, 0x6d404b77, 0xfe244f5d, 0x443c1d8c, 0x6f422f4e, 0xfe295562, 0x472dacdb, 0x67351b31, 0x00010095,
	0x01a60385, 0x00b6054a, 0x402a0003, 0xd005c01c, 0x0305e005, 0x056f052f, 0x0b6c4502, 0x03020227, 0x333f0003, 0x0568452f, 0x23056445, 0x73294a01,
	0x20065b45, 0x24478200, 0x02bcfe52, 0x2a47822b, 0x401a0013, 0xf20e060d, 0x823ff009, 0xf90e2615, 0x3f00f805, 0x0837833f, 0x3132e438, 0x3e341330,
	0x06333702, 0x1e141502, 0x2e231702, 0x4a245203, 0x8cac4e71, 0x6a472591, 0x714eaa45, 0x3102244a, 0xd3e5f37d, 0x32fec15d, 0xe2ec77f4, 0xce5a5ed4,
	0x5d83f0e1, 0x5d823d20, 0x5d841720, 0x0e401c22, 0x0b225d82, 0x5d82b0f0, 0xf80e1524, 0x5e83f905, 0x5dde1023, 0x3f5f83e1, 0x020e1401, 0x033e2307,
	0x27023435, 0x02031e33, 0x714b2417, 0x6a45aa4e, 0x8d902448, 0x4b714eac, 0x7c315f82, 0x5acee1f0, 0xece2d45e, 0xce01f477, 0xe5d35dc1, 0x2ebd84f3,
	0x14047702, 0x0e001406, 0x15402400, 0x8201101f, 0x800e39fc, 0x030e900e, 0x061f0e08, 0x00060601, 0x323f0000, 0x2f015d2f, 0x5de55d5e, 0x3708ff83,
	0x13051725, 0x27030307, 0x05372513, 0x2b980203, 0xfe1a8d01, 0xb0b2f586, 0xfef2b89e, 0x87011d89, 0xfe14062b, 0x1cc16f77, 0x0160bafe, 0x609afe66,
	0xc11c4601, 0x0089016f, 0x3008b582, 0x04060166, 0x00a20402, 0x4029000b, 0x010d1018, 0x03aa0906, 0x200100ef, 0xa0006000, 0x09000300, 0x0306ad00,
	0x333f00b3, 0x2f0132e1, 0xe1325d5d, 0x08708332, 0x21352120, 0x21113311, 0x23112115, 0x7dfee901, 0x01968301, 0x967dfe83, 0x01968702, 0x967bfe85,
	0x59837ffe, 0xf8fe3f30, 0xee007901, 0x38000c00, 0x0ecf1440, 0xc1821001, 0x0ea02108, 0x2b0c1b03, 0x010c020c, 0xb8070697, 0x0d40c0ff, 0x5f481410,
	0x07100107, 0x9c060701, 0xed2f000c, 0x2b256583, 0x5d32ed33, 0x0868825d, 0x0e172522, 0x3e230703, 0x6a013703, 0x2f270e0f, 0x0f8a1933, 0x08161b1d,
	0x7a3617ee, 0x3d387b7c, 0x357d8384, 0x52266983, 0x4202d101, 0xae827902, 0x09401525, 0x82400502, 0xb90025d6, 0xe12f0001, 0x102e4c82, 0x133031ce,
	0x52152135, 0xd101f001, 0x1a82a8a8, 0xff932708, 0x009101e3, 0x001300fa, 0x801b4035, 0xa0159015, 0x15110315, 0xc0960a01, 0x0200d000, 0x00440034,
	0x00740064, 0x9e820004, 0x0a07b627, 0x9b050048, 0x2397840f, 0xed5d5d2b, 0x37209483, 0x200e5648, 0x0f514893, 0x4c486f20, 0x0001280f, 0x02000014,
	0x82b605e7, 0xb11e26a1, 0xffb80201, 0x25a782f0, 0x00100003, 0x12820105, 0x112f3f38, 0x32383301, 0x3133382f, 0x23010130, 0xfde70201, 0x2102b3e0,
	0x8544b605, 0x00022805, 0x04ecff62, 0x82cd0508, 0x00273db1, 0x1e154026, 0x1029006f, 0x6f140129, 0x0a010a20, 0x070f7323, 0x19057319, 0x3fe13f00,
	0xe124ef83, 0xe1de105d, 0x14394782, 0x23060602, 0x02262622, 0x36123435, 0x16323336, 0x14051216, 0x3233021e, 0x0811823e, 0x23022e53, 0x04020e22,
	0xb2713308, 0x73af767f, 0xb16f3339, 0x74b0777e, 0x1e13fd3a, 0x4d4d6b42, 0x1f1f456c, 0x4d4d6c45, 0x021e426b, 0xe8feb1dd, 0xc26666c2, 0xb1b11801,
	0x66c11801, 0xe8fec165, 0x95e096b2, 0xe1944a4b, 0x94e09697, 0xe0944a4a, 0x00010000, 0x20e182b2, 0x08e182c7, 0x35001066, 0x12402140, 0x0e010f01,
	0xbf6e000e, 0x0201ff01, 0x0001017e, 0x20011001, 0x04014001, 0x0f0d0106, 0x00180006, 0x01cd3f3f, 0x5d5d5e2f, 0x2f33e15d, 0x315d3311, 0x11232130,
	0x37023e34, 0x0707030e, 0x02330127, 0x0301b0c7, 0x1a110103, 0x94151e1b, 0x967f0160, 0x622b9103, 0x12225961, 0x121b181a, 0x2b017b79, 0x2b087182,
	0x03000060, 0x00cb05f0, 0x403c0023, 0x6f082320, 0x10251b1b, 0x6f220125, 0x11012101, 0x01012011, 0x10220801, 0x0716730d, 0x01742202, 0xe1297082,
	0x33e13f32, 0x2f013912, 0x2771835d, 0x115ded10, 0x33e12f33, 0x21227882, 0x52450135, 0x27072308, 0x3f45033e, 0x154c0809, 0xfcf00321, 0x4b5e0170,
	0x222c5376, 0x5f35563f, 0x28664599, 0x41766a5c, 0x3b6c9b60, 0x4b815d35, 0xb102e7fe, 0x517d019c, 0x4c818086, 0x203f5a3b, 0x24773c4d, 0x361b2e3f,
	0x555b9165, 0x5196959a, 0x0008d5fe, 0x52000100, 0xee03ecff, 0x4008a982, 0x405d0039, 0x2130210b, 0x6f1a1230, 0x006f2709, 0x40c0ffb8, 0x48171428,
	0x3b090000, 0x4f013b20, 0x06120112, 0x21ab7320, 0x01217901, 0x0801210b, 0x2f152121, 0x0735732c, 0x0e127315, 0x333f0019, 0x41c184e1, 0xc8830536,
	0xce105d2d, 0xe12b2f32, 0x3911e110, 0x482f2f39, 0x1621077a, 0x05f04a16, 0x35272624, 0xef411616, 0x35232108, 0x22210a88, 0x08e68706, 0x2ec103a6,
	0xb1477453, 0xca8441b8, 0x55c16d8a, 0x5c5dcb57, 0x35295786, 0x85598d62, 0x557e5185, 0x5c42242c, 0x4aa36b38, 0x6e5d265c, 0xa36c467d, 0x6004386e,
	0x39587849, 0xb516060c, 0x74a06091, 0xaa2d2240, 0x4a28322e, 0x6144436c, 0x28971e3f, 0x343d664a, 0x431e3952, 0x361f7d36, 0x61361829, 0x00020085,
	0x04000017, 0x00be053f, 0x0018000a, 0x092c404e, 0x00010056, 0x116e0200, 0x20070b0c, 0x03030103, 0x011a101a, 0x18871877, 0x055f1802, 0x06090501,
	0x05017418, 0x07110205, 0x00180206, 0x12333f3f, 0xe1332f39, 0x2105a64a, 0x0c825d5d, 0x82335d21, 0x32e12400, 0x82325d2f, 0x234608ee, 0x21112311,
	0x11330135, 0x34112133, 0x2337023e, 0x0107030e, 0xb0d53f04, 0x97025dfd, 0x7bfed5bc, 0x01050403, 0x19150709, 0x65fe0b1a, 0xb8fe4801, 0x039f4801,
	0x0130fcd7, 0x757b3864, 0x31142266, 0xfd102e31, 0x918200a0, 0xecff8328, 0xb605f603, 0xa3822a00, 0x26182e08, 0x2c056f1a, 0x27012c10, 0x68282424,
	0x23590123, 0xf0232301, 0xb80f010f, 0x1240c0ff, 0x0f480b08, 0x0000731d, 0x24742715, 0x10731506, 0x0698410a, 0xe1279b82, 0x5d2b2f01, 0x825d2f33,
	0x331126a3, 0xe1de105d, 0x4ca38233, 0x27230a7f, 0x41031e35, 0x95080584, 0x0e222326, 0x13270702, 0x03211521, 0x21023636, 0x487fab63, 0x80c58644,
	0x525b6333, 0x62592121, 0x7c4f2a63, 0xa8b02e56, 0x393f3f1b, 0x02375a15, 0x27ecfdb2, 0x81036920, 0x69a06c37, 0x437eb672, 0x141e130a, 0x182417ac,
	0x764e250d, 0x05978f51, 0x39040908, 0xfea6b002, 0x000e065d, 0x71000200, 0x0a04ecff, 0x2b00cb05, 0x37003f00, 0x6e312040, 0x1041220c, 0x3b170141,
	0x1000006f, 0x03002000, 0x1d753600, 0x732c071d, 0x73101927, 0x3f000707, 0x11e13fe1, 0xbf822f39, 0x32e15d22, 0x3228b882, 0x133031e1, 0x33043e34,
	0x1722bc82, 0xad832615, 0x33070422, 0x24091943, 0x022e2223, 0x0a484401, 0x14158808, 0x1571021e, 0xc68e5c35, 0x2f2e1385, 0x5823112b, 0x64895a2b,
	0x03142a43, 0x4c39140c, 0x9a5f3b5f, 0x743e3b6c, 0xaf6466a4, 0xdb014a80, 0x2748633c, 0x42634221, 0x2b4e6f43, 0x026e4925, 0xbfd06971, 0x024579a4,
	0x9b050705, 0x4e2b0c0c, 0x5094836c, 0x1a2d3f24, 0x6aa5723b, 0x447fb672, 0xfef2a04e, 0x7f5329b9, 0x4e6f4657, 0x604b2f2a, 0x6a854330, 0x00010043,
	0x0400005a, 0x00b60506, 0xb12b0006, 0xffb80006, 0x821140f0, 0x05012afc, 0x01081008, 0x74020502, 0x05674403, 0x0132e127, 0xce105d2f, 0x08e08232,
	0x31333880, 0x21012130, 0x01152135, 0x33021901, 0xac030efd, 0x1005d5fd, 0xdbfa91a6, 0x6a000300, 0x0004ecff, 0x2700cd05, 0x4a003a00, 0x53408000,
	0x6e32231e, 0x48280a0f, 0xd305c36e, 0x05b50205, 0x0f050501, 0x014c104c, 0x3e196e28, 0x0123d56e, 0xba0123cc, 0x23230123, 0x19201910, 0x1e0a1902,
	0x38983868, 0x01385902, 0x38383828, 0x38033848, 0x26014393, 0x02435643, 0x2d004343, 0x3b191473, 0x6a410073, 0x5d5d2708, 0x5d5d5dc1, 0x9a823939,
	0x822f3321, 0x10e12209, 0x82a383e1, 0x12e1260a, 0x11e11039, 0x09394239, 0x031e0722, 0x2205cf43, 0x4935022e, 0x032009e4, 0x270acb45, 0x06062727,
	0x15062201, 0x08071c4a, 0x350226b7, 0x42719554, 0x38604628, 0x35576f3a, 0x66a97943, 0x3d75ab6e, 0x3a684c2d, 0x253f5631, 0xc7957243, 0x48684420,
	0x24486b46, 0x3f664927, 0x01807e1e, 0x237d6a16, 0x3033573e, 0x7e243f55, 0x582ccd05, 0x6c435884, 0x1f1c4557, 0x49765f4c, 0x3868955c, 0x5c926536,
	0x4a60784b, 0x5a491f1c, 0x8357426d, 0xa6fb2c58, 0x233f5935, 0x385c4123, 0x40485434, 0x9b3c0e1f, 0x656a5403, 0x33405239, 0x42341618, 0x6a653654,
	0x00020000, 0x04ecff6a, 0x00cb0504, 0x003d0029, 0x391e4035, 0x3f006f15, 0x2f013f10, 0x20100c6e, 0x20022020, 0x1b1b7534, 0x25732a07, 0x07751007,
	0x0b87421a, 0x5de13330, 0x32e1de10, 0x14013031, 0x2223040e, 0xcc44022e, 0x23372107, 0x4c05cb4a, 0x22220835, 0xf983020e, 0x23055843, 0x0404022e,
	0x3e078842, 0x23112c2e, 0xae872b58, 0x0d052b66, 0x604c3814, 0x6c9a5f3b, 0xa5733f3b, 0x80ae6566, 0x4225fe4a, 0x443c0786, 0x252b4e6e, 0x46036e49,
	0xa5bed169, 0x05024578, 0x0d9c0506, 0xd6a15e0c, 0x2e3e2477, 0x29058442, 0x4e447fb7, 0x4701f3a0, 0x84425428, 0x426b210b, 0x933be183, 0x9101e3ff,
	0x13006604, 0x3e002700, 0x29101c40, 0x29902980, 0x1e0429a0, 0x4814960a, 0x40291150, 0x480a070b, 0x199b2300, 0x05554810, 0x01ed3f2c, 0x5d5d2b2f,
	0x5d32e533, 0x58483031, 0x4811200f, 0x78481f68, 0x9103361f, 0x0e213527, 0x2735210e, 0x10223425, 0x00342210, 0xfe3f0002, 0x08af84f8, 0x20000c2b,
	0x2f406100, 0x22802210, 0x22a02290, 0xc0961704, 0x020dd00d, 0x0d740d64, 0x010d5002, 0x3b010d44, 0x0d1f010d, 0x0d020d2f, 0x0db2490d, 0xb2491120,
	0x9b1c2309, 0xb6491012, 0x29c88305, 0x332b5d5d, 0x335d32ed, 0x00845d2f, 0xc049e520, 0x108b510b, 0x200cd049, 0x49c98f11, 0x02210be1, 0x08c58fed,
	0x66000141, 0x0204ee00, 0x0600dd04, 0x30404e00, 0x08400800, 0x01014001, 0x05010201, 0x6f060305, 0x02007f00, 0x00010030, 0x03200400, 0x70035001,
	0xd0038003, 0x0503f003, 0x0001033f, 0x03060103, 0x825e2f00, 0x337121a0, 0x3228a883, 0x2f3d3912, 0x18013333, 0x4e08b482, 0x3031ce10, 0x01350125,
	0x04010115, 0x0364fc02, 0x0221fd9c, 0xa801eedf, 0xa0e10166, 0xbefe94fe, 0x66000200, 0x0204ba01, 0x0300e903, 0x5c000700, 0x02073d40, 0x01094009,
	0x0100c604, 0xa90100bb, 0x00860100, 0x01007b01, 0x42010068, 0x82390100, 0xad043981, 0x052f051f, 0x01057f02, 0x05100500, 0x05050602, 0x01f0ad00,
	0x6f010f01, 0x0020ab82, 0xe1217282, 0x228b8333, 0x4101e171, 0x5d260633, 0x105d335d, 0xb24a32ce, 0x35012605, 0x03661521, 0x2889839c, 0x95955403,
	0x969666fe, 0x8c548200, 0x840520fb, 0x01062efb, 0x01040506, 0x6f000301, 0x02067f06, 0x210e8230, 0xfba10206, 0xfb8e3320, 0x84011321, 0x026624fc,
	0x8320fde0, 0x8f012b76, 0x6c014201, 0x661ffea0, 0xfb8258fe, 0xff253108, 0x052503e3, 0x002700cb, 0x403e003b, 0x289a3221, 0x00462728, 0x460b1400,
	0x3d2f3d1c, 0x170b1401, 0x0601000f, 0x9b2d0000, 0x51101337, 0x3f000417, 0xe521dd82, 0x21e08232, 0xdf823912, 0xe1de1025, 0x822f3911, 0x31e12812,
	0x34350130, 0x4937023e, 0x36210a75, 0x08754936, 0x15030e23, 0x102d4215, 0x0f192008, 0x30324227, 0x1e152b44, 0x53385539, 0x513f4696, 0x955d61bc,
	0x361b3868, 0x42343650, 0x42bb0e26, 0x26080f40, 0x39259e01, 0x2a4d505c, 0x4f454329, 0x394f3035, 0x9122341f, 0x60333b2a, 0x6943578b, 0x2d2f545a,
	0x2c423f43, 0x4bd1fe12, 0x71080fa9, 0xff6d0002, 0x0581064a, 0x005700b6, 0x406f0068, 0x6017583f, 0x01171f27, 0x1701277f, 0x27464627, 0x314e0317,
	0x00010020, 0x016a406a, 0x014e403b, 0x5b0c2c4e, 0x64120712, 0x1f120f1c, 0x0312bf12, 0x011c0006, 0x121c1207, 0x5336401c, 0x49454003, 0xc1332f00,
	0x3912c13f, 0x5e2f2f39, 0x105d5e5d, 0x103311c1, 0x013232c1, 0x5dc15d2f, 0xc171de10, 0x19821711, 0x825d2f21, 0xc1102118, 0x440aeb44, 0x17250ee3,
	0x14060603, 0x0be54414, 0x04222322, 0x2a05b74e, 0x023e3233, 0x06061537, 0x4b242223, 0x242805ea, 0x16043233, 0x16140112, 0xc5081984, 0x23262637,
	0x06020e22, 0x39251381, 0x2d3a614c, 0x06213449, 0x47361204, 0x774d3559, 0x6f3b2b52, 0x5a2d629e, 0x17174552, 0x22150101, 0x462e172b, 0x9856182f,
	0xfea97bd1, 0x4f5aaffe, 0x3d93e399, 0x2b646f77, 0xb382d856, 0x66c3e7fe, 0x3701db76, 0x06019cc1, 0x15fc6abf, 0x4e375565, 0x0e041a32, 0x4a2a4d1c,
	0x021c3f65, 0x717d3edb, 0x1e294861, 0x25234132, 0x381c3142, 0x65568e65, 0x08447aa8, 0xfe08110e, 0x101b1660, 0x44350308, 0x683d0f28, 0xdd8e4e8c,
	0xc76f4f98, 0x97a2effe, 0x0e52a0ea, 0x8d111f18, 0xc3662c26, 0xbcb31901, 0x88ee4501, 0xf1febd65, 0x7785d5fe, 0x4573532d, 0x3a0d08fd, 0x0000785e,
	0x00820002, 0xdd047e08, 0x0700bc05, 0x84001400, 0x05062440, 0x46010246, 0x14020114, 0x01084903, 0x08010149, 0x0e0e0001, 0x10000003, 0x07800107,
	0x07d00790, 0xffb80703, 0x061840c0, 0x1007480a, 0x0f160707, 0x2f161f16, 0x9f168f16, 0x0616df16, 0xb8040307, 0x1140f0ff, 0x0e5f0204, 0x480e0a20,
	0x1414050e, 0x00040305, 0x323f0012, 0x122f393f, 0x01e12b39, 0x5e33382f, 0x2f33115d, 0x715d2b38, 0x39121133, 0x2416823d, 0x125d5d39, 0x08048239,
	0x31333397, 0x21032130, 0x33012303, 0x2e030101, 0x030e2703, 0x1f040307, 0xa2dffda0, 0xaa1902bc, 0x67fe1a02, 0x12110694, 0x12070812, 0x91061112,
	0x3bfec501, 0x44fabc05, 0xa8016a02, 0x413c3412, 0x3d421f1f, 0x58fe1133, 0x00030000, 0x040000c7, 0x00b60587, 0x00220017, 0x4062002f, 0x5a1e0b3e,
	0xe5010605, 0x0206f506, 0x060106d6, 0x5b2a2406, 0x11801170, 0x31671102, 0x318f317f, 0x01311002, 0x175a2418, 0x230b3064, 0x01187960, 0x0801180b,
	0x24001818, 0x22121760, 0x494f8260, 0x5e3b06c7, 0x39e15d5d, 0xe1f61001, 0x105d5d32, 0x12e15df6, 0x5d5d2f39, 0x3132e171, 0x4a211330, 0x0721068e,
	0x06554815, 0x47132121, 0x26270538, 0x11112323, 0x4e3e3221, 0x7508051c, 0x808f01c7, 0x274283c3, 0x45456d4a, 0x41345a79, 0xfe6fb07b, 0x54f4ba1b,
	0x9a1f4672, 0x0a01dfa6, 0x20497758, 0x5c7c4b21, 0x5727b605, 0x6c3e678d, 0x0a093752, 0x784f2d0c, 0x6d9d6456, 0x1e4a033a, 0x783b593b, 0xfd97fd68,
	0x654828f0, 0x435e383d, 0x01000025, 0xecff7d00, 0xcb059804, 0x4c002300, 0x0eaf1440, 0x15400e01, 0x0e0e4818, 0x0120ba18, 0x20702060, 0xb3412002,
	0x20203807, 0x0125af25, 0x66185b05, 0x5f002124, 0x0a0d041d, 0x0013135f, 0x8233e13f, 0x26d68302, 0x2f33115d, 0x825d5d2b, 0x5d2b24d6, 0x48013031,
	0x36240800, 0x030e1537, 0x080cf34e, 0x2607176a, 0x6b190326, 0x3b437bae, 0x5976b076, 0x4e274ea0, 0xa43b6155, 0x574c9df0, 0x6ca2faa9, 0x3f4e4fc4,
	0x51270594, 0x8d89da98, 0x234e96db, 0x170fa217, 0xc66c070e, 0xa6a91601, 0x6ec61401, 0x209c2a2c, 0x0002002e, 0x040000c7, 0x00b605fc, 0x0017000c,
	0x0d154026, 0x1967005b, 0x14011910, 0x1864065a, 0x03076013, 0x12066014, 0x3f219f82, 0x229d84e1, 0x82e1f610, 0x02143495, 0x21230406, 0x16322111,
	0x34071216, 0x2323022e, 0x82203311, 0x60300846, 0xa8f7feb6, 0x970192fe, 0x5faef899, 0xb87e42c5, 0x01a2c975, 0x020c0108, 0xe9feb9e9, 0xb6055ebb,
	0xf4feb55c, 0x8ad592b6, 0x0189fb43, 0x01000024, 0x03217d83, 0x087d82be, 0x42000b29, 0x08142640, 0x01080801, 0x0d670004, 0x015a0a06, 0x5f090c64,
	0x0f01064f, 0x0206af06, 0x0a060608, 0x03025f05, 0x85015f0a, 0x3912258c, 0x715d5e2f, 0x322a9384, 0x1132e610, 0x315d2f39, 0x92822130, 0x03861520,
	0xfdbe0335, 0xfdf70209, 0xfd1702c3, 0x053d02e9, 0x3cfea4b6, 0x8af8fda2, 0x00092471, 0x82114070, 0x0f24086e, 0x03ff0103, 0x90038001, 0x0303d003,
	0xc0ffb803, 0x0a073840, 0x0b030348, 0x0b2f0b0f, 0x0baf0b8f, 0x00060704, 0x0a238d82, 0x830f5f09, 0x063f348d, 0x06ff066f, 0x40060804, 0x06481d1a,
	0x48151040, 0x83000606, 0x8200209b, 0xe13f2199, 0x2b219882, 0x209a882b, 0x06ce415e, 0x16827120, 0x23229f82, 0x9f852111, 0xba810122, 0x9a829c87,
	0xa4fcfd23, 0x06434200, 0x05f22908, 0x002b00cb, 0x2b1e4037, 0x5a290c2b, 0x2d670214, 0x1f012d10, 0x2c660c5b, 0x00005f2b, 0x115f1a24, 0x075f2404,
	0xe13f0013, 0xe1206a84, 0x29069441, 0x3911e132, 0x0130312f, 0x24421121, 0x3324280a, 0x07171632, 0x4223032e, 0x55080844, 0x1137023e, 0x010e0321,
	0x767037e4, 0xf29d4b82, 0xb65f56a6, 0x6fab0b01, 0x244858cc, 0x2e5d5853, 0x427fbc7a, 0x86be7837, 0x373e492c, 0x03d5fe1a, 0x1233fd04, 0x690a131c,
	0xae1701c3, 0xc31601ac, 0xa22a2c69, 0x0e171e11, 0x89da9851, 0x569cd882, 0x050b0805, 0xbb83b401, 0x00c72d08, 0x05d50400, 0x000b00b6, 0x0923403d,
	0x65005a01, 0x010dc00d, 0x20010dbf, 0x0408010d, 0x0c64055a, 0x080f5f03, 0x08080801, 0x0503060a, 0x24058f44, 0x5e2f3933, 0x27c1845d, 0x5d5d5d32,
	0x32e1f610, 0x3b052241, 0x33112311, 0x33112111, 0xfdbad504, 0x02baba66, 0xaa02ba9a, 0xb60556fd, 0x680298fd, 0x52246b83, 0x64020000, 0x3b086b84,
	0x0b264057, 0x020d2b0d, 0x0d9b0d7b, 0x0dfb0dab, 0x010d5404, 0x0d3b0d2b, 0x1f030d4b, 0x0802010d, 0x055a0a0b, 0x0103c902, 0xf8ffb803, 0x100d1040,
	0x01030048, 0x04090306, 0x0a030306, 0xc1258383, 0x32c13f32, 0x28858201, 0x32c15d2b, 0x5f32c1f1, 0x2000825d, 0x08858271, 0x37352127, 0x21352711,
	0x17110715, 0xeefd6402, 0x1202acac, 0x2966acac, 0x66299804, 0x68fb2966, 0xff010029, 0x017bfe48, 0x08858273, 0x2f001324, 0x15df1c40, 0x70156001,
	0x152f0215, 0x0c5a0f01, 0x0c000303, 0x07020c10, 0x07030d0c, 0x2f00005f, 0x63833fe1, 0x102f3323, 0x235e82e1, 0x22033031, 0x8209bd50, 0x142408e9,
	0x331d020e, 0x4e221c4c, 0x3d4b252d, 0x693bbb26, 0x0d7bfe93, 0x0b09a00b, 0x44583213, 0x5efab605, 0x31659a69, 0x20076341, 0x377182a2, 0x4064000c,
	0x660c022d, 0x000c010c, 0x0b100b0a, 0x0000010b, 0x07020010, 0x00290482, 0x010eb00e, 0x10010e2f, 0x0575410e, 0x10020d2b, 0x0848100b, 0x40f0ffb8,
	0x3208820c, 0x0a050802, 0x05000306, 0x333f0012, 0x3912333f, 0x452b2b39, 0x5d27064a, 0x382f3311, 0x82335d5e, 0x11332205, 0x270d8239, 0x23213031,
	0x23110701, 0x373fa082, 0x04013301, 0x3dfed3a2, 0x79baba8b, 0xfdd1c401, 0x72ba02f8, 0xb605b8fd, 0x02a825fd, 0x4383fd33, 0x05360bc7, 0x13402300,
	0x07af0704, 0x01071001, 0x64005a03, 0x03030106, 0x7082005f, 0x833fe121, 0x845d206a, 0x8233205a, 0x15212555, 0x3d02bac7, 0xf021df82, 0x059543a6,
	0x822f0621, 0x00193cdb, 0x3613408b, 0x00390119, 0x080e1701, 0x39480f0c, 0x110e010e, 0xffb8195a, 0x821c40f8, 0x0019210e, 0x00321483, 0x090c0d0d,
	0x4f1b6510, 0x1b20011b, 0x011b0f01, 0x20830b08, 0x20821a20, 0x010b263a, 0x5a08020b, 0x181a6409, 0x09100101, 0x0e014812, 0x0c11030b, 0xb6f0ffb8,
	0x0c210c82, 0x298a8308, 0x322b3232, 0x2b33333f, 0xfd843311, 0x2b5d3231, 0x5d5d5d5e, 0x3911f610, 0x2b331139, 0x82e12b33, 0x31323411, 0x215d5d30,
	0x17162301, 0x11151616, 0x01211123, 0x82210133, 0x343b0807, 0x37363736, 0x23030123, 0x060845fe, 0xac050404, 0x9c011401, 0x019e0106, 0x0304ba14,
	0xfe080304, 0x4a000541, 0x398b3f49, 0xb60596fc, 0xa80458fb, 0x77034afa, 0x473d8634, 0x8502fb49, 0x0e0521e7, 0x2d08e782, 0x40510017, 0x01280e29,
	0x5a150101, 0xb0196500, 0x198f0119, 0x10190001, 0x0c270219, 0x09030c01, 0x18640a5a, 0x06100216, 0x0b024818, 0xbd830d03, 0x0d210a82, 0x20bd860a,
	0x86a5823f, 0x82b884ba, 0x21af82b0, 0xae892321, 0x3301332e, 0x032e2726, 0x05331135, 0x31fdd70e, 0xd533aa85, 0x0307cc02, 0x03030104, 0xba04ae01,
	0x8e414c4d, 0x82e7fc39, 0x4c4c32a4, 0x4343204a, 0x20031a3e, 0x00020000, 0x05ecff7d, 0x068f5571, 0x40342108, 0x005b1e20, 0x29c02967, 0x0129bf01,
	0x2f012970, 0x02295f29, 0x660a5b14, 0x0f5f2328, 0x055f1904, 0x41058944, 0x5d2105d9, 0x081d465d, 0x081f9d55, 0x51710548, 0xa39beda0, 0x4c4c9def,
	0x9ba3f09e, 0xfb51a0eb, 0xa56b34d1, 0x6ba57272, 0xa46a3232, 0x6ca67272, 0xa9dd0234, 0x6cc6eafe, 0x1701c66c, 0x1501aaaa, 0xc56b6bc4, 0x89abebfe,
	0x515199db, 0x8a89db99, 0x515197da, 0xb183da97, 0x00c74108, 0x05330400, 0x000e00b6, 0x40460019, 0x285b152c, 0x48003800, 0x67000300, 0x011bcf1b,
	0x0f011b40, 0x0f06011b, 0x64085a07, 0x30600f1a, 0x02064006, 0x19070606, 0x07030960, 0x3f3f0012, 0x2f3911e1, 0x42068544, 0x5d310505, 0x013031e1,
	0x23020e14, 0x11231123, 0x021e3221, 0x08454801, 0x33043608, 0x98cf7e37, 0x6a01ba96, 0x3c7ec286, 0x5d814efd, 0xa42e5b8b, 0x0a04a0ae, 0x4d81a85b,
	0xb605c7fd, 0xfea06d39, 0x71472067, 0x00898e51, 0xfe7d0002, 0x057105a4, 0x089782cd, 0x38002d2b, 0x5b242240, 0xc02f6700, 0x2fbf012f, 0x012f7001,
	0x2f5f2f2f, 0x105b1a02, 0x5f292e66, 0x5f1f0415, 0x07130b05, 0x333f2f00, 0x066a47e1, 0x8505d941, 0x0107248b, 0x41060123, 0x312b2154, 0x015d8e5f,
	0xebfef452, 0x41122411, 0xef23055c, 0x41ec9aa4, 0x832a155c, 0x2585b5e2, 0x4c018bfe, 0x62410202, 0x0523481e, 0x05a03108, 0x000f00b6, 0x4082001c,
	0x190f0956, 0x0ff9020f, 0x0b080f01, 0x0c0f480f, 0x07010c09, 0x5b16010c, 0x07180708, 0x09070702, 0x0ee9010e, 0x0e020ef9, 0x20081d83, 0x0d100d0e,
	0x8f1e3f1e, 0xbf1e9f1e, 0x051edf1e, 0x10011e20, 0x64025a01, 0x10030c1d, 0x01000060, 0x32038208, 0x0303601c, 0x0012010e, 0xe13f333f, 0x5e2f3911,
	0x4912e15d, 0xce2708e1, 0x5d2b3238, 0x832f3271, 0x5d5e2313, 0x0c823311, 0x01303131, 0x21112311, 0x14151620, 0x0107020e, 0x41270123, 0x7008059f,
	0x2323022e, 0x01ba8101, 0xfe0a0164, 0x37685131, 0xfedb8e01, 0x5aa4e5a1, 0x2925517e, 0xa0577f53, 0xa4fd5c02, 0xd1ceb605, 0x3e5d8257, 0x0271fd14,
	0x45239e5c, 0x64484567, 0x01001d40, 0xecff6800, 0xcb05c903, 0x42003300, 0x23592740, 0x5a112301, 0xbf356700, 0x0235ff35, 0x3f013560, 0x5a2a0135,
	0x34661b09, 0x27052a11, 0x0420245f, 0x0509600e, 0x22b08213, 0x82333fe1, 0x21ad83ac, 0xaf41e132, 0x5d332105, 0x2205b141, 0x55262223, 0x36270512,
	0x022e3435, 0x51032e27, 0x162505d3, 0x26260717, 0x06cf5223, 0x031e5b08, 0x8045c903, 0xc16f73b8, 0x60572241, 0x99a03266, 0x5d7a491d, 0x29558359,
	0x61a17440, 0x434abe77, 0x7a58a541, 0x73461e86, 0x5c895b54, 0x6187012f, 0x23376a99, 0x1f10b222, 0x70780f18, 0x3f435036, 0x68532325, 0x8a585484,
	0x232d325f, 0x712b1d9c, 0x43533960, 0x4c24213b, 0xd3827e60, 0x00145f08, 0x05120400, 0x000700b6, 0x0f32405e, 0x09d00109, 0xcf094f01, 0x09100209,
	0x09300920, 0xef06af03, 0x06840206, 0x07060601, 0x0340025a, 0x0f0203e0, 0x03080103, 0x67025703, 0x03027702, 0xc0ffb802, 0x0a070b40, 0x03070248,
	0x0003045f, 0x3f3f0012, 0x2f0132e1, 0x2f335d2b, 0x105d5d5e, 0xd64f32e1, 0x47712005, 0x353105b4, 0x02211521, 0x5efebb71, 0x5ffefe03, 0xa4a41205,
	0x08818200, 0xecffb82b, 0xb805dd04, 0x2f001700, 0x5a161c40, 0xb0196501, 0x196f0119, 0x100219af, 0x5a0e0119, 0x1118640b, 0x0c13065f, 0x3f000300,
	0x08f54232, 0x20054444, 0x07405f11, 0x11331122, 0x0806ef4d, 0xdd04112a, 0x88c98542, 0x4485c480, 0x59afadbb, 0x01285280, 0x4cfcb805, 0x5290c472,
	0x7ac78e4d, 0x48fcae03, 0x6236c0af, 0xb8035188, 0x00247b82, 0x8b040000, 0x0c34fd82, 0x10406c00, 0x09090203, 0x01600004, 0x01b00170, 0x010401f0,
	0x2608db83, 0x480a0616, 0x01011001, 0x7f0e2f0e, 0x030ebf0e, 0x0906400e, 0xb8040548, 0x04b4f0ff, 0x09030405, 0xb3e0ffb8, 0x8248110a, 0x40f02207,
	0x251a820a, 0x12030209, 0xaa820100, 0x333f332d, 0x3f2b2b33, 0x382f0133, 0x4d5d2b33, 0x332c0549, 0x2f3d3912, 0x30313333, 0x23013301, 0x16360382,
	0x36361716, 0xc6c50337, 0xfebb17fe, 0x2701c519, 0x0f112a1d, 0xf65a1f2e, 0x61fc2705, 0x4a4aa95b, 0xa34161a9, 0xfe062105, 0x2a2ea582, 0x10b6df00,
	0x48181508, 0xffb80f10, 0x0882b5f8, 0x82070f21, 0x40f822a5, 0x210a8212, 0x19830001, 0x1d160022, 0x1d210683, 0x2120821c, 0x16822f40, 0x251c2808,
	0x04010714, 0xb4074407, 0x04070307, 0x24251425, 0x54254425, 0x16070525, 0x07162525, 0x000d1e03, 0x0e70010e, 0x82c00e80, 0x38f083db, 0x480a0718,
	0x0e0e100e, 0x7f2c6f2c, 0x2c20022c, 0x0f022c30, 0x1f08012c, 0x24f2821e, 0x161e1340, 0x21ed8220, 0xe9821016, 0x000d1627, 0x2507031e, 0x06014125,
	0xf0210782, 0x241682b6, 0x121d1025, 0x21fb8400, 0x06823311, 0x2b2b3322, 0x20054b4e, 0x0603415d, 0x12337131, 0x2f3d3917, 0x5e5d2f2f, 0x3311715d,
	0x892b332b, 0x30313b04, 0x1e133301, 0x033e1703, 0x01331337, 0x26260323, 0x06272627, 0x07060607, 0x19882303, 0x29034d08, 0x1d0fe5c5, 0x04061319,
	0x0b13100c, 0x91fec7c8, 0x1a0efebc, 0x0b0b0c0b, 0x0e190a0b, 0x7efebcf2, 0x140cdfc5, 0x05050e11, 0x0d17140f, 0xa8fcb605, 0x5e697038, 0x635a2626,
	0x72033167, 0xaa034afa, 0x372f6c33, 0x2f373334, 0x5cfc3670, 0x872a1f82, 0x5b62632e, 0x6c622526, 0x1142316f, 0x60440806, 0x0b00b605, 0x1d408100,
	0x0a100a09, 0x0b37000a, 0x38080b01, 0x02050105, 0x00000102, 0x80007001, 0x0300c000, 0xc0ffb800, 0x0a071440, 0x00100048, 0x0d0f0d00, 0x0d2f0d1f,
	0x08040d7f, 0xffb80607, 0x0606b3f0, 0x2b05644f, 0x02280410, 0x01082701, 0x09040802, 0x00301282, 0x323f0012, 0x3912333f, 0x015d5d39, 0x3232382f,
	0x2a0c674f, 0x332f3d39, 0x5d33335d, 0x82183311, 0x30312517, 0x01012321, 0x33290282, 0x01330101, 0xfed36004, 0x39eb829e, 0x5afec501, 0x014c01c6,
	0x5bfebe4e, 0x85fd7b02, 0xba02fc02, 0x2f02d1fd, 0x9a824cfd, 0x00820020, 0x82370421, 0x00083dbd, 0xef194073, 0x400a010a, 0x08480c09, 0x980107ab,
	0x07400107, 0x01071b01, 0x0701070f, 0x403da082, 0x0507072f, 0x01028001, 0x1b01024f, 0x10020102, 0x04000202, 0x8705775a, 0x03059705, 0x06ad534f,
	0x36050729, 0x01000100, 0x42071204, 0x122105d1, 0x25b48239, 0x5d5d5d5e, 0xb88239e1, 0x33240782, 0x382f3311, 0x5d260782, 0x5d2b335d, 0xa7833031,
	0x1123113b, 0x1b023301, 0xfec85401, 0x42febb42, 0x02d302cb, 0xfd83fce3, 0x032f02c7, 0x06974b87, 0x82fe0321, 0x092108a1, 0x20403800, 0x07030909,
	0x0b0f0b67, 0x0b4f0b3f, 0x08040b9f, 0x01040408, 0x04070a66, 0x0203055f, 0x05c54d08, 0xe13f392b, 0xe6100139, 0x5e322f32, 0x2606825d, 0x30312f32,
	0x58352121, 0x213505c2, 0x54fcfe03, 0x4dfdc702, 0x3afd8303, 0x0491db02, 0xfb91a67f, 0x24658381, 0x02bcfea4, 0x3b658239, 0x40260007, 0xf3000417,
	0x0100f106, 0x01b00110, 0x010401c0, 0xf802f505, 0xf901f506, 0x21082f5e, 0xba8232ed, 0x21112135, 0x33112315, 0x6bfe3902, 0xdfdf9501, 0xfa06bcfe,
	0x8331fa95, 0x0017244b, 0x82e90200, 0x0003254b, 0x0102b721, 0x05284682, 0xffb80300, 0x0203b4f0, 0x3505ba5e, 0x382f012f, 0x38331133, 0x30313311,
	0x01230113, 0xb22002c9, 0xc443e0fd, 0x243f8305, 0x01bcfe33, 0x368b84c9, 0x03144024, 0xf101f300, 0x06700660, 0x00090602, 0x03f907f5, 0x85f804f5,
	0xd6102388, 0x8983e15d, 0x11331724, 0x8d823523, 0xdfdf333f, 0x6afe9601, 0x95cf05ae, 0x000006f9, 0x02290001, 0x05190425, 0x000600c1, 0x0303b612,
	0x28128208, 0xcd3f0006, 0x33112f01, 0x2078832f, 0x087a8233, 0x01290121, 0xbf0166cb, 0xfeaffea1, 0x032502a3, 0x0264fc9c, 0x0021fddf, 0xfefcff01,
	0xff4e03bc, 0x82030048, 0x0000293b, 0xba010105, 0xe12f0002, 0x012c3b86, 0x03213521, 0x03aefc4e, 0x8cbcfe52, 0x47085682, 0xd9048901, 0x21061203,
	0x16000d00, 0x06000a40, 0x000f8008, 0x0002005f, 0x1a5d2f00, 0xcd2f01cc, 0x23013031, 0x3527032e, 0x17031e33, 0x23781203, 0x103f4d52, 0x2e2b10db,
	0xd9041530, 0x5158531c, 0x5122151b, 0x001d4c51, 0x6f083282, 0x03ecff5e, 0x005e049c, 0x00320023, 0x10114054, 0x23472901, 0x340f3455, 0x0602346f,
	0x1a0c4830, 0x40d0ffb8, 0x48110d1e, 0x0c09101a, 0x0c1a1a48, 0x16193356, 0x522a1d50, 0x101d1010, 0x07025024, 0x00150016, 0xe1333f3f, 0xe12f393f,
	0x0132e110, 0x2f32e610, 0xe1102b2b, 0xf6105d5e, 0x313232e1, 0x23272130, 0x2223030e, 0x3435022e, 0x35373736, 0x21051664, 0x4d552707, 0x11620806,
	0x023e3225, 0x0e073535, 0x16141503, 0x08251903, 0x604e4221, 0x5574453f, 0xb8ece730, 0x3451371d, 0x40428f53, 0x6664b64a, 0xfe306195, 0x4c683d2f,
	0x7a5a8f2b, 0x98612049, 0x142a412d, 0x547b5127, 0x0708b0a4, 0x375a4345, 0x89223018, 0x59293828, 0x10fd628a, 0x754d267f, 0x0407634f, 0x33513920,
	0xe583565c, 0xffae3308, 0x063f04ec, 0x001f0014, 0xb538002f, 0x5705482d, 0xffb83131, 0x0a1740b8, 0x25101549, 0x30541247, 0x15120013, 0x0a0f502a,
	0x1b502016, 0x3f001000, 0xd483e132, 0x84013f21, 0x462b20c5, 0x275d05cc, 0x07232e0b, 0x11331123, 0x06070614, 0x033e3307, 0x089b4f17, 0x34353637,
	0x5e9e0226, 0x3c3c6d9a, 0x3b5e9a6d, 0x173b4d60, 0xb685250c, 0x08008202, 0x3a170843, 0x5019604d, 0x1b1b416b, 0x87516c41, 0x5e047f7f, 0x8cd48f48,
	0x4990d58d, 0x203a2b1a, 0xfe14068b, 0x224f2388, 0x3c232628, 0x3397192c, 0x65699c68, 0xda376b9d, 0x00ced0cc, 0xff710001, 0x046f03ec, 0x3ac1825e,
	0x1d18402a, 0x215f210d, 0x1002217f, 0x48160121, 0x13205605, 0x19100a51, 0x51160051, 0x5d2909e0, 0x3132ce10, 0x2e220530, 0x08b04802, 0x032e4408,
	0x15062223, 0x32331614, 0x06153736, 0x65520206, 0x4c4a82b0, 0x4e66b285, 0x17363295, 0x1a3a3c38, 0x9491909d, 0x36368351, 0x893f147b, 0xdb9d96d5,
	0x19223e89, 0x0f130a9a, 0xd3d4c909, 0xa21925c3, 0x5d001e1d, 0x022206b9, 0x89821406, 0x00302008, 0x261d4034, 0x1e471b00, 0x32103255, 0x0b482e01,
	0x151f3156, 0x502b001c, 0x20101016, 0x82060150, 0x41332090, 0x11420947, 0x42252007, 0xfb6a0810, 0x33172e05, 0x26262726, 0x11331135, 0x3e322523,
	0x07234202, 0x2208aa82, 0x16085403, 0x3c604d3b, 0x3c6e9a5d, 0x5d9a6e3c, 0x3c4d603b, 0x03030c16, 0x93b60402, 0x694cc6fe, 0x41021f41, 0x9324064a,
	0x1a2e3d22, 0x31084d41, 0x22203a2c, 0x10371a1f, 0xecf9b401, 0x8d5e2e83, 0x4941295e, 0xcdd12105, 0x3008bf85, 0x5e04e103, 0x27001e00, 0x28404300,
	0x10194823, 0x29e02957, 0x01296f01, 0x05481122, 0x50112856, 0x222b221b, 0x01220f02, 0x14222206, 0x100a501f, 0x075b4114, 0x2f391224, 0xec505d5e,
	0xf6102308, 0x6441e132, 0x021e240b, 0x60211515, 0xb90805cf, 0x030e1537, 0x07062203, 0x022e3421, 0xb66e6002, 0x78424883, 0x9e6365a7, 0x4cfd3b6e,
	0x33979905, 0x274c5157, 0x57514d28, 0x0b857260, 0x391bec01, 0x8e4a1458, 0xd68887d2, 0x81474e95, 0xc1716eb5, 0x1d130ab6, 0x1c13a212, 0xdb030812,
	0x7144959c, 0x01002c50, 0x00001d00, 0x1f06f002, 0x70001b00, 0x1dcf4e40, 0x60021ddf, 0x901d801d, 0x041da01d, 0x1d3f1d1f, 0x1b031d4f, 0xbf107f1b,
	0x10100210, 0x0347021a, 0x050f0307, 0x052f051f, 0x050405af, 0x10030005, 0x80032003, 0xa0039003, 0x03060603, 0x074f0501, 0x07011a00, 0x50140f1a,
	0x1502010d, 0xe13f3f00, 0x335d5e3f, 0xe35032e1, 0x115d2d05, 0x32e11033, 0x395d2f32, 0x5d5d5d2f, 0x2206c760, 0x4a373523, 0x0e200cfe, 0xb008ef82,
	0xf58b0233, 0x2dc2c2b7, 0x3b4e7c55, 0x1f2f2763, 0x3a282849, 0x03f51326, 0x033ffcc1, 0x60444bc1, 0x23548d6b, 0x0b8d0e17, 0x53301311, 0x00006841,
	0xfe250003, 0x04fc0314, 0x003f005e, 0x005e0052, 0x0d1940a7, 0x47530532, 0x602f1237, 0x80377037, 0x2f370337, 0x48272f37, 0x0547591d, 0x40c0ffb8,
	0x480a074d, 0x0a010505, 0x1dfd011d, 0x011db001, 0x20011d88, 0x401d301d, 0x1d1d031d, 0x01601f60, 0x60df60bf, 0x0160a002, 0x0c402740, 0x0227480f,
	0x040d3205, 0x0a52563c, 0x4f5c220a, 0x0f4e2c3c, 0x17070117, 0x45103c17, 0x011b224f, 0x3f000f00, 0x37e782c1, 0x5d5e2f39, 0xe11039c1, 0xe12f3911,
	0x01391712, 0x5dc12b2f, 0x3311715d, 0x5d3aea83, 0x2f393371, 0xc110e12b, 0x2f393911, 0xc1105d2f, 0x3912e110, 0x01303139, 0xb4620715, 0x030e2609,
	0x021e1415, 0x070f5a33, 0x2805dd44, 0x2637023e, 0x36343526, 0x09244c37, 0x25830120, 0x3536322e, 0x23022e34, 0x020e2223, 0x33161413, 0xd2080e83,
	0x06222326, 0x1cc5fc03, 0x8c5f2f26, 0x0e2c165d, 0x111b2111, 0x1f382918, 0x51805db0, 0xcd864124, 0x6aa06b8b, 0x57422735, 0x40362a2f, 0x31472b45,
	0x9262321b, 0x1b4f2561, 0x3b1a40fe, 0xb9ba4861, 0x415a3718, 0x3f4c23b0, 0x636c5c29, 0x64696764, 0x4a046a63, 0x6d231b71, 0x5e814c45, 0x0a030135,
	0x18282019, 0x0612211b, 0x3d6d502f, 0x34618c58, 0x4771502a, 0x2a425b3c, 0x3552130b, 0x122a593d, 0x3360513f, 0x34628c59, 0x02fb090b, 0x1b2e4025,
	0x3a2e6c73, 0x2c100c21, 0x7360034d, 0x7b776f70, 0x01007874, 0x0000ae00, 0x14061204, 0x32001900, 0x47001d40, 0x101b5519, 0x801b601b, 0x0e0f031b,
	0x540b470a, 0x5004101a, 0x000c1015, 0x0015000b, 0x563f323f, 0x322a06f7, 0xf6105d32, 0x213031e1, 0xe4823411, 0x15020e27, 0x33112311, 0x05986111,
	0x15165108, 0x695c0311, 0x436e5170, 0x08b6b61d, 0x5245190a, 0xb9b7305c, 0x8282c302, 0x60946634, 0x1406c7fd, 0x2b9032fe, 0xbf142a3f, 0x0033fdd2,
	0xa0000200, 0x75010000, 0x0300e505, 0x25001100, 0x13101440, 0x0c021320, 0x01044700, 0x53071254, 0x0f020f0f, 0x27057b46, 0x1001e52f, 0x32e132f6,
	0x2205a165, 0x5b340333, 0x250806a8, 0x26222306, 0xb6b66401, 0x162d3dc4, 0x3f111d27, 0x043d2d2c, 0x3c29014a, 0x2b1c0d36, 0x38393a1e, 0xbcff0200,
	0x618414fe, 0x00132408, 0x402e0021, 0x20231019, 0x0f1c0223, 0x03140c47, 0x22540c03, 0x1f1f5317, 0x50070f0d, 0x3f001b00, 0x83333fe1, 0x32e62467,
	0x8410322f, 0x5313206a, 0x132010fe, 0x422f788b, 0x1a173f30, 0x2e1b2336, 0x22b61323, 0x89136d48, 0x14fe3483, 0x0a940b0e, 0x41270f0b, 0xfbf40433,
	0x577b4d18, 0x895f072f, 0x05794194, 0xf0033a08, 0x0e001406, 0x0b405e00, 0x02040407, 0x44060303, 0xb8050105, 0x1740c0ff, 0x05480a07, 0x10050510,
	0x102f100f, 0x090d0702, 0x0f540a47, 0xb800000b, 0x1040f8ff, 0x07480f0c, 0x2a048208, 0x06030700, 0x0f03150a, 0x543f3f00, 0xc746051e, 0x4b5e2005,
	0x332e06e1, 0x39331133, 0x30313311, 0x33013701, 0x20540101, 0x03250807, 0x01875601, 0x6ffed325, 0xfed1ac01, 0xb4b46db0, 0xaa370210, 0x25fe6901,
	0xf80191fd, 0x065afe52, 0xfe36fd14, 0x219f85ed, 0x9f826401, 0x1a000332, 0x05100e40, 0x00020520, 0x04540147, 0x15000002, 0x01237182, 0x41e1f610,
	0x0123068a, 0x82b6b664, 0x014a0827, 0x0000ae00, 0x5e048706, 0x65002c00, 0x0a233f40, 0x010bb947, 0x0ba60b96, 0x010b8902, 0x0b770b67, 0x160b0b02,
	0x552c4700, 0x012ef02e, 0x20012ecf, 0x022e502e, 0x08012e0f, 0x16471519, 0x1a232d54, 0x500f041a, 0x17101f28, 0x6d42160f, 0x82322005, 0x32e122d7,
	0x06f85332, 0x4f5d5e21, 0x112205b3, 0x08822f39, 0x32e15d22, 0x420d7e42, 0x17260a88, 0x33033e33, 0x06861632, 0x11152e08, 0x6964d105, 0x1e416649,
	0x4d6963b7, 0xb61b3f68, 0x180a1a94, 0x2e594f42, 0x08269f78, 0x6057491a, 0x02b1af32, 0x2f8282c3, 0xfd58875b, 0x09a842a2, 0x944a0430, 0x142a3f2b,
	0x442f5e58, 0xd2bf162d, 0x134133fd, 0x12042105, 0x183de182, 0x1c403000, 0x55184700, 0x601a101a, 0x031a801a, 0x0b470a0e, 0x040f1954, 0x0c101450,
	0x0e2c430f, 0x88122b43, 0x082a439b, 0x2a439482, 0x84818610, 0x054b657b, 0x7b822d20, 0x1f001322, 0x1d3c7d82, 0x5700481a, 0xd0214021, 0x0321e021,
	0x0601210f, 0x560a4814, 0x0f501d20, 0x05501710, 0x20092248, 0x08e7535e, 0x200de26e, 0x0aa34405, 0x432d042c, 0x676fb27d, 0x43477fae, 0x0784b37c,
	0x8900fd25, 0x83879a9a, 0x02210803, 0x91d58927, 0xd5914c4c, 0x91d38889, 0xd3914b4b, 0xd3d3d188, 0xcfcfd1d1, 0x00020000, 0x0414feae, 0x8291823f,
	0x0020088f, 0x2e1e4036, 0x32571b48, 0x26013210, 0x470c0610, 0x2031540d, 0x10161150, 0x1b0c0f0e, 0x0005502b, 0x32259282, 0x3f3f3fe1, 0x05435833,
	0x24074144, 0x022e2205, 0x08b75527, 0x17413320, 0x021e2b05, 0x020e1415, 0x020e2203, 0x5b451507, 0x02262207, 0x0566499e, 0x0203032c, 0x1a94b604,
	0x4d3a1708, 0x81493c60, 0x48812006, 0x14220b24, 0x18482b1a, 0x2bfe2806, 0x23943606, 0x481b2d3d, 0x03250732, 0x8c5e2edb, 0x0626485f, 0x83ced021,
	0x827120c3, 0x820220c3, 0x001022c3, 0x26c38330, 0x2505202b, 0x83552447, 0x480e2fc6, 0x24315616, 0x200f221b, 0x101b500b, 0xcd82002c, 0x2506fa5b,
	0x10013f3f, 0xe848e1f6, 0x31322205, 0x0ece4830, 0x8e491720, 0x021e2508, 0x33373317, 0x23088756, 0x3502030e, 0x6620a88b, 0x2f09f048, 0x08173c4c,
	0x04b6931b, 0x0c030302, 0x604d3b16, 0x200dce48, 0x31bf8797, 0x233d2d1b, 0x01caf994, 0x1b3a13d5, 0x3d222220, 0x93421a2e, 0x08032105, 0x3308c182,
	0x40410016, 0xc203b20b, 0x03900203, 0x030203a0, 0x40c0ffb8, 0x480b071b, 0x30180303, 0x80185018, 0x0d110318, 0x17540e47, 0x150d0f0f, 0x10000712,
	0x33c13f00, 0x3220c985, 0x2306f85a, 0x32013031, 0x4506f352, 0x2c0806d3, 0x033e3317, 0x481d8902, 0x3b1c181a, 0x4b683f1a, 0x1694b629, 0x47391908,
	0x055e0458, 0x0705a805, 0x51855f33, 0x4a04b0fd, 0x3d502bc9, 0x248b8225, 0x03ecff5a, 0x088b823f, 0x4800352e, 0x13252d40, 0xa0009047, 0x57000200,
	0x5f373f37, 0x03379f37, 0x2c013710, 0x1d9f0947, 0x1d021daf, 0x29263656, 0x052c1350, 0x0e091022, 0x2c05b142, 0x39123f32, 0x0132e139, 0x325df610,
	0x05305ee1, 0x9f533320, 0x05155e0e, 0x0818a053, 0x6d3a3f5d, 0x9c6d609a, 0x544c1f3b, 0x5b412c59, 0x35141a39, 0x7348485c, 0x64372b50, 0xa161568c,
	0x89413f48, 0x17626647, 0x48465e38, 0x012a5071, 0x5178502d, 0xa6222328, 0x0f181f10, 0x243b2916, 0x3231321f, 0x4a3c1f1f, 0x6d464361, 0x222a264a,
	0x432b1d93, 0x2e34233e, 0x3c1e1d2f, 0x8200604b, 0x214608df, 0x8f02ecff, 0x1d004605, 0x19b15000, 0xc0ffb805, 0x0b082f40, 0x1f050548, 0x1f4f1f3f,
	0x471b1702, 0x2f121f14, 0x00120212, 0x20101010, 0xc010b010, 0x0610d010, 0x121a1006, 0x1714164f, 0x0b50000f, 0xe13f0016, 0x8049333f, 0x5dc62106,
	0x5d240882, 0x2b2f3311, 0x2525e782, 0x37023e32, 0x06444d15, 0x23113e08, 0x33373735, 0x21152115, 0x01161411, 0x2a2d12fa, 0x280d0923, 0x3e193430,
	0x9b2c4d6a, 0x01694e9b, 0x3fecfe14, 0x08060481, 0x0c068a03, 0x4e200509, 0x7d026585, 0xfce64e51, 0x6183fd89, 0x08a98262, 0xecffa422, 0x4a040804,
	0x30001a00, 0x17011c40, 0x1c551a47, 0x1c601c10, 0x0f031c80, 0x1b540c47, 0x120f0d18, 0x200bd74d, 0x08d14233, 0xcb4d3120, 0x08ce530a, 0x09823520,
	0x1b750322, 0x0805cd47, 0x5c8a5b22, 0x6f6ab62f, 0x1d436e51, 0x3f2b93b6, 0x622e1429, 0xcd026998, 0x82823dfd, 0x60946534, 0xb6fb3a02, 0x21060351,
	0x8182d503, 0x6d00112f, 0xff1100b9, 0x0a0f40f8, 0x0011480e, 0x2c058208, 0x01090900, 0xffb8100f, 0x1512b3c0, 0x25078348, 0x0b071c40, 0x00821048,
	0xbf132008, 0xef13cf13, 0x13500313, 0x2f130f01, 0x03134f13, 0xb8010207, 0x0a40f0ff, 0x01094701, 0x48010f09, 0x3927060d, 0x382f015d, 0x525d5ec1,
	0x2b2906ce, 0x3d3912c1, 0x332b332f, 0x52be822b, 0x332005a2, 0x0805bd52, 0xfe770124, 0x0bc7bc89, 0x04191e1e, 0x1e180507, 0xbcc70b1e, 0x4a0489fe,
	0x68219dfd, 0x1919606c, 0x21686c60, 0xb0826302, 0x14000126, 0xe3050000, 0x2f25af82, 0x00b9c300, 0x20af822f, 0x29a9820c, 0x0908002f, 0x2700480e,
	0x1082b820, 0x0a821220, 0x831f2021, 0x091f2210, 0x21c78310, 0x16830f10, 0x16820920, 0x54180f32, 0xb8270127, 0x1540e0ff, 0x5b480a07, 0x20180118,
	0x27290782, 0x09181809, 0x2d110327, 0x83eb862e, 0x13402107, 0x2e30eb82, 0x312e2e10, 0x31303120, 0x01310f02, 0xb8111207, 0x1624e282, 0x091f2d11,
	0x113ae482, 0x0619270f, 0x76196619, 0x00190319, 0x3f001510, 0x115d3333, 0x5d333f33, 0xf4823333, 0xf4823320, 0x2f331125, 0x532b2b38, 0x2b2207c1,
	0x1f822b5d, 0x270ec153, 0x032e0321, 0x23272627, 0x410cb653, 0x13230513, 0x8517031e, 0x01590809, 0x04a8f003, 0x060d0c0c, 0x0e060f0e, 0x0b190b0d,
	0xe7fed3ac, 0x140a83bf, 0x06040e12, 0x16151105, 0xacc4b30a, 0x12161709, 0x0d030604, 0x890b1512, 0x02e4feba, 0x322d1268, 0x3e3a1934, 0x6a323a3f,
	0x049cfd25, 0x2db8fd4a, 0x1d5b6769, 0x5f61571a, 0xfd6b0221, 0x5f5c2295, 0x080d8258, 0x2f6d6830, 0xb6fb4802, 0x23000100, 0xdb030000, 0x0b004a04,
	0xa140e500, 0x86010989, 0x04060103, 0x0104f701, 0x360104e5, 0x05040104, 0x060106e8, 0x2982e703, 0x09098908, 0x02f80102, 0x0102ea01, 0x02010239,
	0x7b056b01, 0x05570205, 0x4a053a01, 0x01640205, 0x58020174, 0x01350101, 0x05020145, 0x09010901, 0x060b0305, 0x08f70108, 0x0108e501, 0x08010836,
	0x19164007, 0x0e400748, 0x076b4811, 0x5702077b, 0x073a0107, 0x0702074a, 0x300d100d, 0x0d90020d, 0x0f020db0, 0xd906010d, 0x0ac8010a, 0x010aba01,
	0x0a010a09, 0x0b4b0b3b, 0x010b2802, 0x0b150b05, 0x15070b02, 0x3f000f01, 0x5d2f013f, 0x2605176b, 0x5d5d5e5d, 0x82de1071, 0x2b2b220d, 0x270582c1,
	0x39171271, 0x2f182f3d, 0x0e821f83, 0x13841020, 0x5d331125, 0x855d3333, 0x30312d0b, 0x015d5d00, 0x13133301, 0x23010133, 0x21080283, 0xcf9ffe98,
	0xfecffafa, 0xcf75019d, 0xf2fef4fe, 0x023302cf, 0x0166fe17, 0xfde9fd9a, 0xfeb401cd, 0xf782004c, 0x14fe0a32, 0x4a04df03, 0x64002200, 0x081022b6,
	0x0f0e0008, 0x83063142, 0x40240807, 0x480b071d, 0x0f0f100f, 0xcf24bf24, 0x0324ef24, 0x0f012450, 0x4f242f24, 0x18070324, 0xffb80001, 0x000c40f0,
	0x23263682, 0x1b15501c, 0xc182000e, 0xe13f322b, 0x33333311, 0xc1382f01, 0x0f244333, 0x30313324, 0x03423313, 0x030e220a, 0x09e44a23, 0x37374408,
	0x0ed7bd0a, 0x0412191d, 0x1b160506, 0xbcc70b1d, 0x411c4efe, 0x34507456, 0x40151b4c, 0x34463023, 0x04390f25, 0x289bfd4a, 0x23525858, 0x5e615619,
	0xfb630221, 0x5a815127, 0x91060b31, 0x2c170705, 0x83a02940, 0x005224d1, 0x82350300, 0x00092fd1, 0x090b406c, 0x03010397, 0x480d0908, 0xd6820703,
	0x07114036, 0x0707480a, 0x5f0b3f0b, 0x030b7f0b, 0x08010898, 0xb5f8ffb8, 0x08221e82, 0x1f820204, 0x1512b727, 0x01023f48, 0x2c2b8202, 0x071240f0,
	0x0407480c, 0x020f054f, 0x29098210, 0x014f0802, 0xe13f0015, 0x03832b32, 0x5d2f0127, 0x2b33332b, 0x0542455d, 0x825d2b21, 0x0a9354d9, 0x1dfd3533,
	0x09fe1802, 0xf4fdb002, 0x037d1e02, 0xfc928944, 0x089983d1, 0xbcfe3d30, 0xb605a202, 0x40002700, 0x051a2540, 0x2720f705, 0x0f1323f1, 0x010c10f6,
	0xf50f230c, 0x0f0110d9, 0x02105f10, 0x1a291010, 0x05f819f5, 0xa15406f5, 0x39122605, 0xe15d5d2f, 0x39738239, 0xf13333e6, 0x322fe232, 0x14053031,
	0x1517021e, 0x1135032e, 0x35232634, 0x07823632, 0x0805c445, 0x1411154b, 0x16150706, 0xf4011516, 0x28412d18, 0x365f834d, 0x837d7d83, 0x4d835f36,
	0x182d4128, 0x77737377, 0x233d3010, 0x0196010d, 0x4e6e4721, 0x56674e01, 0x0167569b, 0x476e4e4d, 0x01950121, 0x303d230d, 0x7b69b4fe, 0x7a140c14,
	0x08b3826a, 0xfee90143, 0x067f0214, 0x00030014, 0x001f402d, 0x05300105, 0x05700540, 0x02040580, 0x100300aa, 0x80034003, 0x0503c003, 0x1b020307,
	0x3f000000, 0x5e2f013f, 0x715de15d, 0x33013031, 0xe9012311, 0x14069696, 0x221882f8, 0x82330001, 0x829820fb, 0x832920fb, 0x0d2308fb, 0x07f72424,
	0xf61af100, 0x1d900314, 0x1a041d01, 0xff19eff5, 0x19d90219, 0x0e191901, 0xf923f524, 0x550ef50d, 0x11200514, 0x3322fb88, 0xfb86e633, 0x36341326,
	0x26263537, 0x5e7af282, 0x25f28205, 0x1533021e, 0x08820622, 0x07020e27, 0x35033e35, 0x87e783e1, 0x412123ff, 0x01413e60, 0x3b012309, 0xdd827a6a,
	0x01697b27, 0x233d304c, 0x08f3820d, 0x6e472168, 0x34b3fe4e, 0x9b142d48, 0xb2fe6756, 0x21476e4e, 0x0d019601, 0x00303d23, 0x02660001, 0x0302044a,
	0x0023005a, 0x1d0d403c, 0x01251025, 0x0a010a10, 0x1f0aad17, 0x40c0ffb8, 0x48131016, 0xad051f1f, 0x1f0d0f1c, 0x4f0d3f0d, 0x8f0d6f0d, 0x000d060d,
	0xf1335d2f, 0x322b2fc8, 0x5d2f01e1, 0x31ce105d, 0x032e0130, 0x9c832223, 0x33362908, 0x17021e32, 0x3233031e, 0x1537023e, 0x2e222306, 0x25120202,
	0x16292d37, 0x383b3c1c, 0x1d946419, 0x2f433732, 0x282f3725, 0x18221084, 0x10839563, 0x108b022f, 0x13050d16, 0xa2192c21, 0x190d056c, 0x330d8c14,
	0x93000200, 0x91018bfe, 0x03005e04, 0x41001700, 0xff0000b9, 0x2f05317e, 0x19a01930, 0x19c019b0, 0x9a040204, 0x0e03030e, 0x0f39b283, 0x0e480a07,
	0x139b0900, 0x02100200, 0x00020702, 0x2f5d5e2f, 0x2f01cef5, 0x08387e2b, 0x13331324, 0x585b1323, 0x06806d07, 0x3379d53b, 0x2313efdf, 0x2e1a1b2e,
	0x23141423, 0x2e1b1a2e, 0xa4021323, 0x4805e7fb, 0x07377e26, 0x0806606d, 0x00010034, 0x03ecffbc, 0x00cb05ba, 0x405a0025, 0x46031225, 0x0a04040f,
	0x40271525, 0x481e0127, 0x0a300a00, 0x0ad00a40, 0x1b0a0604, 0x0f120f73, 0x02057321, 0x9a830f05, 0x120f0c39, 0x0f050f48, 0x07100305, 0x3f001903,
	0x3939123f, 0x112b2f2f, 0x83e11033, 0x055a4203, 0x32c61030, 0x332f3911, 0x303132e1, 0x15070624, 0x5a7c3523, 0x0c84540d, 0x6e760336, 0x8a57894c,
	0x61353462, 0x4889568b, 0x17352e88, 0x193b3c38, 0x08068654, 0x021ed420, 0x4b0dcec8, 0x8d89c785, 0x0d4b88cb, 0x2103a4ac, 0x130a9a17, 0xd4ca090f,
	0x1825c3d2, 0xc78200a1, 0x00004437, 0xc9052304, 0x75002800, 0x110d1140, 0x0f0f236f, 0x07020f1f, 0x2205821f, 0x82170319, 0x0ab323b3, 0x0782480e,
	0x40c83008, 0x48090630, 0x102a1717, 0x1921012a, 0x480e0b40, 0x10291919, 0x2f0d7521, 0x8f227f22, 0xbf22af22, 0xff22df22, 0x22220722, 0x19741600,
	0x71730718, 0xcb820a06, 0x33011127, 0x5d332b2f, 0x21058211, 0xf584332b, 0x845d5e21, 0x0c154be2, 0x21152127, 0x020e1415, 0x08078207, 0x033e3585,
	0x35233535, 0x3e341133, 0x6a9a0202, 0x384242ae, 0x52304b8d, 0x7801213c, 0x271788fe, 0xec021b33, 0x492c21fc, 0xc6c61e35, 0x0592693b, 0x90232dc9,
	0x3b1b2b1d, 0xd9fe425e, 0x593ed389, 0xa6102b40, 0x44290b9a, 0x89d54361, 0x89574401, 0x0200325f, 0x1d017b00, 0x8b04ec03, 0x37002300, 0x23408600,
	0x01168f0e, 0xab2e1616, 0x180c0f15, 0x03211e06, 0x12700008, 0x39121201, 0x04013910, 0x80aa2420, 0x82000100, 0x404508ff, 0x480a0631, 0x17380000,
	0x1f011f80, 0x1e18060c, 0x0904060f, 0x1b00ae29, 0x050d1b01, 0x09cfae33, 0x900209ef, 0xb009a009, 0x091f0309, 0x096f093f, 0x2f000903, 0xe15d5d5d,
	0x5d2f32c6, 0x391712e1, 0x5dc63311, 0x83ff8432, 0x115d2413, 0x825d2f33, 0xf12b0815, 0x325d2fc0, 0x34133031, 0x37273736, 0x33363617, 0x37171632,
	0x16160717, 0x07061415, 0x06270717, 0x26222306, 0x37270727, 0x72372626, 0x42080a05, 0x020e2223, 0x811f23ba, 0x6c2f7f62, 0x2e6b3c3c, 0x1f826381,
	0x7f212325, 0x6b2e8160, 0x2d6e3c3c, 0x1f7f607f, 0x41258a23, 0x59333257, 0x42262642, 0x57323359, 0xd3022541, 0x812f6b3b, 0x24208162, 0x82812024,
	0x886d202a, 0x2024212a, 0x2d223182, 0x25823c6c, 0x89262621, 0x55002035, 0x2208052b, 0xb6054c04, 0x95001600, 0x18305b40, 0x0c130f01, 0x0115aa16,
	0x040c1515, 0x02ab0108, 0x01021f01, 0x82980202, 0x072e0828, 0x995a0b03, 0x10140114, 0x8a010c0f, 0x0c00010c, 0x0c400c10, 0x0a0c0703, 0x070f600e,
	0x6012060f, 0x13000313, 0x0f8f0f7f, 0x01133002, 0x488213d0, 0x02131f2a, 0x130f130f, 0x15120b01, 0x2d07755b, 0x5d2f2f39, 0x115d715d, 0xe1103333,
	0x04831132, 0x5e2f0122, 0x33281182, 0x32e15d33, 0x325d3932, 0x33341e82, 0x33113939, 0x12335d2f, 0x315d3939, 0x33010130, 0x21153301, 0x11240183,
	0x35211123, 0x11820183, 0x0133022e, 0x7ffebf5a, 0x01d3feef, 0xb2d3fe2d, 0xea300685, 0x02c085fe, 0xfde302d3, 0x899e8900, 0x0601fafe, 0x03240682,
	0x02000000, 0x080afd45, 0x39000726, 0x09002540, 0x40093001, 0x80097009, 0x06020409, 0x070003aa, 0x07400710, 0x07c00780, 0x04070705, 0x06030403,
	0x20050546, 0x83af8239, 0xe13322a0, 0x070b4632, 0x0f461120, 0x96962906, 0xf4fc1406, 0xf3fc19fe, 0x5e085f82, 0xf6ff7900, 0x1f065e03, 0x5a004500,
	0x4b407900, 0x51085605, 0x4c262146, 0x29463c46, 0x21ff1029, 0xb021a001, 0x5c210221, 0xbf015cc0, 0x4646015c, 0x08461700, 0x00003108, 0x10000001,
	0xc0003000, 0xf000d000, 0x00080600, 0x054c265b, 0x4c561756, 0x370d0429, 0x14152e50, 0x00010d50, 0x423fe13f, 0x1133055f, 0xc6100133, 0x32715d5e,
	0x10e12f32, 0x105d5de1, 0x835d5dce, 0x39122b0b, 0x11e11039, 0x30313939, 0x5b553413, 0x023e2206, 0x07864e33, 0x1415062c, 0x1e17021e, 0x0e141503,
	0x99550702, 0x08be7609, 0x27022e25, 0x8337032e, 0x3e172423, 0x82343503, 0x0e28080e, 0x2d1a8903, 0x554b1f3a, 0x568c6437, 0x38489d61, 0x63478c41,
	0x5f391866, 0x4e714846, 0x3429182a, 0x3b4c451c, 0x6c609b6c, 0x0805254e, 0x5d452bc5, 0x33111737, 0x73494c5e, 0x1c9a2950, 0x2348653f, 0x15212914,
	0x526c411a, 0x17262f19, 0x53332903, 0x260f2d40, 0x623d5472, 0x20282544, 0x3b271c8b, 0x2c2e1b39, 0x411c1d2f, 0x343e614e, 0x10314455, 0x474e6d26,
	0x21284d6f, 0x1e0f9e20, 0x27180e17, 0x2d1d1b33, 0x1f1f312d, 0x59644e3e, 0x373a3f25, 0x240d0f1e, 0x2622382e, 0x1e393b40, 0x3a2d1f08, 0x01020000,
	0x030c0533, 0x00d9056a, 0x0019000b, 0x0c214035, 0x0114af86, 0x8606c014, 0x00100000, 0x00500040, 0x0f000604, 0x9f179103, 0x0209cf09, 0x09010930,
	0x5d5d2f00, 0x0132e533, 0xe15d5e2f, 0xe15ddc1a, 0x34013031, 0x16323336, 0x23061415, 0x55252622, 0x24080c0b, 0x27283833, 0x28273a3a, 0x38770138,
	0x1a231328, 0x28263a10, 0x36730538, 0x35353130, 0x36353232, 0x26190c30, 0x3b09821b, 0x00030000, 0x06ecff64, 0x00cb0544, 0x00410025, 0x406a0055,
	0x1ac50543, 0x1a220f0f, 0x2c080182, 0x00c34c26, 0x34c00134, 0x42573401, 0xc90a26c3, 0x1fc90015, 0x151f150f, 0x157f152f, 0x159f158f, 0x1f000806,
	0x1f601f10, 0x1f801f70, 0x2d178205, 0xc8472d1f, 0x2dc8513b, 0xe13f0004, 0x5757e12f, 0x5d5e2c05, 0xe110e110, 0x10e12f01, 0x85715dde, 0x33112313,
	0xbe83102f, 0x20084a5b, 0x09f54e3e, 0xf9413420, 0x77012008, 0x042105f3, 0x05737515, 0x5e440420, 0x032f080f, 0x405e3d7b, 0x5f3d1d21, 0x39361743,
	0x31181938, 0x66233c35, 0x36336598, 0x3f649969, 0x343e3b84, 0x36befc61, 0xc0a78a61, 0xa7c06868, 0x8b36618a, 0x656d280b, 0x8585eaaf, 0x8765afea,
	0x04210807, 0x78532c1d, 0x52784e4b, 0x110c072b, 0x120b8309, 0x7a42070e, 0xa76567aa, 0x1d214378, 0xfe1c1a7f, 0x25448ebe, 0x35356289, 0x5c828962,
	0x4d82458b, 0x00006008, 0x03440002, 0x05420210, 0x001e00c7, 0x404e002d, 0x0f012d2f, 0x101d00e0, 0x2f1d021d, 0x2f1f2f0f, 0x2f7f2f4f, 0x24052faf,
	0x17170be0, 0x0b010b60, 0x0fe42d2e, 0x27011a0f, 0xc00600e4, 0xde1ae413, 0x1ae13f00, 0x39e1c4dc, 0xe12f3911, 0x5dc61001, 0xe1102f32, 0x5dd6105d,
	0x313232e1, 0x5d270130, 0x26230c62, 0x5d062223, 0x5c080561, 0x03111516, 0x1415030e, 0x3e323316, 0x01353502, 0x27121ce7, 0x2b23382f, 0x8d1d3448,
	0x383d638f, 0x302a5a30, 0x7d3c7533, 0x4433c977, 0x2a321229, 0x192b3a22, 0x16521d03, 0x1a0d1923, 0x66334d33, 0x1f04056c, 0x161d3948, 0x6a241a64,
	0x013afe7a, 0x1e120339, 0x2d331d2b, 0x2c412c15, 0x08d38231, 0x73005253, 0xc7039303, 0x0d000600, 0x11406000, 0xeb0d0402, 0x6004500a, 0x0a040204,
	0x0b060a04, 0xc0ffb809, 0x0c092140, 0x0f0f0948, 0xaf0f9f0f, 0xeb06030f, 0x0301039f, 0x0d030006, 0x050a0a07, 0x0c010303, 0x00010805, 0x332f332f,
	0x2f3d3912, 0x33113912, 0x23028233, 0x5d2f1801, 0xc622dd82, 0x2d42322b, 0xe1102105, 0x2605ba5f, 0x07130317, 0x84012501, 0x01523f06, 0xeeee7535,
	0x01cbfe75, 0x74360197, 0xfe74eded, 0x012902ca, 0xa4fe4e9e, 0x014ea4fe, 0x0a891b9b, 0x01003708, 0x06016600, 0x1d030204, 0x39000500, 0xaa022440,
	0x07100701, 0x01049601, 0x7901048b, 0x04560104, 0x01044b01, 0x12010438, 0x04090104, 0xad040401, 0x3f00b305, 0xca4d01e1, 0x5d5d3d06, 0xe1de105d,
	0x11013031, 0x35211123, 0xfc950204, 0xfd1d03f9, 0x968101e9, 0x00ffff00, 0x2706d77f, 0x10000602, 0x04000000, 0x08083743, 0x1e00085e, 0x4e003a00,
	0x7d40c200, 0x16b416a4, 0xb40316c4, 0x0217c417, 0x52011617, 0x0e170e15, 0x0e15c516, 0x0e151514, 0x1900090e, 0xc5091ac5, 0x00041504, 0x1a00011a,
	0x1ad01ac0, 0x048f0703, 0x1a041a01, 0xc3451f04, 0xc0012d00, 0x502d012d, 0x0e1fc33b, 0x0000c918, 0x15161b16, 0x1bc9081a, 0x26082c82, 0x1a1f1a0f,
	0x1a7f1a2f, 0x1a9f1a8f, 0x1b000806, 0x1b601b10, 0x1b801b70, 0x1a1b1a05, 0xc840261b, 0xc84a1334, 0x71000426, 0x39310570, 0x5e5d2f2f, 0xe110715d,
	0x11333311, 0xe1103912, 0x0c7b4332, 0x11201b83, 0x17821582, 0x87391132, 0x00102b10, 0x2b0587c1, 0x5d01c410, 0x015d3031, 0x3406b35a, 0x0e140523,
	0x17160702, 0x1717021e, 0x11230323, 0x32331123, 0x1f8f4316, 0x48e7023d, 0x59534f5b, 0x1b920146, 0x431f392d, 0x212a1735, 0xceb30a0a, 0xa8e99d5f,
	0x43ebfb9e, 0x033b2889, 0x4a454800, 0x4b30813b, 0x6e0d2839, 0x38472557, 0x60011111, 0x7d03a0fe, 0x43c3fe82, 0x01282883, 0x1406faff, 0xa0060604,
	0x08196561, 0xfb060427, 0x060c04f4, 0x00008c14, 0x037b0002, 0x05f20256, 0x001300cb, 0x40430027, 0x0aab1e2c, 0x01299f29, 0x0030aa14, 0x301d8240,
	0x0f10ae19, 0xe0020f20, 0x020ff00f, 0x00010f6f, 0x260e830f, 0x0f0f0603, 0x7605ae23, 0x5e2d0558, 0x715d5d5d, 0x5d2f01e1, 0xd6105de1, 0x05c746e1,
	0x440b335c, 0x7b2a0fbb, 0x41735532, 0x32567341, 0x07835632, 0x7b32552c, 0x2846341e, 0x1e354628, 0x0783351e, 0x041e3423, 0x351e888f, 0x31315572,
	0x27417255, 0x1e1e3445, 0x28274534, 0x1f1f3547, 0x97824735, 0x00662a08, 0x04020400, 0x000b00a2, 0x403a000f, 0x01111021, 0x0608080f, 0x010caa09,
	0x00ef0301, 0x60002001, 0x0300a000, 0x0cad0d00, 0x38431809, 0x832f2009, 0x335d29a6, 0xe1331133, 0x33113232, 0x0f404318, 0x15213524, 0x4318e901,
	0xfe230944, 0x189c037d, 0x08094843, 0x96fafe42, 0x00010096, 0x024a0231, 0x00c9056d, 0x4040001e, 0x00e10815, 0x204f2017, 0x2002207f, 0x480a0640,
	0x0f01e11d, 0xffb8010f, 0x150e40c0, 0x08014818, 0x12e50b1d, 0x01e51dde, 0xe13f00dd, 0x3912e13f, 0x2f06dd4c, 0xde105d2b, 0x3031e132, 0x37352101,
	0x3435033e, 0x5709c844, 0x390805f8, 0x02210707, 0xd1c4fd6d, 0x0f284839, 0x5d333642, 0x85364e2d, 0x44613c52, 0x4f361d25, 0x8c019433, 0xe4704a02,
	0x3b43553e, 0x32404122, 0x41305e26, 0x395b3f21, 0x5b555632, 0x9f829d37, 0x39021f24, 0x9f826802, 0x61003038, 0x00033c40, 0x060e1919, 0x0000e11e,
	0x3206e115, 0x328f325f, 0xa8833202, 0x0e27272a, 0x48201940, 0xe419030e, 0x35055f43, 0x1adf1a5f, 0x1a1a0805, 0xe5232612, 0xe512de2c, 0x00df0b0f,
	0xb482333f, 0x39123326, 0xe15d5e2f, 0xb883ba85, 0x2f33e124, 0x148211e1, 0x82391221, 0x061421c0, 0x210b9448, 0x42431616, 0x84352007, 0x2e5d0808,
	0x06222302, 0x033e2707, 0x021e3233, 0x45514e02, 0x53285858, 0x7b46567e, 0x35843f39, 0x606b5862, 0x545c6262, 0x1b2f2314, 0x4533613b, 0x4c443d1d,
	0x4669452c, 0x4ee70423, 0x6a17186a, 0x47643c4e, 0x851f1928, 0x49532622, 0x4f71434a, 0x1e2f2040, 0x6025290e, 0x0f1a2517, 0x00533c22, 0x0d1d6401,
	0x0500062e, 0x5f0c0f80, 0x000c020c, 0xcd1a5d2f, 0x08051d64, 0x37033e3d, 0x030e1533, 0x89012307, 0x2a2f2f16, 0x3f10db10, 0x7923514d, 0x4c1df404,
	0x15225151, 0x5358511b, 0x0100001c, 0x14feae00, 0x4a041204, 0x37001d00, 0x090d2240, 0x1f550a47, 0x47201f10, 0x143507db, 0x541c471d, 0x031b1a1e,
	0x0b161150, 0x0f091c15, 0x3f333f00, 0x0521703f, 0x105d3223, 0x051b7df6, 0x25057b46, 0x23113311, 0x174c2327, 0x078c6f05, 0x6401333b, 0x6e526f6a,
	0x93b61c43, 0x90300a1b, 0x236a4867, 0x01020201, 0x8701b6b6, 0x08305682, 0x5453932d, 0x28262a2e, 0xfe2a5523, 0x823606c0, 0xfe712893, 0x066604fc,
	0x82130014, 0x212d0893, 0x05009904, 0x05400530, 0x06040550, 0x010d0505, 0x10150099, 0x0d000115, 0x0d020d10, 0x05001203, 0x322f0000, 0x2f01c13f,
	0xd6105d5d, 0x05b141e1, 0x2107cc60, 0xb75f0611, 0x33240807, 0x78660421, 0x553d79cf, 0x3c6d9b5f, 0x64a67741, 0xfcfe3302, 0x87f97906, 0x33123303,
	0x938cc076, 0x003278c5, 0x93267982, 0x91014802, 0x79825e03, 0x1a40332b, 0x15801510, 0x15a01590, 0x94451804, 0x01e5271d, 0x5d5d2b2f, 0xfd435ded,
	0x7a932011, 0x02210f0f, 0x12a94fd3, 0xfe233608, 0x00980114, 0x00190000, 0x141f4039, 0x7f151313, 0x02128f12, 0x0d061212, 0x061b0084, 0x158c121a,
	0x480e0940, 0x0a131515, 0x2f00038d, 0x2f392fe1, 0x1001e12b, 0x27ed82c6, 0x5d2f3911, 0x33113333, 0x1420ef82, 0x2622ea82, 0x86423527, 0x2e340806,
	0x33372702, 0x01031e07, 0x16968d98, 0x310f0f2d, 0x1a504710, 0x5a253f2e, 0x3a223979, 0xe1fe192b, 0x03066c61, 0x2b03036c, 0x1a231831, 0x73b00913,
	0x3a291a08, 0x3c08ff83, 0x014a023f, 0x00b605ba, 0x4034000e, 0x7f104f21, 0x40100210, 0x0e480a06, 0x00e1020e, 0x038f037f, 0x30032002, 0x02030203,
	0xe5090ddd, 0x3f00dc00, 0x013fcde1, 0x335d5d2f, 0x2b2f33e1, 0x0572525d, 0x34115308, 0x0637023e, 0x27070706, 0x91873301, 0x01030301, 0x5e16260e,
	0xfcb6054a, 0x19040294, 0x16383c3c, 0x49112811, 0x02000060, 0x10034200, 0xc7058b02, 0x1f001300, 0x1ab22e00, 0xffb800e0, 0x091440c0, 0x2100480f,
	0x1401210f, 0x17200ae0, 0x1dc005e4, 0x1b490fe4, 0x25f58205, 0x105de1d6, 0xf76f2bd6, 0x0a6c5b07, 0x080bd35c, 0x298b0234, 0x3f446d4d, 0x292b4e6a,
	0x3e446d4c, 0xfe2c4e6b, 0x55564b3a, 0x56554b4b, 0x536d044b, 0x2f2f5982, 0x53538259, 0x2e2e5881, 0x77538158, 0x78777979, 0x8f837373, 0x73005424,
	0xeb489603, 0x40562206, 0x06d0482f, 0x04eb0724, 0x01820a02, 0x090b0337, 0x9feb000e, 0x03100103, 0x03400320, 0x070d0303, 0x0300060a, 0x4801820a,
	0x39230be3, 0x482f2f3d, 0x5d2309e3, 0x48c610e1, 0x112d05e2, 0x315de133, 0x27010130, 0x01370313, 0x08068505, 0xfe960320, 0xeded74ca, 0xfe360174,
	0x75cbfe68, 0x0175eeee, 0xfe0e0235, 0x5c014e65, 0xfe4e5c01, 0x0a891b62, 0xff003f08, 0x003f00ff, 0x058b0500, 0x002600b6, 0x0000007b, 0x02170227,
	0x0100004a, 0x023c0207, 0x00b7fdfc, 0x031d4030, 0x03181602, 0x0116bf02, 0x3f01168f, 0x01160116, 0x00011140, 0x00110111, 0x07820040, 0x11355d23,
	0x2603845d, 0x0035355d, 0x8235353f, 0x822c2051, 0x85a02051, 0x85ed2051, 0x83352051, 0x74002351, 0x51823303, 0x1840282d, 0x02181402, 0x14011400,
	0x8311b001, 0x0011244c, 0x85010070, 0x8249844c, 0x824a8351, 0x821f2049, 0x05ce2249, 0x209b82c9, 0x209b8675, 0x234983a8, 0x3f033c02, 0x3c254982,
	0x02032740, 0x089b8238, 0x01387021, 0x38013850, 0x0133b401, 0x840133a4, 0x33640133, 0x01335001, 0x20013330, 0x0f330133, 0x825d014c, 0x835d20a3,
	0x84ac8400, 0x020032a7, 0x77fe4400, 0x5e044403, 0x3b002700, 0x12404400, 0x06f57d32, 0x140b3208, 0x013d0f3d, 0x1c460b08, 0x40c0ffb8, 0x481b0f10,
	0x27170b1c, 0x379b2d27, 0x51101310, 0xe12f0017, 0x32e53f33, 0x0139122f, 0x5ee12b2f, 0x11ce105d, 0x29128239, 0x3031e12f, 0x0e141501, 0xe5630702,
	0x36322406, 0x44061737, 0x3724082b, 0x3535033e, 0x240f7c53, 0x27105002, 0x07fb7d41, 0x96543734, 0xbc524045, 0x67955d61, 0x51351b38, 0x26423436,
	0x9953ba0e, 0x3a252411, 0x7d4c515b, 0x333509fb, 0x3a2a9223, 0x588a6033, 0x545a6844, 0x3e432d2f, 0x01132b43, 0x0e10442f, 0x00ffff22, 0x26080082,
	0x7307dd04, 0x24002602, 0x07010000, 0xbdff4300, 0x15005201, 0x051502b4, 0xffb80226, 0x151bb49c, 0x01250704, 0x8200352b, 0x222f9202, 0x828d0076,
	0x4013242f, 0x8221020b, 0x156c2230, 0x232d9b1b, 0x1f004b01, 0xff225d8b, 0x5d931db4, 0x8d873520, 0x06202b82, 0x1d205d86, 0x01225d82, 0x5d922c1e,
	0xbb882b20, 0x21006a22, 0x172c2d82, 0x02030d40, 0x0326051e, 0x29150102, 0xbc832f85, 0x88003521, 0x860420bd, 0x06240831, 0x7d1f5001, 0x20403100,
	0x1aef0203, 0x011adf01, 0x40011a50, 0x1a20011a, 0x011a1001, 0x1a011a00, 0x1f000203, 0x3521a086, 0x082a4200, 0x00353208, 0xfeff0200, 0x56060000,
	0x0f00b605, 0x84001300, 0x13062a40, 0x015a0e0a, 0x03100111, 0x13a91304, 0x34132401, 0x03135413, 0x14010110, 0x0113010c, 0x0804820c, 0x0805033b,
	0x04156700, 0xf0ffb805, 0x09052040, 0x03065f13, 0x5f0d105f, 0x010a4f0a, 0x0aaf0a0f, 0x0a100802, 0x03060a10, 0x055f0e04, 0x3f001201, 0x3f2fe133,
	0x2f2f3939, 0x10715d5e, 0x280183e1, 0x382f0132, 0x32e61033, 0x063e7f11, 0x7d5d5d27, 0x11c4c487, 0x05215201, 0x2205e57a, 0x7a012303, 0x52080649,
	0x21012111, 0x56062311, 0x25fe08fd, 0x8f02bacb, 0xc3fdc903, 0xeafd1602, 0x75fb3d02, 0x016c9301, 0x053bfec5, 0x3cfea4b6, 0x01f8fda2, 0x00a802c6,
	0x7d00ffff, 0x980414fe, 0x2602cb05, 0x00002600, 0x7a000701, 0x0000fc01, 0x01b60b00, 0x18242a4f, 0x41012520, 0xc72a05ff, 0xbe030000, 0x26027307,
	0x25842800, 0xb7ff4334, 0x15005201, 0x050c01b4, 0xffb80126, 0x0c12b4c2, 0x2f420001, 0x222f8f0a, 0x413f0076, 0x012105d1, 0x22308218, 0x9b120c4a,
	0x4b01232d, 0x5d8bf1ff, 0x14b4fd22, 0x2b205d93, 0x6a228d88, 0x0142f5ff, 0x01022905, 0x02260515, 0x200c0101, 0x01425f85, 0x003e2408, 0x84640200,
	0x852c20bf, 0xb5fe21bf, 0xa820618b, 0x5220bf8f, 0x8a202f82, 0x76222f8a, 0xbf8a78ff, 0xbf8e6a20, 0x2d821120, 0x2d89a920, 0x0f20bf82, 0x0c202d86,
	0x0220ed82, 0x4020bd8e, 0x77212d82, 0x85bd8307, 0xff6a228b, 0x20bd8c0d, 0x08bd8d00, 0x00020040, 0x0400002f, 0x00b605fc, 0x001f0010, 0x1a3a405d,
	0x5b110e1a, 0x20216708, 0x1c180121, 0x10100e5a, 0x20640e01, 0x185f101b, 0x0f01000f, 0x6f003f00, 0xdf00af00, 0x0600ff00, 0x1a400008, 0x6e82481d,
	0x601c2208, 0x6017120e, 0x3f000302, 0x11e13fe1, 0x5e2b2f39, 0xe133715d, 0xe6100132, 0x102f3232, 0x105d32e1, 0x231683f6, 0x33133031, 0x3805c77d,
	0x06021415, 0x11212304, 0x2e342523, 0x11232302, 0x11211521, 0x2f002033, 0x05cd7d98, 0xb6604508, 0xfea8f7fe, 0x08049892, 0x75b87e42, 0xfe5001c9,
	0x0801a2b0, 0x25030c01, 0xb55c9102, 0xb9b0f4fe, 0x5ebbe9fe, 0x92608302, 0xfe438ad5, 0x1dfea20e, 0xffff2401, 0x0000c700, 0x35070e05, 0x31002602,
	0x07010000, 0x8b20f582, 0x27062741, 0x01260520, 0x0a2f210a, 0x260b4342, 0x05ecff7d, 0x82730771, 0x4132202d, 0x002105b3, 0x2c2d8254, 0x2802b415,
	0xb8022605, 0x2eb4abff, 0x222f9c28, 0x85020176, 0x3402215d, 0x58223082, 0x2d9b2e28, 0x004b0123, 0x832d86ae, 0x3005215e, 0xb9835b93, 0x29828b84,
	0x8b857d20, 0x8b843020, 0x31b4f023, 0x205d923f, 0x22bb882b, 0x41aa006a, 0x032905e3, 0x26053102, 0x28010203, 0x422f853c, 0x210805a1, 0x8d000100,
	0xdd032d01, 0x0b007b04, 0x00b98700, 0xb3f0ff06, 0x06481714, 0x40e0ffb8, 0x48120f18, 0x0d821000, 0x82200021, 0x83092009, 0x83092009, 0xb8032109,
	0x07822485, 0x3040e022, 0x40341a82, 0x0507010d, 0x010b0305, 0x01035001, 0x0a0a0803, 0x20020204, 0x002a5982, 0x00500020, 0x00800070, 0x4a5500a0,
	0x06092c05, 0x1900b300, 0x715d5e3f, 0x82331132, 0x2f012402, 0x8411335d, 0x315d2401, 0x822b0030, 0x84012000, 0x01800804, 0x17010137, 0x01070101,
	0xcb012701, 0x0169c2fe, 0x6842013d, 0x3f01bffe, 0xfebefe66, 0xd30267c3, 0xfe693f01, 0x673e01c2, 0xc0febffe, 0xfe3d0166, 0x000067c5, 0xff7d0003,
	0x057105b4, 0x001a00fc, 0x00310026, 0x293a405c, 0x041e2a1f, 0x015b271b, 0x040e0b19, 0x33670411, 0xbf0133c0, 0x33700133, 0x5f332f01, 0x5b1b0233,
	0x1f326611, 0x042a1e29, 0x195f222d, 0x040b0e01, 0x04161a09, 0x090c5f2d, 0x26065477, 0xe1391712, 0x7a391711, 0x0c820957, 0x31321083, 0x16070130,
	0x02141512, 0x22230606, 0x37270727, 0x50180226, 0x80080702, 0x14013717, 0x26011716, 0x0e222326, 0x27100502, 0x33161601, 0x05023e32, 0x5e5b5c14,
	0x9beda051, 0x894e85bd, 0x4c5b615a, 0x5ea3f09e, 0xfc5042a1, 0x02302eb7, 0x47723043, 0x346ca672, 0xfd586a03, 0x45722fbe, 0x326ba572, 0x6395ae05,
	0xa9b7defe, 0x6cc6eafe, 0x914e7f47, 0xbe2a0164, 0xc41501aa, 0x7f262a6b, 0xd183e1fc, 0x1db1034e, 0xda975120, 0x9701018a, 0x1e1c54fc, 0xffdb9951,
	0xffb800ff, 0x065d47ec, 0xb9423820, 0x013d3106, 0xb4150052, 0x26051801, 0xc0ffb801, 0x0b181eb4, 0x8f0be942, 0x0076222f, 0x058b42c5, 0x82240121,
	0x18482230, 0x232d9b1e, 0x79004b01, 0xfd225d8b, 0x5d9320b4, 0x26022b23, 0x228d8500, 0x427d006a, 0x0229058b, 0x26052101, 0x18010102, 0x475f852c,
	0x37220c2f, 0x31827307, 0xbf843c20, 0x31007622, 0x15208f86, 0x63248f82, 0x02070f09, 0x2207eb45, 0x7b000200, 0x103f0771, 0x3c001b00, 0x5b172140,
	0x9f1d6700, 0x1d10011d, 0x070b1101, 0x1c64085a, 0x1b066011, 0x82060b60, 0x7b072001, 0x12280666, 0x2f2f3939, 0xe110e110, 0x20051871, 0x05c1685d,
	0x0e14012c, 0x11232302, 0x15331123, 0x697b3233, 0xb0ba2113, 0x2b0d697b, 0xa85b0e03, 0xc3fe4d81, 0x39fcb605, 0x21076a7b, 0xb282888f, 0xae005d08,
	0x7504ecff, 0x4b001f06, 0x48406d00, 0x352e4607, 0x190f0047, 0x192f191f, 0x0d401903, 0x2e5f4813, 0x0f022e6f, 0x2f001f00, 0x19080300, 0x2e00002e,
	0x24410319, 0x4d571147, 0x4d204d10, 0x40034dc0, 0x4c544147, 0x03350724, 0x47503a16, 0x1f154101, 0x16161a50, 0xe1333f00, 0x12e13f3f, 0x21068a42,
	0x0a83f610, 0x2f2f2f27, 0x2b5d5d5e, 0x21cd835d, 0xc2823031, 0x58150421, 0x23200952, 0x6607f779, 0x04260b57, 0x022e3435, 0x01672223, 0x70342005,
	0x530805bc, 0x3f2bf203, 0x0e2b3f4b, 0x38394627, 0x38213d58, 0x61558d65, 0x411a358b, 0x38254c48, 0x11183451, 0x3f38482b, 0x29163555, 0x293e483e,
	0x33533c21, 0x27425831, 0x9c713fb6, 0x6c985c5c, 0x39ec043c, 0x373c4959, 0x21151e36, 0x25263127, 0x3e605248, 0x27517e57, 0x08067866, 0x402d194d,
	0x383b2428, 0x4428233a, 0x362a4643, 0x3a363f4f, 0x3e2a2c43, 0x30131329, 0x4efb4153, 0x8d68b004, 0x4c262555, 0x00ffff74, 0x03ecff5e, 0x0221069c,
	0x00440026, 0x00060100, 0x00009443, 0x3302b415, 0xb8022611, 0x39b4e5ff, 0x41220c33, 0x2d9207f7, 0x00357628, 0x0b401300, 0x2e823f02, 0x39338522,
	0x01222b9b, 0x2b85e24b, 0x33215a83, 0x2157923b, 0x8587e305, 0xbd520122, 0x3b202b85, 0x29225782, 0x57914a3c, 0x88d90521, 0xde6a30b1, 0x40170000,
	0x3c02030d, 0x02032611, 0x8547332f, 0x08d9422d, 0x8720e185, 0x50205b88, 0x38202f87, 0x30212f83, 0x8589863d, 0x0300222f, 0x082f8200, 0x04440661,
	0x0038005e, 0x00500047, 0x2f1a407c, 0x481e4b14, 0x00424204, 0x1d26484c, 0x524f5257, 0x529f525f, 0x00483903, 0xc0ffb80e, 0x110d2e40, 0x000e0e48,
	0x42005156, 0x42024210, 0x0400501e, 0x04020410, 0x4b1f4b0f, 0x4b4b0702, 0x503c2111, 0x16342c2f, 0x500a0d48, 0x10111417, 0x33333f00, 0x843232e1,
	0x39113605, 0x335d5e2f, 0x5d32e15d, 0x32e61001, 0xe1102b2f, 0x32f6105d, 0x05055fe1, 0x7405be5a, 0x16210ff8, 0x06fe7417, 0x2e721520, 0x2223230a,
	0xc6572726, 0x14372205, 0x05af5716, 0x030e0724, 0x44722201, 0x755e2005, 0x27080d0f, 0x332ba683, 0x9a6167a6, 0x60fd396c, 0x31939305, 0x254a4e55,
	0x554f4b27, 0x3eca8a31, 0x745f4c22, 0x5a7b474a, 0x4f61bd34, 0x2b083175, 0x7f6e8503, 0x1ad7010b, 0x33015437, 0x230d3375, 0x5d555d55, 0x2c0f7472,
	0x55367372, 0x51271f3b, 0x565c527b, 0x084c7526, 0x9c630237, 0x50714495, 0xffff002c, 0x14fe7100, 0x5e046f03, 0x46002602, 0x057d4a00, 0x0000422c,
	0x01b60b00, 0x0520262f, 0x7d4a250d, 0xff712606, 0x06e103ec, 0x20258221, 0x0b974248, 0x2611282b, 0xb9ffb802, 0x05282eb4, 0x0a97420f, 0x76212d8f,
	0x053f4252, 0x2e823420, 0x2e287622, 0x01222b9b, 0x2b85de4b, 0x03215a83, 0x21579230, 0x8588d905, 0x42da6a21, 0x3127066b, 0x02032611, 0x853c2800,
	0x053b4259, 0xffffff22, 0x01214a82, 0x20b58467, 0x22db84f3, 0x8255fe43, 0xb4152cdb, 0x26110401, 0x9affb801, 0x4b040ab4, 0xae240c05, 0x42020000,
	0x76222f8a, 0x2f8230ff, 0x0b401324, 0x30821001, 0x0a047422, 0xff212d8b, 0x202d82bd, 0x232d8955, 0xbbfe4b01, 0x5e832d86, 0x8c0c0021, 0xeeff215b,
	0x25202d82, 0x8b85bb84, 0x2d846a20, 0x0d40172c, 0x110d0102, 0x00010226, 0x314b1804, 0x0061080b, 0xff6f0002, 0x062d04ec, 0x00270023, 0x40740039,
	0x48281246, 0x16202300, 0x221c0419, 0x22221c18, 0x0a03181c, 0x403b5700, 0xe03bd03b, 0x3b0f033b, 0x48320601, 0x203a560a, 0x04162319, 0x1d212117,
	0x120f502d, 0xbf0faf0f, 0x0f30020f, 0x170f1701, 0x37011d0f, 0x00160550, 0x393fe13f, 0x5d2f2f39, 0x05ee615d, 0x4b451120, 0x5d5e2406, 0x4ce6105d,
	0x128305e2, 0xf2531020, 0x0b516e05, 0x37171627, 0x05272626, 0x21058327, 0x0d821637, 0x1e071724, 0x48450703, 0x1e142507, 0x36323302, 0x0805676e,
	0x7faf6887, 0xa8763f47, 0x2b9a6669, 0x5a781f08, 0xd94a00ff, 0x462f5528, 0xe33b7a41, 0x6f43c34a, 0x22bc2c4f, 0x4d4b6e46, 0x2121466d, 0x9a4c6d47,
	0x8e3d0287, 0x424f98dc, 0x7777b97f, 0x3b417eb8, 0xc076043c, 0x83729951, 0x7b1a371c, 0x8a2c4820, 0x9c417571, 0x38b0ddbb, 0x2e32526b, 0x4c558358,
	0xc7315a7d, 0x00ffff00, 0x040000ae, 0x02e30512, 0x00510026, 0x01060100, 0x0000f952, 0x010b4013, 0x01261121, 0x0b302202, 0x0d914217, 0x062d0423,
	0x202b8221, 0x05bf4252, 0x0000d82f, 0x2002b415, 0xb8022611, 0x26b4d7ff, 0x0c3b4a20, 0xecff7122, 0x76212d8c, 0x21598450, 0x2e822c02, 0x26204e22,
	0x01222b9b, 0x598afb4b, 0x28b4fa22, 0xb3845992, 0x01228784, 0x2d84e252, 0x87842820, 0x29b4fd23, 0x215b9137, 0xb588d905, 0x00f96a2b, 0x03b61900,
	0x26112902, 0x23b78203, 0x3420b4f9, 0x080cc34a, 0x66000375, 0x0204f800, 0x0300ac04, 0x2b001700, 0x15406000, 0x22012d30, 0x0e1818aa, 0x660356aa,
	0x03280203, 0x03020338, 0xf0ffb800, 0x0d092840, 0x27040048, 0x011d10ad, 0x1d011d0f, 0xad09011d, 0x13101300, 0x13601320, 0x13c013b0, 0x070713d0,
	0xad001313, 0x3f00b301, 0x5e2f33e1, 0x3311e15d, 0xe1715d2f, 0x2b332f01, 0xe15d5d33, 0x5de12f33, 0x35133031, 0x18011521, 0x180e3952, 0x340f4952,
	0xfd9c0366, 0x291f12bf, 0x202a1718, 0x2a201212, 0x1f291817, 0x360f8f12, 0x96968702, 0x2f23eefe, 0x1e0d0d1e, 0x2f21232f, 0x1f0e0e1f, 0x8edb022f,
	0x00550810, 0x73000300, 0x2f04b4ff, 0x1a009104, 0x2d002400, 0x3b405c00, 0x1e281f27, 0x48251b04, 0x15161817, 0x090a0807, 0x57000d08, 0xd02f402f,
	0x032fe02f, 0x06012f0f, 0x560d481b, 0x271e282e, 0x222b041f, 0x180a0750, 0x16050415, 0x502b1012, 0x00160508, 0x3fe1c63f, 0x0adc4ac6, 0x5d5d5e24,
	0xdb4af610, 0x0e142209, 0x06d64a02, 0x84352621, 0x171627e5, 0x16071737, 0xd94a0516, 0x05062207, 0x05d84a34, 0x2f043634, 0x6fb27d43, 0x8344627d,
	0x43463f50, 0x3f6fb37c, 0x0b823171, 0xfd453e33, 0x01161300, 0x2d4b1d8d, 0x4402879a, 0x1f72fe27, 0x29098348, 0x91d58927, 0x4a6d354c, 0x76714883,
	0x1d260805, 0x81496c1c, 0x5486d149, 0x87023383, 0xd1cf1211, 0x7bfd639f, 0x00d31011, 0xa400ffff, 0x0804ecff, 0x26022106, 0xbb425800, 0x00a33105,
	0x01b41500, 0x0126111b, 0xb49bffb8, 0x190c1b21, 0x8f0ae942, 0x6076282d, 0x40130000, 0x8227010b, 0x1b57222e, 0x222b9b21, 0x85084b01, 0x215a832b,
	0x57922300, 0x88d90521, 0x026a2b85, 0xb6190000, 0x11240102, 0x87820226, 0x1bb4fb23, 0x475b852f, 0x0a2408e9, 0xdf0314fe, 0x5c20b784, 0x7621b784,
	0x205d850e, 0x2389822f, 0x00292367, 0x72083146, 0x2a080767, 0x20001406, 0x38003100, 0x482f1f40, 0x1033570a, 0x20270133, 0x471b151f, 0x1d32541c,
	0x2c1b1b00, 0x160f1550, 0x05005021, 0x7a3f0010, 0x32200a8d, 0xbd4a0082, 0x05875906, 0x0e141525, 0x72222302, 0x11220c74, 0x6a722507, 0x6401210d,
	0x7b0b5c72, 0x032806de, 0xb6040203, 0x1f0108b6, 0x210bc271, 0x5e72b603, 0x0a78720b, 0xfe000825, 0x72119436, 0xff220d6d, 0xf58400ff, 0x02d90524,
	0xf5850026, 0x00b16a30, 0x0d401700, 0x112c0102, 0x0b010226, 0xf7853723, 0x220ce94b, 0x53c106dd, 0x4d220879, 0xa9533300, 0x05172905, 0xffb80226,
	0x1615b4ff, 0x260c7b53, 0x03ecff5e, 0x496f059c, 0x4d21083f, 0x05c749e6, 0x5e823520, 0x34332322, 0x54056d49, 0x40200c33, 0x4e225b88, 0x454c2100,
	0x1a022105, 0x62535c82, 0x852d8608, 0x88ee2059, 0xd44e2159, 0x38205985, 0x25205982, 0x86079749, 0xfe00262b, 0x05dd0442, 0x265988bc, 0x00620351,
	0x82140000, 0x27803ae7, 0x01273001, 0x00272700, 0x2b012500, 0xff355d5d, 0xfe5e00ff, 0x04b80342, 0x2459865e, 0x02510107, 0x352d825a, 0x02164020,
	0xa00145f0, 0x45900145, 0x01458001, 0x00014530, 0x36864545, 0x39855d20, 0xecff7d26, 0x73079804, 0x22081b53, 0x850a0176, 0x300127c1, 0xcd012605,
	0x20532a24, 0x05235306, 0xecff7126, 0x21066f03, 0x3606cb48, 0x4a760006, 0x40170000, 0x112c010e, 0x20100126, 0x2620a701, 0x82250d05, 0x86352094,
	0x235d8ec5, 0xb4004b01, 0x210af54d, 0x7e532c77, 0x205d8907, 0x225d898f, 0x85f54b01, 0x8320205d, 0x0128235d, 0x2f492853, 0x8d5d2005, 0x8737205d,
	0x4f0123bb, 0x5d860002, 0xbb822f20, 0x2c248022, 0x0521bb91, 0x25bb86e5, 0x014f0107, 0x5f850033, 0xbd852b20, 0x28204d22, 0x4c22bd9d, 0x5f86a800,
	0x5f822920, 0x912f6b21, 0x8aa020bd, 0x064c21bd, 0x25205d85, 0x2b235d83, 0x8e2b6401, 0x00c726bd, 0x07fc0400, 0x288f8273, 0x01000027, 0x004c0107,
	0x0597424a, 0x26051d2a, 0xb7ffb802, 0x061823b4, 0x260b414f, 0x05ecff71, 0x82140652, 0x8347202f, 0x3802232f, 0xbf82d902, 0x02b60b28, 0x1d3e3e5e,
	0x474a251d, 0x06475306, 0x00060223, 0x211d8292, 0x35820002, 0x9e044208, 0x27001406, 0x55003800, 0x1b1f3140, 0x26472d00, 0x220b1d1d, 0x103a5526,
	0x4836013a, 0x2739560b, 0x4f1d2515, 0x101e1e22, 0x50330020, 0x10100016, 0x03102010, 0x50281010, 0x00160600, 0x3fe1333f, 0x2503825d, 0x332f3912,
	0xb57532e1, 0x32e62b06, 0x102f3911, 0x323232e1, 0xa47e3031, 0x05a76716, 0x15331523, 0x2aac7e23, 0x0185fe27, 0x9c9cb67b, 0x12b27e93, 0x8a462508,
	0xce8786cc, 0x2c19478b, 0x1f21203a, 0x9e10371a, 0x89b6b689, 0x2c832bfb, 0x275a8559, 0x34669561, 0xc3c6c3cf, 0x23058153, 0xc106be03, 0x22073955,
	0x42004d01, 0x0e2607d1, 0x02012605, 0x914a0d0c, 0xff71260c, 0x05e103ec, 0x07f14a6f, 0x93432d82, 0x112a2605, 0x28110226, 0x0c494b29, 0x2005f155,
	0x22598840, 0x42fbff4e, 0x1120060f, 0x06215982, 0x0dc15516, 0xee205985, 0x4e215988, 0x205985ea, 0x2159822d, 0x774b320f, 0x2059850d, 0x2a59881a,
	0x013f014f, 0x40130035, 0x8217010b, 0x0c072259, 0x20b39214, 0x255986e5, 0x014f0107, 0x5b85002b, 0x5b823320, 0x30280c22, 0xfe25b58d, 0x05be0342,
	0x225b88b6, 0x82210251, 0xb90e382d, 0xc1ff0100, 0x001212b4, 0x2b012500, 0x00ffff35, 0x0361fe71, 0x885e04e1, 0x51230855, 0x1f003b02, 0x13402700,
	0x013bf002, 0xa0013be0, 0x3b90013b, 0x013b5001, 0xb8013b00, 0x3bb4caff, 0x821a1a3b, 0x845d203a, 0x00352100, 0x57077941, 0x01230941, 0x41f9ff4c,
	0x04210a1f, 0x121f4117, 0x2209f14c, 0x41e44c01, 0x0921091f, 0x0d1f4133, 0xecff7d24, 0x5984f204, 0x00002a28, 0x4b010701, 0x5986d700, 0x26052c28,
	0x2c346d01, 0xa147010c, 0xfe25240a, 0x84fc0314, 0x824a2059, 0x0106232d, 0x5984c64b, 0x115f0328, 0x67030326, 0x8155275f, 0x2059820e, 0x85f58240,
	0x004e2259, 0x205986c9, 0x21598231, 0x5992365f, 0x82ee0521, 0x2759852d, 0x0000b14e, 0x6403b415, 0xb8245882, 0x69b4efff, 0x37205b93, 0x4f225b88,
	0x5b860c02, 0x5b833720, 0x91342c21, 0xe50521b5, 0x07255b86, 0xf2004f01, 0x205d8400, 0x235d846a, 0x675fb4ec, 0xfe25b98d, 0x05f2043b, 0x235d87cb,
	0x17013902, 0x0b252f82, 0x2c5101b6, 0x22588632, 0x4100ffff, 0x02220e0b, 0x0b412d3a, 0x21b28305, 0xaf8d651c, 0x0000c726, 0x7307d504, 0x2b215182,
	0x05654100, 0x41587f20, 0xb4ff240b, 0x41050c14, 0xae200b3b, 0x12222f82, 0x2f82aa07, 0x2f864b20, 0x89012b39, 0x14401f00, 0x70010d70, 0x7001010c,
	0x021a011a, 0x22190126, 0x41180b1a, 0x5d27059e, 0x005d5d35, 0x82000200, 0x05300800, 0x00b6059c, 0x00170013, 0x142f4056, 0x075a0c04, 0xb019650b,
	0x19af0119, 0x01191001, 0x5a0f0317, 0x18641000, 0x16175f0e, 0x1360120a, 0x17130307, 0x01240182, 0x05120b10, 0x2505496c, 0x39391233, 0x466c2f2f,
	0x10322205, 0x05d77ee1, 0x5d5d3230, 0x32f6105d, 0x313232e1, 0x33351330, 0x03822115, 0x23153326, 0x21112311, 0x23380382, 0x21350135, 0x02bac715,
	0xc7c7ba9a, 0xba66fdba, 0xfd1b04c7, 0xf3c30466, 0x4f080082, 0x02d3fb96, 0x0456fdaa, 0x8bfe962d, 0x0100dfdf, 0x00001200, 0x14061204, 0x55002100,
	0x0b133440, 0x55214700, 0x60231023, 0x03238023, 0x0a121617, 0x540b0f47, 0x4f0d1522, 0xcf0ebf12, 0x0e0e020e, 0x50041710, 0x1d101d00, 0x1d031d20,
	0x0b001010, 0x2106ea7f, 0xa782e15d, 0x335d2f24, 0xa08632e1, 0x9f823220, 0x3912e122, 0x220d777d, 0x82333523, 0x152123a8, 0xfe7f1521, 0x9c9c2711,
	0xfe7b01b6, 0x40180885, 0x2f080804, 0x3482829a, 0xfd609466, 0x89d504f0, 0xb889b6b6, 0x2a3f2b90, 0xfdd2bf14, 0xffff005c, 0x0000f5ff, 0x3507c402,
	0x2c002602, 0x07010000, 0xf3fe5201, 0x26067142, 0x01260514, 0x44231501, 0xff210b47, 0x222d82a3, 0x82e30572, 0x86f3202d, 0x44a1202d, 0x01220547,
	0x2d82110c, 0x441b0d21, 0x3d200c75, 0x7c222d82, 0x5b88c106, 0x22ff4d22, 0x0e205b86, 0x57455b83, 0xebff210d, 0x2a222d82, 0x5b886f05, 0xd0fe4d22,
	0x06205b86, 0x04215b83, 0x205b8c05, 0x222d8230, 0x8840078a, 0xff4e215b, 0x20075d5a, 0x205b8211, 0x0d594502, 0x82deff21, 0x0538222d, 0x225b88ee,
	0x86bdfe4e, 0x8209205b, 0x0e02215b, 0x270c1750, 0x42fe5200, 0xb6056402, 0x51225b88, 0x27439c00, 0x19002105, 0x2907a25b, 0x4400ffff, 0x830142fe,
	0x2582e505, 0x00004c2f, 0x51010601, 0x10000025, 0x6f020a40, 0x82a88225, 0x0125240b, 0x82355d2b, 0x82522027, 0x0764227b, 0x224d8837, 0x4150004f,
	0x17200605, 0x0020a982, 0x7c0ba945, 0x01240557, 0x004a0464, 0x200fff7f, 0x13ff7f0f, 0x834a0421, 0x7bfe265f, 0xb6052904, 0x06c14100, 0x022d0023,
	0x08ad82b6, 0x0e403828, 0x187f1801, 0x01184f01, 0x07074018, 0xffb81848, 0x061740c0, 0x21bf4806, 0x0121a001, 0x5001218f, 0x210f0121, 0x1c832101,
	0x835d2b21, 0x822b2000, 0x83112006, 0xfea026b1, 0x05870314, 0x835182e5, 0x000724d9, 0x8212024d, 0x402e3f51, 0x1e020320, 0xdf011ecf, 0x359f0135,
	0x01358001, 0x4001355f, 0x35200135, 0x01350001, 0x5b824035, 0x4b824785, 0x82351121, 0x48ff2347, 0x5f5c7bfe, 0x002d2806, 0x01070100, 0x86cafe4b,
	0x831420f9, 0x141c23f9, 0x83450e0d, 0xbcff2b09, 0x570214fe, 0x26022106, 0x2d863702, 0x2407a341, 0x01261114, 0x2b2d8d00, 0x3bfec700, 0xb605a204,
	0x2e002602, 0x062e2d82, 0x00733902, 0x00b90e00, 0xb4b1ff01, 0x7344130d, 0xffff2905, 0x3bfeae00, 0x1406f003, 0x4e202582, 0x21202585, 0xc4252586,
	0x0a150fb4, 0x087d8405, 0xae000137, 0xf0030000, 0x11004a04, 0x0a404900, 0x0e101001, 0x11440f0f, 0xffb81101, 0x071c40c0, 0x1011480a, 0x0f131111,
	0x02132f13, 0x47030707, 0x0c125404, 0x0f050e01, 0x05b04304, 0x39393327, 0xe1f61001, 0xff411832, 0x11400808, 0x33113933, 0x01213031, 0x11231107,
	0x06141133, 0x37070607, 0x01013301, 0xacfe2303, 0x05b4b46d, 0x83040403, 0xfecd3301, 0x01ac016f, 0x68fe51e9, 0xe7fe4a04, 0x2c26663c, 0x8101b024,
	0xa0fd16fe, 0x200d1747, 0x24b7822f, 0xff760007, 0x05574565, 0x2605122b, 0x70ffb801, 0x000c06b4, 0x093b4104, 0x00ab0027, 0x07340200, 0x20e782ac,
	0x352f864f, 0x008b0122, 0x7014401f, 0x02700103, 0x10700101, 0x26021001, 0x2e536601, 0x355d2309, 0x69845d5d, 0x473bfe21, 0x698306eb, 0x39020623,
	0x0621412d, 0x6388dd20, 0x00ffff29, 0x013bfe66, 0x8714066c, 0x3902245f, 0x8600f7fe, 0xb4e02127, 0xcf475487, 0xb7052107, 0xb7842782, 0x01380234,
	0x00a3ff00, 0x010d4016, 0x1001030b, 0x06600106, 0xb783020c, 0xbb625d20, 0x82ae2006, 0x88b420b7, 0x02063857, 0x00003b38, 0x01114018, 0x100e4004,
	0x06400448, 0x045e4809, 0x82030304, 0x2b2b22e9, 0x205f8835, 0x2c5f87b6, 0xe3014f01, 0x0b0065fd, 0x06ab01b6, 0x0610410e, 0x2b058552, 0x1406a202,
	0x4f002600, 0x07010000, 0x21082582, 0x0038fd2d, 0xff16402b, 0x13ef0113, 0x01139f01, 0x7f01138f, 0x135f0113, 0x01131f01, 0x2e01b801, 0x694804b4,
	0x855d2006, 0x08368200, 0x001d0035, 0x05be0300, 0x000d00b6, 0x0b324061, 0x050c0506, 0x0d040300, 0x05050404, 0x0f08080a, 0x10010faf, 0x0d0c010f,
	0x0703060d, 0x0a000b5a, 0x04050e64, 0x82040c0d, 0x07012a01, 0x01120a5f, 0x3f3f0003, 0x067146e1, 0x33112208, 0x32f61001, 0x3232e132, 0x5d332f33,
	0x1133115d, 0x332f3912, 0x04877d10, 0x8710c4c4, 0x3031c4c4, 0x08138213, 0x05173725, 0x21152111, 0xc7270711, 0xfe4ee3ba, 0xfd3d02cf, 0x02496109,
	0xfd1203a4, 0xbe7d8f63, 0x01a639fe, 0x827d3cf8, 0xf6ff2599, 0x1d020000, 0x0b2ddf82, 0x3b406900, 0x0d500d40, 0x05060902, 0x379e830a, 0x0b0b0a0b,
	0x05dd0408, 0xcb05bb01, 0x050f0205, 0x052f051f, 0x05050603, 0x472aa482, 0x54080009, 0x050a0b0c, 0x01820a04, 0x15070124, 0xa2820001, 0x3227a190,
	0x5d5d5e2f, 0x8211335d, 0x219f88a9, 0xa1875d01, 0x23110722, 0xae369f82, 0xb94e6bb6, 0x024e6ab6, 0xfd1e03f6, 0x78794559, 0x4a023ffd, 0xcb5e7946,
	0x5e732008, 0x002307cb, 0x4df20076, 0x55220abd, 0x4b531e18, 0x00ae260c, 0x06120400, 0x072d5421, 0x6f76002f, 0x40130000, 0x1125010b, 0x195c0126,
	0x0c2d541f, 0x3bfec726, 0xb6050e05, 0x02235987, 0x42d90039, 0xe1210781, 0x435787b4, 0x042305f1, 0x875e0412, 0x39022253, 0x06a7424c, 0x87b4de21,
	0x23a79151, 0x9c004c01, 0x1d26a786, 0x00012605, 0xa79b1823, 0x0c4c0128, 0xb4150000, 0xa6821e01, 0xfaffb825, 0x8b1924b4, 0x085d82a9, 0xa1040034,
	0x2700b605, 0x8f005100, 0x06010000, 0x00e80702, 0x1d402900, 0x27551800, 0xbf0127ef, 0x279f0127, 0x01275f01, 0x2701272f, 0x48080840, 0x06064027,
	0x3b452b48, 0xf6102205, 0x23328234, 0x7bfec700, 0x4408ed83, 0x4a002500, 0x0c182a40, 0x04205a1f, 0x65201504, 0x0127b027, 0x0001278f, 0x02271027,
	0x140e1317, 0x2664155a, 0x03160d1f, 0x0c181215, 0x005f0712, 0x3fe12f00, 0x333f3f33, 0xf6100133, 0x323232e1, 0x105d5d5d, 0x06774de6, 0x01303122,
	0x2109707c, 0x43180135, 0x2c0809fd, 0x27263301, 0x11352626, 0x0e141133, 0x338b0302, 0x4e221b4d, 0x3d4b252d, 0x0808fd26, 0x05040406, 0xcc02d5ac,
	0x03040307, 0x6437ae05, 0x775b188f, 0x1f59180a, 0x4175270b, 0x347d3841, 0x5b182003, 0xdd6a0989, 0x5e2f0805, 0x3a002800, 0x03032240, 0x24470c17,
	0x2a102a55, 0x2a802a60, 0x47161a03, 0x1a295417, 0x10205010, 0x15170f18, 0x1b005007, 0x3fe13f00, 0x85e13f3f, 0x087861b8, 0x1320b18b, 0x116b4618,
	0x82031521, 0xee0221b1, 0x090d4818, 0x70690229, 0x1d436e51, 0x481a94b6, 0x222208fc, 0x48186d48, 0x03210a14, 0x060b496d, 0x4a04c723, 0x05064994,
	0x4d95fc3b, 0xff2f577b, 0xff7d00ff, 0x067105ec, 0x002602c1, 0x01000032, 0x004d0107, 0x051342bc, 0x052a0227, 0x28000226, 0x0c134229, 0xecff7126,
	0x6f052d04, 0x2a070756, 0x00144d01, 0x0b401300, 0x82112202, 0x2120212b, 0x59842b8c, 0x88400721, 0x004e2259, 0x205986aa, 0x2159822d, 0x55613201,
	0x2059850d, 0x275988ee, 0x0000004e, 0x2502b415, 0xb8245882, 0x2ab4ffff, 0x850dbd56, 0x080f625b, 0x00530123, 0x2a5b82ec, 0x030d4017, 0x26053402,
	0x61430203, 0xe7820d53, 0x230e4957, 0x00465301, 0x21051d5c, 0x2f82112c, 0xbf564520, 0x0002210e, 0x44086182, 0xcd05a406, 0x2a001900, 0x36405b00,
	0x16011614, 0x18140016, 0x0927275a, 0x2c670012, 0x1f012c1f, 0x2b66095b, 0x144f5f17, 0xaf140f01, 0x14080214, 0x5f121914, 0x5f1a0311, 0x5f24040e,
	0x5f191304, 0x3f001200, 0x210185e1, 0x60183912, 0x5d270895, 0x1132e610, 0x83e12f39, 0x315d2504, 0x06212130, 0x0cbe5918, 0xbe651720, 0x08b67409,
	0x37363108, 0x06262611, 0x2b0afda4, 0xefa3305b, 0x9e4c4c9d, 0x5462a3f0, 0xc2fdf402, 0xe9fd1702, 0x56fc3e02, 0x346ca672, 0x72a56b34, 0x26265a34,
	0x6c0b0959, 0x081a5b18, 0xe1651720, 0x85043a05, 0x8ada9751, 0x5199db89, 0x58040f12, 0x00001110, 0xff710003, 0x04e106ec, 0x08df825e, 0x3f003641,
	0x3b406400, 0x1d3f0313, 0x0131d048, 0x370b3131, 0x571c2548, 0x01410f41, 0x400141ff, 0x482b0141, 0x1d40560b, 0x2b3f1b50, 0x3f0f023f, 0x3f3f0601,
	0x50343c2e, 0x10101316, 0x03502e20, 0x5c160600, 0x3f2405bd, 0x32e13333, 0x0ad04e18, 0x715d5d22, 0x2a06b75c, 0x3932e15d, 0x05303139, 0x68272622,
	0x332109f8, 0x14b55c32, 0x18140121, 0x3d09d24c, 0x022e3405, 0x07062223, 0xcc826005, 0x80c63f41, 0x477fae67, 0x6fb37c43, 0x3c3fc379, 0x4e1875b9,
	0xfb3711fc, 0x969a899a, 0x9a978c8b, 0x1bf00487, 0x723e5839, 0x70140b85, 0x18706d6d, 0x23075448, 0x70696a6f, 0x300f995c, 0xd3d13b02, 0xcedcd1c9,
	0x714462cf, 0x959c2c50, 0x05294500, 0x07a00426, 0x00260273, 0x20059f6a, 0x076f6476, 0x2605292b, 0xeeffb802, 0x02231db4, 0x0a89480d, 0x0000ae23,
	0x05195703, 0x00005527, 0x76000601, 0x05d345ce, 0x26112328, 0x1d174001, 0x2b8a030e, 0x3bfec726, 0xb605a004, 0x062b5b86, 0x00773902, 0x00b90e00,
	0x88b6ff02, 0x26818255, 0x033bfe60, 0x825e0408, 0x25518325, 0xfe390207, 0x278400f1, 0x08ff0123, 0x915187b4, 0x4c012aa9, 0x52010e00, 0x02b41500,
	0x23a98422, 0x1d28b4a9, 0x7220a98c, 0x0a22a982, 0x57872106, 0xff4c0123, 0x23578270, 0x1c01b415, 0xb825aa82, 0x22b4e3ff, 0x26ad8c17, 0x03ecff68,
	0x827307c9, 0x4936202f, 0x00210563, 0x05c5433b, 0x05400128, 0x34700126, 0xe94e083a, 0x825a200b, 0x843f202d, 0x8256205d, 0x0006232d, 0x0741dc76,
	0x82422005, 0x365d225c, 0x8e2b8c3c, 0x4b012359, 0x5986edff, 0x59823420, 0x343c2222, 0x598e2d8c, 0x9b4b0122, 0x36205985, 0x1c225982, 0x2b8c363e,
	0x14fe6826, 0xcb05c903, 0x7a22b388, 0x3b413501, 0xb4fa2207, 0x2357863a, 0x5a00ffff, 0x3f222782, 0x27825e04, 0x0724ad83, 0xf0007a00, 0x0b242782,
	0x3c0101b6, 0x25825087, 0x4c22a78f, 0xa786e6ff, 0xa7823920, 0x9d3f1b21, 0x974c21a7, 0x3b20a785, 0x1821a782, 0x26a78d41, 0x043bfe14, 0x82b60512,
	0x0037277f, 0x02060100, 0xe141f939, 0xb4d82506, 0x05030e08, 0x26066f52, 0x023bfe21, 0x8246058f, 0x82572025, 0x02072425, 0x875dff39, 0xb4f724cd,
	0x8712241e, 0x00142627, 0x07120400, 0x244d8673, 0xff4c0107, 0x20a786c8, 0x22a7820d, 0x85081303, 0x06715651, 0xecff2126, 0x1406e802, 0x062c5586,
	0x006f3802, 0x01b60b00, 0x18242461, 0x18058350, 0x080a275c, 0x73000f5c, 0x111f4c40, 0x0111e001, 0x11df115f, 0x30112002, 0x03114011, 0xff05bf08,
	0x05050205, 0x015a060a, 0x0250010f, 0x1f0202f0, 0x02020102, 0x8701770d, 0x03019701, 0x00010131, 0x20011001, 0x01070301, 0x07600d0a, 0x0b030000,
	0x5f020612, 0x3f000303, 0x123f32e1, 0xe1332f39, 0x79490132, 0x2f333605, 0x39125d5d, 0x3232e110, 0x5d395d2f, 0x31715d5d, 0x21110130, 0x070c4535,
	0x0b822320, 0xfeb6013c, 0xfefe035e, 0xfe27015f, 0xd7febbd9, 0xdf013303, 0x21fea4a4, 0x0262fd95, 0x4918959e, 0x41080a2f, 0xb66a0025, 0x20011f14,
	0xb8051c1c, 0x3740c0ff, 0x05480b08, 0x272f2705, 0x1f02273f, 0x1347231b, 0x161f160f, 0x14181602, 0x10101000, 0x10b010a0, 0x070510c0, 0x4f221110,
	0x0b1f1f14, 0x1a4f1e15, 0x49181b18, 0xa6890c3c, 0xc4333324, 0xa182325d, 0x33115d2b, 0x11332b2f, 0x315d0033, 0x49491830, 0x2335230c, 0x03823335,
	0x33373723, 0x84b88215, 0x51491803, 0x8b8b2e11, 0x694e9b9b, 0xecfe1401, 0xfefe0201, 0x5749183f, 0x8afb2c0d, 0xe64e51f8, 0x8af889fc, 0x666261fb,
	0x3521083d, 0x06af6502, 0x00520123, 0x2c038260, 0x2001b415, 0xb8012605, 0x21b4ffff, 0x0c0f662f, 0xecffa426, 0xe3050804, 0x58272f82, 0x06010000,
	0x44f35201, 0x06220987, 0x735b3224, 0x82b8200c, 0x05ef592b, 0x2b823820, 0x4d010724, 0x5b858f00, 0x5b861a20, 0x92191821, 0x886f205b, 0x214d215b,
	0x1d265b85, 0x05012611, 0x5b911c1b, 0x88400721, 0x004e22b7, 0x0b694a7d, 0x95662220, 0x20b5850d, 0x215988ee, 0x59850c4e, 0x59822020, 0x5b250421,
	0xb5840dfd, 0x88d90721, 0x00502259, 0x07316b7b, 0x26051d25, 0x87000102, 0x08d75a5b, 0x06215d84, 0x205d8887, 0x245d8250, 0x020d4017, 0x225e8201,
	0x87050102, 0x672f885f, 0x01230e81, 0x87b20053, 0x83242061, 0x67362061, 0x61831023, 0x175d0e20, 0x53012409, 0x84000050, 0x11272161, 0x48209182,
	0x26108f5c, 0x0442feb8, 0x88b805dd, 0x02512ac3, 0x00000019, 0x0d01b60b, 0x07de6725, 0x00ffff23, 0x222582a4, 0x864a0416, 0x010724b7, 0x85b80251,
	0x210e2525, 0x251a1a21, 0x2606c758, 0x06000014, 0x827307fe, 0x003a2725, 0x01070100, 0x9f45014b, 0x052b2707, 0x33000126, 0x6d501e2b, 0x8200200a,
	0xe305212d, 0x5a20a984, 0x00212d85, 0x255382ae, 0x010b4013, 0x2d821130, 0x11303823, 0x0ee96f2e, 0x230afb67, 0xd0ff4b01, 0x2006c541, 0x225b8209,
	0x67091102, 0x6f5c09fb, 0x09655d07, 0xa94b0122, 0x22097b42, 0x5d232b02, 0x2b820965, 0x04237482, 0x822b0737, 0x833c20b5, 0x6a002387, 0x6341ceff,
	0x05122707, 0x01010226, 0x5b851d09, 0x23089541, 0x03000052, 0x3d20e785, 0x76223184, 0x8b863900, 0x8b821620, 0x100a5e22, 0x830c2753, 0x8435202d,
	0x465d208b, 0xd6200587, 0x16208b85, 0x6020e582, 0xfe222b92, 0x8b823707, 0x01235984, 0x6829014f, 0x0b210ae1, 0x0d9f6e0a, 0x05215984, 0x832d82e5,
	0x01072459, 0x41cd004f, 0x15200641, 0x14205b82, 0xb58a2d92, 0xff4c0123, 0x205b86e0, 0x21b5820f, 0xc7631506, 0x8e00200c, 0x4c0122b5, 0x20b58586,
	0x2059820f, 0x082b8b10, 0x00010033, 0x020000ae, 0x001f06be, 0x40250013, 0x15090915, 0x15101500, 0x13031520, 0x14540047, 0x0106500d, 0x3f001500,
	0x1001e13f, 0x115de1f6, 0x30312f33, 0x050d6133, 0x0a724f18, 0x552dae32, 0x633b4e7c, 0x481f2f26, 0x273a2828, 0x6bb00413, 0x0b595718, 0x824efb21,
	0xcb320865, 0xe90314fe, 0x2b00cb05, 0x2a404a00, 0x29012d30, 0x47011f1f, 0x14121612, 0x0a0a1214, 0x12101200, 0x12401230, 0x13120704, 0x29166000,
	0x50230d29, 0x7c82071c, 0x79001b21, 0xdf450583, 0x2f332107, 0x112f8282, 0x32e11033, 0x315d322f, 0x14110130, 0x4d23020e, 0x11200a96, 0x14065818,
	0x8f021530, 0x4e7b552d, 0x1a1c3d20, 0x3b281f39, 0x58181326, 0xb1880713, 0x4403f624, 0xb4833ffc, 0x9906092d, 0x30130a08, 0xc3034153, 0x8c89444b,
	0x899125c6, 0x00040000, 0xc8080082, 0xaa07dd04, 0x23001600, 0x3e003100, 0x5e400101, 0x29012989, 0x302a2abe, 0x381d3131, 0x1f0d0f83, 0x0d10020d,
	0x0d020d20, 0x6623560d, 0x07230223, 0x69175908, 0x17060217, 0x83321d05, 0x001f000f, 0x0003006f, 0x010ad600, 0x0a470a37, 0x0ac70a57, 0x03d90a04,
	0x48033801, 0xc8035803, 0x1d030403, 0x1005091d, 0x04800104, 0x04d00490, 0xffb80403, 0x061840c0, 0x1004480a, 0x0f400404, 0x2f401f40, 0x9f408f40,
	0x0640df40, 0xb8090807, 0x3140f0ff, 0x235f0709, 0x0e0a201d, 0x030a1d48, 0x0135193c, 0x10128c35, 0x128f013c, 0x600212ef, 0x31100112, 0x23023120,
	0x3131123c, 0x04233c12, 0x04092904, 0x333f0012, 0x3917122f, 0x2000822f, 0x2800825d, 0x115de110, 0x2b333333, 0xb86f1810, 0x3912260e, 0x5d332f3d,
	0x2802835d, 0xe15d2f18, 0x39391211, 0x3a03835d, 0x715d2f33, 0x2f3311e1, 0xed2f3333, 0x0130315d, 0x01070614, 0x03210323, 0x62260123, 0x1e2c0653,
	0x2e030302, 0x030e2703, 0x3e130307, 0x0807ce79, 0x26341326, 0x15062223, 0x33171614, 0x50033632, 0xfc01333c, 0xd3fd9abe, 0xf801bc9c, 0x3b203a33,
	0x54313252, 0x940c233e, 0x0afb6f18, 0x30158523, 0x08ff792f, 0x3fbc7008, 0x333f3132, 0x3f320c31, 0x60469c05, 0x0123fb19, 0x0479fe87, 0x466019db,
	0x1d384f33, 0xfc4f371d, 0x107d015f, 0x1c3b362e, 0x2e363c1c, 0x0483fe0f, 0x413d188b, 0x16101c40, 0x16424741, 0x3c34f6fe, 0x3b33343c, 0x05003c03,
	0xecff5e00, 0xaa079c03, 0x31000d00, 0x54004000, 0x9c006000, 0x83552340, 0x411f410f, 0x4103412f, 0x4b835b41, 0x824b0d06, 0x1a500801, 0x47370f1e,
	0x3f625531, 0x483e0162, 0xffb8281a, 0x0d3a40d0, 0x10284811, 0x28480c09, 0x61561a28, 0x50508c58, 0x700d600d, 0x0d0d030d, 0x5e055050, 0x5046408c,
	0x46460246, 0x2b502427, 0x1e1e5238, 0x5032102b, 0x0e16150f, 0x01050f15, 0x5d2f0005, 0x0a8d5e18, 0x5d2f3326, 0x2f3911e1, 0x10210682, 0x059c69e1,
	0x2b059d69, 0x113232e1, 0x2f2f3939, 0xe110cd10, 0xe1231c82, 0x41013031, 0x01200842, 0x29af5e18, 0x18140121, 0x200d3a55, 0x077d4107, 0x36323324,
	0x5841c701, 0x23522508, 0x25520178, 0x27d95e18, 0x2386013c, 0x3231543d, 0x21213b52, 0x3032523b, 0x75233e54, 0x3f32313f, 0x3f313839, 0x6d41b806,
	0x5cf9220a, 0x035f1898, 0x08052929, 0x1d385133, 0x334f381d, 0x2406c841, 0x3c3c3534, 0x2d038235, 0xfeffffff, 0x56060000, 0x26027307, 0xab458800,
	0x25022105, 0x2905934c, 0x02260520, 0xb44801b8, 0x1f5b1a14, 0xff5e260c, 0x064406ec, 0x202f8221, 0x212f85a8, 0x53457501, 0x5d032905, 0x71032611,
	0x1c005751, 0x220a9546, 0x72b4ff7d, 0x9a20060b, 0x02202d86, 0x28055345, 0x26053e03, 0x38325803, 0x0b235611, 0xb4ff7324, 0x5b842f04, 0x0946ba20,
	0x05416705, 0x823a0321, 0x2e4c2359, 0xbd4c0d34, 0xfe68220b, 0x0a374c3b, 0x39020622, 0x2107674b, 0xe74cb4da, 0xffff2307, 0x25825a00, 0x8209354c,
	0x4bbb2025, 0xe12106b5, 0x08e14cb4, 0x01016b08, 0x03d90402, 0x0021069a, 0x40250014, 0x040e0f11, 0x08c00004, 0x00800e04, 0x085f080f, 0x2f000802,
	0xcc1a335d, 0x1a2f0132, 0x2f3d39cc, 0x30313333, 0x26262301, 0x07060627, 0x033e3523, 0x031e3337, 0x799a0317, 0x36346c33, 0x1a79336a, 0x103b4344,
	0x433b10c0, 0xd9041945, 0x37376122, 0x1d1b2261, 0x2251514c, 0x4c515122, 0x6b8e001d, 0x10050630, 0x0bc00010, 0x10800d13, 0x065f060f, 0x6b840602,
	0x6b8ccd20, 0x07030e33, 0x27032e23, 0x16163335, 0x37363617, 0x199a0333, 0x2b638645, 0x33791a44, 0x6c34366a, 0x06067933, 0x50236482, 0x82502323,
	0x221b2664, 0x61383861, 0x206b8222, 0x32d7821b, 0x006f055a, 0x40150003, 0x0000010a, 0x5f030f8f, 0x82030203, 0x7ee12064, 0x212b0508, 0x1b012115,
	0xc1fd3f02, 0x82966f05, 0x8221202f, 0x057b2d2f, 0x001500ee, 0x151c402f, 0x0100ff83, 0x83339c82, 0x0a7f000a, 0x0a9f0a8f, 0x10800a03, 0x5f050f8f,
	0x83050205, 0xcd1a2241, 0x27a7825d, 0x5ddc1ae1, 0x013031e1, 0x0805ba6c, 0x1e332731, 0x3e323303, 0x7b033702, 0x6d4d2c04, 0x496d4947, 0x046c0327,
	0x2c43301c, 0x22334124, 0x3dee0504, 0x27294a65, 0x2b3f6649, 0x09071932, 0x8228311b, 0x05a03c62, 0x05750100, 0x000d00e5, 0x0810401c, 0x91030087,
	0x0bcf0b9f, 0x30030bef, 0x820b010b, 0xe55d2369, 0x62822f01, 0x46181320, 0xa0200bcc, 0x09505b18, 0x3c73052f, 0x2b1c0d36, 0x38393a1e, 0x01020000,
	0x08c3826d, 0x87063131, 0x1f001300, 0x2d404000, 0x000f8314, 0x004f003f, 0x0004005f, 0x0a30831a, 0x8c170a01, 0x0f1f0f0f, 0x0f4f0f3f, 0x0faf0f5f,
	0x06070fff, 0x898c1d0f, 0x5ed428d6, 0x2f01e15d, 0x84d4e15d, 0x1ae243d6, 0x43310321, 0x202106a9, 0x0fa94320, 0x43b20521, 0xed82166f, 0x42fe1f39,
	0x00005e01, 0x16001400, 0x80060940, 0x120d8400, 0x000a8e03, 0x822fe12f, 0x1a3908e5, 0x173031cc, 0x32331614, 0x06153736, 0x26222306, 0x023e3435,
	0xb4063337, 0x2d192234, 0x1d401a0e, 0x2f1e6464, 0x8b811a38, 0x052b2dee, 0x08087104, 0x4b2a5a68, 0x85133440, 0x06594200, 0x05d12808, 0x001b00e3,
	0x0f234038, 0x02172f17, 0x20090017, 0x09070209, 0x0e8f0516, 0x48131040, 0x0b07400e, 0x130e0e48, 0x820f098f, 0x2f003489, 0x33e1325d, 0xe12b2b2f,
	0x5e2f0133, 0x315dcc5d, 0x51220130, 0x232005c2, 0x83051367, 0x0e333b87, 0x28fe0203, 0x20464c4f, 0x680e302d, 0x4a352105, 0x4c512a2e, 0x2e2d1d45,
	0x0d83690f, 0xdb042008, 0x35232b23, 0x45623c3e, 0x232a2325, 0x613c3e34, 0x00002645, 0x04df0002, 0x06be03d9, 0x820d0021, 0x402d2d8f, 0x0e0e1419,
	0x00504007, 0x4f003f01, 0x13241c82, 0x1b809205, 0x08964018, 0xed1a332e, 0x5d2f0132, 0x39cd1a5d, 0x3031cd2f, 0x2009cf46, 0x08964525, 0x2f16df30,
	0xc7102a2f, 0x514d3f10, 0x6b016523, 0x0d823015, 0x0d84c620, 0x40186420, 0x6b430cb5, 0xc1401805, 0xf8012108, 0x04208582, 0x272c8584, 0x10051640,
	0x0548110c, 0x000c4006, 0x8182fd82, 0x1a218088, 0x247e82ed, 0x32cd1a33, 0x0c0a462b, 0x0af82308, 0x04101314, 0x2d2106c7, 0x046c1834, 0x514d1ef4,
	0x18152150, 0x2056574e, 0x14010300, 0x89030c05, 0xdf84b406, 0x6600292b, 0x841c1940, 0x241f240f, 0x37048302, 0x240324cf, 0x480c0940, 0x160d2424,
	0xffb80e84, 0x092740c0, 0x0e0e480d, 0x0c3b8086, 0x0c92050d, 0x91111f0c, 0x0119ff27, 0x19b01960, 0x0f0319d0, 0x02191f19, 0x4f001906, 0xe5230561,
	0x822f3932, 0x82332093, 0x2f332491, 0x8211e12b, 0x715d2104, 0x200ca746, 0x0b0d4327, 0x0de74918, 0x190bfe39, 0xcf081618, 0x3d383012, 0x38ea5220,
	0x1a231329, 0x29263a10, 0x18b50138, 0x320af649, 0x4f4b1e87, 0x20142451, 0x2551504d, 0x0c303606, 0x181b2619, 0x250c044a, 0xe9ffffff, 0xad670000,
	0xfd54350c, 0x0097fff1, 0x1a02b618, 0x22300203, 0xe9ffb801, 0x042222b4, 0x18082b5b, 0x82732141, 0x82e720a5, 0x054d30a5, 0x002700b8, 0x008f0028,
	0x01070100, 0x82effd54, 0x2e2a08a7, 0x031101b4, 0xffb81201, 0x0f08b2c0, 0x9dffb848, 0x12120f40, 0x00250202, 0xbf1b6700, 0x1b0f011b, 0x5d5d0101,
	0x0134fe10, 0xe95b2b2b, 0x82ff2005, 0x50052149, 0x26234982, 0x897b2b00, 0x8a312047, 0x82112047, 0x40b12647, 0x06121212, 0x29478206, 0x011b6f65,
	0x10011b2f, 0x0482011b, 0x5d5d5d24, 0x4a8534fe, 0x95850020, 0x84600321, 0x002c2295, 0x22958afc, 0x83164066, 0x12c03696, 0x0112a001, 0x20011230,
	0x12100112, 0x01120001, 0x40a5ffb8, 0x3c58852f, 0xd00100f0, 0x00c00100, 0x0100af01, 0x60010070, 0x00500100, 0x01004001, 0x0001003f, 0x286c8220,
	0x48070740, 0x0907401b, 0x21ba8248, 0x7882115d, 0x35200285, 0x5c059e59, 0xff2c06b7, 0x05ecffe7, 0x00cd05c3, 0x52320026, 0x2408cd89, 0x02304047,
	0xa002032d, 0x2e80012e, 0x012e7001, 0x20012e50, 0x2e10012e, 0x012e0001, 0x0a2e2e24, 0x0001250a, 0x2a708450, 0x37bf6700, 0x01370f01, 0x82100137,
	0x5d5d23da, 0x5f863434, 0xe3866084, 0x84540521, 0x013c22e3, 0x2fe38a1d, 0x0e01b44b, 0xb80f0103, 0x16b6c0ff, 0x0fa04817, 0x25080a84, 0x481109b2,
	0x40d6ffb8, 0x070f0f1c, 0xc0002507, 0x05b00105, 0x01057f01, 0x05010520, 0x2f01183f, 0x180f0118, 0xc9820101, 0x3528d084, 0x2b5d2b2b, 0x353f0035,
	0x06216786, 0x22c98300, 0x895a7601, 0x403539c9, 0x03350123, 0x01362001, 0x00013610, 0x36160136, 0x25131336, 0x011d5000, 0x1d280282, 0x013fbf67,
	0x3f013f0f, 0xbb83bc87, 0xe42a4f87, 0x7702ecff, 0x2602b406, 0xb5848601, 0xd0fe5535, 0x18000000, 0x02030f40, 0x0124c001, 0x20012440, 0x6a153a24,
	0x35230687, 0x82ffff35, 0x0509431d, 0x24000623, 0x07715600, 0xb6058726, 0x25000602, 0x3c081b82, 0x00c70001, 0x05be0300, 0x000500b6, 0xc40a4043,
	0x0200f400, 0x020100b0, 0xc0ffb800, 0x13081f40, 0x07000048, 0x072f070f, 0x076f074f, 0x11400704, 0x5a034818, 0x02066404, 0x0303055f, 0x07f84d12,
	0x115d2b3a, 0x5f2b2f33, 0x30315d5d, 0x11211501, 0xbe031123, 0x05bac3fd, 0xf0faa6b6, 0x00215882, 0x21698302, 0x63846804, 0x58000e30, 0x04051140,
	0x0b020606, 0x7001605b, 0x6f18b001, 0x2608080c, 0x480a0627, 0x2f100101, 0x6f105f10, 0x9f107f10, 0x0610bf10, 0x09064010, 0x025b0a48, 0x110a2006,
	0x03040648, 0x82025f0a, 0x3fe12674, 0x2f012b33, 0x227585e1, 0x4812e15d, 0x2e0806d8, 0x35211525, 0x06073301, 0x21030706, 0x04262603, 0x01bdfb68,
	0x115ebbc2, 0x02fe1d2a, 0x2e1ffcae, 0x05857d7d, 0xa84acd31, 0x020afd5b, 0x41a861f0, 0xfb83060b, 0x00060224, 0x0f830028, 0x00005226, 0xb605fe03,
	0x3d200f82, 0x20082b41, 0x210f84d5, 0x1a82002b, 0x2205c35a, 0x7000cd05, 0x2208056b, 0x00344053, 0x0e010001, 0x67045b22, 0x012dd02d, 0x80012dcf,
	0x2d3f012d, 0x18022d6f, 0x2c660e5b, 0x7d0f6003, 0x042b0614, 0x1d000008, 0x04135f27, 0x18095f1d, 0x27083979, 0x01e15d5e, 0x5de1f610, 0x06820082,
	0x3939122b, 0x30312f2f, 0x21152101, 0x055c7a25, 0x597a2620, 0x18162009, 0x28105c8a, 0x1602ec01, 0x8503eafd, 0xc4741851, 0x39032620, 0xfea945a1,
	0xc67418ea, 0x0749631f, 0x2c20ed84, 0xa220fd88, 0x2e200f84, 0x0120fd82, 0x003a0382, 0xb6058b04, 0x5f000c00, 0x0e2f1c40, 0x0eff0eef, 0x12400e03,
	0x400e4815, 0x0482100d, 0x09064c08, 0x050b0c48, 0xb80a0905, 0x2240f0ff, 0x002f010a, 0x005f004f, 0x00af009f, 0x00ef00cf, 0x01001007, 0x05001000,
	0x480e0a20, 0x0a030b05, 0x3f001200, 0x2b333f32, 0x5d382f01, 0x382f325d, 0x2f3d3933, 0x2b2b3333, 0x30315d2b, 0x4a012321, 0x013e05a4, 0x04330123,
	0xdbfec68b, 0x110f2e1f, 0xd9fe1d2a, 0xbbe701c5, 0xa8619a03, 0x5ba84b4b, 0x8c8260fc, 0x00ffff27, 0x060000c7, 0x20a7842f, 0x21b78730, 0x0f840e05,
	0xb3823120, 0x52000326, 0xee030000, 0x032e2a82, 0x0b000700, 0x3e406300, 0x1b010014, 0x8e820101, 0x0b012408, 0x08000606, 0x0108c001, 0x0801083f,
	0x6f0d4f0d, 0x0d30020d, 0x70070701, 0x020b800b, 0x0b010b4f, 0x820f5f03, 0x08022dbf, 0x0b040000, 0x07120a5f, 0x0003045f, 0x4906cf7e, 0x5d2f056b,
	0x5d5d2f33, 0x5d5dce10, 0x112f3271, 0x822f3939, 0x3031260d, 0x21152113, 0x3c038203, 0x35211501, 0xfda602cd, 0x4a03525a, 0x7303b6fc, 0x4e0364fc,
	0xa40a03a2, 0xa4a492fb, 0x07135d00, 0x02cd0525, 0x82320006, 0x830120a9, 0xc10421c9, 0x2008a982, 0x40310007, 0x005a011e, 0x09b00965, 0x9f096f01,
	0x0309af09, 0x04010910, 0x0864055a, 0x03065f03, 0x053c4105, 0x25073f42, 0x31e1f610, 0x53672130, 0x04212b05, 0x7bfdbbc1, 0x05fa03ba, 0xf483fa12,
	0x23051f41, 0xb6053304, 0x33206582, 0x4e206584, 0x1220cc82, 0x3a086582, 0x405a000b, 0x065b080d, 0x48171420, 0x06020602, 0xffb80a01, 0x062640c0,
	0x0a0a4815, 0x2f0d0f0d, 0x8f0d6f0d, 0x0706040d, 0x2f035b09, 0x02013f01, 0x02020801, 0x045f0709, 0x835f0903, 0x3fe1217f, 0x24057a43, 0x5d2f1801,
	0x06a16333, 0x39122b26, 0x2b2f2f39, 0x24088e82, 0x01013533, 0x21152135, 0x15210101, 0xfe9e014e, 0xfd7d036e, 0xfe850158, 0x98f70267, 0x25026602,
	0xeefda493, 0x050541fd, 0x8f851420, 0x37229f82, 0xb1440000, 0x84372006, 0x823c20af, 0x035b08af, 0xecff6800, 0xcb05ba05, 0x2e002100, 0x81003b00,
	0x02225040, 0x11011167, 0x9a213b5a, 0x12870112, 0x01127a01, 0x281b1212, 0x3d67085b, 0x00013d2f, 0x3dd0013d, 0xbf3daf01, 0x3d90023d, 0x013d5f01,
	0x0f013d30, 0x023d1f3d, 0x1b5b3506, 0x3b223c66, 0x13101360, 0x21602f2e, 0x82132102, 0x13112601, 0x3f000400, 0x24b6833f, 0xe1103311, 0x24048432,
	0xe1f61001, 0x0599465e, 0x82717121, 0x3911220b, 0x280d822f, 0x5de13333, 0x30313232, 0x052a7c01, 0x0e141535, 0x15232304, 0x22233523, 0x3435042e,
	0x3333023e, 0x7b323313, 0x2b270574, 0x020e2203, 0x821e1415, 0x025c0813, 0x8649bbb4, 0x183c7ec2, 0x9f785434, 0x2fbb2f65, 0x54789f65, 0x7e3d1835,
	0xbb4a85c2, 0x5b8b5d1a, 0x7f53292e, 0x39bb3957, 0x28547f57, 0x5d8b5b2e, 0xb4cb051a, 0x66c4995e, 0x6e7b813d, 0xe1e13052, 0x7b6e5230, 0xc4663d81,
	0x53fc5e99, 0x5894693b, 0x3c688b4e, 0x4e8b683c, 0x3b699458, 0x08062d41, 0xb6056064, 0x3b000602, 0x01000000, 0x00006800, 0xb605ba05, 0x70002500,
	0x671f4740, 0x5a090109, 0x010a9a1c, 0x7a010a87, 0x0a0a010a, 0x005b2313, 0x272f2767, 0x01270001, 0xaf0127d0, 0x0227bf27, 0x5f012790, 0x27300127,
	0x1f270f01, 0x16060227, 0x2666135b, 0x08601c1f, 0x24090b0b, 0x0903141d, 0x3f3f0012, 0x9f583333, 0x151a4106, 0x325de12b, 0x14013031, 0x2323040e,
	0x2b018211, 0x35042e22, 0x14113311, 0x3333021e, 0x33220782, 0x0e823632, 0x41ba0521, 0xc1200e03, 0x2608ee84, 0xb7ba1abb, 0x3dd703c0, 0x4e6a777f,
	0x0142fe2e, 0x684e2dbe, 0x013d7e77, 0x5821fee3, 0x0334628d, 0xc6a6fc5a, 0x83e301b1, 0x824e20db, 0xa64908db, 0x2f00cd05, 0x51407c00, 0x220b5b0e,
	0x0b20255b, 0x04020b30, 0x252f010b, 0x25df253f, 0x0b0425ef, 0x0b070125, 0x13250b25, 0x23065b2b, 0x23022316, 0xd031671d, 0x31cf0131, 0x01318001,
	0x316f313f, 0x190d0902, 0x0d08020d, 0x2be68205, 0x185f0030, 0x0a222604, 0x0c255f0d, 0x3324e582, 0x323232e1, 0x2005cc54, 0x05ff4133, 0x32f61029,
	0x3911e15d, 0x842f2f39, 0xe110210f, 0x0be75318, 0x2115172a, 0x032e2135, 0x023e3435, 0x085f8518, 0x13822120, 0x12823e20, 0x022e5808, 0xa472fa02,
	0x5123326a, 0xb0fd5f83, 0x6f406201, 0xa0512e50, 0xeb9b9aec, 0x502e51a0, 0x6201416e, 0x835fb0fd, 0x6a322351, 0x442905a4, 0x6475ba81, 0x4197abbb,
	0x8730a493, 0x966fc7a8, 0x5e5eacf4, 0x6f96f4ac, 0x3087a8c7, 0x974193a4, 0x7564bbab, 0x004481ba, 0x1800ffff, 0x572ec943, 0x20083403, 0x04ecff71,
	0x02210691, 0x007e0126, 0x01060100, 0x00001954, 0x020b4013, 0x0226114a, 0x16443e16, 0x0a25512f, 0xecff5a24, 0x2b845c03, 0x2b858220, 0x2b84ca20,
	0x11460129, 0x3a6d0126, 0x8a2d1840, 0xfeae222b, 0x05916414, 0x85840121, 0x8544202b, 0x8225202b, 0x6462202b, 0xa4240e91, 0x7702ecff, 0xe9485784,
	0xfe542205, 0x053f5ece, 0x2c822220, 0xfdffb826, 0x152216b4, 0x820b5351, 0x3d04232f, 0xb382b406, 0x5b849220, 0x00105530, 0x03b21200, 0xffb80102,
	0x422cb4ee, 0x87831b05, 0x00353524, 0xdd840002, 0x5e042908, 0x3d001000, 0x1e403800, 0x47051e38, 0x103f282f, 0x480e013f, 0x223e5616, 0x500b1e0f,
	0x2f380f1b, 0x3350002c, 0x3f001611, 0x20061442, 0x06697133, 0xe132d424, 0x67183232, 0x162a1a1f, 0x36363317, 0x030e3337, 0x0c4f1115, 0x022e250a,
	0x030e2327, 0x122a6718, 0x713d2f08, 0x907064a2, 0x210a0c31, 0x130b8f19, 0x2232080d, 0x0f08250e, 0x3f262241, 0x0c0c2432, 0x604d3b16, 0x98622f83,
	0x9d650f68, 0xccda376b, 0x6718cdd1, 0x533a0836, 0x1f522355, 0x7e796821, 0x3c5dfe37, 0x85030733, 0x27101109, 0x3d223040, 0x5d761a2e, 0x06752406,
	0x821b001f, 0x594308e3, 0x48393440, 0x1f050805, 0x02332f33, 0x05330533, 0x0c472c15, 0x3f203f57, 0x22023f30, 0x54164715, 0x081b153e, 0x330f5032,
	0x33330801, 0x50272200, 0x501c1611, 0x3f000100, 0x32e13fe1, 0x5e2f3911, 0x8439e15d, 0x062b6dfc, 0x2f2f3934, 0x1039125d, 0x013031e1, 0x15021e32,
	0x15070614, 0x82761616, 0x27262d05, 0x34112311, 0x2217023e, 0x1115020e, 0x25054f51, 0x022e3435, 0x91182323, 0x6608081f, 0xa3607702, 0x8f984376,
	0x783fb9b0, 0xa4606dad, 0x7945b63c, 0x643863a8, 0x4e202c4b, 0x50245252, 0x351f466f, 0x664f8460, 0x4e77524d, 0x5f442625, 0x62311f06, 0xad956294,
	0xca150617, 0x6da26cba, 0xfd1f2037, 0x7b3406e9, 0x963773b2, 0x607f4c1f, 0x1e1292fc, 0x4d280b15, 0x7550476f, 0x2898254d, 0x3f3d6649, 0x181f3e5e,
	0x080a7f62, 0x63001b34, 0x401d1640, 0x50481512, 0x1d0f011d, 0x1d4f1d2f, 0x051a0703, 0x06480501, 0x40f0ffb8, 0x0b060615, 0x0c131300, 0x201b001a,
	0x031b401b, 0x1b101b08, 0x19830c0d, 0x1a0c0a3a, 0x00130f0c, 0x1b05150b, 0x333f3f00, 0x01333f33, 0x2f33382f, 0x335d5e38, 0x3005744a, 0x382f1833,
	0x5d5e5de1, 0x30312b5d, 0x15030e25, 0x20fa8223, 0xa9651837, 0x0237080b, 0x18221660, 0x1b0fbe0c, 0x60fe1525, 0x1e0ed9bd, 0x0604141a, 0x1b191405,
	0x12bcc70b, 0x7e86883e, 0x89792a34, 0x3e043f8d, 0x5d28bafd, 0x1a1b505a, 0x215a5d52, 0x7d004c02, 0x4408080b, 0x0032001f, 0x40510044, 0x00461a2e,
	0x2e050538, 0x240f4833, 0x46404657, 0x46e046d0, 0x01460f03, 0x2e483d06, 0x24004556, 0x380a1a42, 0x50420a38, 0x50151629, 0x00010a10, 0x3fe1333f,
	0x2f3911e1, 0x39123912, 0x06ce4633, 0x32f61022, 0x39251283, 0x3031e139, 0x09b64401, 0x2e071722, 0x08a08318, 0x181e1721, 0x240c0d8f, 0x022e3401,
	0x4b4c1827, 0x02c20808, 0x435d3814, 0x7d5c3325, 0x6071444a, 0x204a2351, 0x335b5149, 0x12273c2a, 0x47623c1b, 0x315c8655, 0x6db27f45, 0x477fae67,
	0x01997243, 0x52391eb4, 0x687e3a35, 0x69492644, 0x03998e43, 0x564b20aa, 0x69483962, 0x1f142246, 0x14911327, 0x17121e26, 0x251b3225, 0x29413d3e,
	0x937e6c31, 0x83c17f58, 0xaa753d43, 0x7aa36a6e, 0x4551fe53, 0x1f49596f, 0x91623a10, 0x516f4267, 0x0100b42d, 0xecff5a00, 0x5e045c03, 0x59003900,
	0x231d3740, 0x10180101, 0xa03b572d, 0xc03bb03b, 0x3b3f033b, 0x10023b5f, 0x4634013b, 0x47052323, 0x1e3a5618, 0x39bf5002, 0x89397901, 0x39390239,
	0x2850310a, 0x13500a10, 0x2e5a0016, 0x5d5d2d06, 0x100139e1, 0x2f33e1f6, 0x5d5d5de1, 0x2c052765, 0x30313912, 0x22231501, 0x1e141506, 0xf7891802,
	0x022e2709, 0x023e3435, 0x2f413537, 0x5826200b, 0x268205a9, 0x9c025f08, 0x29858a81, 0x33376046, 0x1f47515c, 0x716d9e3b, 0x26356ca6, 0x2b2c523f,
	0x3a1c3346, 0x35569069, 0x284d525a, 0x47814b3f, 0x4827736c, 0x87023d64, 0x335e5b99, 0x0f122a45, 0xa0101f18, 0x56312922, 0x583e4375, 0x0b0f293e,
	0x503e2b0e, 0x4a6d4632, 0x1c130926, 0x26229314, 0x402d4d4d, 0xf7821227, 0xfe712b08, 0x066a036f, 0x00330014, 0x2e1f4039, 0x461f0303, 0x0114201a,
	0x35103514, 0x0a0235c0, 0x00002948, 0x19345629, 0x5000032e, 0xdf820001, 0x2f323223, 0x27d08201, 0x5de1102f, 0x325dd610, 0x3320e282, 0x2105b47c,
	0x4418050e, 0x07210a23, 0x05a34623, 0xd6832720, 0x36126608, 0x07063736, 0xae230606, 0xb880b602, 0x0d284c7e, 0x4b78542d, 0x193a5f47, 0x162b2215,
	0x222b18aa, 0x5b300e14, 0x5c87594d, 0xc99a5c2e, 0x282f2b6c, 0x7b052f60, 0xcd768d99, 0x6f859ab3, 0x406c5930, 0x2e0f1123, 0x2d2a483b, 0x1f4b5258,
	0x43484820, 0x2225141d, 0x42110f1f, 0x9466986c, 0xd9e80101, 0x0203036c, 0x93531804, 0x005e2808, 0x40310018, 0x1847001d, 0x2c0f696e, 0x1450040e,
	0x0b0f0c10, 0x001b0015, 0x0daf683f, 0x01303122, 0x0b967118, 0x3e331729, 0x16323303, 0x18031115, 0x68079571, 0xfe230993, 0x68af0414, 0xfb221086,
	0x89660047, 0x04210805, 0x002b0617, 0x001e0013, 0x405b0027, 0x4719253a, 0x0f295700, 0x29d00129, 0x9f297f01, 0x29400229, 0x080d8201, 0x1a240621,
	0x28560a47, 0x24cb501a, 0x0124ba01, 0x24992489, 0x01240f02, 0x14242408, 0x010f501f, 0x42055014, 0x5e21084a, 0x2100825d, 0xa36e01e1, 0x200a8205,
	0x3b541871, 0x06022107, 0x080c6e67, 0x12161698, 0x023e3201, 0x031e2137, 0x020e2213, 0x02022107, 0x70341704, 0xaf767eb3, 0x6f333874, 0xb0767eb1,
	0x2bfe3a75, 0x23456849, 0x02cbfd03, 0x4a684421, 0x23446647, 0x09330205, 0xbc0c0384, 0x6dced7fe, 0x2901ce6d, 0x2901bcbc, 0xcd6b6cce, 0xb9fcd7fe,
	0x95df944a, 0x4b95df93, 0x89451005, 0x110189cd, 0x00001301, 0xffa40001, 0x047702ec, 0x00150048, 0x30234035, 0x09090109, 0x10170017, 0x60172017,
	0x90177017, 0xd017c017, 0x01080817, 0x16541447, 0x160f5004, 0xc44f0f00, 0x5d5e2407, 0x5d2f3311, 0x16200534, 0x5705fe42, 0x35390516, 0x3f5a0111,
	0x2a2d1248, 0x290d0924, 0x3e183430, 0x042c4d6a, 0x61fcfc48, 0xa86b1862, 0x0403300c, 0xae00ffff, 0xf0030000, 0x06024a04, 0x8200fa00, 0xf2ff368b,
	0x1704ecff, 0x2e002106, 0x2a406800, 0x1a151522, 0x29011212, 0x0801820a, 0x1a500030, 0x441a3401, 0x1a00021a, 0x1a201a10, 0x301a1a03, 0x30903060,
	0x01300f02, 0xb8002e06, 0x0f40f0ff, 0x29152e00, 0x170e0101, 0x07161e50, 0x8d460e50, 0x39112405, 0x183f332f, 0x08092e6a, 0x5d5d5d26, 0x3d393912,
	0x112f182f, 0x12113333, 0x31331139, 0x27012330, 0x2223032e, 0x36350706, 0x1e323336, 0x16011702, 0x9256ce82, 0x2e630806, 0x2e032702, 0x06232703,
	0x0e030706, 0x0d35b801, 0x2b3d2b1f, 0x1a143222, 0x694a2342, 0x011f3f4f, 0x262e1248, 0x1708260e, 0x3b272537, 0x870f252f, 0x161b1d0b, 0x350d0605,
	0x3304e51f, 0x314329a0, 0x9105071b, 0x592a0a07, 0x36fc5d87, 0x03073936, 0x110e0c85, 0x012e4028, 0x615e21a2, 0xaa4d1957, 0x82c1fd4f, 0x7b5618f7,
	0x403f250a, 0x090c0d26, 0x0f7c5618, 0x471a002b, 0x1a1e541b, 0x030d141b, 0x7f561850, 0x4833200c, 0x322b0565, 0xf6105d32, 0x313232e1, 0x18140130,
	0x084f8356, 0x0000003a, 0x4a04cf03, 0x3b001400, 0x13141640, 0x0d000707, 0x16570e47, 0xb0011610, 0x160f0116, 0x00010601, 0xb6f0ffb8, 0x15140700,
	0x000f000d, 0x333f323f, 0x32382f01, 0x715d5d5e, 0xf7469382, 0x313c0805, 0x13331130, 0x3317031e, 0x3512023e, 0x02021433, 0xbc230706, 0x1e1f0cc9,
	0x5a060519, 0xb6194272, 0x759a5c25, 0xfd4a04c0, 0x676321b0, 0xcd60195c, 0x970501e7, 0xfee0fea3, 0x007ffdf5, 0x320ad344, 0x407e0046, 0x3b3b324e,
	0x41012a11, 0x2d2d3846, 0x65001c24, 0x4b0805c7, 0x1c010108, 0x01112046, 0x483f4811, 0x487f485f, 0x100448ef, 0x48070148, 0x3c475624, 0x39503832,
	0x1c49002a, 0x1c691c59, 0x011c3803, 0x031c2407, 0x004f0116, 0x00391600, 0x3f00fa16, 0x2f39123f, 0x391711e1, 0x39115d5d, 0x3232e110, 0x28056451,
	0xf15dd610, 0x5d5e2fc0, 0x271d8211, 0x3912e133, 0x332f3311, 0x4d05f045, 0xf94605a8, 0x08184506, 0x2105ab5e, 0x07863537, 0x06070629, 0x35232306,
	0x4d231521, 0x032607d8, 0x7f51a223, 0x2a452d57, 0xb2270814, 0x664e2fb8, 0x2d726537, 0x223e6b4f, 0x2e552127, 0x3781023e, 0x47739149, 0x51724620,
	0x31897703, 0x4e417155, 0x45223b60, 0x33081436, 0x4db5c722, 0x1143637f, 0x75861c0c, 0x31496648, 0x02030313, 0x268d9904, 0x354e754e, 0x001c3751,
	0x7100ffff, 0x2d04ecff, 0x06025e04, 0x00005200, 0x19000100, 0x25080f82, 0x004a04c9, 0x40580018, 0x8f470a38, 0x16160116, 0x1414030e, 0x03100300,
	0x1a030302, 0x1a9f1a2f, 0x10031aef, 0xb651470d, 0x15103608, 0x19540e48, 0x50100c15, 0x150e0f12, 0x16075000, 0x3fe13f00, 0x052f413f, 0xe15d2b33,
	0x33115d33, 0x2f335d2f, 0x2f391211, 0x3031e15d, 0x09d65925, 0x21113c08, 0x23112311, 0x15213735, 0x16141123, 0x2f1c5004, 0x304a0f0f, 0x6dfe7171,
	0x0489ddb6, 0x812fd327, 0x0990080d, 0x02828411, 0x0350fcbe, 0x9a504ab0, 0x37464efd, 0x00020000, 0x8314fea4, 0x1a002fb7, 0x39002700, 0x48252140,
	0xcf295700, 0x74450129, 0x091f3006, 0x5410470f, 0x16501b28, 0x221b0f10, 0x82050850, 0x83332092, 0x10012293, 0x209782f6, 0x0528535e, 0x5e303121,
	0x262105bb, 0x08636f27, 0x25067f4d, 0x07062201, 0xd36b1611, 0x04450806, 0xa7753f2d, 0x368f4b68, 0x02020106, 0x7841b601, 0xa36169a9, 0x3bfe4377,
	0x36038289, 0x7b8c4b8f, 0x8927027d, 0x2d4c91d5, 0x272e2b2d, 0xddfe2e61, 0xd3881304, 0x914b4b91, 0xc41801d3, 0x33acfec8, 0xd1d1d331, 0x06ab42cf,
	0x046f4708, 0x0031005e, 0x27364051, 0x10461527, 0x0a100a00, 0x0a030a20, 0x5f333f33, 0xef337f33, 0x33100433, 0x1f480001, 0x2d283256, 0x010a3751,
	0x15381528, 0x15031548, 0x04001f0a, 0x0f10240f, 0x3f3f00fa, 0x5d391712, 0x8b42e15d, 0xe1322309, 0xc9832f33, 0x09086418, 0x240b9147, 0x3233023e,
	0x07974916, 0x1c2d0125, 0x47617e49, 0x4d3b108e, 0x49376284, 0x4e6ab383, 0x17363295, 0x1a3a3c38, 0x22497250, 0x79600602, 0x47162f4e, 0x0f32138d,
	0x82b47641, 0x4995e29a, 0x0a9a1922, 0x39090f13, 0x0b4da470, 0x85280806, 0x16004a04, 0x36002900, 0x21242140, 0x00101248, 0x2b102b57, 0x2ba02b90,
	0x2be02bb0, 0x0a481705, 0x25122a56, 0x1c0f0f50, 0x8507f646, 0xf61023c6, 0x47183232, 0x21251033, 0x031e2115, 0x06414905, 0x34355908, 0x22232726,
	0x2d04020e, 0x75b47a3e, 0x447daf6b, 0x80ce904d, 0xf6fee901, 0x1c304125, 0x472100fd, 0x6d4c4d6e, 0x4b4f2147, 0x5a8b5f3b, 0x6ff8012b, 0x46508dc0,
	0x9c85cb8a, 0x9a3e8ada, 0x7c6c5d29, 0x69905536, 0x8662373b, 0x59d7904e, 0x00a1632c, 0x12000100, 0x6603e5ff, 0x2508b182, 0x403a001c, 0x0d0f0124,
	0x06020d1f, 0x101e570d, 0x1a2b011e, 0x1a021a3b, 0x18104703, 0x180218e0, 0x1c501902, 0xf449080f, 0x01322c07, 0xc6e15d2f, 0xe6105d5d, 0x56325d5e,
	0xe64905a6, 0x07e74608, 0x35213508, 0xfe660337, 0x3e2d198c, 0x282a1224, 0x270d0d24, 0x401b352e, 0xfe345975, 0x4a0486d7, 0x3ba2fd9a, 0x03173352,
	0x87040706, 0x060b0c06, 0x68864d1d, 0x504a7302, 0xa4249383, 0x3d04ecff, 0x26089382, 0x4029001d, 0x1b471018, 0x1f101f57, 0x1f801f60, 0x05470803,
	0x06151e54, 0x00500d0f, 0xe13f0016, 0x1001333f, 0x825de1f6, 0x30312503, 0x022e2205, 0x08072351, 0x35363259, 0x27022e34, 0x15031e33, 0x5c020210,
	0x2964aa81, 0x664220b6, 0x098d9246, 0xb60f1710, 0x0810180f, 0x8c5014f4, 0x58026dbd, 0x8c56b2fd, 0xf7e83663, 0x74757d47, 0x77723d3d, 0xc1fe4b81,
	0x0200d3fe, 0x14fe7100, 0x5e042505, 0x35002500, 0x3c405e00, 0x16472531, 0x82a60096, 0x06003718, 0x571f4826, 0x01372037, 0xe001370f, 0x376f0137,
	0x379f377f, 0x0f834003, 0x02371f3b, 0x06471106, 0x502b3656, 0x31101a0b, 0x01245016, 0x001b0016, 0xe1333f3f, 0x53038232, 0x05530807, 0x23178208,
	0x11013031, 0x21050d4b, 0x1b4c1737, 0x11172305, 0x00513634, 0x01112108, 0x08694e18, 0x033ea208, 0xb76d6602, 0x38204b86, 0x258d2d4e, 0x33192d3f,
	0xa5407458, 0x66925a91, 0xbe905637, 0x1e4f0168, 0x1b2b4936, 0x48162531, 0xfe33597b, 0x05da0114, 0x97d58943, 0x7d8a9853, 0x68336037, 0x6f477d72,
	0x07306199, 0xc1bc5e02, 0x7ac99050, 0x4a90d995, 0x0426fe05, 0x65946225, 0x57351733, 0x07a0fd41, 0x009f6b3b, 0xecff0100, 0x250414fe, 0x28004e04,
	0x1a40a000, 0x1f781f68, 0x09671f02, 0x09c70977, 0x76060903, 0x1c37011c, 0x1e1c1c01, 0xffb80807, 0x130e40c0, 0x08344816, 0x08100801, 0x0112c008,
	0x08128312, 0x0b06193d, 0x2a121248, 0x2a3f2a0f, 0x2acf2a4f, 0x25b00604, 0x250225c0, 0xb81e1d25, 0x1f40f0ff, 0x1e291e1e, 0x2706171b, 0x1c180206,
	0x1c021c28, 0x04061f09, 0x16500f00, 0x230f071b, 0x450f0050, 0x12350536, 0x5d5d3917, 0x3301113f, 0x3333382f, 0x5d5e5d2f, 0x2b2f3311, 0x3b0d825d,
	0x12332b5d, 0x5d2f3d39, 0x5d33335d, 0x30315d33, 0x021e3213, 0x33011317, 0x031e1301, 0x08082a5f, 0x27022ea5, 0x01230103, 0x23262603, 0x36350722,
	0x492dbc36, 0x7b15313a, 0xfeb21f01, 0x1d0eb273, 0x1a253426, 0x3916102e, 0x475f4328, 0xfe831733, 0xc601c2b6, 0x35471ba0, 0x3e161c24, 0x3e1f4e04,
	0xa8fe3d5c, 0xf8fc4a02, 0x422620fe, 0x03051d33, 0x260b068d, 0x01416646, 0x0383fd6a, 0x4fbe013e, 0x078f0a59, 0x0100000a, 0x14fea400, 0x12067105,
	0x4c002700, 0x17012f40, 0x18182647, 0x1147061e, 0x29302957, 0x29902940, 0x29c029b0, 0x1f290f05, 0x21060229, 0x28541e47, 0x010f1f0b, 0x19165026,
	0x001b1716, 0x423f0000, 0x4d4e0615, 0x11e12308, 0x0f422f39, 0x064d4c06, 0x3e4e3320, 0x11072505, 0x032e1123, 0x0806dc42, 0x0311174a, 0x5f834e56,
	0x180f0834, 0x1810b610, 0x93570810, 0x6fb26dc4, 0xb64c89bc, 0x42785a36, 0x73fa1206, 0x9c6c3c09, 0x7e804767, 0x83484983, 0x9d447e7e, 0x07458cdc,
	0xda0126fe, 0xd6884104, 0xfd1f029a, 0x619a72d9, 0x8f05052e, 0x3a08c182, 0x05ecff71, 0x004a0496, 0x4070003b, 0x1d673848, 0xd5471d01, 0x1ab7011a,
	0x011aa901, 0x03011a9a, 0x25051a1a, 0x3d573048, 0x3d143d04, 0xf43dc402, 0x3d7b023d, 0x40023d9b, 0x5602013d, 0x103a0807, 0x3c560548, 0x0a2a1b1b,
	0x5015200f, 0x16003539, 0x32323f00, 0x333f32e1, 0xdb862f39, 0xc84b5f20, 0x21e08206, 0x00825d5f, 0x395de122, 0x2406b043, 0x37023e34, 0x05f54233,
	0x3e323322, 0x4905c043, 0xc04305a1, 0x14270807, 0x2223020e, 0x06232726, 0x5ae90106, 0x0f32608c, 0xba202f1f, 0x0f1f2f20, 0x2d4b361d, 0x162c442e,
	0x2d5163b2, 0x831d364b, 0x83bb2017, 0x32470817, 0x6b5a8d60, 0x1f0a1f8b, 0x9252148b, 0x8f5179cb, 0x49488787, 0x528e8786, 0x34659662, 0x39624829,
	0xcefe3201, 0x65348b81, 0x8e526296, 0x48498687, 0x518f8787, 0x5292cb79, 0x575b5b57, 0x00ffff00, 0x02ecff15, 0x5cd90577, 0x003b0713, 0x00e2fe6a,
	0x40170000, 0x1f01020d, 0x01022611, 0x142a1632, 0x2b012500, 0x83003535, 0x24318203, 0x04ecffa4, 0x2631843d, 0x01000092, 0x826a0006, 0xb619242f,
	0x83270102, 0xffb8252e, 0x321eb4de, 0x87062f53, 0x0fd57431, 0x000e5428, 0x0b401300, 0x31822c02, 0x18203d21, 0x840d1f4c, 0x2106215d, 0x5d848f82,
	0x10540122, 0x01272b84, 0x0126112a, 0x85241e1d, 0x48588259, 0x052106c9, 0x202b8496, 0x24898296, 0x00540107, 0x248b82c3, 0x01094021, 0x302d8248,
	0x3c013c60, 0x40c0ffb8, 0x480b0909, 0x05423c3d, 0x21c58230, 0x46185d2b, 0xc725076d, 0xbe030000, 0x91591807, 0x00690828, 0xff140001, 0x050605ec,
	0x002500b6, 0x045a4085, 0x5a0c1304, 0xdf01210f, 0x0221ff21, 0x0f275521, 0x7f276f27, 0x1a060327, 0xa00118f4, 0x0218b018, 0x18011874, 0x135a1218,
	0x15301500, 0x15501540, 0x150515c0, 0x0113b015, 0x13771367, 0x01135e02, 0x134f133f, 0x01130002, 0x1a5f1113, 0x1519071a, 0x1303165f, 0x005f0712,
	0x05124413, 0x39123227, 0x2f01e12f, 0x2500835d, 0x105d2f33, 0x0b8332e1, 0x5d5e3227, 0x715df610, 0x271c82e1, 0x22053031, 0x16352726, 0x26053f42,
	0x23263435, 0x70231121, 0x4708078b, 0x15021e32, 0x020e1415, 0x462f9e03, 0x27441d19, 0x21334020, 0xbbfe7b69, 0x03acfebb, 0x015efeb1, 0x65925d5a,
	0x845f3535, 0xa00b0d14, 0x33130c09, 0x73854557, 0x0523fd74, 0xfea4a412, 0x8b5e316f, 0x9a698959, 0xffff3165, 0x2505df5d, 0x26027307, 0xc5666101,
	0x33002105, 0x2905c566, 0x26051201, 0x0c063e01, 0x55180004, 0x4a080857, 0xff7d0001, 0x059804ec, 0x002600cb, 0x1113405f, 0x48181340, 0x11071107,
	0x0123ca1b, 0x23802370, 0xffb82302, 0x072440c0, 0x2323480a, 0x0128bf28, 0x1b5b0805, 0x5f082766, 0x05af050f, 0x05050802, 0x5f00240d, 0x5f0d0420,
	0x18131610, 0x240c6964, 0xe1f61001, 0x05124532, 0x215a5d20, 0x30312905, 0x020e2201, 0x21152107, 0x23060645, 0x2223030e, 0x330af15c, 0x26260717,
	0xa05f1903, 0x020d4d78, 0x0586fd74, 0x71ab7640, 0x17609818, 0xaf7a4129, 0xc982a26f, 0x1823488a, 0x73146198, 0x05270759, 0x000602cb, 0x5c000036,
	0x535712e9, 0x48ff2730, 0x73017bfe, 0x5182b605, 0x00002d24, 0x55820200, 0x06e96a08, 0x00b605df, 0x0035002a, 0x2b25b58d, 0x080d065a, 0x40f8ffb8,
	0x48171453, 0x99235a08, 0x101e011e, 0x0600231e, 0x06020690, 0xb40123e0, 0xd423c423, 0x23000323, 0x23902350, 0x070423a0, 0x23062306, 0x005b2f15,
	0x37cf3767, 0x06403701, 0x15154809, 0x0f5f3536, 0x0225af25, 0x2b252508, 0x03235f08, 0x13126019, 0x1206602b, 0x0aea7700, 0x0111e125, 0x792b2f33,
	0x392005d1, 0x2a05a458, 0x33115d5e, 0xe1105d38, 0x4910322b, 0x2127089e, 0x030e2111, 0x6d030e07, 0x372c0a0c, 0x12123636, 0x33112137, 0x01021e32,
	0x07da6518, 0x06237d08, 0xc27e3cdf, 0xfebffe86, 0x211f0fc2, 0x35141022, 0x234e6e4f, 0x3a171c4a, 0x2a3e3020, 0x200c0c1a, 0x02162b27, 0xcf986d93,
	0x77fd377e, 0x2ea4ae77, 0x585d8b5b, 0x9e61ac01, 0x12053d70, 0xd4ecf471, 0x6fa26751, 0x9a0b0e3b, 0x623f100d, 0xc8393675, 0x3a010601, 0x4298fdaa,
	0x9dfe9871, 0x61468884, 0x02001b3c, 0x0000c700, 0xb6050c07, 0x21001600, 0x32405300, 0x0e5a1711, 0x1b0a0606, 0x3108fe82, 0x01230f23, 0x231f230f,
	0x23ff237f, 0x5a090d04, 0x2122640a, 0x0f115f08, 0x020daf0d, 0x0f0d0d08, 0x6017030b, 0x0012060a, 0x3fe1333f, 0x5e2f3933, 0x544b335d, 0x5d322105,
	0x4606a75b, 0x14230590, 0x8223020e, 0x231125f3, 0x21113311, 0xe48d0382, 0x850c0721, 0xb8fd26e4, 0x4802baba, 0x29cd94ba, 0x56fdaa02, 0x98fdb605,
	0xbc8d6802, 0x2105ad74, 0xbd820605, 0x00155008, 0x084d4073, 0x1755075a, 0x176f170f, 0x0603177f, 0xa00114f4, 0x0214b014, 0x14011474, 0x5a0e0014,
	0x3011000f, 0x50114011, 0x0511c011, 0x0fb01111, 0x770f6701, 0x0f5e020f, 0x4f0f3f01, 0x0f00020f, 0x11150f01, 0x5f0d125f, 0x12070000, 0x83070f03,
	0x123f25d6, 0x10e12f39, 0x2f20d482, 0x200a3844, 0x200c8332, 0x05374a5e, 0x32210125, 0x8215021e, 0x0b2f44d9, 0x44230221, 0xba200510, 0x290a2244,
	0x5e318103, 0xf2fd598b, 0x1844f601, 0x050d4407, 0x07a20427, 0x01260273, 0x060d44b4, 0x0d448920, 0x05172606, 0x0b220126, 0x090d4411, 0x19262d82,
	0xae04ecff, 0x2d826907, 0x2d83bd20, 0x00360223, 0x202d8623, 0x232d8227, 0x13222c0d, 0x080b3b44, 0x7ffec727, 0xb605c104, 0x63000b00, 0x02c64140,
	0x020202d6, 0xd503c55a, 0x03a80203, 0x01039601, 0x110e1003, 0x01034748, 0x080a823a, 0x09050328, 0x0d65005a, 0x6f010db0, 0xaf0d9f0d, 0x0d10030d,
	0x055a0801, 0x060a0c64, 0x055f0803, 0x05010202, 0x33332f00, 0x324b102f, 0x425d2007, 0x2f3005e2, 0x5d2b5d5d, 0x5de15d5d, 0x21213031, 0x21112311,
	0x3405df41, 0x5afec104, 0xba5dfeb1, 0xfebb8502, 0x0581017f, 0x05f0fab6, 0x0ffb6210, 0x21057742, 0xa1823304, 0x00103108, 0x404b001b, 0x01085f2e,
	0x15110808, 0x1d67005b, 0x1d5f1d0f, 0x1dcf1d7f, 0x110b0604, 0x1c64065a, 0x0b0f5f1b, 0x08020baf, 0x0a110b0b, 0x1103075f, 0x22077643, 0x612f3912,
	0x322106b7, 0x8292835e, 0x208b820f, 0x066f4201, 0x4e431520, 0x3304330f, 0x86c27e3c, 0x140396fe, 0x9896a6fd, 0xfd377ecf, 0x3443a04e, 0x43812005,
	0xb6230634, 0x433cfea4, 0xa3410b1c, 0x08a16306, 0x0a954118, 0x6101062c, 0x02000000, 0x7ffe0e00, 0xc5820a05, 0xc5821120, 0x408b7308, 0x281b180b,
	0x071b021b, 0x14011437, 0x40f8ffb8, 0x4817140b, 0x0f0e5a14, 0x07070107, 0x40f0ffb8, 0xc00e3010, 0x0e07020e, 0x12050e07, 0x5a01105a, 0xc0ffb800,
	0x15102540, 0x10000048, 0x1d201d65, 0x011d0f01, 0x055a0408, 0x5f141c05, 0x5109030e, 0x06101b08, 0x0500035f, 0x00120305, 0x332f333f, 0x3232e110,
	0xe13fe22f, 0x2f330111, 0x5d5d5ee1, 0xab18e410, 0x56080a14, 0x5d5e385d, 0x5d2be110, 0x315d3311, 0x11230130, 0x11231121, 0x37053e33, 0x21331121,
	0x050e2111, 0xb00a0507, 0x71b064fc, 0x414d562f, 0x02041d30, 0x83fec265, 0x1f04fafe, 0x4d463d2e, 0x017ffe27, 0x027ffe81, 0xd9c85527, 0x69e3e8e6,
	0x6a04f0fa, 0xd1cab94c, 0x634bb7c8, 0x0027109b, 0x00040001, 0x84810600, 0xcb4f08f5, 0x09664e40, 0x09860976, 0x47093703, 0x03095709, 0x47060609,
	0x020df70d, 0x00695a0d, 0x00890079, 0x48003803, 0x03005800, 0xa8030300, 0x020eb80e, 0x86010e99, 0x0e57010e, 0x0e770e67, 0x110e0e03, 0x0808070a,
	0x010a000b, 0x0a800a70, 0x60030ac0, 0x3d0805f6, 0x0a480a07, 0x130a0a10, 0xbf0113f0, 0xdf13cf13, 0x13a00313, 0x01138f01, 0x0f011340, 0x02131f13,
	0x01010208, 0xffb81110, 0x110f40f0, 0x03061211, 0x0a110403, 0x0107120e, 0x3f000304, 0x02823333, 0x11391223, 0x06004c33, 0x3d5e1120, 0x115d2906,
	0x2b382f33, 0x3333715d, 0x12231a82, 0x825d2f39, 0x2e0a8200, 0x5de15d5d, 0x5d331132, 0x0130315d, 0x84013301, 0x01240836, 0x11012301, 0x23011123,
	0xedfd2502, 0xb30a02cd, 0xfdcd0a02, 0xd32102ed, 0xfdb3eefd, 0xf202d3ee, 0x3cfdc402, 0xfd250387, 0xfde5020e, 0x0803831b, 0x0100004e, 0xecff4800,
	0xcb05ec03, 0x68003900, 0x5b273f40, 0x00210500, 0x00002130, 0x13033021, 0x670b5b1c, 0x013b9f3b, 0x13801370, 0x4f133f02, 0x03135f13, 0x053a1313,
	0x21aa6020, 0x01217801, 0x0801210f, 0x2f192121, 0x0435602c, 0x10146019, 0x820cb647, 0x833920a6, 0x20b482d0, 0x765c1810, 0x5b112007, 0x142306f8,
	0x1807020e, 0x2b07e4a0, 0x35272622, 0x3233031e, 0x26343536, 0x210ae85b, 0x6c182223, 0x92080827, 0x5b33d103, 0x8a574b7d, 0x8843325e, 0xc06e89cd,
	0x63602b55, 0xb0b22e63, 0xb0bfbacf, 0x32618e5c, 0x3a5f4425, 0x5c4ba96e, 0x83746226, 0x71a66d47, 0x49600439, 0x0c395878, 0x59390b06, 0xa0604877,
	0x2d224074, 0x182417aa, 0x8787940d, 0x48279781, 0x53363d65, 0x36431e3a, 0x29361f7d, 0x85613618, 0x00010000, 0x050000c9, 0x00b60510, 0x406b0017,
	0x0e0b141b, 0x19650d5a, 0xaf0119d0, 0x19200119, 0x16021930, 0x175a0209, 0x09171864, 0xb3e8ffb8, 0x82481814, 0x40e03107, 0x48130a23, 0x09160906,
	0x09030926, 0x1814120d, 0x14211782, 0x35138220, 0x14191409, 0x07031429, 0x03000b14, 0x32323f00, 0x2b2b5d5e, 0x0482333f, 0x9a183320, 0x103108f3,
	0x3232e1f6, 0x33133031, 0x020e1411, 0x33070607, 0x13851801, 0x01310809, 0x01aec923, 0x04020202, 0xcc020704, 0x0406acd5, 0xfd080504, 0xb605d731,
	0x3e1ae0fc, 0x4a204343, 0xfab4044c, 0x3919034a, 0x4d4c418e, 0xff0046fb, 0x25bd85ff, 0x26026907, 0x6945b201, 0x01893206, 0xb4150052, 0x26051d01,
	0xebffb801, 0x001822b4, 0x0aa7490c, 0x0000c724, 0xed82a204, 0x5e000a30, 0x09082140, 0x01091009, 0x00100000, 0x04820702, 0x0c002808, 0x2f010cb0,
	0x0c10010c, 0x010a9701, 0x0a010a56, 0x40f8ffb8, 0x480c0814, 0x0307070a, 0x0b64045a, 0x08040207, 0x64040305, 0x33230545, 0x84393912, 0x331123d6,
	0x00835d2b, 0x2f331131, 0x335d5e38, 0x33113833, 0x23213031, 0x42231101, 0x043705a1, 0xbafddba2, 0x3502baba, 0x02cbfdcf, 0x051bfde5, 0x023cfdb6,
	0x8242fdc4, 0x000025b0, 0x9304e9ff, 0x1f258f82, 0x08b16200, 0x086f8303, 0x17143b39, 0x895a0348, 0x10190119, 0x011ee019, 0x1ec41eb4, 0x00031ed4,
	0x801e501e, 0x1e07031e, 0x5a01101e, 0x0f216500, 0x7f211f21, 0x10080321, 0x5f032010, 0x6014031e, 0x83130d11, 0x05bf5c96, 0x2f330123, 0x06f8455e,
	0x99825e20, 0x5d383325, 0x64322be1, 0xce4805ea, 0x93042416, 0x4885feba, 0xd0201aba, 0x441aa548, 0x4b660675, 0x6804200f, 0xb1650801, 0x2b0f820f,
	0x040000c7, 0x02b605c1, 0x006e0106, 0x6b653f86, 0x272f8509, 0xcb059804, 0x26000602, 0xeb641f84, 0x06b9550c, 0x05ae5f08, 0x002100b6, 0x1210406f,
	0x131b1b01, 0x70006021, 0xf000b000, 0xb8000400, 0x1040c0ff, 0x00480a06, 0x23000010, 0x237f230f, 0x13091402, 0x40f0ffb8, 0x2213130c, 0x1af71ae7,
	0x011ad602, 0xe0ffb81a, 0x0e0a1040, 0x1a011248, 0x5f0d0003, 0x1313060a, 0x3f000300, 0xe1333f32, 0x2b391711, 0x94445d5d, 0x068c4406, 0x39123329,
	0x31333311, 0x4a010130, 0x52080d0e, 0x1e013301, 0x3e331703, 0x04013703, 0x2654feae, 0x6f9c7053, 0x25255a33, 0x52353459, 0xfd1c3842, 0x7f01ccee,
	0x09090a05, 0x0b030204, 0x01030b0b, 0xfbb60537, 0x7ba45dfa, 0xb90f0f48, 0x35171914, 0x3f043f56, 0x180ad7fc, 0x0909171a, 0x071d211f, 0x4b001803,
	0x05210579, 0x21ff83ba, 0xff847301, 0x00000023, 0x0bad6404, 0x7ffec724, 0xff827105, 0x3b000b32, 0x5a032140, 0x5a090202, 0x0db00d00, 0x010daf01,
	0x2d0a1248, 0x055f0800, 0x12050202, 0x2f333f00, 0xd982e110, 0xf6100130, 0x5d5d5de1, 0x33e1d410, 0x3031e12f, 0x0b483325, 0xb0b02a0b, 0x02ba06fc,
	0xfda6bb85, 0x070b48d9, 0x00010023, 0x207982a6, 0x08698281, 0x48001532, 0x01131d40, 0x1765005a, 0x17a01770, 0x01172f02, 0x0d011710, 0x700a605a,
	0xb00aa00a, 0xb80a040a, 0x0e40c0ff, 0x0a480a07, 0x055f1013, 0x030b1405, 0x27059042, 0x33e12f39, 0x5d2b2f01, 0xf6217884, 0x058742e1, 0x23060623,
	0x06c75322, 0x33162908, 0x11373632, 0xba810433, 0x5d62c373, 0xba356592, 0xb95a7b69, 0x5602ba70, 0x5f312e2c, 0x4702598a, 0x7473d1fd, 0xc6022828,
	0xc7248d82, 0x33070000, 0x603af784, 0x08564240, 0x175a0801, 0x05860105, 0x05a60596, 0x77056703, 0x05050205, 0xa3820901, 0x000d3208, 0x020d100d,
	0x0d500d20, 0x0d800d70, 0x0dd00dc0, 0x0f070de0, 0x0407010d, 0x0c64015a, 0x0302060a, 0x015f0408, 0xe13f0012, 0x33333f32, 0xe1f61001, 0x05a8595e,
	0x2f391122, 0x28490882, 0x05044b06, 0x33112129, 0x94f93307, 0x831f02ba, 0x05244902, 0x05f0fa24, 0x8f830010, 0x077ffe23, 0x088f82e3, 0x71000f47,
	0x0c564b40, 0x175a0c01, 0x09860109, 0x09a60996, 0x77096703, 0x09090209, 0x005a0d05, 0x02025a03, 0x00116500, 0x02111011, 0x11501120, 0x11801170,
	0x11d011c0, 0x0f0711e0, 0x08070111, 0x1064055a, 0x03060a0e, 0x0eb1410c, 0xe4259c8c, 0x10e12f32, 0x41a089e1, 0x11200bbd, 0xb021a484, 0x41a688b0,
	0xab850ac4, 0x14000226, 0xd5040000, 0x2b06c549, 0x0b334052, 0x06905a11, 0x08060601, 0x2e06c849, 0x2f1d0f01, 0x5f1d3f1d, 0x051daf1d, 0x49080806,
	0x08220bca, 0xca49095f, 0x0111240f, 0x4c5e2f33, 0x5d20073c, 0x200b304d, 0x10cc4935, 0x7e3cd538, 0x95fe86c2, 0x0f02acfe, 0x7fcf9895, 0xa04efd37,
	0x5c2da3ae, 0xcc495d8a, 0xa4122107, 0x260d2c4c, 0x00c70003, 0x82cf0500, 0x0e3108ab, 0x1d001900, 0x2b404900, 0x00005b13, 0x06000001, 0x651d5a1a,
	0x9f1f0f1f, 0x0906021f, 0x64065a0f, 0x0f5f191e, 0x0209af09, 0x1b090908, 0x600f0307, 0x0be44c1a, 0x68075f5e, 0xe121068a, 0x05035931, 0x2311d94c,
	0x11331101, 0x2007734a, 0x0e704aba, 0xbb930322, 0x8c07734a, 0x56fd25a5, 0x4afab605, 0x830a1d4b, 0x404825ab, 0x905b132e, 0x6731a982, 0x5f1b0f1b,
	0x1b06021b, 0x48181540, 0x130d401b, 0x20ae8448, 0x83ae891a, 0x21ac83ad, 0x1b4b3fe1, 0x2b2b2509, 0xf6105d5e, 0x91088574, 0x94a497a8, 0x088682a1,
	0xecff3b43, 0xcb054404, 0x51002400, 0x201d2f40, 0x1e160c5b, 0x0c041e16, 0x26bf2667, 0x26df26cf, 0x25040403, 0x1faa5f1e, 0x011f7801, 0x08011f0f,
	0x1a071f1f, 0x1311175f, 0x075f0003, 0xe13f0004, 0xe1333f33, 0x2e9e8311, 0x11e15d5d, 0x5d2f3301, 0x3911e610, 0x4f2f2f39, 0x22280521, 0x36270706,
	0x16323336, 0x08d86718, 0x51022e21, 0x99080597, 0x35211312, 0x01032e21, 0x3f945eba, 0x6cc44f4e, 0x52a2f4a2, 0xa4f7a552, 0x4e56613a, 0x59a04e27,
	0xfd06f7ed, 0x0971028b, 0x059d7347, 0x9c202e27, 0xc16d2c2a, 0xb39df6fe, 0x6dcae0fe, 0x0f170e07, 0x012317a2, 0xa2060117, 0x407ab06f, 0xc7000200,
	0x9e07ecff, 0x1a00cd05, 0x5e002e00, 0x5b1b3c40, 0x0111900a, 0x250d1111, 0x3067005b, 0x3f01300f, 0x7f306f30, 0xff30ef30, 0x40300530, 0x10481411,
	0x640d5a0c, 0x165f2a2f, 0x0f5f0b04, 0x10080110, 0x030e0d10, 0x5f20120d, 0xd4821305, 0x4c3f3f21, 0x3f20058d, 0x20051e42, 0x08c5422b, 0x31e13324,
	0x446e0130, 0x21272908, 0x33112311, 0x033e2111, 0x9c59e184, 0x2e2b0809, 0x0e222302, 0x4f9e0702, 0x9796e59b, 0x065098e1, 0xbabaaefe, 0x550b5601,
	0x9591db98, 0xfb4f9ae5, 0x9d6731fa, 0x669d6d6c, 0x82653030, 0x679e2e07, 0xa9dd0231, 0x6cc6eafe, 0x0301b764, 0x051e4fa0, 0xa7ec9226, 0xfec56b5a,
	0x1415a318, 0x00192b08, 0x05f20300, 0x000f00b6, 0x409b001c, 0x01000609, 0x00f600e6, 0xffb80002, 0x0b2440f8, 0x0e1c480f, 0x0000035a, 0x1e650d08,
	0xa1181e3f, 0x06280b9e, 0x01e60101, 0x010201f6, 0x0d202883, 0x59082882, 0x01024b01, 0x0b084002, 0xffb80248, 0x022640f0, 0xdf5b1602, 0xff08ef08,
	0x40080308, 0x0748130f, 0x02081708, 0x1d660808, 0x0f03601c, 0x6011010f, 0x010e030b, 0x333f0012, 0x3912e13f, 0x01e1332f, 0x5d5ef610, 0x33e15d2b,
	0x5d2b382f, 0x715d2b33, 0xf6105d5d, 0x33113911, 0x0c8232e1, 0x01303130, 0x2e012301, 0x36343503, 0x23112133, 0xe15d1111, 0x33890808, 0xb2fe4202,
	0x377d01db, 0xfd2c4b63, 0xbb7501fb, 0x4f734abc, 0x774e2729, 0x5c02b451, 0x8f02a4fd, 0x88613e14, 0xfac9c65d, 0x025c024a, 0x613e1dbb, 0x4a694244,
	0xffff0028, 0xecff5e00, 0x5e049c03, 0x44000602, 0x02000000, 0xecff7500, 0x23062104, 0x3b002700, 0x2c404900, 0x1e09482d, 0x3dd03d57, 0x013d7f01,
	0x0f013d40, 0x1306013d, 0x56004837, 0x1350323c, 0x28081919, 0x09162350, 0x48100b08, 0x01085109, 0x2be13f00, 0x0569573f, 0x2b096462, 0xe132f610,
	0x34133031, 0x37363612, 0x17230282, 0x8207030e, 0x18332002, 0x200d0c5e, 0x068b6c01, 0xc008cf83, 0x021e1407, 0xa2683175, 0x66f27d71, 0x7d7b3221,
	0x643e2c75, 0x0d042948, 0x6b543e12, 0x65966340, 0xae7c4532, 0x7bad6b68, 0x3ce10142, 0x1a264662, 0x3d415a3a, 0x0d39536a, 0x02724119, 0x1901b593,
	0x1b197ecb, 0x08a01431, 0x0a181816, 0xa571420e, 0x313c1d71, 0xb4834920, 0x8ace896c, 0xfdad5945, 0x582794fe, 0x8654698f, 0x4430335f, 0xbc641a49,
	0x03005993, 0x0000ae00, 0x4a041904, 0x20001500, 0x5c002b00, 0x1b033a40, 0x00004621, 0x0947160f, 0x2d202d57, 0x902d4001, 0xd02db02d, 0x052df02d,
	0x06012d0f, 0x0f471b26, 0x1a032c54, 0x0126bf50, 0x26892679, 0x1b262602, 0x0f105025, 0x150f501b, 0x0eb86500, 0x28098e60, 0x3912e12f, 0x14013031,
	0x088e4c06, 0x21112129, 0x03021e32, 0x83232634, 0x863e2009, 0x32332109, 0x50080982, 0x386b7bf6, 0x2f294761, 0xfe719f65, 0x53c50139, 0x903b678e,
	0x00ff8082, 0x5d380401, 0x6d1e2643, 0xecf5fe6c, 0x1f3f5c3e, 0x75683503, 0x24070712, 0x433f5b3d, 0x04305674, 0x6b401c4a, 0x485cc7fd, 0x2a12a8fe,
	0x4d0c0245, 0x0fd7fe40, 0x00003c24, 0x21e38301, 0xe3820a03, 0x2f00053f, 0x00001c40, 0x00020010, 0x07a00700, 0x01078101, 0x02010750, 0x06540347,
	0x0f045001, 0x24411802, 0x5d5d2509, 0x5d2f3311, 0x212fb282, 0x21112311, 0x5afe0a03, 0x035c02b6, 0x8250fcb0, 0x00022645, 0x0483fe29, 0x08098237,
	0x17000f5a, 0x10407900, 0x46120717, 0x3f072f0c, 0x070b0207, 0x0702071b, 0x40f0ffb8, 0xb20ca239, 0x0c04020c, 0x07020c14, 0x050c070c, 0x010e4710,
	0x20000046, 0x550e010e, 0xcf19af19, 0x19300219, 0x01192f01, 0x05054604, 0x0c4f1218, 0x060e170f, 0x05150350, 0x3f00fb00, 0x32e13f32, 0x11210382,
	0x06f96601, 0x475de421, 0x392b068b, 0x5d5d2f2f, 0x105d5d38, 0x4f3311e1, 0x02210ac9, 0x05ca4f12, 0x0e233108, 0x37040703, 0xae4efdae, 0x43634156,
	0x17020122, 0xc0b2fe97, 0x513a2407, 0x0183fe34, 0x0283fe7d, 0xf3df5f17, 0xfc7f0001, 0x67240350, 0x53c2d1d7, 0x2905a560, 0x5e04e103, 0x48000602,
	0xc14f0000, 0xbe052105, 0x2208db82, 0x409c0011, 0x0303061f, 0x000f460a, 0x010bd600, 0x0bc90bb9, 0x010ba602, 0x0b010b97, 0x04070e0b, 0x82080505,
	0xb3c024e8, 0x83481512, 0x402e0807, 0x480b0724, 0x0601070f, 0x07071007, 0x10130013, 0x13df0213, 0x70133001, 0x03139013, 0x0701130f, 0x0d101011,
	0xf0ffb80e, 0x0e0e0f40, 0x69820312, 0x0a080d27, 0x01041115, 0x17984f0f, 0x33117128, 0x5d5e382f, 0x974f2b2b, 0x32e1210e, 0x8f4ffc84, 0x01013e0d,
	0xa48f0233, 0xfec5a001, 0xcece0158, 0xfea443fe, 0xcf01cf44, 0x02c558fe, 0xfd150235, 0x250383eb, 0x2d02cbfd, 0x0384d3fd, 0xe9821382, 0xecff4432,
	0x5e045203, 0x5f003900, 0x46053a40, 0x39161b16, 0x31080182, 0x2147340c, 0x3bb03b57, 0x3bd03bc0, 0x013b6f03, 0x29013b20, 0x1b3a560c, 0x39cf5038,
	0x99398901, 0x390f0239, 0x39390801, 0x26502f11, 0x11500816, 0x69720010, 0x5d5d2708, 0x100139e1, 0x8a4f32e6, 0x39392306, 0x884f2f2f, 0x3e322506,
	0x26343502, 0x200a6b4f, 0x139a4f15, 0x61082485, 0x71013523, 0x2748643d, 0x81476c73, 0x4d283f4b, 0x56355a52, 0x1c3a6990, 0x2c2b4633, 0x35263f52,
	0x6d71a66c, 0x4c1f3aaf, 0x37336157, 0x85294660, 0x8702818a, 0x2d402712, 0x22264d4d, 0x131c1493, 0x6d4a2609, 0x3b4d3246, 0x0e0b0e29, 0x3e5a422c,
	0x31567543, 0x10a62223, 0x120f181f, 0x5e33452a, 0x1143995b, 0x04310805, 0x004a043b, 0x4051000b, 0x0910031b, 0x06034818, 0x0d550546, 0x0d100d00,
	0x0da00d20, 0x0dd00dc0, 0x0d070df0, 0xb3c0ffb8, 0x0948110e, 0x40f0ffb8, 0x2d258211, 0x0a460009, 0x03080c54, 0x02060f0b, 0xba41150a, 0x10012706,
	0x2b32e1f6, 0x06845d2b, 0x30312708, 0x01071101, 0x11231133, 0x11230113, 0x020c5a01, 0x0bace904, 0x04eafefd, 0xfc64fd4a, 0xb6fb9803, 0x0f018702,
	0x7c826afc, 0x3f058b66, 0x17063b04, 0xd2012602, 0x06010000, 0x00253602, 0x01b41500, 0x01261111, 0xb4ffffb8, 0x040a0c16, 0x240a4f4f, 0x030000ae,
	0x283882e5, 0x4041000a, 0x01010023, 0x053a6304, 0x03031037, 0x010c0f0c, 0x4706020a, 0x050b5407, 0x070a0a02, 0x040f0800, 0x209f8307, 0x05494d3f,
	0x3230a284, 0x2f33115d, 0x33335d38, 0x30313311, 0x01013301, 0x2b06354f, 0xfec4fa02, 0xcec60161, 0xb4b44bfe, 0xf126a582, 0x2d02c5fd, 0x0982d3fd,
	0x0100eb28, 0xf2ff1000, 0x7382b003, 0x00143408, 0x0331404c, 0x01130446, 0x800113f4, 0xc0139013, 0x0413d013, 0x13011354, 0x47010b13, 0x0f165500,
	0xff162f16, 0x0b060316, 0x5003150b, 0x4f0e0f13, 0x82011608, 0xe13f2181, 0x20059553, 0x06224f5e, 0x5d5d5d23, 0x06087471, 0x7d680220, 0x27300805,
	0x32331635, 0x37123636, 0xb6b00321, 0x4014fefe, 0x1c56825f, 0x1b171031, 0x33455937, 0x03540212, 0xfefdfeb0, 0x0669e694, 0x75068306, 0xfa6f01f1,
	0x2105bf41, 0x95821005, 0x00204208, 0x1f3f405e, 0x55004601, 0x0122cf22, 0x22502240, 0x01220f02, 0x46101306, 0x02215411, 0x4b0f3b0f, 0x030f5b0f,
	0x0f190f09, 0x0f030f29, 0x340f121f, 0x54194419, 0x19060319, 0x19261916, 0x01091903, 0x25a38211, 0x5d333333, 0x04833f5d, 0x46331121, 0x102008bf,
	0x2a073d4d, 0x0107030e, 0x032e0123, 0x82231127, 0x031e351e, 0x37033e17, 0x10053301, 0x141106a1, 0xf8fe0712, 0x05f7fe87, 0x32080983, 0x0b01dda2,
	0x0f13160d, 0x130e0604, 0x0e010d16, 0x158103d9, 0x12363b39, 0xb00250fd, 0x3e3b310d, 0x047ffc1a, 0x2247fd4a, 0x10323c43, 0x413b3111, 0x42bd0221,
	0x44080c89, 0x0217405b, 0x55054706, 0x200d000d, 0x0d30020d, 0x0d500d40, 0x0df00dd0, 0xffb80d05, 0x0e2340c0, 0x09014811, 0x0c540a47, 0x01eb5008,
	0xb901a901, 0x010f0201, 0x012f011f, 0x01010603, 0x0315050a, 0x3f000f00, 0x056f5832, 0x495d5d21, 0x32260b6d, 0x11013031, 0x7e4e1121, 0x11233805,
	0x21026401, 0xdffdb6b6, 0xfe4a04b6, 0xfbc70139, 0xfee901b6, 0x654a0417, 0x280812b1, 0x040000ae, 0x004a0412, 0x402d0007, 0x0447051c, 0x09100955,
	0x09600920, 0x09800970, 0x01470005, 0x50070854, 0x00050f02, 0x84788315, 0x755d2071, 0x012e0ce5, 0x6403b664, 0x0408feb6, 0x03b6fb4a, 0x618200b0,
	0x14feae2b, 0x5e043f04, 0x53000602, 0x240f8300, 0x03ecff71, 0x2a0f846f, 0x00000046, 0x00290001, 0x845e0300, 0x40582871, 0x0109203c, 0x830109df,
	0x5f02286c, 0x000f0109, 0x8200cc01, 0x00bf2105, 0x003d3d82, 0x60034702, 0xd0057005, 0x051f0305, 0x00050501, 0xb0031003, 0x0403c003, 0x50050103,
	0x06c94606, 0x2f013230, 0x5d2f335d, 0x32e1105d, 0x5d5d5e2f, 0x03825d71, 0x3b07d246, 0x5e032135, 0xfeb7c1fe, 0x033503c1, 0x0350fcb0, 0xffff9ab0,
	0x14fe0a00, 0x4a04df03, 0x5c205f82, 0x032c8d82, 0x14fe7100, 0x14062305, 0x22001900, 0x30089982, 0x274b4074, 0x1d460b00, 0x130d0c17, 0xc90cb949,
	0x0c97020c, 0x0c020ca7, 0x4823120c, 0x202b5705, 0x2b0f012b, 0xef2b9f01, 0x2b80022b, 0x012b6f01, 0x37108340, 0x06022b1f, 0x5612481a, 0x2600182a,
	0x1700501e, 0x501d2710, 0x0b160d0a, 0x2209be62, 0x4f013f32, 0x9e830510, 0x2508c775, 0xe133332b, 0xad823232, 0x080cac60, 0x023e3483, 0x01331137,
	0x11171614, 0x3405030e, 0x36112726, 0x71210336, 0x474c88bd, 0xaa77be86, 0x4c89bf72, 0x79c18547, 0x9c0cfeaa, 0x507d58ae, 0x9b390325, 0x0499acaa,
	0x8f550c5a, 0xc87d7dc6, 0xfe0b5691, 0x0adc0124, 0x7ec99056, 0x558fc77d, 0xfcba010b, 0x13d2bb13, 0x3d093c03, 0xba5e9167, 0xc6fc14cc, 0xff00d114,
	0x002300ff, 0x04db0300, 0x0006024a, 0x0000005b, 0xfeae0001, 0x04b20483, 0x000b004a, 0x32d68244, 0x01000f47, 0x07000006, 0x010a8f47, 0x0d100d0a,
	0x4f600d20, 0x063206f9, 0x54034706, 0x0f04080c, 0x0350060a, 0x00fb0115, 0x09513f3f, 0xd4102808, 0x2f33e15d, 0x47e15d5e, 0xef4f06ba, 0x04333605,
	0xb2fcb6b2, 0xb6f801b6, 0x0183fea0, 0xfc4a047d, 0xfcb00350, 0x20738250, 0x2083829a, 0x287382fe, 0x40310018, 0x470c081c, 0xf29b180b, 0x47012c08,
	0x08195417, 0x12125003, 0x4209150b, 0x392205f6, 0xb664e12f, 0x82322008, 0x14112b60, 0x023e3233, 0x11331137, 0x3a651123, 0x012b0807, 0x502db850,
	0xb62a4d4c, 0x55502cb6, 0x7a4e3a5e, 0x4a042b52, 0x0fae66fe, 0x011c2c1c, 0x01b6fbd5, 0x20301ee9, 0x73542f11, 0x43a60144, 0x06210599, 0x08f38446,
	0x4340662f, 0x09b64700, 0xa90209c6, 0x74030109, 0x94098409, 0x09670309, 0x09090601, 0x04470105, 0x0d200d55, 0x010d0f01, 0x0df00d80, 0x010d6f02,
	0x300d8340, 0x06020d2f, 0x54054708, 0x5008000c, 0x060a1505, 0x05e84702, 0x4132e121, 0xae6408ed, 0x5d5f2207, 0x2302825d, 0x253031e1, 0x2006285a,
	0x2f078211, 0xba01d503, 0xb668fab7, 0x9ab6bb01, 0xb6fbb003, 0x41051741, 0x06210589, 0x2d9582e5, 0x4077000f, 0xb6470a4e, 0x0207c607, 0x958207a9,
	0x07840732, 0x67030794, 0x07060107, 0x470b0307, 0x0e47010e, 0x24082e82, 0x010ebf00, 0x1120110e, 0x01110f01, 0x11801140, 0x11f011e0, 0x2f110f04,
	0x06060211, 0x10540347, 0x0f04080c, 0x0bac410e, 0xa1513220, 0x1071260a, 0x2f325dc4, 0x0507515d, 0x0120a688, 0x8308d15a, 0x331126a8, 0xfab6e506,
	0x82a8837f, 0x419f20b1, 0x032b0bc3, 0x0050fcb0, 0x00290002, 0x82fc0400, 0x0e3708b1, 0x5c001b00, 0x470f3e40, 0x501d5704, 0x901d601d, 0x041de01d,
	0x00011d3f, 0x000a4716, 0x020c100c, 0x0cf00cb0, 0x000c0c02, 0x500a100a, 0xa00a600a, 0x0a08050a, 0x83bf5015, 0x0c1627c5, 0x160f0d50, 0x634b0a50,
	0x01e12c09, 0x335d5e2f, 0x10715d2f, 0x5c5d32e1, 0xe1730874, 0x11212805, 0x01213521, 0x4b022e34, 0x0225065c, 0xd4140148, 0x05504bcc, 0x98fe2808,
	0x02021f02, 0x40604121, 0x040100ff, 0x26445d37, 0x9b9c8702, 0x2f587c4d, 0xfc9ab003, 0x284231f8, 0x11a8fe11, 0x4c004229, 0x3f08051b, 0x4a045005,
	0x10000c00, 0x61001d00, 0x47184040, 0x04100400, 0x04700420, 0x060504d0, 0x0e0a0404, 0x1f550d47, 0xbf011f0f, 0xdf1fcf1f, 0x041fff1f, 0x0f011fa0,
	0x021f7f1f, 0x47120007, 0x111e540a, 0x0f25be85, 0x50120f0b, 0x5ebd830e, 0x9e450511, 0x635e2006, 0x164309c1, 0x32332105, 0x332bc087, 0x33112301,
	0x32331101, 0x8335023e, 0x640122c8, 0x2dc186ec, 0xec03b662, 0x14fcb6b6, 0x435d38db, 0xc7822126, 0x0427bf87, 0x04b6fb4a, 0x84a4fd4a, 0x833020be,
	0x000022c8, 0x08df4c02, 0x19000c3e, 0x29404000, 0x57044714, 0x011b001b, 0x1b201b00, 0x1b901b70, 0x1bd01bb0, 0x0e000806, 0x1a21ac82, 0x22ac850d,
	0x410e0f0b, 0x39200668, 0x09f1b118, 0xf6107127, 0x013031e1, 0x22a08921, 0x89211111, 0x1501219c, 0x39239d86, 0x910401b6, 0x08948c98, 0x3700014b,
	0x4203ecff, 0x26005e04, 0x3e405e00, 0x0c040e0e, 0x5722480f, 0xaf288f28, 0x28400228, 0x040f1801, 0x042f041f, 0x0c400403, 0x58044811, 0xef500d27,
	0x0ea9010e, 0x0f020eb9, 0x2f0e1f0e, 0x0e06030e, 0x5112070e, 0x5107101d, 0x0ce17000, 0x1001e125, 0x42712be6, 0x3223050d, 0x622f3911, 0x372b0cba,
	0x26213521, 0x0e222326, 0x4e270702, 0x4c080982, 0x7c594201, 0x52833636, 0x30527449, 0x0123fe04, 0x8c920ddb, 0x383c3b19, 0x40183517, 0x66264e48,
	0x514d84b3, 0x1e14ba8c, 0x2519a21d, 0x5c845428, 0x0997a69a, 0x9a0a130f, 0x0910160c, 0x9ddb893e, 0x438ad492, 0x00020000, 0x06ecffae, 0x20d18208,
	0x08d3821a, 0x4b407220, 0x200a481b, 0x114f0111, 0x0d111101, 0x57004821, 0x2f280f28, 0x28ef0228, 0x470228ff, 0x0c840128, 0x0c102608, 0x27540d47,
	0x10165024, 0x10ef500b, 0xb910a901, 0x102c0210, 0x1b100b01, 0x10060210, 0x0f0e0d10, 0x501e150d, 0x21e08405, 0x1552123f, 0xe15d2105, 0x42064551,
	0x5d210937, 0x05475171, 0x23020e25, 0x51022e22, 0x1e210b45, 0x95831802, 0x0623080b, 0xab784008, 0x75a2626a, 0xeffe0746, 0x1301b6b6, 0xa076480a,
	0x79a76263, 0x8029fd44, 0x807e8f8e, 0x6c7e8e8f, 0x4230056b, 0xfe7cbe81, 0xfe4a0417, 0x78b17439, 0xd3914b3e, 0x0b77a018, 0x00233e08, 0x04910300,
	0x0011004a, 0x4053001c, 0x11110214, 0x470f1807, 0x0f1e550e, 0x8f1e6f1e, 0x0006031e, 0xf0ffb801, 0x01011940, 0x40074612, 0x07481512, 0x10021d56,
	0x00181850, 0x0f0d5019, 0x0629480f, 0xe137ce82, 0xf6100132, 0x2f33e12b, 0x5d5e3338, 0x32e1f610, 0x33113911, 0x50333031, 0x420805e4, 0x2133023e,
	0x23112311, 0x021e1403, 0x23113333, 0xc6e90622, 0x542d2301, 0x64382841, 0xbc01538a, 0x25ddf4b6, 0xdb365a41, 0x01686bfe, 0x4c300ccd, 0x794e476c,
	0xb6fb2a51, 0x5401b001, 0x162e4630, 0x485f6601, 0xe12b075d, 0x2602d905, 0x00004800, 0x18000601, 0x2b1c9774, 0x12000100, 0x120414fe, 0x31001406,
	0x2c08db82, 0x0c171f32, 0x33552d47, 0x33603310, 0x23033380, 0x47161e22, 0x3254171b, 0x1e4f1921, 0x231c1a1a, 0x29005010, 0x29202910, 0x1c0f2903,
	0xbf5c1800, 0xe15d220b, 0x08847c33, 0x32e13222, 0x22052571, 0x18313912, 0x200c7a5d, 0xc85c1811, 0x35232109, 0x10c66518, 0x020e1424, 0x5c18f002,
	0x692809d1, 0x436e5170, 0x9c9cb61d, 0x0dd36518, 0x0ed55c18, 0x65184420, 0xfc2615e1, 0x577b4dbe, 0x6b4c002f, 0x0a032e05, 0x26022106, 0x0000cd01,
	0x76000601, 0x05f166d4, 0x26111227, 0x0c064501, 0x0b256103, 0x08069749, 0x00220033, 0x1731404f, 0x0d1f1617, 0xaf248f24, 0x24400224, 0x48191601,
	0x19235605, 0x0116ef50, 0x16b916a9, 0x1f160f02, 0x03162f16, 0x1c161606, 0x100a5113, 0x1194431c, 0x32e1f626, 0xce105d5d, 0x21079243, 0x8b7c022e,
	0x063b6e05, 0x21070624, 0xfe722115, 0x52022208, 0x35ab1865, 0x928b380f, 0xfedb010e, 0x8a920923, 0x36368351, 0x893f147b, 0xdb9d96d5, 0x6e223e89,
	0x97290522, 0xa4b89aa6, 0x1da21925, 0x23e3821e, 0x03ecff5a, 0x21055f4a, 0xf3830056, 0xe982a020, 0xe5057527, 0x4c000602, 0x210f8200, 0x7518eeff,
	0xff262ded, 0xfebcffff, 0x41850114, 0x82004d21, 0x0041083c, 0x06f2ff10, 0x004a0412, 0x002a001d, 0x0c45406b, 0x25001c46, 0x1cd40a47, 0xa01c9001,
	0x1c24021c, 0x011c0001, 0x0a1c0a1c, 0x04471e14, 0x2c0f2c57, 0x2c3f2c2f, 0x2c7f2c5f, 0x2cef2cbf, 0x2b141407, 0x05644524, 0x500c2529, 0x4f170f1c,
	0x45251611, 0xe126066b, 0x3912e13f, 0xf8555d2f, 0xe1f62706, 0x2f393911, 0x00825d2f, 0x32e11027, 0x3031e110, 0x091b4601, 0x384d2320, 0x34013610,
	0x2323022e, 0x3e323311, 0xec870302, 0x652ecbd4, 0x62fe719f, 0x0f4a4dd9, 0xd9012b2b, 0x40604121, 0x5d38dbd7, 0x0af64643, 0x470e5e4d, 0x02260b04,
	0x0000ae00, 0xef827506, 0x00142a08, 0x40530021, 0x471c0530, 0x130f0f02, 0x57094715, 0x0123ef23, 0x3f012380, 0x23100123, 0x47120101, 0x1b225413,
	0xbf055011, 0x24008201, 0x13501c00, 0x08924c0f, 0x2f21cc82, 0x0803655d, 0x20051e50, 0x08966b11, 0x33112122, 0xb947b982, 0x23112208, 0x24ce8a11,
	0xcf016401, 0x08fa46b6, 0xb631fe2e, 0x41211505, 0xdcd83f61, 0x26445d37, 0x2105c04c, 0xbf473dfe, 0x05c64c05, 0x0127bd8b, 0x00001200, 0x85061204,
	0x683226bb, 0x0b140114, 0x92691800, 0x0e0e2117, 0x0b8d6918, 0x00100f23, 0x8d69180b, 0x8c69180c, 0x3911230e, 0xa918315d, 0xc6430c84, 0x5c032112,
	0x2016b943, 0x8d691802, 0xae00321b, 0xe5030000, 0x26022106, 0x0000d401, 0x76000601, 0x05a74308, 0x26111728, 0x110b0c01, 0x11500307, 0x07b14c07,
	0x02170625, 0x835c0026, 0x3602222b, 0x202b85b1, 0x232b8228, 0x00232d0a, 0x09cb7318, 0x2205c34b, 0x824a0412, 0x592408d7, 0x06d63d40, 0xc706b701,
	0x47060206, 0x07c507b5, 0x760307d5, 0x02078607, 0x075a074a, 0x09070702, 0x55044701, 0x340ad74b, 0x09470005, 0x00050c54, 0x06150950, 0x0f020afb,
	0x3f333f00, 0x096f4b3f, 0x2f391128, 0xe15d5d5d, 0xc24a5d5d, 0x11232e08, 0x01331121, 0xb6f80164, 0xfeb7b3fe, 0x05c24aa0, 0x82051a4a, 0xc70021a6,
	0xbe31e182, 0x0700e306, 0x2c404400, 0x03df5a00, 0x03ff03ef, 0x05cc5003, 0xb0090335, 0x0209d009, 0x09af090f, 0x065a0502, 0x5f040864, 0x82012007,
	0x03072e00, 0x3f001206, 0x5d2f333f, 0x1001e110, 0x206e82f6, 0x260b8211, 0x3031e15d, 0x82331101, 0x1123316f, 0xfdb00e03, 0xb605bac3, 0x2dfe2d01,
	0xb605f0fa, 0x2305c34b, 0x89050a03, 0x30346982, 0x47051c40, 0x00100000, 0x09000002, 0x54034702, 0x20061008, 0x0622ff82, 0xf9544f01, 0x834e8207,
	0x83568358, 0x5d212055, 0x033205ae, 0xb65afe0a, 0x03b6a601, 0x043ffcc1, 0xff3f014a, 0x581800ff, 0x00230e65, 0x61e70043, 0x2b2b0507, 0xb8012605,
	0x31b4acff, 0x410e1e2b, 0x58180aa5, 0x062a0d67, 0x004c4300, 0x01b41500, 0x2d831130, 0x36b49e25, 0x8d2e1130, 0xc358182d, 0x7600230b, 0x5d82a001,
	0x0b401324, 0x5e823701, 0x312b6422, 0x07205b9a, 0x17242d82, 0x13000000, 0x3c202d82, 0x69225e82, 0x5b923630, 0x26022b2c, 0x00003a00, 0x6a000701,
	0x5b823901, 0x02b61927, 0x26053401, 0x23bb8202, 0x3f2bb4ff, 0x876d5f85, 0x21bd8408, 0x3382d905, 0x33855a20, 0x82ac0021, 0x21338361, 0x33861139,
	0x85443021, 0x82338865, 0x18042020, 0x230a2b59, 0x72ff4300, 0x20052141, 0x24c28209, 0xb4a4ffb8, 0x2d59180f, 0x8207201b, 0x824b202f, 0xb4152342,
	0xc4822301, 0x29202f83, 0x080dcb42, 0xd1015225, 0x7902ae03, 0x1d000300, 0xff0200b9, 0x060b40c0, 0x0202480c, 0xb9000005, 0x3f00bd01, 0x112f01e1,
	0x7c2b2f33, 0x52290553, 0xd1015c03, 0x0100a8a8, 0x20358200, 0x2035a807, 0x2835bb07, 0xfefcff02, 0xff4e0331, 0x34a182d3, 0x402a0007, 0x00000418,
	0x05010509, 0xff06efba, 0x02060206, 0x064278ba, 0x2f000124, 0x0282e15d, 0x332f0122, 0x3325b082, 0x21013031, 0x25018435, 0xaefc4e03, 0x03835203,
	0x8b31fe25, 0x82008b8c, 0x172808bd, 0x5001c103, 0x0c00b605, 0x17402500, 0x06010e5f, 0x075f070f, 0x07bf076f, 0x070507cf, 0x0c01980c, 0x0003069c,
	0x2f01e53f, 0x33215082, 0x08fb825d, 0x033e2721, 0x030e3337, 0x0e0e2507, 0x19342e27, 0x1a1d0f89, 0xc1030816, 0x7c7a3616, 0x843d387b, 0x93357c83,
	0x2d4a8255, 0x015f010f, 0x01bf016f, 0x010501cf, 0xc2829c06, 0xa7825583, 0x01215583, 0x20518217, 0x21598223, 0x56824201, 0x19332f33, 0x1b1d0e89,
	0xb6050816, 0x7d793716, 0x843c387a, 0x82568284, 0xfe3f2657, 0x007901f8, 0x2cad82ee, 0x0e00b935, 0x1440c0ff, 0x0c48180a, 0x205a8598, 0x2a5a847f,
	0xb8070601, 0x10b7c0ff, 0x82074815, 0x84a82065, 0x332b29bb, 0xe15d2f33, 0x2530312b, 0x6a226788, 0xd5180e0f, 0x012816f6, 0xc1031900, 0xb6055201,
	0x2b3a6582, 0x0e5f1c40, 0x050f0601, 0x056f055f, 0x05bf057f, 0x05df05cf, 0x00050507, 0xc2880b98, 0x5b82e120, 0x2a08c383, 0x17031e13, 0x27032e23,
	0x1608ee37, 0x890f1d1a, 0x272e3419, 0xb6050e0e, 0x84847c35, 0x7d7a383c, 0x00163779, 0x03170002, 0x84d102c1, 0x1938085b, 0x48406200, 0x90011bbf,
	0x1b0f011b, 0x1b6f1b5f, 0x140f1303, 0x146f145f, 0x14bf147f, 0x14df14cf, 0x19141407, 0x980c0e98, 0x01500100, 0x01700160, 0x01c001b0, 0x010701d0,
	0x2d0da341, 0x139c0c19, 0x3f000306, 0x0132e533, 0xe8845d2f, 0x92852f20, 0x315d5d24, 0xae410130, 0x87212007, 0xa6012108, 0x210bb841, 0xc641b8fd,
	0x0bd14118, 0x002cb79e, 0x60145014, 0xb0147014, 0xd014c014, 0x0f2ab785, 0x6f0e5f0e, 0xcf0ebf0e, 0xc282050e, 0x2407a041, 0x01cf01bf, 0x25c284df,
	0x9c061307, 0xb782000d, 0xb7833220, 0x5d20b685, 0xa841b78a, 0x42212007, 0x02211519, 0x18274248, 0x080b3242, 0x3f000230, 0xfa02f8fe, 0x0c00ee00,
	0x7e001900, 0x1bd05140, 0x1bf01be0, 0xb41ba403, 0x031bc41b, 0x02011b90, 0x1b301b20, 0x1b601b40, 0x1b801b70, 0xc9871306, 0x062bc783, 0x98191414,
	0x0ee00e90, 0x83030ef0, 0x8a0220ce, 0x21c683c8, 0x6b420106, 0x0a402405, 0x85481810, 0x00a822cf, 0x42cf843f, 0x2f210570, 0x23d1865d, 0x5d5d5d5f,
	0x890a7c42, 0x0c8542d3, 0xee21d38d, 0x07514317, 0x8a357d21, 0x006a080a, 0x7b000100, 0x68030000, 0x0b001406, 0x52407c00, 0x0da00d90, 0x0df00de0,
	0x010d6f04, 0x0d300d10, 0x07030d40, 0x0804c006, 0x0be40308, 0xd6020bf4, 0x0b77010b, 0x010b6a01, 0x45010b54, 0x0b26010b, 0x09c00b01, 0x0909010a,
	0x02010236, 0x100300be, 0x0303a003, 0x00010403, 0x0a0bbf05, 0x08c20607, 0x2f000300, 0x3232f63f, 0x0382e132, 0x5d2f012a, 0x11325de1, 0xe6103333,
	0x0283c282, 0x2f331125, 0x8433e633, 0x250136cf, 0x05132313, 0x33030535, 0x68032503, 0xd937b5fe, 0x01c9fe37, 0x31068237, 0xdd034b01, 0x0304fc1f,
	0x1eb41ffc, 0x5ffea101, 0xb586001e, 0xb5827d20, 0x00154e08, 0x007140b0, 0x17a00117, 0x17f017b0, 0x01177f03, 0x17401720, 0x08031750, 0x0b0ec00d,
	0x01050f0f, 0xf4011204, 0x12e60112, 0x01128701, 0x6401127a, 0x12550112, 0x46123601, 0xc0120212, 0x10111410, 0x00031510, 0x0a05be04, 0x0006090a,
	0x08b98205, 0x20051025, 0xa0055005, 0x0605b005, 0x13140508, 0x12bf0c0b, 0xc20d0e11, 0x0109000f, 0x06bf0800, 0xc2070203, 0x872f0005, 0x27dc8ad3,
	0x33715d5e, 0x102f3333, 0xe58cea83, 0x0d827120, 0x33332f24, 0xdd5532e6, 0x15252106, 0xf087eb87, 0x022e1082, 0xfe4c0131, 0x38d937b4, 0x4c01b4fe,
	0x05832f2f, 0x37d93822, 0x2f301383, 0xb41ef001, 0x0187fe1f, 0x1eb41f79, 0x13012201, 0x78220683, 0x148388fe, 0x00ed3208, 0x96000100, 0x6d02e501,
	0x1300f203, 0x24404600, 0x155f152f, 0x157f156f, 0x15ef15cf, 0x100715ff, 0x0a5f0115, 0x0a9f0a6f, 0x0adf0aaf, 0x0a060aef, 0x2f3082d0, 0x40c0ffb8,
	0x480a070c, 0x010f1f00, 0x0105100f, 0x5d25cf82, 0x2f015dc5, 0x2005822b, 0xa694185d, 0x962b0812, 0x32563f24, 0x25405631, 0x31564025, 0x243f5632,
	0x6447ec02, 0x3f1c1c3f, 0x64464764, 0x3f1e1e3f, 0x00030064, 0x05e3ff93, 0x82fa00db, 0x278a0885, 0xa8003900, 0x3b147640, 0xfb023b24, 0x3be4013b,
	0xcb3bbb01, 0x3ba4023b, 0x013b8b01, 0x3b743b64, 0x013b4b02, 0x0b013b34, 0x961e013b, 0x14761466, 0x00141402, 0x32249628, 0x0132fb01, 0xd40132e0,
	0x32bb0132, 0x0132a401, 0x7201328b, 0x32660132, 0x01324b01, 0x02013230, 0x0f013220, 0x32060132, 0x00e0960a, 0x540200f0, 0x02006400, 0x00100000,
	0x07030020, 0x05192d00, 0x0f23379b, 0x33332f00, 0x013232ed, 0x5d5d5e2f, 0x0583ed5d, 0x6c425f20, 0x26068206, 0x3911ed71, 0x88ed5d2f, 0x31712410,
	0x18343730, 0x2409744a, 0x022e2223, 0x210f9c25, 0x95189326, 0x252010b1, 0x13221191, 0xe3182e23, 0x363208bb, 0x35266f49, 0x210f0f21, 0x35252635,
	0x22101022, 0x0f9b2535, 0x00425208, 0xff660007, 0x05f408ec, 0x000900cb, 0x0027001d, 0x003f003b, 0x005d0049, 0x405c4089, 0x4ab554b4, 0xb532b41e,
	0xa028b423, 0x3c30013e, 0x3cb03c40, 0x40283003, 0x3c3e0228, 0x3e3c2828, 0xb4451403, 0x5f3f5f4a, 0x5f5f5f4f, 0x5faf5f7f, 0x0ab40505, 0x09e118b5,
	0xb6472709, 0xb643b759, 0xe118194f, 0x3f231e11, 0x18e1f4e1, 0x290915e1, 0x2f391712, 0x5d5d2f2f, 0x1682105d, 0xe1f4102f, 0x14133031, 0x11323316,
	0x06222310, 0x1a591805, 0x9901200e, 0x23012219, 0x3a1d9901, 0x9c5047fa, 0x0147509c, 0x734a24c7, 0x4c70494f, 0x71492326, 0x4d714b4e, 0x86ac0127,
	0x18c62019, 0x261635e1, 0x51479702, 0x82519b9b, 0x2c208b3a, 0x274c724a, 0xa5a50204, 0x48014a01, 0x4fe118a3, 0x02fc252e, 0x4901a4a5, 0xab3d3784,
	0x763f3f76, 0xaa6c6cab, 0x753e3e75, 0x00ffffaa, 0x01a60385, 0x02b6054a, 0x000a0006, 0x210f8500, 0x0f84b202, 0x00054008, 0x00010000, 0x01730052,
	0x00c703fc, 0xb13c0006, 0xffb80204, 0x091f40c0, 0x0802480c, 0x089f083f, 0x08df08af, 0x08ff08ef, 0x9feb0606, 0x06030103, 0x01030300, 0x2f000105,
	0x3d39122f, 0x1833332f, 0x2309ef9e, 0x01133031, 0x0dde9e18, 0x0bd49e18, 0x3f24658c, 0xeb002840, 0x25069b4c, 0x03200310, 0x698c0302, 0x023f0424,
	0x68930201, 0x2f5d3325, 0x18e15d5d, 0x26086c96, 0xcbfefc01, 0x18eded75, 0x820e5b96, 0xff932cdf, 0x056203e3, 0x002700b6, 0x82d10104, 0x000622e0,
	0x32e78204, 0x312fb509, 0x01311001, 0x00005d5d, 0x00a0fe01, 0x82680200, 0x00032223, 0x33de181d, 0x12012d0c, 0x3f000300, 0x382f013f, 0x33382f32,
	0x2a051d64, 0xd5fc6802, 0x052b039d, 0x824afab6, 0x01380831, 0x1d036a00, 0xc7059302, 0x41001400, 0xe0001740, 0x14011400, 0xc0166016, 0xf016e016,
	0x160f0416, 0xe00a0e01, 0xc0ffb80b, 0x0f0a0e40, 0x000a0b48, 0xe4040ec0, 0xdc0cde11, 0xe12d5682, 0x32cc1a33, 0xe12b2f01, 0x105d5d32, 0x52cb84d6,
	0x29080ab0, 0x36331733, 0x11153233, 0x3f3f1402, 0x152a412d, 0x0910697f, 0x03e58240, 0x51a6011d, 0x57341544, 0x02a6fe41, 0xfa65589d, 0xc18250fe,
	0x00600022, 0x8f82d682, 0x00112a08, 0x02484076, 0x05100210, 0x0b100b00, 0x0b030b20, 0x1330130b, 0x04000e01, 0x0509055a, 0x070107df, 0x10050007,
	0x0305c005, 0x3e028207, 0x08000860, 0x0f0e5f11, 0x6f0e3f0e, 0x0e08030e, 0x48151040, 0x0e080e08, 0x0a5f0d04, 0x83120403, 0x39122aa3, 0x2b2f2f39,
	0xe1105d5e, 0x0fa61811, 0x2f332207, 0x200b845d, 0x20068232, 0x05c3772f, 0x0130312c, 0x11211521, 0x35231123, 0x09831133, 0x013e0382, 0xfe2401c3,
	0xb0b0b3dc, 0xc3fdf002, 0xeafd1602, 0xfe898f01, 0x890601fa, 0xfda42704, 0xb583a4fc, 0xb5824420, 0xc9052332, 0x87003000, 0x0d111040, 0x272b6f15,
	0x23130f23, 0x4b080182, 0xb81b031e, 0x3e40c0ff, 0x1b480e09, 0x3210321b, 0x1e252901, 0x480e0b40, 0x7525141e, 0x10261126, 0x0d2a7529, 0x01266f2a,
	0x0f012ad0, 0x3f2a1f2a, 0xaf2a4f2a, 0x062abf2a, 0x2a262a26, 0x741a1e00, 0x7307181d, 0x3f000700, 0x32e13fe1, 0x8407e351, 0x240484b4, 0x332b2f01,
	0x21bd8333, 0xdf84332b, 0x11331122, 0x2307085c, 0x07171632, 0x2105c056, 0xc4821515, 0xa9180384, 0x35200e0d, 0x3527e482, 0x02023e34, 0x18ae6a9a,
	0x240c11a9, 0x88fe7801, 0x15a91817, 0x17a9180c, 0x89c0310f, 0x3e13899e, 0x102b4059, 0x290b9aa6, 0x15436144, 0x23081082, 0x5f8957dd, 0x00030032,
	0x05ecff96, 0x00b605b6, 0x002a001b, 0x40790035, 0x1c6f3118, 0x6e0f1012, 0x1c181518, 0x2c080182, 0x0105ff24, 0x15124005, 0xffb80548, 0x092c40c0,
	0x0505480e, 0x01370f37, 0x100b4037, 0x6e232b48, 0x0f367c24, 0x12157518, 0x22732b15, 0x30018215, 0x25733524, 0x00182406, 0x00190975, 0x3f3fe13f,
	0x41ea84e1, 0x102a07c7, 0x2b32e1f6, 0x2f33115d, 0xc2412b2b, 0x33112f05, 0x3232e110, 0x3031e110, 0x023e3225, 0xcd6c1537, 0x35233407, 0x15333737,
	0x11231533, 0x14011614, 0x2323020e, 0x77112311, 0x4a620643, 0x054a0806, 0x23240f3b, 0x5017071e, 0x4058353f, 0x419c9c24, 0x34d1d16b, 0x7c348cfe,
	0xb22f98cc, 0x7bbf86fb, 0x1abdfd3a, 0x2e5b8b5d, 0x8139aea4, 0x03080604, 0x22140c8a, 0x01486a46, 0xbd4d52bf, 0x56fe89d3, 0x89034e4c, 0x4d81a85b,
	0xca18c7fd, 0x01320db3, 0xecff3f00, 0xcb054a04, 0x86003900, 0x280712b4, 0xfb831936, 0x094b5108, 0x1919480d, 0x013b103b, 0x1323232c, 0x2e6f0d05,
	0x01286322, 0x133a2828, 0x10246023, 0x602c0824, 0x5f2d052d, 0x8f247f24, 0xff24ef24, 0x2d0f0524, 0x2d2f2d1f, 0x2d9f2d5f, 0x24062dcf, 0x162d242d,
	0x33740037, 0x195f1607, 0x3f00191d, 0xe13fe133, 0x20050642, 0x05d7425d, 0x10331130, 0x011132e1, 0x335d2f33, 0x3232e133, 0x2a421133, 0x09aa7a09,
	0x06071427, 0x14141514, 0x0b555517, 0x2e22232d, 0x35232702, 0x35342633, 0x82353634, 0x033e2208, 0x054f4233, 0x0803d308, 0x435e7645, 0xfeb00112,
	0x02010141, 0x92fe8101, 0x4b95b922, 0x853b3b87, 0x87b6735b, 0x94a41558, 0xa0940202, 0xb8875812, 0x4fa06172, 0x05773350, 0x8f633427, 0x0e0f895b,
	0x13091a0c, 0xaf891629, 0xa21a20b8, 0x87491f1c, 0x178979c1, 0x2e161d1e, 0xca7d8908, 0x312b4e90, 0x002b1f92, 0x8d000400, 0xdb05f8ff, 0x0300c105,
	0x2b001700, 0x86004800, 0x02010a40, 0xb4184639, 0x0200030e, 0x40f0ffb8, 0x9046704a, 0xd046a046, 0x0edf0446, 0x02100001, 0x00000e46, 0x0402460e,
	0x0fb42231, 0x04ef0104, 0x040204ff, 0x00b4404a, 0x31000131, 0x31203110, 0x31f031e0, 0x42310805, 0x3dfd2cfc, 0x270736fc, 0x1dfd13fc, 0x031909fc,
	0x00180106, 0xe13f3f3f, 0x6247e1f4, 0x5d5e2505, 0xde10e171, 0x11230482, 0x822f3917, 0x5d382a00, 0x3311385d, 0x3311e110, 0x06304511, 0x60470120,
	0x0f746a0e, 0x56220121, 0x51080aaa, 0x22232626, 0x33141506, 0x15373632, 0x0a050606, 0x039dd5fc, 0x2d6e012b, 0x3f447050, 0x2c2f516e, 0x3e447150,
	0xfe2f526e, 0x3c261133, 0x253c2a2b, 0x3c251111, 0x263c2b2a, 0x45cbfd11, 0x35345a79, 0x33487d5c, 0x1f212064, 0x5f672255, 0x235a33c2, 0xa8456323,
	0x98fb2905, 0x2d577f53, 0x537f572d, 0x7e080787, 0x233e5633, 0x33563e23, 0x213d5534, 0x01553d21, 0x80522692, 0x52845f5a, 0x6b0f1626, 0x7674140d,
	0x6b1011e5, 0x00001312, 0xff770002, 0x057b03ec, 0x002d00cb, 0x4055003a, 0x23702e32, 0x48141040, 0x05112323, 0x28353c06, 0x1014196e, 0x30112011,
	0x90118011, 0x18110511, 0x14763615, 0x00282811, 0x071e7630, 0x060b7500, 0x00190b06, 0x102f333f, 0x12e13fe1, 0x33332f39, 0x013232e1, 0x82c55d2f,
	0xd6102207, 0x201182c1, 0x0771432b, 0x030e3330, 0x022e2223, 0x06063535, 0x36363507, 0xc5491137, 0x0701090a, 0x021e1411, 0x22233413, 0x1115020e,
	0x6f02033e, 0x1e2e3920, 0x26046403, 0x3a466946, 0x2e30516a, 0x5f343161, 0x68401c2d, 0x3d57364b, 0x7c5c3521, 0x37241147, 0x29206663, 0x4e360917,
	0x16771833, 0x533b5232, 0x25305a83, 0xe7638854, 0x790c1c11, 0x010f1e0e, 0x536c3bee, 0x6f4f2a31, 0x86a66345, 0xd3fe2668, 0x213b5130, 0x1bbc2104,
	0xfe2a4532, 0x624e216a, 0x00040079, 0x070000c7, 0x00b60589, 0x002b0017, 0x003b0037, 0x0e7240ba, 0x005a1501, 0xe12c3939, 0x01001022, 0x9f0100b0,
	0x00300100, 0x00020040, 0x0a220022, 0x0f18e132, 0x2f3a1f3a, 0x3a3a033a, 0x180118ef, 0x3d6f3d67, 0x3dcf3dbf, 0x013d4003, 0x0903080c, 0x3c640a5a,
	0x351de52f, 0x1dcf27e5, 0x1def1ddf, 0x06401d03, 0x270f480b, 0x275f271f, 0x277f276f, 0x060627ef, 0x271d271d, 0x06100316, 0x0b034818, 0x38e53903,
	0xf0ffb80e, 0x2b0d82b6, 0x120a010e, 0x33333f00, 0x3fe0332b, 0x39280482, 0x5e2f2f39, 0x105d2b5d, 0x08c69318, 0x5d5d3229, 0x325de610, 0x5710712f,
	0x0a8208d7, 0x2305ce4c, 0x23213031, 0x0e897718, 0x35032e24, 0x9d423311, 0x08741811, 0x03230809, 0x04152135, 0x87fdcda8, 0x04040608, 0x02cfa605,
	0x04030676, 0x01020301, 0x29e102a4, 0x3f446d4d, 0x832c4d6b, 0x6b3e3c07, 0x42fe2c4e, 0x47515148, 0x48515147, 0x04f00163, 0x414c4dba, 0xe7fc398e,
	0x18fbb605, 0x2409cfd0, 0x8253b9fc, 0x969f1859, 0x717e080c, 0x72717373, 0x1ffd6d6d, 0x02009393, 0xe5022500, 0xb6055005, 0x20000700, 0x5d40a300,
	0x1301c400, 0x11c4100a, 0x06d006c0, 0x6f0306e0, 0x06300106, 0x06500640, 0x01061f03, 0x20010604, 0x0211d011, 0x11110601, 0x03030106, 0x1815191e,
	0xaf179fc4, 0x22170217, 0x222f220f, 0x2203223f, 0x48181540, 0x120f4022, 0xef03cf48, 0x1f030203, 0x0c200909, 0x07094818, 0x1804c803, 0xe0ffb814,
	0x0e820c40, 0x0811142e, 0x12150101, 0x3f000304, 0x2f333333, 0x2b350382, 0x32e11033, 0x33112b33, 0x2b5d2f01, 0xd6105d2b, 0x3232e15d, 0x05dd4332,
	0x4605744c, 0x01340727, 0x35231123, 0x01231521, 0x031e2303, 0x11231115, 0x33131333, 0x343b0682, 0x2337023e, 0x7f680103, 0xc70a02c4, 0x07ba4002,
	0x01010201, 0xbfb4ba7b, 0x82017fb2, 0x06640800, 0x02e502c3, 0xfd6c6c65, 0x1025029b, 0x06181e22, 0xd10249fe, 0x2702d9fd, 0xac012ffd, 0x23231e09,
	0xffdbfd0c, 0x004e00ff, 0x05a60500, 0x010602cd, 0x00000076, 0xff660002, 0x048b04dd, 0x00220048, 0x403b002f, 0x1e4a2321, 0x132f3111, 0x0105104a,
	0x181d1d05, 0x2f2b4e12, 0x2f022f3b, 0x4e29182f, 0x4e180f0c, 0x2409b25e, 0x3911e15d, 0x23cb822f, 0xde1032e1, 0x0ae7c418, 0x3233042b, 0x2115021e,
	0x33031e11, 0x08af8232, 0x030e1764, 0x032e1113, 0x020e2223, 0x79021107, 0x4586c682, 0x76664c2c, 0xc2713f80, 0xc5fc518e, 0x584d4016, 0x5e744a2e,
	0x2448224d, 0xcc8f6e53, 0x5d4d3b13, 0x49573335, 0x5e23183c, 0x636ecc9d, 0x3c5c7ea0, 0xd1934f1d, 0x189cfe83, 0x2015222c, 0x2937573c, 0x2c4d6539,
	0x15018b02, 0x16232a14, 0x172a2113, 0xd582e9fe, 0xff534208, 0x05d305ec, 0x002600b6, 0x0000147b, 0x02170227, 0x0100005e, 0x03400207, 0x00b3fd62,
	0x041f4030, 0x19270203, 0x0111f401, 0xd00111e4, 0x11b00111, 0x0111a001, 0x11011130, 0x0f01592f, 0x5d5d0159, 0x05844111, 0x3f003525, 0x82353535,
	0x84332051, 0x82c92051, 0x86752051, 0x8a8b2051, 0x403c2251, 0x08518228, 0x01194923, 0xd00133f0, 0x33c40133, 0x0133b401, 0x940133a0, 0x33600133,
	0x01333001, 0x33013324, 0x0f017b2f, 0x825a897b, 0x205d8860, 0x825d844f, 0x3d0221af, 0x3d205d98, 0x273f5d82, 0x0127d001, 0xb40127c4, 0x27a00127,
	0x01279401, 0x30012760, 0x27240127, 0x6f2f2701, 0x956f0f01, 0x8871205d, 0x423f215d, 0x20050d41, 0x22bb8a39, 0x82224034, 0x191f3dbb, 0x0109f401,
	0xcb0109eb, 0x09b40109, 0x01099b01, 0x2b01097f, 0x2f090109, 0x510f0151, 0xb385578a, 0x02003408, 0xecff6200, 0xc5053b04, 0x43002b00, 0x21403b00,
	0x00471933, 0x45404557, 0x01450f01, 0x21483f06, 0x3844560c, 0x2c13134f, 0x27501c21, 0x07502c04, 0x483f0016, 0x2f290501, 0xf61001e1, 0x5d5ee132,
	0x0594685d, 0x0e14013a, 0x2e222304, 0x3e343502, 0x16323304, 0x35343617, 0x22232634, 0x3507020e, 0x2605da60, 0x043e3201, 0x82032e37, 0x047d0812,
	0x021e1415, 0x41203b04, 0x6db18a65, 0x22538c6a, 0x73513217, 0x935b6299, 0x898b022d, 0x4143441f, 0x4b43181b, 0xa67d254f, 0x9efd2a63, 0x43515e35,
	0x0a0a2535, 0x2a493b29, 0x3a4f663e, 0x2d151225, 0x6aa60346, 0x8dbcd4e1, 0x8f6e4252, 0x8d8d3c4c, 0x4f3d6583, 0x0b2a1345, 0x160cc9be, 0x0cae131f,
	0x590a1117, 0x73fcc496, 0x7a684d2c, 0x45284385, 0x51301e33, 0x2f6e6f68, 0x24405632, 0x08f38200, 0x0000292a, 0xb6056204, 0x0e000500, 0x11405800,
	0x09090102, 0x605b0e05, 0xb0047004, 0x0404f004, 0xc0ffb804, 0x0a062740, 0x10040448, 0x11556118, 0x055b0d37, 0x12055f0d, 0x110a2009, 0x03010948,
	0x2b333f00, 0x2f01e13f, 0x051f4ae1, 0x4de15d21, 0x3b0805dd, 0x01373031, 0x21150133, 0x27262601, 0x03070606, 0xbe012921, 0xfbc001bb, 0x207702c7,
	0x2a110f2d, 0xa602fa1d, 0xfa450571, 0x9a036fb9, 0x4b4ba861, 0x04fd5ba8, 0xc7000100, 0x270514fe, 0x072e9982, 0x11403700, 0x65075a00, 0x30090009,
	0xdd684009, 0x83092005, 0x140f2f97, 0x5a034818, 0x02086404, 0x0403055f, 0xe6681b00, 0x5d2b2b08, 0x31e1f610, 0x21110130, 0x03822311, 0xfd6d0430,
	0x6004ba14, 0xfc0614fe, 0xa20704f9, 0x5d825ef8, 0x14fe4a24, 0x5d82e304, 0x5c000b2f, 0x5b080b40, 0x02010670, 0x00060206, 0x2757820a, 0x480e09b7,
	0x070d0a0a, 0xe02b6382, 0x180f0940, 0x00030948, 0x840d0c00, 0x18132571, 0x02020848, 0x07c05e18, 0xe1207182, 0x07c05e18, 0x33112b32, 0x33332f18,
	0x3311322b, 0x39122b2f, 0x5d2f2f39, 0x13208282, 0x0ac15e18, 0x70024a3d, 0x4804a0fd, 0x3a02bcfc, 0x9b03b0fd, 0x037314fe, 0x722b0392, 0xfc09fda4,
	0x8200a49d, 0x66240893, 0x02048702, 0x03001d03, 0x1f403200, 0x00960502, 0x01008b01, 0x56010079, 0x004b0100, 0x01003801, 0x09010014, 0x00242782,
	0x00b301ad, 0x0ba0ad18, 0x31ce102e, 0x21351330, 0x9c036615, 0x96968702, 0x25304b83, 0xc504f2ff, 0x0800a006, 0x13402c00, 0x05060001, 0x0739de83,
	0x03081008, 0x0404ae03, 0x2f000007, 0xe12f392f, 0x382f2f01, 0x19393933, 0x08ba822f, 0x33331122, 0x23053031, 0x21352301, 0x02330113, 0xebfe8573,
	0xe52901b4, 0x0e920002, 0xfd8f0a03, 0x00ac0569, 0x79089982, 0x05910177, 0x000e0431, 0x00330023, 0x40760043, 0x0117494f, 0xf0010d48, 0x452f0145,
	0x3a02455f, 0x6a274a27, 0x372a0327, 0x081a3701, 0x773f0427, 0x022f972f, 0x1220aa2f, 0x12021230, 0x3f013f78, 0x2a3400ab, 0x243a17ae, 0x273708ae,
	0x0517041a, 0x0d100d00, 0x0d0d0702, 0x01179f1f, 0x17011720, 0x5d5d2f00, 0x5e2f3333, 0x1712335d, 0x1032e139, 0x2f0132e1, 0x5d2f5de1, 0x0f825de1,
	0x00825d20, 0x5d30312b, 0x0e14015d, 0x26222302, 0x06f84827, 0x023e3426, 0x17163233, 0x08055b43, 0x3632058b, 0x23262637, 0x15020e22, 0x01021e14,
	0x16070622, 0x3e323316, 0x2e343502, 0x2b310502, 0x5d426d4d, 0x461d419b, 0x412b534e, 0x2b2d4f6e, 0x55436f4e, 0x441d3e9e, 0x4230574f, 0xfc2b4d6d,
	0x346c3f7b, 0x28456b31, 0x15182c40, 0x7c02412c, 0x33376b3f, 0x4027446c, 0x2e19182d, 0x3fcd0240, 0x69345772, 0x384f3073, 0x75522c1e, 0x56734148,
	0x30706b31, 0x2d1f384e, 0x57f97552, 0x1d5a5e61, 0x24264433, 0x011e3242, 0x5d61576a, 0x080d825c, 0x43262744, 0x01001c31, 0x14fe1000, 0x14060603,
	0x37002300, 0x25102340, 0x140225d0, 0x04060104, 0xac0d0401, 0x0901151b, 0x10150115, 0x021e201e, 0x12ae191e, 0x00ae071c, 0xe13f0000, 0x2f01e13f,
	0x5d5d335d, 0xf68432e1, 0xe2820120, 0xd9861520, 0x72181120, 0x3b080f93, 0x02023e34, 0x164b2283, 0x33243d12, 0x32102742, 0x244a7c59, 0x3e14174b,
	0x2a453323, 0x79572f12, 0x09091406, 0x27110993, 0xfa2d5441, 0x56865ed7, 0x93080b29, 0x40251008, 0x27053054, 0x282a0e82, 0x66000200, 0x02047b01,
	0xa1822504, 0x00474308, 0x412e404b, 0x4910491d, 0x0a102e01, 0x0a020a20, 0x31ad2940, 0xad1743af, 0x1caf1f0a, 0x0ddfad05, 0x0dff0def, 0x0f400d03,
	0x0d0d4812, 0x432ead3b, 0x333f00b3, 0x2b2f33e1, 0xf533e15d, 0xf510e132, 0xba8433e1, 0x32ce1026, 0x2e013031, 0x22051d47, 0x18333635, 0x20105aba,
	0x271b9a03, 0x37251202, 0x1c16292d, 0x1a76ba18, 0x219a2f20, 0x1d97612e, 0x01433732, 0x0d1610bc, 0x2c211305, 0x1398ba18, 0x10ae0123, 0x281c8215,
	0xa21a2c20, 0x190e056d, 0x200d8514, 0x082a852d, 0x00010074, 0x04a40066, 0x00040502, 0x40a60013, 0x0e0d0a11, 0x12091211, 0x04030012, 0x08130807,
	0xffb81309, 0x094f40f0, 0x13091310, 0x0b100609, 0x01154015, 0x0106c601, 0xa90106bb, 0x06860106, 0x01067b01, 0x42010668, 0x06390106, 0x08090601,
	0xad040d08, 0x12121307, 0x0ead0011, 0x032f031f, 0x01037f02, 0x03100300, 0x03030602, 0x0107f00a, 0x076f070f, 0xfd420702, 0x715d2f08, 0x3232e133,
	0xe1103311, 0x33113332, 0xbb472f01, 0x5d5d2205, 0x05a86333, 0x2f2f3929, 0x33113838, 0x82c4877d, 0x33012200, 0x27078410, 0x23013031, 0x21132135,
	0x17260382, 0x21153307, 0x03822103, 0x01272a08, 0x3e01f85e, 0x0149fe79, 0x698a85fc, 0x7bc1fefa, 0x00feba01, 0xba018981, 0x95040196, 0xe03b1b01,
	0x96fcfe95, 0x0039eafe, 0x08ef8202, 0x02040021, 0x0600dd04, 0x52000a00, 0x00093240, 0x010c400c, 0x01014008, 0x05010201, 0x6f060305, 0x18007f00,
	0x8433b5e7, 0x303135b4, 0x01350125, 0x35020915, 0x02041521, 0x9c0364fc, 0xdf0221fd, 0xee210783, 0xbee71801, 0x71fe2408, 0x92009696, 0x85052089,
	0x01062a89, 0x01040506, 0x6f000301, 0x43e71806, 0x21898635, 0x8a830113, 0x82150121, 0x0266268a, 0x031efde2, 0x2c87839c, 0x42018f01, 0xfea26a01,
	0x58fe661f, 0x088785ee, 0x00006d39, 0xc3053f04, 0x09000500, 0x36405d00, 0x05090102, 0x07090704, 0x00ac0603, 0x010bff0b, 0x0b500b40, 0x0bb00b80,
	0x0f050bc0, 0x020b2f0b, 0x0310aa08, 0x08030301, 0x82080600, 0x07022201, 0x302c82ad, 0x2f0002ad, 0x12e13fe1, 0x2f3d3939, 0x1133112f, 0x05ec5433,
	0x105d5d23, 0x211483de, 0x12823311, 0x31333108, 0x23010130, 0x09330101, 0xfe3f0403, 0x3efe4c3c, 0x014cc201, 0xfecffe0c, 0x023101cf, 0x021ffde1,
	0xfde402df, 0xfe00021e, 0x00fefd00, 0x1d00ffff, 0x2d089782, 0x001f0617, 0x00490026, 0x00070100, 0x00a2024c, 0x40240000, 0xaf010218, 0x1d50011d,
	0x011d1f01, 0x1d011d0f, 0x40012faf, 0x2f0f012f, 0xff495d01, 0x35352106, 0x06203d86, 0x4f203d8a, 0x22223d84, 0x3c8e1740, 0x40012126, 0x210f0121,
	0x003f3c89, 0x04cf0001, 0x06cd03d9, 0x00150017, 0x0029403f, 0x02172017, 0x17cf17af, 0x70173002, 0x820f0217, 0x0000291f, 0x020a300a, 0x7f0a0a06,
	0x40360c82, 0x00480906, 0x058e1000, 0x33e12f00, 0x335d2b2f, 0x5d5e2f01, 0x0a5a2f33, 0x05bd4506, 0x4b332721, 0x56820649, 0x5d314308, 0x8c67648d,
	0xaa052958, 0x4c321b05, 0x36492c35, 0x17060622, 0x2951764e, 0x50775027, 0x10294939, 0x35482b13, 0xbcff0100, 0x640114fe, 0x13004a04, 0x13402300,
	0x15201510, 0x0c470f02, 0x540c0303, 0xcc180d14, 0x5c1808af, 0x312207c1, 0x4d181330, 0x112a0a21, 0x0e141133, 0x3f304202, 0xcc181a17, 0x8418099d,
	0x2c080a7d, 0x18fbf404, 0x2f577b4d, 0x01010000, 0x02cd0487, 0x00140679, 0x4019000d, 0x3f85050c, 0x0c060106, 0x05920c00, 0xe53f0000, 0xdd332f01,
	0x906e185d, 0x87013a0c, 0x0e111209, 0x1f06b404, 0x60162e29, 0x4d1ee704, 0x14215051, 0x56564e19, 0x264b8220, 0x023bfe6f, 0x8283ff75, 0x4016284b,
	0x00000c09, 0x83068505, 0x822f2049, 0x32e12548, 0x3031332f, 0x0a817518, 0x1a0b6f32, 0xb2041318, 0x362c1f06, 0x56fe621d, 0x53544c19, 0x4d234882,
	0x83215657, 0x047d2695, 0x068302d9, 0x22498221, 0x850a4017, 0x92052149, 0x93830782, 0x0e384a86, 0x35230703, 0x3337033e, 0x1a0c8302, 0xb2041218,
	0x372d1f05, 0x0606621c, 0x15214a84, 0x08938218, 0x0200212b, 0x39022500, 0xc7057f02, 0x1d000b00, 0x19402a00, 0x1f0ce106, 0x1f7f1f4f, 0x06401f02,
	0xe100480a, 0x1be50916, 0x11e503de, 0x068b46df, 0x5d2be124, 0xf282de10, 0x4e141321, 0x045909e9, 0xb816240d, 0x824e5147, 0x0f925800, 0x049a952b,
	0x9fa1a502, 0x9f9fa5a7, 0x065058a5, 0xa96c6c26, 0x00ec3c74, 0x0c3c8582, 0x8f024a02, 0x0a00bc05, 0x46001500, 0x02092a40, 0x03070be1, 0x175f1703,
	0x1702178f, 0x25088983, 0x0105e115, 0x0f09e504, 0x2f0b1f0b, 0x0b08030b, 0xe50f020b, 0xdd02dc07, 0xe13f3f00, 0x5e2f3912, 0x32e1335d, 0x9d822f01,
	0x08062651, 0x0130315f, 0x35231523, 0x33013521, 0x35213311, 0x0e373634, 0x02070703, 0xfe8f7d8f, 0x8d790189, 0x03f4fe7d, 0x16140503, 0x039b0918,
	0x6fc0c00a, 0xcdfd4302, 0x31632ac3, 0x282a250b, 0x0000f00f, 0x023b0001, 0x05660237, 0x002400b6, 0x2117404a, 0x1d1e2222, 0x14200b1d, 0x4f2605e1,
	0x02267f26, 0x35938326, 0xc0ffb80b, 0x18121140, 0xe5170b48, 0x21110000, 0x11dc1ee5, 0x294108e5, 0x29868205, 0x2b2f01e1, 0xde105d2b, 0x938433e1,
	0x82331121, 0x1e322693, 0x06141502, 0xe8461823, 0x224c080c, 0x2707020e, 0x21152113, 0x01363607, 0x4f6b3d42, 0x3fa1a62d, 0x3c1a2c79, 0x55183b3d,
	0x0d595f5f, 0x0e252725, 0xba012143, 0x1412befe, 0x236d0439, 0x8c416544, 0x8d1a1c9d, 0x0a131b12, 0x554d584c, 0x02070604, 0x7ba8012b, 0x000603d7,
	0x3408d141, 0x001d00d5, 0x4038002d, 0x210a1020, 0x4f2f00e1, 0x022f7f2f, 0x2eb5832f, 0x0ae12915, 0x1915e424, 0xde0f1019, 0x8405e51e, 0x393323ae,
	0xae82332f, 0x8432e121, 0x391221af, 0x7753a982, 0x1737280a, 0x3307030e, 0x82333636, 0x320522bd, 0x06c74c36, 0x14157508, 0x7f02021e, 0x446f4e2a,
	0x2f526e40, 0x6eb27e45, 0x607f4f2d, 0x1b0b0f40, 0x5a364a63, 0xdbfe2440, 0x474d5444, 0x192d3f27, 0x033d2d19, 0x506f4166, 0x80582d2d, 0x8fb36e53,
	0x1b6d276d, 0x3b604f40, 0x4825312b, 0x565cf769, 0x29195a52, 0x492c1e37, 0x01001d35, 0x4a022f00, 0xb6056402, 0x38000600, 0xff0000b9, 0x001f40f0,
	0xe1010200, 0x084f0805, 0x0802087f, 0xd030c183, 0xf002e002, 0x02020302, 0x00dc03e5, 0x3f3f00dd, 0x5d20ba82, 0x1135b984, 0x31382f39, 0x21011330,
	0x01152135, 0xfe40018d, 0xfe350262, 0x085182bf, 0x647bf125, 0x0300f8fc, 0x39023100, 0xc7057102, 0x34002500, 0x77004400, 0xe1382240, 0x05e14221,
	0x1c323d0a, 0x82210504, 0x2c172a01, 0x4f460fe1, 0x02467f46, 0x086a8346, 0x17e12638, 0x40c0ffb8, 0x48181527, 0x3d1c0a17, 0x5b324b32, 0x9b326b32,
	0x0532ab32, 0xb6351432, 0xd63dc63d, 0x003d033d, 0xdf14e529, 0xde00e535, 0x3fe13f00, 0x5d3911e1, 0x03841211, 0x2f013924, 0x9884e12b, 0x3939122b,
	0x17122f2f, 0x10e11039, 0x070642e1, 0x07020e22, 0x18053874, 0x2607e174, 0x3435032e, 0x4303023e, 0x2e2e0659, 0x06272702, 0x06221306, 0x021e1415,
	0x1b823e17, 0x0126aa08, 0x465e3452, 0x3427162a, 0x303e221e, 0x694d2a1c, 0x19968b3f, 0x1b1f382a, 0x2b13232e, 0x4a625f48, 0x164b4a48, 0x0f213727,
	0x38944241, 0x2d20123f, 0x202c181a, 0xc7054113, 0x3854371b, 0x28323e25, 0x372d1311, 0x5d392a45, 0x73832442, 0x2b38452a, 0x352b1411, 0x5338253e,
	0x68fd1c37, 0x3b46463b, 0x2027301e, 0x4d22060f, 0x3637e801, 0x1d242a1b, 0x231c0c0d, 0x37361c2c, 0x21000200, 0x7b023902, 0x2500c905, 0x3b003500,
	0x11312240, 0x001c09e0, 0x7f374f37, 0x40370237, 0x29480a06, 0xe42c1ce1, 0x05171711, 0xde21e526, 0x0657420c, 0x4212e121, 0x2b250658, 0x11de105d,
	0x14431839, 0x098b4508, 0x4b233721, 0x1e220bbf, 0xef832502, 0x0908ab4b, 0x217b021d, 0x1981a25a, 0x36151540, 0x406c5319, 0x0d09031d, 0x263d3024,
	0x2444603c, 0x436c4b29, 0x30547241, 0x5644cbfe, 0x3f264c4a, 0x2a15182d, 0x6042043e, 0x085b93bb, 0x0a0d7d07, 0x3d725735, 0x111b2412, 0x41664725,
	0x2d516f42, 0xac93612f, 0x584c585e, 0x1a332919, 0x243b4824, 0x00160000, 0x0781fe54, 0x00ee05c1, 0x000b0005, 0x00170011, 0x001f001b, 0x00270023,
	0x002f002b, 0x00370033, 0x003f003b, 0x00470043, 0x005f0053, 0x0078006f, 0x00900081, 0x345940e4, 0x381c202c, 0x7a515718, 0x67746f70, 0x7e826464,
	0xc051706b, 0x0351d051, 0x6b6b6f51, 0x5d03516f, 0x5f8c4f89, 0x8c8c028c, 0x09242844, 0x4b505d17, 0x4b024b60, 0x313d414b, 0x422a0c00, 0x32263e46,
	0x6f8f8f86, 0x70706779, 0x6f7a607a, 0x70484854, 0x026f806f, 0x6f016f61, 0x40c0ffb8, 0x480c0725, 0x5a606f6f, 0x788a4e4e, 0x602f601f, 0x606f603f,
	0x01606004, 0x12181c2c, 0x2135390c, 0x01010f07, 0x2f000107, 0x53335d5e, 0x33230673, 0x832f3912, 0x332f280c, 0x2b2f3311, 0x83335d5d, 0x44112008,
	0x2f200673, 0x03830d82, 0x822f0121, 0x3333212d, 0x08882882, 0x2006d75e, 0x82468511, 0x843e8206, 0x30313c2d, 0x15211113, 0x35251523, 0x35231121,
	0x15331101, 0x35211533, 0x11333533, 0x82213521, 0x15212209, 0x24078201, 0x33112301, 0x87038211, 0x2007830b, 0x20178633, 0x83178335, 0x26222b03,
	0x37363435, 0x14151632, 0x39442706, 0x15062506, 0x33011614, 0x07221284, 0x19831615, 0x13232323, 0x221c8533, 0x86151523, 0x35052309, 0x0a831616,
	0x23086382, 0x22230614, 0xc02f0154, 0x3001ce05, 0x6f00f96d, 0xc30e05c0, 0x0149fd6d, 0x01e1fb11, 0x01f2fe0e, 0x6db7040e, 0xfb310082, 0xfc1001c2,
	0x026f6f30, 0x771001c0, 0xa8fa1101, 0x2900826f, 0x6d6dfe06, 0x877f99fa, 0x03837f87, 0x3f483e08, 0x4245483f, 0xac9f0142, 0x2d2d706d, 0x5e6d3338,
	0x2e427bcf, 0x3b302924, 0x2625314a, 0x100e0134, 0x31251420, 0x3d5f687d, 0x3001be04, 0x6fc1c16f, 0xf9c1d0fe, 0xc22f0102, 0xfec26d6d, 0x326482d1,
	0x6ffe066d, 0x01a8fa6f, 0x0102020e, 0x6d3bfa0f, 0x82a6016d, 0x824a207f, 0x6f4e0869, 0x10012ffc, 0xfd0f0179, 0xfe100168, 0x918e9f8a, 0x919c019b,
	0x67689f8e, 0x66665e5e, 0x01675e5e, 0x315343ea, 0x0b040844, 0x59513a44, 0x20226201, 0x9ae31d22, 0x2a20252b, 0x050366fc, 0x92013224, 0x645e72fe,
	0x54000300, 0xaa07c1fe, 0x09821406, 0x00233e08, 0x4050002f, 0x23230428, 0x302a2024, 0x032a402a, 0x244f2a2a, 0x02242401, 0x020b0b1c, 0x23021515,
	0x012d3023, 0x27272d2d, 0x10101903, 0x2f190003, 0x332f1833, 0x332f3311, 0x2f335d2f, 0x830e8401, 0x8203820d, 0x825d200f, 0x31333706, 0x05030930,
	0x37363435, 0x34353636, 0x2223022e, 0x1707020e, 0x8d413636, 0x06062306, 0x7d441515, 0x26720807, 0x03062223, 0xfcac03fe, 0x0356fc54, 0x634c21eb,
	0x835b314d, 0x575a2b51, 0x44522252, 0x3e3f387e, 0x4a455227, 0x4446471b, 0x46444747, 0xfc140647, 0x0357fc56, 0x2c2ffba9, 0x834c3a3e, 0x4a6b4559,
	0x231b1027, 0x2e22b214, 0x44312f3a, 0x50793541, 0x3eedfe3b, 0x403e4949, 0xff004949, 0xfebcffff, 0x06550214, 0x02260221, 0x00000037, 0xfe4c0107,
	0x178200bb, 0x69170021, 0x0223053f, 0x82070206, 0x02560817, 0xecff0a00, 0x2b06b204, 0x4f000c00, 0x47407500, 0x10430d4d, 0x083b003e, 0x1a434347,
	0x004f473b, 0x10100110, 0x0151a051, 0x3301513f, 0x101a0047, 0x031a201a, 0x2950221a, 0x4e4f4f3e, 0x29004e00, 0x29302910, 0x29502940, 0x4e290605,
	0x05384e29, 0x38014850, 0xb3531550, 0x58122005, 0x11290502, 0x32e11033, 0x2f01e110, 0x06ad6c5d, 0x11e13324, 0x03822f39, 0x82113921, 0x30312521,
	0x23032e01, 0x27058345, 0x15161605, 0x06060214, 0x7f06d553, 0x3627082d, 0x1e323336, 0x50141502, 0x3326056c, 0x34111232, 0xcb452726, 0x08188305,
	0x1533172a, 0x390d6a03, 0x4c305b4d, 0xab6a2e56, 0x02023c01, 0x83c48140, 0x2256926f, 0x1f0a0b0a, 0x1036181f, 0x36642525, 0x132c4532, 0x60080f82,
	0x3a4e3015, 0x0202a4a4, 0x4396f2ae, 0x597f5127, 0x4b75a168, 0xd1038f12, 0x3d74aa6c, 0x69384858, 0x168a3352, 0xfe9f1f3a, 0x3773c9ee, 0x28457d5f,
	0x184b595d, 0x0a0f212d, 0x1c1a117f, 0x23284432, 0x2d615d56, 0x1f364a2a, 0x30013201, 0x02143e17, 0x519a784b, 0x2e527043, 0x8bdf9c54, 0x01000089,
	0x08008200, 0x0548047d, 0x002200c3, 0xaf1b408f, 0x0224ef24, 0x0c094024, 0x21ab2248, 0x01219801, 0x1b012140, 0x210f0121, 0xffb82101, 0x214440f0,
	0x1b1f0021, 0x0d0f010d, 0x12200d01, 0x0d9f4816, 0x7d020daf, 0x0d6b010d, 0x010d5a01, 0x2b010d4f, 0x020d3b0d, 0x5a1e0d0d, 0x1f871f77, 0x4f031f97,
	0x1f00011f, 0x07021f10, 0x1f001d1f, 0x121f0321, 0x00040a11, 0x3f3fc13f, 0x01393912, 0x5d5d5e2f, 0x4e32e15d, 0x2b2706c6, 0x39117171, 0x82382f33,
	0x5d5d2a13, 0x315d2b33, 0x033e0130, 0x05f35c37, 0x0806e150, 0x050e0759, 0x11231107, 0x1d023301, 0x3c3f3d19, 0x352f1618, 0x2b232940, 0x0d200d11,
	0x23201c0b, 0x32280d13, 0x13323636, 0xcb42febb, 0xa84bdb02, 0x282c89a0, 0x0914273d, 0x05039108, 0x232a1707, 0x806e5518, 0xfd3c8585, 0x032f02e3,
	0x00020087, 0x06ecff12, 0x004a0460, 0x823c001c, 0x476e08fb, 0x012f6719, 0x2cd5472f, 0x012cb701, 0x9a012ca9, 0x2c03012c, 0x4837032c, 0x12bb12ab,
	0x3e121202, 0x54013e14, 0x843e643e, 0xb43ea43e, 0x3e40053e, 0x3e300201, 0x013e0f01, 0x03004822, 0x03300310, 0x03500340, 0xb8030605, 0x1540c0ff,
	0x03481512, 0x2d2d001a, 0x080e1d27, 0x320f0b50, 0x00165027, 0x323f0016, 0xe13f32e1, 0x39123232, 0xfe82122f, 0x5d5e2b31, 0x5f5d5de1, 0x11715d5d,
	0xe15d2f33, 0x822f3911, 0x825d200b, 0x31393213, 0x26220530, 0x023e3435, 0x37352137, 0x1e231521, 0x06244a03, 0x06062323, 0x235c1803, 0x3335230a,
	0x1b471415, 0x278b0808, 0xc3b62902, 0x1a2b2012, 0x0586ebfe, 0x2618f3c8, 0xb5c40f1b, 0x0b1f8b6a, 0x16ba8b1f, 0x1d121f28, 0x2e2d4b36, 0xb3162c44,
	0x4b2d5262, 0x190f1d36, 0xea141524, 0x7e7d39f3, 0x504a387b, 0x7e7b389a, 0xeaf3397d, 0x575b5b57, 0x7636c403, 0x623a7a79, 0x29214e83, 0xb0396248,
	0x218a82b0, 0x3a62834e, 0x3676797a, 0x00ffff00, 0x060000c7, 0x0275072f, 0x00300026, 0x00070100, 0x01790176, 0x40130054, 0x0527010b, 0x1a4b0126,
	0x6f0f0920, 0xae200a19, 0x87222d82, 0x2d822106, 0x2d865020, 0x2d843f82, 0x26113a28, 0x332d7a01, 0x2d8a2b16, 0xd5fd0026, 0xbc05dd04, 0x24202d82,
	0x022f2d83, 0x001b015b, 0xb70d0000, 0x1f010203, 0x83070415, 0x83352029, 0xfd5e2683, 0x049c03d5, 0x2027825e, 0x21278544, 0x2786bc00, 0x183d1421,
	0x2508f5ac, 0xd3feffff, 0x7918ecff, 0x02230bef, 0x8240fe5c, 0x3f300827, 0x2d0203b6, 0x35020303, 0xb2c0ffb8, 0xb8480f09, 0x1a4021ff, 0x0a0a3535,
	0xb0000125, 0x00800100, 0x01007f01, 0x40010050, 0x001f0100, 0x5d110001, 0x35270084, 0x352b2b35, 0x823f0035, 0x02003203, 0xd5fd7300, 0x83ff3702,
	0x1f001300, 0x28403a00, 0x517f1814, 0x1d200810, 0x1005008c, 0x40053005, 0xa0055005, 0x0705f005, 0x8c170506, 0xe12f000f, 0xe15d5ed4, 0xe15d2f01,
	0x204b7f18, 0x37022008, 0x31543d23, 0x203b5232, 0x32523b20, 0x233e5430, 0x32314074, 0x3138393f, 0x33aefe40, 0x181d3851, 0x8212bb82, 0x04932899,
	0x05d90268, 0x820d00c7, 0x40422b99, 0x0e301509, 0x0e020e40, 0xec821a11, 0x1c403108, 0x1a481009, 0x010d2b1a, 0x0d140d04, 0x05060d02, 0x3f0c050c,
	0x5f114f11, 0x1d110311, 0x5dcc2f00, 0x2f2f3939, 0x5dcd2f01, 0x2b2f325d, 0x395dcd33, 0x2f058643, 0x030e1533, 0x34252307, 0x06153736, 0x1e141506,
	0x3d06b44c, 0x190bb001, 0xcf081618, 0x3e383012, 0xe3fe521f, 0x393c7a78, 0x321f251f, 0x04453a2f, 0x7d181e89, 0x7838094a, 0x4c1f734e, 0x13182e16,
	0x1c1a1012, 0x00462725, 0x1d00ffff, 0xb9060000, 0x08076f50, 0x0027003a, 0x00a20249, 0x00070100, 0x0044054c, 0x40380000, 0x8f020326, 0x39700139,
	0x01394001, 0x0f01392f, 0x01390139, 0xb0011fe0, 0xaf1f011f, 0x4b70014b, 0x014b4001, 0x5d014b0f, 0x2005c450, 0x05a34135, 0x2107c950, 0x5992a806,
	0x59844f20, 0x25403622, 0x3d295899, 0x013d7001, 0x0f013d40, 0x08588f3d, 0x0002004a, 0x06ecff7d, 0x00140625, 0x00340020, 0x1b2c404b, 0x20091306,
	0x2b01015b, 0x3667095b, 0xbf0136c0, 0x36700136, 0x5f362f01, 0x5b210236, 0x06356613, 0x5f300e1b, 0x26041820, 0x00130e5f, 0xce3fe13f, 0x393912e1,
	0xe1f61001, 0x5d20b182, 0x33220682, 0x5146e12f, 0x0e172306, 0x4b460703, 0x26262708, 0x12343502, 0xbc563636, 0x01352405, 0x56021e14, 0x232e07a9,
	0x06020e22, 0x280c0e17, 0x2b3f5a3f, 0x7918512d, 0x280808a0, 0xec9ea4ef, 0x19312951, 0x34f2fb08, 0x7272a56b, 0x32326ba5, 0x7272a46a, 0x06346ca6,
	0x703c1614, 0x59184c61, 0xfeaa7fd8, 0xaa7918eb, 0x666f2b0b, 0x5d4a350c, 0x89c9fc34, 0xee1899db, 0x71260f75, 0xf404ecff, 0xe982f204, 0x002c2d08,
	0x172c404a, 0x1e19194a, 0x48270a12, 0x00100000, 0x00000702, 0x902e102e, 0xb02ea02e, 0x4821042e, 0x122d560a, 0x502a051e, 0x24100f17, 0x2006fa7a,
	0x24e988c6, 0x5e2f3311, 0x820d835d, 0x0d434eec, 0x3320de86, 0xf57afb85, 0x0423080b, 0xb27d432d, 0x7fae676f, 0xb37c4347, 0x3fa9646f, 0x0619342e,
	0x2d100fc6, 0x2039563f, 0x8900fd24, 0x83879a9a, 0x02660803, 0x91d58927, 0xd5914c4c, 0x91d38889, 0x0d44474b, 0x335d4b37, 0x5e784a17, 0x9e411443,
	0xd3d3d15e, 0xd0d0d0d1, 0x00010000, 0x06ecffb8, 0x0014064e, 0x40510024, 0x085b0632, 0x015a2308, 0xb0010e9f, 0x0eaf010e, 0x260e0e01, 0x26802670,
	0x5f0326f0, 0x26000126, 0x1b022610, 0x2564185a, 0x240d0d01, 0x1e031906, 0xbb41135f, 0x33332305, 0xbb41332f, 0x24d38206, 0x33715d5d, 0x23d285e1,
	0x35033e15, 0x1120c484, 0x2207204f, 0x45113311, 0x42080594, 0xdd041137, 0x0a203e34, 0x320f0fc6, 0x425b8055, 0x8088c985, 0xbb4485c4, 0x8059b0ac,
	0x05012852, 0x3206c4b6, 0x1638644e, 0x4a698247, 0x7291fd0f, 0x4d5290c4, 0x037ac78e, 0xb048fcae, 0x886236bf, 0x82b60351, 0xa44708bd, 0x7905ecff,
	0x2700f204, 0x33405400, 0x21214a1f, 0x1a471701, 0x10292727, 0x29800129, 0x29e029a0, 0x01296f03, 0x29202900, 0x07032930, 0x540c470f, 0x26261a28,
	0x0f0d181f, 0x07025012, 0x00150016, 0xe1333f3f, 0x86c6333f, 0x5d5e21c0, 0x22056f46, 0x8432e133, 0x272121c0, 0x8807704d, 0x113522b7, 0x34d58933,
	0x0a1b7503, 0x5c524519, 0x5c8a5b30, 0x6f6ab62f, 0x1d436e51, 0x24d58ab6, 0x293f2b93, 0xd1d81814, 0x827b200f, 0x38653cd8, 0x6d884717, 0xb0fc0748,
	0xfc010000, 0xfed9048f, 0x00210619, 0x4016000d, 0x1806000a, 0x3a1b9be7, 0x237919fe, 0x10404d51, 0x2e2b10db, 0xd9041630, 0x5158531c, 0x5023151b,
	0x821d4c51, 0x48fd2149, 0xd1204982, 0x06254987, 0x0f800500, 0xc7c3180c, 0x48fd2517, 0x2b2e3015, 0x3f2b4882, 0x7922524d, 0x4c1df404, 0x18235051,
	0x2c080583, 0xd90446fc, 0xe30514ff, 0x38001b00, 0x19841840, 0x42fe374c, 0x474c4f28, 0x0e302d1f, 0x35210568, 0x51292e4a, 0x2d1d454d, 0x0d830f2e,
	0xdb04492b, 0x35232b23, 0x45613c3e, 0x19841826, 0xfd01280a, 0xfeb80404, 0x828f0679, 0x4026288d, 0x08080512, 0x8215000d, 0x0f123405, 0x02191f19,
	0x00068019, 0x5dcc1a2f, 0x33113932, 0x83cc2f01, 0x054d4306, 0x23070725, 0x4b033e27, 0x580805ba, 0x36350706, 0x16323336, 0x2d1b79fe, 0x710a223c,
	0x2a3c250e, 0x32241517, 0x10341c1d, 0x85293210, 0x27d30585, 0x071b293a, 0x1006b06f, 0x18182118, 0x03071320, 0x05036c03, 0x0100005b, 0x98fe31fd,
	0x7dff06fe, 0x0f000d00, 0x008708b5, 0x0003910b, 0x2f01e52f, 0x053031e1, 0x050e4c34, 0x020e2008, 0xfd262223, 0x2b2d3e31, 0x271d113f, 0xf63e2d15,
	0x3c37373c, 0x0e1c2b1d, 0x00ffff37, 0x180000c7, 0x2a2c51bd, 0x050000c9, 0x02730710, 0x82b20126, 0x0007347e, 0x01420043, 0xb4150052, 0x26051801,
	0xa3ffb801, 0x18181eb4, 0x82099558, 0xff712a5f, 0x06e103ec, 0x00260221, 0x242f8248, 0x94430006, 0x202d8200, 0x33b31802, 0x00ae2416, 0x833b0400,
	0xd201212d, 0xca202d85, 0x01222d83, 0x5b85110c, 0x180c1221, 0x080ca149, 0xecff7d5f, 0xc9055e07, 0x71004500, 0x04144840, 0xc5255a39, 0x36960136,
	0x890236a6, 0x36360136, 0x0c5b411d, 0x47004767, 0x00024710, 0x50472047, 0xd0477047, 0x0647e047, 0x1d5b2e07, 0x37374666, 0x5f290033, 0x07262603,
	0x20140422, 0x14480e09, 0x115f333c, 0x3f001318, 0x3232e133, 0x33333f2b, 0x26088211, 0x012f3912, 0x18e1f610, 0x21090e54, 0x15825d5d, 0x30313923,
	0x21521801, 0x27262611, 0x23060623, 0x0b074622, 0x2907436a, 0x33021e14, 0x11373632, 0xbe5c1133, 0x6877080a, 0x4c2a5e3c, 0x77518f3b, 0x3f407db7,
	0x6f88c681, 0x4b0249aa, 0xc6886ea8, 0x7d403f81, 0x8f5177b7, 0x5f294c3b, 0x5071453c, 0x8a5c2e2b, 0x2e76395c, 0x3b762ebb, 0x2e5c8b5c, 0x0571502c,
	0x9c202e25, 0xb8632c2a, 0xaaa6f8fe, 0x77d2dffe, 0x32303032, 0x2101d277, 0x0801a6aa, 0x2a2c63b8, 0x462e209c, 0x8d88cf8a, 0x2459a4e5, 0xfebd0126,
	0x59242643, 0x888de5a4, 0x4c468acf, 0x053a053b, 0x004a04f4, 0x40e7002c, 0x01106509, 0x22f922c9, 0xffb82102, 0x100ab3f0, 0x07832c48, 0x841b1221,
	0x19403a07, 0x00480f0a, 0x481b0a10, 0x0e220d26, 0x2c152221, 0x0f560600, 0x0f020f66, 0x0825820e, 0x1f484049, 0x0e6f010e, 0x0e9f0e7f, 0x59040edf,
	0x0e4f010e, 0x01157401, 0x2401156b, 0x02153415, 0x06340624, 0x06740644, 0x0e050694, 0x0e151506, 0x1b010306, 0x101c0047, 0x1c07021c, 0x2e102e1c,
	0x2e302e20, 0x2ee02ed0, 0x83010205, 0x011e2a4c, 0x1d154026, 0x0c202648, 0x086d8214, 0x1b031022, 0x150f010e, 0x36062606, 0x22060206, 0x3f001500,
	0x115d3232, 0x33333f33, 0x2b2b3917, 0x33382f01, 0x2f2a0d82, 0x12e15d5e, 0x2f3d3917, 0x8e4c182f, 0x715d2106, 0x33261884, 0x11333311, 0x29823912,
	0x5d2b2b36, 0x215d3031, 0x16133301, 0x3e331716, 0x03133703, 0x031e1333, 0x98080a83, 0x02143335, 0x23070602, 0x35262603, 0x0307030e, 0x89fe7701,
	0x261ce0bc, 0x15070709, 0x770f1d1a, 0x0cc9bca2, 0x05181e1f, 0x41725a07, 0x5c25b719, 0x77c0759a, 0x06010d0c, 0x98040a09, 0x56fd4a04, 0x16339d57,
	0x2045413a, 0xcf010c01, 0x6321b0fd, 0x67195c67, 0x98ffe2d0, 0xfedffea3, 0x017ffcf5, 0x03352054, 0x1d1b1301, 0x00aafe0a, 0x14000200, 0xbc040000,
	0x16001406, 0x9b002100, 0x00130a40, 0x150c5a17, 0x0c100615, 0x40c0ffb8, 0x48271a0d, 0x02010c20, 0x0ca00c90, 0x23118302, 0x481813b3, 0x44081984,
	0x480e0b40, 0x1b0e0c0c, 0x2367065b, 0x23302300, 0x23602350, 0xe0052380, 0x239f0123, 0x01235001, 0x005f210e, 0x105f0d16, 0x00b01013, 0x01008901,
	0x0f01004f, 0x00070110, 0x11100010, 0x0c601700, 0xe13f0012, 0x05234f3f, 0xdb6a5d20, 0xe1102306, 0x0b822f01, 0xf6107137, 0x2f3911e1, 0x5f5d2b2b,
	0x12332b71, 0xe1102f39, 0x30313232, 0x07064f01, 0x1121232a, 0x11213521, 0x15211133, 0x32200582, 0x08056a50, 0x0a022338, 0x7ecf9896, 0xc27e3c37,
	0xfe96fe86, 0xba3c01c4, 0x87fe7901, 0x2ea4aea0, 0x815d8b5b, 0x71424e03, 0x9e615798, 0x60043d70, 0xfe1001a4, 0x40fca4f0, 0x61468884, 0x01411b3c,
	0x056d3206, 0x00140027, 0x40810021, 0x16021309, 0x0c001047, 0x2ce68401, 0x481a0d47, 0x000c000c, 0x06471c0e, 0x3fe88257, 0x70022310, 0xc0239023,
	0x0423e023, 0x0250150e, 0x10500d01, 0x020f1013, 0x0202021f, 0x481e0c40, 0x0f34e382, 0x02101f10, 0x02100207, 0x01117f10, 0x11011130, 0x150c5016,
	0xdb82ed82, 0x7122ef85, 0x16505d2b, 0x20ed8309, 0x22178312, 0x85335d2b, 0x30de82e7, 0x14151632, 0x2123020e, 0x33352311, 0x21153335, 0x68451801,
	0xe3023209, 0x1501d5fe, 0x652fcdd3, 0x39fe719f, 0x01b6eeee, 0x2c10822b, 0x435e3704, 0x60412126, 0xfeb00340, 0xcb4618d7, 0xdddd2108, 0x0e754518,
	0xffc73708, 0x05ec06ec, 0x002d00cb, 0x082f4058, 0x221b5b05, 0x07111107, 0x2a1e0322, 0x1d212f2a, 0x2e641e5a, 0x275f002b, 0x1c081b04, 0x0f05225f,
	0x21080121, 0x1e031f21, 0x67180d12, 0x3f230828, 0x6c5e2f39, 0x3f320579, 0x100133e1, 0x1132e1f6, 0x122f7d33, 0x2f183917, 0xbf822f2f, 0x2c09836c,
	0x3233031e, 0x0e153736, 0x26222303, 0x95441826, 0x1716270c, 0x05262607, 0x67185f6d, 0x23080933, 0x5971ac75, 0x4e274ea0, 0x9e3a6156, 0x05529deb,
	0xbabab0fe, 0x630e5601, 0x6c95e9a7, 0x3f4e4fc4, 0x41270595, 0x0e3b6718, 0xb8644a08, 0xfd9f0301, 0xfdb60556, 0xa7eb8f98, 0x9c2a2c5c, 0x00002e20,
	0xffae0001, 0x047105ec, 0x0029005e, 0x20394064, 0x4f05481d, 0x1f0c010c, 0x27081f0c, 0x0b2b1414, 0x54084707, 0x15511a2a, 0x05201011, 0x0c1d5006,
	0x0bb90ba9, 0x06f45902, 0x0b0b0629, 0x15080f09, 0x4f265123, 0x3f20055b, 0xec86eb84, 0x88e13321, 0x123322ec, 0x20ed8339, 0x22ed845d, 0x8f2e2205,
	0x822e20db, 0x070621f1, 0x3c0b7a6d, 0xa9615404, 0xfe074f81, 0x01b6b6f1, 0x81550c13, 0x954e5ea5, 0x38173632, 0x8c193b3c, 0xd8421891, 0x82523b07,
	0x147c3536, 0x87c17b3a, 0x4a0417fe, 0xb58039fe, 0x19223472, 0x0f130a9a, 0x42189709, 0x002308de, 0x82000200, 0x05490800, 0x00b6052f, 0x0018000b,
	0x084940ae, 0x06d80106, 0x070206e8, 0x07d70107, 0xa60207e7, 0x019b0107, 0xa7007701, 0x0a0d0200, 0x04030c09, 0x13130607, 0x0100a708, 0x05010100,
	0x01080009, 0x08100800, 0x08700820, 0x08c00880, 0x080b8206, 0x901a084f, 0x021aa01a, 0xc0ffb81a, 0x18150f40, 0x011a8f48, 0x0f011a40, 0x0408011a,
	0xf0ffb805, 0x0b051340, 0x10135f03, 0x13480e0a, 0x04060c0c, 0x06120900, 0x3f3f0003, 0x39123333, 0xe12b392f, 0x382f0132, 0x5d5d5e33, 0x115d2b5d,
	0x5d382f33, 0x25178371, 0x39115d33, 0x22832f3d, 0x39123923, 0x2d1c8239, 0x715d715d, 0x23213031, 0x23012311, 0x03823301, 0x27239508, 0x032e2721,
	0x07030e27, 0x7fa6ec02, 0x02c5fefe, 0x3b02bb39, 0x7afefec7, 0x352301e8, 0x11161c12, 0x15110907, 0xaa021119, 0xb60556fd, 0xaa024afa, 0x4c308fa4,
	0x25254143, 0x2d494341, 0x00020000, 0x0400000a, 0x004a045a, 0x0017000b, 0x393840cf, 0x79025902, 0x04028902, 0x022b021b, 0x0105b502, 0x05a60596,
	0x01058702, 0x03190309, 0x16080602, 0x12090208, 0x06021219, 0x02111611, 0x02031207, 0xb6090811, 0xb8000100, 0x1b40f8ff, 0xb9480f0a, 0x080b010b,
	0x00360782, 0x010cb40b, 0x05050c0c, 0x010a0606, 0xb8010210, 0x12b3c0ff, 0x07834815, 0x18403708, 0x01480b07, 0x19c01901, 0xaf0219e0, 0x19500119,
	0x1f190f01, 0x0a090219, 0x40f0ffb8, 0x08040a0f, 0x110b0c50, 0x0f0b0111, 0x1501060a, 0x33333f00, 0x2f39123f, 0x23413912, 0x825d2005, 0x33112600,
	0x332b2b2f, 0x2e158238, 0x3d391233, 0x33335d2f, 0x5d2b5d2b, 0x82393912, 0x825e2002, 0x2902831f, 0x5d5d3031, 0x03230101, 0x01821123, 0x23032b08,
	0x030e1701, 0x032e3307, 0x01a60227, 0x60bbbcb4, 0xbdba60a2, 0x0571b401, 0x0d25231b, 0x23250ef0, 0x4a04041b, 0xe901b6fb, 0x038317fe, 0x794a043f,
	0x5e605519, 0x605f2222, 0x00001954, 0x00c70002, 0x05290700, 0x001300b6, 0x40bf0020, 0x081a421b, 0x050e0627, 0x14111215, 0x263e8203, 0x0f010005,
	0x83051b0e, 0x5d6208c3, 0xcb010180, 0x1b84011b, 0x7b1b2b01, 0x050f021b, 0x052f051f, 0x05cf057f, 0x05ff05df, 0x01050807, 0x05011b1b, 0x10101103,
	0x10101000, 0x10b01070, 0x100510f0, 0x22302210, 0x22c02250, 0x22e022d0, 0x5a080c05, 0x13216409, 0x0d5f0306, 0x1009201b, 0x14141b48, 0x0104090e,
	0x0e0a1211, 0x333f0003, 0x3742333f, 0xe1333606, 0x10013232, 0x5d32e1f6, 0x5d2f3311, 0x39173338, 0x2f182f3d, 0x0504412f, 0x33113824, 0x01831133,
	0x39391223, 0x82028211, 0x5d5d2106, 0x22083e42, 0x82231121, 0x1321211c, 0x2f0d4642, 0x81a5e704, 0x01c4fdfe, 0xba7ffe08, 0xf1c101ba, 0x2a054d42,
	0x2301e979, 0x151c1335, 0x42080811, 0x5142074d, 0x98fd2305, 0x55426802, 0xae3c0813, 0x08060000, 0x13004a04, 0xeb001f00, 0x05a53140, 0x96058601,
	0x05770205, 0x16090601, 0x02190209, 0x02490229, 0x02790269, 0x01020b05, 0x1902031a, 0x12091408, 0x110a130b, 0xc60e470d, 0x28064e42, 0x480f0a17,
	0x130113c9, 0x29078208, 0x14c41300, 0x05141401, 0x25420605, 0x2f133205, 0xaf0a3f0a, 0x060a030a, 0x0e01060a, 0x01022054, 0x0c624210, 0x072c3d08,
	0x0101480b, 0x0121d021, 0x600121bf, 0x90217021, 0x214f0321, 0x01210001, 0x08040b08, 0x13141250, 0x0f021919, 0x090e0f13, 0x00150206, 0x3333333f,
	0x3912333f, 0x3339122f, 0x013232e1, 0x31053e41, 0x2b2f3311, 0x1033382b, 0x393911e6, 0x385d2f2f, 0x6d421133, 0xe110240b, 0x41121132, 0x11200554,
	0x23059b43, 0x30315d5d, 0x200a7142, 0x07604113, 0x79421720, 0x54042106, 0x28087942, 0xb6e9fec3, 0xb55401b6, 0x167f4270, 0x28058342, 0xc70139fe,
	0x60541979, 0x0987425f, 0x00142408, 0x056a0500, 0x002300b6, 0x40c00026, 0x01228611, 0x59011a86, 0x02128912, 0x0c091025, 0xffb82648, 0x822c40f0,
	0x25520808, 0x24060b0a, 0x1b5a1a24, 0x0a000726, 0x0a200a10, 0x071b0a03, 0x030a1b07, 0x11101200, 0xd0021120, 0x11800111, 0x11021190, 0x40c0ffb8,
	0x480a073b, 0x1f281111, 0x28f00128, 0xdf28cf01, 0x28400228, 0x28702850, 0x3f280f03, 0x23070228, 0x611c1900, 0x05190b24, 0x002d0a19, 0x5f26070a,
	0x121b0308, 0x3f001200, 0x073d5532, 0x715d5e2b, 0x32e13333, 0x5e332f01, 0x2000825d, 0x05e75a71, 0x5a337121, 0x240808c1, 0x3d39e110, 0x1133332f,
	0x5d2b2b33, 0x5d30315d, 0x033e1333, 0x21350137, 0x031e0115, 0x03231317, 0x2323032e, 0x08018211, 0x020e2259, 0x01010307, 0x187b1421, 0x5f7c5436,
	0x490490fe, 0x806185fe, 0x7a183756, 0x26147bbe, 0x183d4f36, 0x4f3d18bb, 0x7b142636, 0x4a01eb01, 0xc5016ffd, 0x3a628855, 0x8be70106, 0x0619fe8b,
	0x56896238, 0xc1013bfe, 0x17395f48, 0xb80248fd, 0x485f3917, 0x5a033ffe, 0x4400b801, 0xe53506ef, 0x23004a04, 0xc7002600, 0x1a760d40, 0x1a961a86,
	0x07102503, 0x053d410c, 0x08821820, 0x0112093c, 0x0b012306, 0x1a242406, 0x0a251b46, 0x1ba70726, 0xffb80a01, 0x161040c0, 0x48414819, 0x11202308,
	0xd6441101, 0x28078306, 0x0b073f40, 0x28111148, 0x06434110, 0x28602e08, 0x1f022890, 0x02284f28, 0x070a0023, 0x19085026, 0x2416521c, 0x24362426,
	0x240424a6, 0x1f060f0b, 0x5f064f06, 0x06070406, 0x1b0f0806, 0x05034b12, 0x18483f20, 0xe15d2905, 0x32e11032, 0x332f0132, 0x20074841, 0x0747412b,
	0x115d2b25, 0x41331133, 0x5d26064a, 0x5d2b2b5d, 0x48413031, 0x1353081d, 0x167b0a21, 0x5367422c, 0xcf03cefe, 0x6853c9fe, 0x7b172c43, 0x24147bba,
	0x04354430, 0x463504a6, 0x7a142530, 0xfefcb401, 0x3d54010a, 0x09314d65, 0x69696401, 0x31089cfe, 0xfe3d674c, 0x365001ac, 0xfd112b48, 0x110a02f6,
	0xfe36482b, 0x018302b0, 0x4500002d, 0x24080511, 0x00b60589, 0x002b0028, 0x861540ca, 0x1759011f, 0x10021789, 0x1f29290b, 0x102a205a, 0x2b480c09,
	0x40f0ffb8, 0x3c088233, 0x0c2b0f2a, 0x0f100f00, 0x07030f20, 0x20200c0f, 0x16030f0c, 0xc000b028, 0x000f0200, 0x084b821f, 0x1707004e, 0x16101600,
	0x80167002, 0x0316c016, 0xc0ffb816, 0x0a073440, 0x2d161648, 0x9f012de0, 0x022dbf2d, 0x2f012d40, 0x060a012d, 0x2c64075a, 0x5f2b0c0f, 0x21051e0d,
	0x0f102961, 0x0b08010b, 0x030d080b, 0x03201707, 0x3f001200, 0x333f3217, 0x21054341, 0x434132e1, 0xf6102305, 0x344632e1, 0x05564707, 0x425d5d21,
	0x5e270693, 0x1133115d, 0x412b2b33, 0x3126084d, 0x36132130, 0xb9433736, 0x1a9a4206, 0x7b330237, 0xfe1c2913, 0x02baba7b, 0x0495fea4, 0x6185fe4a,
	0x18375580, 0x069f427b, 0x19ba1923, 0x0c9f423c, 0x2e734422, 0x21056549, 0xa342dd01, 0x00ae3822, 0x04980600, 0x0028004a, 0x40cf002b, 0x861f760d,
	0x031f961f, 0x4107102a, 0x2c200653, 0x28080882, 0x10011709, 0x1f29290b, 0x0f2a2046, 0x20a70c2b, 0x0c200f01, 0x030f200c, 0x2f001f16, 0x00ff0200,
	0x07000001, 0x01162017, 0x06a24216, 0x3a080783, 0x0b073f40, 0x2d161648, 0xb0012dcf, 0x2d9f012d, 0x012d6001, 0x00012d4f, 0x022d302d, 0x0747060a,
	0x0c0f2c54, 0x1e0d502b, 0xa6522105, 0x10290129, 0x0b1f0b0f, 0x0b0b0702, 0x820f0d08, 0x0003224b, 0x0b5f4115, 0x60415d20, 0x5d5d2d0f, 0x2b2f3311,
	0x1233712b, 0x715d2f39, 0x4208f543, 0x2b2209ac, 0x60415d2b, 0x21133a26, 0x107bbc01, 0xedfe131d, 0x0b02b6b6, 0xce03d5fe, 0x6853c9fe, 0x7b172d43,
	0x09b742bb, 0x24314524, 0xb7427b14, 0x4b2a2206, 0x05ef4920, 0x425e0121, 0x8f0820bb, 0xfe390001, 0x06ec0346, 0x007600d5, 0x2127409f, 0x480e0918,
	0x51596259, 0x51474d4d, 0x6c675b3b, 0x35446751, 0x14511467, 0x44355167, 0x5b2e2405, 0x05786772, 0xffb8245a, 0x143640c0, 0x5d244818, 0x568f4d52,
	0x56af569f, 0x07405603, 0x5656480b, 0x60346c47, 0x0f01354f, 0x0235af35, 0x29353508, 0x03625143, 0x03476140, 0x1f5f0a15, 0x006029fb, 0xe13f0013,
	0x3f33e13f, 0x123317e1, 0x5d5e2f39, 0x1139e171, 0x5d2b2f33, 0x2f01e133, 0xf610e12b, 0x2105e34e, 0x00822f18, 0x39121128, 0x3311e110, 0x03832f33,
	0x00303125, 0x5c22052b, 0x3e2707af, 0x1e323302, 0x6b151702, 0x23200586, 0x6d085077, 0x2322052e, 0x8f563523, 0x07062b09, 0x37363627, 0x3527032e,
	0x6b6d1633, 0x17162105, 0x6207ac5b, 0x5f1805cb, 0x2d08073c, 0x5a47e101, 0x240e1434, 0x61412f3d, 0x2b325153, 0x0c233142, 0x4d361f08, 0x4a473135,
	0x8868465c, 0x6631204f, 0x80596c9d, 0x67392651, 0x6b185891, 0x80080dbc, 0x1867a63b, 0x14323637, 0x36613379, 0x4b433b1a, 0x0e2f1f2a, 0x1611220b,
	0x142e3030, 0x2b557e52, 0x4b7d5b33, 0x325e8a57, 0x14c48343, 0x18292012, 0x0e1a2416, 0x07040404, 0xb6070f0a, 0x0c101207, 0x29020303, 0x3c376048,
	0x26264662, 0x47446948, 0x971d3f65, 0x3e644827, 0x1e3a5336, 0x307d3643, 0x411e114b, 0x1b173a3f, 0x24386122, 0x09233846, 0x07057705, 0x21382917,
	0x765c3f0d, 0x58774a45, 0x2e6c1839, 0x0080080a, 0xfe170001, 0x05520373, 0x00700052, 0x407140b7, 0x480e0918, 0x6c626868, 0x6c030c03, 0x16114658,
	0x5fe0116c, 0x11525f01, 0x11336c33, 0x055f526c, 0x1c474d43, 0x72c07257, 0x72e072d0, 0x01727f03, 0x0f017230, 0x26070172, 0x0c404346, 0x16434811,
	0x89505116, 0x02529952, 0x0801520f, 0x48625252, 0x00520768, 0x48141040, 0x0c074000, 0x6c5e0048, 0x505b0300, 0x3410620c, 0xfb3e502b, 0x16215048,
	0x3806e241, 0x3317e133, 0xe12b2b2f, 0x39121133, 0x5d5d5e2f, 0x2f3d39e1, 0x2b2f1801, 0x210b82e1, 0xea415d5d, 0x415d200c, 0x356e10eb, 0x0672640a,
	0x2007a641, 0x0c054223, 0x04421620, 0x8b6d1815, 0x23262109, 0x4205bf52, 0x02300a02, 0x0e2f1fcf, 0x1511210b, 0x132d2e2e, 0x233f5937, 0x0b045e18,
	0x594b5308, 0x220e0f2f, 0x63322c3a, 0x4221535d, 0x22090d47, 0x20132c28, 0x396f6455, 0x18407058, 0x6e905622, 0x2c4c6437, 0x61818a85, 0x2748643d,
	0x81476c73, 0x6b393f4b, 0x30311741, 0x3379122c, 0x3a1a3662, 0x52054b43, 0x05770509, 0x33261507, 0x45310e1f, 0x5e183558, 0x3a080836, 0x74443d5b,
	0x1a0e3156, 0x23161726, 0x04030d18, 0x97131603, 0x060a0f0a, 0x2e030303, 0x2f295647, 0x132a4659, 0x5e33452b, 0x2712995b, 0x4d4d2d40, 0x1c932226,
	0x3b1c0822, 0x41153237, 0xff3907fa, 0x006800ff, 0x05ba0500, 0x010602b6, 0xff000075, 0xfea400ff, 0x06710514, 0x080f8212, 0x00009547, 0x7d000300,
	0x7105ecff, 0x1300cd05, 0x29001e00, 0x32404f00, 0x005b1925, 0x2bd02b67, 0x012bcf01, 0x3f012b80, 0x022b6f2b, 0x0a5b1a24, 0x601a2a66, 0x0f01244f,
	0xdf24af24, 0x24080324, 0x5f1f1424, 0x5f14040f, 0x05a54305, 0xa0431220, 0x05524b05, 0x5d5d5d22, 0x20072574, 0x0efc5302, 0x85181620, 0x2e240edd,
	0x51710503, 0x3e0afa59, 0x51a0ec9a, 0x9e6a87fd, 0xfc06396b, 0x6b3a069a, 0x9c696d9e, 0x03083d6c, 0x693b0864, 0x59dd029b, 0x6b370ef5, 0xfdebfec5,
	0xc2864707, 0x86c27a7a, 0x439a0447, 0x7575b880, 0x834380b8, 0xff7126d9, 0x042d04ec, 0x22d9825e, 0x8221001a, 0x333008d9, 0x0048171f, 0x23402357,
	0x23e023d0, 0x01230f03, 0x0a48181e, 0x50182256, 0xa9011eef, 0x021eb91e, 0x1e1f1e0f, 0x06031e2f, 0x1b141e1e, 0x14100f50, 0x2006fe59, 0x21da84e1,
	0x814f5d5d, 0x21d98905, 0x4b44020e, 0x021e2f09, 0x37363201, 0x13161621, 0x21070622, 0xf4592626, 0xae67340d, 0x23fe477f, 0xfd0a888d, 0x8c8c09be,
	0x020e8889, 0x598a0d3e, 0x4b250def, 0xd4fdd391, 0x290082b2, 0xa4a24403, 0x0000a2a4, 0x00820001, 0x02052208, 0x1c00c305, 0x29405a00, 0x0d0b0607,
	0x010dfb01, 0x90080d0d, 0x0219d019, 0x001e1919, 0x1eb0011e, 0x08b48501, 0x5f1e4f22, 0x061e7f1e, 0xb8080907, 0x0c40f0ff, 0x16600008, 0x03080904,
	0x1207060d, 0x33333f00, 0xe13f333f, 0x2c06264f, 0x2f331171, 0x3d39125d, 0x33715d2f, 0x062d5133, 0x0123012e, 0x16160133, 0x37363617, 0x33033e13,
	0x08058371, 0x2496043c, 0x12242a35, 0xfecdd7fe, 0x2701c519, 0x0e112e1d, 0x1f8d1a2a, 0x4b674c3d, 0x171a4423, 0x252d0535, 0xfb426748, 0xfcb605e9,
	0x4faf5b61, 0x0261bc4e, 0x629c7100, 0x97080d2b, 0xbf860d09, 0x040e0433, 0x001f0052, 0x1e00b96d, 0x1640f8ff, 0x1f480e0a, 0x08048308, 0x20071e2b,
	0x0748110d, 0x16e00007, 0xffb81601, 0x071a40e0, 0x1616480a, 0xcf21bf21, 0x0321ef21, 0x0f012150, 0x4f212f21, 0x01070321, 0x30d08400, 0x1f071e00,
	0x134f1a15, 0x0f00010f, 0x3f323f00, 0x86d482e1, 0x825d20d0, 0x842b20d0, 0x332b27d1, 0x312b2b33, 0xc7541130, 0x08cc8a07, 0x06222342, 0xbc230307,
	0x1f200bc9, 0x0406051a, 0x09191814, 0x43351956, 0x221a3c58, 0x12260b11, 0xe0183a2f, 0xfd4a04f3, 0x6e6a21a2, 0x5f191961, 0x0121676c, 0x42755e40,
	0x87050518, 0x58500503, 0xffffdffc, 0x25058f41, 0x26027307, 0xde828002, 0x76030738, 0x5201b804, 0x02b61900, 0x26051d01, 0xffb80102, 0x1d31b482,
	0xd35f1908, 0x352b2305, 0x33850035, 0x060e0423, 0x20338221, 0x20338681, 0x83478250, 0x11202133, 0x94253384, 0x002034b4, 0x08338916, 0x00030045,
	0x0914fe7d, 0x00cd055a, 0x00270013, 0x40a1004a, 0x1e5b000a, 0x2f2f4a38, 0xb8282937, 0x2340f0ff, 0x00402828, 0x02401040, 0x1f0140f0, 0x3f402f40,
	0x1e000340, 0x1e401e01, 0x37360a40, 0xe037d010, 0x4a370237, 0x2f080506, 0x3737480b, 0x014c0f4c, 0x4c1f4c0f, 0x4c4f4c2f, 0x4cbf4c7f, 0x4cef4cdf,
	0x5b140708, 0x384b660a, 0x284a4a2f, 0x1b3d5044, 0x230f2836, 0x19040f5f, 0x2607ca43, 0xe13f333f, 0x18113911, 0x4c07256d, 0x3826058e, 0x393912c1,
	0x554b2f2f, 0x280d8306, 0x33332f3d, 0x3031e110, 0x05346401, 0x230ae057, 0x14051216, 0x200de65d, 0x09934125, 0x0e013324, 0x20692303, 0x3748080a,
	0x964c1f05, 0xe09891dd, 0x93474793, 0xdd9099e1, 0x23fc4c95, 0x6796612f, 0x2e609667, 0x6794602e, 0x2f619768, 0xd7bd4304, 0x13191d0d, 0x17040604,
	0xc70b1d1b, 0x1d4efebc, 0x50745640, 0x151b4c34, 0x46302340, 0x390f2534, 0x20141c44, 0x0e0e5eab, 0xfde39608, 0x5858289b, 0x56192253, 0x02215e61,
	0x5127fb63, 0x0b315a81, 0x07059106, 0x29402c17, 0xffff00a0, 0x14fe7100, 0x5e044e08, 0x52002600, 0x07010000, 0x6f045c00, 0x11000000, 0xb80202b1,
	0x20b41404, 0x25000a2f, 0x00352b01, 0x02000035, 0x83ff7d00, 0x3106c305, 0x3f001f00, 0x33405200, 0x67005b30, 0xc441b441, 0x41900241, 0x41300201,
	0x20024180, 0x4066105b, 0x0b011819, 0x08040118, 0x07020814, 0x5f3b3538, 0x0315181b, 0x085f2528, 0x00120b05, 0xe133333f, 0x2b048432, 0x5d5d5e32,
	0xf610015d, 0x5d5f5de1, 0x2706dc77, 0x07020e14, 0x22230606, 0x2d077065, 0x33363637, 0x1e171632, 0x1e140503, 0x555f1702, 0x2e342308, 0x26852702,
	0x030e9508, 0x8949c305, 0x4a0e7cc5, 0x0d483b37, 0x4587c781, 0x81c78745, 0x373b480d, 0xc57b0e4a, 0x7ffb4a89, 0x537f572d, 0x31354311, 0x80521145,
	0x572d2d57, 0x46105280, 0x11433531, 0x2d577f53, 0xfc95dd02, 0x3f177dc0, 0x163f3636, 0x96fec07d, 0x7bbffb96, 0x33313f17, 0xbf7d173d, 0xc07496fb,
	0x30156292, 0x152e2826, 0x74c09262, 0x6292bf73, 0x29293216, 0x91611630, 0x020000bf, 0x91ff7100, 0xb604a804, 0x37001f00, 0x2cb55400, 0x39570048,
	0xc0ffb839, 0x48140eb3, 0x40290783, 0x480c0924, 0x56104820, 0x0b0d4138, 0x352f322f, 0x15021b50, 0x2326290f, 0x0b050850, 0x050e4116, 0x240e0f41,
	0xf6102b2b, 0x06215ce1, 0x20160d41, 0x060c4116, 0x35363624, 0x0b412634, 0x06480806, 0x39a80406, 0x095f996b, 0x3b3a383c, 0x6e995d08, 0x9a6c393d,
	0x3a3b0862, 0x5b093d37, 0xfc3c6d98, 0x0b7b6f85, 0x39323439, 0x6e6d790c, 0x32390c78, 0x7b0b3934, 0x7627026f, 0x125a8ebf, 0x382d2e39, 0xc08e5a12,
	0x8dbf7577, 0xe8080d82, 0x123a2a29, 0x75bc8d5b, 0x2c1fcdac, 0x1f2a2020, 0xc8a9abcc, 0x20202b20, 0x00c81f2d, 0x7d000300, 0x3507ecff, 0x45003d08,
	0x6d005b00, 0x9240da00, 0x04241437, 0x24140414, 0x5b411c03, 0x006f670c, 0x026f106f, 0x6f206f00, 0x6f806f50, 0x6fa06f90, 0x6fe06fd0, 0x1c5b2d08,
	0x68636e66, 0x685c4747, 0x50524051, 0x03526052, 0x005f5252, 0x20681068, 0x90688068, 0x68070568, 0x4d014de0, 0x56cf56bf, 0xef525602, 0x47460146,
	0x01524f47, 0x6b605252, 0x6bd06bc0, 0x6b046be0, 0x5f7f5f6f, 0x5fef5faf, 0x015f1004, 0x5f3c325f, 0x377f1411, 0x3702378f, 0x480a0740, 0x11173737,
	0x03032513, 0x215f0028, 0x3f000407, 0x3332e133, 0x333f3311, 0x5d2b2f33, 0x32e11033, 0xcc5d5d2f, 0x712f325d, 0x5dcd1033, 0xcd5ddd10, 0x5e2f015d,
	0x2c1d825d, 0xcd10cd5d, 0x39112f32, 0x5de1f610, 0x0a7a4971, 0x5b331121, 0xe24716e0, 0x5b17200e, 0x3e220cdf, 0xfc723702, 0x34353e05, 0x1503022e,
	0x022e2223, 0x15062223, 0x34352315, 0x1e323336, 0x14053302, 0x36350706, 0x841e8336, 0x05162212, 0x0e025c3f, 0x45a26725, 0x5c67a047, 0x2a291601,
	0x17424e56, 0x564e4217, 0x06045c2a, 0x5610033d, 0x2a647a90, 0x7c853a2e, 0x77703a6d, 0xeffe4e85, 0x383c7978, 0x321f241f, 0x5c443b2e, 0x2a231022,
	0x5c2a2c2c, 0x13281622, 0x1c1c2f23, 0x5913232f, 0x2b06225c, 0x2481a602, 0x352d242a, 0x656b2310, 0xe2270882, 0x4c1f734d, 0x64192d16, 0x8b080506,
	0x03004626, 0xecff7100, 0x0807df05, 0x59004300, 0xb2006c00, 0x67606b40, 0x675a4545, 0x5050404f, 0x50500250, 0x9f676f5d, 0x67100267, 0x15246701,
	0x033f350b, 0x482c0b03, 0x1e6e573f, 0x6d560b48, 0x4b014b00, 0x540154df, 0x01440f50, 0x6f454544, 0x50500150, 0xe0016a00, 0x026af06a, 0x7f5d0f6a,
	0x5d07025d, 0x34511b2f, 0x103a1616, 0x51292110, 0x40240300, 0x24481510, 0x480c0740, 0x00062424, 0x323f0016, 0x2b2b2f32, 0x32e11033, 0x2506a65d,
	0xcc5d5e2f, 0xe141715d, 0x10712905, 0x71cd5ddd, 0xe1f61001, 0x122b0282, 0x122f3d39, 0x33391239, 0x415d2f18, 0x31230bf1, 0x43220530, 0x2e23053d,
	0x4d343502, 0x07230638, 0x6e23032e, 0x362106b5, 0xbe781837, 0x18222008, 0x200dc45e, 0x18d84113, 0x2e343523, 0x05d74104, 0x10043d08, 0x2b2b6d51,
	0xa95f506a, 0x6d3f4a7f, 0x401f5493, 0x3f14343c, 0x2b2b2911, 0x8d697012, 0x29734988, 0x42393116, 0x698c8529, 0x2b2b1270, 0x14401129, 0x203f3c35,
	0x3f6d9354, 0x3aa97e4a, 0x2507d541, 0x396e7c86, 0xd5417870, 0x0f742e05, 0x0f151a15, 0x443b2e32, 0x20202314, 0x955b1823, 0x10093907, 0x0a9a0c16,
	0xca090f13, 0x34c3d3d3, 0x181e1020, 0xd3d3c30e, 0x130f09ca, 0x09355f18, 0x89d5962e, 0x82aa063f, 0x2e242b24, 0x6c231134, 0x0808cf41, 0x0d332934,
	0x0f0a0c0f, 0x26261217, 0x02000046, 0xecff7d00, 0x04075e07, 0x53000d00, 0x62409b00, 0x5a471223, 0x0144c533, 0x44a64496, 0x01448902, 0x4f2b4444,
	0x1d821a5b, 0x2b0d4708, 0x0055671a, 0x02551055, 0x55205500, 0x55705550, 0x55e055d0, 0x5b3c0706, 0x4554662b, 0x370e4145, 0x3411305f, 0x00040409,
	0x3f060a80, 0xcf027f02, 0xef02df02, 0x34020502, 0x4a043015, 0x0e092023, 0x5f412348, 0x695f261f, 0x322b3205, 0x2f33333f, 0x1a33335d, 0x332f39cd,
	0xe1103311, 0x0a735f32, 0x25055755, 0x3911e110, 0x795f5d2f, 0x07152408, 0x86232723, 0x5f352003, 0x8b2d4287, 0xb8322252, 0xb8312331, 0x03502232,
	0x0e91431c, 0x242b945f, 0xac1b0407, 0x23008267, 0x21fe1bac, 0x203a9e5f, 0x05795a00, 0xa405f42a, 0x3a000d00, 0x0d402301, 0x0d290782, 0x30b90f2a,
	0x01308201, 0x06a55f2f, 0x07833a20, 0x481b1322, 0x40290783, 0x480f0a19, 0x0e010ea9, 0x21108210, 0x0c82100e, 0x1c1b3028, 0x011d6634, 0x25821c1d,
	0x53405408, 0x1c1f1c0f, 0x4f031c3f, 0x7f1c6f1c, 0xbf1c9f1c, 0x1c1c051c, 0x232f3034, 0x74012390, 0x236b0123, 0x34232401, 0x0e3a0223, 0x01349014,
	0x14341424, 0x14741444, 0x23051494, 0x34141434, 0x290f0323, 0x102a0047, 0x2a07022a, 0x3c103c2a, 0x3c303c20, 0x830f1003, 0x0f352157, 0x0806e541,
	0x7f020f30, 0x9f028f02, 0x40020402, 0x02481714, 0x1d154034, 0x0c203448, 0x341b4814, 0x290e031e, 0x230f0f1c, 0x36142614, 0x30140214, 0x3f00150e,
	0xc75f3333, 0x17122605, 0x2f2b2b39, 0x07fc412b, 0xd25f0120, 0x5d2f210f, 0x33202782, 0x31059853, 0x18331133, 0x38715d2f, 0xc0875d33, 0x2b2b01c0,
	0x03822b5d, 0x12115d29, 0x2f2f3939, 0x42013031, 0x03200c13, 0x2123eb5f, 0xf641ba04, 0x23312307, 0xf75f0450, 0xa4052129, 0x2107e441, 0x03605cfa,
	0x01490830, 0x14fe7d00, 0xcb059804, 0x54002300, 0x5a111740, 0x0701100f, 0x120f4010, 0x18101048, 0x600120ba, 0x02207020, 0xc0ffb820, 0x0a061a40,
	0x25202048, 0x050125af, 0x2466185b, 0x1d5f0021, 0x5f0a0f04, 0x1b101313, 0xe13f3f00, 0x06145e33, 0x2705134c, 0x2f39125d, 0xe15d5e2b, 0x2005e54c,
	0x06924a15, 0x23113723, 0x108e6211, 0x19033a08, 0x437bae6b, 0x76b0763b, 0x25282d1d, 0xa410bb15, 0x574c9df0, 0x6ca2faa9, 0x3f4e4fc4, 0x51270594,
	0x8d89da98, 0x044e96db, 0xfd090d09, 0x6cd80162, 0xaa1501c6, 0xc61401a6, 0x08f95d6e, 0xfe713508, 0x046f0314, 0x001f005e, 0x1d25403e, 0x0e401c47,
	0x1c1c4811, 0x5f210c04, 0x02217f21, 0x15012110, 0x20560448, 0x1f51181b, 0x121b1c16, 0x10090d51, 0xe1333f00, 0x0128b583, 0x5de1f610, 0x11ce105d,
	0xad82af82, 0x7c450420, 0x17162107, 0x830c7b45, 0xed0128b8, 0x4c4a82b0, 0x5d66b285, 0x9d2908c1, 0x3e949190, 0x12b72368, 0x07fe4414, 0x0806b55d,
	0xd3d3ca4e, 0xfd141bc3, 0x00d8015a, 0x68000100, 0x7904faff, 0x13000a05, 0x67402501, 0x111d110d, 0x1d010d02, 0x0b020201, 0x02020b12, 0x02071207,
	0x0c111007, 0x000b1213, 0x02030801, 0x040f0407, 0x0a0c110d, 0x01090b12, 0x07020608, 0x0d050e05, 0x11211e82, 0x2120820a, 0x22820912, 0x82060121,
	0x02440824, 0x0b0c0504, 0x0f0e0102, 0x4001014f, 0x0b05010b, 0x010f0f01, 0x1204050b, 0x11701160, 0x110311f0, 0x40c0ffb8, 0x480a074d, 0x11070811,
	0x30152015, 0x06030215, 0x07040900, 0x13020101, 0x040d100a, 0x1211110b, 0x30080d82, 0x0b080707, 0x0b0b010b, 0xc00cb00c, 0x120f020c, 0x0002121f,
	0x02081008, 0x0c081202, 0x0212080c, 0x0e0f0404, 0x480d0740, 0x0004050e, 0x2b2f332f, 0x05215533, 0xcf5c2f20, 0x11712305, 0x03832f33, 0x09821482,
	0x01210582, 0x2707825d, 0x5d2b2f32, 0x2f391733, 0x5d200082, 0x11210f82, 0x23018333, 0xc0c08710, 0x0821038d, 0x210185c0, 0x07858710, 0x31c00825,
	0x825e0030, 0x015d2a58, 0x03250705, 0x37251327, 0x21038405, 0x0f820317, 0x4c023308, 0xfe471c01, 0xb481b4e3, 0x0146e5fe, 0xe4fec61f, 0xb61d0147,
	0x1f01b67f, 0x01e5fe4a, 0xa47ba6b0, 0x014ac7fe, 0xa47ba43b, 0x7da45a01, 0x493901a4, 0x0c82c4fe, 0x00010039, 0x038f04c9, 0x00b805b0, 0xb5420015,
	0x0a07200f, 0xffb80348, 0x821e40e0, 0x0c280808, 0x00171212, 0x06100600, 0x06900620, 0x070506a0, 0x0f160606, 0x03000b0f, 0x2f000003, 0xcd102f32,
	0x01112f32, 0x5d5e2f33, 0x2f29c182, 0x2b2b0033, 0x06013031, 0x06527706, 0x21332f08, 0x32333636, 0x06141516, 0x068b0123, 0x2838302c, 0x1d251709,
	0x2d05c101, 0x2b2a3830, 0x2cee0439, 0x1c383333, 0x2d091625, 0x39363231, 0x89820029, 0xe504f426, 0xd905df03, 0x403c8983, 0x90088011, 0x08080208,
	0x10140017, 0x03142014, 0xffb81407, 0x0d1240c0, 0x14144810, 0x14345482, 0xbf400e09, 0x80050105, 0x1a2f0009, 0xcd1a5ddd, 0xcd2f3311, 0x2b228c83,
	0x0a825d5e, 0x89825d20, 0x023e3222, 0x28087f83, 0x34352315, 0x0e222326, 0x35232302, 0x854e0201, 0x6d3a7077, 0x2e3a857c, 0x9179652a, 0x66051055,
	0x65242b24, 0x3411236c, 0x2008822e, 0x08858281, 0x04e10129, 0x06d302d7, 0x00110035, 0x0b124020, 0x4f063f0e, 0x00060206, 0x034f033f, 0x0303035f,
	0xcc2f000f, 0xcd2f015d, 0x8239325d, 0x08b06763, 0x14152408, 0x26151716, 0x44e10126, 0x1f322f3b, 0x3c391f25, 0xb605787a, 0x26264639, 0x11111a1b,
	0x152e1913, 0x8b731f4c, 0x8313205d, 0x3f07295d, 0x02004f00, 0x3f0e0300, 0x2006176e, 0x6e5d8503, 0x7c4a060d, 0x06a44808, 0x78d30225, 0x48393c7a,
	0x05280857, 0x1f734db6, 0x192e154c, 0x2e0b1548, 0xfe290008, 0x05c107c1, 0x00130091, 0x823b0027, 0x0063265f, 0x008b0077, 0x567c829f, 0x07290565,
	0x33363623, 0x17021e32, 0x200f8e03, 0x200f8e01, 0xbf0f8e21, 0x6f04351f, 0x2e241803, 0x212f1e19, 0x054b0314, 0x4d316764, 0x4f031e36, 0x01231392,
	0x821703f4, 0x2f1f2728, 0x4c031321, 0x28856505, 0x922ffb21, 0x31042114, 0x29951492, 0x6882f020, 0x82192d21, 0x277c8453, 0x364c3168, 0xbef9031f,
	0x04313e92, 0x13231ccf, 0x23120506, 0x1c685a1e, 0xf92b4833, 0x270f87f2, 0x331d6959, 0x16012b47, 0x0f821f88, 0x8d2b4821, 0xdb03210d, 0x0d8d0f8d,
	0x8819fe21, 0x8368200f, 0x080d8d4b, 0x08000027, 0x7ffe2900, 0xd3057d07, 0x19000c00, 0x33002600, 0x4d004000, 0x67005a00, 0x17050000, 0x2307030e,
	0x0337033e, 0x20048227, 0x2a0c8233, 0x031e3701, 0x032e1517, 0x82070527, 0x82352004, 0x3701210c, 0x27831a82, 0x82070121, 0x2127831f, 0x1a822703,
	0x1a833720, 0x04821720, 0x042e2783, 0x1c0a0b37, 0x61122320, 0x1012150a, 0x0c8b3b05, 0x0e230233, 0x57575526, 0x5b5d2a27, 0x68fb2557, 0x5755270e,
	0x320c8556, 0x2202a603, 0x28565450, 0x4e4f2545, 0xeafc1e49, 0x884f2302, 0x112b330d, 0x24272914, 0x3317430f, 0x03173234, 0x2814116a, 0x0d822527,
	0x32343424, 0x428a2316, 0x8a980421, 0x16fe215c, 0x01228498, 0x4f8210aa, 0x440f2522, 0x16224f83, 0x0d8b95fc, 0x83de0221, 0x28552286, 0x20868546,
	0x878683e9, 0x004f080d, 0xfec90002, 0x07d3057f, 0x001b0068, 0x40b30031, 0x301c1c48, 0x26d00126, 0xcf26af01, 0x26200226, 0x26802630, 0x17262603,
	0x1a1a190a, 0x07151b18, 0x65175a00, 0x0133d033, 0x200133af, 0x02333033, 0x5a0c0813, 0x26326409, 0x1c011c9f, 0x82090640, 0x8e2c2d3e, 0xfb1a0521,
	0xe8ffb813, 0x481814b3, 0xe0340782, 0x130a2640, 0x16130648, 0x03132613, 0x5f171309, 0x18061200, 0x06211a82, 0x37168220, 0x06190609, 0x07030629,
	0x030a1606, 0x33333f00, 0x2b2b5d5e, 0x3333e13f, 0x07820683, 0x5d2b2f2e, 0xf6100133, 0x5d3232e1, 0xf4105d5d, 0x33280782, 0x332f3933, 0x2f391211,
	0x71311082, 0x30312f33, 0x36341121, 0x23373637, 0x33112301, 0x91841811, 0x03332b09, 0x0e031323, 0x2e222303, 0x41182702, 0xae0807ac, 0x04056404,
	0xfd080604, 0x01aed731, 0x04010303, 0xcc020703, 0xda8fc3d5, 0x31069da6, 0x67648d5d, 0x042a588c, 0x321c04aa, 0x492b354c, 0x03062237, 0x418f3819,
	0x46fb4d4c, 0xe0fcb605, 0x44433e1a, 0x044c4a1f, 0xfdf0fab4, 0x078101d9, 0x50774d68, 0x774f2729, 0x29483950, 0x472c1210, 0x02000035, 0x83feae00,
	0x1706f204, 0x25000f00, 0x3a409600, 0x1a041010, 0x1a841a34, 0x1a1a0703, 0x0e0d050b, 0x090c0f0e, 0x48180910, 0x46000209, 0xa427550b, 0xd427c427,
	0x0427f427, 0x02012780, 0x27102700, 0x27502720, 0x27702760, 0xffb80306, 0x822540f0, 0x08033f29, 0x54044607, 0x107f1a26, 0x06401001, 0x10104809,
	0x11158e20, 0x0209fb0e, 0x600b0f05, 0x2a5f0408, 0x3fe12405, 0x413f3333, 0x2b220c2d, 0x2f415f5d, 0x412b2006, 0x5e210830, 0x052e415d, 0x23011329,
	0x07113311, 0x41113301, 0x032f1323, 0xfefd0b8f, 0x020cacea, 0x7bb7e904, 0x41477ab6, 0x76181419, 0xfd2e076d, 0x9803fc64, 0xe9fd50fc, 0x17067d01,
	0x4218764e, 0x123609f1, 0x0035482c, 0x002f0002, 0x05330400, 0x001600b6, 0x40520021, 0x096a132c, 0x06e66908, 0xd2690e20, 0x00892108, 0x2009cc69,
	0x0ecc6903, 0x6908da68, 0xc06905c6, 0x06d76815, 0x210bc069, 0xc0698101, 0x9898260a, 0xfe3b01ba, 0x14be69c5, 0x69b2b221, 0xb58209bc, 0x00001228,
	0x14061904, 0xb5821400, 0x40613d08, 0x0e01013b, 0x5708471c, 0xbf236f23, 0xff23df23, 0x00030423, 0x11124716, 0x1522540e, 0x0f030450, 0x12001250,
	0x24074004, 0x01120f48, 0x121f120f, 0x12040702, 0x00131204, 0x150e5016, 0x2109916a, 0xc5872b71, 0xc4f61027, 0x3232e133, 0x26cc825d, 0x312f3912,
	0x82210130, 0x692120b3, 0x11200d9f, 0x25099d69, 0x17016401, 0x9f69e9fe, 0x9c9c2309, 0x9b6901b6, 0x21053a08, 0x9ceffd89, 0x587c4d9b, 0x8998042f,
	0xfedafbf3, 0x422911a8, 0x28423130, 0x20c78211, 0x36c782c7, 0x00b60533, 0x00220013, 0x1b4f4088, 0x1a061a05, 0x07190818, 0x82190607, 0x0c4a0801,
	0x00285b1e, 0x00480038, 0x24670003, 0x400124cf, 0x240f0124, 0x0c140601, 0x23640d5a, 0xaf1b1819, 0x1a1a011a, 0xb0062214, 0x07070107, 0x1408050c,
	0x400b3060, 0x0b0b020b, 0x0e60220c, 0x00120c03, 0x11e13f3f, 0xe15d2f39, 0xc7823939, 0x93435d20, 0x39392105, 0x2205ae43, 0x825d5d5e, 0xe15d27e0,
	0x2f393912, 0x1b83112f, 0x74323921, 0x142b064c, 0x1707020e, 0x23062707, 0x82231123, 0x1e4f08e6, 0x32330102, 0x37273736, 0x35363617, 0x23232634,
	0x2f163304, 0x6a6e364b, 0x967c5d81, 0x866a01ba, 0xfd3c7ec2, 0x4426814e, 0x706d5c1f, 0xaea43433, 0x3a0a04a0, 0x2056646f, 0x1bb64e9b, 0xb605c7fd,
	0xfea06d39, 0x85050567, 0x7324a04c, 0x82898e57, 0xae4b08f7, 0x3f0414fe, 0x23005e04, 0x72003900, 0x35344040, 0x2a333332, 0x1f1f1e20, 0x2a214837,
	0x303b571b, 0x102a013b, 0x540d470c, 0x3235333a, 0x1f340f2f, 0xcf346f34, 0x34070434, 0x50242f34, 0x0e101610, 0x20201f0f, 0x211b0c00, 0x51502f1e,
	0xe3820586, 0xe4823f20, 0x3f3f3323, 0x21f38333, 0xd7825d5e, 0x3220e885, 0x1127e682, 0x2f39e139, 0x82113339, 0x33392e04, 0x22053031, 0x2327022e,
	0x16161716, 0x28e18215, 0x3e331733, 0x1e323303, 0x64011902, 0x22032408, 0x4c07020e, 0xf78505bc, 0xad08f682, 0x603b9e02, 0x0c163c4d, 0x04020303,
	0x081a94b6, 0x604d3b16, 0x6e995e3c, 0x6d525a3c, 0x411f756a, 0x41694c46, 0x411b021f, 0x2111516c, 0x6e6d6a0f, 0x19147f54, 0x22203a2c, 0x10371a1f,
	0x36062bfe, 0x2d3e2294, 0xd48f481b, 0x44f2af8c, 0x09a64e9a, 0x2edb030b, 0x295e8d5e, 0x376b9d65, 0x4c980503, 0xd0ee6a9e, 0x010000ce, 0x00002f00,
	0xb605be03, 0x89000d00, 0x051f1540, 0x0502052f, 0x000f0805, 0x9002001f, 0xe000a000, 0xb8000300, 0x1e40c0ff, 0x00480a07, 0x0f1f0f00, 0x0f9f0f3f,
	0x03040fbf, 0x000c5a07, 0x0a06010a, 0x08c00880, 0x22830802, 0x0a062632, 0x09060848, 0x0c0f035f, 0x0c3f0c2f, 0x0f040c4f, 0xaf300682, 0xff0cdf0c,
	0x0c08050c, 0x5f02070c, 0x1207030d, 0x08ee4418, 0xe133712a, 0x2b2f0132, 0x5d5ec65d, 0xcf4d0982, 0x12712b05, 0x315d2f39, 0x21150130, 0x5b182111,
	0x0337084f, 0x01c3fdbe, 0xbab0fe50, 0xb6059898, 0xa215fea6, 0x83027dfd, 0x839102a2, 0x821220bd, 0x040a22bd, 0x3ebd824a, 0x0b1d406e, 0x0620000b,
	0x06020630, 0x0f700f06, 0x0fc00fa0, 0x470d0903, 0xef02df04, 0x83020202, 0x12b323c5, 0x07834815, 0x21402208, 0x00480b06, 0x094f010c, 0x045f044f,
	0x17400402, 0x040b481c, 0x0702041b, 0x08000404, 0x000f0550, 0x20a58815, 0x829c832b, 0xc62b21a6, 0x5d20a587, 0x3125a382, 0x23113330, 0x051e6e35,
	0xae3ca883, 0x5c029c9c, 0x17015afe, 0xe101e9fe, 0x9ae00189, 0xfe89bafe, 0x0001001f, 0x0400fec7, 0x3408b582, 0x66002600, 0x15094140, 0x07070701,
	0x125b2205, 0x0128c028, 0x288f287f, 0x40281002, 0x1c1c0228, 0x055a040a, 0x201d2764, 0x001c175f, 0x2f0d0f60, 0x030d3f0d, 0x2d04820f, 0x0dff0ddf,
	0x0d0d0804, 0x065f0905, 0x3b410503, 0x4fe1200a, 0xf1290506, 0x5d2fc032, 0xde105d5d, 0x299484e1, 0x015d5e00, 0x11070622, 0x94831123, 0x08059f4a,
	0x0e141556, 0x2e222302, 0x16352702, 0x11203316, 0x01022e34, 0x1a3c25fc, 0xfdf702ba, 0x2d471dc3, 0x57a5f09a, 0x76c99252, 0x3d444e31, 0x487f3f1f,
	0x7b437701, 0x058302ae, 0x0587fd05, 0x0bfea6b6, 0xab5c0305, 0xf8aa97f2, 0x0c064fa2, 0x17a20c13, 0x79ef0118, 0x00407eb9, 0x4a08db82, 0x030afeae,
	0x004a04c5, 0x405c0023, 0x19220939, 0x03222922, 0x0a121414, 0x0f251f48, 0x02251f25, 0x257f255f, 0x030325ff, 0x47111703, 0x04245412, 0x0b510d00,
	0x021a1b1a, 0x121a1a07, 0x0f135016, 0x51071512, 0x3f001b00, 0x5d3f3fe1, 0xe9210580, 0x05424311, 0x5d2f3923, 0x82d28871, 0x842620d1, 0x363225bb,
	0x23263435, 0x3b08de93, 0x6a4b2902, 0x426a2b2e, 0x9d907576, 0xb61f3e1a, 0x5afe5c02, 0x661f3b1d, 0x404c85b3, 0x0afe966f, 0x18a11d1f, 0xd4d2c325,
	0xfe080aca, 0x9a4a0435, 0x0505c3fe, 0x9ddb8a3e, 0x4088d596, 0x043cc782, 0xcb067ffe, 0x1500b605, 0x5740e200, 0x18144011, 0x09201148, 0x110a4813,
	0x0002111a, 0x00200e83, 0x003c0e84, 0x0702001a, 0x020d0d10, 0x0a0a075a, 0x03b803a8, 0x01039902, 0x5701038d, 0x77036703, 0x5e08e582, 0x06120303,
	0x100f0e00, 0x180c400f, 0x0f110f48, 0x12045a15, 0x84127401, 0x0312c412, 0xc0ffb812, 0x0a072740, 0x17121248, 0xf0011704, 0x17e40117, 0x0117a001,
	0x30172002, 0x70176017, 0x05179017, 0x0801170f, 0x08050809, 0xf0ffb806, 0x06061340, 0x0dfb1316, 0x0f000a0a, 0x11030b08, 0x6803055f, 0xe135054e,
	0x1233333f, 0x3f331139, 0x2f330111, 0x11333338, 0x5d5d5e33, 0x06b25b5f, 0x715d2b30, 0x2f3333e1, 0x3233382b, 0x2f391211, 0x00825d5f, 0xe1212182,
	0x33258332, 0x2b5d2b2b, 0x2130312b, 0x11231101, 0x01012301, 0x33110133, 0x08824482, 0x053c1082, 0xb3eefdae, 0x02d3eefd, 0xcdedfd21, 0x02b30a02,
	0xedfdcd0a, 0xb0c3a801, 0x1bfde502, 0xf2240384, 0x3cfdc402, 0x2e080387, 0xd9fdb4fd, 0x00008101, 0xfe040001, 0x04040683, 0x0115004a, 0x276c4011,
	0x02103710, 0x0e390e29, 0x36092602, 0x0a270209, 0x27020a37, 0x86043704, 0x37012304, 0x5e410201, 0x0d10371d, 0x0746020d, 0x03cd0a0a, 0x0103b901,
	0x960103a9, 0x03870103, 0x5a410301, 0x410a2009, 0x4628055a, 0xc0ffb812, 0x481512b3, 0x40380783, 0x480b0717, 0x10171212, 0x17000117, 0xf417e401,
	0x17b40217, 0x170217c4, 0x402f2382, 0x48110d13, 0x02011730, 0x0f011720, 0x41070117, 0x0f241560, 0x03056011, 0x41093949, 0x2b251260, 0x71715d5d,
	0x05bf6211, 0x200e6141, 0x0662415d, 0x61415d20, 0x5d002406, 0x835d015d, 0x156a4100, 0xfef0043c, 0x44fea443, 0xfecf01cf, 0x9f01c558, 0xc5a001a4,
	0x4f0158fe, 0x2d02aec5, 0x0384d3fd, 0x15023524, 0x0387ebfd, 0x65fe2a08, 0x7d01e9fd, 0x4800ffff, 0xec0342fe, 0x2602cb05, 0x0000b101, 0x7f030701,
	0x00004801, 0x01b11100, 0xffffb801, 0x134248b4, 0x06b35c0b, 0x44202b82, 0x52222b82, 0x2b825e04, 0x2b85d120, 0x88f20021, 0x82f8202b, 0x2129212b,
	0x24082b86, 0xc7000100, 0xec047ffe, 0x1000b605, 0x5940a600, 0x18144005, 0xcd05bd48, 0x0305dd05, 0x10092005, 0x2a051a48, 0x05044305, 0xcd00bd27,
	0x0300dd00, 0x3c158400, 0x02002a00, 0x08101006, 0x7f100f0e, 0x020f9f0f, 0x0f300f00, 0x06030f40, 0x04050f0f, 0x3a72825a, 0x07020110, 0xb0120101,
	0x080c0112, 0x1164095a, 0xf0ffb80c, 0x100b1640, 0x82100648, 0x060c3a04, 0x030a0f09, 0x05055f00, 0xfb021209, 0x333f3f00, 0x333fe12f, 0x2b393912,
	0x08af6d2b, 0x335d5e2a, 0x2f3332e1, 0x385d5d5e, 0x11231982, 0x852b5d33, 0x30312901, 0x23113325, 0x07012311, 0x333f0582, 0x33013711, 0xb7350401,
	0x3dfe6cb1, 0x79baba8b, 0xfdd1c401, 0xd9fda6f8, 0xba028101, 0x19b8fd72, 0x2f09142d, 0xfeae0001, 0x042b0483, 0x000e004a, 0x086a4099, 0x0826e784,
	0x08dd08cd, 0xd1840803, 0x082a0824, 0x15840302, 0x03cd0326, 0x030303dd, 0x3f081584, 0x02032a03, 0x00460708, 0x86017601, 0x016d0201, 0x01015501,
	0x013b012b, 0x1403014b, 0x010b0101, 0x01030601, 0x04100400, 0x10040402, 0x470a020e, 0x090f540b, 0x000e0e02, 0x0850030b, 0x0cfb0515, 0x2105ca60,
	0xc284e13f, 0x2505dc44, 0x2f331132, 0x066c335d, 0x5d5d2205, 0x89e58211, 0x20cc82da, 0x84dd8501, 0xfa0238dc, 0x0161fec4, 0x66aec14b, 0xb4b44bfe,
	0xf1fd4a04, 0xe9fd5ffe, 0x18027d01, 0x08093781, 0x0000c748, 0xb605a204, 0x97001200, 0xff0f00b9, 0x125d40e0, 0x0f504815, 0x22020f60, 0x420f320f,
	0x4002030f, 0x0b480d09, 0x34085a07, 0x02125412, 0x03570f12, 0x1d0c0301, 0x040b0104, 0x00040401, 0x10136408, 0x00011111, 0x02820010, 0x07022008,
	0xb0140000, 0x142f0114, 0x01141001, 0x0809050b, 0x04300420, 0x04030440, 0x100d040d, 0x82080309, 0x323f2e65, 0x3939333f, 0x115d2f2f, 0x01393912,
	0x08c0835d, 0x5d5e2f24, 0x11333338, 0x11e61033, 0x5d5d2f39, 0x325dc133, 0xe1105d32, 0x00303132, 0x2b5d5d2b, 0x15012321, 0xad411123, 0x33112206,
	0x08e38215, 0xd3a2043c, 0x7785aefe, 0x8577baba, 0xfdd14101, 0xcdf401f8, 0xfd626401, 0xfdb605d7, 0x6301a406, 0xfda601b3, 0x00010065, 0x040000ae,
	0x004a0423, 0xb59c0013, 0x110b4011, 0xffb80a48, 0x0782b3c0, 0xb80e5208, 0x5740f0ff, 0x0e480d08, 0x0112260a, 0x13890712, 0x13a91399, 0x2f131f03,
	0x03133f13, 0x1301130b, 0x02060f13, 0x14540347, 0x100c0c0b, 0x0f20100f, 0x0f020f30, 0x1500150f, 0x00021510, 0x60154015, 0xa0158015, 0xe015c015,
	0x0e070715, 0x0806060d, 0x2b018213, 0x0f040b02, 0x00150210, 0x333f333f, 0x2f2ddc82, 0x1139122f, 0x5e013333, 0x3311715d, 0x22e2862f, 0x4e32e1f6,
	0xe5840568, 0xe2832b20, 0x27012b28, 0x33112311, 0xdb823711, 0x01331324, 0xef830115, 0xcf012708, 0x6db4b46d, 0xfec5eb7d, 0xcfd70150, 0x017df8fe,
	0xd3fd7bb2, 0xebfd4a04, 0xb946017b, 0x16fe0d01, 0x01e9fd49, 0x7f49cd27, 0x04270805, 0x00b605a2, 0x40850014, 0x66140240, 0x13140114, 0x500e4004,
	0x0e0e020e, 0x040c1000, 0x0507095a, 0x13121564, 0x41131310, 0x163b0aa7, 0x2f0116b0, 0x16100116, 0x5f060f01, 0x0009090c, 0x100b1002, 0xffb81048,
	0x830c40f0, 0x05022508, 0x05030a12, 0x8206b041, 0x2b2b21cd, 0x3322b782, 0xb24132e1, 0x382f250b, 0xc6f61033, 0xd3841482, 0x39121128, 0x3133115d,
	0x5a432130, 0x053d4d05, 0x23153322, 0x2a056243, 0x3dfed3a2, 0x9898ba8b, 0x43d5d5ba, 0x02310564, 0xb8fd72ba, 0xb2a46004, 0x7bfea4b2, 0xfd3302a8,
	0x08cb8283, 0x00001222, 0x1406f003, 0x84001600, 0x0e110f40, 0x08040f0e, 0x47130309, 0x01060014, 0xc0ffb806, 0x481510b3, 0x3a080783, 0x0e093540,
	0x0f060648, 0x54140116, 0x100d0c17, 0x35100f0d, 0x0f00010f, 0x0f200f10, 0x0f0f0803, 0x01180f18, 0x14021109, 0x15070f14, 0x0101044f, 0x0c150f02,
	0x0000020f, 0x853f3f3f, 0x053f4cc5, 0xaf820120, 0x21052044, 0xc9821133, 0x82c63221, 0x2b2b281c, 0x17e11071, 0x83391132, 0x33132fca, 0x21153335,
	0x03112115, 0x33013733, 0xd9860101, 0x9c122e08, 0xfe7b01b4, 0x87041085, 0xfed32501, 0xd1ac016f, 0xb46db0fe, 0xb65e059c, 0x75fe89b6, 0x01aaedfe,
	0xfd25fe69, 0x52f80191, 0xd5045afe, 0x3dd78200, 0x05000014, 0x00b60544, 0x4057000e, 0x0e0e0233, 0x5a040a0d, 0x05300520, 0x05800540, 0x008205f0,
	0x0c070024, 0x9e410d0d, 0x10102a0a, 0x0a020110, 0x5f070c05, 0x07854108, 0x1233e124, 0xb2863939, 0x82333821, 0x822f20b1, 0xe15d21ae, 0x7541aa86,
	0x35212306, 0xaa831121, 0xd344052a, 0xbb8b3dfe, 0x0f02acfe, 0x240a6e41, 0xfda41205, 0x076b4125, 0x00294008, 0x04c90400, 0x000d004a, 0x02404067,
	0x060b0d0d, 0x01070047, 0x07100700, 0x07600720, 0x080507c0, 0x09030707, 0x01d50100, 0x010201f5, 0x00100304, 0x02031003, 0x400f0303, 0x020fe00f,
	0x82010f0f, 0x09072733, 0x0f0a0050, 0xf4420307, 0x12e12705, 0x01331139, 0xee425d5d, 0x82078306, 0x5d5e29a2, 0x3232e171, 0x30313311, 0x22054241,
	0x82112311, 0x076908a5, 0xc5dd0311, 0xc70160fe, 0xb54cfecf, 0x1f0298fe, 0xfd4a0402, 0x02c5fdf1, 0x03d3fd2d, 0xfd029ab0, 0x010000ed, 0x7ffee500,
	0xb605a405, 0x63000f00, 0x5a043f40, 0x74010104, 0x94018401, 0x01010301, 0x5a050d11, 0x11e41100, 0xc00211f4, 0x10020111, 0x40112011, 0x04118011,
	0x095a080c, 0x5f071064, 0x08010c0f, 0x0e050c0c, 0x21c3820a, 0x2646055f, 0x33e12305, 0x9184333f, 0x2646e120, 0x5d5f2605, 0xe1dc105d, 0x21af8332,
	0x1846e171, 0x6e112007, 0x112d06a0, 0xb0f40433, 0x67fdbbb0, 0x9902bbbb, 0x051346bb, 0x676eaa20, 0x68022105, 0xae269b82, 0xdb0483fe, 0x9b824a04,
	0x5240793a, 0x04470008, 0x0b0b010b, 0x0cc4470f, 0x0c020cd4, 0x1104110c, 0xd4021124, 0xb0209e83, 0x30209e82, 0x50209c82, 0x26089e82, 0x11a01190,
	0x47030706, 0x0d105404, 0xeb5002fb, 0x07a90107, 0x0f0207b9, 0x2f071f07, 0x07060307, 0x05090007, 0x51500b0f, 0xe1200585, 0x5d23ad86, 0x883fe15d,
	0x837120b0, 0x33e128ad, 0x32e15d2f, 0x89213031, 0x33112fac, 0x03112311, 0xb6dffd85, 0xb62102b6, 0xe572b6a0, 0x054d5109, 0xe536b182, 0x48060000,
	0x0d00b605, 0x3b405d00, 0x005a0109, 0x0b400500, 0xb782e001, 0x43200f21, 0x2108053e, 0x0f400f30, 0x0fa00f60, 0x0fe00fb0, 0x04080608, 0x0e64055a,
	0x0a0a5f0d, 0x0f5f0306, 0x08080108, 0x8d420608, 0x2f392407, 0x82e15d5e, 0x0549418a, 0x715d5e29, 0x715dc610, 0x842f3911, 0x88232095, 0x15212496,
	0x41f40421, 0x02240643, 0x02acfe0f, 0x21084141, 0xa14500a4, 0xa4052305, 0x91824a04, 0x21406833, 0x05470408, 0x00470109, 0x54050b00, 0x0f0b0b0e,
	0x21958200, 0x8b829002, 0x0fc03208, 0x0ff00fd0, 0xffb80f05, 0x071f40c0, 0x5003480c, 0xa90108eb, 0x0208b908, 0x081f080f, 0x0603082f, 0x0d000808,
	0x050f060a, 0x3f001500, 0xc4333f32, 0x249e8312, 0x01e15d5d, 0x2394822b, 0xe6102f33, 0x10209984, 0x3b219c92, 0x053141b6, 0xfe1f0223, 0x09324197,
	0x9b829a20, 0xfec72e08, 0x05db0700, 0x002700b6, 0x093a405f, 0x1207010b, 0x5a200012, 0x18252121, 0x6f29085b, 0x5a240129, 0x1d286425, 0x2f030f60,
	0x03033f03, 0x3c04820f, 0x03ff03df, 0x03030804, 0x265f2325, 0x12252103, 0x0d5f1613, 0xe13f001c, 0x3f333f33, 0x299284e1, 0x1001e171, 0x105de1f6,
	0x9084e1de, 0x312f3927, 0x5d5e0030, 0x17684d01, 0x07222323, 0x054b4111, 0xc1042129, 0x9a2e491e, 0x4d56a5f0, 0x4335056b, 0x7e3f1f3d, 0x43770149,
	0x4b6bae7c, 0x7bfdbb33, 0x03fa03ba, 0x166b4d1b, 0x89fd0c26, 0xeefa1205, 0x5808cb82, 0xfeae0001, 0x0475060a, 0x0024004a, 0x0b4e4077, 0x02231b23,
	0x11190303, 0x01120247, 0xa60112c2, 0x0212b612, 0x12871277, 0x16121202, 0x2620480a, 0x261f260f, 0x5f264f02, 0xff26af26, 0x26100426, 0x16471501,
	0x510d2554, 0x1b1b1b0b, 0x1b1b0702, 0x17501416, 0x1516120f, 0x06884d04, 0xe885e989, 0x85715d21, 0x5d5d25ea, 0x32e1715d, 0x8e4dee84, 0x18e68415,
	0x2108444c, 0x8f4dd904, 0x3e1c2a09, 0x08feb61f, 0x3a6403b6, 0x158f4d3f, 0xfcb00328, 0xfe4a0450, 0x914d0c27, 0x02660808, 0xacff7d00, 0xcd059605,
	0x52003e00, 0x50407a00, 0x32104e05, 0x5b490004, 0x20102000, 0x35203502, 0x5b3f1820, 0x0f546700, 0x4f541f54, 0x7f545f54, 0xaf549f54, 0x2b070754,
	0x5366185b, 0x054e6044, 0x3a103a00, 0x3a603a20, 0x3a803a70, 0x073a3a06, 0x1d215f26, 0x30321004, 0x5f07135f, 0x13130e0e, 0x2f333f00, 0xd08210e1,
	0xe1333f28, 0x5d2f3912, 0xee843939, 0xa2185e20, 0x5d36083a, 0x391712e1, 0x14013031, 0x1607020e, 0x37363233, 0x23060615, 0x04652722, 0x032e2110,
	0x21097d6e, 0x4f632637, 0x34072308, 0x1887022e, 0x3e17ee08, 0x276f0503, 0x362d5541, 0x1f462551, 0xa6264f1d, 0x3c7c328b, 0x519de896, 0xa6f29e4d,
	0x35257842, 0x3330280a, 0x6ca97615, 0xa0703c33, 0x4f263064, 0x8360375b, 0x62854b4c, 0x2a16c539, 0x3d29273d, 0x29181529, 0x422a1f36, 0xa602182e,
	0x6f90af65, 0x0b0e1924, 0x620c0daa, 0xc06a1111, 0xb5a50e01, 0x69c71f01, 0x059c0f16, 0x5105090a, 0x948dde9a, 0x074690da, 0x9b160169, 0x3b7bc185,
	0x95c67b38, 0x36638954, 0x50876237, 0x65768548, 0x77622127, 0x02000088, 0xc5ff7100, 0x5e04a404, 0x4d000d00, 0x49407900, 0x32110544, 0x48003f04,
	0x21642154, 0x35213502, 0x48081921, 0x3f4a4a3f, 0x4f7b4f57, 0x4fbb4f8b, 0x6f4f5f03, 0x4f1b024f, 0x014f0f01, 0x482a0207, 0x0b4e5619, 0x3a3a0544,
	0x22502547, 0x3211101e, 0x4714502f, 0x140e0e50, 0x0a5a4116, 0x3912e92d, 0xc139392f, 0xe1f61001, 0x825d5e5f, 0xe6102500, 0xe1102f32, 0x41053078,
	0x1e210760, 0x06e55302, 0x01062223, 0x0d976422, 0x64661620, 0x3736270d, 0x34352626, 0x3953023e, 0x020e2305, 0x99411607, 0x02920807, 0x2a2014dd,
	0x38483915, 0x01413e3d, 0x3988454c, 0x75476228, 0x3c3f7ab3, 0x4279b478, 0x13291a52, 0x70542a4a, 0x431e1c43, 0x3225506e, 0x314a3903, 0x40417255,
	0x1e2e526f, 0x14274534, 0x391a1d37, 0x0142191c, 0x4b5c35f4, 0x96281239, 0x7a7a676b, 0x252a68fd, 0x97571711, 0xd68375cc, 0x06105397, 0x3a100596,
	0x5967a06f, 0x083c6b94, 0x77b44202, 0x2b59885e, 0x638a5627, 0x4d637846, 0x060d0a1b, 0x07099308, 0x7d00ffff, 0x980442fe, 0x2602cb05, 0x754d2600,
	0x2f022d05, 0x0e000000, 0x750101b7, 0x20182c32, 0x8205724d, 0xfe712a27, 0x046f0342, 0x0026025e, 0x21278546, 0x27867101, 0x282e5224, 0x27850d05,
	0x01005708, 0x7ffe1400, 0xb6051204, 0x6f000b00, 0x0d1f3940, 0x010de001, 0x0ddf0d5f, 0x300d2002, 0x030d400d, 0x010f5a04, 0x0702011f, 0x0aaf0101,
	0x0a020aef, 0x065a0b0a, 0x07e00740, 0x01070f02, 0x57070708, 0x77066706, 0xb8060306, 0x0f40c0ff, 0x06480a07, 0x085f070b, 0x4b470003, 0xe13f3108,
	0x2b2f0132, 0x5e2f335d, 0xe1105d5d, 0x395d2f32, 0xe1240982, 0x715d5d5d, 0x37094947, 0x21152135, 0xb0b07102, 0x035efebb, 0xa65ffefe, 0x8101d9fd,
	0xa4a41205, 0x0027b682, 0x0383fe29, 0x844a045e, 0xf04d399d, 0x0daf010d, 0x500d4001, 0x0d2f020d, 0xaf470b01, 0xcf08bf08, 0x40080308, 0x33087882,
	0x05df0808, 0x01059d01, 0x0501058f, 0x00470705, 0x02700260, 0x1f0302d0, 0x02020102, 0x00100000, 0x00c000b0, 0xfb090004, 0x03500206, 0x0050070f,
	0xe13f0015, 0x3f209c82, 0x0a568b18, 0x39209582, 0x9d83ab82, 0x30315d25, 0x83211121, 0x33113898, 0x01112311, 0x03c1fe68, 0x9fc1fe35, 0x9ab003b6,
	0xfdeafc9a, 0x6d7d01e9, 0x37270795, 0x0602b605, 0x83003c00, 0xfe0024ad, 0x82d50314, 0x001336ad, 0x0a13407c, 0xa647000a, 0x01870101, 0x01020197,
	0x12110301, 0x0c4e5010, 0x07204208, 0x1212480b, 0x0115f015, 0x15ef15df, 0x90155002, 0x0315a015, 0x3001154f, 0x150f0115, 0xb8030401, 0x1040f0ff,
	0x0f031103, 0x0a150a05, 0x0a130702, 0x1b001502, 0x333f3f00, 0x3f5d5e33, 0x382f0133, 0x82b08233, 0x33112902, 0x382b2b2f, 0x2f391233, 0x2205ed72,
	0x82013031, 0x333908b1, 0x17031e13, 0x37033e33, 0x02013313, 0x71feb746, 0x2010c7bc, 0x0705141b, 0x201b1504, 0xfebcc710, 0x0114fe71, 0xfd4e04e8,
	0x5e642ecf, 0x4f19194f, 0x022e645e, 0x00b2fb31, 0x21c98201, 0xd5820400, 0x10002e08, 0x19409f00, 0x120112ef, 0x480c0940, 0x08040000, 0x090d095a,
	0x77010996, 0x02098709, 0xc0ffb806, 0x18150d40, 0x06090b48, 0x030b0906, 0x05b36402, 0xab383c08, 0x0f90010f, 0x010f1401, 0x1002010f, 0xef010210,
	0x02d00102, 0x0102bf01, 0x4f010280, 0x02025f02, 0x00010214, 0x02070102, 0x0a071202, 0x0d00045f, 0x1208010d, 0x0003010f, 0x823f333f, 0x333928c2,
	0x011132e1, 0x855e2f33, 0x715d23db, 0xd6823338, 0xde825d20, 0x2f39172e, 0x5d2b2f2f, 0x1033115d, 0x3d3932e1, 0xe8820a82, 0x01330123, 0x05c25515,
	0x35212808, 0x33013521, 0x54011b02, 0x0142fec8, 0xbbd9fe27, 0x2601dafe, 0x02cb42fe, 0xfce302d3, 0xfea43d83, 0xa45801a8, 0x41870333, 0x19310ba7,
	0x15408500, 0x01170e0e, 0x02a60647, 0x97028701, 0x23008202, 0x10161507, 0x080cb277, 0x0b072037, 0x1b161648, 0xdf011bf0, 0x021bef1b, 0x1b901b50,
	0x4f031ba0, 0x1b30011b, 0x011b0f01, 0xffb80708, 0x071340f0, 0x000f0715, 0x0e054f03, 0x07020e15, 0x1506170e, 0x07ac4101, 0x4132e121, 0xec8217ae,
	0x3125c982, 0x23110530, 0x20c08211, 0x0bb44101, 0x0215212a, 0xf6feb746, 0x73fe0801, 0x2910ba41, 0xfe890a01, 0x8963019d, 0xbe414a04, 0xb62b080e,
	0x00010089, 0x047ffe00, 0x00b605b4, 0x4006010f, 0x010f4788, 0x03010948, 0x060b000f, 0x0e070a05, 0x0b000c07, 0x080a0509, 0x820c080d, 0x09002112,
	0x32081482, 0x0f0c0905, 0x0e060603, 0x01050a08, 0x05ba05aa, 0x05ea05ca, 0x050505fa, 0x480e0b30, 0x015a0405, 0x0b100e0d, 0x0eab010e, 0x0ecb0ebb,
	0x0efb0eeb, 0x82400e05, 0x0a0e2f19, 0x00aa0100, 0x00ca00ba, 0x00fa00ea, 0x2d830005, 0x000e3e08, 0x01140104, 0x01010702, 0xe411d411, 0x0311f411,
	0x020111c0, 0x11401120, 0xffb81102, 0x100b40c0, 0x110f4814, 0x0a0a0b01, 0xffb80807, 0x081440f0, 0x27010628, 0x060c010c, 0x030a0d05, 0x09354407,
	0x333f3328, 0x5d393912, 0x7c54015d, 0x2b5d2405, 0x4d5d5f5d, 0x33250586, 0x715d2b33, 0x2403822f, 0xe1103338, 0x30078232, 0x3d391211, 0x1033172f,
	0x04c00e87, 0xc08710c0, 0x2204820e, 0x8608c008, 0x82012005, 0x08cb5137, 0x08058f54, 0x01330143, 0xb0b6fe03, 0xfe9efe77, 0xc501bc91, 0x01c65afe,
	0xbe4e014c, 0xfda65bfe, 0x028101d9, 0x0285fd7b, 0xfdba02fc, 0xfd2f02d1, 0x0100004c, 0x83fe2300, 0x4a041f04, 0x39010f00, 0x0d592540, 0x01035601,
	0x3ab282b4, 0x48110e20, 0x29010c3d, 0x0c0b010c, 0x0c020c1b, 0x0008460b, 0x0d030603, 0x8304010d, 0x714508da, 0xb5481815, 0x04990104, 0x6a0204a9,
	0x8a047a04, 0x04450304, 0x06020455, 0x05040104, 0x02eb02db, 0xc90302fb, 0x02bb0102, 0xa6029601, 0x02650202, 0x02850275, 0x5a024a03, 0x01020202,
	0x05ef05df, 0x050305ff, 0x3a638240, 0x054b053b, 0x01052702, 0x051a050a, 0x44013402, 0x01280201, 0x15010501, 0x82050201, 0x3b0f2406, 0x83070107,
	0x0754088a, 0xc0ffb808, 0x0c074940, 0x11080848, 0x11801160, 0x11b01190, 0x11e011d0, 0xdb0711f0, 0x0ec9010e, 0x010eba01, 0x0e750e65, 0x4a030e85,
	0x020e5a0e, 0x0e010e09, 0x0f4b0f3b, 0x010f2802, 0x0f150f05, 0x0d030f02, 0x50070e01, 0xfb09150c, 0x000f0104, 0x3f3f333f, 0x24054c4e, 0x5d5d5d2f,
	0x068e43c5, 0x2f33112a, 0x5d2b332b, 0x2f393912, 0x15821683, 0x105d2b22, 0x07861c86, 0x90412b20, 0x32e12106, 0x312a1d84, 0x5d5d0030, 0x13330101,
	0x04563313, 0x232c0805, 0x01230101, 0xcf9ffe98, 0xfecffafa, 0xaa0f019d, 0xf4fe65ae, 0x02cff2fe, 0xfe170233, 0xfd9a0166, 0xfd67fee9, 0x017d01e9,
	0x004cfeb4, 0x33059f46, 0xb6056006, 0x94000f00, 0x5a010d40, 0x5a080404, 0xd0010510, 0xf183fd82, 0x07444408, 0x05054812, 0x0111df11, 0x0f0111a0,
	0x4f112f11, 0x04118f11, 0x200e1007, 0x500e400e, 0x800e600e, 0x0e0e060e, 0x0f095a00, 0x2f0b1f0b, 0x6f0b5f0b, 0x060baf0b, 0x300b0b08, 0x50094009,
	0x90098009, 0x83090509, 0x07112348, 0x2482480a, 0x0c025f30, 0x5f000403, 0xfb061209, 0xe13f3f00, 0x3e5a3f32, 0x2f332206, 0x05bf465e, 0xd5825e20,
	0x2f33112f, 0xe1715d2b, 0x31e12f33, 0x11212530, 0x21018233, 0x2f461123, 0x71022806, 0xb0ba8502, 0x4606fcb0, 0x052106cc, 0x05b85f10, 0xa4120523,
	0x26cd82a4, 0x0583fe29, 0x824a046d, 0xb68028cd, 0x0e0e470b, 0x820f4702, 0x0eb3237d, 0x07834818, 0x0733402a, 0x0f0f480b, 0x1f110f11, 0xbf20ca84,
	0x062ed882, 0xe0086007, 0x0308f008, 0x470a0808, 0x1a421f03, 0x00052a06, 0x60031003, 0x04037003, 0x2fbd8403, 0x03481814, 0x0c500509, 0x0a0e0f06,
	0x00150350, 0xbc87bd8f, 0x2b20ba83, 0x0120b985, 0xbb82b388, 0x0524c382, 0xb2fcb76d, 0x2705e746, 0xa0b6f801, 0x7d0183fe, 0x2405ed46, 0x50fcb003,
	0x3ebb8200, 0x057ffea6, 0x00b60531, 0x4063001d, 0x1b0d0b12, 0x041a020d, 0xa01d905a, 0x1d1d021d, 0x83005a03, 0x2c2b0887, 0x00481007, 0x1f0f1f00,
	0x1f2f1f1f, 0x1f5f1f4f, 0x1faf1f7f, 0x07081fbf, 0x640f5a12, 0x1a5f151e, 0x1b040a0a, 0x5f1d0310, 0x84011204, 0x333f25a2, 0x332f3912, 0x8306184b,
	0x07b44e9c, 0x11255d23, 0x26018223, 0x2223030e, 0x1835022e, 0x2008834f, 0x35098237, 0xbab03105, 0x6163693a, 0x65925d31, 0x7b69ba35, 0x665e5a2d,
	0xbe43ba38, 0x16563605, 0x310c1622, 0x02598b5e, 0x73d1fd47, 0x1e140a74, 0xfac60214, 0x08bd82f0, 0x83fe9a23, 0x4a049e04, 0x61001c00, 0x090b1740,
	0x092b091b, 0x00150703, 0x1c181847, 0x10190047, 0x03192019, 0x08c28319, 0x150e2522, 0x1e191948, 0x1e5f1e0f, 0x1ebf1e7f, 0x0e051ecf, 0x1d540b47,
	0x1015fb1a, 0x00060650, 0x180f0c16, 0x83063d48, 0x33e127ba, 0xf610013f, 0xba835de1, 0xbb825d20, 0x3132e127, 0x215d5e30, 0x23b78a11, 0x023e3233,
	0x3320b683, 0x0334ce82, 0x55502c48, 0x7a4e3a5e, 0xb8b62b52, 0x4d4c502d, 0xb7a0b62a, 0x0baa9118, 0xae66fe28, 0x1d2b1c0f, 0x8f4fd501, 0xa6580808,
	0x81040000, 0x1d00b605, 0x2e407000, 0x041b040b, 0x1d0f1c02, 0x0e140e04, 0x0e0e0702, 0x5a171306, 0x701f6516, 0x021fa01f, 0x10011f2f, 0x5a09011f,
	0x06700660, 0x06b006a0, 0xffb80604, 0x071640c0, 0x0e06480a, 0x131d0e10, 0x0c031d1b, 0x1701015f, 0x17030714, 0x3f3f0012, 0x1726be84, 0x32322f33,
	0xf648012f, 0x27c98206, 0x2f391132, 0xc1335d5e, 0x5d21c782, 0x0a7b4101, 0x33113325, 0x83363611, 0x112329c7, 0x11070606, 0x21500223, 0x2c067f41,
	0x7638850c, 0x42baba44, 0x01853977, 0x097b41fc, 0x58012108, 0x2209b4fe, 0xfac60219, 0x1a56024a, 0xc9fe0b25, 0x9a000100, 0xfe030000, 0x1c004a04,
	0x42406b00, 0x2308cd84, 0x1c0e1b07, 0x04010d50, 0x240d140d, 0x0d08030d, 0x1612060d, 0x1e55155a, 0x1e601e10, 0x09031e80, 0x1d54065a, 0x28068b4a,
	0x1c0d0f0d, 0x031c1a12, 0x25c6820b, 0x0f071316, 0xc68d1516, 0x8805f374, 0x23c585c4, 0x30315d5e, 0x3320c889, 0x0e21c791, 0x058e412f, 0x7d062708,
	0xb6335b2f, 0x325932b6, 0x2f6a017d, 0x01447354, 0xae66fea6, 0xe5fe2d01, 0x0123300e, 0x01b6fbd5, 0x103323e9, 0xc58200ff, 0x08070f57, 0x5000173a,
	0x07043640, 0x07020714, 0x650b5a0c, 0x5f192f19, 0x8f196f19, 0xaf199f19, 0xef19cf19, 0x0919ff19, 0x02011910, 0x64175a16, 0x5f101518, 0x05100500,
	0x17050502, 0x0300120b, 0x3923b983, 0x57e15d2f, 0x5d2005ae, 0x2505a675, 0x135d5e00, 0xe84f1133, 0x11330806, 0x26341123, 0x020e2223, 0xc7231107,
	0x62c373ba, 0x3565925d, 0x2d7b68bb, 0x38655f5a, 0xfdb605ba, 0x312d2daa, 0xfd598a5e, 0x732f02b8, 0x1e140a75, 0x5139fd14, 0x2408052d, 0x4a041204,
	0x3f001800, 0xff1400b9, 0x072240e0, 0x4700480a, 0xef1a5518, 0x1a10011a, 0x1a801a60, 0x47090d03, 0x7494180a, 0x0a0f2107, 0x21050f51, 0x8b8e2f39,
	0x11212b23, 0x227e8634, 0x60113311, 0x1122064c, 0xb7425c03, 0x42b62006, 0x6b0808c9, 0x0fae9a01, 0xfe1c2c1c, 0xfe4a042b, 0x202f1f16, 0x73532f11,
	0x005afe44, 0xff3d0002, 0x050606ec, 0x002b00cd, 0x40640036, 0x145b323e, 0x0f38670b, 0x02381f38, 0x01222029, 0x0c312222, 0x1f70005b, 0x1fc01f80,
	0x1f371f03, 0x4f31600c, 0x2b0f012b, 0x2bff2baf, 0x01250f03, 0x2b252b08, 0x5f110525, 0x2c131a14, 0x0004055f, 0x333fe13f, 0x3905d84d, 0x715d5d5e,
	0x0132e133, 0x325dd610, 0x2f3332e1, 0x105dc15d, 0x31e132f6, 0xa6830130, 0x1216162c, 0x1e211515, 0x36323303, 0x88431537, 0x27eb0805, 0x34352622,
	0x06333736, 0x33141506, 0x020e2201, 0x2e342107, 0x0a660102, 0x8ddd9c5b, 0x3e88d699, 0x3f0725fc, 0x8070a974, 0x5b2a5bcf, 0x984c7c69, 0x095ca4eb,
	0x0b129a8f, 0x670f069c, 0x955b8902, 0x0307416e, 0x8b562512, 0xf49a3903, 0xc56b5bab, 0x45abebfe, 0x4786c27a, 0x0faa202c, 0x610a121a, 0x759bfdb3,
	0x17422a7a, 0x61233e0f, 0x7e41f001, 0xb87578b9, 0x00004380, 0xff330002, 0x04b604ec, 0x002c005e, 0x40840035, 0x2748312b, 0xff37571e, 0x37900137,
	0x1f0237b0, 0x02377f37, 0x05481f30, 0x0108df0f, 0x00130808, 0x20051005, 0x05400305, 0x05020550, 0x40c0ffb8, 0x48131028, 0x1f053605, 0x121b3050,
	0x0f02122b, 0x0b1b0112, 0x0f020b2b, 0x1206010b, 0x220b120b, 0x1018502d, 0x00275122, 0x323f0016, 0x12e13fe1, 0x4b2f3939, 0x3332053b, 0x100132e1,
	0x715d2bc6, 0x5d2f3232, 0x32e110c1, 0x23415d5d, 0x22052506, 0x2627022e, 0x21090f41, 0x29623316, 0x15340807, 0x33161621, 0x37023e32, 0x03030e15,
	0x21070622, 0x03022e34, 0x82b36b35, 0x8e85044b, 0x06950912, 0x1b31310e, 0x98744c0e, 0x6e9e635a, 0x054cfd3b, 0x57339799, 0x0e9b3819, 0x14598208,
	0x81c78846, 0x27726f02, 0x3a0e153f, 0x6c312f22, 0x473e75a9, 0x716eb581, 0x130ab6c1, 0x13a2121d, 0x0308121c, 0x44959cdb, 0x002c5071, 0x3d000200,
	0x06067ffe, 0x2e00cd05, 0x72003900, 0x5a1b4640, 0x35221c1c, 0x670b145b, 0x1f3b0f3b, 0x202c023b, 0x25250125, 0x005b0c34, 0x22802270, 0x220322c0,
	0x600c223a, 0x012e4f34, 0x2e3f2e0f, 0x0f032eaf, 0x2e080128, 0x05282e28, 0x6011141a, 0xfb1b121d, 0x062b422f, 0x33e13f22, 0x42056159, 0x1222162d,
	0x31422f39, 0x11072516, 0x032e1123, 0x2a2a3342, 0x64584e25, 0xc480b63a, 0x42084d8a, 0x0e2d2634, 0x020b1117, 0x730191fe, 0xebb06d10, 0x133a428e,
	0x00027508, 0x0483fe33, 0x005e04b6, 0x0036002d, 0x04304092, 0x0b050547, 0x242d4832, 0x38ff3857, 0xb0389001, 0x381f0238, 0x3102387f, 0x150b4825,
	0x0e010edf, 0x0b00190e, 0x0b200b10, 0x500b4003, 0xb80b020b, 0x2b40c0ff, 0x0b481310, 0x50250b37, 0x2b181b31, 0x180f0218, 0x2b111b01, 0x110f0211,
	0x11180601, 0x2e281118, 0x28101e50, 0x06032d51, 0x00fb0416, 0x33333f3f, 0x41244342, 0x25220539, 0x28410606, 0x1d4c4206, 0x49420120, 0x85042a06,
	0xb64c8042, 0x38638954, 0x1c4d4203, 0x7283fe36, 0xec010b85, 0x3559391b, 0xfe042320, 0x11750195, 0x6fb28454, 0x21195242, 0x4d42f002, 0xff3a0806,
	0x005200ff, 0x05640200, 0x000602b6, 0xff00002c, 0x000400ff, 0x07810600, 0x01260269, 0x010000b0, 0x00360207, 0x005201f4, 0x010b4013, 0x01260517,
	0x11121c00, 0x2b01250a, 0x02820035, 0x05232d85, 0x821706be, 0x86d0202d, 0x0093212d, 0x09af8e18, 0x0e212d82, 0x202d8707, 0x05756300, 0x05e14308,
	0x002500b6, 0x1b3f4067, 0x5b21051b, 0x100a0911, 0x180c400a, 0x040a0a48, 0x27102711, 0x0b022740, 0x5a040808, 0x1f266405, 0x1c161c5f, 0x60000308,
	0x0c5f0c2f, 0x0cff0cef, 0x10400c04, 0x0c0c4815, 0x73630905, 0x12332906, 0x5d2b2f39, 0x3f3333e1, 0x23050f49, 0x5d331132, 0x2905ca71, 0xe1103338,
	0x312f3911, 0x97620130, 0x11332405, 0x52013301, 0x756307a1, 0x46022c0d, 0xba285c41, 0xcf3502ba, 0x5606d1fd, 0x7f370d09, 0x43770148, 0x6f02ae7c,
	0xb0fd0e11, 0x3cfdb605, 0x58fdc402, 0x63eca355, 0xb3220e76, 0xdb823a76, 0xfeae5408, 0x04e9030a, 0x0023004a, 0x0b474072, 0x02081b08, 0x1f102322,
	0x23230123, 0x0d0d051d, 0x0548141e, 0x01250f25, 0x256f255f, 0x259f257f, 0x25df25bf, 0x000725ff, 0x471d2121, 0x2124541e, 0x0b51191c, 0x02001b00,
	0x1e000007, 0x1e0f1f22, 0x0e511115, 0x82001b0a, 0x057648d8, 0x825d5e21, 0x100123e6, 0xe383e1f6, 0x2006fd55, 0x29fe8211, 0x31333871, 0x015d0030,
	0x4f64031e, 0x09926305, 0x63022e21, 0xfb830693, 0x2b022908, 0x4578a35e, 0x57966f3f, 0x2c2f694c, 0x75764369, 0x4e724a23, 0xb4295520, 0xc49801b4,
	0x40056a02, 0x9694d084, 0x1f4088d5, 0x2d059263, 0x2d60976a, 0x50fe0d10, 0x0afe4a04, 0xdd82f601, 0x7ffe0026, 0xb6055605, 0x3a08dd82, 0x0207b173,
	0x40f8ffb8, 0x48171446, 0x18895a02, 0x18101801, 0xb4011de0, 0xd41dc41d, 0x1d00031d, 0x07021d50, 0x0f1f1d1d, 0x00222221, 0x1f20235a, 0xc0259025,
	0x0325f025, 0x821f250f, 0x080333f9, 0x02fb210f, 0x13031d5f, 0x1f130c60, 0x0012005f, 0x0184e13f, 0x5e2f012a, 0xd4105d5d, 0x39e13232, 0x8205356c,
	0x335d2f0e, 0x2be15d38, 0x21303132, 0x030e2111, 0xbc7e0e07, 0x3636250c, 0x21371212, 0x2a05196b, 0x0f85fed9, 0x10212120, 0x184f3514, 0x2c120ab8,
	0xd98fc3d0, 0x711205a5, 0x51d4ebf5, 0xf9b71867, 0x056e4c12, 0xe5820020, 0xfe104108, 0x04660483, 0x0018004a, 0x02384058, 0xe412d446, 0x12600212,
	0x12a01270, 0x340412b0, 0x12120112, 0x1717160a, 0x15184700, 0x201a5514, 0x021ab01a, 0x08011a0f, 0x02fb160a, 0x0d0f1250, 0x1416074f, 0x8306e84a,
	0x20d185d3, 0x25d186f4, 0x5d5d2f39, 0xca84e15d, 0xa0180220, 0xc4840ff8, 0xfefa0239, 0x5f4014fe, 0x311c5682, 0x371c1610, 0x12334559, 0x7ab65402,
	0x18037bb7, 0x250f00a1, 0xe9fd50fc, 0xaf837d01, 0xfee53b08, 0x05f40400, 0x001b00b6, 0x052b404b, 0x0c141005, 0x1d65175a, 0xbf011dc0, 0x1d20011d,
	0x5a0f1301, 0x0e1c6410, 0x01130f5f, 0x10131308, 0x10031115, 0x065f0912, 0x3f001c00, 0x5742e132, 0x10012208, 0x06eb46f6, 0x4332e121, 0x2e210633,
	0x07d96502, 0x11211125, 0x82331123, 0x11332605, 0x02020e14, 0x078e66d1, 0xfdc6bb22, 0x2405c05b, 0xfec99252, 0x06826600, 0x02f7f023, 0x07c95b1f,
	0xaaddfa25, 0x434fa2f8, 0x04230517, 0x824a043b, 0x406924a3, 0x8203031a, 0x473408a3, 0x001d5517, 0x021d201d, 0x1d401d30, 0x1dd01d50, 0x1d051df0,
	0x40c0ffb8, 0x48110e28, 0x10470f13, 0x500e1c54, 0xa90113eb, 0x0213b913, 0x131f130f, 0x0603132f, 0x0f25bf84, 0x51071510, 0x8a4a8204, 0x1d4418bf,
	0x5d2b2207, 0x86c88371, 0x060743c1, 0x35023e22, 0xa02ac18e, 0x2c2f694c, 0x5b3b4269, 0xa15a1f3d, 0x3fb62105, 0x2f088a66, 0x6996612d, 0x17feb201,
	0x39fe4a04, 0xf3fbc701, 0x36068766, 0x057ffee5, 0x00b605b6, 0x4052000f, 0x03030232, 0x045a050d, 0x5d110001, 0xc020071a, 0x5d053350, 0x102f2b20,
	0xe13232d4, 0x332f3932, 0x33253031, 0x5b132303, 0x332609d8, 0x8fc2f404, 0x1e5da6d9, 0x01002917, 0x83feae00, 0x4a04f204, 0x76318d82, 0x0e0d4f40,
	0x4700080e, 0x0bab0c0f, 0x0b020bbb, 0x581c5d11, 0x5dd41022, 0x1c5db188, 0x20bc820c, 0x071c5d03, 0xb67bb723, 0x09eb5b7a, 0x2209a542, 0x4d7ffea6,
	0x592a068f, 0x5a1d2140, 0x00161a1a, 0x824d195a, 0x0e30080c, 0x700b605a, 0xb00ba00b, 0xb80b040b, 0x1440c0ff, 0x0b480a07, 0x065f1116, 0x1b1a0c06,
	0x1a5f1dfb, 0x030c1712, 0x3f333f00, 0x12113fe1, 0x33e12f39, 0x250b7e4d, 0x31e12f32, 0x3f4e2530, 0x0592490b, 0x11331123, 0x21018223, 0xf94ec703,
	0xb0ba2411, 0x4eb001a6, 0x4a2414f7, 0x27027ffe, 0x4d05fb4e, 0x402a0675, 0x471b2540, 0x1c141818, 0x624d1747, 0x470d3308, 0x191d540a, 0x500f14fb,
	0x1b0b0505, 0x15151850, 0x9e840f0b, 0xdf4e9c84, 0xf6102305, 0x9a8432e1, 0xd94e0120, 0x20988312, 0x13da4e33, 0x4ea0b621, 0xfb2514db, 0x0283feb6,
	0x3d978217, 0x067ffec7, 0x00b605f2, 0xb69a001f, 0x39011f36, 0xb81f0100, 0x2c40f8ff, 0x1f480f0c, 0x05820800, 0x0d0d0029, 0x1209100c, 0x830e1313,
	0x0e39340d, 0x151d0e01, 0x1011145a, 0xc0212021, 0x210f0221, 0x830b0801, 0x82102030, 0x0b263f2a, 0x08020b01, 0x2064095a, 0xb80c5f10, 0x1640f0ff,
	0x00481209, 0x15030c09, 0x1efb1212, 0x46820101, 0x0e014824, 0xd982030a, 0x112b332a, 0x173f3f33, 0x01e12b33, 0x5d21d784, 0x07ad452b, 0x5d323223,
	0x05b1452b, 0x3311392b, 0x312b332b, 0x215d5d30, 0x08546d01, 0x33012123, 0x05a44501, 0x11233908, 0x37023e34, 0x01233736, 0x45fe2303, 0x04040508,
	0x1401ac06, 0x01069c01, 0xc314019e, 0xbaa6d990, 0x02020201, 0xfe080403, 0x4a000541, 0x398b3f49, 0xb60596fc, 0xa80458fb, 0x2a059f45, 0x3d197703,
	0x471e4241, 0x4302fb49, 0x70080505, 0x4a04c705, 0x87002400, 0x07085a40, 0x20101818, 0x1e232322, 0x21244600, 0x20bf20af, 0xe0262002, 0x26cf0126,
	0x40263001, 0xa0265026, 0x260f0426, 0x0f120601, 0x25541046, 0x3b01fb22, 0x5b0e4b0e, 0x0e0b030e, 0x0e2b0e1b, 0x1e0e0e03, 0x50200f11, 0x18441834,
	0x05031854, 0x25181518, 0x10080318, 0x15000318, 0x32173f00, 0x3fe15d5d, 0x5d2f3333, 0x05b8505d, 0xf9823220, 0x435d5d21, 0x11210910, 0x38f88212,
	0x21303133, 0x07030e11, 0x2e012301, 0x23112703, 0x1e013311, 0x033e1703, 0x06bb7137, 0x066f0422, 0x142da618, 0x06050e2f, 0x0d16130e, 0xb7d90e01,
	0x037ab67b, 0x31a61881, 0x0554431f, 0x2b12b549, 0x04000000, 0x026907dd, 0x00240026, 0x2005b549, 0x05b54921, 0x051a0228, 0x1f000226, 0x87490415,
	0x263d8208, 0x03ecff5e, 0x821706a1, 0x8244202d, 0x0206322d, 0x0000d436, 0x020b4013, 0x02261138, 0x0c333d25, 0x07b34922, 0x59852b82, 0x59872b20,
	0x006a0022, 0x172c5983, 0x02030d40, 0x0326051e, 0x29150102, 0x95185b85, 0x5d8308fd, 0x19059c21, 0x2d287b14, 0x0000feff, 0xb6055606, 0x88000602,
	0x9d850000, 0x04440623, 0x200f825e, 0x240f84a8, 0x030000c7, 0x20db84c8, 0x21db8528, 0xdb85fbff, 0x05110129, 0x16060126, 0x8a00010c, 0x827120af,
	0x84e120db, 0x854820db, 0x19ea20db, 0x22164107, 0x82000200, 0x053e082b, 0x00cd0512, 0x0029001e, 0x242f4049, 0x670e5b1a, 0x8f2b0f2b, 0xbf2baf2b,
	0x402b042b, 0x25480f0b, 0x6619035b, 0x2f5f252a, 0x7f195f19, 0x19190319, 0x135f1f09, 0x5f000313, 0x3f000409, 0x597133e1, 0x10012a06, 0x2be132f6,
	0xe1f6105d, 0x05734a32, 0x564f3520, 0xa1471807, 0x35520809, 0x03032e21, 0x37023e32, 0x021e1421, 0xcf807902, 0x695a2a5b, 0xf4a04c7d, 0x9d5154a5,
	0xd79996e8, 0xdb033e87, 0xa9734007, 0x6d955b43, 0xedfc0742, 0x058c5526, 0xaa202c29, 0x0a131a0f, 0xe9fec66c, 0xebfeaeab, 0xc46b68c2, 0x46ab1501,
	0x4786c17a, 0x354f66fb, 0x447f2205, 0x20cb8200, 0x22f78266, 0x825e04d7, 0x272d08cb, 0x29404300, 0x05481122, 0x29b02957, 0x01293f01, 0x10194823,
	0x50232856, 0x10af109f, 0x10df10cf, 0x00101004, 0x160a501f, 0x00511419, 0x20c58f10, 0x22c5875d, 0x4a021e32, 0x2e2b0553, 0x21353502, 0x22232626,
	0x8207020e, 0x321322d7, 0x08c28436, 0x6ee7013a, 0x424983b6, 0x6366a778, 0x023b6e9e, 0x979a05b5, 0x4c505733, 0x514c2827, 0x85736057, 0x1b14fe0b,
	0x5e045839, 0x87d28e4a, 0x4e95d688, 0x6eb58147, 0x0ab6c071, 0xa1121c13, 0x09220382, 0x834c25fc, 0x712a0809, 0x1205ecff, 0x26022b07, 0x0000e102,
	0x6a000701, 0x52014600, 0x03b61900, 0x26053302, 0xffb80203, 0x3e2ab4d3, 0x01250e18, 0x6542352b, 0x21ef8408, 0x3382d905, 0x3382e220, 0x6a000624,
	0x318400c4, 0x84113121, 0xb4f42531, 0x050f3c28, 0x0424318c, 0x81060000, 0xd94c6583, 0x20658205, 0x2c6582f4, 0x020d4017, 0x26051b01, 0x12000102,
	0x05db4c26, 0x31826388, 0x83be0521, 0xd0012263, 0x21978500, 0x65830091, 0x11203082, 0xb8253082, 0x12b4ffff, 0x05e14c26, 0x48243388, 0xec03ecff,
	0xb1206584, 0xff213385, 0x22cb84bf, 0x83430102, 0xffb82764, 0x4e3ab4f4, 0x998c0b13, 0x33824420, 0x67845220, 0x3386d120, 0x67865520, 0x67854320,
	0x3382d920, 0x85051c6c, 0x01002267, 0x08678400, 0x00b60564, 0x40720020, 0x1b5b002d, 0x20205b1c, 0x48181040, 0x20201b1d, 0x0d031d1b, 0x67055b16,
	0x01229f22, 0x0d800d70, 0x4f0d3f02, 0x030d5f0d, 0x5f1d200d, 0xffb81b1e, 0x071840f0, 0x191b480d, 0x780100aa, 0x000f0100, 0x00000801, 0x6013031e,
	0x00130a0e, 0x3fe1333f, 0x5d5e2f39, 0x33335d5d, 0x32e1102b, 0x0a822f01, 0xe1f61023, 0x054e5c12, 0x10e11025, 0x4c3031e1, 0x44180b6f, 0x23310897,
	0x35210135, 0xf4011521, 0x4784ba73, 0x89cd8843, 0x44bd186e, 0x7b21080a, 0xa6fda601, 0x3b033d03, 0x97643505, 0x74a06066, 0xaa2d2240, 0x0d182417,
	0x81878794, 0xa6d10197, 0x23d38291, 0x0314fe1b, 0x08054563, 0x3e40643d, 0x201f4a00, 0x4024244a, 0x21481813, 0x1f24241f, 0x180d0321, 0x26570547,
	0x269f266f, 0x01263002, 0x0701260f, 0x110c400d, 0x21240d48, 0x1d1f2250, 0x0c092000, 0x22000048, 0x4d50130f, 0x3924073a, 0x33332b2f, 0x2b20c384,
	0xc59fd083, 0x08965218, 0x3e08c785, 0x7da85fa8, 0xba844749, 0x3ab57373, 0x665b4e1f, 0x56774736, 0x8b633730, 0x92016d54, 0x0603c6fd, 0x4107d501,
	0x6e6ca675, 0x244984b7, 0x1f10a622, 0x572e0f18, 0x7d564e7d, 0x017d2752, 0x18859aed, 0x3d0731bd, 0x2602c106, 0x0000b201, 0x4d010701, 0x5201b000,
	0x01b41500, 0x0126051a, 0xb4feffb8, 0x64181918, 0xae260c9b, 0x3b040000, 0x2f826f05, 0x2f82d220, 0x4d010624, 0x2d830039, 0x83110e21, 0xb4ff252d,
	0x040a0d0c, 0x260ae944, 0x050000c9, 0x872b0710, 0x6a00235d, 0x69429c00, 0x42212006, 0x5f820569, 0x5f852c20, 0x82053542, 0x20618591, 0x226187d9,
	0x42256a00, 0x152005cf, 0x82056742, 0x85202063, 0x24318863, 0x05ecff7d, 0x21658371, 0x9b423200, 0xaa002105, 0x2b053543, 0x05310203, 0x01020326,
	0x000a3c28, 0x250ccd42, 0x04ecff71, 0x6382052d, 0x43520021, 0xf9200599, 0x20059943, 0x05994329, 0x20b4f923, 0x84318e34, 0xcd052a63, 0x7e020602,
	0xffff0000, 0x21418400, 0x0f825e04, 0x0f847f20, 0x1f838388, 0x82070121, 0x298386e9, 0x05330304, 0x01030426, 0x518e3e2a, 0x02208388, 0x01214182,
	0x28318206, 0x40170000, 0x2b03040d, 0x222f8211, 0x8e362200, 0x823b202f, 0x834420b3, 0xc70121e5, 0x6182b382, 0x4197ff21, 0x2e20064b, 0x25054b41,
	0x3925b4a6, 0xe78c0c04, 0xecff3724, 0xe7834203, 0x86e70121, 0x43382033, 0x302006b5, 0x25054d41, 0x3b27b4ca, 0x338c2203, 0x67821920, 0xc106ae26,
	0xbd012602, 0x01233383, 0x4227004d, 0x24210511, 0x05114205, 0x13232222, 0x2a0bcd46, 0x0314fe0a, 0x026f05df, 0x425c0026, 0xbb2d0511, 0x40130000,
	0x1125010b, 0x23010126, 0x47f61824, 0x845b840c, 0x825b84c3, 0x861220f3, 0x852b20c3, 0xb4fd23c3, 0x5d853622, 0x1908dd41, 0x28101713, 0x170000a7,
	0x01020d40, 0x22c2832c, 0x85372301, 0x852f8861, 0x88732063, 0x005322bf, 0x050d4266, 0x2e010222, 0x51206483, 0x06216195, 0x21c18821, 0x61860053,
	0x61832f20, 0x61905a20, 0x0000a623, 0x05a54504, 0x5541c120, 0x54002105, 0x1f206187, 0x0f226183, 0xbb412a16, 0x009a260e, 0x05fe0300, 0x209382d9,
	0x233182e1, 0x066a0006, 0x22206186, 0x08246183, 0x0a172d19, 0x4b098341, 0x4b080543, 0xb605be03, 0x64000900, 0x00140b40, 0x0100e401, 0x020100d0,
	0xc0ffb800, 0x13083540, 0x0b000048, 0x0b4f0b2f, 0x0b8f0b6f, 0x11400b04, 0x5a074818, 0x04cf04bf, 0x01048402, 0x041f040f, 0x04040702, 0x64085a03,
	0x095f020a, 0x075f0303, 0x2006f85c, 0x051a4b3f, 0x5d5e2f34, 0x2be15d5d, 0x2f33115d, 0x5d5d5f2b, 0x01303171, 0x8a4c2115, 0xfdbe2e07, 0xbab0b0c3,
	0xfba6b605, 0x01d9fd96, 0x28838281, 0xfeae0001, 0x040a0383, 0x268d824a, 0x2032404e, 0x82023002, 0x0b2a0800, 0xa1010bc0, 0x0b70010b, 0xbf470901,
	0x0206cf06, 0x0f010684, 0x02061f06, 0x05060607, 0x0a540047, 0x15095005, 0x5004fb08, 0xa6750f01, 0x10012405, 0x8532e1f6, 0x056d5d7a, 0x30315d25,
	0x86211133, 0x02ae2879, 0xa05afe5c, 0x634a04b6, 0xff2d0688, 0x00c700ff, 0x07cf0500, 0x0126022b, 0x066541c5, 0x6541fc20, 0x03042b05, 0x04260527,
	0x321e0003, 0xb9421c06, 0x82ae200c, 0x05502231, 0x203182d9, 0x203186e5, 0x05c941b0, 0x11203182, 0x0a213185, 0x2a318c0d, 0x036dfe2f, 0x02b605be,
	0x839b0226, 0x80032331, 0x3182a600, 0x01b30a2a, 0x01071f1f, 0x35113c10, 0x12208782, 0xfd822382, 0x9c202382, 0x81222384, 0x23878900, 0x23870d20,
	0x6dfe002a, 0xb6059a04, 0x3b002600, 0x80222384, 0x23822303, 0x01b11735, 0xc0ffb81d, 0x481513b2, 0xb49effb8, 0x00001d1d, 0x542b0125, 0x23200595,
	0x11223182, 0x31824a04, 0x31845b20, 0x9a028122, 0x12283182, 0x1d5001b3, 0x9affb801, 0x07212c82, 0x212c8207, 0xbb63355d, 0x82602006, 0x1133085d,
	0x2740b200, 0x0f560f46, 0x59094902, 0x00360209, 0x01063901, 0x000f0906, 0x03030c04, 0x01113001, 0x0701073f, 0x05110711, 0xb80a0b01, 0x0ab3f0ff,
	0x8205040a, 0x14403407, 0x100e0d05, 0x01020e0e, 0x01010010, 0x01800170, 0x820301c0, 0x40c02864, 0x480a0727, 0x50130101, 0x7f3a05c0, 0x00080413,
	0x090f5f06, 0x27010328, 0x0c03010c, 0x0109090a, 0x05030a0d, 0xd8701201, 0x112f2b06, 0x5d5d3939, 0x32e13311, 0x06825e01, 0x2205b161, 0x83382f33,
	0x25038302, 0x39391211, 0x21822f2f, 0x2f3d3926, 0x5d331733, 0x31240082, 0x23010130, 0x21250283, 0x33012135, 0x26028201, 0xc5021521, 0x61d39b01,
	0x9a2605a9, 0x1401dffe, 0xad6192fe, 0x8e400806, 0xb4021c01, 0x7b024cfd, 0xb40285fd, 0xfd5e02a4, 0xfd2f02d1, 0x0100a4a2, 0x00002300, 0x4a04db03,
	0x17011100, 0x0880bf40, 0x08020890, 0x0b000800, 0x0105060f, 0xe50105f7, 0x05360105, 0x07060501, 0x9508f082, 0x1010010d, 0x0103090d, 0xea0103f8,
	0x03390103, 0x6b020301, 0x02067b06, 0x3a010657, 0x02064a06, 0x02740264, 0x01025802, 0x02450235, 0x0d020602, 0x03060d02, 0x010c060f, 0xe5010cf7,
	0x0c36010c, 0x400b0c01, 0x0b481916, 0x48110e40, 0x0b7b0b6b, 0x010b5702, 0x0b4a0b3a, 0x130b0b02, 0x13301310, 0xb0139002, 0x130f0213, 0x010e0901,
	0xea010ef8, 0x0e39010e, 0x0f6b0e01, 0x58020f7b, 0x0f35010f, 0x0f020f45, 0x4f100a0d, 0x01ef0704, 0x1b010b01, 0x5b012b01, 0x9c826b01, 0x02010128,
	0x05150b0f, 0x4c410f02, 0x5d5e2607, 0xe133335d, 0x05bd4832, 0x5d5dc124, 0x0282715d, 0x2fce1022, 0x2b210982, 0x250f842b, 0x3d391712, 0x9461182f,
	0x84102007, 0x33112113, 0x04820183, 0x72410e86, 0x30312305, 0x8e612113, 0x15212205, 0x06704121, 0x01685f08, 0xcfcffe00, 0xfecffafa, 0xfe0401cd,
	0xcf4a01f7, 0xf2fef4fe, 0xfe4a01cf, 0x017b02fb, 0x0166fecf, 0x8931fe9a, 0xb4010efe, 0xf2014cfe, 0x00020000, 0x03000089, 0x00b605f6, 0x0019000e,
	0x06294040, 0x65095a19, 0x011b9f1b, 0x15011b10, 0x1a66005b, 0x063f5f0f, 0x066f064f, 0x06bf069f, 0x008206df, 0x5f190728, 0x03071209, 0x634c3f00,
	0x4be12009, 0x1324079c, 0x33023e34, 0x1125a782, 0x022e2221, 0x05d36a01, 0x33162e08, 0x7f378933, 0xbb9598cf, 0xc28695fe, 0xb2023c7e, 0x5b8a5d81,
	0x9fafa32e, 0x9857ac01, 0x68024271, 0x703d4afa, 0x1b5f019e, 0x8846613c, 0x07674784, 0x14060227, 0x47000602, 0x23a38400, 0x3b06ecff, 0x2108a382,
	0x00320023, 0x183f4063, 0x1a5a3209, 0x5a22111a, 0x0f346501, 0x346f0134, 0x34ef349f, 0x50344003, 0x0e820234, 0x2a063308, 0x3366115b, 0x23175f24,
	0x4f173f23, 0xbf176f17, 0x0517df17, 0x03181717, 0x09602d1d, 0x00130e06, 0xe133333f, 0x2f393f32, 0x102f335d, 0xf61001e1, 0x69185ee1, 0xe12f09e2,
	0x30313239, 0x0e141101, 0x26222302, 0x18030e27, 0x83075647, 0x161428d4, 0x023e3233, 0x87051135, 0x080d83d8, 0x2d3b0653, 0x725e8c5b, 0x3f182b99,
	0xd73f6752, 0xd78a41e4, 0x67bb7a96, 0x33482c61, 0x81bafd1c, 0x2d5b8b5d, 0x5b43867e, 0x50031738, 0x8b5118fe, 0x4d613a66, 0x192e3f26, 0xa367d6d2,
	0x68023c72, 0x6970b2fb, 0x3250391e, 0x1ea6e801, 0x804d6b43, 0x4d3e2582, 0x20f38329, 0x22f38271, 0x8214065a, 0x433d08f1, 0x39405c00, 0x47382c10,
	0x2e012e50, 0x47031b2e, 0x6f455506, 0x9f457f45, 0xef45cf45, 0x45400545, 0x2f450f01, 0x41060245, 0x44561b48, 0x3e330404, 0x10202550, 0x3300002c,
	0x160b1050, 0x22ed8616, 0x18e1333f, 0x21082e4e, 0xf3825d5d, 0xff821120, 0x3932e12a, 0x32253031, 0x33113536, 0x2e23f185, 0x52232702, 0x3a6b0616,
	0x33172506, 0x26262726, 0x1e222083, 0xef822103, 0x35373708, 0x23022e34, 0x14150622, 0x6fd30416, 0x5c2fb662, 0x67415b8b, 0x06173d51, 0x795b441b,
	0x6e9a5d51, 0x9a6e3c3c, 0x4d603b5d, 0x030c173b, 0xb6040203, 0x512c0f01, 0x7e7ea6fd, 0x7f873e08, 0x8282837f, 0xc1fe3501, 0x2e629869, 0x2c4a361e,
	0x20374a29, 0x8cd48f48, 0x4990d58d, 0x05937e1a, 0x11366d08, 0x92fbb401, 0x2d4e6a3e, 0x5f8c5e2e, 0x6b9d6529, 0xd1ccda37, 0x010000cd, 0xecff4e00,
	0xcb054406, 0x85003f00, 0x5b0d5640, 0x2b5b0020, 0x20072025, 0x07202b2b, 0x5a331603, 0x7f416536, 0x9f418f41, 0xff41ef41, 0x41000541, 0x41304120,
	0x80167003, 0x163f0216, 0x1602164f, 0x06254016, 0x34000760, 0xdf343401, 0x07aa0107, 0x01077801, 0x2805006b, 0x3b5f301b, 0x60121513, 0x09404f1b,
	0x825d5e21, 0x2f332700, 0x39e1105d, 0x07820111, 0x2705714c, 0x2f391711, 0x39122f2f, 0x2706724c, 0x23022e34, 0x32333523, 0x2106a54b, 0xaf180622,
	0x07230bc9, 0x7f031e15, 0x644106a9, 0x033a080a, 0x92653529, 0x5cb0bf5d, 0x2532618e, 0x6e3a5f44, 0x265c4ba9, 0x47837462, 0x3971a66d, 0x4b7d5b33,
	0x325e8a57, 0x374f3218, 0x38b7626f, 0x57599166, 0x013c6c94, 0x466d4d87, 0x5d189721, 0x74080ad5, 0x1829361f, 0x4f856136, 0x3958774a, 0x390b060c,
	0x4a487759, 0x771e4168, 0xfec90181, 0x6298692d, 0x9c642f2e, 0x00010000, 0x05ecff50, 0x005e04a2, 0x4081003b, 0x00471523, 0x36314620, 0x31001931,
	0x00311919, 0x47082703, 0x0f3d550b, 0x3dd0013d, 0x013dbf01, 0x27013d30, 0x40c0ffb8, 0x48151229, 0x2701275f, 0x19363c27, 0x09091a50, 0x99011adf,
	0x021aa91a, 0x06907d0b, 0x2326052e, 0x05102c50, 0x00161050, 0xe13fe13f, 0x23056673, 0x2f335d5d, 0x20072a41, 0x0752432b, 0x2f391725, 0x41112f2f,
	0x1423082d, 0x4233021e, 0x35220c70, 0x3e412634, 0x23262108, 0x31113d41, 0x31155203, 0x60693b50, 0x8f5f2fb6, 0x64905c60, 0x5d188535, 0x28360c3b,
	0x355a524d, 0x3a699056, 0x2b46331c, 0x223c5332, 0x49274c01, 0x61422138, 0x542b2309, 0x5d184f7b, 0x13240b10, 0x2609131d, 0x088bbb18, 0x3e290939,
	0x01000052, 0x7ffe4e00, 0xcb059c04, 0x83003100, 0x5b0f5440, 0x82220927, 0x184a0801, 0x2e705a01, 0x2e022e80, 0x2f5a002e, 0x3300332f, 0xd033c001,
	0x339f0233, 0x20330001, 0x03333033, 0x18801870, 0x4f183f02, 0x18180218, 0x27fb3032, 0x09df6008, 0x0109aa01, 0x0f010978, 0x09080109, 0x14170109,
	0x2e041d60, 0x4f5a015f, 0x07264105, 0x39e15d23, 0x0750423f, 0x11715d36, 0x32e12f33, 0x12e15d2f, 0x2f2f3939, 0x31e13912, 0x11232130, 0x29215542,
	0x23113315, 0x38bbec03, 0x49429567, 0xb0b0271f, 0x6443a001, 0x3c422041, 0xfdfa381e, 0x000100d9, 0x0383fe50, 0x005e04f2, 0x408d002d, 0x1d460c1a,
	0x82061d22, 0x13230801, 0x29294700, 0x2a20472d, 0x2a402a30, 0x2a042a60, 0x40c0ffb8, 0x48130f0e, 0xc02f2a2a, 0xe02fd02f, 0x8313032f, 0x2d2a0812,
	0x5f481512, 0x13130113, 0x22fb2b2e, 0x06df5005, 0xa9069901, 0x064f0206, 0x0b02065f, 0x02061b06, 0x00060607, 0x18500f12, 0x925a2910, 0x08144107,
	0x1441e920, 0x05a44a06, 0x32e15d23, 0x0712412f, 0x31e11025, 0x42112130, 0x15281e28, 0x23113315, 0x819c0211, 0x29191f42, 0x263f522c, 0x2b01b7a0,
	0x5f18655e, 0x0f420920, 0x2c0e250d, 0x913d5b42, 0x0807c75a, 0xe9ff0077, 0xb605ec06, 0x92003100, 0x06d76540, 0x060206e7, 0xd7010107, 0x0201f701,
	0x171c5a01, 0x48181010, 0x1701178b, 0x480e0710, 0x5a311c17, 0x011eb01e, 0xb4011ce0, 0xd41cc41c, 0x1c00031c, 0x1c901c50, 0x07041ca0, 0x1e1c1e1c,
	0x275a240e, 0x334f3365, 0x337f336f, 0x33af339f, 0x200633df, 0x330f0133, 0x25250e01, 0x1c5f0112, 0x60122103, 0x00130b2c, 0x32e1333f, 0x20f7823f,
	0x07df502f, 0x39391122, 0x2f060862, 0x3311e110, 0x102b5d2b, 0x32715de1, 0x0130315d, 0x20187b5c, 0x47821814, 0x020e2708, 0x022e2223, 0x885c0335,
	0x6e63211e, 0x22076844, 0x5c3a6892, 0xfb231a91, 0x447781d1, 0x4d08095e, 0x6c99602c, 0x00010000, 0x06ecff10, 0x004a0400, 0x405c0028, 0x11460139,
	0xa0134728, 0x11db0113, 0x0111c401, 0x11a01190, 0x01112402, 0x11011110, 0x09131113, 0x551e471b, 0xcf2a7f2a, 0x032aef2a, 0x0c1c1c09, 0x0f115001,
	0x234f0c18, 0xf98c1606, 0xe1f61022, 0xac6af784, 0x06684505, 0xa05c2120, 0x114d4411, 0x4414ae5c, 0x91220b41, 0xb95c3666, 0x3dfd2510, 0x20416241,
	0x23093344, 0x6996622e, 0xc728d983, 0x2d07ecff, 0x1d00b605, 0x3724d982, 0xa05a131b, 0x3108ed82, 0x5a061700, 0xc01f6509, 0x1faf011f, 0x20021fbf,
	0x1f0f011f, 0x5a161a01, 0x151e6417, 0x07071a5f, 0x08011a0f, 0x1c171a1a, 0x12170318, 0x130e5f03, 0xd25c3f00, 0x076e4808, 0xd6833220, 0x22088247,
	0x41013031, 0x1c5c10b0, 0xd5043709, 0x636e6f62, 0x906638b6, 0x68915859, 0xba66fd3a, 0xba9a02ba, 0x88418701, 0x2d01210f, 0x080bab78, 0x06ecff37,
	0x004a048b, 0x406c001f, 0x471a0247, 0x0d1e0505, 0x21551047, 0x21202100, 0x50214002, 0x90218021, 0xf021b021, 0x210f0621, 0x471d0101, 0x1c20541e,
	0x0e0e0150, 0xc1bd18eb, 0x031e2910, 0x151e0f1f, 0x1615500a, 0xe745c78a, 0x5d012005, 0x7120059f, 0xe121c885, 0x5dc78232, 0xe145058f, 0x21353b10,
	0x01112311, 0xb6210264, 0x3b503115, 0x2fb65f6a, 0x5b608f5f, 0xfd366692, 0xd35cb6df, 0x13804105, 0x17fe6e22, 0x3808c282, 0x7d000100, 0x5205ecff,
	0x2a00cb05, 0x29404700, 0x290c2a2a, 0x4014015b, 0x14480e09, 0x2c670114, 0x70012cbf, 0x5b1f012c, 0x2a2b660c, 0x2400005f, 0x11155f1a, 0x075f2404,
	0x25af8313, 0x3912e133, 0xa883e12f, 0x105d5d27, 0x2b2f32e6, 0x82108310, 0x152121a8, 0x0ca15e18, 0x32332427, 0x2e071716, 0x05d74903, 0x021e5408,
	0x023e3233, 0x17032135, 0x8e423b02, 0xf29d9cde, 0xb65f56a6, 0x6fab0b01, 0x244858cc, 0x2e5d5853, 0x427fbc7a, 0x75ab7036, 0x295d956c, 0xf60288fe,
	0xfefea856, 0xc3695baf, 0xacae1701, 0x69c31601, 0x11a22a2c, 0x510e171e, 0x8289da98, 0x42569cd8, 0x8264a677, 0xff7131c7, 0x047b04ec, 0x0028005e,
	0x285a4081, 0x47270c28, 0x0c21c782, 0x08c78311, 0x142a574b, 0x022a242a, 0x2af42ae4, 0x012ad002, 0x502a4002, 0xa02a802a, 0x052ac02a, 0x560c481d,
	0x00502829, 0x48191540, 0x00db00cb, 0xa90300eb, 0x0200b900, 0x009f008f, 0x1b000b02, 0x03002b00, 0x22000006, 0x11155018, 0x07502210, 0x21f88816,
	0x00825d5e, 0xfe852b20, 0x5d5d5f23, 0x0f014171, 0x21061c44, 0xef823e34, 0x4957fe82, 0x05ac4805, 0xfe823e20, 0x7b024508, 0x78390002, 0xcb8781ba,
	0x954c4488, 0xad6f8fdb, 0x943c3e4d, 0x6595615b, 0x87562934, 0x4a74515e, 0x02b8fe23, 0xc882444a, 0x934f4789, 0xd38284d3, 0x27255094, 0x3a291d8d,
	0x5d629d6d, 0x2d3e709b, 0x00447050, 0x1420f782, 0x3508f782, 0x00b605c9, 0x40650019, 0x095a062f, 0x1b4f1b65, 0x1b9f1b7f, 0x00041baf, 0x18af011b,
	0x840218ef, 0x18180118, 0x40135a00, 0x150f0115, 0x15150801, 0x13671357, 0x53461377, 0x07102c05, 0x1913480a, 0x07165f15, 0x43031607, 0x39210752,
	0x053f552f, 0x490a9074, 0x4e43059d, 0x21352a15, 0x71022115, 0x626e6f62, 0x054a43b7, 0xfe3a6927, 0xfefe035e, 0x1149435f, 0x6d950321, 0xb58205df,
	0x046f3c08, 0x001b004a, 0x0d4a406d, 0x1d551047, 0xcf011d0f, 0xff1def1d, 0x1d30031d, 0x1d601d40, 0x1f1d0f03, 0x030f021d, 0x0103cc01, 0x03bf030f,
	0x03030602, 0x601a4705, 0xd0007000, 0x821f0300, 0x00003df9, 0x021a101a, 0x010e0e1a, 0x1615500a, 0x01500004, 0xe13f000f, 0x11e13f32, 0x2f012f39,
	0x4a75ba82, 0x5d5e2305, 0x2e49715d, 0x30312206, 0x20aa8313, 0x11d84411, 0x0329113a, 0x15c1fe35, 0x693b5031, 0x5f2fb75f, 0x925c608f, 0xb0033666,
	0xd7fd9a9a, 0x2111bc44, 0x7d823502, 0xc1826f20, 0x050c4308, 0x003900cb, 0x5b13b45d, 0xb8001a34, 0x2e40c0ff, 0x00481a17, 0x2f1a001a, 0x3b270a0a,
	0x20013b9f, 0x3a662f5b, 0xaa601b34, 0x18780118, 0x01180f01, 0x05181808, 0x2a266023, 0x0b600e13, 0x3f000405, 0x0282e133, 0xa482af82, 0x39e15d34,
	0xe1f61001, 0x32ce105d, 0x3939122f, 0x122b2f2f, 0xb182e139, 0x023e3426, 0x021e3233, 0x210c7f77, 0x244d1533, 0x79362008, 0x2e22050e, 0x28823502,
	0x35376308, 0x3b9c032e, 0x486da973, 0x265a697b, 0x67a24b5c, 0x26445f39, 0x5782572c, 0x925dbfc3, 0xa4aa3565, 0x5353cc6c, 0xc38080c0, 0x5f314283,
	0x784a5789, 0x60042d54, 0x3661854f, 0x1f362918, 0x1e43367d, 0x3e36533a, 0x97274864, 0x43654321, 0x2b318e89, 0x3c2526aa, 0x48609c6f, 0x0b3d5e7b,
	0x58390c06, 0xfb820077, 0xecff5c30, 0x5e046a03, 0x6d003700, 0x1e4632b4, 0xfb832301, 0xfb823d20, 0x01233908, 0x2b180123, 0x39d0390f, 0x39f039e0,
	0x01398f03, 0x05013940, 0x38561847, 0xef50021d, 0x37a90137, 0x0f0237b9, 0x2f371f37, 0x37060337, 0x502f0a37, 0x0a10282c, 0x16130f50, 0x20060a41,
	0x05845812, 0x25060a41, 0xce105d5d, 0x0b411132, 0x15012409, 0x43062223, 0xf78f0743, 0x3321ff83, 0x066a4332, 0x83082585, 0x8a819e02, 0x60462985,
	0x57613337, 0xaf3c1e4d, 0x6ba26e73, 0x59432835, 0x35492b30, 0x90693a1e, 0x50a25a56, 0x47834b3f, 0x44266d66, 0x8702395f, 0x335e5b99, 0x0e122a45,
	0xa2101e16, 0x5630281d, 0x5b3d4778, 0x0b0d2940, 0x4d3b290e, 0x4a6d4632, 0x93272526, 0x4d4d2622, 0x1227402d, 0x00ffff00, 0x056dfe00, 0x02b6052f,
	0x00b50126, 0x03070100, 0x00b80380, 0xb40d0000, 0x31310101, 0x3c100100, 0x35003511, 0x10262783, 0x4c046dfe, 0x27824a04, 0x2784d520, 0x82028121,
	0x21278407, 0x278b2626, 0x98fe0026, 0xbc05dd04, 0x2208cf5d, 0x82d30467, 0x40132a4f, 0x1418020b, 0x15000227, 0x0dcf5d1b, 0x1898fe21, 0x220cc384,
	0x866f0467, 0x1736262d, 0x330d0227, 0x12d15d39, 0x5b88e120, 0xd1046622, 0x26054f5d, 0x26051b02, 0x5e2a2102, 0x9c22112b, 0x2d828f06, 0xb1834420,
	0x04660223, 0x255b8675, 0x02261139, 0x2d5e4836, 0x87d12013, 0x7703235b, 0x5b82cb04, 0x03b6192d, 0x26051502, 0xffb80203, 0x861db4ff, 0x0853565f,
	0xecff5e26, 0x7f064704, 0x33826187, 0x59548920, 0x02032305, 0x34821133, 0x863b3321, 0x82318863, 0xdd04221e, 0x20658907, 0x20658878, 0x2165871d,
	0x955e1d25, 0xff12240e, 0x8a9c03ec, 0x04782165, 0x3b206588, 0x43216584, 0x0525413b, 0x0821658d, 0x20cb884a, 0x22cba679, 0x88f80606, 0x897920cb,
	0x21cb9b65, 0x65886208, 0xcba27a20, 0xcb835e20, 0x88100721, 0x8e7a2065, 0x410b20cb, 0xfe251131, 0x07dd0498, 0x2a658573, 0x4b012700, 0x52011f00,
	0x42020701, 0x25310557, 0x2d031040, 0x15022714, 0x00032605, 0x0704302a, 0x0ca94125, 0x00352b24, 0x5955352b, 0xfe5e2605, 0x069c0398, 0x25798521,
	0x4b012600, 0x458400d4, 0x00006f2b, 0x16402200, 0x27174b03, 0x27e88302, 0x0c4e480d, 0x25022522, 0x42868887, 0x82ffff21, 0x04002427, 0x881308dd,
	0x847b20ef, 0x401725ef, 0x2602030d, 0x02237e82, 0x41212900, 0xed840eb9, 0x88c10621, 0x047b22ed, 0x071f427b, 0x26114427, 0x471e0203, 0x14b9413f,
	0x7c206389, 0x7c2063b0, 0x582063a6, 0x7d20c788, 0x1a206389, 0xe742c784, 0x9c032313, 0xc7880607, 0x63897d20, 0xc7843820, 0x2311b541, 0xdd040000,
	0x200a1b42, 0x4263a67e, 0x7e200919, 0x5021638f, 0x0f2b415e, 0x0498fe25, 0x425b07dd, 0x4e240819, 0x6d012100, 0x27081942, 0x03164022, 0x0227142e,
	0x0026d283, 0x0704312b, 0x4c620225, 0x09d34108, 0x98fe5e26, 0xee059c03, 0x20081542, 0x0e15424e, 0x27174c23, 0x22e28302, 0x824f490d, 0x1e02217d,
	0x89076262, 0x82c72041, 0x05be2241, 0x214182b6, 0x51420028, 0x44aa2005, 0x01270565, 0x0127140f, 0x61120c03, 0x2d820de3, 0x5e04e122, 0x48202d82,
	0xbe202d86, 0x02212d85, 0x2469822b, 0x052e2830, 0x0a275d0f, 0x0000c726, 0xe107be03, 0x66225b88, 0xef449104, 0x12012605, 0x0d012605, 0x133f6221,
	0x5b888f20, 0x98046622, 0x2e265b86, 0x2d022611, 0x5b92283d, 0x5b873520, 0xff520123, 0x235b82d4, 0x1401b415, 0xb8255a82, 0x15b4fbff, 0x25b98d23,
	0xe103ecff, 0x5d86e305, 0x5201062a, 0x130000de, 0x30020b40, 0x1e225b82, 0x5b8f3f31, 0x075c0423, 0x235b87d1, 0x9e047703, 0x19245b82, 0x0c0102b6,
	0x2007cf5b, 0x44bb8614, 0x712008b3, 0x24084b45, 0x01000048, 0x0b4b4507, 0x26112825, 0x19030203, 0x8807bb35, 0x00272431, 0x8abe0300, 0x88782065,
	0x27c28265, 0xffb80102, 0x141cb4fd, 0x3388c385, 0xc5831220, 0x867f0621, 0x030721c5, 0x820a4b45, 0x216582c8, 0xc9853038, 0xc7263188, 0x1b040000,
	0xcb884a08, 0xcba67920, 0x85054b45, 0x0a4b45cb, 0x6582cb96, 0x08be0323, 0x20658862, 0x20cba27a, 0x21cb8371, 0xcb881007, 0x970a4b45, 0x98fe25cb,
	0x7307be03, 0x00256585, 0xff4b0127, 0x064b45f1, 0x0000aa3a, 0x10402500, 0x27142402, 0x26050c01, 0x27210302, 0x01250001, 0xb4fdffb8, 0x4507a941,
	0x71200a4b, 0xe1224782, 0x79852106, 0x01260024, 0xf942de4b, 0x40222709, 0x17400316, 0xe8830227, 0x433d1c25, 0x41250f05, 0x354309ba, 0x00522609,
	0x07640200, 0x214182e1, 0x3b83002c, 0xb0036622, 0x200ad942, 0x0ed94213, 0x23826220, 0x8f06d722, 0xf3202d82, 0x5e202d86, 0x132aaf82, 0x0a010b40,
	0x13012611, 0xa9420419, 0xfe52260c, 0x05640298, 0x225b88b6, 0x82be0367, 0xb415232d, 0xdc820f01, 0xffffb823, 0x0e9343b4, 0x98fe9e26, 0xe5057501,
	0x4c202f82, 0x67225d84, 0x2f846d03, 0x82150221, 0xffb827c6, 0x1812b4fe, 0x95430c04, 0xfe7d260a, 0x05710598, 0x202f82cd, 0x212f8532, 0x8d855c05,
	0x142b0228, 0x28000227, 0x075f0a2e, 0xfe71260b, 0x042d0498, 0x822d825e, 0x070125f3, 0xb2046702, 0x23205d85, 0xff235d84, 0x8c2620b4, 0x0531602f,
	0x5d88e120, 0x4e056622, 0x27051941, 0x26052e02, 0x283d1502, 0x71262d8c, 0x2d04ecff, 0x5d888f06, 0xa4046622, 0x26268b86, 0x13022611, 0x2d8c2035,
	0xd1205b85, 0x03235b87, 0x5d580577, 0x0328053b, 0x26052802, 0x30050203, 0x95435d86, 0x0668220c, 0x235f877f, 0xaa047703, 0x19255f82, 0x200203b6,
	0x24308211, 0xb4faffb8, 0x61638628, 0x65890e77, 0x65897820, 0x65843020, 0x5f303821, 0x33200e07, 0x6589c584, 0x65887820, 0x65872820, 0xcb849990,
	0x884a0821, 0xa47920cb, 0x062d22cb, 0x20cb88f8, 0x21cba779, 0x65886208, 0xcba07a20, 0xcb837120, 0x88100721, 0xa37a2065, 0x98fe25cb, 0x73077105,
	0x00256585, 0x004b0127, 0x059743ae, 0x005c0522, 0x2d059d48, 0x02271440, 0x03260528, 0x0a433d00, 0xa8412500, 0x09514309, 0x98fe7126, 0x21062d04,
	0x00247785, 0xfb4b0126, 0x20059343, 0x314182b2, 0x03094028, 0x02271738, 0x03261120, 0xb5ffffb8, 0x44833b35, 0x890bbc41, 0xff7d2447, 0x832506ec,
	0x5f02228b, 0x23418200, 0x06017600, 0x28067f42, 0x02260541, 0x133b3502, 0x0db36801, 0x83f40421, 0x60022175, 0x06342d82, 0x00507600, 0x02b41500,
	0x0226113a, 0xb4ebffb8, 0x190a332d, 0x5b8f2d8a, 0x54004322, 0x2f825b82, 0x5a823520, 0x51ffb825, 0x9c353bb4, 0xd843215d, 0x2e205d84, 0xd7235d84,
	0x422d34b4, 0xb9820fdd, 0x2602e122, 0x0220b985, 0x23053943, 0x3c02b415, 0xbc225d84, 0x5d934ab4, 0x2f828f20, 0x0721bb83, 0x053b4302, 0x34202f82,
	0xb0235f84, 0x922d42b4, 0x873520bd, 0x20b9825f, 0x20bd857d, 0x235f843d, 0x4c3eb496, 0x0521bd91, 0x235f86e3, 0xe2520106, 0x2d20bd84, 0xfd235d84,
	0x8d4436b4, 0x98fe25bd, 0x14062506, 0x6723bd88, 0x84005c05, 0x1438272f, 0xffb80227, 0x7941b4a7, 0x98fe250f, 0xf204f404, 0x5744bd88, 0x17302108,
	0x9b202f83, 0x200f7b41, 0x2e2f82b8, 0x02b805dd, 0x00380026, 0x02070100, 0x442f0567, 0x01280529, 0x0127141b, 0x0b1e1800, 0x200bb544, 0x222d82a4,
	0x824a0408, 0x8558202d, 0xb804212d, 0x012b8d84, 0x0127171e, 0xb4feffb8, 0x410c211b, 0xb8260bd9, 0xdd04ecff, 0x5d88e107, 0x1d056622, 0x27053542,
	0x26051e01, 0x182d1101, 0x2d825d8d, 0x8f060822, 0x66225d88, 0x8b86a604, 0x26112126, 0x1b300e01, 0x06235b8f, 0x8273074e, 0x426120e9, 0x00210591,
	0x235b82c5, 0x3101b415, 0xb8275a82, 0x25b490ff, 0x4208182b, 0xa4260a65, 0x7905ecff, 0x2f822106, 0x2f826220, 0x76000628, 0x11000060, 0xb68201b1,
	0x28b49f25, 0x84210c2e, 0x0035272a, 0xb800ffff, 0x598cecff, 0x3d004322, 0x25205985, 0x08235984, 0x9c252bb4, 0xa3432159, 0xfe245986, 0x282eb4e2,
	0xe1205991, 0x0220b387, 0x85050f41, 0xb4592285, 0x8456873a, 0x20af8585, 0x21af868f, 0x0d410207, 0x222b8505, 0x923db456, 0x87352057, 0x491e1957,
	0x842d2009, 0xb44723b1, 0xb1913c2e, 0x86e30521, 0x0106235b, 0xb186f352, 0xb44eff24, 0xb18c3f31, 0x0698fe25, 0x8814064e, 0x051f42b1, 0x01b41529,
	0x01271428, 0x4148ffb8, 0xfe251065, 0x04790598, 0x20b588f2, 0x07214267, 0x83172b21, 0x4145202f, 0x7f4d096a, 0xfe002a05, 0x05370498, 0x002602b6,
	0x0651423c, 0x51427f20, 0x840c2005, 0xb4ff255f, 0x02070f09, 0x260ac541, 0x0314fe0a, 0x654a04df, 0x0724067d, 0x8b056702, 0x11292f82, 0xb80101b1,
	0x23b43201, 0x05de6529, 0x82059b50, 0x37042318, 0x5b88e107, 0x71046622, 0x26067d42, 0x0126050f, 0x91091e14, 0x8f062159, 0x66225988, 0x7d424a04,
	0x11292106, 0x38212d82, 0x0c9b6623, 0x35205b85, 0x01235b87, 0x86b3ff52, 0x8211205b, 0x1201225b, 0x215b9120, 0x3366e305, 0x8c522808, 0x40130000,
	0x822b010b, 0x2c012259, 0x26598c3a, 0x04bcfe71, 0x8214069e, 0x00d3282b, 0x00070100, 0x82b40042, 0x0e56086c, 0xff0200b9, 0x393ab4d2, 0x0125230b,
	0x0200352b, 0xd904dbfb, 0x2106bafe, 0x1b000d00, 0x19402d00, 0x070e0e14, 0x01005040, 0x004f003f, 0x07150002, 0x0f0f8092, 0x02015f01, 0x5d2f0001,
	0x32ed1a33, 0x5d5d2f01, 0x2f39cd1a, 0x013031cd, 0x27032e23, 0x031e3335, 0x09880517, 0x64bafe32, 0x3f4d5123, 0x2a10c610, 0xfe15302f, 0x52236496,
	0xc7200d82, 0x042d0d84, 0x58531cd9, 0x23151b51, 0x1d4c5150, 0x080b8a1b, 0xfc020042, 0xffd9046a, 0x007f06be, 0x001c0010, 0x0d314052, 0x1710040c,
	0x2f401701, 0x4f1c3f1c, 0x041c031c, 0x002f1c04, 0x008f005f, 0x0004009f, 0x1b1608c0, 0x0c7f041b, 0x0c020c8f, 0x080f0080, 0x0802085f, 0xcc229d84,
	0x9882325d, 0x1a2f012a, 0x39395dcc, 0x2f182f3d, 0x5d23a982, 0x83333311, 0x262634aa, 0x07060627, 0x36363523, 0x16163337, 0x033e2717, 0x83153337,
	0xfe3c0811, 0x6c3364d9, 0x336a3634, 0x30753365, 0x337430c0, 0x1d21144e, 0x2db4101d, 0x0465376a, 0x305422d9, 0x1b225430, 0x4545843b, 0x19c23b84,
	0x21342e2d, 0x2b673c15, 0x89fb0200, 0xddfed904, 0x4a2fb186, 0x03042a40, 0x01161f0c, 0x0c1c4016, 0x822f1c0c, 0x088f3392, 0x0804089f, 0x121600c0,
	0x037f0c12, 0x0302038f, 0xaa8a1080, 0xaa8fcd20, 0x86cd1a21, 0x21a086a9, 0xb1862315, 0x08833720, 0x1e333528, 0x6ffc1703, 0xa1847433, 0x6a336434,
	0x336b3536, 0x38644d64, 0x10b42d6a, 0x14201e1d, 0xa285f404, 0xb0851b20, 0x672bc329, 0x3421153c, 0x41192d2e, 0x2008065b, 0x00f8067d, 0x00280010,
	0x1638405e, 0x06201919, 0x1c19480e, 0x232f8011, 0x234f233f, 0x04042303, 0x0c5e4123, 0x1f191925, 0x41181826, 0xcc241862, 0x33113932, 0x230d6641,
	0x112b3932, 0x36136741, 0x020e1413, 0x27230707, 0x34353636, 0x06222326, 0x36363507, 0x41163233, 0xa4331074, 0x192e2214, 0x370a5606, 0x162b3941,
	0x260b0b27, 0x4164631f, 0x01330e7d, 0x1e2b1d76, 0x83510615, 0x25251f09, 0x52030319, 0x82450303, 0x232682dd, 0x1007e9fe, 0x2c2bdd82, 0x3b406100,
	0x0c0c0304, 0x41282800, 0x003a0982, 0x001a1ac0, 0xcf8e1627, 0xef1fdf1f, 0x401f031f, 0x1f480d09, 0x198e241f, 0x98411111, 0x2f322816, 0x2f33e133,
	0x82e15d2b, 0x2f332ce3, 0x5dcc101a, 0x39112f32, 0x83332f3d, 0x0f9e41e0, 0x2e220123, 0x2dd78302, 0x33033e23, 0x33021e32, 0x33373632, 0xaa41030e,
	0xbe013410, 0x40454724, 0x0e2a281c, 0x301d055d, 0x4a252a41, 0x821a3e45, 0x055c240d, 0x4141301c, 0x012a0ebc, 0x1c221c5a, 0x5130322a, 0x0882213b,
	0x83312b21, 0x82002008, 0x04733be9, 0x06cdfed9, 0x000b00c1, 0x4032001f, 0x0b800619, 0x0c2f1f0b, 0x15c00c01, 0x0a820514, 0x1a801436, 0x115f110f,
	0x2f001102, 0xcd1a335d, 0xcc2f3232, 0x1a332f01, 0x3926bd82, 0x31cd1a2f, 0xf2420130, 0x0e252808, 0x26222303, 0x821e3327, 0x023e27b2, 0x145efd37,
	0xf1421e20, 0x01260806, 0x4d2b056f, 0x9192466e, 0x1b046c06, 0x242c4430, 0x05213341, 0x2c19f805, 0x1521352e, 0x062c673c, 0x2645633c, 0x19197e8c,
	0x02210845, 0x29958bfc, 0x051e4038, 0x13400b80, 0x9a8a4816, 0x1f000022, 0xcd209a91, 0x2b209a88, 0xe4429b84, 0x8e172008, 0x42d1209b, 0xfc2009e3,
	0xdd2a9a93, 0x153c672c, 0x2c2e3521, 0x9a8e1519, 0x2c073141, 0x13000607, 0x42002a00, 0x1c192140, 0x288a821c, 0x2f132525, 0x09000100, 0x2e0e8208,
	0x1bc02822, 0x8008131b, 0x5f050f0e, 0x41050205, 0x39220639, 0xe2421a2f, 0x41332006, 0x0d84053d, 0x01303122, 0x27209b8d, 0x2411db42, 0xfe163233,
	0x20a692cd, 0x06de422b, 0x3941382c, 0x0b27152c, 0x63643a15, 0xaf8de305, 0x2b1d9632, 0x2906141f, 0x2520095a, 0x03031825, 0x00450652, 0x2d0add42,
	0x002f0013, 0x1c274048, 0x2a081d1d, 0xc0842b2b, 0x0809c030, 0x22cf192a, 0x22ef22df, 0x1c272203, 0xc7901414, 0x332f3227, 0x325dcd33, 0x066b4132,
	0x11230e82, 0x91332f33, 0x14c242c7, 0x2f20c794, 0x8f1ac542, 0x425020d0, 0x013b13c5, 0x42fe3100, 0x00007101, 0x18001400, 0x800f0940, 0x02080800,
	0x00020b12, 0x82332f2f, 0x332f2ea6, 0x3031cc1a, 0x33273417, 0x1415031e, 0x947b1806, 0x363a0808, 0x1a818bdb, 0x651e2f39, 0x1a401d64, 0x22192d0e,
	0x8569ee34, 0x4b403413, 0x08685a2a, 0x05047108, 0x0001002b, 0x016dfe10, 0x00a60077, 0xb6120011, 0x0d100109, 0x0000fa06, 0x56833f2f, 0x0879c420,
	0x06fe7a07, 0x35362208, 0x01770111, 0x3f59391a, 0x0e163f26, 0x322e223b, 0x42d9fea6, 0x11244666, 0x0e079609, 0x3c013131, 0x204f8800, 0x224fb49a,
	0x8be5fe9a, 0x3034084f, 0x00020000, 0x0414fe71, 0x005e0402, 0x003e0010, 0x2d21403b, 0x47063e2c, 0x1040552f, 0x480e0140, 0x3f562136, 0x1b325039,
	0x0b2c0f2e, 0x16102650, 0x161c5000, 0x2f058174, 0xe13f3f33, 0xc4f61001, 0xf6105de1, 0x323232e1, 0x0667ca82, 0x3405250d, 0x37363736, 0x22103667,
	0x41113337, 0x3e240a40, 0x35023502, 0x220b0367, 0x8201a001, 0x17042500, 0x3c604d3a, 0x32093467, 0x08173c4c, 0xe8eb931b, 0x4545b077, 0x69466cbf,
	0x67832347, 0x772a0c00, 0x1a172d0c, 0x2e3c231d, 0x3067481a, 0x2d1b3506, 0xfb94223e, 0x24eaeea2, 0x2e28a622, 0x4470502d, 0x1400ffff, 0x1237e982,
	0x2602b605, 0x00003700, 0x7a000701, 0x00002201, 0x01b60b00, 0x511c1b03, 0x2582064c, 0x14fe2126, 0x46058f02, 0x57202582, 0x00212585, 0x05a148be,
	0xf6ff012b, 0x101e25b4, 0x2b012506, 0x24118235, 0x004a011b, 0x83078201, 0x82342002, 0x240b8504, 0x000a0001, 0x24178634, 0x00070002, 0x240b863e,
	0x00150003, 0x200b8645, 0x24238a04, 0x000c0005, 0x2417865a, 0x00090006, 0x240b8666, 0x004e0007, 0x240b866f, 0x00140008, 0x240b86bd, 0x0067000a,
	0x240b86d1, 0x012e000d, 0x230b8638, 0x012a000e, 0x12203b87, 0x03245f84, 0x09040100, 0x68239782, 0x85009001, 0x0001240b, 0x86f80114, 0x0002240b,
	0x860c020e, 0x0003240b, 0x861a022a, 0x8a04200b, 0x00052423, 0x8644022c, 0x00062417, 0x86700212, 0x0007240b, 0x8682029c, 0x0008240b, 0x861e0328,
	0x000a240b, 0x864603ce, 0x000b240b, 0x86140438, 0x000c240b, 0x864c045c, 0x820d200b, 0x86a8200b, 0x0e54080b, 0x04055400, 0x69676944, 0x657a6974,
	0x61642064, 0x63206174, 0x7279706f, 0x74686769, 0x3220a920, 0x2c373030, 0x6f6f4720, 0x20656c67, 0x70726f43, 0x7461726f, 0x2e6e6f69, 0x696f7244,
	0x61532064, 0x6552736e, 0x616c7567, 0x63734172, 0x65646e65, 0x202d2072, 0x56231b89, 0x82737265, 0x3120242d, 0x8430302e, 0x84308315, 0x69203108,
	0x20612073, 0x64617274, 0x72616d65, 0x666f206b, 0x61326587, 0x6d20646e, 0x62207961, 0x65722065, 0x74736967, 0x99827265, 0x206e6927, 0x74726563,
	0x27078261, 0x6972756a, 0x63696473, 0x73218783, 0x8a77882e, 0x8580899d, 0x75682466, 0x826e616d, 0x73202149, 0x2035af82, 0x69726573, 0x79742066,
	0x61666570, 0x64206563, 0x67697365, 0x2462826e, 0x20726f66, 0x221c8275, 0x826e6920, 0x211b8373, 0x8c832073, 0x656c652f, 0x6f727463, 0x2063696e,
	0x6d6d6f63, 0x41088275, 0x4c210503, 0x20f28269, 0x20398273, 0x27f88475, 0x20656874, 0x63617041, 0x19860682, 0x41202c21, 0x322e0700, 0x7468302e,
	0x2f3a7074, 0x7777772f, 0x2584612e, 0x726f2e25, 0x856c2f67, 0x2f732943, 0x4543494c, 0x2d45534e, 0x00252982, 0x00690044, 0x20038267, 0x26038274,
	0x0065007a, 0x82200064, 0x00612403, 0x82610074, 0x00632809, 0x0070006f, 0x84720079, 0x82682025, 0x00202215, 0x221782a9, 0x82300032, 0x00372201,
	0x200b822c, 0x20238247, 0x2043826f, 0x223d826c, 0x82430020, 0x8272200d, 0x826f2033, 0x20458333, 0x220f8269, 0x822e006e, 0x82722067, 0x84692009,
	0x8253205f, 0x006e245b, 0x82520073, 0x00672631, 0x006c0075, 0x202d8261, 0x20118241, 0x20118263, 0x2023826e, 0x220f8265, 0x822d0020, 0x8244205d,
	0x826f2009, 0x8797837d, 0x82562037, 0x82722025, 0x225b852d, 0x82310020, 0x228f835f, 0x82620020, 0x8269204d, 0x8264204f, 0x82312039, 0x8a342017,
	0x8b3d8777, 0x82692051, 0x84202045, 0x847420e9, 0x826420af, 0x846d2059, 0x826b208d, 0x006f2241, 0x21df9066, 0x9f830061, 0x83002021, 0x82792025,
	0x8462201d, 0x847220f5, 0x204d83c9, 0x419b8474, 0x69200547, 0x20222b82, 0x11846300, 0x55827420, 0x6a200f85, 0x7220a382, 0x7322d182, 0x05826400,
	0x74006322, 0x6f200582, 0x73202982, 0x0341c582, 0x154f4111, 0x20131541, 0x85538420, 0x826820cd, 0x20a18363, 0x2013846e, 0x20a78274, 0x207f8273,
	0x20ed846e, 0x208f8473, 0x24db8469, 0x00790074, 0x200f8270, 0x201d8266, 0x20c98463, 0x20058264, 0x20358273, 0x85918267, 0x006624c5, 0x8272006f,
	0x82752041, 0x0597413d, 0x7420c783, 0x37874584, 0x1f827320, 0x22071941, 0x826c0065, 0x20d7831b, 0x83398272, 0x42632081, 0x6d220649, 0x97826d00,
	0x1b421185, 0x0068220b, 0x24018274, 0x003a0070, 0x2101822f, 0x01830077, 0x91822e20, 0x42007321, 0x63200b0f, 0x70228784, 0x15822e00, 0x49826f20,
	0xb7002f21, 0x8df58737, 0x827220eb, 0x842e20df, 0x826d2053, 0x004c22c1, 0x207d8669, 0x20cd8273, 0x42ff8464, 0x74200999, 0x65202782, 0x41221382,
	0xa7827000, 0x0d866320, 0x2c20338d, 0xa9421f82, 0x8232200f, 0x983020bd, 0x204b89b7, 0x22eb842e, 0x822f0067, 0x20878b89, 0x2a118273, 0x0049004c,
	0x00450043, 0x8253004e, 0x002d2105, 0x00235385, 0x84000200, 0x66ff2300, 0x08846600, 0x0325048e, 0x01000085, 0x08258202, 0x04000338, 0x06000500,
	0x08000700, 0x0a000900, 0x0c000b00, 0x0e000d00, 0x10000f00, 0x12001100, 0x14001300, 0x16001500, 0x18001700, 0x1a001900, 0x1c001b00, 0x1e001d00,
	0xcf821f00, 0x22002130, 0x24002300, 0x26002500, 0x28002700, 0xc7192900, 0x750e70dd, 0x00a300ac, 0x00850084, 0x009600bd, 0x008600e8, 0x008b008e,
	0x00a9009d, 0x000301a4, 0x0004018a, 0x00930083, 0x00f300f2, 0x0097008d, 0x00050188, 0x00f100de, 0x00aa009e, 0x00f400f5, 0x00a200f6, 0x00c900ad,
	0x00ae00c7, 0x00630062, 0x00640090, 0x006500cb, 0x00ca00c8, 0x00cc00cf, 0x00ce00cd, 0x006600e9, 0x00d000d3, 0x00af00d1, 0x00f00067, 0x00d60091,
	0x00d500d4, 0x00eb0068, 0x008900ed, 0x0069006a, 0x006d006b, 0x006e006c, 0x006f00a0, 0x00700071, 0x00730072, 0x00740075, 0x00770076, 0x007800ea,
	0x0079007a, 0x007d007b, 0x00b8007c, 0x007f00a1, 0x0080007e, 0x00ec0081, 0x01ba00ee, 0x01070106, 0x01090108, 0x000b010a, 0x01fe00fd, 0x010d010c,
	0x000f010e, 0x010001ff, 0x01110110, 0x01130112, 0x01150114, 0x01170116, 0x01190118, 0x011b011a, 0x011d011c, 0x001f011e, 0x01f900f8, 0x01210120,
	0x01230122, 0x01250124, 0x01270126, 0x01290128, 0x012b012a, 0x012d012c, 0x012f012e, 0x01d70030, 0x01320131, 0x01340133, 0x01360135, 0x01380137,
	0x013a0139, 0x013c013b, 0x013e013d, 0x00e2003f, 0x014001e3, 0x01420141, 0x01440143, 0x01460145, 0x01480147, 0x014a0149, 0x014c014b, 0x004e014d,
	0x01b100b0, 0x0150014f, 0x01520151, 0x01540153, 0x01560155, 0x00580157, 0x00fc00fb, 0x01e500e4, 0x015a0159, 0x015c015b, 0x015e015d, 0x0160015f,
	0x01620161, 0x01640163, 0x01660165, 0x01680167, 0x016a0169, 0x016c016b, 0x006e016d, 0x016f01bb, 0x01710170, 0x00e60072, 0x007301e7, 0x017401a6,
	0x01760175, 0x01780177, 0x017a0179, 0x00d8007b, 0x007c01e1, 0x00dc00db, 0x00e000dd, 0x01df00d9, 0x017e017d, 0x0180017f, 0x01820181, 0x01840183,
	0x01860185, 0x01880187, 0x018a0189, 0x018c018b, 0x018e018d, 0x0190018f, 0x01920191, 0x01940193, 0x01960195, 0x01980197, 0x019a0199, 0x019c019b,
	0x019e019d, 0x01a0019f, 0x01a201a1, 0x01a401a3, 0x01a601a5, 0x01a801a7, 0x01aa01a9, 0x01ac01ab, 0x01ae01ad, 0x01b001af, 0x01b201b1, 0x01b401b3,
	0x019b00b5, 0x01b701b6, 0x01b901b8, 0x01bb01ba, 0x01bd01bc, 0x01bf01be, 0x01c101c0, 0x01c301c2, 0x01c501c4, 0x01c701c6, 0x01c901c8, 0x01cb01ca,
	0x01cd01cc, 0x01cf01ce, 0x01d101d0, 0x01d301d2, 0x01d501d4, 0x01d701d6, 0x01d901d8, 0x01db01da, 0x01dd01dc, 0x01df01de, 0x01e101e0, 0x01e301e2,
	0x01e501e4, 0x01e701e6, 0x01e901e8, 0x01eb01ea, 0x01ed01ec, 0x01ef01ee, 0x01f101f0, 0x01f301f2, 0x01f501f4, 0x01f701f6, 0x01f901f8, 0x01fb01fa,
	0x01fd01fc, 0x02ff01fe, 0x02010200, 0x02030202, 0x02050204, 0x02070206, 0x02090208, 0x020b020a, 0x020d020c, 0x020f020e, 0x02110210, 0x02130212,
	0x02150214, 0x02170216, 0x02190218, 0x021b021a, 0x021d021c, 0x021f021e, 0x02210220, 0x02230222, 0x02250224, 0x02270226, 0x00290228, 0x02b300b2,
	0x002b022a, 0x00b700b6, 0x002c02c4, 0x00b500b4, 0x008200c5, 0x008700c2, 0x02c600ab, 0x002e022d, 0x02bf00be, 0x02bc002f, 0x02f70030, 0x02320231,
	0x02340233, 0x00360235, 0x029f008c, 0x02380237, 0x023a0239, 0x0298003b, 0x009a003c, 0x00ef0099, 0x009200a5, 0x00a7009c, 0x0094008f, 0x02b90095,
	0x023e023d, 0x0240023f, 0x02420241, 0x02440243, 0x02460245, 0x02480247, 0x024a0249, 0x024c024b, 0x024e024d, 0x0250024f, 0x02520251, 0x02540253,
	0x02560255, 0x02580257, 0x025a0259, 0x025c025b, 0x025e025d, 0x0260025f, 0x02620261, 0x02640263, 0x02660265, 0x02680267, 0x026a0269, 0x026c026b,
	0x026e026d, 0x0270026f, 0x02720271, 0x02740273, 0x02760275, 0x02780277, 0x027a0279, 0x027c027b, 0x027e027d, 0x0280027f, 0x02820281, 0x02840283,
	0x02860285, 0x02880287, 0x028a0289, 0x028c028b, 0x028e028d, 0x0290028f, 0x02920291, 0x02940293, 0x02960295, 0x02980297, 0x029a0299, 0x029c029b,
	0x029e029d, 0x02a0029f, 0x02a202a1, 0x02a402a3, 0x02a602a5, 0x02a802a7, 0x02aa02a9, 0x02ac02ab, 0x02ae02ad, 0x02b002af, 0x02b202b1, 0x02b402b3,
	0x02b602b5, 0x02b802b7, 0x02ba02b9, 0x02bc02bb, 0x02be02bd, 0x02c002bf, 0x02c202c1, 0x02c402c3, 0x02c602c5, 0x02c802c7, 0x02ca02c9, 0x02cc02cb,
	0x02ce02cd, 0x02d002cf, 0x02d202d1, 0x02d402d3, 0x02d602d5, 0x02d802d7, 0x02da02d9, 0x02dc02db, 0x02de02dd, 0x02e002df, 0x02e202e1, 0x02e402e3,
	0x02e602e5, 0x02e802e7, 0x02ea02e9, 0x02ec02eb, 0x02ee02ed, 0x02f002ef, 0x02f202f1, 0x02f402f3, 0x02f602f5, 0x02f802f7, 0x02fa02f9, 0x02fc02fb,
	0x02fe02fd, 0x030003ff, 0x03020301, 0x03040303, 0x03060305, 0x03080307, 0x030a0309, 0x030c030b, 0x030e030d, 0x0310030f, 0x03120311, 0x03140313,
	0x03160315, 0x03180317, 0x031a0319, 0x031c031b, 0x031e031d, 0x0320031f, 0x03220321, 0x03240323, 0x03260325, 0x03280327, 0x032a0329, 0x032c032b,
	0x032e032d, 0x0330032f, 0x03320331, 0x03340333, 0x03360335, 0x03380337, 0x033a0339, 0x033c033b, 0x033e033d, 0x0340033f, 0x03420341, 0x03440343,
	0x03460345, 0x03480347, 0x034a0349, 0x034c034b, 0x034e034d, 0x0350034f, 0x03520351, 0x03540353, 0x03560355, 0x03580357, 0x035a0359, 0x035c035b,
	0x035e035d, 0x0360035f, 0x03620361, 0x03640363, 0x03660365, 0x03680367, 0x036a0369, 0x036c036b, 0x036e036d, 0x0370036f, 0x03720371, 0x03740373,
	0x03760375, 0x03780377, 0x037a0379, 0x037c037b, 0x037e037d, 0x0380037f, 0x03820381, 0x03840383, 0x03860385, 0x03880387, 0x038a0389, 0x038c038b,
	0x6e2e058d, 0x076c6c75, 0x30696e75, 0x09444130, 0x7265766f, 0x726f6373, 0x65700e65, 0x646f6972, 0x746e6563, 0x64657265, 0x616d4107, 0x6e6f7263,
	0x07856107, 0x62410628, 0x65766572, 0x06846106, 0x6f410729, 0x656e6f67, 0x8561076b, 0x430b2d07, 0x63726963, 0x6c666d75, 0x630b7865, 0x04260b89,
	0x746f6443, 0x04826304, 0x63440623, 0x214e8261, 0x06856406, 0x72634425, 0x8274616f, 0x2106830d, 0x63854507, 0x85650721, 0x45062107, 0x06216484,
	0x21068465, 0x3e82450a, 0x83636121, 0x650a2198, 0x07210a88, 0x21798545, 0x07856507, 0x85450621, 0x84652058, 0x470b2106, 0x0b218389, 0x210b8967,
	0x40824704, 0x82670421, 0x470c2604, 0x6d6d6f63, 0x21578561, 0x0c8a670c, 0x89480b21, 0x680b212f, 0x04260b89, 0x72616248, 0x04826804, 0x74490628,
	0x65646c69, 0x06846906, 0x85490721, 0x690721b5, 0x06210785, 0x21b68449, 0x06846906, 0x85490721, 0x6907219f, 0x0a210785, 0x27c28849, 0x024a4902,
	0x4a0b6a69, 0x0b216289, 0x210b896a, 0x938a4b0c, 0x8c6b0c21, 0x7267330c, 0x6c6e6565, 0x69646e61, 0x614c0663, 0x65747563, 0x06846c06, 0x8b4c0c21,
	0x8a6c2027, 0x4c06280c, 0x6f726163, 0x846c066e, 0x4c042106, 0x04218582, 0x2104826c, 0x3f854e06, 0x3f856e20, 0x328a4e20, 0x8a6e0c21, 0x4e06210c,
	0x06213884, 0x3506846e, 0x70616e0b, 0x7274736f, 0x6568706f, 0x676e4503, 0x676e6503, 0xff854f07, 0x856f0721, 0x4f062807, 0x76657262, 0x846f0665,
	0x4f0d2f06, 0x676e7568, 0x6d757261, 0x7475616c, 0x0d8b6f0d, 0x84520621, 0x7206217c, 0x0c210684, 0x21768a52, 0x0c8a720c, 0x84520621, 0x7206217c,
	0x53200685, 0x06212e84, 0x21068473, 0x3a41530b, 0x730b2109, 0x0c210b89, 0x21408a54, 0x0c8a740c, 0x85540621, 0x84742046, 0x54042606, 0x04726162,
	0x28048274, 0x69745506, 0x0665646c, 0x21068475, 0xcd855507, 0x85750721, 0x55062107, 0x0621ce84, 0x27068475, 0x69725505, 0x7505676e, 0x0d210583,
	0x20e18c55, 0x210d8b75, 0xfd415507, 0x75072105, 0x0b210785, 0x21a18957, 0x0b8a770b, 0x0b8a5920, 0x0b897920, 0x845a0621, 0x7a0621e4, 0x0a210684,
	0x0843425a, 0x887a0a21, 0x6c05270a, 0x73676e6f, 0x8b83410a, 0x61202685, 0x07220a88, 0x12844541, 0x65610722, 0x0b260784, 0x616c734f, 0x0b856873,
	0x0b896f20, 0x41530c21, 0x0c210a20, 0x200c8a73, 0x2efe8506, 0x6e6f7405, 0x640d736f, 0x65726569, 0x84736973, 0x410a250d, 0x6168706c, 0x092e0a84,
	0x746f6e61, 0x69656c65, 0x70450c61, 0x91826973, 0x08221684, 0x1f867445, 0x866f4921, 0x4f0c2709, 0x7263696d, 0x1f846e6f, 0x8a550c21, 0x4f0a242c,
	0x8567656d, 0x6911212e, 0x6b8c2e82, 0x6b840520, 0x65420433, 0x47056174, 0x616d6d61, 0x696e7507, 0x34393330, 0x216f8607, 0x1a825a04, 0x6f820320,
	0x68540522, 0x04200982, 0x05367083, 0x7070614b, 0x614c0661, 0x6164626d, 0x02754d02, 0x5802754e, 0x81860769, 0x69500231, 0x6f685203, 0x67695305,
	0x5403616d, 0x86077561, 0x5003258d, 0x43036968, 0x50220382, 0x66856973, 0x0c394122, 0x91874f83, 0x28860f20, 0x0a210f87, 0x08084161, 0x8a650c21,
	0x820820d1, 0x20e78488, 0x84cf8309, 0x75142109, 0xdc8d1f85, 0x04213f84, 0x212e8262, 0xdc836705, 0x65640526, 0x0761746c, 0x04214b86, 0x2018827a,
	0x21038203, 0xda847405, 0x05214c83, 0x20da846b, 0x85da846c, 0x434229a4, 0x02756e02, 0x6f076978, 0x25056141, 0x6f687203, 0xdc837306, 0x84053121,
	0x74032106, 0x7f86e382, 0x82700321, 0x826320df, 0x268e8203, 0x656d6f05, 0x410c6167, 0x0f200b73, 0x0c20a68e, 0xc3845386, 0x1c860c20, 0x0a200c84,
	0x0a843c84, 0x66610929, 0x30316969, 0x87333230, 0x31352109, 0x32200988, 0x1d890988, 0x13883420, 0x09883520, 0x09883620, 0x09883720, 0x09883820,
	0x09873920, 0x88303621, 0x20638809, 0x21638736, 0x4f883431, 0x45883120, 0x45883120, 0x45883120, 0x45883220, 0x45883220, 0xa9883220, 0x9f883220,
	0x4f883220, 0x9f883220, 0x59883220, 0x59883220, 0x59883220, 0x59883320, 0x59883320, 0x59883320, 0x03413320, 0x88332008, 0x88332063, 0x88332063,
	0x88332063, 0x88332063, 0x88332063, 0x88342063, 0x88342063, 0x88342063, 0x88342063, 0x88342063, 0x09174163, 0x63883420, 0x63883420, 0x63883420,
	0x63883420, 0x95883620, 0x31883620, 0x31883620, 0x31883620, 0x31883620, 0x95883720, 0x8b883720, 0x8b883720, 0x8b883720, 0x59883720, 0x59883720,
	0x59883720, 0x59883720, 0x59883720, 0x59883820, 0xef883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820, 0x63883820,
	0x63883820, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x63883920, 0x45893720, 0x31216387, 0x21638730,
	0x1d873031, 0x42303121, 0x302008bb, 0x31216387, 0x21638730, 0x63873031, 0x87303121, 0x30312163, 0x31216387, 0x21c78730, 0x63883031, 0x63883120,
	0x3520b389, 0x3829db89, 0x72675706, 0x06657661, 0x24068577, 0x75636157, 0x840d8274, 0x57092106, 0x21079d44, 0x09877709, 0x85590621, 0x84792028,
	0x61092d06, 0x30696966, 0x38303230, 0x646e750d, 0x2b06484a, 0x0d6c6264, 0x746f7571, 0x76657265, 0x65251282, 0x696d0664, 0x2c55836e, 0x6f636573,
	0x6509646e, 0x616c6378, 0x2925826d, 0x75736e09, 0x69726570, 0x4785726f, 0x3439382f, 0x65700631, 0x61746573, 0x72754504, 0x2215846f, 0x42323136,
	0x0982068f, 0x3d069f41, 0x35333136, 0x73650932, 0x616d6974, 0x09646574, 0x65656e6f, 0x74686769, 0x68740c68, 0x0b866572, 0x660b7324, 0x0b877669,
	0x82730c21, 0x856e208b, 0x05732e24, 0x746c6544, 0x6e750761, 0x30424669, 0x2a078631, 0x79630d32, 0x6c6c6972, 0x83626369, 0x64082db7, 0x656c746f,
	0x106a7373, 0x6f726163, 0x200b0849, 0x0a14470b, 0x0b8a1120, 0x746f7222, 0x0c248c82, 0x6f72657a, 0x0c24d687, 0x72756f66, 0x8e820c89, 0x0b230c87,
	0x87786973, 0x840d200b, 0x840d889b, 0x233488a4, 0x656e696e, 0xa9830c87, 0x30303223, 0x84078630, 0x303223b9, 0x0f863230, 0x07863320, 0x07863420,
	0x07863520, 0x07863620, 0x07863720, 0x07863820, 0x07863920, 0x07864120, 0x07834220, 0x46454623, 0x22078446, 0x86434646, 0x83442007, 0x31302307,
	0x07843046, 0x84423221, 0x33302317, 0x0f843144, 0x84443321, 0x840f827f, 0x45312367, 0x17834533, 0x47840782, 0x85453121, 0x840782af, 0x4631222f,
	0x2b4f8534, 0x09334632, 0x69736164, 0x69786f61, 0x84078b41, 0x42462bc1, 0x4f053430, 0x6e726f68, 0x05846f05, 0x05845520, 0x05837520, 0x51857185,
	0x41333021, 0x078205bb, 0x6804332e, 0x086b6f6f, 0x62746f64, 0x776f6c65, 0x34202584, 0x34212586, 0x216f8530, 0xbf853534, 0x86353421, 0x8636200f,
	0x8436200f, 0x34302297, 0x21c78536, 0x85843634, 0x34200f82, 0x36214785, 0x84078635, 0x201782df, 0x200f8637, 0x20078638, 0x20078639, 0x20078641,
	0x41078642, 0x34210527, 0x206f8736, 0x20178645, 0x21078546, 0x07863037, 0x07863120, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86,
	0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x37207f86, 0x38217f86, 0x21778530, 0x07863138, 0x38207f86,
	0x38207f86, 0x38207f86, 0x38207f86, 0x38207f86, 0x38207786, 0x38207786, 0x38207786, 0x38207786, 0x38207786, 0x38207786, 0x38207786, 0x39207786,
	0x39206786, 0x39206786, 0x39206786, 0x39206786, 0x39206786, 0x3920e786, 0x39206f86, 0x39206f86, 0x39206f86, 0x39206f86, 0x39206f86, 0x39206f86,
	0x39206f86, 0x41216f86, 0x21df8530, 0x07863141, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86,
	0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x41207f86, 0x42217f86, 0x21778530, 0x07863142, 0x42207f86, 0x42207f86, 0x42207f86, 0x42207f86,
	0x42207f86, 0x42207f86, 0x42207f86, 0x42207f86, 0x42207f86, 0x8f437f86, 0x42342106, 0x42207f86, 0x42207f86, 0x43217f86, 0x21778530, 0x07863143,
	0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x43207f86, 0x4320ff86, 0x43207f86,
	0x43207f86, 0x44217f86, 0x44778530, 0x3420062f, 0x21062f44, 0x7f864434, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420,
	0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864420, 0x7f864520, 0x85314521, 0x86452087, 0x864520ff, 0x8645207f, 0x8645207f,
	0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x8645207f, 0x0637457f, 0x31463422,
	0x46207f85, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0x46207f86, 0xa7457f86, 0x34302205,
	0x207f8646, 0x457f8646, 0x302105c7, 0x06074535, 0x2d453520, 0x46352006, 0x1782052f, 0x35217f85, 0x217f8530, 0x7f853035, 0x85303521, 0x3035217f,
	0x35217f85, 0x217f8530, 0x7f853035, 0x85303521, 0x3035217f, 0x35217f85, 0x21ff8530, 0x7f853035, 0x85303521, 0x3035217f, 0x3522ff85, 0xf7843031,
	0x31313522, 0xff850786, 0x84313521, 0x4531217f, 0x82059f43, 0x821f8407, 0x821f8407, 0x841f8707, 0x840f829f, 0x8407829f, 0x8407829f, 0x8407829f,
	0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x8407829f, 0x4531219f, 0x82059f43, 0x46312007, 0x422005b7, 0x9f437f86,
	0x86178205, 0x059f437f, 0x7f860f82, 0x82059f43, 0x437f860f, 0x0f82059f, 0x9f437f86, 0x860f8205, 0x059f437f, 0x7f860f82, 0x21059f43, 0x9f434531,
	0x86078205, 0x8643207f, 0x059f437f, 0x7f861782, 0x82059f43, 0x437f860f, 0x0f82059f, 0x9f437f86, 0x860f8205, 0x059f437f, 0x7f860f82, 0x82059f43,
	0x437f860f, 0x3121059f, 0x059f4345, 0x7f860782, 0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f,
	0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f, 0x82059f43, 0x067f410f, 0x21059f43, 0x9f434531, 0x86078205, 0x059f43ff, 0xff860f82, 0x82059f43,
	0x43ff860f, 0x0f82059f, 0x9f43ff86, 0x860f8205, 0x059f43ff, 0xff860f82, 0x82059f43, 0x43ff860f, 0x3121059f, 0x059f4345, 0x31200782, 0x4305ff41,
	0x0f82058f, 0x8f43ef86, 0x860f8205, 0x058f43ef, 0xef840f82, 0x46303221, 0x33230607, 0x51134630, 0x612809af, 0x65747563, 0x626d6f63, 0x6723138a,
	0x84766172, 0x89122013, 0x6f682327, 0x268e6b6f, 0x6c697423, 0x25268464, 0x6572620e, 0x49886576, 0x44880e85, 0x1d840d20, 0x1c853f87, 0x10203a88,
	0x8307cb4a, 0x656c241f, 0x4a117466, 0x692108dc, 0x21138367, 0x118f4355, 0x05434c32, 0x6c612e67, 0x63540874, 0x6c696465, 0x7408616c, 0x00200886,
	0x022a0084, 0x02000500, 0x0300ffff, 0x0f820100, 0x03820c20, 0x03821620, 0x0d830220, 0x82840321, 0x82042005, 0x2219830d, 0x82010000, 0x000a2e09,
	0x002c001e, 0x74616c01, 0x0008006e, 0x20118204, 0x203b8200, 0x23078201, 0x72656b01, 0x00211383, 0x820d8400, 0x8202201b, 0x83012021, 0xc8a52103,
	0x38080d82, 0x03f10100, 0x07ec03ec, 0x08600752, 0x096007de, 0x0bce0a3c, 0x0d220c34, 0x0f3a0e54, 0x11061020, 0x13ca1298, 0x15d214a0, 0x1a8a1904,
	0x21ba1d18, 0x27922360, 0x285207ac, 0x20018292, 0x26038298, 0x294429aa, 0x8260295a, 0x29922a09, 0x28802972, 0x2afe2998, 0x08018214, 0x042b2a22,
	0x52071a2b, 0xf22be42b, 0x522e002c, 0x002c522e, 0xe2329830, 0x3835340b, 0x38351e36, 0x3a0e3835, 0x36230185, 0x877e37fc, 0x98112301, 0x0185dc38,
	0x84e63921, 0x82658361, 0x72292503, 0xa43e9828, 0xae220186, 0x0187bc3e, 0x3e722923, 0x260186d6, 0x096640e0, 0x8392283c, 0x84402703, 0x340b9228,
	0x01839828, 0x42210783, 0x214b851a, 0x07839842, 0x423a0e23, 0x23db839e, 0x06106029, 0x42210183, 0x8505831a, 0x98112121, 0x7220c382, 0x3f850585,
	0x2888432b, 0x44964498, 0x191a4296, 0x3101858a, 0x142aba1d, 0x042b9223, 0xac271049, 0x8a4dac27, 0x7383a050, 0x98285b08, 0x9c516e51, 0xd851aa51,
	0x78526a52, 0x2054de52, 0x4c568254, 0x38591659, 0x6c5a565a, 0x585e165b, 0x845f665e, 0x04615e60, 0x6465ae64, 0xec658e65, 0x2c661e66, 0x9c6ade66,
	0x9228a26a, 0x9c6abc6a, 0x146b0e6b, 0x4c6b426b, 0x92287a6b, 0x2e6cec6b, 0x8a6c546c, 0xb66ca86c, 0x0382cc6c, 0xfc6cde2c, 0x486d366d, 0x9e6d7229,
	0xa383b06d, 0xfe6d7708, 0xd66fe06e, 0xaa732c73, 0x2a74c073, 0xda750875, 0x1677a076, 0x6a7acc78, 0x3e7d947c, 0x0680c87d, 0xd6811081, 0xa2837082,
	0x16860085, 0x6e8c2087, 0xa68efc8d, 0x2290608f, 0x96911c91, 0xa6921892, 0x82931c93, 0x9a940894, 0xfa94b894, 0xb2953095, 0xae962896, 0x86973897,
	0xa698e497, 0xaa993899, 0x769a209a, 0x9828d09a, 0xa89b369b, 0x9828ee9b, 0x3e9c309c, 0x07829828, 0xba9cb032, 0xbe9d409d, 0x369ec49d, 0x9a94ac9e,
	0x142aba1d, 0x23250387, 0xa2042b92, 0x0801821a, 0x28a22820, 0x3c093c09, 0x7ca53aa5, 0xa283fa94, 0x9691a698, 0x1686ae96, 0x6a7a8697, 0x10816a7a,
	0x03833095, 0x96a28325, 0x830085ae, 0x6e8c2305, 0x0383a698, 0x98a69823, 0x850f83a6, 0xa6982703, 0x608fbea5, 0x3b83209a, 0x96008529, 0x972087ae,
	0x83a076e4, 0xae962111, 0x47870583, 0x0f830783, 0x3b831f85, 0x0d836983, 0x98208723, 0x830383a6, 0x2703871d, 0xa283a076, 0xc073a283, 0x4d853583,
	0x73211987, 0x219d83c0, 0xb183fa94, 0x83ae9621, 0x83a58747, 0x85118531, 0xae962199, 0x0783b187, 0x97216985, 0x859387e4, 0x89a385d1, 0x833f85cd,
	0x21278399, 0x01953c09, 0x420bf542, 0x0e2505ad, 0x2998113a, 0x21039772, 0x01873aa5, 0x198a1925, 0x877ca58a, 0x92232301, 0x0387042b, 0x00964431,
	0xff2400d9, 0x002c00ae, 0x00370029, 0x82390052, 0x003a2403, 0x823b0066, 0x823c200f, 0x823d200b, 0xff462407, 0x824700c3, 0x82482003, 0xff4a2403,
	0x825200d7, 0x82542007, 0x82572003, 0x8259201b, 0x005a2403, 0x825c0014, 0x82822007, 0x82832047, 0x82842003, 0x82852003, 0x82862003, 0x82872003,
	0xff882403, 0x828e005c, 0x828f201f, 0x82902003, 0x82912003, 0x829f2003, 0x82a8205b, 0x82a92043, 0x82aa2003, 0x82ab2003, 0x82ac2003, 0x82ad2003,
	0x82b42003, 0x82b52003, 0x82b62003, 0x82b72003, 0x82b82003, 0x82ba2003, 0x82bf2003, 0x82c12037, 0x82c22003, 0x82c42053, 0x82c62003, 0x82c92003,
	0x82cb2017, 0x82cd2003, 0x82cf2003, 0x82d52003, 0x82d72003, 0x82d92003, 0x82db2003, 0x82dd2003, 0x82ec2003, 0x82f02033, 0x00f22803, 0xff0f0129,
	0x821101c3, 0x82132003, 0x82152003, 0x00242403, 0x82260152, 0x00362803, 0x00370166, 0x82380114, 0x8239200b, 0x823a2027, 0x823b2007, 0x21ff8207,
	0x07823f01, 0xaeff4324, 0x03825f01, 0x03826920, 0x1b827120, 0x3b827920, 0x03827e20, 0x1b828020, 0x07828220, 0x07828a20, 0x07828c20, 0x03828e20,
	0x03829020, 0x0121e382, 0x20078293, 0x20178294, 0x20078296, 0x20038299, 0x2003829b, 0x243b829d, 0x019affa4, 0x240782a6, 0x013d00a8, 0x244f82aa,
	0x0185ffae, 0x200b82b0, 0x207f82b1, 0x200b82b5, 0x201b82bc, 0x820f82bd, 0xc40121ef, 0xd7820b82, 0x82d80121, 0x82db203b, 0x82dc2003, 0x82dd204f,
	0x82de2003, 0x82ea200b, 0x82ed2003, 0x82fa2003, 0x82fb20bb, 0x82fc203b, 0x82fd2007, 0x82fe2007, 0x00ff3007, 0x00000214, 0x00010252, 0xff280229,
	0x825802ae, 0xff602403, 0x826a02c3, 0x826d2003, 0x82722013, 0x0076240f, 0x827f023d, 0x8281200f, 0x8283200f, 0x82852003, 0x8287200b, 0x82892003,
	0x828b2003, 0x828d200f, 0x829f2007, 0x82a92023, 0x82aa2047, 0x82b2200f, 0x82b4200f, 0x82b52003, 0x82b6200f, 0x82b7200f, 0x82b82007, 0x82b92007,
	0x82ba2007, 0x82bb2007, 0x82bd202b, 0x82ca200b, 0xffce2407, 0x82d90285, 0x82db2063, 0x82dd2003, 0x82e02003, 0x82e52037, 0x82f02017, 0x82f22007,
	0x82f42003, 0x82f72003, 0x82f8200f, 0x82f92037, 0x82fa2007, 0x82fb2007, 0x00fc2807, 0x00050329, 0x8207033d, 0xff0a2403, 0x820c03c3, 0x820e2003,
	0x82102013, 0xff112403, 0x82160385, 0x0017240f, 0x82180352, 0x821a200f, 0x821b200b, 0xff1d2413, 0x821f03ae, 0x82212003, 0x82232003, 0x82252003,
	0x82272003, 0x82292003, 0x822b2003, 0x822d2003, 0x822f2003, 0x82312003, 0x82332003, 0x82362003, 0x82382037, 0x823a2003, 0x823c2003, 0x823e2003,
	0x82402003, 0x82422003, 0x82442003, 0x82452003, 0x8247205b, 0x824a2003, 0x824c200b, 0x824e2003, 0x82502003, 0x82522003, 0x82542003, 0x82562003,
	0x82582003, 0x825a2003, 0x825c2003, 0x825e2003, 0x82602003, 0x826f2003, 0x82702097, 0x82712037, 0x82722007, 0x82732007, 0x82742007, 0x00832e07,
	0x00030052, 0x007b002d, 0x017b00f6, 0x260782a3, 0xff26005f, 0x822a00c3, 0x82322003, 0x82342003, 0xff372803, 0xff38009a, 0x823900d7, 0xff3a2407,
	0x823c00ae, 0x82892007, 0x82942017, 0x82952003, 0x82962003, 0x82972003, 0x82982003, 0x829a2003, 0x829b2003, 0x829c202b, 0x829d2003, 0x829e2003,
	0x829f2003, 0x82c8202f, 0x82ce2017, 0x82de2003, 0x82e02003, 0x82e22003, 0xffe42403, 0x820e01c3, 0x82122003, 0xff242403, 0x8226019a, 0xff2c2403,
	0x823001d7, 0x82322003, 0x82342003, 0xff362403, 0x823801ae, 0x823a2017, 0x82662003, 0x826d2027, 0x82712003, 0x82b8200b, 0x82bb2007, 0x82bc2003,
	0x82fa200b, 0x82fc2023, 0xfffe3003, 0xff0002ae, 0xff5f029a, 0xff6102c3, 0x826c02d7, 0x827e2007, 0x82842003, 0x82862003, 0x82882003, 0x828a2003,
	0x828c2003, 0x82a92003, 0x82b12027, 0x82b32007, 0x82b52003, 0x82b7200b, 0x82b92003, 0x82bd2003, 0x82e12003, 0x82e32013, 0x82ef2003, 0x82f12003,
	0xfff32403, 0x821503c3, 0xff172403, 0x8219039a, 0x82492007, 0x824b2003, 0x824d2003, 0x824f2003, 0x82512003, 0x82532003, 0x82552003, 0x82572003,
	0x82592003, 0x825b2003, 0x825d2003, 0x258b8203, 0xd7ff6103, 0x03826303, 0x03826520, 0x03826720, 0x03826920, 0x03826b20, 0x03826d20, 0x53826f20,
	0x03827120, 0x03827320, 0x9aff8326, 0x37001700, 0x1182d182, 0xff720129, 0xffb001c3, 0x82b501d7, 0x20e58303, 0x20dd82c4, 0x20d58276, 0x8303829f,
	0x20b58bbd, 0x201382bb, 0x20b982bd, 0x200782ca, 0x200382ce, 0x205982e5, 0x20038205, 0x20038207, 0x83038211, 0xff1b2ab9, 0x006400d7, 0x00aeff05,
	0x2403820a, 0x00ecff26, 0x2003822a, 0x20038232, 0x24038234, 0x0085ff37, 0x24078238, 0x00c3ff39, 0x4129823a, 0xec2205e3, 0x13829400, 0x03829520,
	0x03829620, 0x03829720, 0x03829820, 0x03829a20, 0x03829b20, 0x03829c20, 0x03829d20, 0x03829e20, 0x2205e341, 0x82ce00ec, 0x82de200b, 0x82e02003,
	0x82e22003, 0xffe42403, 0x820e01ec, 0x82122003, 0x82142003, 0xff2424c9, 0x82260185, 0x822c2003, 0x8230200f, 0x82322003, 0x82342003, 0x82362003,
	0x09e7411b, 0x6d01ec22, 0x71201382, 0xb8202782, 0xbb200782, 0xbc200382, 0xfa200b82, 0xfc202382, 0xfe200382, 0x0020e182, 0x0724ed82, 0x0b02aeff,
	0x5f240382, 0x6102ecff, 0x6c200382, 0x7e200382, 0x84200382, 0x86200382, 0x88200382, 0x8a200382, 0x8c200382, 0xa9240382, 0xb10285ff, 0xb3200782,
	0xb5200382, 0xb7200b82, 0xb9200382, 0xbd200382, 0xe1200382, 0xe3201382, 0xef200382, 0xf1200382, 0xf3240382, 0x1503ecff, 0x17240382, 0x190385ff,
	0x49200782, 0x4b200382, 0x4d200382, 0x4f200382, 0x51200382, 0x53200382, 0x55200382, 0x57200382, 0x59200382, 0x5b200382, 0x5d200382, 0x5f200382,
	0x61200382, 0x63200382, 0x65200382, 0x67200382, 0x69200382, 0x6b200382, 0x6d200382, 0xef410382, 0x0085280d, 0xff2c0019, 0x823700ec, 0x82392003,
	0x823b2003, 0x823c2003, 0x829f2003, 0x822420f1, 0x82262003, 0x82382003, 0x823a2003, 0x82712003, 0x82bc2003, 0x8400209d, 0x02ec22cd, 0x200782b5,
	0x200382b7, 0x200382b9, 0x22ad84bd, 0x824503ec, 0x84472007, 0x03ec2165, 0x03212f82, 0x200b8273, 0x264f8283, 0x0005003b, 0x820a0029, 0x820c2003,
	0xff262403, 0x822a00d7, 0x82322003, 0x82342003, 0x82402003, 0x82602013, 0x82892003, 0x8294200b, 0x82952003, 0x82962003, 0x82972003, 0x82982003,
	0x829a2003, 0x82c82003, 0x82ce2003, 0x82de2003, 0x82e02003, 0x82e22003, 0xffe42403, 0x820e01d7, 0x82122003, 0x82662003, 0x826d2003, 0x82b82003,
	0xffbb2803, 0x000702d7, 0x820b0229, 0x825f2003, 0x826c200b, 0x827e2003, 0x82842003, 0x82862003, 0x82882003, 0x828a2003, 0x828c2003, 0x82b12003,
	0x82b32003, 0x82e12003, 0x82e32003, 0x82ef2003, 0x82f12003, 0xfff32403, 0x821503d7, 0x82192003, 0x82492003, 0x824b2003, 0x824d2003, 0x824f2003,
	0x82512003, 0x82532003, 0x82552003, 0x82572003, 0x82592003, 0x825b2003, 0x825d2003, 0x276f8203, 0x0f004c00, 0x1100c3ff, 0x24200382, 0x5f41fb82,
	0x00c32205, 0x200b8239, 0x0863413a, 0x3d00d722, 0x82200b82, 0x83200382, 0x84200382, 0x85200382, 0x86200382, 0x87200382, 0x88200382, 0x8e203b82,
	0x8f200782, 0x90200382, 0x91200382, 0x9f200382, 0xc220f182, 0xc4200782, 0xc6200382, 0xec200382, 0xf0200382, 0xf2280382, 0x2401ecff, 0x2601c3ff,
	0x36280382, 0x3801ecff, 0x3a01d7ff, 0x3b200382, 0x3d200b82, 0x3f200382, 0x43200382, 0x5f200382, 0x69200382, 0x71200382, 0xaa202782, 0xbc200782,
	0xfa200782, 0xfc200782, 0xfe240382, 0x0002ecff, 0x2820f582, 0x58200782, 0x72200382, 0xa9240382, 0xb502c3ff, 0xb7200382, 0xb9200382, 0xbd200382,
	0xd9200382, 0xdb201782, 0xdd280382, 0x1703ecff, 0x1d03c3ff, 0x1f200782, 0x21200382, 0x23200382, 0x25200382, 0x27200382, 0x29200382, 0x2b200382,
	0x2d200382, 0x2f200382, 0x31200382, 0x33200382, 0x1f420382, 0x03d72609, 0x03d7ff71, 0x20038273, 0x26eb8283, 0x00050039, 0x820a003d, 0x000c2803,
	0xff0f0029, 0x8211009a, 0x82222003, 0x8224200b, 0x003924f5, 0x823a0014, 0x823c2003, 0x072b4203, 0x17828220, 0x03828320, 0x03828420, 0x03828520,
	0x03828620, 0x03828720, 0x4d828820, 0x27829f20, 0x0b82c220, 0x0382c420, 0xd7ffc628, 0x14003601, 0x03823801, 0x03823a20, 0x0f824320, 0x03825f20,
	0x03826920, 0x0382aa20, 0x1382fa20, 0x0382fc20, 0x1400fe24, 0x03820002, 0x3d000724, 0x03820b02, 0xd7ff2824, 0x03825802, 0x03827220, 0x0382d920,
	0x0382db20, 0xad82dd20, 0x03821d20, 0x03821f20, 0x03822120, 0x03822320, 0x03822520, 0x03822720, 0x03822920, 0x03822b20, 0x03822d20, 0x03822f20,
	0x03823120, 0x03823320, 0x14006f24, 0x03827103, 0x93827320, 0x0543e583, 0x0ffd4405, 0x44ff8921, 0xc82019e9, 0xd5441b82, 0x01ec231d, 0xb144ff66,
	0x06ad4405, 0x210afd42, 0x954402ec, 0x0791441b, 0x44178144, 0x0020327d, 0xe743e58b, 0x3bdf430d, 0xe3431420, 0x0064268e, 0x009aff05, 0x4103820a,
	0xc9460fcb, 0x00ae2409, 0x48c3ff3a, 0xdf4106ad, 0x35c94619, 0x4601ec21, 0xc32019c9, 0x460ab148, 0xc32917c9, 0xc3fffc01, 0xc3fffe01, 0x05c94602,
	0x0b029a25, 0x46029aff, 0x7545bbc9, 0x00d72117, 0x23057545, 0xff3c00d7, 0x211f7545, 0x754500d7, 0x003526eb, 0x0033ff0f, 0x20038211, 0x06914924,
	0x2307ff47, 0x00d7ff3d, 0x2619b14e, 0xff890071, 0x829f00ec, 0x0b6d4e03, 0x2006a744, 0x072f4801, 0xd7ff3b24, 0x03823d01, 0x03823f20, 0x280b214e,
	0x01aeffaa, 0x02ecffbb, 0x4d038200, 0x7222077d, 0x114daeff, 0x4c03200b, 0x6f212fb5, 0x086f48ff, 0x42187d47, 0xc3202b07, 0x22ec0742, 0x4937000c,
	0xe7490aef, 0xffa92107, 0x2015e349, 0x262b8283, 0x00050021, 0x820a0052, 0xff0f2403, 0x4710009a, 0x85200caf, 0x2c10bf4d, 0x00ecff36, 0x00140037,
	0x0085ff44, 0x20038246, 0x20038247, 0x20038248, 0x2437824a, 0x00aeff50, 0x20038251, 0x200f8252, 0x20078253, 0x20078254, 0x20078255, 0x20078256,
	0x24078258, 0x00c3ff59, 0x2003825a, 0x2003825b, 0x2003825c, 0x2003825d, 0x201b8282, 0x20038283, 0x20038284, 0x20038285, 0x20038286, 0x23038287,
	0x0071ff88, 0x201b174e, 0x202382a2, 0x200382a3, 0x200382a4, 0x200382a5, 0x200382a6, 0x200382a7, 0x200382a8, 0x200382a9, 0x200382aa, 0x200382ab,
	0x200382ac, 0x200382ad, 0x207f82b3, 0x200782b4, 0x200382b5, 0x200382b6, 0x200382b7, 0x200382b8, 0x200382ba, 0x201b82bb, 0x200382bc, 0x200382bd,
	0x200382be, 0x209782bf, 0x200382c1, 0x201b82c2, 0x200382c3, 0x200382c4, 0x200382c5, 0x200382c6, 0x200382c7, 0x201b82c8, 0x200782c9, 0x200382cb,
	0x200382cd, 0x200f82ce, 0x200782cf, 0x200382d5, 0x200382d7, 0x200382d9, 0x200382db, 0x4e0382dd, 0x06240fa3, 0x0801aeff, 0x0a200382, 0x0e280382,
	0x0f01c3ff, 0x110185ff, 0x12200382, 0x13200b82, 0x14200782, 0x15200782, 0x1c240782, 0x1d01ecff, 0x1f200782, 0x20200382, 0x21200b82, 0x22200782,
	0x23200782, 0x24240782, 0x26011400, 0x37200382, 0x39202b82, 0x40200382, 0x43200382, 0x44201782, 0x4a200382, 0x5f200382, 0x66200382, 0x69201382,
	0x6d200782, 0x71200782, 0x79202b82, 0x7b200b82, 0x7e207382, 0x80200782, 0x82201382, 0x84200782, 0x8a200f82, 0x8c200b82, 0x8e200b82, 0x90200382,
	0x91200382, 0x93200f82, 0x94200782, 0x96200782, 0x99200782, 0x9b200382, 0xa0200382, 0xaa207b82, 0x2b4f0782, 0x20538208, 0x820f82ca, 0xd80121f7,
	0xdb200782, 0xdc200382, 0xdd203382, 0xde200382, 0xea200b82, 0xed200382, 0xee200382, 0xfb200382, 0xfd201382, 0xff240382, 0x0102c3ff, 0x022c0382,
	0x0302aeff, 0x07029aff, 0x0b025200, 0x28240382, 0x580285ff, 0x59200382, 0x5f200382, 0x60201f82, 0x6a200782, 0x6c200382, 0xbf820b82, 0x82720221,
	0x827e200b, 0x827f200b, 0x82812007, 0x4f832007, 0x85200687, 0x86200f82, 0x87200b82, 0x88200782, 0x89200782, 0xcf820782, 0x828b0221, 0x828c200b,
	0x828d2003, 0x00a9240f, 0x82aa0214, 0x82b1200b, 0x82b22003, 0x82b3200f, 0x82b42007, 0x82b52007, 0x82b62017, 0x82b7200b, 0x82b82007, 0x82b92007,
	0x82ba2007, 0x82bd2007, 0x82d92007, 0x82da201f, 0x21d38203, 0x0782dc02, 0x0382dd20, 0x0382e020, 0x200bcb4f, 0x200f82f0, 0x202f82f1, 0x200782f2,
	0x200782f3, 0x200782f4, 0x200782f8, 0x280382fa, 0x03c3fffc, 0x0385ff0a, 0x2003820c, 0x200b820e, 0x20038210, 0x20038215, 0x240f8216, 0x03140017,
	0x200b8218, 0x20038219, 0x200f821a, 0x2003821d, 0x2003821e, 0x2003821f, 0x20038221, 0x20038222, 0x20038223, 0x20038224, 0x20038225, 0x20038226,
	0x20038227, 0x20038228, 0x20038229, 0x2003822a, 0x2003822b, 0x2003822c, 0x2003822d, 0x2003822e, 0x2003822f, 0x20038230, 0x20038231, 0x20038232,
	0x20038233, 0x20038234, 0x20038236, 0x20038238, 0x2003823a, 0x2003823c, 0x2003823e, 0x20038240, 0x20038242, 0x20038244, 0x20838249, 0x2007824a,
	0x2007824b, 0x2007824c, 0x2007824d, 0x2007824e, 0x2007824f, 0x20078250, 0x20078251, 0x20078252, 0x20078253, 0x20078254, 0x20078255, 0x20078256,
	0x20078257, 0x20078258, 0x20078259, 0x2007825a, 0x2007825b, 0x2007825c, 0x2007825d, 0x2007825e, 0x2007825f, 0x24078260, 0x03aeff62, 0x20038264,
	0x20038266, 0x20038268, 0x2003826a, 0x2003826c, 0x2003826e, 0x20238270, 0x20038272, 0x2a038274, 0x00140083, 0xff0f0023, 0x821100d7, 0x4d242003,
	0xd7211c4b, 0x0a374d00, 0x0b4d0120, 0xffaa230b, 0xf34c02ec, 0x0bdf4c0b, 0x212edb4c, 0x1345e800, 0x09bf4c0c, 0x4e00c321, 0x44230fef, 0x5600c3ff,
	0xc3220d37, 0xc5825000, 0x3f565120, 0x82532006, 0x82542007, 0x82552023, 0x82562007, 0x82582003, 0x82822003, 0x8283200f, 0x82842003, 0x82852003,
	0x82862003, 0x82872003, 0xff882303, 0x574b0085, 0x82a2201b, 0x82a32023, 0x82a42003, 0x82a52003, 0x82a62003, 0x82a72003, 0x175f5603, 0x6b82b320,
	0x6356b420, 0x82bb2016, 0x82bc201b, 0x82bd2003, 0x82be2003, 0x82c22003, 0x82c32027, 0x82c42003, 0x82c52003, 0x82c62003, 0x82c72003, 0x82c82003,
	0x0b7b561b, 0x0f82ce20, 0x4f177f56, 0x06240fcf, 0x0801d7ff, 0x0a200382, 0x0e200382, 0x93560382, 0x82122007, 0xff13240b, 0x821401c3, 0x82152007,
	0x821d2007, 0x821f2007, 0x82212003, 0x82232003, 0x82432003, 0x82442013, 0x824a2003, 0x825f200b, 0x82662007, 0x82692007, 0x826d2007, 0x82792007,
	0x827b2007, 0x827e2007, 0x82822007, 0x82842003, 0x0b8f560b, 0x13829320, 0x200b8756, 0x500f82aa, 0x01210647, 0x560b82ca, 0x5b560b63, 0xffee220b,
	0x0a8f44d7, 0x5802c326, 0x5902c3ff, 0x5f200382, 0x4f561782, 0x826c2007, 0x8272200b, 0x827e2013, 0x827f2007, 0x217b8207, 0x07828502, 0x0f828620,
	0x07828720, 0x07828820, 0x07828920, 0x20078f50, 0x200b828d, 0x201382b1, 0x200782b2, 0x200782b3, 0x200782b4, 0x200382d9, 0x200382da, 0x200382db,
	0x200382dc, 0x200382dd, 0x500382e0, 0xf0200bb3, 0xf1200f82, 0xf2202f82, 0xf3200782, 0xf4240782, 0x0a03c3ff, 0x0c200382, 0x15240382, 0x1603d7ff,
	0x19200782, 0x1a200782, 0x1d200782, 0x1e200382, 0x1f200382, 0x21200382, 0x22200382, 0x23200382, 0x24200382, 0x25200382, 0x26200382, 0x27200382,
	0x28200382, 0x29200382, 0x2a200382, 0x2b200382, 0x2c200382, 0x2d200382, 0x2e200382, 0x2f200382, 0x30200382, 0x31200382, 0x32200382, 0x33200382,
	0x34200382, 0x3f560382, 0x8249201f, 0x824a2083, 0x824b2027, 0x824c2007, 0x824d2007, 0x824e2007, 0x824f2007, 0x82502007, 0x82512007, 0x82522007,
	0x82532007, 0x82542007, 0x82552007, 0x82562007, 0x82572007, 0x82582007, 0x82592007, 0x825a2007, 0x825b2007, 0x825c2007, 0x825d2007, 0x825e2007,
	0x825f2007, 0x82602007, 0x82622007, 0x82642007, 0x82662003, 0x82682003, 0x826a2003, 0x826c2003, 0xff6e2a03, 0x00e900d7, 0x00660005, 0x2403820a,
	0x00aeff0f, 0x20038211, 0x4d158224, 0x44200fbf, 0x46201382, 0x47200382, 0x48200382, 0x4a240382, 0x5000ecff, 0x51200382, 0x52200382, 0x53200f82,
	0x54200782, 0x55200782, 0x56200782, 0x58200782, 0x5d200782, 0x91500382, 0x00ae2119, 0x201bdf4f, 0x204382a2, 0x200382a3, 0x200382a4, 0x200382a5,
	0x200382a6, 0x200382a7, 0x200382a8, 0x200382a9, 0x200382aa, 0x200382ab, 0x200382ac, 0x200382ad, 0x206b82b3, 0x200782b4, 0x200382b5, 0x200382b6,
	0x200382b7, 0x200382b8, 0x200382ba, 0x201b82bb, 0x200382bc, 0x200382bd, 0x200382be, 0x201382c2, 0x200382c3, 0x200382c4, 0x200382c5, 0x200382c6,
	0x200382c7, 0x201b82c8, 0x200782c9, 0x200382cb, 0x200382cd, 0x200f82ce, 0x200782cf, 0x200382d5, 0x200382d7, 0x200382d9, 0x200382db, 0x550382dd,
	0x06240f4d, 0x0801ecff, 0x0a200382, 0x24065955, 0x01d7ff0f, 0x20038211, 0x200f8212, 0x20078213, 0x20078214, 0x43078215, 0x40200fa1, 0x43201782,
	0x44201782, 0xa5430382, 0x01d72205, 0x20138266, 0x200f8269, 0x2007826d, 0x20078279, 0x2007827b, 0x2007827e, 0x20038282, 0x200b8284, 0x2007828c,
	0x2003828e, 0x20038290, 0x20038293, 0x20038296, 0x20038299, 0x06bd519b, 0x2106ef50, 0x0f82ca01, 0x0382cf20, 0x0382d820, 0x0382db20, 0x0382de20,
	0x0382ea20, 0x0382ed20, 0x2a05a543, 0x000b0266, 0xff280266, 0x825802d7, 0x82592003, 0xff5f2403, 0x826002ec, 0x826a2007, 0x826c2003, 0x8272200b,
	0x827e2007, 0x827f2007, 0x82842007, 0x82852007, 0x82862007, 0x82872007, 0x82882007, 0x82892007, 0x07cd5507, 0x0b828d20, 0x1382b120, 0x0782b220,
	0x0782b320, 0x0782b420, 0x0382d920, 0x0382da20, 0x02217f82, 0x200782dc, 0x200382dd, 0x510382e0, 0xf0200b5b, 0xf1200f82, 0xf2202f82, 0xf3200782,
	0xf4240782, 0x0a03d7ff, 0x0c200382, 0x15240382, 0x1603ecff, 0x19200782, 0x1a200782, 0x1d200782, 0x1e200382, 0x200a6d52, 0x200b8222, 0x20038223,
	0x20038224, 0x20038225, 0x20038226, 0x20038227, 0x20038228, 0x20038229, 0x2003822a, 0x2003822b, 0x2003822c, 0x2003822d, 0x2003822e, 0x2003822f,
	0x20038230, 0x20038231, 0x20038232, 0x20038233, 0x20038234, 0x20038236, 0x20038238, 0x2003823a, 0x2003823c, 0x2003823e, 0x20038240, 0x20038242,
	0x20038244, 0x20838249, 0x2007824a, 0x2007824b, 0x2007824c, 0x2007824d, 0x2007824e, 0x2007824f, 0x20078250, 0x20078251, 0x20078252, 0x20078253,
	0x20078254, 0x20078255, 0x20078256, 0x20078257, 0x20078258, 0x20078259, 0x2007825a, 0x2007825b, 0x2007825c, 0x2007825d, 0x2007825e, 0x2007825f,
	0x20078260, 0x20078262, 0x20038264, 0x20038266, 0x20038268, 0x2003826a, 0x2403826c, 0x00ecff6e, 0x082b568c, 0x200f3747, 0x201d8246, 0x20038247,
	0x20038248, 0x20038252, 0x46038254, 0xa8201bfb, 0xa9201f82, 0xaa200382, 0xab200382, 0xac200382, 0xad200382, 0xb4200382, 0xb5200382, 0xb6200382,
	0xb7200382, 0xb8200382, 0xba200382, 0xb7460382, 0x00ec2205, 0x200b82cb, 0x460382cd, 0xec2205b7, 0x0b82d500, 0x0382d720, 0x0382d920, 0x0382db20,
	0x0382dd20, 0x460fb746, 0xec2505ab, 0xecff1101, 0x05ab4601, 0xab46ec20, 0x01ec2106, 0x20079b56, 0x201b8279, 0x2003827e, 0x20038282, 0x2003828c,
	0x2003828e, 0x20038290, 0x20038293, 0x20038296, 0x20038299, 0x4603829b, 0xcf20077b, 0xd8200b82, 0xdb200382, 0xde200382, 0xea200382, 0xed220382,
	0xdb56ecff, 0x8260200c, 0x826a200f, 0x07e35603, 0x0b827f20, 0x21056346, 0x634602ec, 0x02ec2105, 0x21056346, 0x634602ec, 0x02ec2109, 0x21056346,
	0x634602ec, 0x02ec2205, 0x463782e0, 0xec260d4f, 0xd7fff102, 0x1782f202, 0x26054f46, 0xff0a03ec, 0x820c03ec, 0x054f4603, 0x4603ec21, 0xec22054f,
	0x13823603, 0x03823820, 0x03823a20, 0x03823c20, 0x03823e20, 0x03824020, 0x03824220, 0x03824420, 0x2105f345, 0xf34503ec, 0x03ec2105, 0x2105f345,
	0xf34503ec, 0x03ec2105, 0x2105f345, 0xf34503ec, 0x03ec2105, 0x2105f345, 0xf34503ec, 0x03ec2105, 0x2105f345, 0xf34503ec, 0x03ec2105, 0x2105f345,
	0xf34503ec, 0x01ec2205, 0x16794906, 0x79499a20, 0xff362810, 0xff4400ec, 0x8246009a, 0x82472003, 0x82482003, 0x05854e03, 0x5100c326, 0x5200c3ff,
	0x53200f82, 0x54200782, 0x55200782, 0x56240782, 0x5800aeff, 0x5b240782, 0x5c00d7ff, 0x7d4e3b82, 0x009a2205, 0x201f8283, 0x20038284, 0x20038285,
	0x20038286, 0x4e038287, 0xd721057d, 0x17c15800, 0x2382a220, 0x0382a320, 0x0382a420, 0x0382a520, 0x0382a620, 0x0382a720, 0x0382a820, 0x0382a920,
	0x0382aa20, 0x0382ab20, 0x0382ac20, 0x0382ad20, 0x7782b320, 0x0782b420, 0x0382b520, 0x0382b620, 0x0382b720, 0x0382b820, 0x0382ba20, 0x1b82bb20,
	0x0382bc20, 0x0382bd20, 0x0382be20, 0x9b82bf20, 0x0382c120, 0x1b82c220, 0x0382c320, 0x0382c420, 0x0382c520, 0x0382c620, 0x0382c720, 0x2205d942,
	0x82cb009a, 0x82cd200b, 0x05d94203, 0xd5009a22, 0xd7200b82, 0xd9200382, 0xdb200382, 0xdd200382, 0xd9420382, 0xff06240f, 0x820801c3, 0x820a2003,
	0x05e54203, 0x11019a24, 0xe5429aff, 0x429a2006, 0x9a2106e5, 0x057d4e01, 0x1f01ae25, 0x4e01aeff, 0xae21057d, 0x057d4e01, 0x3901ae25, 0x4e01ecff,
	0x9a220571, 0x3b824401, 0x23824a20, 0x07825f20, 0x2105a549, 0xa549019a, 0x019a2205, 0x2063827b, 0x2017827e, 0x202f8280, 0x20078282, 0x200f8284,
	0x200b828a, 0x200b828c, 0x2003828e, 0x20038290, 0x20038293, 0x20038296, 0x20038299, 0x4e03829b, 0x9a210565, 0x09b14901, 0xcf019a22, 0xd8201782,
	0xdb200382, 0xdd200382, 0xde203f82, 0xea200782, 0xed200382, 0xee260382, 0x0102aeff, 0xb949ecff, 0x029a260a, 0x029aff58, 0x49038259, 0x9a2205b9,
	0x0b826a02, 0xd7ff6c24, 0x27826d02, 0x0b827220, 0x2205bd49, 0x8281029a, 0x4383200f, 0x9a200861, 0x20066143, 0x0661439a, 0x8a029a22, 0x8b203382,
	0x8c201f82, 0x8d200782, 0x65433782, 0x439a2005, 0x9a220665, 0x1b82b802, 0x0382ba20, 0x1b82d920, 0x0382da20, 0x02219f82, 0x200782dc, 0x200382dd,
	0x430382e0, 0x9a200d81, 0x21068143, 0x8143029a, 0x029a2205, 0x203b82f8, 0x280382fa, 0x03ecfffc, 0x039aff0a, 0x2003820c, 0x200b820e, 0x08954310,
	0x95439a20, 0x039a2206, 0x201b821d, 0x2003821e, 0x2003821f, 0x20038221, 0x20038222, 0x20038223, 0x20038224, 0x20038225, 0x20038226, 0x20038227,
	0x20038228, 0x20038229, 0x2003822a, 0x2003822b, 0x2003822c, 0x2003822d, 0x2003822e, 0x2003822f, 0x20038230, 0x20038231, 0x20038232, 0x20038233,
	0x20038234, 0x20038236, 0x20038238, 0x2003823a, 0x2003823c, 0x2003823e, 0x20038240, 0x20038242, 0x43038244, 0x9a2005f1, 0x2006f143, 0x06f1439a,
	0xf1439a20, 0x439a2006, 0x9a2006f1, 0x2006f143, 0x06f1439a, 0xf1439a20, 0x439a2006, 0x9a2006f1, 0x2006f143, 0x06f1439a, 0xf1439a20, 0x039a2606,
	0x03c3ff62, 0x20038264, 0x20038266, 0x20038268, 0x2003826a, 0x2003826c, 0x2403826e, 0x03ecff70, 0x22038272, 0x58ecff74, 0x6f5e0c8b, 0x1b91490d,
	0x48217159, 0x6d2305b9, 0x5901ecff, 0x01268371, 0xd7ff0a00, 0x435b0400, 0x5a022007, 0x002106c3, 0x08ef4a26, 0x14005923, 0x05896400, 0xbf001422,
	0xc1240b82, 0x37011400, 0x39200382, 0x80200382, 0x8a200382, 0x91200382, 0x94200382, 0xdc200382, 0xdd200382, 0xfb200382, 0xfd200382, 0xff240382,
	0x01021400, 0x07210382, 0x05434900, 0x0b826d20, 0x03828120, 0x03828320, 0x03828b20, 0x0382aa20, 0x0382b620, 0x0382b820, 0x0382ba20, 0x0382f820,
	0x0382fa20, 0x1400fc24, 0x03820e03, 0x03821020, 0x03821820, 0x03827020, 0x03827220, 0x7f827420, 0xe3470520, 0x844a2008, 0x02292559, 0x0029000b,
	0xc320c783, 0x2924c784, 0x29000a00, 0x2307e746, 0x5b000300, 0x5d28df82, 0x4001ecff, 0x1f00ecff, 0x4420d588, 0x4a200d82, 0xa2200382, 0xa3200382,
	0xa4200382, 0xa5200382, 0xa6200382, 0xa7200382, 0xc3200382, 0xc5200382, 0xc7200382, 0x2b823982, 0xffca0123, 0x855382ec, 0x825920c5, 0x82da200b,
	0xffdc2403, 0x821e03ec, 0x82222003, 0x82242003, 0x82262003, 0x82282003, 0x822a2003, 0x822c2003, 0x822e2003, 0x82302003, 0x82322003, 0x82342003,
	0x20b9834b, 0x229d8252, 0x84570052, 0x825220b9, 0x825220b9, 0x070f5591, 0x158a4920, 0xe5883620, 0xbf825220, 0x0382a820, 0x2016b74b, 0x07434b01,
	0xd7ff1324, 0x03821501, 0x201bf74a, 0x05df4ad8, 0x4a080548, 0x7f2407c3, 0x8502d7ff, 0x87200382, 0x89200382, 0x8d200382, 0xb2200382, 0xb4200382,
	0x2006874a, 0x200782f0, 0x4a0382f2, 0x16240b73, 0x1a03d7ff, 0x4a200382, 0x4c200382, 0x4e200382, 0x50200382, 0xaf820382, 0x82540321, 0x82562007,
	0x82582003, 0x825a2003, 0x825c2003, 0x825e2003, 0x82602003, 0x5d0520c7, 0xef8508af, 0x0b023d2c, 0x32003d00, 0xecff5200, 0x0382a800, 0x82166149,
	0x01ec26e7, 0x01ecff11, 0x20038213, 0x1e054915, 0x1f82d820, 0xecffde23, 0x07e14802, 0x0b827f20, 0x03828520, 0x03828720, 0x03828920, 0x03828d20,
	0x0382b220, 0x0382b420, 0x0382e020, 0x0382f020, 0x0382f220, 0x48fff421, 0x162009a9, 0x1a200b82, 0x4a200382, 0x4c200382, 0x4e200382, 0x50200382,
	0xa7820382, 0xec22df82, 0x0b825603, 0x03825820, 0x03825a20, 0x03825c20, 0x03825e20, 0xbf826020, 0x71010326, 0x7801d7ff, 0x91230382, 0x83002900,
	0x019a240d, 0x82c3ff72, 0x00c32211, 0x08c36294, 0x85ff0d28, 0x44000f00, 0x03821e00, 0xc3ff2224, 0x39822600, 0x03822a20, 0x5e002d23, 0x1bd76200,
	0x3b003d24, 0x27824900, 0x03825720, 0xd7ff5924, 0x07825a00, 0x07825c20, 0x03828220, 0x5c1b9744, 0xbf201329, 0xc1203382, 0x5e06d14d, 0x00231225,
	0x625e00f6, 0x372828ff, 0x3801ecff, 0x39019aff, 0x3a20f782, 0x3b230782, 0x82013b00, 0x3f0121ab, 0x66200782, 0x2406615e, 0x0185ff71, 0x201f8280,
	0x2003828a, 0x20038291, 0x20038294, 0x636382a3, 0xdc200b27, 0xdd201382, 0xfa200382, 0xfb200382, 0xfc203782, 0xfd200782, 0xfe200782, 0xff2b0782,
	0x0002ecff, 0x01029aff, 0x6302d7ff, 0x6d20133f, 0x2006854d, 0x20078281, 0x63038283, 0x8b200f4b, 0x4f631382, 0x82aa2007, 0x0b53630b, 0x0f82b620,
	0x85ffb724, 0x0782b802, 0x0782b920, 0x0782ba20, 0x21165f63, 0x1b82f802, 0x0382fa20, 0xd7fffc24, 0x03820e03, 0x03821020, 0xecff1528, 0x85ff1703,
	0x854d1803, 0x4f776306, 0x57827020, 0x9aff7124, 0x07827203, 0x07827320, 0x07827420, 0x85ff8324, 0x51429100, 0x334d4220, 0x104e4942, 0xa0014502,
	0x45429220, 0x447f200a, 0xd7200a97, 0x282c9744, 0x00e5ff57, 0x00d5ff59, 0x2207825a, 0x52dbff5c, 0x8f441cb9, 0x00db2215, 0x493782c1, 0x8f441643,
	0x44e5202e, 0xdb21068f, 0x1d8f4401, 0x8a01db26, 0x9101d5ff, 0x94200382, 0x8f440382, 0x01d52511, 0x01dbffdd, 0x21058f44, 0x8f4401e5, 0x01e52105,
	0x20058f44, 0x068f44e5, 0x8f44db20, 0x02db2a16, 0x02ecff7e, 0x02dbff81, 0x44038283, 0xdb21118f, 0x098f4402, 0xe367d520, 0xffb6230c, 0x8f4402d5,
	0x02db2105, 0x21058f44, 0x8f4402db, 0x02db2219, 0x245f82fa, 0x03dbfffc, 0x2003820e, 0x44038210, 0xd520098f, 0x20540768, 0x44638270, 0xdb21058f,
	0x058f4403, 0x8303db2c, 0x950085ff, 0x66ff0500, 0x03820a00, 0x10ff0d21, 0x35014902, 0x66ff0628, 0xaeff0702, 0x07820a02, 0x07820b20, 0x5b632020,
	0xff6d210e, 0x66f15542, 0x10200917, 0x46067557, 0x842407d5, 0x8900ecff, 0x8a200382, 0x6b06f168, 0x534417f3, 0x00f62207, 0x088d463d, 0x20079748,
	0x4d1382a3, 0x3720838b, 0x8f08f34b, 0x20e183e5, 0x22e7678b, 0x229bdd40, 0x5d240020, 0x655d1a69, 0x00572463, 0x6bd7ff0c, 0x2d24105f, 0x3600f6ff,
	0x37249982, 0x3900c3ff, 0xf1651f82, 0x8240200f, 0x82602013, 0x196f6b03, 0x292cf965, 0xf6fff600, 0xecff1c01, 0x03822001, 0x7f6b2220, 0x82a02032,
	0x82a32033, 0x8f876b43, 0x515f4220, 0xff30240c, 0x823d00ec, 0x41442003, 0x88231af3, 0x4f00d7ff, 0xc220177f, 0x2006834f, 0x06874fc4, 0x8b4fc620,
	0x0f996c06, 0x01205f82, 0x24079d6c, 0x01ecffaa, 0x0a955fca, 0x0b825920, 0x03827220, 0x0382d920, 0x0382da20, 0x0382db20, 0x0382dc20, 0xecffdd24,
	0xbb4f1d03, 0x821f2006, 0x82212007, 0x82222003, 0x82232003, 0x82242003, 0x4f252003, 0x272006cb, 0x28200782, 0x29200382, 0x2006d34f, 0x06d74f2b,
	0xdb4f2d20, 0x4f2f2006, 0x312006df, 0x32200782, 0x2006a56c, 0x2a838234, 0x0005002f, 0xff090052, 0x820a00c3, 0x000c2507, 0x000d003d, 0x6405996c,
	0x63560ded, 0xff2d2409, 0x823000be, 0xff32242f, 0x823400d7, 0x82362003, 0x003724ed, 0x82390027, 0x003a2437, 0x82400014, 0x0f7b5643, 0xe5ff4923,
	0x237f5600, 0x5607254e, 0x60200b87, 0x82214f82, 0xec8b56ff, 0xfff60024, 0x8f5601be, 0x00242443, 0x82260127, 0x00362603, 0xff370114, 0x249f56ec,
	0x2f827120, 0x56ff7921, 0xd72117a3, 0x0ba35601, 0xd7ff9124, 0x2b829301, 0x07829420, 0x200fab56, 0x20c382a3, 0x561b82aa, 0xbc2007af, 0xca205782,
	0xb3560f82, 0x05414f0b, 0x5601ec21, 0x01210eb7, 0x20af82fa, 0x20af82fb, 0x200782fc, 0x200782fd, 0x220782fe, 0x56ecffff, 0xa92368cf, 0x4f022700,
	0xd7230575, 0x56ffb202, 0xb52009d7, 0xb6241782, 0xb702d7ff, 0xb8200782, 0xb9208f82, 0xba200782, 0xbd200782, 0xeb560782, 0x0017225b, 0x06ad4f27,
	0x1a03d723, 0xf31610ff, 0x032f0401, 0x00270083, 0xff050002, 0xff0a0098, 0x870300d7, 0x0b022109, 0x06200d82, 0x6f200d82, 0x6f241782, 0xdbff4900,
	0x830c5555, 0x82be2031, 0x00be2219, 0x08db5361, 0xbeff0f24, 0x03821100, 0xb4ff2228, 0xf6ff4600, 0x03824700, 0x03824820, 0x14004924, 0x07824a00,
	0x03825220, 0x03825420, 0x06005724, 0x0782a800, 0x0382a920, 0x0382aa20, 0x0382ab20, 0x0382ac20, 0x0382ad20, 0x0382b420, 0x0382b520, 0x0382b620,
	0x0382b720, 0x0382b820, 0x0382ba20, 0x0382c920, 0x0382cb20, 0x0382cd20, 0x0382cf20, 0x0382d520, 0x0382d720, 0x0382d920, 0x0382db20, 0xf6ffdd24,
	0x03820f01, 0x03821120, 0x03821320, 0x03821520, 0x03827920, 0x03827e20, 0x03828220, 0x03828c20, 0x03828e20, 0x03829020, 0x03829320, 0x03829620,
	0x03829920, 0x03829b20, 0x01214f82, 0x200782d8, 0x200382db, 0x200382de, 0x2c0382ea, 0x02f6ffed, 0x023d0007, 0x028dff08, 0x2007820b, 0x2807820c,
	0x0281ff10, 0x020c0015, 0x201b8260, 0x2003826a, 0x2003827f, 0x20038285, 0x20038287, 0x20038289, 0x2003828d, 0x200382b2, 0x200382b4, 0x200382e0,
	0x200382f0, 0x240382f2, 0x03f6fff4, 0x2003820a, 0x2003820c, 0x20038216, 0x2003821a, 0x20038236, 0x20038238, 0x2003823a, 0x2003823c, 0x2003823e,
	0x20038240, 0x20038242, 0x20038244, 0x2003824a, 0x2003824c, 0x2003824e, 0x20038250, 0x20038252, 0x20038254, 0x20038256, 0x20038258, 0x2003825a,
	0x2003825c, 0x2003825e, 0x20ff8260, 0x10854107, 0x200b6955, 0x08eb4f65, 0x20097354, 0x1c7354e1, 0x4f2f0d52, 0x055216bf, 0xf34b7728, 0x28099958,
	0x008f000c, 0x00a40022, 0x24038240, 0x00520045, 0x2403824b, 0x003d004c, 0x2003824d, 0x200b824e, 0x2c03824f, 0x00b80060, 0x00f600ae, 0x00cd00b0,
	0x200382b1, 0x201382e7, 0x242f82e9, 0x000a01eb, 0x200f82ed, 0x241b82ef, 0x002900f1, 0x243382f5, 0x00e100f7, 0x201f82f9, 0x240382fc, 0x015200fe,
	0x20038200, 0x28038202, 0x02520004, 0x028f0007, 0x266f820b, 0x002d0001, 0x4c3a0066, 0x1942087f, 0x42522009, 0x05420819, 0x21f1411b, 0x208d6774,
	0x22e98843, 0x4b140030, 0xd72006fd, 0x710a6577, 0x592405ef, 0x5c00ecff, 0x9f240382, 0xbf00d7ff, 0x4b05255f, 0x23280cb9, 0x2401ecff, 0x2601d7ff,
	0x36200382, 0x38200b82, 0x39200782, 0x3a200782, 0x71200782, 0x80200382, 0x8a200b82, 0x91200382, 0x94200382, 0xa0200382, 0xbc200382, 0xdc201782,
	0xdd200782, 0x41770382, 0x05595e0f, 0x0b022928, 0x6d022900, 0x315eecff, 0x828b2008, 0xffa9240b, 0x82aa02d7, 0x82b52007, 0x82b62007, 0x82b72007,
	0x82b82007, 0x82b92007, 0x82ba2007, 0x82bd2007, 0x0be15d07, 0x2807d95d, 0x03d7ff17, 0x03ecff18, 0x2007826f, 0x20078270, 0x20078271, 0x20078272,
	0x20078273, 0x20078274, 0x208f8283, 0x1603611e, 0x028d2f10, 0x852f1055, 0x01200a02, 0x4f057944, 0x5c201529, 0x4f0ac77b, 0xec210f29, 0x0f294f00,
	0x103b214f, 0x4f01190f, 0x4f23b165, 0xec201d11, 0x650c114f, 0x094f13b5, 0x1fbd6523, 0xd7ff0f25, 0x65ff2802, 0xa92259c1, 0x2b692700, 0x0ded4e06,
	0x2173e94e, 0x0e10ff19, 0x200d01e5, 0x08014ac5, 0x7d611020, 0x0755580a, 0xd7ff3627, 0xecff3800, 0x13356c00, 0x22054f53, 0x615c00d7, 0x516c2e71,
	0x0b9d612f, 0x8b82c920, 0x2209596c, 0x82cf00ec, 0x15596c0f, 0x1800ec21, 0x240fbd44, 0x01ecff0f, 0x20038211, 0x063b6312, 0x26050573, 0xff1c01ec,
	0x822001d7, 0x82222003, 0xd1441803, 0x8237200f, 0x82392013, 0x07215903, 0x20077d6c, 0x20138280, 0x20478282, 0x6c07828a, 0xb3520b85, 0x01ec2105,
	0x2105b352, 0x8d6c01ec, 0x82a02007, 0x82b82027, 0x82bb202f, 0x0b916c03, 0x2105a352, 0x996c01d7, 0xfb01210a, 0xfd202b82, 0xff220382, 0xe161d7ff,
	0x85431805, 0x05c76308, 0xad6c6120, 0x02ec2108, 0x2007e961, 0x6113827f, 0x85200bed, 0x776f0f82, 0x02ec2105, 0x2205776f, 0x828a02ec, 0x07f96113,
	0x0b828d20, 0x22058352, 0x82b202ec, 0x057f6f0b, 0xb602ec22, 0xb8207382, 0xba200382, 0xcd6c0382, 0x02ec2105, 0x07554518, 0x2782f020, 0x2105776f,
	0x776f02ec, 0x62ec2005, 0x0a240c01, 0x0c03ecff, 0x09620382, 0x8216200b, 0x0709620f, 0x0b821a20, 0x2221e56c, 0x824a03ec, 0x05336f27, 0x6f03ec21,
	0xec220533, 0x73644f03, 0x05336f06, 0x6f03ec21, 0xec210533, 0x05336f03, 0x6f03ec21, 0xec220533, 0x27825903, 0x03825a20, 0x2105336f, 0x336f03ec,
	0x03ec2105, 0x2105336f, 0x451803ec, 0x70241bd5, 0x7203d7ff, 0x74240382, 0x3300d7ff, 0x22548565, 0x6514000b, 0x0b247489, 0x29006201, 0x82052772,
	0xff6d3007, 0xff7101ec, 0xff720185, 0xff73019a, 0x827501d7, 0x82782003, 0x8288200b, 0xff91241b, 0x180300c3, 0x26080943, 0x00ecff73, 0x825f010b,
	0x8264202f, 0x82672003, 0x826c2003, 0x84702003, 0x82c3203f, 0x01d7223f, 0x203b8274, 0x200f8277, 0x20078278, 0x222d8288, 0x82100024, 0xff6d2241,
	0x223582c3, 0x7662019a, 0x73200a43, 0x76202182, 0x79200382, 0x7a206982, 0x20060156, 0x201f827d, 0x240b827e, 0x01aeff81, 0x20078282, 0x201f8283,
	0x20138284, 0x20078285, 0x20078286, 0x20038287, 0x20038289, 0x06b96c8c, 0x07828f20, 0x03829020, 0x13829220, 0x33829320, 0x27829420, 0x0b829520,
	0x0b829620, 0x0b829820, 0x1b829920, 0x0f829a20, 0xaeff9b28, 0xc3ff0202, 0xcd840302, 0x11827120, 0x03827220, 0x0d827820, 0x79011922, 0x7d202782,
	0x7e200382, 0x80200382, 0x81200382, 0x83200382, 0x7385c182, 0x8801d726, 0x8a012900, 0x8b201382, 0x8c201382, 0x8d200782, 0x8f200782, 0x90200382,
	0x91200b82, 0x92200782, 0x93200782, 0x94200382, 0x95200b82, 0x96200782, 0x7b850782, 0x9a01d722, 0x9b240f82, 0x5000d7ff, 0x64105952, 0x4f501b7b,
	0x131d621b, 0x20216350, 0xd74218d7, 0x18d7201a, 0x4214d742, 0xc329090b, 0x9aff7801, 0xc3ff9101, 0xa9491801, 0x6503201e, 0x71204fd9, 0x08414b18,
	0x18008523, 0x4d491800, 0x05914223, 0x4201d721, 0xec260591, 0xecff7201, 0x03827401, 0x20059142, 0x29c582ec, 0xff9401ec, 0xff0002ec, 0x401803ec,
	0x03250add, 0x00ecff83, 0x7b441872, 0x0b7d7f08, 0x180fc776, 0x25138744, 0x009aff6d, 0x8f76ff7d, 0x35b7411d, 0x258f4418, 0x85ff5f28, 0x9aff6201,
	0xe9826601, 0x07826920, 0x07826d20, 0xaeff7323, 0x055d4301, 0x7a018522, 0x200e717e, 0x7e238281, 0xc3210575, 0x0b554301, 0xc3ff8a24, 0x2b828c01,
	0x07828d20, 0x23828e20, 0x897e8f20, 0x0561430a, 0x94018522, 0x61431b82, 0x019a2605, 0x01290097, 0x200f8298, 0x43278299, 0x9a220565, 0x0f82fa01,
	0x0b034518, 0x9aff0224, 0x03820302, 0x03820720, 0x0a0b4518, 0x205c2b42, 0x16b551b2, 0x01333c10, 0x00622271, 0x08a77514, 0x6bff7121, 0x614605ed,
	0x01c32a09, 0x01c3ff79, 0x01290088, 0x1df37b8d, 0x5b7b0320, 0x470820f7, 0x01250b79, 0x01d7ff92, 0x43038295, 0xd7260577, 0xd7ff9a01, 0xb5614700,
	0x17ad6110, 0x1846a561, 0x2028154d, 0x24a98262, 0x01ecff67, 0x16254869, 0x1f827820, 0x240fe755, 0x02ecff28, 0x06836058, 0x43014d18, 0x3f410520,
	0x8281200c, 0x00882489, 0x792a0029, 0xf778180b, 0x2b4f181b, 0x4b4b181f, 0xff73240b, 0x419101ae, 0x517005a9, 0xff5f2308, 0x4e1803d7, 0xd0202ff3,
	0x20083748, 0x20b78222, 0x128f4d24, 0x13e15118, 0x51094118, 0x2d674b18, 0x751d4118, 0x1800ec21, 0x210d1d41, 0x411800ec, 0x0b4e191d, 0x1d41180d,
	0x01ec210d, 0x091d4118, 0x1801ec21, 0x181b1d41, 0x49192b4c, 0x41180953, 0xed6f0b41, 0x115f490b, 0x5f49d720, 0xff282118, 0x0b054118, 0x6002ec22,
	0x61220f82, 0x1545ecff, 0x03ec257e, 0x03c3ff4a, 0x2005974d, 0x06974dc3, 0x974dc320, 0x03c32106, 0x2005974d, 0x06974dc3, 0x974dc320, 0x4dc32006,
	0xc3200697, 0x2106974d, 0x974d03c3, 0x4dc32005, 0xc3200697, 0x2106974d, 0xdf8303c3, 0xd7ff6224, 0xe7826303, 0x07826420, 0x07826520, 0x07826620,
	0x07826720, 0x07826820, 0x07826920, 0x07826a20, 0x07826b20, 0x07826c20, 0x07826d20, 0x55186e20, 0x85201079, 0x220abb4c, 0x45290088, 0x29459a2d,
	0x05bd4a1b, 0x4501d721, 0x36205f2d, 0x70b94c18, 0xaeff6228, 0xecff6401, 0x07826901, 0x07827420, 0x03827820, 0xd7ff8124, 0x03828801, 0xd7ff8e22,
	0x0bcd4c18, 0x3cbd4c18, 0xf1452920, 0x77b58262, 0x0220095d, 0x2033ed45, 0x0cb74aea, 0x5c0d1167, 0xc54c6171, 0x00d72105, 0x01074c10, 0x05a14d57,
	0x1801c321, 0x240b0b4c, 0x01c3ff73, 0x21038276, 0xa54dff79, 0x187d2009, 0x510a1b4c, 0x85220507, 0x13828401, 0x03828620, 0x03828720, 0x14008824,
	0x4c188901, 0xa94d0e2f, 0x01ae210d, 0x07374c18, 0x27829520, 0x5b829620, 0x3d009724, 0x0b829801, 0x2205a94d, 0x189b01ae, 0x4d140b4c, 0x4c1806a9,
	0x0320190b, 0x01234b10, 0x002d2107, 0x25052350, 0xff1100c3, 0xdd52009a, 0x019a2511, 0x01d7ff6d, 0x2105dd41, 0xe15201d7, 0x01ae2905, 0x01c3ff7b,
	0x01ecff7c, 0x22056d52, 0x827f019a, 0x058b4f23, 0x5201ae21, 0xe94113e9, 0x01c32105, 0x21057952, 0x934f019a, 0x019a2505, 0x019aff90, 0x20057952,
	0x080f69c3, 0x2005934f, 0x0a934fae, 0x52019a21, 0x0a250ff9, 0xd7ff5f01, 0x09974b01, 0x5301d721, 0x74200709, 0x77209982, 0x78201b82, 0x88240782,
	0x1700d7ff, 0x8308b54d, 0x827920c3, 0x22b785b3, 0x827e01ec, 0x8281200b, 0x82852003, 0x82862003, 0x20a38303, 0x0811538c, 0x9782ec20, 0x5301d721,
	0xec210511, 0x0d0d5301, 0x0d53ec20, 0x00ec2a06, 0xff0f000c, 0xff1100ae, 0x208f82ae, 0x208f84c3, 0x20778269, 0x95461881, 0x82ec2008, 0x01ec21d5,
	0x0abb4318, 0x86030021, 0x01d722a9, 0x209d8278, 0x108d632c, 0x53074d53, 0x25531b39, 0x09896321, 0x8b827320, 0xe9868020, 0x9120e183, 0x0c1f4418,
	0xbd50ec20, 0xef00212f, 0x5d1af76c, 0x6d2779cd, 0x7d00c3ff, 0x1000d7ff, 0x3f01ef2c, 0x5617d55d, 0x0f4409ed, 0x01c3231f, 0x0f44ff7e, 0x05754205,
	0xfd569a20, 0x0da3530c, 0x0f44ec20, 0xff8d2208, 0x0e1344d7, 0x5301d721, 0x9a2105a7, 0x09095701, 0x440ba753, 0x9a200713, 0x5d0cdb6c, 0x421016ed,
	0x2f0301eb, 0x27008303, 0x88010100, 0x06002900, 0xd7ff7901, 0x2408ff44, 0x01ecff8c, 0x24038290, 0x00ecff93, 0x20198214, 0x06d945ec, 0x4101ec21,
	0xec2105c1, 0x09214501, 0x83053f58, 0x093b5831, 0x22072945, 0x829501ec, 0x82972045, 0x82982003, 0x82992003, 0x829a2003, 0x01012651, 0x00ecff94,
	0x08ad6a0b, 0x63824920, 0x1b828120, 0x29008d24, 0x07828e01, 0x0f829120, 0x03829420, 0x5d189620, 0x0022095b, 0x4d670102, 0x89d72005, 0x83b18437,
	0x828c2037, 0x07b358b9, 0x0b829320, 0xd7ff9922, 0x08cf4218, 0x25821c20, 0x7a01ae22, 0x20080559, 0x26c182c3, 0xff8101d7, 0x828201c3, 0x05974613,
	0xcd82d720, 0x8601d722, 0x87200f82, 0x11597d82, 0x01d72209, 0x2027828c, 0x2003828d, 0x2003828f, 0x20038290, 0x42038291, 0xc3200583, 0xc322d982,
	0x0f829601, 0x03829820, 0x03829920, 0x22058f46, 0x821000c3, 0x005224d7, 0x8452000a, 0x827d209f, 0x827e2051, 0x82802003, 0x0573595d, 0x7359ec20,
	0x828d2008, 0x82912013, 0x20b38303, 0x5d461897, 0x09002109, 0x84070146, 0x827e2041, 0x82812021, 0x82822003, 0x458c2045, 0x002109a9, 0x0c3f410d,
	0x80206783, 0x63832182, 0x3d008824, 0x31828a01, 0xc3225f85, 0x0f419401, 0x09236c0a, 0x14004924, 0x03828d01, 0x53848e20, 0x0b023d28, 0x03003d00,
	0x3b821e00, 0x05417e20, 0x185f8205, 0x410a4343, 0x0421087f, 0x82cf8401, 0x008a2839, 0x00910129, 0x6e070014, 0x01200b15, 0x071b4418, 0x91245b83,
	0x0e002900, 0x8208f74b, 0x7d002171, 0x21833382, 0x63828120, 0x8c203f83, 0x4b82a783, 0x07828f20, 0xfb419020, 0x65471805, 0x04002107, 0x9424578c,
	0x1500ecff, 0x01214b8b, 0x20338279, 0x2003827a, 0x8503827e, 0x01d72253, 0x200b8282, 0x42478285, 0xd7220513, 0x0f829001, 0xc9429220, 0x94012105,
	0xb5477b82, 0x01d72205, 0x0a6f4199, 0x4982678d, 0x82130021, 0x01ec215b, 0x2005bb41, 0x063142d7, 0x4101ec21, 0x2922055b, 0x4f828c01, 0x73428d20,
	0x09eb4208, 0x4207235b, 0x01210aeb, 0x20b5829b, 0x10df7738, 0x3d002d22, 0x78085f6b, 0x635f3bc9, 0x47be2007, 0x5f180dc1, 0x3d2e70bf, 0xc3ff0500,
	0xc3ff0a00, 0x85ff9d01, 0x0382a601, 0xd7ffb024, 0x0782bc01, 0x0782bd20, 0xecffbf24, 0x1b82c101, 0x5718c420, 0xec2208bb, 0x1382df01, 0x1382e120,
	0xaeffe428, 0xc3ff0702, 0x03820b02, 0xc5826d20, 0xd7ff7624, 0x0b827c02, 0x03827d20, 0x03828020, 0x13828120, 0x07828220, 0x07828320, 0x03828b20,
	0x1f829f20, 0x85ffa924, 0x1382aa02, 0x0782b520, 0x0782b620, 0x0782b720, 0x2205136b, 0x82ba0285, 0x82bb2023, 0x82bd2023, 0x82bf2013, 0x82c0201b,
	0x82c12003, 0x82c22003, 0x82ca2003, 0x82d42017, 0x82d52007, 0x82e52003, 0x82f7200b, 0x82f82003, 0x82f9202f, 0x82fa2007, 0x82fb2007, 0x82fc2007,
	0x82fd2007, 0xfffe281f, 0xff0503c3, 0x820703d7, 0x820d2003, 0xff0e240b, 0x820f03ec, 0x18102007, 0x2208ef41, 0x42d500c3, 0x1022088d, 0x317f5cff,
	0x11fb5c08, 0x81d35f18, 0xecff9f2c, 0x9affa401, 0x85ffaa01, 0x0382ae01, 0x0382b520, 0x26054b74, 0xffbe01ec, 0x82ca01c3, 0xffcb240f, 0x82cc01d7,
	0x82cd200b, 0xffce2403, 0x82cf015c, 0x82d02013, 0x82d1200b, 0x82d22003, 0x82d32003, 0x82d42003, 0x82d52003, 0x82d6201b, 0x82d72007, 0x82d82003,
	0x82d92023, 0x82da2007, 0x99591803, 0x82df200f, 0x82e02013, 0x82e12003, 0x82e22003, 0x82e32003, 0x82e42003, 0x82e52003, 0x82e62003, 0x82e72003,
	0x82e82003, 0x82e92003, 0x82ea2097, 0x82ec2047, 0x82ed200b, 0xffee2807, 0x00f001ae, 0x82f2013d, 0x82f32067, 0x82f52013, 0x82f72003, 0x82f92003,
	0x0f7f5b03, 0xcd4d0720, 0xff5f2306, 0x276202ec, 0x02852905, 0x02c3ff6b, 0x02d7ff6c, 0x07d15918, 0x55187d20, 0x85210849, 0xd5591802, 0x02d72609,
	0x0285ff85, 0x20278286, 0x20078287, 0x20078288, 0x20078289, 0x2007828a, 0x202f828b, 0x2007828c, 0x200f828d, 0x200b8296, 0x2003829a, 0x200382a0,
	0x200382a4, 0x200382a6, 0x200382aa, 0x200382ac, 0x200382ae, 0x200382b0, 0x202b82b1, 0x202b82b2, 0x200782b3, 0x069142b4, 0xc3ffb824, 0x0382ba02,
	0x8142bc20, 0x82c22006, 0x82c42007, 0xffc52803, 0xffc602ae, 0x82c70271, 0x82cb2007, 0x82ce200f, 0xffcf242f, 0x82d1025c, 0x42d3200b, 0xd7200699,
	0xd9200782, 0x18195a18, 0xe302d722, 0xe6206782, 0xec202382, 0xee200382, 0xef200382, 0xf0200f82, 0xf1202f82, 0xf2200782, 0xf3200782, 0x5a180782,
	0x02250e25, 0x03c3fffe, 0x20038200, 0x20038206, 0x28038208, 0x035cff09, 0x0385ff0a, 0x1807820b, 0x200b3d5a, 0x20138211, 0x20138212, 0x01561814,
	0x03852208, 0x660b8218, 0x85220545, 0x1f821b03, 0x1f821c20, 0x205b0b5f, 0x08fd461f, 0x45649f20, 0x01d72608, 0x01ecffbe, 0x200f82de, 0x20dd82e1,
	0x06216407, 0xecff6c24, 0x0f827d02, 0x173f6918, 0x07e74518, 0x2382c020, 0x0382c220, 0x5318d520, 0xf1200e59, 0xf3203f82, 0xfe2e0382, 0x1503d7ff,
	0x1903ecff, 0x0500ecff, 0x6982a001, 0x2982dc20, 0x0382aa20, 0x1982b620, 0xd7ff1826, 0x9f011a00, 0x01211585, 0x820782dd, 0xe4012183, 0x6d203782,
	0x4d187f86, 0x8b2007e1, 0x64066564, 0xec220555, 0x0f82ba02, 0xc5207b87, 0xc7204d82, 0xaf6f8386, 0x8302200a, 0x07b36f7b, 0x0b7e6983, 0x0f9b5f09,
	0x833ffd4d, 0x062f46c1, 0x000b0225, 0x185f0229, 0x411e7d6a, 0x5418073d, 0x31410b8b, 0x072d4106, 0x2030294e, 0x07856034, 0xffa60129, 0xffa80185,
	0x82b001d7, 0xffb52203, 0x062b46ec, 0x4601ec21, 0xae21052b, 0x052b4601, 0x4101d721, 0xc321056b, 0x07615f02, 0x2a051f46, 0xff7d02ae, 0xff8002d7,
	0x828202ae, 0x09134603, 0x4602d721, 0xd7260513, 0x85ffb702, 0x0382b902, 0x22090b46, 0x82c002ae, 0x82c12033, 0x82c2202f, 0x82ca2007, 0xffce2403,
	0x82d402ec, 0x82d5200f, 0x050f460b, 0xf902ec22, 0xfb201382, 0xfd200382, 0xfe221782, 0x0346d7ff, 0x03ae260a, 0x03aeff0f, 0x08ff4511, 0x1b03d726,
	0x3100ecff, 0xf946d188, 0x87d58507, 0x01d721d1, 0xcd887182, 0x2205f546, 0x82e401ec, 0x22d18971, 0x827c02ec, 0x827d206d, 0x21d18975, 0xe54602ec,
	0x21d19305, 0xdd4602ec, 0x82ae2005, 0x02ec21d1, 0xec22d185, 0xcd88ca02, 0xe502ec22, 0xf7200b82, 0xf9206382, 0xfb200382, 0xcd850382, 0xcd82ec20,
	0x0703ec22, 0x0d20c182, 0xcd83c982, 0x85ff172e, 0xd7ff1803, 0x9d011d00, 0xa6019aff, 0x77410382, 0x09e74207, 0xf601c322, 0x2056eb42, 0x58b7566d,
	0xd7ff9f28, 0x2900a401, 0x0382b501, 0x2d05e746, 0xffbe01d7, 0xffcb01ae, 0x00ce01ec, 0x57180114, 0x93680bf7, 0x01d72109, 0x22059148, 0x82ea01d7,
	0x44ed203f, 0x5f200a69, 0x08f35718, 0x6d02d722, 0x53460b82, 0x02d72109, 0x22098768, 0x828502d7, 0x0553461b, 0x4602d721, 0xd7220553, 0x13828a02,
	0x22058768, 0x448d02d7, 0x33460657, 0x02d72105, 0x20053346, 0x0c8768d7, 0xad48c020, 0x00ce2406, 0x82d50229, 0x18e0200b, 0x200e696c, 0x450f82f0,
	0xd72105eb, 0x05eb4502, 0x9768d720, 0xfe02230b, 0x5818c3ff, 0x0e24081f, 0x1003d7ff, 0x11240382, 0x15032900, 0x16200782, 0x2005cf44, 0x05cf4503,
	0x1b03d722, 0xb55d1782, 0x4c67202f, 0x514808df, 0x01712e09, 0x019affb5, 0x01d7ffbb, 0x012900bc, 0x2c0782be, 0x011400c4, 0x01ecffc9, 0x01aeffca,
	0x200f82cc, 0x480382cd, 0xae220555, 0x0b82d101, 0x0382d220, 0x0382d320, 0x0382d420, 0x22055148, 0x82d701d7, 0x82d8200b, 0x82d9202f, 0x82da2007,
	0x82db2003, 0x82de200b, 0x45e02003, 0x012105f7, 0x200782e2, 0x200382e3, 0x200382e5, 0x200382e6, 0x200382e8, 0x200382e9, 0x200382ea, 0x200382ec,
	0x202b82ed, 0x280782ee, 0x015200f0, 0x0171fff2, 0x200b82f3, 0x200382f5, 0x200382f7, 0x0a8361f9, 0xaeff6a24, 0x0f826b02, 0x85ff7224, 0x07827d02,
	0x0f827f20, 0x03828520, 0x03828720, 0x03828920, 0x03828d20, 0x17829620, 0x03829a20, 0x0382a420, 0x0382a620, 0x2900a924, 0x0782ac02, 0x0382ae20,
	0x0382b020, 0x2382b220, 0x0382b420, 0x1782b520, 0x0382b720, 0x0382b920, 0x0382bd20, 0x2007ef45, 0x232382c4, 0x029affce, 0x2105dd47, 0xeb8202d7,
	0x82d50221, 0x82d72013, 0x05dd4703, 0xdb02ae22, 0xdc207f82, 0xdd204382, 0xe0200782, 0xc3820782, 0xbf820220, 0x82f00221, 0x82f2200b, 0x44f42003,
	0x00280683, 0x0a03d7ff, 0x0c03aeff, 0x11230382, 0x47039aff, 0xd72205a1, 0x0f821603, 0x29001724, 0x07821a03, 0x17821b20, 0x5cff1c24, 0x8b678a00,
	0xff9d30a4, 0xff9f019a, 0x00a401ec, 0xffa6013d, 0x43ae0185, 0xec2108ab, 0x39711801, 0xffbe2107, 0x22073b45, 0x82d5019a, 0x82dc201f, 0x059f430f,
	0xe701c322, 0xf2200f82, 0xb3670382, 0x6c02231e, 0x5b45ecff, 0x02c32206, 0x0a5f457e, 0x0f914918, 0x098d4918, 0x4918d720, 0x49460e8d, 0x09734509,
	0x7345c320, 0x02c32106, 0x2a05cf49, 0xffc702c3, 0x00ce02ae, 0x82cf0229, 0x05514603, 0x4702c321, 0x02201237, 0x21058745, 0x7f4503c3, 0x00112407,
	0x82120329, 0xb5491803, 0x03d72609, 0x03ecff19, 0x2013821b, 0x4903821c, 0x2a265b67, 0xd7ff9d01, 0x0382bc01, 0x220da34d, 0x48d001d7, 0xe12006eb,
	0xe4211b82, 0x078f4dff, 0x8002d726, 0x8202c3ff, 0xa0200382, 0x21089778, 0x977802d7, 0x02d72205, 0x202782b7, 0x200382b9, 0x069378bc, 0x21057b4d,
	0x7b4d02d7, 0x02d72205, 0x4d1782cb, 0xd722057b, 0x9d46e602, 0x02c32610, 0x03d7fffe, 0x20f98206, 0x24038208, 0x03c3ff0d, 0x2003820f, 0x05ad4417,
	0x69220021, 0xb020241d, 0x7d82b582, 0x82bd0121, 0x82bf2007, 0x82002061, 0x82762003, 0x189f2003, 0x20127b72, 0x47a584bb, 0x2b470533, 0x08f94705,
	0x20082347, 0x12456917, 0xf14d8f20, 0x05c1420b, 0x4d12554d, 0x4d4d0751, 0x0767519e, 0xff6a0222, 0x01350d10, 0x42002f64, 0xd7ff9d01, 0xf600a301,
	0x2900a401, 0x0b82a601, 0x1400aa22, 0x4c12fb44, 0xc12005ed, 0xc4201f82, 0xce200382, 0xd5202b82, 0xe1200382, 0xe7200b82, 0xf1320782, 0xf2016600,
	0x6c022900, 0x7202ecff, 0x7c021400, 0x054dd7ff, 0x82802008, 0x1882200b, 0x44120153, 0xdb4405df, 0x09b1430b, 0x2f82bd20, 0x0382bf20, 0x22051d4b,
	0x82c202d7, 0x82c6200b, 0x09cf4403, 0xd502d722, 0xd9200f82, 0xdb206b82, 0xdd200382, 0xdb440382, 0x02d72615, 0x03d7fffe, 0x2003820d, 0x0673480f,
	0x4409db44, 0x00210cd7, 0x08bb5431, 0xd5821020, 0x2215ad49, 0x82cb01c3, 0x09f9451b, 0xf584ae20, 0x3d000724, 0x03820b02, 0xf5846c20, 0x7e02ae22,
	0x16a37518, 0x4905ed71, 0xb6200561, 0xae20dd84, 0xae2ad982, 0xc3ffc502, 0x9affc602, 0x0782c702, 0xd523e187, 0x1802aeff, 0x8212cb75, 0x03ae21cd,
	0x2009a145, 0x354418d7, 0x069d4508, 0x4e260021, 0xb12408a9, 0xb501ecff, 0x22084d45, 0x82be01ec, 0x82bf200f, 0x82c1200f, 0x82c42007, 0x53c72003,
	0x7c200a9f, 0x80200b82, 0x82200382, 0xa1200382, 0xa9200382, 0x3b829d82, 0x41084145, 0xec21058f, 0x213b8202, 0x1b82ce02, 0x2382d420, 0x0382e720,
	0x0382e920, 0x0382f520, 0x0382f720, 0x2609a54c, 0xff0d03ec, 0x820f03ec, 0xff112403, 0x821703d7, 0xff1b2403, 0x544c00d7, 0xd7210e71, 0x3b771800,
	0x3f07680b, 0x2005af41, 0x125d4b3d, 0x4201d721, 0xae2205a9, 0xfd82e401, 0x3162f220, 0x4102200d, 0x77181fb3, 0xc0210757, 0x05ab41ff, 0x202f9f41,
	0x47fd8319, 0xd7210839, 0x7f771803, 0x6a57202b, 0x9d249469, 0xa401d7ff, 0xa6200382, 0xaa240382, 0xae01ecff, 0x59550382, 0x01c32205, 0x200b82bf,
	0x19656ac4, 0xff720225, 0x187602ec, 0x18087b7b, 0x4f0d9777, 0xc3220515, 0x1f82ca02, 0x2782d920, 0x0382db20, 0x0382dd20, 0x0b837b18, 0x4bab7718,
	0xef434520, 0x3d721808, 0xffa4246b, 0x82aa01ae, 0xffae2203, 0x069f4c9a, 0xce01ec22, 0xd5200b82, 0xf2241382, 0x0002aeff, 0x7718f182, 0xae2209bb,
	0x13825802, 0x03827220, 0x1805b74b, 0x240d5d72, 0x03aeff09, 0x087f4b0b, 0x4b03ae21, 0xae20056f, 0x203cb765, 0xe17a1842, 0x05415360, 0xbb01d726,
	0xbe01d7ff, 0x18058b55, 0x430c0964, 0xc3200591, 0x43184545, 0xc32a0991, 0xc3ffc202, 0xaeffc602, 0x0782d502, 0x20152d45, 0xfd7a18c3, 0x53012137,
	0x107c1b66, 0x53011326, 0xc3ff9f27, 0xecffa001, 0x05834301, 0x43018521, 0x71180783, 0xbe200bd7, 0xc4262382, 0xca011400, 0x795885ff, 0x5871200a,
	0x75581079, 0x01712105, 0x20377558, 0x206782e5, 0x580382e6, 0xc322056d, 0x6f82ea01, 0x2900eb23, 0x09715801, 0x50018521, 0x85210533, 0x0f715801,
	0x0f537218, 0x18077158, 0x58174b72, 0xc320057d, 0x210e7d58, 0x721802c3, 0x7d583353, 0x00a92313, 0x81580214, 0x02c32611, 0x0285ffb2, 0x737218b3,
	0x82bc201e, 0x82bd201f, 0x0761523f, 0x22059158, 0x82c602c3, 0x82c7203b, 0x82cb201b, 0x05fb4403, 0x91587120, 0x02c3222a, 0x583782e3, 0xc3210d91,
	0x05915802, 0x1802c321, 0x5816b772, 0x85201291, 0x18069158, 0x500dcf72, 0x712105ef, 0x05915803, 0x1803c321, 0x4513db72, 0x7120058b, 0x01bf2710,
	0x4b632008, 0xff25115d, 0xffaa01ae, 0x06fb5b9a, 0x2705a953, 0x01ecffbe, 0x012900c4, 0x2105a153, 0xf75b01c3, 0x01712205, 0x10ef5bcf, 0x210b7943,
	0xef5b019a, 0x01c32209, 0x5b5782de, 0x6d430fe3, 0x43c32011, 0xc3220669, 0x5b82ee01, 0x4305db5b, 0xb1611069, 0x6a022907, 0x6b029aff, 0x7202c3ff,
	0x7d200782, 0x7f200782, 0x85200782, 0x87200382, 0x89200382, 0x8d200382, 0x19430382, 0x5ba42007, 0x8f5b0693, 0x82b2200b, 0x82b4201f, 0x0be54203,
	0xd547c620, 0x13d94208, 0xda029a22, 0xdb201f82, 0x8d533382, 0x029a2205, 0x200b82e0, 0x065f5bec, 0x0b82f020, 0x0382f220, 0x0382f420, 0x2807475b,
	0x0385ff09, 0x039aff0a, 0x2007820b, 0x4207820c, 0x16200ba5, 0x1a200f82, 0x95420382, 0x51002006, 0xc5490567, 0x01c32a05, 0x01ecffa8, 0x01d7ffaa,
	0x220382ae, 0x4cc3ffb0, 0xc3220635, 0x0f82bf01, 0x0f82c420, 0x0782c720, 0x0782ce20, 0x0382d520, 0x8182f220, 0xd7ff7224, 0x07827602, 0x03829f20,
	0x0b82a120, 0x8118a920, 0xbb200e61, 0xbd200f82, 0xca200382, 0xce200382, 0xcf201f82, 0x80180782, 0x02210a7b, 0x200f82e5, 0x201782e7, 0x280382e9,
	0x03d7fff5, 0x03c3ff05, 0x20038207, 0x200b8211, 0x20078212, 0x20038217, 0x240b821b, 0x00c3ff1c, 0x0c795b2e, 0x3d00a422, 0x210e9b4e, 0x935301d7,
	0x01ec2205, 0x5b5582e1, 0x7c230b85, 0x5702ecff, 0xec210513, 0x07db4c02, 0x20136353, 0x202782b1, 0x200382b3, 0x5f0382bf, 0xec220599, 0x894dc202,
	0x82d42006, 0x055b4813, 0x837fec20, 0x066f5a08, 0x82fd0221, 0x82fe201b, 0x08eb4ca9, 0x53063353, 0x0021062b, 0x08554f30, 0x210b514f, 0x894dffbc,
	0x14002306, 0x0b82c101, 0x2005494f, 0x21bd8214, 0x494f01d7, 0x05454f0b, 0x87054b5c, 0xc97a18bd, 0x85022012, 0x02d722b5, 0x248d82c1, 0x02d7ffc2,
	0x200382c5, 0x200382c6, 0x082d4fc7, 0x85021421, 0x02d721c5, 0x850b2d4f, 0x4dd720bd, 0xbd8209a9, 0x14001224, 0xe9531703, 0x00142408, 0x829d013e,
	0x00a32aa1, 0x00a401e1, 0x00aa013d, 0x087b4129, 0xbd20c583, 0xbe200f82, 0xbf201f82, 0xc420c986, 0xc7200b82, 0xce200b82, 0xd1202b82, 0x254f0782,
	0x84ec2005, 0x82e420d9, 0x21dd8d1b, 0x9f410229, 0x41d72005, 0xa123089b, 0x83021400, 0x82aa20e1, 0x82b520c9, 0x18b62003, 0x900d9785, 0x090b50e9,
	0x0b50ec20, 0x02292606, 0x022900db, 0x200382dd, 0x204b82e7, 0x200382e9, 0x200382f5, 0x200f82f7, 0x200382f9, 0x950382fb, 0x842920f5, 0x881820f5,
	0x002922f9, 0x0e3b621e, 0xa8017123, 0x053b62ff, 0x20093362, 0x06315bd7, 0x22052762, 0x54c3ff7c, 0x255b088b, 0x05ad5517, 0x8202c321, 0xd4022143,
	0xfd232f82, 0x5403c3ff, 0xf55a0957, 0x5b202005, 0xbc2214bb, 0xad6285ff, 0x2579870a, 0xff0b029a, 0x79af029a, 0x7982c520, 0x0382c720, 0x23218197,
	0x0be14d01, 0x1744f783, 0x05515007, 0x9f55c320, 0x01ec2606, 0x01d7ffbf, 0x200382d5, 0x0a0f44f2, 0x440f3950, 0xd721050b, 0x050b4402, 0xcf02c322,
	0xe5202b82, 0x31507d82, 0x0aff430a, 0x1203c322, 0x22083150, 0x5c1c03c3, 0x6f4e0605, 0xffa82209, 0x06a544ec, 0x8501d721, 0x55d7208d, 0xd722065b,
	0x8d8cce01, 0x9f02d722, 0xbb206982, 0x2008555d, 0x217986d7, 0x798d02d7, 0x0703d722, 0x79447182, 0x03d72105, 0x24057544, 0x001900d7, 0x204d820a,
	0x5c0382dc, 0xec220573, 0x0b82e401, 0x4d82f620, 0x18055f5f, 0x5f0d0f4f, 0x6d180695, 0xc0240815, 0xc202ecff, 0xd5200382, 0x575f0382, 0x03ec210d,
	0x200b575f, 0x20b38421, 0x226988d0, 0x82df01d7, 0x82e1200b, 0x226d89e3, 0x187d02d7, 0x200a5744, 0x2081828b, 0x090760a0, 0xd7227182, 0x0f82ba02,
	0x0382bc20, 0xcb207587, 0x79830b82, 0x0782e620, 0x0a1d6618, 0xfffe0225, 0x820603ec, 0x820820eb, 0x07835b03, 0xd7ff1824, 0x99472400, 0x08635707,
	0x8582dd20, 0x934e898f, 0x05695c07, 0xd722ff83, 0x61828302, 0xec219185, 0x09034102, 0xec219187, 0x21918902, 0x918502ec, 0x0cad4418, 0xec229186,
	0x44180803, 0x91830ab1, 0x114f0720, 0x019a2e06, 0x01ecffed, 0x029afff2, 0x039affcf, 0x2a038212, 0x009aff1c, 0x00ca0110, 0x59ce0114, 0xd72a087d,
	0xc3ffe401, 0x7b00f101, 0x19417d02, 0x0b5f610a, 0x1400da24, 0x0382dc02, 0xf982fe20, 0x0d225f83, 0xe1820a00, 0x25057741, 0xffdf01ec, 0x534102ec,
	0x02ec2205, 0x200b82b6, 0x204582bc, 0x200382cb, 0x412d82e6, 0x1824072f, 0x2000ecff, 0x5d088946, 0xff6109a9, 0x109d5d08, 0x41826a20, 0x6a188f83,
	0xa38b1bcd, 0x2f82e020, 0x0ad96a18, 0xab830220, 0x0321a582, 0x2085820c, 0x24038216, 0x00d7ff1a, 0x08a9411d, 0xecffd124, 0x0382dc01, 0x0382dd20,
	0x2205bf5f, 0x50f601d7, 0x05620a39, 0x20df8515, 0x622782b8, 0xd5200b05, 0x0dad5118, 0x220efd61, 0x882100ec, 0x18cb20f7, 0x20129d76, 0xa17618e1,
	0x08c54f09, 0x2220fbd3, 0x200c7769, 0x207582d0, 0x20fb82d1, 0x0a0163d5, 0x1382df20, 0x0f82f220, 0x1960f620, 0x0b016306, 0x630d3343, 0xe7410505,
	0x82cf2007, 0x052b432f, 0x1802ec21, 0x43079370, 0xec260927, 0xecff1003, 0x03821203, 0xd7ff1829, 0xecff1c03, 0x8d011300, 0x01ec227d, 0x207582df,
	0x820382e4, 0x1449427d, 0x7d436186, 0x204d8508, 0x204d84ec, 0x08d34117, 0x01212582, 0x197518d8, 0x05515608, 0x9b826a20, 0x3a2f6c18, 0x6a300021,
	0xca270c9b, 0xce01d7ff, 0x83019aff, 0xffd52269, 0x226d82c3, 0x82db01d7, 0x00dd2413, 0x82de0114, 0x82ed2007, 0x82f22003, 0x18f6201f, 0x2509fb6d,
	0xd7ff6a02, 0x0f826d02, 0x07827f20, 0x07828120, 0x03828320, 0x0b9d6d18, 0x0f828b20, 0x6d188d20, 0xb8200aa1, 0xba200f82, 0xcf240382, 0xda02c3ff,
	0xdc201782, 0x11b56d18, 0x6f180220, 0xe3420b59, 0x616f1807, 0xff122307, 0xef4203c3, 0x1c032306, 0x9d44c3ff, 0x49002109, 0xca22a582, 0xc182ecff,
	0x8501c321, 0x01ec22bd, 0x22b984dc, 0x82f201ec, 0x07a1446d, 0x20173341, 0x249582aa, 0x02ecffb2, 0x200382b4, 0x22a188b6, 0x18dc02ec, 0x851a776d,
	0x03ec288d, 0x03140018, 0x84ecff1a, 0x421c2091, 0x4d631c89, 0x4595820a, 0x7d4205bd, 0x0fa9450b, 0x2746cf20, 0xffe62206, 0x0ca145d7, 0x220b7142,
	0x18cb011d, 0x200eb34a, 0x200f82de, 0x200382e1, 0x062f42ea, 0x7d20f383, 0x461e2b42, 0x6e180b95, 0x79840e67, 0xdf820a20, 0x03820c20, 0x03821620,
	0x0022eb82, 0x9b4a0115, 0x01292205, 0x206d86dc, 0x06ed59e4, 0x1400e924, 0xf159f101, 0xf6012405, 0x83021400, 0x49aa2079, 0x658706b1, 0x2900cf24,
	0x1382d502, 0x4d82fe20, 0x29001224, 0x07821803, 0x29001c24, 0x55821600, 0x4a013d21, 0xec21091b, 0x051b4a01, 0x86011421, 0x2059b8cb, 0x21a78219,
	0xbb46019a, 0x07754a05, 0xf6017124, 0x1d63c3ff, 0x09156306, 0xd7ff8b28, 0x9affaa02, 0x0382b602, 0x07694b18, 0x470b8b45, 0x6d180d35, 0x18240957,
	0x1c009aff, 0x2108af43, 0x6d90ffdc, 0x47082f4e, 0x71c50525, 0x25481120, 0x07f14408, 0x24056f44, 0xfff201d7, 0x22df82ec, 0x48a002d7, 0xcb200601,
	0x6b440782, 0xff1c2413, 0x981000ec, 0x46f62045, 0x0f4506ff, 0x0cad440e, 0x5d184183, 0x01200881, 0x00217f82, 0x0649441c, 0xd501d724, 0x49449aff,
	0x050d4706, 0x4705a764, 0x6a2005b7, 0x01479182, 0xffcf231b, 0xf946029a, 0x0827640e, 0x9aff1222, 0x2d0a0944, 0x0102009a, 0x013d00eb, 0x003d00f4,
	0xbb470121, 0x019a2605, 0x01c3ffdd, 0x0a0347de, 0x8b82e420, 0x2205a549, 0x827d02c3, 0xff81247b, 0x828302c3, 0x828b2003, 0x05854303, 0x6b07f541,
	0xd721070b, 0x07f94102, 0x22053749, 0x82e602d7, 0xcd841837, 0xfe02210a, 0x240a0748, 0x03c3ff0e, 0x24038210, 0x009aff18, 0x43858c1f, 0xd72105f7,
	0x21818201, 0x6d826d02, 0x01217ddf, 0x21e78201, 0x9b471c00, 0x66ec200a, 0x89410a41, 0x0719480b, 0x0b022925, 0x41022900, 0x8d411f91, 0x08834817,
	0xffca0123, 0x0c7f45d7, 0xd7fff222, 0xec215582, 0x13a74602, 0x21157345, 0x154602d7, 0x02ec2105, 0x13eb7218, 0x20137345, 0xc4d56edb, 0x85ffbc22,
	0x6108d96e, 0x4a189e87, 0xd56e1055, 0x71a92073, 0xd96e0653, 0x0d6f711b, 0xb902c322, 0xba203382, 0x2006e56e, 0x560b82bd, 0xe96e0d57, 0x050d6bb1,
	0x1d69c320, 0x65ed6e06, 0x99180320, 0x00210b3b, 0x3b9e18c4, 0x858f1844, 0x379e1819, 0xc18f1845, 0x2f9e180b, 0x2b9e1853, 0x279e1827, 0x239e186f,
	0xa1901827, 0xff602407, 0x826a02c3, 0x1b9e1803, 0x8285200b, 0x8287200f, 0x82892003, 0x0f9e1803, 0x00b92423, 0x18bb0252, 0x2032079e, 0x223382f9,
	0x183d00fb, 0x1810fb9d, 0x24a3f39d, 0x03520071, 0x2e038273, 0x00520083, 0x00450010, 0x0049003d, 0x824b0066, 0x0f631807, 0x003d2209, 0x200f824f,
	0x20178257, 0x20038259, 0x2403825a, 0x0029005b, 0x2807825c, 0x0329005d, 0x03660070, 0x20038272, 0xa70f8274, 0x00522141, 0x14204189, 0x022e418c,
	0x85ff0903, 0x85ff0b03, 0x97000200, 0x01820500, 0x0a000032, 0x01000b00, 0x11000f00, 0x24000300, 0x06002700, 0x29207d82, 0x2c221582, 0x19822c00,
	0x2f002e38, 0x32000c00, 0x0e003500, 0x3e003700, 0x44001200, 0x1a004600, 0xc5824800, 0x4e001d22, 0x21220182, 0xdd825000, 0x5500222e, 0x25005700,
	0x5e005900, 0x6d002800, 0x2e220182, 0x01827d00, 0x82002f3c, 0x30008700, 0x92008900, 0x94003600, 0x40009800, 0x9f009a00, 0xa2004500, 0x4382ad00,
	0xb800b322, 0xba2c3782, 0x5d00bf00, 0xc900c100, 0xcb006300, 0x6c240182, 0xcf00cd00, 0xd1264382, 0x7000d100, 0x0182d500, 0xd7007122, 0x72280182,
	0xdb00d900, 0xdd007300, 0x76220182, 0x0182ec00, 0xf0007722, 0x78220182, 0x0182f200, 0xf8007922, 0x7a280182, 0xfb00fa00, 0xfd007b00, 0x04090182,
	0x01ff007d, 0x017e0001, 0x00030103, 0x01060181, 0x01820006, 0x00080108, 0x010a0183, 0x0184000a, 0x000f010e, 0x01110185, 0x01870013, 0x00150115,
	0x011d018a, 0x018b001d, 0x001f011f, 0x0121018c, 0x018d0024, 0x00270126, 0x012c0191, 0x0193002c, 0x00300130, 0x01320194, 0x01950032, 0x00340134,
	0x01360196, 0x0197003b, 0x003d013d, 0x013f019d, 0x019e0040, 0x00440143, 0x014a01a0, 0x01a2004a, 0x00560156, 0x015a01a3, 0x01a40062, 0x00640164,
	0x016601ad, 0x01ae0069, 0x006d016c, 0x016f01b2, 0x01b4007c, 0x0084017e, 0x018601c2, 0x01c90088, 0x008e018a, 0x019001cc, 0x01d10091, 0x00970193,
	0x019901d3, 0x01d80099, 0x00a2019b, 0x01a401d9, 0x01e100a8, 0x00ae01aa, 0x01b001e6, 0x01eb00b1, 0x00b401b4, 0x01b801ed, 0x01ee00b8, 0x00c001ba,
	0x01c301ef, 0x01f600c4, 0x00c801c6, 0x01ca01f8, 0x01fb00d1, 0x220182d4, 0x82d80103, 0x01043401, 0x01e001da, 0x01e30105, 0x010c01ea, 0x01ee01ec,
	0x82f00114, 0x17840901, 0xf601f201, 0xf8011801, 0x1d010302, 0x06020602, 0x0a022901, 0x2a010a02, 0x28022802, 0x58022b01, 0x2c015802, 0x60026002,
	0x62022d01, 0x2e016202, 0x6a026a02, 0x6c022f01, 0x30017202, 0x74027402, 0x76023701, 0x38017c02, 0x8c027e02, 0x95023f01, 0x4e019d02, 0xa0029f02,
	0xa2025701, 0x5901af02, 0xc002b102, 0xc3026701, 0x7701c302, 0xc502c502, 0xc7027801, 0x7901c702, 0xcc02c902, 0xce027a01, 0x7e01cf02, 0xd302d202,
	0xd6028001, 0x8201d902, 0xdb02db02, 0xde028601, 0x8701de02, 0xe902e002, 0xef028801, 0x9201fc02, 0x0003ff02, 0x0303a001, 0xa2010803, 0x1d030b03,
	0x1f03a801, 0xbb011f03, 0x21032103, 0x2303bc01, 0xbd012303, 0x25032503, 0x2703be01, 0xbf012703, 0x29032903, 0x2b03c001, 0xc1012b03, 0x2d032d03,
	0x2f03c201, 0xc3012f03, 0x31033103, 0x3303c401, 0xc5013303, 0x36033603, 0x3803c601, 0xc7013803, 0x3a033a03, 0x3c03c801, 0xc9013c03, 0x3e033e03,
	0x4003ca01, 0xcb014003, 0x42034203, 0x4403cc01, 0xcd014503, 0x47034703, 0x4903cf01, 0xd0015603, 0x58035803, 0x5a03de01, 0xdf015a03, 0x5c035c03,
	0x5e03e001, 0xe1015e03, 0x61036003, 0x6303e201, 0xe4016303, 0x66036603, 0x6803e501, 0xe6016803, 0x6a036a03, 0x6c03e701, 0xe8016c03, 0x74036e03,
	0x8303e901, 0xf0018303, 0x01000000, 0x0a240382, 0x1e001c00, 0x108fa918, 0x00000024, 0xfa050000, 0x4812c497,
};
```

`src/render/fonts/undefeated.hpp`:

```hpp
// File: 'undefeated.ttf' (47320 bytes)
// Exported using binary_to_compressed_c.cpp
static const unsigned int undefeated_compressed_size = 41197;
static const unsigned int undefeated_compressed_data[41200 / 4] =
{
	0x0000bc57, 0x00000000, 0xd8b80000, 0x00000400, 0x00010037, 0x000d0000, 0x00030080, 0x54464650, 0x73e37b4d, 0xb800008d, 0x281582bc, 0x4544471c,
	0x00270046, 0x200f8267, 0x2c0f8294, 0x2f534f26, 0x74d05732, 0x010000a0, 0x2c0f8258, 0x616d6360, 0xdc361d70, 0x0200003c, 0x241382b8, 0x73616776,
	0x20178270, 0x202f8210, 0x3807828c, 0x796c6708, 0xdda24066, 0x0400000d, 0xb10000b4, 0x61656860, 0x60161464, 0x201b82ca, 0x210382dc, 0x10826836,
	0x0def1023, 0x203b8299, 0x280f8214, 0x746d6824, 0x130cc478, 0x820f823f, 0xfe00294f, 0x61636f6c, 0x16dfafaf, 0x30203f82, 0x84281f82, 0x7078616d,
	0x31025200, 0x38201f82, 0x20270f82, 0x656d616e, 0x82d04cf8, 0x14b6214f, 0xc22c1382, 0x74736f70, 0x4f3e3125, 0xd8b70000, 0xb3201f82, 0x012ddb84,
	0x19e00000, 0x0f5f8d16, 0x0b00f53c, 0x24168204, 0xebd20000, 0x2d3382ed, 0xded40000, 0x0000832e, 0x2d0dbfff, 0x1882c103, 0x02000822, 0x02830582,
	0x0000012a, 0xc0ffc003, 0x9a0d0000, 0x0d210e83, 0x8349842d, 0x2003870a, 0x2411843e, 0x002f0241, 0x21128410, 0x008f0002, 0x7607032c, 0x05009001,
	0x99020000, 0x1c82cc02, 0x07858f20, 0x00eb0125, 0x82090133, 0x21028b0f, 0x0d8a1001, 0x45665023, 0x220e8264, 0x84760001, 0x03402483, 0x844000c0,
	0x2304820f, 0x5a036303, 0x20230682, 0x82040100, 0x21028306, 0x05835501, 0x002b6582, 0xcd080000, 0x4d095300, 0x82085d00, 0x66082807, 0x4d085300,
	0x82095200, 0xcd082303, 0x13845100, 0x5000cd22, 0x54340782, 0x5d008006, 0x4f00000a, 0x57004d05, 0x4b00e605, 0x55000005, 0x59210382, 0x2c338209,
	0x65006606, 0x5a009a05, 0x5b004d07, 0x2b4b8205, 0x5a00b309, 0x5d009a0a, 0x61001a06, 0x4f204f82, 0x62260382, 0x5d001a0c, 0x17821a09, 0x6400b326,
	0x5b009a0d, 0x0a2b3783, 0x0b530080, 0x0b56001a, 0x824d004d, 0x824a2003, 0x08622417, 0x825200cd, 0x0c533603, 0x0a550080, 0x0a6200e6, 0x075e0066,
	0x0b6300e6, 0x0960004d, 0x30138266, 0x0553009a, 0x02560033, 0x02540000, 0x025800e6, 0x2607821a, 0x035700cd, 0x8261009a, 0x0451280b, 0x035e0000,
	0x82620000, 0x03662403, 0x825900e6, 0x8a00200f, 0x82032000, 0x2203830b, 0x8201001c, 0x00002409, 0x84030070, 0x001c2409, 0x82540004, 0x00102211,
	0x20118210, 0x2c138200, 0x00390020, 0x005d005b, 0xfffdff76, 0x261982ff, 0x00200000, 0x82410030, 0x85612011, 0xe4ff2911, 0xceffd5ff, 0xcaffcdff,
	0x8e414384, 0x202e830b, 0x26158201, 0x00060100, 0x83030100, 0x2507820e, 0x00000002, 0x008d0002, 0x00000124, 0x008d0004, 0x07060529, 0x0b0a0908,
	0x860e0d0c, 0x100f3c17, 0x14131211, 0x18171615, 0x1c1b1a19, 0x201f1e1d, 0x24232221, 0x28272625, 0x822a0029, 0x2c2b3523, 0x302f2e2d, 0x34333231,
	0x38373635, 0x3c3b3a39, 0x403f3e3d, 0x02401882, 0x0880088c, 0x10000800, 0x4e011800, 0x2c04c202, 0xc6067e05, 0x160bf008, 0x580f340d, 0xea12b411,
	0xc815ca14, 0xc417ae16, 0x1c1a5019, 0xe61d5a1c, 0xf220921f, 0xbe25b823, 0xf0285827, 0x9a2cc02a, 0xe02fd02d, 0x02336431, 0xa436c835, 0x023c1439,
	0xee3df43c, 0xba41803f, 0xa0449443, 0xe6472246, 0x7a4c544a, 0xa64d4c4d, 0xaa4f9a4e, 0x0a515e50, 0x94531652, 0x2e557454, 0x0857a456, 0xde57aa57,
	0x0100b058, 0x24080d41, 0x39000002, 0x310fa202, 0x08da0053, 0x00a50253, 0x010000d6, 0x0e37013e, 0x028b0701, 0x0722062a, 0x26232622, 0x012e2706,
	0x08820283, 0x23012a27, 0x26272622, 0x85268506, 0x21328917, 0x118b2606, 0x35822320, 0x23822987, 0x2c894185, 0x27010e25, 0x82353626, 0x2d028d74,
	0x33011e17, 0x1e331632, 0x36321701, 0x0b823a33, 0x11823620, 0x0e820286, 0x16251782, 0x26343536, 0x250b8227, 0x1415013a, 0x92822322, 0x33201484,
	0x4a822f82, 0x2f8a3220, 0x3616ad08, 0xf4073137, 0x01173018, 0x0b060308, 0x111f0e05, 0x35244121, 0x2e17376f, 0x0b170b16, 0x1d0a160a, 0x2f171d3a,
	0x19351717, 0x01040803, 0x0b020104, 0x0d1b0d04, 0x0710240f, 0x2b0e0209, 0x0a20122e, 0x03030704, 0x1a0d0805, 0x0b140a0c, 0x0c183418, 0x1a0b0c19,
	0x0a180b0b, 0x0908240f, 0x05030709, 0x06100706, 0x1610160b, 0x27160f21, 0x09110814, 0x05060b06, 0x01080407, 0x1b0c1201, 0x632b3762, 0x172c1631,
	0x07214120, 0x0a040712, 0x070f0703, 0x031a351a, 0x0a060204, 0x070e0706, 0x1d142915, 0x13091d39, 0x02030109, 0x01020607, 0x112c0082, 0x07081121,
	0x09040502, 0x08090304, 0x0f820582, 0x172f1836, 0x0f091409, 0x4a240f1d, 0x31613025, 0x02244523, 0x02050227, 0x052d6582, 0x1c0e060c, 0x0c251309,
	0x03050d10, 0x08008201, 0x0905022e, 0x050c0405, 0x07010306, 0x01080301, 0x05050a05, 0x1b010110, 0x04512305, 0x05110802, 0x0707060b, 0x02070101,
	0x02010302, 0x04020406, 0x013b7582, 0x1905040a, 0x0c1c0b0b, 0x01020b05, 0x190b0703, 0x0e160202, 0x0a172f16, 0x82050815, 0x08033b1a, 0x1d10230f,
	0x563b1a39, 0x091c1a20, 0x03020904, 0x03010407, 0x01040101, 0x04840201, 0x82010321, 0x8201208a, 0x040d2300, 0x0b830601, 0x07050823, 0x2514820f,
	0x02030101, 0x8e820306, 0x82140c21, 0x3a698205, 0x00020002, 0x08d7005d, 0x01aa02de, 0x0032011c, 0x032e0100, 0x23222627, 0x8227012a, 0x26222102,
	0x02830882, 0x85062221, 0x3c352208, 0x20028301, 0x220e8334, 0x83011c15, 0x16142102, 0x07252388, 0x2e272606, 0x890e8801, 0x012a2a0b, 0x06073023,
	0x23010e33, 0x23518606, 0x15062227, 0x60820e82, 0x0725308a, 0x2627010e, 0x83238206, 0x247e8305, 0x16060706, 0x24668707, 0x33011e17, 0x3002873a,
	0x3e371632, 0x16363701, 0x37363233, 0x16173236, 0x05924214, 0x9b421183, 0x832c8607, 0x17162220, 0x05b34216, 0x2c831620, 0x32214788, 0x23c38814,
	0x013b3233, 0x2984db86, 0x36254482, 0x023a3332, 0x43608336, 0x25240508, 0x1407011e, 0x2324f883, 0x34352622, 0x3b082584, 0x08173632, 0x6d6d37de,
	0x0e07366d, 0x162c1606, 0x46489048, 0x2915468e, 0x04080514, 0x11070c06, 0x060c1020, 0x0f02020e, 0x22120702, 0x060d0611, 0x06060405, 0x01020309,
	0x08100802, 0x073d0282, 0x08050709, 0x070f0803, 0x02091009, 0x02020203, 0x03070301, 0x09080708, 0x0d070812, 0x2e0e8206, 0x0802020a, 0x01030202,
	0x09060e06, 0x82070911, 0x050a2f3d, 0x0f070d05, 0x14070e17, 0x20402008, 0x3682100a, 0x02080131, 0x03020701, 0x21100406, 0x12251210, 0x82071108,
	0x0f072a2e, 0x06060707, 0x02040804, 0x08168203, 0x0602086a, 0x1007090a, 0x08061120, 0x01060209, 0x0f030403, 0x05010f20, 0x040d0601, 0x0a050b04,
	0x10030912, 0x070f0502, 0x12070306, 0x0a051223, 0x06020104, 0x010b0b02, 0x060a0504, 0x45142a14, 0x7f404489, 0x22407f80, 0x60322243, 0x1a341f2e,
	0x0607c0fe, 0x0c050302, 0x09060c18, 0x0e070508, 0x040b0407, 0x1009c401, 0x01081111, 0x21080082, 0x44220c0a, 0x05090422, 0x04020103, 0x45230409,
	0x0a0e0623, 0x04050101, 0x010b0102, 0x02020901, 0x08820402, 0x02010438, 0x05010403, 0x04020303, 0x01010506, 0x02030507, 0x0d091001, 0x55820d1c,
	0x0528fc82, 0x0f02050d, 0x07030301, 0x02244f82, 0x02040102, 0x062a2d82, 0x01030b0d, 0x03010607, 0x3d830403, 0x03030722, 0x12224782, 0x80821224,
	0x06010528, 0x2211050c, 0x2e820511, 0x04052608, 0x0f161805, 0x04081728, 0x1102080c, 0x13030511, 0x00000302, 0x53000200, 0x53080001, 0xe9007f02,
	0x0000f900, 0x084f4501, 0x022e0626, 0x07012e27, 0x062a0f82, 0x06162326, 0x23012e15, 0x0582011c, 0x06142723, 0x24178207, 0x06072622, 0x250b8226,
	0x27062615, 0x11822226, 0x0e822720, 0x42012e21, 0x232205a2, 0x38452206, 0x210b860b, 0x1a451614, 0x45372008, 0x32200b44, 0x11861783, 0x32210b85,
	0x05c64236, 0x16202f86, 0x35450e84, 0x013a2205, 0x05ba4233, 0x82011e21, 0x32172323, 0x4a823516, 0x36214188, 0x86118216, 0x84148220, 0x16172238,
	0x466e8c32, 0x05210537, 0x0733433c, 0x16063708, 0x07012a17, 0x5f2fea07, 0x1e3e1f30, 0x312f5e2f, 0x30606261, 0x03040e04, 0x06030207, 0x02010103,
	0x04020304, 0x06010102, 0x05010303, 0x05020301, 0x01060402, 0x0a840205, 0x08052108, 0x0b0d180b, 0x3e1e0c16, 0x2b562b1f, 0x181f3d1f, 0x2c161830,
	0x19381e16, 0x07112918, 0x081b010f, 0x5d083983, 0x1709050b, 0x080e0809, 0x18080f09, 0x210f1e32, 0x20442210, 0x050b120a, 0x2c11050c, 0x0d1b0e15,
	0x06091108, 0x190b0508, 0x0f22160d, 0x07060b08, 0x0b0a0d09, 0x08100807, 0x02010302, 0x1f100505, 0x050a050f, 0x05070f07, 0x0f090408, 0x0511020a,
	0x0e04060c, 0x02070103, 0x07050704, 0x9c82080d, 0x09034c08, 0x0a0e0903, 0x03020502, 0x16090305, 0x0909070a, 0x360d1a0d, 0x6f39346b, 0x20412232,
	0x1a0b180c, 0x66fb1b34, 0x040a0501, 0x010b160b, 0x20100101, 0x0d620211, 0x08040618, 0x02050604, 0x0f080102, 0x0106010a, 0x02010701, 0x82030201,
	0x85f28203, 0x0102210a, 0x04201f82, 0x8982f482, 0x60820682, 0x05227682, 0x43820606, 0x48081482, 0x09020104, 0x070e0404, 0x1313170a, 0x150b192b,
	0x040e0c0d, 0x05050e02, 0x04030204, 0x03050203, 0x13060c03, 0x0303081f, 0x030a0b01, 0x0b010107, 0x010e0c03, 0x0b030505, 0x07030801, 0x0b030209,
	0x090e070f, 0x01010c0a, 0x21ec8304, 0x56820d06, 0x04020a24, 0xc7820205, 0x03040624, 0x02830108, 0x05010224, 0x76820301, 0x08201482, 0x02220a82,
	0x1d820103, 0x09060822, 0x2f082582, 0x18080204, 0x23381413, 0x091a3217, 0x0f070913, 0x0e028207, 0x01040704, 0x53000200, 0xed070801, 0xd4007802,
	0x0000e100, 0x27012e01, 0x0607012e, 0x22097e42, 0x42061617, 0xff4705d8, 0x21058605, 0xf0420622, 0x26272505, 0x26060706, 0x27220582, 0x08862226,
	0x11833e83, 0x8d450e82, 0x46178505, 0xea420503, 0x2206240c, 0x88261627, 0x84152011, 0x0f7e4274, 0x37013e2a, 0x32333632, 0x011e1736, 0x1a431a88,
	0x20088508, 0x05ba4233, 0x15011e24, 0xb1453614, 0x20298405, 0x82058303, 0x1e0522ce, 0x07a24801, 0x17364608, 0x813dba07, 0x0a110c40, 0x06031006,
	0x180c060b, 0x0107060a, 0x080a0201, 0x0b04070e, 0x0d1a0d04, 0x1c295228, 0x170b1c39, 0x040a040c, 0x08090307, 0x08080706, 0x04080608, 0x08050c02,
	0x0b060904, 0x040a0305, 0x28138208, 0x0c050705, 0x020b0205, 0x25208207, 0x04080905, 0x01820207, 0x070e3f08, 0x3a316131, 0x783c3a77, 0x0d190d3b,
	0x08050e05, 0x22030a07, 0x05100c07, 0x060c1b0e, 0x11100106, 0x060c120a, 0x2e17060d, 0x0c130c16, 0x170b160c, 0x7038172f, 0x0a150a38, 0x0e041105,
	0x5e821216, 0x0c140b28, 0x07162814, 0x9a82070f, 0x16142308, 0x01030105, 0x04010801, 0x0b030302, 0x1e040603, 0x13241303, 0x3a122411, 0x552a3a76,
	0x31265054, 0x67822851, 0xddf82308, 0x03040507, 0x0c0c0815, 0x0e290403, 0x281aff01, 0x08010311, 0x02010705, 0x0b060204, 0x07060409, 0xe3821507,
	0x46820120, 0x04090428, 0x080b1a0e, 0x1a82060a, 0x02010934, 0x0203040c, 0x03030506, 0x03030a02, 0x0407050c, 0x0a820803, 0x04050234, 0x06040405,
	0x01020804, 0x0506010e, 0x04010505, 0x86820b05, 0x02022108, 0x08070304, 0x05030e13, 0x04010102, 0x030f0306, 0x09210302, 0x0c1a3319, 0x1e120d17,
	0x03050408, 0x08245482, 0x07050a17, 0x20830882, 0x030a0430, 0x09040201, 0x09020410, 0x050f0803, 0x0e820409, 0x0d010134, 0x17260c06, 0x01060e07,
	0x03030202, 0x08040204, 0x5c820a07, 0x01012a08, 0x150e0405, 0x4319131e, 0x050b0624, 0x0c100a96, 0x04030f06, 0x10150d0c, 0x0000000a, 0x00520002,
	0x03d30754, 0x00bf002c, 0x07a342d8, 0x22098e42, 0x4a272622, 0x222105b8, 0x08bb4a06, 0x06220723, 0x05ca4223, 0x2208a445, 0x4b15010e, 0x26240c00,
	0x17062223, 0x8505b245, 0x26062238, 0x058e4217, 0x83160621, 0x422c8a17, 0x6d42059a, 0x3e372805, 0x34363701, 0x83361635, 0x013e2208, 0x20088917,
	0x0f884532, 0x42263621, 0x03210db2, 0x20928217, 0x83728405, 0x842620bd, 0x36322142, 0x3c085783, 0x07070616, 0x1f35169d, 0x2c3b692b, 0x4120325f,
	0x172f1721, 0x01070e07, 0x2e080207, 0x040e050c, 0x260e1b0b, 0x10072857, 0x04070307, 0x07040904, 0x170b0707, 0x3e83450b, 0x030e1d0f, 0x26258201,
	0x04030b06, 0x820b0706, 0x0622080c, 0x02130806, 0x05070303, 0x0806050a, 0x0a020401, 0x02021306, 0x06060624, 0x06050203, 0x02020f06, 0x1a820205,
	0x0f045b08, 0x020f0409, 0x09050937, 0x09110805, 0x3522451d, 0x0701044b, 0x0e070207, 0x1c39160a, 0x09040608, 0x471d0d13, 0x06060c24, 0x1e0f1b08,
	0x1a101d4b, 0x0a0b0409, 0x07042f07, 0x0d060b08, 0x1c371c06, 0x41336632, 0x45233b85, 0x0415373e, 0xe4f91220, 0x15172410, 0x17151420, 0x9d820808,
	0x0f193436, 0x2c1c0f1f, 0x150e0807, 0x4d2a6201, 0x20523324, 0x070a2918, 0x042d9e82, 0x11010102, 0x020b0a03, 0x0e0a0310, 0x32858205, 0x04010201,
	0x03010601, 0x06030103, 0x222e1102, 0x82081008, 0x8302200c, 0x05053e0e, 0x03030207, 0x06030a0e, 0x0109070a, 0x05070802, 0x01010c08, 0x01110c05,
	0x0a120808, 0x21d28208, 0x2e820706, 0x1223122e, 0x060e1f10, 0x070e0712, 0x03070202, 0x1232dd82, 0x570d0912, 0x070d0736, 0x0c031205, 0x03160917,
	0xb5820102, 0x0a184508, 0x040b0d18, 0x0a1d110b, 0x0c150115, 0x23071120, 0x05130102, 0x02040a08, 0x0f080205, 0x05050905, 0x121e2b06, 0x223e372e,
	0xbe244e28, 0x02021012, 0x210d0c05, 0x172d1716, 0x01022e17, 0x1d330a05, 0x00173e1e, 0x02340082, 0x94005200, 0xed02d308, 0xaa019401, 0x3e010000,
	0x012e3701, 0x24068f42, 0x1e232226, 0x051e4d01, 0x26222322, 0x22210b83, 0x841a8326, 0x06dd4a0b, 0x23830620, 0xe24c2f85, 0x84072005, 0x420b8523,
	0x3b8208d7, 0x06161722, 0x26210e83, 0x214a8506, 0xae4d1407, 0x07224b09, 0x3c352629, 0x26342701, 0x4a263435, 0x1c2a0688, 0x26141501, 0x07140615,
	0x2382012e, 0x06220728, 0x07010e23, 0xdb4d2614, 0x20058205, 0x42a18223, 0x748205ef, 0x17823420, 0x21058f4a, 0x95821506, 0x8205ac4b, 0x2606231d,
	0x74822627, 0xc2830288, 0x27243882, 0x0e072622, 0x06275684, 0x06141514, 0x82011e17, 0x16172c74, 0x32363336, 0x17163233, 0x82333216, 0x07ae4802,
	0x02881182, 0x013e3722, 0x33252c82, 0x32333632, 0x07604b26, 0x14861620, 0x85013e21, 0x3a172117, 0x16202385, 0x36273587, 0x33011c37, 0x82151416,
	0x16142102, 0x8205274c, 0x22ef8229, 0x4c363435, 0xb14b0545, 0x872f8205, 0x013e255c, 0x013a3732, 0x37225882, 0x56823a25, 0x06219282, 0x052f4c07,
	0x4608ec82, 0x08373626, 0x0e1d0e9a, 0x40295228, 0x4221407f, 0x14241321, 0x070c0106, 0x09030306, 0x08100707, 0x080e0508, 0x03050308, 0x08100809,
	0x080c0a05, 0x0402030d, 0x09110808, 0x090e0406, 0x05050307, 0x0810090a, 0x82100606, 0x0404280b, 0x09100909, 0x82100405, 0x054b083b, 0x11080906,
	0x01050408, 0x08070e02, 0x20010408, 0x09140903, 0x12010904, 0x03070302, 0x01050902, 0x10080208, 0x11231108, 0x01010409, 0x01010724, 0x07040201,
	0x2110070f, 0x03010610, 0x01020208, 0x020d0202, 0x060a1309, 0x8202060c, 0x0502231b, 0x00820205, 0x060d062d, 0x010f1d0f, 0x05020203, 0x83060204,
	0x0451082c, 0x05050704, 0x0a030b03, 0x0d070913, 0x05030407, 0x05060607, 0x1f10050b, 0x162f1710, 0x030d190e, 0x0802010e, 0x03050102, 0x03070e04,
	0x05010306, 0x050d0401, 0x1c0c170c, 0x09051c39, 0x08070704, 0x08040303, 0x1109070e, 0x030e0309, 0x05060503, 0x2d838304, 0x08050107, 0x180c0402,
	0x041b080d, 0x6e820a02, 0x1d0e0623, 0x242f820f, 0x03060205, 0x298e8203, 0x04080401, 0x060f1f10, 0x1b82060a, 0x05033c08, 0x02100101, 0x01011001,
	0x20040904, 0x130a203e, 0x05020408, 0x432d592d, 0x43878787, 0x4e102010, 0x62fe4394, 0x060e1a0d, 0x08030208, 0x040d0409, 0x06070f08, 0x0c05020c,
	0x82820109, 0x140a3478, 0x0c160c07, 0x04050c06, 0x0e011606, 0x01010605, 0x820d1905, 0x01012698, 0x03041606, 0x2c2a8209, 0x021b0601, 0x09070d01,
	0x01180701, 0x34458210, 0x01031b08, 0x0108060f, 0x04020101, 0x0609050b, 0x08130404, 0x25368203, 0x0c05070d, 0x05820706, 0x01050837, 0x0e090101,
	0x3f1f0e1d, 0x09020920, 0x19132813, 0x0c061933, 0x23ad8206, 0x05060a05, 0x04201d83, 0x09226782, 0x27820201, 0x04020222, 0x042c0682, 0x06010402,
	0x010b0401, 0x030c0905, 0x0b3b1783, 0x05020302, 0x03040101, 0x06040201, 0x3019060b, 0x0d180d1a, 0x06040c05, 0x83050103, 0x2333851f, 0x01010c04,
	0x0f215582, 0x264e8209, 0x0f040208, 0x82030803, 0x8204205f, 0x010c2256, 0x21508203, 0x74820101, 0x0202122e, 0x0f1f0f05, 0x04112211, 0x04020407,
	0x07210282, 0x220c8203, 0x820f1e0f, 0x0507224a, 0x824a8203, 0x31062f30, 0x06094728, 0x0206130b, 0x0c040b01, 0x53440712, 0x00512d05, 0x025308e8,
	0x016c0197, 0x01000078, 0x2605f943, 0x1e27012e, 0x440e1501, 0x1e21075c, 0x05414401, 0x17842720, 0x0e240b8c, 0x012a0701, 0x82054744, 0x06f04832,
	0x22202686, 0x21095344, 0xae511416, 0x058a4c0f, 0x26202982, 0x26212684, 0x05294406, 0x4905bd49, 0x232805c0, 0x26372636, 0x06141506, 0x05834782,
	0x0736262a, 0x22071622, 0x16262736, 0x11822682, 0x012e3522, 0x06241786, 0x26062316, 0x8c831d83, 0x06230623, 0x0e295222, 0x4a05a047, 0x3d47095f,
	0x0ef64907, 0x011e3323, 0x85028217, 0x1636211d, 0x17250b91, 0x1c15011c, 0x224d8501, 0x82011e15, 0x2041862f, 0x073e4436, 0x41843a20, 0x33214787,
	0x0a864f32, 0x820b504d, 0x013124f8, 0x82372606, 0x162c0864, 0x37060706, 0x0b0c7607, 0x0207050e, 0x04080604, 0x06100205, 0x04030804, 0x02040905,
	0x03100407, 0x04020605, 0x05040705, 0x050c0508, 0x03270b82, 0x06030805, 0x83010202, 0x0656081f, 0x06030208, 0x03060107, 0x06060a04, 0x06040405,
	0x01020309, 0x05051303, 0x04010305, 0x05030201, 0x0d040202, 0x04060605, 0x0b050f04, 0x27140a14, 0x356f3517, 0x07132613, 0x0802070e, 0x070b0602,
	0x09050b04, 0x110a0911, 0x04090308, 0x03040703, 0x0602010b, 0x5c820103, 0x04032508, 0x01060101, 0x06040305, 0x06030303, 0x03070203, 0x08080502,
	0x03040601, 0x03070404, 0x01040503, 0x03010204, 0x4a080a82, 0x0d060c06, 0x32190d18, 0x35733a19, 0x0b213e20, 0x120e0b16, 0x080d0708, 0x06061008,
	0x0d060808, 0x10211005, 0x0b091307, 0x170a060f, 0x0b180b0f, 0x08060d07, 0x1007060c, 0x060d0609, 0x050d1a0e, 0x0b08050b, 0x0d160c05, 0x820c3c18,
	0x100c2b35, 0x181c0804, 0x09142918, 0xe382070f, 0x0d06022e, 0x010d0509, 0x1a0c040b, 0x030c0c0c, 0x03364d82, 0x3e1f0a23, 0x3e7e3f1f, 0x0c040805,
	0x0a060815, 0x01030104, 0x1a821103, 0x140a063f, 0x203f2009, 0x0e29562b, 0x0f070e1b, 0x15291505, 0x37112311, 0x48fc376f, 0x07111a0f, 0x20b48212,
	0x08da8202, 0x1a075826, 0x050a0207, 0x04020607, 0x0508060a, 0x040a0305, 0x06020609, 0x02030513, 0x040b0303, 0x06010607, 0x05040511, 0x05210b82,
	0x305b8207, 0x0304040e, 0x050d0101, 0x03010806, 0x06040310, 0x082d8204, 0x01080725, 0x07051004, 0x05090303, 0x04030503, 0x040b0401, 0x05060605,
	0x01060610, 0x040d0201, 0x07030e0a, 0x83030a0a, 0x340f823d, 0x02030904, 0x02020a02, 0x02020409, 0x02050204, 0x04040501, 0x2288820b, 0x82030201,
	0x04022470, 0x82070303, 0x07012a13, 0x02010401, 0x09020108, 0x21338209, 0x2a820103, 0x05010123, 0x20148202, 0x20038205, 0x3d008201, 0x1a080305,
	0x091b0d17, 0x01010403, 0x140a0c08, 0x0b130a08, 0x080a130c, 0x341b080f, 0x54820a1a, 0x0d091823, 0x2090821a, 0x24558204, 0x06050c04, 0x20558309,
	0x3c718203, 0x04070101, 0x09051207, 0x160c1619, 0x0820110b, 0x07072516, 0x14060c0e, 0x07050309, 0x26f98202, 0x150c050c, 0x820e060a, 0x03012a3a,
	0x0c080202, 0x0d1b361b, 0x29708202, 0x04070801, 0x0b02060a, 0x0d830201, 0x03060238, 0x050c1504, 0x04020408, 0x152b1605, 0x07122413, 0xaffe070e,
	0xfb82200e, 0x83060821, 0x01002b3c, 0x09015300, 0x77025308, 0x2d4b8d01, 0x2e312308, 0x65482701, 0x31302105, 0x2c05db47, 0x23012a27, 0x2207012e,
	0x30170706, 0x2f098231, 0x07010e27, 0x23222330, 0x22230626, 0x22312326, 0x16271283, 0x31231714, 0x82150614, 0x2606223c, 0x26168227, 0x22151614,
	0x87221526, 0x0622222f, 0x22578527, 0x8515010e, 0x26062244, 0x25118207, 0x30151416, 0x2f820139, 0x56820b82, 0x15232222, 0x0b820582, 0x17011e28,
	0x2223012e, 0x7b841506, 0x23243b82, 0x1c232226, 0xe4443b83, 0x15302406, 0x44141516, 0x2d820737, 0x15012a22, 0x26243082, 0x012a0722, 0x27232d82,
	0x82171614, 0x84222048, 0x22062763, 0x07220627, 0x17832623, 0x23209482, 0x3e225282, 0x70853501, 0x2a822482, 0x0e21dd82, 0x20ec8201, 0x82948527,
	0x06262105, 0x0884ef83, 0x0622ee83, 0x4e840714, 0xe7822320, 0x16216c82, 0x09684406, 0x48013e21, 0x1182059e, 0x7a4e3720, 0x16362108, 0x2b05034c,
	0x07061617, 0x32071606, 0x26343736, 0x2205e656, 0x82362627, 0x16172126, 0x48096544, 0x37220595, 0x02833616, 0x373c4d84, 0x07272622, 0x162e17ed,
	0x03162f17, 0x02010306, 0x03050201, 0x070e0701, 0x010d190d, 0x04260e82, 0x0d1a0d04, 0x0a830101, 0x01241d82, 0x050b0401, 0x07832083, 0x012a1582,
	0x05030503, 0x05020717, 0x39820102, 0x01251083, 0x08040204, 0x21498204, 0x13820702, 0x05281583, 0x0c06060c, 0x04020107, 0x02211e83, 0x2b158204,
	0x09020403, 0x0401090d, 0x030a0301, 0x08245182, 0x03060403, 0x02251882, 0x03020203, 0x831c8201, 0x0103234a, 0x22821309, 0x06212d83, 0x23518303,
	0x09030407, 0x08224282, 0x9c820710, 0x04223b82, 0x27820308, 0x02202d82, 0x05240082, 0x0a140a02, 0x6a827582, 0x1f840b20, 0x0b050135, 0x13281206,
	0x11162c16, 0x743a1121, 0x2344223a, 0x82142814, 0x0e092f52, 0x14291508, 0x03031408, 0x03080501, 0x44820703, 0x820f0621, 0x0d6608c5, 0x0a081106,
	0x05030913, 0x0b1e0d05, 0x1b122412, 0x381c1b37, 0x2b572c1c, 0x0c142a15, 0x1c0f0d19, 0x060e090e, 0x010b180d, 0x02060206, 0x09120902, 0x0a0f0601,
	0x01010e05, 0x20120302, 0x0e1d0f11, 0x1b010406, 0x3e1f1c37, 0x43874320, 0x13203f1f, 0x1f101326, 0x1c412210, 0x19041207, 0xef011934, 0x07070603,
	0xe0820b10, 0x01233283, 0x82070401, 0x010123e9, 0x01820301, 0x0120c783, 0x5a820e84, 0x05240882, 0x04080b03, 0x4705e443, 0x148206ea, 0x03820220,
	0x02030725, 0x84050304, 0x07022521, 0x04010202, 0x27077541, 0x02010a02, 0x03010208, 0x16822482, 0x02865682, 0x07840320, 0x01010324, 0x1f830308,
	0x3c821e82, 0x02020423, 0x822b8205, 0x8201203c, 0x2013843f, 0x22058301, 0x82112311, 0x130a2807, 0x05090609, 0x82040704, 0x0308296a, 0x03010303,
	0x02030403, 0x0128ad82, 0x020a0105, 0x0c030202, 0x27083b82, 0x0a060206, 0x040c180c, 0x07010609, 0x0504070e, 0x142f1608, 0x04030407, 0x140a040a,
	0x0b0b0a09, 0x04020102, 0x0b020605, 0x03233c82, 0x82091005, 0x0122080a, 0x0b020307, 0x0a140a06, 0x0e060c07, 0x03010f1f, 0x0c020803, 0x0b060916,
	0x0d1c0e09, 0x01041104, 0x66820b02, 0x01010324, 0x9c820d0f, 0x6c820120, 0x030b2a08, 0x0917200a, 0x04010b0e, 0x50000a00, 0x54080d01, 0xf3007102,
	0x0c01ff00, 0x25011901, 0x3b013201, 0x52014401, 0x00006801, 0x088b4801, 0x47222621, 0x8548057d, 0x822e2009, 0x220283a0, 0x52260623, 0x154d061c,
	0x22232307, 0xe751020e, 0x20088308, 0x06484306, 0x430ef647, 0x33260872, 0x1e151632, 0x3f851701, 0x480a685a, 0x37220538, 0x38913632, 0x9c433720,
	0x32162105, 0x22052c52, 0x4f011e17, 0xa04f05ee, 0x48272005, 0x36240b68, 0x013e0716, 0x82059f43, 0x3e35241d, 0x52321701, 0xed430aef, 0x05fc5408,
	0x48053121, 0x3f20091d, 0x220a2948, 0x8b25013f, 0x89172018, 0x8b37200c, 0x84022031, 0x06072217, 0x822d8536, 0x0e172508, 0x012e2701, 0x0725ae82,
	0x07363730, 0x05154525, 0x3a20ec82, 0x20088684, 0x3127032e, 0x65341908, 0x18331b33, 0x05050b06, 0x2e160705, 0x22432217, 0x1a142815, 0x1a0c1933,
	0x0814820c, 0x0b0f0729, 0x0b081007, 0x1d080508, 0x1a31190f, 0x12132714, 0x30191320, 0x67673319, 0x4a253264, 0x0d190d23, 0x040b1f0e, 0x82060408,
	0x104e0804, 0x0b110908, 0x190b140b, 0x47221a33, 0x1b371b25, 0x2f1c391d, 0x33192f5f, 0x0a160b19, 0x05030202, 0x17291804, 0x301c381c, 0x964b2f61,
	0x214b2546, 0x0409180c, 0x170b041e, 0x02040311, 0x1e060b05, 0x64302043, 0x17311732, 0x21152a16, 0x08822140, 0x162c1523, 0x25998205, 0x0504040d,
	0x02830502, 0x0408012b, 0x10021003, 0x230e090a, 0x2c34820b, 0x05010101, 0x09070609, 0x05090403, 0x261a8205, 0x2d030305, 0x82040101, 0x22113e33,
	0x34673312, 0x18182e17, 0x341a1830, 0x19402318, 0x0f0d1c0e, 0x94f80f1d, 0x0713180e, 0x38248210, 0x49010202, 0x0811190e, 0x04010310, 0x01020302,
	0x1a0e0302, 0x03110810, 0x2a0d8202, 0x0d470201, 0x1107101a, 0x82050303, 0xf7fd2126, 0x0f230c83, 0x82040404, 0x3a012426, 0x820e1c0c, 0x06032302,
	0x3e820d02, 0x140d3108, 0x3d06030b, 0x08040804, 0x24090309, 0x0201010f, 0x0803d201, 0x32633203, 0x0a204221, 0x06070a13, 0x5d5e2e06, 0x15022f5e,
	0x070e0704, 0x06040e18, 0x04254482, 0x05020209, 0x24768302, 0x04030405, 0x32b08203, 0x02020b08, 0x07090104, 0x0804110b, 0x01010211, 0x820f0506,
	0x0b053722, 0x180c1014, 0x070e0610, 0x050d1209, 0x0c06050a, 0x08110905, 0x02820d08, 0x170e0729, 0x081b0f0c, 0x82040d06, 0x02062e7b, 0x01030103,
	0x02100301, 0x02050b06, 0x3db58317, 0x09060304, 0x21101e1f, 0x0a0f0816, 0x0c052305, 0x020d0313, 0x13050706, 0x1c130d19, 0xd482060d, 0x82010421,
	0x08012234, 0x827f8303, 0x0c2108b5, 0x09110903, 0x030d150e, 0x0b030309, 0x15301002, 0x0308120c, 0x0a020307, 0x01070301, 0x04060901, 0x21618204,
	0xb3830108, 0x01062208, 0x04020101, 0x060d0602, 0x02020703, 0x02010107, 0x1d1f0d09, 0x02112011, 0x0f6c0305, 0x08040724, 0x2b938208, 0x0e1b0103,
	0x07040b20, 0x04090508, 0x7c26d082, 0x050b1f0e, 0xc4820805, 0x02010325, 0x861e0d05, 0x0102220c, 0x250b82cc, 0x06060404, 0x1882060a, 0x1a0d1938,
	0x0c190c0c, 0x0e510503, 0x16060920, 0x0905030b, 0x01010402, 0xb782080f, 0x02010123, 0x8276823f, 0x820120ba, 0x0503234f, 0xc0820301, 0x00820020,
	0x54000836, 0x54088600, 0x7700f502, 0xac009000, 0x3601cf00, 0x6b014f01, 0x20059148, 0x06904c03, 0x23012a25, 0x4c23012e, 0x21440778, 0x271d8308,
	0x26353426, 0x013e3736, 0x220b755e, 0x55140607, 0xd04309fa, 0x26362105, 0x47094953, 0x1e44099d, 0x012e280d, 0x011f2627, 0x83013e25, 0x0616213c,
	0x82091b4d, 0x06362460, 0x860e1337, 0x05534464, 0x250ae147, 0x010e023f, 0x164d0607, 0x89528605, 0x431a821d, 0xa64407bf, 0x0b6e5405, 0x27260624,
	0x4f853426, 0x3482c08c, 0x974c0e20, 0x84208309, 0x08f744c0, 0x16141722, 0x210dd944, 0x56823703, 0xbbd23120, 0x0736373f, 0x5124e803, 0x1f2b5654,
	0x150a203e, 0x0306030a, 0x06040204, 0x0904030e, 0x02070505, 0x080c8201, 0x130e0b96, 0x1c101c32, 0x14020305, 0x05010409, 0x070d1608, 0x0c080a1b,
	0x09221206, 0x0501020b, 0x0811070b, 0x1211170a, 0x0b070b29, 0x03090101, 0x03020804, 0x25070701, 0x0e1e1311, 0x02011c09, 0x100a0701, 0x0e240c04,
	0x271f3d1f, 0x8044274f, 0x0f1a0d3c, 0xfc0e0f1d, 0x0b1003ba, 0x0a08100b, 0x0802020f, 0x070e080a, 0x05040f07, 0x13090412, 0x0f0b390a, 0x060b070a,
	0x08060802, 0x16090810, 0x02030305, 0x01010202, 0x0408050d, 0x180c0204, 0x081f0c0d, 0x01010308, 0x34085982, 0x14060703, 0x0d1a0d07, 0x040d2010,
	0x170a0403, 0x1a0d0d0b, 0x5f2f6207, 0x1c371c37, 0x21214221, 0x11081d46, 0x03040608, 0x171d2108, 0x070b0e39, 0x03040903, 0x2cdc820b, 0x0f21080a,
	0x0a040b07, 0x160f0913, 0x085b8304, 0x08120724, 0x22090911, 0x07221119, 0x07061008, 0x4d070403, 0x091a0e1d, 0x0b020105, 0x02070409, 0x1c091303,
	0xbd821c38, 0x4c4e2837, 0x0a062349, 0x0498fc05, 0x100b0b0f, 0x030e0909, 0x070b0702, 0x21bc830f, 0xbc861104, 0x0c070927, 0x07080305, 0x24db8207,
	0x04030515, 0x43bc9001, 0x04220525, 0xbc8b0507, 0x820c1621, 0xe10128bc, 0x0c152018, 0x82050404, 0x010125ef, 0x08050203, 0x6d085a82, 0x12090902,
	0x0f241409, 0x05081514, 0x140a1116, 0x13291609, 0x0f090e09, 0x13050b19, 0x0b160809, 0x2c23421f, 0x36192c5b, 0x101f1116, 0x10102d14, 0x12080d2a,
	0x070e090b, 0x0f0b150a, 0x12110e24, 0x0c0d0101, 0x0d0e1d09, 0x30120b26, 0x02020803, 0x05040702, 0x360f0908, 0x09110b22, 0xbb0a0a14, 0x02021e08,
	0x3b08070d, 0x04070a0b, 0xfb820804, 0x1d08073a, 0x12251307, 0x020a2ffe, 0x0a13090c, 0x05051004, 0x0606050b, 0x0812080c, 0x2c08ea83, 0x0407040a,
	0x150bb803, 0x14140b0b, 0x200f162e, 0x081a0b0f, 0x0b060407, 0x1d0d0b17, 0x04070610, 0x0d0b160d, 0x1c4a190c, 0x0c060c2f, 0x30708303, 0x2f030c01,
	0x0d200c13, 0x0a0c2a1e, 0x3412160f, 0x08cf8213, 0x07150747, 0x0909160b, 0x1401031d, 0x12241105, 0x17213c1e, 0x5328172d, 0x11211124, 0x090c3e10,
	0x1c121225, 0x13231211, 0x09141526, 0x14090f1c, 0x102e0609, 0x09080c07, 0x04040104, 0x050a0504, 0x241e1505, 0x04090413, 0x36bcd5cf, 0x00020000,
	0x0626005d, 0x005b0316, 0x00de00c2, 0x012e0100, 0x58013e35, 0x232c0b4a, 0x0e072622, 0x06220701, 0x23362627, 0x2405c044, 0x2227012a, 0x82178206,
	0x22028326, 0x83232622, 0x8306200e, 0x012e2123, 0x07221782, 0x32831606, 0x82220621, 0x8227202f, 0x223e8211, 0x5d151606, 0x162005e2, 0x8206b358,
	0x05f75423, 0x2105a444, 0x17871415, 0x17010e22, 0x33272984, 0x3e37011e, 0x832e3301, 0x09eb5005, 0x2305584c, 0x3435013e, 0x2506a044, 0x33013a33,
	0x7260033a, 0x01272108, 0xa54d7582, 0x20c98205, 0x8327833c, 0x83322021, 0x0757087e, 0x03011406, 0x040d0101, 0x09020115, 0x0a130b0b, 0x080a0b08,
	0x0203071f, 0x010f0102, 0x07080504, 0x6e37070d, 0x11231137, 0x07030305, 0x5d2f060c, 0x162c162f, 0x320a0a0c, 0x170f3263, 0x06170810, 0x06051404,
	0x08050522, 0x09200f05, 0x040d0e06, 0x08020309, 0x82100402, 0x0c220853, 0x020a0504, 0x04020503, 0x24111017, 0x0f080b0b, 0x1209130a, 0x1b1a1125,
	0x08030306, 0x060a0602, 0x48821b10, 0x09013608, 0x070e070f, 0x242e582e, 0x1204254a, 0x03060303, 0x04050d05, 0x2b0d180b, 0x1428150f, 0x0d0a150b,
	0x0608050b, 0x1b0c0e14, 0x21432111, 0x67676733, 0x040e0a34, 0x08238207, 0xfd021033, 0x11220803, 0x0b0d250d, 0x01020409, 0x21111128, 0x02021c11,
	0x0aee0207, 0x0d0b0b14, 0x0a040402, 0x0c03030e, 0x04010506, 0x020a0204, 0x0c040101, 0x21e98201, 0x0a820105, 0x010f4108, 0x0603010a, 0x04041804,
	0x08041b04, 0x020c0f17, 0x02010601, 0x030f0203, 0x08071308, 0x13090a0d, 0x0507110a, 0x0f0f1005, 0x0301010a, 0x0e191c04, 0x0f060e18, 0x0d190c06,
	0x1d264c25, 0x230b1e3c, 0x02324482, 0x0d020301, 0x0f0b240a, 0x3d1f0f1d, 0x112e1b1f, 0x1283110a, 0x47820220, 0x2d150d33, 0x09280f14, 0x0b021609,
	0x10132713, 0xcdfe1027, 0x2f6b8212, 0x09060b05, 0x12251307, 0x1331031a, 0x000d1f0f, 0x04330082, 0x25004f00, 0x5a039309, 0x0c019100, 0x4a012c01,
	0x4e010000, 0xae460a77, 0x23172708, 0x0607010e, 0x02822326, 0x42262221, 0x0624067f, 0x15071716, 0x27231684, 0x600f012e, 0x1525088a, 0x14171614,
	0x2c2c8306, 0x012f0622, 0x2e35012e, 0x26342701, 0x0a895a27, 0x20065347, 0x062f4226, 0x23823720, 0x36227382, 0x05821716, 0x06823520, 0x15163228,
	0x33363217, 0x05823216, 0x21011f24, 0x208a1735, 0x20833320, 0x86011e21, 0x08ee5a19, 0x010e0724, 0x73842317, 0x3f662620, 0x06142106, 0x0f218882,
	0x60a08501, 0x8a5708d2, 0x05114706, 0x843e3521, 0x8235209c, 0x3437249e, 0x84333736, 0x853720f8, 0x3e37221b, 0x230f8201, 0x012a0527, 0x200f2f54,
	0x2218831e, 0x83263637, 0x05232527, 0x23072622, 0x21055247, 0x96831733, 0x3f21c483, 0x081b8301, 0x23012aef, 0x09038804, 0x090e0505, 0x04060d07,
	0x0702010b, 0x01080303, 0x51010602, 0x0b020302, 0x1d0f0b1c, 0x1a351a0f, 0x170e1d0e, 0x02161020, 0x3e1c0a02, 0x1321131e, 0x17153416, 0x0805080a,
	0x06040911, 0x08070305, 0x1f1a4017, 0x010c1c3e, 0x12201401, 0x05010202, 0x01090202, 0x080e1d10, 0x0f0d0910, 0x143a0a10, 0x0603030a, 0x18150815,
	0x02050208, 0x190f0404, 0x101d0e0e, 0x040c170c, 0x3d1f0403, 0x1325121f, 0x080d220d, 0x01d61102, 0x04060203, 0x0f0e170f, 0x180c101e, 0x0103070c,
	0x0940803f, 0x04030e02, 0x2e160209, 0x0c0b0306, 0x55010402, 0x17371604, 0x211c361b, 0x180c1a38, 0x05080202, 0x22451f0a, 0x11226527, 0x0d08070c,
	0x1516110b, 0x3c1e1731, 0x0b05021d, 0x02080905, 0x12231302, 0x09010502, 0x21080205, 0x06260f0d, 0x088b820d, 0x07010937, 0x19071506, 0x33fd071f,
	0x13112311, 0x0907111c, 0x02050602, 0x0f060c06, 0x1d0e111d, 0x04332f0f, 0x05080102, 0x04350d11, 0x0b210d74, 0x05190d04, 0x03070302, 0x241d8214,
	0x2f0f1e0f, 0x2e8d8231, 0x190d1205, 0x2e031932, 0x06040a06, 0x83020104, 0x0d082bb5, 0x1f080d19, 0x1a361a0a, 0x71820603, 0x01015d08, 0x05030102,
	0x35140f19, 0x0b020a19, 0x02010215, 0x050a0302, 0x10190d0d, 0x0f1c391c, 0x2714101a, 0x08191114, 0x0c03050e, 0x0a150b0f, 0x020a0502, 0x1f100206,
	0x1224120f, 0x13214120, 0x2c191327, 0x0407141c, 0x060c130a, 0x29140106, 0x0e1b0d1c, 0x01010806, 0x0c060305, 0x03011b01, 0x182f7182, 0x01010104,
	0x2e030d03, 0x07080f08, 0x82020107, 0x191021a3, 0x06251982, 0x0202090f, 0x2c29820a, 0x1b130507, 0x0b310e16, 0x091e3c1e, 0x322c8308, 0x180a170a,
	0x070d0611, 0x0b041906, 0x02130c04, 0x82191a02, 0x381a289d, 0x20522319, 0x8202030b, 0x1405253b, 0x04090410, 0x063adf82, 0x0e190e05, 0x21132514,
	0x4a221e41, 0x09142524, 0x081b0702, 0x33170905, 0x8482ba24, 0x0b05082b, 0x0c190c06, 0x04060b06, 0x3384820d, 0x0e101707, 0x10090d18, 0x05030607,
	0x0d0e0d07, 0x06140c1a, 0x06391783, 0x20131218, 0x00060f09, 0x57000200, 0xd4042400, 0x98005a03, 0x0000b700, 0x05d26301, 0x66062221, 0x032010be,
	0x85451183, 0x16262105, 0x2706d242, 0x0607010e, 0x14161716, 0x820be945, 0x1415211a, 0x36261482, 0x37013e37, 0xda4a3632, 0x0c476905, 0x37343629,
	0x1617013e, 0x4a363732, 0x36210728, 0x43268234, 0xc066058a, 0x82172008, 0x36342226, 0x28448235, 0x01272634, 0x1415011c, 0x27818626, 0x3c353626,
	0x32343501, 0x69822a84, 0x15066008, 0x0c02ce04, 0x050a050c, 0x14070c04, 0x6633152a, 0x020a0332, 0x0c030503, 0x69350c17, 0x1235696a, 0x0f081325,
	0x1b301807, 0x0a06070c, 0x090c0614, 0x010a0405, 0x121c4802, 0x08040308, 0x050b0604, 0x0507120b, 0x0e0d0d06, 0x4d27132e, 0x082e1127, 0x02030701,
	0x02040305, 0x02050904, 0x82010206, 0x0c112b2c, 0x160c1014, 0x254b260b, 0x1c822415, 0x00820120, 0x0e090431, 0x1e0d1024, 0x3265320d, 0x0203090f,
	0x8203083a, 0x08178228, 0x20fe0525, 0x381c0c2c, 0x0b2c0c1c, 0x0d250208, 0x042b582c, 0x02050207, 0x1e093003, 0x23010102, 0x03030201, 0x820f0501,
	0x132b0856, 0x0c0f0705, 0x12173415, 0x222a1121, 0x1016090d, 0x0c081209, 0x25110c16, 0x25492412, 0x10183117, 0x050f0c19, 0x01050101, 0x8204180f,
	0x020c3273, 0x12091109, 0x14091223, 0x080f080a, 0x090d3814, 0x084f8205, 0x06090130, 0x0b151603, 0x11080c18, 0x05130a08, 0x02031509, 0x060c1f02,
	0x0c060303, 0x06050606, 0x1a0b180b, 0xccfe1931, 0x130a150a, 0x05070502, 0xc582071e, 0xf6821420, 0x00091b33, 0x4b000200, 0x73052600, 0x94005a03,
	0x0000a700, 0x07af4701, 0x28058f44, 0x17160607, 0x1415011e, 0x200e8206, 0x05f84127, 0x41071d51, 0x232208fe, 0xb354012a, 0x22372905, 0x36262726,
	0x15011c37, 0x44089858, 0x2e2305e0, 0x693c2701, 0x4860052c, 0x1632270a, 0x33361617, 0x0284033a, 0x65330121, 0xc14505e3, 0x05956805, 0x82063221,
	0x0517217a, 0x22215d82, 0x85818206, 0x35840821, 0x05233634, 0x14210a73, 0x4f271428, 0x162a1627, 0x0302360c, 0x06010402, 0x51280212, 0x13291328,
	0x0a0b160b, 0x19110b0d, 0x0e1c1409, 0x07080f08, 0x10010216, 0x060d060d, 0x013e7b3e, 0x28140203, 0x060d0e0d, 0x0b162b19, 0x0f0b0c18, 0x28041108,
	0x0a0a150b, 0x04070106, 0x0e071c04, 0x0a06060a, 0x02070d0d, 0x2b020e01, 0x2a545454, 0x7473743a, 0x254c263a, 0x03081109, 0x0a020101, 0x06020805,
	0x07080106, 0x013b5682, 0x02040101, 0x4e2803fe, 0x020d1128, 0x28502811, 0x12030f0d, 0x4c18c002, 0x82030203, 0x8201201a, 0x11042c00, 0x08142813,
	0x16030812, 0x82020405, 0x0203327b, 0x04020702, 0x441f0d27, 0x14291522, 0x0e163216, 0x23a08313, 0x18371614, 0x26082d82, 0x11224420, 0x29101120,
	0x175b2512, 0x06050a05, 0x29140a19, 0x08110814, 0x08070b07, 0x03010102, 0x01020a0b, 0x82030d09, 0x03042286, 0x30018201, 0x06150402, 0x7d1b341b,
	0x3f091210, 0x4409100d, 0x2f008200, 0x00550002, 0x03970425, 0x0093005a, 0x010000c4, 0x26053347, 0x2a232226, 0x84062301, 0x16222105, 0x8206ad41,
	0x36222111, 0x26210b8a, 0x4a268227, 0x06210511, 0x08da4126, 0x8805254e, 0x4e08820e, 0x27200bb7, 0x2e205f85, 0x2306c949, 0x33321633, 0x4607eb5a,
	0x352b05fe, 0x36373634, 0x36323716, 0x82323633, 0x3e352605, 0x06052701, 0x05685314, 0xeb490582, 0x08b35205, 0x82060d47, 0x36262154, 0x36214b83,
	0x236c8216, 0x01960407, 0x0a2afe82, 0x190d160c, 0x68341932, 0x3a4d0434, 0x03053405, 0x091a351a, 0x05050914, 0x0e1e0e04, 0x0f3c783c, 0x82020f1d,
	0x0f330800, 0x030d0303, 0x09040404, 0x12090a19, 0x031c0b06, 0x11120103, 0x0a14122c, 0x05090305, 0x0f0b160a, 0x10090916, 0x0d170103, 0x301b351b,
	0x32093062, 0x83190516, 0x02390860, 0x0c170a05, 0x08051c03, 0x3c1d080f, 0x264f271d, 0x01021e08, 0x04010203, 0x220e1215, 0x1f3f1f0f, 0x14142714,
	0x01010105, 0x0b019dfe, 0x16081708, 0x6119162a, 0x1e0c0c01, 0x37618210, 0x0a0b2101, 0x190e0d15, 0x040b0603, 0x02021408, 0x31180e0a, 0x02180218,
	0x0228aa82, 0x101e0fde, 0x0607160a, 0x24082b82, 0x0302010d, 0x020d0201, 0x05050705, 0x2a0f0915, 0x10421712, 0x0d0c0b0f, 0x190e171a, 0x19331a0c,
	0x1d214020, 0x2550833c, 0x0a050b05, 0x46820a13, 0x060d0337, 0x120c190d, 0x3f211020, 0x01570820, 0x01010201, 0x04010707, 0x821d820c, 0x11132556,
	0x01030404, 0x2c280082, 0x152b150d, 0x06170af1, 0x3e080d84, 0x26030302, 0x0e0e2211, 0x04280103, 0x06061a0d, 0x0904050b, 0x06070201, 0x130e190a,
	0x13060104, 0x0f210e03, 0x00030000, 0x04250059, 0x0059038e, 0x01d400ce, 0x0100001e, 0x26273634, 0x49363706, 0x1420079e, 0x6d45b482, 0x3c353606,
	0x010e2301, 0x23223635, 0x2326022a, 0x2615011c, 0x06142322, 0x05b14807, 0x07061624, 0x02821406, 0x32161723, 0x057e5817, 0x21058158, 0x11460616,
	0x87172005, 0x08464229, 0x010e1522, 0x2206e361, 0x58173614, 0xde5c05ab, 0x611e2005, 0x16240541, 0x27263435, 0x240b1f4c, 0x3e37013e, 0x05465101,
	0x013a3322, 0x17210282, 0x82238232, 0x823620ae, 0x05644229, 0x33221785, 0xc0821632, 0x372a1482, 0x17163601, 0x06012622, 0xa76c2726, 0x06072107,
	0x21078746, 0x4e823634, 0x4205fa58, 0x372105ce, 0x294b8232, 0x27303506, 0x012e2326, 0x55822627, 0x36373622, 0x16204982, 0x08061862, 0x07011c8a,
	0x04038b04, 0x03020905, 0x2c160824, 0x3b763b16, 0x17030303, 0x172f1804, 0x0306110a, 0x0a09010c, 0x62626231, 0x08110831, 0x0e050514, 0x01060406,
	0x05070401, 0x01010201, 0x02030405, 0x12071307, 0x07060c23, 0x0b090101, 0x010a0203, 0x0604020b, 0x070e0403, 0x03020403, 0x06060202, 0x0d3a0501,
	0x06090305, 0x240c060f, 0x19341a0d, 0x0a0a0e0a, 0x12060a14, 0x080a0317, 0x01040407, 0x04020802, 0x0a04040b, 0x01070202, 0x062b5482, 0x39713907,
	0x03183118, 0x82080412, 0x0b0b365d, 0x0e092306, 0x371c0e1c, 0x0242091c, 0x02010303, 0x050394fc, 0x395c8201, 0x070c0119, 0x24120e08, 0x20402112,
	0x01010110, 0x0d01010a, 0x16030412, 0x9f820a06, 0x07122808, 0x090c1208, 0x04060a15, 0x060f0204, 0x12090105, 0x08010a07, 0x162d1605, 0x040a170e,
	0x0302010f, 0x03120425, 0x820a0405, 0x01012f0a, 0x04061906, 0x040c0202, 0x0501010b, 0x4083010a, 0x110c5508, 0x0a150a0b, 0x0a0a1709, 0x19040505,
	0x07110706, 0x04010306, 0x03040402, 0x08101c09, 0x0c070a0c, 0x05170505, 0x03031003, 0x11060318, 0x0d1b0d07, 0x07060f05, 0x26100710, 0x04040511,
	0x0b050805, 0x0f190b17, 0x030e0307, 0x07030202, 0x06030108, 0x03060306, 0x0736e782, 0x0f340c04, 0x09091808, 0x1b0f080f, 0x0d190d0f, 0x090a180a,
	0xa2820916, 0x0805013b, 0x30020513, 0x09120905, 0x060b1010, 0x190c0504, 0x351a1936, 0x0119fd1a, 0x25de8202, 0x0102088e, 0x0a82020e, 0x0b0c1322,
	0x12350282, 0x070c0a0b, 0x03020905, 0x110f082e, 0x060c0b0b, 0x12010104, 0x2ed78202, 0x0d050203, 0x0e200d08, 0x05010e06, 0x82010106, 0x03082872,
	0x08112312, 0x82000810, 0x00023900, 0x08260053, 0x005a03fb, 0x008c0064, 0x012f0100, 0x21270721, 0x15230727, 0x43080182, 0x35072735, 0x21152327,
	0x21352315, 0x0f15022f, 0x27072701, 0x14070622, 0x0f021f16, 0x1e011f01, 0x011e1701, 0x010e020f, 0x0f010e07, 0x37270501, 0x013f1713, 0x033f021f,
	0x013f013e, 0x35013f21, 0x15333527, 0x17280182, 0x17372137, 0x27023f21, 0x2f212c82, 0x07e94204, 0x36833f20, 0x06072809, 0x37011f16, 0x3634012f,
	0x021f033f, 0x08f80815, 0x0a46fe07, 0x0da9fe0a, 0x1c2b960a, 0x48080a0b, 0xfeafd2fe, 0x175c09c7, 0x072b131e, 0x02090810, 0x350a0504, 0x260b0103,
	0x0604130e, 0x140a0203, 0x090a1a10, 0x0103040e, 0x49031035, 0x16161a0a, 0x17961525, 0x06023a0e, 0x46010603, 0x1e070703, 0x090d9131, 0x06095701,
	0x0905bf01, 0x55fa0204, 0x473f1d15, 0x19252a1f, 0x03020104, 0x1305080a, 0x0910170d, 0x0501010b, 0x060a0b06, 0x11050602, 0x100aa423, 0x1e2d0302,
	0x06010409, 0x17142a06, 0x0a1a010d, 0x07060527, 0x39190d02, 0x02261c5e, 0x0a050807, 0x15060303, 0x050d0c21, 0x0d050509, 0x23291a09, 0x5227274a,
	0x1703472b, 0x03360123, 0x0c030503, 0x10050508, 0x0308058c, 0x18063103, 0x1a153206, 0x04030605, 0x35381e0d, 0x413cecfe, 0x02020304, 0x14091d10,
	0x09120a0b, 0x06040a06, 0x0f1a0c13, 0x180d1608, 0x0a1d0e07, 0x24170812, 0x0e090101, 0x02000009, 0x26006500, 0x5f03f605, 0xb4017b01, 0x55010000,
	0x1e240505, 0x06141501, 0x23064148, 0x36372632, 0x5906c55c, 0x1522053a, 0x1d821614, 0x17301724, 0x68443516, 0x16322e05, 0x15011c15, 0x32231626,
	0x16261736, 0x210b8235, 0x11830616, 0x23261427, 0x010f2622, 0x05e74806, 0x0f060729, 0x27261401, 0x51270626, 0xad440700, 0x23222407, 0x44070622,
	0x3e8208bc, 0x17321422, 0x830af750, 0x08354526, 0x23012a2d, 0x2627012a, 0x013c3536, 0x82010e35, 0x3435265f, 0x3d343526, 0x29178401, 0x15162223,
	0x22272226, 0x4d822306, 0x82101f45, 0x06072262, 0x057b4432, 0x21068d4e, 0x8c84012e, 0x2a272624, 0x9b833501, 0x27513420, 0x3e372208, 0x55f68201,
	0x1a820b6c, 0x56373521, 0x27250972, 0x3435012e, 0x47808206, 0x0e840593, 0x7c662620, 0x22388608, 0x74373635, 0x4d82059a, 0x27013e2c, 0x26173616,
	0x011e3336, 0xa4491415, 0x33012b05, 0x3b16023a, 0x26343101, 0xef6f0337, 0x011e2108, 0x8505d84f, 0x20de8257, 0x82ea8427, 0x141522bd, 0x23398206,
	0x26331632, 0x15225683, 0x22823634, 0xfd023536, 0x05111c11, 0x0204050d, 0x5a2d0101, 0x252d5b5a, 0x0305264c, 0x02310c82, 0x0d020201, 0x07120903,
	0x01080701, 0x0b040402, 0x34048202, 0x0c010301, 0x08150904, 0x01010902, 0x18070709, 0x07020105, 0x38008302, 0x050e0303, 0x2f264c26, 0x05032f5e,
	0x2e060b02, 0x090f0c09, 0x020c0d04, 0x231c8204, 0x06070903, 0x27082484, 0x1b021301, 0x160c1b37, 0x0305090b, 0x05050303, 0x03260409, 0x130f1d0f,
	0x02091326, 0x05142914, 0x07010207, 0x05040205, 0x02277e82, 0x04010502, 0x82010204, 0x01033f60, 0x02030303, 0x13060904, 0x06130902, 0x10152715,
	0x0b051320, 0x10160706, 0x03070202, 0xab820602, 0x82010121, 0x030134ad, 0x0707110b, 0x05020716, 0x10080103, 0x02010302, 0x82010106, 0x8205209d,
	0x07192750, 0x06061008, 0xb7820407, 0x12820320, 0x03040422, 0x3883cd82, 0x04010929, 0x0c060202, 0x821b0706, 0x01022571, 0x11050a0b, 0x32086f82,
	0x2a150615, 0x5d5e2f15, 0x01012f5e, 0x05044502, 0x07150608, 0x020c180c, 0x12030813, 0x08100101, 0x020b140e, 0x0d02090e, 0x07030703, 0x393e3209,
	0x82030107, 0x01012a73, 0x44030401, 0x040b1209, 0x24738207, 0x01120207, 0x23bf8303, 0x0f020201, 0x08240782, 0x04030202, 0x0332d582, 0x01080104,
	0x02100305, 0x0402020b, 0x030a0402, 0x91820103, 0x07020532, 0x07040710, 0x03010803, 0x01070804, 0x09010c03, 0x04231e82, 0x85010309, 0x080a2300,
	0x0282070f, 0x091e092d, 0x0a080c04, 0x0d060913, 0x82060206, 0x180830a9, 0x05090a07, 0x0e080903, 0x5e2f0e20, 0x8211032f, 0x07053bd4, 0x7339081f,
	0x030d0339, 0x0b1a0805, 0x130c0c01, 0x20010108, 0x06020b01, 0x65820506, 0x05060538, 0x08030a03, 0x0803080d, 0x050a0502, 0x0c030609, 0x05180a02,
	0x3a820602, 0x99820220, 0x01090131, 0x09040407, 0x101b1205, 0x02080e07, 0x82030104, 0x03093689, 0x110f220b, 0x06040d1d, 0x010d0203, 0x070a0d09,
	0x06060208, 0x27be8207, 0x05040a04, 0x02080808, 0x0b333d82, 0x020a0102, 0x06040902, 0x1e0f0815, 0x07150a0f, 0x82020904, 0x02012f3d, 0x01030201,
	0x02030206, 0x03040704, 0xd182090f, 0x04820b20, 0x0f030532, 0x01010401, 0xfe051207, 0x041408a1, 0x150c0102, 0x0438ff82, 0x04030909, 0x0b030b0a,
	0x03110303, 0x02010301, 0x1103071b, 0x050c0504, 0x052b6082, 0x010e0405, 0x04040504, 0x82000406, 0x00033a00, 0x0526005a, 0x005a032d, 0x01dc00cc,
	0x0100000d, 0x3e333216, 0x3a163301, 0x20068202, 0x05084337, 0x3305b751, 0x2a071416, 0x16062701, 0x23010e07, 0x36072606, 0x011e1716, 0x22056655,
	0x82031e23, 0x0e17230b, 0xf0430701, 0x22272207, 0x07534d06, 0x61270321, 0x062305ef, 0x4f141516, 0x7d5e0758, 0x0c3a5207, 0x0e223e82, 0x5c822701,
	0x27262225, 0x8235013c, 0x08005335, 0x37013e2b, 0x26272636, 0x36262706, 0x850b8227, 0x012e220e, 0x53208537, 0x36210518, 0x82b08316, 0x25ad8205,
	0x0517013a, 0x5d830622, 0x3e220c82, 0x3c822701, 0x06260522, 0x15209d82, 0x2205d24f, 0x8215011e, 0x824c8264, 0x36342218, 0x832a8435, 0x361621c1,
	0x83057344, 0x02ba08b2, 0x1b361b4b, 0x290d1b0d, 0x29525252, 0x09040202, 0x07040913, 0x04020506, 0x072a552a, 0x2b562b07, 0x02040304, 0x4f27060c,
	0x0c140d27, 0x06020503, 0x160b070e, 0x2221120b, 0x0f061121, 0x03060305, 0x0e050101, 0x06070506, 0x10070e08, 0x06061020, 0x1e1e0f02, 0x1c0d0f1f,
	0x030a070e, 0x01010402, 0x160d1a0b, 0x2513172e, 0x0f220f12, 0x0705120f, 0x0f070814, 0x01010204, 0x06031108, 0x0502090f, 0x2f5d2f03, 0x10040a05,
	0x06030624, 0x0b150a07, 0x0b060c05, 0x0a06091b, 0x142a1213, 0x14010208, 0x01060f2a, 0x08090201, 0x01010b06, 0x08040507, 0x060c0704, 0x0c050c05,
	0x98820b18, 0x060c0622, 0x42299382, 0x72fe4284, 0x01020502, 0x08288203, 0x07030536, 0x03090101, 0x1d11e401, 0x0d040110, 0x0b080302, 0x17100e06,
	0x01080a09, 0x01020601, 0x0a09160d, 0x1e01010d, 0x1e422013, 0x01041710, 0x18070802, 0x0341030c, 0x85829182, 0x23820120, 0x040d2a08, 0x01030b03,
	0x10230f01, 0x10221101, 0x01010407, 0x04100102, 0x05040602, 0x36010307, 0x366c6b6c, 0x03162a16, 0x0c060304, 0x24728205, 0x07010b01, 0x08358201,
	0x2f081030, 0x305e5f5f, 0x062d5b2d, 0x12090910, 0x0f1e0e0a, 0x08050b09, 0x08020208, 0x08070506, 0x1c0f1b05, 0x2b161c38, 0x0f1e0f16, 0x08090804,
	0x5582060d, 0x01012e08, 0x0d070205, 0x110d0206, 0x20183319, 0x1a0e2040, 0x1626150d, 0x0b0c2d14, 0x12050105, 0x10060607, 0x0b081006, 0x0c060715,
	0x050c0809, 0x84898202, 0x0101212f, 0x3b827a82, 0x01060c25, 0x82010224, 0x052108f7, 0x06030107, 0x02040604, 0x010f02a7, 0x08030503, 0x200f0a0e,
	0x090b050b, 0x240f0c17, 0x03050411, 0x08638202, 0x1b0a082f, 0x0620150e, 0x080f0607, 0x1c0d111d, 0x020d0b0b, 0x00050000, 0x0627005b, 0x005a03e3,
	0x00e600d6, 0x010601f3, 0x01000034, 0x16171614, 0x055e4b06, 0x7c4b0720, 0x522a2005, 0x07250637, 0x0607010e, 0x05916914, 0x58051c4c, 0xa9730548,
	0x73162006, 0x0721068b, 0x07024322, 0x50010e21, 0x0243057d, 0x05bd5805, 0xf0422720, 0x013e240b, 0x5c323637, 0x11820d69, 0x08431620, 0x833e2006,
	0x3233223e, 0x22208326, 0x43333236, 0x362a052c, 0x06323316, 0x15163233, 0x26483614, 0x3a332205, 0x890e8201, 0x033a2105, 0x82088c50, 0x23808208,
	0x06360537, 0x2325a882, 0x06072622, 0x21128232, 0x0f853733, 0x83360621, 0x8217200c, 0x2102823e, 0x06773632, 0x26222206, 0x06c55617, 0x82160621,
	0x05ed4e3c, 0x26342723, 0x44fc8223, 0xb1860729, 0x84263621, 0xc25008f9, 0x0101021c, 0x04070201, 0x05010402, 0x09140a06, 0x7878783d, 0x2f5c2f3c,
	0x07070510, 0x0401020a, 0x0d103508, 0x13170847, 0x2d141736, 0x071b1210, 0x03060c01, 0x0b030108, 0x0a15080b, 0x080c170c, 0x04010105, 0x05110201,
	0x02020708, 0x0c090c01, 0x39334982, 0x19311911, 0x100e2815, 0x31080303, 0x0a140a1e, 0x82081b0b, 0x047c085d, 0x0806060a, 0x0c1d0b05, 0x0909080e,
	0x0c060c0d, 0x050d0506, 0x0a101b16, 0x150b071b, 0x0e180d0c, 0x0407010b, 0x180d0408, 0x041b0710, 0x02020101, 0x04060312, 0x07020904, 0x08200906,
	0x05040503, 0x2513050c, 0x38703912, 0x11090b0b, 0x67331123, 0x1d336766, 0x1c0d1d3a, 0x080e080b, 0x01020506, 0xdefd0802, 0x0c092b05, 0x16030b18,
	0x03380c02, 0xfe122612, 0x12083305, 0x2e011124, 0x59080582, 0x24117d12, 0x0a150a12, 0x01071202, 0x190d0211, 0x0433080c, 0x0f08c3fc, 0x030d0d09,
	0x02080904, 0x05060409, 0x050f1106, 0x150c021f, 0x0509050c, 0x16100f08, 0x1b151a4a, 0x0101060a, 0x0a120602, 0x33030623, 0x0a161e15, 0x150d0a12,
	0x0817060d, 0x11041d04, 0x08122110, 0xc9820721, 0x11048e08, 0x133b1c0e, 0x0f0d0810, 0x2503171e, 0x0523050a, 0x0305020e, 0x05020206, 0x0c071c01,
	0x14080c17, 0x0f0d0c07, 0x0c0d180d, 0x0d0b0807, 0x0101150e, 0x01010203, 0x1b321813, 0x12397940, 0x2d151224, 0x0a150b16, 0x0d030408, 0x02040604,
	0x08090803, 0x0301030d, 0x03030101, 0x0101230a, 0x08050a0b, 0x03060202, 0x04080407, 0x060c040a, 0x02022703, 0x09010802, 0x04040106, 0x06030b01,
	0x0503040d, 0x02080606, 0x02040f28, 0x0e010b02, 0x083c8204, 0x02070151, 0xfe0c0402, 0x030805a1, 0x110e0203, 0x08030e18, 0x05040503, 0x0215230f,
	0x03060308, 0x120c180c, 0x02100b0f, 0x13130506, 0x130d1d0b, 0x11040707, 0x0000000f, 0x005d0003, 0x03e30426, 0x00e7005a, 0x000701f7, 0x011c0100,
	0x23260607, 0x7c150622, 0x22210562, 0x06374f16, 0x23262226, 0x0e070626, 0x06251d84, 0x011c2726, 0x24028215, 0x06072614, 0x07b34a16, 0x2607f051,
	0x3c353622, 0x4f343501, 0x262005d1, 0x200b4443, 0x08037f27, 0x26204182, 0x2005e942, 0x8471822b, 0x2306224a, 0x202c8222, 0x60238406, 0x3528098d,
	0x1e17011e, 0x17303301, 0x07228783, 0x5d4a2206, 0x012a2606, 0x06273127, 0x05544f36, 0x17433320, 0x24058205, 0x36353632, 0x081a6034, 0x32211786,
	0x05b64a26, 0x8305e043, 0x16322614, 0x32160517, 0x05484333, 0x82262221, 0x011721d5, 0xd082f182, 0x2c086d82, 0x2e37013e, 0xe3042301, 0x0a27070c,
	0x0d040110, 0x0e234622, 0x0d010105, 0x01020201, 0x03112211, 0x1109041a, 0x0914090e, 0x0f182e1b, 0x08138204, 0x150a0336, 0x1931190a, 0x100f0103,
	0x0a0c1a0d, 0x06020609, 0x04060301, 0x02091108, 0x0d070603, 0x0f380c0a, 0x09050a08, 0x1604040d, 0x0f1e0f04, 0x1b0c0c02, 0x0a110b04, 0x07264182,
	0x0b08030d, 0x43820302, 0x01024208, 0x9e501d01, 0x080f084f, 0x02010303, 0x28100504, 0x12241312, 0x030d1c0e, 0x02010115, 0x150b0910, 0x1528150a,
	0x2a244824, 0x33192a53, 0x02010419, 0x1024100c, 0x05020906, 0x2f180903, 0x04070318, 0x08468305, 0x390a0644, 0x0201110b, 0x0c170b12, 0xfe07070c,
	0x192d1708, 0x06062413, 0x1d0a163b, 0x0d050e0a, 0x0809c8fd, 0x06020201, 0x0704080d, 0x11c80204, 0x04070c16, 0x1a0b0d12, 0x04080b0e, 0x070d0608,
	0x05320101, 0x8182110b, 0x07014908, 0x2d5c2d0f, 0x09091009, 0x0f030505, 0x0d1b0d03, 0x021a351a, 0x1b05390a, 0x03111c36, 0x1203080e, 0x0f1d0e03,
	0x0c254b25, 0x1b0c0b0b, 0x01060c0a, 0x09050901, 0x03030312, 0x0b0b160c, 0x07020b16, 0x02030302, 0x060f0204, 0x273df082, 0x2c172751, 0x0e140e16,
	0x010b0e05, 0x01030403, 0x0a030707, 0x02010103, 0x0c010301, 0x05e64a01, 0x0b051229, 0x01020209, 0x820e0204, 0x08ff82d3, 0x04020d3f, 0x1c0e091a,
	0x022a0a15, 0x1008e90b, 0x02021d1a, 0x0a290705, 0x0b013301, 0x10080f07, 0x321a101e, 0x00020119, 0x00050000, 0x0924005a, 0x015a033d, 0x01c201a4,
	0x02e501d5, 0x01000007, 0x059c421e, 0x16171626, 0x36163336, 0x2a061749, 0x0e27010e, 0x26060701, 0x45061415, 0x07200529, 0x16210e83, 0x073d5215,
	0x0d520e84, 0x51342007, 0x062205c1, 0x2c832623, 0x013e2323, 0x223b8435, 0x83011e23, 0x0730254d, 0x16062306, 0x490cd862, 0x2e21052d, 0x05a24c01,
	0x23200585, 0x83098c5b, 0x05e16757, 0x33203582, 0x6c494b84, 0x080e6808, 0x850bab45, 0x2023842c, 0x20058203, 0x23908635, 0x32363336, 0x46086e7f,
	0x3e200f8d, 0x17239c83, 0x56173632, 0x834e05f0, 0x36142405, 0x87263435, 0x82088332, 0x323322ff, 0x27148216, 0x33013a33, 0x14150632, 0x23076174,
	0x1c153632, 0x16231182, 0x87263637, 0x3516211a, 0x2305c77c, 0x16170632, 0x34242682, 0x33163435, 0x16215f82, 0x05fe5206, 0x15210b82, 0x82118214,
	0x17362117, 0x50861482, 0x40183220, 0x3e240f31, 0x36343701, 0x2f82ad82, 0x9b823720, 0x17011e23, 0x05a84705, 0x89063221, 0x05c4432a, 0x35263225,
	0x84361401, 0x4736207f, 0x2325055b, 0x25152622, 0x06c45d36, 0x841e1721, 0x060268a1, 0x4a05d153, 0xf7640525, 0x057a4107, 0x08276508, 0x090e0caf,
	0x05250101, 0x04032609, 0x1b080a09, 0x0f140e0c, 0x08090402, 0x05060307, 0x19060619, 0x090e0705, 0x02020512, 0x05020204, 0x0a040302, 0x03033114,
	0x05030104, 0x0f040b03, 0x0f061314, 0x09100807, 0x01122611, 0x0e190d02, 0x040e1e0d, 0x07010307, 0x01080702, 0x09010305, 0x11080812, 0x090c0209,
	0x2b05a574, 0x02011405, 0x0b050203, 0x07110805, 0x033c4e82, 0x26130b03, 0x0f0f1012, 0x19142713, 0x0d061735, 0x060f0806, 0x02031203, 0x07030407,
	0x30080582, 0x060b0602, 0x02031109, 0x18060605, 0x10201106, 0x05023b05, 0x29140812, 0x0b130815, 0x2313300f, 0x2d17234c, 0x31613115, 0x52525229,
	0x035a1129, 0x369e8204, 0x14152b02, 0x9f501428, 0x274e2750, 0x130d1f0d, 0x21100f20, 0x820f0813, 0x0b062986, 0x11090f18, 0x060c0609, 0x04205c82,
	0x0b376282, 0x05090a03, 0x1f030202, 0x050a0505, 0x02020404, 0x0205011e, 0x82050110, 0x01042221, 0x26e38211, 0x020f0102, 0x82070b02, 0x02012113,
	0x072b8b83, 0x06061a01, 0x0302070c, 0x820f0201, 0x020626e0, 0x0301020e, 0x280b8203, 0x07050502, 0x0908011a, 0x080f821e, 0x0d070221, 0x08030906,
	0x10221002, 0x1c386e37, 0x0a041d39, 0x07150a04, 0x01010c03, 0x0e0e0301, 0x82050c05, 0x0a092c36, 0x2baefd02, 0x2b565556, 0x82203f20, 0x04270843,
	0x25120409, 0x3f7e3f12, 0x06183018, 0x0107060d, 0x0f557cfe, 0x0d0b150b, 0x1b07050d, 0x0a170a0b, 0xa3fd4e16, 0x82160707, 0x0c3008d1, 0x0f06080c,
	0x0b290e08, 0x0e075afe, 0x01060107, 0x0c050201, 0x25110e1b, 0x12231111, 0x02041812, 0x03050304, 0x1223120f, 0x031d381c, 0x1538121b, 0x04202582,
	0x08067e45, 0x0b1d0c39, 0x02010409, 0x0a0c0406, 0x0e020808, 0x03021107, 0x09010102, 0x03070403, 0x270e2b07, 0x2412274d, 0x070f0712, 0x0301080a,
	0x1b121a07, 0x28522812, 0x06023706, 0x8201031d, 0x03023c00, 0x07100703, 0x05060e07, 0x11221102, 0x03041f05, 0x050a0302, 0x25274e28, 0x820b254a,
	0x0103211f, 0x05334d83, 0x070e0806, 0x23172e17, 0x120a2244, 0x06110a09, 0x82032605, 0x02012229, 0x08988309, 0x05090b43, 0x1204081a, 0x01020803,
	0x12090404, 0x11240e09, 0x05071608, 0x12080302, 0x0a210309, 0x250f1f11, 0x310d2448, 0x04100c08, 0x03050906, 0x22110812, 0x1d1d0e12, 0x02060f1d,
	0x254f251b, 0x1b274d26, 0x286a8207, 0x05030b01, 0x0b0b0c0c, 0x26718204, 0x0b051403, 0x82020220, 0x010224c7, 0x82040103, 0x0a082f08, 0x020b160b,
	0x13020305, 0x0d030302, 0x15820202, 0x02010929, 0x040a0a04, 0x820d0102, 0x03012327, 0x26820607, 0x07070e2d, 0x06080301, 0x02010e04, 0x83060302,
	0x82022056, 0x2a03822c, 0x04020708, 0x02030109, 0x83160d02, 0x18043d15, 0x040a0308, 0x0d050d06, 0x0c020413, 0x0c1b0a02, 0x07060d27, 0x021c92fe,
	0x120f0b0e, 0x23234f83, 0x821d1088, 0x091b266a, 0x0a020508, 0x379f8246, 0x06264b26, 0x05080418, 0x050e0303, 0x0a080f06, 0x11091813, 0x020b0e08,
	0x08224782, 0x4b48030b, 0x0a403305, 0x0144032d, 0x014a0127, 0x01000075, 0x2627011e, 0xe8471716, 0x37262206, 0x430e823e, 0xdf6306d4, 0x0bf55d05,
	0x06262724, 0x964b2207, 0x010e2107, 0x63088d45, 0x118506fd, 0x86010e21, 0x012a2132, 0x8506d461, 0x22062117, 0x23222f82, 0x14820622, 0x832a2721,
	0x3627223b, 0x21418526, 0x29842e23, 0x250a7c79, 0x15011c15, 0x80821614, 0x92820582, 0x033e3725, 0x53163637, 0x1724085c, 0x3233011e, 0x595ca484,
	0x05295c08, 0x4b361621, 0x3e2106a2, 0x05114901, 0x36243b83, 0x26363734, 0x37223e85, 0x11823214, 0x83263521, 0x3a332526, 0x16323303, 0x2505fa57,
	0x37163633, 0x17823436, 0x2406c245, 0x36273634, 0x053e4516, 0x05231183, 0x8307030e, 0x37262360, 0x30822606, 0x82069645, 0x25d8823f, 0x0523013a,
	0xd0822606, 0x2722d982, 0x6a86012e, 0x4f011e21, 0x1184051a, 0x36204982, 0xca828e82, 0x0a07ce08, 0x03020125, 0x09010203, 0x1b0d0b2c, 0x01110b0e,
	0x02040101, 0x05020104, 0x0c3a0604, 0x0401060a, 0x3a1e1528, 0x3a743a1d, 0x03052008, 0x19050408, 0x06120807, 0x0613010a, 0x0703080d, 0x04010303,
	0x0206230c, 0x11060511, 0x0a0c0c08, 0x02030c04, 0x0804030f, 0x0c1a0d05, 0x33193219, 0x34173365, 0x0e1d1317, 0x120f150a, 0x10071019, 0x0c170c09,
	0x221b361b, 0x1b0d2244, 0x0414060d, 0x08080709, 0x3515080d, 0x376e3716, 0x040a2914, 0x05070502, 0x050e0503, 0x880c1709, 0xdcb20406, 0x461e14c2,
	0x090a1a1b, 0x120f100a, 0x44151611, 0x071b0c21, 0x090d0106, 0x0d060406, 0x060c0505, 0x0a080903, 0x2b09050c, 0x1224130b, 0x070d2110, 0x2c508211,
	0x071f0301, 0x04030104, 0x09080603, 0x08ce8307, 0x061e1166, 0x08010406, 0x3062310c, 0x63646332, 0x14281332, 0x0f0e1c0d, 0x200e1101, 0x01020c0e,
	0x05020305, 0x120f0605, 0x2a081228, 0x05030705, 0x11f4f808, 0x11b9d7b9, 0x02010702, 0x030e0206, 0x05020101, 0x2141200f, 0x7d7d7d3e, 0x0506043e,
	0x02020101, 0x0f410998, 0x0c101f10, 0x0202041c, 0x08020403, 0x03020809, 0x4a086d82, 0x11080a13, 0x1a210a0b, 0x060f1e0f, 0x0303042d, 0x82020404,
	0x03040202, 0x04090102, 0x28130e01, 0x0a150a12, 0x100a130b, 0x2e020209, 0x03011c07, 0x05090507, 0x01010405, 0x0e1d0907, 0x01030904, 0x06020202,
	0x0c0a0401, 0x82050b06, 0x081737b1, 0x03050803, 0x0e030401, 0x23040404, 0x01180a0d, 0x05081b01, 0x91820201, 0x0101012b, 0x0d040309, 0x030b0404,
	0x083f8209, 0x0a170446, 0x20070b19, 0x0a060605, 0x0c0a130a, 0x1f050c19, 0x0f400703, 0x060b2411, 0x39010328, 0x08053d45, 0x3b111203, 0x17361b17,
	0x1d1c461c, 0x080b030d, 0x200a0425, 0x1120100d, 0x0a112312, 0x14060616, 0x02040905, 0x053da682, 0x17010109, 0x08060a06, 0x07060c06, 0x220a070f,
	0x04230508, 0x0b0a3307, 0x06060101, 0x8376820c, 0x172308a3, 0x04050501, 0x27130b1d, 0x07130813, 0x09010e04, 0x0205021c, 0x1b090705, 0x09200a0b,
	0x453b059d, 0x8203073d, 0x08d982f5, 0x14092145, 0x40071426, 0x7a010702, 0x03010413, 0x0816080e, 0x08071a0a, 0x180d0907, 0x020c0809, 0x07080d02,
	0x01010236, 0x1b060504, 0x081b0906, 0x61000400, 0x9e052600, 0x02015a03, 0x18010b01, 0x00002d01, 0x42063401, 0x272705c7, 0x34352636, 0x4b362336,
	0x232306ed, 0x48230626, 0x2222050d, 0x4b790706, 0x07302c08, 0x010e2306, 0x17140607, 0x4c23012a, 0x1620097b, 0x2105bd43, 0x214c3233, 0x24488206,
	0x17160637, 0x1c4b1816, 0x820b820a, 0x077e431d, 0x5c161721, 0x1522061c, 0x02821614, 0x69561720, 0x85058405, 0x3233220e, 0x234d8316, 0x26271636,
	0x2005f349, 0x0bc24934, 0xab843720, 0x013c3522, 0x6e827185, 0x27240282, 0x3a333236, 0x8c851182, 0x82070621, 0x011e2180, 0x3c212983, 0x4c1d8201,
	0x1627067e, 0x2f343536, 0x85013e01, 0x201d8329, 0x821e8205, 0x14162402, 0x53012e05, 0x222306c9, 0x82372726, 0x830e20e5, 0x217682e2, 0x8b833635,
	0x16076008, 0x19980506, 0x084f0d07, 0x03030603, 0x050c0108, 0x1f0e090d, 0x0f0c0b0b, 0x480d1b0c, 0x48919091, 0x13316231, 0x04050816, 0x06050605,
	0x03070d0c, 0x05010102, 0x0e050301, 0x03090d1a, 0x03180507, 0x01010504, 0x191f0401, 0x08050916, 0x080f0305, 0x040a0106, 0x12081307, 0x24081225,
	0x82040308, 0x10062f29, 0x0a061020, 0x04020404, 0x07020102, 0x2f820e0d, 0x0802023b, 0x0409040c, 0x0a070501, 0x0f130606, 0x0b0a1309, 0x33090912,
	0x04040306, 0x25258201, 0x02030101, 0x02830403, 0x0f042208, 0x020c0707, 0x172f1709, 0x0414301a, 0x04080304, 0x10244824, 0x0302010d, 0x3c0d2606,
	0x0a040406, 0x36398207, 0x09041102, 0x0202020a, 0x20110114, 0x051b0910, 0xd9fa0606, 0x6f640203, 0x35080573, 0x0f050603, 0x037c0402, 0x12050303,
	0x06020c0a, 0x32011603, 0x041f0709, 0xc3020702, 0x0b06020b, 0x08010401, 0x0d060810, 0x07051a0c, 0x11090805, 0x10110201, 0x60820504, 0x08072608,
	0x05030504, 0x060d0603, 0x07080107, 0x06070708, 0x773b060c, 0x161d183b, 0x0a160b14, 0x08081c08, 0x1305042b, 0x25d78202, 0x02090204, 0xb5830502,
	0x0a022408, 0x010a0304, 0x0c052f03, 0x1d0f0d1c, 0x0e1f0e10, 0x03021506, 0x38200d05, 0x0710071e, 0x0d070d08, 0x820d0a24, 0x01022683, 0x11060d02,
	0x05704707, 0x04060331, 0x0f070f06, 0x42180f1c, 0x1e3b1c18, 0x820f1d10, 0x012d0834, 0x09200702, 0x0f07060c, 0x10010108, 0x1e0f1d0f, 0x47201e3b,
	0x1215050c, 0x3c0c230c, 0x090b3b76, 0x12100704, 0x07021404, 0x0702090e, 0x34b08207, 0x0a2a0909, 0x0913092b, 0x0a030803, 0x0904671f, 0x04070404,
	0x2a978203, 0x0c04110a, 0x08010804, 0x82210306, 0x0320081a, 0x0008060d, 0x00040000, 0x073e004f, 0x014303d5, 0x01150108, 0x002b0128, 0x013e0100,
	0x33163627, 0x4507a06a, 0x332205f8, 0x08821632, 0x06141529, 0x27061615, 0x5f23012a, 0x142a0504, 0x012a2306, 0x27012e27, 0x14590626, 0x05de4205,
	0x6f08fc4c, 0x34200ac3, 0x2205f55e, 0x82012e35, 0x200b8608, 0x07876834, 0x07010e25, 0x5a272606, 0x5382057a, 0x68162221, 0x30250682, 0x34273437,
	0x294c1836, 0x5a362007, 0x3e210c15, 0x05516101, 0x06222325, 0x82260623, 0xb14c1830, 0x242f8208, 0x33262227, 0x829c8326, 0x2223229f, 0x829c8216,
	0x2202838a, 0x43072206, 0x05820511, 0x33163424, 0xe784011e, 0x3a370125, 0x50323701, 0x37220642, 0x68831636, 0xd6820120, 0x82010e21, 0x821720ca,
	0x2e372208, 0x213d8301, 0x46181614, 0x580809df, 0x03162601, 0x01020294, 0x2d151518, 0x8b452d5b, 0x0b468b8b, 0x09090744, 0x0f320908, 0x0b132c14,
	0x02010103, 0x18301811, 0x020b150b, 0x11030101, 0x08080a0f, 0x32030910, 0x050e0702, 0x05030905, 0x230d1916, 0x0915090f, 0x0f051907, 0x09030508,
	0x02060103, 0x03020302, 0x3c2d8204, 0x1c150e02, 0x0e09161b, 0x0f170d0a, 0x20193c22, 0x0405030d, 0x3f050103, 0x1c381c0d, 0x2b008201, 0x0e041002,
	0x01040514, 0x07010903, 0x01232e82, 0x82030b04, 0x04012f9e, 0x060e0304, 0x17336633, 0x130a133e, 0x50820616, 0x23830120, 0x3e038608, 0x773c3d7b,
	0x0704103b, 0x02060302, 0x04020601, 0x010d0f14, 0x4822471f, 0x55294890, 0x0d1b0d2a, 0x06060107, 0x04069709, 0x100dd601, 0x061d0502, 0x0314240e,
	0x117a0305, 0x0c13182d, 0x05070801, 0x110a0907, 0x0b141008, 0x02011cfe, 0x04023503, 0x06250305, 0x1229110d, 0x02040a13, 0x0f0b0701, 0x070b0f36,
	0x18301901, 0x11030a03, 0x1e0f0e08, 0x0b03060f, 0x12112211, 0x23101121, 0x10200f0f, 0x080d6315, 0x82a88305, 0x062c08ae, 0x11090d0a, 0x04080309,
	0x07050506, 0x20100714, 0x08110711, 0x12081008, 0x25131221, 0x0a300604, 0x07050e05, 0x0104020b, 0x46843b18, 0x04282982, 0x0a030e09, 0x01070604,
	0x4283b882, 0x250f0f37, 0x1e432110, 0x04040904, 0x10090408, 0x12211108, 0x05090e0a, 0x261f821a, 0x0812050a, 0x82102011, 0x0608255b, 0x04010106,
	0x73083382, 0x2e150a1c, 0x1f3f2016, 0x10060e07, 0x366c3602, 0x061f3e1f, 0x0705060c, 0x01010105, 0x11080703, 0x0b2c0d09, 0x0a081015, 0x7afe0803,
	0x0412210d, 0x120e051f, 0x02050302, 0x04171135, 0x0e140403, 0x09070d1d, 0x04070102, 0xfe0e190a, 0x00060592, 0x00620005, 0x03df073f, 0x001e0048,
	0x005a003c, 0x005e0173, 0x16060100, 0x33011c17, 0x3233013a, 0x06141536, 0x45052342, 0x072605d1, 0x0507010e, 0x44182634, 0x804f0806, 0x14172108,
	0x21064068, 0x1d893601, 0x45852720, 0x220a5a52, 0x83012a37, 0x16322151, 0x152f3882, 0x1617011e, 0x013c3532, 0x27363435, 0x43011e05, 0xab460624,
	0x06222205, 0x201e8307, 0x22278206, 0x4a011c07, 0x99430599, 0x22072205, 0x51471806, 0x21268209, 0x7d620622, 0x2627230b, 0x14822706, 0x210bfc4a,
	0x63823626, 0x4a089046, 0xc08405f3, 0x22230322, 0x34221a84, 0x724a2726, 0x3a33230d, 0x87563303, 0x013e2405, 0x46343637, 0xea59058d, 0x4fbd8205,
	0x3221096e, 0x221a8236, 0x82063435, 0x25c3823e, 0x17363237, 0x32441416, 0x055f4405, 0x8905145e, 0x05910832, 0x0101085e, 0x070f0701, 0x03010e02,
	0x1a171a13, 0x1d090d12, 0x0e08070b, 0xfe0c2310, 0x16110df4, 0x150b162b, 0x040b030b, 0x06040e06, 0x0406040f, 0x18100c01, 0x541b1928, 0x17062602,
	0x0d190c04, 0x271b351a, 0x0601274f, 0x3c1e060e, 0x2142201e, 0x090b150a, 0x080a2c01, 0x0a050601, 0x01080302, 0x0d010102, 0x2c010c05, 0x0d16060d,
	0x2a150e1f, 0x050a0516, 0x02020203, 0x10070108, 0x02040303, 0x03020402, 0x11090d03, 0x0103052e, 0x083c0205, 0x2f878206, 0x1c1f0301, 0x0d204019,
	0x10060e1a, 0x01100a07, 0x03221882, 0x05820306, 0x32075608, 0x060a0b10, 0x2f071105, 0x4c253d72, 0x0c180c25, 0x0a07010b, 0x31180a14, 0x04090418,
	0x05012103, 0x1d0f0c11, 0x5e5e2f0f, 0x01202f5e, 0x01020201, 0x1f0f0c0e, 0x6869340f, 0x31173468, 0x1e371d17, 0x5a5a5a2d, 0x0303052d, 0x04070f08,
	0x030c0b0a, 0x04092004, 0x31008201, 0x0f040205, 0x6a35101e, 0x0d1a0d35, 0x0b051205, 0xb882050e, 0x06090a23, 0x821b8218, 0x0b2e082d, 0x09060908,
	0x1b0d0812, 0x190c0502, 0x1b341b0c, 0x240c6001, 0x010e010f, 0x01120302, 0x0a081506, 0x1210192c, 0x02070a0e, 0x230e0602, 0xdf822a0e, 0x04114e08,
	0x08060c06, 0x20130818, 0x0a0b120b, 0x40012e0a, 0x02060509, 0x1b041f03, 0x0106050b, 0x0c070707, 0x0b170c07, 0x150b0305, 0x07330b0a, 0x05470b79,
	0x06070203, 0x0b130802, 0x13081608, 0x15081326, 0x04020908, 0x12251216, 0x1701020b, 0x24ea8205, 0x14164123, 0x3bd28215, 0x03030102, 0x0710080c,
	0x060d190d, 0x0311060f, 0x060a0501, 0x4224050d, 0x03030202, 0x01231e82, 0x82080b0e, 0x03083acd, 0x01091309, 0x09020305, 0x26145915, 0x532a254b,
	0x03061229, 0x2e040504, 0x085d8206, 0x050f0b38, 0x0e0b1b05, 0x14081415, 0x04090409, 0x04040402, 0x06030e15, 0x050a0d06, 0x040c0304, 0x04011007,
	0x0a140a0a, 0x0c0a0f0a, 0x09060106, 0x1c0d0a13, 0x18311814, 0x0f4e1204, 0x0b252f05, 0x015a039f, 0x01490139, 0x01000055, 0x566b0632, 0x432a2006,
	0x2e680615, 0x16222106, 0x21099d46, 0x094e012e, 0x6a118205, 0x14250618, 0x06222322, 0x85328407, 0x0e352126, 0x14203e84, 0x53067949, 0x81530687,
	0x4e118411, 0xee430848, 0x22148706, 0x43061415, 0xe5590657, 0x860e8507, 0x203b8b74, 0x09124a26, 0x8a473320, 0x22058205, 0x7b371632, 0x75530d53,
	0x06537b05, 0x83361421, 0x05964a08, 0xd4822c82, 0x45530582, 0x2e418805, 0x34353426, 0x013e3726, 0x37013e33, 0x57150632, 0x06200651, 0x21058443,
	0x41821617, 0x1d823220, 0x22051723, 0x4ee18206, 0x23240531, 0x2523012a, 0x8205a356, 0x1e600809, 0x108f0b01, 0x0d060804, 0x49240e1c, 0x2a552a25,
	0x0d112312, 0x0b060c18, 0x03020906, 0x0b102906, 0x16030914, 0x0b130b04, 0x0b285228, 0x06010202, 0x01020805, 0x1a010201, 0x2c592d02, 0x0a285529,
	0x1d070a15, 0x1c010d07, 0x0e061b37, 0x04010407, 0x08020206, 0x13210d05, 0x280e130a, 0x0e042650, 0x54083082, 0x050e0803, 0x16060d06, 0x11081222,
	0x05070507, 0x160c200a, 0x0a061426, 0x050b0405, 0x04030707, 0x09050408, 0x03040201, 0x0c1a0e09, 0x09132714, 0x1f10030a, 0x0c0e050d, 0x03060c06,
	0x4d27051b, 0x2b572b26, 0x1a317342, 0x0b061735, 0x030b1007, 0x03020105, 0x082f8202, 0x2d09049e, 0x351b371b, 0x356b6a6b, 0x050b180b, 0x080c0408,
	0x1427140d, 0x0b090f0b, 0x06030106, 0x080c0a1f, 0x0c0e0d0a, 0x04050609, 0x11074702, 0x1a0d1124, 0x366d360d, 0x010a120a, 0x160a0303, 0x0a0c100b,
	0x27050e05, 0x7038274e, 0x1d387070, 0x06011d3a, 0x060b0203, 0x090c170b, 0x041e0a02, 0x4f12250e, 0x2f174e9c, 0x0a480f17, 0x0717b8f8, 0x0c14090b,
	0x0605490a, 0x29151d04, 0x055dfc15, 0x7e3a0607, 0x44874540, 0xd5020301, 0x01070b49, 0x01020101, 0x0f080601, 0x1305071a, 0x02040308, 0x042ca782,
	0x0a0b0204, 0x03010404, 0x0a130909, 0x05212082, 0x27228202, 0x42030209, 0x0609060b, 0x15390f82, 0x0d250d02, 0x33132614, 0x35193162, 0x14290e17,
	0x06020802, 0x2110070e, 0x38c78210, 0x04448943, 0x07030407, 0x01030602, 0x030a0a02, 0x04040407, 0x07180303, 0x08b9820b, 0x15112030, 0x0d07162b,
	0x060c0402, 0x04091509, 0x4e260612, 0x0d260e27, 0x04070d07, 0x02020101, 0x02020402, 0x2c142849, 0x04110617, 0x120c1a08, 0x4f821125, 0x21080282,
	0x01014d1c, 0x0505031c, 0x08080407, 0x170d1309, 0x080d012a, 0x02010209, 0x14080a05, 0x01060309, 0x9f820801, 0x070f083f, 0x0102050c, 0x05050905,
	0x1a05050f, 0x0e020201, 0x0d1a0d08, 0x01030704, 0x13040303, 0x20ea8202, 0x08268204, 0x0f030339, 0x0e30a20f, 0x0e040108, 0x24022914, 0x5e332449,
	0x00170b2e, 0x00020000, 0x0840005a, 0x004103a7, 0x00db00c4, 0x16170100, 0x06221706, 0x23260623, 0x2223012a, 0x43270706, 0x4347051e, 0x16142109,
	0x2a06be56, 0x15140607, 0x1e07010e, 0x82011f01, 0x17152223, 0x06f25622, 0x012e2722, 0x4a062360, 0x232c0a62, 0x1e151614, 0x010e0701, 0x27032e23,
	0x08823582, 0x2e230582, 0x84012f01, 0x05894306, 0x81513720, 0x33352105, 0x17202a82, 0x32220b82, 0x1285021e, 0x013e3524, 0x02821e17, 0x05840320,
	0x36330123, 0x06e54a16, 0x15270884, 0x3233013a, 0x823e3716, 0x25152988, 0x1d062221, 0x33161401, 0x20059051, 0x08938336, 0x9f082320, 0x01090206,
	0x14183018, 0x43221426, 0x17291822, 0x0c04050a, 0x1522140d, 0x29295129, 0x16822952, 0x120d013f, 0x25121536, 0x0a0d1411, 0x0101050b, 0x0d060601,
	0x2511040a, 0x070f0811, 0x09030704, 0x08038207, 0x250b1145, 0x18090902, 0x26181728, 0x1b120b0e, 0x01060204, 0x02305827, 0x01030405, 0x011e3c1e,
	0x1d0d0903, 0x0407040c, 0x386a3202, 0x0f020401, 0x03020515, 0x08120914, 0xd0050c05, 0x140b1409, 0x50291120, 0x82285150, 0x0250084d, 0x1a481309,
	0x2e224422, 0x2d5b5a5a, 0x2a2b552b, 0x08042b55, 0x02031404, 0x0f020801, 0x01010e1d, 0x13162b16, 0x5027132a, 0xeefd0828, 0x12133ffd, 0xa2511213,
	0x0f52a2a2, 0x010e0b38, 0x090d040d, 0x0a144a02, 0x01050a14, 0x07011109, 0x07122215, 0x1627ae82, 0x070c1230, 0x82050202, 0x226808b6, 0x0916040e,
	0x09040a04, 0x06151d10, 0x0601030a, 0x02020103, 0x25050d04, 0x23172252, 0x050a0519, 0x08090204, 0x2c12141f, 0x1d183018, 0x151c1d3c, 0x5554552a,
	0x070c052a, 0x09031b07, 0x04080501, 0x030f1a0a, 0x2c010302, 0x56202f5a, 0x0c150c1c, 0x06081008, 0x0c180d06, 0x040e1709, 0x0b050104, 0x19090c17,
	0x0108120a, 0x01255682, 0x01030303, 0x27028401, 0x45160706, 0x1426131c, 0x02206f82, 0x0521fa82, 0x0874820b, 0x1499052e, 0x13122313, 0x430b0e03,
	0x0006050b, 0x00640003, 0x03420a21, 0x00180060, 0x0091012b, 0x26340100, 0x17162223, 0x2e272606, 0x010e2701, 0x2306f544, 0x0137013e, 0x2e051b4c,
	0x34372632, 0x26223736, 0x07010e07, 0x42012e17, 0x2e820692, 0x23062623, 0x06d75922, 0x20074a50, 0x05564226, 0x55453520, 0x07162106, 0x220a087d,
	0x7d232207, 0x6d820c38, 0x61590282, 0x54352007, 0x69840864, 0x06262722, 0x60422c82, 0x82788206, 0x06162697, 0x2e010e23, 0x09ae5901, 0x27062623,
	0x82988326, 0x2a3321b7, 0x2d439784, 0x212e8405, 0x40832223, 0x3620ac84, 0x8209b454, 0x0ae749b5, 0x20072f4d, 0x46538226, 0x17220862, 0x0b843216,
	0xcf490120, 0x20058505, 0x07dd4237, 0x26363722, 0xa5497482, 0x33162607, 0x34353432, 0x232f8216, 0x011d1415, 0x2505b44a, 0x16171632, 0x6c543736,
	0x05875005, 0x36211786, 0x704e1817, 0x013a2108, 0x21081f6d, 0x44513233, 0x15162305, 0xad830614, 0x4d052008, 0x0e0d1840, 0x03130702, 0x12010207,
	0x1f090c0f, 0x0e1d0e11, 0x03030814, 0x050301b7, 0x820d1a0d, 0x015d0816, 0x07210801, 0x8b040b06, 0x05010801, 0x080e060c, 0x04140708, 0x03081b08,
	0x07100b1f, 0x6b360711, 0x1e356b6b, 0x15131d3b, 0x02060309, 0x050b0902, 0x0101010a, 0x0c1b0603, 0x01060801, 0x130a0202, 0x1c381c09, 0x02072708,
	0x07030102, 0x01110c04, 0x0b010304, 0x05010203, 0x180d0709, 0x086e820c, 0x0613075a, 0x0809070a, 0x09070415, 0x06050206, 0x0d051207, 0x05060911,
	0x0d070806, 0x273e410b, 0x2243210e, 0x08040a04, 0x1f0c0e08, 0x0202080a, 0x03040905, 0x10080103, 0x1d3a1e07, 0x08091409, 0x280d0502, 0x0a08040b,
	0x05090811, 0x1b0e0b05, 0x07080a0e, 0x13051e06, 0x0f081326, 0x013a4182, 0x0b274e27, 0x2b050420, 0x02030c0e, 0x10220804, 0x352a542a, 0x35696969,
	0x4b821009, 0x0d082308, 0x351b0d19, 0x06050b1a, 0x070d130b, 0x17060507, 0x0a140a09, 0x04041c05, 0x1c030113, 0x15230805, 0xa9820610, 0x05061f38,
	0x2a532905, 0x092e5c2e, 0x0a030509, 0x050e0404, 0x01010a04, 0xd1820505, 0xa04f0a09, 0x2a522950, 0x0c0c3012, 0x0b040d19, 0x0b150b07, 0x041c060a,
	0x19070807, 0x34161a32, 0x4120151d, 0x24a00120, 0x04073801, 0x15080418, 0x151e0c0a, 0x01010312, 0x010f1d03, 0x181c043d, 0x0b160b06, 0x1f040404,
	0x06018107, 0x12090b09, 0x01040401, 0x07101202, 0x13030102, 0x01050905, 0x11080104, 0x1a341a09, 0x0a050907, 0x2b150d15, 0x26502714, 0x01070204,
	0x09030603, 0x10020912, 0x0517040b, 0x2c0d1a0d, 0x19062e5d, 0x01020203, 0x05020b01, 0x0402020b, 0x190d0f0d, 0x0e0c0b06, 0x03030805, 0x28100607,
	0x0c0d0c12, 0x0201090e, 0x3a181607, 0x10083a73, 0x092c0d08, 0x0b0e0b07, 0x02030b35, 0x07140701, 0x09151813, 0x0b0e0512, 0x03031305, 0x050f1c0f,
	0x0709050c, 0x1932190e, 0x160e1107, 0x180b0c01, 0x172f1710, 0x0c397139, 0x07120b1f, 0x0305080c, 0x05190104, 0x03010406, 0x08140705, 0x160b0c0d,
	0x1b070920, 0x2b88820f, 0x0a050105, 0x02040207, 0x070b0a0a, 0x91827b82, 0x05050434, 0x21111103, 0x01100511, 0x0d090303, 0x31190d19, 0xa6820318,
	0x1b205d08, 0x0700000a, 0x26005b00, 0x5a032d0d, 0xc500ba00, 0xdc00ca00, 0xee00e700, 0x00001101, 0x3f272501, 0x0f352701, 0x15172701, 0x23152707,
	0x27353335, 0x012f030f, 0x0f232737, 0x05072302, 0x2707012f, 0x020f1707, 0x0f062227, 0x011f1502, 0x011e1507, 0x2307031f, 0x07032f35, 0x23072327,
	0x17251683, 0x0f010e07, 0x301b8204, 0x013f1327, 0x0715032f, 0x0f23022f, 0x17071501, 0x214f8223, 0x4e833507, 0x1f331324, 0x02820501, 0x3533272c,
	0x35371737, 0x033f1733, 0x47820533, 0x17013f34, 0x3f353735, 0x15170501, 0x3f33031f, 0x17013e02, 0x4982011e, 0x83331721, 0x21352125, 0x25209482,
	0x173a6982, 0x23353733, 0x23373307, 0x21272515, 0x2517030f, 0x013e013f, 0x2f263435, 0xa7820501, 0x33203082, 0x01257882, 0x022f3315, 0x50108207,
	0x458205d2, 0x012e2727, 0x3f362635, 0x24108201, 0x1f161417, 0x207c8201, 0x08338236, 0xfd290d6a, 0x010c01a7, 0x8b1050c1, 0x171e071c, 0x03025606,
	0x05070603, 0x02110201, 0x08090505, 0x0c091bfe, 0x02180318, 0x030c0402, 0x06010403, 0x11010802, 0x1d050601, 0x06c60511, 0x030a1e15, 0x297b130e,
	0x03070506, 0x040f1d08, 0x0a050904, 0x07013902, 0xa6b90505, 0x0f090304, 0x020b2a10, 0x20840121, 0x4c026d7d, 0x019c7c25, 0x41081982, 0x058b0302,
	0x04670104, 0x01220102, 0x23010c22, 0x04580222, 0x01080d0b, 0x0d160db5, 0x02090306, 0x0603091b, 0x0e05e601, 0x11030402, 0x04085001, 0x0e0a0408,
	0x02020405, 0xc14f128b, 0x04054c02, 0x9a82e9fb, 0x2f1f5708, 0x0c075907, 0x58045453, 0xfe046efd, 0x050c0f88, 0xa3010815, 0x08070b05, 0xfa0b0707,
	0x056105ac, 0x63040504, 0x6f040403, 0x0504027d, 0x0ab60472, 0x06050c32, 0x0c050401, 0x09091105, 0x05030301, 0x020b0c16, 0x76100809, 0x0401030a,
	0x012d0217, 0x03090118, 0x01820105, 0x08183408, 0x05280b02, 0x04140702, 0x12030403, 0x04051d08, 0x03050411, 0x15022109, 0x01040702, 0x05080302,
	0x07090270, 0x152c1729, 0x37073666, 0x4f754506, 0x82030322, 0x3708229f, 0x084a8211, 0x04080242, 0x030b0a6f, 0x21012b0c, 0x1018170c, 0x02050108,
	0x180c0248, 0x44020b03, 0x3f4e1b1c, 0x05041a47, 0x5d010405, 0x03041205, 0x090c0107, 0x0f020901, 0x08058c02, 0x0d023006, 0x01550c17, 0x02090526,
	0x3708f882, 0x010e0a08, 0x33200501, 0x03030771, 0x05080101, 0x0694040a, 0x06240501, 0x07b2077c, 0x4a030d11, 0x4d1f0805, 0x02810d0d, 0x33070c06,
	0x05010308, 0x090c1106, 0xf4070610, 0x21082b82, 0x07040307, 0x090e9a07, 0xfa020205, 0x0f090c04, 0x080e0708, 0x080d040a, 0x0e060911, 0x08080c08,
	0x13820f17, 0x0f0b2b08, 0x0b150910, 0x02000015, 0xf2ff5300, 0x8d03fc08, 0x28011e00, 0x07010000, 0x1715010e, 0x0727010f, 0x0e020f23, 0x011e1701,
	0xcf453317, 0x26362d05, 0x17252327, 0x011f3337, 0x2f23010f, 0x272b0483, 0x0e232723, 0x2f012b01, 0x82070501, 0x2307280a, 0x07061407, 0x831e011f,
	0x011f2243, 0x223a8215, 0x820f0616, 0x3634281d, 0x013e013f, 0x8226022f, 0x82272007, 0x010f285f, 0x030f010e, 0x822f2622, 0x42198315, 0x272006ba,
	0x1e841783, 0x2506845a, 0x06020f06, 0xae493726, 0x022f2105, 0x82095661, 0x1f01213d, 0x2305e077, 0x2622012b, 0x2f212082, 0x05d74201, 0x013e022c,
	0x3f352533, 0x23351702, 0xa4820616, 0x23072322, 0x34241882, 0x17333736, 0x333a6483, 0x37151632, 0x15173735, 0x1733013f, 0x15333533, 0x15071533,
	0x17233523, 0x50821e33, 0x14831084, 0x1723038b, 0x84211715, 0x3776082d, 0x013e3717, 0x0417013b, 0x0404078b, 0x0e160503, 0x06081b06, 0x04010537,
	0x4b060903, 0x080b2015, 0x08032f36, 0x13045e0a, 0x05370f0e, 0x31070505, 0x060e0a0a, 0x0431051f, 0x04050118, 0xfe03092d, 0x060811be, 0x09430507,
	0x12080707, 0x03010809, 0x01010202, 0x08020c0d, 0x1c312a0a, 0x050f0402, 0x09080102, 0x140a0902, 0x2b106153, 0x170c471a, 0x4e6e400b, 0x25820705,
	0x05063a08, 0x030c0815, 0x0e080817, 0x10443e0e, 0x0f050213, 0x1103030b, 0x1328160f, 0x52090208, 0x01050752, 0x0a190e19, 0x05040f0a, 0x05023221,
	0x01050404, 0x1f1a280e, 0x0c080322, 0x3a0d820d, 0x0682080b, 0x0b07060c, 0x0e0c2304, 0x0e020201, 0x07150d24, 0x1b12bb02, 0x82112a1f, 0x020e2470,
	0x820e0527, 0x0a0426ae, 0x02022607, 0x08008207, 0x17150b53, 0x10226a58, 0x16160d0f, 0x0e09370c, 0x05010808, 0x10261124, 0x0f271026, 0x4e1e1027,
	0x06590114, 0x140a2909, 0x02012b0a, 0x071c0304, 0x0505f901, 0x0617060b, 0x020e0101, 0x120a6407, 0x02080608, 0x07080b02, 0x16054d53, 0x0701b210,
	0x0a191a0a, 0x2a778203, 0x03040403, 0x12080203, 0x82440606, 0x08238221, 0x13050724, 0x3a33091b, 0x04132511, 0x09070408, 0x142d1907, 0x06140d37,
	0x0a05131c, 0x04040a06, 0x6b252f0b, 0x5a821811, 0x03014108, 0x22181704, 0x120f270b, 0x190a1402, 0x0313100e, 0x05010502, 0x040b0605, 0x32511e28,
	0x0a18674f, 0x1c1d050f, 0x36161402, 0x2b2b4f25, 0x023d2752, 0x05030228, 0x05010405, 0x22151217, 0x130d1b0b, 0x2b08fb82, 0x05050404, 0x900b1107,
	0x0d0e493c, 0x1d150714, 0x080f0908, 0x0105120d, 0x05060639, 0x19070607, 0x02121111, 0x04070205, 0x01060703, 0x0e2f6082, 0x060c0c0d, 0x05016d04,
	0x04010d07, 0x88041503, 0x1a273900, 0x0905040b, 0x02040206, 0x00000202, 0x53000300, 0x100a0d00, 0xee017503, 0x11281282, 0x36010000, 0x013e3726,
	0x2e05c15d, 0x17163427, 0x26353616, 0x36323336, 0x18061615, 0x6309ae62, 0x16210530, 0x28178232, 0x15163437, 0x36371416, 0x05314a06, 0x15211182,
	0x202f8214, 0x57448516, 0x32280999, 0x16343516, 0x35013c35, 0x32223b83, 0x955d1615, 0x17322505, 0x1407011e, 0x17225983, 0x14830616, 0x23011e2a,
	0x3023012a, 0x32150607, 0x07272183, 0x14152606, 0x85013a16, 0x089c5368, 0x142a2c83, 0x26062316, 0x07262223, 0x6d4d3606, 0x14062109, 0x07253182,
	0x22071606, 0x05364326, 0x2634272b, 0x27342207, 0x26230626, 0x21178306, 0x32821606, 0x864a0283, 0x213e8305, 0x2a4b2726, 0x06e15706, 0x8f871720,
	0x06222323, 0x05c74315, 0xe685058a, 0x44820582, 0x0cbe5e18, 0x07222622, 0x1a825384, 0x180ac257, 0x82094b48, 0x2223252c, 0x22262327, 0x82050441,
	0x825c828c, 0x82272032, 0x010e2483, 0x83221415, 0x010e246e, 0x82062207, 0x05c15159, 0x27224a82, 0xee6d3626, 0x20441805, 0x20478208, 0x05904b35,
	0x37362628, 0x36372634, 0x37511716, 0x06d94d09, 0x013e3725, 0x58323637, 0x32240631, 0x36342734, 0x71823282, 0x37215982, 0x235f8234, 0x34060716,
	0x13213b83, 0x210c8326, 0xd84a1417, 0x84262005, 0x27262936, 0x15062607, 0x34331614, 0x5508bb84, 0x03093603, 0x04160204, 0x060e0e09, 0x02100112,
	0x0a010704, 0x01160309, 0x1b090302, 0x101f100b, 0x03010f02, 0x04130402, 0x0f0a150a, 0x01110102, 0x01030609, 0x02050d03, 0x20030a1c, 0x31180a1b,
	0x07100718, 0x3c0e080b, 0x62313c77, 0x15316263, 0x13031429, 0x1f820409, 0x02080133, 0x03050202, 0x04010104, 0x040c0204, 0x36010105, 0x32558204,
	0x02060c05, 0x02140301, 0x05050402, 0x4c55442e, 0x82020407, 0x10082875, 0x0f1e0e08, 0x82040903, 0x0b033217, 0x391c0b16, 0x07040d1c, 0x1e112311,
	0x0b051d3c, 0x08728205, 0x0404093f, 0x0e060909, 0x04020b06, 0x05030401, 0x05010a02, 0x02020908, 0x01070d02, 0x0d1a0d0b, 0x1d3d7b3d, 0x1d0f1d3a,
	0x042d090e, 0x02030f03, 0x0e070201, 0x1c361c07, 0x09142818, 0x01010108, 0x3f338202, 0x03090507, 0x01020401, 0x02030206, 0x07100603, 0x04050703,
	0x19030406, 0x0f1d0f06, 0x0e183016, 0x0c291f82, 0x030b0404, 0x04060804, 0x3f798201, 0x0912091e, 0x03050b09, 0x04020c0c, 0x0b0c060c, 0x08390303,
	0x21163017, 0x130c0d5b, 0x10300606, 0x01245682, 0x0a080605, 0x16230782, 0x820c170b, 0x010224a7, 0x8203052e, 0x060835ac, 0x0109050b, 0x090b1a0a,
	0x17040813, 0x0f030706, 0x23120820, 0x0b24dd82, 0x06081308, 0x05219c82, 0x224d8203, 0x82020203, 0x820520ef, 0x02073e12, 0x051b0101, 0x3e1f3f1f,
	0x39193f7c, 0x11191419, 0x02010406, 0x2c17050e, 0x14271417, 0x2d60820b, 0x05030108, 0x0209040c, 0x08100320, 0x0c82120a, 0x0abf2808, 0x04190c2b,
	0x07061e01, 0x090d070d, 0x011a0805, 0x86080f01, 0x10160408, 0x0902020b, 0x08480302, 0x06060a0f, 0x82290704, 0x0509286d, 0x01060304, 0x82010a09,
	0x011023f8, 0x06820303, 0x04020726, 0x0c040103, 0x062f0382, 0x1a02020d, 0x0a150b03, 0x03023a05, 0x8201030d, 0x0120088a, 0x02020c01, 0x03060408,
	0x0d1a0d05, 0x01034506, 0x05050905, 0x06050a05, 0x07100603, 0x050a1c0a, 0x0f2e4282, 0x0e131304, 0x05041101, 0x05040201, 0x5582010a, 0x04010122,
	0x0125fb82, 0x02042a01, 0x6344821a, 0x08260595, 0x05010802, 0x55823507, 0x090a0a33, 0x01040911, 0x0d030501, 0x09060137, 0x0204080b, 0x25368206,
	0x03020406, 0x2f820901, 0x060d0924, 0x80820b0d, 0x0104043c, 0x09070f02, 0x08152a15, 0x1007070b, 0x152b1508, 0x06091509, 0x0507090b, 0xe8820602,
	0x39113908, 0x1630130a, 0x16122011, 0x0910162e, 0x08010101, 0x05071406, 0x11090511, 0x15241408, 0x0a041a10, 0x6e110c11, 0x12240d0d, 0x05010e12,
	0x09120904, 0x04030309, 0x15120a0d, 0x013e2b82, 0x07031701, 0x0508020c, 0x08070101, 0x090a0b0a, 0x02050b0c, 0x06250303, 0x27120a21, 0xc7840918,
	0x0805122f, 0x4623090d, 0x162c1624, 0x05183119, 0x2c1f8214, 0x09040d01, 0x04050302, 0x04030824, 0x24b58207, 0x08040a05, 0x23008203, 0x07050607,
	0x0423bd82, 0x820a2007, 0x6ffe3c2d, 0x112f080a, 0x0502030a, 0x090c0d07, 0x0d110411, 0x0f12031d, 0x08050d04, 0x8200080e, 0x00023b00, 0x0a400056,
	0x004003a0, 0x0095007d, 0x012f0100, 0x07152335, 0x020f010e, 0x02832f23, 0x0b832520, 0x27210125, 0x822f030f, 0x82272013, 0x1307350d, 0x36043f25,
	0x0f011f16, 0x17011e03, 0x023f011e, 0x3e37013e, 0x0d820682, 0x37220782, 0x08793f17, 0x221a8205, 0x44023f17, 0x2e230535, 0x82333501, 0x8233200f,
	0x37212610, 0x21371733, 0x25058217, 0x0527013f, 0x8a48010e, 0x68352006, 0x8968058b, 0x0a152505, 0x2e2b089b, 0x8108b382, 0xb00d2203, 0xc81e1b16,
	0xfe1b1615, 0x06041b20, 0x91fd0702, 0x303f6609, 0xa2202f1c, 0x313a316e, 0x1608150c, 0x4dc80a01, 0x08173243, 0x1413070e, 0x03112022, 0x170b0b0d,
	0x04142d0d, 0x160a0b0e, 0x0f15290c, 0x0e35101e, 0x09210d1b, 0x1c2f130c, 0x1f1a361c, 0x2533223f, 0x19472e14, 0x0d0b2318, 0x010f9a0d, 0x15160305,
	0x5301281d, 0x0f12d803, 0x13242e01, 0x05130d0d, 0x05ebf905, 0x093d080d, 0x00840610, 0x3d09103b, 0x06050d08, 0x12b00205, 0x11087905, 0x4b080b02,
	0x251c0e05, 0x05090607, 0x08008202, 0x5709065f, 0x0a060d13, 0x01090a0a, 0x0a040c01, 0x58c3fe07, 0x11191a4a, 0x06050108, 0x3e3d1b0e, 0x071b1424,
	0x0a010606, 0x10211109, 0x2c0e1f12, 0x010e0c11, 0x070a0303, 0x38020705, 0x452a2861, 0x1737201b, 0x201a3a52, 0x3a202141, 0x1c3b1e1b, 0x0403020a,
	0x13160f05, 0x210e130e, 0x0d0b0703, 0x088383ae, 0x070d0523, 0x05070f09, 0x05060105, 0x00091006, 0x4d000200, 0xe20a5500, 0xb8012903, 0x0000c801,
	0x27260601, 0x08275b22, 0x0e070626, 0x06262701, 0x8205c846, 0x2a232c05, 0x26222301, 0x07221415, 0x5e272622, 0x36200590, 0x8308fc5d, 0x822f832c,
	0x4626201a, 0x1e2407d5, 0x011e1701, 0x46057546, 0x11820b6f, 0x013e2723, 0x714d8337, 0x5f8209a2, 0x22262722, 0x520fa757, 0x6654052f, 0x09c35b08,
	0x4a826e86, 0x22052c47, 0x82263637, 0x45272002, 0x058405f8, 0x36343529, 0x33323637, 0x82333632, 0x1636246b, 0x82363237, 0x210e8302, 0x395c3632,
	0x3e372305, 0x17823301, 0x82013a21, 0x36372208, 0x23148216, 0x35361607, 0x0e213b85, 0x20ef8501, 0x07654727, 0x013c2723, 0x25508337, 0x16323316,
	0x41861617, 0x33205982, 0x41883e82, 0xf2841a82, 0x5c825083, 0x16210e82, 0x79a18214, 0xb372087d, 0x06072205, 0x21148322, 0x8c82033a, 0x3b863720,
	0x8083a782, 0x52062548, 0x9284057f, 0x14161725, 0x82011c15, 0x51072005, 0x332007c2, 0x20093a52, 0x25178236, 0x07061617, 0x96820605, 0x75823620,
	0x232b5782, 0x0a070622, 0x244924d5, 0x5b050805, 0x50080514, 0x07070408, 0x0f15080f, 0x02110407, 0x0f200e0c, 0x060d180d, 0x05070219, 0x0904050a,
	0x02010604, 0x15041c06, 0x6733152b, 0x1c361c33, 0x09081008, 0x0804081b, 0x01010203, 0x1d071008, 0x07031d39, 0x0c100103, 0x0a254b24, 0x0303022b,
	0x02050302, 0x271b8201, 0x08030112, 0x03040208, 0x01304483, 0x04070401, 0x0c0a0e03, 0x0b070b17, 0x06190707, 0x02226d82, 0x5a820209, 0x1d102c08,
	0x070a0411, 0x11062108, 0x05021021, 0x080e0b03, 0x0b0d220c, 0x2d171a08, 0x12251316, 0x200e1e0f, 0x90481f3e, 0x22422048, 0x82060c1c, 0x07022257,
	0x08008501, 0x0202042b, 0x12081201, 0x10091225, 0x04070609, 0x230f300c, 0x26142346, 0x0a130a13, 0x0a021b03, 0x1e111311, 0x1629110f, 0x0a112311,
	0x29ee8210, 0x0f1d0f0a, 0x090d1607, 0x90820a01, 0x13251237, 0x13101f0f, 0x23111428, 0x13271410, 0x01010405, 0x33020107, 0x2441820a, 0x10244b24,
	0x20148224, 0x378f8214, 0x03091109, 0x03070209, 0x0f1e0f0a, 0x03030404, 0x2210050e, 0x264d2710, 0x0e367482, 0x0409092f, 0x04060c03, 0x2814063f,
	0x152b1513, 0x03081908, 0xed820106, 0x072b132d, 0x9999994c, 0x162c164d, 0x82070e07, 0x064608da, 0x090a070f, 0x0e070907, 0x20132713, 0x0c022040,
	0x080d0608, 0x06011505, 0x05010307, 0x09040304, 0x04070402, 0x06040205, 0x4523060e, 0x22442222, 0x03030e06, 0x0b020101, 0x3e1045f9, 0x072a1309,
	0x0b0f0803, 0x66820c11, 0x05dd0124, 0x29820302, 0x0405042b, 0x080e1c0a, 0x130b0e0d, 0x223e8204, 0x82010907, 0x23408200, 0x02040105, 0x01210982,
	0x36b38207, 0x4c260901, 0x03760c26, 0x02050e09, 0x24120f0a, 0x1c381c12, 0x820e1b0e, 0x0e062457, 0x82090502, 0x160b2878, 0x0219090a, 0x83020403,
	0x04350833, 0x01040805, 0x020d0106, 0x071f4121, 0x1503030b, 0x0c170c05, 0x0d010302, 0x1e150e23, 0x0c361113, 0x0c160b04, 0x0b1a341c, 0x171e010e,
	0x070c140c, 0x23120812, 0x21e08213, 0x90820b05, 0x1109032e, 0x02040a09, 0x1b010105, 0x01010b05, 0x02295083, 0x071f0c03, 0x0b091005, 0x3991821a,
	0x060b0907, 0x01040908, 0x08020418, 0x05070607, 0x030b1809, 0x02030305, 0x7f820201, 0x3401012c, 0x0a120a07, 0x0c070e08, 0x11820304, 0x08020522,
	0x01281882, 0x05010201, 0x0707030a, 0x04230d82, 0x82030104, 0x0407210f, 0x0d390482, 0x0a0e2e0d, 0x03070813, 0x07030201, 0x04060204, 0x06030d02,
	0x16160b02, 0x283a8308, 0x08010405, 0x2709030d, 0x30e48208, 0x11040401, 0x0e061220, 0x03010607, 0x05040b03, 0x08508203, 0x0513043c, 0x8b031609,
	0x16011210, 0x0203160a, 0x00050605, 0x4a000800, 0xd50a5a00, 0x06002603, 0xe7010c00, 0x0d02fa01, 0x28021f02, 0x00002e02, 0x31272201, 0x37163130,
	0x32230622, 0x8f4b2536, 0x012e2b05, 0x07062207, 0x22230636, 0x11822706, 0x27012a34, 0x3c071606, 0x010e3301, 0x33063435, 0x16272622, 0x20833326,
	0x2e172226, 0x06322301, 0x17253b82, 0x22233626, 0x211d8206, 0x14833407, 0x06322726, 0x34012b35, 0x0e291084, 0x16060701, 0x15011e17, 0x284f8216,
	0x011c1516, 0x17061415, 0x05c47d2a, 0x07203483, 0x23830b82, 0x82151421, 0x05134464, 0x16200e82, 0x0cb44218, 0x06262723, 0x826a8223, 0x441a8273,
	0x70820794, 0x012e2723, 0x20798327, 0x82628226, 0x16272856, 0x16322706, 0x4b360615, 0x272905a0, 0x34352634, 0x36323326, 0x05ab4c07, 0x30287a82,
	0x34351617, 0x26363716, 0x26213c83, 0x08677036, 0x36161722, 0x2108164c, 0x4e820607, 0x0d673620, 0x32332105, 0x26832c83, 0x85363221, 0x25178232,
	0x17163633, 0x08820616, 0x38820582, 0x36373322, 0x82059d4c, 0x846f828a, 0x82f0832c, 0x051c7768, 0x17226e82, 0x02823626, 0x17220e82, 0x0e82011e,
	0x013a3322, 0x36211a84, 0x05e64b37, 0x6e823220, 0x4d820620, 0xa2821520, 0x9b841420, 0x2105e947, 0x74822226, 0x2457db82, 0x26362109, 0x26205f86,
	0xee568384, 0x07162606, 0x14150616, 0x82568416, 0x371627f0, 0x3c17011e, 0x9c5d3501, 0x36322705, 0x07161417, 0x57823405, 0x14072622, 0x27826683,
	0x36263723, 0x82128235, 0x061722f4, 0x20058336, 0x298b8316, 0x06261335, 0x23262215, 0x7482012e, 0x16320729, 0x05363433, 0x82072622, 0x013c2d65,
	0x07232205, 0xa4063632, 0x11010101, 0x30080382, 0x20040101, 0x13123a07, 0x0a08019a, 0x0c070a0b, 0x240e5b05, 0x8e072253, 0x366c3613, 0x01070301,
	0x04171205, 0x060a0409, 0x020a0217, 0x051b0508, 0x3b078208, 0x13010616, 0x0c020b08, 0x05110c01, 0x040a091b, 0x2522010c, 0x04153124, 0x0205150d,
	0x0805014b, 0x02060a25, 0x5b2e0705, 0x0304082e, 0x0509070b, 0x0d1d3c1d, 0x01010312, 0x0f020205, 0x03050503, 0x14040f06, 0x82120f62, 0x0c3d082e,
	0x13221404, 0x0e0d140a, 0x2215173c, 0x132a1b16, 0x0f060b06, 0x3c070609, 0x1c391c1f, 0x04144a15, 0x0a060405, 0x05230a0e, 0x190e0303, 0x010c0902,
	0x02102001, 0x09080302, 0x12082309, 0x08158213, 0x612121d9, 0x0e0c0205, 0x05062617, 0x17070903, 0x2242210a, 0x16265227, 0x13020742, 0x0c160905,
	0x14081206, 0x6b030362, 0x040d0715, 0x1315360e, 0x01040b2d, 0x07150504, 0x0211090e, 0x0806021d, 0x0c230f07, 0x07050d08, 0x210a1004, 0x02030307,
	0x02123e0f, 0x170b0303, 0x2a612c0d, 0x03030309, 0x23074605, 0x0f061e44, 0x0e0f0c37, 0x0a180a11, 0x03100505, 0x0b030902, 0x0504180e, 0x03162406,
	0x1b0d0c08, 0x170a120e, 0x19152217, 0x1e171a34, 0x1b351a1e, 0x0402010f, 0x280f1204, 0x1d0d2757, 0x0d1d0f0d, 0x19101f10, 0x01030402, 0x3b763c0f,
	0x10254925, 0x03020406, 0x0b2f0605, 0x01061009, 0x050a0520, 0x2548251b, 0x09182f18, 0x01091213, 0x67341c09, 0x0b060d34, 0x82011703, 0x50183266,
	0x11120924, 0x0203410e, 0x0511f602, 0x061b0b11, 0x239d8202, 0x08190e13, 0x2b080782, 0x11192c7d, 0x12200502, 0x1201061a, 0x070c4c0f, 0x3a0bab02,
	0x010b150a, 0x03050942, 0x305e3001, 0x0b440203, 0x160a041b, 0x01e9fe0a, 0xa9200084, 0x2e330584, 0x0f05050d, 0x06010205, 0x06071601, 0x01091008,
	0x8205180c, 0x06022818, 0x0206110d, 0x82040101, 0x04022d03, 0x02070101, 0x0a0d0702, 0x01020706, 0x64086a82, 0x09030602, 0x0a050e17, 0x0c070402,
	0x05061a05, 0x0e0b020c, 0x23110517, 0x1b491e12, 0x7e0f0a2b, 0x0d010108, 0x010a030b, 0x02040b01, 0x060d0403, 0x240b180a, 0x05060417, 0x060b0812,
	0x0f1e3620, 0x0314121d, 0x0c020b01, 0x10060c04, 0x071d150f, 0x0c020808, 0x03040403, 0x07220507, 0x0a010219, 0x0101030c, 0x29ad820a, 0x2e181b37,
	0x05140816, 0x2d820e07, 0x080e0235, 0x120a0818, 0x10050409, 0x0f1c221f, 0x11120302, 0x83050758, 0x1b053ba0, 0x0b071309, 0x0f050a1e, 0x19110702,
	0x04100717, 0x0b034f0f, 0x04031003, 0xb6830c02, 0xb3820520, 0x08024508, 0x11020402, 0x21070801, 0x160f0521, 0x01060601, 0x19030932, 0x03070503,
	0x10080105, 0x0214050e, 0x040f0202, 0x10010e08, 0x11110907, 0x0b020a12, 0x06060612, 0x0104060b, 0x29110c07, 0x09120912, 0x08050211, 0x51085582,
	0x03030804, 0x2a0f1101, 0x0a070c07, 0x06040704, 0x060e1406, 0x040e120d, 0x1a111608, 0x12120b07, 0x03040402, 0x020d0305, 0x14060c05, 0x040f4a05,
	0x1f0f0501, 0x06070e0f, 0x470f210d, 0x0c130c20, 0x5002121e, 0x09310e08, 0x06090107, 0x63010c10, 0x6282150a, 0x09104008, 0x01081f05, 0x02412405,
	0xba040108, 0x00000101, 0x62000200, 0x2b0d8d00, 0xa400f302, 0x0000b200, 0x35012f01, 0x17373521, 0x2f331735, 0x23020f02, 0x3f363235, 0x07232701,
	0x0f151715, 0x82272301, 0x0e073211, 0x17011d01, 0x3f011f15, 0x23153302, 0x030f010e, 0x251a8223, 0x012e2721, 0x0b822123, 0x07201e84, 0x3a081e82,
	0x33033f33, 0x36323717, 0x1f333735, 0x33043f05, 0x17011e37, 0x013e023f, 0x35251533, 0x033f013e, 0x23010e17, 0x012b012e, 0x06150622, 0x33021f16,
	0x37012f37, 0x3f353721, 0x82263401, 0x239d0883, 0x3e372135, 0x05273501, 0x35262223, 0x013b3634, 0x14151632, 0x04270d06, 0x3792f806, 0x0207e021,
	0x4b462605, 0x0502a737, 0x020b0301, 0x3220025f, 0x37412e64, 0x02020618, 0x38020402, 0x241d3741, 0x01030361, 0x022d250b, 0xc8fe0906, 0x040a041f,
	0x0609edfe, 0x671e0203, 0x03060c0b, 0x251c0803, 0x284c1723, 0x0c04030d, 0x21221697, 0x36514f2b, 0x01080e10, 0x22130509, 0x1322350f, 0x010a0d02,
	0x0c0e0108, 0xdf1d3537, 0x0309130a, 0x07040e12, 0x06010407, 0x052f050f, 0x01050508, 0x256782d9, 0x5a0d0505, 0x1783c804, 0x40f3f63a, 0x0d0e0e0d,
	0x0d0d0e40, 0x0c0c2602, 0x05011a05, 0x03840e04, 0x08080605, 0x5b082782, 0x12062004, 0x01031306, 0x03030404, 0x05060202, 0x0604311f, 0x04070603,
	0x0103011d, 0x06080703, 0x051f1d1d, 0x02030705, 0x09050703, 0x84674c05, 0x08050314, 0x08080406, 0x104a0504, 0x0d0f2220, 0x2b17060a, 0x0c03232f,
	0x1205010d, 0x5303030f, 0x0502501c, 0x080f0f03, 0x04050403, 0x08267d82, 0x06230d16, 0x1f820911, 0x09030431, 0x0d040e0a, 0x0a06154e, 0xe80f0610,
	0x820c0e0f, 0x0f0e2200, 0x2c008200, 0x00520001, 0x025308da, 0x00a800a9, 0xb7791800, 0x0c61720e, 0x5d012e21, 0x172208cc, 0x4b64011e, 0x36342106,
	0x824c1485, 0x0626210c, 0x8c521d85, 0x36262706, 0x37263637, 0x02833634, 0x776a3620, 0x820b840a, 0x05976b4a, 0x35222382, 0x59853634, 0x2405d547,
	0x15061617, 0x05107214, 0x32330122, 0x08083078, 0x3e37365b, 0x14083701, 0x1c0f2010, 0x3e1a253c, 0x14281320, 0x4a386f37, 0x1c0e4b95, 0x0313030e,
	0x05020502, 0x481f0d10, 0x0a1a0a17, 0x05061004, 0x10020204, 0x01211c07, 0x0c180202, 0x17132614, 0x7139172e, 0x3e7d3e39, 0x15122512, 0x11050917,
	0x0102060a, 0x0d040101, 0x0c070402, 0x3c098205, 0x0b050301, 0x180a0512, 0x13271314, 0x393e7c3e, 0x2d163972, 0x13271416, 0x08060a06, 0x2b458203,
	0x010f1c2b, 0x0210070b, 0x02080903, 0x26083a83, 0x26130616, 0x22432213, 0x3a397339, 0x42203a74, 0x162e1621, 0x021d391c, 0x02050105, 0x141c4624,
	0x0a060a1b, 0x820d0402, 0x13470839, 0x08150d04, 0x0c191412, 0x04061130, 0x050c0303, 0x04010408, 0x200f1c28, 0x0104110f, 0x03030603, 0x08030202,
	0x06050303, 0x02010402, 0x0d081019, 0x0813060a, 0x09102010, 0x200f090b, 0x0716050a, 0x07081008, 0x820c0610, 0x82152014, 0x0602212a, 0x09203282,
	0x03233483, 0x82010306, 0x05103c00, 0x1b0f200e, 0x1802042d, 0x0b030506, 0x030a220d, 0x0c030304, 0x0a020703, 0x82050505, 0x01013430, 0x05020105,
	0x00000002, 0x00530001, 0x025408d4, 0x822001ab, 0x012e220c, 0x05e35427, 0x27010e2b, 0x06012b30, 0x06262726, 0x05954d23, 0x22313024, 0x0c831423,
	0x24821282, 0x1b820720, 0x2e202482, 0x22095f74, 0x82010e07, 0x2235232a, 0x17843123, 0x09765218, 0x35012e24, 0x42183436, 0x0e20097f, 0x08127318,
	0x32820620, 0x26204783, 0x08875818, 0x22071429, 0x17221706, 0x55161433, 0x16210650, 0x052c4e36, 0x4d741720, 0x013e2405, 0x42323637, 0x1e220627,
	0x69180701, 0x3e2008a6, 0x48092f70, 0x3583059d, 0x82333121, 0x2140822b, 0x5642013e, 0x17162907, 0x3233013e, 0x36161516, 0x17220582, 0x25833216,
	0x31333222, 0x11892684, 0x013b3022, 0x16213282, 0x060e4914, 0x8205344e, 0x012e3b79, 0x20e50727, 0x67332143, 0x3e7b3e33, 0x01030b04, 0x030d0201,
	0x09090a08, 0x0882080b, 0x0301012c, 0x01040406, 0x060b0c07, 0x1d820310, 0x07044b08, 0x07030205, 0x07060702, 0x0801030a, 0x01060102, 0x01010405,
	0x03050a01, 0x1b0d0902, 0x0a0f090d, 0x05060a05, 0x04040102, 0x02020409, 0x0b160a04, 0x111e1906, 0x85431325, 0x32663342, 0x0c1c3a1d, 0x2a100b12,
	0x04130b0e, 0x5b820302, 0x09010b23, 0x05146201, 0x1d062408, 0x1027171e, 0x100b1409, 0x86431123, 0x152a1543, 0x100f1d0f, 0x11091120, 0x060d0809,
	0x0b100316, 0x82050c17, 0x09113964, 0x08040101, 0x06081008, 0x1b0e0608, 0x0401090e, 0x01010806, 0x05030d03, 0x0a2b9882, 0x01070606, 0x06010406,
	0x82010209, 0x06052310, 0x0a82090c, 0x82070321, 0x8201201f, 0x020e22d7, 0x23108207, 0x08020308, 0xb6821085, 0x04012408, 0x1c060e07, 0x6a351c38,
	0x1e3e1f34, 0x182c7738, 0xf4011d3a, 0x05030f09, 0x10010f0a, 0x050f0110, 0x82051616, 0x0d043c06, 0x1905030e, 0x0d180103, 0x030a0b10, 0x0a040d14,
	0x010b0504, 0x03050902, 0x82020404, 0x1007271b, 0x0c01090d, 0x01830203, 0x150a0634, 0x0c1a0c0a, 0x03011905, 0x3f200304, 0x010c0911, 0x74820402,
	0x07010238, 0x040f0103, 0x080a0206, 0x0e060d15, 0x030f0506, 0x04010223, 0xcd820509, 0x042a1b2c, 0x080e2203, 0x02040304, 0xab820402, 0x01070123,
	0x27b18202, 0x05090101, 0x03183a13, 0x0f24d382, 0x19331a04, 0x08204782, 0x0a201d82, 0x04373682, 0x04130a09, 0x0a040f0f, 0x01050502, 0x04050a02,
	0x130e030a, 0x820e0304, 0x07162da7, 0x0f060506, 0x0f0f0a0a, 0x05081605, 0x06240a84, 0x05040e11, 0x043d9c82, 0x14262208, 0x00000818, 0x55000400,
	0x0f0c3e00, 0x8a014203, 0xa6019d01, 0x0000b201, 0x06fe6c01, 0x26630320, 0x07796208, 0x32433620, 0x010e2c06, 0x23010e07, 0x3623012a, 0x85343526,
	0x62142014, 0x14830522, 0x22211782, 0x82178736, 0x82262084, 0x5807202c, 0x1e2a054f, 0x013a3301, 0x07063233, 0x42692206, 0x051a4c0e, 0x34363722,
	0x35203882, 0x8305a743, 0x263b8447, 0x1e17010e, 0x872e1701, 0x05615874, 0x08524018, 0x15011c30, 0x36371614, 0x16063732, 0x27263435, 0x4182013c,
	0x16323322, 0x83053a51, 0x32362305, 0x8a701617, 0x32332206, 0x820b8236, 0x5892821d, 0x14200aa0, 0x47430b82, 0x013e2106, 0x85053363, 0x8335203e,
	0x360221b0, 0x4e883682, 0x023a3322, 0x2105254c, 0x76821706, 0x2226d682, 0x16061506, 0x43830633, 0x05830720, 0x61821620, 0x17228b82, 0x6a840622,
	0x39823620, 0x26362722, 0x21058f52, 0x9d823e27, 0x35200b83, 0x2721a684, 0x82978326, 0x163723b5, 0x5584013a, 0x33321624, 0x1c831636, 0x010e0128,
	0x07062223, 0x23822622, 0xf1733720, 0x26252b05, 0x011c3736, 0x17260617, 0x22832636, 0x1626dd08, 0x0c010e33, 0x230d080f, 0x793c236e, 0x433c7979,
	0x43868686, 0x0a0f1e0f, 0x12100702, 0x330d1331, 0x0a170709, 0x380e200e, 0x02043970, 0x3e060204, 0x0d040d0a, 0x42210d18, 0x02010820, 0x0d370703,
	0x06050d10, 0x0c090d40, 0x06040301, 0x3014102c, 0x0e1c0d17, 0x02010102, 0x2312030e, 0x0d1c0b11, 0x0f10210e, 0x1b0d0f1f, 0x063f0b0f, 0x01010a03,
	0x0c120204, 0x251e3d1e, 0x290d254a, 0x01040a0b, 0x03020301, 0x200d0109, 0x0406040d, 0x13060d06, 0x12051327, 0x0f030503, 0x1a331a11, 0x01086a05,
	0x07070d05, 0x3c793c07, 0x07070f08, 0x29050904, 0x06190502, 0x08070506, 0x0a0b0407, 0x0c040b16, 0x0c0c0102, 0x030a0503, 0x03020c03, 0x3a09040f,
	0x0a200913, 0x04011705, 0x04010207, 0x043e2782, 0x06020b03, 0x6c6b3603, 0x1105356b, 0x050f0703, 0x07071205, 0x7c3e0a0a, 0x323e7b7c, 0x90823163,
	0x0c092e08, 0x06120403, 0x01130c01, 0x01060414, 0x1127100d, 0x0e022207, 0x2c040506, 0x05070908, 0x06080b04, 0x0705050c, 0x0d110504, 0x02030201,
	0x08c08204, 0x03060126, 0x6c360102, 0x3e366c6b, 0x160b3e7c, 0xf50c160b, 0x051b02af, 0x03050706, 0x0302031b, 0x0a2b0701, 0x02021009, 0x05315382,
	0x44110a0b, 0x3d030901, 0x0221050a, 0x04010768, 0x08df820b, 0x09130a28, 0x06050c0a, 0x070a0506, 0x0907050a, 0x060e1d0f, 0x050a0511, 0x0f070b27,
	0x11070408, 0x05130607, 0x082f050b, 0xbb820a0c, 0x2c0c0b3c, 0x0105100c, 0x02050101, 0x07030101, 0x09091405, 0x0d070710, 0x08050505, 0x20820408,
	0x08050a32, 0x080e0715, 0x14040504, 0x050b040a, 0x01050705, 0x042f2d82, 0x09200704, 0x280b170b, 0x2813284e, 0x820b1214, 0x1320083f, 0x0b0a1703,
	0x060b0609, 0x0302040c, 0x031a321a, 0x09030306, 0x0a040202, 0x12080618, 0x01020406, 0x2808d282, 0x0c060723, 0x02140307, 0x06051402, 0x1407060c,
	0x0b150b08, 0x04071114, 0x09010109, 0x0d200d04, 0x0a0e0e0e, 0x0f060910, 0x084f8207, 0x0a042021, 0x150a0a14, 0x010d0809, 0x1708080d, 0x0f281104,
	0x0a120f0b, 0x03040905, 0x13050302, 0x820c0c08, 0x0121085c, 0x3a0c3d0a, 0x0204090a, 0x04190506, 0x07070d0b, 0x340b0911, 0x05110402, 0x07030704,
	0x140a0a0e, 0x28eb820b, 0x14071304, 0x22111524, 0x36558211, 0x09080201, 0xfdfe0928, 0x02070e07, 0x1b030401, 0x01040702, 0x82092f0b, 0x172c08da,
	0x070b0406, 0x05060307, 0x040f0508, 0x05001516, 0xa4006200, 0xda026a0a, 0x1e010b01, 0x50014a01, 0x00005601, 0x37363201, 0x3135013e, 0x43053755,
	0x2320052e, 0x2107ae50, 0x1e562627, 0x23032105, 0x21051444, 0x11822606, 0x36262727, 0x15012a27, 0x201a8516, 0x241a8401, 0x16141506, 0x24178215,
	0x22072226, 0x78448226, 0x22210915, 0x220e8206, 0x6d010e37, 0xa6710ee1, 0x23358206, 0x16170614, 0x0de06418, 0x82013e21, 0x4915202f, 0x16200592,
	0x4706c747, 0x1e2006bb, 0x820c2644, 0x057f55b8, 0x49062844, 0x178307f2, 0x16240b82, 0x32161736, 0x1d822082, 0x55363321, 0x1a820660, 0x033a3323,
	0x067d5033, 0x36373622, 0x1622d185, 0xdb830537, 0xb77b2220, 0x3a172305, 0x78821701, 0x26222522, 0x22051057, 0x51260623, 0x7172066f, 0x21088208,
	0xbb443632, 0x334a0805, 0x1517011e, 0x33163225, 0x2a232706, 0x16362301, 0x130a350a, 0x03020d09, 0x060c0908, 0x06101e0c, 0x0309070d, 0x07080202,
	0x36080d06, 0x7038356d, 0x5a5a2d37, 0x592d2d5a, 0x2a542a2d, 0x02030610, 0x06030924, 0x010e0306, 0x37820802, 0x2c582c29, 0x06162d17, 0x820a0104,
	0x162b0814, 0x0a190b08, 0x03020202, 0x10090305, 0x07110505, 0x050b0202, 0x582c010c, 0x2c582b2d, 0x08172d16, 0x0c06060d, 0x152a1507, 0x82012709,
	0x034c0800, 0x0f1e1109, 0x060b260f, 0x09040308, 0x10150905, 0x022a532a, 0x0a150a01, 0x08031b06, 0x170b0608, 0x0118080b, 0x20100b1e, 0x15291411,
	0x08041713, 0x1209080c, 0x0e0d0509, 0x0b0f2310, 0x11080b16, 0x08160e08, 0x0f10110a, 0x180b0f1e, 0x0f2b0e83, 0x2c140f17, 0x11251115, 0x82142c13,
	0x5a2d3265, 0x2d582d2c, 0x09172c16, 0x10090914, 0x59592c0a, 0x36c68359, 0x0c182e18, 0x0b020211, 0x06210b0e, 0xf9041b03, 0x0d2c0a2f, 0x8208150a,
	0x052a08d9, 0x16091234, 0x03040806, 0x9a4f7a06, 0x274f274f, 0x0a102010, 0x14040a0d, 0x08120806, 0x27142714, 0x4e26284f, 0x0a140a26, 0xbe820a03,
	0x0d05012e, 0x03040405, 0x02016af9, 0x42010301, 0x48081183, 0x034d0201, 0x0b020402, 0x0209081d, 0x0d080603, 0x07030915, 0x140a060f, 0x01010708,
	0x03020304, 0x0f0d0e01, 0x0f03060d, 0x05090501, 0x0b050601, 0x09100505, 0x07010108, 0x01030b01, 0x1e070703, 0x02051901, 0x08040611, 0x82028204,
	0x01270847, 0x06050602, 0x03050401, 0x2c0c0201, 0x2f172c56, 0x04360a17, 0x06070e06, 0x14070c0f, 0x09120a08, 0x0904100e, 0x82040815, 0x8202204c,
	0x1d0f2d2b, 0x142a150d, 0x0f10220e, 0x0605030d, 0x052d4382, 0x13081705, 0x2513101e, 0x04270b13, 0x2bb28404, 0x140b0a15, 0x01020303, 0x02030502,
	0x0b827982, 0x02020425, 0x83060604, 0x0304331c, 0x03030101, 0x0e0b1605, 0x0904051f, 0x0102080d, 0x12820d91, 0x1005082c, 0x01011808, 0x0b160a08,
	0xe5840281, 0x0b070127, 0x02010205, 0x24038302, 0x06040401, 0x2015848c, 0x36008200, 0x005e0002, 0x02e809bb, 0x00ac00c6, 0x010000c5, 0x2a35013c,
	0x48222601, 0x07200822, 0x43054c4b, 0xf163135f, 0x22232605, 0x011c1526, 0x05684315, 0x200adc4a, 0x23148237, 0x35323330, 0x43053343, 0xd3780b81,
	0x36322a05, 0x33061617, 0x2617013a, 0x05dc6a36, 0x82141521, 0x05f24208, 0x16330624, 0x26833332, 0xf0470320, 0x32362206, 0x052d7817, 0x36258d83,
	0x33163237, 0x2b918205, 0x2e272606, 0x16143701, 0x37362233, 0x32212d82, 0x08518216, 0xe8090723, 0xcacac962, 0x73723a62, 0x42203a72, 0x06220921,
	0x3f148408, 0x2a143d86, 0x0e1f0f10, 0x0b0e1a0e, 0x08028218, 0x230f0af8, 0x162d1510, 0x0714241c, 0x22040901, 0x11160702, 0x1520172c, 0x07110408,
	0x01355b20, 0x101e2701, 0x2d0e140a, 0x441d2a6a, 0x101f0e25, 0x0a0b1d06, 0x3a1d0b18, 0x122b121d, 0x0b060402, 0x01010b15, 0x05071105, 0x0f614502,
	0x0a317232, 0x03050a13, 0x0b170b04, 0x29109f02, 0x29525152, 0x06154b1f, 0x1b0d0609, 0x091f1515, 0x0f040408, 0x16f9101e, 0x150e260a, 0x0c111131,
	0x04160117, 0x1d0b0316, 0x0822150d, 0x02060304, 0x12361646, 0x1e030601, 0x0909080c, 0x0d07090b, 0x07100707, 0x03021605, 0x0d080513, 0x020f0706,
	0x030a1104, 0x07030107, 0x3118070c, 0x184e2219, 0x0c092f14, 0x1b0a1510, 0x18512f0a, 0x01020402, 0x0e182e0e, 0x12170816, 0x0a21151d, 0x01010704,
	0x01050617, 0x0a010404, 0x07070501, 0x06080102, 0x0909061b, 0x01030b02, 0x060d0109, 0x56820f03, 0x0f010c26, 0x15070f1f, 0x2f082a82, 0xdc010907,
	0x0704120e, 0x2e0b0b08, 0x46311310, 0x03020406, 0x07130a14, 0x03000000, 0x72006300, 0x0d037207, 0x1001fe00, 0x00002401, 0x37363401, 0x2105504c,
	0xab5b012e, 0x200b820b, 0x05064907, 0x07c16918, 0x34363722, 0x3e2b0283, 0x3a353301, 0x16323301, 0x82363237, 0x72332005, 0xa06c08fa, 0x33323009,
	0x23170614, 0x17163215, 0x35173236, 0x6c150616, 0x1e2608a3, 0x16141501, 0x02461407, 0x011c2507, 0x26062315, 0x25050946, 0x23061607, 0x11822315,
	0x2508497a, 0x27262223, 0x54460622, 0x22178708, 0x83343526, 0x2a272202, 0x831a8201, 0x5c142002, 0x07210913, 0x08d77034, 0x23372625, 0x83150614,
	0x8203201b, 0x06232539, 0x22060716, 0x2908084e, 0x3f363435, 0x07352501, 0xcd4d011c, 0x26342709, 0x0e350727, 0x36830701, 0x28080383, 0x3315010e,
	0x01372634, 0x05021aa3, 0x1d06070d, 0x0c160b08, 0x10142d15, 0x11081027, 0x090f0908, 0x02091006, 0x07040311, 0x08008401, 0x04090242, 0x01020304,
	0x4c080802, 0x361b4c97, 0x0610071b, 0x06020503, 0xae57050a, 0x3157aead, 0x170b3263, 0x0205020c, 0x02020603, 0x01010506, 0x02040204, 0x09040e03,
	0x23472301, 0x06172f17, 0x0206051e, 0x082d1582, 0x0b152914, 0x04010b18, 0x1e0f0930, 0x373d820e, 0x25051006, 0x0508030a, 0x06041105, 0x1d0c0c33,
	0x20422108, 0x02030905, 0x08372c82, 0x040c0602, 0x0c110c08, 0x01010433, 0x0d183118, 0x0b050d1b, 0x83020a05, 0x0508212d, 0x082b6882, 0x15331101,
	0x050f200f, 0x8305040d, 0x23230873, 0x0401232a, 0x04050401, 0x060d0503, 0x0d244924, 0x0b030b2b, 0x013f0526, 0x070361c8, 0x1a090f10, 0x820c0205,
	0x0183224a, 0x08d18403, 0x18040327, 0x73010109, 0x0b033202, 0x03050b15, 0x01050101, 0x06070804, 0x07060a08, 0x050e0504, 0x07021004, 0x0c05050b,
	0x380b8206, 0x08060d06, 0x0d070609, 0x050f0505, 0x01011006, 0x04030301, 0x140b0403, 0x20a6820b, 0x08038203, 0x03061324, 0x09090705, 0x06060d07,
	0x0306030e, 0x0301030a, 0x05030408, 0x0901050b, 0x0d080910, 0x0a090d07, 0xd3820603, 0x00820220, 0x0c054908, 0x041b0d08, 0x06130904, 0x0c06060b,
	0x07020105, 0x0a050505, 0x050a0504, 0x01040303, 0x03040908, 0x05080407, 0x03030b03, 0x01475547, 0x09010709, 0x09030404, 0x07050b03, 0x837c0a58,
	0x0f060101, 0x02040c06, 0x0115040a, 0x1223c782, 0x45040102, 0x0226062a, 0x0b060408, 0x00820008, 0x60000230, 0xdb0aa500, 0x2a01da02, 0x00003d01,
	0x124d2601, 0x52342005, 0x15270533, 0x1423012e, 0x482a1716, 0x232606bb, 0x2623012a, 0x14822706, 0x26320582, 0x22060706, 0x23262223, 0x30370622,
	0x2e172227, 0x09820701, 0x2322362b, 0x22073626, 0x22261726, 0x0b8b4223, 0x21075c45, 0x877d0623, 0x010e210a, 0x27233c82, 0x8207012a, 0x204b851d,
	0x524e8306, 0xb465065b, 0x08c14c0a, 0x3620088c, 0x200b284d, 0x09044d16, 0x10c65718, 0x8605ab50, 0x3632223b, 0x05f86627, 0x37013a22, 0x45057e48,
	0x032006d1, 0x8208115f, 0x3427222f, 0x06bd4c36, 0x33013e22, 0x2e332f82, 0x36322701, 0x27263435, 0x1f261517, 0x16260501, 0x53013a33, 0x37200863,
	0x86081282, 0x0c05d40a, 0x0a160a11, 0x1c060307, 0x0a0b0e0a, 0x01010a14, 0xaaaaaa55, 0x29532a55, 0x0b152915, 0x0f070b17, 0x05070507, 0x0b041105,
	0x28140f20, 0x0b160b13, 0x07020f01, 0x30170507, 0x014f0717, 0x07031002, 0x21080a02, 0x03040304, 0x20100b1b, 0x08100811, 0x1509120a, 0x120a142a,
	0x0a11090a, 0x04021406, 0x5a2c071e, 0x1428142c, 0x13162d16, 0x0b061224, 0x01030205, 0x09060c06, 0x0c070a12, 0x0a1f1507, 0x82010504, 0x03840800,
	0x04010201, 0x08010202, 0x05102709, 0x18020213, 0x12221307, 0x0a091309, 0x1e0f0b13, 0x060c050e, 0x08070c08, 0x150a0710, 0x172c160a, 0x03061a10,
	0x160b0801, 0x08110809, 0x0d071009, 0x0a020504, 0x04040202, 0x100f1b0c, 0x0e141122, 0x1b50140b, 0x060e190e, 0x1201060a, 0x0f200e01, 0x16193118,
	0x0f07162c, 0x0a100806, 0x1711210f, 0x5c2e182f, 0x352f5c5c, 0x170c366b, 0x0b1b0c0c, 0x01011f0a, 0x07080404, 0x0e25ec82, 0x71380e1a, 0x2d908338,
	0x0103010a, 0xf9020305, 0x092f035f, 0x9a820f05, 0x2f050233, 0x060c080a, 0x02010102, 0x04150a8e, 0x04110203, 0x230c820a, 0x03010f0a, 0x0120d282,
	0x01272e82, 0x03030107, 0x82010309, 0x01022300, 0x12820402, 0x01070524, 0x0282010c, 0x100e2108, 0x050e0806, 0x04030a03, 0x10090407, 0x02040409,
	0x04010703, 0x01060806, 0x01010605, 0x04010107, 0x3f060041, 0x0a050102, 0x0a110914, 0x170a1309, 0x2b16172e, 0x102d1116, 0x01030610, 0x05090603,
	0x0a110603, 0x042d3f82, 0x0f06040b, 0x03080309, 0x02020604, 0x05f04909, 0x19060829, 0x0109060d, 0x82050c02, 0x08022459, 0x82230905, 0x0506360e,
	0x0b0a0406, 0x01050304, 0x1a0f1d01, 0x17091005, 0x030c0309, 0x0550430a, 0x10090622, 0x01275282, 0x06030102, 0x82070a0d, 0x830520b1, 0x05032ac6,
	0x0915050d, 0x0d070818, 0x20da8203, 0x82c48203, 0x093b0890, 0x01010810, 0x9f05050a, 0x0505020b, 0x030c0413, 0x031d0304, 0x00040408, 0x00550002,
	0x0306090c, 0x01b8017a, 0x010000d1, 0x1607011e, 0x22062326, 0x07012a07, 0x14150622, 0x83161716, 0x14272305, 0x08820716, 0x82011c21, 0x22232211,
	0x26058416, 0x36343506, 0x46013c35, 0x08850509, 0x823e3721, 0x0736250e, 0x2e373426, 0x26230882, 0x18061415, 0x2a08174e, 0x27010e07, 0x34353626,
	0x622a2306, 0x062305c8, 0x82361617, 0x5105825c, 0x05860506, 0x6e821420, 0x22068d46, 0x51062627, 0x36230a45, 0x42220637, 0x072105f9, 0x646a1830,
	0x06072209, 0x25028216, 0x23062223, 0x8f822606, 0x43478085, 0x06262109, 0x74830b82, 0x82062221, 0x8226827d, 0x43bf8253, 0xcc4605f8, 0x20238408,
	0x05d65d26, 0x16361728, 0x33013a33, 0x05833632, 0x15362229, 0x36373436, 0x86363732, 0x0515545c, 0x8205f243, 0x222c8223, 0x82163215, 0x3e172274,
	0x250b8201, 0x33163217, 0x3b863616, 0x32210b82, 0x22148236, 0x4c323633, 0x3e2106e2, 0x18298201, 0x2109e490, 0xe943012e, 0x16322106, 0x53832682,
	0x17361422, 0x24056441, 0x1415011c, 0x09845d06, 0x22060e5e, 0x82343726, 0x82362002, 0x202c8244, 0x202c8215, 0x8226821e, 0x330322a7, 0x225a8205,
	0x4423012a, 0x698408b9, 0x9c082782, 0x0bd90837, 0x5c061522, 0x48904812, 0x033a7439, 0x03030f02, 0x02140203, 0x01051003, 0x0a031301, 0x071e050c,
	0x02011301, 0x0e020702, 0x09040404, 0x02040409, 0x0a020209, 0x130d0d1b, 0x17010106, 0x264c2602, 0x01016206, 0x04020602, 0x08030901, 0x280c1f02,
	0x220b2851, 0x03090408, 0x080c0205, 0x02062513, 0x0f050a0c, 0x05050e06, 0x05030204, 0x05030103, 0x03060504, 0x0b030703, 0x104b1604, 0x040d0404,
	0x0a110607, 0x01050d09, 0x02040301, 0x2e050507, 0x0d491103, 0x0d12080a, 0x261a821e, 0x06030705, 0x822f5f2b, 0x02aa087e, 0x0e030304, 0x0a1a0b04,
	0x06090e0a, 0x03020106, 0x23051d03, 0x284f2809, 0x0e346034, 0x09020e1b, 0x0e050703, 0x0a090604, 0x070c0608, 0x02040d09, 0x03040511, 0x0e220d07,
	0x0b021108, 0x143a1806, 0x07051807, 0x37060712, 0x0105030a, 0x08040904, 0x190d0811, 0x0308050c, 0x08010e04, 0x1009080c, 0x02030109, 0x07060f08,
	0x1704070d, 0x0f1d0f0d, 0x02022408, 0x13060721, 0x05080404, 0x05060e0b, 0x6009040b, 0x06250b0d, 0x0102040c, 0x0d0c0c17, 0x06010509, 0x06254a25,
	0x04040419, 0x01010b07, 0x010b0401, 0x04081e06, 0xf9820603, 0x4316412e, 0x43868687, 0x0402a0f8, 0x356b3502, 0x0332da82, 0x0905020c, 0x0d1c1104,
	0x11081608, 0xb4021021, 0xb05e3503, 0x1d200805, 0x08030b04, 0x0c0b2008, 0x24100727, 0x126a020f, 0x07204020, 0x01102b36, 0x0308020a, 0x08040603,
	0x2b08aa82, 0x0a0d0406, 0x07418141, 0x0905060f, 0x082d0a0a, 0x02022f06, 0x0d030506, 0x04030706, 0x02050203, 0x03070106, 0x0c020101, 0x02030a02,
	0x032b0782, 0x01070309, 0x0a110906, 0x82070104, 0x20112c3f, 0x21422110, 0x09102010, 0x82110812, 0x030421e4, 0x052d5382, 0x41071008, 0x10144084,
	0x0a19010e, 0x2529820c, 0x07070201, 0x1582080f, 0x16072a08, 0x05140505, 0x02050a03, 0x20101d07, 0x0d230d0e, 0x090b0a0b, 0x0d050509, 0x0308030a,
	0x01030104, 0x01020506, 0x110a0c07, 0x2b5f8202, 0x48250505, 0x0202021e, 0x0a02030d, 0x08321882, 0x0d0c2a07, 0x240d0c27, 0x0945120e, 0x0d070206,
	0xa2840601, 0x0d061134, 0x10040504, 0x04050802, 0x04020702, 0x040c0204, 0x4e820720, 0x050e142f, 0x020a0504, 0x02010702, 0x0d0a0601, 0x245c8202,
	0x03030201, 0x3b618203, 0x0b05040b, 0x0a090205, 0x07060108, 0x0c0b0908, 0x05160d07, 0x03220f02, 0x010b0b03, 0x0b2d4582, 0x09100804, 0x0e081108,
	0x02040204, 0x2303820a, 0x0e03030b, 0x0124b483, 0x0904010b, 0x07291482, 0x08060109, 0x041e0b0c, 0x085b8249, 0x07190930, 0x0d080308, 0x0d0d0d1b,
	0x060b070a, 0x000d180c, 0x00020000, 0x0a580053, 0x01260333, 0x008d0180, 0x36320100, 0x33011e17, 0x16171432, 0x2a433336, 0x011e2208, 0x05a75015,
	0x580a1f4b, 0x29820851, 0x013e3729, 0x37363437, 0x7e331634, 0x1425054a, 0x32161706, 0x82028233, 0x16322117, 0x25061b4d, 0x0e07011e, 0x82552301,
	0x06072107, 0x36252c82, 0x15061617, 0x054f5114, 0x1d820620, 0x26220722, 0x06200583, 0x27201183, 0x14212f82, 0x055a5906, 0x8206424b, 0x16142186,
	0x2406b251, 0x2e352622, 0x050c5601, 0x16141722, 0x17214d82, 0x23418314, 0x27262223, 0x8307ce48, 0x85718217, 0x012e224d, 0x07f04307, 0x60443882,
	0x08107905, 0x35452982, 0x22232305, 0x3e852306, 0x7a832220, 0x51085945, 0xf28b051d, 0x3e443320, 0x013e2108, 0x08b58f18, 0x09af9218, 0x59263221,
	0x33250809, 0x3a170616, 0x06254101, 0x4c0bde44, 0x2d6307c7, 0x3e372205, 0x25f28201, 0x012a0117, 0x737f2207, 0x363f0805, 0x09f30527, 0x05030715,
	0x05020403, 0x100a0408, 0x09100908, 0x05031704, 0x02010105, 0x200d1003, 0x2b16203f, 0x051c0616, 0x08080106, 0x1d0e0911, 0x070f070f, 0x0202060e,
	0x01020111, 0x82030518, 0x17022b05, 0x060c0603, 0x1c438442, 0x1c821d3a, 0x02093008, 0x06030202, 0x3c061105, 0x542a3c78, 0x08100929, 0x07070106,
	0x01110617, 0x0b080315, 0x22442109, 0x03162a16, 0x0a040214, 0x09150c08, 0x82090c07, 0x04240842, 0x05080510, 0x0c070e06, 0x5c2f0b17, 0x01030b2e,
	0x20442009, 0x0c122513, 0x01010116, 0x01100703, 0x04060705, 0x87080982, 0x170b2306, 0x0e06152a, 0x03080406, 0x08010601, 0x0a110102, 0x090d1e0e,
	0x16090811, 0x0f1d1109, 0x02050a05, 0x0b030109, 0x3e050e04, 0x3e1f3e7d, 0x1328141e, 0x05013316, 0x010c0304, 0x0c040801, 0x592d0c1a, 0x1225122d,
	0x10081508, 0x040c0305, 0x0c050515, 0x254c2506, 0x0e0b1d0d, 0x13081217, 0x3a7b3f08, 0x191a3118, 0x20111832, 0x06110110, 0x0f10260e, 0x020a0f1d,
	0x12231204, 0x06132513, 0x11080103, 0x0a140a08, 0x02277b82, 0x1e100505, 0x823b1f0f, 0x100f2903, 0x10020c22, 0x080e0803, 0x08212682, 0x3bc98210,
	0x07030503, 0x06071607, 0x0e020306, 0x09170d01, 0x130ac8fe, 0x04180d0a, 0x140e2104, 0x11208c82, 0x0321b983, 0x23008201, 0x01040508, 0x032b5482,
	0x09061905, 0x25090912, 0x82030301, 0x03023caa, 0x03070302, 0x02010202, 0x170f0c0e, 0x080f080f, 0x04380104, 0x03091309, 0x8204020d, 0x83012035,
	0x08113105, 0x04060d08, 0x02030302, 0x03030d01, 0x030e2508, 0x05221683, 0x21820101, 0x10070230, 0x08090604, 0x0a040507, 0x140d0a15, 0x16820103,
	0x4e292208, 0x02770629, 0x0f030304, 0x05478f48, 0x0a05021a, 0x03120508, 0x06061102, 0x0f0a0514, 0x23120a05, 0x2aa48211, 0x06040b04, 0x14090608,
	0x82040a01, 0x0b042582, 0x19361802, 0x0538f382, 0x140b050d, 0x01080305, 0x03010904, 0x02020402, 0x11091b12, 0x070e0508, 0x0e820a82, 0x01020136,
	0x24080302, 0x12241210, 0x0e2a542a, 0x03020907, 0x050b0501, 0x0b291382, 0x0202051b, 0x0a192202, 0x82f78212, 0x043222ad, 0x8208820d, 0x0c2523f6,
	0xca820a02, 0x032be482, 0x0c020201, 0x05021803, 0x82070409, 0x030325f5, 0x05030301, 0x07320382, 0x14070913, 0x090b0106, 0x01016efe, 0x1e031314,
	0x0082000e, 0x56000230, 0xcb042300, 0x0d005b03, 0x00008d00, 0xff7e2301, 0x16322606, 0x25013e37, 0x08664c17, 0x15262222, 0x2707c743, 0x35012e07,
	0x012b010e, 0x22079055, 0x5e261417, 0x591808fc, 0x36270c8c, 0x36262726, 0x82263435, 0x44372049, 0x1f300797, 0x33163601, 0x2e173632, 0x36343701,
	0x013e1737, 0x20054b4c, 0x0a394c17, 0x011e1723, 0x262e8215, 0x02171636, 0x82085459, 0x15f30800, 0x0f07112f, 0x03085302, 0x3505060f, 0x10240e13,
	0x13028a0c, 0x1e1d3c1d, 0x05051d39, 0x75091208, 0x0e060c11, 0x0a0d0710, 0x08091e07, 0x2e17080f, 0x12241217, 0x09073415, 0x0d070713, 0x0b1e0c07,
	0x0b0d2e02, 0x06060204, 0x2f0c0e22, 0x10200e08, 0x06224221, 0x21244722, 0x01012042, 0x140a0a01, 0x18040d04, 0x1508161c, 0x09100808, 0x0c152c15,
	0x17090a13, 0x15030408, 0x100d1222, 0x083e020d, 0x09083008, 0x3c070f01, 0x572c04b8, 0x050f162c, 0x0e020d04, 0x0502410b, 0x0b040602, 0x280e0f06,
	0x1e3b1c0d, 0x10365f35, 0x02010107, 0x050a0501, 0x05050a03, 0x451c190e, 0x1c371c1c, 0x1b316232, 0x340f121e, 0x13301411, 0x020b1b12, 0x06060a02,
	0x05010401, 0x0102090e, 0x04050308, 0x04020604, 0x02011a05, 0x08030806, 0x01010701, 0x0903040c, 0x82010307, 0x03320810, 0x03090c06, 0x00000502,
	0x00540001, 0x0380015a, 0x00440026, 0x2e351300, 0x36343501, 0x1733013f, 0x26270711, 0x013e3736, 0x2711013f, 0x23150715, 0x03883315, 0x1415172e,
	0x22012b06, 0x37013d26, 0x23353335, 0x27200388, 0x3b2d3a82, 0x0d953701, 0x1705050e, 0x1135697c, 0x25828203, 0x2e10090e, 0x00840b1b, 0x08071b27,
	0x1a0808c9, 0x0800840c, 0x08081a2f, 0xc902220f, 0x0b0d022d, 0x03020a07, 0x1a9dfea8, 0x040a0503, 0x08050904, 0x351a3d01, 0x38363519, 0x34363936,
	0x0708272e, 0x2e270807, 0x270c8234, 0x19353638, 0x1e080749, 0x5824b382, 0x73025800, 0xa620b382, 0x9546c082, 0x0607260a, 0x16141516, 0x058a5307,
	0x3621be82, 0x21928226, 0x41183427, 0x63450afc, 0x06262305, 0x88682227, 0x1e172206, 0x0bd74601, 0x5208b557, 0xcb4e0e52, 0x16362809, 0x23343637,
	0x46353622, 0x3e210511, 0x4a1a8501, 0x352008c0, 0x32207483, 0x15225382, 0x20460614, 0x31780809, 0x1503fd01, 0x08110b07, 0x09090f07, 0x06030107,
	0x06010202, 0x010f0407, 0x03010d02, 0x07010103, 0x0506020b, 0x0c050104, 0x09040a0e, 0x04020405, 0x08091909, 0x0204061b, 0x0e060802, 0x0a150b06,
	0x100d1b13, 0x0708070b, 0x17210403, 0x142a591d, 0x2412152c, 0x0a120c12, 0x07050907, 0x1415050c, 0x14120101, 0x1010130a, 0x1e0a1021, 0x080a0202,
	0x0a160a03, 0x03010404, 0x5c086782, 0x070c0302, 0x19090909, 0x24031a33, 0x03100101, 0x03040708, 0x06020602, 0x0a0a0404, 0x1196020e, 0x2a130f1e,
	0x0e201014, 0x2f101d0f, 0x2c162e5d, 0x02090716, 0x08050101, 0x11080506, 0x19321a07, 0x072a552c, 0x0d040411, 0x0f1d0b03, 0x04060c06, 0x0205030b,
	0x03060201, 0x16070515, 0x2e298304, 0x0e100502, 0x1814260f, 0x49241a2b, 0x8219241c, 0x06062577, 0x0f04060b, 0x05382a82, 0x25080906, 0x40202a4e,
	0x06120d19, 0x03060906, 0x29070d05, 0x04010a83, 0x032fee82, 0x03030305, 0x09050704, 0x0b050201, 0x82010505, 0x030522b4, 0x39198203, 0x2b100712,
	0x0000000f, 0x00540003, 0x03a30158, 0x00860026, 0x00cb00a9, 0xcd5c0100, 0x012e2405, 0x59342627, 0x471809bf, 0x362c0811, 0x36262706, 0x23222627,
	0x3607010e, 0x2906334d, 0x33010e07, 0x1c15013a, 0x54531501, 0x17012206, 0x200e821c, 0x20118403, 0x06854716, 0x55050a5d, 0x4e4205d1, 0x0a554c08,
	0x16141522, 0x20058e4c, 0x20238235, 0x424b8407, 0x27200528, 0x22218a82, 0x56158336, 0x30240869, 0x11151415, 0x2620228e, 0x1d82228d, 0x01a2012b,
	0x03070203, 0x02010703, 0x08048204, 0x0403082f, 0x04010603, 0x06010408, 0x01020102, 0x05010901, 0x3502040b, 0x0c1a0c06, 0x09040d05, 0x1802030b,
	0x09051706, 0x07210a32, 0x0e2a5029, 0x261c821f, 0x04040606, 0x82020306, 0x06053f29, 0x02040701, 0x45010702, 0x23110d04, 0x08120712, 0x061e3b1d,
	0x1f3e1f01, 0x100d1f0d, 0x1595101e, 0x1ca40130, 0x1e0e1b37, 0x070a090c, 0x02060804, 0x68820108, 0x0819072e, 0x03041003, 0x140b030d, 0x0402060a,
	0x4c081482, 0x07110201, 0x02020309, 0x0a012903, 0x0b070a14, 0x01030409, 0x17150501, 0x5e2f162d, 0x0b2f5e5e, 0x0e070b17, 0x09031102, 0x03080b02,
	0x150b0401, 0x2c592c0b, 0x04499149, 0x0b05040c, 0x030b0305, 0x370c230b, 0x371b376e, 0x0705041b, 0x2dd88207, 0x370a1105, 0x0599366d, 0x020d060b,
	0x4c820202, 0x072f3582, 0x07060704, 0x0603060d, 0x02060203, 0x83010401, 0x82312000, 0x030c2121, 0x10832182, 0x04070424, 0x22820601, 0x06040722,
	0x08050b4b, 0x0201023c, 0x00000001, 0x00570002, 0x0361023e, 0x004d0040, 0x01000074, 0x16171606, 0x0e010f06, 0x023f0701, 0x012e012f, 0x010f012f,
	0x2e270733, 0x36013f01, 0x1e172734, 0x37021f01, 0x19832636, 0x36343722, 0x20093546, 0x08645b02, 0x83011e21, 0x0f012324, 0x3e853702, 0x15330724,
	0x4e82020f, 0x59820320, 0x30081b84, 0x013f1617, 0x37013e13, 0x023f013e, 0x03024e02, 0x05020304, 0x0a110622, 0x07240509, 0x060e0719, 0x040a2216,
	0x01050d17, 0x04040c03, 0x030a060c, 0x34818204, 0x03170707, 0x05050103, 0x04090901, 0x09071217, 0x030c0802, 0x08d98206, 0x0207063b, 0x0b0d0109,
	0x01020e0c, 0x1f390b08, 0x0c071605, 0x011f0f06, 0x181f1353, 0x02b6081f, 0x18090706, 0x101e0e0f, 0xb60a0b11, 0x03030b08, 0x05440205, 0x09048602,
	0x080f0505, 0x08458228, 0x32011036, 0x07051812, 0x0e2f0202, 0x170e1b1c, 0x14071709, 0x0c03050d, 0x220b1c08, 0x1d0b1105, 0x12111605, 0x130b0516,
	0x06090409, 0x16060902, 0x02020510, 0x0a0a0c02, 0x102b9d82, 0x0b150b0b, 0x4f111915, 0x82130e2b, 0x015b0840, 0x0c65062b, 0x0c160b0f, 0x120600ff,
	0x0a180e0c, 0x04050e0b, 0x00010302, 0x1b19250c, 0x016f031c, 0x61000400, 0x1d035a00, 0x12008c03, 0x38002500, 0x00007d00, 0x27071713, 0x07352315,
	0x37273727, 0x15333517, 0x13071737, 0x35072737, 0x07271523, 0x37170717, 0x17353315, 0x92052737, 0x23072612, 0x011d0622, 0x0a4f4617, 0x0715232c,
	0x3b161415, 0x3d363201, 0x4f462701, 0x3533250a, 0x11173537, 0x25056843, 0x1137011f, 0x0b822327, 0x17382982, 0x132eda15, 0x1230252d, 0x2e142f2f,
	0x2d122d25, 0x3516374e, 0x3816382d, 0x2d250282, 0x01371635, 0x201382c7, 0x2a228225, 0x252f122d, 0xfe2e132d, 0x461021a9, 0xc9220b77, 0x91460708,
	0x2e3a0807, 0x040e0910, 0x11030305, 0x177c6935, 0x0d0e0505, 0x201a0002, 0x1b35341a, 0x211b1a20, 0x1a35361b, 0x27011b21, 0x3e1f2620, 0x20262140,
	0x40202620, 0x20261e3e, 0x1a211b2b, 0x1f823635, 0x1b201a24, 0x2f823435, 0x081e3324, 0xb1464907, 0x08072309, 0xb1460708, 0x35290809, 0x08c3fe1a,
	0x04040905, 0x1a03050a, 0x03a86301, 0x0c070a02, 0x002d020c, 0x00030000, 0x01580051, 0x002603a1, 0x00a20086, 0x08cb46c4, 0x46141621, 0x56180638,
	0xe1500725, 0x0e07250b, 0x26222301, 0x45064652, 0x2e22080f, 0x02822701, 0x52011c21, 0x26200710, 0x20089f44, 0x21238235, 0x0583033c, 0x37362624,
	0x3886013e, 0x23223423, 0x09536f22, 0x013e0725, 0x52013a37, 0x39820658, 0x2d827e83, 0x82160621, 0x16072108, 0x26202782, 0x37275d82, 0x1307010e,
	0x82013d34, 0x890e2006, 0x4433206d, 0x5b8208f8, 0x013c5008, 0x034d0135, 0x05020309, 0x07040304, 0x03030801, 0x02010703, 0x03020803, 0x02070101,
	0x01060403, 0x01040406, 0x0503020a, 0x05070404, 0x1f0c0303, 0x2a4f2a0e, 0x320b2106, 0x0716050a, 0x0b030219, 0x040d0509, 0x050d190d, 0x0b030135,
	0x82080106, 0x01aa083c, 0x208a0602, 0x2201011e, 0x1e03222f, 0x060c0e06, 0x21150e25, 0x0e0c0403, 0x0f213617, 0x0f970f1e, 0x1e0e0f1f, 0x1f3e1f0e,
	0x1e3b1d06, 0x11081108, 0x040c1223, 0x140a1203, 0x030d030b, 0x08031004, 0x0d040719, 0x02080105, 0x07040806, 0x1e0c090a, 0x1c371b0e, 0x0a376d36,
	0x01010511, 0x05070702, 0x1b371b04, 0x0c376e37, 0x0b030b23, 0x050b0503, 0x49040c04, 0x592c4991, 0x0b150b2c, 0x08030104, 0x0309020b, 0x080d0211,
	0x2f0b170b, 0x2f5e5e5e, 0x15172d16, 0x03010105, 0x070b0904, 0x010a140a, 0x02020329, 0x11070903, 0x64820102, 0x02042108, 0x551cd406, 0x034c2829,
	0x11165515, 0x2f060d20, 0x0e370809, 0x22142f19, 0x180c285a, 0x01cdfe0c, 0x04200082, 0x022ad382, 0x06030603, 0x0706070d, 0x64820704, 0x02274d82,
	0x060d0202, 0x8200050b, 0x10400800, 0xc0005e00, 0xc0028f03, 0x2d001000, 0x51003f00, 0x70006100, 0x8c007d00, 0xa7009b00, 0xc100b900, 0xdd00cf00,
	0x0c01e900, 0x34010000, 0x22212326, 0x15010f06, 0x3221011f, 0x37013d36, 0x1115011e, 0x3b05fa4e, 0x27262221, 0x1135012e, 0x3e373634, 0x32213301,
	0x27071716, 0x33351737, 0x07173707, 0x17250a82, 0x2f073523, 0x43098701, 0x1b8206c8, 0x23012f2e, 0x0e070622, 0x1f011d01, 0x023f3301, 0x01210988,
	0x22198235, 0x8423022f, 0x3f33266b, 0x27373501, 0x211c8a23, 0x0e8d1727, 0x89273521, 0x90272029, 0x3f072365, 0x48823301, 0x82172321, 0x8250886b,
	0x240b825f, 0x3b011e17, 0x315e8201, 0x33150527, 0x33353315, 0x23352335, 0x011f2707, 0x154c2f37, 0x14152205, 0x82228216, 0x07272180, 0x5405167e,
	0x333d05c2, 0x08074a03, 0x0503cefe, 0x0a060602, 0x07083201, 0x0606053a, 0x0b110605, 0x10092afd, 0x08008407, 0x02091041, 0x07100bd6, 0x0d040bd1,
	0x040d020a, 0x0d040e0e, 0x040d0a02, 0x050d0d13, 0x0b0b030e, 0x060d0d06, 0x0e030b0b, 0x270a0306, 0x02010403, 0x27080402, 0x0823030a, 0x08050203,
	0x03030829, 0x82232908, 0x04082119, 0x54201684, 0x18861283, 0x260a5726, 0x0402020a, 0x04200582, 0xee250489, 0x0f030d0d, 0x205e8203, 0x236e830b,
	0x0cee0f03, 0x01244882, 0x0226e42d, 0x0922a183, 0x2b830a26, 0x06060922, 0x0b830e82, 0xe4fe4708, 0x1b1b2e5b, 0x10314e3b, 0x1311080b, 0x0a0c2217,
	0x0b0a0b0b, 0x1319131e, 0x080f0e05, 0x0707060f, 0x10050606, 0x087a020a, 0x0b020207, 0x07030bc4, 0x0738c407, 0x5efe0a11, 0x07070f09, 0x07070808,
	0xa201090f, 0xe884110a, 0x05829d20, 0x820d0d21, 0x08072704, 0x070e0e07, 0x21820e08, 0x12830884, 0xfe271882, 0x03030608, 0x82030401, 0x0a0326de,
	0x05010635, 0x25098402, 0x4e060827, 0xe383030a, 0x83060621, 0x030321fa, 0x08201882, 0x5e220b84, 0x2f870606, 0x5e082722, 0x9b202388, 0xac28588e,
	0x14151514, 0x0303162e, 0x0a233e84, 0x83610827, 0x0303214d, 0x46334e83, 0x24313120, 0x022a7f7b, 0x01042302, 0x1c0b0c0c, 0x821e1312, 0x040322e3,
	0x23d98226, 0x090b1005, 0x0037e483, 0x00620003, 0x0389023e, 0x003b0040, 0x0091006a, 0x16060100, 0x4b141617, 0xa04b0897, 0x2703250d, 0x1e373626,
	0x4e06824b, 0x3722080a, 0x0b823632, 0x16071724, 0x486d020e, 0x842e200c, 0x36342328, 0xf8493637, 0x45342008, 0x2e820569, 0x012e2722, 0x20052952,
	0x4a708227, 0x49840804, 0x033e3722, 0x53081a83, 0x02232606, 0x01050183, 0x0a020101, 0x26360f09, 0x0a0b130a, 0x16090c18, 0x070a060a, 0x2e0c1e0f,
	0x0620354a, 0x19080404, 0x2c1b1f35, 0x09120b15, 0x15030509, 0x2a132230, 0x0d1c0e15, 0x5e0a110a, 0x2f190705, 0x0b150924, 0x10061006, 0x36300e1d,
	0x02040309, 0x6e084c82, 0x12030101, 0x15391b03, 0x0609120a, 0x0d160808, 0x0c172515, 0x4f320716, 0x11200d1d, 0x092f5a28, 0x4714120a, 0x0e1a0d34,
	0x02070e07, 0x1d0f0105, 0x2849370d, 0x150b060b, 0x0a17090a, 0x2111cc02, 0x15291511, 0x3b254b26, 0x1a0c3072, 0x0b140b0c, 0x05070d09, 0x1c060307,
	0x6c60290a, 0x66313e74, 0x03141031, 0x09111b04, 0x170a0b14, 0x823c200c, 0x013108b4, 0x05050508, 0x67336408, 0x0a275962, 0x0c040713, 0x0e180b04,
	0x19447931, 0x0d071a33, 0x010a0107, 0x0a010c01, 0x120a120f, 0x0c05080a, 0x0e08170d, 0x08118206, 0x38033833, 0x0c1e1127, 0x4316121d, 0x81474188,
	0x0a170c35, 0x05050a06, 0x0c150b01, 0x948c7e33, 0x03060348, 0x00000103, 0x00660004, 0x03900240, 0x00290040, 0x270b8247, 0x01000084, 0x070f0616,
	0x29054f4d, 0x3f35012f, 0x011e1701, 0x0482053f, 0x3616172d, 0x1517023f, 0x27012e07, 0x820e030f, 0x83198304, 0x063f2d17, 0x1f072735, 0x2f050f01,
	0x33373504, 0x04202d82, 0x1f2e0482, 0x33013f01, 0x3733070f, 0x061f3733, 0xdf681f33, 0x23010906, 0x09870207, 0x36261209, 0x0d242f36, 0x5c3a0907,
	0x0b251922, 0x1207050c, 0x321c371a, 0x0c0b1826, 0x2a4a200d, 0x0b172a14, 0x2d700509, 0x07052250, 0x4e252a1f, 0x0b020228, 0x1e18230a, 0x22163654,
	0x24362626, 0x11550214, 0x221b1203, 0x4c1d1f24, 0x06101f34, 0x2a150204, 0x101b2416, 0x1a0c0304, 0x1d2b310d, 0x1435ce04, 0x07040e12, 0x1b0b0902,
	0x14150f12, 0x0b07050f, 0x1b14144c, 0x0e180b1b, 0x52c50236, 0x5e694395, 0x0c162d41, 0x62280504, 0x3a692d3b, 0x2834495c, 0x0709100b, 0x0e1d1f19,
	0x35311b1f, 0x0b0a0103, 0x0912050b, 0x2f300124, 0x1d220706, 0x21120516, 0x65387d2d, 0x235b372d, 0x34261b0f, 0x2aba6359, 0x74380b26, 0x2b384a5c,
	0x4541161d, 0x553e4146, 0x07070d10, 0x09141911, 0x14081b13, 0x10380d03, 0x07261d14, 0x02030306, 0x060c0902, 0x05020502, 0x44320b04, 0x02090910,
	0x33008200, 0x00590004, 0x037d0359, 0x00c40026, 0x00e400d4, 0x010000f7, 0x2705a247, 0x2627012e, 0x010e0722, 0x22051a63, 0x43012e27, 0xf442050f,
	0x14152505, 0x32161716, 0x17821182, 0x43182720, 0x1c200e7b, 0x2109bf66, 0x3f4f0623, 0x0e716110, 0x36373022, 0x820b526e, 0x05134f54, 0x82363721,
	0x223c87b3, 0x66333626, 0x698e05e1, 0x8f630e85, 0x16362105, 0x2309314f, 0x25070616, 0x07216784, 0x22158622, 0x4f262737, 0x4c420651, 0x37272105,
	0x4b081f84, 0x33142227, 0x1e333216, 0x26323301, 0x05700327, 0x150a070e, 0x24432008, 0x1b152715, 0x1a0f1b35, 0x050b050e, 0x02020504, 0x02060304,
	0x03060204, 0x031a1203, 0x01030502, 0x08050205, 0x02070304, 0x0a050502, 0x1a0b1822, 0x0114060d, 0x012e0c82, 0x03060101, 0x0b060407, 0x0d1b0f05,
	0x0b83432f, 0x03070137, 0x07040804, 0x1a0d0b14, 0x070e090d, 0x031c391c, 0x02020204, 0x2b458201, 0x120e1c0e, 0x090d1325, 0x04110102, 0x62823d82,
	0x05343882, 0x2a150309, 0x03050315, 0x02050d06, 0x0e070106, 0x11221007, 0x02258582, 0x11090108, 0x084a8209, 0x05100435, 0x0e0e1b0e, 0x361b0e1e,
	0x152d151b, 0x0c0b180b, 0x28160d1a, 0x0c010715, 0x09047efe, 0x050e0508, 0x04040406, 0x11040508, 0x02053805, 0x06120503, 0x82030e03, 0x05032e47,
	0x06034403, 0x080f0704, 0x08020404, 0x2d078202, 0x01010103, 0x010503e3, 0x13051001, 0x0782081e, 0x01288a82, 0x01040206, 0x03030301, 0x032bb782,
	0x05080505, 0x05061305, 0x82010312, 0x020232fd, 0x190c0306, 0x1326130d, 0x0d1b4023, 0x0d040a16, 0x21a48209, 0x58820403, 0x0401022f, 0x09020701,
	0x70280b15, 0x1c381d3e, 0x24668206, 0x190a070e, 0x30b88205, 0x17060d03, 0x0402172e, 0x01050603, 0x0a060102, 0x228a8206, 0x820f0605, 0x02072f6e,
	0x07040704, 0x03020206, 0x1c381c04, 0x01820803, 0x04020424, 0xd282050a, 0x0308042c, 0x0c010202, 0x0a050c19, 0x7c820404, 0x3d830e82, 0x02010125,
	0x83050305, 0x1f0b2d41, 0x061f080e, 0x0304080a, 0x0c020702, 0x01241782, 0x06030701, 0x05250382, 0x02030308, 0x24588209, 0x1a010302, 0x22e08202,
	0x820e0103, 0x0834081e, 0x00000001, 0xff000006, 0x030004c0, 0x001700c0, 0x0027001f, 0x0037002f, 0x0100003f, 0x010e2315, 0x35231507, 0x2327012e,
	0x013e3335, 0x15333537, 0x2317011e, 0x07830f82, 0x36320628, 0x06222634, 0x25821114, 0x07201d83, 0x2b831b82, 0x29821720, 0x042a3983, 0xc0156500,
	0xc0868086, 0x08876515, 0x75138234, 0x0e3e2951, 0x262634cf, 0x75512634, 0x3e0e6413, 0x1385d929, 0x0e86f520, 0x8c000221, 0x863a8431, 0x8280201a,
	0x34262334, 0x308d3301, 0xc7823f86, 0xc7880a20, 0x0d000732, 0x25001900, 0x3d003100, 0x55004900, 0x6d006100, 0x32241f82, 0x22061416, 0xb7834082,
	0x32022325, 0x83011d16, 0x013d250f, 0x26221234, 0x36200582, 0x01201184, 0x2b212583, 0x24278201, 0x14043336, 0x24098506, 0x0132013b, 0x273d8317,
	0x3426012f, 0x27013236, 0x1f210583, 0x20118301, 0x21528325, 0x3c82013f, 0x84071421, 0x010f2105, 0x37241183, 0x96d49601, 0x01260282, 0x5e5e4200,
	0xf0841a42, 0x05845a20, 0x1a800126, 0x401a2626, 0xfd210483, 0x2e088640, 0xa3021a40, 0x3526132d, 0x25122e12, 0x8899fd35, 0x6702240a, 0x82253513,
	0x26352414, 0x8859fd13, 0xc002210a, 0xfe265b84, 0x5e845ef6, 0x428920fe, 0x0a88a620, 0x26dafe22, 0x05856b84, 0x2edefe23, 0x20418212, 0x2140822d,
	0x0a88b201, 0x6a821220, 0x69841320, 0x880efe21, 0x0100300a, 0xbfff0000, 0xc0030104, 0x00001f00, 0x82011e25, 0x27262ccd, 0x22230601, 0x37343526,
	0x82321617, 0x342908e9, 0x3336012f, 0x14151632, 0x14eb0307, 0x13651302, 0x75fe1133, 0xa977483f, 0x3612a70c, 0x12126612, 0x772b29a7, 0x118e22a9,
	0x2a1b8233, 0xcd011402, 0x2b77a922, 0x8212a729, 0x12362a1a, 0x77a90ca7, 0x00003f48, 0x06ab4104, 0x2700c128, 0x7f002f00, 0x6d828700, 0x1f162608,
	0x06071501, 0x27071707, 0x23010f06, 0x07272627, 0x2f263727, 0x36373501, 0x17372737, 0x33013f36, 0x37171617, 0x07774217, 0x2b860120, 0x358e3084,
	0x3f8e3a84, 0x498c4484, 0x4e830720, 0x1f230486, 0x42320401, 0x013405cf, 0x4605096c, 0x29090546, 0x12103a2d, 0x120c400c, 0x292d3a10, 0xc4421291,
	0x60033305, 0x39030243, 0x08064318, 0x0a382d27, 0x253b0e0a, 0x33820c0c, 0x250b0d31, 0x0a0a0e3b, 0x07272e38, 0x3a194306, 0x82430203, 0x193a2926,
	0x27070643, 0x0b09382e, 0x0929268c, 0x272d380b, 0x18430707, 0x27268239, 0x517466fe, 0xee517451, 0x8c88799b, 0x3426c828, 0x01342626, 0x6e9c0cba,
	0x268795a6, 0x7e82ab20, 0x00745122, 0x0e220084, 0xb118ae00, 0x01200c55, 0x01241584, 0x19000a00, 0x02241786, 0x34000700, 0x03240b86, 0x88002500,
	0x04200b86, 0xc4202382, 0x05240b86, 0xe7000b00, 0x062a0b86, 0x09010a00, 0x01000300, 0x4b840904, 0x0b860020, 0x14000122, 0x17850982, 0x0e000224,
	0x17862400, 0x4a000324, 0x0b863c00, 0x23820420, 0x0b86ae20, 0x16000524, 0x0b86cf00, 0x17820620, 0x4d83f320, 0x6e007528, 0x65006400, 0x03826600,
	0x74006122, 0x642b0582, 0x6e750000, 0x65666564, 0x82657461, 0x0052340b, 0x00670065, 0x006c0075, 0x00720061, 0x67655200, 0x82616c75, 0x00462208,
	0x213a826f, 0x07830074, 0x21827220, 0x20006528, 0x2e003200, 0x07823000, 0x03823a20, 0x20215893, 0x23198300, 0x002d0033, 0x32200383, 0x31342b82,
	0x00003700, 0x746e6f46, 0x67726f46, 0x2e322065, 0x203a2030, 0x0c827e89, 0x332d3326, 0x3130322d, 0x51932682, 0x5620aa8c, 0x7224aa82, 0x69007300,
	0x20229a84, 0x8e823100, 0x0000312c, 0x73726556, 0x206e6f69, 0x0c822e31, 0x002344a0, 0x9d000200, 0x41300800, 0x02010000, 0x03010200, 0x13000300,
	0x15001400, 0x17001600, 0x19001800, 0x1b001a00, 0x24001c00, 0x26002500, 0x28002700, 0x2a002900, 0x2c002b00, 0x2e22ef82, 0xed842f00, 0x33003228,
	0x35003400, 0xf7823600, 0x00384808, 0x003a0039, 0x003c003b, 0x003e003d, 0x00440040, 0x00460045, 0x00480047, 0x004a0049, 0x004c004b, 0x004e004d,
	0x0050004f, 0x00520051, 0x00540053, 0x00560055, 0x00580057, 0x6c670659, 0x31687079, 0x696e7507, 0x82303030, 0x000128d6, 0x00ffff01, 0x8201000f,
	0x820c20ba, 0x00162203, 0x82c7821e, 0x22578215, 0x82040001, 0x00022211, 0x201d8400, 0x83078201, 0x23078402, 0x3f5719d4, 0xd22b0c83, 0x00caedeb,
	0xd4000000, 0x05832ede, 0xc7e185fa, 0x000000da,
};


```

`src/render/menu.cpp`:

```cpp
#include "render.h"

#include "../settings/globals.h"
#include "../settings/options.hpp"

#include "../helpers/input.h"
#include "../helpers/console.h"
#include "../helpers/notifies.h"
#include "../features/features.h"

#define VERSION "1.17"

static const char* const KeyNames[] = {
	"Unknown",
	"LBUTTON",
	"RBUTTON",
	"VK_CANCEL",
	"MBUTTON",
	"MOUSE4",
	"MOUSE5",
	"Unknown",
	"BACKSPACE",
	"TAB",
	"Unknown",
	"Unknown",
	"VK_CLEAR",
	"RETURN",
	"Unknown",
	"Unknown",
	"SHIFT",
	"CTRL",
	"ALT",
	"VK_PAUSE",
	"CAPSLOCK",
	"VK_KANA",
	"Unknown",
	"VK_JUNJA",
	"VK_FINAL",
	"VK_KANJI",
	"Unknown",
	"ESCAPE",
	"VK_CONVERT",
	"VK_NONCONVERT",
	"VK_ACCEPT",
	"VK_MODECHANGE",
	"SPACE",
	"VK_PRIOR",
	"NEXT",
	"END",
	"HOME",
	"LEFT",
	"UP",
	"RIGHT",
	"DOWN",
	"VK_SELECT",
	"VK_PRINT",
	"VK_EXECUTE",
	"VK_SNAPSHOT",
	"INSERT",
	"DELETE",
	"VK_HELP",
	"0",
	"1",
	"2",
	"3",
	"4",
	"5",
	"6",
	"7",
	"8",
	"9",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"A",
	"B",
	"C",
	"D",
	"E",
	"F",
	"G",
	"H",
	"I",
	"J",
	"K",
	"L",
	"M",
	"N",
	"O",
	"P",
	"Q",
	"R",
	"S",
	"T",
	"U",
	"V",
	"W",
	"X",
	"Y",
	"Z",
	"VK_LWIN",
	"VK_RWIN",
	"VK_APPS",
	"Unknown",
	"VK_SLEEP",
	"NUMPAD 0",
	"NUMPAD 1",
	"NUMPAD 2",
	"NUMPAD 3",
	"NUMPAD 4",
	"NUMPAD 5",
	"NUMPAD 6",
	"NUMPAD 7",
	"NUMPAD 8",
	"NUMPAD 9",
	"MULTIPLY",
	"ADD",
	"SEPARATOR",
	"SUBTRACT",
	"DECIMAL",
	"DIVIDE",
	"F1",
	"F2",
	"F3",
	"F4",
	"F5",
	"F6",
	"F7",
	"F8",
	"F9",
	"F10",
	"F11",
	"F12",
	"VK_F13",
	"VK_F14",
	"VK_F15",
	"VK_F16",
	"VK_F17",
	"VK_F18",
	"VK_F19",
	"VK_F20",
	"VK_F21",
	"VK_F22",
	"VK_F23",
	"VK_F24",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"NUMLOCK",
	"SCROLL",
	"VK_OEM_NEC_EQUAL",
	"VK_OEM_FJ_MASSHOU",
	"VK_OEM_FJ_TOUROKU",
	"VK_OEM_FJ_LOYA",
	"VK_OEM_FJ_ROYA",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"Unknown",
	"LSHIFT",
	"RSHIFT",
	"LCONTROL",
	"RCONTROL",
	"L-ALT",
	"R-ALT"
};

bool Hotkey(const char* label, int* k, const ImVec2& size_arg)
{
	ImGuiWindow* window = ImGui::GetCurrentWindow();
	if (window->SkipItems)
		return false;

	ImGuiContext& g = *GImGui;
	ImGuiIO& io = g.IO;
	const ImGuiStyle& style = g.Style;

	const ImGuiID id = window->GetID(label);
	const ImVec2 label_size = ImGui::CalcTextSize(label, nullptr, true);
	ImVec2 size = ImGui::CalcItemSize(size_arg, ImGui::CalcItemWidth(), label_size.y + style.FramePadding.y * 2.0f);
	const ImRect frame_bb(window->DC.CursorPos + ImVec2(label_size.x + style.ItemInnerSpacing.x, 0.0f), window->DC.CursorPos + size);
	const ImRect total_bb(window->DC.CursorPos, frame_bb.Max);

	ImGui::ItemSize(total_bb, style.FramePadding.y);
	if (!ImGui::ItemAdd(total_bb, id))
		return false;

	const bool focus_requested = ImGui::FocusableItemRegister(window, g.ActiveId == id, false);
	const bool focus_requested_by_code = focus_requested && (window->FocusIdxAllCounter == window->FocusIdxAllRequestCurrent);
	const bool focus_requested_by_tab = focus_requested && !focus_requested_by_code;

	const bool hovered = ImGui::ItemHoverable(frame_bb, id);

	if (hovered) {
		ImGui::SetHoveredID(id);
		g.MouseCursor = ImGuiMouseCursor_TextInput;
	}

	const bool user_clicked = hovered && io.MouseClicked[0];

	if (focus_requested || user_clicked) {
		if (g.ActiveId != id) {
			// Start edition
			memset(io.MouseDown, 0, sizeof(io.MouseDown));
			memset(io.KeysDown, 0, sizeof(io.KeysDown));
			*k = 0;
		}
		ImGui::SetActiveID(id, window);
		ImGui::FocusWindow(window);
	}
	else if (io.MouseClicked[0]) {
		// Release focus when we click outside
		if (g.ActiveId == id)
			ImGui::ClearActiveID();
	}

	bool value_changed = false;
	int key = *k;

	if (g.ActiveId == id) {
		for (auto i = 0; i < 5; i++) {
			if (io.MouseDown[i]) {
				switch (i) {
				case 0:
					key = VK_LBUTTON;
					break;
				case 1:
					key = VK_RBUTTON;
					break;
				case 2:
					key = VK_MBUTTON;
					break;
				case 3:
					key = VK_XBUTTON1;
					break;
				case 4:
					key = VK_XBUTTON2;
					break;
				}
				value_changed = true;
				ImGui::ClearActiveID();
			}
		}

		if (!value_changed)
		{
			for (int n = VK_BACK; n <= VK_RMENU; n++)
			{
				if (input_system::is_key_down(n)) //Originally used ImGui::IsKeyDown(n), but it wont catch some keys like LALT (VK_LMENU)
				{
					key = n;
					value_changed = true;
					ImGui::ClearActiveID();
				}
			}
		}

		if (ImGui::IsKeyPressed(io.KeyMap[ImGuiKey_Escape]))
		{
			*k = 0;
			ImGui::ClearActiveID();
		}
		else
			*k = key;
	}

	char buf_display[64] = "None";

	ImGui::GetWindowDrawList()->AddRect(frame_bb.Min, frame_bb.Max, ImGui::GetColorU32(ImGui::GetStyleColorVec4(ImGuiCol_ButtonOutline)));

	if (*k != 0 && g.ActiveId != id) {
		strcpy_s(buf_display, KeyNames[*k]);
	}
	else if (g.ActiveId == id) {
		strcpy_s(buf_display, "<Press a key>");
	}

	const ImRect clip_rect(frame_bb.Min.x, frame_bb.Min.y, frame_bb.Min.x + size.x, frame_bb.Min.y + size.y); // Not using frame_bb.Max because we have adjusted size
	ImVec2 render_pos = frame_bb.Min + style.FramePadding;

	ImGui::PushStyleColor(ImGuiCol_Text, ImGui::GetStyleColorVec4(ImGuiCol_Text));
	ImGui::RenderTextClipped(frame_bb.Min + style.FramePadding, frame_bb.Max - style.FramePadding, buf_display, nullptr, nullptr, style.ButtonTextAlign, &clip_rect);
	ImGui::PopStyleColor();
	
	if (label_size.x > 0)
		ImGui::RenderText(ImVec2(total_bb.Min.x, frame_bb.Min.y + style.FramePadding.y), label);

	return value_changed;
}

void bind_button(const char* label, int& key)
{
	render::columns(2);
	{
		ImGui::Text(label);

		ImGui::NextColumn();

		ImGui::PushItemWidth(-1);

		char buf[1024];
		sprintf_s(buf, "##binds.%s", label);

		Hotkey(buf, &key, ImVec2(0.f, 0.f));

		ImGui::PopItemWidth();
	}
	render::columns(1);
}

namespace render
{
	namespace menu
	{
		auto current_tab = 0;
		auto s_visible = false;
		float window_alpha = 0.f;
		const auto window_size = ImVec2(720.f, 585.f); //680, 460

		bool is_visible()
		{
			return s_visible;
		}

		void toggle()
		{
			s_visible = !s_visible;
		}

		std::map<int, weapon_type_t> get_weapons(bool need_knife)
		{
			std::map<int, weapon_type_t> k_item_names =
			{
				{ 63,{ "CZ75 Auto", WEAPONTYPE_PISTOL } },
				{ 1,{ "Desert Eagle", WEAPONTYPE_PISTOL } },
				{ 2,{ "Dual Berettas", WEAPONTYPE_PISTOL } },
				{ 3,{ "Five-SeveN", WEAPONTYPE_PISTOL } },
				{ 32,{ "P2000", WEAPONTYPE_PISTOL } },
				{ 36,{ "P250", WEAPONTYPE_PISTOL } },
				{ 61,{ "USP-S", WEAPONTYPE_PISTOL } },
				{ 30,{ "Tec-9", WEAPONTYPE_PISTOL } },
				{ 64,{ "R8 Revolver", WEAPONTYPE_PISTOL } },
				{ 4,{ "Glock-18", WEAPONTYPE_PISTOL } },

				{ 27,{ "MAG-7", WEAPONTYPE_SHOTGUN } },
				{ 35,{ "Nova", WEAPONTYPE_SHOTGUN } },
				{ 29,{ "Sawed-Off", WEAPONTYPE_SHOTGUN } },
				{ 25,{ "XM1014", WEAPONTYPE_SHOTGUN } },

				{ 24,{ "UMP-45", WEAPONTYPE_SUBMACHINEGUN } },
				{ 19,{ "P90", WEAPONTYPE_SUBMACHINEGUN } },
				{ 26,{ "PP-Bizon", WEAPONTYPE_SUBMACHINEGUN } },
				{ 17,{ "MAC-10", WEAPONTYPE_SUBMACHINEGUN } },
				{ 33,{ "MP7", WEAPONTYPE_SUBMACHINEGUN } },
				{ 34,{ "MP9", WEAPONTYPE_SUBMACHINEGUN } },
				{ WEAPON_MP5SD,{ "MP5-SD", WEAPONTYPE_SUBMACHINEGUN } },

				{ 14,{ "M249", WEAPONTYPE_MACHINEGUN } },
				{ 28,{ "Negev", WEAPONTYPE_MACHINEGUN } },

				{ 7,{ "AK-47", WEAPONTYPE_RIFLE } },
				{ 8,{ "AUG", WEAPONTYPE_RIFLE } },
				{ 13,{ "Galil AR", WEAPONTYPE_RIFLE } },
				{ 60,{ "M4A1-S", WEAPONTYPE_RIFLE } },
				{ 16,{ "M4A4", WEAPONTYPE_RIFLE } },
				{ 39,{ "SG 553", WEAPONTYPE_RIFLE } },
				{ 10,{ "FAMAS", WEAPONTYPE_RIFLE } },

				{ 9,{ "AWP", WEAPONTYPE_SNIPER_RIFLE } },
				{ 11,{ "G3SG1", WEAPONTYPE_SNIPER_RIFLE } },
				{ 38,{ "SCAR-20", WEAPONTYPE_SNIPER_RIFLE } },
				{ 40,{ "SSG 08", WEAPONTYPE_SNIPER_RIFLE } },
			};

			if (need_knife)
			{
				k_item_names[WEAPON_KNIFE_T] = { "T", -1 };
				k_item_names[WEAPON_KNIFE] = { "CT", -1 };

				k_item_names[GLOVE_T_SIDE] = { "T", -2 };
				k_item_names[GLOVE_CT_SIDE] = { "CT", -2 };
			}

			return k_item_names;
		}

		std::map<int, const char*> get_groups(bool need_knife = false, bool need_groups = false)
		{
			std::map<int, const char*> groups =
			{
				{ WEAPONTYPE_PISTOL, "Pistols" },
				{ WEAPONTYPE_SHOTGUN, "Shotguns" },
				{ WEAPONTYPE_SUBMACHINEGUN, "Submachineguns" },
				{ WEAPONTYPE_MACHINEGUN, "Machineguns" },
				{ WEAPONTYPE_RIFLE, "Rifles" },
				{ WEAPONTYPE_SNIPER_RIFLE, "Snipers" },
			};

			if (need_knife)
			{
				groups[-1] = { "Knives" };
				groups[-2] = { "Gloves" };
			}

			if (need_groups)
			{
				groups[201] = "Desert Eagle";
				groups[240] = "SSG08";
				groups[209] = "AWP";
			}

			return groups;
		}

		bool selectable_weapons(
			int& selected_item,
			bool only_groups,
			std::string& weaponName,
			std::map<int, const char*> groups,
			std::map<int, weapon_type_t> k_item_names,
			std::vector<int> selected_weapons = {}
		)
		{
			if (!ImGui::BeginCombo("##aimbot.weapons", weaponName.c_str()))
				return false;

			auto current_item = selected_item;

			for (auto& group : groups)
			{
				if (only_groups)
				{
					if (selectable(group.second, group.first == selected_item))
						selected_item = group.first;

					if (group.first == selected_item)
						ImGui::SetItemDefaultFocus();
				}
				else
				{
					if (group.first == 201)
						break;

					if (group.first != WEAPONTYPE_PISTOL)
						ImGui::Separator();

					ImGui::TextDisabled(group.second);

					ImGui::Separator();

					for (auto& item : k_item_names)
					{
						if (item.second.type == group.first)
						{
							if (std::find(selected_weapons.begin(), selected_weapons.end(), item.first) != selected_weapons.end())
								continue;

							if (selectable(item.second.name, item.first == selected_item))
								selected_item = item.first;

							if (item.first == selected_item)
								ImGui::SetItemDefaultFocus();
						}
					}
				}
			}

			ImGui::EndCombo();

			return current_item != selected_item;
		}

		bool listbox_group_weapons(
			int& selected_item,
			std::map<int, const char*> groups,
			std::map<int, weapon_type_t> items,
			ImVec2 listbox_size,
			bool show_only_selected = false,
			std::vector<int> selected_weapons = { }
		)
		{
			auto current_value = selected_item;

			ImGui::ListBoxHeader("##items", listbox_size);
			{
				for (auto& group : groups)
				{
					ImGui::TextDisabled(group.second);
					ImGui::Separator();

					auto has_items = false;

					for (auto& item : items)
					{
						if (item.second.type == group.first)
						{
							if (show_only_selected)
								if (std::find(selected_weapons.begin(), selected_weapons.end(), item.first) == selected_weapons.end())
									continue;

							has_items = true;

							char name[128];
							sprintf(name, "%s##%d", item.second.name, item.first);
							if (selectable(name, item.first == selected_item))
								selected_item = item.first;
						}
					}

					if (has_items)
						ImGui::Separator();
				}
			}
			ImGui::ListBoxFooter();

			return current_value != selected_item;
		}

		void render_header()
		{
			auto win_pos = ImGui::GetWindowPos();
			auto draw_list = ImGui::GetWindowDrawList();

			if (!render::fonts::header_title || !render::fonts::header_buttons)
				return;

			ImVec2 title_size;
			ImGui::PushFont(render::fonts::header_title);
			{
				static const auto white = ImGui::GetColorU32(ImVec4(1.f, 1.f, 1.f, 1.f));

				title_size = ImGui::CalcTextSize("Sensum");
				const auto rect_start = ImVec2(win_pos.x, win_pos.y);
				const auto rect_end = ImVec2(win_pos.x + window_size.x, win_pos.y + title_size.y + 16.f);
				const auto rect_height = rect_end.y - rect_start.y;

				draw_list->AddRectFilled(rect_start, rect_end, ImGui::GetColorU32(ImVec4(0.1f, 0.1f, 0.1f, 1.f)));

				ImGui::SetCursorPosX(10.f);
				ImGui::SetCursorPosY(rect_start.y + rect_height / 2 - win_pos.y - title_size.y / 2);

				static float _rainbow = 0.f;
				if (_rainbow > 1.f)
					_rainbow = 0.f;

				auto cursor = ImGui::GetCursorPos();

				ImGui::Text("");

				auto rainbow = _rainbow;

				for (auto& letter : "Sensum")
				{
					const auto rgb_color = Color::FromHSB(rainbow, 1.f, 1.f);

					auto color = ImVec4(rgb_color.r() / 255.f, rgb_color.g() / 255.f, rgb_color.b() / 255.f, 1.f);

					char buf[4];
					sprintf_s(buf, "%c", letter);

					draw_list->AddText(win_pos + cursor, ImGui::GetColorU32(color), buf);

					cursor.x += 0.5f + ImGui::CalcTextSize(buf).x;

					rainbow += 0.0025f;

					if (rainbow > 1.f)
						rainbow = 0.f;
				}

				_rainbow += 0.0007f;
			}
			ImGui::PopFont();

			ImGui::SameLine();

			ImGui::PushFont(render::fonts::header_buttons);
			{
				const auto menu_items = std::vector<std::string>
				{
					"Visuals",
					"Aimbot",
					"Misc",
					"Skins",
					"Players",
					"Colors",
					"Configs"
				};

				const auto menu_items_count = menu_items.size();

				const auto button_width = 72.f;
				const auto total_button_space = button_width * menu_items_count + 5.f * menu_items_count;
				ImGui::SetCursorPosX(window_size.x - total_button_space);

				ImGui::PushStyleColor(ImGuiCol_ButtonText, ImVec4(1.f, 1.f, 1.f, 1.f));
				ImGui::PushStyleColor(ImGuiCol_ButtonHovered, ImVec4(0.8f, 0.1f, 0.1f, 1.f));
				ImGui::PushStyleColor(ImGuiCol_ButtonActive, ImVec4(0.8f, 0.1f, 0.1f, 1.f));
				ImGui::PushStyleColor(ImGuiCol_ButtonOutline, ImVec4(0.8f, 0.1f, 0.1f, 1.f));

				auto& button_color = ImGui::GetStyleColorVec4(ImGuiCol_ButtonActive);

				for (size_t k = 0; k < menu_items_count; k++)
				{
					const auto selected = current_tab == k;
					if (selected)
						ImGui::PushStyleColor(ImGuiCol_Button, button_color);

					if (ImGui::Button(menu_items[k].c_str(), ImVec2(button_width, title_size.y)))
						current_tab = k;

					if (selected)
						ImGui::PopStyleColor();

					if (k != menu_items_count - 1)
						ImGui::SameLine();
				}

				ImGui::PopStyleColor(4);
			}
			ImGui::PopFont();
		}

		void background()
		{
			//nice bg
			ImGui::SetNextWindowPos(ImVec2(0, 0), ImGuiCond_Once);
			ImGui::SetNextWindowSize(ImGui::GetIO().DisplaySize, ImGuiCond_Once);

			ImGui::PushStyleColor(ImGuiCol_WindowBg, ImVec4(0.09f, 0.09f, 0.09f, 0.40f / 1.f * window_alpha));
			static const auto flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoScrollWithMouse | ImGuiWindowFlags_NoBringToFrontOnFocus | ImGuiWindowFlags_NoMove;
			ImGui::Begin("##background", nullptr, flags);
			ImGui::End();
			ImGui::PopStyleColor();
		}

		void render_bottom()
		{
			ImVec2 win_pos = ImGui::GetWindowPos();

			static auto copyright = "Xardch & MartiNJ409";

			static const auto copyright_size = ImGui::CalcTextSize(copyright);

			static char buildtime[256];
			sprintf(buildtime, "Built on %s | Version %s", xorstr_(__DATE__), VERSION);
			static const auto buildtime_size = ImGui::CalcTextSize(buildtime);
			static const auto name_size = ImGui::CalcTextSize("Sensum");

			auto draw_list = ImGui::GetWindowDrawList();
			const auto bottom_color = ImGui::GetColorU32(ImVec4(0.1f, 0.1f, 0.1f, 1.f));
			const auto text_color = ImGui::GetColorU32(ImVec4(1.f, 1.f, 1.f, 1.f));
			const auto start = ImVec2(win_pos.x, win_pos.y + window_size.y);
			const auto end = ImVec2(start.x + window_size.x, start.y - copyright_size.y - 4.f);

			draw_list->AddRectFilled(start, end, bottom_color);
			draw_list->AddText(ImVec2(start.x + 10.f, start.y - copyright_size.y - 2.f), text_color, copyright);
			draw_list->AddText(ImVec2(end.x - 10.f - buildtime_size.x, start.y - buildtime_size.y - 2.f), text_color, buildtime);
		}

		void show()
		{
			if (s_visible)
			{
				if (window_alpha < 1.f)
					window_alpha += 0.04f;
			}
			else
			{
				window_alpha -= 0.04f;

				if (window_alpha <= 0.f)
					return;
			}

			if (window_alpha <= 0.f)
				window_alpha = 0.01f;
			else if (window_alpha > 1.f)
				window_alpha = 1.f;

			background();

			const auto old_alpha = ImGui::GetStyle().Alpha;

			ImGui::GetStyle().Alpha = window_alpha;

			ImGui::SetNextWindowPosCenter(ImGuiCond_Once);
			ImGui::SetNextWindowSize(window_size, ImGuiCond_Once);

			auto* style = &ImGui::GetStyle();
			const auto old_window_padding = style->WindowPadding;
			style->WindowPadding = ImVec2(0, 0);

			static auto flags = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar; //ImGuiWindowFlags_NoMove
			ImGui::Begin("Sensum", nullptr, flags);
			{
				render_header();

				style->WindowPadding = old_window_padding;

				ImGui::BeginChild("##content", ImVec2(), false, ImGuiWindowFlags_AlwaysUseWindowPadding);
				{
					columns(current_tab == 4 ? 1 : 3);
					{
						if (current_tab == 0)
							visuals_tab();
						else if (current_tab == 1)
							aimbot_tab();
						else if (current_tab == 2)
							misc_tab();
						else if (current_tab == 3)
							skins_tab();
						else if (current_tab == 4)
							players_tab();
						else if (current_tab == 5)
							colors_tab();
						else if (current_tab == 6)
							configs_tab();
					}
					columns(1);
				}
				ImGui::EndChild();

				render_bottom();
			}
			ImGui::End();

			ImGui::GetStyle().Alpha = old_alpha;
		}
	}
}
```

`src/render/menu_strings.h`:

```h
#pragma once

namespace render
{
	namespace visual_tab
	{
		static const char* chams_list[] = { "Enemies", "Teammates" };
		static const char* cross_types[] = { "Crosshair", "Circle" };
		static const char* positions[] = { "Left", "Right", "Bottom" };
		static const char* weapon_modes[] = { "Text", "Icons" };
		static const char* box_types[] = { "Normal", "Corner" };
	}

	namespace misc_tab
	{
		static const char* viewmodel_override_list[] = { "X", "Y", "Z" };
	}
}

```

`src/render/render.cpp`:

```cpp
#include "render.h"

#include "../settings/globals.h"
#include "../settings/settings.h"
#include "../helpers/input.h"
#include "../helpers/imdraw.h"

#include "fonts/droidsans.hpp"
#include "fonts/undefeated.hpp"

namespace render
{
	auto s_ready = false;

	void* saved_hwnd = nullptr;

	void switch_hwnd()
	{
		if (menu::is_visible())
		{
			if (!saved_hwnd)
				std::swap(saved_hwnd, g::input_system->GetWindow());
		}
		else if (saved_hwnd)
			std::swap(saved_hwnd, g::input_system->GetWindow());
	}

	namespace fonts
	{
		ImFont* main;
		ImFont* visuals;
		ImFont* damage_indicator_font;
		ImFont* low_size;
		ImFont* notifies;
		ImFont* spectators;
		ImFont* configs_list;
		ImFont* weapon_icon;

		ImFont* header_title;
		ImFont* header_buttons;
	}

	void apply_fonts()
	{
		ImFontConfig font_config;
		font_config.OversampleH = 1;
		font_config.OversampleV = 1;
		font_config.PixelSnapH = true;

		static const ImWchar ranges[] =
		{
			0x0020, 0x00FF,
			0x0400, 0x044F,
			0,
		};

		auto io = &ImGui::GetIO();

		fonts::main = io->Fonts->AddFontFromMemoryCompressedTTF(droidsans_compressed_data, droidsans_compressed_size, 15.f, &font_config, ranges);
		fonts::visuals = io->Fonts->AddFontFromMemoryCompressedTTF(droidsans_compressed_data, droidsans_compressed_size, 12.f, &font_config, ranges);
		fonts::damage_indicator_font = io->Fonts->AddFontFromMemoryCompressedTTF(droidsans_compressed_data, droidsans_compressed_size, 18.f, &font_config, ranges);
		fonts::low_size = io->Fonts->AddFontFromMemoryCompressedTTF(droidsans_compressed_data, droidsans_compressed_size, 12.f, &font_config, ranges);
		fonts::notifies = io->Fonts->AddFontFromMemoryCompressedTTF(droidsans_compressed_data, droidsans_compressed_size, 13.f, &font_config, ranges);
		fonts::spectators = ImGui::GetIO().Fonts->AddFontFromMemoryCompressedTTF(droidsans_compressed_data, droidsans_compressed_size, 14.f, &font_config, ranges);
		fonts::configs_list = io->Fonts->AddFontFromMemoryCompressedTTF(droidsans_compressed_data, droidsans_compressed_size, 16.f, &font_config, ranges);
		fonts::weapon_icon = io->Fonts->AddFontFromMemoryCompressedTTF(undefeated_compressed_data, undefeated_compressed_size, 12.f, &font_config, ranges);

		fonts::header_title = ImGui::GetIO().Fonts->AddFontFromMemoryCompressedTTF(droidsans_compressed_data, droidsans_compressed_size, 24.f);
		fonts::header_buttons = ImGui::GetIO().Fonts->AddFontFromMemoryCompressedTTF(droidsans_compressed_data, droidsans_compressed_size, 17.f, &font_config, ranges);
	}

	void initialize()
	{
		ImGui::CreateContext();

		ImGui_ImplDX9_Init(input_system::get_main_window(), g::d3_device);

		s_ready = true;

		auto& style = ImGui::GetStyle();
		style.Alpha = 1.f;
		style.WindowRounding = 0.f;
		style.WindowBorderSize = 0.f;
		style.FrameRounding = 0.f;
		style.ScrollbarRounding = 0.f;
		style.ScrollbarSize = 12.f;

		style.WindowTitleAlign = ImVec2(0.5f, 0.5f);
		style.FramePadding = ImVec2(4.f, 2.f);
		style.ItemSpacing = ImVec2(5, 5);

		//restyle
		style.FrameRounding = 2.f;
		style.WindowBorderSize = 0.f;
		style.PopupBorderSize = 0.5f;
		style.ItemSpacing = ImVec2(4.f, 6.f);
		style.ItemInnerSpacing = ImVec2(4.f, 4.f);
		style.GrabMinSize = 16.f;
		style.FramePadding = ImVec2(4.f, 1.f);
		style.GrabMinSize = 1.f;

		imdraw::apply_style();

		apply_fonts();
	}

	void destroy()
	{
		s_ready = false;

		ImGui_ImplDX9_Shutdown();
	}

	void device_lost()
	{
		ImGui_ImplDX9_InvalidateDeviceObjects();
	}

	void device_reset()
	{
		ImGui_ImplDX9_CreateDeviceObjects();
	}

	bool is_ready()
	{
		return s_ready;
	}

	void tooltip(const char* text)
	{
		if (ImGui::IsItemHovered())
			ImGui::SetTooltip(text);
	}

	ImVec2 get_listbox_size(float x, float y_offset)
	{
		return {x, (ImGui::GetCurrentWindow()->Size.y - ImGui::GetStyle().WindowPadding.y * 2) - ImGui::GetCursorPosY() - y_offset};
	}

	bool ColorEdit4(const char* label, ImVec4* v)
	{
		return ImGui::ColorEdit4(label, &v->x, false);
	}

	bool ColorEdit4(const char* label, Color* v)
	{
		auto clr = ImVec4{
			v->r() / 255.0f,
			v->g() / 255.0f,
			v->b() / 255.0f,
			v->a() / 255.0f
		};

		if (ImGui::ColorEdit4(label, &clr.x, false)) {
			v->SetColor(clr.x, clr.y, clr.z, clr.w);
			return true;
		}

		return false;
	}

	bool ColorEdit4(const char* label, Color* v, ImGuiColorEditFlags flag)
	{
		auto clr = ImVec4{
			v->r() / 255.0f,
			v->g() / 255.0f,
			v->b() / 255.0f,
			v->a() / 255.0f
		};

		if (ImGui::ColorEdit4(label, &clr.x, flag)) {
			v->SetColor(clr.x, clr.y, clr.z, clr.w);
			return true;
		}

		return false;
	}

	bool ColorEdit4(const char* label, ImVec4* v, ImGuiColorEditFlags flag)
	{
		return ImGui::ColorEdit4(label, &v->x, flag);
	}

	bool ColorEdit3(const char* label, Color* v)
	{
		return ColorEdit4(label, v);
	}

	void columns(int count)
	{
		ImGui::Columns(count, nullptr, false);
	}

	void separator(const char* label)
	{
		auto size = ImGui::CalcTextSize(label);
		auto draw_list = ImGui::GetWindowDrawList();
		const auto width = ImGui::GetContentRegionAvailWidth();

		const auto win_pos = ImGui::GetWindowPos();
		const auto cursor = ImVec2(ImGui::GetCursorPosX() + win_pos.x, ImGui::GetCursorPosY() + win_pos.y);
		const auto pos = ImVec2(cursor.x + width / 2 - size.x / 2, cursor.y);
		const auto col = ImGui::GetColorU32(ImGui::GetStyleColorVec4(ImGuiCol_Text));
		draw_list->AddText(pos, col, label);

		draw_list->AddLine(ImVec2(cursor.x, cursor.y + size.y / 2), ImVec2(pos.x - 5.f, cursor.y + size.y / 2), col);
		draw_list->AddLine(ImVec2(pos.x + size.x + 5.f, cursor.y + size.y / 2), ImVec2(cursor.x + width, cursor.y + size.y / 2), col);

		ImGui::NewLine();
	}

	void child(const char* label, const std::function<void()>& body)
	{
		ImGui::BeginChild(label, ImVec2(0.f, 0.f), false);
		{
			separator(label);

			ImGui::PushItemWidth(-1);

			body();

			ImGui::PopItemWidth();
		}
		ImGui::EndChild();
	}

	void checkbox(const char* label, bool* value)
	{
		ImGui::Checkbox(label, value);
	}

	void combo(const char* label, const std::function<void(std::string&)>& body)
	{
		static auto preview = std::map<const char*, std::string>{};
		if (ImGui::BeginCombo(label, preview[label].c_str()))
		{
			body(preview[label]);

			ImGui::EndCombo();
		}
	}

	bool selectable(const char* label, bool selected)
	{
		ImGui::PushStyleColor(ImGuiCol_Header, ImGui::GetStyleColorVec4(ImGuiCol_ListBoxItem));
		ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImGui::GetStyleColorVec4(ImGuiCol_ListBoxItemActive));
		ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImGui::GetStyleColorVec4(ImGuiCol_ListBoxItemHovered));

		const auto state = ImGui::Selectable(label, selected);

		ImGui::PopStyleColor(3);

		return state;
	}
}
```

`src/render/render.h`:

```h
#pragma once

#include "../valve_sdk/csgostructs.hpp"

#define IMGUI_DEFINE_MATH_OPERATORS

#include "../imgui/imgui.h"
#include "../imgui/imgui_internal.h"
#include "../imgui/directx9/imgui_impl_dx9.h"

namespace render
{
	namespace fonts
	{
		extern ImFont* main;
		extern ImFont* visuals;
		extern ImFont* damage_indicator_font;
		extern ImFont* low_size;
		extern ImFont* notifies;
		extern ImFont* spectators;
		extern ImFont* configs_list;
		extern ImFont* weapon_icon;

		extern ImFont* header_title;
		extern ImFont* header_buttons;
	}

	void initialize();
	void destroy();

	void device_lost();
	void device_reset();

	bool is_ready();

	/*gui helpers*/
	
	void tooltip(const char* text);

	bool selectable(const char* label, bool selected);
	void combo(const char* label, const std::function<void(std::string&)>& body);
	ImVec2 get_listbox_size(float x = 0, float y_offset = 0.f);

	bool ColorEdit4(const char* label, ImVec4* v);
	bool ColorEdit4(const char* label, Color* v);
	bool ColorEdit4(const char* label, Color* v, ImGuiColorEditFlags flag);
	bool ColorEdit4(const char* label, ImVec4* v, ImGuiColorEditFlags flag);
	bool ColorEdit3(const char* label, Color* v);

	void columns(int count);
	void separator(const char* label);

	void child(const char* label, const std::function<void()>& body);

	void checkbox(const char* label, bool* value);
	
	void switch_hwnd();

	namespace menu
	{
		struct weapon_type_t
		{
			const char* name;
			int type;
		};

		bool is_visible();
		void toggle();
		void background();
		void show();

		void visuals_tab();
		void aimbot_tab();
		void misc_tab();
		void skins_tab();
		void players_tab();
		void configs_tab();
		void colors_tab();

		void initconfig();
	}

	namespace timers
	{
		void show();
	}

	namespace spectators
	{
		void show();
	}
}
```

`src/render/spectators.cpp`:

```cpp
#include "render.h"
#include "../settings/options.hpp"
#include "../settings/globals.h"

namespace render
{
	namespace spectators
	{
		void show()
		{
			if (!render::fonts::spectators || !g::local_player)
				return;

			c_base_player* player = g::local_player;
			if (player->m_hObserverTarget())
				player = c_base_player::GetEntityFromHandle<c_base_player>(player->m_hObserverTarget());

			if (!player || !player->IsPlayer())
				return;

			auto offset_y = 5.f;
			const auto screen_size = ImGui::GetIO().DisplaySize;
			const auto color = ImGui::GetColorU32(player->IsFlashed() ? ImVec4::Black : ImVec4::White);

			const auto max_clients = g::engine_client->GetMaxClients();
			for (int i = 1; i <= max_clients; i++)
			{
				auto entity = c_base_player::GetPlayerByIndex(i);
				if (!entity || !entity->IsPlayer() || entity->IsDormant() || entity->IsAlive() || entity == player || entity == g::local_player)
					continue;

				const auto observer_target = c_base_player::GetEntityFromHandle(entity->m_hObserverTarget());
				if (!observer_target || observer_target != player)
					continue;

				auto info = entity->GetPlayerInfo();
				if (!info.fakeplayer)
				{
					const auto text_size = ImGui::CalcTextSize(info.szName);
					const auto pos = ImVec2(screen_size.x - text_size.x - 5.f, offset_y);

					globals::draw_list->AddText(pos, color, info.szName);

					offset_y += text_size.y + 5.f;
				}
			}
		}
	}
}
```

`src/render/tabs/aimbot_tab.cpp`:

```cpp
#include "../render.h"
#include "../../settings/globals.h"
#include "../../settings/settings.h"
#include "../../helpers/notifies.h"
#include "../../render/menu_strings.h"

extern void bind_button(const char* label, int& key);
extern bool Hotkey(const char* label, int* k, const ImVec2& size_arg = ImVec2(0.f, 0.f));

namespace render
{
	namespace menu
	{
		extern std::map<int, weapon_type_t> get_weapons(bool need_knife);
		extern std::map<int, const char*> get_groups(bool need_knife = false, bool need_groups = false);
		extern bool selectable_weapons(
			int& selected_item,
			bool only_groups,
			std::string& weaponName,
			std::map<int, const char*> groups,
			std::map<int, weapon_type_t> k_item_names,
			std::vector<int> selected_weapons = { }
		);

		extern bool listbox_group_weapons(
			int& selected_item,
			std::map<int, const char*> groups,
			std::map<int, weapon_type_t> items,
			ImVec2 listbox_size,
			bool show_only_selected = false,
			std::vector<int> selected_weapons = { }
		);

		void aimbot_tab()
		{
			static int definition_index = 7;
			auto settings = &settings::aimbot::m_items[definition_index];

			child("Main", [&settings]()
				{
					auto k_item_names = get_weapons(false);

					const char* setting_types[] =
					{
						"Separately",
						"Subgroups",
						"For all",
						"Groups"
					};

					static bool is_settings_visible = false;

					if (ImGui::Combo("##setting_type", &settings::aimbot::setting_type, setting_types, IM_ARRAYSIZE(setting_types)))
						is_settings_visible = settings::aimbot::setting_type == settings_type_t::groups ? false : true;

					if (settings::aimbot::setting_type != settings_type_t::groups)
						is_settings_visible = true;

					if (settings::aimbot::setting_type == settings_type_t::for_all)
					{
						definition_index = 0;
					}
					else if (settings::aimbot::setting_type == settings_type_t::separately || settings::aimbot::setting_type == settings_type_t::subgroups)
					{
						auto groups = get_groups(false, true);

						std::string weaponName;
						if (settings::aimbot::setting_type == settings_type_t::subgroups)
						{
							if (groups.count(definition_index) == 0)
								definition_index = WEAPONTYPE_PISTOL;

							weaponName = groups[definition_index];
						}
						else
						{
							if (k_item_names.count(definition_index) == 0)
								definition_index = WEAPON_AK47;

							weaponName = k_item_names[definition_index].name;
						}

						selectable_weapons(definition_index, settings::aimbot::setting_type == settings_type_t::subgroups, weaponName, groups, k_item_names);
					}
					else if (settings::aimbot::setting_type == settings_type_t::groups)
					{
						if (definition_index < 0 || definition_index >= settings::aimbot::m_groups.size())
						{
							definition_index = 0;
						}

						if (!settings::aimbot::m_groups.empty())
						{
							ImGui::PushItemWidth(ImGui::GetContentRegionAvailWidth() - 70.f);
							ImGui::Combo("##aimbot.groups", &definition_index, [](void* data, int idx, const char** out_text)
								{
									*out_text = settings::aimbot::m_groups[idx].name.c_str();
									return true;
								}, nullptr, settings::aimbot::m_groups.size(), 10);
							ImGui::PopItemWidth();

							ImGui::SameLine();

							if (is_settings_visible)
							{
								if (ImGui::Button("Edit", ImVec2(ImGui::GetContentRegionAvailWidth(), 0.f)))
									is_settings_visible = false;
							}
							else
							{
								if (ImGui::Button("Hide", ImVec2(ImGui::GetContentRegionAvailWidth(), 0.f)))
									is_settings_visible = true;
							}
						}

						if (!is_settings_visible)
						{
							separator("New group");

							ImGui::Text("Name");

							static char group_name[32];
							ImGui::InputText("##aimbot.group_name", group_name, sizeof(group_name));

							if (ImGui::Button("Create"))
							{
								if (strlen(group_name) == 0)
									notifies::push("Enter the group name", notify_state_s::danger_state);
								else
								{
									settings::aimbot::m_groups.emplace_back(aimbot_group{ std::string(group_name), { } });

									memset(group_name, 0, sizeof(group_name));
									notifies::push("Group created");

									definition_index = settings::aimbot::m_groups.size() - 1;
								}
							}

							if (settings::aimbot::m_groups.empty())
								return;

							separator("Current group");

							auto& current_group = settings::aimbot::m_groups[definition_index];

							static auto weapon_to_select = -1;
							std::string placeholder = "Select weapon";

							const auto groups = get_groups(false, false);

							if (selectable_weapons(weapon_to_select, false, placeholder, groups, k_item_names, current_group.weapons))
							{
								if (std::find(current_group.weapons.begin(), current_group.weapons.end(), weapon_to_select) == current_group.weapons.end())
									current_group.weapons.emplace_back(weapon_to_select);

								weapon_to_select = -1;
							}

							static int weapon_to_remove = -1;
							if (listbox_group_weapons(weapon_to_remove, groups, k_item_names, ImVec2(0, 150.f), true, current_group.weapons))
							{
								current_group.weapons.erase(std::find(current_group.weapons.begin(), current_group.weapons.end(), weapon_to_remove));

								weapon_to_remove = -1;
							}

							if (ImGui::Button("Delete"))
							{
								notifies::push("Group removed");

								settings::aimbot::m_groups.erase(settings::aimbot::m_groups.begin() + definition_index);

								definition_index = 0;
							}

							return;
						}
					}

					checkbox("Enabled", &settings->enabled);

					if (settings::aimbot::setting_type == settings_type_t::separately)
					{
						switch (definition_index)
						{
						case WEAPON_P250:
						case WEAPON_USP_SILENCER:
						case WEAPON_GLOCK:
						case WEAPON_FIVESEVEN:
						case WEAPON_TEC9:
						case WEAPON_DEAGLE:
						case WEAPON_ELITE:
						case WEAPON_HKP2000:
							checkbox("Auto Pistol", &settings->autopistol);
							break;
						default:
							break;
						}
					}
					else if (settings::aimbot::setting_type == settings_type_t::subgroups && (definition_index == WEAPONTYPE_PISTOL || definition_index == 201))
						checkbox("Auto Pistol", &settings->autopistol);
					else
						checkbox("Auto Pistol", &settings->autopistol);

					checkbox("Air Check", &settings->check_air);
					checkbox("Flash Check", &settings->check_flash);
					checkbox("Smoke Check", &settings->check_smoke);

					if (settings::aimbot::setting_type == settings_type_t::separately)
					{
						if (utils::is_sniper(definition_index))
							checkbox("Zoom Check", &settings->check_zoom);
					}
					else if (settings::aimbot::setting_type == settings_type_t::subgroups)
					{
						if (definition_index == 240 || definition_index == 209 || definition_index == WEAPONTYPE_SNIPER_RIFLE)
							checkbox("Zoom Check", &settings->check_zoom);
					}
					else if (settings::aimbot::setting_type == settings_type_t::groups)
						checkbox("Zoom Check", &settings->check_zoom);

					checkbox("Target Teammates", &settings::misc::deathmatch);
					
					columns(2);
					{
						checkbox("By Damage", &settings->by_damage);

						ImGui::NextColumn();

						ImGui::PushItemWidth(-1);
						ImGui::SliderIntLeftAligned("Min:##min_damage", &settings->min_damage, 1, 100, "%.0f HP");
						ImGui::PopItemWidth();
					}
					columns(1);

					columns(2);
					{
						checkbox("Auto Wall", &settings->autowall.enabled);

						ImGui::NextColumn();

						ImGui::PushItemWidth(-1);
						ImGui::SliderIntLeftAligned("Min:##autowall", &settings->autowall.min_damage, 1, 100, "%.0f HP");
						ImGui::PopItemWidth();
					}
					columns(1);

					checkbox("Disable Backtrack", &settings::aimbot::hello_nigga);

					separator("Delays");

					checkbox("Auto Delay", &settings->delays.auto_delay);
					ImGui::SliderIntLeftAligned("Shot Delay:", &settings->delays.before_shot, 0, 250, "%.0f ms");
					ImGui::SliderIntLeftAligned("Target Switch Delay:", &settings->delays.target_switch, 0, 1000, "%.0f ms");

					checkbox("Auto Stop", &settings->auto_stop);

					if (settings::aimbot::setting_type != 0)
						return;

					if (!utils::is_connected())
						return;

					auto& weapon = g::local_player->m_hActiveWeapon();
					if (!weapon || !weapon->IsWeapon())
						return;

					const auto item_definition_index = weapon->m_iItemDefinitionIndex();
					if (k_item_names.count(item_definition_index) == 0)
						return;

					ImGui::Separator();

					if (ImGui::Button("Current"))
						definition_index = item_definition_index;

					if (weapon)
						definition_index = item_definition_index;
				});

			ImGui::NextColumn();

			child("Customization", [&settings]()
				{
					ImGui::PushID("aimbot.other");
					{
						checkbox("Dynamic FOV", &settings->dynamic_fov);
						checkbox("Legit Backtrack", &settings->backtrack.legit);
			
						ImGui::SliderFloatLeftAligned("FOV:", &settings->fov, 0, 180.f, "%.1f \u00B0");

						ImGui::SliderFloatLeftAligned("Smooth:", &settings->smooth, 1, 30.f, "%.1f");
						
						ImGui::SliderIntLeftAligned("Backtrack:", &settings->backtrack.time, 1, 200, "%1.f ms");
						
						ImGui::SliderIntLeftAligned("Hit Chance:", &settings->min_hitchance, 0, 100, "%.0f%%");
					}
					ImGui::PopID();

					separator("Hitboxes");

					columns(3);
					{
						checkbox("Head", &settings->hitboxes.head);
						checkbox("Arms", &settings->hitboxes.arms);

						ImGui::NextColumn();

						checkbox("Neck", &settings->hitboxes.neck);
						checkbox("Legs", &settings->hitboxes.legs);

						ImGui::NextColumn();

						checkbox("Body", &settings->hitboxes.body);
					}
					columns(1);

					separator("Aim Assist");

					checkbox("Spray Override##AimAssist", &settings->fov_smooth_override);

					if (settings->fov_smooth_override)
					{
						ImGui::SliderIntLeftAligned("Shots for Activation:", &settings->min_shots_fired, 3, 25, "%1.f shots");

						ImGui::SliderFloatLeftAligned("Override FOV: (?)", &settings->extended_fov, 0.f, 180.f, "%.1f \u00B0");
						tooltip("Sets FOV to X when spraying over Y shots");

						ImGui::SliderFloatLeftAligned("Override Smooth: (?)", &settings->extended_smooth, 1.f, 30.f, "%.1f");
						tooltip("Sets smooth to X when spraying over Y shots");
					}
				});

			ImGui::NextColumn();

			child("Recoil Control System", [&settings]()
				{
					checkbox("Enabled", &settings->recoil.enabled);
					checkbox("First Bullet", &settings->recoil.first_bullet);
					checkbox("Humanization", &settings->recoil.humanized);
					checkbox("Target Chest While Spraying", &settings->rcs_override_hitbox);
					
					static float pitch_max = 2.0f, yaw_max = 2.0f;

					float pitch_perc = (settings->recoil.pitch / pitch_max) * 100.0f;
					float yaw_perc = (settings->recoil.yaw / yaw_max) * 100.0f;

					ImGui::SliderFloatLeftAlignedCustom("Pitch:", &settings->recoil.pitch, 0.0f, pitch_max, "%.1f%%", &pitch_perc);
					ImGui::SliderFloatLeftAlignedCustom("Yaw:", &settings->recoil.yaw, 0.0f, yaw_max, "%.1f%%", &yaw_perc);

					separator("Trigger");

					columns(2);
					{
						checkbox("Enabled##trigger", &settings->trigger.enabled);

						ImGui::NextColumn();

						ImGui::PushItemWidth(-1);
						Hotkey("##binds.trigger", &globals::binds::trigger);
						ImGui::PopItemWidth();

						ImGui::NextColumn();

						ImGui::PushItemWidth(-1);
						checkbox("Magnet##trigger", &settings->trigger.magnet);
						ImGui::PopItemWidth();
					}
					columns(1);

					ImGui::SliderIntLeftAligned("Reaction time:", &settings->trigger.delay, 0, 250, "%.0f ms");
					ImGui::SliderIntLeftAligned("Delay Between Shots:", &settings->trigger.delay_btw_shots, 0, 250, "%.0f ms");
					ImGui::SliderIntLeftAligned("Hit Chance:", &settings->trigger.hitchance, 1, 100, "%.0f%%");
				});
		}
	}
}
```

`src/render/tabs/colors_tab.cpp`:

```cpp
#include "../../render/render.h"
#include "../../settings/globals.h"
#include "../../settings/settings.h"
#include "../../helpers/imdraw.h"
#include "../../helpers/console.h"

extern void bind_button(const char* label, int& key);
extern bool Hotkey(const char* label, int* k, const ImVec2& size_arg = ImVec2(0.f, 0.f));

namespace render
{
	namespace menu
	{
		void colors_tab()
		{
			child("Colors", []()
			{
					separator("Chams");
					ColorEdit4("Enemy Visible", &settings::chams::enemy::color_visible, ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_PickerHueBar);
					ImGui::SameLine();
					ColorEdit4("Enemy XQZ", &settings::chams::enemy::color_not_visible, ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_PickerHueBar);

					ColorEdit4("Team Visible  ", &settings::chams::teammates::color_visible, ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_PickerHueBar);
					ImGui::SameLine();
					ColorEdit4("Team XQZ", &settings::chams::teammates::color_not_visible, ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_PickerHueBar);
					ColorEdit4("Enemy Backtrack ##chams", &settings::chams::enemy::color_backtrack, ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_PickerHueBar);
					ImGui::SameLine();
					ColorEdit4("Team Backtrack ##chams", &settings::chams::teammates::color_backtrack, ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_PickerHueBar);

					separator("ESP");
					ColorEdit4("ESP Visible ", &settings::esp::visible_color, ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_PickerHueBar);
					ImGui::SameLine();
					ColorEdit4("ESP Invisible", &settings::esp::occluded_color, ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_PickerHueBar);

					ColorEdit4("Bone ESP", &settings::esp::bone_esp_color, ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_PickerHueBar);

					ColorEdit4("RCS Cross  ", &settings::visuals::recoil_color, ImGuiColorEditFlags_AlphaBar | ImGuiColorEditFlags_PickerHueBar);
					ImGui::SameLine();
			});
		}
	}
}
```

`src/render/tabs/configs_tab.cpp`:

```cpp
#include "../render.h"
#include "../../settings/config.h"
#include "../../settings/globals.h"
#include "../../settings/settings.h"
#include "../../helpers/notifies.h"
#include "../../features/features.h"

extern void bind_button(const char* label, int& key);

namespace render
{
	namespace menu
	{
		char filename[32];
		bool is_loaded = true;
		std::string currentName;
		char current_loaded_config[32];

		ImVec2 button_size = ImVec2();

		void initialize()
		{
			if (globals::configs_initialized)
				return;

			globals::configs_initialized = true;
			currentName = globals::settings;
			strcpy(current_loaded_config, globals::settings.c_str());

			button_size = ImVec2(ImGui::GetContentRegionAvailWidth(), 24.f);
		}

		void configs_tab()
		{
			initialize();

			if (!is_loaded)
			{
				config::cache("configs");

				is_loaded = true;
			}

			child("New Config", []()
				{
					ImGui::InputText("##filename", filename, 32);

					if (ImGui::Button("Create", button_size))
					{
						if (strlen(filename) == 0)
						{
							notifies::push("Enter config name", notify_state_s::warning_state);
						}
						else
						{
							settings::save(std::string(filename));
							memset(filename, 0, 32);
							is_loaded = false;

							notifies::push("Config created");

							globals::settings = currentName;
							globals::save();
						}
					}

					separator("Some Actions");

					if (!currentName.empty())
					{
						ImGui::InputText("##currentname", current_loaded_config, 32);

						if (ImGui::Button("Rename", button_size))
						{
							if (strlen(current_loaded_config) == 0)
							{
								notifies::push("Enter new config name", notify_state_s::warning_state);
							}
							else
							{
								settings::load(currentName);
								config::remove(currentName, "configs");

								currentName = std::string(current_loaded_config);
								settings::save(currentName);
								is_loaded = false;

								notifies::push("Config renamed");

								globals::settings = currentName;
								globals::save();
							}
						}

						if (ImGui::Button("Load", button_size))
						{
							settings::load(currentName);

							globals::load();

							skins::load();

							notifies::push("Config loaded");
						}

						ImGui::NewLine();
						
						if (ImGui::Button("Save", button_size))
						{
							settings::save(currentName);

							globals::settings = currentName;
							globals::save();

							notifies::push("Config saved", notify_state_s::success_state);
						}

						ImGui::NewLine();

						if (ImGui::Button("Remove", button_size))
						{
							if (config::remove(currentName, "configs"))
							{
								currentName.clear();
								is_loaded = false;

								notifies::push("Config removed", notify_state_s::success_state);
							}
							else
							{
								notifies::push("Something went wrong", notify_state_s::warning_state);
							}
						}
					}
				});

			ImGui::NextColumn();

			child("Configs", []()
				{
					if (!render::fonts::configs_list)
						return;

					ImGui::PushFont(render::fonts::configs_list);
					{
						ImGui::ListBoxHeader("##configs", get_listbox_size(0.f, 26.f));
						{
							for (auto& config : config::cached["configs"])
							{
								if (selectable(config.first.c_str(), config.first == currentName))
								{
									strcpy(current_loaded_config, config.first.c_str());
									currentName = config.first;
								}
							}
						}
						ImGui::ListBoxFooter();
					}
					ImGui::PopFont();

					if (ImGui::Button("Refresh", button_size))
						is_loaded = false;
				});

			ImGui::NextColumn();

			child("Binds & Misc", []()
				{
					checkbox("Show notify when loaded", &globals::binds::notify_when_loaded);
					checkbox("ESP while in menu", &globals::esp_menu_opened);
					
					for (auto& config : config::cached["configs"])
						bind_button(config.first.c_str(), globals::binds::configs[config.first]);
				});
		}
	}
}
```

`src/render/tabs/misc_tab.cpp`:

```cpp
#include "../render.h"
#include "../../settings/globals.h"
#include "../../settings/settings.h"
#include "../../features/features.h"
#include "../../helpers/console.h"
#include "../menu_strings.h"

extern void bind_button(const char* label, int& key);
extern bool Hotkey(const char* label, int* k, const ImVec2& size_arg = ImVec2(0.f, 0.f));

namespace render
{
	namespace menu
	{
		void misc_tab()
		{
				child("Customization", []()
				{
					ImGui::SliderFloatLeftAligned("Viewmodel FOV:", &settings::misc::viewmodel_fov, 54, 120, "%.0f *");
					ImGui::SliderIntLeftAligned("Camera FOV:", &settings::misc::debug_fov, 80, 120, "%.0f *");
				});

				ImGui::NextColumn();

				child("Extra", []()
				{
					checkbox("Radar", &settings::misc::radar);
					checkbox("Bunny Hop", &settings::misc::bhop);
					checkbox("Auto Strafe", &settings::misc::auto_strafe);
					checkbox("Grief Nade (?)", &settings::misc::selfnade);
					tooltip("Look up, hold mouse2, once fully primed start holding mouse1, once is HE in air - crouch, does -98 dmg.");
					checkbox("Post Processing", &globals::post_processing);
					checkbox("Noscope Overlay", &settings::misc::noscope);
					checkbox("Left Hand Knife", &settings::misc::lefthandknife);
					checkbox("Smoke Helper", &settings::misc::smoke_helper);
					checkbox("Flash Helper", &settings::misc::flash_helper);
					checkbox("Fast Stop", &settings::misc::fast_stop);
					checkbox("Print FOV (Debug)", &settings::misc::print_fov);
				});

				ImGui::NextColumn();

				child("Binds", []()
				{
					bind_button("Third Person", globals::binds::thirdperson::key);
				});
		}
	}
}

```

`src/render/tabs/players_tab.cpp`:

```cpp
#include "../render.h"
#include "../../settings/globals.h"

namespace render
{
	namespace menu
	{
		const auto blue = ImVec4(0.05f, 0.4f, 0.7f, 1.f);
		const auto orange = ImVec4(0.7f, 0.4f, 0.05f, 1.f);

		struct player_info_t
		{
			bool is_ct_team;
			std::string name;
			int wins;
			int rank;
			int money;
			int id;
			int level;
		};

		std::vector<player_info_t> list;

		void render_players(const std::vector<player_info_t>& list, const bool& ct_team)
		{
			auto is_first = true;
			static const std::vector<const char*> ranks =
			{
				"Unranked",
				"Silver I",
				"Silver II",
				"Silver III",
				"Silver IV",
				"Silver Elite",
				"Silver Elite Master",
				"Gold Nova I",
				"Gold Nova II",
				"Gold Nova III",
				"Gold Nova Master",
				"Master Guardian I",
				"Master Guardian II",
				"Master Guardian Elite",
				"Distinguished Master Guardian",
				"Legendary Eagle",
				"Legendary Eagle Master",
				"Supreme Master First Class",
				"The Global Elite"
			};

			for (const auto& item : list)
			{
				if ((ct_team && !item.is_ct_team) || (!ct_team && item.is_ct_team))
					continue;

				if (is_first)
				{
					is_first = false;
					ImGui::Separator();
				}

				columns(5);

				ImGui::SetColumnWidth(-1, 200.f);
				ImGui::PushStyleColor(ImGuiCol_Text, item.is_ct_team ? blue : orange);

				ImGui::Text(item.name.c_str());

				ImGui::NextColumn();

				ImGui::SetColumnWidth(-1, 60.f);
				ImGui::Text("$%d", item.money);

				ImGui::NextColumn();

				ImGui::SetColumnWidth(-1, 60.f);
				ImGui::Text("%d", item.wins);

				ImGui::NextColumn();

				ImGui::SetColumnWidth(-1, 60.f);
				ImGui::Text("%d", globals::team_damage[item.id]);

				ImGui::NextColumn();

				if (item.rank == 0)
					ImGui::Text("[%i] %s", item.level, ranks[item.rank]);
				else
					ImGui::Text("[%i] %s", item.level, ranks[item.rank]);

				ImGui::PopStyleColor();

				columns(1);
			}
		}

		void players_tab()
		{
			columns(5);
			{
				ImGui::SetColumnWidth(-1, 200.f);
				ImGui::Text("Name");

				ImGui::NextColumn();

				ImGui::SetColumnWidth(-1, 60.f);
				ImGui::Text("Money");

				ImGui::NextColumn();

				ImGui::SetColumnWidth(-1, 60.f);
				ImGui::Text("Wins");

				ImGui::NextColumn();

				ImGui::SetColumnWidth(-1, 60.f);
				ImGui::Text("Damage");

				ImGui::NextColumn();

				ImGui::Text("Rank");
			}
			columns(1);

			list.clear();

			auto player_resource = *g::player_resource;
			if (!player_resource)
				return;

			const auto max_clients = g::engine_client->GetMaxClients();
			for (int i = 1; i <= max_clients; i++)
			{
				auto* player = c_base_player::GetPlayerByIndex(i);
				if (!player || !player->IsPlayer())
					continue;

				if (player->m_iTeamNum() != team::team_ct && player->m_iTeamNum() != team::team_t)
					continue;

				const auto info = player->GetPlayerInfo();
				if (info.fakeplayer)
					continue;

				list.push_back({
					player->m_iTeamNum() == team::team_ct,
					info.szName,
					player_resource->GetWins()[player->GetIndex()],
					player_resource->GetRank()[player->GetIndex()],
					player->m_iAccount(),
					player->GetPlayerInfo().userId,
					player_resource->GetLevel()[player->GetIndex()]
					});
			}

			render_players(list, false);
			render_players(list, true);
		}
	}
}
```

`src/render/tabs/skins_tab.cpp`:

```cpp
#include "../render.h"
#include "../../settings/globals.h"
#include "../../features/features.h"

#include "../../valve_sdk/kit_parser.hpp"
#include "../../helpers/notifies.h"
#include "../../helpers/console.h"

#include <algorithm>
#include <string>
#include <cctype>

bool findStringIC(const std::string& strHaystack, const std::string& strNeedle)
{
	auto it = std::search(
		strHaystack.begin(), strHaystack.end(),
		strNeedle.begin(), strNeedle.end(),
		[](char ch1, char ch2) { return std::toupper(ch1) == std::toupper(ch2); }
	);
	return (it != strHaystack.end());
}

namespace render
{
	namespace menu
	{
		extern std::map<int, weapon_type_t> get_weapons(bool need_knife);
		extern std::map<int, const char*> get_groups(bool need_knife = false, bool need_groups = false);

		extern bool listbox_group_weapons(
			int& selected_item,
			std::map<int, const char*> groups,
			std::map<int, weapon_type_t> items,
			ImVec2 listbox_size,
			bool show_only_selected = false,
			std::vector<int> selected_weapons = { }
		);

		void skins_tab()
		{
			static int definition_index = 1;
			auto& entries = skins::m_items;
			auto& selected_entry = entries[definition_index];
			selected_entry.definition_index = definition_index;

			child("Items", [&selected_entry]()
				{
					auto weapon_index = 0;
					const auto weapons = get_weapons(true);
					auto can_change_index = [weapons, &weapon_index]()
					{
						if (!g::local_player || !g::local_player->IsAlive())
							return false;

						if (!g::local_player->m_hActiveWeapon())
							return false;

						weapon_index = g::local_player->m_hActiveWeapon()->m_iItemDefinitionIndex();
						return weapons.count(weapon_index) > 0;
					};

					const auto state = can_change_index();

					listbox_group_weapons(definition_index, get_groups(true, false), weapons, get_listbox_size(0.f, state ? 26.f : 0.f));

					if (!state)
						return;

					if (ImGui::Button("Current Weapon", ImVec2(ImGui::GetContentRegionAvailWidth(), 22.f)))
						definition_index = weapon_index;
				});

			ImGui::NextColumn();

			child("Paint Kits", [&selected_entry]()
				{
					static auto show_all_kits = false;
					checkbox("Show Only Gun Skins", &show_all_kits);

					static char query_kit[64];

					ImGui::InputText("##skins.query", query_kit, sizeof(query_kit));

					ImGui::PushStyleColor(ImGuiCol_Header, ImVec4(0.f, 0.f, 0.f, 0.1f));
					ImGui::PushStyleColor(ImGuiCol_HeaderActive, ImVec4(0.f, 0.f, 0.f, 0.1f));
					ImGui::PushStyleColor(ImGuiCol_HeaderHovered, ImVec4(0.f, 0.f, 0.f, 0.1f));

					ImGui::ListBoxHeader("##items", get_listbox_size());
					{
						const std::string query(query_kit);
						const auto query_length = query.length();
						const auto has_query = query_length > 0;

						const auto is_glove = selected_entry.definition_index == GLOVE_CT_SIDE || selected_entry.definition_index == GLOVE_T_SIDE;
						for (size_t k = 0; k < (is_glove ? game_data::glove_kits.size() : game_data::skin_kits.size()); k++)
						{
							auto name = is_glove ? game_data::glove_kits[k].name.c_str() : game_data::skin_kits[k].name.c_str();
							if (has_query)
							{
								if (!is_glove && game_data::skin_kits[k].name.length() < query_length)
									continue;

								if (!is_glove && !findStringIC(game_data::skin_kits[k].name, query))
									continue;

								if (is_glove && game_data::glove_kits[k].name.length() < query_length)
									continue;

								if (is_glove && !findStringIC(game_data::glove_kits[k].name, query))
									continue;
							}

							ImVec4 color;
							if (is_glove ? game_data::glove_kits[k].rarity : game_data::skin_kits[k].rarity == 1)
								color = ImVec4(0.69f, 0.76f, 0.85f, 1.f);
							else if (is_glove ? game_data::glove_kits[k].rarity : game_data::skin_kits[k].rarity == 2)
								color = ImVec4(0.29f, 0.41f, 1.f, 1.f);
							else if (is_glove ? game_data::glove_kits[k].rarity : game_data::skin_kits[k].rarity == 3)
								color = ImVec4(0.36f, 0.60f, 0.85f, 1.f);
							else if (is_glove ? game_data::glove_kits[k].rarity : game_data::skin_kits[k].rarity == 4)
								color = ImVec4(0.53f, 0.27f, 1.f, 1.f);
							else if (is_glove ? game_data::glove_kits[k].rarity : game_data::skin_kits[k].rarity == 5)
								color = ImVec4(0.82f, 0.17f, 0.90f, 1.f);
							else if (is_glove ? game_data::glove_kits[k].rarity : game_data::skin_kits[k].rarity == 6)
								color = ImVec4(0.92f, 0.29f, 0.29f, 1.f);
							else if (is_glove ? game_data::glove_kits[k].rarity : game_data::skin_kits[k].rarity == 7)
								color = ImVec4(0.89f, 0.68f, 0.22f, 1.f);
							else
								continue;

							ImGui::PushStyleColor(ImGuiCol_Text, color);
							
							char buf_name[256];
								sprintf_s(buf_name, sizeof(buf_name), "%s##%d", name, game_data::skin_kits[k].id);
								if (selectable(buf_name, game_data::skin_kits[k].id == selected_entry.paint_kit_index))
									selected_entry.paint_kit_index = game_data::skin_kits[k].id;

							ImGui::PopStyleColor();
						}
					}
					ImGui::ListBoxFooter();

					ImGui::PopStyleColor(3);
				});

			ImGui::NextColumn();

			child("Customizing", [&selected_entry]()
				{
					if (selected_entry.definition_index == WEAPON_KNIFE || selected_entry.definition_index == WEAPON_KNIFE_T)
					{
						ImGui::Text("Model");

						std::string knife_name;
						for (const auto& item : skins::knife_names)
						{
							if (item.definition_index == selected_entry.definition_override_index)
								knife_name = item.name;
						}

						if (ImGui::BeginCombo("##skins.knives", knife_name.c_str(), ImGuiComboFlags_HeightLarge))
						{
							for (auto& item : skins::knife_names)
							{
								if (ImGui::Selectable(item.name, selected_entry.definition_override_index == item.definition_index))
									selected_entry.definition_override_index = item.definition_index;
							}

							ImGui::EndCombo();
						}
					}
					else if (selected_entry.definition_index == GLOVE_CT_SIDE || selected_entry.definition_index == GLOVE_T_SIDE)
					{
						ImGui::Text("Model");

						std::string glove_name;
						for (const auto& item : skins::glove_names)
						{
							if (item.definition_index == selected_entry.definition_override_index)
								glove_name = item.name;
						}

						if (ImGui::BeginCombo("##skins.knives", glove_name.c_str(), ImGuiComboFlags_HeightLarge))
						{
							for (auto& item : skins::glove_names)
							{
								if (ImGui::Selectable(item.name, selected_entry.definition_override_index == item.definition_index))
									selected_entry.definition_override_index = item.definition_index;
							}

							ImGui::EndCombo();
						}
					}
					else
						selected_entry.definition_override_index = 0;

					if (selected_entry.definition_index != GLOVE_CT_SIDE && selected_entry.definition_index != GLOVE_T_SIDE)
						checkbox("Enabled", &selected_entry.enabled);

					//ImGui::SliderFloatLeftAligned(___("Wear:", u8"Èçíîñ:"), &selected_entry.wear, FLT_MIN, 1.f, "%.10f");
					ImGui::Text("Wear:");
					ImGui::InputFloat("##skins.wear", &selected_entry.wear);
					tooltip("FN: 0 - 0.07, MW: 0.08 - 0.14, FT: 0.15 - 0.38, WW: 0.39 - 0.45, BS: 0.46");

					ImGui::Text("Seed");
					ImGui::InputInt("##skins.seed", &selected_entry.seed);

					if (selected_entry.definition_index != GLOVE_CT_SIDE && selected_entry.definition_index != GLOVE_T_SIDE)
					{
						ImGui::Text("Name Tag");
						ImGui::InputText("##skins.nametag", selected_entry.custom_name, 32);
					}

					if (ImGui::Button("Apply", ImVec2(ImGui::GetContentRegionAvailWidth(), 18.f)))
					{
						utils::force_full_update();
					}

					if (ImGui::Button("Save", ImVec2(ImGui::GetContentRegionAvailWidth(), 18.f)))
					{
						skins::save();

						notifies::push("Skin config saved", notify_state_s::success_state);
					}
				});
		}
	}
}
```

`src/render/tabs/visuals_tab.cpp`:

```cpp
#include "../render.h"
#include "../../settings/globals.h"
#include "../../settings/settings.h"
#include "../../helpers/imdraw.h"
#include "../../helpers/console.h"
#include "../..//features/features.h"
#include "../menu_strings.h"

extern void bind_button(const char* label, int& key);
extern bool Hotkey(const char* label, int* k, const ImVec2& size_arg = ImVec2(0.f, 0.f));


namespace render
{
	namespace menu
	{
		void visuals_tab()
		{
			child("ESP", []()
				{
					columns(2);
					{
						checkbox("Enabled", &settings::esp::enabled);

						ImGui::NextColumn();

						ImGui::PushItemWidth(-1);
						Hotkey("##binds.esp", &globals::binds::esp);
						ImGui::PopItemWidth();
					}
					columns(1);

					checkbox("Visible Only", &settings::esp::visible_only);

					if (settings::esp::visible_only)
						checkbox("Sound Visible", &settings::esp::visible_on_sound);
					
					checkbox("Name", &settings::esp::names);

					columns(2);
					{
						checkbox("Weapon", &settings::esp::weapons);

						ImGui::NextColumn();

						ImGui::PushItemWidth(-1);
						{
							ImGui::Combo("Mode", &settings::esp::weapon_mode, render::visual_tab::weapon_modes, IM_ARRAYSIZE(render::visual_tab::weapon_modes));
						}
						ImGui::PopItemWidth();
					}
					ImGui::Columns(1);

					columns(2);
					{
						checkbox("Player Info Box", &settings::visuals::player_info_box);

						ImGui::NextColumn();
						ImGui::PushItemWidth(-1);
						{
							ImGui::SliderFloatLeftAligned("Alpha##infobox", &settings::visuals::player_info_box_alpha, 0.0f, 1.0f, "%0.1f");
						}
						ImGui::PopItemWidth();
					}
					ImGui::Columns(1);

					columns(2);
					{
						checkbox("Boxes", &settings::esp::boxes);

						ImGui::NextColumn();

						ImGui::PushItemWidth(-1);
						{
							ImGui::Combo("##esp.box_type", &settings::esp::box_type, render::visual_tab::box_types, IM_ARRAYSIZE(render::visual_tab::box_types));
						}
						ImGui::PopItemWidth();
					}
					ImGui::Columns(1);

					
					columns(2);
					{
						checkbox("Health", &settings::esp::health);

						ImGui::NextColumn();

						ImGui::PushItemWidth(-1);
						ImGui::Combo("##health.position", &settings::esp::health_position, render::visual_tab::positions, IM_ARRAYSIZE(render::visual_tab::positions));
						ImGui::PopItemWidth();
					}
					columns(1);

					columns(2);
					{
						checkbox("Armor", &settings::esp::armour);

						ImGui::NextColumn();

						ImGui::PushItemWidth(-1);
						ImGui::Combo("##armor.position", &settings::esp::armour_position, render::visual_tab::positions, IM_ARRAYSIZE(render::visual_tab::positions));
						ImGui::PopItemWidth();
					}
					columns(1);

					checkbox("Bone ESP", &settings::esp::bone_esp);
					checkbox("Is Scoped", &settings::esp::is_scoped);
					checkbox("Is Flashed", &settings::esp::is_flashed);
					checkbox("Is Defusing", &settings::esp::is_defusing);
					checkbox("Ammo ESP", &settings::esp::ammo);
					checkbox("Bomb Carrier ESP", &settings::esp::bomb_esp);
					checkbox("Offscreen ESP", &settings::esp::offscreen);
				});

			ImGui::NextColumn();

			child("Chams", []()
				{
					ImGui::Combo("List##chams", &settings::chams::chams_list_mode, render::visual_tab::chams_list, IM_ARRAYSIZE(render::visual_tab::chams_list));

					bool b_wip = false;

					switch (settings::chams::chams_list_mode)
					{
					case 0:
						columns(2);
						{
							checkbox("Enabled", &settings::chams::enemy::enabled);

							checkbox("Health", &settings::chams::enemy::health_chams);

							ImGui::NextColumn();

							ImGui::PushItemWidth(-1);
							checkbox("Visible only", &settings::chams::enemy::visible_only);
							ImGui::PopItemWidth();
						}
						columns(1);
						break;
					case 1:
						columns(2);
						{
							checkbox("Enabled", &settings::chams::teammates::enabled);

							checkbox("Health", &settings::chams::teammates::health_chams);

							ImGui::NextColumn();

							ImGui::PushItemWidth(-1);
							checkbox("Visible only", &settings::chams::teammates::visible_only);
							ImGui::PopItemWidth();
						}
						columns(1);
						break;
					}
				});

			ImGui::NextColumn();

			child("Extra", []()
				{
					checkbox("Buy Log", &settings::esp::buylog);
					checkbox("Planted C4", &settings::visuals::planted_c4);
					checkbox("World Weapons", &settings::visuals::dropped_weapons);
					checkbox("World Grenades", &settings::visuals::world_grenades);
					checkbox("Sniper Crosshair", &settings::visuals::sniper_crosshair);
					checkbox("Grenade Prediction", &settings::visuals::grenade_prediction);
	
					columns(2);
					{
						checkbox("RCS Crosshair", &settings::visuals::rcs_cross);

						ImGui::NextColumn();

						ImGui::PushItemWidth(-1);
						ImGui::Combo("RCS Crosshair Type", &settings::visuals::rcs_cross_mode, render::visual_tab::cross_types, IM_ARRAYSIZE(render::visual_tab::cross_types));
						ImGui::PopItemWidth();
					}
					columns(1);

					if (settings::visuals::rcs_cross_mode == 1)
						ImGui::SliderFloatLeftAligned("Radius", &settings::visuals::radius, 8.f, 18.f, "%.1f");

					checkbox("Night Mode", &settings::visuals::night_mode);
				});
		}
	}
}
```

`src/render/timers.cpp`:

```cpp
#include "render.h"
#include "../settings/globals.h"
#include "../settings/options.hpp"
#include "../helpers/imdraw.h"
#include "../helpers/entities.h"
#include "../features/features.h"
#include "..//helpers/notifies.h"

namespace render
{
	const char* get_time_as_string()
	{
		static tm now;
		static char t_now[16];

		std::time_t t = std::time(0);

		localtime_s(&now, &t);
		strftime(t_now, sizeof(t_now), xorstr_("%X"), &now);

		return t_now;
	}

	namespace timers
	{
		auto m_Framerate = 0.f;

		ConVar* cl_hud_playercount_pos = nullptr;

		decltype(entities::m_local) m_local;
		entities::player_data_t m_players[MAX_PLAYERS];
	
		void render_panel()
		{
			if (g::engine_client->IsDrawingLoadingImage())
				return;

			if (!cl_hud_playercount_pos)
				cl_hud_playercount_pos = g::cvar->find("cl_hud_playercount_pos");

			if (!cl_hud_playercount_pos)
				return;

			ImGui::PushFont(render::fonts::low_size);

			const auto screen_size = ImGui::GetIO().DisplaySize;

			const auto is_top = cl_hud_playercount_pos->GetBool();

			const auto start_color = ImGui::GetColorU32(ImVec4(0.1f, 0.1f, 0.1f, 0.0f));
			const auto end_color = ImGui::GetColorU32(ImVec4(0.1f, 0.1f, 0.1f, 1.f));

			static const auto fps_text_size = ImGui::CalcTextSize("FPS");

			const auto start_pos = ImVec2(screen_size.x / 2.f - 240.f, (is_top ? fps_text_size.y + 4.f : screen_size.y - fps_text_size.y - 4.f));
			const auto end_pos = ImVec2(screen_size.x / 2.f + 240.f, is_top ? 0.f : screen_size.y);

			if (entities::locker.try_lock())
			{
				memcpy(m_players, entities::m_items.front().players, sizeof(m_players));
				entities::locker.unlock();
			}

			globals::draw_list->AddRectFilledMultiColor(
				start_pos, ImVec2(start_pos.x + 240.f, end_pos.y), start_color, end_color, end_color, start_color
			);

			globals::draw_list->AddRectFilledMultiColor(
				ImVec2(start_pos.x + 240.f, start_pos.y), end_pos, end_color, start_color, start_color, end_color
			);

			char fps[256];
			sprintf(fps, "%4i", (int)(1.0f / m_Framerate));

			auto txt_size = ImGui::CalcTextSize(fps);
			auto text_pos = ImVec2(start_pos.x + 240.f - 2.f - txt_size.x, !is_top ? end_pos.y - 2.f - txt_size.y : end_pos.y + 2.f);

			const auto fps_color = g::global_vars->interval_per_tick * 0.8f < g::global_vars->absoluteframetime ? ImVec4(1.f, 0.37f, 0.15f, 1.f) : ImVec4(0.64f, 0.82f, 0.45f, 1.f);

			if (!m_local.bomb_has_been_planted)
			{
				imdraw::outlined_text(fps, text_pos, ImGui::GetColorU32(fps_color));

				txt_size = ImGui::CalcTextSize("FPS");
				text_pos = ImVec2(start_pos.x + 240.f + 2.f, !is_top ? end_pos.y - 2.f - txt_size.y : end_pos.y + 2.f);
				imdraw::outlined_text("FPS", text_pos, ImGui::GetColorU32(ImVec4::White));

				const char* current_time = get_time_as_string();

				auto current_time_txt_size = ImGui::CalcTextSize(current_time);

				imdraw::outlined_text(current_time, ImVec2(text_pos.x + current_time_txt_size.x, text_pos.y), ImGui::GetColorU32(ImVec4::White));
			}

			if (m_local.is_matchmaking) //TODO: Recode using std::format
			{
				char bomb_time[16];
				sprintf_s(bomb_time, "%.2f", m_local.bomb_time);

				const auto bomb_color = m_local.bomb_time > 0.f ? ImVec4(0.88f, 0.82f, 0.45f, 1.f) : ImVec4(1.f, 1.f, 1.f, 1.f);

				char defuse_time[16];
				sprintf_s(defuse_time, "%.2f", m_local.defuse_time);

				char bomb_location[256];
				sprintf_s(bomb_location, "%s", m_local.bombsite_index ? "BOMB: B" : "BOMB: A");

				char hp[256];
				sprintf_s(hp, "%d", m_local.hp);

				static const auto mp_c4timer = g::cvar->find("mp_c4timer");

				if (m_local.is_bomb_planted && (m_local.bomb_time > 0.f && m_local.bomb_time <= mp_c4timer->GetFloat()))
				{
					const auto bomb_text_size = ImGui::CalcTextSize("BOMB");
					txt_size = ImGui::CalcTextSize(bomb_time);
					text_pos = ImVec2(start_pos.x + 240.f - 2.f - txt_size.x - 25.f - 30.f - bomb_text_size.x - 4.f - txt_size.x, !is_top ? end_pos.y - 2.f - txt_size.y : end_pos.y + 2.f);
					imdraw::outlined_text(bomb_time, text_pos, ImGui::GetColorU32(bomb_color));

					txt_size = ImGui::CalcTextSize(defuse_time);
					text_pos = ImVec2(start_pos.x + 319.f - txt_size.x - 4.f, !is_top ? end_pos.y - 2.f - txt_size.y : end_pos.y + 2.f);

					const auto defuse_color = m_local.defuse_time > 0.f ? ImVec4(0.f, 1.f, 0.15f, 1.f) : ImVec4(1.f, 1.f, 1.f, 1.f);
					imdraw::outlined_text(defuse_time, text_pos, ImGui::GetColorU32(defuse_color));

					const auto speed_text_size = ImGui::CalcTextSize("DEFUSE");

					text_pos = ImVec2(start_pos.x + 240.f + 2.f + 25.f + 30.f + 22.f, !is_top ? end_pos.y - 2.f - speed_text_size.y : end_pos.y + 2.f);
					imdraw::outlined_text("DEFUSE", text_pos, ImGui::GetColorU32(ImVec4::White));

					text_pos = ImVec2(start_pos.x + 240.f - 2.f - txt_size.x - 25.f - 30.f - bomb_text_size.x, !is_top ? end_pos.y - 2.f - bomb_text_size.y : end_pos.y + 2.f);
					imdraw::outlined_text(bomb_location, text_pos, ImGui::GetColorU32(ImVec4::White));

					txt_size = ImGui::CalcTextSize(hp);

					if (m_local.is_alive) 
					{
						text_pos = ImVec2(start_pos.x + 240.f - 2.f - txt_size.x, !is_top ? end_pos.y - 2.f - txt_size.y : end_pos.y + 2.f);
						imdraw::outlined_text(m_local.hp <= 0 ? "DEAD" : hp, text_pos, ImGui::GetColorU32(m_local.hp <= 0 ? ImVec4::Red : bomb_color));

						if (m_local.hp > 0)
						{
							text_pos = ImVec2(start_pos.x + 240.f + 2.f, !is_top ? end_pos.y - 2.f - txt_size.y : end_pos.y + 2.f);
							imdraw::outlined_text("HP", text_pos, ImGui::GetColorU32(ImVec4::White));
						}
					}
				}
			}
			ImGui::PopFont();
		}

		void show()
		{
			m_Framerate = 0.9 * m_Framerate + (1.0 - 0.9) * g::global_vars->absoluteframetime;

			if (!g::local_player || !render::fonts::low_size)
				return;

			if (entities::local_mutex.try_lock())
			{
				m_local = entities::m_local;

				entities::local_mutex.unlock();
			}

			render_panel();
		}
	}
}
```

`src/security/importer.h`:

```h
/*
 * Copyright 2018-2020 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// documentation is available at https://github.com/JustasMasiulis/lazy_importer

#ifndef LAZY_IMPORTER_HPP
#define LAZY_IMPORTER_HPP

#define LI_FN(name) \
    ::li::detail::lazy_function<::li::detail::khash(#name), decltype(&name)>()

#define LI_FN_DEF(name) ::li::detail::lazy_function<::li::detail::khash(#name), name>()

#define LI_MODULE(name) ::li::detail::lazy_module<::li::detail::khash(name)>()

// NOTE only std::forward is used from this header.
// If there is a need to eliminate this dependency the function itself is very small.

#include <utility>
#include <cstddef>
#include <intrin.h>

#ifndef LAZY_IMPORTER_NO_FORCEINLINE
#if defined(_MSC_VER)
#define LAZY_IMPORTER_FORCEINLINE __forceinline
#elif defined(__GNUC__) && __GNUC__ > 3
#define LAZY_IMPORTER_FORCEINLINE inline __attribute__((__always_inline__))
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif
#else
#define LAZY_IMPORTER_FORCEINLINE inline
#endif

#ifdef LAZY_IMPORTER_CASE_INSENSITIVE
#define LAZY_IMPORTER_TOLOWER(c) (c >= 'A' && c <= 'Z' ? (c | (1 << 5)) : c)
#else
#define LAZY_IMPORTER_TOLOWER(c) (c)
#endif

namespace li { namespace detail {

    template<class First, class Second>
    struct pair {
        First  first;
        Second second;
    };

    namespace win {

        struct LIST_ENTRY_T {
            const char* Flink;
            const char* Blink;
        };

        struct UNICODE_STRING_T {
            unsigned short Length;
            unsigned short MaximumLength;
            wchar_t*       Buffer;
        };

        struct PEB_LDR_DATA_T {
            unsigned long Length;
            unsigned long Initialized;
            const char*   SsHandle;
            LIST_ENTRY_T  InLoadOrderModuleList;
        };

        struct PEB_T {
            unsigned char   Reserved1[2];
            unsigned char   BeingDebugged;
            unsigned char   Reserved2[1];
            const char*     Reserved3[2];
            PEB_LDR_DATA_T* Ldr;
        };

        struct LDR_DATA_TABLE_ENTRY_T {
            LIST_ENTRY_T InLoadOrderLinks;
            LIST_ENTRY_T InMemoryOrderLinks;
            LIST_ENTRY_T InInitializationOrderLinks;
            const char*  DllBase;
            const char*  EntryPoint;
            union {
                unsigned long SizeOfImage;
                const char*   _dummy;
            };
            UNICODE_STRING_T FullDllName;
            UNICODE_STRING_T BaseDllName;

            LAZY_IMPORTER_FORCEINLINE const LDR_DATA_TABLE_ENTRY_T*
                                            load_order_next() const noexcept
            {
                return reinterpret_cast<const LDR_DATA_TABLE_ENTRY_T*>(
                    InLoadOrderLinks.Flink);
            }
        };

        struct IMAGE_DOS_HEADER { // DOS .EXE header
            unsigned short e_magic; // Magic number
            unsigned short e_cblp; // Bytes on last page of file
            unsigned short e_cp; // Pages in file
            unsigned short e_crlc; // Relocations
            unsigned short e_cparhdr; // Size of header in paragraphs
            unsigned short e_minalloc; // Minimum extra paragraphs needed
            unsigned short e_maxalloc; // Maximum extra paragraphs needed
            unsigned short e_ss; // Initial (relative) SS value
            unsigned short e_sp; // Initial SP value
            unsigned short e_csum; // Checksum
            unsigned short e_ip; // Initial IP value
            unsigned short e_cs; // Initial (relative) CS value
            unsigned short e_lfarlc; // File address of relocation table
            unsigned short e_ovno; // Overlay number
            unsigned short e_res[4]; // Reserved words
            unsigned short e_oemid; // OEM identifier (for e_oeminfo)
            unsigned short e_oeminfo; // OEM information; e_oemid specific
            unsigned short e_res2[10]; // Reserved words
            long           e_lfanew; // File address of new exe header
        };

        struct IMAGE_FILE_HEADER {
            unsigned short Machine;
            unsigned short NumberOfSections;
            unsigned long  TimeDateStamp;
            unsigned long  PointerToSymbolTable;
            unsigned long  NumberOfSymbols;
            unsigned short SizeOfOptionalHeader;
            unsigned short Characteristics;
        };

        struct IMAGE_EXPORT_DIRECTORY {
            unsigned long  Characteristics;
            unsigned long  TimeDateStamp;
            unsigned short MajorVersion;
            unsigned short MinorVersion;
            unsigned long  Name;
            unsigned long  Base;
            unsigned long  NumberOfFunctions;
            unsigned long  NumberOfNames;
            unsigned long  AddressOfFunctions; // RVA from base of image
            unsigned long  AddressOfNames; // RVA from base of image
            unsigned long  AddressOfNameOrdinals; // RVA from base of image
        };

        struct IMAGE_DATA_DIRECTORY {
            unsigned long VirtualAddress;
            unsigned long Size;
        };

        struct IMAGE_OPTIONAL_HEADER64 {
            unsigned short       Magic;
            unsigned char        MajorLinkerVersion;
            unsigned char        MinorLinkerVersion;
            unsigned long        SizeOfCode;
            unsigned long        SizeOfInitializedData;
            unsigned long        SizeOfUninitializedData;
            unsigned long        AddressOfEntryPoint;
            unsigned long        BaseOfCode;
            unsigned long long   ImageBase;
            unsigned long        SectionAlignment;
            unsigned long        FileAlignment;
            unsigned short       MajorOperatingSystemVersion;
            unsigned short       MinorOperatingSystemVersion;
            unsigned short       MajorImageVersion;
            unsigned short       MinorImageVersion;
            unsigned short       MajorSubsystemVersion;
            unsigned short       MinorSubsystemVersion;
            unsigned long        Win32VersionValue;
            unsigned long        SizeOfImage;
            unsigned long        SizeOfHeaders;
            unsigned long        CheckSum;
            unsigned short       Subsystem;
            unsigned short       DllCharacteristics;
            unsigned long long   SizeOfStackReserve;
            unsigned long long   SizeOfStackCommit;
            unsigned long long   SizeOfHeapReserve;
            unsigned long long   SizeOfHeapCommit;
            unsigned long        LoaderFlags;
            unsigned long        NumberOfRvaAndSizes;
            IMAGE_DATA_DIRECTORY DataDirectory[16];
        };

        struct IMAGE_OPTIONAL_HEADER32 {
            unsigned short       Magic;
            unsigned char        MajorLinkerVersion;
            unsigned char        MinorLinkerVersion;
            unsigned long        SizeOfCode;
            unsigned long        SizeOfInitializedData;
            unsigned long        SizeOfUninitializedData;
            unsigned long        AddressOfEntryPoint;
            unsigned long        BaseOfCode;
            unsigned long        BaseOfData;
            unsigned long        ImageBase;
            unsigned long        SectionAlignment;
            unsigned long        FileAlignment;
            unsigned short       MajorOperatingSystemVersion;
            unsigned short       MinorOperatingSystemVersion;
            unsigned short       MajorImageVersion;
            unsigned short       MinorImageVersion;
            unsigned short       MajorSubsystemVersion;
            unsigned short       MinorSubsystemVersion;
            unsigned long        Win32VersionValue;
            unsigned long        SizeOfImage;
            unsigned long        SizeOfHeaders;
            unsigned long        CheckSum;
            unsigned short       Subsystem;
            unsigned short       DllCharacteristics;
            unsigned long        SizeOfStackReserve;
            unsigned long        SizeOfStackCommit;
            unsigned long        SizeOfHeapReserve;
            unsigned long        SizeOfHeapCommit;
            unsigned long        LoaderFlags;
            unsigned long        NumberOfRvaAndSizes;
            IMAGE_DATA_DIRECTORY DataDirectory[16];
        };

        struct IMAGE_NT_HEADERS {
            unsigned long     Signature;
            IMAGE_FILE_HEADER FileHeader;
#ifdef _WIN64
            IMAGE_OPTIONAL_HEADER64 OptionalHeader;
#else
            IMAGE_OPTIONAL_HEADER32 OptionalHeader;
#endif
        };

    } // namespace win

    // hashing stuff
    struct hash_t {
        using value_type                            = unsigned long;
        constexpr static value_type         offset  = 2166136261;
        constexpr static value_type         prime   = 16777619;
        constexpr static unsigned long long prime64 = prime;

        LAZY_IMPORTER_FORCEINLINE constexpr static value_type single(value_type value,
                                                                     char c) noexcept
        {
            return static_cast<hash_t::value_type>(
                (value ^ LAZY_IMPORTER_TOLOWER(c)) *
                static_cast<unsigned long long>(prime));
        }
    };

    template<class CharT = char>
    LAZY_IMPORTER_FORCEINLINE constexpr hash_t::value_type
    khash(const CharT* str, hash_t::value_type value = hash_t::offset) noexcept
    {
        return (*str ? khash(str + 1, hash_t::single(value, *str)) : value);
    }

    template<class CharT = char>
    LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(const CharT* str) noexcept
    {
        hash_t::value_type value = hash_t::offset;

        for(;;) {
            char c = *str++;
            if(!c)
                return value;
            value = hash_t::single(value, c);
        }
    }

    LAZY_IMPORTER_FORCEINLINE hash_t::value_type hash(
        const win::UNICODE_STRING_T& str) noexcept
    {
        auto       first = str.Buffer;
        const auto last  = first + (str.Length / sizeof(wchar_t));
        auto       value = hash_t::offset;
        for(; first != last; ++first)
            value = hash_t::single(value, static_cast<char>(*first));

        return value;
    }

    LAZY_IMPORTER_FORCEINLINE pair<hash_t::value_type, hash_t::value_type> hash_forwarded(
        const char* str) noexcept
    {
        pair<hash_t::value_type, hash_t::value_type> module_and_function{
            hash_t::offset, hash_t::offset
        };

        for(; *str != '.'; ++str)
            module_and_function.first = hash_t::single(module_and_function.first, *str);

        ++str;

        for(; *str; ++str)
            module_and_function.second = hash_t::single(module_and_function.second, *str);

        return module_and_function;
    }


    // some helper functions
    LAZY_IMPORTER_FORCEINLINE const win::PEB_T* peb() noexcept
    {
#if defined(_M_X64) || defined(__amd64__)
        return reinterpret_cast<const win::PEB_T*>(__readgsqword(0x60));
#elif defined(_M_IX86) || defined(__i386__)
        return reinterpret_cast<const win::PEB_T*>(__readfsdword(0x30));
#elif defined(_M_ARM) || defined(__arm__)
        return *reinterpret_cast<const win::PEB_T**>(_MoveFromCoprocessor(15, 0, 13, 0, 2) + 0x30);
#elif defined(_M_ARM64) || defined(__aarch64__)
        return *reinterpret_cast<const win::PEB_T**>(__getReg(18) + 0x60);
#elif defined(_M_IA64) || defined(__ia64__)
        return *reinterpret_cast<const win::PEB_T**>(static_cast<char*>(_rdteb()) + 0x60);
#else
#error Unsupported platform. Open an issue and I'll probably add support.
#endif
    }

    LAZY_IMPORTER_FORCEINLINE const win::PEB_LDR_DATA_T* ldr()
    {
        return reinterpret_cast<const win::PEB_LDR_DATA_T*>(peb()->Ldr);
    }

    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_NT_HEADERS* nt_headers(
        const char* base) noexcept
    {
        return reinterpret_cast<const win::IMAGE_NT_HEADERS*>(
            base + reinterpret_cast<const win::IMAGE_DOS_HEADER*>(base)->e_lfanew);
    }

    LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* image_export_dir(
        const char* base) noexcept
    {
        return reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
            base + nt_headers(base)->OptionalHeader.DataDirectory->VirtualAddress);
    }

    LAZY_IMPORTER_FORCEINLINE const win::LDR_DATA_TABLE_ENTRY_T* ldr_data_entry() noexcept
    {
        return reinterpret_cast<const win::LDR_DATA_TABLE_ENTRY_T*>(
            ldr()->InLoadOrderModuleList.Flink);
    }

    struct exports_directory {
        const char*                        _base;
        const win::IMAGE_EXPORT_DIRECTORY* _ied;
        unsigned long                      _ied_size;

    public:
        using size_type = unsigned long;

        LAZY_IMPORTER_FORCEINLINE
        exports_directory(const char* base) noexcept : _base(base)
        {
            const auto ied_data_dir = nt_headers(base)->OptionalHeader.DataDirectory[0];
            _ied = reinterpret_cast<const win::IMAGE_EXPORT_DIRECTORY*>(
                base + ied_data_dir.VirtualAddress);
            _ied_size = ied_data_dir.Size;
        }

        LAZY_IMPORTER_FORCEINLINE explicit operator bool() const noexcept
        {
            return reinterpret_cast<const char*>(_ied) != _base;
        }

        LAZY_IMPORTER_FORCEINLINE size_type size() const noexcept
        {
            return _ied->NumberOfNames;
        }

        LAZY_IMPORTER_FORCEINLINE const char* base() const noexcept { return _base; }
        LAZY_IMPORTER_FORCEINLINE const win::IMAGE_EXPORT_DIRECTORY* ied() const noexcept
        {
            return _ied;
        }

        LAZY_IMPORTER_FORCEINLINE const char* name(size_type index) const noexcept
        {
            return reinterpret_cast<const char*>(
                _base + reinterpret_cast<const unsigned long*>(
                            _base + _ied->AddressOfNames)[index]);
        }

        LAZY_IMPORTER_FORCEINLINE const char* address(size_type index) const noexcept
        {
            const auto* const rva_table =
                reinterpret_cast<const unsigned long*>(_base + _ied->AddressOfFunctions);

            const auto* const ord_table = reinterpret_cast<const unsigned short*>(
                _base + _ied->AddressOfNameOrdinals);

            return _base + rva_table[ord_table[index]];
        }

        LAZY_IMPORTER_FORCEINLINE bool is_forwarded(
            const char* export_address) const noexcept
        {
            const auto ui_ied = reinterpret_cast<const char*>(_ied);
            return (export_address > ui_ied && export_address < ui_ied + _ied_size);
        }
    };

    struct safe_module_enumerator {
        using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T;
        value_type* value;
        value_type* head;

        LAZY_IMPORTER_FORCEINLINE safe_module_enumerator() noexcept
            : safe_module_enumerator(ldr_data_entry())
        {}

        LAZY_IMPORTER_FORCEINLINE
        safe_module_enumerator(const detail::win::LDR_DATA_TABLE_ENTRY_T* ldr) noexcept
            : value(ldr->load_order_next()), head(value)
        {}

        LAZY_IMPORTER_FORCEINLINE void reset() noexcept
        {
            value = head->load_order_next();
        }

        LAZY_IMPORTER_FORCEINLINE bool next() noexcept
        {
            value = value->load_order_next();

            return value != head && value->DllBase;
        }
    };

    struct unsafe_module_enumerator {
        using value_type = const detail::win::LDR_DATA_TABLE_ENTRY_T*;
        value_type value;

        LAZY_IMPORTER_FORCEINLINE unsafe_module_enumerator() noexcept
            : value(ldr_data_entry())
        {}

        LAZY_IMPORTER_FORCEINLINE void reset() noexcept { value = ldr_data_entry(); }

        LAZY_IMPORTER_FORCEINLINE bool next() noexcept
        {
            value = value->load_order_next();
            return true;
        }
    };

    // provides the cached functions which use Derive classes methods
    template<class Derived, class DefaultType = void*>
    class lazy_base {
    protected:
        // This function is needed because every templated function
        // with different args has its own static buffer
        LAZY_IMPORTER_FORCEINLINE static void*& _cache() noexcept
        {
            static void* value = nullptr;
            return value;
        }

    public:
        template<class T = DefaultType>
        LAZY_IMPORTER_FORCEINLINE static T safe() noexcept
        {
            return Derived::template get<T, safe_module_enumerator>();
        }

        template<class T = DefaultType, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static T cached() noexcept
        {
            auto& cached = _cache();
            if(!cached)
                cached = Derived::template get<void*, Enum>();

            return (T)(cached);
        }

        template<class T = DefaultType>
        LAZY_IMPORTER_FORCEINLINE static T safe_cached() noexcept
        {
            return cached<T, safe_module_enumerator>();
        }
    };

    template<hash_t::value_type Hash>
    struct lazy_module : lazy_base<lazy_module<Hash>> {
        template<class T = void*, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static T get() noexcept
        {
            Enum e;
            do {
                if(hash(e.value->BaseDllName) == Hash)
                    return (T)(e.value->DllBase);
            } while(e.next());
            return {};
        }

        template<class T = void*, class Ldr>
        LAZY_IMPORTER_FORCEINLINE static T in(Ldr ldr) noexcept
        {
            safe_module_enumerator e((const detail::win::LDR_DATA_TABLE_ENTRY_T*)(ldr));
            do {
                if(hash(e.value->BaseDllName) == Hash)
                    return (T)(e.value->DllBase);
            } while(e.next());
            return {};
        }

        template<class T = void*, class Ldr>
        LAZY_IMPORTER_FORCEINLINE static T in_cached(Ldr ldr) noexcept
        {
            auto& cached = lazy_base<lazy_module<Hash>>::_cache();
            if(!cached)
                cached = in(ldr);

            return (T)(cached);
        }
    };

    template<hash_t::value_type Hash, class T>
    struct lazy_function : lazy_base<lazy_function<Hash, T>, T> {
        using base_type = lazy_base<lazy_function<Hash, T>, T>;

        template<class... Args>
        LAZY_IMPORTER_FORCEINLINE decltype(auto) operator()(Args&&... args) const
        {
#ifndef LAZY_IMPORTER_CACHE_OPERATOR_PARENS
            return get()(std::forward<Args>(args)...);
#else
            return this->cached()(std::forward<Args>(args)...);
#endif
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F get() noexcept
        {
            // for backwards compatability.
            // Before 2.0 it was only possible to resolve forwarded exports when
            // this macro was enabled
#ifdef LAZY_IMPORTER_RESOLVE_FORWARDED_EXPORTS
            return forwarded<F, Enum>();
#else

            Enum e;

            do {
#ifdef LAZY_IMPORTER_HARDENED_MODULE_CHECKS
                if(!e.value->DllBase || !e.value->FullDllName.Length)
                    continue;
#endif

                const exports_directory exports(e.value->DllBase);

                if(exports) {
                    auto export_index = exports.size();
                    while(export_index--)
                        if(hash(exports.name(export_index)) == Hash)
                            return (F)(exports.address(export_index));
                }
            } while(e.next());
            return {};
#endif
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F forwarded() noexcept
        {
            detail::win::UNICODE_STRING_T name;
            hash_t::value_type            module_hash   = 0;
            auto                          function_hash = Hash;

            Enum e;
            do {
                name = e.value->BaseDllName;
                name.Length -= 8; // get rid of .dll extension

                if(!module_hash || hash(name) == module_hash) {
                    const exports_directory exports(e.value->DllBase);

                    if(exports) {
                        auto export_index = exports.size();
                        while(export_index--)
                            if(hash(exports.name(export_index)) == function_hash) {
                                const auto addr = exports.address(export_index);

                                if(exports.is_forwarded(addr)) {
                                    auto hashes = hash_forwarded(
                                        reinterpret_cast<const char*>(addr));

                                    function_hash = hashes.second;
                                    module_hash   = hashes.first;

                                    e.reset();
                                    break;
                                }
                                return (F)(addr);
                            }
                    }
                }
            } while(e.next());
            return {};
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_safe() noexcept
        {
            return forwarded<F, safe_module_enumerator>();
        }

        template<class F = T, class Enum = unsafe_module_enumerator>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_cached() noexcept
        {
            auto& value = base_type::_cache();
            if(!value)
                value = forwarded<void*, Enum>();
            return (F)(value);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F forwarded_safe_cached() noexcept
        {
            return forwarded_cached<F, safe_module_enumerator>();
        }

        template<class F = T, bool IsSafe = false, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in(Module m) noexcept
        {
            if(IsSafe && !m)
                return {};

            const exports_directory exports((const char*)(m));
            if(IsSafe && !exports)
                return {};

            for(unsigned long i{};; ++i) {
                if(IsSafe && i == exports.size())
                    break;

                if(hash(exports.name(i)) == Hash)
                    return (F)(exports.address(i));
            }
            return {};
        }

        template<class F = T, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_safe(Module m) noexcept
        {
            return in<F, true>(m);
        }

        template<class F = T, bool IsSafe = false, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_cached(Module m) noexcept
        {
            auto& value = base_type::_cache();
            if(!value)
                value = in<void*, IsSafe>(m);
            return (F)(value);
        }

        template<class F = T, class Module>
        LAZY_IMPORTER_FORCEINLINE static F in_safe_cached(Module m) noexcept
        {
            return in_cached<F, true>(m);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt() noexcept
        {
            return in<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_safe() noexcept
        {
            return in_safe<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_cached() noexcept
        {
            return in_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
        }

        template<class F = T>
        LAZY_IMPORTER_FORCEINLINE static F nt_safe_cached() noexcept
        {
            return in_safe_cached<F>(ldr_data_entry()->load_order_next()->DllBase);
        }
    };

}} // namespace li::detail

#endif // include guard

```

`src/security/xor.h`:

```h
#pragma once

/*
 * Copyright 2017 - 2021 Justas Masiulis
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifndef JM_XORSTR_HPP
#define JM_XORSTR_HPP

#if defined(_M_ARM64) || defined(__aarch64__) || defined(_M_ARM) || defined(__arm__)
#include <arm_neon.h>
#elif defined(_M_X64) || defined(__amd64__) || defined(_M_IX86) || defined(__i386__)
#include <immintrin.h>
#else
#error Unsupported platform
#endif

#include <cstdint>
#include <cstddef>
#include <utility>
#include <type_traits>

#define xorstr(str) ::jm::xor_string([]() { return str; }, std::integral_constant<std::size_t, sizeof(str) / sizeof(*str)>{}, std::make_index_sequence<::jm::detail::_buffer_size<sizeof(str)>()>{})
#define xorstr_(str) xorstr(str).crypt_get()

#ifdef _MSC_VER
#define XORSTR_FORCEINLINE __forceinline
#else
#define XORSTR_FORCEINLINE __attribute__((always_inline)) inline
#endif

namespace jm {

    namespace detail {

        template<std::size_t Size>
        XORSTR_FORCEINLINE constexpr std::size_t _buffer_size()
        {
            return ((Size / 16) + (Size % 16 != 0)) * 2;
        }

        template<std::uint32_t Seed>
        XORSTR_FORCEINLINE constexpr std::uint32_t key4() noexcept
        {
            std::uint32_t value = Seed;
            for(char c : __TIME__)
                value = static_cast<std::uint32_t>((value ^ c) * 16777619ull);
            return value;
        }

        template<std::size_t S>
        XORSTR_FORCEINLINE constexpr std::uint64_t key8()
        {
            constexpr auto first_part  = key4<2166136261 + S>();
            constexpr auto second_part = key4<first_part>();
            return (static_cast<std::uint64_t>(first_part) << 32) | second_part;
        }

        // loads up to 8 characters of string into uint64 and xors it with the key
        template<std::size_t N, class CharT>
        XORSTR_FORCEINLINE constexpr std::uint64_t
        load_xored_str8(std::uint64_t key, std::size_t idx, const CharT* str) noexcept
        {
            using cast_type = typename std::make_unsigned<CharT>::type;
            constexpr auto value_size = sizeof(CharT);
            constexpr auto idx_offset = 8 / value_size;

            std::uint64_t value = key;
            for(std::size_t i = 0; i < idx_offset && i + idx * idx_offset < N; ++i)
                value ^=
                    (std::uint64_t{ static_cast<cast_type>(str[i + idx * idx_offset]) }
                     << ((i % idx_offset) * 8 * value_size));

            return value;
        }

        // forces compiler to use registers instead of stuffing constants in rdata
        XORSTR_FORCEINLINE std::uint64_t load_from_reg(std::uint64_t value) noexcept
        {
#if defined(__clang__) || defined(__GNUC__)
            asm("" : "=r"(value) : "0"(value) :);
            return value;
#else
            volatile std::uint64_t reg = value;
            return reg;
#endif
        }

    } // namespace detail

    template<class CharT, std::size_t Size, class Keys, class Indices>
    class xor_string;

    template<class CharT, std::size_t Size, std::uint64_t... Keys, std::size_t... Indices>
    class xor_string<CharT, Size, std::integer_sequence<std::uint64_t, Keys...>, std::index_sequence<Indices...>> {
#ifndef JM_XORSTR_DISABLE_AVX_INTRINSICS
        constexpr static inline std::uint64_t alignment = ((Size > 16) ? 32 : 16);    
#else
        constexpr static inline std::uint64_t alignment = 16;
#endif

        alignas(alignment) std::uint64_t _storage[sizeof...(Keys)];

    public:
        using value_type    = CharT;
        using size_type     = std::size_t;
        using pointer       = CharT*;
        using const_pointer = const CharT*;

        template<class L>
        XORSTR_FORCEINLINE xor_string(L l, std::integral_constant<std::size_t, Size>, std::index_sequence<Indices...>) noexcept
            : _storage{ ::jm::detail::load_from_reg((std::integral_constant<std::uint64_t, detail::load_xored_str8<Size>(Keys, Indices, l())>::value))... }
        {}

        XORSTR_FORCEINLINE constexpr size_type size() const noexcept
        {
            return Size - 1;
        }

        XORSTR_FORCEINLINE void crypt() noexcept
        {
            // everything is inlined by hand because a certain compiler with a certain linker is _very_ slow
#if defined(__clang__)
            alignas(alignment)
                std::uint64_t arr[]{ ::jm::detail::load_from_reg(Keys)... };
            std::uint64_t*    keys =
                (std::uint64_t*)::jm::detail::load_from_reg((std::uint64_t)arr);
#else
            alignas(alignment) std::uint64_t keys[]{ ::jm::detail::load_from_reg(Keys)... };
#endif

#if defined(_M_ARM64) || defined(__aarch64__) || defined(_M_ARM) || defined(__arm__)
#if defined(__clang__)
            ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : __builtin_neon_vst1q_v(
                                    reinterpret_cast<uint64_t*>(_storage) + Indices * 2,
                                    veorq_u64(__builtin_neon_vld1q_v(reinterpret_cast<const uint64_t*>(_storage) + Indices * 2, 51),
                                              __builtin_neon_vld1q_v(reinterpret_cast<const uint64_t*>(keys) + Indices * 2, 51)),
                                    51)), ...);
#else // GCC, MSVC
            ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : vst1q_u64(
                        reinterpret_cast<uint64_t*>(_storage) + Indices * 2,
                        veorq_u64(vld1q_u64(reinterpret_cast<const uint64_t*>(_storage) + Indices * 2),
                                  vld1q_u64(reinterpret_cast<const uint64_t*>(keys) + Indices * 2)))), ...);
#endif
#elif !defined(JM_XORSTR_DISABLE_AVX_INTRINSICS)
            ((Indices >= sizeof(_storage) / 32 ? static_cast<void>(0) : _mm256_store_si256(
                reinterpret_cast<__m256i*>(_storage) + Indices,
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(_storage) + Indices),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys) + Indices)))), ...);

            if constexpr(sizeof(_storage) % 32 != 0)
                _mm_store_si128(
                    reinterpret_cast<__m128i*>(_storage + sizeof...(Keys) - 2),
                    _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage + sizeof...(Keys) - 2)),
                                  _mm_load_si128(reinterpret_cast<const __m128i*>(keys + sizeof...(Keys) - 2))));
#else
        ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : _mm_store_si128(
            reinterpret_cast<__m128i*>(_storage) + Indices,
            _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage) + Indices),
                          _mm_load_si128(reinterpret_cast<const __m128i*>(keys) + Indices)))), ...);
#endif
        }

        XORSTR_FORCEINLINE const_pointer get() const noexcept
        {
            return reinterpret_cast<const_pointer>(_storage);
        }

        XORSTR_FORCEINLINE pointer get() noexcept
        {
            return reinterpret_cast<pointer>(_storage);
        }

        XORSTR_FORCEINLINE pointer crypt_get() noexcept
        {
            // crypt() is inlined by hand because a certain compiler with a certain linker is _very_ slow
#if defined(__clang__)
            alignas(alignment)
                std::uint64_t arr[]{ ::jm::detail::load_from_reg(Keys)... };
            std::uint64_t*    keys =
                (std::uint64_t*)::jm::detail::load_from_reg((std::uint64_t)arr);
#else
            alignas(alignment) std::uint64_t keys[]{ ::jm::detail::load_from_reg(Keys)... };
#endif

#if defined(_M_ARM64) || defined(__aarch64__) || defined(_M_ARM) || defined(__arm__)
#if defined(__clang__)
            ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : __builtin_neon_vst1q_v(
                                    reinterpret_cast<uint64_t*>(_storage) + Indices * 2,
                                    veorq_u64(__builtin_neon_vld1q_v(reinterpret_cast<const uint64_t*>(_storage) + Indices * 2, 51),
                                              __builtin_neon_vld1q_v(reinterpret_cast<const uint64_t*>(keys) + Indices * 2, 51)),
                                    51)), ...);
#else // GCC, MSVC
            ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : vst1q_u64(
                        reinterpret_cast<uint64_t*>(_storage) + Indices * 2,
                        veorq_u64(vld1q_u64(reinterpret_cast<const uint64_t*>(_storage) + Indices * 2),
                                  vld1q_u64(reinterpret_cast<const uint64_t*>(keys) + Indices * 2)))), ...);
#endif
#elif !defined(JM_XORSTR_DISABLE_AVX_INTRINSICS)
            ((Indices >= sizeof(_storage) / 32 ? static_cast<void>(0) : _mm256_store_si256(
                reinterpret_cast<__m256i*>(_storage) + Indices,
                _mm256_xor_si256(
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(_storage) + Indices),
                    _mm256_load_si256(reinterpret_cast<const __m256i*>(keys) + Indices)))), ...);

            if constexpr(sizeof(_storage) % 32 != 0)
                _mm_store_si128(
                    reinterpret_cast<__m128i*>(_storage + sizeof...(Keys) - 2),
                    _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage + sizeof...(Keys) - 2)),
                                  _mm_load_si128(reinterpret_cast<const __m128i*>(keys + sizeof...(Keys) - 2))));
#else
        ((Indices >= sizeof(_storage) / 16 ? static_cast<void>(0) : _mm_store_si128(
            reinterpret_cast<__m128i*>(_storage) + Indices,
            _mm_xor_si128(_mm_load_si128(reinterpret_cast<const __m128i*>(_storage) + Indices),
                          _mm_load_si128(reinterpret_cast<const __m128i*>(keys) + Indices)))), ...);
#endif

            return (pointer)(_storage);
        }
    };

    template<class L, std::size_t Size, std::size_t... Indices>
    xor_string(L l, std::integral_constant<std::size_t, Size>, std::index_sequence<Indices...>) -> xor_string<
                std::remove_const_t<std::remove_reference_t<decltype(l()[0])>>,
                Size,
                std::integer_sequence<std::uint64_t, detail::key8<Indices>()...>,
                std::index_sequence<Indices...>>;

} // namespace jm

#endif // include guard

```

`src/settings/config.cpp`:

```cpp
#include "config.h"
#include "../helpers/console.h"

#include <fstream>
#include <filesystem>

namespace fs = std::filesystem;

namespace config
{
	const std::string path = "C:\\Sensum";
	std::map<std::string, std::map<std::string, Json::Value>> cached;

	std::string path_to_folder(const std::string& folder)
	{
		return path + (folder.empty() ? "" : "/" + folder);
	}

	std::string path_to_file(const std::string& name, const std::string& folder)
	{
		const auto next = path_to_folder(folder);

		return next + (name.empty() ? "" : "/" + name);
	}

	Json::Value get_source(const std::string& name, const std::string& folder)
	{
		Json::Value root;

		std::ifstream source(path_to_file(name, folder), std::ifstream::binary);
		if (!source.good())
		{
#ifdef _DEBUG
			console::print("File %s doesnt exists.", name.c_str());
#endif
			return root;
		}

		source >> root;

#ifdef _DEBUG
		console::print("File %s was succesfully loaded.", name.c_str());
#endif

		return root;
	}

	Json::Value get_and_cache_source(const std::string& name, const std::string& folder)
	{
		if (cached[folder].count(name) == 0)
			cached[folder][name] = get_source(name, folder);

		return cached[folder][name];
	}

	void cache(const std::string& folder)
	{
		const auto items = get_files(folder);
		for (auto& file : items)
			get_and_cache_source(file, folder);
	}

	std::vector<std::string> get_files(const std::string& folder)
	{
		std::vector<std::string> items;

		std::string path = path_to_folder(folder);
		if (!fs::is_directory(path))
			fs::create_directories(path);

		for (auto& p : fs::directory_iterator(path))
			items.emplace_back(p.path().string().substr(path.length() + 1));

		return items;
	}

	void load(const std::string& name, const std::string& folder, const bool& cache, const std::function<void(Json::Value)>& callback)
	{
		if (name.empty())
			return;

		const auto source = cache ? get_and_cache_source(name, folder) : get_source(name, folder);

		callback(source);
	}

	bool save(const std::string& name, const std::string& folder, const bool& cache, const std::function<Json::Value(void)>& callback)
	{
		if (name.empty())
			return false;

		const auto root = callback();
		if (cache)
			cached[folder][name] = root;

		Json::StyledWriter styledWriter;

		try
		{
			std::ofstream(path_to_file(name, folder)) << styledWriter.write(root);

#ifdef _DEBUG
			console::print("%s successfully saved", name.c_str());
#endif // _DEBUG

			return true;
		}
		catch (const std::exception& ex)
		{
#ifdef _DEBUG
			console::print("failed to save %s: %s", name.c_str(), ex.what());
#endif // _DEBUG
		}

		return false;
	}

	bool remove(const std::string& name, const std::string& folder)
	{
		const auto state = fs::remove(path_to_file(name, folder));
		if (state)
		{
			cached[folder].clear();
			cache(folder);
		}

		return state;
	}
}
```

`src/settings/config.h`:

```h
#pragma once

#include <map>
#include <vector>
#include <string>
#include <functional>

#include "../jsoncpp/json.h"

namespace config
{
	extern std::map<std::string, std::map<std::string, Json::Value>> cached;

	void load(const std::string& name, const std::string& folder, const bool& cache, const std::function<void(Json::Value)>& callback);
	bool save(const std::string& name, const std::string& folder, const bool& cache, const std::function<Json::Value(void)>& callback);
	bool remove(const std::string& name, const std::string& folder);

	void cache(const std::string& folder);
	std::vector<std::string> get_files(const std::string& folder);
}
```

`src/settings/globals.cpp`:

```cpp
#include "globals.h"
#include "config.h"
#include "../render/render.h"

#include "../helpers/input.h"
#include "../helpers/console.h"
#include "../helpers/notifies.h"
#include "../features/features.h"

#include <thread>

namespace globals
{
	bool post_processing = true;
	bool configs_initialized = false;
	bool esp_menu_opened = false;

	float window_alpha = 1.f;
	
	int teamkills = 0;

	std::string settings;

	ImDrawList* draw_list = nullptr;

	std::map<int, int> team_damage = { };
	std::map<int, bool> is_visible = { };
	std::map<int, bool> in_smoke = { };

	std::map<std::string, int> class_ids = { };

	namespace view_matrix
	{
		bool has_offset = false;
		DWORD offset;
	}

	namespace clantag
	{
		float delay = 0.6;
		std::string value;
		bool animation = false;
	}

	namespace binds
	{
		namespace thirdperson
		{
			bool enabled = false;
			int key = 0;
		}

		int esp = 0;
		int trigger = 18; // 18 = L-ALT key, 16 = L-SHIFT, 0 = NOTHING
		
		bool notify_when_loaded = true;
		std::map<std::string, int> configs;

		bool is_pressed(const int& key)
		{
			return key > 0 && input_system::was_key_pressed(key);
		}

		void handle(const int& key)
		{
			if (key <= 0)
				return;

			if (key == esp)
				settings::esp::enabled = !settings::esp::enabled;

			if (key == thirdperson::key && !g::engine_client->IsConsoleVisible())
				thirdperson::enabled = !thirdperson::enabled;

			for (auto& bind : configs)
			{
				if (bind.second > 0 && bind.second == key)
				{
					globals::settings = bind.first;
					configs_initialized = false;
					settings::load(bind.first);

					if (notify_when_loaded)
					{
						static char buf[256];
						sprintf_s(buf, "\"%s\" %s", bind.first.c_str(), "loaded");

						notifies::push(buf);
					}

					return;
				}
			}
		}
	}

	void load()
	{
		config::load("config.json", "", true, [](Json::Value root)
			{
				settings = root["settings"].asString();
				if (!settings.empty())
					settings::load(settings);

				Option::Load(root["post_processing"], post_processing, true);
				Option::Load(root["esp_while_in_menu"], esp_menu_opened, false);
			});
	}

	void save()
	{
		config::save("config.json", "", false, []()
			{
				Json::Value root;

				root["post_processing"] = post_processing;
				root["esp_while_in_menu"] = esp_menu_opened;

				root["configs"] = settings;
				root["clantag"] = clantag::value;

				return root;
			});
	}
}
```

`src/settings/globals.h`:

```h
#pragma once

#include <map>
#include <vector>
#include <string>
#include "options.hpp"

namespace globals
{
	extern bool post_processing;
	extern bool configs_initialized;
	extern bool esp_menu_opened;

	extern float window_alpha;
	
	extern int teamkills;

	extern ImDrawList* draw_list;

	extern std::string settings;

	extern std::map<int, int> team_damage;
	extern std::map<int, bool> is_visible;
	extern std::map<int, bool> in_smoke;
	extern std::map<std::string, int> class_ids;

	void save();
	void load();

	namespace view_matrix
	{
		extern bool has_offset;
		extern DWORD offset;
	}

	namespace clantag
	{
		extern float delay;
		extern std::string value;
		extern bool animation;
	}

	namespace binds
	{
		namespace thirdperson
		{
			extern bool enabled;
			extern int key;
		}

		extern int esp;
		extern int trigger;
		
		extern bool notify_when_loaded;
		extern std::map<std::string, int> configs;

		void handle(const int& key);
	}
}
```

`src/settings/options.cpp`:

```cpp
#include "options.hpp"
#include "../helpers/console.h"
#include <filesystem>

#pragma warning( disable : 4101 )

namespace fs = std::filesystem;

namespace Config
{
	std::string GetPath(const std::string& name, const std::string& folder)
	{
		return "C:\\Sensum/" + (folder.empty() ? "" : folder + "/") + name;
	}

	std::vector<std::string> Configs(const std::string& folder)
	{
		std::vector<std::string> items = { };

		std::string path("C:\\Sensum/" + folder);
		if (!fs::is_directory(path))
			fs::create_directories(path);

		for (auto& p : fs::directory_iterator(path))
			items.emplace_back(p.path().string().substr(path.length() + 1));

		return items;
	}

	bool Delete(const std::string& name, const std::string& folder)
	{
		return fs::remove(GetPath(name, folder));
	}

	void Load(const std::string& name, const std::string& folder, std::function<void(Json::Value)> f)
	{
		if (name.empty())
			return;

		Json::Value root;

		try
		{
			std::ifstream f(GetPath(name, folder), std::ifstream::binary);
			if (!f.good())
			{
#ifdef _DEBUG
				console::print("file doesnt exists");
#endif
				return;
			}

			f >> root;
		}
		catch (const std::exception& ex)
		{
#ifdef _DEBUG
			console::print("Failed to load %s: %s", name.c_str(), ex.what());
#endif
			return;
		}

		f(root);

#ifdef _DEBUG
		console::print("%s successfully loaded", name.c_str());
#endif
	}

	void Save(const std::string& name, const std::string& folder, std::function<Json::Value(void)> f)
	{
		if (name.empty())
			return;

		const auto root = f();

		Json::StyledWriter styledWriter;

		try
		{
			std::ofstream(GetPath(name, folder)) << styledWriter.write(root);

#ifdef _DEBUG
			console::print("%s successfully saved", name.c_str());
#endif
		}
		catch (const std::exception& ex)
		{
#ifdef _DEBUG
			console::print("Failed to save %s: %s", name.c_str(), ex.what());
#endif
		}
	}
};

namespace Option
{
	void Save(Json::Value& config, ImVec4 setting)
	{
		config["x"] = setting.x;
		config["y"] = setting.y;
		config["z"] = setting.z;
		config["w"] = setting.w;
	}

	void Save(Json::Value& config, float setting)
	{
		config["r"] = config.asFloat();
		config["g"] = config.asFloat();
		config["b"] = config.asFloat();
		config["a"] = config.asFloat();
	}

	void Save(Json::Value& config, Color setting)
	{
		config["r"] = setting.r();
		config["g"] = setting.g();
		config["b"] = setting.b();
		config["a"] = setting.a();
	}

	void Load(Json::Value config, ImVec4& setting, const ImVec4& def)
	{
		if (config.isNull())
			setting = def;
		else
			setting = ImVec4(config["x"].asFloat(), config["y"].asFloat(), config["z"].asFloat(), config["w"].asFloat());
	}

	void Load(Json::Value config, Color& setting, const Color& def)
	{
		if (config.isNull())
			setting = def;
		else
			setting.SetColor(config["r"].asInt(), config["g"].asInt(), config["b"].asInt(), config["a"].asInt());
	}

	void Load(Json::Value config, int& setting, const int& def)
	{
		setting = config.isNull() ? def : config.asInt();
	}

	void Load(Json::Value config, bool& setting, const bool& def)
	{
		setting = config.isNull() ? def : config.asBool();
	}

	void Load(Json::Value config, float& setting, const float& def)
	{
		setting = config.isNull() ? def : config.asFloat();
	}
}
```

`src/settings/options.hpp`:

```hpp
#pragma once

#include <fstream>
#include <functional>

#include "settings.h"
#include "../jsoncpp/json.h"
#include "../helpers/math.h"

namespace Option
{
	void Save(Json::Value&, ImVec4);
	void Save(Json::Value&, Color);
	void Save(Json::Value&, float);

	void Load(Json::Value, ImVec4&, const ImVec4 & = ImVec4::White);
	void Load(Json::Value, Color&, const Color & = Color::White);
	void Load(Json::Value, int&, const int& = 0);
	void Load(Json::Value, bool&, const bool& = false);
	void Load(Json::Value, float&, const float& = 0.f);
}
```

`src/settings/settings.cpp`:

```cpp
#include "settings.h"
#include "config.h"
#include "options.hpp"
#include "../jsoncpp/json.h"
#include "../helpers/imdraw.h"
#include "globals.h"

namespace settings
{
	namespace esp
	{
		bool enabled = false;
		bool visible_only = false;
		bool boxes = false;
		int box_type = 0;
		bool names = false;
		bool health = false;
		int health_position = 0;
		bool armour = false;
		int armour_position = 1;
		bool weapons = false;
		int weapon_mode = 0;
		bool ammo = false;
		bool offscreen = false;
		bool is_scoped = false;
		bool dormant = false;
		bool is_flashed = false;
		bool is_defusing = false;
		bool is_reloading = false;
		bool bomb_esp = false;
		bool bone_esp = false;
		bool visible_on_sound = false;
		bool buylog = false;

		Color visible_color = Color(0, 200, 80);
		Color occluded_color = Color(0, 0, 0);
		Color bone_esp_color = Color(255, 255, 255, 255);
	}

	namespace chams
	{
		int chams_list_mode = 0;

		namespace enemy
		{
			bool enabled = false;
			bool visible_only = false;
			bool health_chams = false;

			Color color_visible = Color(0, 128, 0, 255);
			Color color_not_visible = Color(255, 0, 0, 255);
			Color color_backtrack = Color(0, 255, 128, 128);
		}

		namespace teammates
		{
			bool enabled = false;
			bool visible_only = false;
			bool health_chams = false;

			Color color_visible = Color(0, 128, 0, 255);
			Color color_not_visible = Color(255, 0, 0, 255);
			Color color_backtrack = Color(0, 255, 128, 128);
		}
	}

	namespace visuals
	{
		bool grenade_prediction = false;
		bool player_info_box = false;
		bool world_grenades = false;
		bool sniper_crosshair = true;
		bool planted_c4 = false;
		bool dropped_weapons = false;
		bool night_mode = false;
		bool rcs_cross = false;
		float radius = 12;
		int rcs_cross_mode;
		float player_info_box_alpha = 1.0f;
		
		ImVec4 recoil_color = ImVec4{ 0.f, 0.f, 0.f, 1.0f };
		ImVec4 spread_cross_color = ImVec4{ 1.f, 0.f, 0.f, 1.0f };
	}

	namespace aimbot
	{
		int setting_type = settings_type_t::separately;

		std::vector<aimbot_group> m_groups = { };
		std::map<int, weapon_setting> m_items = { };

		bool hello_nigga = true;
	}

	namespace misc
	{
		bool radar = false;
		bool bhop = false;
		bool auto_strafe = false;
		bool selfnade = false;
		float viewmodel_fov = 68.f;
		bool deathmatch = false;
		int debug_fov = 90;
		bool noscope = false;
		bool lefthandknife = false;
		bool fast_stop = false;
		bool smoke_helper = false;
		bool flash_helper = false;
		bool print_fov = false;
	};

	void load(std::string name)
	{
		config::load(name, "configs", true, [](Json::Value root)
			{
				Option::Load(root["esp.enabled"], esp::enabled);//Cant choose team bug
				Option::Load(root["esp.visible_only"], esp::visible_only);
				Option::Load(root["esp.boxes"], esp::boxes, true);
				Option::Load(root["esp.names"], esp::names);
				Option::Load(root["esp.box_type"], esp::box_type, EBoxType::Normal);
				Option::Load(root["esp.health"], esp::health);
				Option::Load(root["esp.health_position"], esp::health_position, 0);
				Option::Load(root["esp.armour"], esp::armour);
				Option::Load(root["esp.armour_position"], esp::armour_position, 1);
				Option::Load(root["esp.weapons"], esp::weapons);
				Option::Load(root["esp.offscreen"], esp::offscreen);
				Option::Load(root["esp.dormant"], esp::dormant);
				Option::Load(root["esp.is_scoped"], esp::is_scoped);
				Option::Load(root["esp.is_flashed"], esp::is_flashed);
				Option::Load(root["esp.is_defusing"], esp::is_defusing);
				Option::Load(root["esp_weapon_mode"], settings::esp::weapon_mode);
				Option::Load(root["esp.player_info_box_alpha"], settings::visuals::player_info_box_alpha);
				Option::Load(root["esp.visible_color"], esp::visible_color, Color(0, 200, 80));
				Option::Load(root["esp.occluded_color"], esp::occluded_color, Color::Black);
		
				Option::Load(root["visuals.world_grenades"], visuals::world_grenades, true);
				Option::Load(root["visuals.sniper_crosshair"], visuals::sniper_crosshair, true);
				Option::Load(root["visuals.grenade_prediction"], visuals::grenade_prediction, true);
				Option::Load(root["visuals.planted_c4"], visuals::planted_c4);
				Option::Load(root["visuals.dropped_weapons"], visuals::dropped_weapons);
				Option::Load(root["visuals.night_mode"], visuals::night_mode);

				Option::Load(root["chams.list_mode"], chams::chams_list_mode, 0);
				Option::Load(root["chams.enemy_enabled"], chams::enemy::enabled, false);
				Option::Load(root["chams.enemy_visible_only"], chams::enemy::visible_only, true);

				Option::Load(root["chams.teammates_enabled"], chams::teammates::enabled, false);
				Option::Load(root["chams.teammates_visible_only"], chams::teammates::visible_only, true);
				
				Option::Load(root["chams.enemy_color_vis"], chams::enemy::color_visible);
				Option::Load(root["chams.team_color_vis"], chams::teammates::color_visible);
				Option::Load(root["chams.enemy_color_xqz"], chams::enemy::color_not_visible);
				Option::Load(root["chams.team_color_xqz"], chams::teammates::color_not_visible);
				
				Option::Load(root["misc.viewmodel_fov"], misc::viewmodel_fov, 68);
				Option::Load(root["misc.deathmatch"], misc::deathmatch);
				Option::Load(root["misc.radar"], misc::radar);
				Option::Load(root["misc.debug_fov"], misc::debug_fov);
				Option::Load(root["misc.rcs_cross"], visuals::rcs_cross);
				Option::Load(root["misc.rcs_cross_mode"], visuals::rcs_cross_mode);
				Option::Load(root["misc.radius"], visuals::radius, 12.f);
				Option::Load(root["mics.rcs_cross_color"], visuals::recoil_color);
				Option::Load(root["misc.no_scope_overlay"], misc::noscope);
				Option::Load(root["misc.bomb_damage_esp"], esp::bomb_esp);
				Option::Load(root["misc_spread_crosshair_color"], settings::visuals::spread_cross_color);
				Option::Load(root["misc_esp_ammo"], settings::esp::ammo);
				Option::Load(root["misc.player_info_box"], settings::visuals::player_info_box);
				Option::Load(root["misc.left_hand_knife"], settings::misc::lefthandknife);
				Option::Load(root["misc.fast_stop"], settings::misc::fast_stop);
				Option::Load(root["misc.smoke_helper"], misc::smoke_helper);
				Option::Load(root["misc.flash_helper"], misc::flash_helper);
				Option::Load(root["misc.print_fov"], misc::print_fov);
				Option::Load(root["aimbot.nigga_backtrack_off"], aimbot::hello_nigga);

				Option::Load(root["binds.esp"], globals::binds::esp, 0);
				Option::Load(root["binds.trigger"], globals::binds::trigger, 18);
				Option::Load(root["binds.thirdperson"], globals::binds::thirdperson::key, 86);

				Json::Value config_binds = root["binds.configs"];
				if (!config_binds.empty())
				{
					for (Json::Value::iterator it = config_binds.begin(); it != config_binds.end(); ++it)
					{
						Json::Value settings = *it;

						if (settings["key"].asInt() > 0)
							globals::binds::configs[settings["name"].asString()] = settings["key"].asInt();
					}
				}

				Option::Load(root["legitbot.setting_type"], aimbot::setting_type);

				aimbot::m_items.clear();

				Json::Value aimbot_items = root["legitbot.items"];
				for (Json::Value::iterator it = aimbot_items.begin(); it != aimbot_items.end(); ++it)
				{
					Json::Value settings = *it;

					weapon_setting data;
					Option::Load(settings["enabled"], data.enabled);
					Option::Load(settings["back_shot"], data.back_shot);
					Option::Load(settings["autodelay"], data.autodelay);
					Option::Load(settings["autopistol"], data.autopistol);
					Option::Load(settings["check_smoke"], data.check_smoke);
					Option::Load(settings["check_flash"], data.check_flash);
					Option::Load(settings["check_air"], data.check_air, true);
					Option::Load(settings["backtrack.enabled"], data.backtrack.enabled);
					Option::Load(settings["backtrack.legit"], data.backtrack.legit);
					Option::Load(settings["autostop"], data.auto_stop);
					Option::Load(settings["dynamic_fov"], data.dynamic_fov);
					Option::Load(settings["backtrack.time"], data.backtrack.time, 100);
					if (data.backtrack.time < 0 || data.backtrack.time > 200)
						data.backtrack.time = 100;

					Option::Load(settings["check_zoom"], data.check_zoom, true);
					
					Option::Load(settings["trigger.enabled"], data.trigger.enabled);
					Option::Load(settings["trigger.delay"], data.trigger.delay);
					Option::Load(settings["trigger.delay_btw_shots"], data.trigger.delay_btw_shots, 50);
					Option::Load(settings["trigger.hitchance"], data.trigger.hitchance, 1);
					Option::Load(settings["trigger.magnet"], data.trigger.magnet);

					Option::Load(settings["hitboxes.head"], data.hitboxes.head, true);
					Option::Load(settings["hitboxes.neck"], data.hitboxes.neck, true);
					Option::Load(settings["hitboxes.body"], data.hitboxes.body, true);
					Option::Load(settings["hitboxes.hands"], data.hitboxes.arms);
					Option::Load(settings["hitboxes.legs"], data.hitboxes.legs);

					Option::Load(settings["fov"], data.fov);
					Option::Load(settings["smooth"], data.smooth, 1);
					Option::Load(settings["shot_delay"], data.shot_delay);
					Option::Load(settings["kill_delay"], data.kill_delay, 600);
					Option::Load(settings["by_damage"], data.by_damage);
					Option::Load(settings["min_damage"], data.min_damage, 0);
					Option::Load(settings["hitchanse"], data.min_hitchance, 0);
					Option::Load(settings["rcs_hitbox_override"], data.rcs_override_hitbox);
					Option::Load(settings["extended_fov"], data.extended_fov);
					Option::Load(settings["extended_smooth"], data.extended_smooth);
					Option::Load(settings["fov_smooth_override"], data.fov_smooth_override);
					Option::Load(settings["min_shots_fired"], data.min_shots_fired, 3);

					Option::Load(settings["autowall.enabled"], data.autowall.enabled);
					Option::Load(settings["autowall.min_damage"], data.autowall.min_damage, 1);

					Option::Load(settings["rcs"], data.recoil.enabled);
					Option::Load(settings["rcs.first_bullet"], data.recoil.first_bullet);
					Option::Load(settings["rcs.humanized"], data.recoil.humanized);
					Option::Load(settings["rcs_value_x"], data.recoil.pitch, 2.f);
					Option::Load(settings["rcs_value_y"], data.recoil.yaw, 2.f);

					aimbot::m_items[it.key().asInt()] = data;
				}

				settings::aimbot::m_groups.clear();

				for (auto& group : root["aimbot.groups"])
				{
					std::vector<int> weapons = { };

					for (auto& weapon_index : group["weapons"])
					{
						weapons.emplace_back(weapon_index.asInt());
					}

					settings::aimbot::m_groups.emplace_back(aimbot_group{ group["name"].asString(), weapons });
				}
			});
	}

	void save(std::string name)
	{
		config::save(name, "configs", true, []()
			{
				Json::Value config;

				config["esp.enabled"] = esp::enabled;
				config["esp.visible_only"] = esp::visible_only;
				config["esp.boxes"] = esp::boxes;
				config["esp.names"] = esp::names;
				config["esp.box_type"] = esp::box_type;
				config["esp.health"] = esp::health;
				config["esp.health_position"] = esp::health_position;
				config["esp.armour"] = esp::armour;
				config["esp.armour_position"] = esp::armour_position;
				config["esp.weapons"] = esp::weapons;
				config["esp.offscreen"] = esp::offscreen;
				config["esp.dormant"] = esp::dormant;
				config["esp.is_scoped"] = esp::is_scoped;
				config["esp.is_defusing"] = esp::is_defusing;
				config["esp.is_flashed"] = esp::is_flashed;
				config["esp_weapon_mode"] = settings::esp::weapon_mode;
				config["esp.player_info_box_alpha"] = settings::visuals::player_info_box_alpha;
				
				Option::Save(config["esp.visible_color"], esp::visible_color);
				Option::Save(config["esp.occluded_color"], esp::occluded_color);
				
				config["visuals.world_grenades"] = visuals::world_grenades;
				config["visuals.sniper_crosshair"] = visuals::sniper_crosshair;
				config["visuals.grenade_prediction"] = visuals::grenade_prediction;
				config["visuals.planted_c4"] = visuals::planted_c4;
				config["visuals.dropped_weapons"] = visuals::dropped_weapons;
				config["visuals.night_mode"] = visuals::night_mode;

				config["chams.list_mode"] = chams::chams_list_mode;
				config["chams.enemy_enabled"] = chams::enemy::enabled;
				config["chams.enemy_visible_only"] = chams::enemy::visible_only;

				config["chams.teammates_enabled"] = chams::teammates::enabled;
				config["chams.teammates_visible_only"] = chams::teammates::visible_only;
	
				Option::Save(config["chams.enemy_color_vis"], chams::enemy::color_visible);
				Option::Save(config["chams.team_color_vis"], chams::teammates::color_visible);
				Option::Save(config["chams.enemy_color_xqz"], chams::enemy::color_not_visible);
				Option::Save(config["chams.team_color_xqz"], chams::teammates::color_not_visible);
				
				config["misc.viewmodel_fov"] = misc::viewmodel_fov;
				config["misc.deathmatch"] = misc::deathmatch;
				config["misc.radar"] = misc::radar;
				config["misc.debug_fov"] = misc::debug_fov;
				config["misc.rcs_cross"] = visuals::rcs_cross;
				config["misc.rcs_cross_mode"] = visuals::rcs_cross_mode;
				config["misc.radius"] = visuals::radius;
				config["misc.no_scope_overlay"] = misc::noscope;
				config["misc.bomb_damage_esp"] = esp::bomb_esp;
				config["misc_esp_ammo"] = settings::esp::ammo;
				config["misc.player_info_box"] = settings::visuals::player_info_box;
				config["misc.left_hand_knife"] = settings::misc::lefthandknife;
				config["misc.fast_stop"] = settings::misc::fast_stop;
				config["misc.smoke_helper"] = misc::smoke_helper;
				config["misc.flash_helper"] = misc::flash_helper;
				config["misc.print_fov"] = misc::print_fov;
				config["aimbot.nigga_backtrack_off"] = aimbot::hello_nigga;
				
				config["binds.esp"] = globals::binds::esp;
				config["binds.trigger"] = globals::binds::trigger;
				config["binds.thirdperson"] = globals::binds::thirdperson::key;

				Json::Value config_binds;
				for (auto& bind : globals::binds::configs)
				{
					Json::Value bind_data;
					bind_data["key"] = bind.second;
					bind_data["name"] = bind.first;

					config_binds.append(bind_data);
				}

				config["binds.configs"] = config_binds;

				Option::Save(config["misc_spread_crosshair_color"], settings::visuals::spread_cross_color);
				Option::Save(config["mics.rcs_cross_color"], visuals::recoil_color);

				config["legitbot.setting_type"] = aimbot::setting_type;

				Json::Value aimbot_items;
				for (const auto& data : aimbot::m_items)
				{
					Json::Value act;
					const auto aimbot_data = data.second;
					act["back_shot"] = aimbot_data.back_shot;
					act["autodelay"] = aimbot_data.autodelay;
					act["autopistol"] = aimbot_data.autopistol;
					act["autowall.enabled"] = aimbot_data.autowall.enabled;
					act["autowall.min_damage"] = aimbot_data.autowall.min_damage;
					act["backtrack.enabled"] = aimbot_data.backtrack.enabled;
					act["backtrack.legit"] = aimbot_data.backtrack.legit;
					act["backtrack.time"] = aimbot_data.backtrack.time;
					act["check_flash"] = aimbot_data.check_flash;
					act["check_smoke"] = aimbot_data.check_smoke;
					act["check_air"] = aimbot_data.check_air;
					act["enabled"] = aimbot_data.enabled;
					act["fov"] = aimbot_data.fov;
					act["extended_fov"] = aimbot_data.extended_fov;
					act["extended_smooth"] = aimbot_data.extended_smooth;
					act["fov_smooth_override"] = aimbot_data.fov_smooth_override;
					act["min_shots_fired"] = aimbot_data.min_shots_fired;
					act["by_damage"] = aimbot_data.by_damage;
					act["min_damage"] = aimbot_data.min_damage;
					act["hitchanse"] = aimbot_data.min_hitchance;
					act["rcs_hitbox_override"] = aimbot_data.rcs_override_hitbox;
					act["autostop"] = aimbot_data.auto_stop;
					act["dynamic_fov"] = aimbot_data.dynamic_fov;
					
					act["trigger.enabled"] = aimbot_data.trigger.enabled;
					act["trigger.delay"] = aimbot_data.trigger.delay;
					act["trigger.delay_btw_shots"] = aimbot_data.trigger.delay_btw_shots;
					act["trigger.hitchance"] = aimbot_data.trigger.hitchance;
					act["trigger.magnet"] = aimbot_data.trigger.magnet;

					act["hitboxes.head"] = aimbot_data.hitboxes.head;
					act["hitboxes.neck"] = aimbot_data.hitboxes.neck;
					act["hitboxes.body"] = aimbot_data.hitboxes.body;
					act["hitboxes.hands"] = aimbot_data.hitboxes.arms;
					act["hitboxes.legs"] = aimbot_data.hitboxes.legs;

					act["kill_delay"] = aimbot_data.kill_delay;
					act["check_zoom"] = aimbot_data.check_zoom;
					act["shot_delay"] = aimbot_data.shot_delay;
					act["smooth"] = aimbot_data.smooth;
					act["min_damage"] = aimbot_data.min_damage;

					act["rcs"] = aimbot_data.recoil.enabled;
					act["rcs.first_bullet"] = aimbot_data.recoil.first_bullet;
					act["rcs.humanized"] = aimbot_data.recoil.humanized;
					act["rcs_value_x"] = aimbot_data.recoil.pitch;
					act["rcs_value_y"] = aimbot_data.recoil.yaw;

					aimbot_items[data.first] = act;
				}

				config["legitbot.items"] = aimbot_items;

				Json::Value aimbot_groups;
				for (auto& group : aimbot::m_groups)
				{
					Json::Value act;
					act["name"] = group.name;

					Json::Value weapons;
					for (auto& weapon : group.weapons)
						weapons.append(weapon);

					act["weapons"] = weapons;

					aimbot_groups.append(act);
				}

				config["aimbot.groups"] = aimbot_groups;

				return config;
			});
	}
}
```

`src/settings/settings.h`:

```h
#pragma once

#include "../imgui/imgui.h"
#include "../valve_sdk/csgostructs.hpp"

struct aimbot_group
{
	std::string name;
	std::vector<int> weapons = { };
};

enum settings_type_t : int
{
	separately = 0,
	subgroups,
	for_all,
	groups,
};

#pragma pack(push, 1)
struct weapon_setting
{
	bool enabled = false;
	bool autopistol = false;
	bool auto_stop = false;
	bool check_smoke = false;
	bool check_flash = false;
	bool check_zoom = true;
	bool check_air = true;
	bool by_damage = false;
	bool back_shot = false;
	bool rcs_override_hitbox = false;
	bool dynamic_fov = true;

	int min_damage = 0;
	int min_hitchance = 0;

	int rcs_type = 0;

	struct
	{
		bool enabled = false;
		int time = 100;
		bool legit = false;
	} backtrack;

	struct
	{
		bool auto_delay = false;

		int before_shot = 0;
		int target_switch = 600;
	} delays;

	bool autodelay = false;

	struct
	{
		bool enabled = false;
		bool magnet = true;
		int delay = 0;
		int delay_btw_shots = 50;
		int hitchance = 1;
	} trigger;

	struct {
		bool enabled = false;
		bool first_bullet = false;
		bool humanized = false;
		
		float pitch = 2.0f;
		float yaw = 2.0f;
	} recoil;

	struct
	{
		bool head = true;
		bool neck = true;
		bool body = true;
		bool arms = true;
		bool legs = true;
	} hitboxes;

	struct
	{
		bool enabled = false;
		int min_damage = 1;
	} autowall;

	float fov = 0.f;
	float smooth = 1.f;
	int shot_delay = 0;
	int kill_delay = 600;

	float extended_fov = 0.f;
	float extended_smooth = 1.f;
	bool fov_smooth_override = false;
	int min_shots_fired = 3;
};
#pragma pack(pop)

namespace settings
{
	void load(std::string name);
	void save(std::string name);

	namespace esp
	{
		extern bool enabled;
		extern bool visible_only;
		extern bool boxes;
		extern int box_type;
		extern bool names;
		extern bool health;
		extern int health_position;
		extern bool armour;
		extern int armour_position;
		extern bool weapons;
		extern int weapon_mode;
		extern bool ammo;
		extern bool offscreen;
		extern bool is_scoped;
		extern bool is_flashed;
		extern bool is_defusing;
		extern bool dormant;
		extern bool is_reloading;
		extern bool bomb_esp;
		extern bool ammo;
		extern bool bone_esp;
		extern bool visible_on_sound;
		extern bool buylog;

		extern Color visible_color;
		extern Color occluded_color;
		extern Color bone_esp_color;
	}

	namespace chams
	{
		extern int chams_list_mode;

		namespace enemy
		{
			extern bool enabled;
			extern bool visible_only;
			extern bool health_chams;
			
			extern Color color_visible;
			extern Color color_not_visible;
			extern Color color_backtrack;
		}

		namespace teammates
		{
			extern bool enabled;
			extern bool visible_only;
			extern bool health_chams;
			
			extern Color color_visible;
			extern Color color_not_visible;
			extern Color color_backtrack;
		}
	}
	
	namespace visuals
	{
		extern bool grenade_prediction;
		extern bool player_info_box;
		extern bool world_grenades;
		extern bool sniper_crosshair;
		extern bool planted_c4;
		extern bool dropped_weapons;
		extern bool night_mode;
		extern bool rcs_cross;
		extern float radius;
		extern int rcs_cross_mode;
		extern float player_info_box_alpha;

		extern ImVec4 recoil_color;
	}

	namespace aimbot
	{
		extern int setting_type;

		extern std::vector<aimbot_group> m_groups;
		extern std::map<int, weapon_setting> m_items;

		extern bool hello_nigga;
	}

	namespace misc
	{
		extern float viewmodel_fov;
		extern bool deathmatch;
		extern bool radar;
		extern bool bhop;
		extern bool auto_strafe;
		extern bool selfnade;
		extern int debug_fov;
		extern bool noscope;
		extern bool lefthandknife;
		extern bool fast_stop;
		extern bool smoke_helper;
		extern bool flash_helper;
		extern bool print_fov;
	}
}

```

`src/valve_sdk/classids.cpp`:

```cpp
#include "classids.h"

namespace classids
{
	int CAI_BaseNPC = 0;
	int CAK47 = 0;
	int CBaseAnimating = 0;
	int CBaseAnimatingOverlay = 0;
	int CBaseAttributableItem = 0;
	int CBaseButton = 0;
	int CBaseCombatCharacter = 0;
	int CBaseCombatWeapon = 0;
	int CBaseCSGrenade = 0;
	int CBaseCSGrenadeProjectile = 0;
	int CBaseDoor = 0;
	int CBaseEntity = 0;
	int CBaseFlex = 0;
	int CBaseGrenade = 0;
	int CBaseParticleEntity = 0;
	int CBasePlayer = 0;
	int CBasePropDoor = 0;
	int CBaseTeamObjectiveResource = 0;
	int CBaseTempEntity = 0;
	int CBaseToggle = 0;
	int CBaseTrigger = 0;
	int CBaseViewModel = 0;
	int CBaseVPhysicsTrigger = 0;
	int CBaseWeaponWorldModel = 0;
	int CBeam = 0;
	int CBeamSpotlight = 0;
	int CBoneFollower = 0;
	int CBRC4Target = 0;
	int CBreachCharge = 0;
	int CBreachChargeProjectile = 0;
	int CBreakableProp = 0;
	int CBreakableSurface = 0;
	int CBumpMine = 0;
	int CBumpMineProjectile = 0;
	int CC4 = 0;
	int CCascadeLight = 0;
	int CChicken = 0;
	int CColorCorrection = 0;
	int CColorCorrectionVolume = 0;
	int CCSGameRulesProxy = 0;
	int CCSPlayer = 0;
	int CCSPlayerResource = 0;
	int CCSRagdoll = 0;
	int CCSTeam = 0;
	int CDangerZone = 0;
	int CDangerZoneController = 0;
	int CDEagle = 0;
	int CDecoyGrenade = 0;
	int CDecoyProjectile = 0;
	int CDrone = 0;
	int CDronegun = 0;
	int CDynamicLight = 0;
	int CDynamicProp = 0;
	int CEconEntity = 0;
	int CEconWearable = 0;
	int CEmbers = 0;
	int CEntityDissolve = 0;
	int CEntityFlame = 0;
	int CEntityFreezing = 0;
	int CEntityParticleTrail = 0;
	int CEnvAmbientLight = 0;
	int CEnvDetailController = 0;
	int CEnvDOFController = 0;
	int CEnvGasCanister = 0;
	int CEnvParticleScript = 0;
	int CEnvProjectedTexture = 0;
	int CEnvQuadraticBeam = 0;
	int CEnvScreenEffect = 0;
	int CEnvScreenOverlay = 0;
	int CEnvTonemapController = 0;
	int CEnvWind = 0;
	int CFEPlayerDecal = 0;
	int CFireCrackerBlast = 0;
	int CFireSmoke = 0;
	int CFireTrail = 0;
	int CFish = 0;
	int CFists = 0;
	int CFlashbang = 0;
	int CFogController = 0;
	int CFootstepControl = 0;
	int CFunc_Dust = 0;
	int CFunc_LOD = 0;
	int CFuncAreaPortalWindow = 0;
	int CFuncBrush = 0;
	int CFuncConveyor = 0;
	int CFuncLadder = 0;
	int CFuncMonitor = 0;
	int CFuncMoveLinear = 0;
	int CFuncOccluder = 0;
	int CFuncReflectiveGlass = 0;
	int CFuncRotating = 0;
	int CFuncSmokeVolume = 0;
	int CFuncTrackTrain = 0;
	int CGameRulesProxy = 0;
	int CGrassBurn = 0;
	int CHandleTest = 0;
	int CHEGrenade = 0;
	int CHostage = 0;
	int CHostageCarriableProp = 0;
	int CIncendiaryGrenade = 0;
	int CInferno = 0;
	int CInfoLadderDismount = 0;
	int CInfoMapRegion = 0;
	int CInfoOverlayAccessor = 0;
	int CItem_Healthshot = 0;
	int CItemCash = 0;
	int CItemDogtags = 0;
	int CKnife = 0;
	int CKnifeGG = 0;
	int CLightGlow = 0;
	int CMapVetoPickController = 0;
	int CMaterialModifyControl = 0;
	int CMelee = 0;
	int CMolotovGrenade = 0;
	int CMolotovProjectile = 0;
	int CMovieDisplay = 0;
	int CParadropChopper = 0;
	int CParticleFire = 0;
	int CParticlePerformanceMonitor = 0;
	int CParticleSystem = 0;
	int CPhysBox = 0;
	int CPhysBoxMultiplayer = 0;
	int CPhysicsProp = 0;
	int CPhysicsPropMultiplayer = 0;
	int CPhysMagnet = 0;
	int CPhysPropAmmoBox = 0;
	int CPhysPropLootCrate = 0;
	int CPhysPropRadarJammer = 0;
	int CPhysPropWeaponUpgrade = 0;
	int CPlantedC4 = 0;
	int CPlasma = 0;
	int CPlayerPing = 0;
	int CPlayerResource = 0;
	int CPointCamera = 0;
	int CPointCommentaryNode = 0;
	int CPointWorldText = 0;
	int CPoseController = 0;
	int CPostProcessController = 0;
	int CPrecipitation = 0;
	int CPrecipitationBlocker = 0;
	int CPredictedViewModel = 0;
	int CProp_Hallucination = 0;
	int CPropCounter = 0;
	int CPropDoorRotating = 0;
	int CPropJeep = 0;
	int CPropVehicleDriveable = 0;
	int CRagdollManager = 0;
	int CRagdollProp = 0;
	int CRagdollPropAttached = 0;
	int CRopeKeyframe = 0;
	int CSCAR17 = 0;
	int CSceneEntity = 0;
	int CSensorGrenade = 0;
	int CSensorGrenadeProjectile = 0;
	int CShadowControl = 0;
	int CSlideshowDisplay = 0;
	int CSmokeGrenade = 0;
	int CSmokeGrenadeProjectile = 0;
	int CSmokeStack = 0;
	int CSnowball = 0;
	int CSnowballPile = 0;
	int CSnowballProjectile = 0;
	int CSpatialEntity = 0;
	int CSpotlightEnd = 0;
	int CSprite = 0;
	int CSpriteOriented = 0;
	int CSpriteTrail = 0;
	int CStatueProp = 0;
	int CSteamJet = 0;
	int CSun = 0;
	int CSunlightShadowControl = 0;
	int CSurvivalSpawnChopper = 0;
	int CTablet = 0;
	int CTeam = 0;
	int CTeamplayRoundBasedRulesProxy = 0;
	int CTEArmorRicochet = 0;
	int CTEBaseBeam = 0;
	int CTEBeamEntPoint = 0;
	int CTEBeamEnts = 0;
	int CTEBeamFollow = 0;
	int CTEBeamLaser = 0;
	int CTEBeamPoints = 0;
	int CTEBeamRing = 0;
	int CTEBeamRingPoint = 0;
	int CTEBeamSpline = 0;
	int CTEBloodSprite = 0;
	int CTEBloodStream = 0;
	int CTEBreakModel = 0;
	int CTEBSPDecal = 0;
	int CTEBubbles = 0;
	int CTEBubbleTrail = 0;
	int CTEClientProjectile = 0;
	int CTEDecal = 0;
	int CTEDust = 0;
	int CTEDynamicLight = 0;
	int CTEEffectDispatch = 0;
	int CTEEnergySplash = 0;
	int CTEExplosion = 0;
	int CTEFireBullets = 0;
	int CTEFizz = 0;
	int CTEFootprintDecal = 0;
	int CTEFoundryHelpers = 0;
	int CTEGaussExplosion = 0;
	int CTEGlowSprite = 0;
	int CTEImpact = 0;
	int CTEKillPlayerAttachments = 0;
	int CTELargeFunnel = 0;
	int CTEMetalSparks = 0;
	int CTEMuzzleFlash = 0;
	int CTEParticleSystem = 0;
	int CTEPhysicsProp = 0;
	int CTEPlantBomb = 0;
	int CTEPlayerAnimEvent = 0;
	int CTEPlayerDecal = 0;
	int CTEProjectedDecal = 0;
	int CTERadioIcon = 0;
	int CTEShatterSurface = 0;
	int CTEShowLine = 0;
	int CTesla = 0;
	int CTESmoke = 0;
	int CTESparks = 0;
	int CTESprite = 0;
	int CTESpriteSpray = 0;
	int CTest_ProxyToggle_Networkable = 0;
	int CTestTraceline = 0;
	int CTEWorldDecal = 0;
	int CTriggerPlayerMovement = 0;
	int CTriggerSoundOperator = 0;
	int CVGuiScreen = 0;
	int CVoteController = 0;
	int CWaterBullet = 0;
	int CWaterLODControl = 0;
	int CWeaponAug = 0;
	int CWeaponAWP = 0;
	int CWeaponBaseItem = 0;
	int CWeaponBizon = 0;
	int CWeaponCSBase = 0;
	int CWeaponCSBaseGun = 0;
	int CWeaponCycler = 0;
	int CWeaponElite = 0;
	int CWeaponFamas = 0;
	int CWeaponFiveSeven = 0;
	int CWeaponG3SG1 = 0;
	int CWeaponGalil = 0;
	int CWeaponGalilAR = 0;
	int CWeaponGlock = 0;
	int CWeaponHKP2000 = 0;
	int CWeaponM249 = 0;
	int CWeaponM3 = 0;
	int CWeaponM4A1 = 0;
	int CWeaponMAC10 = 0;
	int CWeaponMag7 = 0;
	int CWeaponMP5Navy = 0;
	int CWeaponMP7 = 0;
	int CWeaponMP9 = 0;
	int CWeaponNegev = 0;
	int CWeaponNOVA = 0;
	int CWeaponP228 = 0;
	int CWeaponP250 = 0;
	int CWeaponP90 = 0;
	int CWeaponSawedoff = 0;
	int CWeaponSCAR20 = 0;
	int CWeaponScout = 0;
	int CWeaponSG550 = 0;
	int CWeaponSG552 = 0;
	int CWeaponSG556 = 0;
	int CWeaponShield = 0;
	int CWeaponSSG08 = 0;
	int CWeaponTaser = 0;
	int CWeaponTec9 = 0;
	int CWeaponTMP = 0;
	int CWeaponUMP45 = 0;
	int CWeaponUSP = 0;
	int CWeaponXM1014 = 0;
	int CWeaponZoneRepulsor = 0;
	int CWorld = 0;
	int CWorldVguiText = 0;
	int DustTrail = 0;
	int MovieExplosion = 0;
	int ParticleSmokeGrenade = 0;
	int RocketTrail = 0;
	int SmokeTrail = 0;
	int SporeExplosion = 0;
	int SporeTrail = 0;

	void initialize()
	{
		CAI_BaseNPC = globals::class_ids.at("CAI_BaseNPC");
		CAK47 = globals::class_ids.at("CAK47");
		CBaseAnimating = globals::class_ids.at("CBaseAnimating");
		CBaseAnimatingOverlay = globals::class_ids.at("CBaseAnimatingOverlay");
		CBaseAttributableItem = globals::class_ids.at("CBaseAttributableItem");
		CBaseButton = globals::class_ids.at("CBaseButton");
		CBaseCombatCharacter = globals::class_ids.at("CBaseCombatCharacter");
		CBaseCombatWeapon = globals::class_ids.at("CBaseCombatWeapon");
		CBaseCSGrenade = globals::class_ids.at("CBaseCSGrenade");
		CBaseCSGrenadeProjectile = globals::class_ids.at("CBaseCSGrenadeProjectile");
		CBaseDoor = globals::class_ids.at("CBaseDoor");
		CBaseEntity = globals::class_ids.at("CBaseEntity");
		CBaseFlex = globals::class_ids.at("CBaseFlex");
		CBaseGrenade = globals::class_ids.at("CBaseGrenade");
		CBaseParticleEntity = globals::class_ids.at("CBaseParticleEntity");
		CBasePlayer = globals::class_ids.at("CBasePlayer");
		CBasePropDoor = globals::class_ids.at("CBasePropDoor");
		CBaseTeamObjectiveResource = globals::class_ids.at("CBaseTeamObjectiveResource");
		CBaseTempEntity = globals::class_ids.at("CBaseTempEntity");
		CBaseToggle = globals::class_ids.at("CBaseToggle");
		CBaseTrigger = globals::class_ids.at("CBaseTrigger");
		CBaseViewModel = globals::class_ids.at("CBaseViewModel");
		CBaseVPhysicsTrigger = globals::class_ids.at("CBaseVPhysicsTrigger");
		CBaseWeaponWorldModel = globals::class_ids.at("CBaseWeaponWorldModel");
		CBeam = globals::class_ids.at("CBeam");
		CBeamSpotlight = globals::class_ids.at("CBeamSpotlight");
		CBoneFollower = globals::class_ids.at("CBoneFollower");
		CBRC4Target = globals::class_ids.at("CBRC4Target");
		CBreachCharge = globals::class_ids.at("CBreachCharge");
		CBreachChargeProjectile = globals::class_ids.at("CBreachChargeProjectile");
		CBreakableProp = globals::class_ids.at("CBreakableProp");
		CBreakableSurface = globals::class_ids.at("CBreakableSurface");
		CBumpMine = globals::class_ids.at("CBumpMine");
		CBumpMineProjectile = globals::class_ids.at("CBumpMineProjectile");
		CC4 = globals::class_ids.at("CC4");
		CCascadeLight = globals::class_ids.at("CCascadeLight");
		CChicken = globals::class_ids.at("CChicken");
		CColorCorrection = globals::class_ids.at("CColorCorrection");
		CColorCorrectionVolume = globals::class_ids.at("CColorCorrectionVolume");
		CCSGameRulesProxy = globals::class_ids.at("CCSGameRulesProxy");
		CCSPlayer = globals::class_ids.at("CCSPlayer");
		CCSPlayerResource = globals::class_ids.at("CCSPlayerResource");
		CCSRagdoll = globals::class_ids.at("CCSRagdoll");
		CCSTeam = globals::class_ids.at("CCSTeam");
		CDangerZone = globals::class_ids.at("CDangerZone");
		CDangerZoneController = globals::class_ids.at("CDangerZoneController");
		CDEagle = globals::class_ids.at("CDEagle");
		CDecoyGrenade = globals::class_ids.at("CDecoyGrenade");
		CDecoyProjectile = globals::class_ids.at("CDecoyProjectile");
		CDrone = globals::class_ids.at("CDrone");
		CDronegun = globals::class_ids.at("CDronegun");
		CDynamicLight = globals::class_ids.at("CDynamicLight");
		CDynamicProp = globals::class_ids.at("CDynamicProp");
		CEconEntity = globals::class_ids.at("CEconEntity");
		CEconWearable = globals::class_ids.at("CEconWearable");
		CEmbers = globals::class_ids.at("CEmbers");
		CEntityDissolve = globals::class_ids.at("CEntityDissolve");
		CEntityFlame = globals::class_ids.at("CEntityFlame");
		CEntityFreezing = globals::class_ids.at("CEntityFreezing");
		CEntityParticleTrail = globals::class_ids.at("CEntityParticleTrail");
		CEnvAmbientLight = globals::class_ids.at("CEnvAmbientLight");
		CEnvDetailController = globals::class_ids.at("CEnvDetailController");
		CEnvDOFController = globals::class_ids.at("CEnvDOFController");
		CEnvGasCanister = globals::class_ids.at("CEnvGasCanister");
		CEnvParticleScript = globals::class_ids.at("CEnvParticleScript");
		CEnvProjectedTexture = globals::class_ids.at("CEnvProjectedTexture");
		CEnvQuadraticBeam = globals::class_ids.at("CEnvQuadraticBeam");
		CEnvScreenEffect = globals::class_ids.at("CEnvScreenEffect");
		CEnvScreenOverlay = globals::class_ids.at("CEnvScreenOverlay");
		CEnvTonemapController = globals::class_ids.at("CEnvTonemapController");
		CEnvWind = globals::class_ids.at("CEnvWind");
		CFEPlayerDecal = globals::class_ids.at("CFEPlayerDecal");
		CFireCrackerBlast = globals::class_ids.at("CFireCrackerBlast");
		CFireSmoke = globals::class_ids.at("CFireSmoke");
		CFireTrail = globals::class_ids.at("CFireTrail");
		CFish = globals::class_ids.at("CFish");
		CFists = globals::class_ids.at("CFists");
		CFlashbang = globals::class_ids.at("CFlashbang");
		CFogController = globals::class_ids.at("CFogController");
		CFootstepControl = globals::class_ids.at("CFootstepControl");
		CFunc_Dust = globals::class_ids.at("CFunc_Dust");
		CFunc_LOD = globals::class_ids.at("CFunc_LOD");
		CFuncAreaPortalWindow = globals::class_ids.at("CFuncAreaPortalWindow");
		CFuncBrush = globals::class_ids.at("CFuncBrush");
		CFuncConveyor = globals::class_ids.at("CFuncConveyor");
		CFuncLadder = globals::class_ids.at("CFuncLadder");
		CFuncMonitor = globals::class_ids.at("CFuncMonitor");
		CFuncMoveLinear = globals::class_ids.at("CFuncMoveLinear");
		CFuncOccluder = globals::class_ids.at("CFuncOccluder");
		CFuncReflectiveGlass = globals::class_ids.at("CFuncReflectiveGlass");
		CFuncRotating = globals::class_ids.at("CFuncRotating");
		CFuncSmokeVolume = globals::class_ids.at("CFuncSmokeVolume");
		CFuncTrackTrain = globals::class_ids.at("CFuncTrackTrain");
		CGameRulesProxy = globals::class_ids.at("CGameRulesProxy");
		CGrassBurn = globals::class_ids.at("CGrassBurn");
		CHandleTest = globals::class_ids.at("CHandleTest");
		CHEGrenade = globals::class_ids.at("CHEGrenade");
		CHostage = globals::class_ids.at("CHostage");
		CHostageCarriableProp = globals::class_ids.at("CHostageCarriableProp");
		CIncendiaryGrenade = globals::class_ids.at("CIncendiaryGrenade");
		CInferno = globals::class_ids.at("CInferno");
		CInfoLadderDismount = globals::class_ids.at("CInfoLadderDismount");
		CInfoMapRegion = globals::class_ids.at("CInfoMapRegion");
		CInfoOverlayAccessor = globals::class_ids.at("CInfoOverlayAccessor");
		CItem_Healthshot = globals::class_ids.at("CItem_Healthshot");
		CItemCash = globals::class_ids.at("CItemCash");
		CItemDogtags = globals::class_ids.at("CItemDogtags");
		CKnife = globals::class_ids.at("CKnife");
		CKnifeGG = globals::class_ids.at("CKnifeGG");
		CLightGlow = globals::class_ids.at("CLightGlow");
		CMapVetoPickController = globals::class_ids.at("CMapVetoPickController");
		CMaterialModifyControl = globals::class_ids.at("CMaterialModifyControl");
		CMelee = globals::class_ids.at("CMelee");
		CMolotovGrenade = globals::class_ids.at("CMolotovGrenade");
		CMolotovProjectile = globals::class_ids.at("CMolotovProjectile");
		CMovieDisplay = globals::class_ids.at("CMovieDisplay");
		CParadropChopper = globals::class_ids.at("CParadropChopper");
		CParticleFire = globals::class_ids.at("CParticleFire");
		CParticlePerformanceMonitor = globals::class_ids.at("CParticlePerformanceMonitor");
		CParticleSystem = globals::class_ids.at("CParticleSystem");
		CPhysBox = globals::class_ids.at("CPhysBox");
		CPhysBoxMultiplayer = globals::class_ids.at("CPhysBoxMultiplayer");
		CPhysicsProp = globals::class_ids.at("CPhysicsProp");
		CPhysicsPropMultiplayer = globals::class_ids.at("CPhysicsPropMultiplayer");
		CPhysMagnet = globals::class_ids.at("CPhysMagnet");
		CPhysPropAmmoBox = globals::class_ids.at("CPhysPropAmmoBox");
		CPhysPropLootCrate = globals::class_ids.at("CPhysPropLootCrate");
		CPhysPropRadarJammer = globals::class_ids.at("CPhysPropRadarJammer");
		CPhysPropWeaponUpgrade = globals::class_ids.at("CPhysPropWeaponUpgrade");
		CPlantedC4 = globals::class_ids.at("CPlantedC4");
		CPlasma = globals::class_ids.at("CPlasma");
		CPlayerPing = globals::class_ids.at("CPlayerPing");
		CPlayerResource = globals::class_ids.at("CPlayerResource");
		CPointCamera = globals::class_ids.at("CPointCamera");
		CPointCommentaryNode = globals::class_ids.at("CPointCommentaryNode");
		CPointWorldText = globals::class_ids.at("CPointWorldText");
		CPoseController = globals::class_ids.at("CPoseController");
		CPostProcessController = globals::class_ids.at("CPostProcessController");
		CPrecipitation = globals::class_ids.at("CPrecipitation");
		CPrecipitationBlocker = globals::class_ids.at("CPrecipitationBlocker");
		CPredictedViewModel = globals::class_ids.at("CPredictedViewModel");
		CProp_Hallucination = globals::class_ids.at("CProp_Hallucination");
		CPropCounter = globals::class_ids.at("CPropCounter");
		CPropDoorRotating = globals::class_ids.at("CPropDoorRotating");
		CPropJeep = globals::class_ids.at("CPropJeep");
		CPropVehicleDriveable = globals::class_ids.at("CPropVehicleDriveable");
		CRagdollManager = globals::class_ids.at("CRagdollManager");
		CRagdollProp = globals::class_ids.at("CRagdollProp");
		CRagdollPropAttached = globals::class_ids.at("CRagdollPropAttached");
		CRopeKeyframe = globals::class_ids.at("CRopeKeyframe");
		CSCAR17 = globals::class_ids.at("CSCAR17");
		CSceneEntity = globals::class_ids.at("CSceneEntity");
		CSensorGrenade = globals::class_ids.at("CSensorGrenade");
		CSensorGrenadeProjectile = globals::class_ids.at("CSensorGrenadeProjectile");
		CShadowControl = globals::class_ids.at("CShadowControl");
		CSlideshowDisplay = globals::class_ids.at("CSlideshowDisplay");
		CSmokeGrenade = globals::class_ids.at("CSmokeGrenade");
		CSmokeGrenadeProjectile = globals::class_ids.at("CSmokeGrenadeProjectile");
		CSmokeStack = globals::class_ids.at("CSmokeStack");
		CSnowball = globals::class_ids.at("CSnowball");
		CSnowballPile = globals::class_ids.at("CSnowballPile");
		CSnowballProjectile = globals::class_ids.at("CSnowballProjectile");
		CSpatialEntity = globals::class_ids.at("CSpatialEntity");
		CSpotlightEnd = globals::class_ids.at("CSpotlightEnd");
		CSprite = globals::class_ids.at("CSprite");
		CSpriteOriented = globals::class_ids.at("CSpriteOriented");
		CSpriteTrail = globals::class_ids.at("CSpriteTrail");
		CStatueProp = globals::class_ids.at("CStatueProp");
		CSteamJet = globals::class_ids.at("CSteamJet");
		CSun = globals::class_ids.at("CSun");
		CSunlightShadowControl = globals::class_ids.at("CSunlightShadowControl");
		CSurvivalSpawnChopper = globals::class_ids.at("CSurvivalSpawnChopper");
		CTablet = globals::class_ids.at("CTablet");
		CTeam = globals::class_ids.at("CTeam");
		CTeamplayRoundBasedRulesProxy = globals::class_ids.at("CTeamplayRoundBasedRulesProxy");
		CTEArmorRicochet = globals::class_ids.at("CTEArmorRicochet");
		CTEBaseBeam = globals::class_ids.at("CTEBaseBeam");
		CTEBeamEntPoint = globals::class_ids.at("CTEBeamEntPoint");
		CTEBeamEnts = globals::class_ids.at("CTEBeamEnts");
		CTEBeamFollow = globals::class_ids.at("CTEBeamFollow");
		CTEBeamLaser = globals::class_ids.at("CTEBeamLaser");
		CTEBeamPoints = globals::class_ids.at("CTEBeamPoints");
		CTEBeamRing = globals::class_ids.at("CTEBeamRing");
		CTEBeamRingPoint = globals::class_ids.at("CTEBeamRingPoint");
		CTEBeamSpline = globals::class_ids.at("CTEBeamSpline");
		CTEBloodSprite = globals::class_ids.at("CTEBloodSprite");
		CTEBloodStream = globals::class_ids.at("CTEBloodStream");
		CTEBreakModel = globals::class_ids.at("CTEBreakModel");
		CTEBSPDecal = globals::class_ids.at("CTEBSPDecal");
		CTEBubbles = globals::class_ids.at("CTEBubbles");
		CTEBubbleTrail = globals::class_ids.at("CTEBubbleTrail");
		CTEClientProjectile = globals::class_ids.at("CTEClientProjectile");
		CTEDecal = globals::class_ids.at("CTEDecal");
		CTEDust = globals::class_ids.at("CTEDust");
		CTEDynamicLight = globals::class_ids.at("CTEDynamicLight");
		CTEEffectDispatch = globals::class_ids.at("CTEEffectDispatch");
		CTEEnergySplash = globals::class_ids.at("CTEEnergySplash");
		CTEExplosion = globals::class_ids.at("CTEExplosion");
		CTEFireBullets = globals::class_ids.at("CTEFireBullets");
		CTEFizz = globals::class_ids.at("CTEFizz");
		CTEFootprintDecal = globals::class_ids.at("CTEFootprintDecal");
		CTEFoundryHelpers = globals::class_ids.at("CTEFoundryHelpers");
		CTEGaussExplosion = globals::class_ids.at("CTEGaussExplosion");
		CTEGlowSprite = globals::class_ids.at("CTEGlowSprite");
		CTEImpact = globals::class_ids.at("CTEImpact");
		CTEKillPlayerAttachments = globals::class_ids.at("CTEKillPlayerAttachments");
		CTELargeFunnel = globals::class_ids.at("CTELargeFunnel");
		CTEMetalSparks = globals::class_ids.at("CTEMetalSparks");
		CTEMuzzleFlash = globals::class_ids.at("CTEMuzzleFlash");
		CTEParticleSystem = globals::class_ids.at("CTEParticleSystem");
		CTEPhysicsProp = globals::class_ids.at("CTEPhysicsProp");
		CTEPlantBomb = globals::class_ids.at("CTEPlantBomb");
		CTEPlayerAnimEvent = globals::class_ids.at("CTEPlayerAnimEvent");
		CTEPlayerDecal = globals::class_ids.at("CTEPlayerDecal");
		CTEProjectedDecal = globals::class_ids.at("CTEProjectedDecal");
		CTERadioIcon = globals::class_ids.at("CTERadioIcon");
		CTEShatterSurface = globals::class_ids.at("CTEShatterSurface");
		CTEShowLine = globals::class_ids.at("CTEShowLine");
		CTesla = globals::class_ids.at("CTesla");
		CTESmoke = globals::class_ids.at("CTESmoke");
		CTESparks = globals::class_ids.at("CTESparks");
		CTESprite = globals::class_ids.at("CTESprite");
		CTESpriteSpray = globals::class_ids.at("CTESpriteSpray");
		CTest_ProxyToggle_Networkable = globals::class_ids.at("CTest_ProxyToggle_Networkable");
		CTestTraceline = globals::class_ids.at("CTestTraceline");
		CTEWorldDecal = globals::class_ids.at("CTEWorldDecal");
		CTriggerPlayerMovement = globals::class_ids.at("CTriggerPlayerMovement");
		CTriggerSoundOperator = globals::class_ids.at("CTriggerSoundOperator");
		CVGuiScreen = globals::class_ids.at("CVGuiScreen");
		CVoteController = globals::class_ids.at("CVoteController");
		CWaterBullet = globals::class_ids.at("CWaterBullet");
		CWaterLODControl = globals::class_ids.at("CWaterLODControl");
		CWeaponAug = globals::class_ids.at("CWeaponAug");
		CWeaponAWP = globals::class_ids.at("CWeaponAWP");
		CWeaponBaseItem = globals::class_ids.at("CWeaponBaseItem");
		CWeaponBizon = globals::class_ids.at("CWeaponBizon");
		CWeaponCSBase = globals::class_ids.at("CWeaponCSBase");
		CWeaponCSBaseGun = globals::class_ids.at("CWeaponCSBaseGun");
		CWeaponCycler = globals::class_ids.at("CWeaponCycler");
		CWeaponElite = globals::class_ids.at("CWeaponElite");
		CWeaponFamas = globals::class_ids.at("CWeaponFamas");
		CWeaponFiveSeven = globals::class_ids.at("CWeaponFiveSeven");
		CWeaponG3SG1 = globals::class_ids.at("CWeaponG3SG1");
		CWeaponGalil = globals::class_ids.at("CWeaponGalil");
		CWeaponGalilAR = globals::class_ids.at("CWeaponGalilAR");
		CWeaponGlock = globals::class_ids.at("CWeaponGlock");
		CWeaponHKP2000 = globals::class_ids.at("CWeaponHKP2000");
		CWeaponM249 = globals::class_ids.at("CWeaponM249");
		CWeaponM3 = globals::class_ids.at("CWeaponM3");
		CWeaponM4A1 = globals::class_ids.at("CWeaponM4A1");
		CWeaponMAC10 = globals::class_ids.at("CWeaponMAC10");
		CWeaponMag7 = globals::class_ids.at("CWeaponMag7");
		CWeaponMP5Navy = globals::class_ids.at("CWeaponMP5Navy");
		CWeaponMP7 = globals::class_ids.at("CWeaponMP7");
		CWeaponMP9 = globals::class_ids.at("CWeaponMP9");
		CWeaponNegev = globals::class_ids.at("CWeaponNegev");
		CWeaponNOVA = globals::class_ids.at("CWeaponNOVA");
		CWeaponP228 = globals::class_ids.at("CWeaponP228");
		CWeaponP250 = globals::class_ids.at("CWeaponP250");
		CWeaponP90 = globals::class_ids.at("CWeaponP90");
		CWeaponSawedoff = globals::class_ids.at("CWeaponSawedoff");
		CWeaponSCAR20 = globals::class_ids.at("CWeaponSCAR20");
		CWeaponScout = globals::class_ids.at("CWeaponScout");
		CWeaponSG550 = globals::class_ids.at("CWeaponSG550");
		CWeaponSG552 = globals::class_ids.at("CWeaponSG552");
		CWeaponSG556 = globals::class_ids.at("CWeaponSG556");
		CWeaponShield = globals::class_ids.at("CWeaponShield");
		CWeaponSSG08 = globals::class_ids.at("CWeaponSSG08");
		CWeaponTaser = globals::class_ids.at("CWeaponTaser");
		CWeaponTec9 = globals::class_ids.at("CWeaponTec9");
		CWeaponTMP = globals::class_ids.at("CWeaponTMP");
		CWeaponUMP45 = globals::class_ids.at("CWeaponUMP45");
		CWeaponUSP = globals::class_ids.at("CWeaponUSP");
		CWeaponXM1014 = globals::class_ids.at("CWeaponXM1014");
		CWeaponZoneRepulsor = globals::class_ids.at("CWeaponZoneRepulsor");
		CWorld = globals::class_ids.at("CWorld");
		CWorldVguiText = globals::class_ids.at("CWorldVguiText");
		DustTrail = globals::class_ids.at("DustTrail");
		MovieExplosion = globals::class_ids.at("MovieExplosion");
		ParticleSmokeGrenade = globals::class_ids.at("ParticleSmokeGrenade");
		RocketTrail = globals::class_ids.at("RocketTrail");
		SmokeTrail = globals::class_ids.at("SmokeTrail");
		SporeExplosion = globals::class_ids.at("SporeExplosion");
		SporeTrail = globals::class_ids.at("SporeTrail");
	}
}
```

`src/valve_sdk/classids.h`:

```h
#pragma once

#include "../settings/globals.h"

namespace classids
{
	extern int CAI_BaseNPC;
	extern int CAK47;
	extern int CBaseAnimating;
	extern int CBaseAnimatingOverlay;
	extern int CBaseAttributableItem;
	extern int CBaseButton;
	extern int CBaseCombatCharacter;
	extern int CBaseCombatWeapon;
	extern int CBaseCSGrenade;
	extern int CBaseCSGrenadeProjectile;
	extern int CBaseDoor;
	extern int CBaseEntity;
	extern int CBaseFlex;
	extern int CBaseGrenade;
	extern int CBaseParticleEntity;
	extern int CBasePlayer;
	extern int CBasePropDoor;
	extern int CBaseTeamObjectiveResource;
	extern int CBaseTempEntity;
	extern int CBaseToggle;
	extern int CBaseTrigger;
	extern int CBaseViewModel;
	extern int CBaseVPhysicsTrigger;
	extern int CBaseWeaponWorldModel;
	extern int CBeam;
	extern int CBeamSpotlight;
	extern int CBoneFollower;
	extern int CBRC4Target;
	extern int CBreachCharge;
	extern int CBreachChargeProjectile;
	extern int CBreakableProp;
	extern int CBreakableSurface;
	extern int CBumpMine;
	extern int CBumpMineProjectile;
	extern int CC4;
	extern int CCascadeLight;
	extern int CChicken;
	extern int CColorCorrection;
	extern int CColorCorrectionVolume;
	extern int CCSGameRulesProxy;
	extern int CCSPlayer;
	extern int CCSPlayerResource;
	extern int CCSRagdoll;
	extern int CCSTeam;
	extern int CDangerZone;
	extern int CDangerZoneController;
	extern int CDEagle;
	extern int CDecoyGrenade;
	extern int CDecoyProjectile;
	extern int CDrone;
	extern int CDronegun;
	extern int CDynamicLight;
	extern int CDynamicProp;
	extern int CEconEntity;
	extern int CEconWearable;
	extern int CEmbers;
	extern int CEntityDissolve;
	extern int CEntityFlame;
	extern int CEntityFreezing;
	extern int CEntityParticleTrail;
	extern int CEnvAmbientLight;
	extern int CEnvDetailController;
	extern int CEnvDOFController;
	extern int CEnvGasCanister;
	extern int CEnvParticleScript;
	extern int CEnvProjectedTexture;
	extern int CEnvQuadraticBeam;
	extern int CEnvScreenEffect;
	extern int CEnvScreenOverlay;
	extern int CEnvTonemapController;
	extern int CEnvWind;
	extern int CFEPlayerDecal;
	extern int CFireCrackerBlast;
	extern int CFireSmoke;
	extern int CFireTrail;
	extern int CFish;
	extern int CFists;
	extern int CFlashbang;
	extern int CFogController;
	extern int CFootstepControl;
	extern int CFunc_Dust;
	extern int CFunc_LOD;
	extern int CFuncAreaPortalWindow;
	extern int CFuncBrush;
	extern int CFuncConveyor;
	extern int CFuncLadder;
	extern int CFuncMonitor;
	extern int CFuncMoveLinear;
	extern int CFuncOccluder;
	extern int CFuncReflectiveGlass;
	extern int CFuncRotating;
	extern int CFuncSmokeVolume;
	extern int CFuncTrackTrain;
	extern int CGameRulesProxy;
	extern int CGrassBurn;
	extern int CHandleTest;
	extern int CHEGrenade;
	extern int CHostage;
	extern int CHostageCarriableProp;
	extern int CIncendiaryGrenade;
	extern int CInferno;
	extern int CInfoLadderDismount;
	extern int CInfoMapRegion;
	extern int CInfoOverlayAccessor;
	extern int CItem_Healthshot;
	extern int CItemCash;
	extern int CItemDogtags;
	extern int CKnife;
	extern int CKnifeGG;
	extern int CLightGlow;
	extern int CMapVetoPickController;
	extern int CMaterialModifyControl;
	extern int CMelee;
	extern int CMolotovGrenade;
	extern int CMolotovProjectile;
	extern int CMovieDisplay;
	extern int CParadropChopper;
	extern int CParticleFire;
	extern int CParticlePerformanceMonitor;
	extern int CParticleSystem;
	extern int CPhysBox;
	extern int CPhysBoxMultiplayer;
	extern int CPhysicsProp;
	extern int CPhysicsPropMultiplayer;
	extern int CPhysMagnet;
	extern int CPhysPropAmmoBox;
	extern int CPhysPropLootCrate;
	extern int CPhysPropRadarJammer;
	extern int CPhysPropWeaponUpgrade;
	extern int CPlantedC4;
	extern int CPlasma;
	extern int CPlayerPing;
	extern int CPlayerResource;
	extern int CPointCamera;
	extern int CPointCommentaryNode;
	extern int CPointWorldText;
	extern int CPoseController;
	extern int CPostProcessController;
	extern int CPrecipitation;
	extern int CPrecipitationBlocker;
	extern int CPredictedViewModel;
	extern int CProp_Hallucination;
	extern int CPropCounter;
	extern int CPropDoorRotating;
	extern int CPropJeep;
	extern int CPropVehicleDriveable;
	extern int CRagdollManager;
	extern int CRagdollProp;
	extern int CRagdollPropAttached;
	extern int CRopeKeyframe;
	extern int CSCAR17;
	extern int CSceneEntity;
	extern int CSensorGrenade;
	extern int CSensorGrenadeProjectile;
	extern int CShadowControl;
	extern int CSlideshowDisplay;
	extern int CSmokeGrenade;
	extern int CSmokeGrenadeProjectile;
	extern int CSmokeStack;
	extern int CSnowball;
	extern int CSnowballPile;
	extern int CSnowballProjectile;
	extern int CSpatialEntity;
	extern int CSpotlightEnd;
	extern int CSprite;
	extern int CSpriteOriented;
	extern int CSpriteTrail;
	extern int CStatueProp;
	extern int CSteamJet;
	extern int CSun;
	extern int CSunlightShadowControl;
	extern int CSurvivalSpawnChopper;
	extern int CTablet;
	extern int CTeam;
	extern int CTeamplayRoundBasedRulesProxy;
	extern int CTEArmorRicochet;
	extern int CTEBaseBeam;
	extern int CTEBeamEntPoint;
	extern int CTEBeamEnts;
	extern int CTEBeamFollow;
	extern int CTEBeamLaser;
	extern int CTEBeamPoints;
	extern int CTEBeamRing;
	extern int CTEBeamRingPoint;
	extern int CTEBeamSpline;
	extern int CTEBloodSprite;
	extern int CTEBloodStream;
	extern int CTEBreakModel;
	extern int CTEBSPDecal;
	extern int CTEBubbles;
	extern int CTEBubbleTrail;
	extern int CTEClientProjectile;
	extern int CTEDecal;
	extern int CTEDust;
	extern int CTEDynamicLight;
	extern int CTEEffectDispatch;
	extern int CTEEnergySplash;
	extern int CTEExplosion;
	extern int CTEFireBullets;
	extern int CTEFizz;
	extern int CTEFootprintDecal;
	extern int CTEFoundryHelpers;
	extern int CTEGaussExplosion;
	extern int CTEGlowSprite;
	extern int CTEImpact;
	extern int CTEKillPlayerAttachments;
	extern int CTELargeFunnel;
	extern int CTEMetalSparks;
	extern int CTEMuzzleFlash;
	extern int CTEParticleSystem;
	extern int CTEPhysicsProp;
	extern int CTEPlantBomb;
	extern int CTEPlayerAnimEvent;
	extern int CTEPlayerDecal;
	extern int CTEProjectedDecal;
	extern int CTERadioIcon;
	extern int CTEShatterSurface;
	extern int CTEShowLine;
	extern int CTesla;
	extern int CTESmoke;
	extern int CTESparks;
	extern int CTESprite;
	extern int CTESpriteSpray;
	extern int CTest_ProxyToggle_Networkable;
	extern int CTestTraceline;
	extern int CTEWorldDecal;
	extern int CTriggerPlayerMovement;
	extern int CTriggerSoundOperator;
	extern int CVGuiScreen;
	extern int CVoteController;
	extern int CWaterBullet;
	extern int CWaterLODControl;
	extern int CWeaponAug;
	extern int CWeaponAWP;
	extern int CWeaponBaseItem;
	extern int CWeaponBizon;
	extern int CWeaponCSBase;
	extern int CWeaponCSBaseGun;
	extern int CWeaponCycler;
	extern int CWeaponElite;
	extern int CWeaponFamas;
	extern int CWeaponFiveSeven;
	extern int CWeaponG3SG1;
	extern int CWeaponGalil;
	extern int CWeaponGalilAR;
	extern int CWeaponGlock;
	extern int CWeaponHKP2000;
	extern int CWeaponM249;
	extern int CWeaponM3;
	extern int CWeaponM4A1;
	extern int CWeaponMAC10;
	extern int CWeaponMag7;
	extern int CWeaponMP5Navy;
	extern int CWeaponMP7;
	extern int CWeaponMP9;
	extern int CWeaponNegev;
	extern int CWeaponNOVA;
	extern int CWeaponP228;
	extern int CWeaponP250;
	extern int CWeaponP90;
	extern int CWeaponSawedoff;
	extern int CWeaponSCAR20;
	extern int CWeaponScout;
	extern int CWeaponSG550;
	extern int CWeaponSG552;
	extern int CWeaponSG556;
	extern int CWeaponShield;
	extern int CWeaponSSG08;
	extern int CWeaponTaser;
	extern int CWeaponTec9;
	extern int CWeaponTMP;
	extern int CWeaponUMP45;
	extern int CWeaponUSP;
	extern int CWeaponXM1014;
	extern int CWeaponZoneRepulsor;
	extern int CWorld;
	extern int CWorldVguiText;
	extern int DustTrail;
	extern int MovieExplosion;
	extern int ParticleSmokeGrenade;
	extern int RocketTrail;
	extern int SmokeTrail;
	extern int SporeExplosion;
	extern int SporeTrail;

	void initialize();
}

```

`src/valve_sdk/csgostructs.cpp`:

```cpp
#include "csgostructs.hpp"
#include "../helpers/math.h"
#include "../helpers/utils.h"
#include "../helpers/console.h"
#include "../settings/globals.h"
#include "../helpers/entities.h"
#include "../features/features.h"
#include "classids.h"
#include "../settings/globals.h"

std::vector<int> c_base_player::hitboxes()
{
	std::vector<int> list;
	//list.clear();

	auto a_settings = &settings::aimbot::m_items[g::local_player->m_hActiveWeapon()->m_iItemDefinitionIndex()];

	if (a_settings->hitboxes.head)
		list.emplace_back(HITBOX_HEAD);

	if (a_settings->hitboxes.neck)
		list.emplace_back(HITBOX_NECK);

	if (a_settings->hitboxes.body)
	{
		list.emplace_back(HITBOX_UPPER_CHEST);
		list.emplace_back(HITBOX_LOWER_CHEST);
		list.emplace_back(HITBOX_THORAX);
		list.emplace_back(HITBOX_BELLY);
		list.emplace_back(HITBOX_PELVIS);
	}

	if (a_settings->hitboxes.arms)
	{
		list.emplace_back(HITBOX_RIGHT_UPPER_ARM);
		list.emplace_back(HITBOX_RIGHT_FOREARM);
		list.emplace_back(HITBOX_LEFT_UPPER_ARM);
		list.emplace_back(HITBOX_LEFT_FOREARM);
	}

	if (a_settings->hitboxes.legs)
	{
		list.emplace_back(HITBOX_RIGHT_THIGH);
		list.emplace_back(HITBOX_LEFT_THIGH);
		list.emplace_back(HITBOX_RIGHT_CALF);
		list.emplace_back(HITBOX_LEFT_CALF);
	}

	if (InAir())
	{
		list.pop_back();

		list.emplace_back(HITBOX_UPPER_CHEST);
		list.emplace_back(HITBOX_LOWER_CHEST);
		list.emplace_back(HITBOX_THORAX);
		list.emplace_back(HITBOX_BELLY);
		list.emplace_back(HITBOX_PELVIS);

		list.emplace_back(HITBOX_RIGHT_UPPER_ARM);
		list.emplace_back(HITBOX_RIGHT_FOREARM);
		list.emplace_back(HITBOX_LEFT_UPPER_ARM);
		list.emplace_back(HITBOX_LEFT_FOREARM);

		list.emplace_back(HITBOX_RIGHT_THIGH);
		list.emplace_back(HITBOX_LEFT_THIGH);
		list.emplace_back(HITBOX_RIGHT_CALF);
		list.emplace_back(HITBOX_LEFT_CALF);
	}
	else
	{
		if (a_settings->hitboxes.head)
			list.emplace_back(HITBOX_HEAD);

		if (a_settings->hitboxes.neck)
			list.emplace_back(HITBOX_NECK);

		if (a_settings->hitboxes.body)
		{
			list.emplace_back(HITBOX_UPPER_CHEST);
			list.emplace_back(HITBOX_LOWER_CHEST);
			list.emplace_back(HITBOX_THORAX);
			list.emplace_back(HITBOX_BELLY);
			list.emplace_back(HITBOX_PELVIS);
		}

		if (a_settings->hitboxes.legs)
		{
			list.emplace_back(HITBOX_RIGHT_THIGH);
			list.emplace_back(HITBOX_LEFT_THIGH);
			list.emplace_back(HITBOX_RIGHT_CALF);
			list.emplace_back(HITBOX_LEFT_CALF);
		}

		if (a_settings->hitboxes.arms)
		{
			list.emplace_back(HITBOX_RIGHT_UPPER_ARM);
			list.emplace_back(HITBOX_RIGHT_FOREARM);
			list.emplace_back(HITBOX_LEFT_UPPER_ARM);
			list.emplace_back(HITBOX_LEFT_FOREARM);
		}
	}

	if (a_settings->rcs_override_hitbox)
	{
		if (g::local_player->m_iShotsFired() >= 3)
		{
			list.pop_back();

			list.emplace_back(HITBOX_UPPER_CHEST);
			list.emplace_back(HITBOX_LOWER_CHEST);
			list.emplace_back(HITBOX_THORAX);
			list.emplace_back(HITBOX_BELLY);
			list.emplace_back(HITBOX_PELVIS);
		}
		else if (g::local_player->m_iShotsFired() < 3)
		{
			list.pop_back();

			if (a_settings->hitboxes.head)
				list.emplace_back(HITBOX_HEAD);

			if (a_settings->hitboxes.neck)
				list.emplace_back(HITBOX_NECK);

			if (a_settings->hitboxes.body)
			{
				list.emplace_back(HITBOX_UPPER_CHEST);
				list.emplace_back(HITBOX_LOWER_CHEST);
				list.emplace_back(HITBOX_THORAX);
				list.emplace_back(HITBOX_BELLY);
				list.emplace_back(HITBOX_PELVIS);
			}

			if (a_settings->hitboxes.legs)
			{
				list.emplace_back(HITBOX_RIGHT_THIGH);
				list.emplace_back(HITBOX_LEFT_THIGH);
				list.emplace_back(HITBOX_RIGHT_CALF);
				list.emplace_back(HITBOX_LEFT_CALF);
			}

			if (a_settings->hitboxes.arms)
			{
				list.emplace_back(HITBOX_RIGHT_UPPER_ARM);
				list.emplace_back(HITBOX_RIGHT_FOREARM);
				list.emplace_back(HITBOX_LEFT_UPPER_ARM);
				list.emplace_back(HITBOX_LEFT_FOREARM);
			}
		}
	}

	return list;
}

int c_base_entity::GetSequenceActivity(studiohdr_t* hdr, const int& sequence)
{
	if (!patterns::get_sequence_activity_addr)
	{
		console::print(xorstr_("patterns::get_sequence_activity_addr - nullptr.\n"));

		return -1;
	}

	static auto get_sequence_activity = reinterpret_cast<int(__fastcall*)(void*, studiohdr_t*, int)>(patterns::get_sequence_activity_addr);

	return get_sequence_activity(this, hdr, sequence);
}

void c_base_entity::UpdateVisibilityAllEntities()
{
	if (!patterns::update_visibility_entities_addr)
	{
		console::print(xorstr_("patterns::update_visibility_entities_addr - nullptr.\n"));

		return;
	}

	static auto fn_offset = reinterpret_cast<void(__thiscall*)(void*)>(patterns::update_visibility_entities_addr);

	fn_offset(this);
}

const matrix3x4_t& c_base_entity::m_rgflCoordinateFrame()
{
	return *(matrix3x4_t*)(uintptr_t(this) + 0x444);
}

Vector& c_base_entity::GetAbsOrigin()
{
	return CallVFunction<Vector& (__thiscall*)(void*)>(this, 10)(this);
}

void c_base_entity::SetAbsOrigin(const Vector& origin)
{
	if (!patterns::set_abs_origin_addr)
	{
		console::print(xorstr_("patterns::set_abs_origin_addr - nullptr.\n"));

		return;
	}

	static auto set_origin_fn = reinterpret_cast<void(__thiscall*)(void*, const Vector&)>(patterns::set_abs_origin_addr);

	set_origin_fn(this, origin);
}

QAngle& c_base_player::GetAbsAngles()
{
	return CallVFunction<QAngle&(__thiscall*)(void*)>(this, 11)(this);
}

void c_base_player::SetAbsAngles(const QAngle& angles)
{
	if (!patterns::set_abs_angle_addr)
	{
		console::print(xorstr_("patterns::set_abs_angle_addr - nullptr.\n"));

		return;
	}

	static auto set_angle_fn = reinterpret_cast<void(__thiscall*)(void*, const QAngle&)>(patterns::set_abs_angle_addr);

	set_angle_fn(this, angles);
}

float c_base_combat_weapon::GetInaccuracy()
{
	return CallVFunction<float(__thiscall*)(void*)>(this, 483)(this);
}

float c_base_combat_weapon::GetSpread()
{
	return CallVFunction<float(__thiscall*)(void*)>(this, 453)(this);
}

void c_base_combat_weapon::UpdateAccuracyPenalty()
{
	CallVFunction<void(__thiscall*)(void*)>(this, 484)(this);
}

CAnimationLayer* c_base_player::GetAnimOverlays()
{
	return *reinterpret_cast<CAnimationLayer**>(reinterpret_cast<DWORD>(this) + 0x2990);
}

CAnimationLayer* c_base_player::GetAnimOverlay(int i)
{
	if (i < 15)
		return &GetAnimOverlays()[i];

	return nullptr;
}

CAnimState* c_base_player::GetPlayerAnimState()
{
	return *reinterpret_cast<CAnimState**>(reinterpret_cast<DWORD>(this) + 0x9960);
}

void c_base_player::ResetAnimationState(CAnimState* state) 
{
	using ResetAnimState_t = void(__thiscall*)(CAnimState*);

	static auto ResetAnimState = (ResetAnimState_t)utils::pattern_scan(("client.dll"), "56 6A 01 68 ? ? ? ? 8B F1");

	if (!ResetAnimState)
		return;

	ResetAnimState(state);
}

void c_base_player::InvalidateBoneCache()
{
	if (!patterns::invalidate_bonecache_addr)
	{
		console::print(xorstr_("patterns::invalidate_bonecache_addr - nullptr.\n"));

		return;
	}

	const auto model_bone_counter = **reinterpret_cast<unsigned long**>(patterns::invalidate_bonecache_addr + 10);
	*reinterpret_cast<unsigned int*>(reinterpret_cast<DWORD>(this) + 0x2928) = 0xFF7FFFFF; // m_flLastBoneSetupTime = -FLT_MAX;
	*reinterpret_cast<unsigned int*>(reinterpret_cast<DWORD>(this) + 0x2690) = model_bone_counter - 1; // m_iMostRecentModelBoneCounter = g_iModelBoneCounter - 1;
}

void c_base_player::UpdateClientSideAnimation()
{
	CallVFunction<void(__thiscall*)(void*)>(this, 224)(this);
}

bool c_base_entity::IsPlayer()
{
	return CallVFunction<bool(__thiscall*)(void*)>(this, 158)(this);
}

bool c_base_entity::IsWeapon()
{
	return CallVFunction<bool(__thiscall*)(c_base_entity*)>(this, 166)(this);
}

bool c_base_entity::IsPlantedC4()
{
	return GetClientClass()->m_ClassID == classids::CPlantedC4;
}

bool c_base_entity::IsDefuseKit()
{
	return GetClientClass()->m_ClassID == classids::CBaseAnimating;
}

CCSWeaponInfo* c_base_combat_weapon::GetWeaponData()
{
	return CallVFunction<CCSWeaponInfo* (__thiscall*)(void*)>(this, 461)(this);
}

bool c_base_combat_weapon::HasBullets()
{
	return !IsReloading() && m_iClip1() > 0;
}

char* c_base_combat_weapon::GetGunIcon()
{
	if (!this)
		return (char*)" ";

	switch (this->m_iItemDefinitionIndex())
	{
	case WEAPON_KNIFE:
	case WEAPON_KNIFE_BAYONET:
	case WEAPON_KNIFE_CSS:
	case WEAPON_KNIFE_FLIP:
	case WEAPON_KNIFE_GUT:
	case WEAPON_KNIFE_KARAMBIT:
	case WEAPON_KNIFE_M9_BAYONET:
	case WEAPON_KNIFE_TACTICAL:
	case WEAPON_KNIFE_FALCHION:
	case WEAPON_KNIFE_SURVIVAL_BOWIE:
	case WEAPON_KNIFE_BUTTERFLY:
	case WEAPON_KNIFE_PUSH:
	case WEAPON_KNIFE_CORD:
	case WEAPON_KNIFE_CANIS:
	case WEAPON_KNIFE_URSUS:
	case WEAPON_KNIFE_GYPSY_JACKKNIFE:
	case WEAPON_KNIFE_OUTDOOR:
	case WEAPON_KNIFE_STILETTO:
	case WEAPON_KNIFE_WIDOWMAKER:
	case WEAPON_KNIFE_SKELETON:
		return (char*)"]";
	case WEAPON_DEAGLE:
		return (char*)"A";
	case WEAPON_ELITE:
		return (char*)"B";
	case WEAPON_FIVESEVEN:
		return (char*)"C";
	case WEAPON_GLOCK:
		return (char*)"D";
	case WEAPON_HKP2000:
		return (char*)"E";
	case WEAPON_P250:
		return (char*)"F";
	case WEAPON_USP_SILENCER:
		return (char*)"G";
	case WEAPON_TEC9:
		return (char*)"H";
	case WEAPON_CZ75A:
		return (char*)"I";
	case WEAPON_REVOLVER:
		return (char*)"J";
	case WEAPON_MAC10:
		return (char*)"K";
	case WEAPON_UMP45:
		return (char*)"L";
	case WEAPON_BIZON:
		return (char*)"M";
	case WEAPON_MP7:
		return (char*)"N";
	case WEAPON_MP5SD:
		return (char*)"N";
	case WEAPON_MP9:
		return (char*)"O";
	case WEAPON_P90:
		return (char*)"P";
	case WEAPON_GALILAR:
		return (char*)"Q";
	case WEAPON_FAMAS:
		return (char*)"R";
	case WEAPON_M4A1:
		return (char*)"S";
	case WEAPON_M4A1_SILENCER:
		return (char*)"T";
	case WEAPON_AUG:
		return (char*)"U";
	case WEAPON_SG556:
		return (char*)"V";
	case WEAPON_AK47:
		return (char*)"W";
	case WEAPON_G3SG1:
		return (char*)"X";
	case WEAPON_SCAR20:
		return (char*)"Y";
	case WEAPON_AWP:
		return (char*)"Z";
	case WEAPON_SSG08:
		return (char*)"a";
	case WEAPON_XM1014:
		return (char*)"b";
	case WEAPON_SAWEDOFF:
		return (char*)"c";
	case WEAPON_MAG7:
		return (char*)"d";
	case WEAPON_NOVA:
		return (char*)"e";
	case WEAPON_NEGEV:
		return (char*)"f";
	case WEAPON_M249:
		return (char*)"g";
	case WEAPON_TASER:
		return (char*)"h";
	case WEAPON_FLASHBANG:
		return (char*)"i";
	case WEAPON_HEGRENADE:
		return (char*)"j";
	case WEAPON_SMOKEGRENADE:
		return (char*)"k";
	case WEAPON_MOLOTOV:
		return (char*)"l";
	case WEAPON_DECOY:
		return (char*)"m";
	case WEAPON_INCGRENADE:
		return (char*)"n";
	case WEAPON_C4:
		return (char*)"o";
	default:
		return (char*)" ";
	}
}

float c_base_combat_weapon::GetGunStringSize()
{
	if (!this)
		return 0.f;

	switch (this->m_iItemDefinitionIndex())
	{
	case WEAPON_KNIFE:
	case WEAPON_KNIFE_BAYONET:
	case WEAPON_KNIFE_CSS:
	case WEAPON_KNIFE_FLIP:
	case WEAPON_KNIFE_GUT:
	case WEAPON_KNIFE_KARAMBIT:
	case WEAPON_KNIFE_M9_BAYONET:
	case WEAPON_KNIFE_TACTICAL:
	case WEAPON_KNIFE_FALCHION:
	case WEAPON_KNIFE_SURVIVAL_BOWIE:
	case WEAPON_KNIFE_BUTTERFLY:
	case WEAPON_KNIFE_PUSH:
	case WEAPON_KNIFE_CORD:
	case WEAPON_KNIFE_CANIS:
	case WEAPON_KNIFE_URSUS:
	case WEAPON_KNIFE_GYPSY_JACKKNIFE:
	case WEAPON_KNIFE_OUTDOOR:
	case WEAPON_KNIFE_STILETTO:
	case WEAPON_KNIFE_WIDOWMAKER:
	case WEAPON_KNIFE_SKELETON:
		return 26.f;
	case WEAPON_DEAGLE:
		return 21.f;
	case WEAPON_ELITE:
		return 26.f;
	case WEAPON_FIVESEVEN:
		return 19.f;
	case WEAPON_GLOCK:
		return 21.f;
	case WEAPON_HKP2000:
		return 20.f;
	case WEAPON_P250:
		return 18.f;
	case WEAPON_USP_SILENCER:
		return 26.f;
	case WEAPON_TEC9:
		return 21.f;
	case WEAPON_CZ75A:
		return 21.f;
	case WEAPON_REVOLVER:
		return 26.f;
	case WEAPON_MAC10:
		return 21.f;
	case WEAPON_UMP45:
		return 26.f;
	case WEAPON_BIZON:
		return 26.f;
	case WEAPON_MP7:
		return 19.f;
	case WEAPON_MP5SD:
		return 26.f;
	case WEAPON_MP9:
		return 26.f;
	case WEAPON_P90:
		return 26.f;
	case WEAPON_GALILAR:
		return 26.f;
	case WEAPON_FAMAS:
		return 26.f;
	case WEAPON_M4A1:
		return 26.f;
	case WEAPON_M4A1_SILENCER:
		return 31.f;
	case WEAPON_AUG:
		return 26.f;
	case WEAPON_SG556:
		return 26.f;
	case WEAPON_AK47:
		return 26.f;
	case WEAPON_G3SG1:
		return 28.f;
	case WEAPON_SCAR20:
		return 28.f;
	case WEAPON_AWP:
		return 31.f;
	case WEAPON_SSG08:
		return 28.f;
	case WEAPON_XM1014:
		return 28.f;
	case WEAPON_SAWEDOFF:
		return 28.f;
	case WEAPON_MAG7:
		return 28.f;
	case WEAPON_NOVA:
		return 28.f;
	case WEAPON_NEGEV:
		return 28.f;
	case WEAPON_M249:
		return 28.f;
	case WEAPON_TASER:
		return 10.f; //was 18 
	case WEAPON_FLASHBANG:
		return 10.f;
	case WEAPON_HEGRENADE:
		return 10.f;
	case WEAPON_SMOKEGRENADE:
		return 10.f;
	case WEAPON_MOLOTOV:
		return 10.f;
	case WEAPON_DECOY:
		return 10.f;
	case WEAPON_INCGRENADE:
		return 10.f;
	case WEAPON_C4:
		return 10.f;
	default:
		return 10.f;
	}
}

bool c_base_combat_weapon::CanFire()
{
	if (!g::local_player)
		return false;

	static auto stored_tick = 0;
	static decltype(this) stored_weapon = nullptr;
	if (stored_weapon != this || stored_tick >= g::local_player->m_nTickBase())
	{
		stored_weapon = this;
		stored_tick = g::local_player->m_nTickBase();

		return false;
	}

	if (IsReloading() || m_iClip1() <= 0 || !g::local_player)
		return false;

	auto flServerTime = g::local_player->m_nTickBase() * g::global_vars->interval_per_tick;

	return m_flNextPrimaryAttack() <= flServerTime;
}

bool c_base_combat_weapon::RequiresRecoilControl()
{
	//Credits: Mr. Krupinski (DanielKrupinski)
	const auto& weapon_data = GetWeaponData();

	if (weapon_data)
		return weapon_data->flRecoilMagnitude < 35.0f && weapon_data->flRecoveryTimeStand > weapon_data->flCycleTime;

	return false;
}

bool c_base_combat_weapon::IsGrenade()
{
	return GetWeaponData()->WeaponType == WEAPONTYPE_GRENADE;
}

bool c_base_combat_weapon::IsKnifeOrGrenade()
{
	return IsKnife() || IsGrenade() && !IsZeus();
}

bool c_base_combat_weapon::IsZeus()
{
	return m_iItemDefinitionIndex() == WEAPON_TASER;
}

bool c_base_combat_weapon::IsKnife()
{
	return m_iItemDefinitionIndex() != WEAPON_TASER && GetWeaponData()->WeaponType == WEAPONTYPE_KNIFE;
}

bool c_base_combat_weapon::IsPistol()
{
	return GetWeaponData()->WeaponType == WEAPONTYPE_PISTOL;
}

bool c_base_combat_weapon::IsSniper()
{
	auto index = m_iItemDefinitionIndex();

	return index == WEAPON_AWP || index == WEAPON_SSG08 || index == WEAPON_SCAR20 || index == WEAPON_G3SG1;

	return GetWeaponData()->WeaponType == WEAPONTYPE_SNIPER_RIFLE;
}

bool c_base_combat_weapon::IsShotgun()
{
	auto index = m_iItemDefinitionIndex();

	return index == WEAPON_NOVA || index == WEAPON_XM1014 || index == WEAPON_SAWEDOFF || index == WEAPON_MAG7;

	return GetWeaponData()->WeaponType == WEAPONTYPE_SHOTGUN;
}

bool c_base_combat_weapon::IsSmoke()
{
	if (!this)
		return false;

	auto index = m_iItemDefinitionIndex();

	return index == WEAPON_SMOKEGRENADE;
}

bool c_base_combat_weapon::IsFlash()
{
	auto index = m_iItemDefinitionIndex();

	return index == WEAPON_FLASHBANG;
}

Vector c_base_player::get_bone_position(int bone) 
{
	static matrix3x4_t bone_matrices[128];

	if (this->SetupBones(bone_matrices, MAXSTUDIOBONES, BONE_USED_BY_HITBOX, g::global_vars->curtime))
		return Vector(bone_matrices[bone][0][3], bone_matrices[bone][1][3], bone_matrices[bone][2][3]);

	return Vector(0.f, 0.f, 0.f);
}

bool c_base_player::IsEnemy()
{
	static auto game_type = g::cvar->find("game_type");
	
	if (game_type->GetInt() == 6)
	{
		return this->m_nSurvivalTeam() != g::local_player->m_nSurvivalTeam() || g::local_player->m_nSurvivalTeam() == -1;
	}
	
	return this->m_iTeamNum() != g::local_player->m_iTeamNum();
}

bool c_base_combat_weapon::IsReloading()
{
	static auto inReload = *reinterpret_cast<uint32_t*>(patterns::in_reload_addr + 0x2);
	return *reinterpret_cast<bool*>(reinterpret_cast<DWORD>(this) + inReload);
}

Vector c_base_player::GetEyePos()
{
	return m_vecOrigin() + m_vecViewOffset();
}

Vector c_base_player::get_hitbox_position(int hitbox_id) 
{
	static matrix3x4_t bone_matrix[MAXSTUDIOBONES];

	if (this->SetupBones(bone_matrix, MAXSTUDIOBONES, BONE_USED_BY_HITBOX, g::global_vars->curtime)) 
	{
		auto studio_model = g::mdl_info->GetStudiomodel(this->GetModel());

		if (!studio_model)
			return Vector{};

		auto hitbox = studio_model->GetHitboxSet(0)->GetHitbox(hitbox_id);

		if (!hitbox)
			return Vector{};

		Vector min = Vector{}, max = Vector{};

		math::VectorTransform(hitbox->bbmin, bone_matrix[hitbox->bone], min);
		math::VectorTransform(hitbox->bbmax, bone_matrix[hitbox->bone], max);

		return Vector(min.x + max.x, min.y + max.y, min.z + max.z) * 0.5f;
	}

	return Vector{};
}

player_info_t c_base_player::GetPlayerInfo()
{
	return g::engine_client->GetPlayerInfo(EntIndex());
}

bool c_base_player::IsAlive()
{
	return m_lifeState() == LIFE_ALIVE;
}

bool c_base_player::IsDead()
{
	return m_lifeState() == LIFE_DEAD;
}

bool c_base_player::IsDying()
{
	return m_lifeState() == LIFE_DYING;
}

bool c_base_player::IsFlashed()
{
	return m_flFlashMaxAlphaOffset() > 200.0;
}

bool c_base_player::HasC4()
{
	static bool has_c4 = false;

	for (int i = 0; i < MAX_WEAPONS; i++)
	{
		auto my_weapons = this->m_hMyWeapons()[i].Get();

		if (!my_weapons)
			continue;

		if (my_weapons->GetClientClass() && my_weapons->GetClientClass()->m_ClassID == classids::CC4)
		{
			has_c4 = true;

			return true;
		}

		if (has_c4)
			break;
	}

	return false;
}

bool c_base_player::InAir()
{
	return this->m_hGroundEntity().Get() == nullptr;
}

int& c_base_player::m_nMoveType()
{
	return *reinterpret_cast<int*>(reinterpret_cast<DWORD>(this) + 0x25C);
}

void c_base_attributable_item::SetModelIndex(int modelIndex)
{
	return CallVFunction<void(__thiscall*)(void*, int)>(this, 75)(this, modelIndex);
}

void c_base_view_model::SendViewModelMatchingSequence(int sequence)
{
	return CallVFunction<void(__thiscall*)(void*, int)>(this, 247)(this, sequence);
}

void c_base_view_model::SetModelIndex(int sequence)
{
	return CallVFunction<void(__thiscall*)(void*, int)>(this, 75)(this, sequence);
}

bool c_base_combat_weapon::check_detonate(const Vector& vecThrow, const trace_t& tr, int tick, float interval)
{
	switch (m_iItemDefinitionIndex())
	{
	case WEAPON_SMOKEGRENADE:
	case WEAPON_DECOY:
		if (vecThrow.Length2D() < 0.1f)
		{
			int det_tick_mod = (int)(0.2f / interval);
			return !(tick % det_tick_mod);
		}
		return false;
	case WEAPON_MOLOTOV:
	case WEAPON_INCGRENADE:
		if (tr.fraction != 1.0f && tr.plane.normal.z > 0.7f)
			return true;
	case WEAPON_FLASHBANG:
	case WEAPON_HEGRENADE:
		return (float)tick * interval > 1.5f && !(tick % (int)(0.2f / interval));
	default:
		return false;
	}
}

```

`src/valve_sdk/csgostructs.hpp`:

```hpp
#pragma once

#include "sdk.hpp"
#include "../helpers/utils.h"

#include <array>
#include <random>

#define MAX_PLAYERS 65
#define MAX_PATCHES 5
#define MAX_WEAPONS 64

class CAnimationLayer
{
public:
	char  pad_0000[20];
	uint32_t m_nOrder; //0x0014
	uint32_t m_nSequence; //0x0018
	float_t m_flPrevCycle; //0x001C
	float_t m_flWeight; //0x0020
	float_t m_flWeightDeltaRate; //0x0024
	float_t m_flPlaybackRate; //0x0028
	float_t m_flCycle; //0x002C
	void* m_pOwner; //0x0030
	char  pad_0038[4]; //0x0034
}; //Size: 0x0038

class CAnimState
{
public:
	void* vtable;
	bool m_bFirstRunSinceInit;
	bool m_bFirstFootPlantSinceInit;
	char pad[2];
	int m_nUnknownInt;
	float m_flEyePositionSmoothLerp;
	float m_flStrafeChangeWeightSmoothFalloff;
	void* m_StandWalkAim;
	void* m_StandRunAim;
	void* m_CrouchWalkAim;
	int m_nUnknownArray[3];
	int m_nModelIndex;
	void* m_pPlayer;
	void* m_pActiveWeapon;
	void* m_pLastActiveWeapon;
	float m_flLastClientSideAnimationUpdateTime;
	int m_nLastClientSideAnimationUpdateFramecount;
	float m_flLastClientSideAnimationUpdateTimeDelta;
	float m_flEyeYaw;
	float m_flEyePitch;
	float m_flMoveYaw;
	float m_flCurrentFeetYaw;
	float m_flMoveYawIdeal;
	float m_flMoveYawCurrentToIdeal;
	float m_flFeetVelDirDelta;
	float pad_0049;
	float m_flFeetCycle;
	float m_flFeetWeight;
	float m_flUnknown2;
	float m_flDuckAmount;
	float m_flHitGroundCycle;
	float m_flMoveWeight;
	Vector m_vecOrigin;
	Vector m_vecLastOrigin;
	Vector m_vecVelocity;
	Vector m_vecVelocityNormalized;
	Vector m_vecLastAcceleratingVelocity;
	float m_flSpeed;
	float m_flAbsVelocityZ;
	float m_flSpeedAsPortionOfRunTopSpeed;
	float m_flRunningSpeed;
	float m_flDuckingSpeed;
	float m_flTimeSinceStartedMoving;
	float m_flTimeSinceStoppedMoving;
	bool m_bOnGround;
	bool m_bLanding;
	char pad_010A[2];
	float m_flNextLowerBodyYawUpdateTime;
	float m_flDurationInAir;
	float m_flLeftGroundHeight;
	float m_flHitGroundWeight;
	float m_flGroundFraction;
	bool m_bLandedOnGroundThisFrame;
	bool m_bLeftTheGroundThisFrame;
	char pad_0120[2];
	float m_flInAirSmoothValue;
	bool m_bOnLadder;
	char pad_0128[3];
	float m_flLandAnimMultiplier;
	float m_flWalkToRunTransition;
	bool m_bNotRunning;
	char pad_0135[3];
	bool m_bInBalanceAdjust;
	char pad_0141[3];
	void* m_ActivityModifiers;
	float m_flLadderWeight;
	int m_flLadderSpeed;
	float m_flTimeOfLastInjury;
	float m_flLastSetupLeanCurtime;
	Vector m_vecLastSetupLeanVelocity;
	Vector m_vecSetupLeanVelocityDelta;
	Vector m_vecSetupLeanVelocityInterpolated;
	float m_flLeanWeight;
	Vector m_vecTargetAcceleration;
	char pad_qzdqzdzqd[3];
	float m_flStrafeWeight;
	Vector m_vecAcceleration;
	float m_flStrafeCycle;
	float m_flStrafeChangeWeight;
	bool m_bStrafing;
	char m_bStrafingPad[3];
	float m_flStrafeChangeCycle;
	int m_nStrafeSequence;
	bool m_bUnknownBool__;
	bool m_bIsAccelerating;
}; // Size: 0x344

class c_base_entity : public IClientEntity
{
public:
	NETVAR(int, m_nModelIndex, "CBaseEntity", "m_nModelIndex");
	NETVAR(int, m_iTeamNum, "CBaseEntity", "m_iTeamNum");
	NETVAR(Vector, m_vecOrigin, "CBaseEntity", "m_vecOrigin");
	NETVAR(Vector, m_vecAngles, "CBaseEntity", "m_vecAngles");
	NETVAR(bool, m_bShouldGlow, "CDynamicProp", "m_bShouldGlow");
	NETVAR(CHandle<c_base_player>, m_hOwnerEntity, "CBaseEntity", "m_hOwnerEntity");
	NETVAR(bool, m_bSpotted, "CBaseEntity", "m_bSpotted");
	NETPROP(m_bSpotted_hook, "CBaseEntity", "m_bSpotted"); //EDIT
	NETVAR(bool, m_bSpottedByMask, "CBaseEntity", "m_bSpottedByMask");
	NETVAR(float, m_flAnimTime, "CBaseEntity", "m_flAnimTime");
	NETVAR_OFFSET(matrix3x4_t&, m_CollisionGroup, "CBaseEntity", "m_CollisionGroup", -0x30);
	NETVAR_OFFSET(int, GetIndex, "CBaseEntity", "m_bIsAutoaimTarget", +0x4);
		
	NETVAR(Vector, m_vecMins, "CBaseEntity", "m_vecMins");
	NETVAR(Vector, m_vecMaxs, "CBaseEntity", "m_vecMaxs");

	bool IsPlayer();
	bool IsWeapon();
	bool IsPlantedC4();
	bool IsDefuseKit();
	Vector& GetAbsOrigin();
	void SetAbsOrigin(const Vector& origin);
	const matrix3x4_t& m_rgflCoordinateFrame();
	void UpdateVisibilityAllEntities();
	int GetSequenceActivity(studiohdr_t* hdr, const int& sequence);

	static __forceinline c_base_entity* GetEntityByIndex(int index)
	{
		return static_cast<c_base_entity*>(g::entity_list->GetClientEntity(index));
	}

	template <typename A>
	static __forceinline A* GetEntityFromHandle(CBaseHandle h)
	{
		return static_cast<A*>(g::entity_list->GetClientEntityFromHandle(h));
	}

	static __forceinline c_base_entity* GetEntityFromHandle(CBaseHandle h)
	{
		return GetEntityFromHandle<c_base_entity>(h);
	}
};

class c_base_planted_c4 : public c_base_entity
{
public:
	NETVAR(bool, m_bBombTicking, "CPlantedC4", "m_bBombTicking");
	NETVAR(bool, m_bBombDefused, "CPlantedC4", "m_bBombDefused");
	NETVAR(float, m_flC4Blow, "CPlantedC4", "m_flC4Blow");
	NETVAR(float, m_flTimerLength, "CPlantedC4", "m_flTimerLength");
	NETVAR(float, m_flDefuseLength, "CPlantedC4", "m_flDefuseLength");
	NETVAR(float, m_flDefuseCountDown, "CPlantedC4", "m_flDefuseCountDown");
	NETVAR(CHandle<c_base_player>, m_hBombDefuser, "CPlantedC4", "m_hBombDefuser");
	NETVAR(int, m_nBombSite, "CPlantedC4", "m_nBombSite");
};

class c_base_grenade : public c_base_entity
{
public:
	NETVAR(float, m_flDamage, "CBaseGrenade", "m_flDamage");
	NETVAR(int, m_DmgRadius, "CBaseGrenade", "m_DmgRadius");
	NETVAR(bool, m_bIsLive, "CBaseGrenade", "m_bIsLive");
	NETVAR(CHandle<c_base_player>, m_hThrower, "CBaseGrenade", "m_hThrower");
	NETVAR(Vector, m_vecVelocity, "CBaseGrenade", "m_vecVelocity");
	NETVAR(int, m_fFlags, "CBaseGrenade", "m_fFlags");

};

class c_base_attributable_item : public c_base_entity
{
private:
	using str_32 = char[32];
public:
	NETVAR(uint64_t, m_OriginalOwnerXuid, "CBaseAttributableItem", "m_OriginalOwnerXuidLow");
	NETVAR(int, m_OriginalOwnerXuidLow, "CBaseAttributableItem", "m_OriginalOwnerXuidLow");
	NETVAR(int, m_OriginalOwnerXuidHigh, "CBaseAttributableItem", "m_OriginalOwnerXuidHigh");
	NETVAR(int, m_nFallbackStatTrak, "CBaseAttributableItem", "m_nFallbackStatTrak");
	NETVAR(int, m_nFallbackPaintKit, "CBaseAttributableItem", "m_nFallbackPaintKit");
	NETVAR(int, m_nFallbackSeed, "CBaseAttributableItem", "m_nFallbackSeed");
	NETVAR(float_t, m_flFallbackWear, "CBaseAttributableItem", "m_flFallbackWear");

	NETVAR(int, m_bInitialized, "CBaseAttributableItem", "m_bInitialized");
	NETVAR(short, m_iItemDefinitionIndex, "CBaseAttributableItem", "m_iItemDefinitionIndex");
	NETVAR(int, m_iEntityLevel, "CBaseAttributableItem", "m_iEntityLevel");
	NETVAR(int, m_iAccountID, "CBaseAttributableItem", "m_iAccountID");
	NETVAR(int, m_iItemIDLow, "CBaseAttributableItem", "m_iItemIDLow");
	NETVAR(int, m_iItemIDHigh, "CBaseAttributableItem", "m_iItemIDHigh");
	NETVAR(int, m_iEntityQuality, "CBaseAttributableItem", "m_iEntityQuality");
	NETVAR(str_32, m_iCustomName, "CBaseAttributableItem", "m_szCustomName");

	void SetModelIndex(int modelIndex);
};

class c_base_weapon_world_model : public c_base_entity
{
public:
	NETVAR(int, m_nModelIndex, "CBaseWeaponWorldModel", "m_nModelIndex");
};

class c_base_combat_weapon : public c_base_attributable_item
{
public:
	NETVAR(float_t, m_flNextPrimaryAttack, "CBaseCombatWeapon", "m_flNextPrimaryAttack");
	NETVAR(float_t, m_flNextSecondaryAttack, "CBaseCombatWeapon", "m_flNextSecondaryAttack");
	NETVAR(int, m_iClip1, "CBaseCombatWeapon", "m_iClip1");
	NETVAR(int, m_iPrimaryReserveAmmoCount, "CBaseCombatWeapon", "m_iPrimaryReserveAmmoCount");
	NETVAR(int, m_iClip2, "CBaseCombatWeapon", "m_iClip2");
	NETVAR(float_t, m_flRecoilIndex, "CWeaponCSBase", "m_flRecoilIndex");
	NETVAR(int, m_iViewModelIndex, "CBaseCombatWeapon", "m_iViewModelIndex");
	NETVAR(int, m_iWorldModelIndex, "CBaseCombatWeapon", "m_iWorldModelIndex");
	NETVAR(int, m_iWorldDroppedModelIndex, "CBaseCombatWeapon", "m_iWorldDroppedModelIndex");
	NETVAR(bool, m_bPinPulled, "CBaseCSGrenade", "m_bPinPulled");
	NETVAR(float_t, m_fThrowTime, "CBaseCSGrenade", "m_fThrowTime");
	NETVAR(float_t, m_flThrowStrength, "CBaseCSGrenade", "m_flThrowStrength");
	NETVAR(int, m_nExplodeEffectTickBegin, "CBaseCSGrenadeProjectile", "m_nExplodeEffectTickBegin");
	NETVAR(float_t, m_flPostponeFireReadyTime, "CBaseCombatWeapon", "m_flPostponeFireReadyTime");
	NETVAR(CHandle<c_base_weapon_world_model>, m_hWeaponWorldModel, "CBaseCombatWeapon", "m_hWeaponWorldModel");
	NETVAR(int, m_zoomLevel, "CWeaponCSBaseGun", "m_zoomLevel");

	CCSWeaponInfo* GetWeaponData();
	bool HasBullets();
	char* GetGunIcon();
	float GetGunStringSize();
	bool CanFire();
	bool IsGrenade();
	bool IsZeus();
	bool IsKnife();
	bool IsReloading();
	bool IsPistol();
	bool IsSniper();
	bool IsShotgun();
	bool IsSmoke();
	bool IsFlash();
	bool IsKnifeOrGrenade();
	bool RequiresRecoilControl();

	float GetInaccuracy();
	float GetSpread();
	void  UpdateAccuracyPenalty();
	bool check_detonate(const Vector& vecThrow, const trace_t& tr, int tick, float interval);
};

class c_base_player : public c_base_entity
{
public:

	NETVAR(bool, m_bHasDefuser, "CCSPlayer", "m_bHasDefuser");
	NETVAR(bool, m_bGunGameImmunity, "CCSPlayer", "m_bGunGameImmunity");
	NETVAR(int, m_iShotsFired, "CCSPlayer", "m_iShotsFired");
	NETVAR(QAngle, m_angEyeAngles, "CCSPlayer", "m_angEyeAngles[0]");
	NETVAR(int, m_ArmorValue, "CCSPlayer", "m_ArmorValue");
	NETVAR(bool, m_bHasHeavyArmor, "CCSPlayer", "m_bHasHeavyArmor");
	NETVAR(bool, m_bHasHelmet, "CCSPlayer", "m_bHasHelmet");
	NETVAR(bool, m_bIsScoped, "CCSPlayer", "m_bIsScoped");
	NETVAR(bool, m_bIsDefusing, "CCSPlayer", "m_bIsDefusing");
	NETVAR(float, m_flLowerBodyYawTarget, "CCSPlayer", "m_flLowerBodyYawTarget");
	NETVAR(int, m_iHealth, "CBasePlayer", "m_iHealth");
	NETVAR(int, m_lifeState, "CBasePlayer", "m_lifeState");
	NETVAR(int, m_fFlags, "CBasePlayer", "m_fFlags");
	NETVAR(int, m_nTickBase, "CBasePlayer", "m_nTickBase");
	NETVAR(Vector, m_vecViewOffset, "CBasePlayer", "m_vecViewOffset[0]");
	NETVAR(QAngle, m_viewPunchAngle, "CBasePlayer", "m_viewPunchAngle");
	NETVAR(QAngle, m_aimPunchAngle, "CBasePlayer", "m_aimPunchAngle");
	NETVAR(CHandle<c_base_view_model>, m_hViewModel, "CBasePlayer", "m_hViewModel[0]");
	NETVAR(Vector, m_vecVelocity, "CBasePlayer", "m_vecVelocity[0]");
	NETVAR(float, m_flMaxspeed, "CBasePlayer", "m_flMaxspeed");
	NETVAR(int, m_iObserverMode, "CBasePlayer", "m_iObserverMode");
	NETVAR(CHandle<c_base_player>, m_hObserverTarget, "CBasePlayer", "m_hObserverTarget");
	NETVAR(float, m_flFlashMaxAlpha, "CCSPlayer", "m_flFlashMaxAlpha");
	NETVAR_OFFSET(float, m_flFlashMaxAlphaOffset, "CCSPlayer", "m_flFlashMaxAlpha", -0x8);
	NETVAR(int, m_nHitboxSet, "CBaseAnimating", "m_nHitboxSet");
	NETVAR(int, m_nForceBone, "CBaseAnimating", "m_nForceBone");
	NETVAR(bool, m_bClientSideAnimation, "CBaseAnimating", "m_bClientSideAnimation");
	NETVAR(CHandle<c_base_combat_weapon>, m_hActiveWeapon, "CBaseCombatCharacter", "m_hActiveWeapon");
	NETVAR(int, m_iAccount, "CCSPlayer", "m_iAccount");
	NETVAR(float, m_flFlashDuration, "CCSPlayer", "m_flFlashDuration");
	NETVAR(float, m_flSimulationTime, "CBaseEntity", "m_flSimulationTime");
	NETVAR(float, m_flCycle, "CServerAnimationData", "m_flCycle");
	NETVAR(int, m_nSequence, "CBaseViewModel", "m_nSequence");
	PNETVAR(char, m_szLastPlaceName, "CBasePlayer", "m_szLastPlaceName");
	NETVAR(QAngle, m_angAbsAngles, "CBaseEntity", "m_angAbsAngles");
	NETVAR(Vector, m_angAbsOrigin, "CBaseEntity", "m_angAbsOrigin");
	NETVAR(float, m_flDuckSpeed, "CBaseEntity", "m_flDuckSpeed");
	NETVAR(float, m_flDuckAmount, "CBaseEntity", "m_flDuckAmount");
	NETVAR(int, m_nSurvivalTeam, "CCSPlayer", "m_nSurvivalTeam");
	NETVAR(int, m_iFOV, "CBasePlayer", "m_iFOV");
	NETVAR(int, m_iDefaultFOV, "CBasePlayer", "m_iDefaultFOV");
	PNETVAR(CHandle<c_base_combat_weapon>, m_hMyWeapons, "CBaseCombatCharacter", "m_hMyWeapons");
	PNETVAR(CBaseHandle, m_hMyWearables, "CBaseCombatCharacter", "m_hMyWearables");
	NETVAR_OFFSET(QAngle*, GetVAngles, "CBasePlayer", "deadflag", +0x4);
	NETVAR(CBaseHandle, m_hGroundEntity, "CBasePlayer", "m_hGroundEntity");
	NETVAR(int[MAX_PATCHES], m_vecPlayerPatchEconIndices, "CCSPlayer", "m_vecPlayerPatchEconIndices");
	NETVAR(float, m_flNextAttack, "CBaseCombatCharacter", "m_flNextAttack");

	std::vector<int> hitboxes();

	Vector        GetEyePos();
	Vector		  get_hitbox_position(int hitbox_id);
	Vector        get_bone_position(int bone);
	player_info_t GetPlayerInfo();
	bool          IsAlive();
	bool		  IsDead();
	bool		  IsDying();
	bool		  IsFlashed();
	bool          IsEnemy();
	bool          HasC4();
	bool		  InAir();
	int& m_nMoveType();
	QAngle& GetAbsAngles();
	void SetAbsAngles(const QAngle& wantedang);
	void UpdateClientSideAnimation();
	void InvalidateBoneCache();
	
	CAnimationLayer* GetAnimOverlay(int i);
	CAnimationLayer* GetAnimOverlays();

	CAnimState* GetPlayerAnimState();

	void ResetAnimationState(CAnimState* state);

	static __forceinline c_base_player* GetPlayerByUserId(int id)
	{
		return static_cast<c_base_player*>(GetEntityByIndex(g::engine_client->GetPlayerForUserID(id)));
	}

	static __forceinline c_base_player* GetPlayerByIndex(int i)
	{
		return static_cast<c_base_player*>(GetEntityByIndex(i));
	}
};

class c_base_view_model : public c_base_entity
{
public:
	NETVAR(int, m_nModelIndex, "CBaseViewModel", "m_nModelIndex");
	NETVAR(int, m_nViewModelIndex, "CBaseViewModel", "m_nViewModelIndex");
	NETVAR(CHandle<c_base_combat_weapon>, m_hWeapon, "CBaseViewModel", "m_hWeapon");
	NETVAR(CHandle<c_base_player>, m_hOwner, "CBaseViewModel", "m_hOwner");
	NETPROP(m_nSequence, "CBaseViewModel", "m_nSequence");

	void SetModelIndex(int sequence);
	void SendViewModelMatchingSequence(int sequence);
};

class c_player_resource
{
public:
	NETVAR(int[MAX_PLAYERS], GetPing, "CPlayerResource", "m_iPing");
};

class CSPlayerResource : public c_player_resource
{
public:
	NETVAR(int[MAX_PLAYERS], GetRank, "CCSPlayerResource", "m_iCompetitiveRanking");
	NETVAR(int[MAX_PLAYERS], GetWins, "CCSPlayerResource", "m_iCompetitiveWins");
	NETVAR(int[MAX_PLAYERS], GetLevel, "CCSPlayerResource", "m_nPersonaDataPublicLevel");
	NETVAR(int[MAX_PLAYERS], GetTeamColor, "CCSPlayerResource", "m_iCompTeammateColor");
	NETVAR(char[MAX_PLAYERS][16], GetClanTag, "CCSPlayerResource", "m_szClan");
	NETVAR(unsigned[MAX_PLAYERS], GetCoin, "CCSPlayerResource", "m_nActiveCoinRank");
	NETVAR(unsigned[MAX_PLAYERS], GetMusicKit, "CCSPlayerResource", "m_nMusicID");
	NETVAR(Vector, m_bombsiteCenterA, "CCSPlayerResource", "m_bombsiteCenterA");
	NETVAR(Vector, m_bombsiteCenterB, "CCSPlayerResource", "m_bombsiteCenterB");
};

class CSGameRulesProxy
{
public:
	NETVAR(bool, m_bBombPlanted, "CCSGameRulesProxy", "m_bBombPlanted");
	NETVAR(uint32_t, m_iRoundTime, "CCSGameRulesProxy", "m_iRoundTime");
	PNETVAR(bool, m_bIsValveDS, "CCSGameRulesProxy", "m_bIsValveDS");
};
```

`src/valve_sdk/interfaces/CClientState.h`:

```h
#pragma once

#include <cstdint>

// Created with ReClass.NET by KN4CK3R
#pragma pack(push, 1)
class INetChannel
{
public:
	char pad_0000[20];           //0x0000
	bool m_bProcessingMessages;  //0x0014
	bool m_bShouldDelete;        //0x0015
	char pad_0016[2];            //0x0016
	int32_t m_nOutSequenceNr;    //0x0018 last send outgoing sequence number
	int32_t m_nInSequenceNr;     //0x001C last received incoming sequnec number
	int32_t m_nOutSequenceNrAck; //0x0020 last received acknowledge outgoing sequnce number
	int32_t m_nOutReliableState; //0x0024 state of outgoing reliable data (0/1) flip flop used for loss detection
	int32_t m_nInReliableState;  //0x0028 state of incoming reliable data
	int32_t m_nChokedPackets;    //0x002C number of choked packets
	char pad_0030[1044];         //0x0030
}; //Size: 0x0444

class CClockDriftMgr {
 
public:
	float m_ClockOffsets[0x10];
	uint32_t m_iCurClockOffset;
	uint32_t m_nServerTick;
	uint32_t m_nClientTick;
};
	

class CClientState {
public:
	/*void ForceFullUpdate() {
		*reinterpret_cast<int*>(std::uintptr_t(this) + 0x174) = -1;
	}*/

	char pad000[0x9C];
	INetChannel* m_NetChannel;
	int	m_nChallengeNr;
	char pad001[0x4];
	double m_connect_time;
	int m_retry_number;
	char pad002[0x54];
	int m_nSignonState;
	char pad003[0x4];
	double m_flNextCmdTime;
	int m_nServerCount;
	int m_nCurrentSequence;
	char pad004[0x8];
	CClockDriftMgr m_ClockDriftMgr;
	int m_nDeltaTick;
	char pad005[0x4];
	int m_nViewEntity;
	int m_nPlayerSlot;
	bool m_bPaused;
	char pad006[0x3];
	char m_szLevelName[0x104];
	char m_szLevelNameShort[0x28];
	char pad007[0xD4];
	int m_nMaxClients;
	char pad008[0x4994];
	int oldtickcount;
	float m_tickRemainder;
	float m_frameTime;
	int lastoutgoingcommand;
	int chokedcommands;
	int last_command_ack;
	int m_last_server_tick;
	int command_ack;
	int m_nSoundSequence;
	int m_last_progress_percent;
	bool m_is_hltv;
	char pad009[0x4B];
	QAngle viewangles;
	char pad010[0xCC];
	void* m_events;

	void ForceFullUpdate() {
		m_nDeltaTick = -1;
	}
};

#pragma pack(pop)

static_assert(FIELD_OFFSET(CClientState, m_NetChannel) == 0x009C, "Wrong struct offset");
static_assert(FIELD_OFFSET(CClientState, m_nCurrentSequence) == 0x011C, "Wrong struct offset");
static_assert(FIELD_OFFSET(CClientState, m_nDeltaTick) == 0x0174, "Wrong struct offset");

```

`src/valve_sdk/interfaces/CFireBullets.h`:

```h
#pragma once

#include "../../valve_sdk/math/Vectors.hpp"
#include "../../valve_sdk/math/QAngle.hpp"

class CFireBullets
{
public:
	char pad_0000[8]; //0x0000
	int m_iPlayer1; //0x000C
	int m_iPlayer; //0x000C
	int m_iItemDefinitionIndex; //0x0010
	Vector m_vecOrigin; //0x0014
	QAngle m_absAngles; //0x0020
};

```

`src/valve_sdk/interfaces/CGlobalVarsBase.h`:

```h
#pragma once

class CGlobalVarsBase
{
public:
	float     realtime;                     // 0x0000
	int       framecount;                   // 0x0004
	float     absoluteframetime;            // 0x0008
	float     absoluteframestarttimestddev; // 0x000C
	float     curtime;                      // 0x0010
	float     frametime;                    // 0x0014
	int       maxClients;                   // 0x0018
	int       tickcount;                    // 0x001C
	float     interval_per_tick;            // 0x0020
	float     interpolation_amount;         // 0x0024
	int       simTicksThisFrame;            // 0x0028
	int       network_protocol;             // 0x002C
	void* pSaveData;                    // 0x0030
	bool      m_bClient;                    // 0x0031
	bool      m_bRemoteClient;              // 0x0032
private:
	int       nTimestampNetworkingBase;
	int       nTimestampRandomizeWindow;
};

```

`src/valve_sdk/interfaces/CGlowObjectManager.h`:

```h
#pragma once
#include <vector>
#include "../valve_sdk/math/Vectors.hpp"

class CGlowObjectDefinition 
{
public:
	void set(Color& color, bool render_when_occluded, bool render_when_unoccluded, int style = 0)
	{
		this->m_vecClr = Vector(color.r() / 255.f, color.g() / 255.f, color.b() / 255.f);
		this->m_flAlpha = (float)color.a() / 255.f;

		this->m_bRenderWhenOccluded = render_when_occluded;
		this->m_bRenderWhenUnoccluded = render_when_unoccluded;
		this->m_nGlowStyle = style;
	}

	void color(Color& color)
	{
		this->m_vecClr = Vector(color.r() / 255.f, color.g() / 255.f, color.b() / 255.f);
		this->m_flAlpha = (float)color.a() / 255.f;
	}

	void glow_style(int style)
	{
		this->m_nGlowStyle = style;
	}

	void full_bloom_render(bool value)
	{
		this->m_bFullBloomRender = value;
	}

	void render_when_occluded(bool value)
	{
		this->m_bRenderWhenOccluded = value;
	}

	void render_when_unoccluded(bool value)
	{
		this->m_bRenderWhenUnoccluded = value;
	}

	bool unused()
	{
		return m_nNextFreeSlot != -2;
	}
	
	int   m_nNextFreeSlot;
	void* m_pEntity;
	Vector m_vecClr;
	float m_flAlpha;
	bool  m_bGlowAlphaCappedByRenderAlpha;
	float m_flGlowAlphaFunctionOfMaxVelocity;
	float m_flGlowAlphaMax;
	float m_flGlowPulseOverdrive;
	bool  m_bRenderWhenOccluded;
	bool  m_bRenderWhenUnoccluded;
	bool  m_bFullBloomRender;
	int   m_nFullBloomStencilTestValue;
	int   m_nGlowStyle;
	int   m_nSplitScreenSlot;
};

class CGlowManager 
{
public:
	CGlowObjectDefinition* objects;
	char pad[8];
	int size;
};

```

`src/valve_sdk/interfaces/CHud.h`:

```h
#pragma once

class CHud
{
public:
	template <typename T>
	T* FindHudElement(const char* name)
	{
		static auto fn = reinterpret_cast<DWORD(__thiscall*)(void*, const char*)>(patterns::find_hud_addr);

		return (T*)fn(this, name);
	}
};

```

`src/valve_sdk/interfaces/CHudChat.h`:

```h
#pragma once
#include <Windows.h>
#include <iostream>

#include "../../valve_sdk/misc/vfunc.hpp"

class CHudChat
{
public:
	enum ChatFilters
	{
		CHAT_FILTER_NONE = 0,
		CHAT_FILTER_JOINLEAVE = 0x000001,
		CHAT_FILTER_NAMECHANGE = 0x000002,
		CHAT_FILTER_PUBLICCHAT = 0x000004,
		CHAT_FILTER_SERVERMSG = 0x000008,
		CHAT_FILTER_TEAMCHANGE = 0x000010,
		CHAT_FILTER_ACHIEVEMENT = 0x000020,
	};

	void ChatPrintf(int iPlayerIndex, int iFilter, const char* fmt, ...)
	{
		char msg[1024];

		va_list args;
		va_start(args, fmt);
		vsprintf(msg, fmt, args);
		CallVFunction<void(__cdecl*)(void*, int, int, const char*, ...)>(this, 27)(this, iPlayerIndex, iFilter, fmt);
		va_end(args);
	}
};

```

`src/valve_sdk/interfaces/CInput.hpp`:

```hpp
#pragma once

#include "../Misc/CUserCmd.hpp"

constexpr const int MULTIPLAYER_BACKUP = 150;

class CInput
{
public:
    char    pad_0000[0xC];
    bool    m_fTrackIRAvailable;               
    bool    m_fMouseInitialized;               
    bool    m_fMouseActive;                              
    byte    pad_0x08[0x9A];                   
    bool    m_fCameraInThirdPerson;
	byte    pad_00C3[0x2];         
    QAngle  m_vecCameraOffset;                 
    byte    pad_00D1[0x38];
    CUserCmd* m_pCommands;                
    CVerifiedUserCmd* pVerifiedCommands;

    CUserCmd* GetUserCmd(const int nSequenceNumber) const
    {
        return &m_pCommands[nSequenceNumber % MULTIPLAYER_BACKUP];
    }

    CVerifiedUserCmd* GetVerifiedCmd(const int nSequenceNumber) const
    {
        return &pVerifiedCommands[nSequenceNumber % MULTIPLAYER_BACKUP];
    }

    CUserCmd* GetUserCmd(int slot, int sequence_number)
    {
        return &m_pCommands[slot, sequence_number % MULTIPLAYER_BACKUP];
    }
};

```

`src/valve_sdk/interfaces/IAppSystem.h`:

```h
#pragma once

typedef void* (*CreateInterfaceFn)(const char* pName, int* pReturnCode);
typedef void* (*InstantiateInterfaceFn)();

class IAppSystem
{
	virtual bool                            Connect(CreateInterfaceFn factory) = 0;                                     // 0
	virtual void                            Disconnect() = 0;                                                           // 1
	virtual void* QueryInterface(const char* pInterfaceName) = 0;                             // 2
	virtual int /*InitReturnVal_t*/         Init() = 0;                                                                 // 3
	virtual void                            Shutdown() = 0;                                                             // 4
	virtual const void* /*AppSystemInfo_t*/ GetDependencies() = 0;                                                      // 5
	virtual int /*AppSystemTier_t*/         GetTier() = 0;                                                              // 6
	virtual void                            Reconnect(CreateInterfaceFn factory, const char* pInterfaceName) = 0;       // 7
	virtual void                            UnkFunc() = 0;                                                              // 8
};
```

`src/valve_sdk/interfaces/IBaseClientDLL.h`:

```h
#pragma once

class IBaseClientDLL
{
public:
	ClientClass* GetAllClasses()
	{
		return CallVFunction<ClientClass * (__thiscall*)(void*)>(this, 8)(this);
	}
};

```

`src/valve_sdk/interfaces/IClientEntity.hpp`:

```hpp
#pragma once

#include "IClientNetworkable.hpp"
#include "IClientRenderable.hpp"
#include "IClientUnknown.hpp"
#include "IClientThinkable.hpp"

class CCSWeaponInfo
{
public:
	void* vtable;		//0x0000
	char* szConsoleName; //0x0004
	char pad_0008[8]; //0x0008
	void* pBaseItemDefinition; //0x0010
	int32_t iMaxClip1; //0x0014
	int32_t iMaxClip2; //0x0018
	int32_t iDefaultClip1; //0x001C
	int32_t iDefaultClip2; //0x0020
	int32_t iMaxReservedAmmo; //0x0024
	char pad_0028[4]; //0x0028
	char* szWorldModel; //0x002C
	char* szViewModel; //0x0030
	char* szDroppedModel; //0x0034
	char* szEmptySound; //0x0038
	char* szShotSound; //0x003C
	char pad_0040[20]; //0x0040
	char* szReloadSound; //0x0054
	char pad_0058[16]; //0x0058
	char* szShotSoundSpecial; //0x0068
	char pad_006C[12]; //0x006C
	char* szNearlyEmptySound; //0x0078
	char pad_007C[4]; //0x007C
	char* szBulletType; //0x0080
	char pad_0084[4]; //0x0084
	char* szHudName; //0x0088
	char* szWeaponName; //0x008C
	char pad_0090[12]; //0x0090
	int32_t iWeaponWeight; //0x009C
	int32_t iRumbleEffect; //0x00A0
	char pad_00A4[32]; //0x00A4
	void* pItemDefinition; //0x00C4
	int32_t WeaponType; //0x00C8
	int32_t WeaponGroup; //0x00CC
	int32_t iWeaponPrice; //0x00D0
	int32_t iKillAward; //0x00D4
	char* szPlayerAnimationExtension; //0x00D8
	float flCycleTime; //0x00DC
	float flCycleTimeAlt; //0x00E0
	float flTimeToIdle; //0x00E4
	float flIdleInterval; //0x00E8
	bool bFullAuto; //0x00EC
	char pad_00ED[3]; //0x00ED
	int32_t iDamage; //0x00F0
	float fHeadshotMultiplier; //0x00F4
	float flArmorRatio; //0x00F8
	int32_t iBullets; //0x00FC
	float flPenetration; //0x0100
	float flFlinchVelocityModifierLarge; //0x0104
	float flFlinchVelocityModifierSmall; //0x0108
	float flRange; //0x010C
	float flRangeModifier; //0x0110
	float flThrowVelocity; //0x0114
	char pad_0118[12]; //0x0118
	bool bHasSilencer; //0x0124
	char pad_0125[3]; //0x0125
	char* szSilencerModel; //0x0128
	int32_t iCrosshairMinDistance; //0x012C
	int32_t iCrosshairDeltaDistance; //0x0130
	float flMaxPlayerSpeed; //0x0134
	float flMaxPlayerSpeedAlt; //0x0138
	int32_t flAttackMoveSpeedFactor; //0x013C
	float flSpread; //0x0140
	float flSpreadAlt; //0x0144
	float flInaccuracyCrouch; //0x0148
	float flInaccuracyCrouchAlt; //0x014C
	float flInaccuracyStand; //0x0150
	float flInaccuracyStandAlt; //0x0154
	float flInaccuracyJumpInitial; //0x0158
	char pad_015C[4]; //0x015C
	float flInaccuracyJump; //0x0160
	float flInaccuracyJumpAlt; //0x0164
	float flInaccuracyLand; //0x0168
	float flInaccuracyLandAlt; //0x016C
	float flInaccuracyLadder; //0x0170
	float flInaccuracyLadderAlt; //0x0174
	float flInaccuracyFire; //0x0178
	float flInaccuracyFireAlt; //0x017C
	float flInaccuracyMove; //0x0180
	float flInaccuracyMoveAlt; //0x0184
	float flInaccuracyReload; //0x0188
	int32_t iRecoilSeed; //0x018C
	float flRecoilAngle; //0x0190
	float flRecoilAngleAlt; //0x0194
	float flRecoilAngleVariance; //0x0198
	float flRecoilAngleVarianceAlt; //0x019C
	float flRecoilMagnitude; //0x01A0
	float flRecoilMagnitudeAlt; //0x01A4
	float flRecoilMagnitudeVariance; //0x01A8
	float flRecoilMagnitudeVarianceAlt; //0x01AC
	int32_t iSpreadSeed; //0x01B0
	float flRecoveryTimeCrouch; //0x01B4
	float flRecoveryTimeStand; //0x01B8
	float flRecoveryTimeCrouchFinal; //0x01BC
	float flRecoveryTimeStandFinal; //0x01C0
	int32_t iRecoveryTransitionStartBullet; //0x01C4
	int32_t iRecoveryTransitionEndBullet; //0x01C8
	bool bUnzoomAfterShot; //0x01CC
	bool bHideViewModelZoomed; //0x01CD
	char pad_01CE[2]; //0x01CE
	int32_t iZoomLevels; //0x01D0
	int32_t iZoomFOVs[2]; //0x01D4
	float flZoomTimes[3]; //0x01DC
	char* szAddonLocation; //0x01E8
	char pad_01EC[4]; //0x01EC
	float flAddonScale; //0x01F0
	char* szEjectBrassEffect; //0x01F4
	char* szTracerEffect; //0x01F8
	int32_t iTracerFrequency; //0x01FC
	int32_t iTracerFrequencyAlt; //0x0200
	char* szFlashEffectFirstPerson; //0x0204
	char pad_0208[4]; //0x0208
	char* szFlashEffectThirdPerson; //0x020C
	char pad_0210[4]; //0x0210
	char* szHeatEffect; //0x0214
	float flHeatPerShot; //0x0218
	char* szZoomInSound; //0x021C
	char* szZoomOutSound; //0x0220
	float flInaccuracyPitchShift; //0x0224
	float flInaccuracySoundThreshold; //0x0228
	float flBotAudibleRange; //0x022C
	void* pPaintData; //0x0230
	char pad_0234[4]; //0x0234
	char* szWrongTeamMsg; //0x0238
	bool bHasBurstMode; //0x023C
	bool bIsRevolver; //0x023D
	bool bUnknown01; //0x023E
	bool bUnknown02; //0x023F
}; //Size: 0x1040

```

`src/valve_sdk/interfaces/IClientEntityList.hpp`:

```hpp
#pragma once

#include "../misc/IHandleEntity.hpp"

class IClientNetworkable;
class IClientEntity;

class IClientEntityList
{
public:
	virtual IClientNetworkable* GetClientNetworkable(int entnum) = 0;
	virtual void* vtablepad0x1(void) = 0;
	virtual void* vtablepad0x2(void) = 0;
	virtual IClientEntity* GetClientEntity(int entNum) = 0;
	virtual IClientEntity* GetClientEntityFromHandle(CBaseHandle hEnt) = 0;
	virtual int                   NumberOfEntities(bool bIncludeNonNetworkable) = 0;
	virtual int                   GetHighestEntityIndex(void) = 0;
	virtual void                  SetMaxEntities(int maxEnts) = 0;
	virtual int                   GetMaxEntities() = 0;
};
```

`src/valve_sdk/interfaces/IClientMode.hpp`:

```hpp
#pragma once

#include "../math/VMatrix.hpp"

class CViewSetup {
public:
	int			x, x_old;
	int			y, y_old;
	int			width, width_old;
	int			height, height_old;
	bool		m_bOrtho;
	float		m_OrthoLeft;
	float		m_OrthoTop;
	float		m_OrthoRight;
	float		m_OrthoBottom;
	bool		m_bCustomViewMatrix;
	matrix3x4_t	m_matCustomViewMatrix;
	char		pad_0x68[0x48];
	float		fov;
	float		viewmodel_fov;
	Vector		origin;
	QAngle		angles;
	float		zNear;
	float		zFar;
	float		zNearViewmodel;
	float		zFarViewmodel;
	float		m_flAspectRatio;
	float		m_flNearBlurDepth;
	float		m_flNearFocusDepth;
	float		m_flFarFocusDepth;
	float		m_flFarBlurDepth;
	float		m_flNearBlurRadius;
	float		m_flFarBlurRadius;
	int			m_nDoFQuality;
	int			m_nMotionBlurMode;
	float		m_flShutterTime;
	Vector		m_vShutterOpenPosition;
	Vector		m_shutterOpenAngles;
	Vector		m_vShutterClosePosition;
	Vector		m_shutterCloseAngles;
	float		m_flOffCenterTop;
	float		m_flOffCenterBottom;
	float		m_flOffCenterLeft;
	float		m_flOffCenterRight;
	int			m_iEdgeBlur;
};

class IClientMode
{
};
```

`src/valve_sdk/interfaces/IClientNetworkable.hpp`:

```hpp
#pragma once

class IClientUnknown;
class ClientClass;
class bf_read;

class IClientNetworkable
{
public:
	virtual IClientUnknown*			GetIClientUnknown() = 0;
	virtual void					Release() = 0;
	virtual ClientClass*			GetClientClass() = 0; //2
	virtual void					NotifyShouldTransmit(int state) = 0;
	virtual void					OnPreDataChanged(int updateType) = 0;
	virtual void					OnDataChanged(int updateType) = 0;
	virtual void					PreDataUpdate(int updateType) = 0;
	virtual void					PostDataUpdate(int updateType) = 0;
	virtual void					__unkn() = 0;
	virtual bool					IsDormant() = 0; //9
 	virtual int						EntIndex() const = 0; //10
	virtual void					ReceiveMessage(int classID, bf_read& msg) = 0;
	virtual void*					GetDataTableBasePtr() = 0;
	virtual void					SetDestroyedOnRecreateEntities() = 0; //13
};
```

`src/valve_sdk/interfaces/IClientRenderable.hpp`:

```hpp
#pragma once

#include "../math/Vectors.hpp"
#include "../math/QAngle.hpp"

typedef unsigned short ClientShadowHandle_t;
typedef unsigned short ClientRenderHandle_t;
typedef unsigned short ModelInstanceHandle_t;
typedef unsigned char uint8_t;

class matrix3x4_t;
class IClientUnknown;
struct model_t;

class IClientRenderable
{
public:
	virtual IClientUnknown* GetIClientUnknown() = 0;
	virtual Vector const& GetRenderOrigin(void) = 0;
	virtual QAngle const& GetRenderAngles(void) = 0;
	virtual bool                       ShouldDraw(void) = 0;
	virtual int                        GetRenderFlags(void) = 0; // ERENDERFLAGS_xxx
	virtual void                       Unused(void) const {}
	virtual ClientShadowHandle_t       GetShadowHandle() const = 0;
	virtual ClientRenderHandle_t& RenderHandle() = 0;
	virtual const model_t* GetModel() const = 0;
	virtual int                        DrawModel(int flags, const int /*RenderableInstance_t*/& instance) = 0;
	virtual int                        GetBody() = 0;
	virtual void                       GetColorModulation(float* color) = 0;
	virtual bool                       LODTest() = 0;
	virtual bool					   SetupBones(matrix3x4_t* pBoneToWorldOut, int nMaxBones, int boneMask, float currentTime) = 0;
	virtual void                       SetupWeights(const matrix3x4_t* pBoneToWorld, int nFlexWeightCount, float* pFlexWeights, float* pFlexDelayedWeights) = 0;
	virtual void                       DoAnimationEvents(void) = 0;
	virtual void* /*IPVSNotify*/       GetPVSNotifyInterface() = 0;
	virtual void                       GetRenderBounds(Vector& mins, Vector& maxs) = 0;
	virtual void                       GetRenderBoundsWorldspace(Vector& mins, Vector& maxs) = 0;
	virtual void                       GetShadowRenderBounds(Vector& mins, Vector& maxs, int /*ShadowType_t*/ shadowType) = 0;
	virtual bool                       ShouldReceiveProjectedTextures(int flags) = 0;
	virtual bool                       GetShadowCastDistance(float* pDist, int /*ShadowType_t*/ shadowType) const = 0;
	virtual bool                       GetShadowCastDirection(Vector* pDirection, int /*ShadowType_t*/ shadowType) const = 0;
	virtual bool                       IsShadowDirty() = 0;
	virtual void                       MarkShadowDirty(bool bDirty) = 0;
	virtual IClientRenderable* GetShadowParent() = 0;
	virtual IClientRenderable* FirstShadowChild() = 0;
	virtual IClientRenderable* NextShadowPeer() = 0;
	virtual int /*ShadowType_t*/       ShadowCastType() = 0;
	virtual void                       CreateModelInstance() = 0;
	virtual ModelInstanceHandle_t      GetModelInstance() = 0;
	virtual const matrix3x4_t& RenderableToWorldTransform() = 0;
	virtual int                        LookupAttachment(const char* pAttachmentName) = 0;
	virtual   bool                     GetAttachment(int number, Vector& origin, QAngle& angles) = 0;
	virtual bool                       GetAttachment(int number, matrix3x4_t& matrix) = 0;
	virtual float* GetRenderClipPlane(void) = 0;
	virtual int                        GetSkin() = 0;
	virtual void                       OnThreadedDrawSetup() = 0;
	virtual bool                       UsesFlexDelayedWeights() = 0;
	virtual void                       RecordToolMessage() = 0;
	virtual bool                       ShouldDrawForSplitScreenUser(int nSlot) = 0;
	virtual uint8_t                    OverrideAlphaModulation(uint8_t nAlpha) = 0;
	virtual uint8_t                    OverrideShadowAlphaModulation(uint8_t nAlpha) = 0;
};
```

`src/valve_sdk/interfaces/IClientThinkable.hpp`:

```hpp
#pragma once

class IClientUnknown;
class CClientThinkHandlePtr;
typedef CClientThinkHandlePtr* ClientThinkHandle_t;

class IClientThinkable
{
public:
	virtual IClientUnknown* GetIClientUnknown() = 0;
	virtual void                ClientThink() = 0;
	virtual ClientThinkHandle_t GetThinkHandle() = 0;
	virtual void                SetThinkHandle(ClientThinkHandle_t hThink) = 0;
	virtual void                Release() = 0;
};
```

`src/valve_sdk/interfaces/IClientUnknown.hpp`:

```hpp
#pragma once

#include "../misc/IHandleEntity.hpp"

//class ICollideable;
class IClientNetworkable;
class IClientRenderable;
class IClientEntity;
class c_base_entity;
class IClientThinkable;
class IClientAlphaProperty;

enum SolidType_t;

class ICollideable
{
public:
	virtual IHandleEntity* GetEntityHandle() = 0;
	virtual const Vector& OBBMins() const = 0;
	virtual const Vector& OBBMaxs() const = 0;
};

class IClientUnknown : public IHandleEntity
{
public:
	virtual ICollideable* GetCollideable() = 0;
	virtual IClientNetworkable* GetClientNetworkable() = 0;
	virtual IClientRenderable* GetClientRenderable() = 0;
	virtual IClientEntity* GetIClientEntity() = 0;
	virtual c_base_entity* GetBaseEntity() = 0;
	virtual IClientThinkable* GetClientThinkable() = 0;
	//virtual IClientModelRenderable*  GetClientModelRenderable() = 0;
	virtual IClientAlphaProperty* GetClientAlphaProperty() = 0;
};
```

`src/valve_sdk/interfaces/IConVar.hpp`:

```hpp
#pragma once

#include "../misc/Color.hpp"

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
class IConVar;
class CCommand;

//-----------------------------------------------------------------------------
// ConVar flags
//-----------------------------------------------------------------------------
// The default, no flags at all
#define FCVAR_NONE                0

// Command to ConVars and ConCommands
// ConVar Systems
#define FCVAR_UNREGISTERED              (1<<0)  // If this is Set, don't add to linked list, etc.
#define FCVAR_DEVELOPMENTONLY           (1<<1)  // Hidden in released products. Flag is removed automatically if ALLOW_DEVELOPMENT_CVARS is defined.
#define FCVAR_GAMEDLL                   (1<<2)  // defined by the game DLL
#define FCVAR_CLIENTDLL                 (1<<3)  // defined by the client DLL
#define FCVAR_HIDDEN                    (1<<4)  // Hidden. Doesn't appear in GetOffset or auto complete. Like DEVELOPMENTONLY, but can't be compiled out.

// ConVar only
#define FCVAR_PROTECTED                 (1<<5)  // It's a server cvar, but we don't send the data since it's a password, etc.  Sends 1 if it's not bland/zero, 0 otherwise as value
#define FCVAR_SPONLY                    (1<<6)  // This cvar cannot be changed by clients connected to a multiplayer server.
#define FCVAR_ARCHIVE                   (1<<7)  // Set to cause it to be saved to vars.rc
#define FCVAR_NOTIFY                    (1<<8)  // notifies players when changed
#define FCVAR_USERINFO                  (1<<9)  // changes the client's info string

#define FCVAR_PRINTABLEONLY             (1<<10) // This cvar's string cannot contain unprintable characters ( e.g., used for player name etc ).
#define FCVAR_UNLOGGED                  (1<<11) // If this is a FCVAR_SERVER, don't log changes to the log file / console if we are creating a log
#define FCVAR_NEVER_AS_STRING           (1<<12) // never try to print that cvar
#define FCVAR_REPLICATED                (1<<13) // server setting enforced on clients, TODO rename to FCAR_SERVER at some time
#define FCVAR_CHEAT                     (1<<14) // Only useable in singleplayer / debug / multiplayer & sv_cheats
#define FCVAR_SS                        (1<<15) // causes varnameN where N == 2 through max splitscreen slots for mod to be autogenerated
#define FCVAR_DEMO                      (1<<16) // record this cvar when starting a demo file
#define FCVAR_DONTRECORD                (1<<17) // don't record these command in demofiles
#define FCVAR_SS_ADDED                  (1<<18) // This is one of the "added" FCVAR_SS variables for the splitscreen players
#define FCVAR_RELEASE                   (1<<19) // Cvars tagged with this are the only cvars avaliable to customers
#define FCVAR_RELOAD_MATERIALS          (1<<20) // If this cvar changes, it forces a material reload
#define FCVAR_RELOAD_TEXTURES           (1<<21) // If this cvar changes, if forces a texture reload
#define FCVAR_NOT_CONNECTED             (1<<22) // cvar cannot be changed by a client that is connected to a server
#define FCVAR_MATERIAL_SYSTEM_THREAD    (1<<23) // Indicates this cvar is read from the material system thread
#define FCVAR_ARCHIVE_XBOX              (1<<24) // cvar written to config.cfg on the Xbox
#define FCVAR_ACCESSIBLE_FROM_THREADS   (1<<25) // used as a debugging tool necessary to check material system thread convars
//#define FCVAR_AVAILABLE               (1<<26)
//#define FCVAR_AVAILABLE               (1<<27)
#define FCVAR_SERVER_CAN_EXECUTE        (1<<28) // the server is allowed to execute this command on clients via ClientCommand/NET_StringCmd/CBaseClientState::ProcessStringCmd.
#define FCVAR_SERVER_CANNOT_QUERY       (1<<29) // If this is Set, then the server is not allowed to query this cvar's value (via IServerPluginHelpers::StartQueryCvarValue).
#define FCVAR_CLIENTCMD_CAN_EXECUTE     (1<<30) // IVEngineClient::ClientCmd is allowed to execute this command.
#define FCVAR_MEME_DLL                  (1<<31)

#define FCVAR_MATERIAL_THREAD_MASK ( FCVAR_RELOAD_MATERIALS | FCVAR_RELOAD_TEXTURES | FCVAR_MATERIAL_SYSTEM_THREAD )

//-----------------------------------------------------------------------------
// Called when a ConVar changes value
// NOTE: For FCVAR_NEVER_AS_STRING ConVars, pOldValue == NULL
//-----------------------------------------------------------------------------
typedef void(*FnChangeCallback_t)(IConVar * var, const char* pOldValue, float flOldValue);

//-----------------------------------------------------------------------------
// Abstract interface for ConVars
//-----------------------------------------------------------------------------
class IConVar
{
public:
	virtual void SetValue(const char* pValue) = 0;
	virtual void SetValue(float flValue) = 0;
	virtual void SetValue(int nValue) = 0;
	virtual void SetValue(Color value) = 0;
	virtual const char* GetName(void) const = 0;
	virtual const char* GetBaseName(void) const = 0;
	virtual bool IsFlagSet(int nFlag) const = 0;
	virtual int GetSplitScreenPlayerSlot() const = 0;
};
```

`src/valve_sdk/interfaces/ICvar.h`:

```h
#pragma once

class IConsoleDisplayFunc
{
public:
    virtual void ColorPrint(const uint8_t* clr, const char* pMessage) = 0;
    virtual void Print(const char* pMessage) = 0;
    virtual void DPrint(const char* pMessage) = 0;
};

class ICvarQuery;

class ICvar : public IAppSystem
{
public:
    virtual CVarDLLIdentifier_t        AllocateDLLIdentifier() = 0; // 9
    virtual void                       RegisterConCommand(ConCommandBase* pCommandBase) = 0; //10
    virtual void                       UnregisterConCommand(ConCommandBase* pCommandBase) = 0;
    virtual void                       UnregisterConCommands(CVarDLLIdentifier_t id) = 0;
    virtual const char*                GetCommandLineValue(const char* pVariableName) = 0;
    virtual ConCommandBase*            FindCommandBase(const char* name) = 0;
    virtual const ConCommandBase*      FindCommandBase(const char* name) const = 0;
    virtual ConVar*                    find(const char* var_name) = 0; //16
    virtual const ConVar*              find(const char* var_name) const = 0;
    virtual ConCommand*                FindCommand(const char* name) = 0;
    virtual const ConCommand*          FindCommand(const char* name) const = 0;
    virtual void                       InstallGlobalChangeCallback(FnChangeCallback_t callback) = 0;
    virtual void                       RemoveGlobalChangeCallback(FnChangeCallback_t callback) = 0;
    virtual void                       call_callbacks(ConVar* var, const char* pOldString, float flOldValue) = 0;
    virtual void                       InstallConsoleDisplayFunc(IConsoleDisplayFunc* pDisplayFunc) = 0;
    virtual void                       RemoveConsoleDisplayFunc(IConsoleDisplayFunc* pDisplayFunc) = 0;
    virtual void                       ConsoleColorPrintf(const Color& clr, const char* pFormat, ...) const = 0;
    virtual void                       ConsolePrintf(const char* pFormat, ...) const = 0;
    virtual void                       ConsoleDPrintf(const char* pFormat, ...) const = 0;
    virtual void                       RevertFlaggedConVars(int nFlag) = 0;

    //New virtual functions beginning:
    virtual void			           InstallCVarQuery(ICvarQuery* pQuery) = 0;
	virtual void			           SetMaxSplitScreenSlots(int nSlots) = 0;
	virtual int				           GetMaxSplitScreenSlots() const = 0;

	virtual void			           AddSplitScreenConVars() = 0;
	virtual void			           RemoveSplitScreenConVars(CVarDLLIdentifier_t id) = 0;

	virtual int				           GetConsoleDisplayFuncCount() const = 0;
	virtual void			           GetConsoleText(int nDisplayFuncIndex, char* pchText, size_t bufSize) const = 0;

	// Utilities for convars accessed by the material system thread
	virtual bool			           IsMaterialThreadSetAllowed() const = 0;
	virtual void			           QueueMaterialThreadSetValue(ConVar* pConVar, const char* pValue) = 0;
	virtual void			           QueueMaterialThreadSetValue(ConVar* pConVar, int nValue) = 0;
	virtual void			           QueueMaterialThreadSetValue(ConVar* pConVar, float flValue) = 0;
	virtual bool			           HasQueuedMaterialThreadConVarSets() const = 0;
	virtual int			               ProcessQueuedMaterialThreadConVarSets() = 0;

protected:	class ICVarIteratorInternal;
public:
	
	class Iterator
	{
	public:
		inline Iterator(ICvar* icvar)
		{
			m_pIter = icvar->FactoryInternalIterator();
		}

		inline ~Iterator()
		{
			delete m_pIter;
		}

		inline void SetFirst() RESTRICT
		{
			m_pIter->SetFirst();
		}

		inline void Next() RESTRICT
		{
			m_pIter->Next();
		}

		inline bool IsValid() RESTRICT
		{
			return m_pIter->IsValid();
		}

		inline ConCommandBase* Get() RESTRICT
		{
			return m_pIter->Get();
		}
	private:
		ICVarIteratorInternal* m_pIter;
	};

protected:
	// internals for  ICVarIterator
	class ICVarIteratorInternal
	{
	public:
		virtual void			SetFirst() RESTRICT = 0;
		virtual void			Next() RESTRICT = 0;
		virtual	bool			IsValid() RESTRICT = 0;
		virtual ConCommandBase* Get() RESTRICT = 0;
	};

	virtual ICVarIteratorInternal* FactoryInternalIterator(void) = 0;
	friend class Iterator;
};
```

`src/valve_sdk/interfaces/IEngineSound.hpp`:

```hpp
#pragma once
#include "../math/Vectors.hpp"
#include "../misc/UtlVector.hpp"
#include "../misc/vfunc.hpp"


struct SndInfo_t
{
	int m_nGuid;
	void* m_filenameHandle;
	int m_nSoundSource;
	int m_nChannel;
	int m_nSpeakerEntity;
	float m_flVolume;
	float m_flLastSpatializedVolume;
	float m_flRadius;
	int m_nPitch;
	Vector *m_pOrigin;
	Vector *m_pDirection;
	bool m_bUpdatePositions;
	bool m_bIsSentence;
	bool m_bDryMix;
	bool m_bSpeaker;
	bool m_bSpecialDSP;
	bool m_bFromServer;
};

class IEngineSound
{
public:
	void GetActiveSounds(CUtlVector<SndInfo_t> & sndlist)
	{
		CallVFunction<void(__thiscall*)(void*, CUtlVector<SndInfo_t> &)>(this, 19)(this, sndlist);
	}
};

```

`src/valve_sdk/interfaces/IEngineTrace.hpp`:

```hpp
#pragma once

#include "../math/Vectors.hpp"

class IClientEntity : public IClientUnknown, public IClientRenderable, public IClientNetworkable, public IClientThinkable
{
public:
	virtual void Release(void) = 0;
};

#pragma region MASKS

#define   DISPSURF_FLAG_SURFACE           (1<<0)
#define   DISPSURF_FLAG_WALKABLE          (1<<1)
#define   DISPSURF_FLAG_BUILDABLE         (1<<2)
#define   DISPSURF_FLAG_SURFPROP1         (1<<3)
#define   DISPSURF_FLAG_SURFPROP2         (1<<4)

#define   CONTENTS_EMPTY                0

#define   CONTENTS_SOLID                0x1
#define   CONTENTS_WINDOW               0x2
#define   CONTENTS_AUX                  0x4
#define   CONTENTS_GRATE                0x8
#define   CONTENTS_SLIME                0x10
#define   CONTENTS_WATER                0x20
#define   CONTENTS_BLOCKLOS             0x40
#define   CONTENTS_OPAQUE               0x80
#define   LAST_VISIBLE_CONTENTS         CONTENTS_OPAQUE

#define   ALL_VISIBLE_CONTENTS            (LAST_VISIBLE_CONTENTS | (LAST_VISIBLE_CONTENTS-1))

#define   CONTENTS_TESTFOGVOLUME        0x100
#define   CONTENTS_UNUSED               0x200
#define   CONTENTS_BLOCKLIGHT           0x400
#define   CONTENTS_TEAM1                0x800
#define   CONTENTS_TEAM2                0x1000
#define   CONTENTS_IGNORE_NODRAW_OPAQUE 0x2000
#define   CONTENTS_MOVEABLE             0x4000
#define   CONTENTS_AREAPORTAL           0x8000
#define   CONTENTS_PLAYERCLIP           0x10000
#define   CONTENTS_MONSTERCLIP          0x20000
#define   CONTENTS_CURRENT_0            0x40000
#define   CONTENTS_CURRENT_90           0x80000
#define   CONTENTS_CURRENT_180          0x100000
#define   CONTENTS_CURRENT_270          0x200000
#define   CONTENTS_CURRENT_UP           0x400000
#define   CONTENTS_CURRENT_DOWN         0x800000

#define   CONTENTS_ORIGIN               0x1000000

#define   CONTENTS_MONSTER              0x2000000
#define   CONTENTS_DEBRIS               0x4000000
#define   CONTENTS_DETAIL               0x8000000
#define   CONTENTS_TRANSLUCENT          0x10000000
#define   CONTENTS_LADDER               0x20000000
#define   CONTENTS_HITBOX               0x40000000

#define   SURF_LIGHT                    0x0001
#define   SURF_SKY2D                    0x0002
#define   SURF_SKY                      0x0004
#define   SURF_WARP                     0x0008
#define   SURF_TRANS                    0x0010
#define   SURF_NOPORTAL                 0x0020
#define   SURF_TRIGGER                  0x0040
#define   SURF_NODRAW                   0x0080

#define   SURF_HINT                     0x0100

#define   SURF_SKIP                     0x0200
#define   SURF_NOLIGHT                  0x0400
#define   SURF_BUMPLIGHT                0x0800
#define   SURF_NOSHADOWS                0x1000
#define   SURF_NODECALS                 0x2000
#define   SURF_NOPAINT                  SURF_NODECALS
#define   SURF_NOCHOP                   0x4000
#define   SURF_HITBOX                   0x8000

// -----------------------------------------------------
// spatial content masks - used for spatial queries (traceline,etc.)
// -----------------------------------------------------
#define   MASK_ALL                      (0xFFFFFFFF)
#define   MASK_SOLID                    (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define   MASK_PLAYERSOLID              (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define   MASK_NPCSOLID                 (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER|CONTENTS_GRATE)
#define   MASK_NPCFLUID                 (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTERCLIP|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define   MASK_WATER                    (CONTENTS_WATER|CONTENTS_MOVEABLE|CONTENTS_SLIME)
#define   MASK_OPAQUE                   (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_OPAQUE)
#define   MASK_OPAQUE_AND_NPCS          (MASK_OPAQUE|CONTENTS_MONSTER)
#define   MASK_BLOCKLOS                 (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_BLOCKLOS)
#define   MASK_BLOCKLOS_AND_NPCS        (MASK_BLOCKLOS|CONTENTS_MONSTER)
#define   MASK_VISIBLE                  (MASK_OPAQUE|CONTENTS_IGNORE_NODRAW_OPAQUE)
#define   MASK_VISIBLE_AND_NPCS         (MASK_OPAQUE_AND_NPCS|CONTENTS_IGNORE_NODRAW_OPAQUE)
#define   MASK_SHOT                     (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_HITBOX)
#define   MASK_SHOT_BRUSHONLY           (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_DEBRIS)
#define   MASK_SHOT_HULL                (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_MONSTER|CONTENTS_WINDOW|CONTENTS_DEBRIS|CONTENTS_GRATE)
#define   MASK_SHOT_PORTAL              (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTER)
#define   MASK_SOLID_BRUSHONLY          (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_GRATE)
#define   MASK_PLAYERSOLID_BRUSHONLY    (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_PLAYERCLIP|CONTENTS_GRATE)
#define   MASK_NPCSOLID_BRUSHONLY       (CONTENTS_SOLID|CONTENTS_MOVEABLE|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
#define   MASK_NPCWORLDSTATIC           (CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP|CONTENTS_GRATE)
#define   MASK_NPCWORLDSTATIC_FLUID     (CONTENTS_SOLID|CONTENTS_WINDOW|CONTENTS_MONSTERCLIP)
#define   MASK_SPLITAREAPORTAL          (CONTENTS_WATER|CONTENTS_SLIME)
#define   MASK_CURRENT                  (CONTENTS_CURRENT_0|CONTENTS_CURRENT_90|CONTENTS_CURRENT_180|CONTENTS_CURRENT_270|CONTENTS_CURRENT_UP|CONTENTS_CURRENT_DOWN)
#define   MASK_DEADSOLID                (CONTENTS_SOLID|CONTENTS_PLAYERCLIP|CONTENTS_WINDOW|CONTENTS_GRATE)
#pragma endregion

class IHandleEntity;
struct Ray_t;
class CGameTrace;
typedef CGameTrace trace_t;
class ICollideable;
class ITraceListData;
class CPhysCollide;
struct cplane_t;
struct virtualmeshlist_t;

enum class TraceType
{
	TRACE_EVERYTHING = 0,
	TRACE_WORLD_ONLY,
	TRACE_ENTITIES_ONLY,
	TRACE_EVERYTHING_FILTER_PROPS,
};

class ITraceFilter
{
public:
	virtual bool ShouldHitEntity(IHandleEntity* pEntity, int contentsMask) = 0;
	virtual TraceType GetTraceType() const = 0;
};

//-----------------------------------------------------------------------------
// Classes are expected to inherit these + implement the ShouldHitEntity method
//-----------------------------------------------------------------------------

// This is the one most normal traces will inherit from
class CTraceFilter : public ITraceFilter
{
public:
	bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/)
	{
		return !(pEntityHandle == pSkip);
	}
	virtual TraceType GetTraceType() const
	{
		return TraceType::TRACE_EVERYTHING;
	}
	void* pSkip;
};

class CTraceFilterSkipEntity : public ITraceFilter
{
public:
	CTraceFilterSkipEntity(IHandleEntity* pEntityHandle)
	{
		pSkip = pEntityHandle;
	}

	bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/)
	{
		return !(pEntityHandle == pSkip);
	}
	virtual TraceType GetTraceType() const
	{
		return TraceType::TRACE_EVERYTHING;
	}
	void* pSkip;
};

class CTraceFilterEntitiesOnly : public ITraceFilter
{
public:
	bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/)
	{
		return true;
	}
	virtual TraceType GetTraceType() const
	{
		return TraceType::TRACE_ENTITIES_ONLY;
	}
};

//-----------------------------------------------------------------------------
// Classes need not inherit from these
//-----------------------------------------------------------------------------
class CTraceFilterWorldOnly : public ITraceFilter
{
public:
	bool ShouldHitEntity(IHandleEntity* /*pServerEntity*/, int /*contentsMask*/)
	{
		return false;
	}
	virtual TraceType GetTraceType() const
	{
		return TraceType::TRACE_WORLD_ONLY;
	}
};

class CTraceFilterWorldAndPropsOnly : public ITraceFilter
{
public:
	bool ShouldHitEntity(IHandleEntity* /*pServerEntity*/, int /*contentsMask*/)
	{
		return false;
	}
	virtual TraceType GetTraceType() const
	{
		return TraceType::TRACE_EVERYTHING;
	}
};

class CTraceFilterPlayersOnlySkipOne : public ITraceFilter
{
public:
	CTraceFilterPlayersOnlySkipOne(IClientEntity* ent)
	{
		pEnt = ent;
	}
	bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/)
	{
		return pEntityHandle != pEnt && ((IClientEntity*)pEntityHandle)->GetClientClass()->m_ClassID == CCSPlayer;
	}
	virtual TraceType GetTraceType() const
	{
		return TraceType::TRACE_ENTITIES_ONLY;
	}

private:
	IClientEntity* pEnt;
};

class CTraceFilterSkipTwoEntities : public ITraceFilter
{
public:
	CTraceFilterSkipTwoEntities(IClientEntity* ent1, IClientEntity* ent2)
	{
		pEnt1 = ent1;
		pEnt2 = ent2;
	}
	bool ShouldHitEntity(IHandleEntity* pEntityHandle, int /*contentsMask*/)
	{
		return !(pEntityHandle == pEnt1 || pEntityHandle == pEnt2);
	}
	virtual TraceType GetTraceType() const
	{
		return TraceType::TRACE_EVERYTHING;
	}

private:
	IClientEntity* pEnt1;
	IClientEntity* pEnt2;
};

class CTraceFilterHitAll : public CTraceFilter
{
public:
	virtual bool ShouldHitEntity(IHandleEntity* /*pServerEntity*/, int /*contentsMask*/)
	{
		return true;
	}
};

enum class DebugTraceCounterBehavior_t
{
	kTRACE_COUNTER_SET = 0,
	kTRACE_COUNTER_INC,
};

//-----------------------------------------------------------------------------
// Enumeration interface for EnumerateLinkEntities
//-----------------------------------------------------------------------------
class IEntityEnumerator
{
public:
	// This gets called with each handle
	virtual bool EnumEntity(IHandleEntity* pHandleEntity) = 0;
};

struct BrushSideInfo_t
{
	Vector4D plane;               // The plane of the brush side
	unsigned short bevel;    // Bevel plane?
	unsigned short thin;     // Thin?
};

class CPhysCollide;

struct vcollide_t
{
	unsigned short solidCount : 15;
	unsigned short isPacked : 1;
	unsigned short descSize;
	// VPhysicsSolids
	CPhysCollide** solids;
	char* pKeyValues;
	void* pUserData;
};

struct cmodel_t
{
	Vector         mins, maxs;
	Vector         origin;        // for sounds or lights
	int            headnode;
	vcollide_t     vcollisionData;
};

struct csurface_t
{
	const char* name;
	short          surfaceProps;
	unsigned short flags;         // BUGBUG: These are declared per surface, not per material, but this database is per-material now
};

//-----------------------------------------------------------------------------
// A ray...
//-----------------------------------------------------------------------------
struct Ray_t
{
	VectorAligned  m_Start;  // starting point, centered within the extents
	VectorAligned  m_Delta;  // direction + length of the ray
	VectorAligned  m_StartOffset; // Add this to m_Start to Get the actual ray start
	VectorAligned  m_Extents;     // Describes an axis aligned box extruded along a ray
	const matrix3x4_t* m_pWorldAxisTransform;
	bool m_IsRay;  // are the extents zero?
	bool m_IsSwept;     // is delta != 0?

	Ray_t() : m_pWorldAxisTransform(NULL) {}

	void Init(Vector const& start, Vector const& end)
	{
		m_Delta = end - start;

		m_IsSwept = (m_Delta.LengthSqr() != 0);

		m_Extents.Init();

		m_pWorldAxisTransform = NULL;
		m_IsRay = true;

		// Offset m_Start to be in the center of the box...
		m_StartOffset.Init();
		m_Start = start;
	}

	void Init(Vector const& start, Vector const& end, Vector const& mins, Vector const& maxs)
	{
		m_Delta = end - start;

		m_pWorldAxisTransform = NULL;
		m_IsSwept = (m_Delta.LengthSqr() != 0);

		m_Extents = maxs - mins;
		m_Extents *= 0.5f;
		m_IsRay = (m_Extents.LengthSqr() < 1e-6);

		// Offset m_Start to be in the center of the box...
		m_StartOffset = maxs + mins;
		m_StartOffset *= 0.5f;
		m_Start = start + m_StartOffset;
		m_StartOffset *= -1.0f;
	}
	Vector InvDelta() const
	{
		Vector vecInvDelta;
		for (int iAxis = 0; iAxis < 3; ++iAxis) {
			if (m_Delta[iAxis] != 0.0f) {
				vecInvDelta[iAxis] = 1.0f / m_Delta[iAxis];
			}
			else {
				vecInvDelta[iAxis] = FLT_MAX;
			}
		}
		return vecInvDelta;
	}

private:
};

class CBaseTrace
{
public:
	bool IsDispSurface(void) { return ((dispFlags & DISPSURF_FLAG_SURFACE) != 0); }
	bool IsDispSurfaceWalkable(void) { return ((dispFlags & DISPSURF_FLAG_WALKABLE) != 0); }
	bool IsDispSurfaceBuildable(void) { return ((dispFlags & DISPSURF_FLAG_BUILDABLE) != 0); }
	bool IsDispSurfaceProp1(void) { return ((dispFlags & DISPSURF_FLAG_SURFPROP1) != 0); }
	bool IsDispSurfaceProp2(void) { return ((dispFlags & DISPSURF_FLAG_SURFPROP2) != 0); }

public:

	// these members are aligned!!
	Vector         startpos;            // start position
	Vector         endpos;              // final position
	cplane_t       plane;               // surface normal at impact

	float          fraction;            // time completed, 1.0 = didn't hit anything

	int            contents;            // contents on other side of surface hit
	unsigned short dispFlags;           // displacement flags for marking surfaces with data

	bool           allsolid;            // if true, plane is not valid
	bool           startsolid;          // if true, the initial point was in a solid area

	CBaseTrace() {}
};

class CGameTrace : public CBaseTrace
{
public:
	float               fractionleftsolid;  // time we left a solid, only valid if we started in solid
	csurface_t          surface;            // surface hit (impact surface)
	int                 hitgroup;           // 0 == generic, non-zero is specific body part
	short               physicsbone;        // physics bone hit by trace in studio
	unsigned short      worldSurfaceIndex;  // Index of the msurface2_t, if applicable
	IClientEntity* hit_entity;				//aka m_pEnt
	int                 hitbox;             // box hit by trace in studio

	CGameTrace() {}

	// No copy constructors allowed
	CGameTrace(const CGameTrace& other) :
		fractionleftsolid(other.fractionleftsolid),
		surface(other.surface),
		hitgroup(other.hitgroup),
		physicsbone(other.physicsbone),
		worldSurfaceIndex(other.worldSurfaceIndex),
		hit_entity(other.hit_entity),
		hitbox(other.hitbox)
	{
		startpos = other.startpos;
		endpos = other.endpos;
		plane = other.plane;
		fraction = other.fraction;
		contents = other.contents;
		dispFlags = other.dispFlags;
		allsolid = other.allsolid;
		startsolid = other.startsolid;
	}

	CGameTrace& operator=(const CGameTrace& other)
	{
		startpos = other.startpos;
		endpos = other.endpos;
		plane = other.plane;
		fraction = other.fraction;
		contents = other.contents;
		dispFlags = other.dispFlags;
		allsolid = other.allsolid;
		startsolid = other.startsolid;
		fractionleftsolid = other.fractionleftsolid;
		surface = other.surface;
		hitgroup = other.hitgroup;
		physicsbone = other.physicsbone;
		worldSurfaceIndex = other.worldSurfaceIndex;
		hit_entity = other.hit_entity;
		hitbox = other.hitbox;
		return *this;
	}

	inline bool DidHitWorld() const
	{
		return hit_entity->EntIndex() == 0;
	}

	inline bool DidHitNonWorldEntity() const
	{
		return hit_entity != NULL && !DidHitWorld();
	}

	inline bool DidHit() const
	{
		return fraction < 1 || allsolid || startsolid;
	}

	inline bool IsVisible() const
	{
		return fraction > 0.97f;
	}

	inline int GetEntityIndex() const
	{
		return hit_entity->EntIndex();
	}
};

class IEngineTrace
{
public:
	virtual int   GetPointContents(const Vector& vecAbsPosition, int contentsMask = MASK_ALL, IHandleEntity** ppEntity = nullptr) = 0;
	virtual int   GetPointContents_WorldOnly(const Vector& vecAbsPosition, int contentsMask = MASK_ALL) = 0;
	virtual int   GetPointContents_Collideable(ICollideable* pCollide, const Vector& vecAbsPosition) = 0;
	virtual void  ClipRayToEntity(const Ray_t& ray, unsigned int fMask, IHandleEntity* pEnt, CGameTrace* pTrace) = 0;
	virtual void  ClipRayToCollideable(const Ray_t& ray, unsigned int fMask, ICollideable* pCollide, CGameTrace* pTrace) = 0;
	virtual void  trace_ray(const Ray_t& ray, unsigned int fMask, ITraceFilter* pTraceFilter, CGameTrace* pTrace) = 0;
};
```

`src/valve_sdk/interfaces/IFileSystem.h`:

```h
#pragma once

class IFileSystem
{
public:
};

```

`src/valve_sdk/interfaces/IGameEvent.hpp`:

```hpp
#pragma once

#include <cstdint>

#define EVENT_DEBUG_ID_INIT 42
#define EVENT_DEBUG_ID_SHUTDOWN 13

class bf_write;
class bf_read;
class IGameEvent
{
public:
	virtual					~IGameEvent() {};
	virtual const char* GetName() const = 0;

	virtual bool			IsReliable() const = 0;
	virtual bool			IsLocal() const = 0;
	virtual bool			IsEmpty(const char* keyname = nullptr) = 0;

	virtual bool			GetBool(const char* keyname = nullptr, bool default_value = false) = 0;
	virtual int				GetInt(const char* keyname = nullptr, int default_value = 0) = 0;
	virtual uint64_t		GetUint64(const char* keyname = nullptr, uint64_t default_value = 0) = 0;
	virtual float			GetFloat(const char* keyname = nullptr, float default_value = 0.0f) = 0;
	virtual const char* GetString(const char* keyname = nullptr, const char* default_value = "") = 0;
	virtual const wchar_t* GetWString(const char* keyname = nullptr, const wchar_t* default_value = L"") = 0;
	virtual const void* GetPtr(const char* keyname = nullptr, const void* default_values = nullptr) = 0;

	virtual void			SetBool(const char* keyname, bool value) = 0;
	virtual void			SetInt(const char* keyname, int value) = 0;
	virtual void			SetUint64(const char* keyname, uint64_t value) = 0;
	virtual void			SetFloat(const char* keyname, float value) = 0;
	virtual void			SetString(const char* keyname, const char* value) = 0;
	virtual void			SetWString(const char* keyname, const wchar_t* value) = 0;
	virtual void			SetPtr(const char* keyname, const void* value) = 0;
};

class IGameEventListener2
{
public:
	virtual ~IGameEventListener2(void) {}

	virtual void FireGameEvent(IGameEvent* event) = 0;
	virtual int  GetEventDebugID(void) = 0;
public:
	int m_iDebugId;
};

class IGameEventManager2
{
public:
	virtual             ~IGameEventManager2() = 0;
	virtual int         LoadEventsFromFile(const char* filename) = 0;
	virtual void        Reset() = 0;
	virtual bool        add_listener(IGameEventListener2* listener, const char* name, bool bServerSide) = 0;
	virtual bool        FindListener(IGameEventListener2* listener, const char* name) = 0;
	virtual int         remove_listener(IGameEventListener2* listener) = 0;
	virtual IGameEvent* CreateEvent(const char* name, bool bForce, unsigned int dwUnknown) = 0;
	virtual bool        FireEvent(IGameEvent* event, bool bDontBroadcast = false) = 0;
	virtual bool        FireEventClientSide(IGameEvent* event) = 0;
	virtual IGameEvent* DuplicateEvent(IGameEvent* event) = 0;
	virtual void        FreeEvent(IGameEvent* event) = 0;
	virtual bool        SerializeEvent(IGameEvent* event, bf_write* buf) = 0;
	virtual IGameEvent* UnserializeEvent(bf_read* buf) = 0;
};
```

`src/valve_sdk/interfaces/IInputSystem.h`:

```h
#pragma once

#include <iostream>

#include "../../valve_sdk/misc/vfunc.hpp"

class IInputSystem
{
public:
	void EnableInput(bool enable)
	{
		return CallVFunction<void(__thiscall*)(void*, bool)>(this, 11)(this, enable);
	}

	void*& GetWindow()
	{
		static uint32_t offset = 0;
		if (!offset)
			offset = *reinterpret_cast<uint32_t*>((*reinterpret_cast<char***>(this))[10] + 5);

		return *reinterpret_cast<void**>(reinterpret_cast<char*>(this) + offset);
	}
};

```

`src/valve_sdk/interfaces/ILocalize.h`:

```h
#pragma once

class ILocalizeTextQuery
{
public:
	virtual int ComputeTextWidth(const wchar_t* pString) = 0;
};

class ILocalizationChangeCallback
{
public:
	virtual void OnLocalizationChanged() = 0;
};

using LocalizeStringIndex_t = unsigned;

class ILocalize : public IAppSystem
{
public:
	virtual bool					AddFile(const char* fileName, const char* pPathID = nullptr, bool bIncludeFallbackSearchPaths = false) = 0;
	virtual void					RemoveAll() = 0;
	virtual wchar_t* Find(const char* tokenName) = 0;
	virtual const wchar_t* FindSafe(const char* tokenName) = 0;
	virtual int						ConvertANSIToUnicode(const char* ansi, wchar_t* unicode, int unicodeBufferSizeInBytes) = 0;
	virtual int						ConvertUnicodeToANSI(const wchar_t* unicode, char* ansi, int ansiBufferSize) = 0;
	virtual LocalizeStringIndex_t	FindIndex(const char* tokenName) = 0;
	virtual void					ConstructString(wchar_t* unicodeOuput, int unicodeBufferSizeInBytes, const wchar_t* formatString, int numFormatParameters, ...) = 0;
	virtual const char* GetNameByIndex(LocalizeStringIndex_t index) = 0;
	virtual wchar_t* GetValueByIndex(LocalizeStringIndex_t index) = 0;
};

```

`src/valve_sdk/interfaces/IMDLCache.hpp`:

```hpp
#pragma once

#include "../misc/Studio.hpp"

class studiohdr_t;
struct studiohwdata_t;
struct vcollide_t;
struct virtualmodel_t;
struct vertexFileHeader_t;

enum MDLCacheDataType_t
{
	// Callbacks to Get called when data is loaded or unloaded for these:
	MDLCACHE_STUDIOHDR = 0,
	MDLCACHE_STUDIOHWDATA,
	MDLCACHE_VCOLLIDE,

	// Callbacks NOT called when data is loaded or unloaded for these:
	MDLCACHE_ANIMBLOCK,
	MDLCACHE_VIRTUALMODEL,
	MDLCACHE_VERTEXES,
	MDLCACHE_DECODEDANIMBLOCK
};

enum MDLCacheFlush_t
{
	MDLCACHE_FLUSH_STUDIOHDR = 0x01,
	MDLCACHE_FLUSH_STUDIOHWDATA = 0x02,
	MDLCACHE_FLUSH_VCOLLIDE = 0x04,
	MDLCACHE_FLUSH_ANIMBLOCK = 0x08,
	MDLCACHE_FLUSH_VIRTUALMODEL = 0x10,
	MDLCACHE_FLUSH_AUTOPLAY = 0x20,
	MDLCACHE_FLUSH_VERTEXES = 0x40,

	MDLCACHE_FLUSH_IGNORELOCK = 0x80000000,
	MDLCACHE_FLUSH_ALL = 0xFFFFFFFF
};

class IMDLCacheNotify
{
public:
	virtual void OnDataLoaded(MDLCacheDataType_t type, MDLHandle_t handle) = 0;
	virtual void OnDataUnloaded(MDLCacheDataType_t type, MDLHandle_t handle) = 0;
};

class IMDLCache : public IAppSystem
{
public:
	virtual void                SetCacheNotify(IMDLCacheNotify* pNotify) = 0;
	virtual MDLHandle_t         FindMDL(const char* pMDLRelativePath) = 0;
	virtual int                 AddRef(MDLHandle_t handle) = 0;
	virtual int                 Release(MDLHandle_t handle) = 0;
	virtual int                 GetRef(MDLHandle_t handle) = 0;
	virtual studiohdr_t* GetStudioHdr(MDLHandle_t handle) = 0;
	virtual studiohwdata_t* GetHardwareData(MDLHandle_t handle) = 0;
	virtual vcollide_t* GetVCollide(MDLHandle_t handle) = 0;
	virtual unsigned char* GetAnimBlock(MDLHandle_t handle, int nBlock) = 0;
	virtual virtualmodel_t* GetVirtualModel(MDLHandle_t handle) = 0;
	virtual int                 GetAutoplayList(MDLHandle_t handle, unsigned short** pOut) = 0;
	virtual vertexFileHeader_t* GetVertexData(MDLHandle_t handle) = 0;
	virtual void                TouchAllData(MDLHandle_t handle) = 0;
	virtual void                SetUserData(MDLHandle_t handle, void* pData) = 0;
	virtual void* GetUserData(MDLHandle_t handle) = 0;
	virtual bool                IsErrorModel(MDLHandle_t handle) = 0;
	virtual void                Flush(MDLCacheFlush_t nFlushFlags = MDLCACHE_FLUSH_ALL) = 0;
	virtual void                Flush(MDLHandle_t handle, int nFlushFlags = MDLCACHE_FLUSH_ALL) = 0;
	virtual const char* GetModelName(MDLHandle_t handle) = 0;
	virtual virtualmodel_t* GetVirtualModelFast(const studiohdr_t* pStudioHdr, MDLHandle_t handle) = 0;
	virtual void                BeginLock() = 0;
	virtual void                EndLock() = 0;
	virtual int* GetFrameUnlockCounterPtrOLD() = 0;
	virtual void                FinishPendingLoads() = 0;
	virtual vcollide_t* GetVCollideEx(MDLHandle_t handle, bool synchronousLoad = true) = 0;
	virtual bool                GetVCollideSize(MDLHandle_t handle, int* pVCollideSize) = 0;
	virtual bool                GetAsyncLoad(MDLCacheDataType_t type) = 0;
	virtual bool                SetAsyncLoad(MDLCacheDataType_t type, bool bAsync) = 0;
	virtual void                BeginMapLoad() = 0;
	virtual void                EndMapLoad() = 0;
	virtual void                MarkAsLoaded(MDLHandle_t handle) = 0;
	virtual void                InitPreloadData(bool rebuild) = 0;
	virtual void                ShutdownPreloadData() = 0;
	virtual bool                IsDataLoaded(MDLHandle_t handle, MDLCacheDataType_t type) = 0;
	virtual int* GetFrameUnlockCounterPtr(MDLCacheDataType_t type) = 0;
	virtual studiohdr_t* LockStudioHdr(MDLHandle_t handle) = 0;
	virtual void                UnlockStudioHdr(MDLHandle_t handle) = 0;
	virtual bool                PreloadModel(MDLHandle_t handle) = 0;
	virtual void                ResetErrorModelStatus(MDLHandle_t handle) = 0;
	virtual void                MarkFrame() = 0;
	virtual void                BeginCoarseLock() = 0;
	virtual void                EndCoarseLock() = 0;
	virtual void                ReloadVCollide(MDLHandle_t handle) = 0;
};
```

`src/valve_sdk/interfaces/IMaterial.h`:

```h
#pragma once

#include "../interfaces/IMaterialVar.h"

class IMaterial

{
public:
	virtual const char* GetName() const = 0;
	virtual const char* GetTextureGroupName() const = 0;

	IMaterialVar* FindVar(const char* name, bool* found = nullptr, bool complain = true)
	{
		return CallVFunction<IMaterialVar*(__thiscall*)(void*, const char*, bool*, bool)>(this, 11)(this, name, found, complain);
	}

	void IncrementReferenceCount()
	{
		CallVFunction<void(__thiscall*)(void*)>(this, 12)(this);
	}

	void AlphaModulate(float alpha)
	{
		CallVFunction<void(__thiscall*)(void*, float)>(this, 27)(this, alpha);
	}

	void ColorModulate(float r, float g, float b)
	{
		CallVFunction<void(__thiscall*)(void*, float, float, float)>(this, 28)(this, r, g, b);
	}

	void SetMaterialVarFlag(EMaterialVarFlag flag, bool on)
	{
		CallVFunction<void(__thiscall*)(void*, EMaterialVarFlag, bool)>(this, 29)(this, flag, on);
	}

	bool GetMaterialVarFlag(EMaterialVarFlag flag)
	{
		return CallVFunction<bool(__thiscall*)(void*, EMaterialVarFlag)>(this, 30)(this, flag);
	}
};
```

`src/valve_sdk/interfaces/IMaterialSystem.hpp`:

```hpp
#pragma once

#define DECLARE_POINTER_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#define MAXSTUDIOSKINS		32

#define TEXTURE_GROUP_LIGHTMAP						        "Lightmaps"
#define TEXTURE_GROUP_WORLD							          "World textures"
#define TEXTURE_GROUP_MODEL							          "Model textures"
#define TEXTURE_GROUP_VGUI							          "VGUI textures"
#define TEXTURE_GROUP_PARTICLE						        "Particle textures"
#define TEXTURE_GROUP_DECAL							          "Decal textures"
#define TEXTURE_GROUP_SKYBOX						          "SkyBox textures"
#define TEXTURE_GROUP_CLIENT_EFFECTS				      "ClientEffect textures"
#define TEXTURE_GROUP_OTHER							          "Other textures"
#define TEXTURE_GROUP_PRECACHED						        "Precached"
#define TEXTURE_GROUP_CUBE_MAP						        "CubeMap textures"
#define TEXTURE_GROUP_RENDER_TARGET					      "RenderTargets"
#define TEXTURE_GROUP_UNACCOUNTED					        "Unaccounted textures"
//#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER		  "Static Vertex"
#define TEXTURE_GROUP_STATIC_INDEX_BUFFER			    "Static Indices"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_DISP		"Displacement Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_COLOR	"Lighting Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_WORLD	"World Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_MODELS	"Model Verts"
#define TEXTURE_GROUP_STATIC_VERTEX_BUFFER_OTHER	"Other Verts"
#define TEXTURE_GROUP_DYNAMIC_INDEX_BUFFER			  "Dynamic Indices"
#define TEXTURE_GROUP_DYNAMIC_VERTEX_BUFFER			  "Dynamic Verts"
#define TEXTURE_GROUP_DEPTH_BUFFER					      "DepthBuffer"
#define TEXTURE_GROUP_VIEW_MODEL					        "ViewModel"
#define TEXTURE_GROUP_PIXEL_SHADERS					      "Pixel Shaders"
#define TEXTURE_GROUP_VERTEX_SHADERS				      "Vertex Shaders"
#define TEXTURE_GROUP_RENDER_TARGET_SURFACE			  "RenderTarget Surfaces"
#define TEXTURE_GROUP_MORPH_TARGETS					      "Morph Targets"
#define TEXTURE_GROUP_STATIC_PROPS						"StaticProp textures"

#define TEXTURE_GROUP_COMBINED						"Combined Textures"
#define TEXTURE_GROUP_COMPOSITE						"Composited Textures"

struct IDirect3DTexture9;

class IMaterial;
class Texture_t;

struct ITexture
{
	int GetActualWidth()
	{
		return CallVFunction<int(__thiscall*)(void*)>(this, 3)(this);
	}

	int GetActualHeight()
	{
		return CallVFunction<int(__thiscall*)(void*)>(this, 4)(this);
	}
};

typedef unsigned short MaterialHandle_t;
DECLARE_POINTER_HANDLE(MaterialLock_t);

class IMatRenderContext
{
public:
	int Release()
	{
		return CallVFunction<int(__thiscall*)(void*)>(this, 1)(this);
	}

	void SetRenderTarget(ITexture* pTexture)
	{
		CallVFunction<void(__thiscall*)(void*, ITexture*)>(this, 6)(this, pTexture);
	}

	void PushRenderTargetAndViewport()
	{
		CallVFunction<void(__thiscall*)(void*)>(this, 119)(this);
	}

	void PopRenderTargetAndViewport()
	{
		CallVFunction<void(__thiscall*)(void*)>(this, 120)(this);
	}

	void DrawScreenSpaceRectangle(IMaterial* material, ITexture* texture, int x, int y, int width, int height)
	{
		CallVFunction<void(__thiscall*)(void*, void*, int, int, int, int, float, float, float, float, int, int, void*, int, int)>(this, 114)
			(this, material, x, y, width, height, 0, 0, float(width), float(height), texture->GetActualWidth(), texture->GetActualHeight(), nullptr, 1, 1);
	}
};

class IMaterialSystem : public IAppSystem
{
public:
	IMaterial* CreateMaterial(const char* pMaterialName, KeyValues* pVMTKeyValues)
	{
		return CallVFunction<IMaterial * (__thiscall*)(PVOID, const char*, KeyValues*)>(this, 83)(this, pMaterialName, pVMTKeyValues);
	}

	IMaterial* FindMaterial(const char* pMaterialName, const char* pTextureGroupName, bool complain = true, const char* pComplainPrefix = 0)
	{
		return CallVFunction<IMaterial * (__thiscall*)(PVOID, const char*, const char*, bool, const char*)>(this, 84)(this, pMaterialName, pTextureGroupName, complain, pComplainPrefix);
	}

	MaterialHandle_t FirstMaterial()
	{
		return CallVFunction<MaterialHandle_t(__thiscall*)(PVOID)>(this, 86)(this);
	}

	MaterialHandle_t NextMaterial(MaterialHandle_t h)
	{
		return CallVFunction<MaterialHandle_t(__thiscall*)(PVOID, MaterialHandle_t)>(this, 87)(this, h);
	}

	MaterialHandle_t InvalidMaterial()
	{
		return CallVFunction<MaterialHandle_t(__thiscall*)(PVOID)>(this, 88)(this);
	}

	IMaterial* GetMaterial(MaterialHandle_t h)
	{
		return CallVFunction<IMaterial * (__thiscall*)(PVOID, MaterialHandle_t)>(this, 89)(this, h);
	}

	int	GetNumMaterials()
	{
		return CallVFunction<int(__thiscall*)(PVOID)>(this, 90)(this);
	}

	void BeginRenderTargetAllocation()
	{
		CallVFunction<void(__thiscall*)(PVOID)>(this, 94)(this);
	}

	void EndRenderTargetAllocation()
	{
		CallVFunction<void(__thiscall*)(PVOID)>(this, 95)(this);
	}

	int GetBackBufferFormat()
	{
		return CallVFunction<int(__thiscall*)(PVOID)>(this, 36)(this);
	}

	ITexture* CreateNamedRenderTargetTextureEx(int back_buffer, const char* name)
	{
		return CallVFunction<ITexture * (__thiscall*)(PVOID, const char*, int, int, int, int, int, int, int)>(this, 97)(this, name, 1, 1, 4, back_buffer, 0x0, 0x00000004 | 0x00000008, 1);
	}

	IMatRenderContext* GetRenderContext()
	{
		return CallVFunction<IMatRenderContext * (__thiscall*)(PVOID)>(this, 115)(this);
	}

	bool& IsGameStarted()
	{
		return *(bool*)(uintptr_t(this) + 0x2C68);
	}
};
```

`src/valve_sdk/interfaces/IMaterialVar.h`:

```h
#pragma once

class IMaterialVar
{
public:
	void SetFloatValue(float value)
	{
		CallVFunction<void(__thiscall*)(void*, float)>(this, 4)(this, value);
	}

	void SetIntValue(int value)
	{
		CallVFunction<void(__thiscall*)(void*, int)>(this, 5)(this, value);
	}

	void SetStringValue(char const* value)
	{
		CallVFunction<void(__thiscall*)(void*, char const*)>(this, 6)(this, value);
	}

	void SetVectorValue(float x, float y, float z)
	{
		CallVFunction<void(__thiscall*)(void*, float, float, float)>(this, 11)(this, x, y, z);
	}

	void SetVecComponentValue(float value, int component)
	{
		CallVFunction<void(__thiscall*)(void*, float, int)>(this, 26)(this, value, component);
	}
};

```

`src/valve_sdk/interfaces/IMemAlloc.h`:

```h
#pragma once
#include <algorithm>

class IMemAlloc
{
public:
	// Release versions
	virtual void* Alloc(size_t nSize) = 0;
	virtual void* Realloc(void* pMem, size_t nSize) = 0;
	virtual void  Free(void* pMem) = 0;
	virtual void* Expand_NoLongerSupported(void* pMem, size_t nSize) = 0;

	// Debug versions
	virtual void* Alloc(size_t nSize, const char* pFileName, int nLine) = 0;
	virtual void* Realloc(void* pMem, size_t nSize, const char* pFileName, int nLine) = 0;
	virtual void  Free(void* pMem, const char* pFileName, int nLine) = 0;
	virtual void* Expand_NoLongerSupported(void* pMem, size_t nSize, const char* pFileName, int nLine) = 0;

	// Returns size of a particular allocation
	virtual size_t GetSize(void* pMem) = 0;

	// Force file + line information for an allocation
	virtual void PushAllocDbgInfo(const char* pFileName, int nLine) = 0;
	virtual void PopAllocDbgInfo() = 0;

	virtual long CrtSetBreakAlloc(long lNewBreakAlloc) = 0;
	virtual	int CrtSetReportMode(int nReportType, int nReportMode) = 0;
	virtual int CrtIsValidHeapPointer(const void* pMem) = 0;
	virtual int CrtIsValidPointer(const void* pMem, unsigned int size, int access) = 0;
	virtual int CrtCheckMemory(void) = 0;
	virtual int CrtSetDbgFlag(int nNewFlag) = 0;
	virtual void CrtMemCheckpoint(_CrtMemState* pState) = 0;
	virtual int heapchk() = 0;

	virtual void DumpStats() = 0;
	virtual void DumpStatsFileBase(char const* pchFileBase) = 0;
};
```

`src/valve_sdk/interfaces/IMoveHelper.hpp`:

```hpp
#pragma once

class IMoveHelper
{
public:
	virtual	void _vpad() = 0;
	virtual void SetHost(IClientEntity* host) = 0;
};
```

`src/valve_sdk/interfaces/INetMessage.h`:

```h
#pragma once

#include "../interfaces/CClientState.h"

class bf_write;
class bf_read;

class INetMessage
{
public:
	virtual	~INetMessage() {};
	virtual void SetNetChannel(INetChannel* netchan) = 0; // netchannel this message is from/for
	virtual void SetReliable(bool state) = 0;	// set to true if it's a reliable message
	virtual bool Process(void) = 0; // calles the recently set handler to process this message
	virtual	bool ReadFromBuffer(bf_read& buffer) = 0; // returns true if parsing was OK
	virtual	bool WriteToBuffer(bf_write& buffer) = 0;	// returns true if writing was OK
	virtual bool IsReliable(void) const = 0;  // true, if message needs reliable handling
	virtual int GetType(void) const = 0; // returns module specific header tag eg svc_serverinfo
	virtual int GetGroup(void) const = 0;	// returns net message group of this message
};

```

`src/valve_sdk/interfaces/IPanel.hpp`:

```hpp
#pragma once

class IPanel
{
public:
	const char* GetName(unsigned int vguiPanel)
	{
		typedef const char* (__thiscall * tGetName)(void*, unsigned int);
		return CallVFunction<tGetName>(this, 36)(this, vguiPanel);
	}

	const char* GetClassName(unsigned int vguiPanel)
	{
		typedef const char* (__thiscall * tGetClassName)(void*, unsigned int);
		return CallVFunction<tGetClassName>(this, 37)(this, vguiPanel);
	}
};
```

`src/valve_sdk/interfaces/IPhysics.hpp`:

```hpp
#pragma once

struct surfacephysicsparams_t
{
	float friction;
	float elasticity;
	float density;
	float thickness;
	float dampening;
};

struct surfaceaudioparams_t
{
	float reflectivity; // like elasticity, but how much sound should be reflected by this surface
	float hardnessFactor; // like elasticity, but only affects impact sound choices
	float roughnessFactor; // like friction, but only affects scrape sound choices
	float roughThreshold; // surface roughness > this causes "rough" scrapes, < this causes "smooth" scrapes
	float hardThreshold; // surface hardness > this causes "hard" impacts, < this causes "soft" impacts
	float hardVelocityThreshold; // collision velocity > this causes "hard" impacts, < this causes "soft" impacts
	float highPitchOcclusion; //a value betweeen 0 and 100 where 0 is not occluded at all and 100 is silent (except for any additional reflected sound)
	float midPitchOcclusion;
	float lowPitchOcclusion;
};

struct surfacesoundnames_t
{
	unsigned short walkStepLeft;
	unsigned short walkStepRight;
	unsigned short	runStepLeft;
	unsigned short	runStepRight;
	unsigned short impactSoft;
	unsigned short impactHard;
	unsigned short scrapeSmooth;
	unsigned short scrapeRough;
	unsigned short bulletImpact;
	unsigned short rolling;
	unsigned short breakSound;
	unsigned short strainSound;
};

struct surfacegameprops_t
{
public:
	float maxSpeedFactor;
	float jumpFactor;
	float flPenetrationModifier;
	float flDamageModifier;
	unsigned short material;
	byte climbable;
};

struct surfacedata_t
{
	surfacephysicsparams_t physics;
	surfaceaudioparams_t audio;
	surfacesoundnames_t sounds;
	surfacegameprops_t game;
};

class IPhysicsSurfaceProps
{
public:
	virtual ~IPhysicsSurfaceProps(void) {}
	virtual int ParseSurfaceData(const char* pFilename, const char* pTextfile) = 0;
	virtual int SurfacePropCount(void) const = 0;
	virtual int GetSurfaceIndex(const char* pSurfacePropName) const = 0;
	virtual void GetPhysicsProperties(int surfaceDataIndex, float* density, float thickness, float friction, float elasticity) const = 0;
	virtual surfacedata_t* GetSurfaceData(int surfaceDataIndex) = 0;
	virtual const char GetString(unsigned short stringTableIndex) const = 0;
	virtual const char GetPropName(int surfaceDataIndex) const = 0;
	virtual void SetWorldMaterialIndexTable(int* pMapArray, int mapSize) = 0;
	virtual void GetPhysicsParameters(int surfaceDataIndex, surfacephysicsparams_t* pParamsOut) const = 0;
};
```

`src/valve_sdk/interfaces/IPrediction.hpp`:

```hpp
#pragma once

#include "../math/QAngle.hpp"
#include "../misc/CUserCmd.hpp"
#include "IMoveHelper.hpp"

class CMoveData {
public:
	bool			m_bFirstRunOfFunctions : 1;
	bool			m_bGameCodeMovedPlayer : 1;
	bool			m_bNoAirControl : 1;

	unsigned long	m_nPlayerHandle;
	int				m_nImpulseCommand;
	QAngle			m_vecViewAngles;
	QAngle			m_vecAbsViewAngles;
	int				m_nButtons;
	int				m_nOldButtons;
	float			m_flForwardMove;
	float			m_flSideMove;
	float			m_flUpMove;

	float			m_flMaxSpeed;
	float			m_flClientMaxSpeed;

	Vector			m_vecVelocity;
	Vector			m_vecOldVelocity;
	float			somefloat;
	QAngle			m_vecAngles;
	QAngle			m_vecOldAngles;

	float			m_outStepHeight;
	Vector			m_outWishVel;
	Vector			m_outJumpVel;

	Vector			m_vecConstraintCenter;
	float			m_flConstraintRadius;
	float			m_flConstraintWidth;
	float			m_flConstraintSpeedFactor;
	bool			m_bConstraintPastRadius;

	void			SetAbsOrigin(const Vector& vec);
	const Vector&	GetAbsOrigin() const;

private:
	Vector			m_vecAbsOrigin;		// edict::origin
};

class c_base_player;

class IGameMovement {
public:
	virtual			~IGameMovement(void) {}

	virtual void	ProcessMovement(c_base_player* pPlayer, CMoveData* pMove) = 0;
	virtual void	Reset(void) = 0;
	virtual void	StartTrackPredictionErrors(c_base_player* pPlayer) = 0;
	virtual void	FinishTrackPredictionErrors(c_base_player* pPlayer) = 0;
	virtual void	DiffPrint(char const* fmt, ...) = 0;

	virtual Vector const& GetPlayerMins(bool ducked) const = 0;
	virtual Vector const& GetPlayerMaxs(bool ducked) const = 0;
	virtual Vector const& GetPlayerViewOffset(bool ducked) const = 0;

	virtual bool			IsMovingPlayerStuck(void) const = 0;
	virtual c_base_player*	GetMovingPlayer(void) const = 0;
	virtual void			UnblockPusher(c_base_player* pPlayer, c_base_player* pPusher) = 0;

	virtual void SetupMovementBounds(CMoveData* pMove) = 0;
};

class CGameMovement
	: public IGameMovement
{
public:
	virtual ~CGameMovement(void) {}
};

class IPrediction
{
public:
	void SetLocalViewAngles(QAngle& va)
	{
		CallVFunction<void(__thiscall*)(void*, QAngle&)>(this, 13)(this, va);
	}

	bool InPrediction()
	{
		typedef bool(__thiscall * oInPrediction)(void*);
		return CallVFunction<oInPrediction>(this, 14)(this);
	}

	void RunCommand(c_base_player* player, CUserCmd* ucmd, IMoveHelper* moveHelper)
	{
		typedef void(__thiscall * oRunCommand)(void*, c_base_player*, CUserCmd*, IMoveHelper*);
		return CallVFunction<oRunCommand>(this, 19)(this, player, ucmd, moveHelper);
	}

	void SetupMove(c_base_player* player, CUserCmd* ucmd, IMoveHelper* moveHelper, void* pMoveData)
	{
		typedef void(__thiscall * oSetupMove)(void*, c_base_player*, CUserCmd*, IMoveHelper*, void*);
		return CallVFunction<oSetupMove>(this, 20)(this, player, ucmd, moveHelper, pMoveData);
	}

	void FinishMove(c_base_player* player, CUserCmd* ucmd, void* pMoveData)
	{
		typedef void(__thiscall * oFinishMove)(void*, c_base_player*, CUserCmd*, void*);
		return CallVFunction<oFinishMove>(this, 21)(this, player, ucmd, pMoveData);
	}
};
```

`src/valve_sdk/interfaces/IRefCounted.h`:

```h
#pragma once

class IRefCounted {
private:
	volatile long refCount;
public:
	virtual void destructor(char bDelete) = 0;
	virtual bool OnFinalRelease() = 0;

	void unreference() {
		if (InterlockedDecrement(&refCount) == 0 && OnFinalRelease()) {
			destructor(1);
		}
	}
};
```

`src/valve_sdk/interfaces/IStudioRender.h`:

```h
#pragma once
#include "../valve_sdk/math/Vectors.hpp"

class LightDesc_t;
class lightpos_t;

enum LightType_t {
	MATERIAL_LIGHT_DISABLE = 0,
	MATERIAL_LIGHT_POINT,
	MATERIAL_LIGHT_DIRECTIONAL,
	MATERIAL_LIGHT_SPOT,
};

class LightDesc_t {
public:
	LightType_t m_Type;                 //0x0000
	Vector m_Color;                     //0x0004
	Vector m_Position;                  //0x0010
	Vector m_Direction;                 //0x001C
	float m_Range;                      //0x0028
	float m_Falloff;                    //0x002C
	float m_Attenuation0;               //0x0030
	float m_Attenuation1;               //0x0034
	float m_Attenuation2;               //0x0038
	float m_Theta;                      //0x003C
	float m_Phi;                        //0x0040
	float m_ThetaDot;                   //0x0044
	float m_PhiDot;                     //0x0048
	float m_OneOverThetaDotMinusPhiDot; //0x004C
	__int32 m_Flags;                    //0x0050
	float m_RangeSquared;               //0x0054
}; //Size=0x0058

class lightpos_t {
public:
	Vector delta;  //0x0000
	float falloff; //0x000C
	float dot;     //0x0010
}; //Size=0x0014

struct MaterialLightingState_t {
	Vector m_vecAmbientCube[6]; // ambient, and lights that aren't in locallight[]
	Vector m_vecLightingOrigin; // The position from which lighting state was computed
	int m_nLocalLightCount;
	LightDesc_t m_pLocalLightDesc[4];
};

struct DrawModelInfo_t {
	studiohdr_t* m_pStudioHdr;
	studiohwdata_t* m_pHardwareData;
	StudioDecalHandle_t m_Decals;
	int m_Skin;
	int m_Body;
	int m_HitboxSet;
	IClientRenderable* m_pClientEntity;
	int m_Lod;
	ColorMeshInfo_t* m_pColorMeshes;
	bool m_bStaticLighting;
	MaterialLightingState_t m_LightingState;
};

class IStudioRender {
public:
	void* vtable;
	float fEyeShiftX;                      //0x0004
	float fEyeShiftY;                      //0x0008
	float fEyeShiftZ;                      //0x000C
	float fEyeSize;                        //0x0010
	float fEyeGlintPixelWidthLODThreshold; //0x0014
	__int32 maxDecalsPerModel;             //0x0018
	__int32 drawEntities;                  //0x001C
	__int32 skin;                          //0x0020
	__int32 fullbright;                    //0x0024
	bool bEyeMove : 1;                     // look around
	bool bSoftwareSkin : 1;
	bool bNoHardware : 1;
	bool bNoSoftware : 1;
	bool bTeeth : 1;
	bool bEyes : 1;
	bool bFlex : 1;
	bool bWireframe : 1;
	bool bDrawNormals : 1;
	bool bDrawTangentFrame : 1;
	bool bDrawZBufferedWireframe : 1;
	bool bSoftwareLighting : 1;
	bool bShowEnvCubemapOnly : 1;
	bool bWireframeDecals : 1;
	int m_nReserved[5];
	Vector m_ViewTarget;           //0x0040
	Vector m_ViewOrigin;           //0x004C
	Vector m_ViewRight;            //0x0058
	Vector m_ViewUp;               //0x0064
	Vector m_ViewPlaneNormal;      //0x0070
	Vector4D m_LightBoxColors[6];  //0x00CC
	LightDesc_t m_LocalLights[4];  //0x01E4
	__int32 m_NumLocalLights;      //0x023C
	float m_ColorMod[3];           //0x0248
	float m_AlphaMod;              //0x024C
	IMaterial* m_pForcedMaterial;  //0x0250
	__int32 m_nForcedMaterialType; //0x0254
	char pad_0x0258[0xC];          //0x0258
	__int32 unkhandle1;            //0x0264
	__int32 unkhandle2;            //0x0268
	__int32 unkhandle3;            //0x026C
	__int32 unkhandle4;            //0x0270
	char pad_0x0274[0x4];          //0x0274
	lightpos_t m_pLightPos[16];    //0x0278

	void SetColorModulation(float const* pColor) {
		typedef void(__thiscall * OrigFn)(void*, float const*);
		CallVFunction< OrigFn >(this, 27)(this, pColor);
	}

	inline void ForcedMaterialOverride(IMaterial* material, OverrideType_t nOverrideType = 0) {
		m_pForcedMaterial = material;
		m_nForcedMaterialType = nOverrideType;
	}
};

static_assert(FIELD_OFFSET(IStudioRender, m_pForcedMaterial) == 0x250, "Wrong m_pForcedMaterial offset");

```

`src/valve_sdk/interfaces/ISurface.h`:

```h
#pragma once

namespace vgui
{
	typedef unsigned long HFont;
	typedef unsigned int VPANEL;
};

enum FontFeature
{
	FONT_FEATURE_ANTIALIASED_FONTS = 1,
	FONT_FEATURE_DROPSHADOW_FONTS = 2,
	FONT_FEATURE_OUTLINE_FONTS = 6,
};

enum FontDrawType
{
	FONT_DRAW_DEFAULT = 0,
	FONT_DRAW_NONADDITIVE,
	FONT_DRAW_ADDITIVE,
	FONT_DRAW_TYPE_COUNT = 2,
};

enum FontFlags
{
	FONTFLAG_NONE,
	FONTFLAG_ITALIC = 0x001,
	FONTFLAG_UNDERLINE = 0x002,
	FONTFLAG_STRIKEOUT = 0x004,
	FONTFLAG_SYMBOL = 0x008,
	FONTFLAG_ANTIALIAS = 0x010,
	FONTFLAG_GAUSSIANBLUR = 0x020,
	FONTFLAG_ROTARY = 0x040,
	FONTFLAG_DROPSHADOW = 0x080,
	FONTFLAG_ADDITIVE = 0x100,
	FONTFLAG_OUTLINE = 0x200,
	FONTFLAG_CUSTOM = 0x400,
	FONTFLAG_BITMAP = 0x800,
};

struct Vertex_t
{
	Vertex_t() {}
	Vertex_t(const Vector2D& pos, const Vector2D& coord = Vector2D(0, 0))
	{
		m_Position = pos;
		m_TexCoord = coord;
	}
	void Init(const Vector2D& pos, const Vector2D& coord = Vector2D(0, 0))
	{
		m_Position = pos;
		m_TexCoord = coord;
	}

	Vector2D m_Position;
	Vector2D m_TexCoord;
};

class ISurface : public IAppSystem
{
public:
	virtual void          RunFrame() = 0;
	virtual vgui::VPANEL  GetEmbeddedPanel() = 0;
	virtual void          SetEmbeddedPanel(vgui::VPANEL pPanel) = 0;
	virtual void          PushMakeCurrent(vgui::VPANEL panel, bool useInsets) = 0;
	virtual void          PopMakeCurrent(vgui::VPANEL panel) = 0;
	virtual void          DrawSetColor(int r, int g, int b, int a) = 0;
	virtual void          DrawSetColor(Color col) = 0;
	virtual void          DrawFilledRect(int x0, int y0, int x1, int y1) = 0;
	virtual void          DrawFilledRectArray(void* pRects, int numRects) = 0;
	virtual void          DrawOutlinedRect(int x0, int y0, int x1, int y1) = 0;
	virtual void          DrawLine(int x0, int y0, int x1, int y1) = 0;
	virtual void          DrawPolyLine(int* px, int* py, int numPoints) = 0;
	virtual void          DrawSetApparentDepth(float f) = 0;
	virtual void          DrawClearApparentDepth(void) = 0;
	virtual void          DrawSetTextFont(vgui::HFont font) = 0;
	virtual void          DrawSetTextColor(int r, int g, int b, int a) = 0;
	virtual void          DrawSetTextColor(Color col) = 0;
	virtual void          DrawSetTextPos(int x, int y) = 0;
	virtual void          DrawGetTextPos(int& x, int& y) = 0;
	virtual void          DrawPrintText(const wchar_t* text, int textLen, FontDrawType drawType = FONT_DRAW_DEFAULT) = 0;
	virtual void          DrawUnicodeChar(wchar_t wch, FontDrawType drawType = FONT_DRAW_DEFAULT) = 0;
	virtual void          DrawFlushText() = 0;
	virtual void* CreateHTMLWindow(void* events, vgui::VPANEL context) = 0;
	virtual void          PaintHTMLWindow(void* htmlwin) = 0;
	virtual void          DeleteHTMLWindow(void* htmlwin) = 0;
	virtual int           DrawGetTextureId(char const* filename) = 0;
	virtual bool          DrawGetTextureFile(int id, char* filename, int maxlen) = 0;
	virtual void          DrawSetTextureFile(int id, const char* filename, int hardwareFilter, bool forceReload) = 0;
	virtual void          DrawSetTextureRGBA(int id, const unsigned char* rgba, int wide, int tall) = 0;
	virtual void          DrawSetTexture(int id) = 0;
	virtual void          DeleteTextureByID(int id) = 0;
	virtual void          DrawGetTextureSize(int id, int& wide, int& tall) = 0;
	virtual void          DrawTexturedRect(int x0, int y0, int x1, int y1) = 0;
	virtual bool          IsTextureIDValid(int id) = 0;
	virtual int           CreateNewTextureID(bool procedural = false) = 0;
	virtual void          GetScreenSize(int& wide, int& tall) = 0;
	virtual void          SetAsTopMost(vgui::VPANEL panel, bool state) = 0;
	virtual void          BringToFront(vgui::VPANEL panel) = 0;
	virtual void          SetForegroundWindow(vgui::VPANEL panel) = 0;
	virtual void          SetPanelVisible(vgui::VPANEL panel, bool state) = 0;
	virtual void          SetMinimized(vgui::VPANEL panel, bool state) = 0;
	virtual bool          IsMinimized(vgui::VPANEL panel) = 0;
	virtual void          FlashWindow(vgui::VPANEL panel, bool state) = 0;
	virtual void          SetTitle(vgui::VPANEL panel, const wchar_t* title) = 0;
	virtual void          SetAsToolBar(vgui::VPANEL panel, bool state) = 0;
	virtual void          CreatePopup(vgui::VPANEL panel, bool minimised, bool showTaskbarIcon = true, bool disabled = false, bool mouseInput = true, bool kbInput = true) = 0;
	virtual void          SwapBuffers(vgui::VPANEL panel) = 0;
	virtual void          Invalidate(vgui::VPANEL panel) = 0;
	virtual void          SetCursor(unsigned long cursor) = 0;
	virtual bool          IsCursorVisible() = 0;
	virtual void          ApplyChanges() = 0;
	virtual bool          IsWithin(int x, int y) = 0;
	virtual bool          HasFocus() = 0;
	virtual bool          SupportsFeature(int /*SurfaceFeature_t*/ feature) = 0;
	virtual void          RestrictPaintToSinglePanel(vgui::VPANEL panel, bool bForceAllowNonModalSurface = false) = 0;
	virtual void          SetModalPanel(vgui::VPANEL) = 0;
	virtual vgui::VPANEL  GetModalPanel() = 0;
	virtual void          UnlockCursor() = 0;
	virtual void          LockCursor() = 0;
	virtual void          SetTranslateExtendedKeys(bool state) = 0;
	virtual vgui::VPANEL  GetTopmostPopup() = 0;
	virtual void          SetTopLevelFocus(vgui::VPANEL panel) = 0;
	virtual vgui::HFont   CreateFont_() = 0;
	virtual bool          SetFontGlyphSet(vgui::HFont font, const char* windowsFontName, int tall, int weight, int blur, int scanlines, int flags, int nRangeMin = 0, int nRangeMax = 0) = 0;
	virtual bool          AddCustomFontFile(const char* fontFileName) = 0;
	virtual int           GetFontTall(vgui::HFont font) = 0;
	virtual int           GetFontAscent(vgui::HFont font, wchar_t wch) = 0;
	virtual bool          IsFontAdditive(vgui::HFont font) = 0;
	virtual void          GetCharABCwide(vgui::HFont font, int ch, int& a, int& b, int& c) = 0;
	virtual int           GetCharacterWidth(vgui::HFont font, int ch) = 0;
	virtual void          GetTextSize(vgui::HFont font, const wchar_t* text, int& wide, int& tall) = 0;
	virtual vgui::VPANEL  GetNotifyPanel() = 0;
	virtual void          SetNotifyIcon(vgui::VPANEL context, unsigned long icon, vgui::VPANEL panelToReceiveMessages, const char* text) = 0;
	virtual void          PlaySound_(const char* fileName) = 0;
	virtual int           GetPopupCount() = 0;
	virtual vgui::VPANEL  GetPopup(int index) = 0;
	virtual bool          ShouldPaintChildPanel(vgui::VPANEL childPanel) = 0;
	virtual bool          RecreateContext(vgui::VPANEL panel) = 0;
	virtual void          AddPanel(vgui::VPANEL panel) = 0;
	virtual void          ReleasePanel(vgui::VPANEL panel) = 0;
	virtual void          MovePopupToFront(vgui::VPANEL panel) = 0;
	virtual void          MovePopupToBack(vgui::VPANEL panel) = 0;
	virtual void          SolveTraverse(vgui::VPANEL panel, bool forceApplySchemeSettings = false) = 0;
	virtual void          PaintTraverse(vgui::VPANEL panel) = 0;
	virtual void          EnableMouseCapture(vgui::VPANEL panel, bool state) = 0;
	virtual void          GetWorkspaceBounds(int& x, int& y, int& wide, int& tall) = 0;
	virtual void          GetAbsoluteWindowBounds(int& x, int& y, int& wide, int& tall) = 0;
	virtual void          GetProportionalBase(int& width, int& height) = 0;
	virtual void          CalculateMouseVisible() = 0;
	virtual bool          NeedKBInput() = 0;
	virtual bool          HasCursorPosFunctions() = 0;
	virtual void          SurfaceGetCursorPos(int& x, int& y) = 0;
	virtual void          SurfaceSetCursorPos(int x, int y) = 0;
	virtual void          DrawTexturedLine(const Vertex_t& a, const Vertex_t& b) = 0;
	virtual void          DrawOutlinedCircle(int x, int y, int radius, int segments) = 0;
	virtual void          DrawTexturedPolyLine(const Vertex_t* p, int n) = 0;
	virtual void          DrawTexturedSubRect(int x0, int y0, int x1, int y1, float texs0, float text0, float texs1, float text1) = 0;
	virtual void          DrawTexturedPolygon(int n, Vertex_t* pVertice, bool bClipVertices = true) = 0;
};
```

`src/valve_sdk/interfaces/IVDebugOverlay.h`:

```h
#pragma once

#include "../../valve_sdk/math/Vectors.hpp"
#include "../../valve_sdk/misc/platform.hpp"
#include "../../valve_sdk/math/QAngle.hpp"
#include "../../valve_sdk/math/VMatrix.hpp"
#include "../../valve_sdk/misc/Color.hpp"

class IVDebugOverlay
{
public:
	virtual void AddEntityTextOverlay(int ent_index, int line_offset, float duration, int r, int g, int b, int a, const char* format, ...) = 0;
	virtual void AddBoxOverlay(const Vector& origin, const Vector& mins, const Vector& max, QAngle const& orientation, int r, int g, int b, int a, float duration) = 0;
	virtual void AddSphereOverlay(const Vector& vOrigin, float flRadius, int nTheta, int nPhi, int r, int g, int b, int a, float flDuration) = 0;
	virtual void AddTriangleOverlay(const Vector& p1, const Vector& p2, const Vector& p3, int r, int g, int b, int a, bool noDepthTest, float duration) = 0;
	virtual void AddLineOverlay(const Vector& origin, const Vector& dest, int r, int g, int b, bool noDepthTest, float duration) = 0;
	virtual void AddTextOverlay(const Vector& origin, float duration, const char* format, ...) FMTFUNCTION(4, 5) = 0;
	virtual void AddTextOverlay(const Vector& origin, int line_offset, float duration, const char* format, ...) FMTFUNCTION(5, 6) = 0;
	virtual void AddScreenTextOverlay(float flXPos, float flYPos, float flDuration, int r, int g, int b, int a, const char* text) = 0;
	virtual void AddSweptBoxOverlay(const Vector& start, const Vector& end, const Vector& mins, const Vector& max, const QAngle& angles, int r, int g, int b, int a, float flDuration) = 0;
	virtual void AddGridOverlay(const Vector& origin) = 0;
	virtual void AddCoordFrameOverlay(const matrix3x4_t& frame, float flScale, int vColorTable[3][3] = NULL) = 0;
	virtual int  ScreenPosition(const Vector& point, Vector& screen) = 0;
	virtual int  ScreenPosition(float flXPos, float flYPos, Vector& screen) = 0;
	virtual void* GetFirst() = 0;
	virtual void* GetNext(void* current) = 0;
	virtual void ClearDeadOverlays() = 0;
	virtual void ClearAllOverlays() = 0;
	virtual void AddTextOverlayRGB(const Vector& origin, int line_offset, float duration, float r, float g, float b, float alpha, const char* format, ...) FMTFUNCTION(9, 10) = 0;
	virtual void AddTextOverlayRGB(const Vector& origin, int line_offset, float duration, int r, int g, int b, int a, const char* format, ...) FMTFUNCTION(9, 10) = 0;
	virtual void AddLineOverlayAlpha(const Vector& origin, const Vector& dest, int r, int g, int b, int a, bool noDepthTest, float duration) = 0;
	virtual void AddBoxOverlay2(const Vector& origin, const Vector& mins, const Vector& max, QAngle const& orientation, const Color& faceColor, const Color& edgeColor, float duration) = 0;
	virtual void AddLineOverlay(const Vector& origin, const Vector& dest, int r, int g, int b, int a, float thickness, float duration) = 0;
	virtual void PurgeTextOverlays() = 0;
	virtual void AddCapsuleOverlay(const Vector& vStart, const Vector& vEnd, const float& flRadius, int r, int g, int b, int a, float flDuration) = 0;
};

```

`src/valve_sdk/interfaces/IVEngineClient.hpp`:

```hpp
#pragma once

#include "../math/Vectors.hpp"
#include "../math/QAngle.hpp"
#include "../math/VMatrix.hpp"

#define FLOW_OUTGOING    0
#define FLOW_INCOMING    1

class KeyValues;

typedef struct player_info_s
{
	__int64         unknown;            //0x0000
	union
	{
		__int64       steamID64;          //0x0008 - SteamID64
		struct
		{
			__int32     xuid_low;
			__int32     xuid_high;
		};
	};
	char            szName[128];        //0x0010 - Player Name
	int             userId;             //0x0090 - Unique Server Identifier
	char            szSteamID[20];      //0x0094 - STEAM_X:Y:Z
	char            pad_0x00A8[0x10];   //0x00A8
	unsigned long   iSteamID;           //0x00B8 - SteamID
	char            szFriendsName[128];
	bool            fakeplayer;
	bool            ishltv;
	unsigned int    customfiles[4];
	unsigned char   filesdownloaded;
} player_info_t;

class INetChannelInfo
{
public:
	virtual const char* GetName(void) const = 0;	// get channel name
	virtual const char* GetAddress(void) const = 0; // get channel IP address as string
	virtual float		GetTime(void) const = 0;	// current net time
	virtual float		GetTimeConnected(void) const = 0;	// get connection time in seconds
	virtual int			GetBufferSize(void) const = 0;	// netchannel packet history size
	virtual int			GetDataRate(void) const = 0; // send data rate in byte/sec
	virtual bool		IsLoopback(void) const = 0;	// true if loopback channel
	virtual bool		IsTimingOut(void) const = 0;	// true if timing out
	virtual bool		IsPlayback(void) const = 0;	// true if demo playback
	virtual float		GetLatency(int flow) const = 0;	 // current latency (RTT), more accurate but jittering
	virtual float		GetAvgLatency(int flow) const = 0; // average packet latency in seconds
	virtual float		GetAvgLoss(int flow) const = 0;	 // avg packet loss[0..1]
	virtual float		GetAvgChoke(int flow) const = 0;	 // avg packet choke[0..1]
	virtual float		GetAvgData(int flow) const = 0;	 // data flow in bytes/sec
	virtual float		GetAvgPackets(int flow) const = 0; // avg packets/sec
	virtual int			GetTotalData(int flow) const = 0;	 // total flow in/out in bytes
	virtual int			GetSequenceNr(int flow) const = 0;	// last send seq number
	virtual bool		IsValidPacket(int flow, int frame_number) const = 0; // true if packet was not lost/dropped/chocked/flushed
	virtual float		GetPacketTime(int flow, int frame_number) const = 0; // time when packet was send
	virtual int			GetPacketBytes(int flow, int frame_number, int group) const = 0; // group size of this packet
	virtual bool		GetStreamProgress(int flow, int* received, int* total) const = 0;  // TCP progress if transmitting
	virtual float		GetTimeSinceLastReceived(void) const = 0;	// get time since last recieved packet in seconds
	virtual	float		GetCommandInterpolationAmount(int flow, int frame_number) const = 0;
	virtual void		GetPacketResponseLatency(int flow, int frame_number, int* pnLatencyMsecs, int* pnChoke) const = 0;
	virtual void		GetRemoteFramerate(float* pflFrameTime, float* pflFrameTimeStdDeviation) const = 0;
	virtual float		GetTimeoutSeconds() const = 0;
};

class IVEngineClient
{
public:
	void GetScreenSize(int& width, int& height)
	{
		return CallVFunction<void(__thiscall*)(void*, int&, int&)>(this, 5)(this, width, height);
	}

	void ClientCmd(const char* szCmdString)
	{
		return CallVFunction<void(__thiscall*)(void*, const char*)>(this, 7)(this, szCmdString);
	}

	player_info_t GetPlayerInfo(int ent_num)
	{
		player_info_t info;
		CallVFunction<bool(__thiscall*)(void*, int, player_info_t*)>(this, 8)(this, ent_num, &info);

		return info;
	}

	int GetPlayerForUserID(int userID)
	{
		return CallVFunction<int(__thiscall*)(void*, int)>(this, 9)(this, userID);
	}

	bool IsConsoleVisible()
	{
		return CallVFunction<bool(__thiscall*)(void*)>(this, 11)(this);
	}

	int GetLocalPlayer()
	{
		return CallVFunction<int(__thiscall*)(void*)>(this, 12)(this);
	}

	void GetViewAngles(QAngle& va)
	{
		return CallVFunction<void(__thiscall*)(void*, QAngle&)>(this, 18)(this, va);
	}

	void SetViewAngles(QAngle& va)
	{
		CallVFunction<void(__thiscall*)(void*, QAngle&)>(this, 19)(this, va);
	}

	int GetMaxClients()
	{
		return CallVFunction<int(__thiscall*)(void*)>(this, 20)(this);
	}

	bool IsInGame()
	{
		return CallVFunction<bool(__thiscall*)(void*)>(this, 26)(this);
	}

	bool IsConnected()
	{
		return CallVFunction<bool(__thiscall*)(void*)>(this, 27)(this);
	}

	bool IsDrawingLoadingImage()
	{
		return CallVFunction<bool(__thiscall*)(void*)>(this, 28)(this);
	}

	const VMatrix& WorldToScreenMatrix()
	{
		return CallVFunction<const VMatrix & (__thiscall*)(void*)>(this, 37)(this);
	}

	const VMatrix& WorldToViewMatrix()
	{
		return CallVFunction<const VMatrix & (__thiscall*)(void*)>(this, 38)(this);
	}

	char const* GetLevelName()
	{
		return CallVFunction<char const* (__thiscall*)(void*)>(this, 52)(this);
	}

	char const* GetLevelNameShort()
	{
		return CallVFunction<char const* (__thiscall*)(void*)>(this, 53)(this);
	}

	char const* GetMapGroupName()
	{
		return CallVFunction<char const* (__thiscall*)(void*)>(this, 54)(this);
	}

	INetChannelInfo* GetNetChannelInfo()
	{
		return CallVFunction<INetChannelInfo * (__thiscall*)(void*)>(this, 78)(this);
	}

	bool IsPlayingDemo()
	{
		return CallVFunction<bool(__thiscall*)(void*)>(this, 82)(this);
	}

	bool IsTakingScreenshot()
	{
		return CallVFunction<bool(__thiscall*)(void*)>(this, 92)(this);
	}

	const char* GetProductVersionString()
	{
		return CallVFunction<const char* (__thiscall*)(void*)>(this, 105)(this);
	}

	void ClientCmd_Unrestricted(const char* command, const bool delayed = false)
	{
		return CallVFunction<void(__thiscall*)(void*, const char*, bool)>(this, 114)(this, command, delayed);
	}

	bool IsVoiceRecording()
	{
		return CallVFunction<bool(__thiscall*)(void*)>(this, 224)(this);
	}
};
```

`src/valve_sdk/interfaces/IVModelInfo.h`:

```h
#pragma once

class IVModelInfo
{
public:
	virtual                                 ~IVModelInfo(void) {}
	virtual const model_t* GetModel(int modelindex) const = 0;
	virtual int                             GetModelIndex(const char* name) const = 0;
	virtual const char* GetModelName(const model_t* model) const = 0;

	studiohdr_t* GetStudiomodel(const model_t* mod)
	{
		return CallVFunction<studiohdr_t * (__thiscall*)(void*, const model_t*)>(this, 32)(this, mod);
	}
};
```

`src/valve_sdk/interfaces/IVModelRender.h`:

```h
#pragma once

struct ModelRenderInfo_t
{
	Vector                  origin;
	QAngle                  angles;
	char                    pad[0x4];
	IClientRenderable* pRenderable;
	const model_t* pModel;
	const matrix3x4_t* pModelToWorld;
	const matrix3x4_t* pLightingOffset;
	const Vector* pLightingOrigin;
	int                     flags;
	int                     entity_index;
	int                     skin;
	int                     body;
	int                     hitboxset;
	ModelInstanceHandle_t   instance;
};

typedef void* StudioDecalHandle_t;
typedef int OverrideType_t;
struct ColorMeshInfo_t;

struct DrawModelState_t
{
	studiohdr_t* m_pStudioHdr;
	studiohwdata_t* m_pStudioHWData;
	IClientRenderable* m_pRenderable;
	const matrix3x4_t* m_pModelToWorld;
	StudioDecalHandle_t     m_decals;
	int                     m_drawFlags;
	int                     m_lod;
};

class IVModelRender
{
public:
	virtual int DrawModel(int flags, IClientRenderable* pRenderable, ModelInstanceHandle_t instance, int entity_index, const model_t* model, Vector const& origin, QAngle const& angles, int skin, int body, int hitboxset, const matrix3x4_t* modelToWorld = NULL, const matrix3x4_t* pLightingOffset = NULL) = 0;
	virtual void ForcedMaterialOverride(IMaterial* newMaterial, int nOverrideType = 0, int nOverrides = 0) = 0;
	virtual bool IsForcedMaterialOverride(void) = 0;
};
```

`src/valve_sdk/interfaces/IVRenderView.h`:

```h
#pragma once

class IVRenderView
{
public:
	void SetBlend(float blend)
	{
		CallVFunction<void(__thiscall*)(void*, float)>(this, 4)(this, blend);
	}

	void SetColorModulation(float const* blend)
	{
		CallVFunction<void(__thiscall*)(void*, float const*)>(this, 6)(this, blend);
	}

	inline void SetColorModulation(float r, float g, float b)
	{
		float clr[3] = { r, g, b };
		SetColorModulation(clr);
	}
};

```

`src/valve_sdk/interfaces/IViewRender.hpp`:

```hpp
#pragma once

enum DrawFlags_t
{
	DF_RENDER_REFRACTION = 0x1,
	DF_RENDER_REFLECTION = 0x2,
	DF_CLIP_Z = 0x4,
	DF_CLIP_BELOW = 0x8,
	DF_RENDER_UNDERWATER = 0x10,
	DF_RENDER_ABOVEWATER = 0x20,
	DF_RENDER_WATER = 0x40,
	DF_UNUSED1 = 0x100,
	DF_WATERHEIGHT = 0x200,
	DF_UNUSED2 = 0x400,
	DF_DRAWSKYBOX = 0x800,
	DF_FUDGE_UP = 0x1000,
	DF_DRAW_ENTITITES = 0x2000,
	DF_UNUSED3 = 0x4000,
	DF_UNUSED4 = 0x8000,
	DF_UNUSED5 = 0x10000,
	DF_SAVEGAMESCREENSHOT = 0x20000,
	DF_CLIP_SKYBOX = 0x40000,
	DF_SHADOW_DEPTH_MAP = 0x100000	// Currently rendering a shadow depth map
};

//-----------------------------------------------------------------------------
// Purpose: View setup and rendering
//-----------------------------------------------------------------------------
class CViewSetup;
class c_base_entity;
struct vrect_t;
class c_base_view_model;
class IMaterial;

enum ClearFlags_t
{
	VIEW_CLEAR_COLOR = 0x1,
	VIEW_CLEAR_DEPTH = 0x2,
	VIEW_CLEAR_FULL_TARGET = 0x4,
	VIEW_NO_DRAW = 0x8,
	VIEW_CLEAR_OBEY_STENCIL = 0x10, // Draws a quad allowing stencil test to clear through portals
	VIEW_CLEAR_STENCIL = 0x20,
};

enum RenderViewInfo_t
{
	RENDERVIEW_UNSPECIFIED = 0,
	RENDERVIEW_DRAWVIEWMODEL = (1 << 0),
	RENDERVIEW_DRAWHUD = (1 << 1),
	RENDERVIEW_SUPPRESSMONITORRENDERING = (1 << 2),
};

class IViewRender
{
public:
};
```

`src/valve_sdk/interfaces/IViewRenderBeams.h`:

```h
#pragma once

class C_Beam;
class Beam_t;

//---------------------------------------------------------------------------—
// Purpose: Popcorn trail for Beam Follow rendering...
//---------------------------------------------------------------------------—
enum
{
	FBEAM_STARTENTITY = 0x00000001,
	FBEAM_ENDENTITY = 0x00000002,
	FBEAM_FADEIN = 0x00000004,
	FBEAM_FADEOUT = 0x00000008,
	FBEAM_SINENOISE = 0x00000010,
	FBEAM_SOLID = 0x00000020,
	FBEAM_SHADEIN = 0x00000040,
	FBEAM_SHADEOUT = 0x00000080,
	FBEAM_ONLYNOISEONCE = 0x00000100, // Only calculate our noise once
	FBEAM_NOTILE = 0x00000200,
	FBEAM_USE_HITBOXES = 0x00000400, // Attachment indices represent hitbox indices instead when this is set.
	FBEAM_STARTVISIBLE = 0x00000800, // Has this client actually seen this beam's start entity yet?
	FBEAM_ENDVISIBLE = 0x00001000, // Has this client actually seen this beam's end entity yet?
	FBEAM_ISACTIVE = 0x00002000,
	FBEAM_FOREVER = 0x00004000,
	FBEAM_HALOBEAM = 0x00008000, // When drawing a beam with a halo, don't ignore the segments and endwidth
	FBEAM_REVERSED = 0x00010000,
	NUM_BEAM_FLAGS = 17 // KEEP THIS UPDATED!
};
enum
{
	TE_BEAMPOINTS = 0x00, // beam effect between two points
	TE_SPRITE = 0x01, // additive sprite, plays 1 cycle
	TE_BEAMDISK = 0x02, // disk that expands to max radius over lifetime
	TE_BEAMCYLINDER = 0x03, // cylinder that expands to max radius over lifetime
	TE_BEAMFOLLOW = 0x04, // create a line of decaying beam segments until entity stops moving
	TE_BEAMRING = 0x05, // connect a beam ring to two entities
	TE_BEAMSPLINE = 0x06,
	TE_BEAMRINGPOINT = 0x07,
	TE_BEAMLASER = 0x08, // Fades according to viewpoint
	TE_BEAMTESLA = 0x09,
};
struct BeamTrail_t
{
	// NOTE: Don't add user defined fields except after these four fields.
	BeamTrail_t* next;
	float die;
	Vector org;
	Vector vel;
};

//---------------------------------------------------------------------------—
// Data type for beams.
//---------------------------------------------------------------------------—
struct BeamInfo_t
{
	int m_nType;

	// Entities
	c_base_entity* m_pStartEnt;
	int m_nStartAttachment;
	c_base_entity* m_pEndEnt;
	int m_nEndAttachment;

	// Points
	Vector m_vecStart;
	Vector m_vecEnd;

	int m_nModelIndex;
	const char* m_pszModelName;

	int m_nHaloIndex;
	const char* m_pszHaloName;
	float m_flHaloScale;

	float m_flLife;
	float m_flWidth;
	float m_flEndWidth;
	float m_flFadeLength;
	float m_flAmplitude;

	float m_flBrightness;
	float m_flSpeed;

	int m_nStartFrame;
	float m_flFrameRate;

	float m_flRed;
	float m_flGreen;
	float m_flBlue;

	bool m_bRenderable;

	int m_nSegments;

	int m_nFlags;

	// Rings
	Vector m_vecCenter;
	float m_flStartRadius;
	float m_flEndRadius;

	BeamInfo_t()
	{
		m_nType = TE_BEAMPOINTS;
		m_nSegments = -1;
		m_pszModelName = NULL;
		m_pszHaloName = NULL;
		m_nModelIndex = -1;
		m_nHaloIndex = -1;
		m_bRenderable = true;
		m_nFlags = 0;
	}
};

//---------------------------------------------------------------------------—
// Purpose: Declare client .dll beam entity interface
//---------------------------------------------------------------------------—
class IViewRenderBeams
{
public:
	virtual void InitBeams(void) = 0;
	virtual void ShutdownBeams(void) = 0;
	virtual void ClearBeams(void) = 0;

	// Updates the state of the temp ent beams
	virtual void UpdateTempEntBeams() = 0;

	virtual void DrawBeam(C_Beam* pbeam, ITraceFilter* pEntityBeamTraceFilter = NULL) = 0;
	virtual void DrawBeam(Beam_t* pbeam) = 0;

	virtual void KillDeadBeams(c_base_entity* pEnt) = 0;

	// New interfaces!
	virtual Beam_t* CreateBeamEnts(BeamInfo_t& beamInfo) = 0;
	virtual Beam_t* CreateBeamEntPoint(BeamInfo_t& beamInfo) = 0;
	virtual Beam_t* CreateBeamPoints(BeamInfo_t& beamInfo) = 0;
	virtual Beam_t* CreateBeamRing(BeamInfo_t& beamInfo) = 0;
	virtual Beam_t* CreateBeamRingPoint(BeamInfo_t& beamInfo) = 0;
	virtual Beam_t* CreateBeamCirclePoints(BeamInfo_t& beamInfo) = 0;

	virtual Beam_t* CreateBeamFollow(BeamInfo_t& beamInfo) = 0;

	virtual void FreeBeam(Beam_t* pBeam) = 0;
	virtual void UpdateBeamInfo(Beam_t* pBeam, BeamInfo_t& beamInfo) = 0;

	// These will go away!
	virtual void CreateBeamEnts(int startEnt, int endEnt, int modelIndex, int haloIndex, float haloScale,
		float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
		float brightness, float speed, int startFrame,
		float framerate, float r, float g, float b, int type = -1) = 0;
	virtual void CreateBeamEntPoint(int nStartEntity, const Vector* pStart, int nEndEntity, const Vector* pEnd,
		int modelIndex, int haloIndex, float haloScale,
		float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
		float brightness, float speed, int startFrame,
		float framerate, float r, float g, float b) = 0;
	virtual void CreateBeamPoints(Vector& start, Vector& end, int modelIndex, int haloIndex, float haloScale,
		float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
		float brightness, float speed, int startFrame,
		float framerate, float r, float g, float b) = 0;
	virtual void CreateBeamRing(int startEnt, int endEnt, int modelIndex, int haloIndex, float haloScale,
		float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
		float brightness, float speed, int startFrame,
		float framerate, float r, float g, float b, int flags = 0) = 0;
	virtual void CreateBeamRingPoint(const Vector& center, float start_radius, float end_radius, int modelIndex, int haloIndex, float haloScale,
		float life, float width, float m_nEndWidth, float m_nFadeLength, float amplitude,
		float brightness, float speed, int startFrame,
		float framerate, float r, float g, float b, int flags = 0) = 0;
	virtual void CreateBeamCirclePoints(int type, Vector& start, Vector& end,
		int modelIndex, int haloIndex, float haloScale, float life, float width,
		float m_nEndWidth, float m_nFadeLength, float amplitude, float brightness, float speed,
		int startFrame, float framerate, float r, float g, float b) = 0;
	virtual void CreateBeamFollow(int startEnt, int modelIndex, int haloIndex, float haloScale,
		float life, float width, float m_nEndWidth, float m_nFadeLength, float r, float g, float b,
		float brightness) = 0;
};
```

`src/valve_sdk/interfaces/ServerClass.h`:

```h
#pragma once

#include "../../valve_sdk/misc/Enums.hpp"
#include "../../valve_sdk/misc/vfunc.hpp"

struct ServerClass
{
	char* m_pNetworkName;
	void* m_pTable; //SendTable*
	ServerClass* m_pNext;
	EClassId m_ClassID;
	int m_InstanceBaselineIndex;
};

struct ServerClassDLL
{
	ServerClass* GetAllClasses()
	{
		return CallVFunction<ServerClass* (__thiscall*)(void*)>(this, 10)(this);
	}
};

```

`src/valve_sdk/kit_parser.cpp`:

```cpp
#include "kit_parser.hpp"
#include "../helpers/utils.h"

#include <algorithm>

std::vector<game_data::paint_kit> game_data::skin_kits;
std::vector<game_data::paint_kit> game_data::glove_kits;

auto game_data::initialize_kits() -> void
{
	static const auto V_UCS2ToUTF8 = static_cast<int(*)(const wchar_t* ucs2, char* utf8, int len)>(utils::get_export("vstdlib.dll", "V_UCS2ToUTF8"));

	const auto sig_address = utils::pattern_scan("client.dll", "E8 ? ? ? ? FF 76 0C 8D 48 04");

	const auto item_system_offset = *reinterpret_cast<std::int32_t*>(sig_address + 1);

	const auto item_system_fn = reinterpret_cast<CCStrike15ItemSystem* (*)()>(sig_address + 5 + item_system_offset);

	const auto item_schema = reinterpret_cast<CCStrike15ItemSchema*>(std::uintptr_t(item_system_fn()) + sizeof(void*));

	// Dump paint kits
	{
		const auto get_paint_kit_definition_offset = *reinterpret_cast<std::int32_t*>(sig_address + 11 + 1);

		const auto get_paint_kit_definition_fn = reinterpret_cast<CPaintKit*(__thiscall*)(CCStrike15ItemSchema*, int)>(sig_address + 11 + 5 + get_paint_kit_definition_offset);

		const auto start_element_offset = *reinterpret_cast<std::intptr_t*>(std::uintptr_t(get_paint_kit_definition_fn) + 8 + 2);

		const auto head_offset = start_element_offset - 12;

		const auto map_head = reinterpret_cast<Head_t<int, CPaintKit*>*>(std::uintptr_t(item_schema) + head_offset);
		
		char name[256];
		for(auto i = 0; i <= map_head->last_element; ++i)
		{
			const auto paint_kit = map_head->memory[i].value;

			if (paint_kit->id == 9001)
			   continue;

			const auto wide_name = g::localize->Find(paint_kit->item_name.buffer + 1);
			
			V_UCS2ToUTF8(wide_name, name, sizeof(name));

			static auto rename_skin = [&](const char* new_name, const int& skin_id)
			{
				if (paint_kit->id == skin_id)
					sprintf(name, "%s", new_name);
			};

			rename_skin("Default", 0);
			rename_skin("Dragon King", 400);
			rename_skin("Redline (AK47)", 282);
			rename_skin("Elite Build (AK47)", 422);
			rename_skin("Hyper Beast (AWP)", 475);
			rename_skin("Asiimov (AWP)", 279);
			rename_skin("Elite Build (AWP)", 525);
			rename_skin("Redline (AWP)", 259);
			rename_skin("Fever Dream (AWP)", 640);
			rename_skin("Capillary (AWP)", 943);
			rename_skin("Blaze (Deagle)", 37);
			rename_skin("Asiimov (AK47)", 801);
			rename_skin("Asiimov (P90)", 359);
			rename_skin("Asiimov (M4A4)", 255);
			rename_skin("Asiimov (P250)", 551);
			
			if (paint_kit->id < 10000)
				game_data::skin_kits.emplace_back(paint_kit->id, name, paint_kit->rarity);
			else
				game_data::glove_kits.emplace_back(paint_kit->id, name);
		}

		std::sort(game_data::skin_kits.begin()+1, game_data::skin_kits.end());
		std::sort(game_data::glove_kits.begin(), game_data::glove_kits.end());
	}
}
```

`src/valve_sdk/kit_parser.hpp`:

```hpp
#pragma once

#include <vector>
#include <string>
#include <iostream>

namespace game_data
{
	struct paint_kit
	{
		int id;
		std::string name;
		int rarity;
	
		paint_kit(int id, const std::string& name)
		{
			this->id = id;
			this->name = name;
		}

		paint_kit(int id, const std::string& name, int rarity)
		{
			this->id = id;
			this->name = name;
			this->rarity = rarity;
		}

		auto operator < (const paint_kit& other) const -> bool
		{
			return name < other.name;
		}
	};

	extern std::vector<paint_kit> skin_kits;
	extern std::vector<paint_kit> glove_kits;

	extern auto initialize_kits() -> void;
}

class CCStrike15ItemSchema;
class CCStrike15ItemSystem;

template <typename Key, typename Value>
struct Node_t
{
	int previous_id;		//0x0000
	int next_id;			//0x0004
	void* _unknown_ptr;		//0x0008
	int _unknown;			//0x000C
	Key key;				//0x0010
	Value value;			//0x0014
};

template <typename Key, typename Value>
struct Head_t
{
	Node_t<Key, Value>* memory;		//0x0000
	int allocation_count;			//0x0004
	int grow_size;					//0x0008
	int start_element;				//0x000C
	int next_available;				//0x0010
	int _unknown;					//0x0014
	int last_element;				//0x0018
}; //Size=0x001C

// could use CUtlString but this is just easier and CUtlString isn't needed anywhere else
struct String_t
{
	char* buffer;	//0x0000
	int capacity;	//0x0004
	int grow_size;	//0x0008
	int length;		//0x000C
}; //Size=0x0010

struct CPaintKit
{
	int id;

	String_t name;
	String_t description_string;
	String_t item_name;
	String_t sameNameFamilyAggregate;
	String_t pattern;
	String_t normal;
	String_t logo_material;

	bool base_diffuse;
	int rarity;
};

struct CStickerKit
{
	int id;

	int item_rarity;

	String_t name;
	String_t description;
	String_t item_name;
	String_t material_name;
	String_t image_inventory;

	int tournament_event_id;
	int tournament_team_id;
	int tournament_player_id;
	bool is_custom_sticker_material;

	float rotate_end;
	float rotate_start;

	float scale_min;
	float scale_max;

	float wear_min;
	float wear_max;

	String_t image_inventory2;
	String_t image_inventory_large;

	std::uint32_t pad0[4];
};


```

`src/valve_sdk/math/QAngle.hpp`:

```hpp
#pragma once

#include <algorithm>

class QAngle
{
public:
	QAngle(void)
	{
		Init();
	}
	QAngle(float X, float Y, float Z)
	{
		Init(X, Y, Z);
	}
	QAngle(const float* clr)
	{
		Init(clr[0], clr[1], clr[2]);
	}

	void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f)
	{
		pitch = ix;
		yaw = iy;
		roll = iz;
	}

	float operator[](int i) const
	{
		return ((float*)this)[i];
	}
	float& operator[](int i)
	{
		return ((float*)this)[i];
	}

	QAngle& operator+=(const QAngle& v)
	{
		pitch += v.pitch; yaw += v.yaw; roll += v.roll;
		return *this;
	}
	QAngle& operator-=(const QAngle& v)
	{
		pitch -= v.pitch; yaw -= v.yaw; roll -= v.roll;
		return *this;
	}
	QAngle& operator*=(float fl)
	{
		pitch *= fl;
		yaw *= fl;
		roll *= fl;
		return *this;
	}
	QAngle& operator*=(const QAngle& v)
	{
		pitch *= v.pitch;
		yaw *= v.yaw;
		roll *= v.roll;
		return *this;
	}
	QAngle& operator/=(const QAngle& v)
	{
		pitch /= v.pitch;
		yaw /= v.yaw;
		roll /= v.roll;
		return *this;
	}
	QAngle& operator+=(float fl)
	{
		pitch += fl;
		yaw += fl;
		roll += fl;
		return *this;
	}
	QAngle& operator/=(float fl)
	{
		pitch /= fl;
		yaw /= fl;
		roll /= fl;
		return *this;
	}
	QAngle& operator-=(float fl)
	{
		pitch -= fl;
		yaw -= fl;
		roll -= fl;
		return *this;
	}

	QAngle& operator=(const QAngle& vOther)
	{
		pitch = vOther.pitch; yaw = vOther.yaw; roll = vOther.roll;
		return *this;
	}

	QAngle operator-(void) const
	{
		return QAngle(-pitch, -yaw, -roll);
	}
	QAngle operator+(const QAngle& v) const
	{
		return QAngle(pitch + v.pitch, yaw + v.yaw, roll + v.roll);
	}
	QAngle operator-(const QAngle& v) const
	{
		return QAngle(pitch - v.pitch, yaw - v.yaw, roll - v.roll);
	}
	QAngle operator*(float fl) const
	{
		return QAngle(pitch * fl, yaw * fl, roll * fl);
	}
	QAngle operator*(const QAngle& v) const
	{
		return QAngle(pitch * v.pitch, yaw * v.yaw, roll * v.roll);
	}
	QAngle operator/(float fl) const
	{
		return QAngle(pitch / fl, yaw / fl, roll / fl);
	}
	QAngle operator/(const QAngle& v) const
	{
		return QAngle(pitch / v.pitch, yaw / v.yaw, roll / v.roll);
	}

	float Length() const
	{
		return sqrt(pitch * pitch + yaw * yaw + roll * roll);
	}
	float LengthSqr(void) const
	{
		return (pitch * pitch + yaw * yaw + roll * roll);
	}
	bool IsZero(float tolerance = 0.01f) const
	{
		return (pitch > -tolerance && pitch < tolerance &&
			yaw > -tolerance && yaw < tolerance &&
			roll > -tolerance && roll < tolerance);
	}
	void Normalize()
	{
		QAngle angles = *this;

		for (auto i = 0; i < 3; i++) 
		{
			while (angles[i] < -180.0f) 
				angles[i] += 360.0f;

			while (angles[i] > 180.0f) 
				angles[i] -= 360.0f;
		}

		*this = angles;
	}
	
	void Clamp()
	{
		QAngle angle = *this;

		if (!std::isfinite(angle.pitch))
			angle.pitch = 0.f;

		if (!std::isfinite(angle.yaw))
			angle.yaw = 0.f;

		if (!std::isfinite(angle.roll))
			angle.roll = 0.f;

		angle.pitch = std::clamp(angle.pitch, -89.f, 89.f);
		angle.yaw = std::clamp(std::remainder(angle.yaw, 360.f), -180.f, 180.f);
		angle.roll = 0.f;

		*this = angle;
	}

	void NormalizeClamp()
	{
		QAngle angles = *this;

		angles.Normalize();
		angles.Clamp();

		*this = angles;
	}

	float pitch;
	float yaw;
	float roll;
};

inline QAngle operator*(float lhs, const QAngle& rhs)
{
	return rhs * lhs;
}
inline QAngle operator/(float lhs, const QAngle& rhs)
{
	return rhs / lhs;
}
```

`src/valve_sdk/math/VMatrix.cpp`:

```cpp
#include "VMatrix.hpp"

//-----------------------------------------------------------------------------
// VMatrix inlines.
//-----------------------------------------------------------------------------
inline VMatrix::VMatrix()
{
}

inline VMatrix::VMatrix(
	float m00, float m01, float m02, float m03,
	float m10, float m11, float m12, float m13,
	float m20, float m21, float m22, float m23,
	float m30, float m31, float m32, float m33)
{
	Init(
		m00, m01, m02, m03,
		m10, m11, m12, m13,
		m20, m21, m22, m23,
		m30, m31, m32, m33
	);
}

inline VMatrix::VMatrix(const matrix3x4_t& matrix3x4)
{
	Init(matrix3x4);
}

//-----------------------------------------------------------------------------
// Creates a matrix where the X axis = forward
// the Y axis = left, and the Z axis = up
//-----------------------------------------------------------------------------
inline VMatrix::VMatrix(const Vector& xAxis, const Vector& yAxis, const Vector& zAxis)
{
	Init(
		xAxis.x, yAxis.x, zAxis.x, 0.0f,
		xAxis.y, yAxis.y, zAxis.y, 0.0f,
		xAxis.z, yAxis.z, zAxis.z, 0.0f,
		0.0f, 0.0f, 0.0f, 1.0f
	);
}

inline void VMatrix::Init(
	float m00, float m01, float m02, float m03,
	float m10, float m11, float m12, float m13,
	float m20, float m21, float m22, float m23,
	float m30, float m31, float m32, float m33
)
{
	m[0][0] = m00;
	m[0][1] = m01;
	m[0][2] = m02;
	m[0][3] = m03;

	m[1][0] = m10;
	m[1][1] = m11;
	m[1][2] = m12;
	m[1][3] = m13;

	m[2][0] = m20;
	m[2][1] = m21;
	m[2][2] = m22;
	m[2][3] = m23;

	m[3][0] = m30;
	m[3][1] = m31;
	m[3][2] = m32;
	m[3][3] = m33;
}

//-----------------------------------------------------------------------------
// Initialize from a 3x4
//-----------------------------------------------------------------------------
inline void VMatrix::Init(const matrix3x4_t& matrix3x4)
{
	memcpy(m, matrix3x4.Base(), sizeof(matrix3x4_t));

	m[3][0] = 0.0f;
	m[3][1] = 0.0f;
	m[3][2] = 0.0f;
	m[3][3] = 1.0f;
}

//-----------------------------------------------------------------------------
// Vector3DMultiplyPosition treats src2 as if it's a point (adds the translation)
//-----------------------------------------------------------------------------
// NJS: src2 is passed in as a full vector rather than a reference to prevent the need
// for 2 branches and a potential copy in the body.  (ie, handling the case when the src2
// reference is the same as the dst reference ).
inline void Vector3DMultiplyPosition(const VMatrix& src1, const Vector& src2, Vector& dst)
{
	dst[0] = src1[0][0] * src2.x + src1[0][1] * src2.y + src1[0][2] * src2.z + src1[0][3];
	dst[1] = src1[1][0] * src2.x + src1[1][1] * src2.y + src1[1][2] * src2.z + src1[1][3];
	dst[2] = src1[2][0] * src2.x + src1[2][1] * src2.y + src1[2][2] * src2.z + src1[2][3];
}

//-----------------------------------------------------------------------------
// Methods related to the basis vectors of the matrix
//-----------------------------------------------------------------------------

inline Vector VMatrix::GetForward() const
{
	return Vector(m[0][0], m[1][0], m[2][0]);
}

inline Vector VMatrix::GetLeft() const
{
	return Vector(m[0][1], m[1][1], m[2][1]);
}

inline Vector VMatrix::GetUp() const
{
	return Vector(m[0][2], m[1][2], m[2][2]);
}

inline void VMatrix::SetForward(const Vector& vForward)
{
	m[0][0] = vForward.x;
	m[1][0] = vForward.y;
	m[2][0] = vForward.z;
}

inline void VMatrix::SetLeft(const Vector& vLeft)
{
	m[0][1] = vLeft.x;
	m[1][1] = vLeft.y;
	m[2][1] = vLeft.z;
}

inline void VMatrix::SetUp(const Vector& vUp)
{
	m[0][2] = vUp.x;
	m[1][2] = vUp.y;
	m[2][2] = vUp.z;
}

inline void VMatrix::GetBasisVectors(Vector& vForward, Vector& vLeft, Vector& vUp) const
{
	vForward.Init(m[0][0], m[1][0], m[2][0]);
	vLeft.Init(m[0][1], m[1][1], m[2][1]);
	vUp.Init(m[0][2], m[1][2], m[2][2]);
}

inline void VMatrix::SetBasisVectors(const Vector& vForward, const Vector& vLeft, const Vector& vUp)
{
	SetForward(vForward);
	SetLeft(vLeft);
	SetUp(vUp);
}

//-----------------------------------------------------------------------------
// Methods related to the translation component of the matrix
//-----------------------------------------------------------------------------

inline Vector VMatrix::GetTranslation() const
{
	return Vector(m[0][3], m[1][3], m[2][3]);
}

inline Vector& VMatrix::GetTranslation(Vector& vTrans) const
{
	vTrans.x = m[0][3];
	vTrans.y = m[1][3];
	vTrans.z = m[2][3];
	return vTrans;
}

inline void VMatrix::SetTranslation(const Vector& vTrans)
{
	m[0][3] = vTrans.x;
	m[1][3] = vTrans.y;
	m[2][3] = vTrans.z;
}

//-----------------------------------------------------------------------------
// appply translation to this matrix in the input space
//-----------------------------------------------------------------------------
inline void VMatrix::PreTranslate(const Vector& vTrans)
{
	Vector tmp;
	Vector3DMultiplyPosition(*this, vTrans, tmp);
	m[0][3] = tmp.x;
	m[1][3] = tmp.y;
	m[2][3] = tmp.z;
}

//-----------------------------------------------------------------------------
// appply translation to this matrix in the output space
//-----------------------------------------------------------------------------
inline void VMatrix::PostTranslate(const Vector& vTrans)
{
	m[0][3] += vTrans.x;
	m[1][3] += vTrans.y;
	m[2][3] += vTrans.z;
}

inline const matrix3x4_t& VMatrix::As3x4() const
{
	return *((const matrix3x4_t*)this);
}

inline matrix3x4_t& VMatrix::As3x4()
{
	return *((matrix3x4_t*)this);
}

inline void VMatrix::CopyFrom3x4(const matrix3x4_t& m3x4)
{
	memcpy(m, m3x4.Base(), sizeof(matrix3x4_t));
	m[3][0] = m[3][1] = m[3][2] = 0;
	m[3][3] = 1;
}

inline void VMatrix::Set3x4(matrix3x4_t& matrix3x4) const
{
	memcpy(matrix3x4.Base(), m, sizeof(matrix3x4_t));
}

//-----------------------------------------------------------------------------
// Matrix Math operations
//-----------------------------------------------------------------------------
inline const VMatrix& VMatrix::operator+=(const VMatrix& other)
{
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			m[i][j] += other.m[i][j];
		}
	}

	return *this;
}

inline VMatrix VMatrix::operator+(const VMatrix& other) const
{
	VMatrix ret;
	for (int i = 0; i < 16; i++) {
		((float*)ret.m)[i] = ((float*)m)[i] + ((float*)other.m)[i];
	}
	return ret;
}

inline VMatrix VMatrix::operator-(const VMatrix& other) const
{
	VMatrix ret;

	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			ret.m[i][j] = m[i][j] - other.m[i][j];
		}
	}

	return ret;
}

inline VMatrix VMatrix::operator-() const
{
	VMatrix ret;
	for (int i = 0; i < 16; i++) {
		((float*)ret.m)[i] = -((float*)m)[i];
	}
	return ret;
}

//-----------------------------------------------------------------------------
// Vector transformation
//-----------------------------------------------------------------------------

inline Vector VMatrix::operator*(const Vector& vVec) const
{
	Vector vRet;
	vRet.x = m[0][0] * vVec.x + m[0][1] * vVec.y + m[0][2] * vVec.z + m[0][3];
	vRet.y = m[1][0] * vVec.x + m[1][1] * vVec.y + m[1][2] * vVec.z + m[1][3];
	vRet.z = m[2][0] * vVec.x + m[2][1] * vVec.y + m[2][2] * vVec.z + m[2][3];

	return vRet;
}

inline Vector VMatrix::VMul4x3(const Vector& vVec) const
{
	Vector vResult;
	Vector3DMultiplyPosition(*this, vVec, vResult);
	return vResult;
}

inline Vector VMatrix::VMul4x3Transpose(const Vector& vVec) const
{
	Vector tmp = vVec;
	tmp.x -= m[0][3];
	tmp.y -= m[1][3];
	tmp.z -= m[2][3];

	return Vector(
		m[0][0] * tmp.x + m[1][0] * tmp.y + m[2][0] * tmp.z,
		m[0][1] * tmp.x + m[1][1] * tmp.y + m[2][1] * tmp.z,
		m[0][2] * tmp.x + m[1][2] * tmp.y + m[2][2] * tmp.z
	);
}

inline Vector VMatrix::VMul3x3(const Vector& vVec) const
{
	return Vector(
		m[0][0] * vVec.x + m[0][1] * vVec.y + m[0][2] * vVec.z,
		m[1][0] * vVec.x + m[1][1] * vVec.y + m[1][2] * vVec.z,
		m[2][0] * vVec.x + m[2][1] * vVec.y + m[2][2] * vVec.z
	);
}

inline Vector VMatrix::VMul3x3Transpose(const Vector& vVec) const
{
	return Vector(
		m[0][0] * vVec.x + m[1][0] * vVec.y + m[2][0] * vVec.z,
		m[0][1] * vVec.x + m[1][1] * vVec.y + m[2][1] * vVec.z,
		m[0][2] * vVec.x + m[1][2] * vVec.y + m[2][2] * vVec.z
	);
}

inline void VMatrix::V3Mul(const Vector& vIn, Vector& vOut) const
{
	float rw;

	rw = 1.0f / (m[3][0] * vIn.x + m[3][1] * vIn.y + m[3][2] * vIn.z + m[3][3]);
	vOut.x = (m[0][0] * vIn.x + m[0][1] * vIn.y + m[0][2] * vIn.z + m[0][3]) * rw;
	vOut.y = (m[1][0] * vIn.x + m[1][1] * vIn.y + m[1][2] * vIn.z + m[1][3]) * rw;
	vOut.z = (m[2][0] * vIn.x + m[2][1] * vIn.y + m[2][2] * vIn.z + m[2][3]) * rw;
}

//-----------------------------------------------------------------------------
// Other random stuff
//-----------------------------------------------------------------------------
inline void VMatrix::Identity()
{
	m[0][0] = 1.0f; m[0][1] = 0.0f; m[0][2] = 0.0f; m[0][3] = 0.0f;
	m[1][0] = 0.0f; m[1][1] = 1.0f; m[1][2] = 0.0f; m[1][3] = 0.0f;
	m[2][0] = 0.0f; m[2][1] = 0.0f; m[2][2] = 1.0f; m[2][3] = 0.0f;
	m[3][0] = 0.0f; m[3][1] = 0.0f; m[3][2] = 0.0f; m[3][3] = 1.0f;
}

inline bool VMatrix::IsIdentity() const
{
	return
		m[0][0] == 1.0f && m[0][1] == 0.0f && m[0][2] == 0.0f && m[0][3] == 0.0f &&
		m[1][0] == 0.0f && m[1][1] == 1.0f && m[1][2] == 0.0f && m[1][3] == 0.0f &&
		m[2][0] == 0.0f && m[2][1] == 0.0f && m[2][2] == 1.0f && m[2][3] == 0.0f &&
		m[3][0] == 0.0f && m[3][1] == 0.0f && m[3][2] == 0.0f && m[3][3] == 1.0f;
}

inline Vector VMatrix::ApplyRotation(const Vector& vVec) const
{
	return VMul3x3(vVec);
}
```

`src/valve_sdk/math/VMatrix.hpp`:

```hpp
#pragma once

#include <limits>

#include "Vectors.hpp"
#include "QAngle.hpp"

struct cplane_t
{
	Vector normal;
	float dist;
	uint8_t type;   // for fast side tests
	uint8_t signbits;  // signx + (signy<<1) + (signz<<1)
	uint8_t pad[2];
};

class matrix3x4_t
{
public:
	matrix3x4_t() {}
	matrix3x4_t(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23)
	{
		m_flMatVal[0][0] = m00; m_flMatVal[0][1] = m01; m_flMatVal[0][2] = m02; m_flMatVal[0][3] = m03;
		m_flMatVal[1][0] = m10; m_flMatVal[1][1] = m11; m_flMatVal[1][2] = m12; m_flMatVal[1][3] = m13;
		m_flMatVal[2][0] = m20; m_flMatVal[2][1] = m21; m_flMatVal[2][2] = m22; m_flMatVal[2][3] = m23;
	}
	//-----------------------------------------------------------------------------
	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	//-----------------------------------------------------------------------------
	void Init(const Vector& xAxis, const Vector& yAxis, const Vector& zAxis, const Vector& vecOrigin)
	{
		m_flMatVal[0][0] = xAxis.x; m_flMatVal[0][1] = yAxis.x; m_flMatVal[0][2] = zAxis.x; m_flMatVal[0][3] = vecOrigin.x;
		m_flMatVal[1][0] = xAxis.y; m_flMatVal[1][1] = yAxis.y; m_flMatVal[1][2] = zAxis.y; m_flMatVal[1][3] = vecOrigin.y;
		m_flMatVal[2][0] = xAxis.z; m_flMatVal[2][1] = yAxis.z; m_flMatVal[2][2] = zAxis.z; m_flMatVal[2][3] = vecOrigin.z;
	}

	//-----------------------------------------------------------------------------
	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	//-----------------------------------------------------------------------------
	matrix3x4_t(const Vector& xAxis, const Vector& yAxis, const Vector& zAxis, const Vector& vecOrigin)
	{
		Init(xAxis, yAxis, zAxis, vecOrigin);
	}

	inline void SetOrigin(Vector const& p)
	{
		m_flMatVal[0][3] = p.x;
		m_flMatVal[1][3] = p.y;
		m_flMatVal[2][3] = p.z;
	}

	inline void Invalidate(void)
	{
		for (int i = 0; i < 3; i++) {
			for (int j = 0; j < 4; j++) {
				m_flMatVal[i][j] = std::numeric_limits<float>::infinity();;
			}
		}
	}

	Vector GetXAxis()  const { return at(0); }
	Vector GetYAxis()  const { return at(1); }
	Vector GetZAxis()  const { return at(2); }
	Vector GetOrigin() const { return at(3); }

	Vector at(int i) const { return Vector{ m_flMatVal[0][i], m_flMatVal[1][i], m_flMatVal[2][i] }; }

	float* operator[](int i) { return m_flMatVal[i]; }
	const float* operator[](int i) const { return m_flMatVal[i]; }
	float* Base() { return &m_flMatVal[0][0]; }
	const float* Base() const { return &m_flMatVal[0][0]; }

	float m_flMatVal[3][4];
};
class VMatrix
{
public:

	VMatrix();
	VMatrix(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23,
		float m30, float m31, float m32, float m33
	);

	// Creates a matrix where the X axis = forward
	// the Y axis = left, and the Z axis = up
	VMatrix(const Vector& forward, const Vector& left, const Vector& up);

	// Construct from a 3x4 matrix
	VMatrix(const matrix3x4_t& matrix3x4);

	// Set the values in the matrix.
	void  Init(
		float m00, float m01, float m02, float m03,
		float m10, float m11, float m12, float m13,
		float m20, float m21, float m22, float m23,
		float m30, float m31, float m32, float m33
	);

	// Initialize from a 3x4
	void  Init(const matrix3x4_t& matrix3x4);

	// array access
	inline float* operator[](int i)
	{
		return m[i];
	}

	inline const float* operator[](int i) const
	{
		return m[i];
	}

	// Get a pointer to m[0][0]
	inline float* Base()
	{
		return &m[0][0];
	}

	inline const float* Base() const
	{
		return &m[0][0];
	}

	void  SetLeft(const Vector& vLeft);
	void  SetUp(const Vector& vUp);
	void  SetForward(const Vector& vForward);

	void  GetBasisVectors(Vector& vForward, Vector& vLeft, Vector& vUp) const;
	void  SetBasisVectors(const Vector& vForward, const Vector& vLeft, const Vector& vUp);

	// Get/Set the translation.
	Vector& GetTranslation(Vector& vTrans) const;
	void  SetTranslation(const Vector& vTrans);

	void  PreTranslate(const Vector& vTrans);
	void  PostTranslate(const Vector& vTrans);

	matrix3x4_t& As3x4();
	const matrix3x4_t& As3x4() const;
	void  CopyFrom3x4(const matrix3x4_t& m3x4);
	void  Set3x4(matrix3x4_t& matrix3x4) const;

	bool  operator==(const VMatrix& src) const;
	bool  operator!=(const VMatrix& src) const { return !(*this == src); }

	// Access the basis vectors.
	Vector  GetLeft() const;
	Vector  GetUp() const;
	Vector  GetForward() const;
	Vector  GetTranslation() const;

	// Matrix->vector operations.
public:
	// Multiply by a 3D vector (same as operator*).
	void  V3Mul(const Vector& vIn, Vector& vOut) const;

	// Multiply by a 4D vector.
	//void  V4Mul( const Vector4D &vIn, Vector4D &vOut ) const;

	// Applies the rotation (ignores translation in the matrix). (This just calls VMul3x3).
	Vector  ApplyRotation(const Vector& vVec) const;

	// Multiply by a vector (divides by w, assumes input w is 1).
	Vector  operator*(const Vector& vVec) const;

	// Multiply by the upper 3x3 part of the matrix (ie: only apply rotation).
	Vector  VMul3x3(const Vector& vVec) const;

	// Apply the inverse (transposed) rotation (only works on pure rotation matrix)
	Vector  VMul3x3Transpose(const Vector& vVec) const;

	// Multiply by the upper 3 rows.
	Vector  VMul4x3(const Vector& vVec) const;

	// Apply the inverse (transposed) transformation (only works on pure rotation/translation)
	Vector  VMul4x3Transpose(const Vector& vVec) const;

	// Matrix->plane operations.
	//public:
	// Transform the plane. The matrix can only contain translation and rotation.
	//void  TransformPlane( const VPlane &inPlane, VPlane &outPlane ) const;

	// Just calls TransformPlane and returns the result.
	//VPlane  operator*(const VPlane &thePlane) const;

	// Matrix->matrix operations.
public:

	VMatrix& operator=(const VMatrix& mOther);

	// Add two matrices.
	const VMatrix& operator+=(const VMatrix& other);

	// Add/Subtract two matrices.
	VMatrix  operator+(const VMatrix& other) const;
	VMatrix  operator-(const VMatrix& other) const;

	// Negation.
	VMatrix  operator-() const;

	// Return inverse matrix. Be careful because the results are undefined
	// if the matrix doesn't have an inverse (ie: InverseGeneral returns false).
	VMatrix  operator~() const;

	// Matrix operations.
public:
	// Set to identity.
	void  Identity();
	bool  IsIdentity() const;
public:
	// The matrix.
	float  m[4][4];
};

inline void MatrixGetColumn(const matrix3x4_t& src, int nCol, Vector& pColumn)
{
	pColumn.x = src[0][nCol];
	pColumn.y = src[1][nCol];
	pColumn.z = src[2][nCol];
}

inline void MatrixPosition(const matrix3x4_t& matrix, Vector& position)
{
	MatrixGetColumn(matrix, 3, position);
}
```

`src/valve_sdk/math/Vectors.cpp`:

```cpp
#include "Vectors.hpp"

Vector2D::Vector2D(void)
{
}

Vector2D::Vector2D(float X, float Y)
{
	x = X; y = Y;
}

Vector2D::Vector2D(float* clr)
{
	x = clr[0]; y = clr[1];
}

//-----------------------------------------------------------------------------
// initialization
//-----------------------------------------------------------------------------

void Vector2D::Init(float ix, float iy)
{
	x = ix; y = iy;
}

void Vector2D::Random(float minVal, float maxVal)
{
	x = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	y = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
}

void Vector2DClear(Vector2D& a)
{
	a.x = a.y = 0.0f;
}

//-----------------------------------------------------------------------------
// assignment
//-----------------------------------------------------------------------------

Vector2D& Vector2D::operator=(const Vector2D& vOther)
{
	x = vOther.x; y = vOther.y;
	return *this;
}

//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------

float& Vector2D::operator[](int i)
{
	return ((float*)this)[i];
}

float Vector2D::operator[](int i) const
{
	return ((float*)this)[i];
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------

float* Vector2D::Base()
{
	return (float*)this;
}

float const* Vector2D::Base() const
{
	return (float const*)this;
}

//-----------------------------------------------------------------------------
// IsValid?
//-----------------------------------------------------------------------------

bool Vector2D::IsValid() const
{
	return !isinf(x) && !isinf(y);
}

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------

bool Vector2D::operator==(const Vector2D& src) const
{
	return (src.x == x) && (src.y == y);
}

bool Vector2D::operator!=(const Vector2D& src) const
{
	return (src.x != x) || (src.y != y);
}

//-----------------------------------------------------------------------------
// Copy
//-----------------------------------------------------------------------------

void Vector2DCopy(const Vector2D& src, Vector2D& dst)
{
	dst.x = src.x;
	dst.y = src.y;
}

void Vector2D::CopyToArray(float* rgfl) const
{
	rgfl[0] = x; rgfl[1] = y;
}

//-----------------------------------------------------------------------------
// standard Math operations
//-----------------------------------------------------------------------------

void Vector2D::Negate()
{
	x = -x; y = -y;
}

void Vector2DAdd(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	c.x = a.x + b.x;
	c.y = a.y + b.y;
}

void Vector2DSubtract(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	c.x = a.x - b.x;
	c.y = a.y - b.y;
}

void Vector2DMultiply(const Vector2D& a, float b, Vector2D& c)
{
	c.x = a.x * b;
	c.y = a.y * b;
}

void Vector2DMultiply(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	c.x = a.x * b.x;
	c.y = a.y * b.y;
}

void Vector2DDivide(const Vector2D& a, float b, Vector2D& c)
{
	float oob = 1.0f / b;
	c.x = a.x * oob;
	c.y = a.y * oob;
}

void Vector2DDivide(const Vector2D& a, const Vector2D& b, Vector2D& c)
{
	c.x = a.x / b.x;
	c.y = a.y / b.y;
}

void Vector2DMA(const Vector2D& start, float s, const Vector2D& dir, Vector2D& result)
{
	result.x = start.x + s * dir.x;
	result.y = start.y + s * dir.y;
}

// FIXME: Remove
// For backwards compatability
void Vector2D::MulAdd(const Vector2D& a, const Vector2D& b, float scalar)
{
	x = a.x + b.x * scalar;
	y = a.y + b.y * scalar;
}

void Vector2DLerp(const Vector2D& src1, const Vector2D& src2, float t, Vector2D& dest)
{
	dest[0] = src1[0] + (src2[0] - src1[0]) * t;
	dest[1] = src1[1] + (src2[1] - src1[1]) * t;
}

//-----------------------------------------------------------------------------
// dot, cross
//-----------------------------------------------------------------------------
float DotProduct2D(const Vector2D& a, const Vector2D& b)
{
	return(a.x * b.x + a.y * b.y);
}

// for backwards compatability
float Vector2D::Dot(const Vector2D& vOther) const
{
	return DotProduct2D(*this, vOther);
}

float Vector2DNormalize(Vector2D& v)
{
	float l = v.Length();
	if (l != 0.0f) {
		v /= l;
	}
	else {
		v.x = v.y = 0.0f;
	}
	return l;
}

//-----------------------------------------------------------------------------
// length
//-----------------------------------------------------------------------------
float Vector2DLength(const Vector2D& v)
{
	return (float)sqrt(v.x * v.x + v.y * v.y);
}

float Vector2D::NormalizeInPlace()
{
	return Vector2DNormalize(*this);
}

bool Vector2D::IsLengthGreaterThan(float val) const
{
	return LengthSqr() > val * val;
}

bool Vector2D::IsLengthLessThan(float val) const
{
	return LengthSqr() < val * val;
}

float Vector2D::Length(void) const
{
	return Vector2DLength(*this);
}

void Vector2DMin(const Vector2D& a, const Vector2D& b, Vector2D& result)
{
	result.x = (a.x < b.x) ? a.x : b.x;
	result.y = (a.y < b.y) ? a.y : b.y;
}

void Vector2DMax(const Vector2D& a, const Vector2D& b, Vector2D& result)
{
	result.x = (a.x > b.x) ? a.x : b.x;
	result.y = (a.y > b.y) ? a.y : b.y;
}

//-----------------------------------------------------------------------------
// Computes the closest point to vecTarget no farther than flMaxDist from vecStart
//-----------------------------------------------------------------------------
void ComputeClosestPoint2D(const Vector2D& vecStart, float flMaxDist, const Vector2D& vecTarget, Vector2D* pResult)
{
	Vector2D vecDelta;
	Vector2DSubtract(vecTarget, vecStart, vecDelta);
	float flDistSqr = vecDelta.LengthSqr();
	if (flDistSqr <= flMaxDist * flMaxDist) {
		*pResult = vecTarget;
	}
	else {
		vecDelta /= sqrt(flDistSqr);
		Vector2DMA(vecStart, flMaxDist, vecDelta, *pResult);
	}
}

//-----------------------------------------------------------------------------
// Returns a Vector2D with the min or max in X, Y, and Z.
//-----------------------------------------------------------------------------

Vector2D Vector2D::Min(const Vector2D& vOther) const
{
	return Vector2D(x < vOther.x ? x : vOther.x, y < vOther.y ? y : vOther.y);
}

Vector2D Vector2D::Max(const Vector2D& vOther) const
{
	return Vector2D(x > vOther.x ? x : vOther.x, y > vOther.y ? y : vOther.y);
}

//-----------------------------------------------------------------------------
// arithmetic operations
//-----------------------------------------------------------------------------

Vector2D Vector2D::operator-(void) const
{
	return Vector2D(-x, -y);
}

Vector2D Vector2D::operator+(const Vector2D& v) const
{
	Vector2D res;
	Vector2DAdd(*this, v, res);
	return res;
}

Vector2D Vector2D::operator-(const Vector2D& v) const
{
	Vector2D res;
	Vector2DSubtract(*this, v, res);
	return res;
}

Vector2D Vector2D::operator*(float fl) const
{
	Vector2D res;
	Vector2DMultiply(*this, fl, res);
	return res;
}

Vector2D Vector2D::operator*(const Vector2D& v) const
{
	Vector2D res;
	Vector2DMultiply(*this, v, res);
	return res;
}

Vector2D Vector2D::operator/(float fl) const
{
	Vector2D res;
	Vector2DDivide(*this, fl, res);
	return res;
}

Vector2D Vector2D::operator/(const Vector2D& v) const
{
	Vector2D res;
	Vector2DDivide(*this, v, res);
	return res;
}

Vector2D operator*(float fl, const Vector2D& v)
{
	return v * fl;
}

void VectorCopy(const Vector4D& src, Vector4D& dst)
{
	dst.x = src.x;
	dst.y = src.y;
	dst.z = src.z;
	dst.w = src.w;
}
void VectorLerp(const Vector4D& src1, const Vector4D& src2, float t, Vector4D& dest)
{
	dest.x = src1.x + (src2.x - src1.x) * t;
	dest.y = src1.y + (src2.y - src1.y) * t;
	dest.z = src1.z + (src2.z - src1.z) * t;
	dest.w = src1.w + (src2.w - src1.w) * t;
}
float VectorLength(const Vector4D& v)
{
	return sqrt(v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w);
}

float NormalizeVector(Vector4D& v)
{
	float l = v.Length();
	if (l != 0.0f) {
		v /= l;
	}
	else {
		v.x = v.y = v.z = v.w = 0.0f;
	}
	return l;
}

Vector4D::Vector4D(void)
{
	Invalidate();
}
Vector4D::Vector4D(float X, float Y, float Z, float W)
{
	x = X;
	y = Y;
	z = Z;
	w = W;
}
Vector4D::Vector4D(float* clr)
{
	x = clr[0];
	y = clr[1];
	z = clr[2];
	w = clr[3];
}

//-----------------------------------------------------------------------------
// initialization
//-----------------------------------------------------------------------------

void Vector4D::Init(float ix, float iy, float iz, float iw)
{
	x = ix; y = iy; z = iz; w = iw;
}

void Vector4D::Random(float minVal, float maxVal)
{
	x = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	y = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	z = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
	w = minVal + ((float)rand() / RAND_MAX) * (maxVal - minVal);
}

// This should really be a single opcode on the PowerPC (move r0 onto the vec reg)
void Vector4D::Zero()
{
	x = y = z = w = 0.0f;
}

//-----------------------------------------------------------------------------
// assignment
//-----------------------------------------------------------------------------

Vector4D& Vector4D::operator=(const Vector4D& vOther)
{
	x = vOther.x; y = vOther.y; z = vOther.z; w = vOther.w;
	return *this;
}

//-----------------------------------------------------------------------------
// Array access
//-----------------------------------------------------------------------------
float& Vector4D::operator[](int i)
{
	return ((float*)this)[i];
}

float Vector4D::operator[](int i) const
{
	return ((float*)this)[i];
}

//-----------------------------------------------------------------------------
// Base address...
//-----------------------------------------------------------------------------
float* Vector4D::Base()
{
	return (float*)this;
}

float const* Vector4D::Base() const
{
	return (float const*)this;
}

//-----------------------------------------------------------------------------
// IsValid?
//-----------------------------------------------------------------------------

bool Vector4D::IsValid() const
{
	return !isinf(x) && !isinf(y) && !isinf(z) && !isinf(w);
}

//-----------------------------------------------------------------------------
// Invalidate
//-----------------------------------------------------------------------------

void Vector4D::Invalidate()
{
	//#ifdef _DEBUG
	//#ifdef VECTOR_PARANOIA
	x = y = z = w = std::numeric_limits<float>::infinity();
	//#endif
	//#endif
}

//-----------------------------------------------------------------------------
// comparison
//-----------------------------------------------------------------------------

bool Vector4D::operator==(const Vector4D& src) const
{
	return (src.x == x) && (src.y == y) && (src.z == z) && (src.w == w);
}

bool Vector4D::operator!=(const Vector4D& src) const
{
	return (src.x != x) || (src.y != y) || (src.z != z) || (src.w != w);
}

//-----------------------------------------------------------------------------
// Copy
//-----------------------------------------------------------------------------
void Vector4D::CopyToArray(float* rgfl) const
{
	rgfl[0] = x, rgfl[1] = y, rgfl[2] = z; rgfl[3] = w;
}

//-----------------------------------------------------------------------------
// standard Math operations
//-----------------------------------------------------------------------------
// #pragma message("TODO: these should be SSE")

void Vector4D::Negate()
{
	x = -x; y = -y; z = -z; w = -w;
}

// Get the component of this vector parallel to some other given vector
Vector4D Vector4D::ProjectOnto(const Vector4D& onto)
{
	return onto * (this->Dot(onto) / (onto.LengthSqr()));
}

// FIXME: Remove
// For backwards compatability
void Vector4D::MulAdd(const Vector4D& a, const Vector4D& b, float scalar)
{
	x = a.x + b.x * scalar;
	y = a.y + b.y * scalar;
	z = a.z + b.z * scalar;
	w = a.w + b.w * scalar;
}

Vector4D VectorLerp(const Vector4D& src1, const Vector4D& src2, float t)
{
	Vector4D result;
	VectorLerp(src1, src2, t, result);
	return result;
}

float Vector4D::Dot(const Vector4D& b) const
{
	return (x * b.x + y * b.y + z * b.z + w * b.w);
}
void VectorClear(Vector4D& a)
{
	a.x = a.y = a.z = a.w = 0.0f;
}

float Vector4D::Length(void) const
{
	return sqrt(x * x + y * y + z * z + w * w);
}

// check a point against a box
bool Vector4D::WithinAABox(Vector4D const& boxmin, Vector4D const& boxmax)
{
	return (
		(x >= boxmin.x) && (x <= boxmax.x) &&
		(y >= boxmin.y) && (y <= boxmax.y) &&
		(z >= boxmin.z) && (z <= boxmax.z) &&
		(w >= boxmin.w) && (w <= boxmax.w)
		);
}

//-----------------------------------------------------------------------------
// Get the distance from this vector to the other one
//-----------------------------------------------------------------------------
float Vector4D::DistTo(const Vector4D& vOther) const
{
	Vector4D delta;
	delta = *this - vOther;
	return delta.Length();
}

//-----------------------------------------------------------------------------
// Returns a vector with the min or max in X, Y, and Z.
//-----------------------------------------------------------------------------
Vector4D Vector4D::Min(const Vector4D& vOther) const
{
	return Vector4D(x < vOther.x ? x : vOther.x,
		y < vOther.y ? y : vOther.y,
		z < vOther.z ? z : vOther.z,
		w < vOther.w ? w : vOther.w);
}

Vector4D Vector4D::Max(const Vector4D& vOther) const
{
	return Vector4D(x > vOther.x ? x : vOther.x,
		y > vOther.y ? y : vOther.y,
		z > vOther.z ? z : vOther.z,
		w > vOther.w ? w : vOther.w);
}

//-----------------------------------------------------------------------------
// arithmetic operations
//-----------------------------------------------------------------------------

Vector4D Vector4D::operator-(void) const
{
	return Vector4D(-x, -y, -z, -w);
}

Vector4D Vector4D::operator+(const Vector4D& v) const
{
	return Vector4D(x + v.x, y + v.y, z + v.z, w + v.w);
}

Vector4D Vector4D::operator-(const Vector4D& v) const
{
	return Vector4D(x - v.x, y - v.y, z - v.z, w - v.w);
}

Vector4D Vector4D::operator*(float fl) const
{
	return Vector4D(x * fl, y * fl, z * fl, w * fl);
}

Vector4D Vector4D::operator*(const Vector4D& v) const
{
	return Vector4D(x * v.x, y * v.y, z * v.z, w * v.w);
}

Vector4D Vector4D::operator/(float fl) const
{
	return Vector4D(x / fl, y / fl, z / fl, w / fl);
}

Vector4D Vector4D::operator/(const Vector4D& v) const
{
	return Vector4D(x / v.x, y / v.y, z / v.z, w / v.w);
}

Vector4D operator*(float fl, const Vector4D& v)
{
	return v * fl;
}
```

`src/valve_sdk/math/Vectors.hpp`:

```hpp
#pragma once

#include <cmath>
#include <limits>
#include <sstream>

class Vector
{
public:
	Vector(void)
	{
		Invalidate();
	}
	Vector(float X, float Y, float Z)
	{
		x = X;
		y = Y;
		z = Z;
	}
	Vector(float X, float Y)
	{
		x = X;
		y = Y;
		z = 0;
	}
	Vector(const float* clr)
	{
		x = clr[0];
		y = clr[1];
		z = clr[2];
	}

	void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f)
	{
		x = ix; y = iy; z = iz;
	}
	bool IsValid() const
	{
		return std::isfinite(x) && std::isfinite(y) && std::isfinite(z);
	}
	void Invalidate()
	{
		x = y = z = std::numeric_limits<float>::infinity();
	}

	float& operator[](int i)
	{
		return ((float*)this)[i];
	}
	float operator[](int i) const
	{
		return ((float*)this)[i];
	}

	void Zero()
	{
		x = y = z = 0.0f;
	}

	bool operator==(const Vector& src) const
	{
		return (src.x == x) && (src.y == y) && (src.z == z);
	}
	bool operator!=(const Vector& src) const
	{
		return (src.x != x) || (src.y != y) || (src.z != z);
	}

	Vector& operator+=(const Vector& v)
	{
		x += v.x; y += v.y; z += v.z;
		return *this;
	}
	Vector& operator+=(const float& v)
	{
		x += v; y += v; z += v;

		return *this;
	}
	Vector& operator-=(const Vector& v)
	{
		x -= v.x; y -= v.y; z -= v.z;
		return *this;
	}
	Vector& operator*=(float fl)
	{
		x *= fl;
		y *= fl;
		z *= fl;
		return *this;
	}
	Vector& operator*=(const Vector& v)
	{
		x *= v.x;
		y *= v.y;
		z *= v.z;
		return *this;
	}
	Vector& operator/=(const Vector& v)
	{
		x /= v.x;
		y /= v.y;
		z /= v.z;
		return *this;
	}
	Vector& operator+=(float fl)
	{
		x += fl;
		y += fl;
		z += fl;
		return *this;
	}
	Vector& operator/=(float fl)
	{
		x /= fl;
		y /= fl;
		z /= fl;
		return *this;
	}
	Vector& operator-=(float fl)
	{
		x -= fl;
		y -= fl;
		z -= fl;
		return *this;
	}

	void NormalizeInPlace()
	{
		*this = Normalized();
	}
	Vector Normalized() const
	{
		Vector res = *this;
		float l = res.Length();
		if (l != 0.0f) {
			res /= l;
		}
		else {
			res.x = res.y = res.z = 0.0f;
		}
		return res;
	}

	float DistTo(const Vector& vOther) const
	{
		Vector delta;

		delta.x = x - vOther.x;
		delta.y = y - vOther.y;
		delta.z = z - vOther.z;

		return delta.Length();
	}
	float DistToSqr(const Vector& vOther) const
	{
		Vector delta;

		delta.x = x - vOther.x;
		delta.y = y - vOther.y;
		delta.z = z - vOther.z;

		return delta.LengthSqr();
	}
	float Dot(const Vector& vOther) const
	{
		return (x * vOther.x + y * vOther.y + z * vOther.z);
	}
	float Length() const
	{
		return sqrt(x * x + y * y + z * z);
	}
	float LengthSqr(void) const
	{
		return (x * x + y * y + z * z);
	}
	float Length2D() const
	{
		return sqrt(x * x + y * y);
	}

	Vector& operator=(const Vector& vOther)
	{
		x = vOther.x; y = vOther.y; z = vOther.z;
		return *this;
	}

	Vector operator-(void) const
	{
		return Vector(-x, -y, -z);
	}
	Vector operator+(const Vector& v) const
	{
		return Vector(x + v.x, y + v.y, z + v.z);
	}
	Vector operator+(const float& v) const
	{
		return Vector(x + v, y + v, z + v);
	}
	Vector operator-(const Vector& v) const
	{
		return Vector(x - v.x, y - v.y, z - v.z);
	}
	Vector operator-(const float& v) const
	{
		return Vector(x - v, y - v, z - v);
	}
	Vector operator*(float fl) const
	{
		return Vector(x * fl, y * fl, z * fl);
	}
	Vector operator*(const Vector& v) const
	{
		return Vector(x * v.x, y * v.y, z * v.z);
	}
	Vector operator/(float fl) const
	{
		return Vector(x / fl, y / fl, z / fl);
	}
	Vector operator/(const Vector& v) const
	{
		return Vector(x / v.x, y / v.y, z / v.z);
	}

	void CrossProduct(const Vector& a, const Vector& b, Vector& result)
	{
		result.x = a.y * b.z - a.z * b.y;
		result.y = a.z * b.x - a.x * b.z;
		result.z = a.x * b.y - a.y * b.x;
	}

	Vector Cross(const Vector& vOther)
	{
		Vector res;
		CrossProduct(*this, vOther, res);
		return res;
	}

	float x, y, z;
};

inline Vector operator*(float lhs, const Vector& rhs)
{
	return rhs * lhs;
}
inline Vector operator/(float lhs, const Vector& rhs)
{
	return rhs / lhs;
}

class __declspec(align(16)) VectorAligned : public Vector
{
public:
	inline VectorAligned(void) {};
	inline VectorAligned(float X, float Y, float Z)
	{
		Init(X, Y, Z);
	}

public:
	explicit VectorAligned(const Vector& vOther)
	{
		Init(vOther.x, vOther.y, vOther.z);
	}

	VectorAligned& operator=(const Vector& vOther)
	{
		Init(vOther.x, vOther.y, vOther.z);
		return *this;
	}

	VectorAligned& operator=(const VectorAligned& vOther)
	{
		Init(vOther.x, vOther.y, vOther.z);
		return *this;
	}

	float w;
};

// 2D Vector
class Vector2D
{
public:
	// Members
	float x, y;

	// Construction/destruction:
	Vector2D(void);
	Vector2D(float X, float Y);
	Vector2D(float* clr);

	Vector2D(const Vector2D& vOther)
	{
		x = vOther.x; y = vOther.y;
	}

	// Initialization
	void Init(float ix = 0.0f, float iy = 0.0f);
	// TODO (Ilya): Should there be an init that takes a single float for consistency?

	// Got any nasty NAN's?
	bool IsValid() const;
	void Invalidate();

	// array access...
	float operator[](int i) const;
	float& operator[](int i);

	// Base address...
	float* Base();
	float const* Base() const;

	// Initialization methods
	void Random(float minVal, float maxVal);
	void Zero(); ///< zero out a vector

				 // equality
	bool operator==(const Vector2D& v) const;
	bool operator!=(const Vector2D& v) const;

	// arithmetic operations
	Vector2D& operator+=(const Vector2D& v)
	{
		x += v.x; y += v.y;
		return *this;
	}

	Vector2D& operator-=(const Vector2D& v)
	{
		x -= v.x; y -= v.y;
		return *this;
	}

	Vector2D& operator*=(float fl)
	{
		x *= fl;
		y *= fl;
		return *this;
	}

	Vector2D& operator*=(const Vector2D& v)
	{
		x *= v.x;
		y *= v.y;
		return *this;
	}

	Vector2D& operator/=(const Vector2D& v)
	{
		x /= v.x;
		y /= v.y;
		return *this;
	}

	// this ought to be an opcode.
	Vector2D& operator+=(float fl)
	{
		x += fl;
		y += fl;
		return *this;
	}

	// this ought to be an opcode.
	Vector2D& operator/=(float fl)
	{
		x /= fl;
		y /= fl;
		return *this;
	}
	Vector2D& operator-=(float fl)
	{
		x -= fl;
		y -= fl;
		return *this;
	}

	// negate the vector components
	void Negate();

	// Get the vector's magnitude.
	float Length() const;

	// Get the vector's magnitude squared.
	float LengthSqr(void) const
	{
		return (x * x + y * y);
	}

	// return true if this vector is (0,0,0) within tolerance
	bool IsZero(float tolerance = 0.01f) const
	{
		return (x > -tolerance && x < tolerance &&
			y > -tolerance && y < tolerance);
	}

	float NormalizeInPlace();
	Vector2D Normalized() const;
	bool IsLengthGreaterThan(float val) const;
	bool IsLengthLessThan(float val) const;

	// check if a vector is within the box defined by two other vectors
	bool WithinAABox(Vector2D const& boxmin, Vector2D const& boxmax);

	// Get the distance from this vector to the other one.
	float DistTo(const Vector2D& vOther) const;

	// Get the distance from this vector to the other one squared.
	// NJS: note, VC wasn't inlining it correctly in several deeply nested inlines due to being an 'out of line' .
	// may be able to tidy this up after switching to VC7
	float DistToSqr(const Vector2D& vOther) const
	{
		Vector2D delta;

		delta.x = x - vOther.x;
		delta.y = y - vOther.y;

		return delta.LengthSqr();
	}

	// Copy
	void CopyToArray(float* rgfl) const;

	// Multiply, add, and assign to this (ie: *this = a + b * scalar). This
	// is about 12% faster than the actual vector equation (because it's done per-component
	// rather than per-vector).
	void MulAdd(const Vector2D& a, const Vector2D& b, float scalar);

	// Dot product.
	float Dot(const Vector2D& vOther) const;

	// assignment
	Vector2D& operator=(const Vector2D& vOther);

	// 2d
	float Length2D(void) const;
	float Length2DSqr(void) const;

	/// Get the component of this vector parallel to some other given vector
	Vector2D  ProjectOnto(const Vector2D& onto);

	// copy constructors
	// Vector2D(const Vector2D &vOther);

	// arithmetic operations
	Vector2D operator-(void) const;

	Vector2D operator+(const Vector2D& v) const;
	Vector2D operator-(const Vector2D& v) const;
	Vector2D operator*(const Vector2D& v) const;
	Vector2D operator/(const Vector2D& v) const;
	Vector2D operator*(float fl) const;
	Vector2D operator/(float fl) const;

	// Cross product between two vectors.
	Vector2D Cross(const Vector2D& vOther) const;

	// Returns a vector with the min or max in X, Y, and Z.
	Vector2D Min(const Vector2D& vOther) const;
	Vector2D Max(const Vector2D& vOther) const;
};

class Vector4D
{
public:
	// Members
	float x, y, z, w;

	// Construction/destruction:
	Vector4D(void);
	Vector4D(float X, float Y, float Z, float W);
	Vector4D(float* clr);

	// Initialization
	void Init(float ix = 0.0f, float iy = 0.0f, float iz = 0.0f, float iw = 0.0f);
	// TODO (Ilya): Should there be an init that takes a single float for consistency?

	// Got any nasty NAN's?
	bool IsValid() const;
	void Invalidate();

	// array access...
	float operator[](int i) const;
	float& operator[](int i);

	// Base address...
	float* Base();
	float const* Base() const;

	// Initialization methods
	void Random(float minVal, float maxVal);
	void Zero(); ///< zero out a vector

				 // equality
	bool operator==(const Vector4D& v) const;
	bool operator!=(const Vector4D& v) const;

	// arithmetic operations
	Vector4D& operator+=(const Vector4D& v)
	{
		x += v.x; y += v.y; z += v.z; w += v.w;
		return *this;
	}

	Vector4D& operator-=(const Vector4D& v)
	{
		x -= v.x; y -= v.y; z -= v.z; w -= v.w;
		return *this;
	}

	Vector4D& operator*=(float fl)
	{
		x *= fl;
		y *= fl;
		z *= fl;
		w *= fl;
		return *this;
	}

	Vector4D& operator*=(const Vector4D& v)
	{
		x *= v.x;
		y *= v.y;
		z *= v.z;
		w *= v.w;
		return *this;
	}

	Vector4D& operator/=(const Vector4D& v)
	{
		x /= v.x;
		y /= v.y;
		z /= v.z;
		w /= v.w;
		return *this;
	}

	// this ought to be an opcode.
	Vector4D& operator+=(float fl)
	{
		x += fl;
		y += fl;
		z += fl;
		w += fl;
		return *this;
	}

	// this ought to be an opcode.
	Vector4D& operator/=(float fl)
	{
		x /= fl;
		y /= fl;
		z /= fl;
		w /= fl;
		return *this;
	}
	Vector4D& operator-=(float fl)
	{
		x -= fl;
		y -= fl;
		z -= fl;
		w -= fl;
		return *this;
	}

	// negate the vector components
	void Negate();

	// Get the vector's magnitude.
	float Length() const;

	// Get the vector's magnitude squared.
	float LengthSqr(void) const
	{
		return (x * x + y * y + z * z);
	}

	// return true if this vector is (0,0,0) within tolerance
	bool IsZero(float tolerance = 0.01f) const
	{
		return (x > -tolerance && x < tolerance &&
			y > -tolerance && y < tolerance &&
			z > -tolerance && z < tolerance &&
			w > -tolerance && w < tolerance);
	}

	float NormalizeInPlace();
	Vector4D Normalized() const;
	bool IsLengthGreaterThan(float val) const;
	bool IsLengthLessThan(float val) const;

	// check if a vector is within the box defined by two other vectors
	bool WithinAABox(Vector4D const& boxmin, Vector4D const& boxmax);

	// Get the distance from this vector to the other one.
	float DistTo(const Vector4D& vOther) const;

	// Get the distance from this vector to the other one squared.
	// NJS: note, VC wasn't inlining it correctly in several deeply nested inlines due to being an 'out of line' .
	// may be able to tidy this up after switching to VC7
	float DistToSqr(const Vector4D& vOther) const
	{
		Vector4D delta;

		delta.x = x - vOther.x;
		delta.y = y - vOther.y;
		delta.z = z - vOther.z;
		delta.w = w - vOther.w;

		return delta.LengthSqr();
	}

	// Copy
	void CopyToArray(float* rgfl) const;

	// Multiply, add, and assign to this (ie: *this = a + b * scalar). This
	// is about 12% faster than the actual vector equation (because it's done per-component
	// rather than per-vector).
	void MulAdd(const Vector4D& a, const Vector4D& b, float scalar);

	// Dot product.
	float Dot(const Vector4D& vOther) const;

	// assignment
	Vector4D& operator=(const Vector4D& vOther);

	// 2d
	float Length2D(void) const;
	float Length2DSqr(void) const;

	/// Get the component of this vector parallel to some other given vector
	Vector4D  ProjectOnto(const Vector4D& onto);

	// copy constructors
	// Vector4D(const Vector4D &vOther);

	// arithmetic operations
	Vector4D operator-(void) const;

	Vector4D operator+(const Vector4D& v) const;
	Vector4D operator-(const Vector4D& v) const;
	Vector4D operator*(const Vector4D& v) const;
	Vector4D operator/(const Vector4D& v) const;
	Vector4D operator*(float fl) const;
	Vector4D operator/(float fl) const;

	// Returns a vector with the min or max in X, Y, and Z.
	Vector4D Min(const Vector4D& vOther) const;
	Vector4D Max(const Vector4D& vOther) const;
};
```

`src/valve_sdk/misc/BaseHandle.hpp`:

```hpp
#pragma once

#include "IHandleEntity.hpp"

#define NUM_ENT_ENTRY_BITS         (11 + 2)
#define NUM_ENT_ENTRIES            (1 << NUM_ENT_ENTRY_BITS)
#define INVALID_EHANDLE_INDEX       0xFFFFFFFF
#define NUM_SERIAL_NUM_BITS        16 // (32 - NUM_ENT_ENTRY_BITS)
#define NUM_SERIAL_NUM_SHIFT_BITS (32 - NUM_SERIAL_NUM_BITS)
#define ENT_ENTRY_MASK             (( 1 << NUM_SERIAL_NUM_BITS) - 1)

class IHandleEntity;

class CBaseHandle
{
public:
	CBaseHandle();
	CBaseHandle(const CBaseHandle& other);
	CBaseHandle(unsigned long value);
	CBaseHandle(int iEntry, int iSerialNumber);

	void Init(int iEntry, int iSerialNumber);
	void Term();

	// Even if this returns true, Get() still can return return a non-null value.
	// This just tells if the handle has been initted with any values.
	bool IsValid() const;

	int GetEntryIndex() const;
	int GetSerialNumber() const;

	int ToInt() const;
	bool operator !=(const CBaseHandle& other) const;
	bool operator ==(const CBaseHandle& other) const;
	bool operator ==(const IHandleEntity* pEnt) const;
	bool operator !=(const IHandleEntity* pEnt) const;
	bool operator <(const CBaseHandle& other) const;
	bool operator <(const IHandleEntity* pEnt) const;

	// Assign a value to the handle.
	const CBaseHandle& operator=(const IHandleEntity* pEntity);
	const CBaseHandle& Set(const IHandleEntity* pEntity);

	// Use this to dereference the handle.
	// Note: this is implemented in game code (ehandle.h)
	IHandleEntity* Get() const;

protected:
	// The low NUM_SERIAL_BITS hold the index. If this value is less than MAX_EDICTS, then the entity is networkable.
	// The high NUM_SERIAL_NUM_BITS bits are the serial number.
	unsigned long	m_Index;
};

inline CBaseHandle::CBaseHandle()
{
	m_Index = INVALID_EHANDLE_INDEX;
}

inline CBaseHandle::CBaseHandle(const CBaseHandle& other)
{
	m_Index = other.m_Index;
}

inline CBaseHandle::CBaseHandle(unsigned long value)
{
	m_Index = value;
}

inline CBaseHandle::CBaseHandle(int iEntry, int iSerialNumber)
{
	Init(iEntry, iSerialNumber);
}

inline void CBaseHandle::Init(int iEntry, int iSerialNumber)
{
	m_Index = iEntry | (iSerialNumber << NUM_ENT_ENTRY_BITS);
}

inline void CBaseHandle::Term()
{
	m_Index = INVALID_EHANDLE_INDEX;
}

inline bool CBaseHandle::IsValid() const
{
	return m_Index != INVALID_EHANDLE_INDEX;
}

inline int CBaseHandle::GetEntryIndex() const
{
	return m_Index & ENT_ENTRY_MASK;
}

inline int CBaseHandle::GetSerialNumber() const
{
	return m_Index >> NUM_ENT_ENTRY_BITS;
}

inline int CBaseHandle::ToInt() const
{
	return (int)m_Index;
}

inline bool CBaseHandle::operator !=(const CBaseHandle& other) const
{
	return m_Index != other.m_Index;
}

inline bool CBaseHandle::operator ==(const CBaseHandle& other) const
{
	return m_Index == other.m_Index;
}

inline bool CBaseHandle::operator ==(const IHandleEntity* pEnt) const
{
	return Get() == pEnt;
}

inline bool CBaseHandle::operator !=(const IHandleEntity* pEnt) const
{
	return Get() != pEnt;
}

inline bool CBaseHandle::operator <(const CBaseHandle& other) const
{
	return m_Index < other.m_Index;
}

inline bool CBaseHandle::operator <(const IHandleEntity* pEntity) const
{
	unsigned long otherIndex = (pEntity) ? pEntity->GetRefEHandle().m_Index : INVALID_EHANDLE_INDEX;
	return m_Index < otherIndex;
}

inline const CBaseHandle& CBaseHandle::operator=(const IHandleEntity* pEntity)
{
	return Set(pEntity);
}

inline const CBaseHandle& CBaseHandle::Set(const IHandleEntity* pEntity)
{
	if (pEntity) {
		*this = pEntity->GetRefEHandle();
	}
	else {
		m_Index = INVALID_EHANDLE_INDEX;
	}

	return *this;
}
```

`src/valve_sdk/misc/CUserCmd.hpp`:

```hpp
#pragma once

#include "../math/QAngle.hpp"
#include "checksum_crc.hpp"

#define IN_ATTACK  (1 << 0)
#define IN_JUMP   (1 << 1)
#define IN_DUCK   (1 << 2)
#define IN_FORWARD  (1 << 3)
#define IN_BACK   (1 << 4)
#define IN_USE   (1 << 5)
#define IN_CANCEL  (1 << 6)
#define IN_LEFT   (1 << 7)
#define IN_RIGHT  (1 << 8)
#define IN_MOVELEFT  (1 << 9)
#define IN_MOVERIGHT (1 << 10)
#define IN_ATTACK2  (1 << 11)
#define IN_RUN   (1 << 12)
#define IN_RELOAD  (1 << 13)
#define IN_ALT1   (1 << 14)
#define IN_ALT2   (1 << 15)
#define IN_SCORE  (1 << 16)   // Used by client.dll for when scoreboard is held down
#define IN_SPEED  (1 << 17) // Player is holding the speed key
#define IN_WALK   (1 << 18) // Player holding walk key
#define IN_ZOOM   (1 << 19) // Zoom key for HUD zoom
#define IN_WEAPON1  (1 << 20) // weapon defines these bits
#define IN_WEAPON2  (1 << 21) // weapon defines these bits
#define IN_BULLRUSH  (1 << 22)
#define IN_GRENADE1  (1 << 23) // grenade 1
#define IN_GRENADE2  (1 << 24) // grenade 2
#define IN_LOOKSPIN  (1 << 25)

class CUserCmd
{
public:
	CUserCmd()
	{
		memset(this, 0, sizeof(*this));
	};
	virtual ~CUserCmd() {};

	CRC32_t GetChecksum(void) const
	{
		CRC32_t crc;
		CRC32_Init(&crc);

		CRC32_ProcessBuffer(&crc, &command_number, sizeof(command_number));
		CRC32_ProcessBuffer(&crc, &tick_count, sizeof(tick_count));
		CRC32_ProcessBuffer(&crc, &viewangles, sizeof(viewangles));
		CRC32_ProcessBuffer(&crc, &aimdirection, sizeof(aimdirection));
		CRC32_ProcessBuffer(&crc, &forwardmove, sizeof(forwardmove));
		CRC32_ProcessBuffer(&crc, &sidemove, sizeof(sidemove));
		CRC32_ProcessBuffer(&crc, &upmove, sizeof(upmove));
		CRC32_ProcessBuffer(&crc, &buttons, sizeof(buttons));
		CRC32_ProcessBuffer(&crc, &impulse, sizeof(impulse));
		CRC32_ProcessBuffer(&crc, &weaponselect, sizeof(weaponselect));
		CRC32_ProcessBuffer(&crc, &weaponsubtype, sizeof(weaponsubtype));
		CRC32_ProcessBuffer(&crc, &random_seed, sizeof(random_seed));
		CRC32_ProcessBuffer(&crc, &mousedx, sizeof(mousedx));
		CRC32_ProcessBuffer(&crc, &mousedy, sizeof(mousedy));

		CRC32_Final(&crc);
		return crc;
	}

	int     command_number;     // 0x04 For matching server and client commands for debugging
	int     tick_count;         // 0x08 the tick the client created this command
	QAngle  viewangles;         // 0x0C Player instantaneous view angles.
	Vector  aimdirection;       // 0x18
	float   forwardmove;        // 0x24
	float   sidemove;           // 0x28
	float   upmove;             // 0x2C
	int     buttons;            // 0x30 Attack button states
	char    impulse;            // 0x34
	int     weaponselect;       // 0x38 Current weapon id
	int     weaponsubtype;      // 0x3C
	int     random_seed;        // 0x40 For shared random functions
	short   mousedx;            // 0x44 mouse accum in x from create move
	short   mousedy;            // 0x46 mouse accum in y from create move
	bool    hasbeenpredicted;   // 0x48 Client only, tracks whether we've predicted this command at least once
	char    pad_0x4C[0x18];     // 0x4C Current sizeof( usercmd ) =  100  = 0x64
};

class CVerifiedUserCmd
{
public:
	CUserCmd m_cmd;
	CRC32_t  m_crc;
};
```

`src/valve_sdk/misc/ClientClass.hpp`:

```hpp
#pragma once

#include "Recv.hpp"

class ClientClass;
class IClientNetworkable;

typedef IClientNetworkable* (*CreateClientClassFn)(int entnum, int serialNum);
typedef IClientNetworkable* (*CreateEventFn)();

class ClientClass
{
public:
	CreateClientClassFn m_pCreateFn;
	CreateEventFn m_pCreateEventFn;
	char* m_pNetworkName;
	RecvTable* m_pRecvTable;
	ClientClass* m_pNext;
	EClassId m_ClassID;
};
```

`src/valve_sdk/misc/Color.cpp`:

```cpp
#include "Color.hpp"
#include <math.h>

Color Color::Black(0, 0, 0, 255);
Color Color::White(255, 255, 255, 255);
Color Color::Red(255, 0, 0, 255);
Color Color::Green(0, 128, 0, 255);
Color Color::Blue(0, 0, 255, 255);
Color Color::Yellow(255, 255, 0, 255);
Color Color::Orange(255, 127, 39, 255);
Color Color::Smoke(255, 255, 255, 102);

Color::Color()
{
	*((int*)this) = 0;
}
Color::Color(int _r, int _g, int _b)
{
	SetColor(_r, _g, _b, 255);
}
Color::Color(int _r, int _g, int _b, int _a)
{
	SetColor(_r, _g, _b, _a);
}
void Color::SetRawColor(int color32)
{
	*((int*)this) = color32;
}
int Color::GetRawColor() const
{
	return *((int*)this);
}
void Color::SetColor(int _r, int _g, int _b, int _a)
{
	_CColor[0] = (unsigned char)_r;
	_CColor[1] = (unsigned char)_g;
	_CColor[2] = (unsigned char)_b;
	_CColor[3] = (unsigned char)_a;
}
void Color::SetColor(float _r, float _g, float _b, float _a)
{
	_CColor[0] = static_cast<unsigned char>(_r * 255.0f);
	_CColor[1] = static_cast<unsigned char>(_g * 255.0f);
	_CColor[2] = static_cast<unsigned char>(_b * 255.0f);
	_CColor[3] = static_cast<unsigned char>(_a * 255.0f);
}
void Color::GetColor(int& _r, int& _g, int& _b, int& _a) const
{
	_r = _CColor[0];
	_g = _CColor[1];
	_b = _CColor[2];
	_a = _CColor[3];
}
bool Color::operator== (const Color& rhs) const
{
	return (*((int*)this) == *((int*)&rhs));
}
bool Color::operator!= (const Color& rhs) const
{
	return !(operator==(rhs));
}
Color& Color::operator=(const Color& rhs)
{
	SetRawColor(rhs.GetRawColor());
	return *this;
}
```

`src/valve_sdk/misc/Color.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cmath>

class Color
{
public:
	Color();
	Color(int _r, int _g, int _b);
	Color(int _r, int _g, int _b, int _a);
	Color(float _r, float _g, float _b) : Color(_r, _g, _b, 1.0f) {}
	Color(float _r, float _g, float _b, float _a)
		: Color(
			static_cast<int>(_r * 255.0f),
			static_cast<int>(_g * 255.0f),
			static_cast<int>(_b * 255.0f),
			static_cast<int>(_a * 255.0f))
	{
	}
	explicit Color(float* rgb) : Color(rgb[0], rgb[1], rgb[2], 1.0f) {}
	explicit Color(unsigned long argb)
	{
		_CColor[2] = (unsigned char)((argb & 0x000000FF) >> (0 * 8));
		_CColor[1] = (unsigned char)((argb & 0x0000FF00) >> (1 * 8));
		_CColor[0] = (unsigned char)((argb & 0x00FF0000) >> (2 * 8));
		_CColor[3] = (unsigned char)((argb & 0xFF000000) >> (3 * 8));
	}

	void    SetRawColor(int color32);
	int     GetRawColor() const;
	void    SetColor(int _r, int _g, int _b, int _a = 0);
	void    SetColor(float _r, float _g, float _b, float _a = 0);
	void    GetColor(int& _r, int& _g, int& _b, int& _a) const;

	int r() const { return _CColor[0]; }
	int g() const { return _CColor[1]; }
	int b() const { return _CColor[2]; }
	int a() const { return _CColor[3]; }

	unsigned char& operator[](int index)
	{
		return _CColor[index];
	}
	const unsigned char& operator[](int index) const
	{
		return _CColor[index];
	}

	bool operator==(const Color& rhs) const;
	bool operator!=(const Color& rhs) const;
	Color& operator=(const Color& rhs);

	static Color Black;
	static Color White;
	static Color Red;
	static Color Green;
	static Color Blue;
	static Color Yellow;
	static Color Orange;
	static Color Smoke;

	static Color FromHSB(float hue, float saturation, float brightness)
	{
		float h = hue == 1.0f ? 0 : hue * 6.0f;
		float f = h - (int)h;
		float p = brightness * (1.0f - saturation);
		float q = brightness * (1.0f - saturation * f);
		float t = brightness * (1.0f - (saturation * (1.0f - f)));

		int hh = int(floor(h));
		switch (hh) {
		case 0:
			return Color(brightness, t, p);
		case 1:
			return Color(q, brightness, p);
		case 2:
			return Color(p, brightness, t);
		case 3:
			return Color(p, q, brightness);
		case 4:
			return Color(t, p, brightness);
		default:
			return Color(brightness, p, q);
		}
	}
private:
	unsigned char _CColor[4];
};
```

`src/valve_sdk/misc/Convar.cpp`:

```cpp
#include "Convar.hpp"

#include "../sdk.hpp"

#include "characterset.hpp"
#include "UtlBuffer.hpp"

#define ALIGN_VALUE( val, alignment ) ( ( val + alignment - 1 ) & ~( alignment - 1 ) )
#define stackalloc( _size )		_alloca( ALIGN_VALUE( _size, 16 ) )

ConCommandBase* ConCommandBase::s_pConCommandBases = NULL;
ConCommandBase* ConCommandBase::s_pRegisteredCommands = NULL;
IConCommandBaseAccessor* ConCommandBase::s_pAccessor = NULL;
static int s_nDLLIdentifier = -1;
static int s_nCVarFlag = 0;
static bool s_bRegistered = false;

class CDefaultAccessor : public IConCommandBaseAccessor
{
public:
	virtual bool RegisterConCommandBase(ConCommandBase* pVar)
	{
		// Link to engine's list instead
		return true;
	}
};

static CDefaultAccessor s_DefaultAccessor;

//-----------------------------------------------------------------------------
// Called by the framework to register ConCommandBases with the ICVar
//-----------------------------------------------------------------------------
inline CVarDLLIdentifier_t ConCommandBase::GetDLLIdentifier()const
{
	return CVarDLLIdentifier_t();
}
ConCommandBase::ConCommandBase(void)
{
	m_bRegistered = false;
	m_pszName = NULL;
	m_pszHelpString = NULL;

	m_nFlags = 0;
	m_pNext = NULL;
}

ConCommandBase::ConCommandBase(const char* pName, const char* pHelpString /*=0*/, int flags /*= 0*/)
{
	Create(pName, pHelpString, flags);
}

ConCommandBase::~ConCommandBase(void)
{
}

bool ConCommandBase::IsCommand(void) const
{
	//	assert( 0 ); This can't assert. . causes a recursive assert in Sys_Printf, etc.
	return true;
}

void ConCommandBase::Create(const char* pName, const char* pHelpString /*= 0*/, int flags /*= 0*/)
{
	static const char* empty_string = "";

	m_bRegistered = false;

	// Name should be static data
	m_pszName = pName;
	m_pszHelpString = pHelpString ? pHelpString : empty_string;

	m_nFlags = flags;

	if (!(m_nFlags & FCVAR_UNREGISTERED)) {
		m_pNext = s_pConCommandBases;
		s_pConCommandBases = this;
	}
	else {
		m_pNext = NULL;
	}
}

void ConCommandBase::Init()
{
	if (s_pAccessor) {
		s_pAccessor->RegisterConCommandBase(this);
	}
}

void ConCommandBase::Shutdown()
{
}

const char* ConCommandBase::GetName(void) const
{
	return m_pszName;
}

bool ConCommandBase::IsFlagSet(int flag) const
{
	return (flag & m_nFlags) ? true : false;
}

void ConCommandBase::AddFlags(int flags)
{
	m_nFlags |= flags;
}

void ConCommandBase::RemoveFlags(int flags)
{
	m_nFlags &= ~flags;
}

int ConCommandBase::GetFlags(void) const
{
	return m_nFlags;
}

const ConCommandBase* ConCommandBase::GetNext(void) const
{
	return m_pNext;
}

ConCommandBase* ConCommandBase::GetNext(void)
{
	return m_pNext;
}

char* ConCommandBase::CopyString(const char* from)
{
	int		len;
	char* to;

	len = strlen(from);
	if (len <= 0) {
		to = new char[1];
		to[0] = 0;
	}
	else {
		to = new char[len + 1];
		strncpy_s(to, len + 1, from, len + 1);
	}
	return to;

	delete[] to;
}

const char* ConCommandBase::GetHelpText(void) const
{
	return m_pszHelpString;
}

bool ConCommandBase::IsRegistered(void) const
{
	return m_bRegistered;
}

static characterset_t s_BreakSet;
static bool s_bBuiltBreakSet = false;

CCommand::CCommand()
{
	if (!s_bBuiltBreakSet) {
		s_bBuiltBreakSet = true;
		CharacterSetBuild(&s_BreakSet, "{}()':");
	}

	Reset();
}

CCommand::CCommand(int nArgC, const char** ppArgV)
{
	assert(nArgC > 0);

	if (!s_bBuiltBreakSet) {
		s_bBuiltBreakSet = true;
		CharacterSetBuild(&s_BreakSet, "{}()':");
	}

	Reset();

	char* pBuf = m_pArgvBuffer;
	char* pSBuf = m_pArgSBuffer;
	m_nArgc = nArgC;
	for (int i = 0; i < nArgC; ++i) {
		m_ppArgv[i] = pBuf;
		int nLen = strlen(ppArgV[i]);
		memcpy(pBuf, ppArgV[i], nLen + 1);
		if (i == 0) {
			m_nArgv0Size = nLen;
		}
		pBuf += nLen + 1;

		bool bContainsSpace = strchr(ppArgV[i], ' ') != NULL;
		if (bContainsSpace) {
			*pSBuf++ = '\"';
		}
		memcpy(pSBuf, ppArgV[i], nLen);
		pSBuf += nLen;
		if (bContainsSpace) {
			*pSBuf++ = '\"';
		}

		if (i != nArgC - 1) {
			*pSBuf++ = ' ';
		}
	}
}

void CCommand::Reset()
{
	m_nArgc = 0;
	m_nArgv0Size = 0;
	m_pArgSBuffer[0] = 0;
}

characterset_t* CCommand::DefaultBreakSet()
{
	return &s_BreakSet;
}

bool CCommand::Tokenize(const char* pCommand, characterset_t* pBreakSet)
{
	Reset();
	if (!pCommand)
		return false;

	// Use default break Set
	if (!pBreakSet) {
		pBreakSet = &s_BreakSet;
	}

	// Copy the current command into a temp buffer
	// NOTE: This is here to avoid the pointers returned by DequeueNextCommand
	// to become invalid by calling AddText. Is there a way we can avoid the memcpy?
	int nLen = strlen(pCommand);
	if (nLen >= COMMAND_MAX_LENGTH - 1) {
		//Warning("CCommand::Tokenize: Encountered command which overflows the tokenizer buffer.. Skipping!\n");
		return false;
	}

	memcpy(m_pArgSBuffer, pCommand, nLen + 1);

	// Parse the current command into the current command buffer
	CUtlBuffer bufParse(m_pArgSBuffer, nLen, CUtlBuffer::TEXT_BUFFER | CUtlBuffer::READ_ONLY);
	int nArgvBufferSize = 0;
	while (bufParse.IsValid() && (m_nArgc < COMMAND_MAX_ARGC)) {
		char* pArgvBuf = &m_pArgvBuffer[nArgvBufferSize];
		int nMaxLen = COMMAND_MAX_LENGTH - nArgvBufferSize;
		int nStartGet = bufParse.TellGet();
		int	nSize = bufParse.ParseToken(pBreakSet, pArgvBuf, nMaxLen);
		if (nSize < 0)
			break;

		// Check for overflow condition
		if (nMaxLen == nSize) {
			Reset();
			return false;
		}

		if (m_nArgc == 1) {
			// Deal with the case where the arguments were quoted
			m_nArgv0Size = bufParse.TellGet();
			bool bFoundEndQuote = m_pArgSBuffer[m_nArgv0Size - 1] == '\"';
			if (bFoundEndQuote) {
				--m_nArgv0Size;
			}
			m_nArgv0Size -= nSize;
			assert(m_nArgv0Size != 0);

			// The StartGet check is to handle this case: "foo"bar
			// which will parse into 2 different args. ArgS should point to bar.
			bool bFoundStartQuote = (m_nArgv0Size > nStartGet) && (m_pArgSBuffer[m_nArgv0Size - 1] == '\"');
			assert(bFoundEndQuote == bFoundStartQuote);
			if (bFoundStartQuote) {
				--m_nArgv0Size;
			}
		}

		m_ppArgv[m_nArgc++] = pArgvBuf;
		if (m_nArgc >= COMMAND_MAX_ARGC) {
			//Warning("CCommand::Tokenize: Encountered command which overflows the argument buffer.. Clamped!\n");
		}

		nArgvBufferSize += nSize + 1;
		assert(nArgvBufferSize <= COMMAND_MAX_LENGTH);
	}

	return true;
}

const char* CCommand::FindArg(const char* pName) const
{
	int nArgC = ArgC();
	for (int i = 1; i < nArgC; i++) {
		if (!_stricmp(Arg(i), pName))
			return (i + 1) < nArgC ? Arg(i + 1) : "";
	}
	return 0;
}

int CCommand::FindArgInt(const char* pName, int nDefaultVal) const
{
	const char* pVal = FindArg(pName);
	if (pVal)
		return atoi(pVal);
	else
		return nDefaultVal;
}

int DefaultCompletionFunc(const char* partial, char commands[COMMAND_COMPLETION_MAXITEMS][COMMAND_COMPLETION_ITEM_LENGTH])
{
	return 0;
}

ConCommand::ConCommand(const char* pName, FnCommandCallbackV1_t callback, const char* pHelpString /*= 0*/, int flags /*= 0*/, FnCommandCompletionCallback completionFunc /*= 0*/)
{
	// Set the callback
	m_fnCommandCallbackV1 = callback;
	m_bUsingNewCommandCallback = false;
	m_bUsingCommandCallbackInterface = false;
	m_fnCompletionCallback = completionFunc ? completionFunc : DefaultCompletionFunc;
	m_bHasCompletionCallback = completionFunc != 0 ? true : false;

	// Setup the rest
	BaseClass::Create(pName, pHelpString, flags);
}

ConCommand::ConCommand(const char* pName, FnCommandCallback_t callback, const char* pHelpString /*= 0*/, int flags /*= 0*/, FnCommandCompletionCallback completionFunc /*= 0*/)
{
	// Set the callback
	m_fnCommandCallback = callback;
	m_bUsingNewCommandCallback = true;
	m_fnCompletionCallback = completionFunc ? completionFunc : DefaultCompletionFunc;
	m_bHasCompletionCallback = completionFunc != 0 ? true : false;
	m_bUsingCommandCallbackInterface = false;

	// Setup the rest
	BaseClass::Create(pName, pHelpString, flags);
}

ConCommand::ConCommand(const char* pName, ICommandCallback* pCallback, const char* pHelpString /*= 0*/, int flags /*= 0*/, ICommandCompletionCallback* pCompletionCallback /*= 0*/)
{
	// Set the callback
	m_pCommandCallback = pCallback;
	m_bUsingNewCommandCallback = false;
	m_pCommandCompletionCallback = pCompletionCallback;
	m_bHasCompletionCallback = (pCompletionCallback != 0);
	m_bUsingCommandCallbackInterface = true;

	// Setup the rest
	BaseClass::Create(pName, pHelpString, flags);
}

ConCommand::~ConCommand(void)
{
}

bool ConCommand::IsCommand(void) const
{
	return true;
}

void ConCommand::Dispatch(const CCommand& command)
{
	if (m_bUsingNewCommandCallback) {
		if (m_fnCommandCallback) {
			(*m_fnCommandCallback)(command);
			return;
		}
	}
	else if (m_bUsingCommandCallbackInterface) {
		if (m_pCommandCallback) {
			m_pCommandCallback->CommandCallback(command);
			return;
		}
	}
	else {
		if (m_fnCommandCallbackV1) {
			(*m_fnCommandCallbackV1)();
			return;
		}
	}

	// Command without callback!!!
	//AssertMsg(0, ("Encountered ConCommand without a callback!\n"));
}

int	ConCommand::AutoCompleteSuggest(const char* partial, CUtlVector< CUtlString >& commands)
{
	if (m_bUsingCommandCallbackInterface) {
		if (!m_pCommandCompletionCallback)
			return 0;
		return m_pCommandCompletionCallback->CommandCompletionCallback(partial, commands);
	}

	if (!m_fnCompletionCallback)
		return 0;

	char rgpchCommands[COMMAND_COMPLETION_MAXITEMS][COMMAND_COMPLETION_ITEM_LENGTH];
	int iret = (m_fnCompletionCallback)(partial, rgpchCommands);
	for (int i = 0; i < iret; ++i) {
		CUtlString str = rgpchCommands[i];
		commands.AddToTail(str);
	}
	return iret;
}

bool ConCommand::CanAutoComplete(void)
{
	return m_bHasCompletionCallback;
}

ConVar::ConVar(const char* pName, const char* pDefaultValue, int flags /* = 0 */)
{
	Create(pName, pDefaultValue, flags);
}

ConVar::ConVar(const char* pName, const char* pDefaultValue, int flags, const char* pHelpString)
{
	Create(pName, pDefaultValue, flags, pHelpString);
}

ConVar::ConVar(const char* pName, const char* pDefaultValue, int flags, const char* pHelpString, bool bMin, float fMin, bool bMax, float fMax)
{
	Create(pName, pDefaultValue, flags, pHelpString, bMin, fMin, bMax, fMax);
}

ConVar::ConVar(const char* pName, const char* pDefaultValue, int flags, const char* pHelpString, FnChangeCallback_t callback)
{
	Create(pName, pDefaultValue, flags, pHelpString, false, 0.0, false, 0.0, callback);
}

ConVar::ConVar(const char* pName, const char* pDefaultValue, int flags, const char* pHelpString, bool bMin, float fMin, bool bMax, float fMax, FnChangeCallback_t callback)
{
	Create(pName, pDefaultValue, flags, pHelpString, bMin, fMin, bMax, fMax, callback);
}

ConVar::~ConVar(void)
{
	//if(IsRegistered())
	//    convar->UnregisterConCommand(this);
	if (m_Value.m_pszString) {
		delete[] m_Value.m_pszString;
		m_Value.m_pszString = NULL;
	}
}

void ConVar::InstallChangeCallback(FnChangeCallback_t callback, bool bInvoke)
{
	if (callback) {
		if (m_fnChangeCallbacks.GetOffset(callback) != -1) {
			m_fnChangeCallbacks.AddToTail(callback);
			if (bInvoke)
				callback(this, m_Value.m_pszString, m_Value.m_fValue);
		}
		else {
			//Warning("InstallChangeCallback ignoring duplicate change callback!!!\n");
		}
	}
	else {
		//Warning("InstallChangeCallback called with NULL callback, ignoring!!!\n");
	}
}

bool ConVar::IsFlagSet(int flag) const
{
	return (flag & m_pParent->m_nFlags) ? true : false;
}

const char* ConVar::GetHelpText(void) const
{
	return m_pParent->m_pszHelpString;
}

void ConVar::AddFlags(int flags)
{
	m_pParent->m_nFlags |= flags;

#ifdef ALLOW_DEVELOPMENT_CVARS
	m_pParent->m_nFlags &= ~FCVAR_DEVELOPMENTONLY;
#endif
}

int ConVar::GetFlags(void) const
{
	return m_pParent->m_nFlags;
}

bool ConVar::IsRegistered(void) const
{
	return m_pParent->m_bRegistered;
}

const char* ConVar::GetName(void) const
{
	return m_pParent->m_pszName;
}

bool ConVar::IsCommand(void) const
{
	return false;
}

void ConVar::Init()
{
	BaseClass::Init();
}

const char* ConVar::GetBaseName(void) const
{
	return m_pParent->m_pszName;
}

int ConVar::GetSplitScreenPlayerSlot(void) const
{
	return 0;
}

void ConVar::InternalSetValue(const char* value)
{
	float fNewValue;
	char  tempVal[32];
	char* val;

	auto temp = *(uint32_t*)&m_Value.m_fValue ^ (uint32_t)this;
	float flOldValue = *(float*)(&temp);

	val = (char*)value;
	fNewValue = (float)atof(value);

	if (ClampValue(fNewValue)) {
		snprintf(tempVal, sizeof(tempVal), "%f", fNewValue);
		val = tempVal;
	}

	// Redetermine value
	*(uint32_t*)&m_Value.m_fValue = *(uint32_t*)&fNewValue ^ (uint32_t)this;
	*(uint32_t*)&m_Value.m_nValue = (uint32_t)fNewValue ^ (uint32_t)this;

	if (!(m_nFlags & FCVAR_NEVER_AS_STRING)) {
		ChangeStringValue(val, flOldValue);
	}
}

void ConVar::ChangeStringValue(const char* tempVal, float flOldValue)
{
	char* pszOldValue = (char*)stackalloc(m_Value.m_StringLength);
	memcpy(pszOldValue, m_Value.m_pszString, m_Value.m_StringLength);

	int len = strlen(tempVal) + 1;

	if (len > m_Value.m_StringLength) {
		if (m_Value.m_pszString) {
			delete[] m_Value.m_pszString;
		}

		m_Value.m_pszString = new char[len];
		m_Value.m_StringLength = len;
	}

	memcpy(m_Value.m_pszString, tempVal, len);

	// Invoke any necessary callback function
	for (int i = 0; i < m_fnChangeCallbacks.Count(); i++) {
		m_fnChangeCallbacks[i](this, pszOldValue, flOldValue);
	}

	if (g::cvar)
		g::cvar->call_callbacks(this, pszOldValue, flOldValue);
}

bool ConVar::ClampValue(float& value)
{
	if (m_bHasMin && (value < m_fMinVal)) {
		value = m_fMinVal;
		return true;
	}

	if (m_bHasMax && (value > m_fMaxVal)) {
		value = m_fMaxVal;
		return true;
	}

	return false;
}

void ConVar::InternalSetFloatValue(float fNewValue)
{
	if (fNewValue == m_Value.m_fValue)
		return;

	ClampValue(fNewValue);

	// Redetermine value
	float flOldValue = m_Value.m_fValue;
	*(uint32_t*)&m_Value.m_fValue = *(uint32_t*)&fNewValue ^ (uint32_t)this;
	*(uint32_t*)&m_Value.m_nValue = (uint32_t)fNewValue ^ (uint32_t)this;

	if (!(m_nFlags & FCVAR_NEVER_AS_STRING)) {
		char tempVal[32];
		snprintf(tempVal, sizeof(tempVal), "%f", m_Value.m_fValue);
		ChangeStringValue(tempVal, flOldValue);
	}
	else {
		//assert(m_fnChangeCallbacks.Count() == 0);
	}
}

void ConVar::InternalSetIntValue(int nValue)
{
	if (nValue == ((int)m_Value.m_nValue ^ (int)this))
		return;

	float fValue = (float)nValue;
	if (ClampValue(fValue)) {
		nValue = (int)(fValue);
	}

	// Redetermine value
	float flOldValue = m_Value.m_fValue;
	*(uint32_t*)&m_Value.m_fValue = *(uint32_t*)&fValue ^ (uint32_t)this;
	*(uint32_t*)&m_Value.m_nValue = *(uint32_t*)&nValue ^ (uint32_t)this;

	if (!(m_nFlags & FCVAR_NEVER_AS_STRING)) {
		char tempVal[32];
		snprintf(tempVal, sizeof(tempVal), "%d", m_Value.m_nValue);
		ChangeStringValue(tempVal, flOldValue);
	}
	else {
		//assert(m_fnChangeCallbacks.Count() == 0);
	}
}

void ConVar::InternalSetColorValue(Color cValue)
{
	int color = (int)cValue.GetRawColor();
	InternalSetIntValue(color);
}

void ConVar::Create(const char* pName, const char* pDefaultValue, int flags /*= 0*/,
	const char* pHelpString /*= NULL*/, bool bMin /*= false*/, float fMin /*= 0.0*/,
	bool bMax /*= false*/, float fMax /*= false*/, FnChangeCallback_t callback /*= NULL*/)
{
	static const char* empty_string = "";

	m_pParent = this;

	// Name should be static data
	m_pszDefaultValue = pDefaultValue ? pDefaultValue : empty_string;

	m_Value.m_StringLength = strlen(m_pszDefaultValue) + 1;
	m_Value.m_pszString = new char[m_Value.m_StringLength];
	memcpy(m_Value.m_pszString, m_pszDefaultValue, m_Value.m_StringLength);

	m_bHasMin = bMin;
	m_fMinVal = fMin;
	m_bHasMax = bMax;
	m_fMaxVal = fMax;

	if (callback)
		m_fnChangeCallbacks.AddToTail(callback);

	float value = (float)atof(m_Value.m_pszString);

	*(uint32_t*)&m_Value.m_fValue = *(uint32_t*)&value ^ (uint32_t)this;
	*(uint32_t*)&m_Value.m_nValue = *(uint32_t*)&value ^ (uint32_t)this;

	BaseClass::Create(pName, pHelpString, flags);
}

void ConVar::SetValue(const char* value)
{
	ConVar* var = (ConVar*)m_pParent;
	var->InternalSetValue(value);
}

void ConVar::SetValue(float value)
{
	ConVar* var = (ConVar*)m_pParent;
	var->InternalSetFloatValue(value);
}

void ConVar::SetValue(int value)
{
	ConVar* var = (ConVar*)m_pParent;
	var->InternalSetIntValue(value);
}

void ConVar::SetValue(Color value)
{
	ConVar* var = (ConVar*)m_pParent;
	var->InternalSetColorValue(value);
}

void ConVar::Revert(void)
{
	// Force default value again
	ConVar* var = (ConVar*)m_pParent;
	var->SetValue(var->m_pszDefaultValue);
}

bool ConVar::GetMin(float& minVal) const
{
	minVal = m_pParent->m_fMinVal;
	return m_pParent->m_bHasMin;
}

bool ConVar::GetMax(float& maxVal) const
{
	maxVal = m_pParent->m_fMaxVal;
	return m_pParent->m_bHasMax;
}

const char* ConVar::GetDefault(void) const
{
	return m_pParent->m_pszDefaultValue;
}
```

`src/valve_sdk/misc/Convar.hpp`:

```hpp
#pragma once

#include <cstdint>
#include "../interfaces/IConVar.hpp"
#include "UtlVector.hpp"
#include "UtlString.hpp"

#define FORCEINLINE_CVAR inline
//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
class ConVar;
class CCommand;
class ConCommand;
class ConCommandBase;
struct characterset_t;

class CCommand
{
public:
	CCommand();
	CCommand(int nArgC, const char** ppArgV);
	bool Tokenize(const char* pCommand, characterset_t* pBreakSet = NULL);
	void Reset();

	int ArgC() const;
	const char** ArgV() const;
	const char* ArgS() const;					        // All args that occur after the 0th arg, in string form
	const char* GetCommandString() const;		  // The entire command in string form, including the 0th arg
	const char* operator[](int nIndex) const;	// Gets at arguments
	const char* Arg(int nIndex) const;		      // Gets at arguments

												  // Helper functions to parse arguments to commands.
	const char* FindArg(const char* pName) const;
	int FindArgInt(const char* pName, int nDefaultVal) const;

	static int MaxCommandLength();
	static characterset_t* DefaultBreakSet();

private:
	enum
	{
		COMMAND_MAX_ARGC = 64,
		COMMAND_MAX_LENGTH = 512,
	};

	int		m_nArgc;
	int		m_nArgv0Size;
	char	m_pArgSBuffer[COMMAND_MAX_LENGTH];
	char	m_pArgvBuffer[COMMAND_MAX_LENGTH];
	const char* m_ppArgv[COMMAND_MAX_ARGC];
};

inline int CCommand::MaxCommandLength()
{
	return COMMAND_MAX_LENGTH - 1;
}

inline int CCommand::ArgC() const
{
	return m_nArgc;
}

inline const char** CCommand::ArgV() const
{
	return m_nArgc ? (const char**)m_ppArgv : NULL;
}

inline const char* CCommand::ArgS() const
{
	return m_nArgv0Size ? &m_pArgSBuffer[m_nArgv0Size] : "";
}

inline const char* CCommand::GetCommandString() const
{
	return m_nArgc ? m_pArgSBuffer : "";
}

inline const char* CCommand::Arg(int nIndex) const
{
	// FIXME: Many command handlers appear to not be particularly careful
	// about checking for valid argc range. For now, we're going to
	// do the extra check and return an empty string if it's out of range
	if (nIndex < 0 || nIndex >= m_nArgc)
		return "";
	return m_ppArgv[nIndex];
}

inline const char* CCommand::operator[](int nIndex) const
{
	return Arg(nIndex);
}

//-----------------------------------------------------------------------------
// Any executable that wants to use ConVars need to implement one of
// these to hook up access to console variables.
//-----------------------------------------------------------------------------
class IConCommandBaseAccessor
{
public:
	// Flags is a combination of FCVAR flags in cvar.h.
	// hOut is filled in with a handle to the variable.
	virtual bool RegisterConCommandBase(ConCommandBase* pVar) = 0;
};

//-----------------------------------------------------------------------------
// Called when a ConCommand needs to execute
//-----------------------------------------------------------------------------
typedef void(*FnCommandCallbackV1_t)(void);
typedef void(*FnCommandCallback_t)(const CCommand& command);

#define COMMAND_COMPLETION_MAXITEMS       64
#define COMMAND_COMPLETION_ITEM_LENGTH    64

//-----------------------------------------------------------------------------
// Returns 0 to COMMAND_COMPLETION_MAXITEMS worth of completion strings
//-----------------------------------------------------------------------------
typedef int(*FnCommandCompletionCallback)(const char* partial, char commands[COMMAND_COMPLETION_MAXITEMS][COMMAND_COMPLETION_ITEM_LENGTH]);

//-----------------------------------------------------------------------------
// Interface version
//-----------------------------------------------------------------------------
class ICommandCallback
{
public:
	virtual void CommandCallback(const CCommand& command) = 0;
};

class ICommandCompletionCallback
{
public:
	virtual int  CommandCompletionCallback(const char* pPartial, CUtlVector<CUtlString>& commands) = 0;
};
enum CVarDLLIdentifier_t;
//-----------------------------------------------------------------------------
// Purpose: The base console invoked command/cvar interface
//-----------------------------------------------------------------------------
class ConCommandBase
{
	friend class CCvar;
	friend class ConVar;
	friend class ConCommand;
	friend void ConVar_Register(int nCVarFlag, IConCommandBaseAccessor* pAccessor);

	// FIXME: Remove when ConVar changes are done
	friend class CDefaultCvar;

public:
	ConCommandBase(void);
	ConCommandBase(const char* pName, const char* pHelpString = 0, int flags = 0);

	virtual                     ~ConCommandBase(void);
	virtual bool                IsCommand(void) const;
	virtual bool                IsFlagSet(int flag) const;
	virtual void                AddFlags(int flags);
	virtual void                RemoveFlags(int flags);
	virtual int                 GetFlags() const;
	virtual const char* GetName(void) const;
	virtual const char* GetHelpText(void) const;
	const ConCommandBase* GetNext(void) const;
	ConCommandBase* GetNext(void);
	virtual bool                IsRegistered(void) const;
	virtual CVarDLLIdentifier_t GetDLLIdentifier() const;

	//protected:
	virtual void                Create(const char* pName, const char* pHelpString = 0, int flags = 0);
	virtual void                Init();
	void                        Shutdown();
	char* CopyString(const char* from);

	//private:
	// Next ConVar in chain
	// Prior to register, it points to the next convar in the DLL.
	// Once registered, though, m_pNext is reset to point to the next
	// convar in the global list
	ConCommandBase* m_pNext;
	bool                        m_bRegistered;
	const char* m_pszName;
	const char* m_pszHelpString;
	int                         m_nFlags;

protected:
	// ConVars add themselves to this list for the executable.
	// Then ConVar_Register runs through  all the console variables
	// and registers them into a global list stored in vstdlib.dll
	static ConCommandBase* s_pConCommandBases;

	// ConVars in this executable use this 'global' to access values.
	static IConCommandBaseAccessor* s_pAccessor;

public:
	// This list will hold all the registered commands.
	// It is not from the official SDK. I've added this so that
	// we can parse all convars we have created if we want to
	// save them to a file later on, for example.
	static ConCommandBase* s_pRegisteredCommands;
};

//-----------------------------------------------------------------------------
// Purpose: The console invoked command
//-----------------------------------------------------------------------------
class ConCommand : public ConCommandBase
{
	friend class CCvar;

public:
	typedef ConCommandBase BaseClass;

	ConCommand(const char* pName, FnCommandCallbackV1_t callback,
		const char* pHelpString = 0, int flags = 0, FnCommandCompletionCallback completionFunc = 0);
	ConCommand(const char* pName, FnCommandCallback_t callback,
		const char* pHelpString = 0, int flags = 0, FnCommandCompletionCallback completionFunc = 0);
	ConCommand(const char* pName, ICommandCallback* pCallback,
		const char* pHelpString = 0, int flags = 0, ICommandCompletionCallback * pCommandCompletionCallback = 0);

	virtual         ~ConCommand(void);
	virtual bool    IsCommand(void) const;
	virtual int     AutoCompleteSuggest(const char* partial, CUtlVector<CUtlString>& commands);
	virtual bool    CanAutoComplete(void);
	virtual void    Dispatch(const CCommand& command);

	//private:
	// NOTE: To maintain backward compat, we have to be very careful:
	// All public virtual methods must appear in the same order always
	// since engine code will be calling into this code, which *does not match*
	// in the mod code; it's using slightly different, but compatible versions
	// of this class. Also: Be very careful about adding new fields to this class.
	// Those fields will not exist in the version of this class that is instanced
	// in mod code.

	// Call this function when executing the command
	union
	{
		FnCommandCallbackV1_t       m_fnCommandCallbackV1;
		FnCommandCallback_t         m_fnCommandCallback;
		ICommandCallback* m_pCommandCallback;
	};

	union
	{
		FnCommandCompletionCallback m_fnCompletionCallback;
		ICommandCompletionCallback* m_pCommandCompletionCallback;
	};

	bool m_bHasCompletionCallback : 1;
	bool m_bUsingNewCommandCallback : 1;
	bool m_bUsingCommandCallbackInterface : 1;
};

//-----------------------------------------------------------------------------
// Purpose: A console variable
//-----------------------------------------------------------------------------
class ConVar : public ConCommandBase, public IConVar
{
	friend class CCvar;
	friend class ConVarRef;
	friend class SplitScreenConVarRef;

public:
	typedef ConCommandBase BaseClass;

	ConVar(const char* pName, const char* pDefaultValue, int flags = 0);
	ConVar(const char* pName, const char* pDefaultValue, int flags, const char* pHelpString);
	ConVar(const char* pName, const char* pDefaultValue, int flags, const char* pHelpString, bool bMin, float fMin, bool bMax, float fMax);
	ConVar(const char* pName, const char* pDefaultValue, int flags, const char* pHelpString, FnChangeCallback_t callback);
	ConVar(const char* pName, const char* pDefaultValue, int flags, const char* pHelpString, bool bMin, float fMin, bool bMax, float fMax, FnChangeCallback_t callback);

	virtual                     ~ConVar(void);
	virtual bool                IsFlagSet(int flag) const;
	virtual const char* GetHelpText(void) const;
	virtual bool                IsRegistered(void) const;
	virtual const char* GetName(void) const;
	virtual const char* GetBaseName(void) const;
	virtual int                 GetSplitScreenPlayerSlot() const;

	virtual void                AddFlags(int flags);
	virtual int                 GetFlags() const;
	virtual bool                IsCommand(void) const;

	// Install a change callback (there shouldn't already be one....)
	void InstallChangeCallback(FnChangeCallback_t callback, bool bInvoke = true);
	void RemoveChangeCallback(FnChangeCallback_t callbackToRemove);

	int GetChangeCallbackCount() const { return m_pParent->m_fnChangeCallbacks.Count(); }
	FnChangeCallback_t GetChangeCallback(int slot) const { return m_pParent->m_fnChangeCallbacks[slot]; }

	// Retrieve value
	virtual float                   GetFloat(void) const;
	virtual int                     GetInt(void) const;
	FORCEINLINE_CVAR Color          GetColor(void) const;
	FORCEINLINE_CVAR bool           GetBool() const { return !!GetInt(); }
	FORCEINLINE_CVAR char const* GetString(void) const;

	// Compiler driven selection for template use
	template <typename T> T Get(void) const;
	template <typename T> T Get(T*) const;

	// Any function that allocates/frees memory needs to be virtual or else you'll have crashes
	//  from alloc/free across dll/exe boundaries.

	// These just call into the IConCommandBaseAccessor to check flags and Set the var (which ends up calling InternalSetValue).
	virtual void                    SetValue(const char* value);
	virtual void                    SetValue(float value);
	virtual void                    SetValue(int value);
	virtual void                    SetValue(Color value);

	// Reset to default value
	void                            Revert(void);
	bool                            HasMin() const;
	bool                            HasMax() const;
	bool                            GetMin(float& minVal) const;
	bool                            GetMax(float& maxVal) const;
	float                           GetMinValue() const;
	float                           GetMaxValue() const;
	const char* GetDefault(void) const;

	struct CVValue_t
	{
		char* m_pszString;
		int     m_StringLength;
		float   m_fValue;
		int     m_nValue;
	};

	FORCEINLINE_CVAR CVValue_t& GetRawValue()
	{
		return m_Value;
	}
	FORCEINLINE_CVAR const CVValue_t& GetRawValue() const
	{
		return m_Value;
	}

	//private:
	bool                        InternalSetColorFromString(const char* value);
	virtual void                InternalSetValue(const char* value);
	virtual void                InternalSetFloatValue(float fNewValue);
	virtual void                InternalSetIntValue(int nValue);
	virtual void                InternalSetColorValue(Color value);
	virtual bool                ClampValue(float& value);
	virtual void                ChangeStringValue(const char* tempVal, float flOldValue);
	virtual void                Create(const char* pName, const char* pDefaultValue, int flags = 0, const char* pHelpString = 0, bool bMin = false, float fMin = 0.0, bool bMax = false, float fMax = false, FnChangeCallback_t callback = 0);

	// Used internally by OneTimeInit to Initialize.
	virtual void                Init();

	//protected:
	ConVar* m_pParent;
	const char* m_pszDefaultValue;
	CVValue_t                   m_Value;
	bool                        m_bHasMin;
	float                       m_fMinVal;
	bool                        m_bHasMax;
	float                       m_fMaxVal;

	// Call this function when ConVar changes
	CUtlVector<FnChangeCallback_t> m_fnChangeCallbacks;
};

//-----------------------------------------------------------------------------
// Purpose: Return ConVar value as a float
// Output : float
//-----------------------------------------------------------------------------
FORCEINLINE_CVAR float ConVar::GetFloat(void) const
{
	uint32_t xored = *(uint32_t*)& m_pParent->m_Value.m_fValue ^ (uint32_t)this;
	return *(float*)& xored;
}

//-----------------------------------------------------------------------------
// Purpose: Return ConVar value as an int
// Output : int
//-----------------------------------------------------------------------------
FORCEINLINE_CVAR int ConVar::GetInt(void) const
{
	return (int)(m_pParent->m_Value.m_nValue ^ (int)this);
}

//-----------------------------------------------------------------------------
// Purpose: Return ConVar value as a color
// Output : Color
//-----------------------------------------------------------------------------
FORCEINLINE_CVAR Color ConVar::GetColor(void) const
{
	int value = GetInt();
	unsigned char* pColorElement = ((unsigned char*)& value);
	return Color(pColorElement[0], pColorElement[1], pColorElement[2], pColorElement[3]);
}

//-----------------------------------------------------------------------------

template <> FORCEINLINE_CVAR float          ConVar::Get<float>(void) const { return GetFloat(); }
template <> FORCEINLINE_CVAR int            ConVar::Get<int>(void) const { return GetInt(); }
template <> FORCEINLINE_CVAR bool           ConVar::Get<bool>(void) const { return GetBool(); }
template <> FORCEINLINE_CVAR const char* ConVar::Get<const char*>(void) const { return GetString(); }
template <> FORCEINLINE_CVAR float          ConVar::Get<float>(float* p) const { return (*p = GetFloat()); }
template <> FORCEINLINE_CVAR int            ConVar::Get<int>(int* p) const { return (*p = GetInt()); }
template <> FORCEINLINE_CVAR bool           ConVar::Get<bool>(bool* p) const { return (*p = GetBool()); }
template <> FORCEINLINE_CVAR const char* ConVar::Get<const char*>(char const** p) const { return (*p = GetString()); }

//-----------------------------------------------------------------------------
// Purpose: Return ConVar value as a string, return "" for bogus string pointer, etc.
// Output : const char *
//-----------------------------------------------------------------------------
FORCEINLINE_CVAR const char* ConVar::GetString(void) const
{
	if (m_nFlags & FCVAR_NEVER_AS_STRING)
		return "FCVAR_NEVER_AS_STRING";
	char const* str = m_pParent->m_Value.m_pszString;
	return str ? str : "";
}

//-----------------------------------------------------------------------------
// Called by the framework to register ConCommands with the ICVar
//-----------------------------------------------------------------------------
void ConVar_Register(int nCVarFlag = 0, IConCommandBaseAccessor * pAccessor = NULL);
void ConVar_Unregister();
```

`src/valve_sdk/misc/EHandle.hpp`:

```hpp
#pragma once

#include "BaseHandle.hpp"
#include "../sdk.hpp"

// -------------------------------------------------------------------------------------------------- //
// Game-code CBaseHandle implementation.
// -------------------------------------------------------------------------------------------------- //

inline IHandleEntity* CBaseHandle::Get() const
{
	return g::entity_list->GetClientEntityFromHandle(*this);
}

// -------------------------------------------------------------------------------------------------- //
// CHandle.
// -------------------------------------------------------------------------------------------------- //
template< class T >
class CHandle : public CBaseHandle
{
public:

	CHandle();
	CHandle(int iEntry, int iSerialNumber);
	CHandle(const CBaseHandle& handle);
	CHandle(T* pVal);

	// The index should have come from a call to ToInt(). If it hasn't, you're in trouble.
	static CHandle<T> FromIndex(int index);

	T* Get() const;
	void	Set(const T* pVal);

	operator T* ();
	operator T* () const;

	bool	operator !() const;
	bool	operator==(T* val) const;
	bool	operator!=(T* val) const;
	const CBaseHandle& operator=(const T* val);

	T* operator->() const;
};

// ----------------------------------------------------------------------- //
// Inlines.
// ----------------------------------------------------------------------- //

template<class T>
CHandle<T>::CHandle()
{
}

template<class T>
CHandle<T>::CHandle(int iEntry, int iSerialNumber)
{
	Init(iEntry, iSerialNumber);
}

template<class T>
CHandle<T>::CHandle(const CBaseHandle& handle)
	: CBaseHandle(handle)
{
}

template<class T>
CHandle<T>::CHandle(T* pObj)
{
	Term();
	Set(pObj);
}

template<class T>
inline CHandle<T> CHandle<T>::FromIndex(int index)
{
	CHandle<T> ret;
	ret.m_Index = index;
	return ret;
}

template<class T>
inline T* CHandle<T>::Get() const
{
	return (T*)CBaseHandle::Get();
}

template<class T>
inline CHandle<T>::operator T* ()
{
	return Get();
}

template<class T>
inline CHandle<T>::operator T* () const
{
	return Get();
}

template<class T>
inline bool CHandle<T>::operator !() const
{
	return !Get();
}

template<class T>
inline bool CHandle<T>::operator==(T* val) const
{
	return Get() == val;
}

template<class T>
inline bool CHandle<T>::operator!=(T* val) const
{
	return Get() != val;
}

template<class T>
void CHandle<T>::Set(const T* pVal)
{
	CBaseHandle::Set(reinterpret_cast<const IHandleEntity*>(pVal));
}

template<class T>
inline const CBaseHandle& CHandle<T>::operator=(const T* val)
{
	Set(val);
	return *this;
}

template<class T>
T* CHandle<T>::operator -> () const
{
	return Get();
}
```

`src/valve_sdk/misc/Enums.hpp`:

```hpp
#pragma once

#include <string>
#include <array>
#include <vector>

enum CSWeaponType
{
	WEAPONTYPE_KNIFE = 0,
	WEAPONTYPE_PISTOL,
	WEAPONTYPE_SUBMACHINEGUN,
	WEAPONTYPE_RIFLE,
	WEAPONTYPE_SHOTGUN,
	WEAPONTYPE_SNIPER_RIFLE,
	WEAPONTYPE_MACHINEGUN,
	WEAPONTYPE_C4,
	WEAPONTYPE_PLACEHOLDER,
	WEAPONTYPE_GRENADE,
	WEAPONTYPE_UNKNOWN
};

enum ECstrike15UserMessages
{
	CS_UM_VGUIMenu = 1,
	CS_UM_Geiger = 2,
	CS_UM_Train = 3,
	CS_UM_HudText = 4,
	CS_UM_SayText = 5,
	CS_UM_SayText2 = 6,
	CS_UM_TextMsg = 7,
	CS_UM_HudMsg = 8,
	CS_UM_ResetHud = 9,
	CS_UM_GameTitle = 10,
	CS_UM_Shake = 12,
	CS_UM_Fade = 13,
	CS_UM_Rumble = 14,
	CS_UM_CloseCaption = 15,
	CS_UM_CloseCaptionDirect = 16,
	CS_UM_SendAudio = 17,
	CS_UM_RawAudio = 18,
	CS_UM_VoiceMask = 19,
	CS_UM_RequestState = 20,
	CS_UM_Damage = 21,
	CS_UM_RadioText = 22,
	CS_UM_HintText = 23,
	CS_UM_KeyHintText = 24,
	CS_UM_ProcessSpottedEntityUpdate = 25,
	CS_UM_ReloadEffect = 26,
	CS_UM_AdjustMoney = 27,
	CS_UM_UpdateTeamMoney = 28,
	CS_UM_StopSpectatorMode = 29,
	CS_UM_KillCam = 30,
	CS_UM_DesiredTimescale = 31,
	CS_UM_CurrentTimescale = 32,
	CS_UM_AchievementEvent = 33,
	CS_UM_MatchEndConditions = 34,
	CS_UM_DisconnectToLobby = 35,
	CS_UM_PlayerStatsUpdate = 36,
	CS_UM_DisplayInventory = 37,
	CS_UM_WarmupHasEnded = 38,
	CS_UM_ClientInfo = 39,
	CS_UM_XRankGet = 40,
	CS_UM_XRankUpd = 41,
	CS_UM_CallVoteFailed = 45,
	CS_UM_VoteStart = 46,
	CS_UM_VotePass = 47,
	CS_UM_VoteFailed = 48,
	CS_UM_VoteSetup = 49,
	CS_UM_ServerRankRevealAll = 50,
	CS_UM_SendLastKillerDamageToClient = 51,
	CS_UM_ServerRankUpdate = 52,
	CS_UM_ItemPickup = 53,
	CS_UM_ShowMenu = 54,
	CS_UM_BarTime = 55,
	CS_UM_AmmoDenied = 56,
	CS_UM_MarkAchievement = 57,
	CS_UM_MatchStatsUpdate = 58,
	CS_UM_ItemDrop = 59,
	CS_UM_GlowPropTurnOff = 60,
	CS_UM_SendPlayerItemDrops = 61,
	CS_UM_RoundBackupFilenames = 62,
	CS_UM_SendPlayerItemFound = 63,
	CS_UM_ReportHit = 64,
	CS_UM_XpUpdate = 65,
	CS_UM_QuestProgress = 66,
	CS_UM_ScoreLeaderboardData = 67,
	CS_UM_PlayerDecalDigitalSignature = 68,
	MAX_ECSTRIKE15USERMESSAGES
};

enum EItemDefinitionIndex : short
{
	WEAPON_NONE = 0,
	WEAPON_DEAGLE,
	WEAPON_ELITE,
	WEAPON_FIVESEVEN,
	WEAPON_GLOCK,
	WEAPON_AK47 = 7,
	WEAPON_AUG,
	WEAPON_AWP,
	WEAPON_FAMAS,
	WEAPON_G3SG1,
	WEAPON_GALILAR = 13,
	WEAPON_M249,
	WEAPON_M4A1 = 16,
	WEAPON_MAC10,
	WEAPON_P90 = 19,
	WEAPON_MP5SD = 23,
	WEAPON_UMP45,
	WEAPON_XM1014,
	WEAPON_BIZON,
	WEAPON_MAG7,
	WEAPON_NEGEV,
	WEAPON_SAWEDOFF,
	WEAPON_TEC9,
	WEAPON_TASER,
	WEAPON_HKP2000,
	WEAPON_MP7,
	WEAPON_MP9,
	WEAPON_NOVA,
	WEAPON_P250,
	WEAPON_SHIELD,
	WEAPON_SCAR20,
	WEAPON_SG556,
	WEAPON_SSG08,
	WEAPON_KNIFEGG,
	WEAPON_KNIFE,
	WEAPON_FLASHBANG,
	WEAPON_HEGRENADE,
	WEAPON_SMOKEGRENADE,
	WEAPON_MOLOTOV,
	WEAPON_DECOY,
	WEAPON_INCGRENADE,
	WEAPON_C4,
	WEAPON_HEALTHSHOT = 57,
	WEAPON_KNIFE_T = 59,
	WEAPON_M4A1_SILENCER,
	WEAPON_USP_SILENCER,
	WEAPON_CZ75A = 63,
	WEAPON_REVOLVER,
	WEAPON_TAGRENADE = 68,
	WEAPON_FISTS,
	WEAPON_BREACHCHARGE,
	WEAPON_TABLET = 72,
	WEAPON_MELEE = 74,
	WEAPON_AXE,
	WEAPON_HAMMER,
	WEAPON_SPANNER = 78,
	WEAPON_KNIFE_GHOST = 80,
	WEAPON_FIREBOMB,
	WEAPON_DIVERSION,
	WEAPON_FRAG_GRENADE,
	WEAPON_SNOWBALL,
	WEAPON_BUMPMINE,
	WEAPON_KNIFE_BAYONET = 500,
	WEAPON_KNIFE_CSS = 503,
	WEAPON_KNIFE_FLIP = 505,
	WEAPON_KNIFE_GUT = 506,
	WEAPON_KNIFE_KARAMBIT = 507,
	WEAPON_KNIFE_M9_BAYONET = 508,
	WEAPON_KNIFE_TACTICAL = 509,
	WEAPON_KNIFE_FALCHION = 512,
	WEAPON_KNIFE_SURVIVAL_BOWIE = 514,
	WEAPON_KNIFE_BUTTERFLY = 515,
	WEAPON_KNIFE_PUSH = 516,
	WEAPON_KNIFE_CORD = 517,
	WEAPON_KNIFE_CANIS = 518,
	WEAPON_KNIFE_URSUS = 519,
	WEAPON_KNIFE_GYPSY_JACKKNIFE = 520,
	WEAPON_KNIFE_OUTDOOR = 521,
	WEAPON_KNIFE_STILETTO = 522,
	WEAPON_KNIFE_WIDOWMAKER = 523,
	WEAPON_KNIFE_SKELETON = 525,
	GLOVE_BROKEN_FANG = 4725,
	GLOVE_STUDDED_BLOODHOUND = 5027,
	GLOVE_T_SIDE = 5028,
	GLOVE_CT_SIDE = 5029,
	GLOVE_SPORTY = 5030,
	GLOVE_SLICK = 5031,
	GLOVE_LEATHER_WRAP = 5032,
	GLOVE_MOTORCYCLE = 5033,
	GLOVE_SPECIALIST = 5034,
	GLOVE_HYDRA = 5035
};

enum EClassId : int
{
	CAI_BaseNPC = 0,
	CAK47 = 1,
	CBaseAnimating = 2,
	CBaseAnimatingOverlay = 3,
	CBaseAttributableItem = 4,
	CBaseButton = 5,
	CBaseCombatCharacter = 6,
	CBaseCombatWeapon = 7,
	CBaseCSGrenade = 8,
	CBaseCSGrenadeProjectile = 9,
	CBaseDoor = 10,
	CBaseEntity = 11,
	CBaseFlex = 12,
	CBaseGrenade = 13,
	CBaseParticleEntity = 14,
	CBasePlayer = 15,
	CBasePropDoor = 16,
	CBaseTeamObjectiveResource = 17,
	CBaseTempEntity = 18,
	CBaseToggle = 19,
	CBaseTrigger = 20,
	CBaseViewModel = 21,
	CBaseVPhysicsTrigger = 22,
	CBaseWeaponWorldModel = 23,
	CBeam = 24,
	CBeamSpotlight = 25,
	CBoneFollower = 26,
	CBRC4Target = 27,
	CBreachCharge = 28,
	CBreachChargeProjectile = 29,
	CBreakableProp = 30,
	CBreakableSurface = 31,
	CBumpMine = 32,
	CBumpMineProjectile = 33,
	CC4 = 34,
	CCascadeLight = 35,
	CChicken = 36,
	CColorCorrection = 37,
	CColorCorrectionVolume = 38,
	CCSGameRulesProxy = 39,
	CCSPlayer = 40,
	CCSPlayerResource = 41,
	CCSRagdoll = 42,
	CCSTeam = 43,
	CDangerZone = 44,
	CDangerZoneController = 45,
	CDEagle = 46,
	CDecoyGrenade = 47,
	CDecoyProjectile = 48,
	CDrone = 49,
	CDronegun = 50,
	CDynamicLight = 51,
	CDynamicProp = 52,
	CEconEntity = 53,
	CEconWearable = 54,
	CEmbers = 55,
	CEntityDissolve = 56,
	CEntityFlame = 57,
	CEntityFreezing = 58,
	CEntityParticleTrail = 59,
	CEnvAmbientLight = 60,
	CEnvDetailController = 61,
	CEnvDOFController = 62,
	CEnvGasCanister = 63,
	CEnvParticleScript = 64,
	CEnvProjectedTexture = 65,
	CEnvQuadraticBeam = 66,
	CEnvScreenEffect = 67,
	CEnvScreenOverlay = 68,
	CEnvTonemapController = 69,
	CEnvWind = 70,
	CFEPlayerDecal = 71,
	CFireCrackerBlast = 72,
	CFireSmoke = 73,
	CFireTrail = 74,
	CFish = 75,
	CFists = 76,
	CFlashbang = 77,
	CFogController = 78,
	CFootstepControl = 79,
	CFunc_Dust = 80,
	CFunc_LOD = 81,
	CFuncAreaPortalWindow = 82,
	CFuncBrush = 83,
	CFuncConveyor = 84,
	CFuncLadder = 85,
	CFuncMonitor = 86,
	CFuncMoveLinear = 87,
	CFuncOccluder = 88,
	CFuncReflectiveGlass = 89,
	CFuncRotating = 90,
	CFuncSmokeVolume = 91,
	CFuncTrackTrain = 92,
	CGameRulesProxy = 93,
	CGrassBurn = 94,
	CHandleTest = 95,
	CHEGrenade = 96,
	CHostage = 97,
	CHostageCarriableProp = 98,
	CIncendiaryGrenade = 99,
	CInferno = 100,
	CInfoLadderDismount = 101,
	CInfoMapRegion = 102,
	CInfoOverlayAccessor = 103,
	CItem_Healthshot = 104,
	CItemCash = 105,
	CItemDogtags = 106,
	CKnife = 107,
	CKnifeGG = 108,
	CLightGlow = 109,
	CMapVetoPickController = 110,
	CMaterialModifyControl = 111,
	CMelee = 112,
	CMolotovGrenade = 113,
	CMolotovProjectile = 114,
	CMovieDisplay = 115,
	CParadropChopper = 116,
	CParticleFire = 117,
	CParticlePerformanceMonitor = 118,
	CParticleSystem = 119,
	CPhysBox = 120,
	CPhysBoxMultiplayer = 121,
	CPhysicsProp = 122,
	CPhysicsPropMultiplayer = 123,
	CPhysMagnet = 124,
	CPhysPropAmmoBox = 125,
	CPhysPropLootCrate = 126,
	CPhysPropRadarJammer = 127,
	CPhysPropWeaponUpgrade = 128,
	CPlantedC4 = 129,
	CPlasma = 130,
	CPlayerPing = 131,
	CPlayerResource = 132,
	CPointCamera = 133,
	CPointCommentaryNode = 134,
	CPointWorldText = 135,
	CPoseController = 136,
	CPostProcessController = 137,
	CPrecipitation = 138,
	CPrecipitationBlocker = 139,
	CPredictedViewModel = 140,
	CProp_Hallucination = 141,
	CPropCounter = 142,
	CPropDoorRotating = 143,
	CPropJeep = 144,
	CPropVehicleDriveable = 145,
	CRagdollManager = 146,
	CRagdollProp = 147,
	CRagdollPropAttached = 148,
	CRopeKeyframe = 149,
	CSCAR17 = 150,
	CSceneEntity = 151,
	CSensorGrenade = 152,
	CSensorGrenadeProjectile = 153,
	CShadowControl = 154,
	CSlideshowDisplay = 155,
	CSmokeGrenade = 156,
	CSmokeGrenadeProjectile = 157,
	CSmokeStack = 158,
	CSnowball = 159,
	CSnowballPile = 160,
	CSnowballProjectile = 161,
	CSpatialEntity = 162,
	CSpotlightEnd = 163,
	CSprite = 164,
	CSpriteOriented = 165,
	CSpriteTrail = 166,
	CStatueProp = 167,
	CSteamJet = 168,
	CSun = 169,
	CSunlightShadowControl = 170,
	CSurvivalSpawnChopper = 171,
	CTablet = 172,
	CTeam = 173,
	CTeamplayRoundBasedRulesProxy = 174,
	CTEArmorRicochet = 175,
	CTEBaseBeam = 176,
	CTEBeamEntPoint = 177,
	CTEBeamEnts = 178,
	CTEBeamFollow = 179,
	CTEBeamLaser = 180,
	CTEBeamPoints = 181,
	CTEBeamRing = 182,
	CTEBeamRingPoint = 183,
	CTEBeamSpline = 184,
	CTEBloodSprite = 185,
	CTEBloodStream = 186,
	CTEBreakModel = 187,
	CTEBSPDecal = 188,
	CTEBubbles = 189,
	CTEBubbleTrail = 190,
	CTEClientProjectile = 191,
	CTEDecal = 192,
	CTEDust = 193,
	CTEDynamicLight = 194,
	CTEEffectDispatch = 195,
	CTEEnergySplash = 196,
	CTEExplosion = 197,
	CTEFireBullets = 198,
	CTEFizz = 199,
	CTEFootprintDecal = 200,
	CTEFoundryHelpers = 201,
	CTEGaussExplosion = 202,
	CTEGlowSprite = 203,
	CTEImpact = 204,
	CTEKillPlayerAttachments = 205,
	CTELargeFunnel = 206,
	CTEMetalSparks = 207,
	CTEMuzzleFlash = 208,
	CTEParticleSystem = 209,
	CTEPhysicsProp = 210,
	CTEPlantBomb = 211,
	CTEPlayerAnimEvent = 212,
	CTEPlayerDecal = 213,
	CTEProjectedDecal = 214,
	CTERadioIcon = 215,
	CTEShatterSurface = 216,
	CTEShowLine = 217,
	CTesla = 218,
	CTESmoke = 219,
	CTESparks = 220,
	CTESprite = 221,
	CTESpriteSpray = 222,
	CTest_ProxyToggle_Networkable = 223,
	CTestTraceline = 224,
	CTEWorldDecal = 225,
	CTriggerPlayerMovement = 226,
	CTriggerSoundOperator = 227,
	CVGuiScreen = 228,
	CVoteController = 229,
	CWaterBullet = 230,
	CWaterLODControl = 231,
	CWeaponAug = 232,
	CWeaponAWP = 233,
	CWeaponBaseItem = 234,
	CWeaponBizon = 235,
	CWeaponCSBase = 236,
	CWeaponCSBaseGun = 237,
	CWeaponCycler = 238,
	CWeaponElite = 239,
	CWeaponFamas = 240,
	CWeaponFiveSeven = 241,
	CWeaponG3SG1 = 242,
	CWeaponGalil = 243,
	CWeaponGalilAR = 244,
	CWeaponGlock = 245,
	CWeaponHKP2000 = 246,
	CWeaponM249 = 247,
	CWeaponM3 = 248,
	CWeaponM4A1 = 249,
	CWeaponMAC10 = 250,
	CWeaponMag7 = 251,
	CWeaponMP5Navy = 252,
	CWeaponMP7 = 253,
	CWeaponMP9 = 254,
	CWeaponNegev = 255,
	CWeaponNOVA = 256,
	CWeaponP228 = 257,
	CWeaponP250 = 258,
	CWeaponP90 = 259,
	CWeaponSawedoff = 260,
	CWeaponSCAR20 = 261,
	CWeaponScout = 262,
	CWeaponSG550 = 263,
	CWeaponSG552 = 264,
	CWeaponSG556 = 265,
	CWeaponShield = 266,
	CWeaponSSG08 = 267,
	CWeaponTaser = 268,
	CWeaponTec9 = 269,
	CWeaponTMP = 270,
	CWeaponUMP45 = 271,
	CWeaponUSP = 272,
	CWeaponXM1014 = 273,
	CWeaponZoneRepulsor = 274,
	CWorld = 275,
	CWorldVguiText = 276,
	DustTrail = 277,
	MovieExplosion = 278,
	ParticleSmokeGrenade = 279,
	RocketTrail = 280,
	SmokeTrail = 281,
	SporeExplosion = 282,
	SporeTrail = 283
};

enum ECSPlayerBone
{
	PELVIS = 0,
	SPINE_0,
	SPINE_1,
	SPINE_2,
	SPINE_3,
	NECK_0,
	HEAD_0,
	CLAVICLE_L,
	ARM_UPPER_L,
	ARM_LOWER_L,
	HAND_L,
	FINGER_MIDDLE_META_L,
	FINGER_MIDDLE_0_L,
	FINGER_MIDDLE_1_L,
	FINGER_MIDDLE_2_L,
	FINGER_PINKY_META_L,
	FINGER_PINKY_0_L,
	FINGER_PINKY_1_L,
	FINGER_PINKY_2_L,
	FINGER_INDEX_META_L,
	FINGER_INDEX_0_L,
	FINGER_INDEX_1_L,
	FINGER_INDEX_2_L,
	FINGER_THUMB_0_L,
	FINGER_THUMB_1_L,
	FINGER_THUMB_2_L,
	FINGER_RING_META_L,
	FINGER_RING_0_L,
	FINGER_RING_1_L,
	FINGER_RING_2_L,
	WEAPON_HAND_L,
	ARM_LOWER_L_TWIST,
	ARM_LOWER_L_TWIST1,
	ARM_UPPER_L_TWIST,
	ARM_UPPER_L_TWIST1,
	CLAVICLE_R,
	ARM_UPPER_R,
	ARM_LOWER_R,
	HAND_R,
	FINGER_MIDDLE_META_R,
	FINGER_MIDDLE_0_R,
	FINGER_MIDDLE_1_R,
	FINGER_MIDDLE_2_R,
	FINGER_PINKY_META_R,
	FINGER_PINKY_0_R,
	FINGER_PINKY_1_R,
	FINGER_PINKY_2_R,
	FINGER_INDEX_META_R,
	FINGER_INDEX_0_R,
	FINGER_INDEX_1_R,
	FINGER_INDEX_2_R,
	FINGER_THUMB_0_R,
	FINGER_THUMB_1_R,
	FINGER_THUMB_2_R,
	FINGER_RING_META_R,
	FINGER_RING_0_R,
	FINGER_RING_1_R,
	FINGER_RING_2_R,
	WEAPON_HAND_R,
	ARM_LOWER_R_TWIST,
	ARM_LOWER_R_TWIST1,
	ARM_UPPER_R_TWIST,
	ARM_UPPER_R_TWIST1,
	LEG_UPPER_L,
	LEG_LOWER_L,
	ANKLE_L,
	BALL_L,
	LFOOT_LOCK,
	LEG_UPPER_L_TWIST,
	LEG_UPPER_L_TWIST1,
	LEG_UPPER_R,
	LEG_LOWER_R,
	ANKLE_R,
	BALL_R,
	RFOOT_LOCK,
	LEG_UPPER_R_TWIST,
	LEG_UPPER_R_TWIST1,
	FINGER_PINKY_L_END,
	FINGER_PINKY_R_END,
	VALVEBIPED_WEAPON_BONE,
	LH_IK_DRIVER,
	PRIMARY_JIGGLE_JNT,
	MAX_ECSPLAYERBONES
};

enum EEntityFlag
{
	FL_ONGROUND = (1 << 0),
	FL_DUCKING = (1 << 1),
	FL_WATERJUMP = (1 << 2),
	FL_ONTRAIN = (1 << 3),
	FL_INRAIN = (1 << 4),
	FL_FROZEN = (1 << 5),
	FL_ATCONTROLS = (1 << 6),
	FL_CLIENT = (1 << 7),
	FL_FAKECLIENT = (1 << 8),
	MAX_ENTITYFLAGS
};

enum ELifeState : unsigned char
{
	LIFE_ALIVE = 0,// alive
	LIFE_DYING = 1, // playing death animation or still falling off of a ledge waiting to hit ground
	LIFE_DEAD = 2, // dead. lying still.
	MAX_LIFESTATE
};

enum EWeaponSound
{
	EMPTY,
	SINGLE,
	SINGLE_NPC,
	WPN_DOUBLE, // Can't be "DOUBLE" because windows.h uses it.
	DOUBLE_NPC,
	BURST,
	RELOAD,
	RELOAD_NPC,
	MELEE_MISS,
	MELEE_HIT,
	MELEE_HIT_WORLD,
	SPECIAL1,
	SPECIAL2,
	SPECIAL3,
	TAUNT,
	FAST_RELOAD,
	// Add new shoot sound types here
	REVERSE_THE_NEW_SOUND,
	NUM_SHOOT_SOUND_TYPES,
	MAX_WEAPONSOUND
};

enum EMoveType
{
	MOVETYPE_NONE = 0,
	MOVETYPE_ISOMETRIC,
	MOVETYPE_WALK,
	MOVETYPE_STEP,
	MOVETYPE_FLY,
	MOVETYPE_FLYGRAVITY,
	MOVETYPE_VPHYSICS,
	MOVETYPE_PUSH,
	MOVETYPE_NOCLIP,
	MOVETYPE_LADDER,
	MOVETYPE_OBSERVER,
	MOVETYPE_CUSTOM,
	MOVETYPE_LAST = MOVETYPE_CUSTOM,
	MOVETYPE_MAX_BITS = 4,
	MAX_MOVETYPE
};

enum EClientFrameStage : int
{
	FRAME_UNDEFINED = -1,
	FRAME_START,
	FRAME_NET_UPDATE_START,
	FRAME_NET_UPDATE_POSTDATAUPDATE_START,
	FRAME_NET_UPDATE_POSTDATAUPDATE_END,
	FRAME_NET_UPDATE_END,
	FRAME_RENDER_START,
	FRAME_RENDER_END
};

enum EMaterialVarFlag
{
	MATERIAL_VAR_DEBUG = (1 << 0),
	MATERIAL_VAR_NO_DEBUG_OVERRIDE = (1 << 1),
	MATERIAL_VAR_NO_DRAW = (1 << 2),
	MATERIAL_VAR_USE_IN_FILLRATE_MODE = (1 << 3),
	MATERIAL_VAR_VERTEXCOLOR = (1 << 4),
	MATERIAL_VAR_VERTEXALPHA = (1 << 5),
	MATERIAL_VAR_SELFILLUM = (1 << 6),
	MATERIAL_VAR_ADDITIVE = (1 << 7),
	MATERIAL_VAR_ALPHATEST = (1 << 8),
	//MATERIAL_VAR_UNUSED = (1 << 9),
	MATERIAL_VAR_ZNEARER = (1 << 10),
	MATERIAL_VAR_MODEL = (1 << 11),
	MATERIAL_VAR_FLAT = (1 << 12),
	MATERIAL_VAR_NOCULL = (1 << 13),
	MATERIAL_VAR_NOFOG = (1 << 14),
	MATERIAL_VAR_IGNOREZ = (1 << 15),
	MATERIAL_VAR_DECAL = (1 << 16),
	MATERIAL_VAR_ENVMAPSPHERE = (1 << 17), // OBSOLETE
	MATERIAL_VAR_UNUSED = (1 << 18), // UNUSED
	MATERIAL_VAR_ENVMAPCAMERASPACE = (1 << 19), // OBSOLETE
	MATERIAL_VAR_BASEALPHAENVMAPMASK = (1 << 20),
	MATERIAL_VAR_TRANSLUCENT = (1 << 21),
	MATERIAL_VAR_NORMALMAPALPHAENVMAPMASK = (1 << 22),
	MATERIAL_VAR_NEEDS_SOFTWARE_SKINNING = (1 << 23), // OBSOLETE
	MATERIAL_VAR_OPAQUETEXTURE = (1 << 24),
	MATERIAL_VAR_ENVMAPMODE = (1 << 25), // OBSOLETE
	MATERIAL_VAR_SUPPRESS_DECALS = (1 << 26),
	MATERIAL_VAR_HALFLAMBERT = (1 << 27),
	MATERIAL_VAR_WIREFRAME = (1 << 28),
	MATERIAL_VAR_ALLOWALPHATOCOVERAGE = (1 << 29),
	MATERIAL_VAR_ALPHA_MODIFIED_BY_PROXY = (1 << 30),
	MATERIAL_VAR_VERTEXFOG = (1 << 31),
};

enum EBoxType : int
{
	Normal = 0,
	Corner
};

enum ESequence
{
	SEQUENCE_DEFAULT_DRAW = 0,
	SEQUENCE_DEFAULT_IDLE1 = 1,
	SEQUENCE_DEFAULT_IDLE2 = 2,
	SEQUENCE_DEFAULT_LIGHT_MISS1 = 3,
	SEQUENCE_DEFAULT_LIGHT_MISS2 = 4,
	SEQUENCE_DEFAULT_HEAVY_MISS1 = 9,
	SEQUENCE_DEFAULT_HEAVY_HIT1 = 10,
	SEQUENCE_DEFAULT_HEAVY_BACKSTAB = 11,
	SEQUENCE_DEFAULT_LOOKAT01 = 12,

	SEQUENCE_BUTTERFLY_DRAW = 0,
	SEQUENCE_BUTTERFLY_DRAW2 = 1,
	SEQUENCE_BUTTERFLY_IDLE1 = 2,
	SEQUENCE_BUTTERFLY_IDLE2 = 3,
	SEQUENCE_BUTTERFLY_LIGHT_MISS1 = 4,
	SEQUENCE_BUTTERFLY_LIGHT_MISS2 = 5,
	SEQUENCE_BUTTERFLY_LIGHT_HIT1 = 6,
	SEQUENCE_BUTTERFLY_LIGHT_HIT2 = 7,
	SEQUENCE_BUTTERFLY_LIGHT_BACKSTAB = 8,
	SEQUENCE_BUTTERFLY_LIGHT_BACKSTAB2 = 9,
	SEQUENCE_BUTTERFLY_HEAVY_MISS = 10,
	SEQUENCE_BUTTERFLY_HEAVY_HIT1 = 11,
	SEQUENCE_BUTTERFLY_HEAVY_BACKSTAB = 12,
	SEQUENCE_BUTTERFLY_LOOKAT01 = 13,
	SEQUENCE_BUTTERFLY_LOOKAT02 = 14,
	SEQUENCE_BUTTERFLY_LOOKAT03 = 15,

	SEQUENCE_FALCHION_IDLE1 = 1,
	SEQUENCE_FALCHION_HEAVY_MISS1 = 8,
	SEQUENCE_FALCHION_HEAVY_MISS1_NOFLIP = 9,
	SEQUENCE_FALCHION_LOOKAT01 = 12,
	SEQUENCE_FALCHION_LOOKAT02 = 13,

	SEQUENCE_DAGGERS_IDLE1 = 1,
	SEQUENCE_DAGGERS_LIGHT_MISS1 = 2,
	SEQUENCE_DAGGERS_LIGHT_MISS5 = 6,
	SEQUENCE_DAGGERS_HEAVY_MISS2 = 11,
	SEQUENCE_DAGGERS_HEAVY_MISS1 = 12,

	SEQUENCE_CSS_LOOKAT01 = 14,
	SEQUENCE_CSS_LOOKAT02 = 15,

	SEQUENCE_BOWIE_IDLE1 = 1,
};

enum team : int
{
	team_spec = 1,
	team_t = 2,
	team_ct = 3
};

struct item_setting
{
	bool enabled = false;
	char name[32] = "Default";
	int definition_vector_index = 0;
	int definition_index = 1;
	int paint_kit_vector_index = 0;
	int paint_kit_index = 0;
	int definition_override_vector_index = 0;
	int definition_override_index = 0;
	int seed = 0;
	
	float wear = std::numeric_limits<float>::min();
	char custom_name[32] = "";
};

struct weapon_info_t
{
	constexpr weapon_info_t(const char* model, const char* icon = nullptr) :
		model(model),
		icon(icon)
	{}
	const char* model;
	const char* icon;
};

struct weapon_name_t
{
	constexpr weapon_name_t(const short definition_index, const char* name) :
		definition_index(definition_index),
		name(name)
	{}
	short definition_index = 0;
	const char* name = nullptr;
};
```

`src/valve_sdk/misc/IHandleEntity.hpp`:

```hpp
#pragma once

class CBaseHandle;

class IHandleEntity
{
public:
	virtual ~IHandleEntity() {}
	virtual void SetRefEHandle(const CBaseHandle& handle) = 0;
	virtual const CBaseHandle& GetRefEHandle() const = 0;
};
```

`src/valve_sdk/misc/Recv.hpp`:

```hpp
#pragma once
#include <string>

enum SendPropType
{
	DPT_Int = 0,
	DPT_Float,
	DPT_Vector,
	DPT_VectorXY,
	DPT_String,
	DPT_Array,
	DPT_DataTable,
	DPT_Int64,
	DPT_NUMSendPropTypes
};

class DVariant
{
public:
	union
	{
		float	   m_Float;
		long	   m_Int;
		char* m_pString;
		void* m_pData;
		float	   m_Vector[3];
		__int64  m_Int64;
	};

	SendPropType  m_Type;
};

class RecvTable;
class RecvProp;

class CRecvProxyData
{
public:
	const RecvProp* m_pRecvProp;        // The property it's receiving.
	DVariant		    m_Value;            // The value given to you to store.
	int				    m_iElement;         // Which array element you're getting.
	int				    m_ObjectID;         // The object being referred to.
};

//-----------------------------------------------------------------------------
// pStruct = the base structure of the datatable this variable is in (like c_base_entity)
// pOut    = the variable that this this proxy represents (like c_base_entity::m_SomeValue).
//
// Convert the network-standard-type value in m_Value into your own format in pStruct/pOut.
//-----------------------------------------------------------------------------
typedef void(*RecvVarProxyFn)(const CRecvProxyData* pData, void* pStruct, void* pOut);

// ------------------------------------------------------------------------ //
// ArrayLengthRecvProxies are optionally used to Get the length of the
// incoming array when it changes.
// ------------------------------------------------------------------------ //
typedef void(*ArrayLengthRecvProxyFn)(void* pStruct, int objectID, int currentArrayLength);

// NOTE: DataTable receive proxies work differently than the other proxies.
// pData points at the object + the recv table's offset.
// pOut should be Set to the location of the object to unpack the data table into.
// If the parent object just contains the child object, the default proxy just does *pOut = pData.
// If the parent object points at the child object, you need to dereference the pointer here.
// NOTE: don't ever return null from a DataTable receive proxy function. Bad things will happen.
typedef void(*DataTableRecvVarProxyFn)(const RecvProp* pProp, void** pOut, void* pData, int objectID);

class RecvProp
{
public:
	char* m_pVarName;
	SendPropType            m_RecvType;
	int                     m_Flags;
	int                     m_StringBufferSize;
	int                     m_bInsideArray;
	const void* m_pExtraData;
	RecvProp* m_pArrayProp;
	ArrayLengthRecvProxyFn  m_ArrayLengthProxy;
	RecvVarProxyFn          m_ProxyFn;
	DataTableRecvVarProxyFn m_DataTableProxyFn;
	RecvTable* m_pDataTable;
	int                     m_Offset;
	int                     m_ElementStride;
	int                     m_nElements;
	const char* m_pParentArrayPropName;

	RecvVarProxyFn			GetProxyFn() const;
	void					SetProxyFn(RecvVarProxyFn fn);
	DataTableRecvVarProxyFn	GetDataTableProxyFn() const;
	void					SetDataTableProxyFn(DataTableRecvVarProxyFn fn);
};

class RecvTable
{
public:
	RecvProp* m_pProps;
	int                     m_nProps;
	void* m_pDecoder;
	char* m_pNetTableName;
	bool                    m_bInitialized;
	bool                    m_bInMainList;
};

inline RecvVarProxyFn RecvProp::GetProxyFn() const
{
	return m_ProxyFn;
}

inline void RecvProp::SetProxyFn(RecvVarProxyFn fn)
{
	m_ProxyFn = fn;
}

inline DataTableRecvVarProxyFn RecvProp::GetDataTableProxyFn() const
{
	return m_DataTableProxyFn;
}

inline void RecvProp::SetDataTableProxyFn(DataTableRecvVarProxyFn fn)
{
	m_DataTableProxyFn = fn;
}

class recv_prop_hook
{
private:
	RecvProp* m_property;
	RecvVarProxyFn m_original_proxy_fn;
public:

	recv_prop_hook(RecvProp* prop, const RecvVarProxyFn proxy_fn) : m_property(prop), m_original_proxy_fn(prop->m_ProxyFn)
	{
		set_proxy_function(proxy_fn);
	}

	~recv_prop_hook()
	{
		m_property->m_ProxyFn = m_original_proxy_fn;
	}

	auto get_original_function() const -> RecvVarProxyFn
	{
		return m_original_proxy_fn;
	}

	auto set_proxy_function(const RecvVarProxyFn proxy_fn) const -> void
	{
		m_property->m_ProxyFn = proxy_fn;
	}
};
```

`src/valve_sdk/misc/Studio.hpp`:

```hpp
#pragma once

#include "../math/Vectors.hpp"

typedef float Quaternion[4];
typedef float RadianEuler[3];

#define MAX_QPATH  260

#define BONE_CALCULATE_MASK             0x1F
#define BONE_PHYSICALLY_SIMULATED       0x01    // bone is physically simulated when physics are active
#define BONE_PHYSICS_PROCEDURAL         0x02    // procedural when physics is active
#define BONE_ALWAYS_PROCEDURAL          0x04    // bone is always procedurally animated
#define BONE_SCREEN_ALIGN_SPHERE        0x08    // bone aligns to the screen, not constrained in motion.
#define BONE_SCREEN_ALIGN_CYLINDER      0x10    // bone aligns to the screen, constrained by it's own axis.

#define BONE_USED_MASK                  0x0007FF00
#define BONE_USED_BY_ANYTHING           0x0007FF00
#define BONE_USED_BY_HITBOX             0x00000100    // bone (or child) is used by a hit box
#define BONE_USED_BY_ATTACHMENT         0x00000200    // bone (or child) is used by an attachment point
#define BONE_USED_BY_VERTEX_MASK        0x0003FC00
#define BONE_USED_BY_VERTEX_LOD0        0x00000400    // bone (or child) is used by the toplevel model via skinned vertex
#define BONE_USED_BY_VERTEX_LOD1        0x00000800
#define BONE_USED_BY_VERTEX_LOD2        0x00001000
#define BONE_USED_BY_VERTEX_LOD3        0x00002000
#define BONE_USED_BY_VERTEX_LOD4        0x00004000
#define BONE_USED_BY_VERTEX_LOD5        0x00008000
#define BONE_USED_BY_VERTEX_LOD6        0x00010000
#define BONE_USED_BY_VERTEX_LOD7        0x00020000
#define BONE_USED_BY_BONE_MERGE         0x00040000    // bone is available for bone merge to occur against it

#define BONE_USED_BY_VERTEX_AT_LOD(lod) ( BONE_USED_BY_VERTEX_LOD0 << (lod) )
#define BONE_USED_BY_ANYTHING_AT_LOD(lod) ( ( BONE_USED_BY_ANYTHING & ~BONE_USED_BY_VERTEX_MASK ) | BONE_USED_BY_VERTEX_AT_LOD(lod) )

#define MAX_NUM_LODS 8
#define MAXSTUDIOBONES		128		// total bones actually used

#define BONE_TYPE_MASK                  0x00F00000
#define BONE_FIXED_ALIGNMENT            0x00100000    // bone can't spin 360 degrees, all interpolation is normalized around a fixed orientation

#define BONE_HAS_SAVEFRAME_POS          0x00200000    // Vector48
#define BONE_HAS_SAVEFRAME_ROT64        0x00400000    // Quaternion64
#define BONE_HAS_SAVEFRAME_ROT32        0x00800000    // Quaternion32

enum modtype_t
{
	mod_bad = 0,
	mod_brush,
	mod_sprite,
	mod_studio
};

enum EHitboxes
{
	HITBOX_HEAD = 0, //0 голова
	HITBOX_NECK, // 1 шея
	HITBOX_PELVIS, //2 таз
	HITBOX_BELLY, //3 поясница
	HITBOX_THORAX, //4 живот
	HITBOX_LOWER_CHEST, //5 грудь
	HITBOX_UPPER_CHEST, //6 предплечье
	HITBOX_RIGHT_THIGH, //7 бедро
	HITBOX_LEFT_THIGH, //8 бедро
	HITBOX_RIGHT_CALF, //9 нога
	HITBOX_LEFT_CALF, //10 нога
	HITBOX_RIGHT_FOOT, //11 стопа
	HITBOX_LEFT_FOOT, //12 стопа
	HITBOX_RIGHT_HAND, //13 рука
	HITBOX_LEFT_HAND, //14 рука
	HITBOX_RIGHT_UPPER_ARM,
	HITBOX_RIGHT_FOREARM,
	HITBOX_LEFT_UPPER_ARM,
	HITBOX_LEFT_FOREARM,
	HITBOX_MAX
};

#define HITBOX_CHEST EHitboxes::HITBOX_BELLY

typedef unsigned short MDLHandle_t;

struct mstudiobone_t
{
	int sznameindex;

	inline char* const pszName(void) const
	{
		return ((char*)this) + sznameindex;
	}

	int parent;        // parent bone
	int bonecontroller[6];    // bone controller index, -1 == none

	// default values
	Vector pos;
	Quaternion quat;
	RadianEuler rot;
	// compression scale
	Vector posscale;
	Vector rotscale;

	matrix3x4_t poseToBone;
	Quaternion qAlignment;
	int flags;
	int proctype;
	int procindex;        // procedural rule
	mutable int physicsbone;    // index into physically simulated bone

	inline void* pProcedure() const
	{
		if (procindex == 0)
			return NULL;
		else
			return (void*)(((unsigned char*)this) + procindex);
	};

	int surfacepropidx;

	inline char* const pszSurfaceProp(void) const
	{
		return ((char*)this) + surfacepropidx;
	}

	inline int GetSurfaceProp(void) const
	{
		return surfacepropLookup;
	}

	int contents;        // See BSPFlags.h for the contents flags
	int surfacepropLookup;    // this index must be cached by the loader, not saved in the file
	int unused[7];        // remove as appropriate
};

struct mstudiobbox_t
{
	int         bone;
	int         group;
	Vector      bbmin;
	Vector      bbmax;
	int         szhitboxnameindex;
	int32_t     m_iPad01[3];
	float       m_flRadius;
	int32_t     m_iPad02[4];

	const char* GetName()
	{
		if (!szhitboxnameindex) return nullptr;
		return (const char*)((uint8_t*)this + szhitboxnameindex);
	}
};

struct mstudiohitboxset_t
{
	int    sznameindex;
	int    numhitboxes;
	int    hitboxindex;

	const char* GetName()
	{
		if (!sznameindex) return nullptr;
		return (const char*)((uint8_t*)this + sznameindex);
	}

	mstudiobbox_t* GetHitbox(int i)
	{
		if (i > numhitboxes) return nullptr;
		return (mstudiobbox_t*)((uint8_t*)this + hitboxindex) + i;
	}
};

struct model_t
{
	void* fnHandle;               //0x0000
	char    szName[260];            //0x0004
	__int32 nLoadFlags;             //0x0108
	__int32 nServerCount;           //0x010C
	__int32 type;                   //0x0110
	__int32 flags;                  //0x0114
	Vector  vecMins;                //0x0118
	Vector  vecMaxs;                //0x0124
	float   radius;                 //0x0130
	char    pad[0x1C];              //0x0134
};//Size=0x0150

class studiohdr_t
{
public:
	__int32 id;                     //0x0000
	__int32 version;                //0x0004
	long    checksum;               //0x0008
	char    szName[64];             //0x000C
	__int32 length;                 //0x004C
	Vector  vecEyePos;              //0x0050
	Vector  vecIllumPos;            //0x005C
	Vector  vecHullMin;             //0x0068
	Vector  vecHullMax;             //0x0074
	Vector  vecBBMin;               //0x0080
	Vector  vecBBMax;               //0x008C
	__int32 flags;                  //0x0098
	__int32 numbones;               //0x009C
	__int32 boneindex;              //0x00A0
	__int32 numbonecontrollers;     //0x00A4
	__int32 bonecontrollerindex;    //0x00A8
	__int32 numhitboxsets;          //0x00AC
	__int32 hitboxsetindex;         //0x00B0
	__int32 numlocalanim;           //0x00B4
	__int32 localanimindex;         //0x00B8
	__int32 numlocalseq;            //0x00BC
	__int32 localseqindex;          //0x00C0
	__int32 activitylistversion;    //0x00C4
	__int32 eventsindexed;          //0x00C8
	__int32 numtextures;            //0x00CC
	__int32 textureindex;           //0x00D0

	mstudiohitboxset_t* GetHitboxSet(int i)
	{
		if (i > numhitboxsets) return nullptr;
		return (mstudiohitboxset_t*)((uint8_t*)this + hitboxsetindex) + i;
	}

	mstudiobone_t* GetBone(int i)
	{
		if (i > numbones)
			return nullptr;

		return (mstudiobone_t*)((uint8_t*)this + boneindex) + i;
	}
};//Size=0x00D4 
```

`src/valve_sdk/misc/UtlBuffer.cpp`:

```cpp
//===== Copyright © 1996-2005, Valve Corporation, All rights reserved. ======//
//
// $Header: $
// $NoKeywords: $
//
// Serialization buffer
//===========================================================================//

#pragma warning (disable : 4514)

#include "UtlBuffer.hpp"
#include <stdio.h>
#include <stdarg.h>
#include <ctype.h>
#include <stdlib.h>
#include <limits.h>
#include "characterset.hpp"

const char* V_strnchr(const char* pStr, char c, int n)
{
	char const* pLetter = pStr;
	char const* pLast = pStr + n;

	// Check the entire string
	while ((pLetter < pLast) && (*pLetter != 0)) {
		if (*pLetter == c)
			return pLetter;
		++pLetter;
	}
	return NULL;
}
//-----------------------------------------------------------------------------
// Finds a string in another string with a case insensitive test w/ length validation
//-----------------------------------------------------------------------------
char const* V_strnistr(char const* pStr, char const* pSearch, int n)
{
	if (!pStr || !pSearch)
		return 0;

	char const* pLetter = pStr;

	// Check the entire string
	while (*pLetter != 0) {
		if (n <= 0)
			return 0;

		// Skip over non-matches
		if (tolower(*pLetter) == tolower(*pSearch)) {
			int n1 = n - 1;

			// Check for match
			char const* pMatch = pLetter + 1;
			char const* pTest = pSearch + 1;
			while (*pTest != 0) {
				if (n1 <= 0)
					return 0;

				// We've run off the end; don't bother.
				if (*pMatch == 0)
					return 0;

				if (tolower(*pMatch) != tolower(*pTest))
					break;

				++pMatch;
				++pTest;
				--n1;
			}

			// Found a match!
			if (*pTest == 0)
				return pLetter;
		}

		++pLetter;
		--n;
	}

	return 0;
}
//-----------------------------------------------------------------------------
// Character conversions for C strings
//-----------------------------------------------------------------------------
class CUtlCStringConversion : public CUtlCharConversion
{
public:
	CUtlCStringConversion(char nEscapeChar, const char* pDelimiter, int nCount, ConversionArray_t* pArray);

	// Finds a conversion for the passed-in string, returns length
	virtual char FindConversion(const char* pString, int* pLength);

private:
	char m_pConversion[255];
};

//-----------------------------------------------------------------------------
// Character conversions for no-escape sequence strings
//-----------------------------------------------------------------------------
class CUtlNoEscConversion : public CUtlCharConversion
{
public:
	CUtlNoEscConversion(char nEscapeChar, const char* pDelimiter, int nCount, ConversionArray_t* pArray) :
		CUtlCharConversion(nEscapeChar, pDelimiter, nCount, pArray)
	{
	}

	// Finds a conversion for the passed-in string, returns length
	virtual char FindConversion(const char* pString, int* pLength) { *pLength = 0; return 0; }
};

//-----------------------------------------------------------------------------
// List of character conversions
//-----------------------------------------------------------------------------
BEGIN_CUSTOM_CHAR_CONVERSION(CUtlCStringConversion, s_StringCharConversion, "\"", '\\')
{
	'\n', (char*)"n"
},
	{ '\t', (char*)"t" },
	{ '\v', (char*)"v" },
	{ '\b', (char*)"b" },
	{ '\r', (char*)"r" },
	{ '\f', (char*)"f" },
	{ '\a', (char*)"a" },
	{ '\\', (char*)"\\" },
	{ '\?', (char*)"\?" },
	{ '\'', (char*)"\'" },
	{ '\"', (char*)"\"" },
		END_CUSTOM_CHAR_CONVERSION(CUtlCStringConversion, s_StringCharConversion, "\"", '\\');

	CUtlCharConversion* GetCStringCharConversion()
	{
		return &s_StringCharConversion;
	}

	BEGIN_CUSTOM_CHAR_CONVERSION(CUtlNoEscConversion, s_NoEscConversion, "\"", 0x7F)
	{
		0x7F, (char*)""
	},
		END_CUSTOM_CHAR_CONVERSION(CUtlNoEscConversion, s_NoEscConversion, "\"", 0x7F);

		CUtlCharConversion* GetNoEscCharConversion()
		{
			return &s_NoEscConversion;
		}

		//-----------------------------------------------------------------------------
		// Constructor
		//-----------------------------------------------------------------------------
		CUtlCStringConversion::CUtlCStringConversion(char nEscapeChar, const char* pDelimiter, int nCount, ConversionArray_t* pArray) :
			CUtlCharConversion(nEscapeChar, pDelimiter, nCount, pArray)
		{
			memset(m_pConversion, 0x0, sizeof(m_pConversion));
			for (int i = 0; i < nCount; ++i) {
				m_pConversion[pArray[i].m_pReplacementString[0]] = pArray[i].m_nActualChar;
			}
		}

		// Finds a conversion for the passed-in string, returns length
		char CUtlCStringConversion::FindConversion(const char* pString, int* pLength)
		{
			char c = m_pConversion[pString[0]];
			*pLength = (c != '\0') ? 1 : 0;
			return c;
		}

		//-----------------------------------------------------------------------------
		// Constructor
		//-----------------------------------------------------------------------------
		CUtlCharConversion::CUtlCharConversion(char nEscapeChar, const char* pDelimiter, int nCount, ConversionArray_t* pArray)
		{
			m_nEscapeChar = nEscapeChar;
			m_pDelimiter = pDelimiter;
			m_nCount = nCount;
			m_nDelimiterLength = strlen(pDelimiter);
			m_nMaxConversionLength = 0;

			memset(m_pReplacements, 0, sizeof(m_pReplacements));

			for (int i = 0; i < nCount; ++i) {
				m_pList[i] = pArray[i].m_nActualChar;
				ConversionInfo_t& info = m_pReplacements[m_pList[i]];
				assert(info.m_pReplacementString == 0);
				info.m_pReplacementString = pArray[i].m_pReplacementString;
				info.m_nLength = strlen(info.m_pReplacementString);
				if (info.m_nLength > m_nMaxConversionLength) {
					m_nMaxConversionLength = info.m_nLength;
				}
			}
		}

		//-----------------------------------------------------------------------------
		// Escape character + delimiter
		//-----------------------------------------------------------------------------
		char CUtlCharConversion::GetEscapeChar() const
		{
			return m_nEscapeChar;
		}

		const char* CUtlCharConversion::GetDelimiter() const
		{
			return m_pDelimiter;
		}

		int CUtlCharConversion::GetDelimiterLength() const
		{
			return m_nDelimiterLength;
		}

		//-----------------------------------------------------------------------------
		// Constructor
		//-----------------------------------------------------------------------------
		const char* CUtlCharConversion::GetConversionString(char c) const
		{
			return m_pReplacements[c].m_pReplacementString;
		}

		int CUtlCharConversion::GetConversionLength(char c) const
		{
			return m_pReplacements[c].m_nLength;
		}

		int CUtlCharConversion::MaxConversionLength() const
		{
			return m_nMaxConversionLength;
		}

		//-----------------------------------------------------------------------------
		// Finds a conversion for the passed-in string, returns length
		//-----------------------------------------------------------------------------
		char CUtlCharConversion::FindConversion(const char* pString, int* pLength)
		{
			for (int i = 0; i < m_nCount; ++i) {
				if (!strcmp(pString, m_pReplacements[m_pList[i]].m_pReplacementString)) {
					*pLength = m_pReplacements[m_pList[i]].m_nLength;
					return m_pList[i];
				}
			}

			*pLength = 0;
			return '\0';
		}

		//-----------------------------------------------------------------------------
		// constructors
		//-----------------------------------------------------------------------------
		CUtlBuffer::CUtlBuffer(int growSize, int initSize, int nFlags) :
			m_Memory(growSize, initSize), m_Error(0)
		{
			m_Get = 0;
			m_Put = 0;
			m_nTab = 0;
			m_nOffset = 0;
			m_Flags = (unsigned char)nFlags;
			if ((initSize != 0) && !IsReadOnly()) {
				m_nMaxPut = -1;
				AddNullTermination();
			}
			else {
				m_nMaxPut = 0;
			}
			SetOverflowFuncs(&CUtlBuffer::GetOverflow, &CUtlBuffer::PutOverflow);
		}

		CUtlBuffer::CUtlBuffer(const void* pBuffer, int nSize, int nFlags) :
			m_Memory((unsigned char*)pBuffer, nSize), m_Error(0)
		{
			assert(nSize != 0);

			m_Get = 0;
			m_Put = 0;
			m_nTab = 0;
			m_nOffset = 0;
			m_Flags = (unsigned char)nFlags;
			if (IsReadOnly()) {
				m_nMaxPut = nSize;
			}
			else {
				m_nMaxPut = -1;
				AddNullTermination();
			}
			SetOverflowFuncs(&CUtlBuffer::GetOverflow, &CUtlBuffer::PutOverflow);
		}

		//-----------------------------------------------------------------------------
		// Modifies the buffer to be binary or text; Blows away the buffer and the CONTAINS_CRLF value.
		//-----------------------------------------------------------------------------
		void CUtlBuffer::SetBufferType(bool bIsText, bool bContainsCRLF)
		{
#ifdef _DEBUG
			// If the buffer is empty, there is no opportunity for this stuff to fail
			if (TellMaxPut() != 0) {
				if (IsText()) {
					if (bIsText) {
						assert(ContainsCRLF() == bContainsCRLF);
					}
					else {
						assert(ContainsCRLF());
					}
				}
				else {
					if (bIsText) {
						assert(bContainsCRLF);
					}
				}
			}
#endif

			if (bIsText) {
				m_Flags |= TEXT_BUFFER;
			}
			else {
				m_Flags &= ~TEXT_BUFFER;
			}
			if (bContainsCRLF) {
				m_Flags |= CONTAINS_CRLF;
			}
			else {
				m_Flags &= ~CONTAINS_CRLF;
			}
		}

		//-----------------------------------------------------------------------------
		// Attaches the buffer to external memory....
		//-----------------------------------------------------------------------------
		void CUtlBuffer::SetExternalBuffer(void* pMemory, int nSize, int nInitialPut, int nFlags)
		{
			m_Memory.SetExternalBuffer((unsigned char*)pMemory, nSize);

			// Reset all indices; we just changed memory
			m_Get = 0;
			m_Put = nInitialPut;
			m_nTab = 0;
			m_Error = 0;
			m_nOffset = 0;
			m_Flags = (unsigned char)nFlags;
			m_nMaxPut = -1;
			AddNullTermination();
		}

		//-----------------------------------------------------------------------------
		// Assumes an external buffer but manages its deletion
		//-----------------------------------------------------------------------------
		void CUtlBuffer::AssumeMemory(void* pMemory, int nSize, int nInitialPut, int nFlags)
		{
			m_Memory.AssumeMemory((unsigned char*)pMemory, nSize);

			// Reset all indices; we just changed memory
			m_Get = 0;
			m_Put = nInitialPut;
			m_nTab = 0;
			m_Error = 0;
			m_nOffset = 0;
			m_Flags = (unsigned char)nFlags;
			m_nMaxPut = -1;
			AddNullTermination();
		}

		//-----------------------------------------------------------------------------
		// Makes sure we've got at least this much memory
		//-----------------------------------------------------------------------------
		void CUtlBuffer::EnsureCapacity(int num)
		{
			// Add one extra for the null termination
			num += 1;
			if (m_Memory.IsExternallyAllocated()) {
				if (IsGrowable() && (m_Memory.NumAllocated() < num)) {
					m_Memory.ConvertToGrowableMemory(0);
				}
				else {
					num -= 1;
				}
			}

			m_Memory.EnsureCapacity(num);
		}

		//-----------------------------------------------------------------------------
		// Base Get method from which all others derive
		//-----------------------------------------------------------------------------
		void CUtlBuffer::Get(void* pMem, int size)
		{
			if (CheckGet(size)) {
				memcpy(pMem, &m_Memory[m_Get - m_nOffset], size);
				m_Get += size;
			}
		}

		//-----------------------------------------------------------------------------
		// This will Get at least 1 uint8_t and up to nSize bytes.
		// It will return the number of bytes actually read.
		//-----------------------------------------------------------------------------
		int CUtlBuffer::GetUpTo(void* pMem, int nSize)
		{
			if (CheckArbitraryPeekGet(0, nSize)) {
				memcpy(pMem, &m_Memory[m_Get - m_nOffset], nSize);
				m_Get += nSize;
				return nSize;
			}
			return 0;
		}

		//-----------------------------------------------------------------------------
		// Eats whitespace
		//-----------------------------------------------------------------------------
		void CUtlBuffer::EatWhiteSpace()
		{
			if (IsText() && IsValid()) {
				while (CheckGet(sizeof(char))) {
					if (!isspace(*(const unsigned char*)PeekGet()))
						break;
					m_Get += sizeof(char);
				}
			}
		}

		//-----------------------------------------------------------------------------
		// Eats C++ style comments
		//-----------------------------------------------------------------------------
		bool CUtlBuffer::EatCPPComment()
		{
			if (IsText() && IsValid()) {
				// If we don't have a a c++ style comment next, we're done
				const char* pPeek = (const char*)PeekGet(2 * sizeof(char), 0);
				if (!pPeek || (pPeek[0] != '/') || (pPeek[1] != '/'))
					return false;

				// Deal with c++ style comments
				m_Get += 2;

				// read complete line
				for (char c = GetChar(); IsValid(); c = GetChar()) {
					if (c == '\n')
						break;
				}
				return true;
			}
			return false;
		}

		//-----------------------------------------------------------------------------
		// Peeks how much whitespace to eat
		//-----------------------------------------------------------------------------
		int CUtlBuffer::PeekWhiteSpace(int nOffset)
		{
			if (!IsText() || !IsValid())
				return 0;

			while (CheckPeekGet(nOffset, sizeof(char))) {
				if (!isspace(*(unsigned char*)PeekGet(nOffset)))
					break;
				nOffset += sizeof(char);
			}

			return nOffset;
		}

		//-----------------------------------------------------------------------------
		// Peek size of sting to come, check memory bound
		//-----------------------------------------------------------------------------
		int	CUtlBuffer::PeekStringLength()
		{
			if (!IsValid())
				return 0;

			// Eat preceeding whitespace
			int nOffset = 0;
			if (IsText()) {
				nOffset = PeekWhiteSpace(nOffset);
			}

			int nStartingOffset = nOffset;

			do {
				int nPeekAmount = 128;

				// NOTE: Add 1 for the terminating zero!
				if (!CheckArbitraryPeekGet(nOffset, nPeekAmount)) {
					if (nOffset == nStartingOffset)
						return 0;
					return nOffset - nStartingOffset + 1;
				}

				const char* pTest = (const char*)PeekGet(nOffset);

				if (!IsText()) {
					for (int i = 0; i < nPeekAmount; ++i) {
						// The +1 here is so we eat the terminating 0
						if (pTest[i] == 0)
							return (i + nOffset - nStartingOffset + 1);
					}
				}
				else {
					for (int i = 0; i < nPeekAmount; ++i) {
						// The +1 here is so we eat the terminating 0
						if (isspace((unsigned char)pTest[i]) || (pTest[i] == 0))
							return (i + nOffset - nStartingOffset + 1);
					}
				}

				nOffset += nPeekAmount;
			} while (true);
		}

		//-----------------------------------------------------------------------------
		// Peek size of line to come, check memory bound
		//-----------------------------------------------------------------------------
		int	CUtlBuffer::PeekLineLength()
		{
			if (!IsValid())
				return 0;

			int nOffset = 0;
			int nStartingOffset = nOffset;

			do {
				int nPeekAmount = 128;

				// NOTE: Add 1 for the terminating zero!
				if (!CheckArbitraryPeekGet(nOffset, nPeekAmount)) {
					if (nOffset == nStartingOffset)
						return 0;
					return nOffset - nStartingOffset + 1;
				}

				const char* pTest = (const char*)PeekGet(nOffset);

				for (int i = 0; i < nPeekAmount; ++i) {
					// The +2 here is so we eat the terminating '\n' and 0
					if (pTest[i] == '\n' || pTest[i] == '\r')
						return (i + nOffset - nStartingOffset + 2);
					// The +1 here is so we eat the terminating 0
					if (pTest[i] == 0)
						return (i + nOffset - nStartingOffset + 1);
				}

				nOffset += nPeekAmount;
			} while (true);
		}

		//-----------------------------------------------------------------------------
		// Does the next bytes of the buffer match a pattern?
		//-----------------------------------------------------------------------------
		bool CUtlBuffer::PeekStringMatch(int nOffset, const char* pString, int nLen)
		{
			if (!CheckPeekGet(nOffset, nLen))
				return false;
			return !strncmp((const char*)PeekGet(nOffset), pString, nLen);
		}

		//-----------------------------------------------------------------------------
		// This version of PeekStringLength converts \" to \\ and " to \, etc.
		// It also reads a " at the beginning and end of the string
		//-----------------------------------------------------------------------------
		int CUtlBuffer::PeekDelimitedStringLength(CUtlCharConversion* pConv, bool bActualSize)
		{
			if (!IsText() || !pConv)
				return PeekStringLength();

			// Eat preceeding whitespace
			int nOffset = 0;
			if (IsText()) {
				nOffset = PeekWhiteSpace(nOffset);
			}

			if (!PeekStringMatch(nOffset, pConv->GetDelimiter(), pConv->GetDelimiterLength()))
				return 0;

			// Try to read ending ", but don't accept \"
			int nActualStart = nOffset;
			nOffset += pConv->GetDelimiterLength();
			int nLen = 1;	// Starts at 1 for the '\0' termination

			do {
				if (PeekStringMatch(nOffset, pConv->GetDelimiter(), pConv->GetDelimiterLength()))
					break;

				if (!CheckPeekGet(nOffset, 1))
					break;

				char c = *(const char*)PeekGet(nOffset);
				++nLen;
				++nOffset;
				if (c == pConv->GetEscapeChar()) {
					int nLength = pConv->MaxConversionLength();
					if (!CheckArbitraryPeekGet(nOffset, nLength))
						break;

					pConv->FindConversion((const char*)PeekGet(nOffset), &nLength);
					nOffset += nLength;
				}
			} while (true);

			return bActualSize ? nLen : nOffset - nActualStart + pConv->GetDelimiterLength() + 1;
		}

		//-----------------------------------------------------------------------------
		// Reads a null-terminated string
		//-----------------------------------------------------------------------------
		void CUtlBuffer::GetString(char* pString, int nMaxChars)
		{
			if (!IsValid()) {
				*pString = 0;
				return;
			}

			if (nMaxChars == 0) {
				nMaxChars = INT_MAX;
			}

			// Remember, this *includes* the null character
			// It will be 0, however, if the buffer is empty.
			int nLen = PeekStringLength();

			if (IsText()) {
				EatWhiteSpace();
			}

			if (nLen == 0) {
				*pString = 0;
				m_Error |= GET_OVERFLOW;
				return;
			}

			// Strip off the terminating NULL
			if (nLen <= nMaxChars) {
				Get(pString, nLen - 1);
				pString[nLen - 1] = 0;
			}
			else {
				Get(pString, nMaxChars - 1);
				pString[nMaxChars - 1] = 0;
				SeekGet(SEEK_CURRENT, nLen - 1 - nMaxChars);
			}

			// Read the terminating NULL in binary formats
			if (!IsText()) {
				assert(GetChar() == 0);
			}
		}

		//-----------------------------------------------------------------------------
		// Reads up to and including the first \n
		//-----------------------------------------------------------------------------
		void CUtlBuffer::GetLine(char* pLine, int nMaxChars)
		{
			assert(IsText() && !ContainsCRLF());

			if (!IsValid()) {
				*pLine = 0;
				return;
			}

			if (nMaxChars == 0) {
				nMaxChars = INT_MAX;
			}

			// Remember, this *includes* the null character
			// It will be 0, however, if the buffer is empty.
			int nLen = PeekLineLength();
			if (nLen == 0) {
				*pLine = 0;
				m_Error |= GET_OVERFLOW;
				return;
			}

			// Strip off the terminating NULL
			if (nLen <= nMaxChars) {
				Get(pLine, nLen - 1);
				pLine[nLen - 1] = 0;
			}
			else {
				Get(pLine, nMaxChars - 1);
				pLine[nMaxChars - 1] = 0;
				SeekGet(SEEK_CURRENT, nLen - 1 - nMaxChars);
			}
		}

		//-----------------------------------------------------------------------------
		// This version of GetString converts \ to \\ and " to \", etc.
		// It also places " at the beginning and end of the string
		//-----------------------------------------------------------------------------
		char CUtlBuffer::GetDelimitedCharInternal(CUtlCharConversion* pConv)
		{
			char c = GetChar();
			if (c == pConv->GetEscapeChar()) {
				int nLength = pConv->MaxConversionLength();
				if (!CheckArbitraryPeekGet(0, nLength))
					return '\0';

				c = pConv->FindConversion((const char*)PeekGet(), &nLength);
				SeekGet(SEEK_CURRENT, nLength);
			}

			return c;
		}

		char CUtlBuffer::GetDelimitedChar(CUtlCharConversion* pConv)
		{
			if (!IsText() || !pConv)
				return GetChar();
			return GetDelimitedCharInternal(pConv);
		}

		void CUtlBuffer::GetDelimitedString(CUtlCharConversion* pConv, char* pString, int nMaxChars)
		{
			if (!IsText() || !pConv) {
				GetString(pString, nMaxChars);
				return;
			}

			if (!IsValid()) {
				*pString = 0;
				return;
			}

			if (nMaxChars == 0) {
				nMaxChars = INT_MAX;
			}

			EatWhiteSpace();
			if (!PeekStringMatch(0, pConv->GetDelimiter(), pConv->GetDelimiterLength()))
				return;

			// Pull off the starting delimiter
			SeekGet(SEEK_CURRENT, pConv->GetDelimiterLength());

			int nRead = 0;
			while (IsValid()) {
				if (PeekStringMatch(0, pConv->GetDelimiter(), pConv->GetDelimiterLength())) {
					SeekGet(SEEK_CURRENT, pConv->GetDelimiterLength());
					break;
				}

				char c = GetDelimitedCharInternal(pConv);

				if (nRead < nMaxChars) {
					pString[nRead] = c;
					++nRead;
				}
			}

			if (nRead >= nMaxChars) {
				nRead = nMaxChars - 1;
			}
			pString[nRead] = '\0';
		}

		//-----------------------------------------------------------------------------
		// Checks if a Get is ok
		//-----------------------------------------------------------------------------
		bool CUtlBuffer::CheckGet(int nSize)
		{
			if (m_Error & GET_OVERFLOW)
				return false;

			if (TellMaxPut() < m_Get + nSize) {
				m_Error |= GET_OVERFLOW;
				return false;
			}

			if ((m_Get < m_nOffset) || (m_Memory.NumAllocated() < m_Get - m_nOffset + nSize)) {
				if (!OnGetOverflow(nSize)) {
					m_Error |= GET_OVERFLOW;
					return false;
				}
			}

			return true;
		}

		//-----------------------------------------------------------------------------
		// Checks if a peek Get is ok
		//-----------------------------------------------------------------------------
		bool CUtlBuffer::CheckPeekGet(int nOffset, int nSize)
		{
			if (m_Error & GET_OVERFLOW)
				return false;

			// Checking for peek can't Set the overflow flag
			bool bOk = CheckGet(nOffset + nSize);
			m_Error &= ~GET_OVERFLOW;
			return bOk;
		}

		//-----------------------------------------------------------------------------
		// Call this to peek arbitrarily long into memory. It doesn't fail unless
		// it can't read *anything* new
		//-----------------------------------------------------------------------------
		bool CUtlBuffer::CheckArbitraryPeekGet(int nOffset, int& nIncrement)
		{
			if (TellGet() + nOffset >= TellMaxPut()) {
				nIncrement = 0;
				return false;
			}

			if (TellGet() + nOffset + nIncrement > TellMaxPut()) {
				nIncrement = TellMaxPut() - TellGet() - nOffset;
			}

			// NOTE: CheckPeekGet could modify TellMaxPut for streaming files
			// We have to call TellMaxPut again here
			CheckPeekGet(nOffset, nIncrement);
			int nMaxGet = TellMaxPut() - TellGet();
			if (nMaxGet < nIncrement) {
				nIncrement = nMaxGet;
			}
			return (nIncrement != 0);
		}

		//-----------------------------------------------------------------------------
		// Peek part of the butt
		//-----------------------------------------------------------------------------
		const void* CUtlBuffer::PeekGet(int nMaxSize, int nOffset)
		{
			if (!CheckPeekGet(nOffset, nMaxSize))
				return NULL;
			return &m_Memory[m_Get + nOffset - m_nOffset];
		}

		//-----------------------------------------------------------------------------
		// Change where I'm reading
		//-----------------------------------------------------------------------------
		void CUtlBuffer::SeekGet(SeekType_t type, int offset)
		{
			switch (type) {
			case SEEK_HEAD:
				m_Get = offset;
				break;

			case SEEK_CURRENT:
				m_Get += offset;
				break;

			case SEEK_TAIL:
				m_Get = m_nMaxPut - offset;
				break;
			}

			if (m_Get > m_nMaxPut) {
				m_Error |= GET_OVERFLOW;
			}
			else {
				m_Error &= ~GET_OVERFLOW;
				if (m_Get < m_nOffset || m_Get >= m_nOffset + Size()) {
					OnGetOverflow(-1);
				}
			}
		}

		//-----------------------------------------------------------------------------
		// Parse...
		//-----------------------------------------------------------------------------

#pragma warning ( disable : 4706 )

		int CUtlBuffer::VaScanf(const char* pFmt, va_list list)
		{
			assert(pFmt);
			if (m_Error || !IsText())
				return 0;

			int numScanned = 0;
			int nLength;
			char c;
			char* pEnd;
			while (c = *pFmt++) {
				// Stop if we hit the end of the buffer
				if (m_Get >= TellMaxPut()) {
					m_Error |= GET_OVERFLOW;
					break;
				}

				switch (c) {
				case ' ':
					// eat all whitespace
					EatWhiteSpace();
					break;

				case '%':
				{
					// Conversion character... try to convert baby!
					char type = *pFmt++;
					if (type == 0)
						return numScanned;

					switch (type) {
					case 'c':
					{
						char* ch = va_arg(list, char*);
						if (CheckPeekGet(0, sizeof(char))) {
							*ch = *(const char*)PeekGet();
							++m_Get;
						}
						else {
							*ch = 0;
							return numScanned;
						}
					}
					break;

					case 'i':
					case 'd':
					{
						int* i = va_arg(list, int*);

						// NOTE: This is not bullet-proof; it assumes numbers are < 128 characters
						nLength = 128;
						if (!CheckArbitraryPeekGet(0, nLength)) {
							*i = 0;
							return numScanned;
						}

						*i = strtol((char*)PeekGet(), &pEnd, 10);
						int nBytesRead = (int)(pEnd - (char*)PeekGet());
						if (nBytesRead == 0)
							return numScanned;
						m_Get += nBytesRead;
					}
					break;

					case 'x':
					{
						int* i = va_arg(list, int*);

						// NOTE: This is not bullet-proof; it assumes numbers are < 128 characters
						nLength = 128;
						if (!CheckArbitraryPeekGet(0, nLength)) {
							*i = 0;
							return numScanned;
						}

						*i = strtol((char*)PeekGet(), &pEnd, 16);
						int nBytesRead = (int)(pEnd - (char*)PeekGet());
						if (nBytesRead == 0)
							return numScanned;
						m_Get += nBytesRead;
					}
					break;

					case 'u':
					{
						unsigned int* u = va_arg(list, unsigned int*);

						// NOTE: This is not bullet-proof; it assumes numbers are < 128 characters
						nLength = 128;
						if (!CheckArbitraryPeekGet(0, nLength)) {
							*u = 0;
							return numScanned;
						}

						*u = strtoul((char*)PeekGet(), &pEnd, 10);
						int nBytesRead = (int)(pEnd - (char*)PeekGet());
						if (nBytesRead == 0)
							return numScanned;
						m_Get += nBytesRead;
					}
					break;

					case 'f':
					{
						float* f = va_arg(list, float*);

						// NOTE: This is not bullet-proof; it assumes numbers are < 128 characters
						nLength = 128;
						if (!CheckArbitraryPeekGet(0, nLength)) {
							*f = 0.0f;
							return numScanned;
						}

						*f = (float)strtod((char*)PeekGet(), &pEnd);
						int nBytesRead = (int)(pEnd - (char*)PeekGet());
						if (nBytesRead == 0)
							return numScanned;
						m_Get += nBytesRead;
					}
					break;

					case 's':
					{
						char* s = va_arg(list, char*);
						GetString(s);
					}
					break;

					default:
					{
						// unimplemented scanf type
						assert(0);
						return numScanned;
					}
					break;
					}

					++numScanned;
				}
				break;

				default:
				{
					// Here we have to match the format string character
					// against what's in the buffer or we're done.
					if (!CheckPeekGet(0, sizeof(char)))
						return numScanned;

					if (c != *(const char*)PeekGet())
						return numScanned;

					++m_Get;
				}
				}
			}
			return numScanned;
		}

#pragma warning ( default : 4706 )

		int CUtlBuffer::Scanf(const char* pFmt, ...)
		{
			va_list args;

			va_start(args, pFmt);
			int count = VaScanf(pFmt, args);
			va_end(args);

			return count;
		}

		//-----------------------------------------------------------------------------
		// Advance the Get index until after the particular string is found
		// Do not eat whitespace before starting. Return false if it failed
		//-----------------------------------------------------------------------------
		bool CUtlBuffer::GetToken(const char* pToken)
		{
			assert(pToken);

			// Look for the token
			int nLen = strlen(pToken);

			int nSizeToCheck = Size() - TellGet() - m_nOffset;

			int nGet = TellGet();
			do {
				int nMaxSize = TellMaxPut() - TellGet();
				if (nMaxSize < nSizeToCheck) {
					nSizeToCheck = nMaxSize;
				}
				if (nLen > nSizeToCheck)
					break;

				if (!CheckPeekGet(0, nSizeToCheck))
					break;

				const char* pBufStart = (const char*)PeekGet();
				const char* pFoundEnd = V_strnistr(pBufStart, pToken, nSizeToCheck);
				if (pFoundEnd) {
					size_t nOffset = (size_t)pFoundEnd - (size_t)pBufStart;
					SeekGet(CUtlBuffer::SEEK_CURRENT, nOffset + nLen);
					return true;
				}

				SeekGet(CUtlBuffer::SEEK_CURRENT, nSizeToCheck - nLen - 1);
				nSizeToCheck = Size() - (nLen - 1);
			} while (true);

			SeekGet(CUtlBuffer::SEEK_HEAD, nGet);
			return false;
		}

		//-----------------------------------------------------------------------------
		// (For text buffers only)
		// Parse a token from the buffer:
		// Grab all text that lies between a starting delimiter + ending delimiter
		// (skipping whitespace that leads + trails both delimiters).
		// Note the delimiter checks are case-insensitive.
		// If successful, the Get index is advanced and the function returns true,
		// otherwise the index is not advanced and the function returns false.
		//-----------------------------------------------------------------------------
		bool CUtlBuffer::ParseToken(const char* pStartingDelim, const char* pEndingDelim, char* pString, int nMaxLen)
		{
			int nCharsToCopy = 0;
			int nCurrentGet = 0;

			size_t nEndingDelimLen;

			// Starting delimiter is optional
			char emptyBuf = '\0';
			if (!pStartingDelim) {
				pStartingDelim = &emptyBuf;
			}

			// Ending delimiter is not
			assert(pEndingDelim && pEndingDelim[0]);
			nEndingDelimLen = strlen(pEndingDelim);

			int nStartGet = TellGet();
			char nCurrChar;
			int nTokenStart = -1;
			EatWhiteSpace();
			while (*pStartingDelim) {
				nCurrChar = *pStartingDelim++;
				if (!isspace((unsigned char)nCurrChar)) {
					if (tolower(GetChar()) != tolower(nCurrChar))
						goto parseFailed;
				}
				else {
					EatWhiteSpace();
				}
			}

			EatWhiteSpace();
			nTokenStart = TellGet();
			if (!GetToken(pEndingDelim))
				goto parseFailed;

			nCurrentGet = TellGet();
			nCharsToCopy = (nCurrentGet - nEndingDelimLen) - nTokenStart;
			if (nCharsToCopy >= nMaxLen) {
				nCharsToCopy = nMaxLen - 1;
			}

			if (nCharsToCopy > 0) {
				SeekGet(CUtlBuffer::SEEK_HEAD, nTokenStart);
				Get(pString, nCharsToCopy);
				if (!IsValid())
					goto parseFailed;

				// Eat trailing whitespace
				for (; nCharsToCopy > 0; --nCharsToCopy) {
					if (!isspace((unsigned char)pString[nCharsToCopy - 1]))
						break;
				}
			}
			pString[nCharsToCopy] = '\0';

			// Advance the Get index
			SeekGet(CUtlBuffer::SEEK_HEAD, nCurrentGet);
			return true;

		parseFailed:
			// Revert the Get index
			SeekGet(SEEK_HEAD, nStartGet);
			pString[0] = '\0';
			return false;
		}

		//-----------------------------------------------------------------------------
		// Parses the next token, given a Set of character breaks to stop at
		//-----------------------------------------------------------------------------
		int CUtlBuffer::ParseToken(characterset_t* pBreaks, char* pTokenBuf, int nMaxLen, bool bParseComments)
		{
			assert(nMaxLen > 0);
			pTokenBuf[0] = 0;

			// skip whitespace + comments
			while (true) {
				if (!IsValid())
					return -1;
				EatWhiteSpace();
				if (bParseComments) {
					if (!EatCPPComment())
						break;
				}
				else {
					break;
				}
			}

			char c = GetChar();

			// End of buffer
			if (c == 0)
				return -1;

			// handle quoted strings specially
			if (c == '\"') {
				int nLen = 0;
				while (IsValid()) {
					c = GetChar();
					if (c == '\"' || !c) {
						pTokenBuf[nLen] = 0;
						return nLen;
					}
					pTokenBuf[nLen] = c;
					if (++nLen == nMaxLen) {
						pTokenBuf[nLen - 1] = 0;
						return nMaxLen;
					}
				}

				// In this case, we hit the end of the buffer before hitting the end qoute
				pTokenBuf[nLen] = 0;
				return nLen;
			}

			// parse single characters
			if (IN_CHARACTERSET(*pBreaks, c)) {
				pTokenBuf[0] = c;
				pTokenBuf[1] = 0;
				return 1;
			}

			// parse a regular word
			int nLen = 0;
			while (true) {
				pTokenBuf[nLen] = c;
				if (++nLen == nMaxLen) {
					pTokenBuf[nLen - 1] = 0;
					return nMaxLen;
				}
				c = GetChar();
				if (!IsValid())
					break;

				if (IN_CHARACTERSET(*pBreaks, c) || c == '\"' || c <= ' ') {
					SeekGet(SEEK_CURRENT, -1);
					break;
				}
			}

			pTokenBuf[nLen] = 0;
			return nLen;
		}

		//-----------------------------------------------------------------------------
		// Serialization
		//-----------------------------------------------------------------------------
		void CUtlBuffer::Put(const void* pMem, int size)
		{
			if (size && CheckPut(size)) {
				memcpy(&m_Memory[m_Put - m_nOffset], pMem, size);
				m_Put += size;

				AddNullTermination();
			}
		}

		//-----------------------------------------------------------------------------
		// Writes a null-terminated string
		//-----------------------------------------------------------------------------
		void CUtlBuffer::PutString(const char* pString)
		{
			if (!IsText()) {
				if (pString) {
					// Not text? append a null at the end.
					size_t nLen = strlen(pString) + 1;
					Put(pString, nLen * sizeof(char));
					return;
				}
				else {
					PutTypeBin<char>(0);
				}
			}
			else if (pString) {
				int nTabCount = (m_Flags & AUTO_TABS_DISABLED) ? 0 : m_nTab;
				if (nTabCount > 0) {
					if (WasLastCharacterCR()) {
						PutTabs();
					}

					const char* pEndl = strchr(pString, '\n');
					while (pEndl) {
						size_t nSize = (size_t)pEndl - (size_t)pString + sizeof(char);
						Put(pString, nSize);
						pString = pEndl + 1;
						if (*pString) {
							PutTabs();
							pEndl = strchr(pString, '\n');
						}
						else {
							pEndl = NULL;
						}
					}
				}
				size_t nLen = strlen(pString);
				if (nLen) {
					Put(pString, nLen * sizeof(char));
				}
			}
		}

		//-----------------------------------------------------------------------------
		// This version of PutString converts \ to \\ and " to \", etc.
		// It also places " at the beginning and end of the string
		//-----------------------------------------------------------------------------
		inline void CUtlBuffer::PutDelimitedCharInternal(CUtlCharConversion* pConv, char c)
		{
			int l = pConv->GetConversionLength(c);
			if (l == 0) {
				PutChar(c);
			}
			else {
				PutChar(pConv->GetEscapeChar());
				Put(pConv->GetConversionString(c), l);
			}
		}

		void CUtlBuffer::PutDelimitedChar(CUtlCharConversion* pConv, char c)
		{
			if (!IsText() || !pConv) {
				PutChar(c);
				return;
			}

			PutDelimitedCharInternal(pConv, c);
		}

		void CUtlBuffer::PutDelimitedString(CUtlCharConversion* pConv, const char* pString)
		{
			if (!IsText() || !pConv) {
				PutString(pString);
				return;
			}

			if (WasLastCharacterCR()) {
				PutTabs();
			}
			Put(pConv->GetDelimiter(), pConv->GetDelimiterLength());

			int nLen = pString ? strlen(pString) : 0;
			for (int i = 0; i < nLen; ++i) {
				PutDelimitedCharInternal(pConv, pString[i]);
			}

			if (WasLastCharacterCR()) {
				PutTabs();
			}
			Put(pConv->GetDelimiter(), pConv->GetDelimiterLength());
		}

		void CUtlBuffer::VaPrintf(const char* pFmt, va_list list)
		{
			char temp[2048];
			int nLen = vsnprintf(temp, sizeof(temp), pFmt, list);
			assert(nLen < 2048);
			PutString(temp);
		}

		void CUtlBuffer::Printf(const char* pFmt, ...)
		{
			va_list args;

			va_start(args, pFmt);
			VaPrintf(pFmt, args);
			va_end(args);
		}

		//-----------------------------------------------------------------------------
		// Calls the overflow functions
		//-----------------------------------------------------------------------------
		void CUtlBuffer::SetOverflowFuncs(UtlBufferOverflowFunc_t getFunc, UtlBufferOverflowFunc_t putFunc)
		{
			m_GetOverflowFunc = getFunc;
			m_PutOverflowFunc = putFunc;
		}

		//-----------------------------------------------------------------------------
		// Calls the overflow functions
		//-----------------------------------------------------------------------------
		bool CUtlBuffer::OnPutOverflow(int nSize)
		{
			return (this->*m_PutOverflowFunc)(nSize);
		}

		bool CUtlBuffer::OnGetOverflow(int nSize)
		{
			return (this->*m_GetOverflowFunc)(nSize);
		}

		//-----------------------------------------------------------------------------
		// Checks if a put is ok
		//-----------------------------------------------------------------------------
		bool CUtlBuffer::PutOverflow(int nSize)
		{
			if (m_Memory.IsExternallyAllocated()) {
				if (!IsGrowable())
					return false;

				m_Memory.ConvertToGrowableMemory(0);
			}

			while (Size() < m_Put - m_nOffset + nSize) {
				m_Memory.Grow();
			}

			return true;
		}

		bool CUtlBuffer::GetOverflow(int nSize)
		{
			return false;
		}

		//-----------------------------------------------------------------------------
		// Checks if a put is ok
		//-----------------------------------------------------------------------------
		bool CUtlBuffer::CheckPut(int nSize)
		{
			if ((m_Error & PUT_OVERFLOW) || IsReadOnly())
				return false;

			if ((m_Put < m_nOffset) || (m_Memory.NumAllocated() < m_Put - m_nOffset + nSize)) {
				if (!OnPutOverflow(nSize)) {
					m_Error |= PUT_OVERFLOW;
					return false;
				}
			}
			return true;
		}

		void CUtlBuffer::SeekPut(SeekType_t type, int offset)
		{
			int nNextPut = m_Put;
			switch (type) {
			case SEEK_HEAD:
				nNextPut = offset;
				break;

			case SEEK_CURRENT:
				nNextPut += offset;
				break;

			case SEEK_TAIL:
				nNextPut = m_nMaxPut - offset;
				break;
			}

			// Force a write of the data
			// FIXME: We could make this more optimal potentially by writing out
			// the entire buffer if you seek outside the current range

			// NOTE: This call will write and will also seek the file to nNextPut.
			OnPutOverflow(-nNextPut - 1);
			m_Put = nNextPut;

			AddNullTermination();
		}

		void CUtlBuffer::ActivateByteSwapping(bool bActivate)
		{
			m_Byteswap.ActivateByteSwapping(bActivate);
		}

		void CUtlBuffer::SetBigEndian(bool bigEndian)
		{
			m_Byteswap.SetTargetBigEndian(bigEndian);
		}

		bool CUtlBuffer::IsBigEndian(void)
		{
			return m_Byteswap.IsTargetBigEndian();
		}

		//-----------------------------------------------------------------------------
		// null terminate the buffer
		//-----------------------------------------------------------------------------
		void CUtlBuffer::AddNullTermination(void)
		{
			if (m_Put > m_nMaxPut) {
				if (!IsReadOnly() && ((m_Error & PUT_OVERFLOW) == 0)) {
					// Add null termination value
					if (CheckPut(1)) {
						m_Memory[m_Put - m_nOffset] = 0;
					}
					else {
						// Restore the overflow state, it was valid before...
						m_Error &= ~PUT_OVERFLOW;
					}
				}
				m_nMaxPut = m_Put;
			}
		}

		//-----------------------------------------------------------------------------
		// Converts a buffer from a CRLF buffer to a CR buffer (and back)
		// Returns false if no conversion was necessary (and outBuf is left untouched)
		// If the conversion occurs, outBuf will be cleared.
		//-----------------------------------------------------------------------------
		bool CUtlBuffer::ConvertCRLF(CUtlBuffer& outBuf)
		{
			if (!IsText() || !outBuf.IsText())
				return false;

			if (ContainsCRLF() == outBuf.ContainsCRLF())
				return false;

			int nInCount = TellMaxPut();

			outBuf.Purge();
			outBuf.EnsureCapacity(nInCount);

			bool bFromCRLF = ContainsCRLF();

			// Start reading from the beginning
			int nGet = TellGet();
			int nPut = TellPut();
			int nGetDelta = 0;
			int nPutDelta = 0;

			const char* pBase = (const char*)Base();
			int nCurrGet = 0;
			while (nCurrGet < nInCount) {
				const char* pCurr = &pBase[nCurrGet];
				if (bFromCRLF) {
					const char* pNext = V_strnistr(pCurr, "\r\n", nInCount - nCurrGet);
					if (!pNext) {
						outBuf.Put(pCurr, nInCount - nCurrGet);
						break;
					}

					int nBytes = (size_t)pNext - (size_t)pCurr;
					outBuf.Put(pCurr, nBytes);
					outBuf.PutChar('\n');
					nCurrGet += nBytes + 2;
					if (nGet >= nCurrGet - 1) {
						--nGetDelta;
					}
					if (nPut >= nCurrGet - 1) {
						--nPutDelta;
					}
				}
				else {
					const char* pNext = V_strnchr(pCurr, '\n', nInCount - nCurrGet);
					if (!pNext) {
						outBuf.Put(pCurr, nInCount - nCurrGet);
						break;
					}

					int nBytes = (size_t)pNext - (size_t)pCurr;
					outBuf.Put(pCurr, nBytes);
					outBuf.PutChar('\r');
					outBuf.PutChar('\n');
					nCurrGet += nBytes + 1;
					if (nGet >= nCurrGet) {
						++nGetDelta;
					}
					if (nPut >= nCurrGet) {
						++nPutDelta;
					}
				}
			}

			assert(nPut + nPutDelta <= outBuf.TellMaxPut());

			outBuf.SeekGet(SEEK_HEAD, nGet + nGetDelta);
			outBuf.SeekPut(SEEK_HEAD, nPut + nPutDelta);

			return true;
		}

		//---------------------------------------------------------------------------
		// Implementation of CUtlInplaceBuffer
		//---------------------------------------------------------------------------

		CUtlInplaceBuffer::CUtlInplaceBuffer(int growSize /* = 0 */, int initSize /* = 0 */, int nFlags /* = 0 */) :
			CUtlBuffer(growSize, initSize, nFlags)
		{
			NULL;
		}

		bool CUtlInplaceBuffer::InplaceGetLinePtr(char** ppszInBufferPtr, int* pnLineLength)
		{
			assert(IsText() && !ContainsCRLF());

			int nLineLen = PeekLineLength();
			if (nLineLen <= 1) {
				SeekGet(SEEK_TAIL, 0);
				return false;
			}

			--nLineLen; // because it accounts for putting a terminating null-character

			char* pszLine = (char*) const_cast<void*>(PeekGet());
			SeekGet(SEEK_CURRENT, nLineLen);

			// Set the out args
			if (ppszInBufferPtr)
				*ppszInBufferPtr = pszLine;

			if (pnLineLength)
				*pnLineLength = nLineLen;

			return true;
		}

		char* CUtlInplaceBuffer::InplaceGetLinePtr(void)
		{
			char* pszLine = NULL;
			int nLineLen = 0;

			if (InplaceGetLinePtr(&pszLine, &nLineLen)) {
				assert(nLineLen >= 1);

				switch (pszLine[nLineLen - 1]) {
				case '\n':
				case '\r':
					pszLine[nLineLen - 1] = 0;
					if (--nLineLen) {
						switch (pszLine[nLineLen - 1]) {
						case '\n':
						case '\r':
							pszLine[nLineLen - 1] = 0;
							break;
						}
					}
					break;

				default:
					assert(pszLine[nLineLen] == 0);
					break;
				}
			}
			return pszLine;
		}
```

`src/valve_sdk/misc/UtlBuffer.hpp`:

```hpp
#pragma once

#include <stdarg.h>
#include "../math/Vectors.hpp"
#include "UtlMemory.hpp"

#pragma warning(disable:4127) //conditional operation is constant
#define IsX360() (0)

//-----------------------------------------------------------------------------
// Forward declarations
//-----------------------------------------------------------------------------
struct characterset_t;
struct typedescription_t;
struct datamap_t;

class CByteswap
{
public:
	CByteswap()
	{
		// Default behavior sets the target endian to match the machine native endian (no swap).
		SetTargetBigEndian(IsMachineBigEndian());
	}

	//-----------------------------------------------------------------------------
	// Write a single field.
	//-----------------------------------------------------------------------------
	void SwapFieldToTargetEndian(void* pOutputBuffer, void* pData, typedescription_t* pField);

	//-----------------------------------------------------------------------------
	// Write a block of fields.  Works a bit like the saverestore code.
	//-----------------------------------------------------------------------------
	void SwapFieldsToTargetEndian(void* pOutputBuffer, void* pBaseData, datamap_t* pDataMap);

	// Swaps fields for the templated type to the output buffer.
	template<typename T> inline void SwapFieldsToTargetEndian(T* pOutputBuffer, void* pBaseData, unsigned int objectCount = 1)
	{
		for (unsigned int i = 0; i < objectCount; ++i, ++pOutputBuffer) {
			SwapFieldsToTargetEndian((void*)pOutputBuffer, pBaseData, &T::m_DataMap);
			pBaseData = (uint8_t*)pBaseData + sizeof(T);
		}
	}

	// Swaps fields for the templated type in place.
	template<typename T> inline void SwapFieldsToTargetEndian(T* pOutputBuffer, unsigned int objectCount = 1)
	{
		SwapFieldsToTargetEndian<T>(pOutputBuffer, (void*)pOutputBuffer, objectCount);
	}

	//-----------------------------------------------------------------------------
	// True if the current machine is detected as big endian.
	// (Endienness is effectively detected at compile time when optimizations are
	// enabled)
	//-----------------------------------------------------------------------------
	static bool IsMachineBigEndian()
	{
		short nIsBigEndian = 1;

		// if we are big endian, the first uint8_t will be a 0, if little endian, it will be a one.
		return (bool)(0 == *(char*)& nIsBigEndian);
	}

	//-----------------------------------------------------------------------------
	// Sets the target uint8_t ordering we are swapping to or from.
	//
	// Braindead Endian Reference:
	//		x86 is LITTLE Endian
	//		PowerPC is BIG Endian
	//-----------------------------------------------------------------------------
	inline void SetTargetBigEndian(bool bigEndian)
	{
		m_bBigEndian = bigEndian;
		m_bSwapBytes = IsMachineBigEndian() != bigEndian;
	}

	// Changes target endian
	inline void FlipTargetEndian(void)
	{
		m_bSwapBytes = !m_bSwapBytes;
		m_bBigEndian = !m_bBigEndian;
	}

	// Forces uint8_t swapping state, regardless of endianess
	inline void ActivateByteSwapping(bool bActivate)
	{
		SetTargetBigEndian(IsMachineBigEndian() != bActivate);
	}

	//-----------------------------------------------------------------------------
	// Returns true if the target machine is the same as this one in endianness.
	//
	// Used to determine when a byteswap needs to take place.
	//-----------------------------------------------------------------------------
	inline bool IsSwappingBytes(void)	// Are bytes being swapped?
	{
		return m_bSwapBytes;
	}

	inline bool IsTargetBigEndian(void)	// What is the current target endian?
	{
		return m_bBigEndian;
	}

	//-----------------------------------------------------------------------------
	// IsByteSwapped()
	//
	// When supplied with a chunk of input data and a constant or magic number
	// (in native format) determines the endienness of the current machine in
	// relation to the given input data.
	//
	// Returns:
	//		1  if input is the same as nativeConstant.
	//		0  if input is byteswapped relative to nativeConstant.
	//		-1 if input is not the same as nativeConstant and not byteswapped either.
	//
	// ( This is useful for detecting byteswapping in magic numbers in structure
	// headers for example. )
	//-----------------------------------------------------------------------------
	template<typename T> inline int SourceIsNativeEndian(T input, T nativeConstant)
	{
		// If it's the same, it isn't byteswapped:
		if (input == nativeConstant)
			return 1;

		int output;
		LowLevelByteSwap<T>(&output, &input);
		if (output == nativeConstant)
			return 0;

		assert(0);		// if we Get here, input is neither a swapped nor unswapped version of nativeConstant.
		return -1;
	}

	//-----------------------------------------------------------------------------
	// Swaps an input buffer full of type T into the given output buffer.
	//
	// Swaps [count] items from the inputBuffer to the outputBuffer.
	// If inputBuffer is omitted or NULL, then it is assumed to be the same as
	// outputBuffer - effectively swapping the contents of the buffer in place.
	//-----------------------------------------------------------------------------
	template<typename T> inline void SwapBuffer(T* outputBuffer, T* inputBuffer = NULL, int count = 1)
	{
		assert(count >= 0);
		assert(outputBuffer);

		// Fail gracefully in release:
		if (count <= 0 || !outputBuffer)
			return;

		// Optimization for the case when we are swapping in place.
		if (inputBuffer == NULL) {
			inputBuffer = outputBuffer;
		}

		// Swap everything in the buffer:
		for (int i = 0; i < count; i++) {
			LowLevelByteSwap<T>(&outputBuffer[i], &inputBuffer[i]);
		}
	}

	//-----------------------------------------------------------------------------
	// Swaps an input buffer full of type T into the given output buffer.
	//
	// Swaps [count] items from the inputBuffer to the outputBuffer.
	// If inputBuffer is omitted or NULL, then it is assumed to be the same as
	// outputBuffer - effectively swapping the contents of the buffer in place.
	//-----------------------------------------------------------------------------
	template<typename T> inline void SwapBufferToTargetEndian(T* outputBuffer, T* inputBuffer = NULL, int count = 1)
	{
		assert(count >= 0);
		assert(outputBuffer);

		// Fail gracefully in release:
		if (count <= 0 || !outputBuffer)
			return;

		// Optimization for the case when we are swapping in place.
		if (inputBuffer == NULL) {
			inputBuffer = outputBuffer;
		}

		// Are we already the correct endienness? ( or are we swapping 1 uint8_t items? )
		if (!m_bSwapBytes || (sizeof(T) == 1)) {
			// If we were just going to swap in place then return.
			if (!inputBuffer)
				return;

			// Otherwise copy the inputBuffer to the outputBuffer:
			memcpy(outputBuffer, inputBuffer, count * sizeof(T));
			return;
		}

		// Swap everything in the buffer:
		for (int i = 0; i < count; i++) {
			LowLevelByteSwap<T>(&outputBuffer[i], &inputBuffer[i]);
		}
	}

private:
	//-----------------------------------------------------------------------------
	// The lowest level uint8_t swapping workhorse of doom.  output always contains the
	// swapped version of input.  ( Doesn't compare machine to target endianness )
	//-----------------------------------------------------------------------------
	template<typename T> static void LowLevelByteSwap(T* output, T* input)
	{
		T temp = *output;
#if defined( _X360 )
		// Intrinsics need the source type to be fixed-point
		DWORD* word = (DWORD*)input;
		switch (sizeof(T)) {
		case 8:
		{
			__storewordbytereverse(*word, 0, &temp);
			__storewordbytereverse(*(word + 1), 4, &temp);
		}
		break;

		case 4:
			__storewordbytereverse(*word, 0, &temp);
			break;

		case 2:
			__storeshortbytereverse(*input, 0, &temp);
			break;

		default:
			assert("Invalid size in CByteswap::LowLevelByteSwap" && 0);
		}
#else
		for (unsigned i = 0; i < sizeof(T); i++) {
			((unsigned char*)& temp)[i] = ((unsigned char*)input)[sizeof(T) - (i + 1)];
		}
#endif
		memcpy(output, &temp, sizeof(T));
	}

	unsigned int m_bSwapBytes : 1;
	unsigned int m_bBigEndian : 1;
};

//-----------------------------------------------------------------------------
// Description of character conversions for string output
// Here's an example of how to use the macros to define a character conversion
// BEGIN_CHAR_CONVERSION( CStringConversion, '\\' )
//	{ '\n', "n" },
//	{ '\t', "t" }
// END_CHAR_CONVERSION( CStringConversion, '\\' )
//-----------------------------------------------------------------------------
class CUtlCharConversion
{
public:
	struct ConversionArray_t
	{
		char m_nActualChar;
		char* m_pReplacementString;
	};

	CUtlCharConversion(char nEscapeChar, const char* pDelimiter, int nCount, ConversionArray_t* pArray);
	char GetEscapeChar() const;
	const char* GetDelimiter() const;
	int GetDelimiterLength() const;

	const char* GetConversionString(char c) const;
	int GetConversionLength(char c) const;
	int MaxConversionLength() const;

	// Finds a conversion for the passed-in string, returns length
	virtual char FindConversion(const char* pString, int* pLength);

protected:
	struct ConversionInfo_t
	{
		int m_nLength;
		char* m_pReplacementString;
	};

	char m_nEscapeChar;
	const char* m_pDelimiter;
	int m_nDelimiterLength;
	int m_nCount;
	int m_nMaxConversionLength;
	char m_pList[255];
	ConversionInfo_t m_pReplacements[255];
};

#define BEGIN_CHAR_CONVERSION( _name, _delimiter, _escapeChar )	\
	static CUtlCharConversion::ConversionArray_t s_pConversionArray ## _name[] = {
#define END_CHAR_CONVERSION( _name, _delimiter, _escapeChar ) \
	}; \
	CUtlCharConversion _name( _escapeChar, _delimiter, sizeof( s_pConversionArray ## _name ) / sizeof( CUtlCharConversion::ConversionArray_t ), s_pConversionArray ## _name )

#define BEGIN_CUSTOM_CHAR_CONVERSION( _className, _name, _delimiter, _escapeChar ) \
	static CUtlCharConversion::ConversionArray_t s_pConversionArray ## _name[] = {
#define END_CUSTOM_CHAR_CONVERSION( _className, _name, _delimiter, _escapeChar ) \
	}; \
	_className _name( _escapeChar, _delimiter, sizeof( s_pConversionArray ## _name ) / sizeof( CUtlCharConversion::ConversionArray_t ), s_pConversionArray ## _name )

//-----------------------------------------------------------------------------
// Character conversions for C strings
//-----------------------------------------------------------------------------
CUtlCharConversion* GetCStringCharConversion();

//-----------------------------------------------------------------------------
// Character conversions for quoted strings, with no escape sequences
//-----------------------------------------------------------------------------
CUtlCharConversion* GetNoEscCharConversion();

//-----------------------------------------------------------------------------
// Macro to Set overflow functions easily
//-----------------------------------------------------------------------------
#define SetUtlBufferOverflowFuncs( _get, _put )	\
	SetOverflowFuncs( static_cast <UtlBufferOverflowFunc_t>( _get ), static_cast <UtlBufferOverflowFunc_t>( _put ) )

//-----------------------------------------------------------------------------
// Command parsing..
//-----------------------------------------------------------------------------
class CUtlBuffer
{
public:
	enum SeekType_t
	{
		SEEK_HEAD = 0,
		SEEK_CURRENT,
		SEEK_TAIL
	};

	// flags
	enum BufferFlags_t
	{
		TEXT_BUFFER = 0x1,			// Describes how Get + put work (as strings, or binary)
		EXTERNAL_GROWABLE = 0x2,	// This is used w/ external buffers and causes the utlbuf to switch to reallocatable memory if an overflow happens when Putting.
		CONTAINS_CRLF = 0x4,		// For text buffers only, does this contain \n or \n\r?
		READ_ONLY = 0x8,			// For external buffers; prevents null termination from happening.
		AUTO_TABS_DISABLED = 0x10,	// Used to disable/enable push/pop tabs
	};

	// Overflow functions when a Get or put overflows
	typedef bool (CUtlBuffer::* UtlBufferOverflowFunc_t)(int nSize);

	// Constructors for growable + external buffers for serialization/unserialization
	CUtlBuffer(int growSize = 0, int initSize = 0, int nFlags = 0);
	CUtlBuffer(const void* pBuffer, int size, int nFlags = 0);
	// This one isn't actually defined so that we catch contructors that are trying to pass a bool in as the third param.
	CUtlBuffer(const void* pBuffer, int size, bool crap);

	unsigned char	GetFlags() const;

	// NOTE: This will assert if you attempt to recast it in a way that
	// is not compatible. The only valid conversion is binary-> text w/CRLF
	void			SetBufferType(bool bIsText, bool bContainsCRLF);

	// Makes sure we've got at least this much memory
	void			EnsureCapacity(int num);

	// Attaches the buffer to external memory....
	void			SetExternalBuffer(void* pMemory, int nSize, int nInitialPut, int nFlags = 0);
	bool			IsExternallyAllocated() const;
	void			AssumeMemory(void* pMemory, int nSize, int nInitialPut, int nFlags = 0);

	__forceinline void ActivateByteSwappingIfBigEndian(void)
	{
		if (IsX360())
			ActivateByteSwapping(true);
	}

	// Controls endian-ness of binary utlbufs - default matches the current platform
	void			ActivateByteSwapping(bool bActivate);
	void			SetBigEndian(bool bigEndian);
	bool			IsBigEndian(void);

	// Resets the buffer; but doesn't free memory
	void			Clear();

	// Clears out the buffer; frees memory
	void			Purge();

	// Read stuff out.
	// Binary mode: it'll just read the bits directly in, and characters will be
	//		read for strings until a null character is reached.
	// Text mode: it'll parse the file, turning text #s into real numbers.
	//		GetString will read a string until a space is reached
	char			GetChar();
	unsigned char	GetUnsignedChar();
	short			GetShort();
	unsigned short	GetUnsignedShort();
	int				GetInt();
	int				GetIntHex();
	unsigned int	GetUnsignedInt();
	float			GetFloat();
	double			GetDouble();
	void			GetString(char* pString, int nMaxChars = 0);
	void			Get(void* pMem, int size);
	void			GetLine(char* pLine, int nMaxChars = 0);

	// Used for getting objects that have a byteswap datadesc defined
	template <typename T> void GetObjects(T* dest, int count = 1);

	// This will Get at least 1 uint8_t and up to nSize bytes.
	// It will return the number of bytes actually read.
	int				GetUpTo(void* pMem, int nSize);

	// This version of GetString converts \" to \\ and " to \, etc.
	// It also reads a " at the beginning and end of the string
	void			GetDelimitedString(CUtlCharConversion* pConv, char* pString, int nMaxChars = 0);
	char			GetDelimitedChar(CUtlCharConversion* pConv);

	// This will return the # of characters of the string about to be read out
	// NOTE: The count will *include* the terminating 0!!
	// In binary mode, it's the number of characters until the next 0
	// In text mode, it's the number of characters until the next space.
	int				PeekStringLength();

	// This version of PeekStringLength converts \" to \\ and " to \, etc.
	// It also reads a " at the beginning and end of the string
	// NOTE: The count will *include* the terminating 0!!
	// In binary mode, it's the number of characters until the next 0
	// In text mode, it's the number of characters between "s (checking for \")
	// Specifying false for bActualSize will return the pre-translated number of characters
	// including the delimiters and the escape characters. So, \n counts as 2 characters when bActualSize == false
	// and only 1 character when bActualSize == true
	int				PeekDelimitedStringLength(CUtlCharConversion* pConv, bool bActualSize = true);

	// Just like scanf, but doesn't work in binary mode
	int				Scanf(const char* pFmt, ...);
	int				VaScanf(const char* pFmt, va_list list);

	// Eats white space, advances Get index
	void			EatWhiteSpace();

	// Eats C++ style comments
	bool			EatCPPComment();

	// (For text buffers only)
	// Parse a token from the buffer:
	// Grab all text that lies between a starting delimiter + ending delimiter
	// (skipping whitespace that leads + trails both delimiters).
	// If successful, the Get index is advanced and the function returns true,
	// otherwise the index is not advanced and the function returns false.
	bool			ParseToken(const char* pStartingDelim, const char* pEndingDelim, char* pString, int nMaxLen);

	// Advance the Get index until after the particular string is found
	// Do not eat whitespace before starting. Return false if it failed
	// String test is case-insensitive.
	bool			GetToken(const char* pToken);

	// Parses the next token, given a Set of character breaks to stop at
	// Returns the length of the token parsed in bytes (-1 if none parsed)
	int				ParseToken(characterset_t* pBreaks, char* pTokenBuf, int nMaxLen, bool bParseComments = true);

	// Write stuff in
	// Binary mode: it'll just write the bits directly in, and strings will be
	//		written with a null terminating character
	// Text mode: it'll convert the numbers to text versions
	//		PutString will not write a terminating character
	void			PutChar(char c);
	void			PutUnsignedChar(unsigned char uc);
	void			PutShort(short s);
	void			PutUnsignedShort(unsigned short us);
	void			PutInt(int i);
	void			PutUnsignedInt(unsigned int u);
	void			PutFloat(float f);
	void			PutDouble(double d);
	void			PutString(const char* pString);
	void			Put(const void* pMem, int size);

	// Used for putting objects that have a byteswap datadesc defined
	template <typename T> void PutObjects(T* src, int count = 1);

	// This version of PutString converts \ to \\ and " to \", etc.
	// It also places " at the beginning and end of the string
	void			PutDelimitedString(CUtlCharConversion* pConv, const char* pString);
	void			PutDelimitedChar(CUtlCharConversion* pConv, char c);

	// Just like printf, writes a terminating zero in binary mode
	void			Printf(const char* pFmt, ...);
	void			VaPrintf(const char* pFmt, va_list list);

	// What am I writing (put)/reading (Get)?
	void* PeekPut(int offset = 0);
	const void* PeekGet(int offset = 0) const;
	const void* PeekGet(int nMaxSize, int nOffset);

	// Where am I writing (put)/reading (Get)?
	int TellPut() const;
	int TellGet() const;

	// What's the most I've ever written?
	int TellMaxPut() const;

	// How many bytes remain to be read?
	// NOTE: This is not accurate for streaming text files; it overshoots
	int GetBytesRemaining() const;

	// Change where I'm writing (put)/reading (Get)
	void SeekPut(SeekType_t type, int offset);
	void SeekGet(SeekType_t type, int offset);

	// Buffer base
	const void* Base() const;
	void* Base();

	// memory allocation size, does *not* reflect size written or read,
	//	use TellPut or TellGet for that
	int Size() const;

	// Am I a text buffer?
	bool IsText() const;

	// Can I grow if I'm externally allocated?
	bool IsGrowable() const;

	// Am I valid? (overflow or underflow error), Once invalid it stays invalid
	bool IsValid() const;

	// Do I contain carriage return/linefeeds?
	bool ContainsCRLF() const;

	// Am I read-only
	bool IsReadOnly() const;

	// Converts a buffer from a CRLF buffer to a CR buffer (and back)
	// Returns false if no conversion was necessary (and outBuf is left untouched)
	// If the conversion occurs, outBuf will be cleared.
	bool ConvertCRLF(CUtlBuffer& outBuf);

	// Push/pop pretty-printing tabs
	void PushTab();
	void PopTab();

	// Temporarily disables pretty print
	void EnableTabs(bool bEnable);

protected:
	// error flags
	enum
	{
		PUT_OVERFLOW = 0x1,
		GET_OVERFLOW = 0x2,
		MAX_ERROR_FLAG = GET_OVERFLOW,
	};

	void SetOverflowFuncs(UtlBufferOverflowFunc_t getFunc, UtlBufferOverflowFunc_t putFunc);

	bool OnPutOverflow(int nSize);
	bool OnGetOverflow(int nSize);

protected:
	// Checks if a Get/put is ok
	bool CheckPut(int size);
	bool CheckGet(int size);

	void AddNullTermination();

	// Methods to help with pretty-printing
	bool WasLastCharacterCR();
	void PutTabs();

	// Help with delimited stuff
	char GetDelimitedCharInternal(CUtlCharConversion* pConv);
	void PutDelimitedCharInternal(CUtlCharConversion* pConv, char c);

	// Default overflow funcs
	bool PutOverflow(int nSize);
	bool GetOverflow(int nSize);

	// Does the next bytes of the buffer match a pattern?
	bool PeekStringMatch(int nOffset, const char* pString, int nLen);

	// Peek size of line to come, check memory bound
	int	PeekLineLength();

	// How much whitespace should I skip?
	int PeekWhiteSpace(int nOffset);

	// Checks if a peek Get is ok
	bool CheckPeekGet(int nOffset, int nSize);

	// Call this to peek arbitrarily long into memory. It doesn't fail unless
	// it can't read *anything* new
	bool CheckArbitraryPeekGet(int nOffset, int& nIncrement);

	template <typename T> void GetType(T& dest, const char* pszFmt);
	template <typename T> void GetTypeBin(T& dest);
	template <typename T> void GetObject(T* src);

	template <typename T> void PutType(T src, const char* pszFmt);
	template <typename T> void PutTypeBin(T src);
	template <typename T> void PutObject(T* src);

	CUtlMemory<unsigned char> m_Memory;
	int m_Get;
	int m_Put;

	unsigned char m_Error;
	unsigned char m_Flags;
	unsigned char m_Reserved;
#if defined( _X360 )
	unsigned char pad;
#endif

	int m_nTab;
	int m_nMaxPut;
	int m_nOffset;

	UtlBufferOverflowFunc_t m_GetOverflowFunc;
	UtlBufferOverflowFunc_t m_PutOverflowFunc;

	CByteswap	m_Byteswap;
};

// Stream style output operators for CUtlBuffer
inline CUtlBuffer& operator<<(CUtlBuffer& b, char v)
{
	b.PutChar(v);
	return b;
}

inline CUtlBuffer& operator<<(CUtlBuffer& b, unsigned char v)
{
	b.PutUnsignedChar(v);
	return b;
}

inline CUtlBuffer& operator<<(CUtlBuffer& b, short v)
{
	b.PutShort(v);
	return b;
}

inline CUtlBuffer& operator<<(CUtlBuffer& b, unsigned short v)
{
	b.PutUnsignedShort(v);
	return b;
}

inline CUtlBuffer& operator<<(CUtlBuffer& b, int v)
{
	b.PutInt(v);
	return b;
}

inline CUtlBuffer& operator<<(CUtlBuffer& b, unsigned int v)
{
	b.PutUnsignedInt(v);
	return b;
}

inline CUtlBuffer& operator<<(CUtlBuffer& b, float v)
{
	b.PutFloat(v);
	return b;
}

inline CUtlBuffer& operator<<(CUtlBuffer& b, double v)
{
	b.PutDouble(v);
	return b;
}

inline CUtlBuffer& operator<<(CUtlBuffer& b, const char* pv)
{
	b.PutString(pv);
	return b;
}

inline CUtlBuffer& operator<<(CUtlBuffer& b, const Vector& v)
{
	b << v.x << " " << v.y << " " << v.z;
	return b;
}

inline CUtlBuffer& operator<<(CUtlBuffer& b, const Vector2D& v)
{
	b << v.x << " " << v.y;
	return b;
}

class CUtlInplaceBuffer : public CUtlBuffer
{
public:
	CUtlInplaceBuffer(int growSize = 0, int initSize = 0, int nFlags = 0);

	//
	// Routines returning buffer-inplace-pointers
	//
public:
	//
	// Upon success, determines the line length, fills out the pointer to the
	// beginning of the line and the line length, advances the "Get" pointer
	// offset by the line length and returns "true".
	//
	// If end of file is reached or upon error returns "false".
	//
	// Note:	the returned length of the line is at least one character because the
	//			trailing newline characters are also included as part of the line.
	//
	// Note:	the pointer returned points into the local memory of this buffer, in
	//			case the buffer gets relocated or destroyed the pointer becomes invalid.
	//
	// e.g.:	-------------
	//
	//			char *pszLine;
	//			int nLineLen;
	//			while ( pUtlInplaceBuffer->InplaceGetLinePtr( &pszLine, &nLineLen ) )
	//			{
	//				...
	//			}
	//
	//			-------------
	//
	// @param	ppszInBufferPtr		on return points into this buffer at start of line
	// @param	pnLineLength		on return holds num bytes accessible via (*ppszInBufferPtr)
	//
	// @returns	true				if line was successfully read
	//			false				when EOF is reached or error occurs
	//
	bool InplaceGetLinePtr( /* out */ char** ppszInBufferPtr, /* out */ int* pnLineLength);

	//
	// Determines the line length, advances the "Get" pointer offset by the line length,
	// replaces the newline character with null-terminator and returns the initial pointer
	// to now null-terminated line.
	//
	// If end of file is reached or upon error returns NULL.
	//
	// Note:	the pointer returned points into the local memory of this buffer, in
	//			case the buffer gets relocated or destroyed the pointer becomes invalid.
	//
	// e.g.:	-------------
	//
	//			while ( char *pszLine = pUtlInplaceBuffer->InplaceGetLinePtr() )
	//			{
	//				...
	//			}
	//
	//			-------------
	//
	// @returns	ptr-to-zero-terminated-line		if line was successfully read and buffer modified
	//			NULL							when EOF is reached or error occurs
	//
	char* InplaceGetLinePtr(void);
};

//-----------------------------------------------------------------------------
// Where am I reading?
//-----------------------------------------------------------------------------
inline int CUtlBuffer::TellGet() const
{
	return m_Get;
}

//-----------------------------------------------------------------------------
// How many bytes remain to be read?
//-----------------------------------------------------------------------------
inline int CUtlBuffer::GetBytesRemaining() const
{
	return m_nMaxPut - TellGet();
}

//-----------------------------------------------------------------------------
// What am I reading?
//-----------------------------------------------------------------------------
inline const void* CUtlBuffer::PeekGet(int offset) const
{
	return &m_Memory[m_Get + offset - m_nOffset];
}

//-----------------------------------------------------------------------------
// Unserialization
//-----------------------------------------------------------------------------

template <typename T>
inline void CUtlBuffer::GetObject(T* dest)
{
	if (CheckGet(sizeof(T))) {
		if (!m_Byteswap.IsSwappingBytes() || (sizeof(T) == 1)) {
			*dest = *(T*)PeekGet();
		}
		else {
			m_Byteswap.SwapFieldsToTargetEndian<T>(dest, (T*)PeekGet());
		}
		m_Get += sizeof(T);
	}
	else {
		Q_memset(&dest, 0, sizeof(T));
	}
}

template <typename T>
inline void CUtlBuffer::GetObjects(T* dest, int count)
{
	for (int i = 0; i < count; ++i, ++dest) {
		GetObject<T>(dest);
	}
}

template <typename T>
inline void CUtlBuffer::GetTypeBin(T& dest)
{
	if (CheckGet(sizeof(T))) {
		if (!m_Byteswap.IsSwappingBytes() || (sizeof(T) == 1)) {
			dest = *(T*)PeekGet();
		}
		else {
			m_Byteswap.SwapBufferToTargetEndian<T>(&dest, (T*)PeekGet());
		}
		m_Get += sizeof(T);
	}
	else {
		dest = 0;
	}
}

template <>
inline void CUtlBuffer::GetTypeBin< float >(float& dest)
{
	if (CheckGet(sizeof(float))) {
		unsigned int pData = (unsigned int)PeekGet();
		if (IsX360() && (pData & 0x03)) {
			// handle unaligned read
			((unsigned char*)& dest)[0] = ((unsigned char*)pData)[0];
			((unsigned char*)& dest)[1] = ((unsigned char*)pData)[1];
			((unsigned char*)& dest)[2] = ((unsigned char*)pData)[2];
			((unsigned char*)& dest)[3] = ((unsigned char*)pData)[3];
		}
		else {
			// aligned read
			dest = *(float*)pData;
		}
		if (m_Byteswap.IsSwappingBytes()) {
			m_Byteswap.SwapBufferToTargetEndian< float >(&dest, &dest);
		}
		m_Get += sizeof(float);
	}
	else {
		dest = 0;
	}
}

template <typename T>
inline void CUtlBuffer::GetType(T& dest, const char* pszFmt)
{
	if (!IsText()) {
		GetTypeBin(dest);
	}
	else {
		dest = 0;
		Scanf(pszFmt, &dest);
	}
}

inline char CUtlBuffer::GetChar()
{
	char c;
	GetType(c, "%c");
	return c;
}

inline unsigned char CUtlBuffer::GetUnsignedChar()
{
	unsigned char c;
	GetType(c, "%u");
	return c;
}

inline short CUtlBuffer::GetShort()
{
	short s;
	GetType(s, "%d");
	return s;
}

inline unsigned short CUtlBuffer::GetUnsignedShort()
{
	unsigned short s;
	GetType(s, "%u");
	return s;
}

inline int CUtlBuffer::GetInt()
{
	int i;
	GetType(i, "%d");
	return i;
}

inline int CUtlBuffer::GetIntHex()
{
	int i;
	GetType(i, "%x");
	return i;
}

inline unsigned int CUtlBuffer::GetUnsignedInt()
{
	unsigned int u;
	GetType(u, "%u");
	return u;
}

inline float CUtlBuffer::GetFloat()
{
	float f;
	GetType(f, "%f");
	return f;
}

inline double CUtlBuffer::GetDouble()
{
	double d;
	GetType(d, "%f");
	return d;
}

//-----------------------------------------------------------------------------
// Where am I writing?
//-----------------------------------------------------------------------------
inline unsigned char CUtlBuffer::GetFlags() const
{
	return m_Flags;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsExternallyAllocated() const
{
	return m_Memory.IsExternallyAllocated();
}

//-----------------------------------------------------------------------------
// Where am I writing?
//-----------------------------------------------------------------------------
inline int CUtlBuffer::TellPut() const
{
	return m_Put;
}

//-----------------------------------------------------------------------------
// What's the most I've ever written?
//-----------------------------------------------------------------------------
inline int CUtlBuffer::TellMaxPut() const
{
	return m_nMaxPut;
}

//-----------------------------------------------------------------------------
// What am I reading?
//-----------------------------------------------------------------------------
inline void* CUtlBuffer::PeekPut(int offset)
{
	return &m_Memory[m_Put + offset - m_nOffset];
}

//-----------------------------------------------------------------------------
// Various put methods
//-----------------------------------------------------------------------------

template <typename T>
inline void CUtlBuffer::PutObject(T* src)
{
	if (CheckPut(sizeof(T))) {
		if (!m_Byteswap.IsSwappingBytes() || (sizeof(T) == 1)) {
			*(T*)PeekPut() = *src;
		}
		else {
			m_Byteswap.SwapFieldsToTargetEndian<T>((T*)PeekPut(), src);
		}
		m_Put += sizeof(T);
		AddNullTermination();
	}
}

template <typename T>
inline void CUtlBuffer::PutObjects(T* src, int count)
{
	for (int i = 0; i < count; ++i, ++src) {
		PutObject<T>(src);
	}
}

template <typename T>
inline void CUtlBuffer::PutTypeBin(T src)
{
	if (CheckPut(sizeof(T))) {
		if (!m_Byteswap.IsSwappingBytes() || (sizeof(T) == 1)) {
			*(T*)PeekPut() = src;
		}
		else {
			m_Byteswap.SwapBufferToTargetEndian<T>((T*)PeekPut(), &src);
		}
		m_Put += sizeof(T);
		AddNullTermination();
	}
}

template <typename T>
inline void CUtlBuffer::PutType(T src, const char* pszFmt)
{
	if (!IsText()) {
		PutTypeBin(src);
	}
	else {
		Printf(pszFmt, src);
	}
}

//-----------------------------------------------------------------------------
// Methods to help with pretty-printing
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::WasLastCharacterCR()
{
	if (!IsText() || (TellPut() == 0))
		return false;
	return (*(const char*)PeekPut(-1) == '\n');
}

inline void CUtlBuffer::PutTabs()
{
	int nTabCount = (m_Flags & AUTO_TABS_DISABLED) ? 0 : m_nTab;
	for (int i = nTabCount; --i >= 0; ) {
		PutTypeBin<char>('\t');
	}
}

//-----------------------------------------------------------------------------
// Push/pop pretty-printing tabs
//-----------------------------------------------------------------------------
inline void CUtlBuffer::PushTab()
{
	++m_nTab;
}

inline void CUtlBuffer::PopTab()
{
	if (--m_nTab < 0) {
		m_nTab = 0;
	}
}

//-----------------------------------------------------------------------------
// Temporarily disables pretty print
//-----------------------------------------------------------------------------
inline void CUtlBuffer::EnableTabs(bool bEnable)
{
	if (bEnable) {
		m_Flags &= ~AUTO_TABS_DISABLED;
	}
	else {
		m_Flags |= AUTO_TABS_DISABLED;
	}
}

inline void CUtlBuffer::PutChar(char c)
{
	if (WasLastCharacterCR()) {
		PutTabs();
	}

	PutTypeBin(c);
}

inline void CUtlBuffer::PutUnsignedChar(unsigned char c)
{
	PutType(c, "%u");
}

inline void  CUtlBuffer::PutShort(short s)
{
	PutType(s, "%d");
}

inline void CUtlBuffer::PutUnsignedShort(unsigned short s)
{
	PutType(s, "%u");
}

inline void CUtlBuffer::PutInt(int i)
{
	PutType(i, "%d");
}

inline void CUtlBuffer::PutUnsignedInt(unsigned int u)
{
	PutType(u, "%u");
}

inline void CUtlBuffer::PutFloat(float f)
{
	PutType(f, "%f");
}

inline void CUtlBuffer::PutDouble(double d)
{
	PutType(d, "%f");
}

//-----------------------------------------------------------------------------
// Am I a text buffer?
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsText() const
{
	return (m_Flags & TEXT_BUFFER) != 0;
}

//-----------------------------------------------------------------------------
// Can I grow if I'm externally allocated?
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsGrowable() const
{
	return (m_Flags & EXTERNAL_GROWABLE) != 0;
}

//-----------------------------------------------------------------------------
// Am I valid? (overflow or underflow error), Once invalid it stays invalid
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsValid() const
{
	return m_Error == 0;
}

//-----------------------------------------------------------------------------
// Do I contain carriage return/linefeeds?
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::ContainsCRLF() const
{
	return IsText() && ((m_Flags & CONTAINS_CRLF) != 0);
}

//-----------------------------------------------------------------------------
// Am I read-only
//-----------------------------------------------------------------------------
inline bool CUtlBuffer::IsReadOnly() const
{
	return (m_Flags & READ_ONLY) != 0;
}

//-----------------------------------------------------------------------------
// Buffer base and size
//-----------------------------------------------------------------------------
inline const void* CUtlBuffer::Base() const
{
	return m_Memory.Base();
}

inline void* CUtlBuffer::Base()
{
	return m_Memory.Base();
}

inline int CUtlBuffer::Size() const
{
	return m_Memory.NumAllocated();
}

//-----------------------------------------------------------------------------
// Clears out the buffer; frees memory
//-----------------------------------------------------------------------------
inline void CUtlBuffer::Clear()
{
	m_Get = 0;
	m_Put = 0;
	m_Error = 0;
	m_nOffset = 0;
	m_nMaxPut = -1;
	AddNullTermination();
}

inline void CUtlBuffer::Purge()
{
	m_Get = 0;
	m_Put = 0;
	m_nOffset = 0;
	m_nMaxPut = 0;
	m_Error = 0;
	m_Memory.Purge();
}
#pragma warning(default:4127) //conditional operation is constant
```

`src/valve_sdk/misc/UtlMemory.hpp`:

```hpp
#pragma once

#include <assert.h>
#include "platform.hpp"

template< class T, class I = int >
class CUtlMemory
{
public:
	// constructor, destructor
	CUtlMemory(int nGrowSize = 0, int nInitSize = 0);
	CUtlMemory(T* pMemory, int numElements);
	CUtlMemory(const T* pMemory, int numElements);
	~CUtlMemory();

	// Set the size by which the memory grows
	void Init(int nGrowSize = 0, int nInitSize = 0);

	class Iterator_t
	{
	public:
		Iterator_t(I i) : index(i) {}
		I index;

		bool operator==(const Iterator_t it) const { return index == it.index; }
		bool operator!=(const Iterator_t it) const { return index != it.index; }
	};
	Iterator_t First() const { return Iterator_t(IsIdxValid(0) ? 0 : InvalidIndex()); }
	Iterator_t Next(const Iterator_t& it) const { return Iterator_t(IsIdxValid(it.index + 1) ? it.index + 1 : InvalidIndex()); }
	I GetIndex(const Iterator_t& it) const { return it.index; }
	bool IsIdxAfter(I i, const Iterator_t& it) const { return i > it.index; }
	bool IsValidIterator(const Iterator_t& it) const { return IsIdxValid(it.index); }
	Iterator_t InvalidIterator() const { return Iterator_t(InvalidIndex()); }

	// element access
	T& operator[](I i);
	const T& operator[](I i) const;
	T& Element(I i);
	const T& Element(I i) const;

	bool IsIdxValid(I i) const;

	static const I INVALID_INDEX = (I)-1; // For use with COMPILE_TIME_ASSERT
	static I InvalidIndex() { return INVALID_INDEX; }

	T* Base();
	const T* Base() const;

	void SetExternalBuffer(T* pMemory, int numElements);
	void SetExternalBuffer(const T* pMemory, int numElements);
	void AssumeMemory(T* pMemory, int nSize);
	T* Detach();
	void* DetachMemory();

	void Swap(CUtlMemory< T, I >& mem);
	void ConvertToGrowableMemory(int nGrowSize);
	int NumAllocated() const;
	int Count() const;
	void Grow(int num = 1);
	void EnsureCapacity(int num);
	void Purge();
	void Purge(int numElements);
	bool IsExternallyAllocated() const;
	bool IsReadOnly() const;
	void SetGrowSize(int size);

protected:
	void ValidateGrowSize()
	{
	}

	enum
	{
		EXTERNAL_BUFFER_MARKER = -1,
		EXTERNAL_CONST_BUFFER_MARKER = -2,
	};

	T* m_pMemory;
	int m_nAllocationCount;
	int m_nGrowSize;
};

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------

template< class T, class I >
CUtlMemory<T, I>::CUtlMemory(int nGrowSize, int nInitAllocationCount) : m_pMemory(0),
m_nAllocationCount(nInitAllocationCount), m_nGrowSize(nGrowSize)
{
	ValidateGrowSize();
	assert(nGrowSize >= 0);
	if (m_nAllocationCount) {
		m_pMemory = (T*)new unsigned char[m_nAllocationCount * sizeof(T)];
		//m_pMemory = (T*)malloc(m_nAllocationCount * sizeof(T));
	}
}

template< class T, class I >
CUtlMemory<T, I>::CUtlMemory(T* pMemory, int numElements) : m_pMemory(pMemory),
m_nAllocationCount(numElements)
{
	// Special marker indicating externally supplied modifyable memory
	m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template< class T, class I >
CUtlMemory<T, I>::CUtlMemory(const T* pMemory, int numElements) : m_pMemory((T*)pMemory),
m_nAllocationCount(numElements)
{
	// Special marker indicating externally supplied modifyable memory
	m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template< class T, class I >
CUtlMemory<T, I>::~CUtlMemory()
{
	Purge();
}

template< class T, class I >
void CUtlMemory<T, I>::Init(int nGrowSize /*= 0*/, int nInitSize /*= 0*/)
{
	Purge();

	m_nGrowSize = nGrowSize;
	m_nAllocationCount = nInitSize;
	ValidateGrowSize();
	assert(nGrowSize >= 0);
	if (m_nAllocationCount) {
		m_pMemory = (T*)malloc(m_nAllocationCount * sizeof(T));
	}
}

//-----------------------------------------------------------------------------
// Fast swap
//-----------------------------------------------------------------------------
template< class T, class I >
void CUtlMemory<T, I>::Swap(CUtlMemory<T, I>& mem)
{
	V_swap(m_nGrowSize, mem.m_nGrowSize);
	V_swap(m_pMemory, mem.m_pMemory);
	V_swap(m_nAllocationCount, mem.m_nAllocationCount);
}

//-----------------------------------------------------------------------------
// Switches the buffer from an external memory buffer to a reallocatable buffer
//-----------------------------------------------------------------------------
template< class T, class I >
void CUtlMemory<T, I>::ConvertToGrowableMemory(int nGrowSize)
{
	if (!IsExternallyAllocated())
		return;

	m_nGrowSize = nGrowSize;
	if (m_nAllocationCount) {
		int nNumBytes = m_nAllocationCount * sizeof(T);
		T* pMemory = (T*)malloc(nNumBytes);
		memcpy(pMemory, m_pMemory, nNumBytes);
		m_pMemory = pMemory;
	}
	else {
		m_pMemory = NULL;
	}
}

//-----------------------------------------------------------------------------
// Attaches the buffer to external memory....
//-----------------------------------------------------------------------------
template< class T, class I >
void CUtlMemory<T, I>::SetExternalBuffer(T* pMemory, int numElements)
{
	// Blow away any existing allocated memory
	Purge();

	m_pMemory = pMemory;
	m_nAllocationCount = numElements;

	// Indicate that we don't own the memory
	m_nGrowSize = EXTERNAL_BUFFER_MARKER;
}

template< class T, class I >
void CUtlMemory<T, I>::SetExternalBuffer(const T* pMemory, int numElements)
{
	// Blow away any existing allocated memory
	Purge();

	m_pMemory = const_cast<T*>(pMemory);
	m_nAllocationCount = numElements;

	// Indicate that we don't own the memory
	m_nGrowSize = EXTERNAL_CONST_BUFFER_MARKER;
}

template< class T, class I >
void CUtlMemory<T, I>::AssumeMemory(T* pMemory, int numElements)
{
	// Blow away any existing allocated memory
	Purge();

	// Simply take the pointer but don't mark us as external
	m_pMemory = pMemory;
	m_nAllocationCount = numElements;
}

template< class T, class I >
void* CUtlMemory<T, I>::DetachMemory()
{
	if (IsExternallyAllocated())
		return NULL;

	void* pMemory = m_pMemory;
	m_pMemory = 0;
	m_nAllocationCount = 0;
	return pMemory;
}

template< class T, class I >
inline T* CUtlMemory<T, I>::Detach()
{
	return (T*)DetachMemory();
}

//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------
template< class T, class I >
inline T& CUtlMemory<T, I>::operator[](I i)
{
	assert(!IsReadOnly());
	assert(IsIdxValid(i));
	return m_pMemory[i];
}

template< class T, class I >
inline const T& CUtlMemory<T, I>::operator[](I i) const
{
	assert(IsIdxValid(i));
	return m_pMemory[i];
}

template< class T, class I >
inline T& CUtlMemory<T, I>::Element(I i)
{
	assert(!IsReadOnly());
	assert(IsIdxValid(i));
	return m_pMemory[i];
}

template< class T, class I >
inline const T& CUtlMemory<T, I>::Element(I i) const
{
	assert(IsIdxValid(i));
	return m_pMemory[i];
}

//-----------------------------------------------------------------------------
// is the memory externally allocated?
//-----------------------------------------------------------------------------
template< class T, class I >
bool CUtlMemory<T, I>::IsExternallyAllocated() const
{
	return (m_nGrowSize < 0);
}

//-----------------------------------------------------------------------------
// is the memory read only?
//-----------------------------------------------------------------------------
template< class T, class I >
bool CUtlMemory<T, I>::IsReadOnly() const
{
	return (m_nGrowSize == EXTERNAL_CONST_BUFFER_MARKER);
}

template< class T, class I >
void CUtlMemory<T, I>::SetGrowSize(int nSize)
{
	assert(!IsExternallyAllocated());
	assert(nSize >= 0);
	m_nGrowSize = nSize;
	ValidateGrowSize();
}

//-----------------------------------------------------------------------------
// Gets the base address (can change when adding elements!)
//-----------------------------------------------------------------------------
template< class T, class I >
inline T* CUtlMemory<T, I>::Base()
{
	assert(!IsReadOnly());
	return m_pMemory;
}

template< class T, class I >
inline const T* CUtlMemory<T, I>::Base() const
{
	return m_pMemory;
}

//-----------------------------------------------------------------------------
// Size
//-----------------------------------------------------------------------------
template< class T, class I >
inline int CUtlMemory<T, I>::NumAllocated() const
{
	return m_nAllocationCount;
}

template< class T, class I >
inline int CUtlMemory<T, I>::Count() const
{
	return m_nAllocationCount;
}

//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------
template< class T, class I >
inline bool CUtlMemory<T, I>::IsIdxValid(I i) const
{
	// GCC warns if I is an unsigned type and we do a ">= 0" against it (since the comparison is always 0).
	// We Get the warning even if we cast inside the expression. It only goes away if we assign to another variable.
	long x = i;
	return (x >= 0) && (x < m_nAllocationCount);
}

//-----------------------------------------------------------------------------
// Grows the memory
//-----------------------------------------------------------------------------
inline int UtlMemory_CalcNewAllocationCount(int nAllocationCount, int nGrowSize, int nNewSize, int nBytesItem)
{
	if (nGrowSize) {
		nAllocationCount = ((1 + ((nNewSize - 1) / nGrowSize)) * nGrowSize);
	}
	else {
		if (!nAllocationCount) {
			// Compute an allocation which is at least as big as a cache line...
			nAllocationCount = (31 + nBytesItem) / nBytesItem;
		}

		while (nAllocationCount < nNewSize) {
#ifndef _X360
			nAllocationCount *= 2;
#else
			int nNewAllocationCount = (nAllocationCount * 9) / 8; // 12.5 %
			if (nNewAllocationCount > nAllocationCount)
				nAllocationCount = nNewAllocationCount;
			else
				nAllocationCount *= 2;
#endif
		}
	}

	return nAllocationCount;
}

template< class T, class I >
void CUtlMemory<T, I>::Grow(int num)
{
	assert(num > 0);

	if (IsExternallyAllocated()) {
		// Can't grow a buffer whose memory was externally allocated
		assert(0);
		return;
	}

	auto oldAllocationCount = m_nAllocationCount;
	// Make sure we have at least numallocated + num allocations.
	// Use the grow rules specified for this memory (in m_nGrowSize)
	int nAllocationRequested = m_nAllocationCount + num;

	int nNewAllocationCount = UtlMemory_CalcNewAllocationCount(m_nAllocationCount, m_nGrowSize, nAllocationRequested, sizeof(T));

	// if m_nAllocationRequested wraps index type I, recalculate
	if ((int)(I)nNewAllocationCount < nAllocationRequested) {
		if ((int)(I)nNewAllocationCount == 0 && (int)(I)(nNewAllocationCount - 1) >= nAllocationRequested) {
			--nNewAllocationCount; // deal w/ the common case of m_nAllocationCount == MAX_USHORT + 1
		}
		else {
			if ((int)(I)nAllocationRequested != nAllocationRequested) {
				// we've been asked to grow memory to a size s.t. the index type can't address the requested amount of memory
				assert(0);
				return;
			}
			while ((int)(I)nNewAllocationCount < nAllocationRequested) {
				nNewAllocationCount = (nNewAllocationCount + nAllocationRequested) / 2;
			}
		}
	}

	m_nAllocationCount = nNewAllocationCount;

	if (m_pMemory) {
		auto ptr = new unsigned char[m_nAllocationCount * sizeof(T)];

		memcpy(ptr, m_pMemory, oldAllocationCount * sizeof(T));
		m_pMemory = (T*)ptr;
	}
	else {
		m_pMemory = (T*)new unsigned char[m_nAllocationCount * sizeof(T)];
	}
}

//-----------------------------------------------------------------------------
// Makes sure we've got at least this much memory
//-----------------------------------------------------------------------------
template< class T, class I >
inline void CUtlMemory<T, I>::EnsureCapacity(int num)
{
	if (m_nAllocationCount >= num)
		return;

	if (IsExternallyAllocated()) {
		// Can't grow a buffer whose memory was externally allocated
		assert(0);
		return;
	}
	m_nAllocationCount = num;

	if (m_pMemory) {
		m_pMemory = (T*)realloc(m_pMemory, m_nAllocationCount * sizeof(T));
	}
	else {
		m_pMemory = (T*)malloc(m_nAllocationCount * sizeof(T));
	}
}

//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------
template< class T, class I >
void CUtlMemory<T, I>::Purge()
{
	if (!IsExternallyAllocated()) {
		if (m_pMemory) {
			free((void*)m_pMemory);
			m_pMemory = 0;
		}
		m_nAllocationCount = 0;
	}
}

template< class T, class I >
void CUtlMemory<T, I>::Purge(int numElements)
{
	assert(numElements >= 0);

	if (numElements > m_nAllocationCount) {
		// Ensure this isn't a grow request in disguise.
		assert(numElements <= m_nAllocationCount);
		return;
	}

	// If we have zero elements, simply do a purge:
	if (numElements == 0) {
		Purge();
		return;
	}

	if (IsExternallyAllocated()) {
		// Can't shrink a buffer whose memory was externally allocated, fail silently like purge
		return;
	}

	// If the number of elements is the same as the allocation count, we are done.
	if (numElements == m_nAllocationCount) {
		return;
	}

	if (!m_pMemory) {
		// Allocation count is non zero, but memory is null.
		assert(m_pMemory);
		return;
	}
	m_nAllocationCount = numElements;
	m_pMemory = (T*)realloc(m_pMemory, m_nAllocationCount * sizeof(T));
}

//-----------------------------------------------------------------------------
// The CUtlMemory class:
// A growable memory class which doubles in size by default.
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
class CUtlMemoryAligned : public CUtlMemory<T>
{
public:
	// constructor, destructor
	CUtlMemoryAligned(int nGrowSize = 0, int nInitSize = 0);
	CUtlMemoryAligned(T* pMemory, int numElements);
	CUtlMemoryAligned(const T* pMemory, int numElements);
	~CUtlMemoryAligned();

	// Attaches the buffer to external memory....
	void SetExternalBuffer(T* pMemory, int numElements);
	void SetExternalBuffer(const T* pMemory, int numElements);

	// Grows the memory, so that at least allocated + num elements are allocated
	void Grow(int num = 1);

	// Makes sure we've got at least this much memory
	void EnsureCapacity(int num);

	// Memory deallocation
	void Purge();

	// Purge all but the given number of elements (NOT IMPLEMENTED IN CUtlMemoryAligned)
	void Purge(int numElements) { assert(0); }

private:
	void* Align(const void* pAddr);
};

//-----------------------------------------------------------------------------
// Aligns a pointer
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
void* CUtlMemoryAligned<T, nAlignment>::Align(const void* pAddr)
{
	size_t nAlignmentMask = nAlignment - 1;
	return (void*)(((size_t)pAddr + nAlignmentMask) & (~nAlignmentMask));
}

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
CUtlMemoryAligned<T, nAlignment>::CUtlMemoryAligned(int nGrowSize, int nInitAllocationCount)
{
	CUtlMemory<T>::m_pMemory = 0;
	CUtlMemory<T>::m_nAllocationCount = nInitAllocationCount;
	CUtlMemory<T>::m_nGrowSize = nGrowSize;
	this->ValidateGrowSize();

	// Alignment must be a power of two
	COMPILE_TIME_ASSERT((nAlignment & (nAlignment - 1)) == 0);
	assert((nGrowSize >= 0) && (nGrowSize != CUtlMemory<T>::EXTERNAL_BUFFER_MARKER));
	if (CUtlMemory<T>::m_nAllocationCount) {
		CUtlMemory<T>::m_pMemory = (T*)_aligned_malloc(nInitAllocationCount * sizeof(T), nAlignment);
	}
}

template< class T, int nAlignment >
CUtlMemoryAligned<T, nAlignment>::CUtlMemoryAligned(T* pMemory, int numElements)
{
	// Special marker indicating externally supplied memory
	CUtlMemory<T>::m_nGrowSize = CUtlMemory<T>::EXTERNAL_BUFFER_MARKER;

	CUtlMemory<T>::m_pMemory = (T*)Align(pMemory);
	CUtlMemory<T>::m_nAllocationCount = ((int)(pMemory + numElements) - (int)CUtlMemory<T>::m_pMemory) / sizeof(T);
}

template< class T, int nAlignment >
CUtlMemoryAligned<T, nAlignment>::CUtlMemoryAligned(const T* pMemory, int numElements)
{
	// Special marker indicating externally supplied memory
	CUtlMemory<T>::m_nGrowSize = CUtlMemory<T>::EXTERNAL_CONST_BUFFER_MARKER;

	CUtlMemory<T>::m_pMemory = (T*)Align(pMemory);
	CUtlMemory<T>::m_nAllocationCount = ((int)(pMemory + numElements) - (int)CUtlMemory<T>::m_pMemory) / sizeof(T);
}

template< class T, int nAlignment >
CUtlMemoryAligned<T, nAlignment>::~CUtlMemoryAligned()
{
	Purge();
}

//-----------------------------------------------------------------------------
// Attaches the buffer to external memory....
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
void CUtlMemoryAligned<T, nAlignment>::SetExternalBuffer(T* pMemory, int numElements)
{
	// Blow away any existing allocated memory
	Purge();

	CUtlMemory<T>::m_pMemory = (T*)Align(pMemory);
	CUtlMemory<T>::m_nAllocationCount = ((int)(pMemory + numElements) - (int)CUtlMemory<T>::m_pMemory) / sizeof(T);

	// Indicate that we don't own the memory
	CUtlMemory<T>::m_nGrowSize = CUtlMemory<T>::EXTERNAL_BUFFER_MARKER;
}

template< class T, int nAlignment >
void CUtlMemoryAligned<T, nAlignment>::SetExternalBuffer(const T* pMemory, int numElements)
{
	// Blow away any existing allocated memory
	Purge();

	CUtlMemory<T>::m_pMemory = (T*)Align(pMemory);
	CUtlMemory<T>::m_nAllocationCount = ((int)(pMemory + numElements) - (int)CUtlMemory<T>::m_pMemory) / sizeof(T);

	// Indicate that we don't own the memory
	CUtlMemory<T>::m_nGrowSize = CUtlMemory<T>::EXTERNAL_CONST_BUFFER_MARKER;
}

//-----------------------------------------------------------------------------
// Grows the memory
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
void CUtlMemoryAligned<T, nAlignment>::Grow(int num)
{
	assert(num > 0);

	if (this->IsExternallyAllocated()) {
		// Can't grow a buffer whose memory was externally allocated
		assert(0);
		return;
	}

	// Make sure we have at least numallocated + num allocations.
	// Use the grow rules specified for this memory (in m_nGrowSize)
	int nAllocationRequested = CUtlMemory<T>::m_nAllocationCount + num;

	CUtlMemory<T>::m_nAllocationCount = UtlMemory_CalcNewAllocationCount(CUtlMemory<T>::m_nAllocationCount, CUtlMemory<T>::m_nGrowSize, nAllocationRequested, sizeof(T));

	if (CUtlMemory<T>::m_pMemory) {
		CUtlMemory<T>::m_pMemory = (T*)MemAlloc_ReallocAligned(CUtlMemory<T>::m_pMemory, CUtlMemory<T>::m_nAllocationCount * sizeof(T), nAlignment);
		assert(CUtlMemory<T>::m_pMemory);
	}
	else {
		CUtlMemory<T>::m_pMemory = (T*)MemAlloc_AllocAligned(CUtlMemory<T>::m_nAllocationCount * sizeof(T), nAlignment);
		assert(CUtlMemory<T>::m_pMemory);
	}
}

//-----------------------------------------------------------------------------
// Makes sure we've got at least this much memory
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
inline void CUtlMemoryAligned<T, nAlignment>::EnsureCapacity(int num)
{
	if (CUtlMemory<T>::m_nAllocationCount >= num)
		return;

	if (this->IsExternallyAllocated()) {
		// Can't grow a buffer whose memory was externally allocated
		assert(0);
		return;
	}

	CUtlMemory<T>::m_nAllocationCount = num;

	if (CUtlMemory<T>::m_pMemory) {
		CUtlMemory<T>::m_pMemory = (T*)MemAlloc_ReallocAligned(CUtlMemory<T>::m_pMemory, CUtlMemory<T>::m_nAllocationCount * sizeof(T), nAlignment);
	}
	else {
		CUtlMemory<T>::m_pMemory = (T*)MemAlloc_AllocAligned(CUtlMemory<T>::m_nAllocationCount * sizeof(T), nAlignment);
	}
}

//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------
template< class T, int nAlignment >
void CUtlMemoryAligned<T, nAlignment>::Purge()
{
	if (!this->IsExternallyAllocated()) {
		if (CUtlMemory<T>::m_pMemory) {
			MemAlloc_FreeAligned(CUtlMemory<T>::m_pMemory);
			CUtlMemory<T>::m_pMemory = 0;
		}
		CUtlMemory<T>::m_nAllocationCount = 0;
	}
}
```

`src/valve_sdk/misc/UtlString.cpp`:

```cpp
#include "UtlString.hpp"

#define NOMINMAX
#include <Windows.h>
#include <stdio.h>

//-----------------------------------------------------------------------------
// Base class, containing simple memory management
//-----------------------------------------------------------------------------
CUtlBinaryBlock::CUtlBinaryBlock(int growSize, int initSize) : m_Memory(growSize, initSize)
{
	m_nActualLength = 0;
}

CUtlBinaryBlock::CUtlBinaryBlock(void* pMemory, int nSizeInBytes, int nInitialLength) : m_Memory((unsigned char*)pMemory, nSizeInBytes)
{
	m_nActualLength = nInitialLength;
}

CUtlBinaryBlock::CUtlBinaryBlock(const void* pMemory, int nSizeInBytes) : m_Memory((const unsigned char*)pMemory, nSizeInBytes)
{
	m_nActualLength = nSizeInBytes;
}

CUtlBinaryBlock::CUtlBinaryBlock(const CUtlBinaryBlock& src)
{
	Set(src.Get(), src.Length());
}

void CUtlBinaryBlock::Get(void* pValue, int nLen) const
{
	assert(nLen > 0);
	if (m_nActualLength < nLen) {
		nLen = m_nActualLength;
	}

	if (nLen > 0) {
		memcpy(pValue, m_Memory.Base(), nLen);
	}
}

void CUtlBinaryBlock::SetLength(int nLength)
{
	assert(!m_Memory.IsReadOnly());

	m_nActualLength = nLength;
	if (nLength > m_Memory.NumAllocated()) {
		int nOverFlow = nLength - m_Memory.NumAllocated();
		m_Memory.Grow(nOverFlow);

		// If the reallocation failed, clamp length
		if (nLength > m_Memory.NumAllocated()) {
			m_nActualLength = m_Memory.NumAllocated();
		}
	}

#ifdef _DEBUG
	if (m_Memory.NumAllocated() > m_nActualLength) {
		memset(((char*)m_Memory.Base()) + m_nActualLength, 0xEB, m_Memory.NumAllocated() - m_nActualLength);
	}
#endif
}

void CUtlBinaryBlock::Set(const void* pValue, int nLen)
{
	assert(!m_Memory.IsReadOnly());

	if (!pValue) {
		nLen = 0;
	}

	SetLength(nLen);

	if (m_nActualLength) {
		if (((const char*)m_Memory.Base()) >= ((const char*)pValue) + nLen ||
			((const char*)m_Memory.Base()) + m_nActualLength <= ((const char*)pValue)) {
			memcpy(m_Memory.Base(), pValue, m_nActualLength);
		}
		else {
			memmove(m_Memory.Base(), pValue, m_nActualLength);
		}
	}
}

CUtlBinaryBlock& CUtlBinaryBlock::operator=(const CUtlBinaryBlock& src)
{
	assert(!m_Memory.IsReadOnly());
	Set(src.Get(), src.Length());
	return *this;
}

bool CUtlBinaryBlock::operator==(const CUtlBinaryBlock& src) const
{
	if (src.Length() != Length())
		return false;

	return !memcmp(src.Get(), Get(), Length());
}

//-----------------------------------------------------------------------------
// Simple string class.
//-----------------------------------------------------------------------------
CUtlString::CUtlString()
{
}

CUtlString::CUtlString(const char* pString)
{
	Set(pString);
}

CUtlString::CUtlString(const CUtlString& string)
{
	Set(string.Get());
}

// Attaches the string to external memory. Useful for avoiding a copy
CUtlString::CUtlString(void* pMemory, int nSizeInBytes, int nInitialLength) : m_Storage(pMemory, nSizeInBytes, nInitialLength)
{
}

CUtlString::CUtlString(const void* pMemory, int nSizeInBytes) : m_Storage(pMemory, nSizeInBytes)
{
}

void CUtlString::Set(const char* pValue)
{
	assert(!m_Storage.IsReadOnly());
	int nLen = pValue ? strlen(pValue) + 1 : 0;
	m_Storage.Set(pValue, nLen);
}

// Returns strlen
int CUtlString::Length() const
{
	return m_Storage.Length() ? m_Storage.Length() - 1 : 0;
}

// Sets the length (used to serialize into the buffer )
void CUtlString::SetLength(int nLen)
{
	assert(!m_Storage.IsReadOnly());

	// Add 1 to account for the NULL
	m_Storage.SetLength(nLen > 0 ? nLen + 1 : 0);
}

const char* CUtlString::Get() const
{
	if (m_Storage.Length() == 0) {
		return "";
	}

	return reinterpret_cast<const char*>(m_Storage.Get());
}

// Converts to c-strings
CUtlString::operator const char* () const
{
	return Get();
}

char* CUtlString::Get()
{
	assert(!m_Storage.IsReadOnly());

	if (m_Storage.Length() == 0) {
		// In general, we optimise away small mallocs for empty strings
		// but if you ask for the non-const bytes, they must be writable
		// so we can't return "" here, like we do for the const version - jd
		m_Storage.SetLength(1);
		m_Storage[0] = '\0';
	}

	return reinterpret_cast<char*>(m_Storage.Get());
}

CUtlString& CUtlString::operator=(const CUtlString& src)
{
	assert(!m_Storage.IsReadOnly());
	m_Storage = src.m_Storage;
	return *this;
}

CUtlString& CUtlString::operator=(const char* src)
{
	assert(!m_Storage.IsReadOnly());
	Set(src);
	return *this;
}

bool CUtlString::operator==(const CUtlString& src) const
{
	return m_Storage == src.m_Storage;
}

bool CUtlString::operator==(const char* src) const
{
	return (strcmp(Get(), src) == 0);
}

CUtlString& CUtlString::operator+=(const CUtlString& rhs)
{
	assert(!m_Storage.IsReadOnly());

	const int lhsLength(Length());
	const int rhsLength(rhs.Length());
	const int requestedLength(lhsLength + rhsLength);

	SetLength(requestedLength);
	const int allocatedLength(Length());
	const int copyLength(allocatedLength - lhsLength < rhsLength ? allocatedLength - lhsLength : rhsLength);
	memcpy(Get() + lhsLength, rhs.Get(), copyLength);
	m_Storage[allocatedLength] = '\0';

	return *this;
}

CUtlString& CUtlString::operator+=(const char* rhs)
{
	assert(!m_Storage.IsReadOnly());

	const int lhsLength(Length());
	const int rhsLength(strlen(rhs));
	const int requestedLength(lhsLength + rhsLength);

	SetLength(requestedLength);
	const int allocatedLength(Length());
	const int copyLength(allocatedLength - lhsLength < rhsLength ? allocatedLength - lhsLength : rhsLength);
	memcpy(Get() + lhsLength, rhs, copyLength);
	m_Storage[allocatedLength] = '\0';

	return *this;
}

CUtlString& CUtlString::operator+=(char c)
{
	assert(!m_Storage.IsReadOnly());

	int nLength = Length();
	SetLength(nLength + 1);
	m_Storage[nLength] = c;
	m_Storage[nLength + 1] = '\0';
	return *this;
}

CUtlString& CUtlString::operator+=(int rhs)
{
	assert(!m_Storage.IsReadOnly());
	assert(sizeof(rhs) == 4);

	char tmpBuf[12];	// Sufficient for a signed 32 bit integer [ -2147483648 to +2147483647 ]
	snprintf(tmpBuf, sizeof(tmpBuf), "%d", rhs);
	tmpBuf[sizeof(tmpBuf) - 1] = '\0';

	return operator+=(tmpBuf);
}

CUtlString& CUtlString::operator+=(double rhs)
{
	assert(!m_Storage.IsReadOnly());

	char tmpBuf[256];	// How big can doubles be???  Dunno.
	snprintf(tmpBuf, sizeof(tmpBuf), "%lg", rhs);
	tmpBuf[sizeof(tmpBuf) - 1] = '\0';

	return operator+=(tmpBuf);
}

int CUtlString::Format(const char* pFormat, ...)
{
	assert(!m_Storage.IsReadOnly());

	char tmpBuf[4096];	//< Nice big 4k buffer, as much memory as my first computer had, a Radio Shack Color Computer

	va_list marker;

	va_start(marker, pFormat);
	int len = _vsnprintf_s(tmpBuf, 4096, sizeof(tmpBuf) - 1, pFormat, marker);
	va_end(marker);

	// Len < 0 represents an overflow
	if (len < 0) {
		len = sizeof(tmpBuf) - 1;
		tmpBuf[sizeof(tmpBuf) - 1] = 0;
	}

	Set(tmpBuf);

	return len;
}

//-----------------------------------------------------------------------------
// Strips the trailing slash
//-----------------------------------------------------------------------------
void CUtlString::StripTrailingSlash()
{
	if (IsEmpty())
		return;

	int nLastChar = Length() - 1;
	char c = m_Storage[nLastChar];
	if (c == '\\' || c == '/') {
		m_Storage[nLastChar] = 0;
		m_Storage.SetLength(m_Storage.Length() - 1);
	}
}
```

`src/valve_sdk/misc/UtlString.hpp`:

```hpp
#pragma once

#include <cstdint>
#include <cstring>

#include "UtlMemory.hpp"

class CUtlBinaryBlock
{
public:
	CUtlBinaryBlock(int growSize = 0, int initSize = 0);

	// NOTE: nInitialLength indicates how much of the buffer starts full
	CUtlBinaryBlock(void* pMemory, int nSizeInBytes, int nInitialLength);
	CUtlBinaryBlock(const void* pMemory, int nSizeInBytes);
	CUtlBinaryBlock(const CUtlBinaryBlock& src);

	void        Get(void* pValue, int nMaxLen) const;
	void        Set(const void* pValue, int nLen);
	const void* Get() const;
	void* Get();

	unsigned char& operator[](int i);
	const unsigned char& operator[](int i) const;

	int         Length() const;
	void        SetLength(int nLength);    // Undefined memory will result
	bool        IsEmpty() const;
	void        Clear();
	void        Purge();

	bool        IsReadOnly() const;

	CUtlBinaryBlock& operator=(const CUtlBinaryBlock& src);

	// Test for equality
	bool operator==(const CUtlBinaryBlock& src) const;

private:
	CUtlMemory<unsigned char> m_Memory;
	int m_nActualLength;
};

//-----------------------------------------------------------------------------
// class inlines
//-----------------------------------------------------------------------------
inline const void* CUtlBinaryBlock::Get() const
{
	return m_Memory.Base();
}

inline void* CUtlBinaryBlock::Get()
{
	return m_Memory.Base();
}

inline int CUtlBinaryBlock::Length() const
{
	return m_nActualLength;
}

inline unsigned char& CUtlBinaryBlock::operator[](int i)
{
	return m_Memory[i];
}

inline const unsigned char& CUtlBinaryBlock::operator[](int i) const
{
	return m_Memory[i];
}

inline bool CUtlBinaryBlock::IsReadOnly() const
{
	return m_Memory.IsReadOnly();
}

inline bool CUtlBinaryBlock::IsEmpty() const
{
	return Length() == 0;
}

inline void CUtlBinaryBlock::Clear()
{
	SetLength(0);
}

inline void CUtlBinaryBlock::Purge()
{
	SetLength(0);
	m_Memory.Purge();
}

//-----------------------------------------------------------------------------
// Simple string class.
// NOTE: This is *not* optimal! Use in tools, but not runtime code
//-----------------------------------------------------------------------------
class CUtlString
{
public:
	CUtlString();
	CUtlString(const char* pString);
	CUtlString(const CUtlString& string);

	// Attaches the string to external memory. Useful for avoiding a copy
	CUtlString(void* pMemory, int nSizeInBytes, int nInitialLength);
	CUtlString(const void* pMemory, int nSizeInBytes);

	const char* Get() const;
	void        Set(const char* pValue);

	// Set directly and don't look for a null terminator in pValue.
	void        SetDirect(const char* pValue, int nChars);

	// Converts to c-strings
	operator const char* () const;

	// for compatibility switching items from UtlSymbol
	const char* String() const { return Get(); }

	// Returns strlen
	int            Length() const;
	bool        IsEmpty() const;

	// Sets the length (used to serialize into the buffer )
	// Note: If nLen != 0, then this adds an extra uint8_t for a null-terminator.
	void        SetLength(int nLen);
	char* Get();
	void        Clear();
	void        Purge();

	// Strips the trailing slash
	void        StripTrailingSlash();

	CUtlString& operator=(const CUtlString& src);
	CUtlString& operator=(const char* src);

	// Test for equality
	bool operator==(const CUtlString& src) const;
	bool operator==(const char* src) const;
	bool operator!=(const CUtlString& src) const { return !operator==(src); }
	bool operator!=(const char* src) const { return !operator==(src); }

	CUtlString& operator+=(const CUtlString& rhs);
	CUtlString& operator+=(const char* rhs);
	CUtlString& operator+=(char c);
	CUtlString& operator+=(int rhs);
	CUtlString& operator+=(double rhs);

	CUtlString operator+(const char* pOther);
	CUtlString operator+(int rhs);

	int Format(const char* pFormat, ...);

	// Take a piece out of the string.
	// If you only specify nStart, it'll go from nStart to the end.
	// You can use negative numbers and it'll wrap around to the start.
	CUtlString Slice(int32_t nStart = 0, int32_t nEnd = INT32_MAX);

	// Grab a substring starting from the left or the right side.
	CUtlString Left(int32_t nChars);
	CUtlString Right(int32_t nChars);

	// Replace all instances of one character with another.
	CUtlString Replace(char cFrom, char cTo);

	// Calls right through to V_MakeAbsolutePath.
	CUtlString AbsPath(const char* pStartingDir = NULL);

	// Gets the filename (everything except the path.. c:\a\b\c\somefile.txt -> somefile.txt).
	CUtlString UnqualifiedFilename();

	// Strips off one directory. Uses V_StripLastDir but strips the last slash also!
	CUtlString DirName();

	// Works like V_ComposeFileName.
	static CUtlString PathJoin(const char* pStr1, const char* pStr2);

	// These can be used for utlvector sorts.
	static int __cdecl SortCaseInsensitive(const CUtlString* pString1, const CUtlString* pString2);
	static int __cdecl SortCaseSensitive(const CUtlString* pString1, const CUtlString* pString2);

private:
	CUtlBinaryBlock m_Storage;
};

//-----------------------------------------------------------------------------
// Inline methods
//-----------------------------------------------------------------------------
inline bool CUtlString::IsEmpty() const
{
	return Length() == 0;
}

inline int __cdecl CUtlString::SortCaseInsensitive(const CUtlString* pString1, const CUtlString* pString2)
{
	return _stricmp(pString1->String(), pString2->String());
}

inline int __cdecl CUtlString::SortCaseSensitive(const CUtlString* pString1, const CUtlString* pString2)
{
	return strcmp(pString1->String(), pString2->String());
}
```

`src/valve_sdk/misc/UtlVector.hpp`:

```hpp
#pragma once

#include <cstring>
#include "UtlMemory.hpp"

template< class T, class A = CUtlMemory<T> >
class CUtlVector
{
	typedef A CAllocator;
public:
	typedef T ElemType_t;

	// constructor, destructor
	CUtlVector(int growSize = 0, int initSize = 0);
	CUtlVector(T* pMemory, int allocationCount, int numElements = 0);
	~CUtlVector();

	// Copy the array.
	CUtlVector<T, A>& operator=(const CUtlVector<T, A>& other);

	// element access
	T& operator[](int i);
	const T& operator[](int i) const;
	T& Element(int i);
	const T& Element(int i) const;
	T& Head();
	const T& Head() const;
	T& Tail();
	const T& Tail() const;

	// Gets the base address (can change when adding elements!)
	T* Base() { return m_Memory.Base(); }
	const T* Base() const { return m_Memory.Base(); }
	// Returns the number of elements in the vector
	int Count() const;
	// Is element index valid?
	bool IsValidIndex(int i) const;
	static int InvalidIndex();
	// Adds an element, uses default constructor
	int AddToHead();
	int AddToTail();
	int InsertBefore(int elem);
	int InsertAfter(int elem);
	// Adds an element, uses copy constructor
	int AddToHead(const T& src);
	int AddToTail(const T& src);
	int InsertBefore(int elem, const T& src);
	int InsertAfter(int elem, const T& src);
	// Adds multiple elements, uses default constructor
	int AddMultipleToHead(int num);
	int AddMultipleToTail(int num);
	int AddMultipleToTail(int num, const T* pToCopy);
	int InsertMultipleBefore(int elem, int num);
	int InsertMultipleBefore(int elem, int num, const T* pToCopy);
	int InsertMultipleAfter(int elem, int num);
	// Calls RemoveAll() then AddMultipleToTail.
	void SetSize(int size);
	void SetCount(int count);
	void SetCountNonDestructively(int count); //sets count by adding or removing elements to tail TODO: This should probably be the default behavior for SetCount
	void CopyArray(const T* pArray, int size); //Calls SetSize and copies each element.
											   // Fast swap
	void Swap(CUtlVector< T, A >& vec);
	// Add the specified array to the tail.
	int AddVectorToTail(CUtlVector<T, A> const& src);
	// Finds an element (element needs operator== defined)
	int GetOffset(const T& src) const;
	void FillWithValue(const T& src);
	bool HasElement(const T& src) const;
	// Makes sure we have enough memory allocated to store a requested # of elements
	void EnsureCapacity(int num);
	// Makes sure we have at least this many elements
	void EnsureCount(int num);
	// Element removal
	void FastRemove(int elem);    // doesn't preserve order
	void Remove(int elem);        // preserves order, shifts elements
	bool FindAndRemove(const T& src);    // removes first occurrence of src, preserves order, shifts elements
	bool FindAndFastRemove(const T& src);    // removes first occurrence of src, doesn't preserve order
	void RemoveMultiple(int elem, int num);    // preserves order, shifts elements
	void RemoveMultipleFromHead(int num); // removes num elements from tail
	void RemoveMultipleFromTail(int num); // removes num elements from tail
	void RemoveAll();                // doesn't deallocate memory
	void Purge(); // Memory deallocation
				  // Purges the list and calls delete on each element in it.
	void PurgeAndDeleteElements();
	// Compacts the vector to the number of elements actually in use
	void Compact();
	// Set the size by which it grows when it needs to allocate more memory.
	void SetGrowSize(int size) { m_Memory.SetGrowSize(size); }
	int NumAllocated() const;    // Only use this if you really know what you're doing!
	void Sort(int(__cdecl* pfnCompare)(const T*, const T*));

protected:
	// Can't copy this unless we explicitly do it!
	CUtlVector(CUtlVector const& vec) { assert(0); }

	// Grows the vector
	void GrowVector(int num = 1);

	// Shifts elements....
	void ShiftElementsRight(int elem, int num = 1);
	void ShiftElementsLeft(int elem, int num = 1);

public:
	CAllocator m_Memory;
	int m_Size;

	// For easier access to the elements through the debugger
	// it's in release builds so this can be used in libraries correctly
	T* m_pElements;

	inline void ResetDbgInfo()
	{
		m_pElements = Base();
	}
};

//-----------------------------------------------------------------------------
// constructor, destructor
//-----------------------------------------------------------------------------
template< typename T, class A >
inline CUtlVector<T, A>::CUtlVector(int growSize, int initSize) :
	m_Memory(growSize, initSize), m_Size(0)
{
	ResetDbgInfo();
}

template< typename T, class A >
inline CUtlVector<T, A>::CUtlVector(T* pMemory, int allocationCount, int numElements) :
	m_Memory(pMemory, allocationCount), m_Size(numElements)
{
	ResetDbgInfo();
}

template< typename T, class A >
inline CUtlVector<T, A>::~CUtlVector()
{
	Purge();
}

template< typename T, class A >
inline CUtlVector<T, A>& CUtlVector<T, A>::operator=(const CUtlVector<T, A>& other)
{
	int nCount = other.Count();
	SetSize(nCount);
	for (int i = 0; i < nCount; i++) {
		(*this)[i] = other[i];
	}
	return *this;
}

//-----------------------------------------------------------------------------
// element access
//-----------------------------------------------------------------------------
template< typename T, class A >
inline T& CUtlVector<T, A>::operator[](int i)
{
	assert(i < m_Size);
	return m_Memory[i];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::operator[](int i) const
{
	assert(i < m_Size);
	return m_Memory[i];
}

template< typename T, class A >
inline T& CUtlVector<T, A>::Element(int i)
{
	assert(i < m_Size);
	return m_Memory[i];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::Element(int i) const
{
	assert(i < m_Size);
	return m_Memory[i];
}

template< typename T, class A >
inline T& CUtlVector<T, A>::Head()
{
	assert(m_Size > 0);
	return m_Memory[0];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::Head() const
{
	assert(m_Size > 0);
	return m_Memory[0];
}

template< typename T, class A >
inline T& CUtlVector<T, A>::Tail()
{
	assert(m_Size > 0);
	return m_Memory[m_Size - 1];
}

template< typename T, class A >
inline const T& CUtlVector<T, A>::Tail() const
{
	assert(m_Size > 0);
	return m_Memory[m_Size - 1];
}

//-----------------------------------------------------------------------------
// Count
//-----------------------------------------------------------------------------
template< typename T, class A >
inline int CUtlVector<T, A>::Count() const
{
	return m_Size;
}

//-----------------------------------------------------------------------------
// Is element index valid?
//-----------------------------------------------------------------------------
template< typename T, class A >
inline bool CUtlVector<T, A>::IsValidIndex(int i) const
{
	return (i >= 0) && (i < m_Size);
}

//-----------------------------------------------------------------------------
// Returns in invalid index
//-----------------------------------------------------------------------------
template< typename T, class A >
inline int CUtlVector<T, A>::InvalidIndex()
{
	return -1;
}

//-----------------------------------------------------------------------------
// Grows the vector
//-----------------------------------------------------------------------------
template< typename T, class A >
void CUtlVector<T, A>::GrowVector(int num)
{
	if (m_Size + num > m_Memory.NumAllocated()) {
		m_Memory.Grow(m_Size + num - m_Memory.NumAllocated());
	}

	m_Size += num;
	ResetDbgInfo();
}

//-----------------------------------------------------------------------------
// Sorts the vector
//-----------------------------------------------------------------------------
template< typename T, class A >
void CUtlVector<T, A>::Sort(int(__cdecl* pfnCompare)(const T*, const T*))
{
	typedef int(__cdecl * QSortCompareFunc_t)(const void*, const void*);
	if (Count() <= 1)
		return;

	if (Base()) {
		qsort(Base(), Count(), sizeof(T), (QSortCompareFunc_t)(pfnCompare));
	}
	else {
		assert(0);
		// this path is untested
		// if you want to sort vectors that use a non-sequential memory allocator,
		// you'll probably want to patch in a quicksort algorithm here
		// I just threw in this bubble sort to have something just in case...

		for (int i = m_Size - 1; i >= 0; --i) {
			for (int j = 1; j <= i; ++j) {
				if (pfnCompare(&Element(j - 1), &Element(j)) < 0) {
					V_swap(Element(j - 1), Element(j));
				}
			}
		}
	}
}

//-----------------------------------------------------------------------------
// Makes sure we have enough memory allocated to store a requested # of elements
//-----------------------------------------------------------------------------
template< typename T, class A >
void CUtlVector<T, A>::EnsureCapacity(int num)
{
	m_Memory.EnsureCapacity(num);
	ResetDbgInfo();
}

//-----------------------------------------------------------------------------
// Makes sure we have at least this many elements
//-----------------------------------------------------------------------------
template< typename T, class A >
void CUtlVector<T, A>::EnsureCount(int num)
{
	if (Count() < num) {
		AddMultipleToTail(num - Count());
	}
}

//-----------------------------------------------------------------------------
// Shifts elements
//-----------------------------------------------------------------------------
template< typename T, class A >
void CUtlVector<T, A>::ShiftElementsRight(int elem, int num)
{
	assert(IsValidIndex(elem) || (m_Size == 0) || (num == 0));
	int numToMove = m_Size - elem - num;
	if ((numToMove > 0) && (num > 0))
		memmove(&Element(elem + num), &Element(elem), numToMove * sizeof(T));
}

template< typename T, class A >
void CUtlVector<T, A>::ShiftElementsLeft(int elem, int num)
{
	assert(IsValidIndex(elem) || (m_Size == 0) || (num == 0));
	int numToMove = m_Size - elem - num;
	if ((numToMove > 0) && (num > 0)) {
		memmove(&Element(elem), &Element(elem + num), numToMove * sizeof(T));

#ifdef _DEBUG
		memset(&Element(m_Size - num), 0xDD, num * sizeof(T));
#endif
	}
}

//-----------------------------------------------------------------------------
// Adds an element, uses default constructor
//-----------------------------------------------------------------------------
template< typename T, class A >
inline int CUtlVector<T, A>::AddToHead()
{
	return InsertBefore(0);
}

template< typename T, class A >
inline int CUtlVector<T, A>::AddToTail()
{
	return InsertBefore(m_Size);
}

template< typename T, class A >
inline int CUtlVector<T, A>::InsertAfter(int elem)
{
	return InsertBefore(elem + 1);
}

template< typename T, class A >
int CUtlVector<T, A>::InsertBefore(int elem)
{
	// Can insert at the end
	assert((elem == Count()) || IsValidIndex(elem));

	GrowVector();
	ShiftElementsRight(elem);
	Construct(&Element(elem));
	return elem;
}

//-----------------------------------------------------------------------------
// Adds an element, uses copy constructor
//-----------------------------------------------------------------------------
template< typename T, class A >
inline int CUtlVector<T, A>::AddToHead(const T& src)
{
	// Can't insert something that's in the list... reallocation may hose us
	assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));
	return InsertBefore(0, src);
}

template< typename T, class A >
inline int CUtlVector<T, A>::AddToTail(const T& src)
{
	// Can't insert something that's in the list... reallocation may hose us
	assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));
	return InsertBefore(m_Size, src);
}

template< typename T, class A >
inline int CUtlVector<T, A>::InsertAfter(int elem, const T& src)
{
	// Can't insert something that's in the list... reallocation may hose us
	assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));
	return InsertBefore(elem + 1, src);
}

template< typename T, class A >
int CUtlVector<T, A>::InsertBefore(int elem, const T& src)
{
	// Can't insert something that's in the list... reallocation may hose us
	assert((Base() == NULL) || (&src < Base()) || (&src >= (Base() + Count())));

	// Can insert at the end
	assert((elem == Count()) || IsValidIndex(elem));

	GrowVector();
	ShiftElementsRight(elem);
	CopyConstruct(&Element(elem), src);
	return elem;
}

//-----------------------------------------------------------------------------
// Adds multiple elements, uses default constructor
//-----------------------------------------------------------------------------
template< typename T, class A >
inline int CUtlVector<T, A>::AddMultipleToHead(int num)
{
	return InsertMultipleBefore(0, num);
}

template< typename T, class A >
inline int CUtlVector<T, A>::AddMultipleToTail(int num)
{
	return InsertMultipleBefore(m_Size, num);
}

template< typename T, class A >
inline int CUtlVector<T, A>::AddMultipleToTail(int num, const T* pToCopy)
{
	// Can't insert something that's in the list... reallocation may hose us
	assert((Base() == NULL) || !pToCopy || (pToCopy + num <= Base()) || (pToCopy >= (Base() + Count())));

	return InsertMultipleBefore(m_Size, num, pToCopy);
}

template< typename T, class A >
int CUtlVector<T, A>::InsertMultipleAfter(int elem, int num)
{
	return InsertMultipleBefore(elem + 1, num);
}

template< typename T, class A >
void CUtlVector<T, A>::SetCount(int count)
{
	RemoveAll();
	AddMultipleToTail(count);
}

template< typename T, class A >
inline void CUtlVector<T, A>::SetSize(int size)
{
	SetCount(size);
}

template< typename T, class A >
void CUtlVector<T, A>::SetCountNonDestructively(int count)
{
	int delta = count - m_Size;
	if (delta > 0) AddMultipleToTail(delta);
	else if (delta < 0) RemoveMultipleFromTail(-delta);
}

template< typename T, class A >
void CUtlVector<T, A>::CopyArray(const T* pArray, int size)
{
	// Can't insert something that's in the list... reallocation may hose us
	assert((Base() == NULL) || !pArray || (Base() >= (pArray + size)) || (pArray >= (Base() + Count())));

	SetSize(size);
	for (int i = 0; i < size; i++) {
		(*this)[i] = pArray[i];
	}
}

template< typename T, class A >
void CUtlVector<T, A>::Swap(CUtlVector< T, A >& vec)
{
	m_Memory.Swap(vec.m_Memory);
	V_swap(m_Size, vec.m_Size);
#ifndef _X360
	V_swap(m_pElements, vec.m_pElements);
#endif
}

template< typename T, class A >
int CUtlVector<T, A>::AddVectorToTail(CUtlVector const& src)
{
	assert(&src != this);

	int base = Count();

	// Make space.
	int nSrcCount = src.Count();
	EnsureCapacity(base + nSrcCount);

	// Copy the elements.
	m_Size += nSrcCount;
	for (int i = 0; i < nSrcCount; i++) {
		CopyConstruct(&Element(base + i), src[i]);
	}
	return base;
}

template< typename T, class A >
inline int CUtlVector<T, A>::InsertMultipleBefore(int elem, int num)
{
	if (num == 0)
		return elem;

	// Can insert at the end
	assert((elem == Count()) || IsValidIndex(elem));

	GrowVector(num);
	ShiftElementsRight(elem, num);

	// Invoke default constructors
	for (int i = 0; i < num; ++i) {
		Construct(&Element(elem + i));
	}

	return elem;
}

template< typename T, class A >
inline int CUtlVector<T, A>::InsertMultipleBefore(int elem, int num, const T* pToInsert)
{
	if (num == 0)
		return elem;

	// Can insert at the end
	assert((elem == Count()) || IsValidIndex(elem));

	GrowVector(num);
	ShiftElementsRight(elem, num);

	// Invoke default constructors
	if (!pToInsert) {
		for (int i = 0; i < num; ++i) {
			Construct(&Element(elem + i));
		}
	}
	else {
		for (int i = 0; i < num; i++) {
			CopyConstruct(&Element(elem + i), pToInsert[i]);
		}
	}

	return elem;
}

//-----------------------------------------------------------------------------
// Finds an element (element needs operator== defined)
//-----------------------------------------------------------------------------
template< typename T, class A >
int CUtlVector<T, A>::GetOffset(const T& src) const
{
	for (int i = 0; i < Count(); ++i) {
		if (Element(i) == src)
			return i;
	}
	return -1;
}

template< typename T, class A >
void CUtlVector<T, A>::FillWithValue(const T& src)
{
	for (int i = 0; i < Count(); i++) {
		Element(i) = src;
	}
}

template< typename T, class A >
bool CUtlVector<T, A>::HasElement(const T& src) const
{
	return (GetOffset(src) >= 0);
}

//-----------------------------------------------------------------------------
// Element removal
//-----------------------------------------------------------------------------
template< typename T, class A >
void CUtlVector<T, A>::FastRemove(int elem)
{
	assert(IsValidIndex(elem));

	Destruct(&Element(elem));
	if (m_Size > 0) {
		if (elem != m_Size - 1)
			memcpy(&Element(elem), &Element(m_Size - 1), sizeof(T));
		--m_Size;
	}
}

template< typename T, class A >
void CUtlVector<T, A>::Remove(int elem)
{
	Destruct(&Element(elem));
	ShiftElementsLeft(elem);
	--m_Size;
}

template< typename T, class A >
bool CUtlVector<T, A>::FindAndRemove(const T& src)
{
	int elem = GetOffset(src);
	if (elem != -1) {
		Remove(elem);
		return true;
	}
	return false;
}

template< typename T, class A >
bool CUtlVector<T, A>::FindAndFastRemove(const T& src)
{
	int elem = GetOffset(src);
	if (elem != -1) {
		FastRemove(elem);
		return true;
	}
	return false;
}

template< typename T, class A >
void CUtlVector<T, A>::RemoveMultiple(int elem, int num)
{
	assert(elem >= 0);
	assert(elem + num <= Count());

	for (int i = elem + num; --i >= elem; )
		Destruct(&Element(i));

	ShiftElementsLeft(elem, num);
	m_Size -= num;
}

template< typename T, class A >
void CUtlVector<T, A>::RemoveMultipleFromHead(int num)
{
	assert(num <= Count());

	for (int i = num; --i >= 0; )
		Destruct(&Element(i));

	ShiftElementsLeft(0, num);
	m_Size -= num;
}

template< typename T, class A >
void CUtlVector<T, A>::RemoveMultipleFromTail(int num)
{
	assert(num <= Count());

	for (int i = m_Size - num; i < m_Size; i++)
		Destruct(&Element(i));

	m_Size -= num;
}

template< typename T, class A >
void CUtlVector<T, A>::RemoveAll()
{
	for (int i = m_Size; --i >= 0; ) {
		Destruct(&Element(i));
	}

	m_Size = 0;
}

//-----------------------------------------------------------------------------
// Memory deallocation
//-----------------------------------------------------------------------------

template< typename T, class A >
inline void CUtlVector<T, A>::Purge()
{
	RemoveAll();
	m_Memory.Purge();
	ResetDbgInfo();
}

template< typename T, class A >
inline void CUtlVector<T, A>::PurgeAndDeleteElements()
{
	for (int i = 0; i < m_Size; i++) {
		delete Element(i);
	}
	Purge();
}

template< typename T, class A >
inline void CUtlVector<T, A>::Compact()
{
	m_Memory.Purge(m_Size);
}

template< typename T, class A >
inline int CUtlVector<T, A>::NumAllocated() const
{
	return m_Memory.NumAllocated();
}

//-----------------------------------------------------------------------------
// Data and memory validation
//-----------------------------------------------------------------------------
#ifdef DBGFLAG_VALIDATE
template< typename T, class A >
void CUtlVector<T, A>::Validate(CValidator& validator, char* pchName)
{
	validator.Push(typeid(*this).name(), this, pchName);

	m_Memory.Validate(validator, "m_Memory");

	validator.Pop();
}
#endif // DBGFLAG_VALIDATE

// A vector class for storing pointers, so that the elements pointed to by the pointers are deleted
// on exit.
template<class T> class CUtlVectorAutoPurge : public CUtlVector< T, CUtlMemory< T, int> >
{
public:
	~CUtlVectorAutoPurge(void)
	{
		this->PurgeAndDeleteElements();
	}
};

// easy string list class with dynamically allocated strings. For use with V_SplitString, etc.
// Frees the dynamic strings in destructor.
class CUtlStringList : public CUtlVectorAutoPurge< char*>
{
public:
	void CopyAndAddToTail(char const* pString)			// clone the string and add to the end
	{
		char* pNewStr = new char[1 + strlen(pString)];
		strcpy_s(pNewStr, 1 + strlen(pString), pString);
		AddToTail(pNewStr);
	}

	static int __cdecl SortFunc(char* const* sz1, char* const* sz2)
	{
		return strcmp(*sz1, *sz2);
	}
};
```

`src/valve_sdk/misc/characterset.cpp`:

```cpp
//========= Copyright © 1996-2005, Valve Corporation, All rights reserved. ============//
//
// Purpose:
//
// $Workfile:     $
// $Date:         $
//
//-----------------------------------------------------------------------------
// $Log: $
//
// $NoKeywords: $
//=============================================================================

#include <string.h>
#include "characterset.hpp"

//-----------------------------------------------------------------------------
// Purpose: builds a simple lookup table of a group of important characters
// Input  : *pParseGroup - pointer to the buffer for the group
//			*pGroupString - null terminated list of characters to flag
//-----------------------------------------------------------------------------
void CharacterSetBuild(characterset_t* pSetBuffer, const char* pszSetString)
{
	int i = 0;

	// Test our pointers
	if (!pSetBuffer || !pszSetString)
		return;

	memset(pSetBuffer->Set, 0, sizeof(pSetBuffer->Set));

	while (pszSetString[i]) {
		pSetBuffer->Set[pszSetString[i]] = 1;
		i++;
	}
}

```

`src/valve_sdk/misc/characterset.hpp`:

```hpp
//===== Copyright © 1996-2005, Valve Corporation, All rights reserved. ======//
//
// Purpose: Shared code for parsing / searching for characters in a string
//			using lookup tables
//
// $Workfile:     $
// $Date:         $
// $NoKeywords: $
//===========================================================================//

#pragma once

struct characterset_t
{
	char Set[256];
};

// This is essentially a strpbrk() using a precalculated lookup table
//-----------------------------------------------------------------------------
// Purpose: builds a simple lookup table of a group of important characters
// Input  : *pSetBuffer - pointer to the buffer for the group
//			*pSetString - list of characters to flag
//-----------------------------------------------------------------------------
extern void CharacterSetBuild(characterset_t* pSetBuffer, const char* pSetString);

//-----------------------------------------------------------------------------
// Purpose:
// Input  : *pSetBuffer - pre-build group buffer
//			character - character to lookup
// Output : int - 1 if the character was in the Set
//-----------------------------------------------------------------------------
#define IN_CHARACTERSET( SetBuffer, character )		((SetBuffer).Set[(character)])
```

`src/valve_sdk/misc/checksum_crc.cpp`:

```cpp
#include "checksum_crc.hpp"

#define BigShort( val )    WordSwap( val )
#define BigWord( val )    WordSwap( val )
#define BigLong( val )    DWordSwap( val )
#define BigDWord( val )    DWordSwap( val )
#define LittleShort( val )   ( val )
#define LittleWord( val )   ( val )
#define LittleLong( val )   ( val )
#define LittleDWord( val )   ( val )
#define SwapShort( val )   BigShort( val )
#define SwapWord( val )    BigWord( val )
#define SwapLong( val )    BigLong( val )
#define SwapDWord( val )   BigDWord( val )

#define CRC32_INIT_VALUE 0xFFFFFFFFUL
#define CRC32_XOR_VALUE  0xFFFFFFFFUL

#define NUM_BYTES 256
static const CRC32_t pulCRCTable[NUM_BYTES] =
{
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba,
	0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,
	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,
	0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,
	0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,
	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
	0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940,
	0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116,
	0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,
	0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,
	0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a,
	0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818,
	0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
	0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,
	0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c,
	0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
	0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,
	0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,
	0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086,
	0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4,
	0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,
	0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,
	0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
	0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe,
	0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,
	0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
	0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252,
	0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60,
	0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,
	0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,
	0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04,
	0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a,
	0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
	0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,
	0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e,
	0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
	0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,
	0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,
	0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0,
	0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6,
	0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,
	0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

void CRC32_Init(CRC32_t* pulCRC)
{
	*pulCRC = CRC32_INIT_VALUE;
}

void CRC32_Final(CRC32_t* pulCRC)
{
	*pulCRC ^= CRC32_XOR_VALUE;
}

CRC32_t CRC32_GetTableEntry(unsigned int slot)
{
	return pulCRCTable[(unsigned char)slot];
}

void CRC32_ProcessBuffer(CRC32_t* pulCRC, const void* pBuffer, int nBuffer)
{
	CRC32_t ulCrc = *pulCRC;
	unsigned char* pb = (unsigned char*)pBuffer;
	unsigned int nFront;
	int nMain;

JustAfew:

	switch (nBuffer) {
	case 7:
		ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

	case 6:
		ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

	case 5:
		ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

	case 4:
		ulCrc ^= LittleLong(*(CRC32_t*)pb);
		ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		*pulCRC = ulCrc;
		return;

	case 3:
		ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

	case 2:
		ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

	case 1:
		ulCrc = pulCRCTable[*pb ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);

	case 0:
		*pulCRC = ulCrc;
		return;
	}

	// We may need to do some alignment work up front, and at the end, so that
	// the main loop is aligned and only has to worry about 8 uint8_t at a time.
	//
	// The low-order two bits of pb and nBuffer in total control the
	// upfront work.
	//
	nFront = ((unsigned int)pb) & 3;
	nBuffer -= nFront;
	switch (nFront) {
	case 3:
		ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
	case 2:
		ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
	case 1:
		ulCrc = pulCRCTable[*pb++ ^ (unsigned char)ulCrc] ^ (ulCrc >> 8);
	}

	nMain = nBuffer >> 3;
	while (nMain--) {
		ulCrc ^= LittleLong(*(CRC32_t*)pb);
		ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc ^= LittleLong(*(CRC32_t*)(pb + 4));
		ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		ulCrc = pulCRCTable[(unsigned char)ulCrc] ^ (ulCrc >> 8);
		pb += 8;
	}

	nBuffer &= 7;
	goto JustAfew;
}
```

`src/valve_sdk/misc/checksum_crc.hpp`:

```hpp
#pragma once

typedef unsigned long CRC32_t;

void CRC32_Init(CRC32_t* pulCRC);
void CRC32_ProcessBuffer(CRC32_t* pulCRC, const void* p, int len);
void CRC32_Final(CRC32_t* pulCRC);
CRC32_t CRC32_GetTableEntry(unsigned int slot);

inline CRC32_t CRC32_ProcessSingleBuffer(const void* p, int len)
{
	CRC32_t crc;

	CRC32_Init(&crc);
	CRC32_ProcessBuffer(&crc, p, len);
	CRC32_Final(&crc);

	return crc;
}
```

`src/valve_sdk/misc/platform.hpp`:

```hpp
#pragma once

#include <malloc.h>
#include <limits.h>
#include <float.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <new.h>

#define COMPILER_MSVC

//-----------------------------------------------------------------------------
// NOTE: All compiler defines are Set up in the base VPC scripts
// COMPILER_MSVC, COMPILER_MSVC32, COMPILER_MSVC64, COMPILER_MSVCX360
// COMPILER_GCC
// The rationale for this is that we need COMPILER_MSVC for the pragma blocks
// #pragma once that occur at the top of all header files, therefore we can't
// place the defines for these in here.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Set up platform defines.
//-----------------------------------------------------------------------------
#ifdef _WIN32
#define IsPlatformLinux()	false
#define IsPlatformPosix()	false
#define IsPlatformOSX()		false
#define IsPlatformPS3()		false
#define IsPlatformWindows() true
#ifndef PLATFORM_WINDOWS
#define PLATFORM_WINDOWS	1
#endif

#ifndef _X360
#define IsPlatformX360() false
#define IsPlatformWindowsPC() true
#define PLATFORM_WINDOWS_PC 1

#ifdef _WIN64
#define IsPlatformWindowsPC64() true
#define IsPlatformWindowsPC32() false
#define PLATFORM_WINDOWS_PC64 1
#else
#define IsPlatformWindowsPC64() false
#define IsPlatformWindowsPC32() true
#define PLATFORM_WINDOWS_PC32 1
#endif

#else // _X360

#define IsPlatformWindowsPC()	false
#define IsPlatformWindowsPC64() false
#define IsPlatformWindowsPC32() false
#define IsPlatformX360()		true
#define PLATFORM_X360 1

#endif // _X360

#elif defined(POSIX)
#define IsPlatformX360()		false
#define IsPlatformPS3()			false
#define IsPlatformWindows()		false
#define IsPlatformWindowsPC()	false
#define IsPlatformWindowsPC64()	false
#define IsPlatformWindowsPC32()	false
#define IsPlatformPosix()		true
#ifndef PLATFORM_POSIX
#define PLATFORM_POSIX 1
#endif

#if defined( LINUX )
#define IsPlatformLinux() true
#define IsPlatformOSX() false
#ifndef PLATFORM_LINUX
#define PLATFORM_LINUX 1
#endif
#elif defined ( OSX )
#define IsPlatformLinux() false
#define IsPlatformOSX() true
#ifndef PLATFORM_OSX
#define PLATFORM_OSX 1
#endif
#else
#define IsPlatformLinux() false
#define IsPlatformOSX() false
#endif

#else
#error
#endif

//-----------------------------------------------------------------------------
// Set up platform type defines.
//-----------------------------------------------------------------------------
#ifdef PLATFORM_X360
#ifndef _CONSOLE
#define _CONSOLE
#endif
#define IsPC()		false
#define IsConsole() true
#else
#define IsPC()		true
#define IsConsole() false
#endif

//-----------------------------------------------------------------------------
// Set up build configuration defines.
//-----------------------------------------------------------------------------
#ifdef _CERT
#define IsCert() true
#else
#define IsCert() false
#endif

#ifdef _DEBUG
#define IsRelease() false
#define IsDebug() true
#else
#define IsRelease() true
#define IsDebug() false
#endif

#ifdef _RETAIL
#define IsRetail() true
#else
#define IsRetail() false
#endif

// Maximum and minimum representable values
#if !defined(PLATFORM_OSX) && !defined(__STDC_LIMIT_MACROS)

#ifndef INT8_MAX
#define  INT8_MAX			SCHAR_MAX
#endif
#ifndef INT16_MAX
#define  INT16_MAX			SHRT_MAX
#endif
#ifndef INT32_MAX
#define  INT32_MAX			LONG_MAX
#endif
#ifndef INT64_MAX
#define  INT64_MAX			(((int64_t)~0) >> 1)
#endif

#ifndef INT8_MIN
#define  INT8_MIN			SCHAR_MIN
#endif
#ifndef INT16_MIN
#define  INT16_MIN			SHRT_MIN
#endif
#ifndef INT32_MIN
#define  INT32_MIN			LONG_MIN
#endif
#ifndef INT64_MIN
#define  INT64_MIN			(((int64_t)1) << 63)
#endif

#ifndef UINT8_MAX
#define  UINT8_MAX			((uint8_t)~0)
#endif
#ifndef UINT16_MAX
#define  UINT16_MAX			((uint16)~0)
#endif
#ifndef UINT32_MAX
#define  UINT32_MAX			((uint32_t)~0)
#endif
#ifndef UINT16_MAX
#define  UINT64_MAX			((uint64_t)~0)
#endif

#ifndef UINT8_MIN
#define  UINT8_MIN			0
#endif
#ifndef UINT16_MIN
#define  UINT16_MIN			0
#endif
#ifndef UINT32_MIN
#define  UINT32_MIN			0
#endif
#ifndef UINT64_MIN
#define  UINT64_MIN			0
#endif

#endif // !PLATFORM_OSX && !__STDC_LIMIT_MACROS

#ifndef  UINT_MIN
#define  UINT_MIN			UINT32_MIN
#endif

#define  FLOAT32_MAX		FLT_MAX
#define  FLOAT64_MAX		DBL_MAX

#ifdef GNUC
#undef offsetof
//#define offsetof( type, var ) __builtin_offsetof( type, var )
#define offsetof(s,m)	(size_t)&(((s *)0)->m)
#else
#include <stddef.h>
#undef offsetof
#define offsetof(s,m)	(size_t)&(((s *)0)->m)
#endif

#define  FLOAT32_MIN		FLT_MIN
#define  FLOAT64_MIN		DBL_MIN

//-----------------------------------------------------------------------------
// Long is evil because it's treated differently by different compilers
// Preventing its use is nasty however. This #define, which should be
// turned on in individual VPC files, causes you to include tier0/valve_off.h
// before standard C + windows headers, and include tier0/valve_on.h after
// standard C + windows headers. So, there's some painful overhead to disabling long
//-----------------------------------------------------------------------------
#ifdef DISALLOW_USE_OF_LONG
#define long			long_is_the_devil_stop_using_it_use_int32_or_int64
#endif

//-----------------------------------------------------------------------------
// Various compiler-specific keywords
//-----------------------------------------------------------------------------
#ifdef COMPILER_MSVC

#ifdef FORCEINLINE
#undef FORCEINLINE
#endif
#define STDCALL					__stdcall
#ifndef FASTCALL
#define  FASTCALL			__fastcall
#endif
#define FORCEINLINE				__forceinline
#define FORCEINLINE_TEMPLATE	__forceinline
#define NULLTERMINATED			__nullterminated

// This can be used to ensure the size of pointers to members when declaring
// a pointer type for a class that has only been forward declared
#define SINGLE_INHERITANCE		__single_inheritance
#define MULTIPLE_INHERITANCE	__multiple_inheritance
#define EXPLICIT				explicit
#define NO_VTABLE				__declspec( novtable )

// gcc doesn't allow storage specifiers on explicit template instatiation, but visual studio needs them to avoid link errors.
#define TEMPLATE_STATIC			static

// Used for dll exporting and importing
#define DLL_EXPORT				extern "C" __declspec( dllexport )
#define DLL_IMPORT				extern "C" __declspec( dllimport )

// Can't use extern "C" when DLL exporting a class
#define DLL_CLASS_EXPORT		__declspec( dllexport )
#define DLL_CLASS_IMPORT		__declspec( dllimport )

// Can't use extern "C" when DLL exporting a global
#define DLL_GLOBAL_EXPORT		extern __declspec( dllexport )
#define DLL_GLOBAL_IMPORT		extern __declspec( dllimport )

// Pass hints to the compiler to prevent it from generating unnessecary / stupid code
// in certain situations.  Several compilers other than MSVC also have an equivilent
// construct.
//
// Essentially the 'Hint' is that the condition specified is assumed to be true at
// that point in the compilation.  If '0' is passed, then the compiler assumes that
// any subsequent code in the same 'basic block' is unreachable, and thus usually
// removed.
#define HINT(THE_HINT)			__assume((THE_HINT))

// decls for aligning data
#define DECL_ALIGN(x)			__declspec( align( x ) )

// GCC had a few areas where it didn't construct objects in the same order
// that Windows does. So when CVProfile::CVProfile() would access g_pMemAlloc,
// it would crash because the allocator wasn't initalized yet.
#define CONSTRUCT_EARLY

#define SELECTANY				__declspec(selectany)

#define RESTRICT				__restrict
#define RESTRICT_FUNC			__declspec(restrict)
#define FMTFUNCTION( a, b )
#define NOINLINE

#if !defined( NO_THREAD_LOCAL )
#define DECL_THREAD_LOCAL		__declspec(thread)
#endif

#define DISABLE_VC_WARNING( x ) __pragma(warning(disable:4310) )
#define DEFAULT_VC_WARNING( x ) __pragma(warning(default:4310) )

#elif defined ( COMPILER_GCC )

#if (CROSS_PLATFORM_VERSION >= 1) && !defined( PLATFORM_64BITS )
#define  STDCALL			__attribute__ ((__stdcall__))
#else
#define  STDCALL
#define  __stdcall			__attribute__ ((__stdcall__))
#endif

#define  FASTCALL
#ifdef _LINUX_DEBUGGABLE
#define  FORCEINLINE
#else
#define  FORCEINLINE		inline
#endif

// GCC 3.4.1 has a bug in supporting forced inline of templated functions
// this macro lets us not force inlining in that case
#define FORCEINLINE_TEMPLATE	inline
#define SINGLE_INHERITANCE
#define MULTIPLE_INHERITANCE
#define EXPLICIT
#define NO_VTABLE

#define NULLTERMINATED

#define TEMPLATE_STATIC

// Used for dll exporting and importing
#define DLL_EXPORT				extern "C" __attribute__ ((visibility("default")))
#define DLL_IMPORT				extern "C"

// Can't use extern "C" when DLL exporting a class
#define DLL_CLASS_EXPORT		__attribute__ ((visibility("default")))
#define DLL_CLASS_IMPORT

// Can't use extern "C" when DLL exporting a global
#define DLL_GLOBAL_EXPORT		__attribute__((visibility("default")))
#define DLL_GLOBAL_IMPORT		extern

#define HINT(THE_HINT)			0
#define DECL_ALIGN(x)			__attribute__( ( aligned( x ) ) )
#define CONSTRUCT_EARLY			__attribute__((init_priority(101)))
#define SELECTANY				__attribute__((weak))
#define RESTRICT
#define RESTRICT_FUNC
#define FMTFUNCTION( fmtargnumber, firstvarargnumber ) __attribute__ (( format( printf, fmtargnumber, firstvarargnumber )))
#define NOINLINE				__attribute__ ((noinline))

#if !defined( NO_THREAD_LOCAL )
#define DECL_THREAD_LOCAL		__thread
#endif

#define DISABLE_VC_WARNING( x )
#define DEFAULT_VC_WARNING( x )

#else

#define DECL_ALIGN(x)			/* */
#define SELECTANY				static

#endif

#if defined( GNUC )
// gnuc has the align decoration at the end
#define ALIGN4
#define ALIGN8
#define ALIGN16
#define ALIGN32
#define ALIGN128

#define ALIGN4_POST DECL_ALIGN(4)
#define ALIGN8_POST DECL_ALIGN(8)
#define ALIGN16_POST DECL_ALIGN(16)
#define ALIGN32_POST DECL_ALIGN(32)
#define ALIGN128_POST DECL_ALIGN(128)
#else
// MSVC has the align at the start of the struct
#define ALIGN4 DECL_ALIGN(4)
#define ALIGN8 DECL_ALIGN(8)
#define ALIGN16 DECL_ALIGN(16)
#define ALIGN32 DECL_ALIGN(32)
#define ALIGN128 DECL_ALIGN(128)

#define ALIGN4_POST
#define ALIGN8_POST
#define ALIGN16_POST
#define ALIGN32_POST
#define ALIGN128_POST
#endif

// This can be used to declare an abstract (interface only) class.
// Classes marked abstract should not be instantiated.  If they are, and access violation will occur.
//
// Example of use:
//
// abstract_class CFoo
// {
//      ...
// }
//
// MSDN __declspec(novtable) documentation: http://msdn.microsoft.com/library/default.asp?url=/library/en-us/vclang/html/_langref_novtable.asp
//
// Note: NJS: This is not enabled for regular PC, due to not knowing the implications of exporting a class with no no vtable.
//       It's probable that this shouldn't be an issue, but an experiment should be done to verify this.
//
#ifndef COMPILER_MSVCX360
#define abstract_class class
#else
#define abstract_class class NO_VTABLE
#endif

//-----------------------------------------------------------------------------
// Why do we need this? It would be nice to make it die die die
//-----------------------------------------------------------------------------
// Alloca defined for this platform
#if defined( COMPILER_MSVC ) && !defined( WINDED )
#if defined(_M_IX86)
#define __i386__	1
#endif
#endif

#if defined __i386__ && !defined __linux__
#define id386	1
#else
#define id386	0
#endif  // __i386__

//-----------------------------------------------------------------------------
// Disable annoying unhelpful warnings
//-----------------------------------------------------------------------------
#ifdef COMPILER_MSVC
// Remove warnings from warning level 4.
#pragma warning(disable : 4514) // warning C4514: 'acosl' : unreferenced inline function has been removed
#pragma warning(disable : 4100) // warning C4100: 'hwnd' : unreferenced formal parameter
#pragma warning(disable : 4127) // warning C4127: conditional expression is constant
#pragma warning(disable : 4512) // warning C4512: 'InFileRIFF' : assignment operator could not be generated
#pragma warning(disable : 4611) // warning C4611: interaction between '_setjmp' and C++ object destruction is non-portable
#pragma warning(disable : 4710) // warning C4710: function 'x' not inlined
#pragma warning(disable : 4702) // warning C4702: unreachable code
#pragma warning(disable : 4505) // unreferenced local function has been removed
#pragma warning(disable : 4239) // nonstandard extension used : 'argument' ( conversion from class Vector to class Vector& )
#pragma warning(disable : 4097) // typedef-name 'BaseClass' used as synonym for class-name 'CFlexCycler::CBaseFlex'
#pragma warning(disable : 4324) // Padding was added at the end of a structure
#pragma warning(disable : 4244) // type conversion warning.
#pragma warning(disable : 4305)	// truncation from 'const double ' to 'float '
#pragma warning(disable : 4786)	// Disable warnings about long symbol names
#pragma warning(disable : 4250) // 'X' : inherits 'Y::Z' via dominance
#pragma warning(disable : 4201) // nonstandard extension used : nameless struct/union

#if _MSC_VER >= 1300
#pragma warning(disable : 4511)	// Disable warnings about private copy constructors
#pragma warning(disable : 4121)	// warning C4121: 'symbol' : alignment of a member was sensitive to packing
#pragma warning(disable : 4530)	// warning C4530: C++ exception handler used, but unwind semantics are not enabled. Specify /EHsc (disabled due to std headers having exception syntax)
#endif

#if _MSC_VER >= 1400
#pragma warning(disable : 4996)	// functions declared deprecated
#endif

// When we port to 64 bit, we'll have to resolve the int, ptr vs size_t 32/64 bit problems...
#if !defined( COMPILER_MSVC64 )
#if ( CROSS_PLATFORM_VERSION < 1 )
#pragma warning( disable : 4267 )	// conversion from 'size_t' to 'int', possible loss of data
#pragma warning( disable : 4311 )	// pointer truncation from 'char *' to 'int'
#pragma warning( disable : 4312 )	// conversion from 'unsigned int' to 'memhandle_t' of greater size
#endif
#endif

#endif

//-----------------------------------------------------------------------------
// Stack-based allocation related helpers
//-----------------------------------------------------------------------------
#if defined( COMPILER_GCC )

#define stackalloc( _size )		alloca( ALIGN_VALUE( _size, 16 ) )

#ifdef PLATFORM_OSX
#define mallocsize( _p )	( malloc_size( _p ) )
#else
#define mallocsize( _p )	( malloc_usable_size( _p ) )
#endif

#elif defined ( COMPILER_MSVC )

#define stackalloc( _size )		_alloca( ALIGN_VALUE( _size, 16 ) )
#define mallocsize( _p )		( _msize( _p ) )

#endif

#define  stackfree( _p )			0

//-----------------------------------------------------------------------------
// Used to break into the debugger
//-----------------------------------------------------------------------------
#ifdef COMPILER_MSVC64
#define DebuggerBreak()		__debugbreak()
#elif COMPILER_MSVC32
#define DebuggerBreak()		__asm { int 3 }
#elif COMPILER_MSVCX360
#define DebuggerBreak()		DebugBreak()
#elif COMPILER_GCC
#if defined( PLATFORM_CYGWIN ) || defined( PLATFORM_POSIX )
#define DebuggerBreak()		__asm__( "int $0x3;")
#else
#define DebuggerBreak()		asm( "int3" )
#endif
#endif

//-----------------------------------------------------------------------------
// DLL export for platform utilities
//-----------------------------------------------------------------------------
#ifndef STATIC_TIER0

#ifdef TIER0_DLL_EXPORT
#define PLATFORM_INTERFACE	DLL_EXPORT
#define PLATFORM_OVERLOAD	DLL_GLOBAL_EXPORT
#define PLATFORM_CLASS		DLL_CLASS_EXPORT
#else
#define PLATFORM_INTERFACE	DLL_IMPORT
#define PLATFORM_OVERLOAD	DLL_GLOBAL_IMPORT
#define PLATFORM_CLASS		DLL_CLASS_IMPORT
#endif

#else	// BUILD_AS_DLL

#define PLATFORM_INTERFACE	extern
#define PLATFORM_OVERLOAD
#define PLATFORM_CLASS

#endif	// BUILD_AS_DLL

//-----------------------------------------------------------------------------
// Posix platform helpers
//-----------------------------------------------------------------------------
#ifdef PLATFORM_POSIX

// Visual Studio likes to put an underscore in front of anything that looks like a portable function.
#define _strupr strupr
#define _getcwd getcwd
#define _open open
#define _lseek lseek
#define _read read
#define _close close
#define _vsnprintf vsnprintf
#define _stat stat
#define _O_RDONLY O_RDONLY
#define _stricmp strcasecmp
#define _finite finite
#define _unlink unlink
#define _putenv putenv
#define _chdir chdir
#define _access access
#define _strtoi64 strtoll

#if !defined( _snprintf )	// some vpc's define this on the command line
#define _snprintf snprintf
#endif

#include <alloca.h>
#include <unistd.h>											// Get unlink
#include <errno.h>

#endif // PLATFORM_POSIX

//-----------------------------------------------------------------------------
// Generally useful platform-independent macros (move to another file?)
//-----------------------------------------------------------------------------

// need macro for constant expression
#define ALIGN_VALUE( val, alignment ) ( ( val + alignment - 1 ) & ~( alignment - 1 ) )

// Force a function call site -not- to inlined. (useful for profiling)
#define DONT_INLINE(a) (((int)(a)+1)?(a):(a))

// Marks the codepath from here until the next branch entry point as unreachable,
// and asserts if any attempt is made to execute it.
#define UNREACHABLE() { Assert(0); HINT(0); }

// In cases where no default is present or appropriate, this causes MSVC to generate
// as little code as possible, and throw an assertion in debug.
#define NO_DEFAULT default: UNREACHABLE();

// Defines MAX_PATH
#ifndef MAX_PATH
#define MAX_PATH  260
#endif

//-----------------------------------------------------------------------------
// FP exception handling
//-----------------------------------------------------------------------------
//#define CHECK_FLOAT_EXCEPTIONS		1
//#define CHECK_FPU_CONTROL_WORD_SET	1	// x360 only

#if defined( COMPILER_MSVC64 )

inline void SetupFPUControlWord()
{
}

#elif defined ( COMPILER_MSVC32 )

inline void SetupFPUControlWordForceExceptions()
{
	// use local to Get and store control word
	uint16 tmpCtrlW;
	__asm
	{
		fnclex						/* clear all current exceptions */
		fnstcw word ptr[tmpCtrlW]	/* Get current control word */
		and [tmpCtrlW], 0FCC0h		/* Keep infinity control + rounding control */
		or [tmpCtrlW], 0230h		/* Set to 53-bit, mask only inexact, underflow */
		fldcw word ptr[tmpCtrlW]	/* put new control word in FPU */
	}
}

#ifdef CHECK_FLOAT_EXCEPTIONS

inline void SetupFPUControlWord()
{
	SetupFPUControlWordForceExceptions();
}

#else

inline void SetupFPUControlWord()
{
	// use local to Get and store control word
	uint16 tmpCtrlW;
	__asm
	{
		fnstcw word ptr[tmpCtrlW]	/* Get current control word */
		and [tmpCtrlW], 0FCC0h		/* Keep infinity control + rounding control */
		or [tmpCtrlW], 023Fh		/* Set to 53-bit, mask only inexact, underflow */
		fldcw word ptr[tmpCtrlW]	/* put new control word in FPU */
	}
}

#endif

#elif defined ( COMPILER_GCC )

inline void SetupFPUControlWord()
{
	__volatile unsigned short int __cw;
	__asm __volatile("fnstcw %0" : "=m" (__cw));
	__cw = __cw & 0x0FCC0;	// keep infinity control, keep rounding mode
	__cw = __cw | 0x023F;	// Set 53-bit, no exceptions
	__asm __volatile("fldcw %0" : : "m" (__cw));
}

#elif defined( COMPILER_MSVCX360 )

#ifdef CHECK_FPU_CONTROL_WORD_SET
FORCEINLINE bool IsFPUControlWordSet()
{
	float f = 0.996f;
	union
	{
		double flResult;
		int pResult[2];
	};
	flResult = __fctiw(f);
	return (pResult[1] == 1);
}
#else
#define IsFPUControlWordSet() true
#endif

inline void SetupFPUControlWord()
{
	// Set round-to-nearest in FPSCR
	// (cannot assemble, must use op-code form)
	__emit(0xFF80010C);	// mtfsfi  7,0

						// Favour compatibility over speed (make sure the VPU Set to Java-compliant mode)
						// NOTE: the VPU *always* uses round-to-nearest
	__vector4  a = { 0.0f, 0.0f, 0.0f, 0.0f };
	a;				//	Avoid compiler warning
	__asm
	{
		mtvscr a;	// Clear the Vector Status & Control Register to zero
	}
}

#endif // COMPILER_MSVCX360

//-----------------------------------------------------------------------------
// Purpose: Standard functions for handling endian-ness
//-----------------------------------------------------------------------------

//-------------------------------------
// Basic swaps
//-------------------------------------

template <typename T>
inline T WordSwapC(T w)
{
	uint16_t temp;

	temp = ((*((uint16_t*)& w) & 0xff00) >> 8);
	temp |= ((*((uint16_t*)& w) & 0x00ff) << 8);

	return *((T*)& temp);
}

template <typename T>
inline T DWordSwapC(T dw)
{
	uint32_t temp;

	temp = *((uint32_t*)& dw) >> 24;
	temp |= ((*((uint32_t*)& dw) & 0x00FF0000) >> 8);
	temp |= ((*((uint32_t*)& dw) & 0x0000FF00) << 8);
	temp |= ((*((uint32_t*)& dw) & 0x000000FF) << 24);

	return *((T*)& temp);
}

//-------------------------------------
// Fast swaps
//-------------------------------------

#if defined( COMPILER_MSVCX360 )

#define WordSwap  WordSwap360Intr
#define DWordSwap DWordSwap360Intr

template <typename T>
inline T WordSwap360Intr(T w)
{
	T output;
	__storeshortbytereverse(w, 0, &output);
	return output;
}

template <typename T>
inline T DWordSwap360Intr(T dw)
{
	T output;
	__storewordbytereverse(dw, 0, &output);
	return output;
}

#elif defined( COMPILER_MSVC32 )

#define WordSwap  WordSwapAsm
#define DWordSwap DWordSwapAsm

#pragma warning(push)
#pragma warning (disable:4035) // no return value

template <typename T>
inline T WordSwapAsm(T w)
{
	__asm
	{
		mov ax, w
		xchg al, ah
	}
}

template <typename T>
inline T DWordSwapAsm(T dw)
{
	__asm
	{
		mov eax, dw
		bswap eax
	}
}

#pragma warning(pop)

#else

#define WordSwap  WordSwapC
#define DWordSwap DWordSwapC

#endif

//-------------------------------------
// The typically used methods.
//-------------------------------------

#if defined( _SGI_SOURCE ) || defined( PLATFORM_X360 )
#define	PLAT_BIG_ENDIAN 1
#else
#define PLAT_LITTLE_ENDIAN 1
#endif

// If a swapped float passes through the fpu, the bytes may Get changed.
// Prevent this by swapping floats as DWORDs.
#define SafeSwapFloat( pOut, pIn )	(*((unsigned int*)pOut) = DWordSwap( *((unsigned int*)pIn) ))

#if defined(PLAT_LITTLE_ENDIAN)
#define BigShort( val )				WordSwap( val )
#define BigWord( val )				WordSwap( val )
#define BigLong( val )				DWordSwap( val )
#define BigDWord( val )				DWordSwap( val )
#define LittleShort( val )			( val )
#define LittleWord( val )			( val )
#define LittleLong( val )			( val )
#define LittleDWord( val )			( val )
#define SwapShort( val )			BigShort( val )
#define SwapWord( val )				BigWord( val )
#define SwapLong( val )				BigLong( val )
#define SwapDWord( val )			BigDWord( val )

// Pass floats by pointer for swapping to avoid truncation in the fpu
#define BigFloat( pOut, pIn )		SafeSwapFloat( pOut, pIn )
#define LittleFloat( pOut, pIn )	( *pOut = *pIn )
#define SwapFloat( pOut, pIn )		BigFloat( pOut, pIn )

#elif defined(PLAT_BIG_ENDIAN)

#define BigShort( val )				( val )
#define BigWord( val )				( val )
#define BigLong( val )				( val )
#define BigDWord( val )				( val )
#define LittleShort( val )			WordSwap( val )
#define LittleWord( val )			WordSwap( val )
#define LittleLong( val )			DWordSwap( val )
#define LittleDWord( val )			DWordSwap( val )
#define SwapShort( val )			LittleShort( val )
#define SwapWord( val )				LittleWord( val )
#define SwapLong( val )				LittleLong( val )
#define SwapDWord( val )			LittleDWord( val )

// Pass floats by pointer for swapping to avoid truncation in the fpu
#define BigFloat( pOut, pIn )		( *pOut = *pIn )
#define LittleFloat( pOut, pIn )	SafeSwapFloat( pOut, pIn )
#define SwapFloat( pOut, pIn )		LittleFloat( pOut, pIn )

#else

// @Note (toml 05-02-02): this technique expects the compiler to
// optimize the expression and eliminate the other path. On any new
// platform/compiler this should be tested.
inline short BigShort(short val) { int test = 1; return (*(char*)& test == 1) ? WordSwap(val) : val; }
inline uint16 BigWord(uint16 val) { int test = 1; return (*(char*)& test == 1) ? WordSwap(val) : val; }
inline long BigLong(long val) { int test = 1; return (*(char*)& test == 1) ? DWordSwap(val) : val; }
inline uint32_t BigDWord(uint32_t val) { int test = 1; return (*(char*)& test == 1) ? DWordSwap(val) : val; }
inline short LittleShort(short val) { int test = 1; return (*(char*)& test == 1) ? val : WordSwap(val); }
inline uint16 LittleWord(uint16 val) { int test = 1; return (*(char*)& test == 1) ? val : WordSwap(val); }
inline long LittleLong(long val) { int test = 1; return (*(char*)& test == 1) ? val : DWordSwap(val); }
inline uint32_t LittleDWord(uint32_t val) { int test = 1; return (*(char*)& test == 1) ? val : DWordSwap(val); }
inline short SwapShort(short val) { return WordSwap(val); }
inline uint16 SwapWord(uint16 val) { return WordSwap(val); }
inline long SwapLong(long val) { return DWordSwap(val); }
inline uint32_t SwapDWord(uint32_t val) { return DWordSwap(val); }

// Pass floats by pointer for swapping to avoid truncation in the fpu
inline void BigFloat(float* pOut, const float* pIn) { int test = 1; (*(char*)& test == 1) ? SafeSwapFloat(pOut, pIn) : (*pOut = *pIn); }
inline void LittleFloat(float* pOut, const float* pIn) { int test = 1; (*(char*)& test == 1) ? (*pOut = *pIn) : SafeSwapFloat(pOut, pIn); }
inline void SwapFloat(float* pOut, const float* pIn) { SafeSwapFloat(pOut, pIn); }

#endif

inline uint32_t LoadLittleDWord(uint32_t* base, unsigned int dwordIndex)
{
	return LittleDWord(base[dwordIndex]);
}

inline void StoreLittleDWord(uint32_t* base, unsigned int dwordIndex, uint32_t dword)
{
	base[dwordIndex] = LittleDWord(dword);
}

// Protect against bad auto operator=
#define DISALLOW_OPERATOR_EQUAL( _classname )			\
	private:											\
		_classname &operator=( const _classname & );	\
	public:

// Define a reasonable operator=
#define IMPLEMENT_OPERATOR_EQUAL( _classname )			\
	public:												\
		_classname &operator=( const _classname &src )	\
		{												\
			memcpy( this, &src, sizeof(_classname) );	\
			return *this;								\
		}

#if _X360
#define Plat_FastMemset XMemSet
#define Plat_FastMemcpy XMemCpy
#else
#define Plat_FastMemset memset
#define Plat_FastMemcpy memcpy
#endif

//-----------------------------------------------------------------------------
// XBOX Components valid in PC compilation space
//-----------------------------------------------------------------------------

#define XBOX_DVD_SECTORSIZE			2048
#define XBOX_DVD_ECC_SIZE			32768 // driver reads in quantum ECC blocks
#define XBOX_HDD_SECTORSIZE			512

// Custom windows messages for Xbox input
#define WM_XREMOTECOMMAND					(WM_USER + 100)
#define WM_XCONTROLLER_KEY					(WM_USER + 101)
#define WM_SYS_UI							(WM_USER + 102)
#define WM_SYS_SIGNINCHANGED				(WM_USER + 103)
#define WM_SYS_STORAGEDEVICESCHANGED		(WM_USER + 104)
#define WM_SYS_PROFILESETTINGCHANGED		(WM_USER + 105)
#define WM_SYS_MUTELISTCHANGED				(WM_USER + 106)
#define WM_SYS_INPUTDEVICESCHANGED			(WM_USER + 107)
#define WM_SYS_INPUTDEVICECONFIGCHANGED		(WM_USER + 108)
#define WM_LIVE_CONNECTIONCHANGED			(WM_USER + 109)
#define WM_LIVE_INVITE_ACCEPTED				(WM_USER + 110)
#define WM_LIVE_LINK_STATE_CHANGED			(WM_USER + 111)
#define WM_LIVE_CONTENT_INSTALLED			(WM_USER + 112)
#define WM_LIVE_MEMBERSHIP_PURCHASED		(WM_USER + 113)
#define WM_LIVE_VOICECHAT_AWAY				(WM_USER + 114)
#define WM_LIVE_PRESENCE_CHANGED			(WM_USER + 115)
#define WM_FRIENDS_PRESENCE_CHANGED			(WM_USER + 116)
#define WM_FRIENDS_FRIEND_ADDED				(WM_USER + 117)
#define WM_FRIENDS_FRIEND_REMOVED			(WM_USER + 118)
#define WM_CUSTOM_GAMEBANNERPRESSED			(WM_USER + 119)
#define WM_CUSTOM_ACTIONPRESSED				(WM_USER + 120)
#define WM_XMP_STATECHANGED					(WM_USER + 121)
#define WM_XMP_PLAYBACKBEHAVIORCHANGED		(WM_USER + 122)
#define WM_XMP_PLAYBACKCONTROLLERCHANGED	(WM_USER + 123)

inline const char* GetPlatformExt(void)
{
	return IsPlatformX360() ? ".360" : "";
}

// flat view, 6 hw threads
#define XBOX_PROCESSOR_0			( 1<<0 )
#define XBOX_PROCESSOR_1			( 1<<1 )
#define XBOX_PROCESSOR_2			( 1<<2 )
#define XBOX_PROCESSOR_3			( 1<<3 )
#define XBOX_PROCESSOR_4			( 1<<4 )
#define XBOX_PROCESSOR_5			( 1<<5 )

// core view, 3 cores with 2 hw threads each
#define XBOX_CORE_0_HWTHREAD_0		XBOX_PROCESSOR_0
#define XBOX_CORE_0_HWTHREAD_1		XBOX_PROCESSOR_1
#define XBOX_CORE_1_HWTHREAD_0		XBOX_PROCESSOR_2
#define XBOX_CORE_1_HWTHREAD_1		XBOX_PROCESSOR_3
#define XBOX_CORE_2_HWTHREAD_0		XBOX_PROCESSOR_4
#define XBOX_CORE_2_HWTHREAD_1		XBOX_PROCESSOR_5

//-----------------------------------------------------------------------------
// Include additional dependant header components.
//-----------------------------------------------------------------------------
#if defined( PLATFORM_X360 )
#include "xbox/xbox_core.h"
#endif

//-----------------------------------------------------------------------------
// Methods to invoke the constructor, copy constructor, and destructor
//-----------------------------------------------------------------------------

template <class T>
inline T* Construct(T* pMemory)
{
	return ::new(pMemory) T;
}

template <class T, typename ARG1>
inline T* Construct(T* pMemory, ARG1 a1)
{
	return ::new(pMemory) T(a1);
}

template <class T, typename ARG1, typename ARG2>
inline T* Construct(T* pMemory, ARG1 a1, ARG2 a2)
{
	return ::new(pMemory) T(a1, a2);
}

template <class T, typename ARG1, typename ARG2, typename ARG3>
inline T* Construct(T* pMemory, ARG1 a1, ARG2 a2, ARG3 a3)
{
	return ::new(pMemory) T(a1, a2, a3);
}

template <class T, typename ARG1, typename ARG2, typename ARG3, typename ARG4>
inline T* Construct(T* pMemory, ARG1 a1, ARG2 a2, ARG3 a3, ARG4 a4)
{
	return ::new(pMemory) T(a1, a2, a3, a4);
}

template <class T, typename ARG1, typename ARG2, typename ARG3, typename ARG4, typename ARG5>
inline T* Construct(T* pMemory, ARG1 a1, ARG2 a2, ARG3 a3, ARG4 a4, ARG5 a5)
{
	return ::new(pMemory) T(a1, a2, a3, a4, a5);
}

template <class T>
inline T* CopyConstruct(T* pMemory, T const& src)
{
	return ::new(pMemory) T(src);
}

template <class T>
inline void Destruct(T* pMemory)
{
	pMemory->~T();

#ifdef _DEBUG
	memset(pMemory, 0xDD, sizeof(T));
#endif
}

//
// GET_OUTER()
//
// A platform-independent way for a contained class to Get a pointer to its
// owner. If you know a class is exclusively used in the context of some
// "outer" class, this is a much more space efficient way to Get at the outer
// class than having the inner class store a pointer to it.
//
//	class COuter
//	{
//		class CInner // Note: this does not need to be a nested class to work
//		{
//			void PrintAddressOfOuter()
//			{
//				printf( "Outer is at 0x%x\n", GET_OUTER( COuter, m_Inner ) );
//			}
//		};
//
//		CInner m_Inner;
//		friend class CInner;
//	};

#define GET_OUTER( OuterType, OuterMember ) \
   ( ( OuterType * ) ( (uint8_t *)this - offsetof( OuterType, OuterMember ) ) )

/*	TEMPLATE_FUNCTION_TABLE()

(Note added to platform.h so platforms that correctly support templated
functions can handle portions as templated functions rather than wrapped
functions)

Helps automate the process of creating an array of function
templates that are all specialized by a single integer.
This sort of thing is often useful in optimization work.

For example, using TEMPLATE_FUNCTION_TABLE, this:

TEMPLATE_FUNCTION_TABLE(int, Function, ( int blah, int blah ), 10)
{
return argument * argument;
}

is equivilent to the following:

(NOTE: the function has to be wrapped in a class due to code
generation bugs involved with directly specializing a function
based on a constant.)

template<int argument>
class FunctionWrapper
{
public:
int Function( int blah, int blah )
{
return argument*argument;
}
}

typedef int (*FunctionType)( int blah, int blah );

class FunctionName
{
public:
enum { count = 10 };
FunctionType functions[10];
};

FunctionType FunctionName::functions[] =
{
FunctionWrapper<0>::Function,
FunctionWrapper<1>::Function,
FunctionWrapper<2>::Function,
FunctionWrapper<3>::Function,
FunctionWrapper<4>::Function,
FunctionWrapper<5>::Function,
FunctionWrapper<6>::Function,
FunctionWrapper<7>::Function,
FunctionWrapper<8>::Function,
FunctionWrapper<9>::Function
};
*/

PLATFORM_INTERFACE bool vtune(bool resume);

#define TEMPLATE_FUNCTION_TABLE(RETURN_TYPE, NAME, ARGS, COUNT)			  \
                                                                      \
typedef RETURN_TYPE (FASTCALL *__Type_##NAME) ARGS;						        \
																		                                  \
template<const int nArgument>											                    \
struct __Function_##NAME												                      \
{																		                                  \
	static RETURN_TYPE FASTCALL Run ARGS;								                \
};																		                                \
																		                                  \
template <const int i>														                    \
struct __MetaLooper_##NAME : __MetaLooper_##NAME<i-1>					        \
{																		                                  \
	__Type_##NAME func;													                        \
	inline __MetaLooper_##NAME() { func = __Function_##NAME<i>::Run; }	\
};																		                                \
																		                                  \
template<>																                            \
struct __MetaLooper_##NAME<0>											                    \
{																		                                  \
	__Type_##NAME func;													                        \
	inline __MetaLooper_##NAME() { func = __Function_##NAME<0>::Run; }	\
};																		                                \
																		                                  \
class NAME																                            \
{																		                                  \
private:																                              \
    static const __MetaLooper_##NAME<COUNT> m;							          \
public:																	                              \
	enum { count = COUNT };												                      \
	static const __Type_##NAME* functions;								              \
};																		                                \
const __MetaLooper_##NAME<COUNT> NAME::m;								              \
const __Type_##NAME* NAME::functions = (__Type_##NAME*)&m;				    \
template<const int nArgument>													                \
RETURN_TYPE FASTCALL __Function_##NAME<nArgument>::Run ARGS

#define LOOP_INTERCHANGE(BOOLEAN, CODE)\
	if( (BOOLEAN) )\
	{\
		CODE;\
	} else\
	{\
		CODE;\
	}

#ifdef COMPILER_MSVC
FORCEINLINE uint32_t RotateBitsLeft32(uint32_t nValue, int nRotateBits)
{
	return _rotl(nValue, nRotateBits);
}
FORCEINLINE uint64_t RotateBitsLeft64(uint64_t nValue, int nRotateBits)
{
	return _rotl64(nValue, nRotateBits);
}
FORCEINLINE uint32_t RotateBitsRight32(uint32_t nValue, int nRotateBits)
{
	return _rotr(nValue, nRotateBits);
}
FORCEINLINE uint64_t RotateBitsRight64(uint64_t nValue, int nRotateBits)
{
	return _rotr64(nValue, nRotateBits);
}
#endif
```

`src/valve_sdk/misc/vfunc.hpp`:

```hpp
#pragma once

template<typename FuncType>
__forceinline static FuncType CallVFunction(void* ppClass, int index)
{
	return (*static_cast<FuncType * *>(ppClass))[index];
}

template <std::size_t index, typename return_type, typename... Args>
__forceinline return_type call_virtual(void* instance, Args... args)
{
	using fn = return_type(__thiscall*)(void*, Args...);

	auto function = (*reinterpret_cast<fn**>(instance))[index];
	return function(instance, args...);
}
```

`src/valve_sdk/netvars.cpp`:

```cpp
#include "netvars.hpp"
#include "sdk.hpp"

#include <fstream>
#include <utility>
#include <map>
#include <type_traits>
#include <cctype>

#ifdef _DEBUG
#define DUMP_NETVARS
#endif

#ifdef DUMP_NETVARS
#define IF_DUMPING(...) __VA_ARGS__
#else
#define IF_DUMPING(...)
#endif

IF_DUMPING(static FILE* s_fp;)

netvar_manager::netvar_manager()
{
	//IF_DUMPING(fopen_s(&s_fp, "netvar_dump.txt", "w");)

		for (auto clazz = g::base_client->GetAllClasses(); clazz; clazz = clazz->m_pNext)
			if (clazz->m_pRecvTable)
				dump_recursive(clazz->m_pNetworkName, clazz->m_pRecvTable, 0);

	//IF_DUMPING(fclose(s_fp);)
}

auto netvar_manager::dump_recursive(const char* base_class, RecvTable* table, const std::uint32_t offset) -> void
{
	for (auto i = 0; i < table->m_nProps; ++i)
	{
		const auto prop_ptr = &table->m_pProps[i];

		if (!prop_ptr || isdigit(prop_ptr->m_pVarName[0]))
			continue;

		if (fnv::hash_runtime(prop_ptr->m_pVarName) == FNV("baseclass"))
			continue;

		if (prop_ptr->m_RecvType == DPT_DataTable && prop_ptr->m_pDataTable != nullptr && prop_ptr->m_pDataTable->m_pNetTableName[0] == 'D')
		{
			dump_recursive(base_class, prop_ptr->m_pDataTable, std::uint32_t(offset + prop_ptr->m_Offset));
		}

		char hash_name[256];

		strcpy_s(hash_name, base_class);
		strcat_s(hash_name, "->");
		strcat_s(hash_name, prop_ptr->m_pVarName);

		const auto hash = fnv::hash_runtime(hash_name);
		auto total_offset = std::uint32_t(offset + prop_ptr->m_Offset);
 
		//IF_DUMPING(fprintf(s_fp, "%s\t0x%04X\t%s\n", base_class, total_offset, prop_ptr->m_pVarName);)

		m_props[hash] = { prop_ptr, total_offset };
	}
}
```

`src/valve_sdk/netvars.hpp`:

```hpp
#pragma once

#include <memory>
#include <iostream>
#include <unordered_map>
#include <map>
#include "misc/Recv.hpp"
#include "../helpers//fnv.h"

#define PNETVAR_OFFSET(type, funcname, class_name, var_name, offset) \
auto funcname() -> std::add_pointer_t<type> \
{ \
	constexpr auto hash = fnv::hash_constexpr(class_name "->" var_name); \
	const auto addr = std::uintptr_t(this) + offset + netvar_manager::get_offset_by_hash_cached<hash>(); \
	return reinterpret_cast<std::add_pointer_t<type>>(addr); \
}

#define PNETVAR(type, funcname, class_name, var_name) \
	PNETVAR_OFFSET(type, funcname, class_name, var_name, 0)

#define NETVAR_OFFSET(type, funcname, class_name, var_name, offset) \
auto funcname() -> std::add_lvalue_reference_t<type> \
{ \
	constexpr auto hash = fnv::hash_constexpr(class_name "->" var_name); \
	const auto addr = std::uintptr_t(this) + offset + netvar_manager::get_offset_by_hash_cached<hash>(); \
	return *reinterpret_cast<std::add_pointer_t<type>>(addr); \
}

#define NETVAR(type, funcname, class_name, var_name) \
	NETVAR_OFFSET(type, funcname, class_name, var_name, 0)

#define NETPROP(funcname, class_name, var_name) \
static auto funcname() ->  RecvProp* \
{ \
	constexpr auto hash = fnv::hash_constexpr(class_name "->" var_name); \
	static auto prop_ptr = netvar_manager::get().get_prop(hash); \
	return prop_ptr; \
}

class netvar_manager
{
private:
	struct stored_data
	{
		RecvProp* prop_ptr;
		uint32_t class_relative_offset;
	};

public:
	// Return a const instance, others shouldnt modify this.
	static auto get() -> const netvar_manager &
	{
		static netvar_manager instance;
		return instance;
	}

	auto get_offset(const fnv::hash hash) const -> std::uint32_t
	{
		return m_props.at(hash).class_relative_offset;
	}

	auto get_prop(const fnv::hash hash) const -> RecvProp*
	{
		return m_props.at(hash).prop_ptr;
	}

	__declspec(noinline) static auto get_offset_by_hash(const fnv::hash hash) -> std::uint32_t
	{
		return get().get_offset(hash);
	}

	template<fnv::hash Hash>
	static auto get_offset_by_hash_cached() -> std::uint32_t
	{
		static auto offset = std::uint32_t(0);
		if (!offset)
			offset = get_offset_by_hash(Hash);
		return offset;
	}

private:
	netvar_manager();
	auto dump_recursive(const char* base_class, RecvTable* table, std::uint32_t offset) -> void;

private:
	std::map<fnv::hash, stored_data> m_props;
};
```

`src/valve_sdk/patterns.cpp`:

```cpp
#include "patterns.h"

#include "../helpers/utils.h"

namespace patterns
{
	void initialize()
	{
		set_sky_addr = utils::pattern_scan(SET_SKY);
		find_hud_addr = utils::pattern_scan(FIND_HUD);
		set_clan_tag_addr = utils::pattern_scan(SET_CLAN_TAG);
		update_visibility_entities_addr = utils::pattern_scan(UPDATE_VISIBILITY_ENTITIES);
		set_abs_origin_addr = utils::pattern_scan(SET_ABS_ORIGIN);
		set_abs_angle_addr = utils::pattern_scan(SET_ABS_ANGLE);
		invalidate_bonecache_addr = utils::pattern_scan(INVALIDATE_BONE_CACHE);
		in_reload_addr = utils::pattern_scan(INRELOAD);
		current_command_addr = utils::pattern_scan(CURRENT_COMMAND);
		has_c4_addr = utils::pattern_scan(HAS_C4);
		get_sequence_activity_addr = utils::pattern_scan(GET_SEQUENCE_ACTIVITY);
		is_line_goes_through_smoke_addr = utils::pattern_scan(IS_LINE_GOES_THROUGH_SMOKE);
		is_line_goes_through_smoke_fn_addr = utils::pattern_scan(IS_LINE_GOES_THROUGH_SMOKE_FN);
		reveal_ranks_addr = utils::pattern_scan(REVEAL_RANKS);
	}
}
```

`src/valve_sdk/patterns.h`:

```h
#pragma once
#include "../security/xor.h"

#define GLOBAL_VARS				 xorstr_("client.dll"), xorstr_("A1 ? ? ? ? 5E 8B 40 10")
#define CLIENT_MODE				 xorstr_("client.dll"), xorstr_("B9 ? ? ? ? E8 ? ? ? ? 84 C0 0F 85 ? ? ? ? 53")
#define CINPUT					 xorstr_("client.dll"), xorstr_("B9 ? ? ? ? F3 0F 11 04 24 FF 50 10")
#define MOVE_HELPER				 xorstr_("client.dll"), xorstr_("8B 0D ? ? ? ? 8B 45 ? 51 8B D4 89 02 8B 01")
#define VIEW_RENDER				 xorstr_("client.dll"), xorstr_("A1 ? ? ? ? B9 ? ? ? ? C7 05 ? ? ? ? ? ? ? ? FF 10")
#define D3D_DEVICE				 xorstr_("shaderapidx9.dll"), xorstr_("A1 ? ? ? ? 50 8B 08 FF 51 0C")
#define CLIENT_STATE 			 xorstr_("engine.dll"), xorstr_("A1 ? ? ? ? 33 D2 6A 00 6A 00 33 C9 89 B0")
#define LOCAL_PLAYER			 xorstr_("client.dll"), xorstr_("8B 0D ? ? ? ? 83 FF FF 74 07")
#define CRENDER					 xorstr_("engine.dll"), xorstr_("56 57 0F 57 C0 C7 05 ? ? ? ? ? ? ? ? 51")
#define CHUD					 xorstr_("client.dll"), xorstr_("B9 ? ? ? ? 68 ? ? ? ? E8 ? ? ? ? 89 46 24")
#define PLAYER_RESOURCE			 xorstr_("client.dll"), xorstr_("8B 3D ? ? ? ? 85 FF 0F 84 ? ? ? ? 81 C7")
#define GLOW_MANAGER			 xorstr_("client.dll"), xorstr_("0F 11 05 ? ? ? ? 83 C8 01")
#define WEAPON_SYSTEM			 xorstr_("client.dll"), xorstr_("8B 35 ? ? ? ? FF 10 0F B7 C0")
#define FIRE_BULLETS			 xorstr_("client.dll"), xorstr_("55 8B EC 51 53 56 8B F1 BB ? ? ? ? B8")
#define GAME_RULES_PROXY 	     xorstr_("client.dll"), xorstr_("A1 ? ? ? ? 85 C0 0F 84 ? ? ? ? 80 B8 ? ? ? ? ? 74 7A")
#define VIEW_RENDER_BEAMS		 xorstr_("client.dll"), xorstr_("B9 ? ? ? ? A1 ? ? ? ? FF 10 A1 ? ? ? ? B9")

#define IS_LINE_GOES_THROUGH_SMOKE xorstr_("client.dll"), xorstr_("55 8B EC 83 EC 08 8B 15 ? ? ? ? 0F 57 C0")
#define IS_LINE_GOES_THROUGH_SMOKE_FN xorstr_("client.dll"), xorstr_("55 8B EC 83 EC 08 8B 15 ? ? ? ? 0F")
#define SET_SKY					xorstr_("engine.dll"), xorstr_("55 8B EC 81 EC ? ? ? ? 56 57 8B F9 C7 45")
#define CLEAR_HUD_WEAPON_ICON	xorstr_("client.dll"), xorstr_("55 8B EC 51 53 56 8B 75 08 8B D9 57 6B FE 2C 89 5D FC")
#define FORCE_FULL_UPDATE		xorstr_("engine.dll"), xorstr_("A1 ? ? ? ? B9 ? ? ? ? 56 FF 50 14 8B 34 85")
#define DRAW_POINTS				xorstr_("studiorender.dll"), xorstr_("8B 7D FC 03 F8")
#define SET_MATCH_ACCEPTED		xorstr_("client.dll"), xorstr_("55 8B EC 83 E4 F8 8B 4D 08 BA ? ? ? ? E8 ? ? ? ? 85 C0 75 12")
#define PRESENT_OVERLAY			xorstr_("gameoverlayrenderer.dll"), xorstr_("FF 15 ? ? ? ? 8B F8 85 DB")
#define RESET_OVERLAY			xorstr_("gameoverlayrenderer.dll"), xorstr_("FF 15 ? ? ? ? 8B F8 85 FF 78 18")
#define CURRENT_COMMAND			xorstr_("client.dll"), xorstr_("89 BE ? ? ? ? E8 ? ? ? ? 85 FF")
#define HAS_C4					xorstr_("client.dll"), xorstr_("56 8B F1 85 F6 74 31")
#define SET_ABS_ORIGIN			xorstr_("client.dll"), xorstr_("55 8B EC 83 E4 F8 51 53 56 57 8B F1 E8")
#define INRELOAD				xorstr_("client.dll"), xorstr_("C6 87 ? ? ? ? ? 8B 06 8B CE FF 90")
#define OVERRIDE_BLUR			xorstr_("client.dll"), xorstr_("80 3D ? ? ? ? ? 53 56 57 0F 85")
#define FIND_HUD				xorstr_("client.dll"), xorstr_("55 8B EC 53 8B 5D 08 56 57 8B F9 33 F6 39")
#define UPDATE_VISIBILITY_ENTITIES xorstr_("client.dll"), xorstr_("53 56 66 8B ? ? ? ? ? ? FF FF ? ? 57 90")
#define UPDATE_ANIM_STATE		xorstr_("client.dll"), xorstr_("55 8B EC 83 E4 F8 83 EC 18 56 57 8B F9 F3 0F 11 54 24")
#define SET_ABS_ANGLE			xorstr_("client.dll"), xorstr_("55 8B EC 83 E4 F8 83 EC 64 53 56 57 8B F1 E8")
#define INVALIDATE_BONE_CACHE	xorstr_("client.dll"), xorstr_("80 3D ? ? ? ? ? 74 16 A1 ? ? ? ? 48 C7 81")
#define SET_CLAN_TAG			xorstr_("engine.dll"), xorstr_("53 56 57 8B DA 8B F9 FF 15")
#define PREDICTION_RANDOM_SEED	xorstr_("client.dll"), xorstr_("8B 0D ? ? ? ? BA ? ? ? ? E8 ? ? ? ? 83 C4 04")
#define IS_GAME_STARTED			xorstr_("materialsystem.dll"), xorstr_("80 B9 ? ? ? ? ? 74 0F")
#define LOBBIES_COLLECTION		xorstr_("client.dll"), xorstr_("8B 35 ? ? ? ? 66 3B D0 74 07")
#define GET_SEQUENCE_ACTIVITY	xorstr_("client.dll"), xorstr_("55 8B EC 53 8B 5D 08 56 8B F1 83")
#define REVEAL_RANKS            xorstr_("client.dll"), xorstr_("55 8B EC 51 A1 ? ? ? ? 85 C0 75 37")

namespace patterns
{
	void initialize();

	inline extern uint8_t* set_sky_addr = 0;
	inline extern uint8_t* find_hud_addr = 0;
	inline extern uint8_t* set_clan_tag_addr = 0;
	inline extern uint8_t* update_visibility_entities_addr = 0;
	inline extern uint8_t* set_abs_origin_addr = 0;
	inline extern uint8_t* set_abs_angle_addr = 0;
	inline extern uint8_t* invalidate_bonecache_addr = 0;
	inline extern uint8_t* in_reload_addr = 0;
	inline extern uint8_t* current_command_addr = 0;
	inline extern uint8_t* has_c4_addr = 0;
	inline extern uint8_t* get_sequence_activity_addr = 0;
	inline extern uint8_t* is_line_goes_through_smoke_addr = 0;
	inline extern uint8_t* is_line_goes_through_smoke_fn_addr = 0;
	inline extern uint8_t* reveal_ranks_addr = 0;
}


```

`src/valve_sdk/sdk.cpp`:

```cpp
#include "sdk.hpp"
#include "../helpers/utils.h"
#include "../helpers/console.h"
#include "../settings/globals.h"
#include "../valve_sdk/classids.h"

#include <optional>
#include <map>

#define PRINT_INTERFACE(name) console::print("%-20s: %p", #name, name)

namespace g
{
	CLocalPlayer local_player;
	
	ActiveChannels* active_channel = nullptr;
	Channel* channels = nullptr;
	CInput* input = nullptr;
	IMDLCache* mdl_cache = nullptr;
	ICvar* cvar = nullptr;
	IPanel* vgui_panel = nullptr;
	IVModelInfo* mdl_info = nullptr;
	ISurface* surface = nullptr;
	IClientMode* client_mode = nullptr;
	IMoveHelper* move_helper = nullptr;
	IPrediction* prediction = nullptr;
	IVModelRender* mdl_render = nullptr;
	IVRenderView* render_view = nullptr;
	IEngineTrace* engine_trace = nullptr;
	IEngineSound* engine_sound = nullptr;
	CClientState* client_state = nullptr;
	IInputSystem* input_system = nullptr;
	IVDebugOverlay* debug_overlay = nullptr;
	IGameEventManager2* game_events = nullptr;
	IViewRender* view_render = nullptr;
	IMaterialSystem* mat_system = nullptr;
	IBaseClientDLL* base_client = nullptr;
	CGameMovement* game_movement = nullptr;
	IVEngineClient* engine_client = nullptr;
	CGlobalVarsBase* global_vars = nullptr;
	IDirect3DDevice9* d3_device = nullptr;
	IClientEntityList* entity_list = nullptr;
	IPhysicsSurfaceProps* physics_surface = nullptr;
	CSPlayerResource** player_resource = nullptr;
	CHud* hud_system = nullptr;
	ILocalize* localize = nullptr;
	IMemAlloc* mem_alloc = nullptr;
	IFileSystem* file_system = nullptr;
	IViewRenderBeams* view_render_beams = nullptr;
	ServerClassDLL* server_class = nullptr;
	CHudChat* hud_chat = nullptr;
	CFireBullets* fire_bullets = nullptr;
	CSGameRulesProxy* game_rules_proxy = nullptr;
	
	ISteamUser* steam_user = nullptr;
	ISteamHTTP* steam_http = nullptr;
	ISteamClient* steam_client = nullptr;
	ISteamFriends* steam_friends = nullptr;
	ISteamGameCoordinator* game_coordinator = nullptr;
	ISteamUtils* steam_utils = nullptr;
	ISteamUserStats* steam_user_stats = nullptr;

	template<typename T>
	T* get_interface(const std::string_view moduleName, const std::string_view szInterfaceVersion)
	{
		auto get_module_factory = [](HMODULE module)->CreateInterfaceFn
		{
			return reinterpret_cast<CreateInterfaceFn>(GetProcAddress(module, "CreateInterface"));
		};

		auto result = reinterpret_cast<T*>(get_module_factory(utils::get_module(moduleName.data()))(szInterfaceVersion.data(), nullptr));

		return result;
	}

	template <typename T>
	T get_steam_interface(const std::string_view version)
	{
		static const auto steam_api = utils::get_module("steam_api.dll");
		return reinterpret_cast<T(__cdecl*)(void)>(GetProcAddress(steam_api, version.data()))();
	}

	void get_class_ids()
	{
		for (auto clazz = g::server_class->GetAllClasses(); clazz; clazz = clazz->m_pNext)
		{
			globals::class_ids.insert(std::make_pair(clazz->m_pNetworkName, clazz->m_ClassID));
		}

		classids::initialize();

		g::cvar->ConsolePrintf("\n\nClass ids initialized.\n\n");
	}

	void initialize()
	{
		global_vars = **reinterpret_cast<CGlobalVarsBase***>(utils::pattern_scan(GLOBAL_VARS) + 1);
		client_mode = *reinterpret_cast<IClientMode**>(utils::pattern_scan(CLIENT_MODE) + 1);
		input = *reinterpret_cast<CInput**>(utils::pattern_scan(CINPUT) + 1);
		move_helper = **reinterpret_cast<IMoveHelper***>(utils::pattern_scan(MOVE_HELPER) + 2);
		view_render = *(IViewRender**)(utils::pattern_scan(VIEW_RENDER) + 1);
		d3_device = **reinterpret_cast<IDirect3DDevice9***>(utils::pattern_scan(D3D_DEVICE) + 1);
		client_state = **reinterpret_cast<CClientState***>(utils::pattern_scan(CLIENT_STATE) + 1);
		local_player = *reinterpret_cast<CLocalPlayer*>(utils::pattern_scan(LOCAL_PLAYER) + 2);
		hud_system = *reinterpret_cast<CHud**>(utils::pattern_scan(CHUD) + 1);
		player_resource = *reinterpret_cast<CSPlayerResource***>(utils::pattern_scan(PLAYER_RESOURCE) + 2);
		view_render_beams = *reinterpret_cast<IViewRenderBeams**>(utils::pattern_scan(VIEW_RENDER_BEAMS) + 1);
		fire_bullets = *reinterpret_cast<CFireBullets**>(utils::pattern_scan(FIRE_BULLETS) + 0x131);
		game_rules_proxy = **reinterpret_cast<CSGameRulesProxy***>(utils::pattern_scan(GAME_RULES_PROXY) + 1);
		
		base_client = get_interface<IBaseClientDLL>("client.dll", "VClient018");
		entity_list = get_interface<IClientEntityList>("client.dll", "VClientEntityList003");
		prediction = get_interface<IPrediction>("client.dll", "VClientPrediction001");
		game_movement = get_interface<CGameMovement>("client.dll", "GameMovement001");
		mdl_cache = get_interface<IMDLCache>("datacache.dll", "MDLCache004");
		engine_client = get_interface<IVEngineClient>("engine.dll", "VEngineClient014");
		mdl_info = get_interface<IVModelInfo>("engine.dll", "VModelInfoClient004");
		mdl_render = get_interface<IVModelRender>("engine.dll", "VEngineModel016");
		render_view = get_interface<IVRenderView>("engine.dll", "VEngineRenderView014");
		engine_trace = get_interface<IEngineTrace>("engine.dll", "EngineTraceClient004");
		debug_overlay = get_interface<IVDebugOverlay>("engine.dll", "VDebugOverlay004");
		game_events = get_interface<IGameEventManager2>("engine.dll", "GAMEEVENTSMANAGER002");
		mat_system = get_interface<IMaterialSystem>("materialsystem.dll", "VMaterialSystem080");
		cvar = get_interface<ICvar>("vstdlib.dll", "VEngineCvar007");
		vgui_panel = get_interface<IPanel>("vgui2.dll", "VGUI_Panel009");
		surface = get_interface<ISurface>("vguimatsurface.dll", "VGUI_Surface031");
		physics_surface = get_interface<IPhysicsSurfaceProps>("vphysics.dll", "VPhysicsSurfaceProps001");
		engine_sound = get_interface<IEngineSound>("engine.dll", "IEngineSoundClient003");
		input_system = get_interface<IInputSystem>("inputsystem.dll", "InputSystemVersion001");
		localize = get_interface<ILocalize>("localize.dll", "Localize_001");
		file_system = get_interface<IFileSystem>("filesystem_stdio.dll", "VFileSystem017");
		server_class = get_interface<ServerClassDLL>("server.dll", "ServerGameDLL005");
	
		active_channel = *reinterpret_cast<ActiveChannels**>(utils::pattern_scan("engine.dll", " 8B 1D ? ? ? ? 89 5C 24 48") + 2);
		channels = *reinterpret_cast<Channel**>(utils::pattern_scan("engine.dll", "81 C2 ? ? ? ? 8B 72 54") + 2);

		mem_alloc = *(IMemAlloc**)GetProcAddress(utils::get_module("tier0.dll"), "g_pMemAlloc");

		const auto _steam_user = get_steam_interface<HSteamUser>("SteamAPI_GetHSteamUser");
		const auto _steam_pipe = get_steam_interface<HSteamPipe>("SteamAPI_GetHSteamPipe");

		steam_client = get_steam_interface<ISteamClient*>("SteamClient");
		steam_user = steam_client->GetISteamUser(_steam_user, _steam_user, "SteamUser019");
		game_coordinator = static_cast<ISteamGameCoordinator*>(steam_client->GetISteamGenericInterface(_steam_user, _steam_pipe, "SteamGameCoordinator001"));
		steam_friends = steam_client->GetISteamFriends(_steam_user, _steam_pipe, "SteamFriends015");
		steam_http = steam_client->GetISteamHTTP(_steam_user, _steam_pipe, "STEAMHTTP_INTERFACE_VERSION002");
		steam_utils = steam_client->GetISteamUtils(_steam_pipe, "SteamUtils009");
		steam_user_stats = steam_client->GetISteamUserStats(_steam_user, _steam_pipe, "STEAMUSERSTATS_INTERFACE_VERSION011");

		hud_chat = hud_system->FindHudElement<CHudChat>("CHudChat");

#ifdef _DEBUG
		PRINT_INTERFACE(active_channel);
		PRINT_INTERFACE(channels);
		PRINT_INTERFACE(global_vars);
		PRINT_INTERFACE(client_mode);
		PRINT_INTERFACE(input);
		PRINT_INTERFACE(view_render);
		PRINT_INTERFACE(move_helper);
		PRINT_INTERFACE(d3_device);
		PRINT_INTERFACE(client_state);
		PRINT_INTERFACE(base_client);
		PRINT_INTERFACE(entity_list);
		PRINT_INTERFACE(prediction);
		PRINT_INTERFACE(game_movement);
		PRINT_INTERFACE(mdl_cache);
		PRINT_INTERFACE(engine_client);
		PRINT_INTERFACE(mdl_info);
		PRINT_INTERFACE(mdl_render);
		PRINT_INTERFACE(render_view);
		PRINT_INTERFACE(engine_trace);
		PRINT_INTERFACE(debug_overlay);
		PRINT_INTERFACE(game_events);
		PRINT_INTERFACE(mat_system);
		PRINT_INTERFACE(cvar);
		PRINT_INTERFACE(vgui_panel);
		PRINT_INTERFACE(surface);
		PRINT_INTERFACE(physics_surface);
		PRINT_INTERFACE(local_player);
		PRINT_INTERFACE(game_coordinator);
		PRINT_INTERFACE(steam_client);
		PRINT_INTERFACE(steam_user);
		PRINT_INTERFACE(engine_sound);
		PRINT_INTERFACE(input_system);
		PRINT_INTERFACE(steam_friends);
		PRINT_INTERFACE(steam_http);
		PRINT_INTERFACE(steam_utils);
		PRINT_INTERFACE(hud_system);
		PRINT_INTERFACE(localize);
		PRINT_INTERFACE(mem_alloc);
		PRINT_INTERFACE(file_system);
		PRINT_INTERFACE(view_render_beams);
		PRINT_INTERFACE(hud_chat);
		PRINT_INTERFACE(server_class);	
		PRINT_INTERFACE(steam_user_stats);
#endif
	}
}

```

`src/valve_sdk/sdk.hpp`:

```hpp
#pragma once

#include "patterns.h"
#include "../security/importer.h"

#define NOMINMAX
#include <Windows.h>
#include <map>

#include "misc/vfunc.hpp"

#include "misc/Enums.hpp"

#include "math/VMatrix.hpp"
#include "math/QAngle.hpp"
#include "math/Vectors.hpp"
#include "misc/Studio.hpp"

#include "interfaces/IRefCounted.h"
#include "interfaces/IAppSystem.h"
#include "interfaces/IClientEntity.hpp"
#include "interfaces/IClientEntityList.hpp"
#include "interfaces/IClientMode.hpp"
#include "interfaces/IConVar.hpp"
#include "misc/ClientClass.hpp"
#include "interfaces/IEngineTrace.hpp"
#include "interfaces/IVEngineClient.hpp"
#include "interfaces/CInput.hpp"
#include "interfaces/IGameEvent.hpp"
#include "interfaces/IMaterialSystem.hpp"
#include "interfaces/IMoveHelper.hpp"
#include "interfaces/IMDLCache.hpp"
#include "interfaces/IPrediction.hpp"
#include "interfaces/IPanel.hpp"
#include "interfaces/IViewRender.hpp"
#include "interfaces/IPhysics.hpp"
#include "interfaces/IMaterial.h"
#include "interfaces/IVModelRender.h"
#include "interfaces/IBaseClientDLL.h"
#include "interfaces/IVRenderView.h"
#include "interfaces/ISurface.h"
#include "interfaces/IVModelInfo.h"
#include "interfaces/CGlobalVarsBase.h"
#include "interfaces/CClientState.h"
#include "interfaces/ILocalize.h"
#include "interfaces/IMemAlloc.h"
#include "interfaces/IFileSystem.h"
#include "interfaces/IViewRenderBeams.h"
#include "interfaces/IStudioRender.h"
#include "interfaces/IEngineSound.hpp"
#include "interfaces/IMaterialVar.h"
#include "interfaces/IInputSystem.h"
#include "interfaces/CHud.h"
#include "interfaces/CHudChat.h"
#include "interfaces/ServerClass.h"
#include "interfaces/IVDebugOverlay.h"
#include "interfaces/CFireBullets.h"

#include "misc/Convar.hpp"
#include "interfaces/ICvar.h"
#include "misc/CUserCmd.hpp"

#include "netvars.hpp"
#include "steam.h"

struct IDirect3DDevice9;

class ActiveChannels 
{
public:
	int count;
	short list[128];
};

class Channel 
{
public:
	std::byte pad001[244];
	int sound_source;
	std::byte pad002[56];
	Vector origin;
	Vector direction;
	std::byte pad003[80];
};

class CLocalPlayer
{
public:
	CLocalPlayer() : m_local(nullptr) {}
	
	operator bool() const 
	{ 
		return *m_local != nullptr; 
	}

	operator c_base_player* () const 
	{ 
		return *m_local; 
	}

	c_base_player* operator->() 
	{ 
		return *m_local; 
	}
private:
	c_base_player** m_local;
};

class CSPlayerResource;

class CSGameRulesProxy;

namespace g
{
	extern ActiveChannels* active_channel;
	extern Channel* channels;
	extern CInput* input;
	extern IDirect3DDevice9* d3_device;
	extern IMDLCache* mdl_cache;
	extern IPrediction* prediction;
	extern IClientMode* client_mode;
	extern CGlobalVarsBase* global_vars;
	extern IMoveHelper* move_helper;
	extern IBaseClientDLL* base_client;
	extern IClientEntityList* entity_list;
	extern CClientState* client_state;
	extern CGameMovement* game_movement;
	extern IVEngineClient* engine_client;
	extern IVModelInfo* mdl_info;
	extern IVModelRender* mdl_render;
	extern IVRenderView* render_view;
	extern IEngineTrace* engine_trace;
	extern IVDebugOverlay* debug_overlay;
	extern IGameEventManager2* game_events;
	extern IViewRender* view_render;
	extern IMaterialSystem* mat_system;
	extern ICvar* cvar;
	extern IPanel* vgui_panel;
	extern ISurface* surface;
	extern IPhysicsSurfaceProps* physics_surface;
	extern CLocalPlayer local_player;
	extern IEngineSound* engine_sound;
	extern IInputSystem* input_system;
	extern CSPlayerResource** player_resource;
	extern CHud* hud_system;
	extern ILocalize* localize;
	extern IMemAlloc* mem_alloc;
	extern IFileSystem* file_system;
	extern IViewRenderBeams* view_render_beams;
	extern CHudChat* hud_chat;
	extern CFireBullets* fire_bullets;
	extern CSGameRulesProxy* game_rules_proxy;
	extern ServerClassDLL* server_class;

	extern ISteamUser* steam_user;
	extern ISteamHTTP* steam_http;
	extern ISteamClient* steam_client;
	extern ISteamFriends* steam_friends;
	extern ISteamGameCoordinator* game_coordinator;
	extern ISteamUtils* steam_utils;
	extern ISteamUserStats* steam_user_stats;

	void initialize();
	void get_class_ids();
}

#include "misc/EHandle.hpp"

```

`src/valve_sdk/steam.h`:

```h
#pragma once

typedef int32_t HSteamPipe;
typedef int32_t HSteamUser;
typedef uint64_t SteamLeaderboard_t;
typedef uint64_t SteamLeaderboardEntries_t;
typedef uint64_t UGCHandle_t;

enum EGCResults
{
	k_EGCResultOK = 0,
	k_EGCResultNoMessage = 1,           // There is no message in the queue
	k_EGCResultBufferTooSmall = 2,      // The buffer is too small for the requested message
	k_EGCResultNotLoggedOn = 3,         // The client is not logged onto Steam
	k_EGCResultInvalidMessage = 4,      // Something was wrong with the message being sent with SendMessage
};

class ISteamGameCoordinator
{
public:
	virtual EGCResults GCSendMessage(int unMsgType, const void* pubData, int cubData) = 0;
	virtual bool IsMessageAvailable(int* pcubMsgSize) = 0;
	virtual EGCResults RetrieveMessage(int* punMsgType, void* pubDest, int cubDest, int* pcubMsgSize) = 0;
};

enum EUniverse
{
	k_EUniverseInvalid = 0,
	k_EUniversePublic = 1,
	k_EUniverseTestPublic = 2,
	k_EUniverseInternal = 3,

	k_EUniverseMax
};

enum EAccountType
{
	k_EAccountTypeInvalid = 0,
	k_EAccountTypeIndividual = 1,		// single user account
	k_EAccountTypeMultiseat = 2,		// multiseat (e.g. cybercafe) account
	k_EAccountTypeGameServer = 3,		// game server account
	k_EAccountTypeAnonGameServer = 4,	// anonomous game server account
	k_EAccountTypePending = 5			// pending
};

enum ELeaderboardSortMethod
{
	k_ELeaderboardSortMethodNone = 0,
	k_ELeaderboardSortMethodAscending = 1,	// top-score is lowest number
	k_ELeaderboardSortMethodDescending = 2,	// top-score is highest number
};

enum ELeaderboardDataRequest
{
	k_ELeaderboardDataRequestGlobal = 0,
	k_ELeaderboardDataRequestGlobalAroundUser = 1,
	k_ELeaderboardDataRequestFriends = 2,
	k_ELeaderboardDataRequestUsers = 3
};

enum ELeaderboardDisplayType
{
	k_ELeaderboardDisplayTypeNone = 0,
	k_ELeaderboardDisplayTypeNumeric = 1,			// simple numerical score
	k_ELeaderboardDisplayTypeTimeSeconds = 2,		// the score represents a time, in seconds
	k_ELeaderboardDisplayTypeTimeMilliSeconds = 3,	// the score represents a time, in milliseconds
};

enum ELeaderboardUploadScoreMethod
{
	k_ELeaderboardUploadScoreMethodNone = 0,
	k_ELeaderboardUploadScoreMethodKeepBest = 1,	// Leaderboard will keep user's best score
	k_ELeaderboardUploadScoreMethodForceUpdate = 2,	// Leaderboard will always replace score with specified
};

class CSteamID
{
public:
	CSteamID()
	{
		m_steamid.m_comp.m_unAccountID = 0;
		m_steamid.m_comp.m_EAccountType = 0;
		m_steamid.m_comp.m_EUniverse = 0;
		m_steamid.m_comp.m_unAccountInstance = 0;
	}

	CSteamID(uint64_t ulSteamID)
	{
		SetFromUint64(ulSteamID);
	}

	uint32_t GetAccountID() const { return m_steamid.m_comp.m_unAccountID; }

	void SetFromUint64(uint64_t ulSteamID)
	{
		m_steamid.m_comp.m_unAccountID = (ulSteamID & 0xFFFFFFFF);							// account ID is low 32 bits
		m_steamid.m_comp.m_unAccountInstance = ((ulSteamID >> 32) & 0xFFFFF);			// account instance is next 20 bits

		m_steamid.m_comp.m_EAccountType = (EAccountType)((ulSteamID >> 52) & 0xF);	// type is next 4 bits
		m_steamid.m_comp.m_EUniverse = (EUniverse)((ulSteamID >> 56) & 0xFF);			// universe is next 8 bits
	}

private:
	union SteamID_t
	{
		struct SteamIDComponent_t
		{
			uint32_t			m_unAccountID : 32;			// unique account identifier
			unsigned int		m_unAccountInstance : 20;	// dynamic instance ID (used for multiseat type accounts only)
			unsigned int		m_EAccountType : 4;			// type of account - can't show as EAccountType, due to signed / unsigned difference
			int					m_EUniverse : 8;	// universe this account belongs to
		} m_comp;

		uint64_t m_unAll64Bits;
	} m_steamid;
};

class ISteamUser
{
public:
	virtual uint32_t GetHSteamUser() = 0;
	virtual bool BLoggedOn() = 0;
	virtual CSteamID GetSteamID() = 0;
};

using HTTPRequestHandle = std::uint32_t;
enum : HTTPRequestHandle { INVALID_HTTPREQUEST_HANDLE = 0 };

using SteamAPICall_t = std::uint64_t;
enum : SteamAPICall_t { k_uAPICallInvalid = 0 };

struct LeaderboardEntry_t
{
	CSteamID m_steamIDUser; // user with the entry - use SteamFriends()->GetFriendPersonaName() & SteamFriends()->GetFriendAvatar() to get more info
	int m_nGlobalRank;	// [1..N], where N is the number of users with an entry in the leaderboard
	int m_nScore;			// score as set in the leaderboard
	int m_cDetails;		// number of int32 details available for this entry
	UGCHandle_t m_hUGC;		// handle for UGC attached to the entry
};

enum class EHTTPMethod
{
	Invalid = 0,
	GET,
	HEAD,
	POST
};

class ISteamHTTP
{
public:
	virtual HTTPRequestHandle CreateHTTPRequest(EHTTPMethod eHTTPRequestMethod, const char* pchAbsoluteURL) = 0;
	virtual bool SetHTTPRequestContextValue(HTTPRequestHandle hRequest, std::uint64_t ulContextValue) = 0;
	virtual bool SetHTTPRequestNetworkActivityTimeout(HTTPRequestHandle hRequest, std::uint32_t unTimeoutSeconds) = 0;
	virtual bool SetHTTPRequestHeaderValue(HTTPRequestHandle hRequest, const char* pchHeaderName, const char* pchHeaderValue) = 0;
	virtual bool SetHTTPRequestGetOrPostParameter(HTTPRequestHandle hRequest, const char* pchParamName, const char* pchParamValue) = 0;
	virtual bool SendHTTPRequest(HTTPRequestHandle hRequest, SteamAPICall_t* pCallHandle) = 0;
	virtual bool SendHTTPRequestAndStreamResponse(HTTPRequestHandle hRequest, SteamAPICall_t* pCallHandle) = 0;
	virtual bool DeferHTTPRequest(HTTPRequestHandle hRequest) = 0;
	virtual bool PrioritizeHTTPRequest(HTTPRequestHandle hRequest) = 0;
	virtual bool GetHTTPResponseHeaderSize(HTTPRequestHandle hRequest, const char* pchHeaderName, std::uint32_t* unResponseHeaderSize) = 0;
	virtual bool GetHTTPResponseHeaderValue(HTTPRequestHandle hRequest, const char* pchHeaderName, std::uint8_t* pHeaderValueBuffer, std::uint32_t unBufferSize) = 0;
	virtual bool GetHTTPResponseBodySize(HTTPRequestHandle hRequest, std::uint32_t* unBodySize) = 0;
	virtual bool GetHTTPResponseBodyData(HTTPRequestHandle hRequest, std::uint8_t* pBodyDataBuffer, std::uint32_t unBufferSize) = 0;
	virtual bool GetHTTPStreamingResponseBodyData(HTTPRequestHandle hRequest, std::uint32_t cOffset, std::uint8_t* pBodyDataBuffer, std::uint32_t unBufferSize) = 0;
	virtual bool ReleaseHTTPRequest(HTTPRequestHandle hRequest) = 0;
	virtual bool GetHTTPDownloadProgressPct(HTTPRequestHandle hRequest, float* pflPercentOut) = 0;
	virtual bool SetHTTPRequestRawPostBody(HTTPRequestHandle hRequest, const char* pchContentType, std::uint8_t* pubBody, std::uint32_t unBodyLen) = 0;
};

class ISteamFriends
{
public:
	// returns the local players name - guaranteed to not be NULL.
	// this is the same name as on the users community profile page
	// this is stored in UTF-8 format
	// like all the other interface functions that return a char *, it's important that this pointer is not saved
	// off; it will eventually be free'd or re-allocated
	virtual const char* GetPersonaName() = 0;

	// Sets the player name, stores it on the server and publishes the changes to all friends who are online.
	// Changes take place locally immediately, and a PersonaStateChange_t is posted, presuming success.
	//
	// The final results are available through the return value SteamAPICall_t, using SetPersonaNameResponse_t.
	//
	// If the name change fails to happen on the server, then an additional global PersonaStateChange_t will be posted
	// to change the name back, in addition to the SetPersonaNameResponse_t callback.
	virtual void SetPersonaName(const char* pchPersonaName) = 0;

	// gets the status of the current user
	virtual void GetPersonaState() = 0;

	// friend iteration
	// takes a set of k_EFriendFlags, and returns the number of users the client knows about who meet that criteria
	// then GetFriendByIndex() can then be used to return the id's of each of those users
	virtual int GetFriendCount(int iFriendFlags) = 0;

	// returns the steamID of a user
	// iFriend is a index of range [0, GetFriendCount())
	// iFriendsFlags must be the same value as used in GetFriendCount()
	// the returned CSteamID can then be used by all the functions below to access details about the user
	virtual CSteamID GetFriendByIndex(int iFriend, int iFriendFlags) = 0;

	// returns a relationship to a user
	virtual void GetFriendRelationship(CSteamID steamIDFriend) = 0;

	// returns the current status of the specified user
	// this will only be known by the local user if steamIDFriend is in their friends list; on the same game server; in a chat room or lobby; or in a small group with the local user
	virtual void GetFriendPersonaState(CSteamID steamIDFriend) = 0;

	// returns the name another user - guaranteed to not be NULL.
	// same rules as GetFriendPersonaState() apply as to whether or not the user knowns the name of the other user
	// note that on first joining a lobby, chat room or game server the local user will not known the name of the other users automatically; that information will arrive asyncronously
	// 
	virtual const char* GetFriendPersonaName(CSteamID steamIDFriend) = 0;

	// returns true if the friend is actually in a game, and fills in pFriendGameInfo with an extra details 
	virtual bool GetFriendGamePlayed(CSteamID steamIDFriend, void* pFriendGameInfo) = 0;
	// accesses old friends names - returns an empty string when their are no more items in the history
	virtual const char* GetFriendPersonaNameHistory(CSteamID steamIDFriend, int iPersonaName) = 0;
	// friends steam level
	virtual int GetFriendSteamLevel(CSteamID steamIDFriend) = 0;

	// Returns nickname the current user has set for the specified player. Returns NULL if the no nickname has been set for that player.
	virtual const char* GetPlayerNickname(CSteamID steamIDPlayer) = 0;

	// friend grouping (tag) apis
	// returns the number of friends groups
	virtual int GetFriendsGroupCount() = 0;
	// returns the friends group ID for the given index (invalid indices return k_FriendsGroupID_Invalid)
	virtual void GetFriendsGroupIDByIndex(int iFG) = 0;
	// returns the name for the given friends group (NULL in the case of invalid friends group IDs)
	virtual const char* GetFriendsGroupName(int friendsGroupID) = 0;
	// returns the number of members in a given friends group
	virtual int GetFriendsGroupMembersCount(int friendsGroupID) = 0;
	// gets up to nMembersCount members of the given friends group, if fewer exist than requested those positions' SteamIDs will be invalid
	virtual void GetFriendsGroupMembersList(int friendsGroupID, int nMembersCount) = 0;

	// returns true if the specified user meets any of the criteria specified in iFriendFlags
	// iFriendFlags can be the union (binary or, |) of one or more k_EFriendFlags values
	virtual bool HasFriend(CSteamID steamIDFriend, int iFriendFlags) = 0;

	// clan (group) iteration and access functions
	virtual int GetClanCount() = 0;
	virtual CSteamID GetClanByIndex(int iClan) = 0;
	virtual const char* GetClanName(CSteamID steamIDClan) = 0;
	virtual const char* GetClanTag(CSteamID steamIDClan) = 0;
	// returns the most recent information we have about what's happening in a clan
	virtual bool GetClanActivityCounts(CSteamID steamIDClan, int* pnOnline, int* pnInGame, int* pnChatting) = 0;
	// for clans a user is a member of, they will have reasonably up-to-date information, but for others you'll have to download the info to have the latest
	virtual SteamAPICall_t DownloadClanActivityCounts(int cClansToRequest) = 0;

	// iterators for getting users in a chat room, lobby, game server or clan
	// note that large clans that cannot be iterated by the local user
	// note that the current user must be in a lobby to retrieve CSteamIDs of other users in that lobby
	// steamIDSource can be the steamID of a group, game server, lobby or chat room
	virtual int GetFriendCountFromSource(CSteamID steamIDSource) = 0;
	virtual CSteamID GetFriendFromSourceByIndex(CSteamID steamIDSource, int iFriend) = 0;

	// returns true if the local user can see that steamIDUser is a member or in steamIDSource
	virtual bool IsUserInSource(CSteamID steamIDUser, CSteamID steamIDSource) = 0;

	// User is in a game pressing the talk button (will suppress the microphone for all voice comms from the Steam friends UI)
	virtual void SetInGameVoiceSpeaking(CSteamID steamIDUser, bool bSpeaking) = 0;

	// activates the game overlay, with an optional dialog to open 
	// valid options are "Friends", "Community", "Players", "Settings", "OfficialGameGroup", "Stats", "Achievements"
	virtual void ActivateGameOverlay(const char* pchDialog) = 0;

	// activates game overlay to a specific place
	// valid options are
	//		"steamid" - opens the overlay web browser to the specified user or groups profile
	//		"chat" - opens a chat window to the specified user, or joins the group chat 
	//		"jointrade" - opens a window to a Steam Trading session that was started with the ISteamEconomy/StartTrade Web API
	//		"stats" - opens the overlay web browser to the specified user's stats
	//		"achievements" - opens the overlay web browser to the specified user's achievements
	//		"friendadd" - opens the overlay in minimal mode prompting the user to add the target user as a friend
	//		"friendremove" - opens the overlay in minimal mode prompting the user to remove the target friend
	//		"friendrequestaccept" - opens the overlay in minimal mode prompting the user to accept an incoming friend invite
	//		"friendrequestignore" - opens the overlay in minimal mode prompting the user to ignore an incoming friend invite
	virtual void ActivateGameOverlayToUser(const char* pchDialog, CSteamID steamID) = 0;

	// activates game overlay web browser directly to the specified URL
	// full address with protocol type is required, e.g. http://www.steamgames.com/
	virtual void ActivateGameOverlayToWebPage(const char* pchURL) = 0;

	// activates game overlay to store page for app
	virtual void ActivateGameOverlayToStore(int nAppID, int eFlag) = 0;

	// Mark a target user as 'played with'. This is a client-side only feature that requires that the calling user is 
	// in game 
	virtual void SetPlayedWith(CSteamID steamIDUserPlayedWith) = 0;

	// activates game overlay to open the invite dialog. Invitations will be sent for the provided lobby.
	virtual void ActivateGameOverlayInviteDialog(CSteamID steamIDLobby) = 0;

	// gets the small (32x32) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set
	virtual int GetSmallFriendAvatar(CSteamID steamIDFriend) = 0;

	// gets the medium (64x64) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set
	virtual int GetMediumFriendAvatar(CSteamID steamIDFriend) = 0;

	// gets the large (184x184) avatar of the current user, which is a handle to be used in IClientUtils::GetImageRGBA(), or 0 if none set
	// returns -1 if this image has yet to be loaded, in this case wait for a AvatarImageLoaded_t callback and then call this again
	virtual int GetLargeFriendAvatar(CSteamID steamIDFriend) = 0;

	// requests information about a user - persona name & avatar
	// if bRequireNameOnly is set, then the avatar of a user isn't downloaded 
	// - it's a lot slower to download avatars and churns the local cache, so if you don't need avatars, don't request them
	// if returns true, it means that data is being requested, and a PersonaStateChanged_t callback will be posted when it's retrieved
	// if returns false, it means that we already have all the details about that user, and functions can be called immediately
	virtual bool RequestUserInformation(CSteamID steamIDUser, bool bRequireNameOnly) = 0;

	// requests information about a clan officer list
	// when complete, data is returned in ClanOfficerListResponse_t call result
	// this makes available the calls below
	// you can only ask about clans that a user is a member of
	// note that this won't download avatars automatically; if you get an officer,
	// and no avatar image is available, call RequestUserInformation( steamID, false ) to download the avatar
	virtual void RequestClanOfficerList(CSteamID steamIDClan) = 0;

	// iteration of clan officers - can only be done when a RequestClanOfficerList() call has completed

	// returns the steamID of the clan owner
	virtual CSteamID GetClanOwner(CSteamID steamIDClan) = 0;
	// returns the number of officers in a clan (including the owner)
	virtual int GetClanOfficerCount(CSteamID steamIDClan) = 0;
	// returns the steamID of a clan officer, by index, of range [0,GetClanOfficerCount)
	virtual CSteamID GetClanOfficerByIndex(CSteamID steamIDClan, int iOfficer) = 0;
	// if current user is chat restricted, he can't send or receive any text/voice chat messages.
	// the user can't see custom avatars. But the user can be online and send/recv game invites.
	// a chat restricted user can't add friends or join any groups.
	virtual int GetUserRestrictions() = 0;

	// Rich Presence data is automatically shared between friends who are in the same game
	// Each user has a set of Key/Value pairs
	// Up to 20 different keys can be set
	// There are two magic keys:
	//		"status"  - a UTF-8 string that will show up in the 'view game info' dialog in the Steam friends list
	//		"connect" - a UTF-8 string that contains the command-line for how a friend can connect to a game
	// GetFriendRichPresence() returns an empty string "" if no value is set
	// SetRichPresence() to a NULL or an empty string deletes the key
	// You can iterate the current set of keys for a friend with GetFriendRichPresenceKeyCount()
	// and GetFriendRichPresenceKeyByIndex() (typically only used for debugging)
	virtual bool SetRichPresence(const char* pchKey, const char* pchValue) = 0;
	virtual void ClearRichPresence() = 0;
	virtual const char* GetFriendRichPresence(CSteamID steamIDFriend, const char* pchKey) = 0;
	virtual int GetFriendRichPresenceKeyCount(CSteamID steamIDFriend) = 0;
	virtual const char* GetFriendRichPresenceKeyByIndex(CSteamID steamIDFriend, int iKey) = 0;
	// Requests rich presence for a specific user.
	virtual void RequestFriendRichPresence(CSteamID steamIDFriend) = 0;

	// rich invite support
	// if the target accepts the invite, the pchConnectString gets added to the command-line for launching the game
	// if the game is already running, a GameRichPresenceJoinRequested_t callback is posted containing the connect string
	// invites can only be sent to friends
	virtual bool InviteUserToGame(CSteamID steamIDFriend, const char* pchConnectString) = 0;

	// recently-played-with friends iteration
	// this iterates the entire list of users recently played with, across games
	// GetFriendCoplayTime() returns as a unix time
	virtual int GetCoplayFriendCount() = 0;
	virtual CSteamID GetCoplayFriend(int iCoplayFriend) = 0;
	virtual int GetFriendCoplayTime(CSteamID steamIDFriend) = 0;
	virtual void GetFriendCoplayGame(CSteamID steamIDFriend) = 0;

	// chat interface for games
	// this allows in-game access to group (clan) chats from in the game
	// the behavior is somewhat sophisticated, because the user may or may not be already in the group chat from outside the game or in the overlay
	// use ActivateGameOverlayToUser( "chat", steamIDClan ) to open the in-game overlay version of the chat
	virtual SteamAPICall_t JoinClanChatRoom(CSteamID steamIDClan) = 0;
	virtual bool LeaveClanChatRoom(CSteamID steamIDClan) = 0;
	virtual int GetClanChatMemberCount(CSteamID steamIDClan) = 0;
	virtual CSteamID GetChatMemberByIndex(CSteamID steamIDClan, int iUser) = 0;
	virtual bool SendClanChatMessage(CSteamID steamIDClanChat, const char* pchText) = 0;
	virtual int GetClanChatMessage(CSteamID steamIDClanChat, int iMessage, void* prgchText, int cchTextMax, void* peChatEntryType, CSteamID* psteamidChatter) = 0;
	virtual bool IsClanChatAdmin(CSteamID steamIDClanChat, CSteamID steamIDUser) = 0;

	// interact with the Steam (game overlay / desktop)
	virtual bool IsClanChatWindowOpenInSteam(CSteamID steamIDClanChat) = 0;
	virtual bool OpenClanChatWindowInSteam(CSteamID steamIDClanChat) = 0;
	virtual bool CloseClanChatWindowInSteam(CSteamID steamIDClanChat) = 0;

	// peer-to-peer chat interception
	// this is so you can show P2P chats inline in the game
	virtual bool SetListenForFriendsMessages(bool bInterceptEnabled) = 0;
	virtual bool ReplyToFriendMessage(CSteamID steamIDFriend, const char* pchMsgToSend) = 0;
	virtual int GetFriendMessage(CSteamID steamIDFriend, int iMessageID, void* pvData, int cubData, void* peChatEntryType) = 0;

	// following apis
		virtual SteamAPICall_t GetFollowerCount(CSteamID steamID) = 0;
		virtual SteamAPICall_t IsFollowing(CSteamID steamID) = 0;
		virtual SteamAPICall_t EnumerateFollowingList(int unStartIndex) = 0;
};

class ISteamUtils
{
public:
	// return the number of seconds since the user 
	virtual unsigned int GetSecondsSinceAppActive() = 0;
	virtual unsigned int GetSecondsSinceComputerActive() = 0;

	// the universe this client is connecting to
	virtual void* GetConnectedUniverse() = 0;

	// Steam server time - in PST, number of seconds since January 1, 1970 (i.e unix time)
	virtual unsigned int GetServerRealTime() = 0;

	// returns the 2 digit ISO 3166-1-alpha-2 format country code this client is running in (as looked up via an IP-to-location database)
	// e.g "US" or "UK".
	virtual const char* GetIPCountry() = 0;

	// returns true if the image exists, and valid sizes were filled out
	virtual bool GetImageSize(int iImage, unsigned int* pnWidth, unsigned int* pnHeight) = 0;

	// returns true if the image exists, and the buffer was successfully filled out
	// results are returned in RGBA format
	// the destination buffer size should be 4 * height * width * sizeof(char)
	virtual bool GetImageRGBA(int iImage, unsigned int* pubDest, int nDestBufferSize) = 0;

	// returns the IP of the reporting server for valve - currently only used in Source engine games
	virtual bool GetCSERIPPort(unsigned int* unIP, unsigned short* usPort) = 0;

	// return the amount of battery power left in the current system in % [0..100], 255 for being on AC power
	virtual unsigned char GetCurrentBatteryPower() = 0;

	// returns the appID of the current process
	virtual unsigned int GetAppID() = 0;

	// Sets the position where the overlay instance for the currently calling game should show notifications.
	// This position is per-game and if this function is called from outside of a game context it will do nothing.
	virtual void SetOverlayNotificationPosition(void* eNotificationPosition) = 0;

	// API asynchronous call results
	// can be used directly, but more commonly used via the callback dispatch API (see steam_api.h)
	virtual bool IsAPICallCompleted(SteamAPICall_t hSteamAPICall, bool* pbFailed) = 0;
	virtual void* GetAPICallFailureReason(SteamAPICall_t hSteamAPICall) = 0;
	virtual bool GetAPICallResult(SteamAPICall_t hSteamAPICall, void* pCallback, int cubCallback, int iCallbackExpected, bool* pbFailed) = 0;

	// Deprecated. Applications should use SteamAPI_RunCallbacks() instead. Game servers do not need to call this function.
	//virtual void RunFrame() = 0;

	// returns the number of IPC calls made since the last time this function was called
	// Used for perf debugging so you can understand how many IPC calls your game makes per frame
	// Every IPC call is at minimum a thread context switch if not a process one so you want to rate
	// control how often you do them.
	virtual unsigned int GetIPCCallCount() = 0;

	// API warning handling
	// 'int' is the severity; 0 for msg, 1 for warning
	// 'const char *' is the text of the message
	// callbacks will occur directly after the API function is called that generated the warning or message
	virtual void SetWarningMessageHook(void* pFunction) = 0;

	// Returns true if the overlay is running & the user can access it. The overlay process could take a few seconds to
	// start & hook the game process, so this function will initially return false while the overlay is loading.
	virtual bool IsOverlayEnabled() = 0;

	// Normally this call is unneeded if your game has a constantly running frame loop that calls the 
	// D3D Present API, or OGL SwapBuffers API every frame.
	//
	// However, if you have a game that only refreshes the screen on an event driven basis then that can break 
	// the overlay, as it uses your Present/SwapBuffers calls to drive it's internal frame loop and it may also
	// need to Present() to the screen any time an even needing a notification happens or when the overlay is
	// brought up over the game by a user.  You can use this API to ask the overlay if it currently need a present
	// in that case, and then you can check for this periodically (roughly 33hz is desirable) and make sure you
	// refresh the screen with Present or SwapBuffers to allow the overlay to do it's work.
	virtual bool BOverlayNeedsPresent() = 0;

	// Asynchronous call to check if an executable file has been signed using the public key set on the signing tab
	// of the partner site, for example to refuse to load modified executable files.  
	// The result is returned in CheckFileSignature_t.
	//   k_ECheckFileSignatureNoSignaturesFoundForThisApp - This app has not been configured on the signing tab of the partner site to enable this function.
	//   k_ECheckFileSignatureNoSignaturesFoundForThisFile - This file is not listed on the signing tab for the partner site.
	//   k_ECheckFileSignatureFileNotFound - The file does not exist on disk.
	//   k_ECheckFileSignatureInvalidSignature - The file exists, and the signing tab has been set for this file, but the file is either not signed or the signature does not match.
	//   k_ECheckFileSignatureValidSignature - The file is signed and the signature is valid.
	virtual SteamAPICall_t CheckFileSignature(const char* szFileName) = 0;

	// Activates the Big Picture text input dialog which only supports gamepad input
	virtual bool ShowGamepadTextInput(void* eInputMode, void* eLineInputMode, const char* pchDescription, unsigned int unCharMax, const char* pchExistingText) = 0;

	// Returns previously entered text & length
	virtual unsigned int GetEnteredGamepadTextLength() = 0;
	virtual bool GetEnteredGamepadTextInput(char* pchText, unsigned int cchText) = 0;

	// returns the language the steam client is running in, you probably want ISteamApps::GetCurrentGameLanguage instead, this is for very special usage cases
	virtual const char* GetSteamUILanguage() = 0;

	// returns true if Steam itself is running in VR mode
	virtual bool IsSteamRunningInVR() = 0;

	// Sets the inset of the overlay notification from the corner specified by SetOverlayNotificationPosition.
	virtual void SetOverlayNotificationInset(int nHorizontalInset, int nVerticalInset) = 0;

	// returns true if Steam & the Steam Overlay are running in Big Picture mode
	// Games much be launched through the Steam client to enable the Big Picture overlay. During development,
	// a game can be added as a non-steam game to the developers library to test this feature
	virtual bool IsSteamInBigPictureMode() = 0;

	// ask SteamUI to create and render its OpenVR dashboard
	virtual void StartVRDashboard() = 0;
};

class ISteamUserStats
{
public:
	// Ask the server to send down this user's data and achievements for this game
	virtual bool RequestCurrentStats() = 0;

	// Data accessors
	virtual bool GetStat(const char* pchName, int* pData) = 0;

	virtual bool GetStat(const char* pchName, float* pData) = 0;

	// Set / update data
	virtual bool SetStat(const char* pchName, int nData) = 0;

	virtual bool SetStat(const char* pchName, float fData) = 0;

	virtual bool UpdateAvgRateStat(const char* pchName, float flCountThisSession, double dSessionLength) = 0;

	// Achievement flag accessors
	virtual bool GetAchievement(const char* pchName, bool* pbAchieved) = 0;
	virtual bool SetAchievement(const char* pchName) = 0;
	virtual bool ClearAchievement(const char* pchName) = 0;

	// Get the achievement status, and the time it was unlocked if unlocked.
	// If the return value is true, but the unlock time is zero, that means it was unlocked before Steam 
	// began tracking achievement unlock times (December 2009). Time is seconds since January 1, 1970.
	virtual bool GetAchievementAndUnlockTime(const char* pchName, bool* pbAchieved, uint32_t* punUnlockTime) = 0;

	// Store the current data on the server, will get a callback when set
	// And one callback for every new achievement
	//
	// If the callback has a result of k_EResultInvalidParam, one or more stats 
	// uploaded has been rejected, either because they broke constraints
	// or were out of date. In this case the server sends back updated values.
	// The stats should be re-iterated to keep in sync.
	virtual bool StoreStats() = 0;

	// Achievement / GroupAchievement metadata

	// Gets the icon of the achievement, which is a handle to be used in ISteamUtils::GetImageRGBA(), or 0 if none set. 
	// A return value of 0 may indicate we are still fetching data, and you can wait for the UserAchievementIconFetched_t callback
	// which will notify you when the bits are ready. If the callback still returns zero, then there is no image set for the
	// specified achievement.
	virtual int GetAchievementIcon(const char* pchName) = 0;

	// Get general attributes for an achievement. Accepts the following keys:
	// - "name" and "desc" for retrieving the localized achievement name and description (returned in UTF8)
	// - "hidden" for retrieving if an achievement is hidden (returns "0" when not hidden, "1" when hidden)
	virtual const char* GetAchievementDisplayAttribute(const char* pchName, const char* pchKey) = 0;

	// Achievement progress - triggers an AchievementProgress callback, that is all.
	// Calling this w/ N out of N progress will NOT set the achievement, the game must still do that.
	virtual bool IndicateAchievementProgress(const char* pchName, uint32_t nCurProgress, uint32_t nMaxProgress) = 0;

	// Used for iterating achievements. In general games should not need these functions because they should have a
	// list of existing achievements compiled into them
	virtual uint32_t GetNumAchievements() = 0;
	// Get achievement name iAchievement in [0,GetNumAchievements)
	virtual const char* GetAchievementName(uint32_t iAchievement) = 0;

	// Friends stats & achievements

	// downloads stats for the user
	// returns a UserStatsReceived_t received when completed
	// if the other user has no stats, UserStatsReceived_t.m_eResult will be set to k_EResultFail
	// these stats won't be auto-updated; you'll need to call RequestUserStats() again to refresh any data
	virtual SteamAPICall_t RequestUserStats(CSteamID steamIDUser) = 0;

	// requests stat information for a user, usable after a successful call to RequestUserStats()
	virtual bool GetUserStat(CSteamID steamIDUser, const char* pchName, int* pData) = 0;

	virtual bool GetUserStat(CSteamID steamIDUser, const char* pchName, float* pData) = 0;

	virtual bool GetUserAchievement(CSteamID steamIDUser, const char* pchName, bool* pbAchieved) = 0;
	// See notes for GetAchievementAndUnlockTime above
	virtual bool GetUserAchievementAndUnlockTime(CSteamID steamIDUser, const char* pchName, bool* pbAchieved, uint32_t* punUnlockTime) = 0;

	// Reset stats 
	virtual bool ResetAllStats(bool bAchievementsToo) = 0;

	// Leaderboard functions

	// asks the Steam back-end for a leaderboard by name, and will create it if it's not yet
	// This call is asynchronous, with the result returned in LeaderboardFindResult_t
	virtual SteamAPICall_t FindOrCreateLeaderboard(const char* pchLeaderboardName, ELeaderboardSortMethod eLeaderboardSortMethod, ELeaderboardDisplayType eLeaderboardDisplayType) = 0;

	// as above, but won't create the leaderboard if it's not found
	// This call is asynchronous, with the result returned in LeaderboardFindResult_t
	virtual SteamAPICall_t FindLeaderboard(const char* pchLeaderboardName) = 0;

	// returns the name of a leaderboard
	virtual const char* GetLeaderboardName(SteamLeaderboard_t hSteamLeaderboard) = 0;

	// returns the total number of entries in a leaderboard, as of the last request
	virtual int GetLeaderboardEntryCount(SteamLeaderboard_t hSteamLeaderboard) = 0;

	// returns the sort method of the leaderboard
	virtual ELeaderboardSortMethod GetLeaderboardSortMethod(SteamLeaderboard_t hSteamLeaderboard) = 0;

	// returns the display type of the leaderboard
	virtual ELeaderboardDisplayType GetLeaderboardDisplayType(SteamLeaderboard_t hSteamLeaderboard) = 0;

	// Asks the Steam back-end for a set of rows in the leaderboard.
	// This call is asynchronous, with the result returned in LeaderboardScoresDownloaded_t
	// LeaderboardScoresDownloaded_t will contain a handle to pull the results from GetDownloadedLeaderboardEntries() (below)
	// You can ask for more entries than exist, and it will return as many as do exist.
	// k_ELeaderboardDataRequestGlobal requests rows in the leaderboard from the full table, with nRangeStart & nRangeEnd in the range [1, TotalEntries]
	// k_ELeaderboardDataRequestGlobalAroundUser requests rows around the current user, nRangeStart being negate
	//   e.g. DownloadLeaderboardEntries( hLeaderboard, k_ELeaderboardDataRequestGlobalAroundUser, -3, 3 ) will return 7 rows, 3 before the user, 3 after
	// k_ELeaderboardDataRequestFriends requests all the rows for friends of the current user 
	virtual SteamAPICall_t DownloadLeaderboardEntries(SteamLeaderboard_t hSteamLeaderboard, ELeaderboardDataRequest eLeaderboardDataRequest, int nRangeStart, int nRangeEnd) = 0;

	// as above, but downloads leaderboard entries for an arbitrary set of users - ELeaderboardDataRequest is k_ELeaderboardDataRequestUsers
	// if a user doesn't have a leaderboard entry, they won't be included in the result
	// a max of 100 users can be downloaded at a time, with only one outstanding call at a time
	virtual SteamAPICall_t DownloadLeaderboardEntriesForUsers(SteamLeaderboard_t hSteamLeaderboard, CSteamID* prgUsers, int cUsers) = 0;

	// Returns data about a single leaderboard entry
	// use a for loop from 0 to LeaderboardScoresDownloaded_t::m_cEntryCount to get all the downloaded entries
	// e.g.
	//		void OnLeaderboardScoresDownloaded( LeaderboardScoresDownloaded_t *pLeaderboardScoresDownloaded )
	//		{
	//			for ( int index = 0; index < pLeaderboardScoresDownloaded->m_cEntryCount; index++ )
	//			{
	//				LeaderboardEntry_t leaderboardEntry;
	//				int32 details[3];		// we know this is how many we've stored previously
	//				GetDownloadedLeaderboardEntry( pLeaderboardScoresDownloaded->m_hSteamLeaderboardEntries, index, &leaderboardEntry, details, 3 );
	//				assert( leaderboardEntry.m_cDetails == 3 );
	//				...
	//			}
	// once you've accessed all the entries, the data will be free'd, and the SteamLeaderboardEntries_t handle will become invalid
	virtual bool GetDownloadedLeaderboardEntry(SteamLeaderboardEntries_t hSteamLeaderboardEntries, int index, LeaderboardEntry_t* pLeaderboardEntry, int* pDetails, int cDetailsMax) = 0;

	// Uploads a user score to the Steam back-end.
	// This call is asynchronous, with the result returned in LeaderboardScoreUploaded_t
	// Details are extra game-defined information regarding how the user got that score
	// pScoreDetails points to an array of int32's, cScoreDetailsCount is the number of int32's in the list
	virtual SteamAPICall_t UploadLeaderboardScore(SteamLeaderboard_t hSteamLeaderboard, ELeaderboardUploadScoreMethod eLeaderboardUploadScoreMethod, int nScore, const int* pScoreDetails, int cScoreDetailsCount) = 0;

	// Attaches a piece of user generated content the user's entry on a leaderboard.
	// hContent is a handle to a piece of user generated content that was shared using ISteamUserRemoteStorage::FileShare().
	// This call is asynchronous, with the result returned in LeaderboardUGCSet_t.
	virtual SteamAPICall_t AttachLeaderboardUGC(SteamLeaderboard_t hSteamLeaderboard, UGCHandle_t hUGC) = 0;

	// Retrieves the number of players currently playing your game (online + offline)
	// This call is asynchronous, with the result returned in NumberOfCurrentPlayers_t
	virtual SteamAPICall_t GetNumberOfCurrentPlayers() = 0;

	// Requests that Steam fetch data on the percentage of players who have received each achievement
	// for the game globally.
	// This call is asynchronous, with the result returned in GlobalAchievementPercentagesReady_t.
	virtual SteamAPICall_t RequestGlobalAchievementPercentages() = 0;

	// Get the info on the most achieved achievement for the game, returns an iterator index you can use to fetch
	// the next most achieved afterwards.  Will return -1 if there is no data on achievement 
	// percentages (ie, you haven't called RequestGlobalAchievementPercentages and waited on the callback).
	virtual int GetMostAchievedAchievementInfo(char* pchName, uint32_t unNameBufLen, float* pflPercent, bool* pbAchieved) = 0;

	// Get the info on the next most achieved achievement for the game. Call this after GetMostAchievedAchievementInfo or another
	// GetNextMostAchievedAchievementInfo call passing the iterator from the previous call. Returns -1 after the last
	// achievement has been iterated.
	virtual int GetNextMostAchievedAchievementInfo(int iIteratorPrevious, char* pchName, uint32_t unNameBufLen, float* pflPercent, bool* pbAchieved) = 0;

	// Returns the percentage of users who have achieved the specified achievement.
	virtual bool GetAchievementAchievedPercent(const char* pchName, float* pflPercent) = 0;

	// Requests global stats data, which is available for stats marked as "aggregated".
	// This call is asynchronous, with the results returned in GlobalStatsReceived_t.
	// nHistoryDays specifies how many days of day-by-day history to retrieve in addition
	// to the overall totals. The limit is 60.
	virtual SteamAPICall_t RequestGlobalStats(int nHistoryDays) = 0;

	// Gets the lifetime totals for an aggregated stat
	virtual bool GetGlobalStat(const char* pchStatName, int64_t* pData) = 0;

	virtual bool GetGlobalStat(const char* pchStatName, double* pData) = 0;

	// Gets history for an aggregated stat. pData will be filled with daily values, starting with today.
	// So when called, pData[0] will be today, pData[1] will be yesterday, and pData[2] will be two days ago, 
	// etc. cubData is the size in bytes of the pubData buffer. Returns the number of 
	// elements actually set.

	virtual int GetGlobalStatHistory(const char* pchStatName, int64_t* pData, uint32_t cubData) = 0;

	virtual int GetGlobalStatHistory(const char* pchStatName, double* pData, uint32_t cubData) = 0;

	// For achievements that have related Progress stats, use this to query what the bounds of that progress are.
	// You may want this info to selectively call IndicateAchievementProgress when appropriate milestones of progress
	// have been made, to show a progress notification to the user.
	virtual bool GetAchievementProgressLimits(const char* pchName, int* pnMinProgress, int* pnMaxProgress) = 0;

	virtual bool GetAchievementProgressLimits(const char* pchName, float* pfMinProgress, float* pfMaxProgress) = 0;
};


class ISteamClient
{
public:
	ISteamUser* GetISteamUser(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		typedef ISteamUser* (__stdcall * func)(HSteamUser, HSteamPipe, const char*);
		return CallVFunction<func>(this, 5)(hSteamUser, hSteamPipe, pchVersion);
	}

	ISteamFriends* GetISteamFriends(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		typedef ISteamFriends* (__stdcall * func)(HSteamUser, HSteamPipe, const char*);
		return CallVFunction<func>(this, 8)(hSteamUser, hSteamPipe, pchVersion);
	}

	ISteamUtils* GetISteamUtils(HSteamPipe hSteamPipe, const char* pchVersion)
	{
		typedef ISteamUtils* (__stdcall* func)(HSteamPipe, const char*);
		return CallVFunction<func>(this, 9)(hSteamPipe, pchVersion);
	}

	ISteamGameCoordinator* GetISteamGenericInterface(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		typedef ISteamGameCoordinator* (__stdcall * func)(HSteamUser, HSteamPipe, const char*);
		return CallVFunction<func>(this, 12)(hSteamUser, hSteamPipe, pchVersion);
	}

	ISteamUserStats* GetISteamUserStats(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		typedef ISteamUserStats*(__stdcall* func)(HSteamUser, HSteamPipe, const char*);
		return CallVFunction<func>(this, 13)(hSteamUser, hSteamPipe, pchVersion);
	}

	ISteamHTTP* GetISteamHTTP(HSteamUser hSteamUser, HSteamPipe hSteamPipe, const char* pchVersion)
	{
		typedef ISteamHTTP* (__stdcall * func)(HSteamUser, HSteamPipe, const char*);
		return CallVFunction<func>(this, 23)(hSteamUser, hSteamPipe, pchVersion);
	}
};
```