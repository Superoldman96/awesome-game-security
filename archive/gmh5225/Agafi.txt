Project Path: arc_gmh5225_Agafi_5sygcnhw

Source Tree:

```txt
arc_gmh5225_Agafi_5sygcnhw
├── README.md
├── agafi-rop.png
├── agafi.png
└── src
    ├── agafi-rop.cpp
    ├── agafi.cpp
    ├── disassembler.c
    ├── fsnap.c
    ├── gisnap
    │   ├── dumpinfo
    │   │   ├── dumpinfo.py
    │   │   └── readme.txt
    │   ├── ollydbg_plugin
    │   │   ├── readme.txt
    │   │   └── src
    │   │       ├── MemorySnapshot.cpp
    │   │       ├── MemorySnapshot.h
    │   │       ├── gisnap.cpp
    │   │       ├── gisnap.sln
    │   │       ├── gisnap.v11.suo
    │   │       ├── gisnap.vcproj
    │   │       ├── gisnap.vcxproj
    │   │       ├── ollydbg.lib
    │   │       ├── plugin.h
    │   │       └── snapshotformat.h
    │   ├── standalone
    │   │   └── src
    │   │       ├── LogWindow.cpp
    │   │       ├── LogWindow.h
    │   │       ├── MemorySnapshot.cpp
    │   │       ├── MemorySnapshot.h
    │   │       ├── ProcessList.cpp
    │   │       ├── ProcessList.h
    │   │       ├── gisnap.cpp
    │   │       ├── gisnap.h
    │   │       ├── gisnap.rc
    │   │       ├── resource.h
    │   │       ├── resource1.h
    │   │       ├── snapshotformat.h
    │   │       ├── stand-alone.rc
    │   │       ├── stand-alone.sln
    │   │       ├── stand-alone.suo
    │   │       ├── stand-alone.v11.suo
    │   │       ├── stand-alone.vcxproj
    │   │       ├── stand-alone.vcxproj.filters
    │   │       ├── stand-alone.vcxproj.user
    │   │       ├── stdafx.cpp
    │   │       └── stdafx.h
    │   └── windbg_ext
    │       ├── readme.txt
    │       └── src
    │           ├── dllmain.cpp
    │           ├── gisnap.cpp
    │           ├── gisnap.h
    │           ├── snapshotformat.h
    │           ├── stdafx.cpp
    │           ├── stdafx.h
    │           ├── targetver.h
    │           ├── windbg_ext.cpp
    │           ├── windbg_ext.def
    │           ├── windbg_ext.opensdf
    │           ├── windbg_ext.sln
    │           ├── windbg_ext.v11.suo
    │           ├── windbg_ext.vcxproj
    │           ├── windbg_ext.vcxproj.filters
    │           └── windbg_ext.vcxproj.user
    ├── list.cpp
    ├── make.bat
    └── qemu.c

```

`README.md`:

```md
##What is Agafi/ROP?

Agafi/ROP is a Win32 command line tool chain useful to find gadgets and build ROP-Chains used by x86 binary exploits.

##What is Agafi?

Agafi (Advanced Gadget Finder) is a x86 gadget-finder tool useful to find gadgets in programs, modules and running processes.

The ROP search engine is based on 4 points:
 1. Search by objective
 2. An "executable/module/process/misc" snapshot
 3. x86 code emulation (QEMU support)
 4. Black box gadget analysis

Implementing the ideas mentioned above, Agafi is able to find very complex gadgets in short time.

Agafi in action ...

![Agafi in action ...](https://github.com/CoreSecurity/Agafi/blob/master/agafi.png)

##What is Agafi-rop?

Agafi-ROP is a x86 ROP-Chainer tool oriented to build ROP chains for win32 programs, modules and running processes.

Using Agafi as gadget-finder + Agafi-ROP as good and fast ROP-Chainer engine, this tool is able to build ROP-Chains to bypass DEP in binary exploits.

Agafi-ROP re-building a ROP-Chain with "invalid chars" to "hxds.dll" v2.5.50727.198 ...

![Agafi in action ...](https://github.com/CoreSecurity/Agafi/blob/master/agafi-rop.png)

##Where can Agafi find gadgets?

Mainly Win32 binary files although other x86 architectures are also supported as RAW snapshots.


##What APi uses Agafi-ROP to build ROP-Chains to bypass DEP?

For now, only "kernel32.VirtualProtect" function is used.


##In which Windows versions does Agafi/ROP work?

Starting from Windows XP SP2 up to the latest Windows version.


##Is it necessary to install Agafi/ROP to use?

No instalation needed.


##Dependencies

The only external dependency is the x86 disassembly lib (Distorm v3).
Please, download this from (https://code.google.com/p/distorm/downloads/detail?name=distorm3-3-dlls.zip) and copy the 32 bit "distorm3.dll" library at the same Agafi path.


##Licensing

Agafi/ROP is released under version 3 of the GNU General Public License.


##Contact

If you have some suggestion or some bug to report, please contact to the authors.

Agafi/Agafi-ROP (neconomou@coresecurity.com)
Gisnap modules (djuarez@coresecurity.com)

```

`src/agafi-rop.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////

/* Agafi-ROP ( A ROP-Chainer tool for Win32 platforms ) */

// Compilation line
// cl.exe agafi-rop.cpp /link -SUBSYSTEM:CONSOLE

////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>

#include "list.cpp"

////////////////////////////////////////////////////////////////////////////////

#pragma pack(1)

#define VALID_REGISTERS 9

#define EAX_REGISTER    0
#define ECX_REGISTER    1
#define EDX_REGISTER    2
#define EBX_REGISTER    3
#define ESP_REGISTER    4
#define EBP_REGISTER    5
#define ESI_REGISTER    6
#define EDI_REGISTER    7
#define EIP_REGISTER    8

#define RET_ENDING      0
#define RETN_ENDING     1
#define RETF_ENDING     2
#define IRET_ENDING     3
#define OTHER_ENDING    4

#define OP_REG_TO_REG         1
#define OP_REGS_TO_REG        2
#define OP_REG_TO_REGS        3
#define OP_REGS_TO_REGS       4
#define OP_MEM_TO_REG         5
#define OP_MEM_TO_REGS        6
#define OP_MEMS_TO_REG        7
#define OP_MEMS_TO_REGS       8
#define OP_VALUE_TO_REG       9
#define OP_RANGE_TO_REG       10
#define OP_REGS_RANGE_TO_REG  11
#define OP_REG_TO_MEM         12
#define OP_REGS_TO_MEM        13
#define OP_REG_TO_NOT_REG     20
#define OP_REG_TO_NEG_REG     21
#define OP_REG_INCREMENTOR    22
#define OP_MEM_TO_ALL_REGS    24

#define READABLE              1
#define WRITABLE              2
#define EXECUTABLE            4
#define RANDOMIZABLE          8

#define uint64_t unsigned __int64

#ifdef _MSC_VER
  #define snprintf _snprintf
#endif

////////////////////////////////////////////////////////////////////////////////

typedef struct
{
  void *address;
  unsigned int offset;
  int register_index;
  int operation;
  unsigned int operand;
  unsigned int offset_base;
  unsigned int offset_limit;
  int stack_pivoting;
  int negator;
  int negator_by_incrementation;
  int neg_operation;
  int ending_type;
  int stack_used;
  int stack_required;
  int ret_extra_consumption;
  int stack_padding;
  int multiple_asignations;
  int asignated_registers [ VALID_REGISTERS ];
  int preserved_registers [ VALID_REGISTERS ];
  unsigned int conditional_jumps;
  unsigned int score;
  int is_super_gadget;
  int is_special_gadget;
  List *addresses;
  List *instructions;
  List *gadgets;
  List *values_to_pop;
  List *comments;
} GADGET;

typedef struct
{
  int restorable;
  void *address;
  unsigned int size;
  int protection;
  char module_name [ 256 ];
  void *data;
} SECTION;

typedef struct
{
  unsigned int sig;           // signature: "snap" or 0x70616E73 in little endian
  unsigned int version;	      // if version == 1: use DUMPBLOCKV10 / version == 2 uses DUMPBLOCKV20 and so on.
  unsigned int flags;         //
  unsigned int blockcount;
} SNAPSHOT_HEADER;

typedef struct
{
  uint64_t BaseAddress;
  uint64_t RegionSize;
  unsigned int Protect;  // see memory protection constants
} DUMPBLOCKV10;

typedef struct
{
  uint64_t BaseAddress;
  uint64_t RegionSize;
  unsigned int Protect;  // see memory protection constants
  char name [256];
} DUMPBLOCKV20;

////////////////////////////////////////////////////////////////////////////////

char *registers [] = {"eax","ecx","edx","ebx","esp","ebp","esi","edi","eip"};

////////////////////////////////////////////////////////////////////////////////

void delete_new_line ( char *line )
{
  char *s;

/* Apunto al inicio del string */
  s = line;

/* Mientras haya caracteres */
  while ( *s != 0 )
  {
  /* Si es un "\r" o "\n" */
    if ( ( *s == '\r' ) || ( *s == '\n' ) )
    {
    /* Lo reemplazo por un CERO */
      *s = 0;
    }

  /* Avanzo en el string */
    s ++;
  }
}

////////////////////////////////////////////////////////////////////////////////

void compress_line ( char *line )
{
  char *s;

/* Apunto al inicio del string */
  s = line;

/* Mientras haya caracteres */
  while ( *s != 0 )
  {
  /* Si NO es un ESPACIO */
    if ( *s != ' ' )
    {
    /* Muevo los caracteres */
      *line = *s;

    /* Avanzo en el string */
      line ++;
      s ++;
    }
  /* Si es un ESPACIO */
    else
    {
    /* NO copio este caracter */
      s ++;
    }
  }

/* Cierro el string COMPRIMIDO */
  *line = 0;
}

////////////////////////////////////////////////////////////////////////////////

int get_register_index ( char *s )
{
  unsigned int cont;
  int ret = -1;

/* Recorro TODOS los REGISTROS VALIDOS */
  for ( cont = 0 ; cont < sizeof ( registers ) / sizeof ( char * ) ; cont ++ )
  {
  /* Si es el REGISTRO que estoy buscando */
    if ( strcmp ( s , registers [ cont ] ) == 0 )
    {
    /* Retorno el INDICE del registro */
      ret = cont;

    /* Dejo de buscar */
      break;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_register_plus_offset ( char *line , unsigned int *registro , unsigned int *offset )
{
  char buffer [256];
  char *s;
  int ret = TRUE;

/* Hago una copia de la linea */
  strncpy ( buffer , line , sizeof ( buffer ) );

/* Elimino lo extremos */
  strcpy ( buffer , buffer + 1 );
  buffer [ strlen ( buffer ) - 1 ] = 0;

/* Separo al string por el SIGNO (+) */
  s = strtok ( buffer , "+" );

/* Obtengo el REGISTRO */
  *registro = get_register_index ( s );

/* Obtengo el OFFSET */
  s = strtok ( NULL , "+" );
  sscanf ( s , "%x" , offset );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_register_asignations ( GADGET *gadget , char *line )
{
  List asignations;
  unsigned int rsrc;
  unsigned int rdst;
  unsigned int cont;
  char *asignation;
  char *s;
  char *t;
  int ret = TRUE;

/* Elimino TODOS los ESPACIOS */
  compress_line ( line );

/* Obtengo TODAS las asignaciones */
  while ( ( asignation = strtok ( line , "," ) ) != NULL )
  {
  /* Agrego la ASIGNACION a la lista */
    asignations.Add ( ( void * ) asignation );

  /* Para seguir con el MISMO string */
    line = NULL;
  }

/* Recorro TODAS las asignaciones */
  for ( cont = 0 ; cont < asignations.Len () ; cont ++ )
  {
  /* Levanto la siguiente ASIGNACION */
    asignation = ( char * ) asignations.Get ( cont );

  /* Obtengo el REGISTRO ASIGNADO */
    s = strtok ( asignation , "=" );

  /* Obtengo el REGISTRO ORIGEN */
    t = strtok ( NULL , "=" );

  /* Obtengo los REGISTROS INVOLUCRADOS */
    rdst = get_register_index ( s );
    rsrc = get_register_index ( t );

  /* Relaciono los SETEOS */
    gadget -> asignated_registers [ rdst ] = rsrc;

  /* Si es la PRIMERA ASIGNACION */
    if ( cont == 0 )
    {
    /* Seteo la ASIGNACION por DEFAULT */
      gadget -> register_index = rdst;
      gadget -> operand = rsrc;
    }
  /* Si HAY MAS de una ASIGNACION */
    else
    {
    /* Prendo el FLAG */
      gadget -> multiple_asignations = TRUE;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_operation_type ( char *line , GADGET *gadget )
{
  char *s;
  int ret = TRUE;

/* Si es un "PUSHAD/RET" */
  if ( strncmp ( line , "[esp+0x0]=" , 10 ) == 0 )
  {
  /* Obtengo el REGISTRO que queda en el TOPE del STACK */
    s = strtok ( &line [10] , "," );

  /* Seteo el REGISTRO USADO */
    gadget -> register_index = get_register_index ( s );

  /* Seteo el TIPO de OPERACION */
    gadget -> operation = OP_REG_TO_MEM;
  }
/* Si es un "POP REG32/RET" */
  else if ( strstr ( line , "=[esp+0x0]" ) != NULL )
  {
  /* Obtengo el REGISTRO que queda en el TOPE del STACK */
    s = strtok ( line , "=" );

  /* Seteo el REGISTRO USADO */
    gadget -> register_index = get_register_index ( s );

  /* Seteo el TIPO de OPERACION */
    gadget -> operation = OP_MEM_TO_REG;

  /* MINIMO STACK REQUERIDO */
    gadget -> stack_required = 4;
  }
/* Si es un "MOV REG32,[REG32+0x00]/RET" */
  else if ( strstr ( line , "=[" ) != NULL )
  {
  /* Obtengo el REGISTRO que queda en el TOPE del STACK */
    s = strtok ( line , "=" );

  /* Seteo el REGISTRO SETEADO */
    gadget -> register_index = get_register_index ( s );

  /* Obtengo el REGISTRO ORIGEN */
    s = strtok ( NULL , "=" );

  /* Obtengo el REGISTRO usado y el OFFSET */
    get_register_plus_offset ( s , &gadget -> operand , &gadget -> offset_base );

  /* Seteo el TIPO de OPERACION */
    gadget -> operation = OP_MEM_TO_REGS;
  }
/* Si es un "REG32=VALOR" */
  else if ( strstr ( line , "=0x" ) != NULL )
  {
  /* Si el VALOR ASIGNADO es el 0x11111111 NOTeado */
    if ( strstr ( line , "0xeeeeeeee" ) != NULL )
    {
    /* Seteo el TIPO de OPERACION */
      gadget -> operation = OP_REG_TO_NOT_REG;
    }
  /* Si el VALOR ASIGNADO es el 0x11111111 NEGado */
    else if ( strstr ( line , "0xeeeeeeef" ) != NULL )
    {
    /* Seteo el TIPO de OPERACION */
      gadget -> operation = OP_REG_TO_NEG_REG;
    }
  /* Si el VALOR ASIGNADO es el 0x1111111e INCREMENTANDO en 1 */
    else if ( strstr ( line , "0x1111111f" ) != NULL )
    {
    /* Obtengo el REGISTRO que queda en el TOPE del STACK */
      s = strtok ( line , "=" );

    /* Seteo el REGISTRO USADO */
      gadget -> register_index = get_register_index ( s );

    /* Seteo el TIPO de OPERACION */
      gadget -> operation = OP_REG_INCREMENTOR;
    }
  }
/* Si es un "REG32=REG32" */
  else if ( strchr ( line , '=' ) != NULL )
  {
  /* Obtengo las ASIGNACIONES entre REGISTROS */
    get_register_asignations ( gadget , line );

  /* Seteo el TIPO de OPERACION */
    gadget -> operation = OP_REGS_TO_REGS;
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_preserved_registers ( char *s , GADGET *gadget )
{
  unsigned int cont;
  int register_index;
  int ret = TRUE;
  char *t;

/* Mientras HAYA registros */
  while ( ( t = strtok ( s , " " ) ) != NULL )
  {
  /* Para seguir buscando en el MISMO string */
    s = NULL;

  /* Obtengo el INDICE del REGISTRO */
    register_index = get_register_index ( t );

  /* Si el registro es VALIDO */
    if ( register_index != -1 )
    {
    /* Seteo el registro PRESERVADO en el GADGET */
      gadget -> preserved_registers [ register_index ] = TRUE;
    }
  /* Si el registro NO es VALIDO */
    else
    {
    /* Salgo con ERROR */
      ret = FALSE;
      break;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int has_this_instruction ( GADGET *gadget , char *instruction )
{
  unsigned int cont;
  int ret = FALSE;

/* Recorro TODAS las INSTRUCCIONES del GADGET */
  for ( cont = 0 ; cont < gadget -> instructions -> Len () ; cont ++ )
  {
  /* Si TIENE la INSTRUCCION que estoy BUSCANDO */
    if ( strncmp ( instruction , ( char * ) gadget -> instructions -> Get ( cont ) , strlen ( instruction ) ) == 0 )
    {
    /* Encontre la instruccion */
      ret = TRUE;

    /* Dejo de buscar */
      break;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int has_this_asignation ( GADGET *gadget , unsigned int dst_register , unsigned int src_register )
{
  int ret = FALSE;

/* Si es un gadget del tipo REG32=REG32 */
  if ( gadget -> operation == OP_REGS_TO_REGS )
  {
  /* Si TIENE esta ASIGNACION */
//    if ( gadget -> asignated_registers [ dst_register ] == src_register )
    if ( ( gadget -> register_index == dst_register ) && ( gadget -> operand == src_register ) )
    {
    /* Retorno OK */
      ret = TRUE;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

char *get_pushad_ret_type ( GADGET *gadget )
{
  char *type;

/* Tipo de secuencia de instrucciones en el ultimo GADGET */
  if ( gadget -> ending_type == RET_ENDING )
  {
    type = "\"pushad/ret\"";
  }
  else if ( gadget -> ending_type == RETN_ENDING )
  {
    type = "\"pushad/ret 4\"";
  }
  else if ( gadget -> ending_type == RETF_ENDING )
  {
    type = "\"pushad/retf\"";
  }
  else if ( gadget -> ending_type == IRET_ENDING )
  {
    type = "\"pushad/iretd\"";
  }
  else
  {
    type = "\"???\"";
  }

  return ( type );
}

////////////////////////////////////////////////////////////////////////////////

char *get_gadget_pseudo_instruction ( GADGET *gadget )
{
  char instruction [ 256 ];
  char *inst;

/* Inicializo la instruccion */
  strcpy ( instruction , "???" );

/* Si es un "REG1=[REG2+0xNN]" */
  if ( gadget -> operation == OP_MEM_TO_REGS )
  {
  /* Armo la instruccion */
    sprintf ( instruction , "\"mov %s,[%s+0x%.2i]/ret\"" , registers [ gadget -> register_index ] , registers [ gadget -> operand ] , gadget -> offset_base );
  }
/* Si es un "POP REG/RET" */
  else if ( gadget -> operation == OP_MEM_TO_REG )
  {
  /* Armo la instruccion */
    sprintf ( instruction , "\"pop %s/ret\"" , registers [ gadget -> register_index ] );
  }
/* Si es un "REG1=REG2" */
  else if ( gadget -> operation == OP_REGS_TO_REGS )
  {
  /* Si NO es un "JMP ESP" */
    if ( gadget -> register_index != EIP_REGISTER )
    {
    /* Si es un "XCHG" */
      if ( gadget -> asignated_registers [ gadget -> operand ] == gadget -> register_index )
      {
      /* Armo la instruccion */
        sprintf ( instruction , "\"xchg %s,%s/ret\"" , registers [ gadget -> register_index ] , registers [ gadget -> operand ] );
      }
    /* Si es un "MOV" comun */
      else
      {
      /* Armo la instruccion */
        sprintf ( instruction , "\"mov %s,%s/ret\"" , registers [ gadget -> register_index ] , registers [ gadget -> operand ] );
      }
    }
  /* Si es un "JMP ESP" */
    else
    {
    /* Armo la instruccion */
      strcpy ( instruction , "\"jmp esp\"" );
    }
  }
/* Si es un "PUSHAD/RET" */
  else if ( gadget -> operation == OP_REG_TO_MEM )
  {
  /* Armo la instruccion */
    sprintf ( instruction , get_pushad_ret_type ( gadget ) );
  }
/* Si es un "NEG/RET" */
  else if ( gadget -> operation == OP_REG_TO_NEG_REG )
  {
  /* Armo la instruccion */
    sprintf ( instruction , "\"neg %s/ret\"" , registers [ gadget -> register_index ] );
  }
/* Si es un "NOT/RET" */
  else if ( gadget -> operation == OP_REG_TO_NOT_REG )
  {
  /* Armo la instruccion */
    sprintf ( instruction , "\"not %s/ret\"" , registers [ gadget -> register_index ] );
  }
/* Si es un "INC/RET" */
  else if ( gadget -> operation == OP_REG_INCREMENTOR )
  {
  /* Armo la instruccion */
    sprintf ( instruction , "\"inc %s/ret\"" , registers [ gadget -> register_index ] );
  }

/* Alloco memoria */
  inst = ( char * ) malloc ( strlen ( instruction ) + 1 );

/* Copio la PSEUDO-INSTRUCCION */
  strcpy ( inst , instruction );

  return ( inst );
}

////////////////////////////////////////////////////////////////////////////////

int get_padding ( unsigned int size , List &values_to_pop , List &comments )
{
  unsigned int cont;
  int ret = TRUE;

/* Appendeo en el STACK el PADDING */
  for ( cont = 0 ; cont < size / 4 ; cont ++ )
  {
  /* Appendeo el siguiente DWORD */
    values_to_pop.Add ( ( void * ) 0x41414141 );
    comments.Add ( ( void * ) "STACK PADDING" );
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_stack_padding ( GADGET *gadget , List &values_to_pop , List &comments )
{
  int ret = TRUE;

/* Si tiene un STACK PADDING positivo */
  if ( gadget -> stack_padding > 0 )
  {
  /* Obtengo PADDING */
    get_padding ( gadget -> stack_padding , values_to_pop , comments );
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_line ( FILE *f , char *line , unsigned int size )
{
  char *s;
  int ret;

/* Si pude leer ALGO */
  if ( fgets ( line , size , f ) != 0 )
  {
  /* Si tiene un "\r" */
    if ( ( s = strchr ( line , '\r' ) ) != NULL )
    {
    /* Cierro el string en esa posicion */
      *s = '\0';
    }

  /* Si tiene un "\n" */
    if ( ( s = strchr ( line , '\n' ) ) != NULL )
    {
    /* Cierro el string en esa posicion */
      *s = '\0';
    }

  /* Salgo OK */
    ret = TRUE;
  }
  else
  {
  /* Salgo con ERROR */
    ret = FALSE;
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void set_preserved_registers ( GADGET *gadget , List &gadgets )
{
  unsigned int cont, cont2;
  GADGET *gadget2;

/* Pongo TODOS los REGISTROS como PRESERVADOS */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Seteo este registro */
    gadget -> preserved_registers [ cont ] = TRUE;
  }

/* Recorro TODOS los GADGETS que forman el SUPER-GADGET */
  for ( cont2 = 0 ; cont2 < gadgets.Len () ; cont2 ++ )
  {
  /* Levanto el SIGUIENTE GADGET */
    gadget2 = ( GADGET * ) gadgets.Get ( cont2 );

  /* Recorro TODOS los REGISTROS PRESERVADOS de este GADGET */
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Si este REGISTRO NO ESTA PRESERVADO */
      if ( gadget2 -> preserved_registers [ cont ] == FALSE )
      {
      /* Apago este registro */
        gadget -> preserved_registers [ cont ] = FALSE;
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

void set_stack_used ( GADGET *super_gadget , List &gadgets )
{
  GADGET *gadget;
  unsigned int cont;

/* Recorro TODOS los GADGETS involucrados */
  for ( cont = 0 ; cont < gadgets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE GADGET */
    gadget = ( GADGET * ) gadgets.Get ( cont );

  /* Sumo el STACK USADO a este GADGET */    
    super_gadget -> stack_used += gadget -> stack_used;
  }
}

////////////////////////////////////////////////////////////////////////////////

GADGET *create_gadget ( void )
{
  unsigned int cont;
  GADGET *gadget;

/* Creo un nuevo gadget */
  gadget = ( GADGET * ) malloc ( sizeof ( GADGET ) );

/* Inicializo el GADGET */
  memset ( gadget , 0 , sizeof ( GADGET ) );

/* Inicializo TODAS las ASIGNACIONES */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Pongo un REGISTRO INVALIDO */
    gadget -> asignated_registers [ cont ] = -1;
  }

/* Seteos INICIALES para el gadget */
  gadget -> ending_type = OTHER_ENDING;
  gadget -> addresses = new ( List );
  gadget -> instructions = new ( List );
  gadget -> gadgets = new ( List );
  gadget -> values_to_pop = new ( List );
  gadget -> comments = new ( List );

/* Retorno el GADGET CREADO */
  return ( gadget );
}

////////////////////////////////////////////////////////////////////////////////

int has_invalid_chars ( List &invalid_chars , void *value )
{
  unsigned char *v = ( unsigned char * ) &value;
  unsigned int cont;
  int ret = FALSE;

/* Recorro byte por byte del VALOR */
  for ( cont = 0 ; cont < sizeof ( value ) ; cont ++ )
  {
  /* Si este BYTE es un INVALID CHAR */
    if ( invalid_chars.Find ( ( void * ) v [ cont ] ) == TRUE )
    {
    /* Retorno OK */
      ret = TRUE;

    /* Dejo de buscar */
      break;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_better_register_preserver ( GADGET *gadget1 , GADGET *gadget2 )
{
  unsigned int cont;
  unsigned int preserves1 = 0;
  unsigned int preserves2 = 0;
  int ret = FALSE;

/* Recorro TODOS los REGISTROS PRESERVADOS */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Si el GADGET 1 preserva este REGISTRO */
    if ( gadget1 -> preserved_registers [ cont ] == TRUE )
    {
    /* Sumo un PUNTO */
      preserves1 ++;
    }

  /* Si el GADGET 2 preserva este REGISTRO */
    if ( gadget2 -> preserved_registers [ cont ] == TRUE )
    {
    /* Sumo un PUNTO */
      preserves2 ++;
    }
  }

/* Si el gadget1 PRESERVA MAS REGISTROS */
  if ( preserves1 > preserves2 )
  {
  /* Retorno OK */
    ret = TRUE;
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_better_gadget ( GADGET *gadget1 , GADGET *gadget2 )
{
  int ret = FALSE;

/* Si el STACK es POSITIVO */
  if ( gadget1 -> stack_used >= 4 )
  {
  /* Si estoy comparando con NINGUNO ( Primera asignacion ) */
    if ( gadget2 == NULL )
    {
    /* Tengo el PRIMER CANDIDATO */
      ret = TRUE;
    }
  /* Si usa MENOS STACK que el gadget 2 */
    else if ( gadget1 -> stack_used < gadget2 -> stack_used )
    {
    /* Tengo un MEJOR CANDIDATO */
      ret = TRUE;
    }
  /* Si usa el MISMO STACK que el gadget 2 */
    else if ( gadget1 -> stack_used == gadget2 -> stack_used )
    {
    /* Si PRESERVA mas REGISTROS */
      if ( is_better_register_preserver ( gadget1 , gadget2 ) == TRUE )
      {
      /* Tengo un MEJOR CANDIDATO */
        ret = TRUE;
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_perfect_preserver ( GADGET *gadget , int register_set )
{
  unsigned int cont;
  int ret = TRUE;

/* Recorro TODOS los REGISTROS PRESERVADOS */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Si es el MISMO REGISTRO seteado */
    if ( cont == register_set )
    {
    /* Paso al SIGUIENTE */
      continue;
    }

  /* Si es EIP o ESP */
    if ( ( cont == ESP_REGISTER ) || ( cont == EIP_REGISTER ) )
    {
    /* Paso al SIGUIENTE */
      continue;
    }

  /* Si ROMPE este REGISTRO */
    if ( gadget -> preserved_registers [ cont ] == FALSE )
    {
    /* ROMPE este registro */
      ret = FALSE;

    /* Dejo de buscar */
      break;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void decompose_gadget ( GADGET *super_gadget , List &gadgets )
{
  GADGET *gadget;
  unsigned int cont;

/* Recorro TODOS los GADGETS que lo COMPONEN */
  for ( cont = 0 ; cont < super_gadget -> gadgets -> Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE GADGET */
    gadget = ( GADGET * ) super_gadget -> gadgets -> Get ( cont );

  /* Si es un GADGET SIMPLE */
    if ( gadget -> is_super_gadget == FALSE )
    {
    /* Agrego el GADGET a la LISTA LINEAL */
      gadgets.Add ( ( void * ) gadget );
    }
  /* Si es un SUPER-GADGET */
    else
    {
    /* Obtengo TODOS los GADGETS del SUPER-GADGET */
      decompose_gadget ( gadget , gadgets );
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

void get_simple_gadgets ( List &rop_chain , List &simple_gadgets )
{
  List gadgets;
  GADGET *gadget;
  unsigned int cont;

/* Limpio la lista a generar */
  simple_gadgets.Clear ();

/* Recorro TODOS los GADGETS del ROP-CHAIN */
  for ( cont = 0 ; cont < rop_chain.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE GADGET */
    gadget = ( GADGET * ) rop_chain.Get ( cont );

  /* Si es un GADGET SIMPLE */
    if ( gadget -> is_super_gadget == FALSE )
    {
    /* Agrego el GADGET a la LISTA LINEAL */
      simple_gadgets.Add ( ( void * ) gadget );
    }
  /* Si es un SUPER-GADGET */
    else
    {
    /* Obtengo TODOS los GADGETS que lo COMPONEN */
      decompose_gadget ( gadget , simple_gadgets );
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

GADGET *create_super_mov_reg32_reg32_gadget ( unsigned int dst_register , unsigned int src_register , List &gadgets )
{
  GADGET *gadget;
  unsigned int cont;

/* Creo un GADGET */
  gadget = create_gadget ();

/* Seteo el FLAG de GADGET COMPUESTO */
  gadget -> is_super_gadget = TRUE;

/* Seteo la ASIGNACION del GADGET */
  gadget -> register_index = dst_register;
  gadget -> operation = OP_REGS_TO_REGS;
  gadget -> operand = src_register;

/* Pongo la ASIGNACION en la lista */
  gadget -> asignated_registers [ dst_register ] = src_register;

/* Seteo los REGISTROS PRESERVADOS */
  set_preserved_registers ( gadget , gadgets );

//  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
//  {
//    printf ( "%i " , gadget -> preserved_registers [ cont ] );
//  }
//
//  printf ( "\n" );

/* Seteo el STACK USADO */
  set_stack_used ( gadget , gadgets );
//  printf ( "stack usado = %i\n" , gadget -> stack_used );

/* Le pongo algo de PUNTAJE ( Para que SEA TOMADO EN CUENTA ) */
  gadget -> score = 1;

/* Seteo el TIPO de RETORNO ( El PEOR de TODO el CONJUNTO ) */

/* Agrego los GADGETS que lo COMPONEN */
  gadget -> gadgets -> Append ( gadgets );

  return ( gadget );
}

////////////////////////////////////////////////////////////////////////////////

GADGET *create_super_pop_reg32_gadget ( unsigned int dst_register , List &gadgets )
{
  List final_gadgets;
  GADGET *gadget;
  unsigned int cont;

/* Recorro TODOS los GADGETS que lo COMPONEN */
  for ( cont = 0 ; cont < gadgets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE GADGET */
    gadget = ( GADGET * ) gadgets.Get ( cont );

  /* Si es un GADGET SIMPLE */
    if ( gadget -> is_super_gadget == FALSE )
    {
    /* Agrego el GADGET DIRECTAMENTE */
      final_gadgets.Add ( ( void * ) gadget );
    }
  /* Si es un GADGET COMPUESTO */
    else
    {
    /* Agrego TODOS los GADGETS que lo COMPONEN */
      final_gadgets.Append ( gadget -> gadgets );
    }
  }

/* Creo un GADGET */
  gadget = create_gadget ();

/* Seteo el FLAG de GADGET COMPUESTO */
  gadget -> is_super_gadget = TRUE;

/* Seteo la ASIGNACION del GADGET */
  gadget -> register_index = dst_register;
  gadget -> operation = OP_MEM_TO_REG;

/* Seteo los REGISTROS PRESERVADOS */
  set_preserved_registers ( gadget , final_gadgets );

//  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
//  {
//    printf ( "%i " , gadget -> preserved_registers [ cont ] );
//  }
//
//  printf ( "\n" );

/* Seteo el STACK USADO */
  set_stack_used ( gadget , final_gadgets );
//  printf ( "stack usado = %i\n" , gadget -> stack_used );

/* Le pongo algo de PUNTAJE ( Para que SEA TOMADO EN CUENTA ) */
  gadget -> score = 1;

/* Agrego los GADGETS que lo COMPONEN */
  gadget -> gadgets -> Append ( final_gadgets );

  return ( gadget );
}

////////////////////////////////////////////////////////////////////////////////

GADGET *create_super_negator_pop_reg32_gadget ( unsigned int dst_register , List &gadgets )
{
  int negator_operator = OP_MEM_TO_REG;
  List simple_gadgets;
  GADGET *simple_gadget;
  GADGET *gadget;
  unsigned int cont;

/* Creo un GADGET */
  gadget = create_gadget ();

/* Seteo el FLAG de GADGET COMPUESTO */
  gadget -> is_super_gadget = TRUE;

/* Marco al GADGET como NEGADOR ( Para saber cuando usarlo ) */
  gadget -> negator = TRUE;

/* Seteo la ASIGNACION del GADGET */
  gadget -> register_index = dst_register;
  gadget -> operation = negator_operator;

/* Seteo los REGISTROS PRESERVADOS */
  set_preserved_registers ( gadget , gadgets );

/* Seteo el STACK USADO */
  set_stack_used ( gadget , gadgets );
//  printf ( "stack usado = %i\n" , gadget -> stack_used );

/* Le pongo algo de PUNTAJE ( Para que SEA TOMADO EN CUENTA ) */
  gadget -> score = 1;

/* Agrego los GADGETS que lo COMPONEN */
  gadget -> gadgets -> Append ( gadgets );

/* Obtengo TODOS los GADGETS que lo COMPONEN */
  decompose_gadget ( gadget , simple_gadgets );

/* Recorro TODOS los GADGETS que lo COMPONEN */
  for ( cont = 0 ; cont < simple_gadgets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE GADGET */
    simple_gadget = ( GADGET * ) simple_gadgets.Get ( cont );

  /* Si el GADGET es un NEGADOR */
    if ( simple_gadget -> operation == OP_REG_TO_NEG_REG )
    {
    /* Seteo la OPERACION NEGADORA en el SUPER-GADGET */
      gadget -> neg_operation = simple_gadget -> operation;

    /* Dejo de buscar */
      break;
    }
  /* Si el GADGET es un NOTEADOR */
    else if ( simple_gadget -> operation == OP_REG_TO_NOT_REG )
    {
    /* Seteo la OPERACION NEGADORA en el SUPER-GADGET */
      gadget -> neg_operation = simple_gadget -> operation;

    /* Dejo de buscar */
      break;
    }
  }

  return ( gadget );
}

////////////////////////////////////////////////////////////////////////////////

GADGET *create_super_jmp_esp_gadget ( List &gadgets )
{
  GADGET *gadget;
  unsigned int cont;

/* Creo un GADGET */
  gadget = create_gadget ();

/* Seteo el FLAG de GADGET COMPUESTO */
  gadget -> is_super_gadget = TRUE;

/* Seteo la ASIGNACION del GADGET */
  gadget -> register_index = EIP_REGISTER;
  gadget -> operation = OP_REGS_TO_REGS;
  gadget -> operand = ESP_REGISTER;

/* Seteo los REGISTROS PRESERVADOS */
  set_preserved_registers ( gadget , gadgets );

/* Seteo el STACK USADO */
  set_stack_used ( gadget , gadgets );
//  printf ( "stack usado = %i\n" , gadget -> stack_used );

/* Le pongo algo de PUNTAJE ( Para que SEA TOMADO EN CUENTA ) */
  gadget -> score = 1;

/* Agrego los GADGETS que lo COMPONEN */
  gadget -> gadgets -> Append ( gadgets );

  return ( gadget );
}

////////////////////////////////////////////////////////////////////////////////

GADGET *create_super_bypasser_gadget ( GADGET *bypass1 , GADGET *gadget_to_bypass , GADGET *bypass2 )
{
  List gadgets;
  GADGET *gadget;
  unsigned int cont;

/* Armo la LISTA de los GADGETS que lo COMPONEN */
  gadgets.Add ( ( void * ) bypass1 );
  gadgets.Add ( ( void * ) gadget_to_bypass );
  gadgets.Add ( ( void * ) bypass2 );
 
/* Creo un GADGET */
  gadget = create_gadget ();

/* Pongo los MISMOS SETEOS que el GADGET a SALVAR */
  gadget -> register_index = gadget_to_bypass -> register_index;
  gadget -> operation = gadget_to_bypass -> operation;
  gadget -> operand = gadget_to_bypass -> operand;

/* Transfiero los SETEOS especiales */
  gadget -> negator = gadget_to_bypass -> negator;
  gadget -> neg_operation = gadget_to_bypass -> neg_operation;
  gadget -> is_special_gadget = gadget_to_bypass -> is_special_gadget;

/* Seteo el FLAG de GADGET COMPUESTO */
  gadget -> is_super_gadget = TRUE;

/* Seteo los REGISTROS PRESERVADOS */
  set_preserved_registers ( gadget , gadgets );

/* Seteo el STACK USADO */
  set_stack_used ( gadget , gadgets );
//  printf ( "stack usado = %i\n" , gadget -> stack_used );

/* Le pongo algo de PUNTAJE ( Para que SEA TOMADO EN CUENTA ) */
  gadget -> score = 1;

/* Agrego los GADGETS que lo COMPONEN */
  gadget -> gadgets -> Append ( gadgets );

  return ( gadget );
}

////////////////////////////////////////////////////////////////////////////////

GADGET *get_best_bypass ( List &mov_reg32_reg32_rets , GADGET *super_gadget , int register_to_save , int register_to_move )
{
  GADGET *best_gadget1 = NULL;
  GADGET *best_gadget2 = NULL;
  GADGET *bypass_gadget = NULL;
  GADGET *gadget;
  unsigned int best_score = 0;
  unsigned int score;
  unsigned int cont;

/* Recorro TODOS los GADGETS DISPONIBLES */
  for ( cont = 0 ; cont < mov_reg32_reg32_rets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE gadget */
    gadget = ( GADGET * ) mov_reg32_reg32_rets.Get ( cont );

  /* Si el GADGET tiene PUNTAJE */
    if ( gadget -> score > 0 )
    {
    /* Si el GADGET MUEVE el REGISTRO que me interesa al REGISTRO que ME INTERESA */
      if ( ( gadget -> register_index == register_to_move ) && ( gadget -> operand == register_to_save ) )
      {
      /* Si es el PRIMER REGISTRO */
        if ( best_gadget1 == NULL )
        {
        /* Por ahora es el MEJOR */
          best_gadget1 = gadget;
        }

      /* Si el GADGET es MEJOR que el ANTERIOR */
        if ( is_better_register_preserver ( gadget , best_gadget1 ) == TRUE )
//        if ( is_better_gadget ( gadget , best_gadget1 ) == TRUE )
        {
        /* Hay un NUEVO MEJOR */
          best_gadget1 = gadget;
        }
      }
    }
  }

/* Si NO hay GADGET para SALVAR el REGISTRO */
  if ( best_gadget1 == NULL )
  {
  /* No hay BYPASS para este REGISTRO */
    return ( NULL );
  }

/* Recorro TODOS los GADGETS DISPONIBLES */
  for ( cont = 0 ; cont < mov_reg32_reg32_rets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE gadget */
    gadget = ( GADGET * ) mov_reg32_reg32_rets.Get ( cont );

  /* Si el GADGET tiene PUNTAJE */
    if ( gadget -> score > 0 )
    {
    /* Si el GADGET MUEVE el REGISTRO que me interesa al REGISTRO que ME INTERESA */
      if ( ( gadget -> register_index == register_to_save ) && ( gadget -> operand == register_to_move ) )
      {
      /* Si el GADGET NO ROMPE el VALOR SETEADO por el SUPER-GADGET */
        if ( gadget -> preserved_registers [ super_gadget -> register_index ] == TRUE )
        {
        /* Si es el PRIMER REGISTRO */
          if ( best_gadget2 == NULL )
          {
          /* Por ahora es el MEJOR */
            best_gadget2 = gadget;
          }

        /* Si el GADGET es MEJOR que el ANTERIOR */
          if ( is_better_register_preserver ( gadget , best_gadget2 ) == TRUE )
//          if ( is_better_gadget ( gadget , best_gadget2 ) == TRUE )
          {
          /* Hay un NUEVO MEJOR */
            best_gadget2 = gadget;
          }
        }
      }
    }
  }

/* Si hay un BYPASSER */
  if ( ( best_gadget1 != NULL ) && ( best_gadget2 != NULL ) )
  {
  /* Creo un SUPER-GADGET */
    bypass_gadget = create_super_bypasser_gadget ( best_gadget1 , super_gadget , best_gadget2 );

  /* Marco al REGISTRO BYPASSEADO como PRESERVADO */
    bypass_gadget -> preserved_registers [ register_to_save ] = TRUE;
  }

  return ( bypass_gadget );
}

////////////////////////////////////////////////////////////////////////////////

int get_super_bypasses ( GADGET *super_gadget , List &mov_reg32_reg32_rets , List &super_bypasses )
{
  unsigned int cont, cont2;
  int ret = TRUE;
  GADGET *gadget;

/* Inicializo la lista */
  super_bypasses.Clear ();

/* Recorro TODOS los REGISTROS */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Si es un "POP REG32" */
    if ( super_gadget -> operation == OP_MEM_TO_REG )
    {
    /* Si este REGISTRO NO es el SETEADO */
      if ( super_gadget -> register_index != cont )
      {
      /* Si este REGISTRO es PRESERVADO */
        if ( super_gadget -> preserved_registers [ cont ] == TRUE )
        {
        /* Paso al SIGUIENTE */
          continue;
        }

      /* Recorro TODOS los REGISTROS */
        for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
        {
        /* Si este REGISTRO NO es el SETEADO */
          if ( super_gadget -> register_index != cont2 )
          {
          /* Si este registro NO es PISADO por el GADGET */
            if ( super_gadget -> preserved_registers [ cont2 ] == TRUE )
            {
            /* Si NO es el MISMO REGISTRO */
              if ( cont != cont2 )
              {
              /* Obtengo el MEJOR BYPASS */
//                printf ( "%s -> %s\n" , registers [ cont ] , registers [ cont2 ] );
                gadget = get_best_bypass ( mov_reg32_reg32_rets , super_gadget , cont , cont2 );
//                printf ( "%s <- %s\n" , registers [ cont ] , registers [ cont2 ] );

              /* Si hay un SUPER-GADGET */
                if ( gadget != NULL )
                {
                /* Agrego el gadget a la lista */
                  super_bypasses.Add ( ( void * ) gadget );
                }
              }
            }
          }
        }
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_gadgets ( char *binary_output , void *module_base , void *real_module_base , List &invalid_chars , List &gadgets )
{
  FILE *f;
  GADGET *gadget2;
  GADGET *gadget;
  List new_simple_gadgets;
  unsigned int cont, cont2;
  void *address;
  char line [1024];
  char *s;
  char *ns;
  int ret_consumption;
  int ret = TRUE;

/* Abro la salida de Agafi */
  f = fopen ( binary_output , "rb" );

/* Si el file pudo ser ABIERTO */
  if ( f != NULL )
  {
  /* Leo el file hasta que NO quede DATA */
    while ( get_line ( f , line , sizeof ( line ) ) == TRUE )
    {
    /* Si es un NUEVO GADGET */
      if ( strncmp ( line , "-----" , 5 ) == 0 )
      {
      /* Creo un nuevo gadget */
        gadget = create_gadget ();

      /* Agrego el gadget a la lista */
        gadgets.Add ( ( void * ) gadget );
      }
    /* Si es la DIRECCION del GADGET */
      else if ( strncmp ( line , "[x] Valid" , 9 ) == 0 )
      {
      /* Busco donde empieza la direccion */        
        s = strchr ( line , ':' );
        s += 2;

      /* Obtengo la DIRECCION del GADGET */
        sscanf ( s , "%x" , &gadget -> address );

      /* Obtengo el OFFSET del GADGET */
        gadget -> offset = ( unsigned int ) ( ( char * ) gadget -> address - ( char * ) module_base );

      /* Seteo la DIRECCION REAL del GADGET */
        gadget -> address = ( void * ) ( ( unsigned int ) real_module_base + gadget -> offset );
      }    
    /* Si es el 'TIPO DE GADGET' */
      else if ( strncmp ( line , "--> matches:" , 12 ) == 0 )
      {
      /* Busco donde empieza el OBJETIVO */        
        s = strchr ( line , ':' );
        s += 2;

      /* Obtengo el TIPO */
        get_operation_type ( s , gadget );
      }
    /* Si es el STACK USADO */
      else if ( strncmp ( line , "--> stack used:" , 15 ) == 0 )
      {
      /* Busco donde empieza la direccion */        
        s = strchr ( line , ':' );
        s += 2;

      /* Obtengo el STACK USADO */
        sscanf ( s , "%x" , &gadget -> stack_used );
      }
    /* Si son los REGISTROS PRESERVADOS */
      else if ( strncmp ( line , "--> preserved registers:" , 24 ) == 0 )
      {
      /* Busco donde empieza la direccion */        
        s = strchr ( line , ':' );
        s += 2;

      /* Recorro TODOS los REGISTROS PRESERVADOS */
        get_preserved_registers ( s , gadget );
      }
    /* Si es la CANTIDAD de JUMP CONDICIONALES usados */
      else if ( strncmp ( line , "--> conditional jumps used:" , 27 ) == 0 )
      {
      /* Busco donde empieza la direccion */        
        s = strchr ( line , ':' );
        s += 2;

      /* Obtengo la CANTIDAD usada */
        sscanf ( s , "%i" , &gadget -> conditional_jumps );
      }
    /* Si es el INICIO de UNA INSTRUCCION */
      else if ( strncmp ( line , "*** " , 4 ) == 0 )
      {
      /* Obtengo la direccion de la instruccion */
        s = strtok ( line , ":" );
        sscanf ( &s [ 4 ] , "%x" , &address );

      /* Direccion REAL de la INSTRUCCION */
        address = ( void * ) ( ( char * ) real_module_base + ( ( char * ) address - ( char * ) module_base ) );

      /* Agrego el ADDRESS de la instruccion */
        gadget -> addresses -> Add ( ( void * ) address );

      /* Obtengo la instruccion */
        s = strtok ( NULL , ":" );
        s += 1;

      /* Alloco un STRING para guardar la INSTRUCCION */        
        ns = ( char * ) malloc ( strlen ( s ) + 1 );

      /* Copio el string */
        strcpy ( ns , s );

      /* Agrego la INSTRUCCION al GADGET */
        gadget -> instructions -> Add ( ( void * ) ns );

      /* Si es una instruccion de FIN de GADGET */
        if ( strncmp ( ns , "ret" , 3 ) == 0 )
        {
        /* Si es un RET comun */
          if ( strcmp ( ns , "ret" ) == 0 )
          {
          /* Seteo el TIPO DE RETORNO */
            gadget -> ending_type = RET_ENDING;
          }
        /* Si es un RETF */
          else if ( strcmp ( ns , "retf" ) == 0 )
          {
          /* Seteo el TIPO DE RETORNO */
            gadget -> ending_type = RETF_ENDING;
          }
        /* Si es un IRET */
          else if ( strcmp ( ns , "iret" ) == 0 )
          {
          /* Seteo el TIPO DE RETORNO */
            gadget -> ending_type = IRET_ENDING;
          }
        /* Si es un 'RET n' */
          else if ( strncmp ( ns , "ret 0x" , 6 ) == 0 )
          {
          /* Seteo el TIPO DE RETORNO */
            gadget -> ending_type = RETN_ENDING;

          /* Obtengo la CANTIDAD de BYTES que SALTEA */
            s = strchr ( ns , ' ' );
            sscanf ( s + 1 , "%x" , &gadget -> ret_extra_consumption );
          }
        }
      }
    }

  /* Cierro el file */
    fclose ( f );
  }

/* Si HAY GADGETS */
  if ( ret == TRUE )
  {
  /* Recorro TODOS los GADGETS encontrados */
    for ( cont = 0 ; cont < gadgets.Len () ; cont ++ )
    {
    /* Levanto el siguiente GADGET */
      gadget = ( GADGET * ) gadgets.Get ( cont );

    /* Si el gadget DES-ALINEA el STACK */
      if ( gadget -> stack_used & 0x3 )
      {
      /* Este gadget NO SIRVE */
        gadgets.Delete ( cont );

      /* Compenso la extraccion */
        cont --;

      /* Paso al SIGUIENTE */
        continue;
      }
    /* Si tiene una INSTRUCCION INVALIDA */
      else if ( has_this_instruction ( gadget , "db" ) == TRUE )
      {
      /* Este gadget NO SIRVE */
        gadgets.Delete ( cont );

      /* Compenso la extraccion */
        cont --;

      /* Paso al SIGUIENTE */
        continue;
      }
    /* Si TIENE INVALID CHARS */
      else if ( has_invalid_chars ( invalid_chars , gadget -> address ) == TRUE )
      {
      /* Este gadget NO SIRVE */
        gadgets.Delete ( cont );

      /* Compenso la extraccion */
        cont --;

      /* Paso al SIGUIENTE */
        continue;
      }
    /* Si termina con un RETF/IRETD */
      else if ( gadget -> ending_type == RETF_ENDING || gadget -> ending_type == IRET_ENDING )
      {
      /* Este gadget NO SIRVE ( Windows usa distintos SELECTORES en 32 y 64 bits ) */
        gadgets.Delete ( cont );

      /* Compenso la extraccion */
        cont --;

      /* Paso al SIGUIENTE */
        continue;
      }

//    /* Si el 0x00 o el 0x1b son "INVALID CHARS" */
//      else if ( invalid_chars.Find ( ( void * ) 0x00 ) == TRUE || invalid_chars.Find ( ( void * ) 0x1b ) == TRUE )
//      {
//      /* Si NO es un "PUSHAD/RET" y familia */
//        if ( gadget -> operation != OP_REG_TO_MEM )
//        {
//        /* Si TERMINA en "RETF/IRETD" */
//          if ( gadget -> ending_type == RETF_ENDING || gadget -> ending_type == IRET_ENDING )
//          {
//          /* NO puedo usar este GADGET */ 
//            gadgets.Delete ( cont );
//
//          /* Compenso la extraccion */
//            cont --;
//
//          /* Paso al SIGUIENTE */
//            continue;
//          }
//        }
//      }

    /* Si es un RET COMUN */
      if ( gadget -> ending_type == RET_ENDING )
      {
      /* Calculo el PADDING a setear */
        ret_consumption = 4;
      }
    /* Si es un RETN */
      else if ( gadget -> ending_type == RETN_ENDING )
      {
      /* Stack que CONSUME el RET */
        ret_consumption = 4;
      }
    /* Si es un RETF */
      else if ( gadget -> ending_type == RETF_ENDING )
      {
      /* Stack que CONSUME el RET */
        ret_consumption = 8;
      }
    /* Si es un IRETD */
      else if ( gadget -> ending_type == IRET_ENDING )
      {
      /* Stack que CONSUME el RET */
        ret_consumption = 0xc;
      }

    /* Calculo el PADDING a setear */
      gadget -> stack_padding = gadget -> stack_used - gadget -> stack_required - gadget -> ret_extra_consumption - ret_consumption;
    }

  /* Recorro TODOS los GADGETS encontrados */
    for ( cont = 0 ; cont < gadgets.Len () ; cont ++ )
    {
    /* Levanto el siguiente GADGET */
      gadget = ( GADGET * ) gadgets.Get ( cont );

    /* Si tiene MULTIPLES ASIGNACIONES */
      if ( gadget -> multiple_asignations == TRUE )
      {
      /* Recorro TODAS las ASIGNACIONES */
        for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
        {
        /* Si es una ASIGNACION DOBLE ("xchg") */
          if ( gadget -> operation == OP_REGS_TO_REGS )
          {
          /* Si hay una ASIGNACION VALIDA */
            if ( gadget -> asignated_registers [ cont2 ] != -1 )
            {
            /* Creo un GADGET con una ASIGNACION SIMPLE */
              gadget2 = create_gadget ();

            /* Asigno los valores del GADGET ORIGINAL */
              *gadget2 = *gadget;

            /* Seteo la ASIGNACION DEL GADGET */
              gadget2 -> register_index = cont2;
              gadget2 -> operand = gadget -> asignated_registers [ cont2 ];
        
            /* Seteo el TIPO de OPERACION */
//            printf ( "SETEAR TIPO DE OPERACION\n" );
            }
          }

         /* Seteo el GADGET como SIMPLE ASIGNACION */
          gadget2 -> multiple_asignations = FALSE;

        /* Agrego el GADGET a la lista TEMPORAL */
          new_simple_gadgets.Add ( ( void * ) gadget2 );
        }
      }
    }

  /* Agrego los GADGETS SIMPLES obtenidos de MULTIPLES ASIGNACIONES */
    gadgets.Append ( new_simple_gadgets );
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void generate_file ( char *oldfile , char *newfile )
{
  FILE *fo;
  FILE *fn;
  char line [ 1024 ];

/* Abro los files */
  fo = fopen ( oldfile , "rt" );
  fn = fopen ( newfile , "wt" );

/* Levanto la siguiente linea */
  while ( fgets ( line , sizeof ( line ) , fo ) != 0 )
  {
  /* Si NO tiene un ENTER al final */
    if ( line [ strlen ( line ) - 1 ] != '\n' )
    {
    /* Pongo un ENTER al final */
      strncat ( line , "\n" , sizeof ( line ) );
    }

  /* Si es la linea que declara "INVALID CHARS" */
    if ( strstr ( line , "invalid_chars" ) != NULL )
    {
    /* Por ahora Agafi NO SOPORTA este comando */
      continue;
    }

  /* Escribo la linea en el NUEVO file */
    fwrite ( line , strlen ( line ) , 1 , fn );
  }

/* Writting a friendly message */
  fprintf ( fn , "\n" );
  fprintf ( fn , "# Gadget to be found\n" );

/* Cierro los files */
  fclose ( fo );
  fclose ( fn );
}

////////////////////////////////////////////////////////////////////////////////

int get_negator_rets ( int new_search , void *module_base , void *real_module_base , char *settings , char *snapshot , List &invalid_chars , List &negator_rets )
{
  char *objective = "objectiveX.txt";
  char txtfile [ 4096 ];
  char cmd1 [ 4096 ];
  char cmd2 [ 4096 ];
  char cmd [ 4096 ];
  int ret = TRUE;

/* Armo el nombre de los files */
  snprintf ( txtfile , sizeof ( txtfile ) , "%s.%s" , snapshot , "negator_rets.txt" );

/* Si tengo que hacer una NUEVA BUSQUEDA */
  if ( new_search == TRUE )
  {
  /* Si hay SETTINGS INICIALES */
    if ( settings != NULL )
    {
    /* Genero el "OBJECTIVE.TXT" */
      generate_file ( settings , objective );
    }
  /* Si NO hay SETTINGS */
    else
    {
    /* Creo el file donde va el OBJETIVO de BUSQUEDA */
      sprintf ( cmd , "echo # finding ... > %s" , objective );
      system ( cmd );

    /* Seteo las EFLAGS para BAJAR el TIEMPO de BUSQUEDA */
      sprintf ( cmd , "echo eflags = 0x202 >> %s" , objective );
      system ( cmd );
    }

  /* Pongo el OBJETIVO */
    sprintf ( cmd , "echo eax=0x11111111 >> %s" , objective );
    system ( cmd );
    sprintf ( cmd , "echo eax==0xeeeeeeee,0xeeeeeeef >> %s" , objective );
    system ( cmd );

  /* Busco los GADGETS */
    snprintf ( cmd , sizeof ( cmd ) , "agafi -s %s %s %s" , snapshot , objective , txtfile );
    system ( cmd );
  }

/* Parseo la salida */
  get_gadgets ( txtfile , module_base , real_module_base , invalid_chars , negator_rets );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_incrementor_rets ( int new_search , void *module_base , void *real_module_base , char *settings , char *snapshot , List &invalid_chars , List &incrementor_rets )
{
  char *objective = "objectiveX.txt";
  char txtfile [ 4096 ];
  char cmd1 [ 4096 ];
  char cmd2 [ 4096 ];
  char cmd [ 4096 ];
  int ret = TRUE;

/* Armo el nombre de los files */
  snprintf ( txtfile , sizeof ( txtfile ) , "%s.%s" , snapshot , "incrementor_rets.txt" );

/* Si tengo que hacer una NUEVA BUSQUEDA */
  if ( new_search == TRUE )
  {
  /* Si hay SETTINGS INICIALES */
    if ( settings != NULL )
    {
    /* Genero el "OBJECTIVE.TXT" */
      generate_file ( settings , objective );
    }
  /* Si NO hay SETTINGS */
    else
    {
    /* Creo el file donde va el OBJETIVO de BUSQUEDA */
      sprintf ( cmd , "echo # finding ... > %s" , objective );
      system ( cmd );

    /* Seteo las EFLAGS para BAJAR el TIEMPO de BUSQUEDA */
      sprintf ( cmd , "echo eflags = 0x202 >> %s" , objective );
      system ( cmd );
    }

  /* Pongo el OBJETIVO para EBX ( SIZE a DESPROTEGER ) */
    sprintf ( cmd , "echo ebx=0x1111111e >> %s" , objective );
    system ( cmd );
    sprintf ( cmd , "echo ebx==0x1111111f >> %s" , objective );
    system ( cmd );

  /* Busco los GADGETS */
    snprintf ( cmd , sizeof ( cmd ) , "agafi -s %s %s %s" , snapshot , objective , txtfile );
    system ( cmd );
  }

/* Parseo la salida */
  get_gadgets ( txtfile , module_base , real_module_base , invalid_chars , incrementor_rets );

//  printf ( "INCREMENTORS ENCONTRADOS = %i\n" , incrementor_rets.Len () );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_pushad_rets ( int new_search , void *module_base , void *real_module_base , char *settings , char *snapshot , List &invalid_chars , List &pushad_rets )
{
  char *objective = "objectiveX.txt";
  char txtfile [ 4096 ];
  char cmd [ 4096 ];
  int ret = TRUE;

/* Armo el nombre de los files */
  snprintf ( txtfile , sizeof ( txtfile ) , "%s.%s" , snapshot , "pushad_rets.txt" );

/* Si tengo que hacer una NUEVA BUSQUEDA */
  if ( new_search == TRUE )
  {
  /* Si hay SETTINGS INICIALES */
    if ( settings != NULL )
    {
    /* Genero el "OBJECTIVE.TXT" */
      generate_file ( settings , objective );
    }
  /* Si NO hay SETTINGS */
    else
    {
    /* Creo el file donde va el OBJETIVO de BUSQUEDA */
      sprintf ( cmd , "echo # finding ... > %s" , objective );
      system ( cmd );

    /* Seteo las EFLAGS para BAJAR el TIEMPO de BUSQUEDA */
      sprintf ( cmd , "echo eflags = 0x202 >> %s" , objective );
      system ( cmd );
    }

  /* Pongo el OBJETIVO */
    sprintf ( cmd , "echo [esp+0x00]==reg32 and [esp+0x04]==reg32 and eip==edi >> %s" , objective );
    system ( cmd );

  /* Busco los GADGETS */
    snprintf ( cmd , sizeof ( cmd ) , "agafi -s %s %s %s" , snapshot , objective , txtfile );
    system ( cmd );
  }

/* Parseo la salida */
  get_gadgets ( txtfile , module_base , real_module_base , invalid_chars , pushad_rets );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_pop_reg32_rets ( int new_search , void *module_base , void *real_module_base , char *settings , char *snapshot , List &invalid_chars , List &pop_reg32_rets )
{
  char *objective = "objectiveX.txt";
  char txtfile [ 4096 ];
  char cmd [ 4096 ];
  int ret = TRUE;

/* Armo el nombre de los files */
  snprintf ( txtfile , sizeof ( txtfile ) , "%s.%s" , snapshot , "pop_reg32_rets.txt" );

/* Si tengo que hacer una NUEVA BUSQUEDA */
  if ( new_search == TRUE )
  {
  /* Si hay SETTINGS INICIALES */
    if ( settings != NULL )
    {
    /* Genero el "OBJECTIVE.TXT" */
      generate_file ( settings , objective );
    }
  /* Si NO hay SETTINGS */
    else
    {
    /* Creo el file donde va el OBJETIVO de BUSQUEDA */
      sprintf ( cmd , "echo # finding ... > %s" , objective );
      system ( cmd );

    /* Seteo las EFLAGS para BAJAR el TIEMPO de BUSQUEDA */
      sprintf ( cmd , "echo eflags = 0x202 >> %s" , objective );
      system ( cmd );
    }

  /* Pongo el OBJETIVO */
    sprintf ( cmd , "echo reg32==[esp+0x00] >> %s" , objective );
    system ( cmd );

  /* Busco los GADGETS */
    snprintf ( cmd , sizeof ( cmd ) , "agafi -s %s %s %s" , snapshot , objective , txtfile );
    system ( cmd );
  }

/* Parseo la salida */
  get_gadgets ( txtfile , module_base , real_module_base , invalid_chars , pop_reg32_rets );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_gadget_route ( unsigned int stack_used , GADGET *gadget_matrix [VALID_REGISTERS] [VALID_REGISTERS] , int dst_register , int src_register , List &gadget_chain )
{
  static int visited_registers [VALID_REGISTERS];
  static List gadgets_used;
  GADGET *gadget;
  unsigned int cont;
  static int max_stack_used;
  int ret = FALSE;
  int res;

/* Si es la PRIMERA VEZ */
  if ( stack_used == 0 )
  {
  /* Inicializo el RECORD ( Pongo un RECORD INVALIDO ) */
    max_stack_used = 0xffffffff;

  /* Inicializo la lista de REGISTROS VISITADOS */
    memset ( visited_registers , 0 , sizeof ( visited_registers ) );

  /* Inicializo la lista de REGISTROS USADOS */
    gadgets_used.Clear ();
  }

/* Si estoy SUPERANDO el RECORD */
  if ( stack_used >= max_stack_used )
  {
  /* Dejo de BUSCAR */
    return ( FALSE );
  }

/* Si LLEGUE al DESTINO */
  if ( dst_register == src_register )
  {
  /* Inicializo la lista a retornar */   
    gadget_chain.Clear ();

  /* Recorro TODOS los GADGETS que lo COMPONEN */
    for ( cont = gadgets_used.Len () ; cont > 0 ; cont -- )
    {
    /* Agrego el SIGUIENTE GADGET */
      gadget_chain.Add ( gadgets_used.Get ( cont - 1 ) );
    }

  /* Seteo el NUEVO RECORD */
    max_stack_used = stack_used;

  /* Retorno OK */
    return ( TRUE );
  }

/* Marco al REGISTRO como VISITADO */
  visited_registers [ dst_register ] = TRUE;

/* Recorro TODOS los POSIBLES SOURCES */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Si este REGISTRO NO FUE VISITADO */
    if ( visited_registers [ cont ] == FALSE )
    {
    /* Si HAY ALGUNA ASIGNACION entre el DST y el SRC */
      if ( gadget_matrix [dst_register] [cont] != NULL )
      {
      /* Obtengo el GADGET que TIENE esta ASIGNACION */
        gadget = gadget_matrix [dst_register] [cont];

      /* Agrego el GADGET a la lista */  
        gadgets_used.Add ( ( void * ) gadget );

      /* Analizo el PROXIMO CAMINO */
        res = get_gadget_route ( gadget -> stack_used + stack_used , gadget_matrix , cont , src_register , gadget_chain );

      /* Elimino el registro de la lista */  
        gadgets_used.Delete ( gadgets_used.Len () - 1 );

      /* Si OBTUVE un CAMINO */
        if ( res == TRUE )
        {
        /* Ya TENGO UNA SOLUCION */
          ret = TRUE;        
        }
      }
    }
  }

/* Desmarco al REGISTRO como VISITADO */
  visited_registers [ dst_register ] = FALSE;

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

GADGET *get_best_asignation ( List &mov_reg32_reg32_rets , unsigned int dst_register , unsigned int src_register )
{
  GADGET *best_gadget = NULL;
  GADGET *gadget;
  unsigned int cont;

/* Recorro TODOS los GADGETS */
  for ( cont = 0 ; cont < mov_reg32_reg32_rets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE GADGET */
    gadget = ( GADGET * ) mov_reg32_reg32_rets.Get ( cont );

  /* Si este GADGET tiene esta ASIGNACION */
    if ( has_this_asignation ( gadget , dst_register , src_register ) == TRUE )
    {
    /* Si el GADGET tiene ALGUN PUNTAJE */
      if ( gadget -> score > 0 )
      {
      /* Si es la PRIMERA VEZ */
        if ( best_gadget == NULL )
        {
        /* Tomo a este GADGET como el MEJOR */
          best_gadget = gadget;
        }
      /* Si NO es el PRIMERO */
        else
        {
        /* Si este GADGET usa MENOS STACK que el SEGUNDO */
          if ( gadget -> stack_used < best_gadget -> stack_used )
          {
          /* Tengo un NUEVO MEJOR */
            best_gadget = gadget;
          }
        /* Si usan la MISMA CANTIDAD DE STACK */
          else
          {
          /* Si este GADGET PRESERVA MAS REGISTROS */
            if ( is_better_register_preserver ( gadget , best_gadget ) == TRUE )
            {
            /* Tengo un NUEVO MEJOR */
              best_gadget = gadget;
            }
          }
        }
      }
    }
  }

  return ( best_gadget );
}

////////////////////////////////////////////////////////////////////////////////

unsigned int get_number_of_preserved_registers ( List &gadgets )
{
  int registers_to_preserve [ VALID_REGISTERS ];
  unsigned int preserved_registers = 0;
  unsigned int cont, cont2;
  GADGET *gadget;

/* Inicializo el CONTADOR de REGISTROS PRESERVADOS */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Prendo otro registro */
    registers_to_preserve [ cont ] = TRUE;
  }

/* Recorro TODOS los GADGETS */
  for ( cont = 0 ; cont < gadgets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE GADGET */
    gadget = ( GADGET * ) gadgets.Get ( cont );

  /* Chequeo los REGISTROS PRESERVADOS */
    for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
    {
    /* Si este REGISTRO NO ESTA PRESERVADO */
      if ( gadget -> preserved_registers [ cont2 ] == FALSE )
      {
      /* Apago este registro */
        registers_to_preserve [ cont2 ] = FALSE;
      }
    }
  }

/* Cuento la CANTIDAD TOTAL de REGISTROS PRESERVADOS */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Si este REGISTRO es PRESERVADO */
    if ( registers_to_preserve [ cont ] == TRUE )
    {
    /* Incremento la cantidad de REGISTROS PRESERVADOS */
      preserved_registers ++;
    }
  }
  
  return ( preserved_registers );
}

////////////////////////////////////////////////////////////////////////////////

int get_negation_type ( GADGET *super_gadget )
{
  unsigned int cont;
  GADGET *gadget;
  int operation_type = -1;

/* Recorro TODOS los GADGETS que lo COMPONEN */
  for ( cont = 0 ; cont < super_gadget -> gadgets -> Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE GADGET */
    gadget = ( GADGET * ) super_gadget -> gadgets -> Get ( cont );

  /* Si es el GADGET NEGADOR */
    if ( gadget -> operation == OP_REG_TO_NOT_REG || gadget -> operation == OP_REG_TO_NEG_REG )
    {
    /* Retorno la operacion */
      operation_type = gadget -> operation;

    /* Dejo de buscar */
      break;
    }
  }

  return ( operation_type );
}

////////////////////////////////////////////////////////////////////////////////

int add_super_mov_reg32_reg32_rets ( List &mov_reg32_reg32_rets )
{
  List gadget_chain;
  GADGET *gadget_matrix [VALID_REGISTERS] [VALID_REGISTERS];
  GADGET *gadget;
  GADGET *super_gadget;
  unsigned int src, dst;
  unsigned int cont, cont2, cont3;
  int ret = TRUE;

/* Inicializo la matriz de GADGETS */
  memset ( gadget_matrix , 0 , sizeof ( gadget_matrix ) );

/* Recorro TODOS los GADGETS ENCONTRADOS */
  for ( cont = 0 ; cont < mov_reg32_reg32_rets.Len () ; cont ++ )
  {
  /* Levanto el siguiente GADGET */
    gadget = ( GADGET * ) mov_reg32_reg32_rets.Get ( cont );

//    if ( gadget -> address == ( void * ) 0x77c2c84b )
//    {
//      printf ( ">>>>>> ASIGNACION: %s = %s\n" , registers [ gadget -> register_index ] , registers [ gadget -> operand ] );
//    }

  /* Si el gadget TIENE ALGUN PUNTAJE */
    if ( gadget -> score > 0 )
    {
    /* Registros ASIGNADOS */
      dst = gadget -> register_index;
      src = gadget -> operand;

    /* Si este GADGET es MEJOR que el ANTERIOR */
      if ( is_better_gadget ( gadget , gadget_matrix [ dst ] [ src ] ) == TRUE )
      {
      /* Pongo esta ASIGNACION en la MATRIZ */
//        gadget_matrix [ dst ] [ src ].Add ( ( void * ) gadget );
        gadget_matrix [ dst ] [ src ] = gadget;
      }
    }
  }

/* Imprimo la MATRIZ */  
//  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
//  {
//    for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
//    {
//      if ( gadget_matrix [cont] [cont2] != NULL )
//      {
//        printf ( "%.8x " , gadget_matrix [cont] [cont2] -> address );
//      }
//      else
//      {
//       printf ( "%.8x " , NULL );
//      }
//    }
//
//    printf ( "\n" );
//  }

/* Busco el DESTINO para TODOS los REGISTROS */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {  
  /* Busco el SOURCE para TODOS los REGISTROS */
    for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
    {
    /* Si el SOURCE es IGUAL al DESTINO */
      if ( cont == cont2 )
      {
      /* Paso al SIGUIENTE */
        continue;
      }

    /* Si encontre un CAMINO entre el SOURCE y el DESTINO */
      if ( get_gadget_route ( 0 , gadget_matrix , cont , cont2 , gadget_chain ) == TRUE )
      {
//        printf ( "--------> %s = %s\n" , registers [ cont ] , registers [ cont2 ] );
//
//        for ( cont3 = 0 ; cont3 < gadget_chain.Len () ; cont3 ++ )
//        {
//          gadget = ( GADGET * ) gadget_chain.Get ( cont3 );
//          printf ( "xxxx --> %x\n" , gadget -> address );
//        }

      /* Creo un SUPER-GADGET */
//        printf ( "Crear SUPER-GADGET para %s <-- %s con %i gadgets\n" , registers [ cont ] , registers [ cont2 ] , gadget_chain.Len () );
        super_gadget = create_super_mov_reg32_reg32_gadget ( cont , cont2 , gadget_chain );

      /* Agrego el GADGET a la lista de ASIGNACIONES */
        mov_reg32_reg32_rets.Add ( ( void * ) super_gadget );
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int add_super_pop_reg32_rets ( List &mov_reg32_reg32_rets , List &pop_reg32_rets )
{
  List sub_pop_reg32_rets;
  List gadgets;
  GADGET *super_gadget;
  GADGET *best_gadget;
  GADGET *gadget;
  unsigned int cont, cont2;
  unsigned int max_stack;
  int ret = TRUE;

/* Recorro TODOS los REGISTROS VALIDOS */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Inicializo el GADGET a usar como REFERENTE */
    best_gadget = NULL;

  /* Recorro TODOS los GADGETS */
    for ( cont2 = 0 ; cont2 < pop_reg32_rets.Len () ; cont2 ++ )
    {
    /* Levanto el siguiente GADGET */
      gadget = ( GADGET * ) pop_reg32_rets.Get ( cont2 );

    /* Si este GADGET SETEA este REGISTRO */
      if ( gadget -> register_index == cont )
      {
      /* Si el gadget TIENE ALGUN PUNTAJE */
        if ( gadget -> score > 0 )
        {
        /* Si es la PRIMERA VEZ */
          if ( best_gadget == NULL )
          {
          /* Tomo a este GADGET como el MEJOR */
            best_gadget = gadget;
          }
        /* Si NO es el PRIMERO */
          else
          {
          /* Si este GADGET usa MENOS STACK que el SEGUNDO */
            if ( gadget -> stack_used < best_gadget -> stack_used )
            {
            /* Tengo un NUEVO MEJOR */
              best_gadget = gadget;
            }
          /* Si usan la MISMA CANTIDAD DE STACK */
            else
            {
            /* Si este GADGET PRESERVA MAS REGISTROS */
              if ( is_better_register_preserver ( gadget , best_gadget ) == TRUE )
              {
              /* Tengo un NUEVO MEJOR */
                best_gadget = gadget;
              }
            }
          }
        }
      }
    }

  /* Si TENGO el MEJOR GADGET */
    if ( best_gadget != NULL )
    {
    /* Recorro TODOS los REGISTROS VALIDOS */
      for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
      {
      /* Si NO se esta SETEANDO A SI MISMO */
        if ( cont != cont2 )
        {
        /* Busco la MEJOR ASIGNACION */
          gadget = get_best_asignation ( mov_reg32_reg32_rets , cont2 , cont );

        /* Si hay ALGUNA ASIGNACION de este TIPO */
          if ( gadget != NULL )
          {
          /* Lista de GADGETS que la COMPONEN */
            gadgets.Clear ();
            gadgets.Add ( ( void * ) best_gadget );
            gadgets.Add ( ( void * ) gadget );

          /* Creo un SUPER-GADGET con este "POP REG" */
            super_gadget = create_super_pop_reg32_gadget ( cont2 , gadgets );

          /* Agrego el GADGET a la lista de ASIGNACIONES */
            sub_pop_reg32_rets.Add ( ( void * ) super_gadget );
          }
        }
      }
    }
  }

/* Appendeo TODOS los GADGETS ENCONTRADOS */
  pop_reg32_rets.Append ( sub_pop_reg32_rets );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_best_negated_pop_reg32_ret ( int level , int register_to_negate , unsigned int score , List &pop_reg32_rets , List &mov_reg32_reg32_rets , List &negated_rets , List &best_gadgets )
{
  static unsigned int best_score;
  static List gadgets;
  unsigned int cont;
  int ret = FALSE;
  GADGET *gadget;

/* Si estoy en algun NIVEL */
  if ( level > 0 )
  {
  /* Si NO hay chances de SUPERAR el RECORD */
    if ( best_score <= score )
    {
    /* NO puedo seguir */
      return ( FALSE );
    }
  }

/* Si es el PRIMER NIVEL */
  if ( level == 0 )
  {
  /* Inicializo la lista a RETORNAR */
    best_gadgets.Clear ();

  /* Inicializo el RECORD en base a REGISTROS PRESERVADOS */
//    best_score = 0;
    best_score = 0xffffffff;

  /* Busco el MEJOR "POP EAX" */
    for ( cont = 0 ; cont < pop_reg32_rets.Len () ; cont ++ )
    {
    /* Levanto el siguiente "POP EAX" */
      gadget = ( GADGET * ) pop_reg32_rets.Get ( cont );

    /* Si POPEA el valor que quiero NEGAR */
      if ( gadget -> register_index == EAX_REGISTER )
      {
      /* Si el registro tiene ALGUN PUNTAJE */
        if ( gadget -> score > 0 )
        {
        /* Agrego el gadget a la lista */
          gadgets.Add ( ( void * ) gadget );

        /* Paso al SIGUIENTE NIVEL */
          ret = get_best_negated_pop_reg32_ret ( level + 1 , register_to_negate , score + gadget -> stack_used , pop_reg32_rets , mov_reg32_reg32_rets , negated_rets , best_gadgets );

        /* Elimino el gadget a la lista */
          gadgets.Delete ( gadgets.Len () - 1 );
        }
      }
    }
  }
/* Si es el SEGUNDO NIVEL */
  else if ( level == 1 )
  {
  /* Busco el MEJOR "NOT EAX" */
    for ( cont = 0 ; cont < negated_rets.Len () ; cont ++ )
    {
    /* Levanto el siguiente "NOT EAX" */
      gadget = ( GADGET * ) negated_rets.Get ( cont );

    /* Si el registro tiene ALGUN PUNTAJE */
      if ( gadget -> score > 0 )
      {
      /* Agrego el gadget a la lista */
        gadgets.Add ( ( void * ) gadget );

      /* Paso al SIGUIENTE NIVEL */
        ret = get_best_negated_pop_reg32_ret ( level + 1 , register_to_negate , score + gadget -> stack_used , pop_reg32_rets , mov_reg32_reg32_rets , negated_rets , best_gadgets );

      /* Elimino el gadget a la lista */
        gadgets.Delete ( gadgets.Len () - 1 );
      }
    }
  }
/* Si es el TERCER NIVEL */
  else if ( level == 2 )
  {
  /* Si estoy NEGANDO EAX */
    if ( register_to_negate == EAX_REGISTER )
    {
    /* NO hace FALTA NINGUNA ASIGNACION */
    /* Paso al SIGUIENTE NIVEL */
      ret = get_best_negated_pop_reg32_ret ( level + 1 , register_to_negate , score , pop_reg32_rets , mov_reg32_reg32_rets , negated_rets , best_gadgets );
    }
  /* Si estoy NEGANDO EAX */
    else
    {
    /* Busco el MEJOR "MOV EAX,REG" */
      for ( cont = 0 ; cont < mov_reg32_reg32_rets.Len () ; cont ++ )
      {
      /* Levanto el siguiente "MOV REGX,EAX" */
        gadget = ( GADGET * ) mov_reg32_reg32_rets.Get ( cont );

      /* Si MUEVE del REGISTRO al REGISTRO que quiero NEGAR */
//        if ( ( gadget -> register_index == register_to_negate ) && ( gadget -> operand == EAX_REGISTER ) )
        if ( has_this_asignation ( gadget , register_to_negate , EAX_REGISTER ) == TRUE )
        {
//          printf ( "------> asignando %s = %s\n" , registers [ gadget -> register_index ] , registers [ gadget -> operand ] );

        /* Si el registro tiene ALGUN PUNTAJE */
          if ( gadget -> score > 0 )
          {
          /* Agrego el gadget a la lista */
            gadgets.Add ( ( void * ) gadget );

          /* Paso al SIGUIENTE NIVEL */
            get_best_negated_pop_reg32_ret ( level + 1 , register_to_negate , score + gadget -> stack_used , pop_reg32_rets , mov_reg32_reg32_rets , negated_rets , best_gadgets );

          /* Elimino el gadget a la lista */
            gadgets.Delete ( gadgets.Len () - 1 );
          }
        }
      }
    }
  }
/* Si es el CUARTO y ULTIMO NIVEL */
  else if ( level == 3 )
  {
  /* Obtengo un PUNTAJE ESPECIAL por REGISTROS PRESERVADOS */
    score = get_number_of_preserved_registers ( gadgets );

  /* Si es la PRIMERA COMBINACION EXITOSA */
    if ( best_gadgets.Len () == 0 )
    {
    /* Por ahora el MEJOR */
      best_score = score;

    /* Me quedo con esta COMBINACION */
      best_gadgets.Append ( gadgets );

    /* Salgo OK */
      ret = TRUE;
    }
  /* Si hay otro CANDIDATO */
    else
    {
    /* Si esta COMBINACION de GADGETS es MEJOR que la ANTERIOR */
//      if ( score > best_score )
      if ( score < best_score )
      {
      /* Un nuevo MEJOR */
        best_score = score;

      /* Limpio el RECORD ANTERIOR */
        best_gadgets.Clear ();

      /* Me quedo con esta COMBINACION */
        best_gadgets.Append ( gadgets );

      /* Salgo OK */
        ret = TRUE;
      }
    }
  }

/* Si es el PRIMER NIVEL */
  if ( level == 0 )
  {
  /* Si hay ALGUNA COMBINACION VALIDA */
    if ( best_gadgets.Len () > 0 )
    {
    /* Salgo OK */
      ret = TRUE;
    }
  /* Si NO hay COMBINACION VALIDA */
    else
    {
    /* Salgo con ERROR */
      ret = FALSE;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_best_negated_pop_reg32_ret2 ( int level , int register_to_negate , unsigned int score , List &pop_reg32_rets , List &mov_reg32_reg32_rets , List &negated_rets , List &best_gadgets )
{
  static unsigned int best_score;
  static List gadgets;
  unsigned int cont;
  int ret = FALSE;
  GADGET *gadget;

/* Si estoy en algun NIVEL */
  if ( level > 0 )
  {
  /* Si NO hay chances de SUPERAR el RECORD */
    if ( best_score <= score )
    {
    /* NO puedo seguir */
      return ( FALSE );
    }
  }

/* Si es el PRIMER NIVEL */
  if ( level == 0 )
  {
  /* Inicializo la lista a RETORNAR */
    best_gadgets.Clear ();

  /* Inicializo el RECORD en base a REGISTROS PRESERVADOS */
//    best_score = 0;
    best_score = 0xffffffff;

  /* Busco el MEJOR "POP REG32" */
    for ( cont = 0 ; cont < pop_reg32_rets.Len () ; cont ++ )
    {
    /* Levanto el siguiente "POP REG" */
      gadget = ( GADGET * ) pop_reg32_rets.Get ( cont );

    /* Si POPEA el valor que quiero NEGAR */
      if ( gadget -> register_index == register_to_negate )
      {
      /* Si el registro tiene ALGUN PUNTAJE */
        if ( gadget -> score > 0 )
        {
        /* Agrego el gadget a la lista */
          gadgets.Add ( ( void * ) gadget );

        /* Paso al SIGUIENTE NIVEL */
          ret = get_best_negated_pop_reg32_ret ( level + 1 , register_to_negate , score + gadget -> stack_used , pop_reg32_rets , mov_reg32_reg32_rets , negated_rets , best_gadgets );

        /* Elimino el gadget a la lista */
          gadgets.Delete ( gadgets.Len () - 1 );
        }
      }
    }
  }
/* Si es el SEGUNDO NIVEL */
  else if ( level == 1 )
  {
  /* Si es un "POP EAX" */
    if ( register_to_negate == EAX_REGISTER )
    {
    /* NO hace FALTA NINGUNA ASIGNACION */
    /* Paso al SIGUIENTE NIVEL */
      ret = get_best_negated_pop_reg32_ret ( level + 1 , register_to_negate , score , pop_reg32_rets , mov_reg32_reg32_rets , negated_rets , best_gadgets );
    }
  /* Si NO es un "POP EAX" */
    else
    {
    /* Busco el MEJOR "MOV EAX,REGX" */
      for ( cont = 0 ; cont < mov_reg32_reg32_rets.Len () ; cont ++ )
      {
      /* Levanto el siguiente "MOV EAX,REG" */
        gadget = ( GADGET * ) mov_reg32_reg32_rets.Get ( cont );

      /* Si MUEVE del REGISTRO al REGISTRO que quiero NEGAR */
        if ( ( gadget -> register_index == EAX_REGISTER ) && ( gadget -> operand == register_to_negate ) )
        {
        /* Si el registro tiene ALGUN PUNTAJE */
          if ( gadget -> score > 0 )
          {
          /* Agrego el gadget a la lista */
            gadgets.Add ( ( void * ) gadget );

          /* Paso al SIGUIENTE NIVEL */
            get_best_negated_pop_reg32_ret ( level + 1 , register_to_negate , score + gadget -> stack_used , pop_reg32_rets , mov_reg32_reg32_rets , negated_rets , best_gadgets );

          /* Elimino el gadget a la lista */
            gadgets.Delete ( gadgets.Len () - 1 );
          }
        }
      }
    }
  }
/* Si es el TERCER NIVEL */
  else if ( level == 2 )
  {
  /* Busco el MEJOR "NOT EAX" */
    for ( cont = 0 ; cont < negated_rets.Len () ; cont ++ )
    {
    /* Levanto el siguiente "NOT EAX" */
      gadget = ( GADGET * ) negated_rets.Get ( cont );

    /* Si el registro tiene ALGUN PUNTAJE */
      if ( gadget -> score > 0 )
      {
      /* Agrego el gadget a la lista */
        gadgets.Add ( ( void * ) gadget );

      /* Paso al SIGUIENTE NIVEL */
        ret = get_best_negated_pop_reg32_ret ( level + 1 , register_to_negate , score + gadget -> stack_used , pop_reg32_rets , mov_reg32_reg32_rets , negated_rets , best_gadgets );

      /* Elimino el gadget a la lista */
        gadgets.Delete ( gadgets.Len () - 1 );
      }
    }
  }
/* Si es el CUARTO NIVEL */
  else if ( level == 3 )
  {
  /* Si estoy NEGANDO EAX */
    if ( register_to_negate == EAX_REGISTER )
    {
    /* NO hace FALTA NINGUNA ASIGNACION */
    /* Paso al SIGUIENTE NIVEL */
      ret = get_best_negated_pop_reg32_ret ( level + 1 , register_to_negate , score , pop_reg32_rets , mov_reg32_reg32_rets , negated_rets , best_gadgets );
    }
  /* Si estoy NEGANDO EAX */
    else
    {
    /* Busco el MEJOR "MOV EAX,REG" */
      for ( cont = 0 ; cont < mov_reg32_reg32_rets.Len () ; cont ++ )
      {
      /* Levanto el siguiente "MOV REGX,EAX" */
        gadget = ( GADGET * ) mov_reg32_reg32_rets.Get ( cont );

      /* Si MUEVE del REGISTRO al REGISTRO que quiero NEGAR */
//        if ( ( gadget -> register_index == register_to_negate ) && ( gadget -> operand == EAX_REGISTER ) )
        if ( has_this_asignation ( gadget , register_to_negate , EAX_REGISTER ) == TRUE )
        {
//          printf ( "------> asignando %s = %s\n" , registers [ gadget -> register_index ] , registers [ gadget -> operand ] );

        /* Si el registro tiene ALGUN PUNTAJE */
          if ( gadget -> score > 0 )
          {
          /* Agrego el gadget a la lista */
            gadgets.Add ( ( void * ) gadget );

          /* Paso al SIGUIENTE NIVEL */
            get_best_negated_pop_reg32_ret ( level + 1 , register_to_negate , score + gadget -> stack_used , pop_reg32_rets , mov_reg32_reg32_rets , negated_rets , best_gadgets );

          /* Elimino el gadget a la lista */
            gadgets.Delete ( gadgets.Len () - 1 );
          }
        }
      }
    }
  }
/* Si es el QUINTO y ULTIMO NIVEL */
  else if ( level == 4 )
  {
  /* Obtengo un PUNTAJE ESPECIAL por REGISTROS PRESERVADOS */
    score = get_number_of_preserved_registers ( gadgets );

  /* Si es la PRIMERA COMBINACION EXITOSA */
    if ( best_gadgets.Len () == 0 )
    {
    /* Por ahora el MEJOR */
      best_score = score;

    /* Me quedo con esta COMBINACION */
      best_gadgets.Append ( gadgets );

    /* Salgo OK */
      ret = TRUE;
    }
  /* Si hay otro CANDIDATO */
    else
    {
    /* Si esta COMBINACION de GADGETS es MEJOR que la ANTERIOR */
//      if ( score > best_score )
      if ( score < best_score )
      {
      /* Un nuevo MEJOR */
        best_score = score;

      /* Limpio el RECORD ANTERIOR */
        best_gadgets.Clear ();

      /* Me quedo con esta COMBINACION */
        best_gadgets.Append ( gadgets );

      /* Salgo OK */
        ret = TRUE;
      }
    }
  }

/* Si es el PRIMER NIVEL */
  if ( level == 0 )
  {
  /* Si hay ALGUNA COMBINACION VALIDA */
    if ( best_gadgets.Len () > 0 )
    {
    /* Salgo OK */
      ret = TRUE;
    }
  /* Si NO hay COMBINACION VALIDA */
    else
    {
    /* Salgo con ERROR */
      ret = FALSE;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void add_super_negated_pop_reg32_rets ( List &pop_reg32_rets , List &mov_reg32_reg32_rets , List &negated_rets )
{
  List best_gadgets;
  List simple_gadgets;
  List super_bypasses;
  List bypasses;
  GADGET *super_gadget;
  GADGET *gadget;
  unsigned int cont, cont2;
  int ret;

/* Busco el REGISTRO a NEGAR */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Busco el MEJOR "POP 'NOT (REG)'" */
    ret = get_best_negated_pop_reg32_ret ( 0 , cont , 0 , pop_reg32_rets , mov_reg32_reg32_rets , negated_rets , best_gadgets );

  /* Si HAY un SUPER-GADGET VALIDO */
    if ( ret == TRUE )
    {
//      printf ( "hay solucion para %s !\n" , registers [ cont ] );

    /* Creo un SUPER-GADGET */
      super_gadget = create_super_negator_pop_reg32_gadget ( cont , best_gadgets );

    /* Agrego el GADGET a la LISTA */
      pop_reg32_rets.Add ( ( void * ) super_gadget );

    /* Obtengo TODOS los GADGETS SIMPLES */
      get_simple_gadgets ( best_gadgets , simple_gadgets );

    /* Recorro los GADGETS OBTENIDOS */
      for ( cont2 = 0 ; cont2 < simple_gadgets.Len () ; cont2 ++ )
      {
      /* Levanto el SIGUIENTE GADGET */
        gadget = ( GADGET * ) simple_gadgets.Get ( cont2 );

      /* Imprimo la direccion */
//        printf ( "-> %x\n" , gadget -> address );
      }

    /* Obtengo TODOS los BYPASSES para este GADGET */
      get_super_bypasses ( super_gadget , mov_reg32_reg32_rets , bypasses );
      super_bypasses.Append ( bypasses );
    }
  } 

/* Agrego los "POP 'NOT (REG)'" con BYPASSES */
  pop_reg32_rets.Append ( super_bypasses );

//  printf ( "gadgets salvados = %i\n" , super_bypasses.Len () );

//  for ( cont = 0 ; cont < super_bypasses.Len () ; cont ++ )
//  {
//  /* Levanto el SIGUIENTE GADGET */
//    super_gadget = ( GADGET * ) super_bypasses.Get ( cont );
//
//    simple_gadgets.Clear ();
//    decompose_gadget ( super_gadget , simple_gadgets );
//
//    printf ( "---------------\n" );
//
//    for ( cont2 = 0 ; cont2 < simple_gadgets.Len () ; cont2 ++ )
//    {
//      gadget = ( GADGET * ) simple_gadgets.Get ( cont2 );
//      printf ( "* %x\n" , gadget -> address );
//    }
//  }
}

////////////////////////////////////////////////////////////////////////////////

void add_super_incrementors_pop_reg32_rets ( List &pop_reg32_rets , List &incrementor_rets )
{
  List gadgets;
  GADGET *incrementor_ret;
  GADGET *pop_reg32_ret;
  GADGET *super_gadget;
  unsigned int cont, cont2;

/* Recorro TODOS los GADGETS INCREMENTADORES */
  for ( cont = 0 ; cont < incrementor_rets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE GADGET */
    incrementor_ret = ( GADGET * ) incrementor_rets.Get ( cont );

  /* Recorro TODOS los GADGETS POPEADORES */
    for ( cont2 = 0 ; cont2 < pop_reg32_rets.Len () ; cont2 ++ )
    {
    /* POPEO el REGISTRO a INCREMENTAR */
      pop_reg32_ret = ( GADGET * ) pop_reg32_rets.Get ( cont2 );

    /* Si POPEA el REGISTRO INCREMENTADO */
      if ( pop_reg32_ret -> register_index == incrementor_ret -> register_index )
      {
      /* Armo la lista de GADGETS que lo COMPONEN */
        gadgets.Add ( ( void * ) pop_reg32_ret );
        gadgets.Add ( ( void * ) incrementor_ret );
        gadgets.Add ( ( void * ) incrementor_ret );

      /* Creo un SUPER-GADGET */
        super_gadget = create_super_negator_pop_reg32_gadget ( pop_reg32_ret -> register_index , gadgets );

      /* Marco al GADGET como NEGADO por INCREMENTACION */
        super_gadget -> negator_by_incrementation = TRUE;

      /* Agrego el GADGET a la LISTA */
        pop_reg32_rets.Add ( ( void * ) super_gadget );

      /* Dejo de buscar */
        return;
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

int get_mov_reg32_reg32_rets ( int new_search , void *module_base , void *real_module_base , char *settings , char *snapshot , List &invalid_chars , List &mov_reg32_reg32_rets )
{
  List super_mov_reg32_reg32_rets;
  char *objective = "objectiveX.txt";
  char txtfile [ 4096 ];
  char cmd [ 4096 ];
  unsigned int cont;
  int ret = TRUE;

/* Armo el nombre de los files */
  snprintf ( txtfile , sizeof ( txtfile ) , "%s.%s" , snapshot , "mov_reg32_reg32_rets.txt" );

/* Si tengo que hacer una NUEVA BUSQUEDA */
  if ( new_search == TRUE )
  {
  /* Si hay SETTINGS INICIALES */
    if ( settings != NULL )
    {
    /* Genero el "OBJECTIVE.TXT" */
      generate_file ( settings , objective );
    }
  /* Si NO hay SETTINGS */
    else
    {
    /* Creo el file donde va el OBJETIVO de BUSQUEDA */
      sprintf ( cmd , "echo # finding ... > %s" , objective );
      system ( cmd );

    /* Seteo las EFLAGS para BAJAR el TIEMPO de BUSQUEDA */
      sprintf ( cmd , "echo eflags = 0x202 >> %s" , objective );
      system ( cmd );
    }

  /* Pongo el OBJETIVO */
    sprintf ( cmd , "echo reg32==reg32 >> %s" , objective );
    system ( cmd );

  /* Busco los GADGETS */
    snprintf ( cmd , sizeof ( cmd ) , "agafi -s %s %s %s" , snapshot , objective , txtfile );
    system ( cmd );
  }

/* Parseo la salida */
  get_gadgets ( txtfile , module_base , real_module_base , invalid_chars , mov_reg32_reg32_rets );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_mov_reg32_creg32_rets ( int new_search , void *module_base , void *real_module_base , char *settings , char *snapshot , List &invalid_chars , List &mov_reg32_creg32_rets )
{
  char *objective = "objectiveX.txt";
  char sub_txtfile [ 4096 ];
  char txtfile [ 4096 ];
  char cmd [ 4096 ];
  unsigned int cont;
  int ret = TRUE;

/* Armo el nombre de los files */
  snprintf ( txtfile , sizeof ( txtfile ) , "%s.%s" , snapshot , "mov_reg32_creg32_rets.txt" );
  snprintf ( sub_txtfile , sizeof ( sub_txtfile ) , "%s.%s" , snapshot , "sub_mov_reg32_creg32_rets.txt" );

/* Si tengo que hacer una NUEVA BUSQUEDA */
  if ( new_search == TRUE )
  {
  /* Creo un OUTPUT nuevo */
    snprintf ( cmd , sizeof ( cmd ) , "del %s" , txtfile );
    system ( cmd );

  /* Hago una BUSQUEDA por CADA REGISTRO */
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Si NO quiero buscar para este REGISTRO */
      if ( cont == EBP_REGISTER || cont == ESP_REGISTER || cont == EIP_REGISTER )
      {
      /* Paso al siguiente */
        continue;
      }

    /* Si hay SETTINGS INICIALES */
      if ( settings != NULL )
      {
      /* Genero el "OBJECTIVE.TXT" */
        generate_file ( settings , objective );
      }
    /* Si NO hay SETTINGS */
      else
      {
      /* Creo el file donde va el OBJETIVO de BUSQUEDA */
        sprintf ( cmd , "echo # finding ... > %s" , objective );
        system ( cmd );

      /* Seteo las EFLAGS para BAJAR el TIEMPO de BUSQUEDA */
        sprintf ( cmd , "echo eflags = 0x202 >> %s" , objective );
        system ( cmd );
      }

    /* Pongo el OBJETIVO */
      sprintf ( cmd , "echo reg32==[%s+0x00] >> %s" , registers [ cont ] , objective );
      system ( cmd );

    /* Busco los GADGETS */
      snprintf ( cmd , sizeof ( cmd ) , "agafi -s %s %s %s" , snapshot , objective , sub_txtfile );
      system ( cmd );

    /* Appendeo el resultado al file de gadgets COMPLETO */
      snprintf ( cmd , sizeof ( cmd ) , "type %s >> %s" , sub_txtfile , txtfile );
      system ( cmd );
    }
  }

/* Parseo la salida */
  get_gadgets ( txtfile , module_base , real_module_base , invalid_chars , mov_reg32_creg32_rets );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_jmp_esps ( int new_search , void *module_base , void *real_module_base , char *settings , char *snapshot , List &invalid_chars , List &jmp_esps )
{
  char *objective = "objectiveX.txt";
  char txtfile [ 4096 ];
  char cmd [ 4096 ];
  int ret = TRUE;

/* Armo el nombre de los files */
  snprintf ( txtfile , sizeof ( txtfile ) , "%s.%s" , snapshot , "jmp_esps.txt" );

/* Si tengo que hacer una NUEVA BUSQUEDA */
  if ( new_search == TRUE )
  {
  /* Si hay SETTINGS INICIALES */
    if ( settings != NULL )
    {
    /* Genero el "OBJECTIVE.TXT" */
      generate_file ( settings , objective );
    }
  /* Si NO hay SETTINGS */
    else
    {
    /* Creo el file donde va el OBJETIVO de BUSQUEDA */
      sprintf ( cmd , "echo # finding ... > %s" , objective );
      system ( cmd );

    /* Seteo las EFLAGS para BAJAR el TIEMPO de BUSQUEDA */
      sprintf ( cmd , "echo eflags = 0x202 >> %s" , objective );
      system ( cmd );
    }

  /* Pongo el OBJETIVO */
    sprintf ( cmd , "echo eip==esp >> %s" , objective );
    system ( cmd );

  /* Busco los GADGETS */
    snprintf ( cmd , sizeof ( cmd ) , "agafi -s %s %s %s" , snapshot , objective , txtfile );
    system ( cmd );
  }

/* Parseo la salida BINARIA */
  get_gadgets ( txtfile , module_base , real_module_base , invalid_chars , jmp_esps );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void depure_gadget_list ( List &gadgets )
{
  GADGET *gadget;
  unsigned int cont;

/* Recorro TODOS los GADGETS */
  for ( cont = 0 ; cont < gadgets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE GADGET */
    gadget = ( GADGET * ) gadgets.Get ( cont );

  /* Si el gadget NO TIENE PUNTAJE */
    if ( gadget -> score == 0 )
    {
    /* Elimino el GADGET de la LISTA */
      gadgets.Delete ( cont );

    /* Compenso la extraccion */
      cont --;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

int sort_incrementor_rets ( List &incrementor_rets )
{
  GADGET *gadget;
  List scores;
  unsigned int cont;
  unsigned int cont2;
  unsigned int score;
  int invalid_gadget;
  int ret = TRUE;

/* Recorro TODOS los GADGETS ENCONTRADOS */
  for ( cont = 0 ; cont < incrementor_rets.Len () ; cont ++ )
  {
  /* Levanto el siguiente GADGET */
    gadget = ( GADGET * ) incrementor_rets.Get ( cont );

  /* Puntaje por DEFAULT */
    score = 0;

  /* Por si TIENE algo que NO ME PERMITE USARLO */
    invalid_gadget = FALSE;

  /* Si NO usa JUMP CONDICIONALES */
    if ( gadget -> conditional_jumps == 0 )
    {
    /* Si usa un RET comun */
      if ( gadget -> ending_type == RET_ENDING )
      {
      /* Incremento el PUNTAJE */
        score += 400000;
      }
    /* Si usa un RETN */
      else if ( gadget -> ending_type == RETN_ENDING )
      {
      /* Incremento el PUNTAJE */
        score += 300000;
      }
    }

  /* Si obtuvo ALGUN PUNTAJE */
    if ( score > 0 )
    {
    /* Recorro todos los REGISTROS PRESERVADOS */
      for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
      {
      /* Si este registro ESTA PRESERVADO */
        if ( gadget -> preserved_registers [ cont2 ] == TRUE )
        {
        /* Le sumo un PLUS */
          score += 1000;
        }
      }
    }

  /* Si NO obtuvo NINGUN PUNTAJE */
    if ( score == 0 )
    {
    /* Si NO usa JUMP CONDICIONALES */
      if ( gadget -> conditional_jumps == 0 )
      {
      /* Le doy PRIORIDAD a los GADGETS que NO usan JUMP CONDICIONALES */
        score += 100;
      }
    }

  /* Si el GADGET tienen PUNTAJE */
    if ( score > 0 )
    {
    /* Lo PREMIO si usa MENOS INSTRUCCIONES */
      score += ( 100 - gadget -> instructions -> Len () );
    }

  /* Si NO termina con un "RET" o un "RETN" */
    if ( ( gadget -> ending_type != RET_ENDING ) && ( gadget -> ending_type != RETN_ENDING ) )
    {
    /* NO puedo usar este gadget */
      invalid_gadget = TRUE;
    }

  /* Si el GADGET es INVALIDO */
    if ( invalid_gadget == TRUE )
    {
    /* NO lo voy a USAR */
      score = 0;
    }

  /* Puntaje asignado al GADGET */
    scores.Add ( ( void * ) ~ score );

  /* Seteo el PUNTAJE al GADGET */
    gadget -> score = score;
  }

/* Ordeno los gadgets en BASE al PUNTAJE */ 
  scores.SortCouple ( incrementor_rets );

/* Elimino los GADGETS que NO CALIFICAN */
  depure_gadget_list ( incrementor_rets );

/* Si hay ALGUN GADGET */
  if ( incrementor_rets.Len () > 0 )
  {
  /* Obtengo el MEJOR gadget */
    gadget = ( GADGET * ) incrementor_rets.Get ( 0 );

  /* Elimino TODOS los DEMAS */
    incrementor_rets.Clear ();

  /* Retorno el MEJOR */
    incrementor_rets.Add ( ( void * ) gadget );
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int sort_negator_rets ( List &negator_rets )
{
  GADGET *gadget;
  List scores;
  unsigned int cont;
  unsigned int cont2;
  unsigned int score;
  int invalid_gadget;
  int ret = TRUE;

/* Recorro TODOS los GADGETS ENCONTRADOS */
  for ( cont = 0 ; cont < negator_rets.Len () ; cont ++ )
  {
  /* Levanto el siguiente GADGET */
    gadget = ( GADGET * ) negator_rets.Get ( cont );

  /* Puntaje por DEFAULT */
    score = 0;

  /* Por si TIENE algo que NO ME PERMITE USARLO */
    invalid_gadget = FALSE;

  /* Si NO usa JUMP CONDICIONALES */
    if ( gadget -> conditional_jumps == 0 )
    {
    /* Si usa un RET comun */
      if ( gadget -> ending_type == RET_ENDING )
      {
      /* Incremento el PUNTAJE */
        score += 400000;
      }
    /* Si usa un RETN */
      else if ( gadget -> ending_type == RETN_ENDING )
      {
      /* Incremento el PUNTAJE */
        score += 300000;
      }
    }

  /* Si obtuvo ALGUN PUNTAJE */
    if ( score > 0 )
    {
    /* Recorro todos los REGISTROS PRESERVADOS */
      for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
      {
      /* Si este registro ESTA PRESERVADO */
        if ( gadget -> preserved_registers [ cont2 ] == TRUE )
        {
        /* Le sumo un PLUS */
          score += 1000;
        }
      }
    }

  /* Si NO obtuvo NINGUN PUNTAJE */
    if ( score == 0 )
    {
    /* Si NO usa JUMP CONDICIONALES */
      if ( gadget -> conditional_jumps == 0 )
      {
      /* Le doy PRIORIDAD a los GADGETS que NO usan JUMP CONDICIONALES */
        score += 100;
      }
    }

  /* Si el GADGET tienen PUNTAJE */
    if ( score > 0 )
    {
    /* Lo PREMIO si usa MENOS INSTRUCCIONES */
      score += ( 100 - gadget -> instructions -> Len () );
    }

  /* Si NO termina con un "RET" o un "RETN" */
    if ( ( gadget -> ending_type != RET_ENDING ) && ( gadget -> ending_type != RETN_ENDING ) )
    {
    /* NO puedo usar este gadget */
      invalid_gadget = TRUE;
    }

  /* Si el GADGET es INVALIDO */
    if ( invalid_gadget == TRUE )
    {
    /* NO lo voy a USAR */
      score = 0;
    }

  /* Puntaje asignado al GADGET */
    scores.Add ( ( void * ) ~ score );

  /* Seteo el PUNTAJE al GADGET */
    gadget -> score = score;
  }

/* Ordeno los gadgets en BASE al PUNTAJE */ 
  scores.SortCouple ( negator_rets );

/* Elimino los GADGET que NO CALIFICAN */
  depure_gadget_list ( negator_rets );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int sort_pushad_rets ( List &pushad_rets )
{
  GADGET *gadget;
  List scores;
  unsigned int cont;
  unsigned int cont2;
  unsigned int score;
  int ret = TRUE;

/* Recorro TODOS los GADGETS ENCONTRADOS */
  for ( cont = 0 ; cont < pushad_rets.Len () ; cont ++ )
  {
  /* Levanto el siguiente GADGET */
    gadget = ( GADGET * ) pushad_rets.Get ( cont );

  /* Puntaje por DEFAULT */
    score = 0;

  /* Si EBP quedo en el TOPE del STACK (PUSHAD/RET 4) */
    if ( ( gadget -> ending_type == RETN_ENDING ) && ( gadget -> register_index == EBP_REGISTER ) )
    {
    /* Si NO usa JUMP CONDICIONALES */
      if ( gadget -> conditional_jumps == 0 )
      {
      /* Si el STACK USADO es -0x18 */
        if ( gadget -> stack_used == -0x18 )
        {
        /* Tengo un "PUSHAD/RET 4" limpito */
          score += 200000;
        }
      /* Si el STACK USADO es distinto de -0x18 */
        else
        {
        /* Tengo un "PUSHAD/RET 4" con ALGO DE RUIDO */
          score += 100000;
        }
      }
    }
  /* Si ESI quedo en el TOPE del STACK (PUSHAD/RET) */
    else if ( ( gadget -> ending_type == RET_ENDING ) && ( gadget -> register_index == ESI_REGISTER ) )
    {
    /* Si NO usa JUMP CONDICIONALES */
      if ( gadget -> conditional_jumps == 0 )
      {
      /* Si el STACK USADO es -0x1c */
        if ( gadget -> stack_used == -0x1c )
        {
        /* Tengo un "PUSHAD/RET" limpito */
          score += 175000;
        }
      /* Si el STACK USADO es distinto de -0x1c */
        else
        {
        /* Tengo un "PUSHAD/RET" con ALGO DE RUIDO */
          score += 75000;
        }
      }
    }
  /* Si EBP quedo en el TOPE del STACK (PUSHAD/RETF) */
    else if ( ( gadget -> ending_type == RETF_ENDING ) && ( gadget -> register_index == EBP_REGISTER ) )
    {
    /* Si NO usa JUMP CONDICIONALES */
      if ( gadget -> conditional_jumps == 0 )
      {
      /* Si el STACK USADO es -0x18 */
        if ( gadget -> stack_used == -0x18 )
        {
        /* Tengo un "PUSHAD/RETF" limpito */
          score += 150000;
        }
      /* Si el STACK USADO es distinto de -0x18 */
        else
        {
        /* Tengo un "PUSHAD/RETF" con ALGO DE RUIDO */
          score += 50000;
        }
      }
    }

  /* Si obtuvo ALGUN PUNTAJE */
    if ( score > 0 )
    {
    /* Recorro todos los REGISTROS PRESERVADOS */
      for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
      {
      /* Si este registro ESTA PRESERVADO */
        if ( gadget -> preserved_registers [ cont2 ] == TRUE )
        {
        /* Le sumo un PLUS */
          score += 1000;
        }
      }
    }

  /* Si NO obtuvo NINGUN PUNTAJE */
    if ( score == 0 )
    {
    /* Si NO usa JUMP CONDICIONALES */
      if ( gadget -> conditional_jumps == 0 )
      {
      /* Le doy PRIORIDAD a los GADGETS que NO usan JUMP CONDICIONALES */
        score += 100;
      }
    }

  /* Si el GADGET tienen PUNTAJE */
    if ( score > 0 )
    {
    /* Lo PREMIO si usa MENOS INSTRUCCIONES */
      score += ( 100 - gadget -> instructions -> Len () );
    }

  /* Puntaje asignado al GADGET */
    scores.Add ( ( void * ) ~ score );

  /* Seteo el PUNTAJE al GADGET */
    gadget -> score = score;
  }

/* Ordeno los gadgets en BASE al PUNTAJE */ 
  scores.SortCouple ( pushad_rets );

/* Elimino los GADGETS que NO CALIFICAN */
  depure_gadget_list ( pushad_rets );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int sort_pop_reg32_rets ( List &pop_reg32_rets )
{
  List best_gadgets;
  List scores;
  GADGET *gadget;
  unsigned int cont;
  unsigned int cont2;
  unsigned int score;
  int invalid_gadget;
  int ret = TRUE;

/* Recorro TODOS los GADGETS ENCONTRADOS */
  for ( cont = 0 ; cont < pop_reg32_rets.Len () ; cont ++ )
  {
  /* Levanto el siguiente GADGET */
    gadget = ( GADGET * ) pop_reg32_rets.Get ( cont );

  /* Puntaje por DEFAULT */
    score = 0;

  /* Por si TIENE algo que NO ME PERMITE USARLO */
    invalid_gadget = FALSE;

  /* Si NO usa JUMP CONDICIONALES */
    if ( gadget -> conditional_jumps == 0 )
    {
    /* Obtengo el PUNTAJE en base al STACK USADO */
      score = 1000000 - ( gadget -> stack_used * 10000 );

    /* Recorro todos los REGISTROS PRESERVADOS */
      for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
      {
      /* Si este registro ESTA PRESERVADO */
        if ( gadget -> preserved_registers [ cont2 ] == TRUE )
        {
        /* Le sumo un PLUS */
          score += 1000;
//          score -= 1000; // Para PROBAR los PEORES
        }
      }

    /* Lo PREMIO si usa MENOS INSTRUCCIONES */
      score += ( 100 - gadget -> instructions -> Len () );
    }

  /* Si NO termina con un "RET ALGO" */
    if ( gadget -> ending_type == OTHER_ENDING )
    {
    /* NO puedo usar este gadget */
      invalid_gadget = TRUE;
    }

  /* Si el STACK USADO es INVALIDO */
    if ( gadget -> stack_used < 8 || gadget -> stack_used > 0x80 )
    {
    /* NO puedo usar este gadget */
      invalid_gadget = TRUE;
    }

  /* Si el GADGET es INVALIDO */
    if ( invalid_gadget == TRUE )
    {
    /* NO lo voy a USAR */
      score = 0;
    }

  /* Puntaje asignado al GADGET */
    scores.Add ( ( void * ) ~ score );

  /* Seteo el PUNTAJE al GADGET */
    gadget -> score = score;
  }

/* Ordeno los gadgets en BASE al PUNTAJE */ 
  scores.SortCouple ( pop_reg32_rets );

/* Elimino los GADGETS que NO CALIFICAN */
  depure_gadget_list ( pop_reg32_rets );

/* Recorro TODOS los REGISTROS VALIDOS */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Recorro TODOS los GADGETS encontrados */
    for ( cont2 = 0 ; cont2 < pop_reg32_rets.Len () ; cont2 ++ )
    {
    /* Levanto el SIGUIENTE GADGET */    
      gadget = ( GADGET * ) pop_reg32_rets.Get ( cont2 );

    /* Si este gadget SETEA el REGISTRO buscado */
      if ( gadget -> register_index == cont )
      {
      /* Me quedo con el MEJOR GADGET */
        best_gadgets.Add ( ( void * ) gadget );

      /* Paso al SIGUIENTE REGISTRO */
        break;
      }
    }
  }

/* Armo la LISTA FINAL */
  pop_reg32_rets.Clear ();
  pop_reg32_rets.Append ( best_gadgets );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int sort_mov_reg32_reg32_rets ( List &mov_reg32_reg32_rets )
{  
  GADGET *gadget;
  List scores;
  unsigned int cont;
  unsigned int cont2;
  unsigned int score;
  int invalid_gadget;
  int ret = TRUE;

/* Recorro TODOS los GADGETS ENCONTRADOS */
  for ( cont = 0 ; cont < mov_reg32_reg32_rets.Len () ; cont ++ )
  {
  /* Levanto el siguiente GADGET */
    gadget = ( GADGET * ) mov_reg32_reg32_rets.Get ( cont );

  /* Puntaje por DEFAULT */
    score = 0;

  /* Por si TIENE algo que NO ME PERMITE USARLO */
    invalid_gadget = FALSE;

  /* Si NO usa JUMP CONDICIONALES */
    if ( gadget -> conditional_jumps == 0 )
    {
    /* Si usa un RET comun */
      if ( ( gadget -> ending_type == RET_ENDING ) && ( gadget -> stack_used == 0x4 ) )
      {
      /* Incremento el PUNTAJE */
        score += 400000;
      }
    /* Si usa un RETN */
      else if ( ( gadget -> ending_type == RETN_ENDING ) && ( ( gadget -> stack_used == 0x4 ) || ( gadget -> stack_used == 0x8 ) ) )
      {
      /* Incremento el PUNTAJE */
        score += 300000;
      }
    /* Si usa un RETF */
      else if ( ( gadget -> ending_type == RETF_ENDING ) && ( gadget -> stack_used == 0x8 ) )
      {
      /* Incremento el PUNTAJE */
        score += 200000;
      }
    /* Si usa un IRETD */
      else if ( ( gadget -> ending_type == IRET_ENDING ) && ( gadget -> stack_used == 0xc ) )
      {
      /* Incremento el PUNTAJE */
        score += 100000;
      }
    }

  /* Si obtuvo ALGUN PUNTAJE */
    if ( score > 0 )
    {
    /* Recorro todos los REGISTROS PRESERVADOS */
      for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
      {
      /* Si este registro ESTA PRESERVADO */
        if ( gadget -> preserved_registers [ cont2 ] == TRUE )
        {
        /* Le sumo un PLUS */
          score += 1000;
        }
      }
    }

  /* Si NO obtuvo NINGUN PUNTAJE */
    if ( score == 0 )
    {
    /* Si NO usa JUMP CONDICIONALES */
      if ( gadget -> conditional_jumps == 0 )
      {
      /* Le doy PRIORIDAD a los GADGETS que NO usan JUMP CONDICIONALES */
        score += 100;
      }
    }

  /* Si el GADGET tienen PUNTAJE */
    if ( score > 0 )
    {
    /* Lo PREMIO si usa MENOS INSTRUCCIONES */
      score += ( 100 - gadget -> instructions -> Len () );
    }

  /* Si NO termina con un "RET ALGO" */
    if ( gadget -> ending_type == OTHER_ENDING )
    {
    /* NO puedo usar este gadget */
      invalid_gadget = TRUE;
    }

  /* Si el GADGET usa MUCHO STACK */
    if ( gadget -> stack_used > 0x80 )
    {
    /* NO puedo usar este gadget */
      invalid_gadget = TRUE;
    }

  /* Si el GADGET es INVALIDO */
    if ( invalid_gadget == TRUE )
    {
    /* NO lo voy a USAR */
      score = 0;
    }

  /* Puntaje asignado al GADGET */
    scores.Add ( ( void * ) ~ score );

  /* Seteo el PUNTAJE al GADGET */
    gadget -> score = score;
  }

/* Ordeno los gadgets en BASE al PUNTAJE */ 
  scores.SortCouple ( mov_reg32_reg32_rets );

/* Elimino los GADGETS que NO CALIFICAN */
  depure_gadget_list ( mov_reg32_reg32_rets );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int sort_mov_reg32_creg32_rets ( List &mov_reg32_creg32_rets )
{
  GADGET *gadget;
  List scores;
  unsigned int cont;
  unsigned int cont2;
  unsigned int score;
  int invalid_gadget;
  int ret = TRUE;

/* Recorro TODOS los GADGETS ENCONTRADOS */
  for ( cont = 0 ; cont < mov_reg32_creg32_rets.Len () ; cont ++ )
  {
  /* Levanto el siguiente GADGET */
    gadget = ( GADGET * ) mov_reg32_creg32_rets.Get ( cont );

  /* Puntaje por DEFAULT */
    score = 0;

  /* Por si TIENE algo que NO ME PERMITE USARLO */
    invalid_gadget = FALSE;

  /* Si NO usa JUMP CONDICIONALES */
    if ( gadget -> conditional_jumps == 0 )
    {
    /* Si NO usa la instruccion "XCHG" ( No pudo escribir la IAT ) */
      if ( has_this_instruction ( gadget , "xchg" ) == FALSE )
      {
      /* Si tiene un RET comun */
        if ( gadget -> ending_type == RET_ENDING )
        {
        /* Si ocupa lo IDEAL */
          if ( gadget -> stack_used == 0x4 )
          {
          /* Mejoro el PUNTAJE */
            score += 400000;
          }
        }
      /* Si tiene un RETN */
        else if ( gadget -> ending_type == RETN_ENDING )
        {
        /* Si es un "RET 4" */
          if ( gadget -> stack_used == 0x8 )
          {
          /* Mejoro el PUNTAJE */
            score += 300000;
          }
        }
      /* Si tiene un RETF */
        else if ( gadget -> ending_type == RETF_ENDING )
        {
        /* Si ocupa lo IDEAL */
          if ( gadget -> stack_used == 0x8 )
          {
          /* Mejoro el PUNTAJE */
            score += 200000;
          }
        }
      /* Si tiene un IRETD */
        else if ( gadget -> ending_type == IRET_ENDING )
        {
        /* Si ocupa lo IDEAL */
          if ( gadget -> stack_used == 0xc )
          {
          /* Mejoro el PUNTAJE */
            score += 100000;
          }
        }
      }
    /* Si tiene un XCHG */
      else
      {
      /* NO SIRVE para LEER la IAT */
        invalid_gadget = TRUE;
      }
    }

  /* Si obtuvo ALGUN PUNTAJE */
    if ( score > 0 )
    {
    /* Recorro todos los REGISTROS PRESERVADOS */
      for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
      {
      /* Si este registro ESTA PRESERVADO */
        if ( gadget -> preserved_registers [ cont2 ] == TRUE )
        {
        /* Le sumo un PLUS */
          score += 1000;
        }
      }
    }

  /* Si NO obtuvo NINGUN PUNTAJE */
    if ( score == 0 )
    {
    /* Si el GADGET podria SERVIR */
      if ( invalid_gadget == FALSE )
      {
      /* Si NO usa JUMP CONDICIONALES */
        if ( gadget -> conditional_jumps == 0 )
        {
        /* Le doy PRIORIDAD a los GADGETS que NO usan JUMP CONDICIONALES */
          score += 100;
        }
      }
    }

  /* Si el GADGET tienen PUNTAJE */
    if ( score > 0 )
    {
    /* Lo PREMIO si usa MENOS INSTRUCCIONES */
      score += ( 100 - gadget -> instructions -> Len () );
    }

  /* Si NO termina con un "RET ALGO" */
    if ( gadget -> ending_type == OTHER_ENDING )
    {
    /* NO puedo usar este gadget */
      invalid_gadget = TRUE;
    }

  /* Si el GADGET es INVALIDO */
    if ( invalid_gadget == TRUE )
    {
    /* NO lo voy a USAR */
      score = 0;
    }

  /* Puntaje asignado al GADGET */
    scores.Add ( ( void * ) ~ score );

  /* Seteo el PUNTAJE al GADGET */
    gadget -> score = score;
  }

/* Ordeno los gadgets en BASE al PUNTAJE */ 
  scores.SortCouple ( mov_reg32_creg32_rets );

/* Elimino los GADGETS que NO CALIFICAN */
  depure_gadget_list ( mov_reg32_creg32_rets );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int sort_jmp_esps ( List &jmp_esps )
{
  GADGET *gadget;
  List scores;
  unsigned int cont;
  unsigned int cont2;
  unsigned int score;
  int ret = TRUE;

/* Recorro TODOS los GADGETS ENCONTRADOS */
  for ( cont = 0 ; cont < jmp_esps.Len () ; cont ++ )
  {
  /* Levanto el siguiente GADGET */
    gadget = ( GADGET * ) jmp_esps.Get ( cont );

  /* Puntaje por DEFAULT */
    score = 0;

  /* Si el STACK USADO es el IDEAL ( "JMP ESP", "PUSH ESP,RET" o "CALL ESP" ) */
    if ( gadget -> stack_used == 0x0 || gadget -> stack_used == -0x4 )
    {
    /* Pongo PUNTAJE a este gadget */
      score += 100000;

    /* Si NO usa JUMP CONDICIONALES */
      if ( gadget -> conditional_jumps == 0 )
      {
      /* MEJORO el PUNTAJE */
        score += 100000;
      }
    }

  /* Si obtuvo ALGUN PUNTAJE */
    if ( score > 0 )
    {
    /* Recorro todos los REGISTROS PRESERVADOS */
      for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
      {
      /* Si este registro ESTA PRESERVADO */
        if ( gadget -> preserved_registers [ cont2 ] == TRUE )
        {
        /* Le sumo un PLUS */
          score += 1000;
        }
      }
    }

  /* Si NO obtuvo NINGUN PUNTAJE */
    if ( score == 0 )
    {
    /* Si NO usa JUMP CONDICIONALES */
      if ( gadget -> conditional_jumps == 0 )
      {
      /* Le doy PRIORIDAD a los GADGETS que NO usan JUMP CONDICIONALES */
        score += 100;
      }
    }

  /* Si el GADGET tienen PUNTAJE */
    if ( score > 0 )
    {
    /* Lo PREMIO si usa MENOS INSTRUCCIONES */
      score += ( 100 - gadget -> instructions -> Len () );
    }

  /* Puntaje asignado al GADGET */
    scores.Add ( ( void * ) ~ score );

  /* Seteo el PUNTAJE al GADGET */
    gadget -> score = score;
  }

/* Ordeno los gadgets en BASE al PUNTAJE */ 
  scores.SortCouple ( jmp_esps );

/* Elimino los GADGETS que NO CALIFICAN */
  depure_gadget_list ( jmp_esps );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int are_registers_preserved ( List &registers_to_preserve , GADGET *gadget , unsigned int register_used )
{
  unsigned int register_to_preserve;
  unsigned int cont;
  int ret = TRUE;

/* Recorro TODOS los REGISTROS a PRESERVAR */
  for ( cont = 0 ; cont < registers_to_preserve.Len () ; cont ++ )
  {
  /* Levanto el siguiente REGISTRO A PRESERVAR */
    register_to_preserve = ( unsigned int ) registers_to_preserve.Get ( cont );

  /* Si NO es el REGISTRO SETEADO por el GADGET */
    if ( register_to_preserve != register_used )
    {
    /* Si este registro NO esta PRESERVADO */
      if ( gadget -> preserved_registers [ register_to_preserve ] == FALSE )
      {
      /* Salgo con ERROR */
        ret = FALSE;

      /* Dejo de buscar */
        break;
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_compatible_solution ( List &gadgets_ordenados , GADGET *gadget1 )
{
  GADGET *gadget2;
  unsigned int cont;
  int ret = TRUE;

/* Recorro TODOS los GADGET ORDENADOS hasta AHORA */
  for ( cont = 0 ; cont < gadgets_ordenados.Len () ; cont ++ )
  {
  /* Levanto el siguiente gadget */
    gadget2 = ( GADGET * ) gadgets_ordenados.Get ( cont );

  /* Si el gadget actual PISA al GADGET ANTERIOR */
    if ( gadget1 -> preserved_registers [ gadget2 -> register_index ] == FALSE )
    {   
    /* Salgo con ERROR */
      ret = FALSE;

    /* Dejo de buscar */
      break;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_combinable_solution ( int level , List &gadgets , List &gadgets_ordenados )
{
  unsigned int cont2;
  GADGET *gadget1;
  GADGET *gadget2;
  unsigned int cont;
  int ret = FALSE;

/* Si llegue hasta aca quiere decir que SON COMBINABLES */
  if ( level == gadgets.Len () )
  {
  /* Retorno OK */
    ret = TRUE;
  }

/* Si es la primera iteraccion */
  if ( level == 0 )
  {
  /* Limpio la lista para marcar los USADOS */
    gadgets_ordenados.Clear ();
  }

/* Recorro TODOS los gadgets */
  for ( cont = 0 ; cont < gadgets.Len () ; cont ++ )
  {
  /* Levanto el siguiente GADGET */
    gadget1 = ( GADGET * ) gadgets.Get ( cont );

  /* Si este gadget esta USADO */
    if ( gadgets_ordenados.Find ( gadget1 ) == TRUE )
    {  
    /* Paso al SIGUIENTE */
      continue;
    }

  /* Si este gadget ENCAJA con el RESTO */
    if ( is_compatible_solution ( gadgets_ordenados , gadget1 ) == TRUE )
    {
    /* Agrego el NUEVO GADGET a la LISTA */
      gadgets_ordenados.Add ( ( void * ) gadget1 );

    /* Paso al SIGUIENTE NIVEL */
      ret = is_combinable_solution ( level + 1 , gadgets , gadgets_ordenados );

    /* Si HAY SOLUCION */
      if ( ret == TRUE )
      {
      /* Dejo de buscar */
        break;
      }
    /* Si NO HAY SOLUCION */
      else
      {
      /* Elimino el GADGET AGREGADO */
        gadgets_ordenados.Delete ( gadgets_ordenados.Len () - 1 );
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_combinable_gadget ( List &sub_rop_chain , List &registers_to_preserve , GADGET *new_gadget )
{  
  List gadgets_ordenados;
  List gadget_mix;
  unsigned int cont;
  int ret;

/* Recorro TODOS los REGISTROS QUE NO SE PUEDEN TOCAR */
  for ( cont = 0 ; cont < registers_to_preserve.Len () ; cont ++ )
  {
  /* Si este gadget PISA los REGISTROS que QUIERO PRESERVAR */
    if ( new_gadget -> preserved_registers [ ( unsigned int ) registers_to_preserve.Get ( cont ) ] == FALSE )
    {
    /* Este GADGET NO SIRVE */
      return ( FALSE );
    }
  }

/* Armo una lista temporal de GADGETS */
  gadget_mix.Append ( sub_rop_chain );
  gadget_mix.Add ( ( void * ) new_gadget );

/* Chequeo si los GADGETS son COMBINABLES */
  ret = is_combinable_solution ( 0 , gadget_mix , gadgets_ordenados );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_sub_rop_chain ( int level , int use_special_gadget , List &gadgets , List &registros_to_get , List &registers_to_preserve , List &registers_to_negate , List &sub_rop_chain )
{
  static List gadgets_per_register [ VALID_REGISTERS ];
  List *my_gadgets;
  GADGET *gadget;
  unsigned int registro;
  unsigned int cont;
  int ret = FALSE;

/* Si es el primer nivel */
  if ( level == 0 )
  {
  /* Limpio la lista a retornar */
    sub_rop_chain.Clear ();

  /* Inicializo TODAS las listas */
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Inicializo la siguiente lista */
      gadgets_per_register [ cont ].Clear ();
    }

  /* Recorro TODOS los GADGETS */
    for ( cont = 0 ; cont < gadgets.Len () ; cont ++ )
    {
    /* Levanto el SIGUIENTE GADGET */
      gadget = ( GADGET * ) gadgets.Get ( cont );

    /* Guardo este GADGET donde CORRESPONDE */
      gadgets_per_register [ gadget -> register_index ].Add ( ( void * ) gadget );
    }
  }

/* Si llegue al LIMITE */
  if ( level == registros_to_get.Len () )
  {
  /* Cumpli el OBJETIVO */
    return ( TRUE );
  }

/* Obtengo el SETEO de REGISTRO que quiero buscar */
  registro = ( unsigned int ) registros_to_get.Get ( level );

/* Obtengo la lista de SETEOS para ESTE REGISTRO */
  my_gadgets = &gadgets_per_register [ registro ];

//  printf ( "----------> POPEANDO %s\n" , registers [registro] );

/* Recorro TODOS los gadgets */
  for ( cont = 0 ; cont < my_gadgets -> Len () ; cont ++ )
  {
  /* Levanto el siguiente GADGET */
    gadget = ( GADGET * ) my_gadgets -> Get ( cont );

  /* Si el gadget NO TIENE PUNTAJE */
    if ( gadget -> score == 0 )
    {
    /* Paso al SIGUIENTE */
      continue;
    }

  /* Si este GADGET setea el REGISTRO que necesito */
    if ( gadget -> register_index == registro )
    {
    /* Si es el PRIMER NIVEL (GADGET ESPECIAL) */
      if ( ( level == 0 ) && ( use_special_gadget == TRUE ) )
      {
      /* Si NO es un GADGET ESPECIAL */
        if ( gadget -> is_special_gadget == FALSE )
        {
        /* Paso al SIGUIENTE */
          continue;
        }
      }

    /* Si este REGISTRO hay que NEGARLO */
      if ( registers_to_negate.Find ( ( void * ) registro ) == TRUE )
      {
      /* Si este GADGET NO ES NEGADOR */
        if ( gadget -> negator == FALSE )
        {
        /* Paso al SIGUIENTE */
          continue;
        }

//        printf ( "------------> hay que negar %s con %i preservados\n" , registers [ registro ] , nicolas9 );
      }

    /* Si este GADGET es COMBINABLE con los GADGETS ANTERIORES */
      if ( is_combinable_gadget ( sub_rop_chain , registers_to_preserve , gadget ) == TRUE )
      {
      /* Agrego el GADGET a la lista */
        sub_rop_chain.Add ( ( void * ) gadget );
 
      /* Paso al siguiente nivel */      
        ret = get_sub_rop_chain ( level + 1 , use_special_gadget , gadgets , registros_to_get , registers_to_preserve , registers_to_negate , sub_rop_chain );

      /* Si tengo el ROP CHAIN armado */
        if ( ret == TRUE )
        {
        /* Dejo de buscar */
          break;
        }
        else
        {
        /* Elimino el GADGET usado */
          sub_rop_chain.Delete ( sub_rop_chain.Len () - 1 );
        }
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_sorted_rop_chain ( List &sub_rop_chain , List &gadgets_ordenados )
{
  int ret;

/* Obtengo los GADGETS ORDENADOS (Preservan, en ORDEN, los registros de los demas) */
  ret = is_combinable_solution ( 0 , sub_rop_chain , gadgets_ordenados );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_pushad_ret_rop_chain ( int special_register , int use_special_register , List &pushad_rets , List &pop_reg32_rets , List &registers_to_preserve , List &registers_to_set , List &registers_to_negate , List &invalid_chars , List &sub_rop_chain )
{
  List my_registers_to_negate;
  List gadgets_ordenados;
  List registers_to_pop;
  List gadget_endings;
  GADGET *gadget;
  unsigned int cont;
  int ret = FALSE;

/* Recorro TODOS los "PUSHAD/RETs" */
  for ( cont = 0 ; cont < pushad_rets.Len () ; cont ++ )
  {
  /* Levanto el siguiente "PUSHAD/RET" */
    gadget = ( GADGET * ) pushad_rets.Get ( cont );
//    printf ( "SCORE: %i\n" , gadget -> score );

  /* Si este tipo de "PUSHAD/RET" no fue TESTEADO */
    if ( gadget_endings.Find ( ( void * ) gadget -> ending_type ) == FALSE )
    {
    /* Solo pruebo UN GADGET como este */
      gadget_endings.Add ( ( void * ) gadget -> ending_type );
    }
  /* Si este tipo de gadget YA FUE PROBADO */
    else
    {
    /* Paso al siguiente */
      continue;
    }

//    printf ( "gadget %x con %s\n" , gadget -> address , get_pushad_ret_type ( gadget ) );

  /* Armo de nuevo la lista de REGISTROS a POPEAR */
    registers_to_pop.Clear ();

  /* Registros a NEGAR */
    my_registers_to_negate.Clear ();
    my_registers_to_negate.Append ( registers_to_negate );

  /* Agrego los REGISTROS que quiero POPEAR del STACK */
    registers_to_pop.Append ( registers_to_set );

  /* Si es un "RET 4" y "EDI = VirtualProtect" */
    if ( ( gadget -> ending_type == RETN_ENDING ) && ( special_register == EDI_REGISTER ) )
    {
    /* Se puede procesar */
    }
  /* Si es un RET COMUN y "ESI = VirtualProtect" */
    else if ( ( gadget -> ending_type == RET_ENDING ) && ( special_register == ESI_REGISTER ) )
    {
    /* Agrego a EDI */
      registers_to_pop.Add ( ( void * ) EDI_REGISTER );
    }
  /* Si es un "RETF" y "EDI = VirtualProtect" */
    else if ( ( gadget -> ending_type == RETF_ENDING ) && ( special_register == EDI_REGISTER ) )
    {
    /* Lo tengo que SETEAR con el SELECTOR de CODIGO */
      registers_to_pop.Add ( ( void * ) ESI_REGISTER );

    /* Si el 0x00 o el 0x1b es INVALID CHAR */
      if ( invalid_chars.Find ( ( void * ) 0x00 ) == TRUE || invalid_chars.Find ( ( void * ) 0x1b ) == TRUE )
      {
      /* Tengo que NEGAR tanto el SIZE como el PROTECTION */
        my_registers_to_negate.Add ( ( void * ) ESI_REGISTER );
      }
    }
  /* No way */
    else
    {
    /* Paso al SIGUIENTE */
      continue;
    }

//    {
//      unsigned int cont2;
//
//      printf ( "tengo que popear: " );
//
//      for ( cont2 = 0 ; cont2 < registers_to_pop.Len () ; cont2 ++ )
//      {
//        printf ( "%s " , registers [ ( int ) registers_to_pop.Get ( cont2 ) ] );
//      }
//
//      printf ( "\n" );
//    }
//
//    {
//      unsigned int cont2;
//
//      printf ( "tengo que preservar: " );
//
//      for ( cont2 = 0 ; cont2 < registers_to_preserve.Len () ; cont2 ++ )
//      {
//        printf ( "%s " , registers [ ( int ) registers_to_preserve.Get ( cont2 ) ] );
//      }
//
//      printf ( "\n" );
//    }
//
//    {
//      unsigned int cont2;
//
//      printf ( "tengo que negar: " );
//
//      for ( cont2 = 0 ; cont2 < my_registers_to_negate.Len () ; cont2 ++ )
//      {
//        printf ( "%s " , registers [ ( int ) my_registers_to_negate.Get ( cont2 ) ] );
//      }
//
//      printf ( "\n" );
//    }

  /* Si tengo TODOS los GADGETS */
    if ( get_sub_rop_chain ( 0 , use_special_register , pop_reg32_rets , registers_to_pop , registers_to_preserve , my_registers_to_negate , sub_rop_chain ) == TRUE )
    {
//      printf ( "match counter = %i\n" , match_counter );

    /* Obtengo el ROP ordenado */
      get_sorted_rop_chain ( sub_rop_chain , gadgets_ordenados );

    /* Agrego el "PUSHAD/RET" al FINAL */
      gadgets_ordenados.Add ( ( void * ) gadget ); 

    /* Retorno la lista ORDENADA */
      sub_rop_chain.Clear ();

    /* Segunda PARTE del ROP-CHAIN ( "PUSHAD/RET" to "VirtualProtect" ) */
      sub_rop_chain.Append ( gadgets_ordenados );

    /* Retorno OK */
      ret = TRUE;

    /* Dejo de buscar */
      break;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

GADGET *get_super_jmp_esp ( List &pushad_rets , List &pop_reg32_rets , void *ret_nop_address )
{
  List jmp_esp_rop_chain;
  List registers_to_preserve;
  List registers_to_set;
  List registers_to_negate;
  List invalid_chars;
  GADGET *super_gadget = NULL;
  GADGET *final_gadget;
  GADGET *gadget;
  unsigned int cont;
  int ret;

/* Busco una SOLUCION para ESI */
  registers_to_set.Clear ();
  registers_to_set.Add ( ( void * ) ESI_REGISTER );
  registers_to_set.Add ( ( void * ) EBP_REGISTER );

/* Obtengo el ROP-CHAIN para OBTENER el STACK */
  ret = get_pushad_ret_rop_chain ( ESI_REGISTER , FALSE , pushad_rets , pop_reg32_rets , registers_to_preserve , registers_to_set , registers_to_negate , invalid_chars , jmp_esp_rop_chain );

/* Si NO hay SOLUCION para ESI */
  if ( ret == FALSE )
  {
  /* Busco una SOLUCION para EDI */
    registers_to_set.Clear ();
    registers_to_set.Add ( ( void * ) EDI_REGISTER );
    registers_to_set.Add ( ( void * ) EBP_REGISTER );

  /* Obtengo el ROP-CHAIN para OBTENER el STACK */
    ret = get_pushad_ret_rop_chain ( EDI_REGISTER , FALSE , pushad_rets , pop_reg32_rets , registers_to_preserve , registers_to_set , registers_to_negate , invalid_chars , jmp_esp_rop_chain );
  }

/* Si PUDE obtener un ROP-CHAIN para obtener el valor de ESP */
  if ( ret == TRUE )
  {
  /* Obtengo el "PUSHAD/RET" ( ULTIMO GADGET ) */
    final_gadget = ( GADGET * ) jmp_esp_rop_chain.Get ( jmp_esp_rop_chain.Len () - 1 );

//  /* Si el "PUSHAD/RET" termina con un "RET" comun */
//    if ( final_gadget -> ending_type == RET_ENDING )
//    {
//    /* Uso al ULTIMO INSTRUCCION como un "RET NOP" */
//      ret_nop_address = final_gadget -> addresses -> Get ( final_gadget -> addresses -> Len () - 1 );
//    }
//  /* Si el "PUSHAD/RET" termina con otro "RET" */
//    else
//    {
//    /* Tengo que buscar un RET en los GADGET DISPONIBLES */
//      ret_nop_address = ( void * ) 0x33333333;
//    }

  /* Imprimo los GADGETS usados */
    for ( cont = 0 ; cont < jmp_esp_rop_chain.Len () - 1 ; cont ++ )
    {
    /* Levanto el siguiente GADGET */
      gadget = ( GADGET * ) jmp_esp_rop_chain.Get ( cont );

    /* Imprimo el GADGET */
//      printf ( "%x\n" , gadget -> address );

    /* Limpio los POPS/COMMENTS del GADGET */
      gadget -> values_to_pop -> Clear ();
      gadget -> comments -> Clear ();

    /* Si es "EDI" */
      if ( gadget -> register_index == EDI_REGISTER )
      {
      /* Si es un RET COMUN */
        if ( final_gadget -> ending_type == RET_ENDING )
        {
        /* Pongo como comentario lo que POPEA */
          gadget -> values_to_pop -> Add ( ret_nop_address );
          gadget -> comments -> Add ( ( void * ) "RET NOP" );
        }
      }
    /* Si es "ESI" */
      else if ( gadget -> register_index == ESI_REGISTER )
      {
      /* Si es un RET COMUN */
        if ( final_gadget -> ending_type == RET_ENDING )
        {
        /* Pongo como comentario lo que POPEA */
          gadget -> values_to_pop -> Add ( ret_nop_address );
          gadget -> comments -> Add ( ( void * ) "RET NOP" );
        }
      /* Si es un RETF */
        else if ( final_gadget -> ending_type == RETF_ENDING )
        {
        /* Pongo como comentario lo que POPEA */
          gadget -> values_to_pop -> Add ( ( void * ) 0x1b );
          gadget -> comments -> Add ( ( void * ) "WINDOWS CODE SELECTOR" );
        }
      }
    /* Si es "EBP" */
      else if ( gadget -> register_index == EBP_REGISTER )
      {
      /* Pongo como comentario lo que POPEA */
        gadget -> values_to_pop -> Add ( ret_nop_address );
        gadget -> comments -> Add ( ( void * ) "RET NOP --> JMP ESP" );
      }
    }

  /* Creo un SUPER-GADGET */
    super_gadget = create_super_jmp_esp_gadget ( jmp_esp_rop_chain );
  }

  return ( super_gadget );
}

////////////////////////////////////////////////////////////////////////////////

int find_iat_rop_chains ( void *vp_address , List &invalid_chars , List &pop_reg32_rets , List &mov_reg32_reg32_rets , List &mov_reg32_creg32_rets , List &esi_sub_rop_chain , List &edi_sub_rop_chain )
{
  List rop_chain;
  GADGET *mov_reg32_creg32_ret;
  GADGET *mov_reg32_reg32_ret;
  GADGET *pop_reg32_ret;
  unsigned int esi_max_score = 0;
  unsigned int edi_max_score = 0;
  unsigned int esi_solutions = 0;
  unsigned int edi_solutions = 0;
  unsigned int score;
  unsigned int cont, cont2, cont3;
  int vp_address_has_invalid_chars = FALSE;
  int ret = FALSE;

/* Si la direccion de "IAT.VirtualProtect" tiene INVALID CHARS */
  if ( has_invalid_chars ( invalid_chars , vp_address ) == TRUE )
  {
  /* Solo uso "POPs NEGADORES" */
    vp_address_has_invalid_chars = TRUE;
  }

/* Recorro TODOS los "REG1=[REG2+0x00]" */
  for ( cont = 0 ; cont < mov_reg32_creg32_rets.Len () ; cont ++ )
  {
  /* Levanto el siguiente GADGET */
    mov_reg32_creg32_ret = ( GADGET * ) mov_reg32_creg32_rets.Get ( cont );  
//    printf ( "%i: testing = %x con %i puntos\n" , cont , mov_reg32_creg32_ret -> address , mov_reg32_creg32_ret -> score );

  /* Si el gadget NO TIENE PUNTAJE */          
    if ( mov_reg32_creg32_ret -> score == 0 )
    {
    /* Sigo buscando */
      continue;
    }

  /* Recorro TODOS los "POP REG32" */
    for ( cont2 = 0 ; cont2 < pop_reg32_rets.Len () ; cont2 ++ )
    {
    /* Levanto el siguiente GADGET */
      pop_reg32_ret = ( GADGET * ) pop_reg32_rets.Get ( cont2 );  

    /* Si el gadget NO TIENE PUNTAJE */          
      if ( pop_reg32_ret -> score == 0 )
      {
      /* Sigo buscando */
        continue;
      }

    /* Si "IAT.VirtualProtect" tiene INVALID CHARS */
      if ( vp_address_has_invalid_chars == TRUE )
      {
      /* Si el gadget NO ES NEGADOR */
        if ( pop_reg32_ret -> negator == FALSE )
        {
        /* Sigo buscando */
          continue;
        }

      /* Si el GADGET NIEGA por INCREMENTACION */
        if ( pop_reg32_ret -> negator_by_incrementation == TRUE )
        {
        /* Sigo buscando */
          continue;
        }

      /* Si es un GADGET que usa NEG */
        if ( pop_reg32_ret -> neg_operation == OP_REG_TO_NEG_REG )
        {
        /* Si el valor NEGADO tiene INVALID CHARS */
          if ( has_invalid_chars ( invalid_chars , ( void * ) ( - ( int ) vp_address ) ) == TRUE )
          {
          /* Sigo buscando */
            continue;
          }
        }
      /* Si es un GADGET que usa NOT */
        else if ( pop_reg32_ret -> neg_operation == OP_REG_TO_NOT_REG )
        {
        /* Si el valor NOTEADO tiene INVALID CHARS */
          if ( has_invalid_chars ( invalid_chars , ( void * ) ( ~ ( int ) vp_address ) ) == TRUE )
          {
          /* Sigo buscando */
            continue;
          }
        }
      }

    /* Si este GADGET saca del STACK el REGISTRO que NECESITO */
      if ( pop_reg32_ret -> register_index == mov_reg32_creg32_ret -> operand )
      {
      /* Si el OUTPUT es en ESI */
        if ( mov_reg32_creg32_ret -> register_index == ESI_REGISTER )
        {
        /* Obtengo el PUNTAJE */
          score  = 0;
//          score += pop_reg32_ret -> score;
//          score += mov_reg32_creg32_ret -> score;
//          score += ( score * 2 );
          score += pop_reg32_ret -> stack_used;
          score += mov_reg32_creg32_ret -> stack_used;
          score = ~score;

        /* Si este puntaje es MEJOR que el ANTERIOR */
          if ( esi_max_score < score )
          {
          /* Tengo un NUEVO RECORD */
            esi_max_score = score;

          /* Limpio el ROP-CHAIN anterior */
            esi_sub_rop_chain.Clear ();

          /* Agrego esta SOLUCION */
            esi_sub_rop_chain.Add ( ( void * ) pop_reg32_ret );
            esi_sub_rop_chain.Add ( ( void * ) mov_reg32_creg32_ret );
          }

        /* Tengo OTRA SOLUCION */
          esi_solutions ++;

        /* Paso al SIGUIENTE */
          continue;
        }
      /* Si el OUTPUT es en EDI */
        else if ( mov_reg32_creg32_ret -> register_index == EDI_REGISTER )
        {
        /* Obtengo el PUNTAJE */
          score  = 0;
//          score += pop_reg32_ret -> score;
//          score += mov_reg32_creg32_ret -> score;
//          score += ( score * 2 );
          score += pop_reg32_ret -> stack_used;
          score += mov_reg32_creg32_ret -> stack_used;
          score = ~score;

        /* Si este puntaje es MEJOR que el ANTERIOR */
          if ( edi_max_score < score )
          {
          /* Tengo un NUEVO RECORD */
            edi_max_score = score;

          /* Limpio el ROP-CHAIN anterior */
            edi_sub_rop_chain.Clear ();

          /* Agrego esta SOLUCION */
            edi_sub_rop_chain.Add ( ( void * ) pop_reg32_ret );
            edi_sub_rop_chain.Add ( ( void * ) mov_reg32_creg32_ret );
          }

        /* Tengo OTRA SOLUCION */
          edi_solutions ++;

        /* Paso al SIGUIENTE */
          continue;
        }
      /* Si el OUTPUT es en OTRO REGISTRO */
        else
        {
        /* Recorro TODOS los "REG32=REG32" */
          for ( cont3 = 0 ; cont3 < mov_reg32_reg32_rets.Len () ; cont3 ++ )
          {
          /* Levanto el siguiente GADGET */
            mov_reg32_reg32_ret = ( GADGET * ) mov_reg32_reg32_rets.Get ( cont3 );  

          /* Si el gadget NO TIENE PUNTAJE */          
            if ( mov_reg32_reg32_ret -> score == 0 )
            {
            /* Sigo buscando */
             continue;
            }

          /* Si el GADGET tiene como SOURCE la SALIDA de "REG1=[REG2+0x00] ..." */
          /* ... y si el DESTINO es ESI */
            if ( has_this_asignation ( mov_reg32_reg32_ret , ESI_REGISTER , mov_reg32_creg32_ret -> register_index ) == TRUE )
            {
            /* Obtengo el PUNTAJE */
              score  = 0;
//              score += pop_reg32_ret -> score;
//              score += mov_reg32_creg32_ret -> score;
//              score += mov_reg32_reg32_ret -> score;
              score += pop_reg32_ret -> stack_used;
              score += mov_reg32_creg32_ret -> stack_used;
              score += mov_reg32_reg32_ret -> stack_used;
              score = ~score;

            /* Si este puntaje es MEJOR que el ANTERIOR */
              if ( esi_max_score < score )
              {
              /* Tengo un NUEVO RECORD */
                esi_max_score = score;

              /* Limpio el ROP-CHAIN anterior */
                esi_sub_rop_chain.Clear ();

              /* Agrego esta SOLUCION */
                esi_sub_rop_chain.Add ( ( void * ) pop_reg32_ret );
                esi_sub_rop_chain.Add ( ( void * ) mov_reg32_creg32_ret );
                esi_sub_rop_chain.Add ( ( void * ) mov_reg32_reg32_ret );
              }

            /* Tengo OTRA SOLUCION */
              esi_solutions ++;
            }
          /* Si el GADGET tiene como SOURCE la SALIDA de "REG1=[REG2+0x00] ..." */
          /* ... y si el DESTINO es EDI */
            else if ( has_this_asignation ( mov_reg32_reg32_ret , EDI_REGISTER , mov_reg32_creg32_ret -> register_index ) == TRUE )
            {
            /* Obtengo el PUNTAJE */
              score  = 0;
//              score += pop_reg32_ret -> score;
//              score += mov_reg32_creg32_ret -> score;
//              score += mov_reg32_reg32_ret -> score;
              score += pop_reg32_ret -> stack_used;
              score += mov_reg32_creg32_ret -> stack_used;
              score += mov_reg32_reg32_ret -> stack_used;
              score = ~score;

            /* Si este puntaje es MEJOR que el ANTERIOR */
              if ( edi_max_score < score )
              {
              /* Tengo un NUEVO RECORD */
                edi_max_score = score;

              /* Limpio el ROP-CHAIN anterior */
                edi_sub_rop_chain.Clear ();

              /* Agrego esta SOLUCION */
                edi_sub_rop_chain.Add ( ( void * ) pop_reg32_ret );
                edi_sub_rop_chain.Add ( ( void * ) mov_reg32_creg32_ret );
                edi_sub_rop_chain.Add ( ( void * ) mov_reg32_reg32_ret );
              }

           /* Tengo OTRA SOLUCION */
              edi_solutions ++;
            }
          }
        }
      }
    }
  }

/* Si tengo ALGUNA SOLUCION */
  if ( ( esi_sub_rop_chain.Len () > 0 ) || ( edi_sub_rop_chain.Len () > 0 ) )
  {
  /* Retorno OK */
    ret = TRUE;
  }

//  printf ( "[x] Solutions for ESI: %i - max %i\n" , esi_solutions , esi_max_score );
//  printf ( "[x] Solutions for EDI: %i - max %i\n" , edi_solutions , edi_max_score );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int find_direct_gadgets ( void *vp_address , List &invalid_chars , List &esi_sub_rop_chain , List &edi_sub_rop_chain , List &pushad_rets , List &pop_reg32_rets , List &mov_reg32_reg32_rets , List &super_rop_chain , unsigned int *register_used )
{
  List registers_to_negate;
  List registers_to_preserve;
  List registers_to_set;
  List sub_rop_chain;
  List super_bypasses;
  GADGET *special_gadget;
  GADGET *final_gadget;
  GADGET *gadget;
  unsigned int cont, cont2;
  int special_register;
  int ret = FALSE;

//  printf ( "SIZES = %i and %i\n" , esi_sub_rop_chain.Len () , edi_sub_rop_chain.Len () );

/* Busco las 2 soluciones ( ESI y EDI ) */
  for ( cont = 0 ; cont < 2 ; cont ++ )
  {
//    printf ( "Probando con %s\n" , ( cont == 0 ) ? "esi":"edi" );

//    if ( cont == 01)
//    {
//      printf ( "BORRAR ESTO !!!\n" );
//      printf ( "CON EDI NO PRUEBO !!!\n" );
//      continue;
//    }

  /* Si quiero buscar un ROP-CHAIN con "ESI = VirtualProtect" */
    if ( cont == 0 )
    {
    /* Si tengo un SUB-ROP-CHAIN para 'ESI' */
      if ( esi_sub_rop_chain.Len () == 0 )
      {
      /* Paso al SIGUIENTE */
        continue;
      }
    }
  /* Si quiero buscar un ROP-CHAIN con "EDI = VirtualProtect" */
    else
    {
    /* Si tengo un SUB-ROP-CHAIN para 'EDI' */
      if ( edi_sub_rop_chain.Len () == 0 )
      {
      /* Paso al SIGUIENTE */
        continue;
      }
    }

  /* Inicializo las listas */
    registers_to_preserve.Clear ();
    registers_to_set.Clear ();
    registers_to_negate.Clear ();

  /* Si estoy buscando un ROP para "ESI = VirtualProtect" */
    if ( cont == 0 )
    {
    /* Registro a SETEAR con "VirtualProtect" */
      special_register = ESI_REGISTER;

    /* Creo un gadget que REPRESENTA un "POP ESI = VirtualProtect" */
      special_gadget = create_super_pop_reg32_gadget ( special_register , esi_sub_rop_chain );

    /* Registros que TENGO que POPEAR */
      registers_to_set.Add ( ( void * ) special_register );
    }
  /* Si estoy buscando un ROP para "EDI = VirtualProtect" */
    else
    {
    /* Registro a SETEAR con "VirtualProtect" */
      special_register = EDI_REGISTER;

    /* Creo un gadget que REPRESENTA un "POP EDI = VirtualProtect" */
      special_gadget = create_super_pop_reg32_gadget ( special_register , edi_sub_rop_chain );

    /* Registros que TENGO que POPEAR */
      registers_to_set.Add ( ( void * ) special_register );
    }

  /* Marco al GADGET como ESPECIAL */
    special_gadget -> is_special_gadget = TRUE;

  /* Agrego el GADGET como SI FUERA un "POP" */
    pop_reg32_rets.Add ( ( void * ) special_gadget );

  /* Obtengo TODOS los BYPASSES para este GADGET */
//    printf ( "[x] Buscando BYPASSES ...\n" );
    get_super_bypasses ( special_gadget , mov_reg32_reg32_rets , super_bypasses );
//    printf ( "bypasses = %i\n" , super_bypasses.Len () );

  /* Agrego los NUEVOS "POP REG32" a la lista */
    pop_reg32_rets.Append ( super_bypasses );

//    {
//      unsigned int contx, conty;
//      List my_gadgets;
//      GADGET *gadgetx;
//      GADGET *gadgety;
//
//      for ( contx = 0 ; contx < super_bypasses.Len () ; contx ++ )
//      {       
//        gadgetx = ( GADGET * ) super_bypasses.Get ( contx );
//
//        my_gadgets.Clear ();
//        decompose_gadget ( gadgetx , my_gadgets );
//
//        printf ( "XXXXXXXXXXXXXXXXXXX con %i\n" , my_gadgets.Len () );
//
//        for ( conty = 0 ; conty < my_gadgets.Len () ; conty ++ )
//        {
//          gadgety = ( GADGET * ) my_gadgets.Get ( conty );
//
//          printf ( "%x\n" , gadgety -> address );
//        }
//      }
//    }

  /* Registros que TENGO que PUSHEAR como ARGUMENTOS para "VirtualProtect" */
    registers_to_set.Add ( ( void * ) EBP_REGISTER );
    registers_to_set.Add ( ( void * ) EBX_REGISTER );
    registers_to_set.Add ( ( void * ) EDX_REGISTER );
    registers_to_set.Add ( ( void * ) ECX_REGISTER );

  /* Si el ZERO es INVALID CHAR */
    if ( invalid_chars.Find ( ( void * ) 0 ) == TRUE )
    {
    /* Tengo que NEGAR tanto el SIZE como el PROTECTION */
      registers_to_negate.Add ( ( void * ) EBX_REGISTER );
      registers_to_negate.Add ( ( void * ) EDX_REGISTER );
    }

  /* Si el 0x40 es INVALID CHAR */
    if ( invalid_chars.Find ( ( void * ) 0x40 ) == TRUE )
    {
    /* Tengo que NEGAR tanto el SIZE como el PROTECTION */
      registers_to_negate.Add ( ( void * ) EDX_REGISTER );
    }

  /* Obtengo el SUB-ROP-CHAIN para llamar a "VirtualProtect" */
    ret = get_pushad_ret_rop_chain ( special_register , TRUE , pushad_rets , pop_reg32_rets , registers_to_preserve , registers_to_set , registers_to_negate , invalid_chars , sub_rop_chain );

  /* Elimino el GADGET ESPECIAL */
    pop_reg32_rets.Delete ( pop_reg32_rets.Len () - 1 );

  /* Si tengo UNA SOLUCION */
    if ( ret == TRUE )
    {
    /* Armo el ROP-CHAIN a RETORNAR */
      super_rop_chain.Clear ();

    /* Seteo el REGISTRO USADO */
      *register_used = special_register;

    /* Retorno el ROP ORIGINAL ( Con SUPER-GADGETS incluidos ) */
      super_rop_chain.Append ( sub_rop_chain );

    /* Dejo de buscar */
      return ( TRUE );
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void build_rop_chain ( List &rop_chain , List &values_to_pop , List &comments , List &final_values_to_pop , List &final_comments )
{
  unsigned int stack_compensator = 0;
  unsigned int cont;
  int last_gadget_ending_type = OTHER_ENDING;
  char *pseudo_instruction;
  GADGET *gadget;

/* Recorro TODOS los GADGETS del ROP-CHAIN */
  for ( cont = 0 ; cont < rop_chain.Len () ; cont ++ )
  {
//    printf ( "compensando %i\n" , stack_compensator );

  /* Levanto el SIGUIENTE GADGET */
    gadget = ( GADGET * ) rop_chain.Get ( cont );

  /* Obtengo lo que "hace" el GADGET */
    pseudo_instruction = get_gadget_pseudo_instruction ( gadget );

  /* Seteo la DIRECCION del GADGET */
    final_values_to_pop.Add ( ( void * ) gadget -> address );
    final_comments.Add ( ( void * ) pseudo_instruction );

  /* Si es un "RETF" */
    if ( last_gadget_ending_type == RETF_ENDING )
    {
//      printf ( "GADGET ----> %x\n" , gadget -> address );

    /* Agrego a POPEAR el SELECTOR DE CODIGO */
      final_values_to_pop.Add ( ( void * ) 0x1b ); // Windows CODE SELECTOR
      final_comments.Add ( ( void * ) "WINDOWS CODE SELECTOR" );
    }
  /* Si es un "IRET" */
    else if ( last_gadget_ending_type == IRET_ENDING )
    {
    /* Agrego a POPEAR el SELECTOR DE CODIGO */
      final_values_to_pop.Add ( ( void * ) 0x1b ); // Windows CODE SELECTOR
      final_comments.Add ( ( void * ) "WINDOWS CODE SELECTOR" );

    /* Agrego a POPEAR las EFLAGS */
//        final_values_to_pop.Add ( ( void * ) 0x202 ); // Eflags
      final_values_to_pop.Add ( ( void * ) 0xffff0202 ); // Eflags
      final_comments.Add ( ( void * ) "EFLAGS" );
    }

  /* Paddeo el STACK CONSUMIDO por el GADGET ANTERIOR */
    get_padding ( stack_compensator , final_values_to_pop , final_comments );

  /* Si HAY valores a POPEAR */
    if ( comments.Get ( cont ) != NULL )
    {
    /* Seteo el VALOR a POPEAR */
      final_values_to_pop.Add ( values_to_pop.Get ( cont ) );
      final_comments.Add ( comments.Get ( cont ) );
    }

  /* Si tiene STACK PADDING POSITIVO ( GADGETS normales ) */
    if ( gadget -> stack_padding >= 0 )
    {
//      printf ( "%x con %i bytes\n" , gadget -> address , gadget -> stack_padding );

    /* Seteo el PADDING antes del RET */
      get_padding ( gadget -> stack_padding , final_values_to_pop , final_comments );
    }

  /* Si NO es un "PUSHAD/RET" */
    if ( gadget -> operation != OP_REG_TO_MEM )
    {
    /* Stack a COMPENSAR en el PROXIMO GADGET */
      stack_compensator = gadget -> ret_extra_consumption;

    /* Para setear en el PROXIMO GADGET */
      last_gadget_ending_type = gadget -> ending_type;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

void print_line ( void )
{
  char buffer [ 80 ];
  unsigned int cont;

/* Armo la linea */
  memset ( buffer , 0 , sizeof ( buffer ) );
  memset ( buffer , '-' , sizeof ( buffer ) - 1 );

  printf ( "\n%s" , buffer );
  printf ( "\n%s\n" , buffer );
}

////////////////////////////////////////////////////////////////////////////////

int print_rop_chain ( List &values_to_pop , List &comments )
{
  char *comment;
  unsigned int value;
  unsigned int cont;
  int ret = TRUE;

//////////////

/* Imprimo una linea SEPARATORIA */
  print_line ();

/* Imprimo el string para el NTSD */
  for ( cont = 0 ; cont < values_to_pop.Len () ; cont ++ )
  {
  /* Si es el PRIMER string */
    if ( cont == 0 )
    {
    /* Separo de la ultima linea */
      printf ( "\nNTSD OUTPUT !\n" );
      printf ( "eb eip c3\n" );
    }

  /* Levanto el SIGUIENTE GADGET */
    value = ( unsigned int ) values_to_pop.Get ( cont );

  /* Imprimo el VALOR a POPEAR */
    printf ( "ed esp+%.2x 0x%.8x\n" , cont * 4 , value );
  }

//////////////

/* Imprimo una linea SEPARATORIA */
  print_line ();

/* Imprimo el inicio del ROP-CHAIN */
  printf ( "\n" );
  printf ( "rop_chain  = \"\" \n" );

/* Recorro VALOR por VALOR */
  for ( cont = 0 ; cont < values_to_pop.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE VALOR */
    value = ( unsigned int ) values_to_pop.Get ( cont );
    comment = ( char * ) comments.Get ( cont );

  /* Imprimo el VALOR a POPEAR */
//    printf ( "rop_chain += 0x%.8x # %s\n" , value , comment );
    printf ( "rop_chain += struct.pack (\"I\",0x%.8x) # %s\n" , value , comment );
  }

/* Imprimo una linea SEPARATORIA */
  print_line ();

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

char *get_next_line ( char *settings )
{
  static FILE *f = NULL;
  static char line [ 1024 ];
  char *new_line = NULL;
  int ret = FALSE;

/* Si es un FILE VALIDO */
  if ( settings != NULL )
  {
  /* Si es la PRIMERA VEZ */
    if ( f == NULL )
    {
    /* Intento abrir el file */
      f = fopen ( settings , "rt" );

    /* Si el file NO existe */
      if ( f == NULL )
      {
      /* Salgo con ERROR */
        return ( NULL );
      }
    }

  /* Levanto la siguiente linea */
    if ( fgets ( line , sizeof ( line ) , f ) != 0 )
    {
    /* Elimino el ENTER al final */
      delete_new_line ( line );

    /* Elimino TODOS los espacios de la linea */
      compress_line ( line );

    /* Retorno la linea leida */
      new_line = line;
    }
    else
    {
    /* Cierro el FILE para que pueda ser ABIERTO DE NUEVO */
      fclose ( f );

    /* Inicializo el HANDLE */
      f = NULL;
    }
  }

  return ( new_line );
}

////////////////////////////////////////////////////////////////////////////////

int get_values ( char *line , List &values )
{
  char *s;
  unsigned int value;
  int ret = TRUE;

/* Mientras haya asignaciones */
  while ( ( s = strtok ( line , "," ) ) != NULL )
  {
  /* Obtengo el valor de esta asignacion */
    sscanf ( s , "%x" , &value );

  /* Agrego el valor a la lista */
    values.Add ( ( void * ) value );

  /* Para NO volver a parsear desde el INICIO */
    line = NULL;
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_modules ( char *line , List &modules )
{
  unsigned int value;
  char *module;
  char *s;
  int ret = TRUE;

/* Mientras haya asignaciones */
  while ( ( s = strtok ( line , "," ) ) != NULL )
  {
  /* Creo un string */
    module = ( char * ) malloc ( strlen ( s ) + 1 );

  /* Obtengo el valor de esta asignacion */
    strcpy ( module , s );

  /* Agrego el valor a la lista */
    modules.Add ( ( void * ) module );

  /* Para NO volver a parsear desde el INICIO */
    line = NULL;
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_valid_settings ( char *settings )
{
  char *line;
  int ret = TRUE;

/* Recorro linea por linea */
  while ( ( line = get_next_line ( settings ) ) != NULL )
  {
  /* Si NO es un COMENTARIO */
    if ( line [ 0 ] != '#' )
    {
    /* Si tengo un OBJETIVO */
      if ( strstr ( line , "==" ) != NULL )
      {
      /* Salgo con ERROR */
        ret = FALSE;
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_invalid_chars ( char *settings , List &invalid_chars )
{
  char *line;
  int ret = FALSE;

/* Recorro linea por linea */
  while ( ( line = get_next_line ( settings ) ) != NULL )
  {
  /* Si NO es un COMENTARIO */
    if ( line [ 0 ] != '#' )
    {
    /* Si son los invalid chars */
      if ( strstr ( line , "invalid_chars" ) != NULL )
      {
      /* Obtengo un puntero a los INVALID CHARS */
        line = strchr ( line , '=' );

      /* Retorno OK */
        ret = TRUE;

      /* Si el SIMBOLO EXISTE */
        if ( line != NULL )
        {
        /* Obtengo todos los caracteres invalidos */
          get_values ( line + 1 , invalid_chars );
        }
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void *get_valid_address ( void *base , unsigned int size , List &invalid_chars )
{
  void *waddress = NULL;
  void *address;
  unsigned int cont;

/* Recorro TODAS las ADDRESSES */
  for ( cont = size - sizeof ( void * ) ; cont > 0 ; cont -- )
  {
  /* Si esta direccion NO TIENE invalid chars */
    if ( has_invalid_chars ( invalid_chars , ( void * ) ( ( unsigned int ) base + cont ) ) == FALSE )
    {
    /* Retorno esta direccion */
      waddress = ( void * ) ( ( unsigned int ) base + cont );

    /* Dejo de buscar */
      break;
    }
  }

  return ( waddress );
}

////////////////////////////////////////////////////////////////////////////////

void *get_ret_nop ( List &gadgets , List &invalid_chars )
{
  void *ret_nop_address = NULL;
  void *ret_address;
  unsigned int cont;
  GADGET *gadget;

/* Recorro TODOS los GADGETS */
  for ( cont = 0 ; cont < gadgets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE GADGET */
    gadget = ( GADGET * ) gadgets.Get ( cont );

  /* Si es un GADGET SIMPLE */
    if ( gadget -> is_super_gadget == FALSE )
    {
    /* Si el GADGET termina en un RET COMUN */
      if ( gadget -> ending_type == RET_ENDING )
      {
      /* Obtengo la direccion del RET */
        ret_address = gadget -> addresses -> Get ( gadget -> addresses -> Len () - 1 );

      /* Si la direccion NO TIENE INVALID CHARS */
        if ( has_invalid_chars ( invalid_chars , ret_address ) == FALSE )
        {
        /* Retorno esta direccion */
          ret_nop_address = ret_address;

        /* Dejo de buscar */
          break;
        }
      }
    }
  }

  return ( ret_nop_address );
}

////////////////////////////////////////////////////////////////////////////////

void read_memory ( void *address , void *destination , unsigned int size )
{
/* Copio la memoria pedida */
  memcpy ( destination , address , size );
}

////////////////////////////////////////////////////////////////////////////////

int get_module_name ( char *snapshot , char *module_name )
{
  SNAPSHOT_HEADER header;
  DUMPBLOCKV20 block;
  SECTION *section;
  unsigned int cont;
  char permisos [ 16 ];
  void *module_base_candidate = NULL;
  unsigned int module_size = 0;
  void *allocated_module = NULL;
  void *data;
  int ret = FALSE;
  int res;
  FILE *f;

/* Abro el file pasado como parametro */
  f = fopen ( snapshot , "rb" );

/* Si pude abrir el file */
  if ( f != NULL )
  {
  /* Levanto el HEADER */
    res = fread ( &header , sizeof ( header ) , 1 , f );

//    printf ( "secciones = %i\n" , header.blockcount );
//    printf ( "sizeof1 = %i\n" , sizeof ( header ) );
//    printf ( "sizeof2 = %i\n" , sizeof ( block ) );

//    header.blockcount = 1;

  /* Si pude leer el header completo */
    if ( res == 1 )
    {
    /* Si el header es INVALIDO */
      if ( header.sig != 0x70616E73 )
      {
      /* Cierro el file */
        fclose ( f );

      /* Salgo con ERROR */
        return ( FALSE );
      }

    /* Tag inicial */
//      printf ( "\nProcessing snaphost file ...\n" );

    /* Inicializo la estructura */
      memset ( &block , 0 , sizeof ( block ) );

    /* Inicializo el campo con el nombre del modulo al que pertenece la SECCION */
      strcpy ( block.name , "" );

    /* Levanto la PRIMER SECCION del SNAPSHOT */
    /* Si es la version 1 de la estructura */
      if ( header.version == 1 )
      {
      /* Levanto el header de la siguiente seccion */
        res = fread ( &block , sizeof ( DUMPBLOCKV10 ) , 1 , f );
      }
    /* Si es la version con el nombre de la DLL */
      else if ( header.version == 2 )
      {
      /* Levanto el header de la siguiente seccion */
        res = fread ( &block , sizeof ( DUMPBLOCKV20 ) , 1 , f );
      }
    /* Si hay algun ERROR */
      else
      {
      /* Salgo con ERROR */
        return ( FALSE );
      }

    /* Si pude leer el HEADER del BLOQUE de MEMORIA */
      if ( res == 1 )
      {
      /* Copio el NOMBRE del MODULO al cual PERTENECE */
        strcpy ( module_name , block.name );

      /* Retorno OK */
        ret = TRUE;
      }
    }

  /* Cierro el file */
    fclose ( f );
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_loaded_modules ( char *snapshot_file , List &modules )
{
  SNAPSHOT_HEADER header;
  DUMPBLOCKV20 block;
  SECTION *section;
  unsigned int cont;
  char last_module [ sizeof ( block.name ) ];
  char permisos [ 16 ];
  char *module_name;
  void *module_base_candidate = NULL;
  unsigned int module_size = 0;
  void *allocated_module = NULL;
  void *data;
  int ret = FALSE;
  int res;
  FILE *f;

/* Abro el file pasado como parametro */
  f = fopen ( snapshot_file , "rb" );

/* Si pude abrir el file */
  if ( f != NULL )
  {
  /* Levanto el HEADER */
    res = fread ( &header , sizeof ( header ) , 1 , f );

//    printf ( "secciones = %i\n" , header.blockcount );
//    printf ( "sizeof1 = %i\n" , sizeof ( header ) );
//    printf ( "sizeof2 = %i\n" , sizeof ( block ) );

//    header.blockcount = 1;

  /* Si pude leer el header completo */
    if ( res == 1 )
    {
    /* Si el header es INVALIDO */
      if ( header.sig != 0x70616E73 )
      {
      /* Cierro el file */
        fclose ( f );

      /* Salgo con ERROR */
        return ( FALSE );
      }

    /* Tag inicial */
//      printf ( "\nProcessing snaphost file ...\n" );

    /* Inicializo el campo con el nombre del modulo al que pertenece la SECCION */
      strcpy ( block.name , "" );

    /* Inicializo el string */
      strcpy ( last_module , "" );

    /* Levanto TODAS las SECCIONES del SNAPSHOT */
      for ( cont = 0 ; cont < header.blockcount ; cont ++ )
      {
      /* Si es la version 1 de la estructura */
        if ( header.version == 1 )
        {
        /* Levanto el header de la siguiente seccion */
          res = fread ( &block , sizeof ( DUMPBLOCKV10 ) , 1 , f );
        }
      /* Si es la version con el nombre de la DLL */
        else if ( header.version == 2 )
        {
        /* Levanto el header de la siguiente seccion */
          res = fread ( &block , sizeof ( DUMPBLOCKV20 ) , 1 , f );
        }
      /* Si hay algun ERROR */
        else
        {
        /* Salgo con ERROR */
          return ( FALSE );
        }

      /* Si pude leer el HEADER del BLOQUE de MEMORIA */
        if ( res == 1 )
        {
        /* Si PERTENECE a un MODULO */
          if ( strlen ( block.name ) > 0 )
          {
          /* Si NO pertenece al MISMO MODULO */
            if ( strcmp ( last_module , block.name ) != 0 )
            {
            /* Tengo un NUEVO MODULO */
              strncpy ( last_module , block.name , sizeof ( block.name ) );

            /* Creo un STRING para mantener el NOMBRE */
              module_name = ( char * ) malloc ( strlen ( last_module ) + 1 );
              strcpy ( module_name , last_module );

            /* Agrego el NOMBRE a la lista */
              modules.Add ( ( void * ) module_name );

            /* Por ahora RETORNO OK */
              ret = TRUE;
            }
          }

        /* Mensaje al usuario */
//          printf ( "* section: %.8I64x - %.8I64x %s %s\n" , block.BaseAddress , block.RegionSize , permisos , block.name );

        /* Avanzo a la SIGUIENTE SECCION */
          fseek ( f , block.RegionSize , SEEK_CUR );
        }
      /* Si hubo algun ERROR */
        else
        {
        /* Salgo con ERROR */
          return ( FALSE );
        }
      }
    }

  /* Cierro el file */
    fclose ( f );
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_rop_module_list ( char *settings , char *snapshot , List &rop_module_list )
{
  List modules;
  char module_list [ 1024 ];
  char *module1;
  char *module2;
  char *line;
  unsigned int cont, cont2;
  int declaration_present = FALSE;
  int module_found;
  int ret = TRUE;

/* Recorro linea por linea */
  while ( ( line = get_next_line ( settings ) ) != NULL )
  {
  /* Si NO es un COMENTARIO */
    if ( line [ 0 ] != '#' )
    {
    /* Si TENGO que BUSCAR */
      if ( declaration_present == FALSE )
      {
      /* Si son los MODULOS donde ROPEAR */
        if ( strstr ( line , "modules" ) != NULL )
        {
        /* Obtengo un puntero a los INVALID CHARS */
          line = strchr ( line , '=' );

        /* Para NO volver a buscar */
          declaration_present = TRUE;

        /* Si el SIMBOLO EXISTE */
          if ( line != NULL )
          {
          /* Obtengo todos los MODULOS */
            get_modules ( line + 1 , rop_module_list );
          }
        }
      }
    }
  }

/* Obtengo la LISTA de MODULOS CARGADOS en el SNAPSHOT */
  get_loaded_modules ( snapshot , modules );

/* Recorro TODOS los MODULOS pasados como parametro */
  for ( cont = 0 ; cont < rop_module_list.Len () ; cont ++ )
  {
  /* Levanto el siguiente modulo */
    module1 = ( char * ) rop_module_list.Get ( cont );

  /* Inicializo una NUEVA BUSQUEDA */
    module_found = FALSE;

  /* Recorro TODOS los modulos en el SNAPSHOT */
    for ( cont2 = 0 ; cont2 < modules.Len () ; cont2 ++ )
    {
    /* Levanto el siguiente modulo */
      module2 = ( char * ) rop_module_list.Get ( cont2 );

    /* Si el MODULO esta CARGADO */
      if ( stricmp ( module1 , module2 ) == 0 )
      {
      /* Modulo encontrado */
        module_found = TRUE;

      /* Dejo de buscar */
        break;
      }
    }

  /* Si el modulo NO ESTA CARGADO */
    if ( module_found == FALSE )
    {
    /* Mensaje de ERROR */
      printf ( "[ ] Error: module '%s' not found in the process\n" , module1 );

    /* Salgo con ERROR */
      ret = FALSE;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_modules_without_aslr ( char *snapshot_file , List &modules )
{
  SNAPSHOT_HEADER header;
  DUMPBLOCKV20 block;
  SECTION *section;
  unsigned int cont;
  char last_module [ sizeof ( block.name ) ];
  char permisos [ 16 ];
  char *module_name;
  void *module_base_candidate = NULL;
  unsigned int module_size = 0;
  void *allocated_module = NULL;
  void *data;
  int ret = TRUE;
  int res;
  FILE *f;

/* Abro el file pasado como parametro */
  f = fopen ( snapshot_file , "rb" );

/* Si pude abrir el file */
  if ( f != NULL )
  {
  /* Levanto el HEADER */
    res = fread ( &header , sizeof ( header ) , 1 , f );

//    printf ( "secciones = %i\n" , header.blockcount );
//    printf ( "sizeof1 = %i\n" , sizeof ( header ) );
//    printf ( "sizeof2 = %i\n" , sizeof ( block ) );

//    header.blockcount = 1;

  /* Si pude leer el header completo */
    if ( res == 1 )
    {
    /* Si el header es INVALIDO */
      if ( header.sig != 0x70616E73 )
      {
      /* Cierro el file */
        fclose ( f );

      /* Salgo con ERROR */
        return ( FALSE );
      }

    /* Tag inicial */
//      printf ( "\nProcessing snaphost file ...\n" );

    /* Inicializo el campo con el nombre del modulo al que pertenece la SECCION */
      strcpy ( block.name , "" );

    /* Inicializo el string */
      strcpy ( last_module , "" );

    /* Levanto TODAS las SECCIONES del SNAPSHOT */
      for ( cont = 0 ; cont < header.blockcount ; cont ++ )
      {
      /* Si es la version 1 de la estructura */
        if ( header.version == 1 )
        {
        /* Levanto el header de la siguiente seccion */
          res = fread ( &block , sizeof ( DUMPBLOCKV10 ) , 1 , f );
        }
      /* Si es la version con el nombre de la DLL */
        else if ( header.version == 2 )
        {
        /* Levanto el header de la siguiente seccion */
          res = fread ( &block , sizeof ( DUMPBLOCKV20 ) , 1 , f );
        }
      /* Si hay algun ERROR */
        else
        {
        /* Salgo con ERROR */
          return ( FALSE );
        }

      /* Si pude leer el HEADER del BLOQUE de MEMORIA */
        if ( res == 1 )
        {
        /* Si la seccion NO tiene ASLR */
          if ( ! ( block.Protect & RANDOMIZABLE ) )
          {
          /* Si PERTENECE a un MODULO */
            if ( strlen ( block.name ) > 0 )
            {
            /* Si NO pertenece al MISMO MODULO */
              if ( strcmp ( last_module , block.name ) != 0 )
              {
              /* Tengo un NUEVO MODULO */
                strncpy ( last_module , block.name , sizeof ( block.name ) );

              /* Creo un STRING para mantener el NOMBRE */
                module_name = ( char * ) malloc ( strlen ( last_module ) + 1 );
                strcpy ( module_name , last_module );

              /* Agrego el NOMBRE a la lista */
                modules.Add ( ( void * ) module_name );
              }
            }
          }

        /* Mensaje al usuario */
//          printf ( "* section: %.8I64x - %.8I64x %s %s\n" , block.BaseAddress , block.RegionSize , permisos , block.name );

        /* Avanzo a la SIGUIENTE SECCION */
          fseek ( f , block.RegionSize , SEEK_CUR );
        }
      /* Si hubo algun ERROR */
        else
        {
        /* Salgo con ERROR */
          return ( FALSE );
        }
      }
    }
  /* Si hubo algun PROBLEMA */
    else
    {
    /* Salgo con ERROR */
      ret = FALSE;
    }

  /* Cierro el file */
    fclose ( f );
  }
/* Si el file NO EXISTE */
  else
  {
  /* Salgo con ERROR */
    ret = FALSE;
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_snapshoted_module ( char *snapshot_file , char *module_name , void **module_base , void **module_address )
{
  SNAPSHOT_HEADER header;
  DUMPBLOCKV20 block;
  SECTION *section;
  unsigned int cont;
  char permisos [ 16 ];
  void *module_base_candidate = NULL;
  unsigned int module_size = 0;
  void *allocated_module = NULL;
  void *data;
  int ret = FALSE;
  int res;
  FILE *f;

/* Abro el file pasado como parametro */
  f = fopen ( snapshot_file , "rb" );

/* Si pude abrir el file */
  if ( f != NULL )
  {
  /* Levanto el HEADER */
    res = fread ( &header , sizeof ( header ) , 1 , f );

//    printf ( "secciones = %i\n" , header.blockcount );
//    printf ( "sizeof1 = %i\n" , sizeof ( header ) );
//    printf ( "sizeof2 = %i\n" , sizeof ( block ) );

//    header.blockcount = 1;

  /* Si pude leer el header completo */
    if ( res == 1 )
    {
    /* Si el header es INVALIDO */
      if ( header.sig != 0x70616E73 )
      {
      /* Cierro el file */
        fclose ( f );

      /* Salgo con ERROR */
        return ( FALSE );
      }

    /* Tag inicial */
//      printf ( "\nProcessing snaphost file ...\n" );

    /* Inicializo el campo con el nombre del modulo al que pertenece la SECCION */
      strcpy ( block.name , "" );

    /* Levanto TODAS las SECCIONES del SNAPSHOT */
      for ( cont = 0 ; cont < header.blockcount ; cont ++ )
      {
      /* Si es la version 1 de la estructura */
        if ( header.version == 1 )
        {
        /* Levanto el header de la siguiente seccion */
          res = fread ( &block , sizeof ( DUMPBLOCKV10 ) , 1 , f );
        }
      /* Si es la version con el nombre de la DLL */
        else if ( header.version == 2 )
        {
        /* Levanto el header de la siguiente seccion */
          res = fread ( &block , sizeof ( DUMPBLOCKV20 ) , 1 , f );
        }
      /* Si hay algun ERROR */
        else
        {
        /* Salgo con ERROR */
          return ( FALSE );
        }

      /* Si pude leer el HEADER del BLOQUE de MEMORIA */
        if ( res == 1 )
        {
        /* Armo el string con los permisos */
          strcpy ( permisos , "" );
          strcat ( permisos , ( block.Protect & RANDOMIZABLE ) ? "A" : "-" );
          strcat ( permisos , ( block.Protect & READABLE ) ? "R" : "-" );
          strcat ( permisos , ( block.Protect & WRITABLE ) ? "W" : "-" );
          strcat ( permisos , ( block.Protect & EXECUTABLE ) ? "X" : "-" );

        /* Mensaje al usuario */
//          printf ( "* section: %.8I64x - %.8I64x %s %s\n" , block.BaseAddress , block.RegionSize , permisos , block.name );

        /* Si es el modulo que estoy buscando */
          if ( stricmp ( module_name , block.name ) == 0 )
          {
          /* Si es la PRIMERA SECCION */
            if ( module_base_candidate == NULL )
            {
            /* Seteo la direccion BASE */
              module_base_candidate = ( void * ) block.BaseAddress;
            }

          /* Realloco la memoria para copiar */
            allocated_module = realloc ( allocated_module , module_size + ( unsigned int ) block.RegionSize );

          /* Copio la nueva SECCION */
//            memcpy ( ( void * ) ( ( char * ) allocated_module + module_size ) , data , ( unsigned int ) block.RegionSize );
            res = fread ( ( void * ) ( ( char * ) allocated_module + module_size ) , ( unsigned int ) block.RegionSize , 1 , f );

            /* Si NO pude leer el bloque de memoria */
            if ( res == 0 )
            {
            /* Salgo con ERROR */
              printf ( "[ ] Error: invalid snapshot\n" );
              exit ( 0 );
            }

          /* Sigo APPENDeando las SECCIONES */
            module_size += ( unsigned int ) block.RegionSize;

          /* Puedo retornar OK */
            ret = TRUE;
          }
        /* Si NO pertenece al modulo que me interesa */
          else
          {
          /* Avanzo a la siguiente seccion */
            fseek ( f , block.RegionSize , SEEK_CUR );
          }
        }
      /* Si hubo algun ERROR */
        else
        {
        /* Salgo con ERROR */
          return ( FALSE );
        }
      }
    }

  /* Cierro el file */
    fclose ( f );
  }

/* Linea para separar la lista */
//  printf ( "\n" );

/* Si pude encontrar el modulo */
  if ( ret == TRUE )
  {
  /* Si es un "MZ" */
    if ( memcmp ( allocated_module , "MZ" , 2 ) == 0 )
    {
    /* Base virtual y allocada del modulo */
      *module_base = module_base_candidate;
      *module_address = allocated_module;
    }
  /* Si es otra cosa */
    else
    {
    /* Salgo con ERROR */
      ret = FALSE;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_module_bases ( char *snapshot , char *module_name , void **snapshot_module_base , void **real_module_base )
{
  IMAGE_NT_HEADERS pe;
  void *module_virtual_address;
  unsigned int module_base;
  unsigned int pe_offset;
  int ret = TRUE;
  int res;

/* Inicializo el puntero a retornar */
  *real_module_base = NULL;

/* Mapeo el SNAPSHOT */
  res = get_snapshoted_module ( snapshot , module_name , &module_virtual_address , ( void ** ) &module_base );

/* Si el modulo NO pudo ser OBTENIDO */
  if ( res == FALSE )
  {
  /* Salgo con ERROR */
    printf ( "[ ] Error: module not found or invalid MZ file\n" );
    return ( FALSE );
  } 

/* Obtengo el puntero al PE */
  pe_offset = 0;
  read_memory ( ( void * ) ( ( unsigned int ) module_base + 0x3c ) , ( void * ) &pe_offset , sizeof ( pe_offset ) );
//  printf ( "PE offset = %x\n" , pe_offset );

/* Obtengo el HEADER del PE */
  read_memory ( ( void * ) ( module_base + pe_offset ) , ( void * ) &pe , sizeof ( IMAGE_NT_HEADERS ) );
//  printf ( "len = %i\n" , sizeof ( IMAGE_NT_HEADERS ) );

/* Retorno la BASE del modulo */
  *snapshot_module_base = module_virtual_address;
  *real_module_base = ( void * ) pe.OptionalHeader.ImageBase;

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_data_section ( char *snapshot , char *module_name , void *real_module_base , void **data_address , unsigned int *data_size )
{
  IMAGE_SECTION_HEADER *section;
  IMAGE_NT_HEADERS pe;
  void *module_virtual_address;
  void *address = NULL;
  unsigned int module_base;
  unsigned int pe_offset;
  unsigned int sections;
  unsigned int cont;
  int ret = FALSE;
  int res;

/* Mapeo el SNAPSHOT */
  res = get_snapshoted_module ( snapshot , module_name , &module_virtual_address , ( void ** ) &module_base );

/* Si el modulo NO pudo ser OBTENIDO */
  if ( res == FALSE )
  {
  /* Salgo con ERROR */
    printf ( "[ ] Error: module not found or invalid MZ file\n" );
    return ( ret );
  } 

/* Obtengo el puntero al PE */
  pe_offset = 0;
  read_memory ( ( void * ) ( ( unsigned int ) module_base + 0x3c ) , ( void * ) &pe_offset , sizeof ( pe_offset ) );
//  printf ( "PE offset = %x\n" , pe_offset );

/* Obtengo el HEADER del PE */
  read_memory ( ( void * ) ( module_base + pe_offset ) , ( void * ) &pe , sizeof ( IMAGE_NT_HEADERS ) );
//  printf ( "len = %i\n" , sizeof ( IMAGE_NT_HEADERS ) );

/* Obtengo la CANTIDAD de SECCIONES del MODULO */
  read_memory ( ( void * ) ( module_base + pe_offset ) , ( void * ) &pe , sizeof ( IMAGE_NT_HEADERS ) );
//  printf ( "sections = %i\n" , pe.FileHeader.NumberOfSections );

/* Address donde empiezan las secciones del binario */
  section = ( IMAGE_SECTION_HEADER * ) ( module_base + pe_offset + pe.FileHeader.SizeOfOptionalHeader + 0x18 );

/* Offset donde empiezan las secciones */
//  read_memory ( ( void * ) ( module_base + pe_address + 0x14 ) , sizeof ( sections_offset ) , ( unsigned char * ) &sections_offset , &leidos ); 
//  printf ( "arranca en %x\n" , section );

//  printf ( ".DATA en %x\n" , ( unsigned int ) module_virtual_address + pe.OptionalHeader.BaseOfData );

/* Recorro TODAS las SECCIONES */
  for ( cont = 0 ; cont < pe.FileHeader.NumberOfSections ; cont ++ )
  {
//    printf ( "section: %s\n" , section [ cont ].Name );

  /* Si el AREA es ESCRIBIBLE */
//    if ( stricmp ( section [ cont ].Name , ".data" ) == 0 )
    if ( section [ cont ].Characteristics & IMAGE_SCN_MEM_WRITE )
    {
    /* Obtengo el ADDRESS y el SIZE */
//      printf ( "-> %x - %x: %x\n" , ( unsigned int ) module_virtual_address + section [ cont ].VirtualAddress , section [ cont ].Misc.VirtualSize , section [ cont ].Characteristics );

    /* Retorno la BASE del AREA ESCRIBIBLE */
      *data_address = ( void * ) ( ( unsigned int ) real_module_base + section [ cont ].VirtualAddress );
      *data_size = section [ cont ].Misc.VirtualSize;

    /* Retorno OK */
      ret = TRUE;

    /* Dejo de buscar */
      break;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void parse_iat ( char *snapshot , char *module_name , List &fnames , List &faddresses )
{
  unsigned int module_base;
  unsigned int pe_offset;
  IMAGE_NT_HEADERS pe;
  IMAGE_DATA_DIRECTORY iat;
  IMAGE_IMPORT_DESCRIPTOR *pdescriptor;
  IMAGE_IMPORT_DESCRIPTOR descriptor;
  IMAGE_IMPORT_BY_NAME **pimported_functions;
  IMAGE_IMPORT_BY_NAME *pimported_function;
  IMAGE_IMPORT_BY_NAME imported_function;
  void *module_virtual_address;
  void *fname;
  char function_name [ 1024 ];
  char dll_name [ 1024 ];
  unsigned int pos;
  int ret;

/* Mapeo el SNAPSHOT */
  ret = get_snapshoted_module ( snapshot , module_name , &module_virtual_address , ( void ** ) &module_base );

/* Si el modulo NO pudo ser OBTENIDO */
  if ( ret == FALSE )
  {
  /* Salgo con ERROR */
    printf ( "[ ] Error: module not found or invalid MZ file\n" );
    return;
  } 

/* Obtengo la BASE del modulo */
//  printf ( "module = %x\n" , module_base );

/* Obtengo el puntero al PE */
  pe_offset = 0;
  read_memory ( ( void * ) ( ( unsigned int ) module_base + 0x3c ) , ( void * ) &pe_offset , sizeof ( pe_offset ) );
//  printf ( "PE offset = %x\n" , pe_offset );

/* Obtengo el HEADER del PE */
  read_memory ( ( void * ) ( module_base + pe_offset ) , ( void * ) &pe , sizeof ( IMAGE_NT_HEADERS ) );
//  printf ( "len = %i\n" , sizeof ( IMAGE_NT_HEADERS ) );

/* Obtengo la Import Table */
//  printf ( "IAT offset = %x\n" , pe.OptionalHeader.DataDirectory [ 1 ].VirtualAddress );
//  printf ( "IAT size = %x\n" , pe.OptionalHeader.DataDirectory [ 1 ].Size );

/* Apunto a la IAT */
  pdescriptor = ( IMAGE_IMPORT_DESCRIPTOR * ) ( module_base + pe.OptionalHeader.DataDirectory [ 1 ].VirtualAddress );
//  printf ( "IAT en %x\n" , pdescriptor );

/* Levanto el siguiente IMPORT DESCRIPTOR */
  read_memory ( ( void * ) pdescriptor , ( void * ) &descriptor , sizeof ( IMAGE_IMPORT_DESCRIPTOR ) );

/* Recorro la IAT */
  while ( descriptor.Name != NULL )
  {
  /* Obtengo el nombre de la DLL */
    read_memory ( ( void * ) ( module_base + descriptor.Name ) , ( void * ) dll_name , sizeof ( dll_name ) );

  /* Nombre de la DLL importada */
//    printf ( "%s\n" , dll_name );

  /* Apunto a los NOMBRES de las FUNCIONES IMPORTADAS */
    pimported_functions = ( IMAGE_IMPORT_BY_NAME ** ) ( module_base + descriptor.OriginalFirstThunk );
//    printf ( "string en %x\n" , pimported_functions );

//    asm int 3

  /* Inicializo el contador de funciones */
    pos = 0;

  /* Levanto la PRIMER ENTRADA */
//    asm int 3
    read_memory ( ( void * ) &pimported_functions [ pos ] , ( void * ) &pimported_function , sizeof ( IMAGE_IMPORT_BY_NAME * ) );

  /* Imprimo TODAS las funciones IMPORTADAS */
    while ( pimported_function != NULL )
    {
    /* Si es un PUNTERO VALIDO ( A veces NO estan los offset bien ! ) */
      if ( IsBadReadPtr ( ( void * ) ( module_base + ( unsigned int ) pimported_function -> Name ) , 1 ) == FALSE )
      {
      /* Obtengo el NOMBRE de la FUNCION */
//      printf ( "offset = %x\n" , imported_function.Name );
//      read_memory ( ( void * ) ( module_base + imported_function.Name ) , ( void * ) function_name , sizeof ( function_name ) );
        read_memory ( ( void * ) ( module_base + ( unsigned int ) pimported_function -> Name ) , ( void * ) function_name , sizeof ( function_name ) );
      }
    /* Si es un PUNTERO INVALIDO */
      else
      {
      /* Seteo un nombre simbolico */
        strcpy ( function_name , "???" );
      }     

    /* Imprimo el nombre de la funcion */
//      printf ( "%x: %s\n" , ( unsigned int ) module_virtual_address + descriptor.FirstThunk + ( sizeof ( void * ) * pos ) , function_name );

    /* Agrego la funcion a la lista */
      fname = malloc ( strlen ( function_name ) + 1 );
      strcpy ( ( char * ) fname , function_name );
      fnames.Add ( ( void * ) fname );
      faddresses.Add ( ( void * ) ( ( unsigned int ) module_virtual_address + descriptor.FirstThunk + ( sizeof ( void * ) * pos ) ) );

    /* Avanzo en las tablas */
      pos ++;

    /* Levanto el siguiente PUNTERO a estructura con la FUNCION IMPORTADA */
//      printf ( "&pimported_functions [ %i ] = %x\n" , pos , &pimported_functions [ pos ] );
      read_memory ( ( void * ) &pimported_functions [ pos ] , ( void * ) &pimported_function , sizeof ( IMAGE_IMPORT_BY_NAME * ) );
    }

  /* Avanzo a la proxima DLL importada */
    pdescriptor ++;

  /* Levanto el siguiente IMPORT DESCRIPTOR */
    read_memory ( ( void * ) pdescriptor , ( void * ) &descriptor , sizeof ( IMAGE_IMPORT_DESCRIPTOR ) );
  }
}

////////////////////////////////////////////////////////////////////////////////

void *get_pointer_to_function_address ( char *snapshot , char *module_name , void *module_base , void *real_module_base , char *function_name )
{
  List fnames;
  List faddresses;
  unsigned int cont;
  void *address = NULL;

/* Obtengo TODAS las funciones IMPORTADAS del modulo */
  parse_iat ( snapshot , module_name , fnames , faddresses );

/* Recorro TODAS las funciones ENCONTRADAS */
  for ( cont = 0 ; cont < fnames.Len () ; cont ++ )
  {
  /* Si es la funcion que estoy BUSCANDO */
    if ( strcmp ( function_name , ( char * ) fnames.Get ( cont ) ) == 0 )
    {
    /* Retorno el PUNTERO en la IAT */
      address = faddresses.Get ( cont );
      address = ( void * ) ( ( char * ) real_module_base + ( ( char * ) address - ( char * ) module_base ) );

    /* Dejo de buscar */
      break;
    }
  }

  return ( address );
}

////////////////////////////////////////////////////////////////////////////////

void set_iat_pops_and_comments ( void *vp_address , List &invalid_chars , List &gadgets , List &values_to_pop , List &comments )
{
  unsigned int cont, cont2;
  void *value_to_pop;
  char *comment;
  GADGET *sub_gadget;
  GADGET *next_gadget;
  GADGET *gadget;
  List sub_gadgets;

/* Recorro TODOS los GADGETS que lo COMPONEN */
  for ( cont = 0 ; cont < gadgets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE */
    gadget = ( GADGET * ) gadgets.Get ( cont );

  /* Limpio la lista */
    sub_gadgets.Clear ();

  /* Si es un GADGET COMUN */
    if ( gadget -> is_super_gadget == FALSE )
    {
    /* Agrego este MISMO GADGET */
      sub_gadgets.Add ( ( void * ) gadget );
    }
    else
    {
    /* Obtengo TODOS los GADGETS que lo componen */
      decompose_gadget ( gadget , sub_gadgets );
    }

  /* Inicializo el VALOR a POPEAR/COMENTAR */
    value_to_pop = NULL;
    comment = ( char * ) NULL;

  /* Si es el PRIMER GADGET ( "POP IAT.VirtualProtect" ) */
    if ( cont == 0 )
    {
    /* Si la direccion en la IAT NO tiene INVALID CHARS */
      if ( has_invalid_chars ( invalid_chars , vp_address ) == FALSE )
      {
      /* Agrego la DIRECCION de "VirtualProtect" en la IAT */
        value_to_pop = vp_address;
        comment = "IAT.VirtualProtect ADDRESS";
      }
    /* Si la direccion en la IAT tiene INVALID CHARS */
      else
      {
      /* Recorro TODOS los GADGETS RESTANTES */
        for ( cont2 = cont + 1 ; cont2 < gadgets.Len () ; cont2 ++ )
        {
        /* Levanto el SIGUIENTE GADGET */
          next_gadget = ( GADGET * ) gadgets.Get ( cont2 );

        /* Si el gadget usa NEG */
          if ( next_gadget -> operation == OP_REG_TO_NEG_REG )
          {
          /* Niego la direccion */
            value_to_pop = ( void * ) ( - ( ( int ) vp_address ) );

          /* Comentario a mostrar */
            comment = "NEG (IAT.VirtualProtect ADDRESS)";

          /* Dejo de buscar */
            break;
          }
        /* Si el gadget usa NEG */
          else if ( next_gadget -> operation == OP_REG_TO_NOT_REG )
          {
          /* Niego la direccion */
            value_to_pop = ( void * ) ( ~ ( ( int ) vp_address ) );

          /* Comentario a mostrar */
            comment = "NOT (IAT.VirtualProtect ADDRESS)";

          /* Dejo de buscar */
            break;
          }
        }
      }
    }

  /* Recorro TODOS los SUB-GADGETS que componen ESTE GADGET */
    for ( cont2 = 0 ; cont2 < sub_gadgets.Len () ; cont2 ++ )
    {
    /* Levanto el SIGUIENTE SUB-GADGET */
      sub_gadget = ( GADGET * ) sub_gadgets.Get ( cont2 );

    /* Si es el PRIMERO de la lista ( generalmente un "POP" ) */
      if ( cont2 == 0 )
      {
      /* Agrego el POP/COMMENT del SUPER-GADGET */
        values_to_pop.Add ( value_to_pop );
        comments.Add ( ( void * ) comment );
      }
    /* Si es un SUB-GADGET */
      else
      {
      /* No pongo NADA como POP/COMMENT */
        values_to_pop.Add ( NULL );
        comments.Add ( NULL );
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

void set_pushad_ret_pops_and_comments ( void *vp_address , void *data_section , unsigned int data_size , void *ret_nop_address , List &invalid_chars , GADGET *final_gadget , List &gadgets , List &values_to_pop , List &comments )
{
  unsigned int cont, cont2;
  void *value_to_pop;
  void *address;
  void *value;
  char *comment;
  GADGET *sub_gadget;
  GADGET *gadget;
  List sub_gadgets;
  List iat_rop_chain;
  void *waddress;

/* Recorro TODOS los GADGETS que lo COMPONEN */
  for ( cont = 0 ; cont < gadgets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE */
    gadget = ( GADGET * ) gadgets.Get ( cont );

  /* Si es el GADGET con el valor de la IAT */
    if ( gadget -> is_special_gadget == TRUE )
    {
    /* Gadget usados para leer la IAT */
      iat_rop_chain.Append ( gadget -> gadgets );

    /* Seteo los COMENTARIOS de "IAT.VirtualProtect" */
      set_iat_pops_and_comments ( vp_address , invalid_chars , iat_rop_chain , values_to_pop , comments );

    /* Paso al siguiente */
      continue;
    }

  /* Limpio la lista */
    sub_gadgets.Clear ();

  /* Si es un GADGET COMUN */
    if ( gadget -> is_super_gadget == FALSE )
    {
    /* Agrego este MISMO GADGET */
      sub_gadgets.Add ( ( void * ) gadget );
    }
    else
    {
    /* Obtengo TODOS los GADGETS que lo componen */
      decompose_gadget ( gadget , sub_gadgets );
    }

  /* Inicializo el VALOR a POPEAR/COMENTAR */
    value_to_pop = NULL;
    comment = ( char * ) NULL;

  /* Si es del tipo "POP REG/RET" */
    if ( gadget -> operation == OP_MEM_TO_REG )
    {
    /* Si es EDI */
      if ( gadget -> register_index == EDI_REGISTER )
      {
      /* Si el GADGET FINAL termina en RET */
        if ( final_gadget -> ending_type == RET_ENDING )
        {
        /* Obtengo la direccion de la ultima instruccion del FINAL GADGET */
//          address = final_gadget -> addresses -> Get ( final_gadget -> addresses -> Len () - 1 );
          address = ret_nop_address;

        /* Apunto al 'RET' del FINAL GADGET */
          value_to_pop = address; // Return to RET

        /* Gadget con solo un "RET" */
          comment = "\"RET NOP\""; // RETURN to RET
        }
      }
    /* Si es ESI */
      else if ( gadget -> register_index == ESI_REGISTER )
      {
      /* Si el GADGET FINAL termina en 'RETF' */
        if ( final_gadget -> ending_type == RETF_ENDING )
        {
        /* Si tengo que NEGAR este VALOR */
          if ( gadget -> negator == TRUE )
          {
          /* Si es un NOT */
            if ( get_negation_type ( gadget ) == OP_REG_TO_NOT_REG )
            {
            /* Valor a POPEAR */
              value = ( void * ) ~ 0x1b;  // WINDOWS CODE SELECTOR
            }
            else
            {
            /* Valor a POPEAR */
              value = ( void * ) - 0x1b;  // WINDOWS CODE SELECTOR
            }
          }
        /* Si NO es un INVALID CHAR */
          else
          {
          /* Valor a POPEAR */
            value = ( void * ) 0x1b;  // WINDOWS CODE SELECTOR
          }

        /* Agrego el selector de codigo de Windows */
          value_to_pop = value; // WINDOWS CODE SELECTOR

        /* Agrego el selector de codigo de Windows */
          comment = "WINDOWS CODE SELECTOR"; // WINDOWS CODE SELECTOR
        }
      /* Si el GADGET FINAL termina en 'RET 4' */
        else if ( final_gadget -> ending_type == RETN_ENDING )
        {
        /* Padding */
          value_to_pop = ( void * ) 0x41414141; // PADDING

        /* Agrego el selector de codigo de Windows */
          comment = "PADDING"; // WINDOWS CODE SELECTOR
        }
      }
    /* Si es EBP */
      else if ( gadget -> register_index == EBP_REGISTER )
      {
      /* Uso el RET del MISMO gadget */
        value_to_pop = gadget -> address; // "RET" address
        comment = "\"ADD ESP,4/RET\"";
      }
    /* Si es EBX */
      else if ( gadget -> register_index == EBX_REGISTER )
      {
      /* Si tengo que NEGAR este VALOR */
        if ( gadget -> negator == TRUE )
        {
        /* Si es un NOT */
          if ( get_negation_type ( gadget ) == OP_REG_TO_NOT_REG )
          {
          /* Valor a POPEAR */
            value = ( void * ) ~ 0x1;  // REGION SIZE
          }
          else
          {
          /* Valor a POPEAR */
            value = ( void * ) - 0x1;  // REGION SIZE
          }
        }
      /* Si NO es un INVALID CHAR */
        else
        {
        /* Busco un SIZE que NO TENGA INVALID CHARS */
          for ( cont2 = 1 ; cont2 <= 256 ; cont2 ++ )
          {
          /* Si este size NO TIENE INVALID CHARS */
            if ( has_invalid_chars ( invalid_chars , ( void * ) cont2 ) == FALSE )
            {
            /* SIZE a POPEAR */
              value = ( void * ) cont2;  // REGION SIZE

            /* Dejo de buscar */
              break;
            }
          }
        }

      /* Valor a POPEAR */
        value_to_pop = value; // REGION SIZE
        comment = "REGION SIZE";
      }
    /* Si es EDX */
      else if ( gadget -> register_index == EDX_REGISTER )
      {
      /* Si tengo que NEGAR este VALOR */
        if ( gadget -> negator == TRUE )
        {
        /* Si es un NOT */
          if ( get_negation_type ( gadget ) == OP_REG_TO_NOT_REG )
          {
          /* Valor a POPEAR */
            value = ( void * ) ~ 0x40;  // PROTECTION
          }
          else
          {
          /* Valor a POPEAR */
            value = ( void * ) - 0x40;  // PROTECTION
          }
        }
      /* Si NO es un INVALID CHAR */
        else
        {
        /* Valor a POPEAR */
          value = ( void * ) 0x40;  // PROTECTION
        }

      /* Valor a POPEAR */
        value_to_pop = value; // PROTECTION
        comment = "PROTECTION";
      }
    /* Si es ECX */
      else if ( gadget -> register_index == ECX_REGISTER )
      {
      /* Obtengo una DIRECCION ESCRIBIBLE SIN INVALID CHARS */
        waddress = get_valid_address ( data_section , data_size , invalid_chars );

      /* Valor a POPEAR */
//        value_to_pop = ( void * ) 0x20ffc; // WRITABLE ADDRESS
//        value_to_pop = ( void * ) ( ( unsigned int ) data_section + data_size - sizeof ( void * ) ); // WRITABLE ADDRESS
        value_to_pop = waddress; // WRITABLE ADDRESS
        comment = "WRITABLE ADDRESS";
      }
    }

  /* Recorro TODOS los SUB-GADGETS que componen ESTE GADGET */
    for ( cont2 = 0 ; cont2 < sub_gadgets.Len () ; cont2 ++ )
    {
    /* Levanto el SIGUIENTE SUB-GADGET */
      sub_gadget = ( GADGET * ) sub_gadgets.Get ( cont2 );

    /* Si es el PRIMERO de la lista ( generalmente un "POP" ) */
//      if ( cont2 == 0 )
      if ( sub_gadget -> operation == OP_MEM_TO_REG )
      {
      /* Agrego el POP/COMMENT del SUPER-GADGET */
        values_to_pop.Add ( value_to_pop );
        comments.Add ( ( void * ) comment );
      }
    /* Si es un SUB-GADGET */
      else
      {
      /* No pongo NADA como POP/COMMENT */
        values_to_pop.Add ( NULL );
        comments.Add ( NULL );
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

void set_jmp_esp_pops_and_comments ( List &gadgets , List &values_to_pop , List &comments , void *ret_nop_address )
{
  GADGET *final_gadget;
  GADGET *sub_gadget;
  GADGET *gadget;
  unsigned int cont, cont2;
  void *value_to_pop;
  void *address = NULL;
  char *comment;
  List sub_gadgets;

/* Recorro TODOS los GADGETS que lo COMPONEN */
  for ( cont = 0 ; cont < gadgets.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE */
    gadget = ( GADGET * ) gadgets.Get ( cont );

  /* Limpio la lista */
    sub_gadgets.Clear ();

  /* Si es un GADGET COMUN ( "JMP ESP" ) */
    if ( gadget -> is_super_gadget == FALSE )
    {
    /* Agrego este MISMO GADGET */
      sub_gadgets.Add ( ( void * ) gadget );
    }
    else
    {
    /* Obtengo TODOS los GADGETS que lo componen */
      decompose_gadget ( gadget , sub_gadgets );

    /* Obtengo el ULTIMO GADGET (PUSHAD/RET) */
      final_gadget = ( GADGET * ) sub_gadgets.Get ( sub_gadgets.Len () - 1 );

    /* Return to RET */
      address = ret_nop_address;
    }

  /* Recorro TODOS los SUB-GADGETS */
    for ( cont2 = 0 ; cont2 < sub_gadgets.Len () ; cont2 ++ )
    {
    /* Levanto el siguiente GADGET */
      sub_gadget = ( GADGET * ) sub_gadgets.Get ( cont2 );

    /* Inicializo el VALOR a POPEAR/COMENTAR */
      value_to_pop = NULL;
      comment = ( char * ) NULL;

    /* Si es un "JMP ESP" */
      if ( sub_gadget -> register_index == EIP_REGISTER )
      {
      /* NO HAGO NADA */
      }
    /* Si es del tipo "POP REG/RET" */
      else if ( sub_gadget -> operation == OP_MEM_TO_REG )
      {
      /* Si es EDI */
        if ( sub_gadget -> register_index == EDI_REGISTER )
        {
        /* Apunto al 'RET' del FINAL GADGET */
          value_to_pop = address; // Return to RET

        /* Gadget con solo un "RET" */
          comment = "\"RET NOP\""; // RETURN to RET
        }
      /* Si es ESI */
        else if ( sub_gadget -> register_index == ESI_REGISTER )
        {
        /* Si el GADGET FINAL termina en 'RET' COMUN */
          if ( final_gadget -> ending_type == RET_ENDING )
          {
          /* Apunto al 'RET' del FINAL GADGET */
            value_to_pop = address; // Return to RET

          /* Agrego el selector de codigo de Windows */
            comment = "\"RET NOP\""; // RETURN to RET
          }
        /* Si el GADGET FINAL termina en 'RETF' */
          else if ( final_gadget -> ending_type == RETF_ENDING )
          {
          /* Agrego el selector de codigo de Windows */
            value_to_pop = ( void * ) 0x1b; // WINDOWS CODE SELECTOR

          /* Agrego el selector de codigo de Windows */
            comment = "WINDOWS CODE SELECTOR"; // WINDOWS CODE SELECTOR
          }
        /* Si el GADGET FINAL termina en 'RET 4' */
          else if ( final_gadget -> ending_type == RETN_ENDING )
          {
          /* Padding */
            value_to_pop = ( void * ) 0x41414141; // PADDING

          /* Agrego el selector de codigo de Windows */
            comment = "PADDING"; // WINDOWS CODE SELECTOR
          }
        }
      /* Si es EBP */
        else if ( sub_gadget -> register_index == EBP_REGISTER )
        {
        /* Apunto al 'RET' del FINAL GADGET */
          value_to_pop = address; // Return to RET

        /* Ultimo GADGET antes de SALTAR AL STACK */
          comment = "\"RET NOP --> JMP ESP\"";
        }
      }

    /* Agrego el VALOR A POPEAR/COMENTARIO AL GADGET */
      values_to_pop.Add ( value_to_pop );
      comments.Add ( ( void * ) comment );
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

int start_building_process ( int new_analysis , char *settings , char *snapshot )
{
  List all_gadgets;
  List negator_rets;
  List pushad_rets;
  List pop_reg32_rets;
  List mov_reg32_reg32_rets;
  List mov_reg32_creg32_rets;
  List jmp_esps;
  List super_iat_rop_chain;
  List super_sub_rop_chain;
  List super_jmp_esp_rop_chain;
  List iat_rop_chain;
  List sub_rop_chain;
  List jmp_esp_rop_chain;
  List rop_chain;
  List first_values_to_pop;
  List second_values_to_pop;
  List third_values_to_pop;
  List first_comments;
  List second_comments;
  List third_comments;
  List esi_sub_rop_chain;
  List edi_sub_rop_chain;
  List final_values_to_pop;
  List values_to_pop;
  List final_comments;
  List comments;
  List invalid_chars;
  List module_list;
  List incrementor_rets;
  GADGET *jmp_esp_gadget;
  GADGET *final_gadget;
  GADGET *gadget;
  char *module_name;
  char *last_instruction;
  char *comment;
  void *data_section_address = NULL;
  void *ret_nop_address;
  void *real_module_base;
  void *module_base;
  void *vp_address;
  void *address;
  unsigned int data_section_size;
  unsigned int register_used;
  unsigned int padding_size;
  unsigned int cont;
  unsigned int ti, tf;
  int ret;

///////////

/* Mensaje al usuario */
  printf ( "\n[x] Starting process\n" );

///////////

/* Obtengo los INVALID CHARS */
  get_invalid_chars ( settings , invalid_chars );

///////////

/* Obtengo la LISTA de MODULOS donde ROPear */
  ret = get_rop_module_list ( settings , snapshot , module_list );

/* Si hubo algun problema */
  if ( ret == FALSE )
  {
  /* Mensaje al USUARIO */
    printf ( "[ ] Error: module list error\n" );
    return ( FALSE );
  }

///////////

/* Si el USUARIO NO declaro MODULOS donde ROPear */
  if ( module_list.Len () == 0 )
  {
  /* Obtengo la LISTA de MODULOS que NO tienen ASLR */
    ret = get_modules_without_aslr ( snapshot , module_list );

  /* Si hay algun problema con el SNAPSHOT */
    if ( ret == FALSE )
    {
    /* Mensaje al USUARIO */
      printf ( "[ ] Error: the snapshot doesn't exist or is invalid\n" );
      exit ( 0 );
    }

  /* Si TODOS los modulos TIENEN ASLR */
    if ( module_list.Len () == 0 )
    {
    /* Mensaje al USUARIO */
      printf ( "[ ] Error: all modules have ASLR\n" );
      return ( FALSE );
    }
  }

///////////

/* Recorro TODOS los MODULOS que NO TIENEN ASLR */
  for ( cont = 0 ; cont < module_list.Len () ; cont ++ )
  {
  /* Levanto el SIGUIENTE NOMBRE */
    module_name = ( char * ) module_list.Get ( cont );
    printf ( "[x] Module name: %s\n" , module_name );

  /* Obtengo la BASE del MODULO */
    ret = get_module_bases ( snapshot , module_name , &module_base , &real_module_base );

  /* Si el modulo NO esta en el SNAPSHOT */
    if ( ret == FALSE )
    {
    /* Mensaje al USUARIO */
      return ( FALSE );
    }

  /* Base del modulo */
    printf ( "[x] Module base = %x\n" , real_module_base );

  ///////////

  /* Obtengo la DIRECCION de la SECCION ".data" ( o CUALQUIERA ESCRIBIBLE ) */
    ret = get_data_section ( snapshot , module_name , real_module_base , &data_section_address , &data_section_size );
    printf ( "[x] WRITABLE SECTION = %x - %x\n" , data_section_address , ( unsigned int ) data_section_address + data_section_size );

  /* Busco el puntero a "VirtualProtect" */
    vp_address = get_pointer_to_function_address ( snapshot , module_name , module_base , real_module_base , "VirtualProtect" );
    printf ( "[x] IAT.VirtualProtect = %x\n" , vp_address );

  /* Si pude obtener la direccion de "VirtualProtect" */
    if ( vp_address != NULL )
    {
    /* Dejo de buscar */
      break;
    }
  }

/* Si NO pude obtener un MODULO con .DATA */
  if ( data_section_address == NULL )
  {
  /* Apunto al area 0x20000 */
    data_section_address = ( void * ) 0x20000;
    data_section_size = 0x1000;
  }

///////////

/* Si hay INVALID CHARS */
  if ( invalid_chars.Len () > 0 )
  {
  /* Si el 0 o el 0x40 es INVALID CHAR */
    if ( ( invalid_chars.Find ( ( void * ) 0x0 ) == TRUE ) || ( invalid_chars.Find ( ( void * ) 0x40 ) == TRUE ) )
    {
    /* Si el 0xff en INVALID CHAR */
      if ( invalid_chars.Find ( ( void * ) 0xff ) == TRUE )
      {
      /* NO se puede setear SIZE ni PROTECTION */
        printf ( "[ ] Error: invalid chars don't allow to set VirtualProtect SIZE/PROTECTION\n" );
        return ( FALSE );
      }
    }

  /* Si el 0x40 es INVALID CHAR */
    if ( invalid_chars.Find ( ( void * ) 0x40 ) == TRUE )
    {
    /* Si 0xbf y 0xc0 son INVALID CHAR */
      if ( ( invalid_chars.Find ( ( void * ) 0xbf ) == TRUE ) && ( invalid_chars.Find ( ( void * ) 0xc0 ) == TRUE ) )
      {
      /* NO se puede setear SIZE ni PROTECTION */
        printf ( "[ ] Error: invalid chars don't allow to set VirtualProtect.PROTECTION\n" );
        return ( FALSE );
      }
    }

  /* Si el 0x00, el 0x40 o IAT.VirtualProtect tiene INVALID CHARS */
    if ( ( invalid_chars.Find ( ( void * ) 0x0 ) == TRUE ) || ( invalid_chars.Find ( ( void * ) 0x40 ) == TRUE ) || ( has_invalid_chars ( invalid_chars , vp_address ) == TRUE ) )
    {
    /* Obtengo todos los GADGETS NEGADORES */
      get_negator_rets ( new_analysis , module_base , real_module_base , settings , snapshot , invalid_chars , negator_rets );

    /* Si tengo problemas con el 0 ( SIZE afectado ! ) */
      if ( invalid_chars.Find ( ( void * ) 0x0 ) == TRUE )
      {
      /* Obtengo todos los GADGETS INCREMENTADORES */
        get_incrementor_rets ( new_analysis , module_base , real_module_base , settings , snapshot , invalid_chars , incrementor_rets );

      /* ORDENO los gadgets de MEJOR a PEOR */
        sort_incrementor_rets ( incrementor_rets );
      }

    /* Agrego los GADGETS a la LISTA TOTAL */
      all_gadgets.Append ( negator_rets );

    /* Mensaje al USUARIO */
      printf ( "[x] NOT-NEG/RET gadgets found: %i\n" , negator_rets.Len () );

    /* ORDENO los gadgets de MEJOR a PEOR */
      sort_negator_rets ( negator_rets );
    }
  }

///////////

/* Busco gadgets del tipo "PUSHAD/RET" */
  get_pushad_rets ( new_analysis , module_base , real_module_base , settings , snapshot , invalid_chars , pushad_rets );

/* Agrego los GADGETS a la LISTA TOTAL */
  all_gadgets.Append ( pushad_rets );

//  get_pushad_rets ( FALSE , settings , snapshot , pushad_rets );
  printf ( "[x] PUSHAD/RET gadgets found: %i\n" , pushad_rets.Len () );

/* ORDENO los gadget de MEJOR a PEOR */
  sort_pushad_rets ( pushad_rets );

/* Imprimo los GADGETS ORDENADOS */
//  for ( cont = 0 ; cont < pushad_rets.Len () ; cont ++ )
//  {
//    gadget = ( GADGET * ) pushad_rets.Get ( cont );
//    printf ( "%i: %x\n" , cont , gadget -> address );
//  }

/* Si NO tengo "PUSHAD/RETS" NO PUEDO SEGUIR */
  if ( pushad_rets.Len () == 0 )
  {
  /* Mensaje al USUARIO */
    printf ( " [ ] Error: it's not possible to build a ROP Chain\n" );
    return ( FALSE );
  }

///////////

/* Busco gadgets que muevan un REGISTRO a otro REGISTRO */
  get_mov_reg32_reg32_rets ( new_analysis , module_base , real_module_base , settings , snapshot , invalid_chars , mov_reg32_reg32_rets );
  printf ( "[x] REG32=REG32/RET gadgets found: %i\n" , mov_reg32_reg32_rets.Len () );

/* ORDENO los gadget de MEJOR a PEOR */
  sort_mov_reg32_reg32_rets ( mov_reg32_reg32_rets );

/* Armo los SUPER-GADGETS */
  add_super_mov_reg32_reg32_rets ( mov_reg32_reg32_rets );

/* Agrego los GADGETS a la LISTA TOTAL */
  all_gadgets.Append ( mov_reg32_reg32_rets );

/* Imprimo los GADGETS ORDENADOS */
//  for ( cont = 0 ; cont < mov_reg32_reg32_rets.Len () ; cont ++ )
//  {
//    gadget = ( GADGET * ) mov_reg32_reg32_rets.Get ( cont );
//    printf ( "%i: %x\n" , cont , gadget -> address );
//  }

///////////

/* Busco gadgets del tipo "POP REG32/RET" */
  get_pop_reg32_rets ( new_analysis , module_base , real_module_base , settings , snapshot , invalid_chars , pop_reg32_rets );
  printf ( "[x] POP REG/RET gadgets found: %i\n" , pop_reg32_rets.Len () );

/* ORDENO los gadget de MEJOR a PEOR */
  sort_pop_reg32_rets ( pop_reg32_rets );

/* Armo los SUPER-GADGETS */
  add_super_pop_reg32_rets ( mov_reg32_reg32_rets , pop_reg32_rets );

/* Si hay INVALID CHARS */
  if ( invalid_chars.Len () > 0 )
  {
  /* Armo los SUPER-GADGETS NEGADOS */
    add_super_negated_pop_reg32_rets ( pop_reg32_rets , mov_reg32_reg32_rets , negator_rets );

  /* Armo los SUPER-GADGETS INCREMENTORS */
    add_super_incrementors_pop_reg32_rets ( pop_reg32_rets , incrementor_rets );
  }

//  printf ( "bye bye ...\n" );
//  return ( 0 );

/* Agrego los GADGETS a la LISTA TOTAL */
  all_gadgets.Append ( pop_reg32_rets );

/* Imprimo los GADGETS ORDENADOS */
//  for ( cont = 0 ; cont < pop_reg32_rets.Len () ; cont ++ )
//  {
//    gadget = ( GADGET * ) pop_reg32_rets.Get ( cont );
//    printf ( "%i: %x\n" , cont , gadget -> address );
//  }

/* Si NO tengo "POP REG32/RETS" NO PUEDO SEGUIR */
  if ( pop_reg32_rets.Len () == 0 )
  {
  /* Mensaje al USUARIO */
    printf ( " [ ] Error: it's not possible to build a ROP Chain\n" );
    return ( FALSE );
  }

///////////

/* Busco gadgets que muevan MEMORIA a un REGISTRO */
  get_mov_reg32_creg32_rets ( new_analysis , module_base , real_module_base , settings , snapshot , invalid_chars , mov_reg32_creg32_rets );
  printf ( "[x] REG=[MEM]/RET gadgets found: %i\n" , mov_reg32_creg32_rets.Len () );

/* Agrego los GADGETS a la LISTA TOTAL */
  all_gadgets.Append ( mov_reg32_creg32_rets );

/* ORDENO los gadget de MEJOR a PEOR */
  sort_mov_reg32_creg32_rets ( mov_reg32_creg32_rets );

/* Si NO tengo "MOV REG1,[REG2+0x00]" NO PUEDO SEGUIR */
  if ( mov_reg32_creg32_rets.Len () == 0 )
  {
  /* Mensaje al USUARIO */
    printf ( " [ ] Error: it's not possible to read the IAT of the module\n" );
    return ( FALSE );
  }

/* Imprimo los GADGETS ORDENADOS */
//  for ( cont = 0 ; cont < mov_reg32_creg32_rets.Len () ; cont ++ )
//  {
//    gadget = ( GADGET * ) mov_reg32_creg32_rets.Get ( cont );
//    printf ( "%i: %x\n" , cont , gadget -> address );
//  }

///////////

/* Busco un RET NOP para USAR */
  ret_nop_address = get_ret_nop ( all_gadgets , invalid_chars );
//  printf ( "RET NOP VALIDO = %x\n" , ret_nop_address );

///////////

/* Busco "JMP ESPs" */
  get_jmp_esps ( new_analysis , module_base , real_module_base , settings , snapshot , invalid_chars , jmp_esps );
  printf ( "[x] JMP ESPs gadgets found: %i\n" , jmp_esps.Len () );

/* Agrego los GADGETS a la LISTA TOTAL */
  all_gadgets.Append ( jmp_esps );

/* ORDENO los gadget de MEJOR a PEOR */
  sort_jmp_esps ( jmp_esps );

/* Si hay algun "JMP ESP" */
  if ( jmp_esps.Len () > 0 )
  {
  /* Obtengo el MEJOR "JMP ESP" */
    jmp_esp_gadget = ( GADGET * ) jmp_esps.Get ( 0 );
  }
/* Si NO tengo "JMP ESPS" */
  else
  {
  /* Mensaje al USUARIO */
    printf ( " [x] Building a special JMP ESP ...\n" ); 

  /* Obtengo un SUPER-GADGET con un "JMP ESP" */
    jmp_esp_gadget = get_super_jmp_esp ( pushad_rets , pop_reg32_rets , ret_nop_address );
  }

/* Si NO se PUDO ENCONTRAR un "JMP ESP" */
  if ( jmp_esp_gadget == NULL )
  {
  /* Mensaje al USUARIO */
    printf ( " [ ] Error: it's not possible to build a ROP Chain\n" );
    return ( FALSE );
  }

/* Agrego el GADGET a la LISTA */
  super_jmp_esp_rop_chain.Add ( ( void * ) jmp_esp_gadget );

/* Obtengo los POPS/COMENTS para el TERCER SUB-ROP-CHAIN */
  set_jmp_esp_pops_and_comments ( super_jmp_esp_rop_chain , third_values_to_pop , third_comments , ret_nop_address );

///////////

/* Armo los 2 sub-rop-chains ( STACK -> IAT -> ESI/EDI ) */
  ret = find_iat_rop_chains ( vp_address , invalid_chars , pop_reg32_rets , mov_reg32_reg32_rets , mov_reg32_creg32_rets , esi_sub_rop_chain , edi_sub_rop_chain );

/* Si hay SOLUCION para ESI */
//  if ( esi_sub_rop_chain.Len () > 0 )
//  {
//    List simple_gadgets;
//
//    printf ( "[x] ESI solution ...\n" );
//
//  /* Obtengo la CADENA de GADGETS */
//    get_simple_gadgets ( esi_sub_rop_chain , simple_gadgets );
//
//  /* Recorro los gadgets */
//    for ( cont = 0 ; cont < simple_gadgets.Len () ; cont ++ )
//    {
//      gadget = ( GADGET * ) esi_sub_rop_chain.Get ( cont );
//      gadget = ( GADGET * ) simple_gadgets.Get ( cont );
//      printf ( "%i: %x\n" , cont , gadget -> address );
//    }
//  }

///* Si hay SOLUCION para EDI */
//  if ( edi_sub_rop_chain.Len () > 0 )
//  {
//    printf ( "[x] EDI solution ...\n" );
//
//  /* Recorro los gadgets */
//    for ( cont = 0 ; cont < edi_sub_rop_chain.Len () ; cont ++ )
//    {
//      gadget = ( GADGET * ) edi_sub_rop_chain.Get ( cont );
//      printf ( "%i: %x\n" , cont , gadget -> address );
//    }
//  }

//  printf ( "borrar esto !!!\n" );
//  esi_sub_rop_chain.Clear ();
//  edi_sub_rop_chain.Clear ();

///////////

/* Tiempo Inicial */
//  ti = GetTickCount ();

/* Clasifico una CONEXION DIRECTA entre los GADGETS */
  ret = find_direct_gadgets ( vp_address , invalid_chars , esi_sub_rop_chain , edi_sub_rop_chain , pushad_rets , pop_reg32_rets , mov_reg32_reg32_rets , super_sub_rop_chain , &register_used );

/* Tiempo final */
//  tf = GetTickCount ();
//  printf ( "[x] Elapsed time: %u ms\n" , tf - ti );

/* Si es POSIBLE generar un ROP CHAIN */
  if ( ret == FALSE )
  {
  /* Mensaje al USUARIO */
    printf ( "[ ] Error: there is not way to build a ROP CHAIN\n" );
    return ( FALSE );
  }

///////////

/* Obtengo el ULTIMO GADGET ( "PUSHAD/RET" ) */
  final_gadget = ( GADGET * ) super_sub_rop_chain.Get ( super_sub_rop_chain.Len () - 1 );

///////////

/* Si es un ROP-CHAIN con "ESI = VirtualProtect" */
  if ( register_used == ESI_REGISTER )
  {
  /* Gadgets que lo COMPONEN */
    super_iat_rop_chain.Append ( esi_sub_rop_chain );
  }
/* Si es un ROP-CHAIN con "EDI = VirtualProtect" */
  else
  {
  /* Gadgets que lo COMPONEN */
    super_iat_rop_chain.Append ( edi_sub_rop_chain );
  }

///////////

/* Obtengo los POPS/COMENTS para el SEGUNDO SUB-ROP-CHAIN */
  set_pushad_ret_pops_and_comments ( vp_address , data_section_address , data_section_size , ret_nop_address , invalid_chars , final_gadget , super_sub_rop_chain , second_values_to_pop , second_comments );

///////////

/* Concateno los SUB-ROP-CHAINS */
  rop_chain.Clear ();

/* Obtengo TODOS los GADGETS del "PUSHAD/RET" */
  get_simple_gadgets ( super_sub_rop_chain , sub_rop_chain );
  rop_chain.Append ( sub_rop_chain );

/* Obtengo TODOS los GADGETS del "JMP ESP" */
  get_simple_gadgets ( super_jmp_esp_rop_chain , jmp_esp_rop_chain );
  rop_chain.Append ( jmp_esp_rop_chain );

/* Concateno los POPS */
  values_to_pop.Clear ();
  values_to_pop.Append ( first_values_to_pop );
  values_to_pop.Append ( second_values_to_pop );
  values_to_pop.Append ( third_values_to_pop );

/* Concateno los COMMENTS */
  comments.Clear ();
  comments.Append ( first_comments );
  comments.Append ( second_comments );
  comments.Append ( third_comments );

/* Si hay INCONSISTENCIA */
  if ( rop_chain.Len () != values_to_pop.Len () )
  {
    printf ( "wtf !\n" );
    return ( FALSE );
  }

////////

/* Armo el ROP-Chain */
  build_rop_chain ( rop_chain , values_to_pop , comments , final_values_to_pop , final_comments );

/* Agrego unos BREAKPOINTS en el STACK */
  final_values_to_pop.Add ( ( void * ) 0xcccccccc ); // Shellcode init
  final_comments.Add ( ( void * ) "SHELLCODE ..." );

////////

/* Imprimo el ROP-Chain */
  print_rop_chain ( final_values_to_pop , final_comments );

  return ( TRUE );
}

////////////////////////////////////////////////////////////////////////////////

int main ( int argc , char *argv [] )
{
  char snapshot [ 1024 ];
  char cmd [ 4096 ];
  char *settings = NULL;
  int new_analysis;
  int pid;
  int ret;

///////////

/* Controlo los argumentos */
  if ( ( argc == 1 ) || ( argc > 4 ) )
  {
  /* Mensaje al usuario */
    printf ( "\nAgafi-ROP v1.1\n" );
    printf ( "Created by 'Nicolas A. Economou' (neconomou@coresecurity.com)\n" );
    printf ( "Core Security Technologies, Buenos Aires, Argentina (2015)\n" );
    printf ( "\nUse: agafi-rop option [settings.txt]\n\n" , argv [ 0 ] );
    printf ( "Options:\n" );
    printf ( " -f module_name\n" );
    printf ( " -rf module_name\n" );
    printf ( " -p pid\n" );
    printf ( " -rp pid\n" );
    printf ( " -s agafi_snapshot\n" );
    printf ( " -rs agafi_snapshot\n" );

    printf ( "\n" );
    printf ( "Note:\n" );
    printf ( " -r means reuse gadgets\n" );

    printf ( "\n" );
    printf ( "Assignations supported in settings.txt:\n" );
    printf ( " \"invalid_chars = 0x00,0x01,0x02,...,0xff\"\n" );
    printf ( " \"modules=MODULE1, MODULE2, ...\"\n" );

    printf ( "\n" );
    printf ( "Besides, you can pass parameters (not objectives) directly to Agafi, like this:\n" );
    printf ( " eax=0x12345678\n" );
    printf ( " test_range=0x401000,0x402000\n" );

    printf ( "\n" );
    printf ( "Examples:\n" );
    printf ( " Please read \"Agafi-ROP-user-guide.txt\" to see more documentation\n" );

    return ( FALSE );
  }

///////////

/* Si tengo que buscar sobre un MODULO */
  if ( strcmp ( argv [ 1 ] , "-f" ) == 0 )
  {
  /* Armo el nombre del file */
    snprintf ( snapshot , sizeof ( snapshot ) , "%s.snap" , argv [ 2 ] );

  /* Obtengo el SNAPSHOT del file ( Modulo o binario RAW ) */
    snprintf ( cmd , sizeof ( cmd ) , "fsnap %s %s" , argv [ 2 ] , snapshot );
    system ( cmd );

  /* Tengo que BUSCAR GADGET de NUEVO */
    new_analysis = TRUE;
  }
/* Si tengo que REUSAR LOS GADGETS tomados del MODULO */
  else if ( strcmp ( argv [ 1 ] , "-rf" ) == 0 )
  {
  /* Armo el nombre del file */
    snprintf ( snapshot , sizeof ( snapshot ) , "%s.snap" , argv [ 2 ] );

  /* Obtengo el SNAPSHOT del file ( Modulo o binario RAW ) */
    snprintf ( cmd , sizeof ( cmd ) , "fsnap %s %s" , argv [ 2 ] , snapshot );

  /* Uso los GADGETS obtenidos ANTERIORMENTE */
    new_analysis = FALSE;
  }
/* Si tengo que buscar sobre un PROCESO */
  else if ( strcmp ( argv [ 1 ] , "-p" ) == 0 )
  {
  /* Obtengo el PID */
    sscanf ( argv [ 2 ] , "%i" , &pid );

  /* Armo el nombre del file */
    snprintf ( snapshot , sizeof ( snapshot ) , "%i.snap" , pid );

  /* Obtengo el SNAPSHOT del PROCESO */
    snprintf ( cmd , sizeof ( cmd ) , "gisnap %i %s" , pid , snapshot );
    system ( cmd );

  /* Tengo que BUSCAR GADGET de NUEVO */
    new_analysis = TRUE;
  }
/* Si tengo que buscar sobre un PROCESO */
  else if ( strcmp ( argv [ 1 ] , "-rp" ) == 0 )
  {
  /* Obtengo el PID */
    sscanf ( argv [ 2 ] , "%i" , &pid );

  /* Armo el nombre del file */
    snprintf ( snapshot , sizeof ( snapshot ) , "%i.snap" , pid );

  /* Tengo que BUSCAR GADGET de NUEVO */
    new_analysis = FALSE;
  }
/* Si tengo que buscar sobre un SNAPSHOT generado por FSNAP/GISNAP */
  else if ( strcmp ( argv [ 1 ] , "-s" ) == 0 )
  {
  /* Snapshot donde buscar los gadgets */
    strncpy ( snapshot , argv [ 2 ] , sizeof ( snapshot ) );

  /* Tengo que BUSCAR GADGET de NUEVO */
    new_analysis = TRUE;
  }
/* Si tengo que REUSAR LOS GADGETS tomados de un SNAPSHOT generado por FSNAP/GISNAP */
  else if ( strcmp ( argv [ 1 ] , "-rs" ) == 0 )
  {
  /* Snapshot donde buscar los gadgets */
    strncpy ( snapshot , argv [ 2 ] , sizeof ( snapshot ) );

  /* Uso los GADGETS obtenidos ANTERIORMENTE */
    new_analysis = FALSE;
  }
/* Si la opcion es desconocida */
  else
  {
  /* Mensaje al usuario */
    printf ( "[ ] Error: invalid option\n" );
    return ( FALSE );
  }

///////////

/* Si tengo SETTINGS iniciales */
  if ( argc == 4 )
  {
  /* Uso este file para pasarlo como "objective.txt" a Agafi */
    settings = argv [ 3 ];

  /* Chequeo que el file NO tenga OBJECTIVOS */
    if ( is_valid_settings ( settings ) == FALSE )
    {
    /* Mensaje al usuario */
      printf ( "[ ] Error: invalid settings file\n" );

    /* Salgo con ERROR */
      return ( FALSE );
    }
  }

///////////

/* Empiezo a buscar gadgets y a armar el ROP-Chain */
  ret = start_building_process ( new_analysis , settings , snapshot );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

```

`src/agafi.cpp`:

```cpp
////////////////////////////////////////////////////////////////////////////////

/* Agafi ( Advanced Gadget Finder ) */

// Compilation line
// cl.exe agafi.cpp /link -SUBSYSTEM:CONSOLE

////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>

#include "qemu.c"
#include "disassembler.c"

#include "list.cpp"

////////////////////////////////////////////////////////////////////////////////

#pragma pack(1)

#ifdef _MSC_VER
  #define asm _asm
  #define snprintf _snprintf
#endif

////////////////////////////////////////////////////////////////////////////////

#define MAX_INSTRUCTIONS      100

#define READABLE              1
#define WRITABLE              2
#define EXECUTABLE            4
#define RANDOMIZABLE          8

#define VAR_TEST_RANGE        0x80000000
#define VAR_CDATA             0x80000001
#define VAR_MODULES           0x80000002

#define OP_REG_TO_REG         1
#define OP_REGS_TO_REG        2
#define OP_REG_TO_REGS        3
#define OP_REGS_TO_REGS       4
#define OP_MEM_TO_REG         5
#define OP_MEM_TO_REGS        6
#define OP_MEMS_TO_REG        7
#define OP_MEMS_TO_REGS       8
#define OP_VALUE_TO_REG       9
#define OP_RANGE_TO_REG       10
#define OP_REGS_RANGE_TO_REG  11
#define OP_REG_TO_MEM         12
#define OP_REGS_TO_MEM        13

#define AS_EQUAL_TO_VALUE     1
#define AS_EQUAL_TO_RANGE     2
#define AS_EQUAL_TO_STRING    3

#define SP_OBJECTIVE          4
#define PC_OBJECTIVE          8
#define EF_OBJECTIVE          9

#define RET_ENDING            0
#define RETN_ENDING           1
#define RETF_ENDING           2
#define IRET_ENDING           3
#define OTHER_ENDING          4

//#define SYMBOLIC_MEMORY_VALUE              0xccccccc0
#define SYMBOLIC_REGISTER_VALUE            0xF0000000

#define SYMBOLIC_STACK_ADDRESS             0x90000000
#define SYMBOLIC_STACK_PIVOTING_ADDRESS    0xa0000000
#define SYMBOLIC_DATA_ADDRESS              0xd0000000
#define SYMBOLIC_GADGET_RETURN             0xbbbbbbbb
#define SYMBOLIC_STACK_PIVOTING_SIZE       0x10000
#define SYMBOLIC_TOTAL_STACK_PIVOTING_SIZE SYMBOLIC_STACK_PIVOTING_SIZE * 0x10

#define VALID_REGISTERS 9
#define ALL_REGISTERS   0xffffffff

#define uint64_t unsigned __int64

unsigned int SYMBOLIC_MEMORY_VALUE = 0xccccccc0;

////////////////////////////////////////////////////////////////////////////////

typedef struct
{
  int restorable;
  void *address;
  unsigned int size;
  int protection;
  char module_name [ 256 ];
  void *data;
} SECTION;

typedef struct
{
  int register_index;
  int operation;
  unsigned int operand;
  unsigned int offset_base;
  unsigned int offset_limit;
  int stack_pivoting;
} OBJECTIVE;

typedef struct
{
  void *address;
  int register_index;
  int operation;
  unsigned int operand;
  unsigned int offset_base;
  unsigned int offset_limit;
  int stack_pivoting;
  int ending_type;
  int stack_used;
  int asignated_registers [ VALID_REGISTERS ];
  int preserved_registers [ VALID_REGISTERS ];
  unsigned int conditional_jumps;
} RESULT;

typedef struct
{
  unsigned int var;
  int operation;
  unsigned int v1;
  unsigned int v2;
} ASIGNATION;

typedef struct
{
  unsigned int sig;           // signature: "snap" or 0x70616E73 in little endian
  unsigned int version;	      // if version == 1: use DUMPBLOCKV10 / version == 2 uses DUMPBLOCKV20 and so on.
  unsigned int flags;         //
  unsigned int blockcount;
} SNAPSHOT_HEADER;

typedef struct
{
  uint64_t BaseAddress;
  uint64_t RegionSize;
  unsigned int Protect;  // see memory protection constants
} DUMPBLOCKV10;

typedef struct
{
  uint64_t BaseAddress;
  uint64_t RegionSize;
  unsigned int Protect;  // see memory protection constants
  char name [256];
} DUMPBLOCKV20;

////////////////////////////////////////////////////////////////////////////////

char *registers [] = {"eax","ecx","edx","ebx","esp","ebp","esi","edi","eip"};

char *current_instruction;
int change_eflags = FALSE;

////////////////////////////////////////////////////////////////////////////////

//void test ( void )
__declspec ( naked ) void test ( void )
{
  asm mov eax,[edx]
  asm mov ebx,[eax]
  asm ret

  asm pushad
  asm ret

  asm mov ebp,eax
  asm ret 0x8000

  asm mov ebp,eax
  asm ret 0xFFFF

  asm mov ebp,ebx
  asm retf

  asm mov ebp,ecx
  asm iretd

  asm mov eax,3
  asm mov ebx,esp
  asm add ebx,4
  asm ret

  asm sub eax,0x1234
  asm mov esp,eax
  asm ret

  asm mov eax,esp
  asm ret

  asm pop eax
  asm pop eax
  asm pop esp
  asm ret

  asm mov eax,[eax]
  asm xchg eax,esp
  asm ret

/* La primera instruccion NO pasa [ESP+0] tiene una DIRECCION INVALIDA */
  asm xchg esp,eax
  asm pop ebx
  asm mov [ebx],eax
  asm ret

  asm xchg esp,eax
  asm iretd

  asm xchg esp,eax
  asm retf

  asm call bypass

asm evil_code: 
  asm add byte ptr [eax],al
  asm jmp byebye
asm bypass:
  asm pop eax
  asm jmp eax  
asm byebye:

  asm nop
  asm nop
  asm nop

/* Stack Pivoting */
  asm mov esp,ecx
  asm ret 0x88

  asm add esp,4

/* EAX = EBX */
  asm push ebx
  asm pop eax
  asm ret

  asm push 0x55555555
  asm nop
  asm nop
  asm nop
  asm mov eax,[esp]
  asm nop
  asm nop
  asm mov edi,0x44444444
  asm push 0x66666666
  asm pop edi
//  asm pushad
//  asm ret

/* EAX = EBX */
  asm pushad
  asm add esp,0x10
  asm popad
  asm push edi
  asm pop eax
  asm ret

  while ( 1 );

/* EIP = EDX */
  asm push edx
  asm ret

  asm call [ebp+0x30]

/* Stack Pivoting */
  asm xchg edi,esp
  asm ret 0x40

/* ESP = EBP */
  asm leave
  asm ret 4

/* Padding */
  asm nop
  asm nop
  asm nop
  asm nop
  asm nop
  asm nop
  asm nop
  asm nop
  asm nop
  asm nop
  asm nop
  asm nop
  asm nop
  asm nop
  asm nop
  asm nop
}

////////////////////////////////////////////////////////////////////////////////

void code_end ( void )
{
}

////////////////////////////////////////////////////////////////////////////////

int is_mapped_address ( List &sections , SECTION *current_section , void *address )
{
  SECTION *section;
  unsigned int cont;
  int ret = FALSE;

/* Si la direccion esta dentro de la SECCION ACTUAL */
  if ( ( current_section -> address <= address ) && ( address < ( ( void * ) ( ( unsigned int ) current_section -> address + current_section -> size ) ) ) )
  {
  /* Si NO estoy cerca del limite de la memoria ( mas de 16 bytes del limite ) */
    if ( ( unsigned int ) address < ( unsigned int ) current_section -> address + current_section -> size - 0x10 )
    {
    /* Esta dentro del RANGO */
      return ( TRUE );
    }
    else
    {
    /* Esta fuera del RANGO */
      return ( FALSE );
    }
  }

/* Recorro seccion por seccion */
  for ( cont = 0 ; cont < sections.Len () ; cont ++ )
  {
  /* Levanto la siguiente seccion */
    section = ( SECTION * ) sections.Get ( cont );

  /* Si la direccion esta dentro de esta seccion */
    if ( ( section -> address <= address ) && ( address < ( ( void * ) ( ( unsigned int ) section -> address + section -> size ) ) ) )
    {
    /* Si NO estoy cerca del limite de la memoria ( mas de 16 bytes del limite ) */
      if ( ( unsigned int ) address < ( unsigned int ) section -> address + section -> size - 0x10 )
      {
      /* Si el area de memoria es EJECUTABLE ! */
        if ( section -> protection & EXECUTABLE )
        {
        /* Retorno OK */
          ret = TRUE;

        /* Dejo de buscar */
          break;
        }
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_end_of_gadget ( QEMU_CONTEXT *context , List &objectives )
{
  OBJECTIVE *objective;
  unsigned int cont;
  int ret = FALSE;

/* Si es el RETORNO POR DEFAULT */
  if ( context -> eip == SYMBOLIC_GADGET_RETURN )
  {
  /* Retorno OK */
    ret = TRUE;
  }
  else
  {
  /* Recorro TODOS los OBJECTIVOS */ 
    for ( cont = 0 ; cont < objectives.Len () ; cont ++ )
    {
    /* Levanto el siguiente OBJETIVO */
      objective = ( OBJECTIVE * ) objectives.Get ( cont );

    /* Si el OBJETIVO es EIP = ALGO */
      if ( objective -> register_index == PC_OBJECTIVE )
      {
      /* Retorno OK */
        ret = TRUE;

      /* Dejo de buscar */
        break;
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_objetive_ok ( QEMU_CONTEXT *context , QEMU_CONTEXT *original_context , OBJECTIVE *objective , RESULT *result )
{
  unsigned int *current_context;
  unsigned int *my_original_context;
  unsigned int value;
  unsigned int cont2;
  unsigned int cont;
  unsigned int r1;
  unsigned int r2;
  int ret = FALSE;

/* Contexto actual */
  current_context = ( unsigned int * ) context;

/* Contexto original */
  my_original_context = ( unsigned int * ) original_context;

/* Obtengo el valor de los REGISTROS */
  r1 = current_context [ objective -> register_index ];

/* Si es una operacion REGISTRO = REGISTRO */
  if ( objective -> operation == OP_REG_TO_REG )
  {
  /* Si REG1 vale el valor original de REG2 */
    if ( r1 == my_original_context [ objective -> operand ] )
    {
    /* Retorno lo ENCONTRADO */
      result -> register_index = objective -> register_index;
      result -> operation = objective -> operation;
      result -> operand = objective -> operand;
      result -> offset_base = 0;
      result -> offset_limit = 0;

    /* Objetivo CUMPLIDO */
      ret = TRUE;
    }
  }
/* Si es una operacion REGISTRO = CUALQUIER REGISTRO */
  else if ( objective -> operation == OP_REGS_TO_REG )
  {
  /* Chequeo el VALOR de TODOS los demas REGISTROS */
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Si NO se esta comparando contra SI MISMO */
      if ( cont != objective -> register_index )
      {
      /* Si REG1 vale el valor original de REG2 */
        if ( r1 == my_original_context [ cont ] )
        {
        /* Retorno lo ENCONTRADO */
          result -> register_index = objective -> register_index;
          result -> operation = objective -> operation;
          result -> operand = cont;
          result -> offset_base = 0;
          result -> offset_limit = 0;

        /* Objetivo CUMPLIDO */
          ret = TRUE;

        /* Dejo de buscar */
          break;
        }
      }
    }
  }
/* Si es una operacion CUALQUIER REGISTRO = REGISTRO */
  else if ( objective -> operation == OP_REG_TO_REGS )
  {
  /* Chequeo el VALOR de TODOS los demas REGISTROS */
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Si NO se esta comparando contra SI MISMO */
      if ( cont != objective -> operand )
      {
      /* Si REG1 vale el valor original de REG2 */
        if ( current_context [ cont ] == my_original_context [ objective -> operand ] )
        {
        /* Retorno lo ENCONTRADO */
          result -> register_index = cont;
          result -> operation = objective -> operation;
          result -> operand = objective -> operand;
          result -> offset_base = 0;
          result -> offset_limit = 0;

        /* Objetivo CUMPLIDO */
          ret = TRUE;

        /* Dejo de buscar */
          break;
        }
      }
    }
  }
/* Si es una operacion CUALQUIER REGISTRO = CUALQUIER REGISTRO */
  else if ( objective -> operation == OP_REGS_TO_REGS )
  {
  /* Recorro los REGISTROS ASIGNADOS */
    for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
    {
    /* Chequeo el VALOR de TODOS los demas REGISTROS */
      for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
      {
      /* Si NO se esta comparando contra SI MISMO */
        if ( cont2 != cont )
        {
        /* Si REG1 vale el valor original de REG2 */
          if ( current_context [ cont2 ] == my_original_context [ cont ] )
          {
          /* Retorno lo ENCONTRADO */
            result -> register_index = cont2;
            result -> operation = objective -> operation;
            result -> operand = cont;
            result -> offset_base = 0;
            result -> offset_limit = 0;

          /* Objetivo CUMPLIDO */
            ret = TRUE;

          /* Dejo de buscar */
            break;
          }
        }
      }
    }
  }
/* Si es una operacion REGISTRO = VALOR */
  else if ( objective -> operation == OP_VALUE_TO_REG )
  {
  /* Si REG1 es IGUAL al VALOR ESPERADO */
    if ( r1 == objective -> operand )
    {
    /* Retorno lo ENCONTRADO */
      result -> register_index = objective -> register_index;
      result -> operation = objective -> operation;
      result -> operand = objective -> operand;
      result -> offset_base = 0;
      result -> offset_limit = 0;

    /* Objetivo CUMPLIDO */
      ret = TRUE;
    }
  }
/* Si es una operacion REGISTRO = CONTENIDO DE MEMORIA */
  else if ( objective -> operation == OP_MEM_TO_REG )
  {
  /* Si REG1 es IGUAL al VALOR ESPERADO */
    if ( r1 == SYMBOLIC_MEMORY_VALUE )
    {
    /* Retorno lo ENCONTRADO */
      result -> register_index = objective -> register_index;
      result -> operation = objective -> operation;
      result -> operand = objective -> operand;
      result -> offset_base = objective -> offset_base;
      result -> offset_limit = objective -> offset_limit;

    /* Objetivo CUMPLIDO */
      ret = TRUE;
    }
  }
/* Si es una operacion REGISTRO = CONTENIDOS DE MEMORIA */
  else if ( objective -> operation == OP_MEMS_TO_REG )
  {
  /* Recorro TODOS los REGISTROS */
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Si el registro NO es el STACK ni EIP */
      if ( ( cont != SP_OBJECTIVE ) && ( cont != PC_OBJECTIVE ) )
      {
      /* Si REG1 es IGUAL al VALOR ESPERADO */
        if ( ( current_context [ objective -> register_index ] & 0xfffffff0 ) == SYMBOLIC_MEMORY_VALUE )
        {
        /* Retorno lo ENCONTRADO */
          result -> register_index = objective -> register_index;
          result -> operation = objective -> operation;
          result -> operand = current_context [ objective -> register_index ] & 0xf;
          result -> offset_base = objective -> offset_base;
          result -> offset_limit = objective -> offset_limit;

        /* Objetivo CUMPLIDO */
          ret = TRUE;
        }
      }
    }
  }
/* Si es una operacion REGISTROS = CONTENIDO DE MEMORIA */
  else if ( objective -> operation == OP_MEM_TO_REGS )
  {
  /* Recorro TODOS los REGISTROS */
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Si REG1 es IGUAL al VALOR ESPERADO */
      if ( current_context [ cont ] == SYMBOLIC_MEMORY_VALUE )
      {
      /* Retorno lo ENCONTRADO */
        result -> register_index = cont;
        result -> operation = objective -> operation;
        result -> operand = objective -> operand;
        result -> offset_base = objective -> offset_base;
        result -> offset_limit = objective -> offset_limit;

      /* Objetivo CUMPLIDO */
        ret = TRUE;

      /* Dejo de buscar */
        break;
      }
    }
  }
/* Si es una operacion REGISTROS = CONTENIDO DE MEMORIA */
  else if ( objective -> operation == OP_MEMS_TO_REGS )
  {
  /* Recorro TODOS los REGISTROS */
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Si REG1 es IGUAL al VALOR ESPERADO */
      if ( ( current_context [ cont ] & 0xfffffff0 ) == SYMBOLIC_MEMORY_VALUE )
      {
      /* Retorno lo ENCONTRADO */
        result -> register_index = cont;
        result -> operation = objective -> operation;
        result -> operand = current_context [ cont ] & 0xf;
        result -> offset_base = objective -> offset_base;
        result -> offset_limit = objective -> offset_limit;

      /* Objetivo CUMPLIDO */
        ret = TRUE;

      /* Dejo de buscar */
        break;
      }
    }
  }
/* Si es una operacion REGISTRO = RANGO */
  else if ( objective -> operation == OP_RANGE_TO_REG )
  {
  /* Si REG1 esta DENTRO del RANGO */
    if ( ( objective -> offset_base <= r1 ) && ( r1 <= objective -> offset_limit ) )
    {
    /* Retorno lo ENCONTRADO */
      result -> register_index = objective -> register_index;
      result -> operation = objective -> operation;
      result -> operand = r1;
      result -> offset_base = 0;
      result -> offset_limit = 0;

    /* Objetivo CUMPLIDO */
      ret = TRUE;
    }
  }
/* Si es una operacion REGISTRO = REG+0xMM,REG+0xNN */
  else if ( objective -> operation == OP_REGS_RANGE_TO_REG )
  {
  /* Si NO estoy buscando un STACK PIVOTING */
    if ( objective -> register_index != SP_OBJECTIVE )
    {
    /* Obtengo el registro usado como INDICE */
      r2 = my_original_context [ objective -> operand ];

    /* Si REG1 esta DENTRO del RANGO */
      if ( ( r2 + objective -> offset_base <= r1 ) && ( r1 <= r2 + objective -> offset_limit ) )
      {
      /* Retorno lo ENCONTRADO */
        result -> register_index = objective -> register_index;
        result -> operation = objective -> operation;
        result -> operand = objective -> operand;
        result -> offset_base = r1 - r2;
        result -> offset_limit = 0;

      /* Objetivo CUMPLIDO */
        ret = TRUE;
      }
    }
  }
/* Si es una operacion [REG+0xNN] = REG */
  else if ( objective -> operation == OP_REG_TO_MEM )
  {
  /* Si es RELATIVO AL STACK ( Valor dinamico ) */
    if ( objective -> operand == SP_OBJECTIVE )
    {
    /* Obtengo el registro usado como INDICE */
      r2 = current_context [ objective -> operand ];
    }
  /* Si es RELATIVO A UN REGISTRO ( Valor inicial ) */
    else
    {
    /* Obtengo el registro usado como INDICE */
      r2 = my_original_context [ objective -> operand ];
    }

  /* Intento leer memoria de la DIRECCION TARGETEADA */
    if ( read_memory ( ( void * ) ( r2 + objective -> offset_base ) , &value , sizeof ( unsigned int ) ) == TRUE )
    {
    /* Obtengo el registro ORIGINAL a ser GUARDADO */
      r1 = my_original_context [ objective -> register_index ];

    /* Si el valor COINCIDE */
      if ( r1 == value )
      {
      /* Retorno lo ENCONTRADO */
        result -> register_index = objective -> register_index;
        result -> operation = objective -> operation;
        result -> operand = objective -> operand;
        result -> offset_base = objective -> offset_base;
        result -> offset_limit = 0;

      /* Objetivo CUMPLIDO */
        ret = TRUE;
      }
    }
  }
/* Si es una operacion [REG+0xNN] = REG32 */
  else if ( objective -> operation == OP_REGS_TO_MEM )
  {
  /* Si es RELATIVO AL STACK ( Valor dinamico ) */
    if ( objective -> operand == SP_OBJECTIVE )
    {
    /* Obtengo el registro usado como INDICE */
      r2 = current_context [ objective -> operand ];
    }
  /* Si es RELATIVO A UN REGISTRO ( Valor inicial ) */
    else
    {
    /* Obtengo el registro usado como INDICE */
      r2 = my_original_context [ objective -> operand ];
    }

  /* Intento leer memoria de la DIRECCION TARGETEADA */
    if ( read_memory ( ( void * ) ( r2 + objective -> offset_base ) , &value , sizeof ( unsigned int ) ) == TRUE )
    {
//      printf ( "leyendo desde %x + %x\n" , r2 , objective -> offset_base );
//      printf ( "comparando %x vs %x\n" , r1 , value );

    /* Recorro TODOS los REGISTROS */
      for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
      {
      /* Obtengo el registro ORIGINAL a ser GUARDADO */
        r1 = my_original_context [ cont ];

      /* Si el valor COINCIDE */
        if ( r1 == value )
        {
        /* Retorno lo ENCONTRADO */
          result -> register_index = cont;
          result -> operation = objective -> operation;
          result -> operand = objective -> operand;
          result -> offset_base = objective -> offset_base;
          result -> offset_limit = 0;

        /* Objetivo CUMPLIDO */
          ret = TRUE;

        /* Dejo de buscar */
          break;
        }
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int are_objetives_ok ( QEMU_CONTEXT *context , QEMU_CONTEXT *original_context , List &objectives , List &results )
{
  OBJECTIVE *objective;
  RESULT result;
  RESULT *result2;
  List pre_results;
  unsigned int cont;
  int ret = TRUE;

/* Recorro TODOS los OBJETIVOS */
  for ( cont = 0 ; cont < objectives.Len () ; cont ++ )
  {
  /* Levanto el siguiente OBJETIVO */
    objective = ( OBJECTIVE * ) objectives.Get ( cont );

  /* Si el OBJETIVO NO es un STACK PIVOTING */
    if ( objective -> stack_pivoting == FALSE )
    {
    /* Chequeo si el OBJECTIVO se CUMPLE */
      ret = is_objetive_ok ( context , original_context , objective , &result );

    /* Si este OBJECTIVO SE CUMPLE */
      if ( ret == TRUE )
      {
      /* Alloco memoria para guardar el OBJETIVO CUMPLIDO */
        result2 = ( RESULT * ) malloc ( sizeof ( RESULT ) );
        *result2 = result;

      /* Agrego el RESULTADO a la lista previa */   
        pre_results.Add ( ( void * ) result2 );
      }
      else
      {
      /* Dejo de buscar */
        break;
      }
    }
  }

/* Si TODOS los OBJETIVOS se CUMPLEN */
  if ( ret == TRUE )
  {
  /* Copio los OBJETIVOS a la lista a retornar */
    results.Append ( pre_results );
  }

  return ( ret ); 
}

////////////////////////////////////////////////////////////////////////////////

int is_pc_in_problems ( QEMU_CONTEXT *context )
{
  unsigned int *registros;
  unsigned int cont;
  int ret = FALSE;

/* Obtengo el puntero a los REGISTROS */
  registros = ( unsigned int * ) context;

/* Recorro TODOS los registros */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Si NO estoy comparando EIP contra si mismo */
    if ( cont != PC_OBJECTIVE )
    {
    /* Si este registro es igual a EIP */
      if ( context -> eip == registros [ cont ] )
      {
      /* Asumo que el shellcode podria AUTO-MODIFICARSE */
        ret = TRUE;

      /* Dejo de buscar */
        break;
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_qemu_evil_instruction ( QEMU_CONTEXT *context , void *address )
{
  char buffer [ 16 ];
  char *instruction;
  unsigned int isize;
  int ret = FALSE;

/* Si es posible CODIGO AUTO-MODIFICANDOSE ( EIP = algun REG ) */
  if ( is_pc_in_problems ( context ) == TRUE )
  {
  /* No ejecuto este tipo de instrucciones */
    return ( TRUE );
  }

/* Si NO ESTOY COMPILANDO CON Visual Studio */
  #ifndef _MSC_VER
  {
  /* Paddeo la memoria */
    memset ( buffer , 0xff , 16 );

  /* Leo 16 bytes de la memoria */
    read_memory ( address , buffer , 16 );

  /* Desensamblo la instruccion */
    instruction = disassembly ( address , ( unsigned char * ) buffer , &isize );

  /* Si la instruccion pudo ser DESENSAMBLADA */
    if ( isize != 0 )
    {
    /* Seteo la instruccion para que pueda ser usada por otras funciones */
      current_instruction = instruction;
    }
    else
    {
    /* La instruccion NO pudo ser desensamblada */
      current_instruction = "";
    }

//    printf ( "%.8x: %s\n" , address , instruction );

  /* Si la instruccion pudo ser desensamblada */
    if ( isize > 0 )
    {
    /* Si es una instruccion de FLOATING POINT */
      if ( *instruction == 'f' )
      {
//      printf ( "%.8x is invalid\n" , address );

      /* No ejecuto este tipo de instrucciones ( TRAEN MUCHOS PROBLEMAS ! ) */
        ret = TRUE;
      }
    /* Si esta tratando de usar registros XMM */
      else if ( strstr ( instruction , "xmm" ) != 0 )
      {
//        printf ( "%.8x is invalid\n" , address );

      /* No ejecuto este tipo de instrucciones ( TRAEN MUCHOS PROBLEMAS ! ) */
        ret = TRUE;
      }
    }
  }
  #endif

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_conditional_jump ( void *address )
{
  unsigned int instruction_size;
  unsigned int cont;
  char buffer [ 16 ];
  char *instruction;
  int ret = FALSE;
  char *jumps [] = { 
                     "je","jne","jo","jno","jb","jae","jz","jnz","jbe",
                     "ja","js","jns","jp","jnp","jpe","jpo","jl","jge",
                     "jle","jg"
                   };

/* Leo los OPCODES de la instruccion ejecutada */
  if ( read_memory ( address , ( void * ) buffer , sizeof ( buffer ) ) == TRUE )
  {
  /* Desensamblo la instruccion */
    instruction = disassembly ( address , ( unsigned char * ) buffer , &instruction_size );

  /* Recorro TODAS las variantes */
    for ( cont = 0 ; cont < sizeof ( jumps ) / sizeof ( char * ) ; cont ++ )
    {
    /* Si es un JUMP CONDICIONAL */
      if ( strncmp ( instruction , jumps [ cont ] , strlen ( jumps [ cont ] ) ) == 0 )
      {
      /* Retorno OK */
        ret = TRUE;

      /* Dejo de buscar */
        break;
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_ending_type ( void *address )
{
  unsigned char c;
  int ret = OTHER_ENDING;

/* Si pude leer un byte de la ultima instruccion */
  if ( read_memory ( address , ( void * ) &c , 1 ) == TRUE )
  {
  /* Si es un RET comun */
    if ( c == 0xc3 )
    {
    /* Retorno el tipo */
      ret = RET_ENDING;
    }
  /* Si es un RETN */
    else if ( c == 0xc2 )
    {
    /* Retorno el tipo */
      ret = RETN_ENDING;
    }
  /* Si es un RETF */
    else if ( c == 0xcb )
    {
    /* Retorno el tipo */
      ret = RETF_ENDING;
    }
  /* Si es un IRET */
    else if ( c == 0xcf )
    {
    /* Retorno el tipo */
      ret = IRET_ENDING;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int step ( QEMU_CONTEXT *context , List &sections , SECTION *current_section )
{
  SECTION *section;
  void *operation_address;
  void *original_pc;
  unsigned char bytecode [ 3 ] = { 0 , 0 , 0 };
  unsigned short ret_operand;
  int ret;
  int res;

/* Si EIP esta fuera de rango */
  if ( is_mapped_address ( sections , current_section , ( void * ) context -> eip ) == FALSE )
  {
//    printf ( "Invalid EIP address: %x\n" , context -> eip );

  /* Salgo con ERROR */
    return ( FALSE );
  }

/* Si es una instruccion que rompe QEMU !!! */
  if ( is_qemu_evil_instruction ( context , ( void * ) context -> eip ) == TRUE )
  {
  /* Salgo con ERROR */
    return ( FALSE );
  }

/* Obtengo la direccion actual de EIP */
  original_pc = ( void * ) context -> eip;

/* Leo los primeros bytes de la instruccion */
  read_memory ( original_pc , bytecode , sizeof ( bytecode ) );

/* Si es un "RETF/IRETD" */
  if ( bytecode [ 0 ] == 0xcb || bytecode [ 0 ] == 0xcf )
  {
  /* Reemplazo la instruccion por un RET comun */
    write_memory ( original_pc , ( void * ) "\xc3" , 1 );
  }
/* Si es un JUMP CONDICIONAL ( Corto ) */
  else if ( ( 0x70 <= bytecode [ 0 ] ) && ( bytecode [ 0 ] <= 0x7f ) )
  {
  /* Prendo el flag para TESTEAR CON EFLAGS */
    change_eflags = TRUE;
  }
/* Si es el PREFIJO para un JUMP CONDICIONAL ( Largo ) */
  else if ( bytecode [ 0 ] == 0x0f )
  {
  /* Si es un JUMP CONDICIONAL ( Largo ) */
    if ( ( 0x80 <= bytecode [ 1 ] ) && ( bytecode [ 1 ] <= 0x8f ) )
    {
    /* Prendo el flag para TESTEAR CON EFLAGS */
      change_eflags = TRUE;
    }
  }

/* Ejecuto la siguiente instruccion */
//  printf ( "entro2\n" );
  res = cpu_x86_exec ( context );
//  printf ( "eip despues = %#x\n" , context -> eip );
//  printf ( "salgo2\n" );

/* Si era un "RETF/IRETD" */
  if ( bytecode [ 0 ] == 0xcb || bytecode [ 0 ] == 0xcf )
  {
  /* Reemplazo la instruccion por la instruccion original */
    write_memory ( original_pc , ( void * ) &bytecode [ 0 ] , 1 );
  }

/* Si era un "RETN" ( Fucking QEMU ) */
  if ( bytecode [ 0 ] == 0xc2 )
  {
  /* Obtengo el OPERANDO de la INSTRUCCION */
    ret_operand = * ( unsigned short * ) &bytecode [ 1 ];

  /* Si tiene un PARAMETRO NEGATIVO */
    if ( ret_operand >= 0x8000 )
    {
    /* Compenso la RESTA MAL HECHA */
      context -> esp += ( unsigned short ) ( - ( short int ) ret_operand );

    /* Ahora sumo el valor REAL */
      context -> esp += ret_operand;
    }
  }
/* Si era un "RETF" */
  else if ( bytecode [ 0 ] == 0xcb )
  {
  /* Sumo los 4 bytes del SELECTOR */
    context -> esp += 4;
  }
/* Si era un "IRETD" */
  else if ( bytecode [ 0 ] == 0xcf )
  {
  /* Sumo los 8 bytes del SELECTOR y las EFLAGS */
    context -> esp += 8;
  }

/* Si la instruccion retorno OK */
  if ( res == 0x10002 )
  {
//    printf ( "code = %x\n" , context -> operation_code );
//    printf ( "addr_code = %x\n" , context -> operation_address );

  /* Si hubo alguna operacion de lectura/escritura */
    if ( context -> operation_code != 0 )
    {
//      asm int 3

    /* Obtengo la direccion donde se hizo el ACCESO a MEMORIA */
      operation_address = ( void * ) context -> operation_address;

//      printf ( "-------> invalid access code: %x\n" , context -> operation_code );
//      printf ( "-------> Memory access: %x\n" , context -> operation_address );

    /* Reinicializo los punteros */
      context -> operation_code = 0;
      context -> operation_address = 0;

    /* Salgo con ERROR */
      return ( FALSE );
    }

  /* Por ahora retorno OK */
    ret = TRUE;
  }
/* Si hay algo MAL */
  else
  {
  /* Salgo con ERROR */
    ret = FALSE;
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int test_address ( QEMU_CONTEXT *context , List &sections , SECTION *section , List &objectives , List &results , void *new_address , List &eips )
{
  QEMU_CONTEXT original_context;
  OBJECTIVE *objective;
  RESULT result;
  RESULT *result2;
  List results2;
  unsigned int *my_original_context;
  unsigned int *my_current_context;
  unsigned int register_index;
  unsigned int cont, cont2;
  unsigned int r2;
  int ret = FALSE;
  int res;

/* Obtengo el OBJECTIVO PRIMARIO */
  objective = ( OBJECTIVE * ) objectives.Get ( 0 );

/* Limpio la lista de GADGETS OBTENIDOS */
  results.Clear ();

/* Backupeo el contexto ( solo los registros ) */
  memcpy ( &original_context , ( void * ) context , sizeof ( QEMU_CONTEXT ) );

/* Contexto original */
  my_original_context = ( unsigned int * ) &original_context;

/* Contexto actual */
  my_current_context = ( unsigned int * ) context;

/* Seteo la direccion EIP a probar */
  context -> eip = ( unsigned int ) new_address;

/* Inicializo la lista que va a contener todos los EIPs ejecutados */
  eips.Clear ();

/* Pruebo la siguiente direccion */
  for ( cont = 0 ; cont < MAX_INSTRUCTIONS ; cont ++ )
  {
//    printf ( "eflags = %x\n" , context -> eflags );
//    printf ( "eip = %x\n" , context -> eip );
//    printf ( "antes ebx = %x\n" , context -> ebx );
//    printf ( "edi = %x\n" , context -> edi );
//    printf ( "esp = %x\n" , context -> esp );

//    if ( new_address == ( void * ) 0x51bd2949 )
//    {
//      char data [ 256 ];
//     unsigned int isize;
//
//      read_memory ( ( void * ) context -> eip , data , 16 );
//      printf ( "%x: %s\n" , context -> eip , disassembly ( ( void * ) context -> eip , data , &isize ) );
//    }

  /* Agrego la instruccion a la lista */
    eips.Add ( ( void * ) context -> eip );

  /* Ejecuto la proxima instruccion */
//    printf ( "entro\n" );
    res = step ( context , sections , section );
//    printf ( "salgo\n" );
//    printf ( "res = %x\n" , res );

//    printf ( "despues ebx = %x\n" , context -> ebx );
//    printf ( "new_eax = %x\n" , context -> eax );
//    printf ( "new_eip = 0x%x\n" , context -> eip );
//    printf ( "new_esp = %x\n" , context -> esp );
 
  /* Si el OBJETIVO es CUALQUIER ASIGNACION ( menos un STACK PIVOTING ) */
    if ( ( objective -> stack_pivoting == FALSE ) && ( is_end_of_gadget ( context , objectives ) == TRUE ) )
    {
    /* Chequeo si CUMPLE con los OBJETIVOS */
      if ( are_objetives_ok ( context , &original_context , objectives , results2 ) == TRUE )
      {
      /* Retorno OK */
        ret = TRUE;

      /* Dejo de buscar */
        break;
      }
    }
  /* Si el OBJETIVO es un STACK PIVOTING */
    else if ( ( context -> eip & 0xf0f0f0f0 ) == 0x80808080 )
    {
//      printf ( "eip = %x\n" , context -> eip );
//      printf ( "esp = %x\n" , context -> esp );

    /* Chequeo que el usuario haya pedido esto */
      if ( objective -> register_index == SP_OBJECTIVE )
      {
      /* Si el STACK POINTER esta apuntando al AREA DESEADA */
        if ( ( context -> esp & 0xfff00000 ) == SYMBOLIC_STACK_PIVOTING_ADDRESS )
        {
        /* Si el objetivo es ESP = REGISTRO */
          if ( objective -> operation == OP_REG_TO_REG )
          {
          /* Seteo a MANO el objetivo LOGRADO */
            result.register_index = objective -> register_index;
            result.operation = objective -> operation;
            result.operand = objective -> operand;

          /* Retorno OK */
            ret = TRUE;
          }
        /* Si el objetivo es ESP = CUALQUIER REGISTRO */
          else if ( objective -> operation == OP_REGS_TO_REG )
          {
          /* Obtengo el INDICE del REGISTRO segun el nuevo EIP */
            register_index = context -> eip & 0x0000000f;

          /* Si ESP esta en el AREA del REGISTRO */
            if ( ( ( context -> esp >> 16 ) & 0x0f ) == register_index )
            {
            /* Seteo a MANO el objetivo LOGRADO */
              result.register_index = objective -> register_index;
              result.operation = objective -> operation;
              result.operand = register_index;

            /* Retorno OK */
              ret = TRUE;
            }
          }
        /* Si el objetivo es ESP = MEM */
          else if ( objective -> operation == OP_MEM_TO_REG )
          {
          /* Retorno lo ENCONTRADO */
            result.register_index = objective -> register_index;
            result.operation = objective -> operation;
            result.operand = objective -> operand;
            result.offset_base = objective -> offset_base;
            result.offset_limit = objective -> offset_limit;

          /* Retorno OK */
            ret = TRUE;
          }
        /* Si el objetivo es ESP = REG+M,REG+N */
          else if ( objective -> operation == OP_REGS_RANGE_TO_REG )
          {
          /* Obtengo el registro usado como INDICE */
            r2 = my_original_context [ objective -> operand ];

          /* Retorno lo ENCONTRADO */
            result.register_index = objective -> register_index;
            result.operation = objective -> operation;
            result.operand = objective -> operand;
            result.offset_base = context -> esp - r2;
            result.offset_limit = 0;

          /* Retorno OK */
            ret = TRUE;
          }
        }
      /* Si estoy en el MISMO STACK */
        else if ( ( context -> esp & 0xfffff000 ) == SYMBOLIC_STACK_ADDRESS )
        {
        /* Si es un STACK PIVOTING sobre el MISMO STACK (ESP==ESP+M,ESP+N) */
          if ( objective -> operation == OP_REGS_RANGE_TO_REG )
          {
          /* Si estoy buscando sobre el MISMO STACK */
            if ( objective -> operand == SP_OBJECTIVE )
            {
            /* Si REG1 esta DENTRO del RANGO */
              if ( ( original_context.esp + objective -> offset_base <= context -> esp ) && ( context -> esp <= original_context.esp + objective -> offset_limit ) )
              {
              /* Retorno lo ENCONTRADO */
                result.register_index = objective -> register_index;
                result.operation = objective -> operation;
                result.operand = objective -> operand;
                result.offset_base = context -> esp - original_context.esp;
                result.offset_limit = 0;

              /* Retorno OK */
                ret = TRUE;
              }
            }
          }
        }
      }

    /* Si el OBJECTIVO esta CUMPLIDO */
      if ( ret == TRUE )
      {
      /* Si NO se cumplen TODOS los demas OBJETIVOS */
        if ( are_objetives_ok ( context , &original_context , objectives , results2 ) == FALSE )
        {
        /* INVALIDO este GADGET */
          ret = FALSE;
        }
      }

    /* Dejo de buscar */
      break;
    }

  /* Si hubo algun ERROR */
    if ( res == FALSE )
    {
    /* Dejo de buscar */
      break;
    }
  }

/* Si ENCONTRO algun GADGET */
  if ( ret == TRUE )
  {
  /* Si NO era un STACK PIVOTING */
    if ( objective -> stack_pivoting == FALSE )
    {
    /* Obtengo la PRIMERA CONDICION CUMPLIDA */
      result = * ( RESULT * ) results2.Get ( 0 );

    /* Elimino esa condicion */
      results2.Delete ( 0 );
    }

  /* Seteo la DIRECCION del GADGET */
    result.address = new_address;

  /* Calculo el USO del STACK */
    result.stack_used = ( int ) context -> esp - ( int ) original_context.esp;

  /* Retorno el tipo de RET que tiene el GADGET */
    result.ending_type = get_ending_type ( eips.Get ( eips.Len () - 1 ) );

  /* Retorno si tiene un STACK PIVOTING */
    result.stack_pivoting = objective -> stack_pivoting;

  /* Limpio la lista de REGISTROS PRESERVADOS */
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Limpio este registro */
      result.preserved_registers [ cont ] = FALSE;
    }

  /* Recorro TODOS los REGISTROS para saber quien MANTUVO su VALOR */
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Si este registro MANTUVO su VALOR */
      if ( my_original_context [ cont ] == my_current_context [ cont ] )
      {
      /* Marco el REGISTRO como PRESERVADO */
        result.preserved_registers [ cont ] = TRUE;
      }
    }

  /* Limpio las ASIGNACIONES */    
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Limpio este registro */
      result.asignated_registers [ cont ] = -1;
    }

  /* Si el OBJETIVO era BUSCAR REG32=REG */
    if ( result.operation == OP_REG_TO_REGS )
    {
    /* Recorro TODOS los REGISTROS */
      for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
      {
      /* Si NO se esta COMPARANDO CONSIGO */
        if ( objective -> operand != cont )
        {
        /* Si este REGISTRO vale IGUAL que el OPERANDO */
          if ( my_current_context [ cont ] == my_original_context [ objective -> operand ] )
          {
          /* Hago la ASIGNACION con este REGISTRO */
            result.asignated_registers [ cont ] = objective -> operand;
          }
        }
      }
    }
  /* Si el OBJETIVO era BUSCAR REG32=REG32 */
    else if ( result.operation == OP_REGS_TO_REGS )
    {
    /* Recorro TODOS los REGISTROS */
      for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
      {
      /* Recorro TODOS los REGISTROS */
        for ( cont2 = 0 ; cont2 < VALID_REGISTERS ; cont2 ++ )
        {
        /* Si NO se esta COMPARANDO CONSIGO MISMO */
          if ( cont != cont2 )
          {
          /* Si este REGISTRO vale IGUAL que el OPERANDO */
            if ( my_current_context [ cont ] == my_original_context [ cont2 ] )
            {
            /* Hago la ASIGNACION con este REGISTRO */
              result.asignated_registers [ cont ] = cont2;
            }
          }
        }
      }
    }
  /* Si el OBJETIVO era BUSCAR REG32=[REG+0xNN] */
    else if ( result.operation == OP_MEM_TO_REGS )
    {
    /* Recorro TODOS los REGISTROS */
      for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
      {
      /* Si este REGISTRO vale IGUAL que el CONTENIDO de la MEMORIA */
        if ( my_current_context [ cont ] == SYMBOLIC_MEMORY_VALUE )
        {
        /* Hago la ASIGNACION con este REGISTRO */
          result.asignated_registers [ cont ] = objective -> operand;
        }
      }
    }
  /* Si el OBJETIVO era BUSCAR REG32=[REG32+0xNN] */
    else if ( result.operation == OP_MEMS_TO_REGS )
    {
    /* Recorro TODOS los REGISTROS */
      for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
      {
      /* Si este REGISTRO vale IGUAL que el CONTENIDO de la MEMORIA */
        if ( ( my_current_context [ cont ] & 0xfffffff0 ) == SYMBOLIC_MEMORY_VALUE )
        {
        /* Hago la ASIGNACION con este REGISTRO */
          result.asignated_registers [ cont ] = my_current_context [ cont ] & 0xf;
        }
      }
    }

  /* Inicializo el FLAG de JUMP CONDICIONAL */
    result.conditional_jumps = 0;

  /* Recorro TODAS las instrucciones del GADGET */
    for ( cont = 0 ; cont < eips.Len () ; cont ++ )
    {
    /* Si la instruccion ES un JUMP CONDICIONAL */
      if ( is_conditional_jump ( eips.Get ( cont ) ) == TRUE )
      {
      /* Seteo el FLAG de JUMP CONDICIONAL */
        result.conditional_jumps ++;
      }
    }
  }

/* Si ENCONTRO algun GADGET ( Again ) */
  if ( ret == TRUE )
  {
  /* Copio la primera CONDICION */
    result2 = ( RESULT * ) malloc ( sizeof ( RESULT ) );
    *result2 = result;
    results.Add ( ( void * ) result2 );

  /* Copio TODAS las CONDICIONES ALCANZADAS */
    results.Append ( results2 );
  }

/* Restauro el contexto  ( solo los registros ) */
  memcpy ( ( void * ) context , &original_context , sizeof ( QEMU_CONTEXT ) );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void restore_memory ( List &sections , SECTION *current_section )
{
  SECTION *section;
  unsigned int cont;

/* Restauro la CURRENT SECTION */
  write_memory ( ( void * ) current_section -> address , current_section -> data , current_section -> size );
  
/* Recorro todas las secciones */
  for ( cont = 0 ; cont < sections.Len () ; cont ++ )
  {
  /* Levanto la siguiente seccion */
    section = ( SECTION * ) sections.Get ( cont );

  /* Si es NECESARIO restaurar esta SECCION */
    if ( section -> restorable == TRUE )
    {
//      printf ( "restoring %x - %x\n" , section -> address , ( unsigned int ) section -> address + section -> size );

    /* Restauro la seccion */
      write_memory ( ( void * ) section -> address , section -> data , section -> size );
    }
  }
}

//  /* Si no esta marcada como RESTAURABLE */
//    else
//    {
//    /* Si la seccion es EJECUTABLE */
//      if ( section -> protection & EXECUTABLE )
//      {
//      /* La restauro POR LAS DUDAS */
//        write_memory ( ( void * ) section -> address , section -> data , section -> size );
//      }
//    }
//  }
//}

////////////////////////////////////////////////////////////////////////////////

void print_objective ( FILE *foutput , RESULT *result )
{
  unsigned int asignaciones = 0;
  unsigned int cont, cont2;
  char *r1;
  char *r2;

/* Si son operaciones REGISTRO = REGISTRO/REGISTROS */
  if ( ( result -> operation == OP_REG_TO_REG ) || ( result -> operation == OP_REGS_TO_REG ) )
  {
  /* Obtengo el nombre de los registros involucrados */
    r1 = registers [ result -> register_index ];
    r2 = registers [ result -> operand ];

  /* Imprimo la ASIGNACION */
    fprintf ( foutput , "%s=%s" , r1 , r2 );
  }
/* Si son operaciones REGISTROS = REGISTRO */
  else if ( result -> operation == OP_REG_TO_REGS || result -> operation == OP_REGS_TO_REGS )
  {
  /* Recorro TODAS las ASIGNACIONES */
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Si este REGISTRO fue ASIGNADO */
      if ( result -> asignated_registers [ cont ] != -1 )
      {
      /* Obtengo el nombre de los registros involucrados */
        r1 = registers [ cont ];
        r2 = registers [ result -> asignated_registers [ cont ] ];

      /* Si es la PRIMERA ASIGNACION */
        if ( asignaciones == 0 )
        {
        /* Imprimo la ASIGNACION */
          fprintf ( foutput , "%s=%s" , r1 , r2 );
        }
      /* Si hay MAS */
        else
        {
        /* Imprimo la ASIGNACION */
          fprintf ( foutput , ", %s=%s" , r1 , r2 );
        }

      /* Incremento la cantidad de REGISTROS ASIGNADOS */
        asignaciones ++;
      }
    }
  }
/* Si es una operacion del tipo REGISTRO = VALOR/RANGO */
  else if ( ( result -> operation == OP_VALUE_TO_REG ) || ( result -> operation == OP_RANGE_TO_REG ) )
  {
  /* Obtengo el nombre de los registros involucrados */
    r1 = registers [ result -> register_index ];

  /* Imprimo la ASIGNACION */
    fprintf ( foutput , "%s=0x%.8x" , r1 , result -> operand );
  }
/* Si es una operacion del tipo REGISTRO = [MEM/MEMS+0xNNNN] */
  else if ( result -> operation == OP_MEM_TO_REG || result -> operation == OP_MEMS_TO_REG )
  {
  /* Obtengo el nombre de los registros involucrados */
    r1 = registers [ result -> register_index ];
    r2 = registers [ result -> operand ];

  /* Imprimo la ASIGNACION */
    fprintf ( foutput , "%s=[%s+0x%x]" , r1 , r2 , result -> offset_base );
  }
/* Si es una operacion del tipo REGISTROS = [MEM+0xNNNN] */
  else if ( result -> operation == OP_MEM_TO_REGS || result -> operation == OP_MEMS_TO_REGS )
  {
  /* Recorro TODAS las ASIGNACIONES */
    for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
    {
    /* Si este REGISTRO fue ASIGNADO */
      if ( result -> asignated_registers [ cont ] != -1 )
      {
      /* Obtengo el nombre de los registros involucrados */
        r1 = registers [ cont ];
        r2 = registers [ result -> asignated_registers [ cont ] ];

      /* Si es la PRIMERA ASIGNACION */
        if ( asignaciones == 0 )
        {
        /* Imprimo la ASIGNACION */
          fprintf ( foutput , "%s=[%s+0x%x]" , r1 , r2 , result -> offset_base );
        }
      /* Si hay MAS */
        else
        {
        /* Imprimo la ASIGNACION */
          fprintf ( foutput , ", %s=[%s+0x%x]" , r1 , r2 , result -> offset_base );
        }

      /* Incremento la cantidad de REGISTROS ASIGNADOS */
        asignaciones ++;
      }
    }

  /* Imprimo la ASIGNACION */
//    fprintf ( foutput , "%s=[%s+0x%x]" , r1 , r2 , result -> offset_base );
  }
/* Si es una operacion del tipo "RANGO RELATIVO" (REG==REG+M,REG+N) */
  else if ( result -> operation == OP_REGS_RANGE_TO_REG )
  {
  /* Obtengo el nombre de los registros involucrados */
    r1 = registers [ result -> register_index ];
    r2 = registers [ result -> operand ];

  /* Si el OFFSET es NEGATIVO */
    if ( ( int ) result -> offset_base < 0 )
    {
    /* Imprimo la ASIGNACION */
      fprintf ( foutput , "%s=%s-0x%x" , r1 , r2 , - ( result -> offset_base ) );
    }
  /* Si el OFFSET es POSITIVO */
    else
    {
    /* Imprimo la ASIGNACION */
      fprintf ( foutput , "%s=%s+0x%x" , r1 , r2 , result -> offset_base );
    }
  }
/* Si es una operacion del tipo [MEM+0xNNNN] = REGISTRO */
  else if ( result -> operation == OP_REG_TO_MEM || result -> operation == OP_REGS_TO_MEM )
  {
  /* Obtengo el nombre de los registros involucrados */
    r1 = registers [ result -> register_index ];
    r2 = registers [ result -> operand ];

  /* Imprimo la ASIGNACION */
    fprintf ( foutput , "[%s+0x%x]=%s" , r2 , result -> offset_base , r1 );
  }
}

////////////////////////////////////////////////////////////////////////////////

void print_objectives ( FILE *foutput , List &results )
{
  RESULT *result;
  RESULT *sub_result;
  unsigned int cont;

/* Obtengo el GADGET PRINCIPAL */
  result = ( RESULT * ) results.Get ( 0 );

/* Recorro TODAS las CONDICIONES CUMPLIDAS */
  for ( cont = 0 ; cont < results.Len () ; cont ++ )
  {
  /* Levanto el siguiente resultado */
    sub_result = ( RESULT * ) results.Get ( cont );

  /* Si es el OBJETIVO PRIMARIO */
    if ( cont == 0 )
    {
    /* Imprimo la primera parte de los MATCHEOS */
      fprintf ( foutput , "--> matches: " );
    }
  /* Si es un OBJETIVO SECUNDARIO */
    else
    {
    /* Imprimo la siguiente parte de los MATCHEOS */
      fprintf ( foutput , ", " );
    }

  /* Imprimo el RESULTADO */
    print_objective ( foutput , sub_result );
  }

/* Imprimo la ultima parte de los MATCHEOS */
  fprintf ( foutput , "\n" );

/* Si NO es un STACK PIVOTING */
  if ( result -> stack_pivoting == FALSE )
  {
  /* Si el balance es POSITIVO */
    if ( result -> stack_used >= 0 )
    {
    /* Imprimo el STACK USADO */
      fprintf ( foutput , "--> stack used: +0x%x\n" , result -> stack_used );
    }
  /* Si el balance es NEGATIVO */
    else
    {
    /* Imprimo el STACK USADO */
      fprintf ( foutput , "--> stack used: -0x%x\n" , - result -> stack_used );
    }
  }
/* Si es un STACK PIVOTING */
  else
  {
  /* No Imprimo el STACK USADO */
    fprintf ( foutput , "--> stack used: N/A\n" );
  }

/* Imprimo los registros que MANTUVIERON SU VALOR */
  fprintf ( foutput , "--> preserved registers: " );

/* Recorro TODOS los REGISTROS */
  for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
  {
  /* Si este registro NO CAMBIO */
    if ( result -> preserved_registers [ cont ] == TRUE )
    {
    /* Imprimo este registro */
      fprintf ( foutput , "%s " , registers [ cont ] );
    }
  }

/* Cierro la lista */
  fprintf ( foutput , "\n" );

/* Imprimo si uso JUMP CONDICIONALES */ 
  fprintf ( foutput , "--> conditional jumps used: %i\n" , result -> conditional_jumps );
}

////////////////////////////////////////////////////////////////////////////////

void print_gadget ( FILE *foutput , List &eips , int fake_snapshot )
{
  unsigned char buffer [ 16 ];
  unsigned int instruction_size;
  unsigned int cont;
  char *instruction;
  void *address;
  int ret;

/* Recorro todos los EIPs ejecutados */
  for ( cont = 0 ; cont < eips.Len () ; cont ++ )
  {
  /* Levanto la siguiente direccion */
    address = eips.Get ( cont );

  /* Leo los OPCODES de la instruccion ejecutada */
    ret = read_memory ( address , ( void * ) buffer , sizeof ( buffer ) );

  /* Si pude leer toda la memoria */
    if ( ret == TRUE )
    {
    /* Desensamblo la instruccion */
      instruction = disassembly ( address , buffer , &instruction_size );

    /* Si es un SNAPSHOT VALIDO */
      if ( fake_snapshot == FALSE )
      {
      /* Instruccion parte del GADGET */
        fprintf ( foutput , "*** %.8x: %s\n" , address , instruction );
      }
    /* Si es un FILE ESTATICO */
      else
      {
      /* Instruccion parte del GADGET */
        fprintf ( foutput , "*** %.8x: %s\n" , ( unsigned int ) address & 0x00ffffff , instruction );
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

int is_register ( char *registro )
{
  unsigned int cont;
  int ret = FALSE;

/* Recorro la lista de registros */
  for ( cont = 0 ; cont < sizeof ( registers ) / sizeof ( char * ) ; cont ++ )
  {
  /* Si es este registro */
    if ( stricmp ( registers [ cont ] , registro ) == 0 )
    {
    /* Retorno OK */
      ret = TRUE;

    /* Dejo de buscar */
      break;
    }
  }

/* Si NO encontre nada */
  if ( ret == FALSE )
  {
  /* Si el registro es las EFLAGS */
    if ( stricmp ( registro , "eflags" ) == 0 )
    {
    /* Retorno OK */
      ret = TRUE;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_register_index ( char *registro )
{
  unsigned int cont;
  int index = -1;

/* Recorro la lista de registros */
  for ( cont = 0 ; cont < sizeof ( registers ) / sizeof ( char * ) ; cont ++ )
  {
  /* Si es este registro */
    if ( stricmp ( registers [ cont ] , registro ) == 0 )
    {
    /* Retorno el indice */
      index = cont;

    /* Dejo de buscar */
      break;
    }
  }

/* Si NO encontre nada */
  if ( index == -1 )
  {
  /* Si el registro es las EFLAGS */
    if ( stricmp ( registro , "eflags" ) == 0 )
    {
    /* Retorno el indice */
      index = EF_OBJECTIVE;
    }
  }

  return ( index );
}

////////////////////////////////////////////////////////////////////////////////

int get_immediate ( char *immediate , unsigned int *value )
{
  unsigned int v;
  int ret = FALSE;

/* Si es un NUMERO HEXADECIMAL */
  if ( strncmp ( immediate , "0x" , 2 ) == 0 ) 
  {
  /* Si pude obtener el valor */
    if ( sscanf ( immediate , "%x" , &v ) == 1 )
    {
    /* Retorno el VALOR */
      *value = v;

    /* Retorno OK */
      ret = TRUE;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_range ( char *string , unsigned int *v1 , unsigned int *v2 )
{
  char range [ 256 ];
  char *part1;
  char *part2;
  int ret = FALSE;

/* Hago una COPIA de la linea */
  strncpy ( range , string , sizeof ( range ) );

/* Separo el string en 2 partes */
  part1 = strtok ( range , "," );
  part2 = strtok ( NULL , "" );

/* Si pude separar el string en 2 partes */
  if ( ( part1 != NULL ) && ( part2 != NULL ) )
  {
  /* Si las 2 partes son NUMEROS HEXADECIMALES */
    if ( ( strncmp ( part1 , "0x" , 2 ) == 0 ) && ( strncmp ( part2 , "0x" , 2 ) == 0 ) ) 
    {
    /* Retorno los 2 valores */
      sscanf ( part1 , "%x" , v1 );
      sscanf ( part2 , "%x" , v2 );

    /* Si el primer valor es MENOR o IGUAL al segundo */
      if ( *v1 <= *v2 )
      {
      /* Retorno OK */
        ret = TRUE;
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_memory_position ( char *string )
{
  int ret = FALSE;

/* Si el string mide mas de 2 bytes */
  if ( strlen ( string ) > 2 )
  {
  /* Si empieza y termina con corchetes */
    if ( ( string [ 0 ] == '[' ) && ( string [ strlen ( string ) - 1 ] == ']' ) )
    {
    /* Retorno OK */
      ret = TRUE;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_register_plus_value ( char *string , unsigned int *register_index , unsigned int *value )
{
  char operando [ 256 ];
  char *operation;
  char *part1;
  char *part2;
  unsigned int rindex;
  unsigned int offset;
  int valid_register = FALSE;
  int ret = FALSE;

/* Hago una COPIA de la linea */
  strncpy ( operando , string , sizeof ( operando ) );

/* Si tengo un SIGNO POSITIVO */
  if ( strchr ( operando , '+' ) != NULL )
  {
  /* Tengo una SUMA */
    operation = "+";
  }
/* Si tengo un SIGNO NEGATIVO */
  else
  {
  /* Tengo una RESTA */
    operation = "-";
  }

/* Separo al string por el signo '+' */
  part1 = strtok ( operando , operation );
  part2 = strtok ( NULL , operation );

/* Si tengo las 2 partes */
  if ( ( part1 != NULL ) && ( part2 != NULL ) )
  {
  /* Si la primer parte es un registro */
    if ( is_register ( part1 ) == TRUE )
    {
    /* Obtengo el INDICE del REGISTRO */
      rindex = get_register_index ( part1 );

    /* Para seguir parseando el resto */
      valid_register = TRUE;
    }
  /* Si la primer parte son TODOS los registros */
    else if ( stricmp ( part1 , "reg32" ) == 0 )
    {
    /* Obtengo el INDICE del REGISTRO */
      rindex = ALL_REGISTERS;

    /* Para seguir parseando el resto */
      valid_register = TRUE;
    }

  /* Si es un REGISTRO VALIDO */
    if ( valid_register == TRUE )
    {
    /* Si pude obtener el OFFSET */
      if ( get_immediate ( part2 , &offset ) == TRUE )
      {
      /* Retorno los valores */
        *register_index = rindex;

      /* Si esta SUMANDO UN OFFSET */
        if ( strcmp ( operation , "+" ) == 0 )
        {
        /* Lo pongo como POSITIVO */
          *value = offset;
        }
      /* Si esta RESTANDO UN OFFSET */
        else
        {
        /* Lo pongo como NEGATIVO */
          *value = ( unsigned int ) ( - ( int ) offset );
        }

      /* Retorno OK */
        ret = TRUE;
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_register_range ( char *string , int *register_index , unsigned int *base , unsigned int *limit )
{
  unsigned int register_index1;
  unsigned int register_index2;
  unsigned int offset1;
  unsigned int offset2;
  char operando [ 256 ];
  char *part1;
  char *part2;
  int ret = FALSE;
  int ret1;
  int ret2;

/* Hago una COPIA de la linea */
  strncpy ( operando , string , sizeof ( operando ) );

/* Separo al string por una coma ',' */
  part1 = strtok ( operando , "," );
  part2 = strtok ( NULL , "," );

/* Si tengo las 2 partes */
  if ( ( part1 != NULL ) && ( part2 != NULL ) )
  {
  /* Obtengo los REGISTROS y los OFFSETS */
    ret1 = get_register_plus_value ( part1 , &register_index1 , &offset1 );
    ret2 = get_register_plus_value ( part2 , &register_index2 , &offset2 );

  /* Si pude obtener los 2 valores */
    if ( ( ret1 == TRUE ) && ( ret2 == TRUE ) )
    {
    /* Si el RANGO es con el MISMO REGISTRO */
      if ( register_index1 == register_index2 )
      {
      /* Si OFFSET1 es COHERENTE con OFFSET2 */
        if ( ( int ) offset1 <= ( int ) offset2 )
        {
        /* Retorno los valores encontrados */
          *register_index = register_index1;
          *base = offset1;
          *limit = offset2;

        /* Retorno OK */
          ret = TRUE;
        }
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_this_objective ( char *line , OBJECTIVE *objective )
{
  char myline [ 255 + 1 ];
  char *registro;
  char *operando;
  char *part1;
  char *part2;
  unsigned int offset;
  unsigned int value;
  unsigned int base;
  unsigned int limit;
  unsigned int register_operand;
  unsigned int register_index;
  int register_index1;
  int register_index2;
  int ret = FALSE;

/* Hago una copia de la linea */
  strncpy ( myline , line , 255 );

/* Divido el objetivo en 2 */
  registro = strtok ( myline , "=" );
  operando = strtok ( NULL , "=" );

//  printf ( "part1: %s\n" , registro );
//  printf ( "part2: %s\n" , operando );

/* Si pude obtener las 2 partes */
  if ( ( registro != NULL ) && ( operando != NULL ) )
  {
  /* Obtengo el indice del registro */
    register_index1 = get_register_index ( registro );

  /* Si la PRIMER PARTE es un REGISTRO VALIDO */
    if ( register_index1 != -1 )
    {
    /* Obtengo el indice del registro */
      register_index2 = get_register_index ( operando );

    /* Si la SEGUNDA PARTE es un REGISTRO VALIDO */
      if ( register_index2 != -1 )
      {
//        printf ( "register --> %s\n" , registro );
//        printf ( "operand --> %s\n" , operando );

      /* Seteo el OBJETIVO */
        objective -> register_index = register_index1;
        objective -> operation = OP_REG_TO_REG;
        objective -> operand = register_index2;
        objective -> offset_base = 0;
        objective -> offset_limit = 0;

      /* Retorno OK */
        ret = TRUE;
      }
    /* Si la SEGUNDA PARTE es un REGISTRO CUALQUIERA */
      else if ( stricmp ( operando , "reg32" ) == 0 )
      {
//        printf ( "register --> %s\n" , registro );
//        printf ( "operand --> %s\n" , operando );

      /* Seteo el OBJETIVO */
        objective -> register_index = register_index1;
        objective -> operation = OP_REGS_TO_REG;
        objective -> operand = 0xffffffff;
        objective -> offset_base = 0;
        objective -> offset_limit = 0;

      /* Retorno OK */
        ret = TRUE;
      }
    /* Si la SEGUNDA PARTE es UN RANGO */
      else if ( get_range ( operando , &base , &limit ) == TRUE )
      {
      /* Seteo el OBJETIVO */
        objective -> register_index = register_index1;
        objective -> operation = OP_RANGE_TO_REG;
        objective -> operand = 0xffffffff;
        objective -> offset_base = base;
        objective -> offset_limit = limit;

      /* Retorno OK */
        ret = TRUE;
      }
    /* Si la SEGUNDA PARTE es UN VALOR INMEDIATO */
      else if ( get_immediate ( operando , &value ) == TRUE )
      {
      /* Seteo el OBJETIVO */
        objective -> register_index = register_index1;
        objective -> operation = OP_VALUE_TO_REG;
        objective -> operand = value;
        objective -> offset_base = 0;
        objective -> offset_limit = 0;

      /* Retorno OK */
        ret = TRUE;
      }
    /* Si la SEGUNDA PARTE es UNA POSICION DE MEMORIA */
      else if ( is_memory_position ( operando ) == TRUE )
      {
      /* Elimino los parentesis */
        operando = operando + 1;
        operando [ strlen ( operando ) - 1 ] = 0;

      /* Si pude obtener REGISTRO + ALGO */
        if ( get_register_plus_value ( operando , &register_index , &offset ) == TRUE )
        {
        /* Seteo el OBJETIVO */
          objective -> register_index = register_index1;
          objective -> operand = register_index;
          objective -> offset_base = offset;
          objective -> offset_limit = 0;

        /* Si es un registro SOLO */
          if ( register_index != ALL_REGISTERS )
          {
          /* Busco para un SOLO REGISTRO */
            objective -> operation = OP_MEM_TO_REG;
          }
        /* Si son TODOS los registros */
          else
          {
          /* Busco para TODOS los REGISTROS */
            objective -> operation = OP_MEMS_TO_REG;
          }

        /* Retorno OK */
          ret = TRUE;
        }
      }
    /* Si la segunda parte es un RANGO con REGISTROS */
      else if ( get_register_range ( operando , &register_index2 , &base , &limit ) == TRUE )
      {
      /* Seteo el OBJETIVO */
        objective -> register_index = register_index1;
        objective -> operation = OP_REGS_RANGE_TO_REG;
        objective -> operand = register_index2;
        objective -> offset_base = base;
        objective -> offset_limit = limit;

      /* Retorno OK */
        ret = TRUE;
      }
    }
  /* Si es una operacion REG32 = ALGO */
    else if ( stricmp ( registro , "reg32" ) == 0 )
    {
    /* Obtengo el indice del registro */
      register_index2 = get_register_index ( operando );

    /* Si la SEGUNDA PARTE es un REGISTRO VALIDO */
      if ( register_index2 != -1 )
      {
      /* Seteo el OBJETIVO */
        objective -> register_index = 0xffffffff;
        objective -> operation = OP_REG_TO_REGS;
        objective -> operand = register_index2;
        objective -> offset_base = 0;
        objective -> offset_limit = 0;

      /* Retorno OK */
        ret = TRUE;
      }
    /* Si la SEGUNDA PARTE es un REGISTRO CUALQUIERA ( REG32 = REG32 ) */
      else if ( stricmp ( operando , "reg32" ) == 0 )
      {
      /* Seteo el OBJETIVO */
        objective -> register_index = 0xffffffff;
        objective -> operation = OP_REGS_TO_REGS;
        objective -> operand = 0xffffffff;
        objective -> offset_base = 0;
        objective -> offset_limit = 0;

      /* Retorno OK */
        ret = TRUE;
      }
    /* Si la SEGUNDA PARTE es UNA/VARIAS POSICION DE MEMORIA */
      else if ( is_memory_position ( operando ) == TRUE )
      {
      /* Elimino los parentesis */
        operando = operando + 1;
        operando [ strlen ( operando ) - 1 ] = 0;

      /* Si pude obtener REGISTRO + ALGO */
        if ( get_register_plus_value ( operando , &register_index , &offset ) == TRUE )
        {
        /* Seteo el OBJETIVO */
          objective -> register_index = register_index1;
          objective -> operand = register_index;
          objective -> offset_base = offset;
          objective -> offset_limit = 0;

        /* Si es un registro SOLO */
          if ( register_index != ALL_REGISTERS )
          {
          /* Busco para un SOLO REGISTRO */
            objective -> operation = OP_MEM_TO_REGS;
          }
        /* Si son TODOS los registros */
          else
          {
          /* Busco para TODOS los REGISTROS */
            objective -> operation = OP_MEMS_TO_REGS;
          }

        /* Retorno OK */
          ret = TRUE;
        }
      }
    }
  /* Si es una OPERACION DE ESCRITURA */
    else
    {
    /* Uso nombres mas representativos :P */
      part1 = registro;
      part2 = operando;

    /* Si la PRIMER PARTE es UNA POSICION DE MEMORIA */
      if ( is_memory_position ( part1 ) == TRUE )
      {
      /* Elimino los parentesis */
        part1 = part1 + 1;
        part1 [ strlen ( part1 ) - 1 ] = 0;

      /* Si pude obtener REGISTRO + ALGO */
        if ( get_register_plus_value ( part1 , &register_index , &offset ) == TRUE )
        {
        /* Obtengo el indice del registro */
          register_operand = get_register_index ( part2 );

        /* Si es un REGISTRO en PARTICULAR */
          if ( register_operand != -1 )
          {
          /* Seteo el OBJETIVO */
            objective -> register_index = register_operand;
            objective -> operation = OP_REG_TO_MEM;
            objective -> operand = register_index;
            objective -> offset_base = offset;
            objective -> offset_limit = 0;

          /* Retorno OK */
            ret = TRUE;
           }
        /* Si son TODOS los REGISTROS */
           else
           {
           /* Si es la CONSTANTE "reg32" */
             if ( strcmp ( part2 , "reg32" ) == 0 )
             {
             /* Seteo el OBJETIVO */
               objective -> register_index = register_operand;
               objective -> operation = OP_REGS_TO_MEM;
               objective -> operand = register_index;
               objective -> offset_base = offset;
               objective -> offset_limit = 0;

             /* Retorno OK */
               ret = TRUE;
             }
           }
        }
      }
    }
  }

/* Si es un OBJETIVO VALIDO */
  if ( ret == TRUE )
  {
  /* Si el DESTINO es el STACK */
    if ( objective -> register_index == SP_OBJECTIVE )
    {
    /* Inicializo el campo del Stack Pivoting */
      objective -> stack_pivoting = TRUE;
    }
    else
    {
    /* Inicializo el campo del Stack Pivoting */
      objective -> stack_pivoting = FALSE;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_this_asignation ( char *line , List &sections , List &asignations )
{
  ASIGNATION *asignation;
  SECTION *section;
  unsigned int register_index;
  unsigned int value;
  unsigned int cont;
  unsigned int base;
  unsigned int limit;
  char *first_part;
  char *second_part;
  char *range1;
  char *range2;
  int asignation_ok = FALSE;
  int module_found = FALSE;
  int ret = FALSE;
  int res;
  List modules;

/* Divido el objetivo en 2 */
  first_part = strtok ( line , "=" );
  second_part = strtok ( NULL , "" );

//  printf ( "registro = %s\n" , first_part );
//  printf ( "operando = %s\n" , second_part );

/* Si pude obtener las 2 partes */
  if ( ( first_part != NULL ) && ( second_part != NULL ) )
  {
  /* Si la primer parte es el RANGO DE TESTEO */
    if ( stricmp ( first_part , "test_range" ) == 0 )
    {
    /* Si pude obtener el RANGO */
      if ( get_range ( second_part , &base , &limit ) == TRUE )
      {
      /* Tengo el RANGO de BRUTFORCEO */
        asignation_ok = TRUE;
      }
//    /* Si NO es un RANGO EXPLICITO */
//      else
//      {
//      /* Recorro todas las SECCIONES del SNAPSHOT */
//        for ( cont = 0 ; cont < sections.Len () ; cont ++ )
//        {
//        /* Levanto la siguiente seccion */
//          section = ( SECTION * ) sections.Get ( cont );
//
//        /* Si es el modulo que estoy buscando */
//          if ( stricmp ( section -> module_name , second_part ) == 0 )
//          {
//          /* Si es la primer seccion del modulo */
//            if ( module_found == FALSE )
//            {
//            /* Seteo el primer rango del modulo */
//              base = ( unsigned int ) section -> address;
//              limit = ( unsigned int ) section -> address + section -> size;
//
//            /* Marco al modulo como encontrado */
//              module_found = TRUE;
//
//            /* Tengo el RANGO de BRUTFORCEO */
//              asignation_ok = TRUE;
//            } 
//          /* Si hay mas entradas para el modulo */
//            else
//            {
//            /* Actualizo SOLO el LIMITE */
//              limit = ( unsigned int ) section -> address + section -> size;
//            }
//          }
//        }
//      }

    /* Si pude obtener el valor de "test_range" */
      if ( asignation_ok == TRUE )
      {
//        printf ( "range = %.8x - %.8x\n" , base , limit );

      /* Si la base es MENOR que el LIMITE */
        if ( base < limit )
        {
        /* Creo una ASIGNACION */
          asignation = ( ASIGNATION * ) malloc ( sizeof ( ASIGNATION ) );
          asignation -> var = VAR_TEST_RANGE;
          asignation -> operation = AS_EQUAL_TO_RANGE;
          asignation -> v1 = base;
          asignation -> v2 = limit;

        /* Agrego la asignacion */
          asignations.Add ( ( void * ) asignation );

        /* Retorno OK */
          ret = TRUE;
        }
      }
    }
  /* Si es la LISTA de MODULOS donde BUSCAR */
    else if ( stricmp ( first_part , "modules" ) == 0 )
    {
    /* Creo una ASIGNACION */
      asignation = ( ASIGNATION * ) malloc ( sizeof ( ASIGNATION ) );
      asignation -> var = VAR_MODULES;
      asignation -> operation = AS_EQUAL_TO_STRING;
      asignation -> v1 = ( unsigned int ) malloc ( strlen ( second_part ) + 1 );

    /* Copio la lista de modulos */
      strcpy ( ( char * ) asignation -> v1 , second_part );

    /* Agrego la asignacion */
      asignations.Add ( ( void * ) asignation );

    /* Retorno OK */
      ret = TRUE;
    }
  /* Si la primer parte es un RANGO CONTROLABLE */
    else if ( stricmp ( first_part , "cdata" ) == 0 )
    {
    /* Si pude obtener el RANGO */
      if ( get_range ( second_part , &base , &limit ) == TRUE )
      {
      /* Creo una ASIGNACION */
        asignation = ( ASIGNATION * ) malloc ( sizeof ( ASIGNATION ) );
        asignation -> var = VAR_CDATA;
        asignation -> operation = AS_EQUAL_TO_RANGE;
        asignation -> v1 = base;
        asignation -> v2 = limit;

      /* Agrego la asignacion */
        asignations.Add ( ( void * ) asignation );

      /* Retorno OK */
        ret = TRUE;
      }
    }
  /* Si es un registro */
    else if ( is_register ( first_part ) == TRUE )
    {
    /* Obtengo el indice del registro */
      register_index = get_register_index ( first_part );

    /* Si la segunda parte es un NUMERO */
      if ( strncmp ( second_part , "0x" , 2 ) == 0 )
      {
      /* Obtengo el valor INMEDIATO */
        res = sscanf ( second_part , "%x" , &value );

      /* Si el valor pudo ser levantado */
        if ( res == 1 )
        {
        /* Creo una ASIGNACION */
          asignation = ( ASIGNATION * ) malloc ( sizeof ( ASIGNATION ) );
          asignation -> var = register_index;
          asignation -> operation = AS_EQUAL_TO_VALUE;
          asignation -> v1 = value;

        /* Agrego la asignacion */
          asignations.Add ( ( void * ) asignation );

        /* Retorno OK */
          ret = TRUE;
        }
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_line ( FILE *f , char *line , unsigned int size )
{
  char *p1;
  char *p2;
  int ret = FALSE;
  int res;

/* Levanto la siguiente linea */
  if ( fgets ( line , size , f ) != 0 )
  {
  /* Si el ultimo caracter es un ENTER */
    if ( line [ strlen ( line ) - 1 ] == '\n' )
    {
    /* Elimino el ENTER */
      line [ strlen ( line ) - 1 ] = '\x00';
    }

  /* Apunto al string */
    p1 = line;
    p2 = line;

  /* Recorro todos los caracteres de la linea */
    do
    {
    /* Si NO es un ESPACIO */
      if ( *p2 != ' ' )
      {
      /* Copio el caracter */
        *p1 = *p2;

      /* Avanzo al siguiente caracter */
        p1 ++;
      }

    /* Avanzo al siguiente caracter */
      p2 ++;
    }
    while ( *p2 != 0 );

  /* Pongo un ENTER al final */
    *p1 = 0;

  /* Retorno OK */
    ret = TRUE;
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

char *my_strtok ( char *line , char *pattern )
{
  static char *p = NULL;
  char *t = NULL;
  char *subline;

/* Si es la primera pasada */
  if ( line != NULL )
  {
  /* Apunto al string */
    p = line;
  }

/* Si tengo un string VALIDO */
  if ( p != NULL )
  {
  /* Apunto al principio del string */
    t = p;

  /* Busco el pattern en el string */
    subline = strstr ( p , pattern );

  /* Si el pattern existe */
    if ( subline != NULL )
    {
    /* Avanzo a la siguiente parte del string */
      p = subline + strlen ( pattern );

    /* Cierro el string donde empieza el pattern */
      *subline = 0;
    }
  /* Si el pattern NO existe */
    else
    {
    /* Me posiciono al final del string */
      p = NULL;
    }
  }

  return ( t );
}

////////////////////////////////////////////////////////////////////////////////

int get_elements_from_string_list ( char *string , List &list )
{
  int ret = TRUE;
  char *module;
  char *s;

/* Inicializo la lista */
  list.Clear ();

/* Busco el resto de las partes */
  while ( ( s = strtok ( string , "," ) ) != NULL )
  {
  /* Alloco espacio para el nombre del modulo */
    module = ( char * ) malloc ( strlen ( s ) + 1 );

  /* Copio el nombre del modulo */
    strcpy ( module , s );

  /* Agrego el MODULO a la lista */
    list.Add ( ( void * ) module );

  /* Para NO empezar de nuevo */
    string = NULL;

//    printf ( "MODULE: %s\n" , module );
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_these_objectives ( char *line , List &objectives )
{
  OBJECTIVE first_objective;
  OBJECTIVE objective;
  OBJECTIVE *objective2;
  char *subline;
  int ret = FALSE;

/* Mientras haya CONDICIONES */
  while ( ( subline = my_strtok ( line , "and" ) ) != NULL )
  {
  /* Obtengo este OBJETIVO */
    if ( get_this_objective ( subline , &objective ) == TRUE )
    {
    /* Creo un nuevo OBJETIVO */
      objective2 = ( OBJECTIVE * ) malloc ( sizeof ( OBJECTIVE ) );
      *objective2 = objective;

    /* Agrego el OBJETIVO a la lista */
      objectives.Add ( ( void * ) objective2 );

    /* Por ahora salgo OK */
      ret = TRUE;

    /* Si es el PRIMER OBJETIVO */
      if ( objectives.Len () == 1 )
      {
      /* Guardo el primer objetivo */
        first_objective = objective;
      }
    /* Si NO es el OBJETIVO PRIMARIO */
      else if ( objectives.Len () >= 2 )
      {
      /* Si es un OBJECTIVO que NO esta SOPORTADO como SECUNDARIO */
        if ( ( objective.stack_pivoting == TRUE ) || ( objective.operation == OP_MEM_TO_REG ) || ( objective.operation == OP_MEMS_TO_REG ) || ( objective.operation == OP_MEM_TO_REGS )  || ( objective.operation == OP_MEMS_TO_REGS ) )
        { 
        /* Imprimo un ERROR */
          printf ( "Error: Secondary objective not supported\n" );

        /* Salgo con ERROR */
          return ( FALSE );
        }
      /* Si tengo que chequear [REG+0xNN] = REG/REG32 */
        else if ( objective.operation == OP_REG_TO_MEM || objective.operation == OP_REGS_TO_MEM )
        {
        /* Si el primer objetivo NO hace la MISMA OPERACION */
          if ( ( first_objective.operation != objective.operation ) || ( first_objective.operand != objective.operand ) )
          {
          /* Imprimo un ERROR */
            printf ( "Error: Secondary objective not supported\n" );

          /* Salgo con ERROR */
            return ( FALSE );
          }
        }
      }
    }
    else
    {
    /* Salgo con ERROR */
      return ( FALSE );
    }

  /* Para que me retorne el RESTO de la LINEA */
    line = NULL;   
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_objective ( char *target_file , List &sections , List &objectives , List &asignations )
{
  FILE *f;
  int objective_counter = 0;
  int ret = FALSE;
  int cont;
  char line [ 256 ];
  char *p;

/* Abro el file pasado como parametro */
  f = fopen ( target_file , "rt" );

/* Si el file pudo ser abierto */
  if ( f != NULL )
  {
  /* Inicializo el contador de lineas */
    cont = 0;

  /* Recorro linea por linea */
    while ( get_line ( f , line , sizeof ( line ) ) == TRUE )
    {
    /* Avanzo a la siguiente linea */
      cont ++;

    /* Saco todos los espacios al principio de la linea */
      p = line;

    /* Si es una LINEA VACIA */
      if ( strlen ( p ) == 0 )
      {
      /* Paso a la siguiente linea */
        continue;
      }

    /* Si es un COMENTARIO */
      if ( *p == '#' )
      {
      /* Paso a la siguiente linea */
        continue;
      }

    /* Imprimo la linea */
//      printf ( "%i: %s\n" , cont , p );

    /* Si es un OBJETIVO */
      if ( strstr ( line , "==" ) != NULL )
      {
      /* Si pude obtener un objetivo valido */
        if ( get_these_objectives ( line , objectives ) == TRUE )
        {
        /* Incremento la cantidad de objetivos encontrados */
          objective_counter ++;

        /* Si es el primero */
          if ( objective_counter == 1 )
          {
          /* Tengo un OBJETIVO VALIDO */
            ret = TRUE;
          }
        /* Si hay mas de un OBJETIVO DEFINIDO */
          else
          {
          /* Mensaje al usuario */
            printf ( "Error: Multiple objectives not supported\n" );

          /* Salgo con ERROR */
            ret = FALSE;

          /* Dejo de procesar el file */
            break;
          }
        }
        else
        {
        /* Mensaje al usuario */
          printf ( "Error: Bad line %i\n" , cont );

        /* Salgo con ERROR */
          ret = FALSE;

        /* Dejo de procesar el file */
          break;
        }
      }
    /* Si es una ASIGNACION */    
      else if ( strstr ( line , "=" ) != NULL )
      {
      /* Si la asignacion es INVALIDA */
        if ( get_this_asignation ( line , sections , asignations ) == FALSE )
        {
        /* Mensaje al usuario */
          printf ( "\nError: invalid asignation in line %i\n" , cont );

        /* Salgo con ERROR */
          ret = FALSE;

        /* Dejo de procesar el file */
          break;
        }
      }

    /* Si no se que es */
      else
      {
      /* Mensaje al usuario */
        printf ( "Error: line %i ignored\n" , cont );

      /* Salgo con ERROR */
        ret = FALSE;
      }
    }

  /* Cierro el file */
    fclose ( f );
  }
/* Si el file NO pudo ser abierto */
  else
  {
    printf ( "\nError: objective file error\n" );
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int get_snapshot_sections ( char *snapshot_file , List &snapshot_sections , unsigned int *flags )
{
  SNAPSHOT_HEADER header;
  DUMPBLOCKV20 block;
  SECTION *section;
  unsigned int cont;
  char permisos [ 16 ];
  void *data;
  int ret = FALSE;
  int res;
  FILE *f;

/* Abro el file pasado como parametro */
  f = fopen ( snapshot_file , "rb" );

/* Si pude abrir el file */
  if ( f != NULL )
  {
  /* Levanto el HEADER */
    res = fread ( &header , sizeof ( header ) , 1 , f );

//    printf ( "secciones = %i\n" , header.blockcount );
//    printf ( "sizeof1 = %i\n" , sizeof ( header ) );
//    printf ( "sizeof2 = %i\n" , sizeof ( block ) );

//    header.blockcount = 1;

  /* Si pude leer el header completo */
    if ( res == 1 )
    {
    /* Si el header es INVALIDO */
      if ( header.sig != 0x70616E73 )
      {
      /* Cierro el file */
        fclose ( f );

      /* Salgo con ERROR */
        return ( FALSE );
      }

    /* Tag inicial */
      printf ( "\nProcessing snaphost file ...\n" );

    /* Inicializo el campo con el nombre del modulo al que pertenece la SECCION */
      strcpy ( block.name , "" );

    /* Levanto TODAS las SECCIONES del SNAPSHOT */
      for ( cont = 0 ; cont < header.blockcount ; cont ++ )
      {
      /* Si es la version 1 de la estructura */
        if ( header.version == 1 )
        {
        /* Levanto el header de la siguiente seccion */
          res = fread ( &block , sizeof ( DUMPBLOCKV10 ) , 1 , f );
        }
      /* Si es la version con el nombre de la DLL */
        else if ( header.version == 2 )
        {
        /* Levanto el header de la siguiente seccion */
          res = fread ( &block , sizeof ( DUMPBLOCKV20 ) , 1 , f );
        }
      /* Si hay algun ERROR */
        else
        {
        /* Salgo con ERROR */
          return ( FALSE );
        }

      /* Si pude leer el HEADER del BLOQUE de MEMORIA */
        if ( res == 1 )
        {
        /* Armo el string con los permisos */
          strcpy ( permisos , "" );
          strcat ( permisos , ( block.Protect & RANDOMIZABLE ) ? "A" : "-" );
          strcat ( permisos , ( block.Protect & READABLE ) ? "R" : "-" );
          strcat ( permisos , ( block.Protect & WRITABLE ) ? "W" : "-" );
          strcat ( permisos , ( block.Protect & EXECUTABLE ) ? "X" : "-" );

        /* Mensaje al usuario */
          printf ( "* section: %.8I64x - %.8I64x %s %s\n" , block.BaseAddress , block.RegionSize , permisos , block.name );

        /* Alloco memoria para levantar la SECCION */
          data = malloc ( ( unsigned int ) block.RegionSize );

        /* Levanto la data del file */
          res = fread ( data , ( unsigned int ) block.RegionSize , 1 , f );

        /* Si pude leer el bloque de memoria */
          if ( res == 1 )
          {
          /* Mappeo la direccion en QEMU */
            allocate_memory ( ( void * ) block.BaseAddress , ( unsigned int ) block.RegionSize );

          /* Creo una SECCION NUEVA */
            section = ( SECTION * ) malloc ( sizeof ( SECTION ) );
            section -> restorable = FALSE;  // Es al pedo restaurar TODO
            section -> address = ( void * ) block.BaseAddress;
            section -> size = ( unsigned int ) block.RegionSize;
            section -> protection = block.Protect & 0xf;
            strcpy ( section -> module_name , block.name );
            section -> data = data;
            snapshot_sections.Add ( ( void * ) section );

          /* Avanzo al siguiente bloque */
//            fseek ( f , block.RegionSize , SEEK_CUR );
          }
        /* Si lago fallo en la lectura */
          else
          {
          /* Salgo con ERROR */
            return ( FALSE );
          }
        }
      /* Si hubo algun ERROR */
        else
        {
        /* Salgo con ERROR */
          return ( FALSE );
        }
      }
  
    /* Retorno los flags del snapshot */
      *flags = header.flags;

    /* Retorno OK */
      ret = TRUE;
    }

  /* Cierro el file */
    fclose ( f );
  }

/* Linea para separar la lista */
  printf ( "\n" );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void get_test_range ( List &asignations , unsigned int *base_address , unsigned int *limit_address )
{
  SECTION *section;
  ASIGNATION *asignation;
  unsigned int cont;

/* Seteo inicial para la variable "test_range" */
  *base_address = 0;
  *limit_address = 0xffffffff;

/* Recorro todas las asignaciones hechas */
  for ( cont = 0 ; cont < asignations.Len () ; cont ++ )
  {
  /* Levanto la siguiente ASIGNACION */
    asignation = ( ASIGNATION * ) asignations.Get ( cont );

  /* Si es la asignacion de la variable "test_range" */
    if ( asignation -> var == VAR_TEST_RANGE )
    {
    /* Seteo el valor de la variable */
      *base_address = asignation -> v1;
      *limit_address = asignation -> v2;

    /* Dejo de buscar */
      break;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

int get_module_list ( List &asignations , List &module_list )
{
  ASIGNATION *asignation;
  unsigned int cont;
  int ret = FALSE;

/* Recorro TODAS las ASIGNACIONES */
  for ( cont = 0 ; cont < asignations.Len () ; cont ++ )
  {
  /* Levanto la siguiente ASIGNACION */
    asignation = ( ASIGNATION * ) asignations.Get ( cont );

  /* Si es la LISTA de MODULOS */
    if ( asignation -> var == VAR_MODULES )
    {
    /* Si pude obtener los modulos de la lista */
      if ( get_elements_from_string_list ( ( char * ) asignation -> v1 , module_list ) == TRUE )
      {
      /* Retorno OK */
        ret = TRUE;

      /* Dejo de buscar */
        break;
      }
    /* Si la lista NO esta bien */
      else
      {
      /* Salgo con ERROR */
        return ( FALSE );
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int is_section_in_targeted_module ( List &modules , SECTION *section )
{
  unsigned int cont;
  int ret = FALSE;
  char *module;

/* Recorro los MODULOS donde BUSCAR GADGETS */
  for ( cont = 0 ; cont < modules.Len () ; cont ++ )
  {
  /* Levanto el siguiente modulo */
    module = ( char * ) modules.Get ( cont );

  /* Si la SECCION pertenece a este MODULO */
    if ( stricmp ( module , section -> module_name ) == 0 )
    {
    /* Retorno OK */
      ret = TRUE;

    /* Dejo de buscar */
      break;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int check_loaded_modules ( List &sections , List &modules )
{
  SECTION *section;
  unsigned int cont1, cont2;
  char *module;
  int module_found;
  int ret = TRUE;

/* Busco MODULO por MODULO */
  for ( cont1 = 0 ; cont1 < modules.Len () ; cont1 ++ )
  {
  /* Levanto el siguiente MODULO */
    module = ( char * ) modules.Get ( cont1 );

  /* Inicializo el flag */
    module_found = FALSE;

  /* Recorro todas las SECCIONES */
    for ( cont2 = 0 ; cont2 < sections.Len () ; cont2 ++ )
    {
    /* Levanto el siguiente MODULO */
      section = ( SECTION * ) sections.Get ( cont2 );

    /* Si es el MODULO que estoy buscando */
      if ( stricmp ( section -> module_name , module ) == 0 )
      {
      /* Salgo OK */
        module_found = TRUE;

      /* Paso al siguiente */
        break;
      }
    }

  /* Si el modulo NO esta CARGADO */
    if ( module_found == FALSE )
    {
    /* Mensaje de ERROR */
      printf ( "[ ] Error: module '%s' not found in the snapshot\n" , module );

    /* Salgo con ERROR */
      ret = FALSE;

    /* Dejo de buscar */
      break;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void get_register_values ( List &asignations , QEMU_CONTEXT *context )
{
  ASIGNATION *asignation;
  unsigned int *registros;
  unsigned int cont;

/* Apunto al CONTEXTO */
  registros = ( unsigned int * ) context;

/* Recorro TODAS las ASIGNACIONES */
  for ( cont = 0 ; cont < asignations.Len () ; cont ++ )
  {
  /* Levanto la siguiente asignacion */
    asignation = ( ASIGNATION * ) asignations.Get ( cont );

  /* Si es una ASIGNACION INMEDIATA */
    if ( asignation -> operation == AS_EQUAL_TO_VALUE )
    {
    /* Si el registro es EIP */
      if ( asignation -> var == PC_OBJECTIVE )
      {
      /* Aborto el programa */
        printf ( "Error: EIP can't be set\n" );
        exit ( 0 );
      } 
    /* Si el registro es el STACK */
      else if ( asignation -> var == SP_OBJECTIVE )
      {
      /* Aborto el programa */
        printf ( "Error: ESP can't be set\n" );
        exit ( 0 );
      } 
    /* Si es cualquiera de los otros registros */
      else
      {
      /* Seteo el valor del registro PASADO POR EL USUARIO */
        registros [ asignation -> var ] = asignation -> v1;
      }
    }
  }
}

////////////////////////////////////////////////////////////////////////////////

int is_eflags_set_by_user ( List &asignations )
{
  ASIGNATION *asignation;
  unsigned int cont;
  int ret = FALSE;

/* Recorro TODAS las ASIGNACIONES */
  for ( cont = 0 ; cont < asignations.Len () ; cont ++ )
  {
  /* Levanto la siguiente asignacion */
    asignation = ( ASIGNATION * ) asignations.Get ( cont );

  /* Si el registro son las EFLAGS */
    if ( asignation -> var == EF_OBJECTIVE )
    {
    /* El usuario esta seteando el valor de las EFLAGS */
      ret = TRUE;

    /* Dejo de buscar */
      break;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

SECTION *create_section ( List &sections , void *address , void *data , unsigned int size , int protection , int restorable )
{
  SECTION *section;

/* Alloco memoria para la LIB */
  allocate_memory ( address , size );
//    printf ( "address = %x\n" , address );

/* Escribo la DATA en la memoria */
  write_memory ( address , data , size );

/* Alloco la SECCION */
  section = ( SECTION * ) malloc ( sizeof ( SECTION ) );
  section -> restorable = restorable;
  section -> address = address;
  section -> size = size;
  section -> protection = protection;
  strcpy ( section -> module_name , "" );
  section -> data = data;

/* Agrego la seccion */
  sections.Add ( ( void * ) section );

  return ( section );
}

////////////////////////////////////////////////////////////////////////////////

int main ( int argc , char *argv [] )
{
  QEMU_CONTEXT initial_context;
  QEMU_CONTEXT *context;
  SECTION *section;
  OBJECTIVE objective;
  RESULT result;
  ASIGNATION *asignation;
  char snapshot [ 256 ];
  char cmd [ 256 ];
  List backup_addresses;
  List addresses;
  List sections;
  List asignations;
  List objectives;
  List results;
  List snapshot_sections;
  List module_list;
  FILE *foutput = stdout;
  void *stack;
  void *heap;
  void *address;
  void *symbolic_data;
  unsigned int initial_address;
  unsigned int testing_range_size;
  unsigned int *current_context;
  unsigned int snapshot_flags;
  unsigned int base_address;
  unsigned int limit_address;
  unsigned int symbolic_value;
  unsigned int suggested_sp;
  unsigned int tries;
  unsigned int size;
  unsigned int t0;
  int eflags_set_by_user = FALSE;
  int fake_snapshot = FALSE;
  int snapshoter_res = 1;
  int processed;
  int completed;
  int pid;
  unsigned int cont;
  unsigned int cont2;
  unsigned int cont3;
  int ret;

/////////

/* Controlo los argumentos */
//  if ( argc != 2 ) && ( argc != 4 ) && ( argc != 5 ) )  /* Para probar con el shellcode de ARRIBA */
  if ( ( argc != 4 ) && ( argc != 5 ) )
  {
    printf ( "\nAgafi v1.1\n" );
    printf ( "Created by 'Nicolas A. Economou' & 'Diego Juarez'\n" );
    printf ( "Core Security Technologies, Buenos Aires, Argentina (2015)\n" );
    printf ( "\nUse: agafi option objective.txt [output_file]\n" );
    printf ( "\nOptions:\n" );
    printf ( " -p pid\n" );
    printf ( " -rp pid\n" );
    printf ( " -f module\n" );
    printf ( " -rf module\n" );
    printf ( " -s snapshot.bin\n" );

    printf ( "\n" );
    printf ( "Note:\n" );
    printf ( " -r means reuse snapshot (not taking another one)\n" );

    printf ( "\n" );
    printf ( "Assignations supported in objective.txt:\n" );
    printf ( " -EFLAGS=VALUE\n" );
    printf ( " -REG=VALUE\n" );
    printf ( " -modules=MODULE1, MODULE2, ...\n" );
    printf ( " -test_range=BASE,LIMIT\n" );

    printf ( "\n" );
    printf ( "Objectives supported in objective.txt:\n" );
    printf ( " -<REG|REG32>==<REG|REG32>\n" );
    printf ( " -REG==VALUE\n" );
    printf ( " -REG==MIN_VALUE,MAX_VALUE\n" );
    printf ( " -REG==REG<+|->0xMM,REG<+|->0xNN\n" );
    printf ( " -<REG|REG32>==[<REG|REG32>+0xNN]\n" );
    printf ( " -[REG+0xNN]==<REG|REG32>\n" );

    printf ( "\n" );
    printf ( "Notes:\n" );
    printf ( "* REG32 = All general purpose registers\n" );
    printf ( "* Many objectives can be concatenated using 'and' with some restrictions\n" );

    printf ( "\n" );
    printf ( "Warnings:\n" );
    printf ( "1. The assignation ESP=VALUE is not supported\n" );
    printf ( "2. The objective 'REG32==REG32' doesn't include Stack Pivotings\n" );
    printf ( "3. The objective '<REG|REG32>==[REG32+0xNN]' doesn't include [ESP+0xNN]\n" );

    printf ( "\n" );
    printf ( "Examples:\n" );
    printf ( " Please read \"Agafi-user-guide.txt\" to see more documentation\n" );

    return ( 0 );
  }

/////////

/* Si el OS no tiene la funcion DecodePointer */
  if ( GetProcAddress ( LoadLibrary ( "kernel32.dll" ) , "DecodePointer" ) == NULL )
  {
  /* Hack para poder usar DISTORM en OSs que no tienen las funcion "DecodePointer" */
    void *p = GetProcAddress ( GetModuleHandle ( "kernel32.dll" ) , "Beep" );
    unsigned long int escritos;

  /* Patcheo la funcion Beep con instrucciones */
    WriteProcessMemory ( ( HANDLE ) -1 , ( void * ) p , ( void * ) "\x8b\x44\x24\x04\xc2\x04\x00" , 7 , &escritos );
  }

/////////

/* Si NO esta DISTORM */
  if ( LoadLibrary ( disasm_lib ) == NULL )
  {
  /* Mensaje al USUARIO */
    printf ( "\n[ ] Error: '%s' not found\n" , disasm_lib );
    printf ( "\n*** IMPORTANT *** Download '%s' from \"https://code.google.com/p/distorm/downloads/detail?name=distorm3-3-dlls.zip\"\n" , disasm_lib );
    return ( 0 );
  }

/////////

/* Cargo QEMU */
  hqemu = LoadLibrary ( qemu_module );
//  printf ( "hqemu = %x\n" , hqemu );

/* Si QEMU NO pudo ser levantado */
  if ( hqemu == NULL )
  {
    printf ( "\n[ ] Error: %s not found\n" , qemu_module );
    return ( 0 );
  }

/* Instancio una VM */
  context = init_vm ();
//  printf ( "context en %x\n" , context );

/////////

/* Si tengo que tomar el SNAPSHOT de un PROCESO */
  if ( strcmp ( argv [ 1 ] , "-p" ) == 0 )
  {
  /* Obtengo el PID */
    sscanf ( argv [ 2 ] , "%i" , &pid );

  /* Armo el nombre del file */
    snprintf ( snapshot , sizeof ( snapshot ) , "%i.snap" , pid );

  /* Obtengo el SNAPSHOT del PROCESO */
    snprintf ( cmd , sizeof ( cmd ) , "gisnap %i %s" , pid , snapshot );
    snapshoter_res = system ( cmd );
  }
/* Si el SNAPSHOT ya fue tomado */
  else if ( strcmp ( argv [ 1 ] , "-rp" ) == 0 )
  {
  /* Obtengo el PID */
    sscanf ( argv [ 2 ] , "%i" , &pid );

  /* Armo el nombre del file */
    snprintf ( snapshot , sizeof ( snapshot ) , "%i.snap" , pid );
  }
/* Si tengo que tomar el SNAPSHOT de un FILE */
  else if ( strcmp ( argv [ 1 ] , "-f" ) == 0 )
  {
  /* Armo el nombre del file */
    snprintf ( snapshot , sizeof ( snapshot ) , "%s.snap" , argv [ 2 ] );

  /* Obtengo el SNAPSHOT del file ( Modulo o binario RAW ) */
    snprintf ( cmd , sizeof ( cmd ) , "fsnap %s %s" , argv [ 2 ] , snapshot );
    snapshoter_res = system ( cmd );
  }
/* Si el SNAPSHOT ya fue tomado */
  else if ( strcmp ( argv [ 1 ] , "-rf" ) == 0 )
  {
  /* Armo el nombre del file */
    snprintf ( snapshot , sizeof ( snapshot ) , "%s.snap" , argv [ 2 ] );
  }
/* Si el SNAPSHOT ya fue tomado */
  else if ( strcmp ( argv [ 1 ] , "-s" ) == 0 )
  {
  /* Armo el nombre del file */
    strncpy ( snapshot , argv [ 2 ] , sizeof ( snapshot ) );
  }
/* Si NO es una opcion SOPORTADA */
  else
  {
  /* Mensaje al USUARIO */
    printf ( "[ ] Error: Invalid option\n" );
    return ( 0 );
  }

/////////

/* Si hubo un ERROR con el SNAPSHOT */
  if ( snapshoter_res != 1 )
  {
  /* Mensaje al USUARIO */
    printf ( "[ ] Error: Snapshot not taken\n" );
    return ( 0 );
  }

/////////

/* Si hay un FILE para escupir el OUTPUT */
  if ( argc == 5 )
  {
  /* Abro el file para escupir la salida */
    foutput = fopen ( argv [ 4 ] , "wt" );

  /* Si el file NO pudo ser abierto */
    if ( foutput == NULL )
    {
    /* Mensaje de ERROR */
      printf ( "\nError: invalid output filename\n" );

    /* Salgo con ERROR */
      return ( FALSE );
    }
  }

/////////

/* Parseo las secciones del SNAPSHOT */
  ret = get_snapshot_sections ( snapshot , snapshot_sections , &snapshot_flags );

/* Si el SNAPSHOT tiene el FORMATO CORRECTO */
  if ( ret == TRUE )
  {
  /* Agrego las secciones del SNAPSHOT */
    sections.Append ( snapshot_sections );

  /* Si es un FAKE SNAPSHOT */
    if ( snapshot_flags & 0x80000000 )
    {
    /* Voy a imprimir SOLO los OFFSETS en el FILE */
      fake_snapshot = TRUE;
    }
  }
/* Si el SNAPSHOT es INVALIDO */
  else
  {
  /* Mensaje de ERROR */
    printf ( "\nError: invalid Snapshot\n" );

  /* Salgo con ERROR */
    return ( FALSE );
  }

/////////

/* Parseo el file que me dice que TENGO QUE BUSCAR */
  ret = get_objective ( argv [ 3 ] , snapshot_sections , objectives , asignations );

/* Si el file NO tiene el objetivo correcto */
  if ( ret == FALSE )
  {
  /* Mensaje de ERROR */
    printf ( "Error: Invalid objective\n" );

  /* Salgo con ERROR */
    return ( FALSE );
  }
/* Obtengo, por ahora, UN SOLO OBJETIVO */
  else
  {
  /* Agarro el PRIMER objetivo */
    objective = * ( OBJECTIVE * ) objectives.Get ( 0 );
  }

/////////

/* Si NO hay SNAPSHOT ( solo para testear este modulo ) */
  if ( argc == 2 )
  {
  /* Alloco memoria para la LIB */
    address = allocate_memory ( ( void * ) 0x33333333 , 0x1000 );
//    printf ( "address = %x\n" , address );

  /* Lib a buscar GADGETS */
    section = ( SECTION * ) malloc ( sizeof ( SECTION ) );
    section -> restorable = TRUE;
    section -> address = ( void * ) 0x33333333;
    section -> size = ( unsigned int ) code_end - ( unsigned int ) test;
    section -> protection = EXECUTABLE;
    section -> data = ( void * ) test;
    sections.Add ( ( void * ) section );
  }

/////////

/* Alloco memoria para el backup del STACK SIMBOLICO */
  stack = malloc ( 0x1000 );

/* Lleno la MITAD de zona de memoria con PADDING ( 0xbbbbbbbb ) */
  memset ( ( void * ) ( ( char * ) stack + 0x800 ) , 0xbb , 0x800 );

/* Creo un STACK de 4KB */
  create_section ( sections , ( void * ) SYMBOLIC_STACK_ADDRESS , stack , 0x1000 , READABLE | WRITABLE , TRUE );

/////////

/* Alloco las DIRECCIONES SIMBOLICAS para obtener MAS GADGETS */
  address = allocate_memory ( ( void * ) ( SYMBOLIC_GADGET_RETURN - 0x800 ) , 0x1000 );
//  printf ( "address = %x\n" , address );

/* Alloco memoria para el backup del STACK */
  heap = malloc ( 0x1000 );

/* Lleno la MITAD de zona de memoria con PADDING ( 0xbbbbbbbb ) */
  memset ( heap , 0xbb , 0x1000 );

/* Stack de la lib */
  section = ( SECTION * ) malloc ( sizeof ( SECTION ) );
  section -> restorable = TRUE;
  section -> address = ( void * ) ( SYMBOLIC_GADGET_RETURN - 0x800 );
  section -> size = 0x1000;
  section -> protection = READABLE | WRITABLE;
  section -> data = heap;
  sections.Add ( ( void * ) section );

/////////

/* Estado inicial de los REGISTROS */
  initial_context.eax = SYMBOLIC_REGISTER_VALUE | 0x000101ff;
  initial_context.ecx = SYMBOLIC_REGISTER_VALUE | 0x000202ff;
  initial_context.edx = SYMBOLIC_REGISTER_VALUE | 0x000404ff;
  initial_context.ebx = SYMBOLIC_REGISTER_VALUE | 0x000808ff;
  initial_context.esp = SYMBOLIC_REGISTER_VALUE | 0x001010ff;
  initial_context.ebp = SYMBOLIC_REGISTER_VALUE | 0x002020ff;
  initial_context.esi = SYMBOLIC_REGISTER_VALUE | 0x004040ff;
  initial_context.edi = SYMBOLIC_REGISTER_VALUE | 0x008080ff;
  initial_context.eip = 0xffffffff;

/////////

/* Si el OBJETIVO es PIVOTEAR el STACK */  
  if ( objective.register_index == SP_OBJECTIVE )
  {
  /* Si cualquier registro es VALIDO */
    if ( objective.operation == OP_REGS_TO_REG )
    {
    /* Alloco memoria para el backup del STACK */
      heap = malloc ( SYMBOLIC_TOTAL_STACK_PIVOTING_SIZE );

    /* Creo una SECCION en QEMU */
      create_section ( sections , ( void * ) SYMBOLIC_STACK_PIVOTING_ADDRESS , heap , SYMBOLIC_TOTAL_STACK_PIVOTING_SIZE , READABLE | WRITABLE , TRUE );

    /* Recorro todas las partes de FUTURO STACK */
      for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
      {
      /* Lleno la zona de memoria con PADDING ( 0x80808080 ) */
        memset ( ( void * ) ( ( char * ) heap + ( SYMBOLIC_STACK_PIVOTING_SIZE * cont ) ) , 0x80 + cont , SYMBOLIC_STACK_PIVOTING_SIZE );
      }

    /* Alloco las secciones con PADDING para los FUTUROS STACKS */
      for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
      {
      /* Alloco memoria para mi */
        heap = malloc ( 0x1000 );

      /* Creo una SECCION en QEMU */
        create_section ( sections , ( void * ) ( 0x80808080 + ( 0x01010101 * cont ) ) , heap , 0x1000 , READABLE | WRITABLE , TRUE );

      /* Paddeo la memoria */
        memset ( heap , 0x80 + cont , 0x1000 );
      }
    }
  /* Si el objetivo es "ESP = REG<-/+>OFF1,REG<-/+>OFF2" */
    else if ( objective.operation == OP_REGS_RANGE_TO_REG )
    {
    /* Si el SOURCE es el STACK */
      if ( objective.operand == SP_OBJECTIVE )
      {
      /* Si el rango es dentro del STACK ALLOCADO */
        if ( ( -0x800 <= ( int ) objective.offset_base ) && ( ( int ) objective.offset_limit <= 0x800 ) )
        {
        /* Escribo el rango que me interesa */
          memset ( ( char * ) stack + 0x800 + objective.offset_base , 0x80 , objective.offset_limit - objective.offset_base );
        }
      /* Si el rango supera los 0x800 bytes */
        else
        {
        /* Mensaje de ERROR */
          printf ( "\nError: Range not supported\n" );

        /* Salgo con ERROR */
          return ( FALSE );
        }
      }
    /* Si el SOURCE es en otro lado */
      else
      {
      /* Si la region mide algo coherente */
        if ( ( - ( SYMBOLIC_TOTAL_STACK_PIVOTING_SIZE / 2 ) <= ( int ) objective.offset_base ) && ( ( int ) objective.offset_limit <= ( SYMBOLIC_TOTAL_STACK_PIVOTING_SIZE / 2 ) ) )
        {
        /* Alloco memoria para poner el PADDING en el FUTURO STACK */
          heap = malloc ( SYMBOLIC_TOTAL_STACK_PIVOTING_SIZE );

        /* Paddeo toda el area */
          memset ( heap , 0 , SYMBOLIC_TOTAL_STACK_PIVOTING_SIZE );

        /* Escribo el rango que me interesa */
          memset ( ( char * ) heap + ( SYMBOLIC_TOTAL_STACK_PIVOTING_SIZE / 2 ) + objective.offset_base , 0x80 , objective.offset_limit - objective.offset_base );

        /* Creo una SECCION en QEMU para MAPEAR a donde APUNTA el REGISTRO que me interesa */
          create_section ( sections , ( void * ) SYMBOLIC_STACK_PIVOTING_ADDRESS , heap , SYMBOLIC_TOTAL_STACK_PIVOTING_SIZE , READABLE | WRITABLE , TRUE );
        }
        else
        {
        /* Mensaje de ERROR */
          printf ( "\nError: Range not supported\n" );

        /* Salgo con ERROR */
          return ( FALSE );
        }
      }
    }
  /* Si el OBJETIVO es ESP = REG */
    else
    {
    /* Alloco memoria para poner el PADDING en el FUTURO STACK */
      heap = malloc ( SYMBOLIC_STACK_PIVOTING_SIZE );

    /* Paddeo toda el area */
      memset ( heap , 0x80 , SYMBOLIC_STACK_PIVOTING_SIZE );

    /* Creo una SECCION en QEMU para MAPEAR a donde APUNTA el REGISTRO que me interesa */
      create_section ( sections , ( void * ) SYMBOLIC_STACK_PIVOTING_ADDRESS , heap , SYMBOLIC_STACK_PIVOTING_SIZE , READABLE | WRITABLE , TRUE );

    ////////

    /* Alloco memoria para de mi lado */
      heap = malloc ( 0x1000 );

    /* Lleno la MITAD de zona de memoria con PADDING ( 0x80808080 ) */
      memset ( heap , 0x80 , 0x1000 );

    /* Creo una SECCION en QEMU para bypassear CRASHES */
      create_section ( sections , ( void * ) 0x80808080 , heap , 0x1000 , READABLE | WRITABLE , TRUE );
    }
  }

/////////

/* Obtengo la lista de MODULOS donde BUSCAR */
  get_module_list ( asignations , module_list );

/* Si hay una lista de MODULOS donde BUSCAR */
  if ( module_list.Len () > 0 )
  {
  /* Si NO estan TODOS los MODULOS */
    if ( check_loaded_modules ( snapshot_sections , module_list ) == FALSE )
    {
    /* Mensaje de ERROR */
      printf ( "[ ] Error: invalid 'modules' parameter\n" );

    /* Salgo con ERROR */
      return ( FALSE );
    }
  }

/////////

/* Obtengo el RANGO de TESTEO */
  get_test_range ( asignations , &base_address , &limit_address );

/* Si la variable "test_range" NO fue SETEADA */
  if ( ( base_address == 0 ) && ( limit_address == 0xffffffff ) )
  {
  /* Si NO hay MODULOS seteados por el USUARIO */
    if ( module_list.Len () == 0 )
    {
    /* Si el SNAPSHOT tiene MAS DE UNA SECCION */
      if ( snapshot_sections.Len () > 1 )
      {
        printf ( "\n" );
        printf ( "Warning: Agafi will process all the snapshot executable addresses\n" );
        printf ( "Advice: Set the 'test_range' var in the config file\n" );

      /* Una demora para que se vea el mensaje */
        Sleep ( 1000 );
      }
    }
  }

/////////

/* Si los EFLAGS son SETEADOS por el USUARIO */
  if ( is_eflags_set_by_user ( asignations ) == TRUE )
  {
  /* Prendo el FLAG para NO probar COMBINACIONES de EFLAGS */
    eflags_set_by_user = TRUE;
  }

/* Obtengo las areas CONTROLABLES */
  for ( cont = 0 ; cont < asignations.Len () ; cont ++ )
  {
  /* Levanto la siguiente ASIGNACION */
    asignation = ( ASIGNATION * ) asignations.Get ( cont );

  /* Si es un RANGO CONTROLABLE */
    if ( asignation -> var == VAR_CDATA )
    {
    /* Alloco memoria para la region controlable */
      heap = malloc ( asignation -> v2 - asignation -> v1 );

    /* Paddeo la memoria */
      memset ( heap , 0xbb , asignation -> v2 - asignation -> v1 );

    /* Creo una SECCION en QEMU */
      create_section ( sections , ( void * ) asignation -> v1 , heap , asignation -> v2 - asignation -> v1 , READABLE | WRITABLE , FALSE );
    }
  }

/////////

/* Si el OBJETIVO es REG/REG32 = [REG+ALGO] */
  if ( objective.operation == OP_MEM_TO_REG || objective.operation == OP_MEM_TO_REGS )
  {
  /* Alloco la zona de memoria donde va a APUNTAR SOURCE */
    symbolic_data = malloc ( 0x1000 );

  /* Paddeo la memoria */
    memset ( symbolic_data , 0 , 0x1000 );

  /* Creo una SECCION en QEMU */
    create_section ( sections , ( void * ) SYMBOLIC_DATA_ADDRESS , symbolic_data , 0x1000 , READABLE | WRITABLE , TRUE );

  /* Si el OFFSET esta DENTRO del RANGO de la MEMORIA ALLOCADA */
    if ( objective.offset_base <= 0x800 - 4 )
    {
    /* Si el objetivo es hacer STACK PIVOTING */
      if ( objective.register_index == SP_OBJECTIVE )
      {
      /* Si el source es el STACK */
        if ( objective.operand == SP_OBJECTIVE )
        {
        /* Direccion donde MAPEO el FUTURO STACK */
          symbolic_value = SYMBOLIC_STACK_PIVOTING_ADDRESS;

        /* Escribo un VALOR SIMBOLICO en el STACK ( SYMBOLIC_MEMORY_GADGET ) */
          memcpy ( ( unsigned char * ) stack + 0x800 + objective.offset_base , ( void * ) &symbolic_value , sizeof ( symbolic_value ) );
        }
      /* Si el source NO es el STACK */
        else
        {
        /* Contexto actual */
          current_context = ( unsigned int * ) &initial_context;

        /* Apunto el registro al area simbolica */
          current_context [ objective.operand ] = SYMBOLIC_DATA_ADDRESS;

        /* Direccion donde MAPEO el FUTURO STACK */
          symbolic_value = SYMBOLIC_STACK_PIVOTING_ADDRESS;

        /* Escribo un VALOR SIMBOLICO en el STACK ( SYMBOLIC_MEMORY_GADGET ) */
          memcpy ( ( unsigned char * ) symbolic_data + objective.offset_base , ( void * ) &symbolic_value , sizeof ( symbolic_value ) );
        }
      }
    /* Si el objetivo NO es hacer stack pivoting */
      else
      {
      /* Si el source es el STACK */
        if ( objective.operand == SP_OBJECTIVE )
        {
        /* Direccion donde MAPEO el FUTURO STACK */
          SYMBOLIC_MEMORY_VALUE = SYMBOLIC_MEMORY_VALUE | 0xf;
          symbolic_value = SYMBOLIC_MEMORY_VALUE;

        /* Escribo un VALOR SIMBOLICO en el STACK ( SYMBOLIC_MEMORY_GADGET ) */
          memcpy ( ( unsigned char * ) stack + 0x800 + objective.offset_base , ( void * ) &symbolic_value , sizeof ( symbolic_value ) );
        }
      /* Si el source NO es el STACK */
        else
        {
        /* Contexto actual */
          current_context = ( unsigned int * ) &initial_context;

        /* Apunto el registro al area simbolica */
          current_context [ objective.operand ] = SYMBOLIC_DATA_ADDRESS;

        /* Direccion donde MAPEO el FUTURO STACK */
          SYMBOLIC_MEMORY_VALUE = SYMBOLIC_MEMORY_VALUE | 0xf;
          symbolic_value = SYMBOLIC_MEMORY_VALUE;

        /* Escribo un VALOR SIMBOLICO en el STACK ( SYMBOLIC_MEMORY_GADGET ) */
          memcpy ( ( unsigned char * ) symbolic_data + objective.offset_base , ( void * ) &symbolic_value , sizeof ( symbolic_value ) );
        }
      }
    }
  /* Si la zona de memoria esta FUERA DE RANGO */
    else
    {
    /* Salgo con ERROR */
      printf ( "\nError: this range is not supported\n" );
      return ( 0 );
    }
  }
/* Si el OBJETIVO es REG/REG32 = [REGS+ALGO] */
  else if ( objective.operation == OP_MEMS_TO_REG || objective.operation == OP_MEMS_TO_REGS )
  {
  /* Si el OFFSET esta DENTRO del RANGO de la MEMORIA ALLOCADA */
    if ( objective.offset_base <= 0x1000 - 4 )
    {
    /* Alloco memoria para TODOS los REGISTROS */
      for ( cont = 0 ; cont < VALID_REGISTERS ; cont ++ )
      {
      /* Si NO es para el STACK/EIP */
        if ( ( cont != SP_OBJECTIVE ) && ( cont != PC_OBJECTIVE ) )
        {
        /* Alloco memoria para APUNTAR al REGISTRO */
          symbolic_data = malloc ( 0x1000 );

        /* Limpio la memoria allocada */
          memset ( symbolic_data , 0 , 0x1000 );

        /* Cookie */
          symbolic_value = SYMBOLIC_MEMORY_VALUE + cont;

        /* Pongo el VALOR MAGICO en la POSICION ESPECIFICADA */
          memcpy ( ( unsigned char * ) symbolic_data + objective.offset_base , ( void * ) &symbolic_value , sizeof ( symbolic_value ) );

        /* Creo una SECCION en QEMU */
          create_section ( sections , ( void * ) ( SYMBOLIC_DATA_ADDRESS + ( cont * 0x1000 ) ) , symbolic_data , 0x1000 , READABLE | WRITABLE , TRUE );

        /* Contexto actual */
          current_context = ( unsigned int * ) &initial_context;

        /* Apunto el registro al area simbolica */
          current_context [ cont ] = SYMBOLIC_DATA_ADDRESS + ( cont * 0x1000 );
        }
      }
    }
  }
/* Si el OBJETIVO es [REG+ALGO] = REG/REG32 */
  else if ( objective.operation == OP_REG_TO_MEM || objective.operation == OP_REGS_TO_MEM )
  {
  /* Si el SOURCE NO es el STACK */
    if ( objective.operand != SP_OBJECTIVE )
    {
    /* Si la POSICION es VALIDA */
      if ( objective.offset_base <= 0x1000 - 4 )
      {
      /* Alloco la zona de memoria donde va a APUNTAR SOURCE */
        symbolic_data = malloc ( 0x1000 );

      /* Paddeo la memoria */
        memset ( symbolic_data , 0xff , 0x1000 );

      /* Creo una SECCION en QEMU */
        create_section ( sections , ( void * ) SYMBOLIC_DATA_ADDRESS , symbolic_data , 0x1000 , READABLE | WRITABLE , TRUE );

      /* Contexto actual */
        current_context = ( unsigned int * ) &initial_context;

      /* Apunto el registro al area simbolica */
        current_context [ cont ] = SYMBOLIC_DATA_ADDRESS + 0x800;
      }
    /* Si la zona de memoria esta FUERA DE RANGO */
      else
      {
      /* Salgo con ERROR */
        printf ( "\nError: this range is not supported\n" );
        return ( 0 );
      }
    }
  }

/////////

/* Pruebo con la PRIMERA DIRECCION */
  printf ( "\nFinding gadgets ...\n\n" );

/* Recorro todas las secciones del SNAPSHOT */
  for ( cont2 = 0 ; cont2 < sections.Len () ; cont2 ++ )
  {
  /* Levanto la siguiente seccion */
    section = ( SECTION * ) sections.Get ( cont2 );

  /* Si la seccion NO es EJECUTABLE */
    if ( ! ( section -> protection & EXECUTABLE ) )
    {
    /* Paso a la siguiente seccion */
      continue;
    }

  /* Si hay MODULOS donde BUSCAR */
    if ( module_list.Len () > 0 )
    {
    /* Si esta seccion NO esta en los MODULOS TARGETEADOS */
      if ( is_section_in_targeted_module ( module_list , section ) == FALSE )
      {
      /* Paso a la siguiente seccion */
        continue;
      }
    }
  /* Si la seccion TIENE ASLR */
    else if ( section -> protection & RANDOMIZABLE )
    {
    /* Paso a la siguiente seccion */
      continue;
    }

  /* Base de la seccion */
    initial_address = ( unsigned int ) section -> address;

  /* Size de la seccion */
    testing_range_size = section -> size;

  /* Indicador de avanze */
    completed = -1;   

  /* Mensaje al usuario */
    printf ( "[x] Processing: %.8x - %.8x\n" , initial_address , initial_address + testing_range_size );

  /* Pruebo todo el shellcode */
    for ( cont = 0 ; cont < testing_range_size ; cont ++ )
    {
    /* Si la direccion este dentro del RANGO DE TESTEO */
      if ( ( base_address <= initial_address + cont ) && ( initial_address + cont < limit_address ) )
      {
      /* Flag para saber si tengo que probar una VARIANTE con EFLAGS PRENDIDOS */
        change_eflags = FALSE;

      /* Cantidad de veces a probar el address por DEFAULT */
        tries = 1;

      /* Inicializo las listas donde voy a guardar el GADGET ENCONTRADO */
        addresses.Clear ();
        backup_addresses.Clear ();

      /* Si tengo que probar con distintos valores para las EFLAGS */
        for ( cont3 = 0 ; cont3 < tries ; cont3 ++ )
        {
        /* Restauro las zonas de memoria */
          restore_memory ( sections , section );

        /* Seteo los valores INICIALES CALCULADOS */
          context -> eax = initial_context.eax;
          context -> ecx = initial_context.ecx;
          context -> edx = initial_context.edx;
          context -> ebx = initial_context.ebx;
          context -> esp = initial_context.esp;
          context -> ebp = initial_context.ebp;
          context -> esi = initial_context.esi;
          context -> edi = initial_context.edi;
          context -> eip = initial_address + cont;

       /* Si tengo que probar con los EFLAGS APAGADOS */
          if ( cont3 == 0 )
          {
          /* Todos los EFLAGS APAGADOS */
            context -> eflags = 0x2;
          }
       /* Si tengo que probar con los EFLAGS PRENDIDOS */
          else
          {
          /* Todos los EFLAGS PRENDIDOS */
            context -> eflags = 0xd7;
          }

        /* Si el OBJETIVO es PIVOTEAR el STACK */  
          if ( objective.register_index == SP_OBJECTIVE )
          {
          /* Si cualquier registro es VALIDO */
            if ( objective.operation == OP_REGS_TO_REG )
            {
            /* Seteo el valor de TODOS los candidatos a la MITAD de cada PARTE */
              context -> eax = SYMBOLIC_STACK_PIVOTING_ADDRESS + 0x08000;
              context -> ecx = SYMBOLIC_STACK_PIVOTING_ADDRESS + 0x18000;
              context -> edx = SYMBOLIC_STACK_PIVOTING_ADDRESS + 0x28000;
              context -> ebx = SYMBOLIC_STACK_PIVOTING_ADDRESS + 0x38000;
              context -> esp = SYMBOLIC_STACK_PIVOTING_ADDRESS + 0x48000;
              context -> ebp = SYMBOLIC_STACK_PIVOTING_ADDRESS + 0x58000;
              context -> esi = SYMBOLIC_STACK_PIVOTING_ADDRESS + 0x68000;
              context -> edi = SYMBOLIC_STACK_PIVOTING_ADDRESS + 0x78000;
            }
          /* Si solo quiero ESP igual al valor de un registro */
            else if ( objective.operation == OP_REG_TO_REG )
            {
            /* Contexto actual */
              current_context = ( unsigned int * ) context;

            /* Apunto el FUTURO STACK al PRINCIPIO de una zona valida */
              current_context [ objective.operand ] = SYMBOLIC_STACK_PIVOTING_ADDRESS + 0x800;
            }
          /* Si quiero que ESP sea igual a [REG+ALGO] */
            else if ( objective.operation == OP_MEM_TO_REG )
            {
            /* Contexto actual */
              current_context = ( unsigned int * ) context;

            /* Apunto el registro SOURCE a un AREA SIMBOLICA */
              current_context [ objective.operand ] = SYMBOLIC_DATA_ADDRESS;
            }
          /* Si quiero que ESP termine apuntando a una REGION (ESP==REG+0xMM,REG+0xNN) */
            else if ( objective.operation == OP_REGS_RANGE_TO_REG )
            {
            /* Contexto actual */
              current_context = ( unsigned int * ) context;

            /* Apunto el registro SOURCE a un AREA SIMBOLICA */
              current_context [ objective.operand ] = SYMBOLIC_STACK_PIVOTING_ADDRESS + ( SYMBOLIC_TOTAL_STACK_PIVOTING_SIZE / 2 );
            }
          }

        /* ESP ( Lo apunto a la mitad del PADDING ) */
          context -> esp = SYMBOLIC_STACK_ADDRESS + 0x800;

        /* Setear el valor de los registros puestos por el USUARIO */
          get_register_values ( asignations , context );

        /* Mensaje al usuario */
//          printf ( "[x] Testing %.8x (%i/%i)\n" , initial_address + cont , cont , testing_range_size );

        /* Calculo el porcentaje de procesamiento */
          processed = ( cont * 100 ) / testing_range_size;

        /* Si avanzo algo */
          if ( completed < processed )
          {
          /* Mensaje al usuario */
//            printf ( "completed: %.2i.%.2i%% ...\r" , ( processed + 1 ) / 100 , ( processed + 1 ) % 100 );
            printf ( "completed: %i%% ...\r" , processed + 1 );

          /* Actualizo el contador */
            completed = processed;
          }

        /* Pruebo la primer direccion */
          ret = test_address ( context , sections , section , objectives , results , ( void * ) ( initial_address + cont ) , addresses );
//        printf ( "ret = %x\n" , ret );

        /* Si hay algun GADGET */
          if ( ret == TRUE )
          {
          /* Si es un gadget SIN EFLAGS o es un gadget DISTINTO con EFLAGS */
            if ( ( cont3 == 0 ) || ( ( cont3 == 1 ) && ( backup_addresses.Len () != addresses.Len () ) ) )
            {
            /* Linea separadora */
              fprintf ( foutput , "----------------------------------------\n" );

            /* Si es un SNAPSHOT VALIDO */
              if ( fake_snapshot == FALSE )
              {
              /* Mensaje al usuario */
                fprintf ( foutput , "[x] Valid gadget at: %.8x\n" , initial_address + cont );
              }
            /* Si es un FILE ESTATICO */
              else
              {
              /* Mensaje al usuario */
                fprintf ( foutput , "[x] Valid gadget at offset: %.8x\n" , cont );
              }

            /* Imprimo el OBJETIVO LOGRADO */
              print_objectives ( foutput , results );

            /* Imprimo las direcciones por donde paso */
              print_gadget ( foutput , addresses , fake_snapshot );

            /* Si es con los EFLAGS APAGADOS */
              if ( cont3 == 0 )
              {
              /* Backupeo el GADGET */
                backup_addresses.Append ( addresses );
              }
            }
          }

        /* Si los EFLAGS modifican el resultado */
          if ( change_eflags == TRUE )
          {
          /* Si el USUARIO NO seteo el valor de los EFLAGS */
            if ( eflags_set_by_user == FALSE )
            {
            /* Vuelvo a testear con los EFLAGS prendidos !!! */
              tries = 2;
            }
          }
        }
      }
    }
  }

  return ( TRUE );
}

////////////////////////////////////////////////////////////////////////////////

```

`src/disassembler.c`:

```c
////////////////////////////////////////////////////////////////////////////////

/* disassembler,c ( DISTORM wrapper ) */

////////////////////////////////////////////////////////////////////////////////

/* Codigo usado por Distorm */

/* Para usar en VC */
#define uint64_t unsigned __int64

/* Static size of strings. Do not change this value. Keep Python wrapper in sync. */
#define MAX_TEXT_SIZE (48)

typedef struct
{
  unsigned int length;
  unsigned char p [MAX_TEXT_SIZE]; /* p is a null terminated string. */
} _WString;

/*
 * Old decoded instruction structure in text format.
 * Used only for backward compatibility with diStorm64.
 * This structure holds all information the disassembler generates per instruction.
 */

typedef struct
{
  _WString mnemonic; /* Mnemonic of decoded instruction, prefixed if required by REP, LOCK etc. */
  _WString operands; /* Operands of the decoded instruction, up to 3 operands, comma-seperated. */
  _WString instructionHex; /* Hex dump - little endian, including prefixes. */
  unsigned int size; /* Size of decoded instruction. */
//  _OffsetType offset; /* Start offset of the decoded instruction. */
  unsigned int offset; /* Start offset of the decoded instruction. */
} _DecodedInst;

/* Decodes modes of the disassembler, 16 bits or 32 bits or 64 bits for AMD64, x86-64. */
typedef enum { Decode16Bits = 0, Decode32Bits = 1, Decode64Bits = 2 } _DecodeType;

/* Return code of the decoding function. */
typedef enum { DECRES_NONE, DECRES_SUCCESS, DECRES_MEMORYERR, DECRES_INPUTERR, DECRES_FILTERED } _DecodeResult;

/* Nombre de la DLL */
char *disasm_lib = "distorm3.dll";

////////////////////////////////////////////////////////////////////////////////

char *disassembly ( void *address , unsigned char *bytecodes , unsigned int *instruction_size )
{
  static int ( *distorm_decode32 ) ( void * , unsigned char * , unsigned int , unsigned int , void * , unsigned int , unsigned int * ) = NULL;
  static int ( *distorm_decode64 ) ( uint64_t , unsigned char * , unsigned int , unsigned int , void * , unsigned int , unsigned int * ) = NULL;
  static char instruction [ 256 ];
  static HMODULE lib;
  char *p;
  _DecodedInst decodedInstructions [ 256 ];
  unsigned int counter;
  int ret;

/* Si es la primera vez */
  if ( ( distorm_decode32 == NULL ) && ( distorm_decode64 == NULL ) )
  {
  /* Resuelvo la direccion de la lib */
    lib = LoadLibrary ( disasm_lib );
//    printf ( "lib = %x\n" , lib );

  /* Resuelvo la direccion de la funcion */
    distorm_decode32 = ( int ( * ) ( void * , unsigned char * , unsigned int , unsigned int , void * , unsigned int , unsigned int * ) ) GetProcAddress ( lib , "distorm_decode32" );
    distorm_decode64 = ( int ( * ) ( uint64_t , unsigned char * , unsigned int , unsigned int , void * , unsigned int , unsigned int * ) ) GetProcAddress ( lib , "distorm_decode64" );
//    printf ( "%x\n" , distorm_decode32 );
  }

//  asm int 3

/* Si tengo la DLL que exporta la funcion de 32 bits */
  if ( distorm_decode32 != NULL )
  {
  /* Desensamblo la instruccion */
    ret = distorm_decode32 ( address , bytecodes ,  16 , Decode32Bits , &decodedInstructions , 16 , &counter );
  }
/* Si tengo la DLL que exporta la funcion de 64 bits */
  else
  {
  /* Desensamblo la instruccion */
    ret = distorm_decode64 ( ( uint64_t ) address , bytecodes ,  16 , Decode32Bits , &decodedInstructions , 16 , &counter );
  }

//  printf ( "ret = %i\n" , ret );
//  printf ( "counter = %i\n" , counter );
//  printf ( "size = %i\n" , decodedInstructions[0].size );
//  printf ( "%s %s\n" , decodedInstructions[0].mnemonic.p , decodedInstructions[0].operands.p );

/* Si pude traducir la instruccion */
  if ( decodedInstructions[0].size > 0 )
  {
  /* Si la instruccion NO tiene operandos */
    if ( decodedInstructions[0].operands.p [0] == '\x00' )
    {
    /* Armo la instruccion a retornar */
      strcpy ( ( char * ) instruction , ( char * ) decodedInstructions[0].mnemonic.p );
    }
  /* Si la instruccion tiene operandos */
    else
    {
    /* Armo la instruccion a retornar */
      sprintf ( instruction , "%s %s" , decodedInstructions[0].mnemonic.p , decodedInstructions[0].operands.p );

    /* Busco si la instruccion tiene un ", " */
      p = strstr ( instruction , ", " );

    /* Si encontre ese ESPACIO DEMAS */
      if ( p != NULL )
      {
      /* Suprimo el espacio */
        strcpy ( p + 1 , p + 2 );
      }
    }

  /* Apunto a la instruccion */
    p = instruction;

  /* Convierto el string a MINUSCULAS */
    while ( *p != 0 )
    {
    /* Convierto el caracter a minuscula */
      *p = tolower ( *p );

    /* Avanzo en el string */
      p ++;
    }
  }
  else
  {
  /* No pude traducir la instruccion */
    strcpy ( instruction , "???" );
  }

/* Bytes usados por la instruccion */
  *instruction_size = decodedInstructions[0].size;

  return ( instruction );
}

////////////////////////////////////////////////////////////////////////////////

```

`src/fsnap.c`:

```c
////////////////////////////////////////////////////////////////////////////////

/* fsnap.c ( Snapshoter ) */

// Compilation line
// cl.exe fsnap.c /link -SUBSYSTEM:CONSOLE -DYNAMICBASE:NO -BASE:0x08000000 -FIXED

////////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>

////////////////////////////////////////////////////////////////////////////////

#pragma pack(1)

#ifdef _MSC_VER
  #define snprintf _snprintf
#endif

////////////////////////////////////////////////////////////////////////////////

#define uint64_t unsigned __int64

#define READABLE   1
#define WRITABLE   2
#define EXECUTABLE 4

#define FALSE 0
#define TRUE  1

#define DONT_RESOLVE_DLL_REFERENCE 0x01
#define FILE_MAP_EXECUTE 0x20

////////////////////////////////////////////////////////////////////////////////

typedef struct
{
  unsigned int sig;           // signature: "snap" or 0x70616E73 in little endian
  unsigned int version;	      // if version == 1: use DUMPBLOCKV10 / version == 2 uses DUMPBLOCKV20 and so on.
  unsigned int flags;         //
  unsigned int blockcount;
} SNAPSHOT_HEADER;

typedef struct
{
  uint64_t BaseAddress;
  uint64_t RegionSize;
  unsigned int Protect;       // see memory protection constants
} DUMPBLOCKV10;

typedef struct
{
  uint64_t BaseAddress;
  uint64_t RegionSize;
  unsigned int Protect;  // see memory protection constants
  char name [256];
} DUMPBLOCKV20;

////////////////////////////////////////////////////////////////////////////////

unsigned int get_file_len ( FILE *f )
{
  unsigned int filelen;

/* Me posiciono al final del file */
  fseek ( f , 0 , SEEK_END );

/* Obtengo la longitud del file */
  filelen = ftell ( f );

/* Me vuelvo a posicionar al principio del file */
  fseek ( f , 0 , SEEK_SET );

  return ( filelen );
}

////////////////////////////////////////////////////////////////////////////////

int is_filename_ok ( char *filename )
{
  FILE *f;
  int ret = FALSE;

/* Abro el file */
  f = fopen ( filename , "rb" );

/* Si el file pudo ser ABIERTO */
  if ( f != NULL )
  {
  /* Cierro el file */
    fclose ( f );

  /* Retorno OK */
    ret = TRUE;
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void get_module_name ( char *fullname , char *name )
{
  char *s;

/* Busco la ULTIMA BARRA */
  s = strrchr ( fullname , '\\' );

/* Si pudo encontrarla */
  if ( s != NULL )
  {
  /* Avanzo al SIGUIENTE CARACTER */
    s ++;
  }
/* Si NO pudo encontrarla */
  else
  {
  /* Uso el FULLNAME directamente */
    s = fullname;
  }

/* Retorno el NOMBRE del MODULO */
  strncpy ( name , s , 255 );
}

////////////////////////////////////////////////////////////////////////////////

int is_windows_module ( char *filename )
{
  char data [ 2 ];
  int ret = FALSE;
  FILE *f;

/* Abro el file */
  f = fopen ( filename , "rb" );

/* Si el file pudo ser ABIERTO */
  if ( f != NULL )
  {
  /* Leo los primeros 2 bytes */
    fread ( data , 1 , 2 , f );

  /* Si es un "MZ" */
    if ( memcmp ( data , "MZ" , 2 ) == 0 )
    {
    /* Retorno OK */
      ret = TRUE;
    }

  /* Cierro el file */
    fclose ( f );
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void *get_module_base ( char *filename )
{
  IMAGE_NT_HEADERS pe;
  unsigned int pe_offset;
  void *base = NULL;
  FILE *f;

/* Si el modulo VALID */
  if ( is_windows_module ( filename ) == TRUE )
  {
  /* Abro el file */
    f = fopen ( filename , "rb" );

  /* Me posiciono al PRINCIPIO del PE */
    fseek ( f , 0x3c , SEEK_SET );

  /* Obtengo el puntero al PE */
    fread ( &pe_offset , 1 , sizeof ( pe_offset ) , f );

  /* Me posiciono al PRINCIPIO del HEADER del PE */
    fseek ( f , pe_offset , SEEK_SET );

  /* Obtengo el HEADER del PE */
    fread ( &pe , 1 , sizeof ( IMAGE_NT_HEADERS ) , f );

  /* Obtengo la BASE del modulo */
    base = ( void * ) pe.OptionalHeader.ImageBase;
//      printf ( "BASE en %x\n" , base );

  /* Cierro el file */
    fclose ( f );
  }

  return ( base );
}

////////////////////////////////////////////////////////////////////////////////

int is_loadable_module ( char *filename , int force_base , void **base_address )
{
  HANDLE fmapping;
  HANDLE module;
  void *real_module_base;
  void *my_base_address;
  int ret = FALSE;

/* Abro el file */
  module = CreateFile ( filename , GENERIC_READ | GENERIC_EXECUTE , FILE_SHARE_READ , NULL , OPEN_EXISTING , NULL , NULL );
//  printf ( "module = %x\n" , module );

/* Si el file pudo ser ABIERTO */
  if ( module != NULL )
  {
  /* Intento cargar el modulo */
    fmapping = CreateFileMapping ( module , NULL , PAGE_EXECUTE_READ | SEC_IMAGE , NULL , NULL , "mapped" );
//    printf ( "fmapping = %x\n" , fmapping );

  /* Si el modulo pudo ser cargado */
    if ( fmapping != NULL )
    {
    /* Si Tengo que CARGARLO en la BASE */
      if ( force_base == TRUE )
      {
      /* Obtengo la BASE del MODULO */
        real_module_base = get_module_base ( filename );
      }
    /* Si NO IMPORTA donde lo carga */
      else
      {
      /* Dejo que el OS lo cargue donde puede */
        real_module_base = NULL;
      }

    /* Intento cargar el modulo */
      my_base_address = MapViewOfFileEx ( fmapping , FILE_MAP_EXECUTE , 0 , 0 , 0 , real_module_base );
//      printf ( "ERROR: %i\n" , GetLastError () );
//      printf ( "my_base_address = %x\n" , my_base_address );

    /* Si el modulo pudo ser cargado */
      if ( my_base_address != NULL )
      {
      /* Retorno la BASE del MODULO */
        *base_address = my_base_address;

      /* Retorno OK */
        ret = TRUE;
      }
    }
  /* Si el FILE NO PUDO ser MAPEADO */
    else
    {
    /* Si NO IMPORTA donde SE CARGA */
      if ( force_base == FALSE )
      {
      /* Si es un modulo VALIDO */
        if ( is_windows_module ( filename ) == TRUE )
        {
        /* Cargo el modulo DONDE PUEDO ( solo valido para OSs arcaicos ) */
          module = LoadLibraryEx ( filename , NULL , DONT_RESOLVE_DLL_REFERENCE );

        /* Si el MODULO pudo ser CARGADO */
          if ( module != NULL )
          {
          /* Retorno la BASE del MODULO */
            *base_address = ( void * ) module;

          /* Retorno OK */
            ret = TRUE;
          }
        }
      }
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

unsigned int get_module_size ( void *base_address )
{
  unsigned int module_size = 0;

/* Recorro la memoria del modulo saltando de a 4kb */
  while ( IsBadReadPtr ( ( void * ) ( ( unsigned int ) base_address + module_size ) , 1 ) == FALSE )
  {
  /* Avanzo a la proxima pagina */
    module_size += 0x1000;
  }

  return ( module_size );
}

////////////////////////////////////////////////////////////////////////////////

unsigned int get_sections_number ( unsigned int module_base , unsigned int module_limit )
{
  MEMORY_BASIC_INFORMATION informacion;
  unsigned int sections = 0;
  unsigned int pos = 0;

/* Mientras este dentro del modulo */
  while ( module_base + pos < module_limit )
  {
  /* Levanto la siguiente seccion */
    VirtualQueryEx ( GetCurrentProcess () , ( void * ) ( module_base + pos ) , &informacion , sizeof ( MEMORY_BASIC_INFORMATION ) );

  /* Avanzo a la siguiente seccion de memoria */
    module_base = module_base + informacion.RegionSize; 

  /* Incremento la cantidad de secciones */
    sections ++;
  }

  return ( sections );
}

////////////////////////////////////////////////////////////////////////////////

void dump_sections ( FILE *f , char *module_name , unsigned int module_base , unsigned int module_limit )
{
  MEMORY_BASIC_INFORMATION informacion;
  DUMPBLOCKV20 block;
  unsigned int pos = 0;
  int protection;

/* Mientras este dentro del modulo */
  while ( module_base + pos < module_limit )
  {
  /* Levanto la siguiente seccion */
    VirtualQueryEx ( GetCurrentProcess () , ( void * ) ( module_base + pos ) , &informacion , sizeof ( MEMORY_BASIC_INFORMATION ) );

  /* Por default pongo que la seccion es LEIBLE y ESCRIBIBLE */
    protection = READABLE | WRITABLE;

  /* Si la seccion es EJECUTABLE */
    if ( ( informacion.Protect == PAGE_EXECUTE ) || ( informacion.Protect == PAGE_EXECUTE_READ ) || ( informacion.Protect == PAGE_EXECUTE_READWRITE )  || ( informacion.Protect == PAGE_EXECUTE_WRITECOPY ) )
    {
    /* Agrego el permiso de EJECUCION */
      protection = protection | EXECUTABLE;

//      printf ( "ejecucion en %x - %x\n" , module_base + pos , module_base + pos + informacion.RegionSize );
    }

  /* Seteo OTRA SECCION del SNAPSHOT */
    block.BaseAddress = module_base + pos;
    block.RegionSize = informacion.RegionSize;
    block.Protect = protection;
    strncpy ( block.name , module_name , sizeof ( block.name ) - 1 );
    fwrite ( &block , sizeof ( block ) , 1 , f );

  /* Dumpeo la data */
    fwrite ( ( void * ) block.BaseAddress , block.RegionSize , 1 , f );

  /* Avanzo a la siguiente seccion de memoria */
    pos += informacion.RegionSize; 
  }
}

////////////////////////////////////////////////////////////////////////////////

void create_snapshot ( char *file_to_dump , void *module_base , char *snapshot )
{
  SNAPSHOT_HEADER header;
  unsigned int sections;
  unsigned int filelen;
  char module_name [ 256 ];
  FILE *f;

/* Creo el OUTPUT FILE */
  f = fopen ( snapshot , "wb" );

/* Si el file NO pudo ser creado */
  if ( f == NULL )
  {
    printf ( "Error: Invalid output_file\n" );
    exit ( 0 );
  }

/* Obtengo el SIZE del MODULO en MEMORIA */
  filelen = get_module_size ( ( void * ) module_base );
//  printf ( "filelen = %x\n" , filelen );

/* Obtengo el numero de secciones del file */
  sections = get_sections_number ( ( unsigned int ) module_base , ( unsigned int ) module_base + filelen );
  printf ( "sections_number = %i\n" , sections );

/* Seteo el header del file */
  header.sig = 0x70616E73;
  header.version = 2;
  header.flags = 0x00000000;
  header.blockcount = sections;
  fwrite ( &header , sizeof ( header ) , 1 , f ); 

/* Obtengo el nombre LIMPIO del modulo */
  get_module_name ( file_to_dump , module_name );
//  printf ( "name: %s con size = %i\n" , module_name , strlen ( module_name ) );

/* Dumpeo TODAS las secciones en el file */
  dump_sections ( f , module_name , ( unsigned int ) module_base , ( unsigned int ) module_base + filelen );

/* Mensaje al usuario */
  printf ( "[x] Setting image base at: %.8x\n" , module_base );

/* Cierro el file */
  fclose ( f );
}

////////////////////////////////////////////////////////////////////////////////

int get_valid_loading ( char *module , char *snapshot )
{
  char cmdline [ 1024 ];
  unsigned int cont;
  int ret = FALSE;
  int res;

/* Armo la linea a EJECUTAR */
  snprintf ( cmdline , sizeof ( cmdline ) , "fsnap %s %s -force_base" , module , snapshot );

/* Hago 10 intentos */
  for ( cont = 0 ; cont < 10 ; cont ++ )
  {
  /* Cargo el MODULO en OTRO PROCESO */
    res = system ( cmdline );

  /* Si el SNAPSHOT pudo ser TOMADO de la BASE REAL del MODULO */
    if ( res == 1 )
    {
    /* Retorno OK */
      ret = TRUE;

    /* Dejo de PROBAR */
      break;
    }
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int main ( int argc , char *argv [] )
{
  SNAPSHOT_HEADER header;
  DUMPBLOCKV10 block;
  unsigned int filelen = 0;
  unsigned int sections;
  void *module_base = 0x10000000;
  void *data;
  FILE *f1;
  FILE *f2;

/* Chequeo los paramentros */
  if ( ( argc != 3 ) && ( argc != 4 ) )
  {
    printf ( "\nfsnap v1.1\n" );
    printf ( "Created by Nicolas A. Economou\n" );
    printf ( "Core Security Technologies, Buenos Aires, Argentina (2015)\n" );
    printf ( "\nUse: fsnap input_file output_file [-force_base]\n" );
    return ( 0 );
  }

/* Si quiero que CARGUE el MODULO en la BASE ORIGINAL */
  if ( argc == 4 )
  {
  /* Si NO es el comando CORRECTO */
    if ( strcmp ( argv [ 3 ] , "-force_base" ) != 0 )
    {
      printf ( "\nUse: fsnap input_file output_file [-force_base]\n" );
      return ( 0 );
    }
  }

/* Si el FILE existe */
  if ( is_filename_ok ( argv [ 1 ] ) == TRUE )
  {
  /* Si es la PRIMERA CORRIDA */
    if ( argc == 3 )
    {
    /* Si pude cargar el MODULO en MEMORIA */
      if ( is_loadable_module ( argv [ 1 ] , FALSE , &module_base ) == TRUE )
      {
      /* Si la BASE es DISTINTA de donde ESTA CARGADO */
        if ( get_module_base ( argv [ 1 ] ) != ( void * ) module_base )
        {
        /* Si PUDE CARGAR el MODULO en la BASE */
          if ( get_valid_loading ( argv [ 1 ] , argv [ 2 ] ) == TRUE )
          {
          /* Salgo OK */
            return ( 1 );
          }
        }

      /* Creo un SNAPSHOT del MODULO */
        create_snapshot ( argv [ 1 ] , module_base , argv [ 2 ] );
      }
    /* Si el file NO ES LOADABLE ( puede ser un file de otro OS, un shellcode, etc ) */
      else
      {
      /* Creo el OUTPUT FILE */
        f2 = fopen ( argv [ 2 ] , "wb" );

      /* Si el file NO pudo ser creado */
        if ( f2 == NULL )
        {
          printf ( "Error: Invalid output_file\n" );
          return ( 0 );
        }

      /* Abro el file */
        f1 = fopen ( argv [ 1 ] , "rb" );

      /* Obtengo el size del file */
        filelen = get_file_len ( f1 );

      /* Seteo el header del file */
        header.sig = 0x70616E73;
        header.version = 1;
        header.flags = 0x80000000; // Fake memory dump
        header.blockcount = 1;
        fwrite ( &header , sizeof ( header ) , 1 , f2 );

      /* Seteo la UNICA SECCION del SNAPSHOT */
        block.BaseAddress = 0x10000000;
        block.RegionSize = filelen;
        block.Protect = READABLE | WRITABLE | EXECUTABLE;
        fwrite ( &block , sizeof ( block ) , 1 , f2 );

      /* Dumpeo la data */
        data = malloc ( filelen );
        fread ( data , filelen , 1 , f1 );
        fwrite ( data , filelen , 1 , f2 );

      /* Mensaje al usuario */
        printf ( "[x] Setting ARBITRARY image base at: %.8x\n" , block.BaseAddress );

      /* Cierro el file */
        fclose ( f1 );

      /* Cierro el file */
        fclose ( f2 );
      }
    }
  /* Si es una CORRIDA AUXILIAR (para intentar MAPEAR en la BASE) */
    else
    {
    /* Si pude cargar el MODULO en MEMORIA */
      if ( is_loadable_module ( argv [ 1 ] , TRUE , &module_base ) == TRUE )
      {
      /* Creo un SNAPSHOT del MODULO */
        create_snapshot ( argv [ 1 ] , module_base , argv [ 2 ] );

      /* Retorno OK */
        return ( 1 );
      }
    /* Si NO se PUDO MAPEAR en la BASE */
      else
      {
      /* Salgo con ERROR */
        return ( 0 );
      }
    }
  }
/* Si hubo algun ERROR */
  else
  {
    printf ( "Error: Invalid input_file\n" );
    return ( 0 );
  }

  return ( 1 );
}

////////////////////////////////////////////////////////////////////////////////

```

`src/gisnap/dumpinfo/dumpinfo.py`:

```py
import os
import sys
import struct

M_READ		= 0x01
M_WRITE		= 0x02
M_EXEC		= 0x04

M_ASLR		= 0x08
M_DEP		= 0x10


#OS flags
OS_WINDOWS	= 0x0100
OS_LINUX	= 0x0200
OS_MACOS	= 0x0400
OS_ANDROID	= 0x0800
OS_IOS		= 0x1000

# Arch. flags
ARCH_X86	= 0x10000
ARCH_X64	= 0x20000
ARCH_ARM	= 0x40000
ARCH_PPC	= 0x80000

class Reader:
	def ReadH(self):
		val = struct.unpack("<H", self.data[self.fp:self.fp+2])[0]
		self.fp += 2
		return val

	def ReadL(self):
		value = struct.unpack("<L", self.data[self.fp:self.fp+4])[0]
		self.fp += 4
		return value

	def ReadB(self, length=1):
		fmt = "B" * length
		value = struct.unpack(fmt, self.data[self.fp:self.fp+length])
		data = ''
		for val in value:
			data += chr(val)
		self.fp += length
		return data

	def ReadQ(self):
		value = struct.unpack("<Q", self.data[self.fp:self.fp+8])[0]
		self.fp += 8
		return value

	def PeekB(self, length=1):
		data = self.ReadB(length)
		self.fp -= length
		return data

class BlockV10(Reader):
	def __init__(self, data):
		self.data = data
		self.fp = 0
		
		self.BaseAddress = self.ReadQ()
		self.RegionSize = self.ReadQ()
		self.Protect = self.ReadL()

	def getProtString(self):
		mystr = ''
		if(self.Protect & M_READ):
			mystr = "R"
		else:
			mystr = "-"
			
		if(self.Protect & M_WRITE):
			mystr += "W"
		else:
			mystr += "-"
			
		if(self.Protect & M_EXEC):
			mystr += "X"
		else:
			mystr += "-"
	
		if(self.Protect & M_ASLR):
			mystr += " ASLR"
		
		if(self.Protect & M_DEP):
			mystr += " DEP"	
		return mystr
		
	def dump(self):
		print "BaseAddress: %08lx - RegionSize: %08lx - Protect: %s" % (self.BaseAddress, self.RegionSize, self.getProtString())


class BlockV20(Reader):
	def __init__(self, data):
		self.data = data
		self.fp = 0
		
		self.BaseAddress = self.ReadQ()
		self.RegionSize = self.ReadQ()
		self.Protect = self.ReadL()
		self.name = self.ReadB(256)

	def getProtString(self):
		mystr = ''
		if(self.Protect & M_READ):
			mystr = "R"
		else:
			mystr = "-"
			
		if(self.Protect & M_WRITE):
			mystr += "W"
		else:
			mystr += "-"
			
		if(self.Protect & M_EXEC):
			mystr += "X"
		else:
			mystr += "-"
	
		if(self.Protect & M_ASLR):
			mystr += " ASLR"
		
		if(self.Protect & M_DEP):
			mystr += " DEP"	
		return mystr
		
	def dump(self):
		cleanname = self.name.strip("\x00\x20")
		print "% 10s BaseAddress:%08lx - RegionSize:%08lx - Protect:%s" % (cleanname, self.BaseAddress, self.RegionSize, self.getProtString())
			
class DumpReader(Reader):
	def __init__(self, filename):
		self.fp = 0

		fd = open(filename, 'rb')
		self.data = fd.read()
		fd.close()
		
		# read file hreader
		self.sig = self.ReadB(4)
		self.ver = self.ReadL()
		self.flags = self.ReadL()
		self.numblocks = self.ReadL()
	
		self.blocks = []
		
		# read blocks
		for i in range(0, self.numblocks):
			if(self.ver == 1):
				blockdata = self.ReadB(0x14)
				blk = BlockV10(blockdata)
				
			elif(self.ver == 2):
				blockdata = self.ReadB(0x114)
				blk = BlockV20(blockdata)

			self.blocks.append(blk)
			self.fp += blk.RegionSize
		
	def getFlagsString(self):
		str = ''
		# get OS name
		if(self.flags & OS_WINDOWS):
			str = 'OS_WINDOWS'
		elif(self.flags & OS_LINUX):
			str = 'OS_LINUX'
		elif(self.flags & OS_MACOS):
			str = 'OS_MACOS'
		elif(self.flags & OS_ANDROID):
			str = 'OS_ANDROID'
		elif(self.flags & OS_IOS):
			str = 'OS_IOS'
		# get Arch
		if(self.flags & ARCH_X86):
			str += '|ARCH_X86'
		elif(self.flags & ARCH_X64):
			str += '|ARCH_X64'
		elif(self.flags & ARCH_ARM):
			str += '|ARCH_ARM'
		elif(self.flags & ARCH_PPC):
			str += '|ARCH_PPC'
		return str

	def dump(self):
		print "sig: %s" % self.sig
		print "ver: %08lx" % self.ver
		print "flags: %s" % self.getFlagsString()
		print "numblocks: %08lx" % self.numblocks
		
		for blk in self.blocks:
			blk.dump()
			

def main(argv):
	if(len(argv) == 0):
		print "Usage: dumpinfo dumpfile.dmp\n"
	else:
		dr = DumpReader(argv[0])
		dr.dump()

if __name__ == "__main__":
   main(sys.argv[1:])

```

`src/gisnap/dumpinfo/readme.txt`:

```txt
Reads and prints out info about a gisnap memory dump.
```

`src/gisnap/ollydbg_plugin/readme.txt`:

```txt
Only for Ollydbg 2.01+
copy plugin dll to your ollydbg\plugins directory

```

`src/gisnap/ollydbg_plugin/src/MemorySnapshot.cpp`:

```cpp
//#include "stdafx.h"
#include <windows.h>
#include "plugin.h"
#include "memorysnapshot.h"


MemorySnapshot::MemorySnapshot()
{
	hprocess = 0;
}

MemorySnapshot::~MemorySnapshot()
{
	hprocess = 0;
}

uint32_t MemorySnapshot::__getArch()
{
	SYSTEM_INFO sysinfo = {0};
	uint32_t res = 0;

	GetSystemInfo(&sysinfo);

	switch(sysinfo.wProcessorArchitecture) {
		case PROCESSOR_ARCHITECTURE_AMD64:
			res = ARCH_X64;
			break;

		case PROCESSOR_ARCHITECTURE_INTEL:
			res = ARCH_X86;
			break;

		case PROCESSOR_ARCHITECTURE_ARM:
			res = ARCH_ARM;
			break;

	}
	return res;
}


void MemorySnapshot::__getName(MEM_BLOCK *tmpblock, char *name)
{
	t_module *module = Findmodule(tmpblock->BaseAddress);
	if(!module) {
		memset(name, 0, 255);
		return;
	}

	wchar_t fullpath[1024];
	memset(fullpath, 0, sizeof(fullpath));

	LPWSTR filepart;
	if(module) {
		if(lstrlen(module->path)) {
			GetFullPathName(module->path, 1024, fullpath, &filepart);
			wcstombs(name, filepart, 255);
		}
	}
}

// sets memory region flags corresponding to ASLR and/or DEP dllCharacteristics
void MemorySnapshot::__setASLRDEP(MEM_BLOCK *tmpblock)
{
	
	t_module *module = Findmodule(tmpblock->BaseAddress);
	if(!module)
		return;

	DWORD modbase = module->base;

	IMAGE_DOS_HEADER hdr_mz;

	ReadProcessMemory(hprocess, (LPCVOID)(modbase), &hdr_mz, sizeof(IMAGE_DOS_HEADER), NULL);
	if(hdr_mz.e_magic == IMAGE_DOS_SIGNATURE) {
		IMAGE_NT_HEADERS hdr_nt;
		ReadProcessMemory(hprocess, (LPCVOID)(modbase+hdr_mz.e_lfanew), &hdr_nt, sizeof(IMAGE_NT_HEADERS), NULL);
		if(hdr_nt.Signature == IMAGE_NT_SIGNATURE) {
			IMAGE_FILE_HEADER hdr_file;
			memcpy(&hdr_file, &hdr_nt.FileHeader, sizeof(IMAGE_FILE_HEADER));

			IMAGE_OPTIONAL_HEADER hdr_optional;
			memcpy(&hdr_optional, &hdr_nt.OptionalHeader, sizeof(IMAGE_OPTIONAL_HEADER));
			if((hdr_optional.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) || (hdr_optional.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)) {
				if(hdr_optional.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) {
					tmpblock->Protect |= M_ASLR;
				}

				if(hdr_optional.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT) {
					tmpblock->Protect |= M_DEP;
				}
			}
		}
	}
}

uint32_t MemorySnapshot::__translateProtFlags(uint32_t prot)
{
	uint32_t flags=0;
	switch(prot & 0xFF)
	{
		case PAGE_EXECUTE:
			flags = M_EXEC;
			break;
		case PAGE_EXECUTE_READ:
			flags = M_EXEC | M_READ;
			break;
		case PAGE_EXECUTE_READWRITE:
			flags = M_EXEC | M_READ | M_WRITE;
			break;
		case PAGE_EXECUTE_WRITECOPY:
			flags = M_EXEC | M_READ | M_WRITE;
			break;
		case PAGE_READONLY:
			flags = M_READ;
			break;
		case PAGE_READWRITE:
			flags = M_READ | M_WRITE;
			break;
		case PAGE_WRITECOPY:
			flags = M_WRITE;
			break;
	}
	return flags;
}

bool MemorySnapshot::Dump(HANDLE hprocess, char *filename)
{
	// open process
//	hprocess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	MemorySnapshot::hprocess = hprocess;
	BOOL bIs64 = (__getArch() == ARCH_X64) ;

	// fill a vector with valid memory blocks
	MEM_BLOCK tmpblock = {0};
	memset(&tmpblock.name, 0, 256);
	MEMORY_BASIC_INFORMATION info = {0};
	uint64_t addr=0;
	while(VirtualQueryEx((HANDLE)hprocess, (LPVOID)addr, &info, sizeof(info))) {
		if((info.State == MEM_COMMIT) || (info.Type == MEM_MAPPED) || (info.Type == MEM_IMAGE)) {
			if(bIs64) {
				tmpblock.BaseAddress = (uint64_t)info.BaseAddress;
				tmpblock.RegionSize = info.RegionSize;
			} else {
				tmpblock.BaseAddress = (DWORD)info.BaseAddress;	//cast takes care of idiotic sign extension on pointers
				tmpblock.RegionSize = (DWORD)info.RegionSize;
			}
			tmpblock.Protect = __translateProtFlags(info.Protect);
			__getName(&tmpblock, (char *)&tmpblock.name);

			// if region is part of an executable image we set ASLR and DEP flags accordingly
			if(info.Type == MEM_IMAGE) {
				__setASLRDEP(&tmpblock);
			}

			memblocks.push_back(tmpblock);
		}
		addr += info.RegionSize;
	} 

	// write
	// create dumpfile
	FILE *dumpfile = fopen(filename, "wb" );
	if(!dumpfile) {
		return false;
	}

	SNAPSHOTFILE snphdr = {0};
	snphdr.sig = 0x70616E73;
	snphdr.version = 0x00000002;
	snphdr.flags = __getArch() | OS_WINDOWS;

	snphdr.blockcount = (uint32_t)memblocks.size();

	// write header SNAPSHOTFILE
	fwrite ( &snphdr, sizeof(SNAPSHOTFILE) , 1 , dumpfile);

	unsigned int blkcnt=0;

//	SetProgressBar(0);

	for (std::vector<MEM_BLOCK>::iterator block = memblocks.begin(); block != memblocks.end(); ++block, ++blkcnt)
	{

		MEM_BLOCK tmpblock = {0};

		tmpblock.RegionSize = block->RegionSize;
		tmpblock.BaseAddress = block->BaseAddress;
		tmpblock.Protect = block->Protect;
		strncpy((char *)&tmpblock.name, (char *)&block->name, 255);

		// write MEM_BLOCK
		fwrite ( &tmpblock, sizeof(MEM_BLOCK) , 1 , dumpfile);
		// write data
		uint8_t *buffer = new uint8_t [(unsigned int)block->RegionSize];
		Readmemory(buffer, block->BaseAddress, block->RegionSize, MM_SILENT);
//		ReadProcessMemory(hprocess, (LPCVOID)block->BaseAddress, buffer, (ULONG)block->RegionSize, NULL);
		fwrite ( buffer , (size_t)block->RegionSize, 1 , dumpfile);
		delete buffer;
//		SetProgressBar(blkcnt*100/snphdr.blockcount);
	}
	fclose(dumpfile);
	CloseHandle(hprocess);
//	SetProgressBar(100);

	return true;
}
```

`src/gisnap/ollydbg_plugin/src/MemorySnapshot.h`:

```h
#ifndef MEMSNAP_H
#define MEMSNAP_H


#include "snapshotformat.h"
#include <iostream>
#include <vector>


#define MEM_BLOCK DUMPBLOCKV20

class MemorySnapshot
{
	public:	
		MemorySnapshot();
		~MemorySnapshot();
		bool MemorySnapshot::Dump(HANDLE hprocess, char *filename);
		void MemorySnapshot::__setASLRDEP(MEM_BLOCK *tmpblock);
	
	private:
		uint32_t MemorySnapshot::__getArch();
		uint32_t MemorySnapshot::__translateProtFlags(uint32_t prot);
		void MemorySnapshot::__getName(MEM_BLOCK *tmpblock, char *name);

		HANDLE hprocess;
		std::vector<MEM_BLOCK> memblocks;
	
};
#endif
```

`src/gisnap/ollydbg_plugin/src/gisnap.cpp`:

```cpp
#define _CRT_SECURE_NO_DEPRECATE

#include <windows.h>
#include "MemorySnapshot.h"
#include <stdio.h>
#include <string.h>
//#include <winnt.h>                     // Only if you call ODBG2_Pluginmainloop
                                       
#include "plugin.h"

#define PLUGINNAME     L"gisnap"    // Unique plugin name
#define VERSION        L"2.00.01"      // Plugin version

HINSTANCE        hdllinst;             // Instance of plugin DLL


void DumpProcess(HANDLE hprocess)
{
	MemorySnapshot *gMemSnap = new MemorySnapshot;

	WCHAR filename[1024];
	char filenameA[1024];
	OPENFILENAME ofln;
	memset(&filename, 0, sizeof(filename));
	memset(&ofln, 0, sizeof(OPENFILENAME));
	ofln.lStructSize = sizeof(OPENFILENAME);
	ofln.hwndOwner = hwollymain;
	ofln.lpstrFile = filename;
	ofln.nMaxFile = sizeof(filename);
	ofln.lpstrFilter = L"Snapshot\0*.snap\0All\0*.*\0";
	ofln.nFilterIndex = 1;
	ofln.lpstrFileTitle = NULL;
	ofln.nMaxFileTitle = 0;
	ofln.lpstrInitialDir = NULL;
	ofln.lpstrDefExt = L".snap";
	ofln.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;

	GetSaveFileName(&ofln);
	CommDlgExtendedError();
	wcstombs(filenameA, filename, 1024);
	gMemSnap->Dump(hprocess, filenameA);
	delete gMemSnap;

	MessageBox(hwollymain, L"Snapshot dump finished.", L"Done!", MB_OK);
}

// main menu click
static int MtakeSnapshot(t_table *pt,wchar_t *name,ulong index,int mode) {
	int ret;

	switch(mode) {
		case MENU_VERIFY:
			ret=MENU_NORMAL;
			break;
		case MENU_EXECUTE:
			ret=MENU_NOREDRAW;
			if(run.status == STAT_IDLE) {
				MessageBox(hwollymain, L"NO TARGET ATTACHED", L"ERROR", MB_OK);
			} else {
				DumpProcess(process);
			}
			break;
		default:
			ret=MENU_ABSENT;
			break;
	}
	return ret;
};

// Plugin menu that will appear in the main OllyDbg menu.
static t_menu mainmenu[] = {
  { L"|gisnap", L"take memory snapshot", K_NONE, MtakeSnapshot, NULL, 0 },
  { NULL, NULL, K_NONE, NULL, NULL, 0 }
};

// Adds items either to main OllyDbg menu (type=PWM_MAIN) or to popup menu in
extc t_menu * __cdecl ODBG2_Pluginmenu(wchar_t *type) {
  if (wcscmp(type,PWM_MAIN)==0)
    // Main menu.
    return mainmenu;
  return NULL;                         // No menu
};

BOOL WINAPI DllEntryPoint(HINSTANCE hi,DWORD reason,LPVOID reserved) {
  if (reason==DLL_PROCESS_ATTACH)
    hdllinst=hi;                       // Mark plugin instance
  return 1;                            // Report success
};

// ODBG2_Pluginquery() is a "must" for valid OllyDbg plugin.
extc int __cdecl ODBG2_Pluginquery(int ollydbgversion,ulong *features, wchar_t pluginname[SHORTNAME],wchar_t pluginversion[SHORTNAME]) {
  if (ollydbgversion<201)
    return 0;
  // Report name and version to OllyDbg.
  wcscpy(pluginname,PLUGINNAME);       // Name of plugin
  wcscpy(pluginversion,VERSION);       // Version of plugin
  return PLUGIN_VERSION;               // Expected API version
};

extc int __cdecl ODBG2_Plugininit(void) {
  return 0;
};

// Function is called when user opens new or restarts current application.
// Plugin should reset internal variables and data structures to the initial
// state.
extc void __cdecl ODBG2_Pluginreset(void) {

};

extc int __cdecl ODBG2_Pluginclose(void) {
  return 0;
};

extc void __cdecl ODBG2_Plugindestroy(void) {

};



```

`src/gisnap/ollydbg_plugin/src/gisnap.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "gisnap", "gisnap.vcxproj", "{FE3AC8DD-4BFC-4445-8D1D-C37502DE48C7}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{FE3AC8DD-4BFC-4445-8D1D-C37502DE48C7}.Debug|Win32.ActiveCfg = Debug|Win32
		{FE3AC8DD-4BFC-4445-8D1D-C37502DE48C7}.Debug|Win32.Build.0 = Debug|Win32
		{FE3AC8DD-4BFC-4445-8D1D-C37502DE48C7}.Release|Win32.ActiveCfg = Release|Win32
		{FE3AC8DD-4BFC-4445-8D1D-C37502DE48C7}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`src/gisnap/ollydbg_plugin/src/gisnap.vcproj`:

```vcproj
<?xml version="1.0" encoding="UTF-8"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="8.00"
	Name="gisnap"
	ProjectGUID="{FE3AC8DD-4BFC-4445-8D1D-C37502DE48C7}"
	Keyword="Win32Proj"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="Debug"
			IntermediateDirectory="Debug"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;GISNAP_EXPORTS;"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="0"
				StructMemberAlignment="1"
				DefaultCharIsUnsigned="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="4"
				CompileAs="1"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalOptions="user32.lib&#x0D;&#x0A;"
				LinkIncremental="1"
				AdditionalLibraryDirectories="&quot;C:\Programs\Microsoft SDK\Lib&quot;"
				GenerateDebugInformation="true"
				SubSystem="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="Release"
			IntermediateDirectory="Release"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;GISNAP_EXPORTS;"
				RuntimeLibrary="0"
				StructMemberAlignment="1"
				DefaultCharIsUnsigned="true"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				AdditionalOptions="user32.lib&#x0D;&#x0A;"
				LinkIncremental="1"
				GenerateDebugInformation="true"
				SubSystem="2"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath=".\plugin.h"
				>
			</File>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath=".\gisnap.cpp"
				>
			</File>
		</Filter>
		<File
			RelativePath=".\ollydbg.lib"
			>
		</File>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`src/gisnap/ollydbg_plugin/src/gisnap.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{FE3AC8DD-4BFC-4445-8D1D-C37502DE48C7}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110_xp</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <PlatformToolset>v110</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>11.0.61030.0</_ProjectFileVersion>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>Debug\</OutDir>
    <IntDir>Debug\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>Release\</OutDir>
    <IntDir>Release\</IntDir>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_WINDOWS;_USRDLL;GISNAP_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <MinimalRebuild>true</MinimalRebuild>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>1Byte</StructMemberAlignment>
      <AdditionalOptions> /J</AdditionalOptions>
      <PrecompiledHeader />
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>
      <CompileAs>CompileAsCpp</CompileAs>
    </ClCompile>
    <Link>
      <AdditionalOptions>user32.lib
 %(AdditionalOptions)</AdditionalOptions>
      <AdditionalLibraryDirectories>C:\Programs\Microsoft SDK\Lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <TargetMachine>MachineX86</TargetMachine>
      <AdditionalDependencies>dbghelp.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_WINDOWS;_USRDLL;GISNAP_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <StructMemberAlignment>1Byte</StructMemberAlignment>
      <AdditionalOptions> /J</AdditionalOptions>
      <PrecompiledHeader />
      <WarningLevel>Level3</WarningLevel>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
    </ClCompile>
    <Link>
      <AdditionalOptions>user32.lib
 %(AdditionalOptions)</AdditionalOptions>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <SubSystem>Windows</SubSystem>
      <OptimizeReferences>true</OptimizeReferences>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <TargetMachine>MachineX86</TargetMachine>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="MemorySnapshot.h" />
    <ClInclude Include="plugin.h" />
    <ClInclude Include="snapshotformat.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="gisnap.cpp">
      <CompileAs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">CompileAsCpp</CompileAs>
      <RuntimeLibrary Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
    <ClCompile Include="MemorySnapshot.cpp">
      <CompileAs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">CompileAsCpp</CompileAs>
      <RuntimeLibrary Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">MultiThreadedDebug</RuntimeLibrary>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Library Include="ollydbg.lib" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/gisnap/ollydbg_plugin/src/plugin.h`:

```h
////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//                        OLLYDBG 2 PLUGIN HEADER FILE                        //
//                                                                            //
//                                Version 2.01                                //
//                                                                            //
//               Written by Oleh Yuschuk (ollydbg@t-online.de)                //
//                                                                            //
//                          Internet: www.ollydbg.de                          //
//                                                                            //
// This code is distributed "as is", without warranty of any kind, expressed  //
// or implied, including, but not limited to warranty of fitness for any      //
// particular purpose. In no event will Oleh Yuschuk be liable to you for any //
// special, incidental, indirect, consequential or any other damages caused   //
// by the use, misuse, or the inability to use of this code, including any    //
// lost profits or lost savings, even if Oleh Yuschuk has been advised of the //
// possibility of such damages.                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#ifndef __ODBG_PLUGIN_H
#define __ODBG_PLUGIN_H

#define PLUGIN_VERSION 0x02010001      // Version 2.01.0001 of plugin interface


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// IMPORTANT INFORMATION /////////////////////////////

// 1. Plugins are UNICODE libraries!
// 2. Export all callback functions by name, NOT by ordinal!
// 3. Force byte alignment of OllyDbg structures!
// 4. Set default char type to unsigned!
// 5. Most API functions are NOT thread-safe!
// 6. Read documentation!

#if !defined(_UNICODE) && !defined(UNICODE)
  #error This version must be compiled with UNICODE on
#endif


////////////////////////////////////////////////////////////////////////////////
////////////// PREFERRED SETTINGS AND FIXES FOR BORLAND COMPILERS //////////////

#ifdef __BORLANDC__
  #pragma option -a1                   // Byte alignment
  #pragma option -K                    // Force unsigned characters!
  // Redefinition of MAKELONG removes nasty warning under Borland Builder 4.0:
  // boolean OR in one row with arithmetical shift.
  #undef  MAKELONG
  #define MAKELONG(lo,hi) ((LONG)(((WORD)(lo))|(((DWORD)((WORD)(hi)))<<16)))
#endif


////////////////////////////////////////////////////////////////////////////////
///////////// PREFERRED SETTINGS AND FIXES FOR MICROSOFT COMPILERS /////////////

// If you like Microsoft compiler, this will force byte alignment and verify
// that character is set to unsigned.
#ifdef _MSC_VER
  #pragma pack(1)                      // Force byte alignment of structures
  #ifndef _CHAR_UNSIGNED               // Verify that character is unsigned
    #error Please set default char type to unsigned (option /J)
  #endif
#endif


////////////////////////////////////////////////////////////////////////////////
//////////////////// PREFERRED SETTINGS AND FIXES FOR MINGW ////////////////////

#ifdef __MINGW32__
  #pragma pack(1)                      // Force byte alignment of structures
  #ifndef __CHAR_UNSIGNED__            // Verify that character is unsigned
    #error Please set default char type to unsigned (option -funsigned-char)
  #endif
#endif


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// GLOBAL DEFINITIONS //////////////////////////////

#ifndef _export
  #define _export      __declspec(dllexport)
#endif

#ifndef _import
  #define _import      __declspec(dllimport)
#endif

#ifndef _USERENTRY
  #define _USERENTRY   __cdecl
#endif

#define MAKEWP(lo,hi)  ((WPARAM)MAKELONG(lo,hi))
#define MAKELP(lo,hi)  ((LPARAM)MAKELONG(lo,hi))

#define LOINT(l)       ((signed short)((WORD)(l)))
#define HIINT(l)       ((signed short)(((DWORD)(l)>>16) & 0xFFFF))

#ifndef MAXPATH
  #define MAXPATH      MAX_PATH
#endif

#ifndef FIELD_OFFSET
  #define FIELD_OFFSET(type,field) ((LONG)&(((type *)0)->field))
#endif

#ifndef arraysize
  #define arraysize(x) (sizeof(x)/sizeof(x[0]))
#endif

#define TEXTLEN        256             // Max length of text string incl. '\0'
#define DATALEN        4096            // Max length of data record (max 65535)
#define ARGLEN         1024            // Max length of argument string
#define MAXMULTIPATH   8192            // Max length of multiple selection
#define SHORTNAME      32              // Max length of short or module name

typedef unsigned char  uchar;          // Unsigned character (byte)
typedef unsigned short ushort;         // Unsigned short
typedef unsigned int   uint;           // Unsigned integer
typedef unsigned long  ulong;          // Unsigned long

// Exports used by plugins are declared as stdapi if they use fixed number of
// arguments, and varapi if variable or if code is written in Assembler
// language (I use C calling conventions). OllyDbg variables are declared as
// oddata.

#ifdef __cplusplus
  #define extc         extern "C" _export
  #define stdapi(type) extern "C"               type __cdecl
  #define varapi(type) extern "C"               type __cdecl
  #define oddata(type) extern "C" const _import type
  #define pentry(type) extern "C" _export       type __cdecl
#else
  #define extc         extern     _export
  #define stdapi(type) extern                   type __cdecl
  #define varapi(type) extern                   type __cdecl
  #define oddata(type) extern     const _import type
  #define pentry(type) extern     _export       type __cdecl
#endif


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// FORWARD REFERENCES //////////////////////////////

struct t_table;                        // Forward reference
struct t_module;                       // Forward reference
struct t_dump;                         // Forward reference


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// SERVICE FUNCTIONS ///////////////////////////////

// Flags returned by functions Istext.../Israre...
#define PLAINASCII     0x01            // Plain ASCII character
#define DIACRITICAL    0x02            // Diacritical character
#define RAREASCII      0x10            // Rare ASCII character

// Flags used by Memalloc() and Virtalloc(). Note that Virtalloc() alwyas
// initializes memory to zero.
#define REPORT         0x0000          // Report memory allocation errors
#define SILENT         0x0001          // Don't report allocation errors
#define ZEROINIT       0x0002          // Initialize memory to 0

#define CONT_BROADCAST 0x0000          // Continue sending msg to MDI windows
#define STOP_BROADCAST 0x1234          // Stop sending message to MDI windows

// Symbol decoding mode, used by Decodethreadname(), Decodeaddress() and
// Decoderelativeoffset().
// Bits that determine when to decode and comment name at all.
#define DM_VALID       0x00000001      // Only decode if memory exists
#define DM_INMOD       0x00000002      // Only decode if in module
#define DM_SAMEMOD     0x00000004      // Only decode if in same module
#define DM_SYMBOL      0x00000008      // Only decode if direct symbolic name
#define DM_NONTRIVIAL  0x00000010      // Only decode if nontrivial form
// Bits that control name format.
#define DM_BINARY      0x00000100      // Don't use symbolic form
#define DM_DIFBIN      0x00000200      // No symbolic form if different module
#define DM_WIDEFORM    0x00000400      // Extended form (8 digits by hex)
#define DM_CAPITAL     0x00000800      // First letter in uppercase if possible
#define DM_OFFSET      0x00001000      // Add 'OFFSET' if data
#define DM_JUMPIMP     0x00002000      // Check if points to JMP to import
#define DM_DYNAMIC     0x00004000      // Check if points to JMP to DLL
#define DM_ORDINAL     0x00008000      // Add ordinal to thread's name
// Bits that control whether address is preceded with module name.
#define DM_NOMODNAME   0x00000000      // Never add module name
#define DM_DIFFMODNAME 0x00010000      // Add name only if different module
#define DM_MODNAME     0x00020000      // Always add module name
// Bits that control comments.
#define DM_STRING      0x00100000      // Check if pointer to ASCII or UNICODE
#define DM_STRPTR      0x00200000      // Check if points to pointer to text
#define DM_FOLLOW      0x00400000      // Check if follows to different symbol
#define DM_ENTRY       0x00800000      // Check if unnamed entry to subroutine
#define DM_EFORCE      0x01000000      // Check if named entry, too
#define DM_DIFFMOD     0x02000000      // Check if points to different module
#define DM_RELOFFS     0x04000000      // Check if points inside subroutine
#define DM_ANALYSED    0x08000000      // Check if points to decoded data

// Standard commenting mode. Note: DM_DIFFMOD and DM_RELOFFS are not included.
#define DM_COMMENT     (DM_STRING|DM_STRPTR|DM_FOLLOW|DM_ENTRY|DM_ANALYSED)

// Address decoding mode, used by Labeladdress().
#define ADDR_SYMMASK   0x00000003      // Mask to extract sym presentation mode
#define   ADDR_HEXSYM  0x00000000      // Hex, followed by symbolic name
#define   ADDR_SYMHEX  0x00000001      // Symbolic name, followed by hex
#define   ADDR_SINGLE  0x00000002      // Symbolic name, or hex if none
#define   ADDR_HEXONLY 0x00000003      // Only hexadecimal address
#define ADDR_MODNAME   0x00000004      // Add module name to symbol
#define ADDR_FORCEMOD  0x00000008      // (ADDR_SINGLE) Always add module name
#define ADDR_GRAYHEX   0x00000010      // Gray hex
#define ADDR_HILSYM    0x00000020      // Highlight symbolic name
#define ADDR_NODEFMEP  0x00000100      // Do not show <ModuleEntryPoint>
#define ADDR_BREAK     0x00000200      // Mark as unconditional breakpoint
#define ADDR_CONDBRK   0x00000400      // Mark as conditional breakpoint
#define ADDR_DISBRK    0x00000800      // Mark as disabled breakpoint
#define ADDR_EIP       0x00001000      // Mark as actual EIP
#define ADDR_CHECKEIP  0x00002000      // Mark as EIP if EIP of CPU thread
#define ADDR_SHOWNULL  0x00004000      // Display address 0

// Mode bits and return value of Browsefilename().
#define BRO_MODEMASK   0xF0000000      // Mask to extract browsing mode
#define   BRO_FILE     0x00000000      // Get file name
#define   BRO_EXE      0x10000000      // Get name of executable
#define   BRO_TEXT     0x20000000      // Get name of text log
#define   BRO_GROUP    0x30000000      // Get one or several obj or lib files
#define   BRO_MULTI    0x40000000      // Get one or several files
#define BRO_SAVE       0x08000000      // Get name in save mode
#define BRO_SINGLE     0x00800000      // Single file selected
#define BRO_MULTIPLE   0x00400000      // Multiple files selected
#define BRO_APPEND     0x00080000      // Append to existing file
#define BRO_ACTUAL     0x00040000      // Add actual contents
#define BRO_TABS       0x00020000      // Separate columns with tabs
#define BRO_GROUPMASK  0x000000FF      // Mask to extract groups
#define   BRO_GROUP1   0x00000001      // Belongs to group 1
#define   BRO_GROUP2   0x00000002      // Belongs to group 2
#define   BRO_GROUP3   0x00000004      // Belongs to group 3
#define   BRO_GROUP4   0x00000008      // Belongs to group 4

// String decoding modes.
#define DS_DIR         0               // Direct quote
#define DS_ASM         1               // Assembler style
#define DS_C           2               // C style

varapi (void)    Error(wchar_t *format,...);
varapi (void)    Conderror(int *cond,wchar_t *title,wchar_t *format,...);
varapi (int)     Condyesno(int *cond,wchar_t *title,wchar_t *format,...);
stdapi (int)     Stringfromini(wchar_t *section,wchar_t *key,wchar_t *s,
                   int length);
stdapi (int)     Filefromini(wchar_t *key,wchar_t *name,wchar_t *defname);
varapi (int)     Getfromini(wchar_t *file,wchar_t *section,wchar_t *key,
                   wchar_t *format,...);
varapi (int)     Writetoini(wchar_t *file,wchar_t *section,wchar_t *key,
                   wchar_t *format,...);
stdapi (int)     Filetoini(wchar_t *key,wchar_t *name);
stdapi (void)    Deleteinisection(wchar_t *file,wchar_t *section);
stdapi (int)     Getfromsettings(wchar_t *key,int defvalue);
stdapi (void)    Addtosettings(wchar_t *key,int value);
stdapi (void)    Replacegraphs(int mode,wchar_t *s,uchar *mask,
                   int select,int n);
stdapi (int)     Unicodetoascii(const wchar_t *w,int nw,char *s,int ns);
stdapi (int)     Asciitounicode(const char *s,int ns,wchar_t *w,int nw);
stdapi (int)     Unicodetoutf(const wchar_t *w,int nw,char *t,int nt);
stdapi (int)     Utftounicode(const char *t,int nt,wchar_t *w,int nw);
stdapi (HGLOBAL) Unicodebuffertoascii(HGLOBAL hunicode);
stdapi (int)     Iszero(void *data,int n);
stdapi (int)     Guidtotext(uchar *guid,wchar_t *s);
varapi (int)     Swprintf(wchar_t *s,wchar_t *format,...);
stdapi (void *)  Memalloc(ulong size,int flags);
stdapi (void)    Memfree(void *data);
stdapi (void *)  Mempurge(void *data,int count,ulong itemsize,int *newcount);
stdapi (void *)  Memdouble(void *data,int *pcount,ulong itemsize,
                   int *failed,int flags);
stdapi (void *)  Virtalloc(ulong size,int flags);
stdapi (void)    Virtfree(void *data);
stdapi (int)     Broadcast(UINT msg,WPARAM wp,LPARAM lp);
stdapi (int)     Browsefilename(wchar_t *title,wchar_t *name,wchar_t *args,
                   wchar_t *currdir,wchar_t *defext,HWND hwnd,int mode);
stdapi (int)     Browsedirectory(HWND hw,wchar_t *comment,wchar_t *dir);
stdapi (void)    Relativizepath(wchar_t *path);
stdapi (void)    Absolutizepath(wchar_t *path);
stdapi (int)     Confirmoverwrite(wchar_t *path);
stdapi (int)     Labeladdress(wchar_t *text,ulong addr,ulong reladdr,int relreg,
                   int index,uchar *mask,int *select,ulong mode);
stdapi (int)     Simpleaddress(wchar_t *text,ulong addr,
                   uchar *mask,int *select);
stdapi (void)    Heapsort(void *data,const int count,const int size,
                   int (_USERENTRY *compare)(const void *,const void *));
stdapi (void)    Heapsortex(void *data,const int count,const int size,
                   int (_USERENTRY *compareex)(const void *,const void *,ulong),
                   ulong lp);
stdapi (uchar *) Readfile(wchar_t *path,ulong fixsize,ulong *psize);
stdapi (int)     Devicenametodosname(wchar_t *devname,wchar_t *dosname);
stdapi (int)     Filenamefromhandle(HANDLE hfile,wchar_t *path);
stdapi (void)    Quicktimerstart(int timer);
stdapi (void)    Quicktimerstop(int timer);
stdapi (void)    Quicktimerflush(int timer);


////////////////////////////////////////////////////////////////////////////////
////////////////// FAST SERVICE ROUTINES WRITTEN IN ASSEMBLER //////////////////

varapi (int)     StrcopyA(char *dest,int n,const char *src);
varapi (int)     StrcopyW(wchar_t *dest,int n,const wchar_t *src);
varapi (int)     StrlenA(const char *src,int n);
varapi (int)     StrlenW(const wchar_t *src,int n);
varapi (int)     HexprintA(char *s,ulong u);
varapi (int)     HexprintW(wchar_t *s,ulong u);
varapi (int)     Hexprint4A(char *s,ulong u);
varapi (int)     Hexprint4W(wchar_t *s,ulong u);
varapi (int)     Hexprint8A(char *s,ulong u);
varapi (int)     Hexprint8W(wchar_t *s,ulong u);
varapi (int)     SignedhexA(char *s,ulong u);
varapi (int)     SignedhexW(wchar_t *s,ulong u);
varapi (void)    Swapmem(void *base,int size,int i1,int i2);
varapi (int)     HexdumpA(char *s,uchar *code,int n);
varapi (int)     HexdumpW(wchar_t *s,uchar *code,int n);
varapi (int)     Bitcount(ulong u);

varapi (char *)  SetcaseA(char *s);
varapi (wchar_t *) SetcaseW(wchar_t *s);
varapi (int)     StrcopycaseA(char *dest,int n,const char *src);
varapi (int)     StrcopycaseW(wchar_t *dest,int n,const wchar_t *src);
varapi (int)     StrnstrA(char *data,int ndata,
                   char *pat,int npat,int ignorecase);
varapi (int)     StrnstrW(wchar_t *data,int ndata,
                   wchar_t *pat,int npat,int ignorecase);
varapi (int)     StrcmpW(const wchar_t *s1,const wchar_t *s2);
varapi (ulong)   Div64by32(ulong low,ulong hi,ulong div);
varapi (ulong)   CRCcalc(uchar *datacopy,ulong datasize);
varapi (int)     Getcpuidfeatures(void);
varapi (void)    Maskfpu(void);
varapi (void)    Clearfpu(void);


////////////////////////////////////////////////////////////////////////////////
////////////////////// DATA COMPRESSION AND DECOMPRESSION //////////////////////

stdapi (ulong)   Compress(uchar *bufin,ulong nbufin,
                   uchar *bufout,ulong nbufout);
stdapi (ulong)   Getoriginaldatasize(uchar *bufin,ulong nbufin);
stdapi (ulong)   Decompress(uchar *bufin,ulong nbufin,
                   uchar *bufout,ulong nbufout);


////////////////////////////////////////////////////////////////////////////////
/////////////////////// TAGGED DATA FILES AND RESOURCES ////////////////////////

#define MI_SIGNATURE   0x00646F4DL     // Signature of tagged file
#define MI_VERSION     0x7265560AL     // File version
#define MI_FILENAME    0x6C69460AL     // Record with full name of executable
#define MI_FILEINFO    0x7263460AL     // Length, date, CRC (t_fileinfo)
#define MI_DATA        0x7461440AL     // Name or data (t_nameinfo)
#define MI_CALLBRA     0x7262430AL     // Call brackets
#define MI_LOOPBRA     0x72624C0AL     // Loop brackets
#define MI_PROCDATA    0x6372500AL     // Procedure data (set of t_procdata)
#define MI_INT3BREAK   0x336E490AL     // INT3 breakpoint (t_bpoint)
#define MI_MEMBREAK    0x6D70420AL     // Memory breakpoint (t_bpmem)
#define MI_HWBREAK     0x6870420AL     // Hardware breakpoint (t_bphard)
#define MI_ANALYSIS    0x616E410AL     // Record with analysis data
#define MI_SWITCH      0x6977530AL     // Switch (addr+dt_switch)
#define MI_CASE        0x7361430AL     // Case (addr+dt_case)
#define MI_MNEMO       0x656E4D0AL     // Decoding of mnemonics (addr+dt_mnemo)
#define MI_JMPDATA     0x74644A0AL     // Jump data
#define MI_NETSTREAM   0x74734E0AL     // .NET streams (t_netstream)
#define MI_METADATA    0x74644D0AL     // .NET MetaData tables (t_metadata)
#define MI_BINSAV      0x7673420AL     // Last entered binary search patterns
#define MI_MODDATA     0x61624D0AL     // Module base, size and path
#define MI_PREDICT     0x6472500AL     // Predicted command execution results
#define MI_LASTSAV     0x61734C0AL     // Last entered strings (t_nameinfo)
#define MI_SAVEAREA    0x7661530AL     // Save area (t_savearea)
#define MI_RTCOND      0x6374520AL     // Run trace pause condition
#define MI_RTPROT      0x7074520AL     // Run trace protocol condition
#define MI_WATCH       0x6374570AL     // Watch in watch window
#define MI_LOADDLL     0x64644C0AL     // Packed loaddll.exe
#define MI_PATCH       0x7461500AL     // Patch data (compressed t_patch)
#define MI_PLUGIN      0x676C500AL     // Plugin prefix descriptor
#define MI_END         0x646E450AL     // End of tagged file

#ifdef FILE                            // Requires <stdio.h>

typedef struct t_fileinfo {            // Length, date, CRC (MI_FILEINFO)
  ulong          size;                 // Length of executable file
  FILETIME       filetime;             // Time of last modification
  ulong          crc;                  // CRC of executable file
  int            issfx;                // Whether self-extractable
  ulong          sfxentry;             // Offset of original entry after SFX
} t_fileinfo;

typedef struct t_tagfile {             // Descriptor of tagged file (reading)
  FILE           *f;                   // File descriptor
  ulong          filesize;             // File size
  ulong          offset;               // Actual offset
  ulong          tag;                  // Tag of next accessed record
  ulong          recsize;              // Size of next accessed record
} t_tagfile;

stdapi (FILE *)  Createtaggedfile(wchar_t *name,char *signature,ulong version);
stdapi (int)     Savetaggedrecord(FILE *f,ulong tag,ulong size,void *data);
stdapi (int)     Savepackedrecord(FILE *f,ulong tag,ulong size,void *data);
stdapi (void)    Finalizetaggedfile(FILE *f);
stdapi (int)     Opentaggedfile(t_tagfile *tf,wchar_t *name,char *signature);
stdapi (int)     Gettaggedrecordsize(t_tagfile *tf,ulong *tag,ulong *size);
stdapi (ulong)   Gettaggedfiledata(t_tagfile *tf,void *buf,ulong bufsize);
stdapi (void)    Closetaggedfile(t_tagfile *tf);

#endif

typedef struct t_nameinfo {            // Header of name/data record (MI_NAME)
  ulong          offs;                 // Offset in module
  uchar          type;                 // Name/data type, one of NM_xxx/DT_xxx
} t_nameinfo;

typedef struct t_uddsave {             // .udd file descriptor used by plugins
  void           *file;                // .udd file
  ulong          uddprefix;            // .udd tag prefix
} t_uddsave;

stdapi (int)     Pluginsaverecord(t_uddsave *psave,ulong tag,
                   ulong size,void *data);
stdapi (int)     Pluginpackedrecord(t_uddsave *psave,ulong tag,
                   ulong size,void *data);
stdapi (void)    Pluginmodulechanged(ulong addr);
stdapi (int)     Plugingetuniquedatatype(void);
stdapi (int)     Plugintempbreakpoint(ulong addr,ulong type,int forceint3);
stdapi (void)    Pluginshowoptions(struct t_control *options);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// LEXICAL SCANNER ////////////////////////////////

#define SMODE_UPCASE   0x00000001      // Convert keywords to uppercase
#define SMODE_NOEOL    0x00000010      // Don't report SCAN_EOL, just skip it
#define SMODE_NOSPEC   0x00000020      // Don't translate specsymbols
#define SMODE_EXTKEY   0x00000040      // Allow &# and .!?%~ inside keywords
#define SMODE_NOUSKEY  0x00000080      // Underscore (_) is not part of keyword
#define SMODE_NODEC    0x00000100      // nn. is not decimal, but nn and '.'
#define SMODE_NOFLOAT  0x00000200      // nn.mm is not float, but nn, '.', mm
#define SMODE_RADIX10  0x00000400      // Default base is 10, not 16
#define SMODE_ANGLES   0x00000800      // Use angular brackets (<>) for text
#define SMODE_MASK     0x00001000      // Allow masked nibbles in SCAN_INT

#define SCAN_EOF       0               // End of data
#define SCAN_EOL       1               // End of line
#define SCAN_KEY       2               // Keyword in text
#define SCAN_TEXT      3               // Text string (without quotes) in text
#define SCAN_INT       4               // Integer in ival or uval
#define SCAN_FLOAT     5               // Floating-point number in fval
#define SCAN_OP        6               // Operator or punctuator in ival
#define SCAN_INVALID   7               // Invalid character in ival
#define SCAN_SYNTAX    8               // Syntactical error in errmsg
#define SCAN_USER      10              // Base for user-defined types

typedef struct t_scan {                // Scan descriptor
  // Fill these fields before the first scan. Set line to 1 for 1-based numbers.
  ulong          mode;                 // Scanning mode, set of SMODE_xxx
  wchar_t        *src;                 // Pointer to UNICODE source data
  ulong          length;               // Length of source data, characters
  ulong          caret;                // Next processed symbol, characters
  int            line;                 // Number of encountered EOLs
  // Call to Scan() fills some of these fields with scan data.
  union {
    int          ival;                 // Scanned item as integer number
    ulong        uval;                 // Scanned item as unsigned number
  };
  ulong          mask;                 // Binary mask for uval, SCAN_INT only
  long double    fval;                 // Scanned item as floating number
  wchar_t        text[TEXTLEN];        // Scanned item as a text string
  int            ntext;                // Length of text, characters
  wchar_t        errmsg[TEXTLEN];      // Error message
  int            type;                 // Type of last scanned item, SCAN_xxx
} t_scan;

stdapi (int)     Skipspaces(t_scan *ps);
stdapi (void)    Scan(t_scan *ps);
stdapi (int)     Optostring(wchar_t *s,int op);


////////////////////////////////////////////////////////////////////////////////
///////////////////////// SHORTCUTS, MENUS AND TOOLBAR /////////////////////////

// Input modes of menu functions.
#define MENU_VERIFY    0               // Check if menu item applies
#define MENU_EXECUTE   1               // Execute menu item
// Values returned by menu functions on MENU_VERIFY.
#define MENU_ABSENT    0               // Item doesn't appear in menu
#define MENU_NORMAL    1               // Ordinary menu item
#define MENU_CHECKED   2               // Checked menu item
#define MENU_CHKPARENT 3               // Checked menu item + checked parent
#define MENU_GRAYED    4               // Inactive menu item
#define MENU_SHORTCUT  5               // Shortcut only, not in menu
// Values returned by menu functions on MENU_EXECUTE.
#define MENU_NOREDRAW  0               // Do not redraw owning window
#define MENU_REDRAW    1               // Redraw owning window

// Shortcut descriptions.
#define KK_KEYMASK     0x0000FFFF      // Mask to extract key
#define KK_CHAR        0x00010000      // Process as WM_CHAR
#define KK_SHIFT       0x00020000      // Shortcut includes Shift key
#define KK_CTRL        0x00040000      // Shortcut includes Ctrl key
#define KK_ALT         0x00080000      // Shortcut includes Alt key
#define KK_WIN         0x00100000      // Shortcut includes WIN key
#define KK_NOSH        0x00200000      // Shortcut ignores Shift in main menu
#define KK_UNUSED      0x7FC00000      // Unused shortcut data bits
#define KK_DIRECT      0x80000000      // Direct shortcut in menu

// Global shortcuts. They may be re-used by plugins.
#define K_NONE         0               // No shortcut
// Global shortcuts: File functions.
#define K_OPENNEW      100             // Open new executable to debug
#define K_SETARGS      101             // Set command line args for next run
#define K_ATTACH       102             // Attach to the running process
#define K_DETACH       103             // Detach from the debugged process
#define K_EXIT         104             // Close OllyDbg
// Global shortcuts: View functions.
#define K_LOGWINDOW    110             // Open Log window
#define K_MODULES      111             // Open Executable modules window
#define K_MEMORY       112             // Open Memory map window
#define K_WINDOWS      113             // Open list of windows
#define K_THREADS      114             // Open Threads window
#define K_CPU          115             // Open CPU window
#define K_WATCHES      116             // Open Watches window
#define K_SEARCHES     117             // Open Search results window
#define K_RTRACE       118             // Open Run trace window
#define K_PATCHES      119             // Open Patches window
#define K_BPOINTS      120             // Open INT3 breakpoints window
#define K_BPMEM        121             // Open Memory breakpoints window
#define K_BPHARD       122             // Open Hardware breakpoints window
#define K_SOURCES      123             // Open list of source files
#define K_FILE         124             // Open file
// Global shortcuts: Debug functions.
#define K_RUN          130             // Run debugged application
#define K_RUNTHREAD    131             // Run only actual thread
#define K_PAUSE        132             // Pause debugged application
#define K_STEPIN       133             // Step into
#define K_STEPOVER     134             // Step over
#define K_TILLRET      135             // Execute till return
#define K_TILLUSER     136             // Execute till user code
#define K_CALLDLL      137             // Call DLL export
#define K_RESTART      138             // Restart last debugged executable
#define K_CLOSE        139             // Close debuggee
#define K_AFFINITY     140             // Set affinity
// Global shortcuts: Trace functions.
#define K_OPENTRACE    150             // Open Run trace
#define K_CLOSETRACE   151             // Close Run trace
#define K_ANIMIN       152             // Animate into
#define K_ANIMOVER     153             // Animate over
#define K_TRACEIN      154             // Trace into
#define K_TRACEOVER    155             // Trace over
#define K_RUNHIT       156             // Run hit trace
#define K_STOPHIT      157             // Stop hit trace
#define K_RTCOND       158             // Set run trace break condition
#define K_RTLOG        159             // Set run trace log condition
// Global shortcuts: Options.
#define K_OPTIONS      170             // Open Options dialog
#define K_PLUGOPTIONS  171             // Open Plugin options dialog
#define K_SHORTCUTS    172             // Open Shortcut editor
// Global shortcuts: Windows functions.
#define K_TOPMOST      180             // Toggle topmost status of main window
#define K_CASCADE      181             // Cascade MDI windows
#define K_TILEHOR      182             // Tile MDI windows horizontally
#define K_TILEVER      183             // Tile MDI windows vertically
#define K_ICONS        184             // Arrange icons
#define K_CLOSEMDI     185             // Close all MDI windows
#define K_RESTORE      186             // Maximize or restore active MDI window
#define K_PREVMDI      187             // Go to previous MDI window
#define K_NEXTMDI      188             // Go to next MDI window
// Global shortcuts: Help functions.
#define K_ABOUT        190             // Open About dialog
// Generic table shortcuts.
#define K_PREVFRAME    200             // Go to previous frame in table
#define K_NEXTFRAME    201             // Go to next frame in table
#define K_UPDATE       202             // Update table
#define K_COPY         203             // Copy to clipboard
#define K_COPYALL      204             // Copy whole table to clipboard
#define K_CUT          205             // Cut to clipboard
#define K_PASTE        206             // Paste
#define K_TOPMOSTMDI   207             // Make MDI window topmost
#define K_AUTOUPDATE   208             // Periodically update contents of window
#define K_SHOWBAR      209             // Show/hide bar
#define K_HSCROLL      210             // Show/hide horizontal scroll
#define K_DEFCOLUMNS   211             // Resize all columns to default width
// Shortcuts used by different windows.
#define K_SEARCHAGAIN  220             // Repeat last search
#define K_SEARCHREV    221             // Repeat search in inverse direction
// Dump: Data backup.
#define K_BACKUP       240             // Create or update backup
#define K_SHOWBKUP     241             // Toggle backup display
// Dump: Edit.
#define K_UNDO         250             // Undo selection
#define K_COPYADDR     251             // Copy address
#define K_COPYHEX      252             // Copy data in hexadecimal format
#define K_PASTEHEX     253             // Paste data in hexadecimal format
#define K_EDITITEM     254             // Edit first selected item
#define K_EDIT         255             // Edit selection
#define K_FILLZERO     256             // Fill selection with zeros
#define K_FILLNOP      257             // Fill selection with NOPs
#define K_FILLFF       258             // Fill selection with FF code
#define K_SELECTALL    259             // Select all
#define K_SELECTPROC   260             // Select procedure or structure
#define K_COPYTOEXE    261             // Copy selection to executable file
#define K_ZERODUMP     262             // Zero whole dump
#define K_LABEL        263             // Add custom label
#define K_ASSEMBLE     264             // Assemble
#define K_COMMENT      265             // Add custom comment
#define K_SAVEFILE     266             // Save file
// Dump: Breakpoints.
#define K_BREAK        280             // Toggle simple INT3 breakpoint
#define K_CONDBREAK    281             // Set or edit cond INT3 breakpoint
#define K_LOGBREAK     282             // Set or edit logging INT3 breakpoint
#define K_RUNTOSEL     283             // Run to selection
#define K_ENABLEBRK    284             // Enable or disable INT3 breakpoint
#define K_MEMBREAK     285             // Set or edit memory breakpoint
#define K_MEMLOGBREAK  286             // Set or edit memory log breakpoint
#define K_MEMENABLE    287             // Enable or disable memory breakpoint
#define K_MEMDEL       288             // Delete memory breakpoint
#define K_HWBREAK      289             // Set or edit hardware breakpoint
#define K_HWLOGBREAK   290             // Set or edit hardware log breakpoint
#define K_HWENABLE     291             // Enable or disable hardware breakpoint
#define K_HWDEL        292             // Delete hardware breakpoint
// Dump: Jumps to location.
#define K_NEWORIGIN    300             // Set new origin
#define K_FOLLOWDASM   301             // Follow address in Disassembler
#define K_ORIGIN       302             // Go to origin
#define K_GOTO         303             // Go to expression
#define K_JMPTOSEL     304             // Follow jump or call to selection
#define K_SWITCHCASE   305             // Go to switch case
#define K_PREVHIST     306             // Go to previous history location
#define K_NEXTHIST     307             // Go to next history location
#define K_PREVTRACE    308             // Go to previous run trace record
#define K_NEXTTRACE    309             // Go to next run trace record
#define K_PREVPROC     310             // Go to previous procedure
#define K_NEXTPROC     311             // Go to next procedure
#define K_PREVREF      312             // Go to previous found item
#define K_NEXTREF      313             // Go to next found item
#define K_FOLLOWEXE    314             // Follow selection in executable file
// Dump: Structures.
#define K_DECODESTR    330             // Decode as structure
#define K_DECODESPTR   331             // Decode as pointer to structure
// Dump: Search.
#define K_NAMES        380             // Show list of names
#define K_FINDCMD      381             // Find command
#define K_FINDCMDSEQ   382             // Find sequence of commands
#define K_FINDCONST    383             // Find constant
#define K_FINDBIN      384             // Find binary string
#define K_FINDMOD      385             // Find modification
#define K_ALLCALLS     386             // Search for all intermodular calls
#define K_ALLCMDS      387             // Search for all commands
#define K_ALLCMDSEQ    388             // Search for all command sequences
#define K_ALLCONST     389             // Search for all constants
#define K_ALLMODS      390             // Search for all modifications
#define K_ALLSTRS      391             // Search for all referenced strings
#define K_ALLGUIDS     392             // Search for all referenced GUIDs
#define K_ALLCOMMENTS  393             // Search for all user-defined comments
#define K_ALLSWITCHES  394             // Search for all switches
#define K_ALLFLOATS    395             // Search for all floating constants
#define K_LASTRTREC    396             // Find last record in run trace
// Dump: References.
#define K_REFERENCES   410             // Find all references
// Dump: Addressing.
#define K_ABSADDR      420             // Show absolute addresses
#define K_RELADDR      421             // Show offsets from current selection
#define K_BASEADDR     422             // Show offsets relative to module base
// Dump: Comments.
#define K_COMMSRC      430             // Toggle between comments and source
#define K_SHOWPROF     431             // Show or hide run trace profile
// Dump: Analysis.
#define K_ANALYSE      440             // Analyse module
#define K_REMANAL      441             // Remove analysis from selection
#define K_REMANMOD     442             // Remove analysis from the module
// Dump: Help.
#define K_HELPCMD      450             // Help on command
#define K_HELPAPI      451             // Help on Windows API function
// Dump: Data presentation.
#define K_DUMPHA16     460             // Dump as 16 hex bytes and ASCII text
#define K_DUMPHA8      461             // Dump as 8 hex bytes and ASCII text
#define K_DUMPHU16     462             // Dump as 16 hex bytes and UNICODE text
#define K_DUMPHU8      463             // Dump as 8 hex bytes and UNICODE text
#define K_DUMPA64      464             // Dump as 64 ASCII characters
#define K_DUMPA32      465             // Dump as 32 ASCII characters
#define K_DUMPU64      466             // Dump as 64 UNICODE characters
#define K_DUMPU32      467             // Dump as 32 UNICODE characters
#define K_DUMPU16      468             // Dump as 16 UNICODE characters
#define K_DUMPISHORT   469             // Dump as 16-bit signed numbers
#define K_DUMPUSHORT   470             // Dump as 16-bit unsigned numbers
#define K_DUMPXSHORT   471             // Dump as 16-bit hexadecimal numbers
#define K_DUMPILONG    472             // Dump as 32-bit signed numbers
#define K_DUMPULONG    473             // Dump as 32-bit unsigned numbers
#define K_DUMPXLONG    474             // Dump as 32-bit hexadecimal numbers
#define K_DUMPADR      475             // Dump as address with comments
#define K_DUMPADRA     476             // Dump as address with ASCII & comments
#define K_DUMPADRU     477             // Dump as address with UNICODE & comms
#define K_DUMPF32      478             // Dump as 32-bit floats
#define K_DUMPF64      479             // Dump as 64-bit floats
#define K_DUMPF80      480             // Dump as 80-bit floats
#define K_DUMPDA       481             // Dump as disassembly
#define K_DUMPSTRUCT   482             // Dump as known structure
// Stack-specific shortcuts.
#define K_LOCKSTK      490             // Toggle stack lock
#define K_PUSH         491             // Push doubleword
#define K_POP          492             // Pop doubleword
#define K_STACKINDASM  493             // Follow stack doubleword in CPU
#define K_GOTOESP      494             // Go to ESP
#define K_GOTOEBP      495             // Go to EBP
#define K_ESPADDR      496             // Show offsets relative to ESP
#define K_EBPADDR      497             // Show offsets relative to EBP
// Shortcuts of Register pane.
#define K_INCREMENT    500             // Increment register
#define K_DECREMENT    501             // Decrement register
#define K_ZERO         502             // Zero selected register
#define K_SET1         503             // Set register to 1
#define K_MODIFY       504             // Modify contents of register
#define K_UNDOREG      505
#define K_PUSHFPU      506             // Push FPU stack
#define K_POPFPU       507             // Pop FPU stack
#define K_REGINDASM    508             // Follow register in CPU Disassembler
#define K_REGINDUMP    509             // Follow register in CPU Dump
#define K_REGINSTACK   510             // Follow register in CPU Stack
#define K_VIEWFPU      511             // View FPU registers
#define K_VIEWMMX      512             // View MMX registers
#define K_VIEW3DNOW    513             // View 3DNow! registers
#define K_HELPREG      514             // Help on register
// Shortcuts of Information pane.
#define K_EDITOP       520             // Edit contents of operand in info pane
#define K_INFOINDASM   521             // Follow information in CPU Disassembler
#define K_INFOINDUMP   522             // Follow information in CPU Dump
#define K_INFOINSTACK  523             // Follow information in CPU Stack
#define K_LISTJUMPS    524             // List jumps and calls to command
#define K_LISTCASES    525             // List switch cases
#define K_INFOSRC      526             // Follow address in Source code
// Log window.
#define K_LOGINDASM    530             // Follow log address in CPU Disassembler
#define K_LOGINDUMP    531             // Follow log address in CPU Dump
#define K_LOGINSTACK   532             // Follow log address in CPU Stack
#define K_LOGCLEAR     533             // Clear log
#define K_LOGTOFILE    534             // Start logging to file
#define K_STOPLOG      535             // Stop logging to file
// Executable modules.
#define K_MODINDASM    540             // Follow module entry point in CPU
#define K_MODDATA      541             // View module data section in CPU Dump
#define K_MODEXE       542             // Open executable in standalone Dump
#define K_MODNAMES     543             // Show names declared in the module
#define K_GLOBNAMES    544             // Show global list of names
#define K_MODCALLS     545             // Find intermodular calls in module
#define K_MODANALYSE   546             // Analyse selected module
#define K_SAVEUDD      547             // Save module data to .udd file
#define K_LOADUDD      548             // Load module data from .udd file
// Memory map.
#define K_MEMBACKUP    550             // Create backup of memory block
#define K_MEMINDASM    551             // Open memory block in CPU Disassembler
#define K_MEMINDUMP    552             // Open memory block in CPU Dump
#define K_DUMP         553             // Dump memory block in separate window
#define K_SEARCHMEM    554             // Search memory block for binary string
#define K_MEMBPACCESS  555             // Toggle break on access
// List of windows.
#define K_WININDASM    560             // Follow WinProc in CPU Disassembler
#define K_CLSINDASM    561             // Follow ClassProc in CPU Disassembler
// Threads.
#define K_THRINCPU     570             // Open thread in CPU window
#define K_THRTIB       571             // Dump Thread Information Block
#define K_REGISTERS    572             // Open Registers window
#define K_THRSUSPEND   573             // Suspend selected thread
#define K_THRRESUME    574             // Resume selected thread
#define K_THRKILL      575             // Kill selected thread
// Watches.
#define K_ADDWATCH     580             // Add watch
#define K_EDITWATCH    581             // Edit existing watch
#define K_DELWATCH     582             // Delete watch
#define K_WATCHUP      583             // Move watch up
#define K_WATCHDN      584             // Move watch down
#define K_EDITCONT     585             // Edit contents of register or memory
#define K_WATCHINDASM  586             // Follow watch value in CPU Disassembler
#define K_WATCHINDUMP  587             // Follow watch value in CPU Dump
#define K_WATCHINSTACK 588             // Follow watch value in CPU Stack
// Search results.
#define K_SEARCHINDASM 600             // Follow address of found item in CPU
#define K_PREVSEARCH   601             // Follow previous found item in Disasm
#define K_NEXTSEARCH   602             // Follow next found item in Disasm
#define K_FINDTEXT     603             // Find text substring in search results
#define K_BREAKALL     604             // Set breakpoint on all found commands
#define K_CONDBPALL    605             // Set conditional bp on all commands
#define K_LOGBPALL     606             // Set logging bp on all commands
#define K_DELBPALL     607             // Remove breakpoints from all commands
#define K_BREAKCALLS   608             // Set break on calls to function
#define K_CONDBPCALLS  609             // Set cond break on calls to function
#define K_LOGBPCALLS   610             // Set logging break on calls to function
#define K_DELBPCALLS   611             // Remove breakpoints from calls
// Run trace.
#define K_RTPREV       620             // Show previous run trace in Disasm
#define K_RTNEXT       621             // Show next run trace in Disasm
#define K_TRACEINDASM  622             // Follow traced command in CPU
#define K_CLRTRACE     623             // Clear run trace
#define K_REGMODE      624             // Toggle register display mode
#define K_MARKTRACE    625             // Mark address in run trace
#define K_FINDTRADDR   626             // Enter address to mark in run trace
#define K_PREVMARK     627             // Find previous marked address
#define K_NEXTMARK     628             // Find next marked address
#define K_CLEARMARK    629             // Clear address marks in run trace
#define K_PROFILE      630             // Profile selected module
#define K_GLOBPROFILE  631             // Profile whole memory
#define K_SAVETRACE    632             // Save run trace data to the file
#define K_STOPSAVETR   633             // Close run trace log file
// Profile.
#define K_PROFINDASM   640             // Follow profiled command in CPU
#define K_PREVPROF     641             // Follow previous profile item in Disasm
#define K_NEXTPROF     642             // Follow next profile item in Disasm
#define K_PROFMARK     643             // Mark profile address in run trace
// Patches.
#define K_PATCHINDASM  650             // Follow patch in CPU Disassembler
#define K_PREVPATCH    651             // Go to previous patch
#define K_NEXTPATCH    652             // Go to next patch
#define K_APPLYPATCH   653             // Apply patch
#define K_RESTOREPT    654             // Restore original code
#define K_DELPATCH     655             // Delete patch record
// Breakpoint lists.
#define K_DELETEBP     660             // Delete breakpoint
#define K_ENABLEBP     661             // Enable or disable breakpoint
#define K_BPINDASM     662             // Follow breakpoint in CPU Disassembler
#define K_BPINDUMP     663             // Follow breakpoint in CPU Dump
#define K_DISABLEALLBP 664             // Disable all breakpoints
#define K_ENABLEALLBP  665             // Enable all breakpoints
// Source.
#define K_SOURCEINDASM 670             // Follow source line in CPU Disassembler
// List of source files.
#define K_VIEWSRC      680             // View source file
// Names.
#define K_FOLLOWIMP    690             // Follow import in CPU Disassembler
#define K_NAMEINDASM   691             // Follow label in CPU Disassembler
#define K_NAMEINDUMP   692             // Follow label in CPU Dump
#define K_NAMEREFS     693             // Find references to name
#define K_NAMEHELPAPI  694             // Help on selected API function
// Special non-changeable shortcuts.
#define K_0            1008            // Digit 0
#define K_1            1009            // Digit 1
#define K_2            1010            // Digit 2
#define K_3            1011            // Digit 3
#define K_4            1012            // Digit 4
#define K_5            1013            // Digit 5
#define K_6            1014            // Digit 6
#define K_7            1015            // Digit 7
#define K_8            1016            // Digit 8
#define K_9            1017            // Digit 9
#define K_A            1018            // Hex digit A
#define K_B            1019            // Hex digit B
#define K_C            1020            // Hex digit C
#define K_D            1021            // Hex digit D
#define K_E            1022            // Hex digit E
#define K_F            1023            // Hex digit F

// Native OllyDbg tables that support embedded plugin menus:
#define PWM_ATTACH     L"ATTACH"       // List of processes in Attach window
#define PWM_BPHARD     L"BPHARD"       // Hardware breakpoints
#define PWM_BPMEM      L"BPMEM"        // Memory breakpoints
#define PWM_BPOINT     L"BPOINT"       // INT3 breakpoints
#define PWM_DISASM     L"DISASM"       // CPU Disassembler pane
#define PWM_DUMP       L"DUMP"         // All dumps except CPU disasm & stack
#define PWM_INFO       L"INFO"         // CPU Info pane
#define PWM_LOG        L"LOG"          // Log window
#define PWM_MAIN       L"MAIN"         // Main OllyDbg menu
#define PWM_MEMORY     L"MEMORY"       // Memory window
#define PWM_MODULES    L"MODULES"      // Modules window
#define PWM_NAMELIST   L"NAMELIST"     // List of names (labels)
#define PWM_PATCHES    L"PATCHES"      // List of patches
#define PWM_PROFILE    L"PROFILE"      // Profile window
#define PWM_REGISTERS  L"REGISTERS"    // Registers, including CPU
#define PWM_SEARCH     L"SEARCH"       // Search tabs
#define PWM_SOURCE     L"SOURCE"       // Source code window
#define PWM_SRCLIST    L"SRCLIST"      // List of source files
#define PWM_STACK      L"STACK"        // CPU Stack pane
#define PWM_THREADS    L"THREADS"      // Threads window
#define PWM_TRACE      L"TRACE"        // Run trace window
#define PWM_WATCH      L"WATCH"        // Watches
#define PWM_WINDOWS    L"WINDOWS"      // List of windows

typedef int  MENUFUNC(struct t_table *,wchar_t *,ulong,int);

typedef struct t_menu {                // Menu descriptor
  wchar_t        *name;                // Menu command
  wchar_t        *help;                // Explanation of command
  int            shortcutid;           // Shortcut identifier, K_xxx
  MENUFUNC       *menufunc;            // Function that executes menu command
  struct t_menu  *submenu;             // Pointer to descriptor of popup menu
  union {
    ulong        index;                // Argument passed to menu function
    HMENU        hsubmenu;             // Handle of pulldown menu
  };
} t_menu;

stdapi (int)     Callmenufunction(struct t_table *pt,t_menu *pm,
                   MENUFUNC *menufunc,ulong index);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// MAIN OLLYDBG WINDOW //////////////////////////////

typedef enum t_status {                // Thread/process status
  STAT_IDLE,                           // No process to debug
  STAT_LOADING,                        // Loading new process
  STAT_ATTACHING,                      // Attaching to the running process
  STAT_RUNNING,                        // All threads are running
  STAT_RUNTHR,                         // Single thread is running
  STAT_STEPIN,                         // Stepping into, single thread
  STAT_STEPOVER,                       // Stepping over, single thread
  STAT_ANIMIN,                         // Animating into, single thread
  STAT_ANIMOVER,                       // Animating over, single thread
  STAT_TRACEIN,                        // Tracing into, single thread
  STAT_TRACEOVER,                      // Tracing over, single thread
  STAT_SFXRUN,                         // SFX using run trace, single thread
  STAT_SFXHIT,                         // SFX using hit trace, single thread
  STAT_SFXKNOWN,                       // SFX to known entry, single thread
  STAT_TILLRET,                        // Stepping until return, single thread
  STAT_OVERRET,                        // Stepping over return, single thread
  STAT_TILLUSER,                       // Stepping till user code, single thread
  STAT_PAUSING,                        // Process is requested to pause
  STAT_PAUSED,                         // Process paused on debugging event
  STAT_FINISHED,                       // Process is terminated but in memory
  STAT_CLOSING                         // Process is requested to close/detach
} t_status;

varapi (void)    Info(wchar_t *format,...);
varapi (void)    Message(ulong addr,wchar_t *format,...);
varapi (void)    Tempinfo(wchar_t *format,...);
varapi (void)    Flash(wchar_t *format,...);
varapi (void)    Progress(int promille,wchar_t *format,...);
stdapi (void)    Moveprogress(int promille);
stdapi (void)    Setstatus(t_status newstatus);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// DATA FUNCTIONS ////////////////////////////////

// Name and data types. Do not change order, it's important! Always keep values
// of demangled names 1 higher than originals, and NM_ALIAS higher than
// NM_EXPORT - name search routines rely on these facts!
#define NM_NONAME      0x00            // Means that name is absent
#define DT_NONE        0x00            // Ditto
#define NM_LABEL       0x21            // User-defined label
#define NM_EXPORT      0x22            // Exported name
#define NM_DEEXP       (NM_EXPORT+1)   // Demangled exported name
#define DT_EORD        (NM_EXPORT+2)   // Exported ordinal (ulong)
#define NM_ALIAS       (NM_EXPORT+3)   // Alias of NM_EXPORT
#define NM_IMPORT      0x26            // Imported name (module.function)
#define NM_DEIMP       (NM_IMPORT+1)   // Demangled imported name
#define DT_IORD        (NM_IMPORT+2)   // Imported ordinal (struct dt_iord)
#define NM_DEBUG       0x29            // Name from debug data
#define NM_DEDEBUG     (NM_DEBUG+1)    // Demangled name from debug data
#define NM_ANLABEL     0x2B            // Name added by Analyser
#define NM_COMMENT     0x30            // User-defined comment
#define NM_ANALYSE     0x31            // Comment added by Analyser
#define NM_MARK        0x32            // Important parameter
#define NM_CALLED      0x33            // Name of called function
#define DT_ARG         0x34            // Name and type of argument or data
#define DT_NARG        0x35            // Guessed number of arguments at CALL
#define NM_RETTYPE     0x36            // Type of data returned in EAX
#define NM_MODCOMM     0x37            // Automatical module comments
#define NM_TRICK       0x38            // Parentheses of tricky sequences
#define DT_SWITCH      0x40            // Switch descriptor (struct dt_switch)
#define DT_CASE        0x41            // Case descriptor (struct dt_case)
#define DT_MNEMO       0x42            // Alternative mnemonics data (dt_mnemo)
#define NM_DLLPARMS    0x44            // Parameters of Call DLL dialog
#define DT_DLLDATA     0x45            // Parameters of Call DLL dialog

#define DT_DBGPROC     0x4A            // t_function from debug, don't save!

#define NM_INT3BASE    0x51            // Base for INT3 breakpoint names
#define   NM_INT3COND  (NM_INT3BASE+0) // INT3 breakpoint condition
#define   NM_INT3EXPR  (NM_INT3BASE+1) // Expression to log at INT3 breakpoint
#define   NM_INT3TYPE  (NM_INT3BASE+2) // Type used to decode expression
#define NM_MEMBASE     0x54            // Base for memory breakpoint names
#define   NM_MEMCOND   (NM_MEMBASE+0)  // Memory breakpoint condition
#define   NM_MEMEXPR   (NM_MEMBASE+1)  // Expression to log at memory break
#define   NM_MEMTYPE   (NM_MEMBASE+2)  // Type used to decode expression
#define NM_HARDBASE    0x57            // Base for hardware breakpoint names
#define   NM_HARDCOND  (NM_HARDBASE+0) // Hardware breakpoint condition
#define   NM_HARDEXPR  (NM_HARDBASE+1) // Expression to log at hardware break
#define   NM_HARDTYPE  (NM_HARDBASE+2) // Type used to decode expression

#define NM_LABELSAV    0x60            // NSTRINGS last user-defined labels
#define NM_ASMSAV      0x61            // NSTRINGS last assembled commands
#define NM_ASRCHSAV    0x62            // NSTRINGS last assemby searches
#define NM_COMMSAV     0x63            // NSTRINGS last user-defined comments
#define NM_WATCHSAV    0x64            // NSTRINGS last watch expressions
#define NM_GOTOSAV     0x65            // NSTRINGS last GOTO expressions
#define DT_BINSAV      0x66            // NSTRINGS last binary search patterns
#define NM_CONSTSAV    0x67            // NSTRINGS last constants to search
#define NM_STRSAV      0x68            // NSTRINGS last strings to search
#define NM_ARGSAV      0x69            // NSTRINGS last arguments (ARGLEN!)
#define NM_CURRSAV     0x6A            // NSTRINGS last current dirs (MAXPATH!)

#define NM_SEQSAV      0x6F            // NSTRINGS last sequences (DATALEN!)

#define NM_RTCOND1     0x70            // First run trace pause condition
#define NM_RTCOND2     0x71            // Second run trace pause condition
#define NM_RTCOND3     0x72            // Third run trace pause condition
#define NM_RTCOND4     0x73            // Fourth run trace pause condition
#define NM_RTCMD1      0x74            // First run trace match command
#define NM_RTCMD2      0x75            // Second run trace match command
#define NM_RANGE0      0x76            // Low range limit
#define NM_RANGE1      0x77            // High range limit

#define DT_ANYDATA     0xFF            // Special marker, not a real data

#define NMOFS_COND     0               // Offset to breakpoint condition
#define NMOFS_EXPR     1               // Offset to breakpoint log expression
#define NMOFS_TYPE     2               // Offset to expression decoding type

typedef struct dt_iord {               // Descriptor of DT_IORD data
  ulong          ord;                  // Ordinal
  wchar_t        modname[SHORTNAME];   // Short name of the module
} dt_iord;

#define NSWEXIT        256             // Max no. of switch exits, incl. default
#define NSWCASE        128             // Max no. of cases in exit

// Types of switches and switch exits.
#define CASE_CASCADED  0x00000001      // Cascaded IF
#define CASE_HUGE      0x00000002      // Huge switch, some cases are lost
#define CASE_DEFAULT   0x00000004      // Has default (is default for dt_case)
#define CASE_TYPEMASK  0x00000070      // Mask to extract case type
#define   CASE_ASCII   0x00000010      // Intreprete cases as ASCII characters
#define   CASE_MSG     0x00000020      // Interprete cases as WM_xxx
#define   CASE_EXCPTN  0x00000040      // Interprete cases as exception codes
#define CASE_SIGNED    0x00000080      // Interprete cases as signed

typedef struct dt_switch {             // Switch descriptor DT_SWITCH
  ulong          casemin;              // Minimal case
  ulong          casemax;              // Maximal case
  ulong          type;                 // Switch type, set of CASE_xxx
  int            nexit;                // Number of exits including default
  ulong          exitaddr[NSWEXIT];    // List of exits (point to dt_case)
} dt_switch;

typedef struct dt_case {               // Switch exit descriptor DT_CASE
  ulong          swbase;               // Address of a switch descriptor
  ulong          type;                 // Switch type, set of CASE_xxx
  int            ncase;                // Number of cases (1..64, 0: default)
  ulong          value[NSWCASE];       // List of cases for exit
} dt_case;

// Flags indicating alternative forms of assembler mnemonics.
#define MF_JZ          0x01            // JZ, JNZ instead of JE, JNE
#define MF_JC          0x02            // JC, JNC instead of JAE, JB

typedef struct dt_mnemo {              // Mnemonics decoding DT_MNEMO
  uchar          flags;                // Set of MF_xxx
} dt_mnemo;

stdapi (int)     Insertdata(ulong addr,int type,void *data,ulong datasize);
stdapi (ulong)   Finddata(ulong addr,int type,void *data,ulong datasize);
stdapi (void *)  Finddataptr(ulong addr,int type,ulong *datasize);
stdapi (void)    Startnextdata(ulong addr0,ulong addr1,int type);
stdapi (ulong)   Findnextdata(ulong *addr,void *data,ulong datasize);
stdapi (void)    Startnextdatalist(ulong addr0,ulong addr1,int *list,int n);
stdapi (int)     Findnextdatalist(ulong *addr,int *type,
                   void *data,ulong datasize);
stdapi (int)     Isdataavailable(ulong addr,int type1,int type2,int type3);
stdapi (int)     Isdatainrange(ulong addr0,ulong addr1,
                   int type1,int type2,int type3);
stdapi (void)    Deletedatarange(ulong addr0,ulong addr1,
                   int type1,int type2,int type3);
stdapi (void)    Deletedatarangelist(ulong addr0,ulong addr1,int *list,int n);
stdapi (int)     Quickinsertdata(ulong addr,int type,
                   void *data,ulong datasize);
stdapi (void)    Mergequickdata(void);
stdapi (int)     DemanglenameW(wchar_t *name,wchar_t *undecorated,int recurs);
stdapi (int)     InsertnameW(ulong addr,int type,wchar_t *s);
stdapi (int)     QuickinsertnameW(ulong addr,int type,wchar_t *s);
stdapi (int)     FindnameW(ulong addr,int type,wchar_t *name,int nname);
stdapi (int)     FindnextnameW(ulong *addr,wchar_t *name,int nname);
stdapi (void)    Startnextnamelist(ulong addr0,ulong addr1,int *list,int n);
stdapi (int)     FindnextnamelistW(ulong *addr,int *type,
                   wchar_t *name,int nname);
stdapi (int)     Findlabel(ulong addr,wchar_t *name,int firsttype);
stdapi (int)     FindaddressW(wchar_t *name,struct t_module *pmod,
                   ulong *addr,wchar_t *errtxt);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// SIMPLE DATA FUNCTIONS ////////////////////////////

typedef struct t_simple {              // Simple data container
  uchar          *heap;                // Data heap
  ulong          itemsize;             // Size of data element, bytes
  int            maxitem;              // Size of allocated data heap, items
  int            nitem;                // Actual number of data items
  int            sorted;               // Whether data is sorted
} t_simple;

stdapi (void)    Destroysimpledata(t_simple *pdat);
stdapi (int)     Createsimpledata(t_simple *pdat,ulong itemsize);
stdapi (int)     Addsimpledata(t_simple *pdat,void *data);
stdapi (void)    Sortsimpledata(t_simple *pdat);
stdapi (void *)  Findsimpledata(t_simple *pdat,ulong addr);
stdapi (int)     Getsimpledataindexbyaddr(t_simple *pdat,ulong addr);
stdapi (void *)  Getsimpledatabyindex(t_simple *pdat,int index);
stdapi (void)    Deletesimpledatarange(t_simple *pdat,ulong addr0,ulong addr1);

// Bits that describe the state of predicted data, similar to PST_xxx.
#define PRED_SHORTSP   0x8000          // Offset of ESP is 1 byte, .udd only
#define PRED_SHORTBP   0x4000          // Offset of EBP is 1 byte, .udd only
#define PRED_ESPRET    0x0400          // Offset of ESP backtraced from return
#define PRED_ESPOK     0x0200          // Offset of ESP valid
#define PRED_EBPOK     0x0100          // Offset of EBP valid
#define PRED_REL       0x0080          // Result constant fixuped or relative
#define PRED_RESMASK   0x003F          // Mask to extract description of result
#define   PRED_VALID   0x0020          // Result constant valid
#define   PRED_ADDR    0x0010          // Result is address
#define   PRED_ORIG    0x0008          // Result is based on original register
#define   PRED_OMASK   0x0007          // Mask to extract original register

#define PRED_ESPKNOWN  (PRED_ESPRET|PRED_ESPOK)

typedef struct sd_pred {               // Descriptor of predicted data
  ulong          addr;                 // Address of predicted command
  ushort         mode;                 // Combination of PRED_xxx
  long           espconst;             // Offset of ESP to original ESP
  long           ebpconst;             // Offset of EBP to original ESP
  ulong          resconst;             // Constant in result of execution
} sd_pred;


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// SORTED DATA //////////////////////////////////

#define SDM_INDEXED    0x00000001      // Indexed sorted data
#define SDM_EXTADDR    0x00000002      // Address is extended by TY_AEXTMASK
#define SDM_NOSIZE     0x00000004      // Header without size and type
#define SDM_NOEXTEND   0x00000008      // Don't reallocate memory, fail instead

// Address extension.
#define TY_AEXTMASK    0x000000FF      // Mask to extract address extension
// General item types.
#define TY_NEW         0x00000100      // Item is new
#define TY_CONFIRMED   0x00000200      // Item still exists
#define TY_EXTADDR     0x00000400      // Address extension active
#define TY_SELECTED    0x00000800      // Reserved for multiple selection
// Module-related item types (used in t_module and t_premod).
#define MOD_MAIN       0x00010000      // Main module
#define MOD_SFX        0x00020000      // Self-extractable file
#define   MOD_SFXDONE  0x00040000      // SFX file extracted
#define MOD_RUNDLL     0x00080000      // DLL loaded by LOADDLL.EXE
#define MOD_SYSTEMDLL  0x00100000      // System DLL
#define MOD_SUPERSYS   0x00200000      // System DLL that uses special commands
#define MOD_DBGDATA    0x00400000      // Debugging data is available
#define MOD_ANALYSED   0x00800000      // Module is already analysed
#define MOD_NODATA     0x01000000      // Module data is not yet available
#define MOD_HIDDEN     0x02000000      // Module is loaded in stealth mode
#define MOD_NETAPP     0x04000000      // .NET application
#define MOD_RESOLVED   0x40000000      // All static imports are resolved
// Memory-related item types (used in t_memory), see also t_memory.special.
#define MEM_ANYMEM     0x0FFFF000      // Mask for memory attributes
#define   MEM_CODE     0x00001000      // Contains image of code section
#define   MEM_DATA     0x00002000      // Contains image of data section
#define   MEM_SFX      0x00004000      // Contains self-extractor
#define   MEM_IMPDATA  0x00008000      // Contains import data
#define   MEM_EXPDATA  0x00010000      // Contains export data
#define   MEM_RSRC     0x00020000      // Contains resources
#define   MEM_RELOC    0x00040000      // Contains relocation data
#define   MEM_STACK    0x00080000      // Contains stack of some thread
#define   MEM_STKGUARD 0x00100000      // Guarding page of the stack
#define   MEM_THREAD   0x00200000      // Contains data block of some thread
#define   MEM_HEADER   0x00400000      // Contains COFF header
#define   MEM_DEFHEAP  0x00800000      // Contains default heap
#define   MEM_HEAP     0x01000000      // Contains non-default heap
#define   MEM_NATIVE   0x02000000      // Contains JIT-compiled native code
#define   MEM_GAP      0x08000000      // Free or reserved space
#define MEM_SECTION    0x10000000      // Section of the executable file
#define MEM_GUARDED    0x40000000      // NT only: guarded memory block
#define MEM_TEMPGUARD  0x80000000      // NT only: temporarily guarded block
// Thread-related item types (used in t_thread).
#define THR_MAIN       0x00010000      // Main thread
#define THR_NETDBG     0x00020000      // .NET debug helper thread
#define THR_ORGHANDLE  0x00100000      // Original thread's handle, don't close
// Window-related item types (used in t_window).
#define WN_UNICODE     0x00010000      // UNICODE window
// Procedure-related item types (used in t_procdata).
#define PD_CALLBACK    0x00001000      // Used as a callback
#define PD_RETSIZE     0x00010000      // Return size valid
#define PD_TAMPERRET   0x00020000      // Tampers with the return address
#define PD_NORETURN    0x00040000      // Calls function without return
#define PD_PURE        0x00080000      // Doesn't modify memory & make calls
#define PD_ESPALIGN    0x00100000      // Aligns ESP on entry
#define PD_ARGMASK     0x07E00000      // Mask indicating valid narg
#define   PD_FIXARG    0x00200000      // narg is fixed number of arguments
#define   PD_FORMATA   0x00400000      // narg-1 is ASCII printf format
#define   PD_FORMATW   0x00800000      // narg-1 is UNICODE printf format
#define   PD_SCANA     0x01000000      // narg-1 is ASCII scanf format
#define   PD_SCANW     0x02000000      // narg-1 is UNICODE scanf format
#define   PD_COUNT     0x04000000      // narg-1 is count of following args
#define PD_GUESSED     0x08000000      // narg and type are guessed, not known
#define PD_NGUESS      0x10000000      // nguess valid
#define PD_VARGUESS    0x20000000      // nguess variable, set to minimum!=0
#define PD_NPUSH       0x40000000      // npush valid
#define PD_VARPUSH     0x80000000      // npush valid, set to maximum
// Argument prediction-related types (used in t_predict).
#define PR_PUSHBP      0x00010000      // PUSH EBP or ENTER executed
#define PR_MOVBPSP     0x00020000      // MOV EBP,ESP or ENTER executed
#define PR_SETSEH      0x00040000      // Structured exception handler set
#define PR_RETISJMP    0x00100000      // Return is (mis)used as a jump
#define PR_DIFFRET     0x00200000      // Return changed, destination unknown
#define PR_JMPTORET    0x00400000      // Jump to original return address
#define PR_TAMPERRET   0x00800000      // Retaddr on stack accessed or modified
#define PR_BADESP      0x01000000      // ESP of actual generation is invalid
#define PR_RET         0x02000000      // Return from subroutine
#define PR_STEPINTO    0x10000000      // Step into CALL command
// Breakpoint-related types (used in t_bpoint, t_bpmem and t_bphard).
#define BP_BASE        0x0000F000      // Mask to extract basic breakpoint type
#define   BP_MANUAL    0x00001000      // Permanent breakpoint
#define   BP_ONESHOT   0x00002000      // Stop and reset this bit
#define   BP_TEMP      0x00004000      // Reset this bit and continue
#define   BP_TRACE     0x00008000      // Used for hit trace
#define BP_SET         0x00010000      // Code INT3 is in memory, cmd is valid
#define BP_DISABLED    0x00020000      // Permanent breakpoint is disabled
#define BP_COND        0x00040000      // Conditional breakpoint
#define BP_PERIODICAL  0x00080000      // Periodical (pauses each passcount)
#define BP_ACCESSMASK  0x00E00000      // Access conditions (memory+hard)
#define   BP_READ      0x00200000      // Break on read memory access
#define   BP_WRITE     0x00400000      // Break on write memory access
#define   BP_EXEC      0x00800000      // Break on code execution
#define BP_BREAKMASK   0x03000000      // When to pause execution
#define   BP_NOBREAK   0x00000000      // No pause
#define   BP_CONDBREAK 0x01000000      // Pause if condition is true
#define   BP_BREAK     0x03000000      // Pause always
#define BP_LOGMASK     0x0C000000      // When to log value of expression
#define   BP_NOLOG     0x00000000      // Don't log expression
#define   BP_CONDLOG   0x04000000      // Log expression if condition is true
#define   BP_LOG       0x0C000000      // Log expression always
#define BP_ARGMASK     0x30000000      // When to log arguments of a function
#define   BP_NOARG     0x00000000      // Don't log arguments
#define   BP_CONDARG   0x10000000      // Log arguments if condition is true
#define   BP_ARG       0x30000000      // Log arguments always
#define BP_RETMASK     0xC0000000      // When to log return value of a function
#define   BP_NORET     0x00000000      // Don't log return value
#define   BP_CONDRET   0x40000000      // Log return value if condition is true
#define   BP_RET       0xC0000000      // Log return value always
#define BP_MANMASK (BP_PERIODICAL|BP_BREAKMASK|BP_LOGMASK|BP_ARGMASK|BP_RETMASK)
#define BP_CONFIRM     TY_CONFIRMED    // Internal OllyDbg use
// Search-related types (used in t_search).
#define SE_ORIGIN      0x00010000      // Search origin
#define SE_STRING      0x00020000      // Data contains string address
#define SE_FLOAT       0x00040000      // Data contains floating constant
#define SE_GUID        0x00080000      // Data contains GUID
#define SE_CONST       0x01000000      // Constant, not referencing command
// Source-related types (used in t_source).
#define SRC_ABSENT     0x00010000      // Source file is absent
// Namelist-related types (used in t_namelist).
#define NL_EORD        0x00010000      // Associated export ordinal available
#define NL_IORD        0x00020000      // Associated import ordinal available

typedef struct t_sorthdr {             // Header of sorted data item
  ulong          addr;                 // Base address of the entry
  ulong          size;                 // Size of the entry
  ulong          type;                 // Type and address extension, TY_xxx
} t_sorthdr;

typedef struct t_sorthdr_nosize {      // Header of SDM_NOSIZE item
  ulong          addr;                 // Base address of the entry
} t_sorthdr_nosize;

typedef int  SORTFUNC(const t_sorthdr *,const t_sorthdr *,const int);
typedef void DESTFUNC(t_sorthdr *);

#define AUTOARRANGE    ((SORTFUNC *)1) // Autoarrangeable sorted data

#define NBLOCK         2048            // Max number of data blocks
#define BLOCKSIZE      1048576         // Size of single data block, bytes

typedef struct t_sorted {              // Descriptor of sorted data
  int            n;                    // Actual number of entries
  int            nmax;                 // Maximal number of entries
  ulong          itemsize;             // Size of single entry
  int            mode;                 // Storage mode, set of SDM_xxx
  void           *data;                // Sorted data, NULL if SDM_INDEXED
  void           **block;              // NBLOCK sorted data blocks, or NULL
  int            nblock;               // Number of allocated blocks
  ulong          version;              // Changes on each modification
  void           **dataptr;            // Pointers to data, sorted by address
  int            selected;             // Index of selected entry
  ulong          seladdr;              // Base address of selected entry
  ulong          selsubaddr;           // Subaddress of selected entry
  SORTFUNC       *sortfunc;            // Function which sorts data or NULL
  DESTFUNC       *destfunc;            // Destructor function or NULL
  int            sort;                 // Sorting criterium (column)
  int            sorted;               // Whether indexes are sorted
  int            *sortindex;           // Indexes, sorted by criterium
} t_sorted;

stdapi (void)    Destroysorteddata(t_sorted *sd);
stdapi (int)     Createsorteddata(t_sorted *sd,ulong itemsize,int nexp,
                   SORTFUNC *sortfunc,DESTFUNC *destfunc,int mode);
stdapi (void)    Deletesorteddata(t_sorted *sd,ulong addr,ulong subaddr);
stdapi (int)     Deletesorteddatarange(t_sorted *sd,ulong addr0,ulong addr1);
stdapi (void *)  Addsorteddata(t_sorted *sd,void *item);
stdapi (int)     Replacesorteddatarange(t_sorted *sd,void *data,int n,
                   ulong addr0,ulong addr1);
stdapi (void)    Renumeratesorteddata(t_sorted *sd);
stdapi (int)     Confirmsorteddata(t_sorted *sd,int confirm);
stdapi (int)     Deletenonconfirmedsorteddata(t_sorted *sd);
stdapi (void)    Unmarknewsorteddata(t_sorted *sd);
stdapi (void *)  Findsorteddata(t_sorted *sd,ulong addr,ulong subaddr);
stdapi (void *)  Findsorteddatarange(t_sorted *sd,ulong addr0,ulong addr1);
stdapi (int)     Findsortedindexrange(t_sorted *sd,ulong addr0,ulong addr1);
stdapi (void *)  Getsortedbyindex(t_sorted *sd,int index);
stdapi (int)     Sortsorteddata(t_sorted *sd,int sort);
stdapi (void *)  Getsortedbyselection(t_sorted *sd,int index);
stdapi (int)     Issortedinit(t_sorted *sd);


////////////////////////////////////////////////////////////////////////////////
///////////////////////// SORTED DATA WINDOWS (TABLES) /////////////////////////

#define NBAR           17              // Max allowed number of segments in bar

#define BAR_FLAT       0x00000000      // Flat segment
#define BAR_BUTTON     0x00000001      // Segment sends WM_USER_BAR
#define BAR_SORT       0x00000002      // Segment re-sorts sorted data
#define BAR_DISABLED   0x00000004      // Bar segment disabled
#define BAR_NORESIZE   0x00000008      // Bar column cannot be resized
#define BAR_SHIFTSEL   0x00000010      // Selection shifted 1/2 char to left
#define BAR_WIDEFONT   0x00000020      // Twice as wide characters
#define BAR_SEP        0x00000040      // Treat '|' as separator
#define BAR_ARROWS     0x00000080      // Arrows if segment is shifted
#define BAR_PRESSED    0x00000100      // Bar segment pressed, used internally
#define BAR_SPMASK     0x0000F000      // Mask to extract speech type
#define   BAR_SPSTD    0x00000000      // Standard speech with all conversions
#define   BAR_SPASM    0x00001000      // Disassembler-oriented speech
#define   BAR_SPEXPR   0x00002000      // Expression-oriented speech
#define   BAR_SPEXACT  0x00003000      // Pass to speech engine as is
#define   BAR_SPELL    0x00004000      // Text, spell symbol by symbol
#define   BAR_SPHEX    0x00005000      // Hexadecimal, spell symbol by symbol
#define   BAR_SPNONE   0x0000F000      // Column is excluded from speech

typedef struct t_bar {                 // Descriptor of columns in table window
  // These variables must be filled before table window is created.
  int            nbar;                 // Number of columns
  int            visible;              // Bar visible
  wchar_t        *name[NBAR];          // Column names (may be NULL)
  wchar_t        *expl[NBAR];          // Explanations of columns
  int            mode[NBAR];           // Combination of bits BAR_xxx
  int            defdx[NBAR];          // Default widths of columns, chars
  // These variables are initialized by window creation function.
  int            dx[NBAR];             // Actual widths of columns, pixels
  int            captured;             // One of CAPT_xxx
  int            active;               // Info about where mouse was captured
  int            scrollvx;             // X scrolling speed
  int            scrollvy;             // Y scrolling speed
  int            prevx;                // Previous X mouse coordinate
  int            prevy;                // Previous Y mouse coordinate
} t_bar;

#define TABLE_USERDEF  0x00000001      // User-drawn table
#define TABLE_STDSCR   0x00000002      // User-drawn but standard scrolling
#define TABLE_SIMPLE   0x00000004      // Non-sorted, address is line number
#define TABLE_DIR      0x00000008      // Bottom-to-top table
#define TABLE_COLSEL   0x00000010      // Column-wide selection
#define TABLE_BYTE     0x00000020      // Allows for bytewise scrolling
#define TABLE_FASTSEL  0x00000040      // Update when selection changes
#define TABLE_RIGHTSEL 0x00000080      // Right click can select items
#define TABLE_RFOCUS   0x00000100      // Right click sets focus
#define TABLE_NOHSCR   0x00000200      // Table contains no horizontal scroll
#define TABLE_NOVSCR   0x00000400      // Table contains no vertical scroll
#define TABLE_NOBAR    0x00000800      // Bar is always hidden
#define TABLE_STATUS   0x00001000      // Table contains status bar
#define TABLE_MMOVX    0x00002000      // Table is moveable by mouse in X
#define TABLE_MMOVY    0x00004000      // Table is moveable by mouse in Y
#define TABLE_WANTCHAR 0x00008000      // Table processes characters
#define TABLE_SAVEAPP  0x00010000      // Save appearance to .ini
#define TABLE_SAVEPOS  0x00020000      // Save position to .ini
#define TABLE_SAVECOL  0x00040000      // Save width of columns to .ini
#define TABLE_SAVESORT 0x00080000      // Save sort criterium to .ini
#define TABLE_SAVECUST 0x00100000      // Save table-specific data to .ini
#define TABLE_GRAYTEXT 0x00200000      // Text in table is grayed
#define TABLE_NOGRAY   0x00400000      // Text in pane is never grayed
#define TABLE_UPDFOCUS 0x00800000      // Update frame pane on focus change
#define TABLE_AUTOUPD  0x01000000      // Table allows periodical autoupdate
#define TABLE_SYNTAX   0x02000000      // Table allows syntax highlighting
#define TABLE_PROPWID  0x04000000      // Column width means proportional width
#define TABLE_INFRAME  0x10000000      // Table belongs to the frame window
#define TABLE_BORDER   0x20000000      // Table has sunken border
#define TABLE_KEEPOFFS 0x80000000      // Keep xshift, offset, colsel

#define TABLE_MOUSEMV  (TABLE_MMOVX|TABLE_MMOVY)
#define TABLE_SAVEALL (TABLE_SAVEAPP|TABLE_SAVEPOS|TABLE_SAVECOL|TABLE_SAVESORT)

#define DRAW_COLOR     0x0000001F      // Mask to extract colour/bkgnd index
// Direct colour/background pairs.
#define   DRAW_NORMAL  0x00000000      // Normal text
#define   DRAW_HILITE  0x00000001      // Highlighted text
#define   DRAW_GRAY    0x00000002      // Grayed text
#define   DRAW_EIP     0x00000003      // Actual EIP
#define   DRAW_BREAK   0x00000004      // Unconditional breakpoint
#define   DRAW_COND    0x00000005      // Conditional breakpoint
#define   DRAW_BDIS    0x00000006      // Disabled breakpoint
#define   DRAW_IPBREAK 0x00000007      // Breakpoint at actual EIP
#define   DRAW_AUX     0x00000008      // Auxiliary colours
#define   DRAW_SELUL   0x00000009      // Selection and underlining
// Indirect pairs used to highlight commands.
#define   DRAW_PLAIN   0x0000000C      // Plain commands
#define   DRAW_JUMP    0x0000000D      // Unconditional jump commands
#define   DRAW_CJMP    0x0000000E      // Conditional jump commands
#define   DRAW_PUSHPOP 0x0000000F      // PUSH/POP commands
#define   DRAW_CALL    0x00000010      // CALL commands
#define   DRAW_RET     0x00000011      // RET commands
#define   DRAW_FPU     0x00000012      // FPU, MMX, 3DNow! and SSE commands
#define   DRAW_SUSPECT 0x00000013      // Bad, system and privileged commands
#define   DRAW_FILL    0x00000014      // Filling commands
#define   DRAW_MOD     0x00000015      // Modified commands
// Indirect pairs used to highlight operands.
#define   DRAW_IREG    0x00000018      // General purpose registers
#define   DRAW_FREG    0x00000019      // FPU, MMX and SSE registers
#define   DRAW_SYSREG  0x0000001A      // Segment and system registers
#define   DRAW_STKMEM  0x0000001B      // Memory accessed over ESP or EBP
#define   DRAW_MEM     0x0000001C      // Any other memory
#define   DRAW_MCONST  0x0000001D      // Constant pointing to memory
#define   DRAW_CONST   0x0000001E      // Any other constant
#define DRAW_APP       0x00000060      // Mask to extract appearance
#define   DRAW_TEXT    0x00000000      // Plain text
#define   DRAW_ULTEXT  0x00000020      // Underlined text
#define   DRAW_GRAPH   0x00000060      // Graphics (text consists of G_xxx)
#define DRAW_SELECT    0x00000080      // Use selection background
#define DRAW_MASK      0x00000100      // Mask in use
#define DRAW_VARWIDTH  0x00000200      // Variable width possible
#define DRAW_EXTSEL    0x00000800      // Extend mask till end of column
#define DRAW_TOP       0x00001000      // Draw upper half of the two-line text
#define DRAW_BOTTOM    0x00002000      // Draw lower half of the two-line text
#define DRAW_INACTIVE  0x00004000      // Gray everything except hilited text
#define DRAW_RAWDATA   0x00008000      // Don't convert glyphs and multibytes
#define DRAW_NEW       0x00010000      // Use highlighted foreground

typedef struct t_drawheader {          // Draw descriptor for TABLE_USERDEF
  int            line;                 // Line in window
  int            n;                    // Total number of visible lines
  ulong          nextaddr;             // First address on next line, or 0
  // Following elements can be freely used by drawing routine. They do not
  // change between calls within one table.
  ulong          addr;                 // Custom data
  uchar          s[TEXTLEN];           // Custom data
} t_drawheader;

// Constants used for scrolling and selection.
#define MOVETOP        0x8000          // Move selection to top of table
#define MOVEBOTTOM     0x7FFF          // Move selection to bottom of table

#define DF_CACHESIZE   (-4)            // Request for draw cache size
#define DF_FILLCACHE   (-3)            // Request to fill draw cache
#define DF_FREECACHE   (-2)            // Request to free cached resources
#define DF_NEWROW      (-1)            // Request to start new row in window

// Reasons why t_table.tableselfunc() was called.
#define TSC_KEY        1               // Keyboard key pressed
#define TSC_MOUSE      2               // Selection changed by mouse
#define TSC_CALL       3               // Call to selection move function

typedef long TABFUNC(struct t_table *,HWND,UINT,WPARAM,LPARAM);
typedef int  UPDATEFUNC(struct t_table *);
typedef int  DRAWFUNC(wchar_t *,uchar *,int *,struct t_table *,
  t_sorthdr *,int,void *);
typedef void TABSELFUNC(struct t_table *,int,int);

typedef struct t_table {               // Window with sorted data and bar
  // These variables must be filled before table window is created.
  wchar_t        name[SHORTNAME];      // Name used to save/restore position
  int            mode;                 // Combination of bits TABLE_xxx
  t_sorted       sorted;               // Sorted data
  int            subtype;              // User-defined subtype
  t_bar          bar;                  // Description of bar
  int            bottomspace;          // Height of free space on the bottom
  int            minwidth;             // Minimal width of the table, pixels
  TABFUNC        *tabfunc;             // Custom message function or NULL
  UPDATEFUNC     *updatefunc;          // Data update function or NULL
  DRAWFUNC       *drawfunc;            // Drawing function
  TABSELFUNC     *tableselfunc;        // Callback indicating selection change
  t_menu         *menu;                // Menu descriptor
  // Table functions neither initialize nor use these variables.
  ulong          custommode;           // User-defined custom data
  void           *customdata;          // Pointer to more custom data
  // These variables are initialized and/or used by table functions.
  HWND           hparent;              // Handle of MDI container or NULL
  HWND           hstatus;              // Handle of status bar or NULL
  HWND           hw;                   // Handle of child table or NULL
  HWND           htooltip;             // Handle of tooltip window or NULL
  int            font;                 // Index of font used by window
  int            scheme;               // Colour scheme used by window
  int            hilite;               // Highlighting scheme used by window
  int            hscroll;              // Whether horizontal scroll visible
  int            xshift;               // Shift in X direction, pixels
  int            offset;               // First displayed row
  int            colsel;               // Column in TABLE_COLSEL window
  ulong          version;              // Version of sorted on last update
  ulong          timerdraw;            // Timer redraw is active (period, ms)
  RECT           rcprev;               // Temporary storage for old position
  int            rtback;               // Back step in run trace, 0 - actual
} t_table;

#define GWL_USR_TABLE  0               // Offset to pointer to t_table

// Custom messages.
#define WM_USER_CREATE (WM_USER+100)   // Table window is created
#define WM_USER_HSCR   (WM_USER+101)   // Update horizontal scroll
#define WM_USER_VSCR   (WM_USER+102)   // Update vertical scroll
#define WM_USER_MOUSE  (WM_USER+103)   // Mouse moves, set custom cursor
#define WM_USER_VINC   (WM_USER+104)   // Scroll contents of window by lines
#define WM_USER_VPOS   (WM_USER+105)   // Scroll contents of window by position
#define WM_USER_VBYTE  (WM_USER+106)   // Scroll contents of window by bytes
#define WM_USER_SETS   (WM_USER+107)   // Start selection in window
#define WM_USER_CNTS   (WM_USER+108)   // Continue selection in window
#define WM_USER_MMOV   (WM_USER+109)   // Move window's contents by mouse
#define WM_USER_MOVS   (WM_USER+110)   // Keyboard scrolling and selection
#define WM_USER_KEY    (WM_USER+111)   // Key pressed
#define WM_USER_BAR    (WM_USER+112)   // Message from bar segment as button
#define WM_USER_DBLCLK (WM_USER+113)   // Doubleclick in column
#define WM_USER_SELXY  (WM_USER+114)   // Get coordinates of selection
#define WM_USER_FOCUS  (WM_USER+115)   // Set focus to child of frame window
#define WM_USER_UPD    (WM_USER+116)   // Autoupdate contents of the window
#define WM_USER_MTAB   (WM_USER+117)   // Middle click on tab in tab parent
// Custom broadcasts and notifications.
#define WM_USER_CHGALL (WM_USER+132)   // Update all windows
#define WM_USER_CHGCPU (WM_USER+133)   // CPU thread has changed
#define WM_USER_CHGMEM (WM_USER+134)   // List of memory blocks has changed
#define WM_USER_BKUP   (WM_USER+135)   // Global backup is changed
#define WM_USER_FILE   (WM_USER+136)   // Query for file dump
#define WM_USER_NAMES  (WM_USER+137)   // Query for namelist window
#define WM_USER_SAVE   (WM_USER+138)   // Query for unsaved data
#define WM_USER_CLEAN  (WM_USER+139)   // End of process, close related windows
#define WM_USER_HERE   (WM_USER+140)   // Query for windows to restore
#define WM_USER_CLOSE  (WM_USER+141)   // Internal substitute for WM_CLOSE

#define KEY_ALT        0x04            // Alt key pressed
#define KEY_CTRL       0x02            // Ctrl key pressed
#define KEY_SHIFT      0x01            // Shift key pressed

// Control alignment modes for Createtablechild().
#define ALIGN_MASK     0xC000          // Mask to extract control alignment
#define   ALIGN_LEFT   0x0000          // Control doesn't move
#define   ALIGN_RIGHT  0x4000          // Control moves with right border
#define   ALIGN_WIDTH  0x8000          // Control resizes with right border
#define ALIGN_IDMASK   0x0FFF          // Mask to extract control ID

stdapi (void)    Processwmmousewheel(HWND hw,WPARAM wp);
stdapi (int)     Getcharacterwidth(t_table *pt,int column);
stdapi (void)    Defaultbar(t_table *pt);
stdapi (int)     Linecount(t_table *pt);
stdapi (int)     Gettabletext(t_table *pt,int row,int column,
                   wchar_t *text,uchar *tmask,int *tselect);
stdapi (int)     Gettableselectionxy(t_table *pt,int column,POINT *coord);
stdapi (int)     Maketableareavisible(t_table *pt,int column,
                   int x0,int y0,int x1,int y1);
stdapi (int)     Movetableselection(t_table *pt,int n);
stdapi (int)     Settableselection(t_table *pt,int selected);
stdapi (int)     Removetableselection(t_table *pt);
stdapi (void)    Updatetable(t_table *pt,int force);
stdapi (void)    Delayedtableredraw(t_table *pt);
stdapi (void)    Setautoupdate(t_table *pt,int autoupdate);
stdapi (HGLOBAL) Copytableselection(t_table *pt,int column);
stdapi (HGLOBAL) Copywholetable(t_table *pt,int compatible);
stdapi (HWND)    Createottablewindow(HWND hparent,t_table *pt,RECT *rpos);
stdapi (HWND)    Createtablewindow(t_table *pt,int nrow,int ncolumn,
                   HINSTANCE hi,wchar_t *icon,wchar_t *title);
stdapi (HWND)    Activatetablewindow(t_table *pt);
stdapi (HWND)    Createtablechild(t_table *pt,wchar_t *classname,wchar_t *name,
                   wchar_t *help,ulong style,int x,int y,int dx,int dy,
                   int idalign);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// FRAME AND TAB WINDOWS /////////////////////////////

#define BLK_NONE       0               // Mouse outside the dividing line
#define BLK_HDIV       1               // Divide horizontally
#define BLK_VDIV       2               // Divide vertically
#define BLK_TABLE      3               // Leaf that describes table window

typedef struct t_block {               // Block descriptor
  int            index;                // Index of pos record in the .ini file
  int            type;                 // One of BLK_xxx
  int            percent;              // Percent of block in left/top subblock
  int            offset;               // Offset of dividing line, pixels
  struct t_block *blk1;                // Top/left subblock, NULL if leaf
  int            minp1;                // Min size of 1st subblock, pixels
  int            maxc1;                // Max size of 1st subblock, chars, or 0
  struct t_block *blk2;                // Bottom/right subblock, NULL if leaf
  int            minp2;                // Min size of 2nd subblock, pixels
  int            maxc2;                // Max size of 2nd subblock, chars, or 0
  t_table        *table;               // Descriptor of table window
  wchar_t        tabname[SHORTNAME];   // Tab (tab window only)
  wchar_t        title[TEXTLEN];       // Title (tab window) or speech name
  wchar_t        status[TEXTLEN];      // Status (tab window only)
} t_block;

typedef struct t_frame {               // Descriptor of frame or tab window
  // These variables must be filled before frame window is created.
  wchar_t        name[SHORTNAME];      // Name used to save/restore position
  int            herebit;              // Must be 0 for plugins
  int            mode;                 // Combination of bits TABLE_xxx
  t_block        *block;               // Pointer to block tree
  t_menu         *menu;                // Menu descriptor (tab window only)
  int            scheme;               // Colour scheme used by window
  // These variables are initialized by frame creation function.
  HWND           hw;                   // Handle of MDI container or NULL
  HWND           htab;                 // Handle of tab control
  WNDPROC        htabwndproc;          // Original WndProc of tab control
  int            capturedtab;          // Tab captured on middle mouse click
  HWND           hstatus;              // Handle of status bar or NULL
  t_block        *active;              // Active table (has focus) or NULL
  t_block        *captured;            // Block that captured mouse or NULL
  int            captureoffset;        // Offset on mouse capture
  int            capturex;             // Mouse screen X coordinate on capture
  int            capturey;             // Mouse screen Y coordinate on capture
  wchar_t        title[TEXTLEN];       // Frame or tab window title
} t_frame;

stdapi (HWND)    Createframewindow(t_frame *pf,wchar_t *icon,wchar_t *title);
stdapi (void)    Updateframe(t_frame *pf,int redrawnow);
stdapi (t_table *) Getactiveframe(t_frame *pf);

stdapi (int)     Updatetabs(t_frame *pf);
stdapi (HWND)    Createtabwindow(t_frame *pf,wchar_t *icon,wchar_t *title);
stdapi (t_table *) Getactivetab(t_frame *pf);
stdapi (int)     Gettabcount(t_frame *pf,int *index);
stdapi (int)     Setactivetab(t_frame *pf,int index);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// FONTS AND GRAPHICS //////////////////////////////

#define FIXEDFONT      0               // Indices of fixed fonts used in tables
#define TERMINAL6      1               // Note: fonts may be changed by user!
#define FIXEDSYS       2
#define COURIERFONT    3
#define LUCIDACONS     4
#define FONT5          5
#define FONT6          6
#define FONT7          7

#define NFIXFONTS      8               // Total number of fixed fonts

#define BLACKWHITE     0               // Colour schemes used by OllyDbg
#define BLUEGOLD       1               // Note: colours may be changed by user!
#define SKYWIND        2
#define NIGHTSTARS     3
#define SCHEME4        4
#define SCHEME5        5
#define SCHEME6        6
#define SCHEME7        7

#define NSCHEMES       8               // Number of predefined colour schemes
#define NDRAW          32              // Number of fg/bg pairs in scheme

#define NOHILITE       0               // Highlighting schemes used by OllyDbg
#define XMASHILITE     1               // Note: colours may be changed by user!
#define JUMPHILITE     2
#define MEMHILITE      3
#define HILITE4        4
#define HILITE5        5
#define HILITE6        6
#define HILITE7        7

#define NHILITE        8               // Number of predefined hilite schemes

#define BLACK          0               // Indexes of colours used by OllyDbg
#define BLUE           1
#define GREEN          2
#define CYAN           3
#define RED            4
#define MAGENTA        5
#define BROWN          6
#define LIGHTGRAY      7
#define DARKGRAY       8
#define LIGHTBLUE      9
#define LIGHTGREEN     10
#define LIGHTCYAN      11
#define LIGHTRED       12
#define LIGHTMAGENTA   13
#define YELLOW         14
#define WHITE          15
#define MINT           16
#define SKYBLUE        17
#define IVORY          18
#define GRAY           19

#define NFIXCOLORS     20              // Number of colors fixed in OllyDbg
#define NCOLORS        (NFIXCOLORS+16) // Number of available colours

// Symbolic names for graphical characters. Any other graphical symbol is
// interpreted as a space. Use only symbols in range [0x01..0x3F], high bits
// are reserved for the future!
#define G_SPACE        0x01            // Space
#define G_SEP          0x02            // Thin separating line
#define G_POINT        0x03            // Point
#define G_BIGPOINT     0x04            // Big point
#define G_JMPDEST      0x05            // Jump destination
#define G_CALLDEST     0x06            // Call destination
#define G_QUESTION     0x07            // Question mark
#define G_JMPUP        0x10            // Jump upstairs
#define G_JMPOUT       0x11            // Jump to same location or outside
#define G_JMPDN        0x12            // Jump downstairs
#define G_SWUP         0x13            // Switch upstairs
#define G_SWBOTH       0x14            // Switch in both directions
#define G_SWDOWN       0x15            // Switch down
#define G_BEGIN        0x18            // Begin of procedure or scope
#define G_BODY         0x19            // Body of procedure or scope
#define G_ENTRY        0x1A            // Loop entry point
#define G_LEAF         0x1B            // Intermediate leaf on a tree
#define G_END          0x1C            // End of procedure or scope
#define G_SINGLE       0x1D            // Single-line scope
#define G_ENDBEG       0x1E            // End and begin of stack scope
#define G_PATHUP       0x21            // Jump path start upstairs
#define G_PATH         0x22            // Jump path through
#define G_PATHDN       0x23            // Jump path start downstairs
#define G_PATHUPDN     0x24            // Two-sided jump path start
#define G_THROUGHUP    0x25            // Jump entry upstairs
#define G_THROUGHDN    0x26            // Jump entry downstairs
#define G_PATHUPEND    0x27            // End of path upstairs
#define G_PATHDNEND    0x28            // End of path downstairs
#define G_PATHBIEND    0x29            // Two-sided end of path
#define G_THRUUPEND    0x2A            // Intermediate end upstairs
#define G_THRUDNEND    0x2B            // Intermediate end downstairs
#define G_ARRLEFT      0x2C            // Left arrow
// Graphical elements used to draw frames in the command help.
#define G_HL           0x30            // Horizontal line
#define G_LT           0x31            // Left top corner
#define G_CT           0x32            // Central top element
#define G_RT           0x33            // Right top corner
#define G_LM           0x34            // Left middle element
#define G_CM           0x35            // Central cross
#define G_RM           0x36            // Right middle element
#define G_LB           0x37            // Left bottom corner
#define G_CB           0x38            // Central bottom element
#define G_RB           0x39            // Right bottom corner
#define G_VL           0x3A            // Vertical line
#define G_LA           0x3B            // Horizontal line with left arrow
#define G_RA           0x3C            // Horizontal line with right arrow
#define G_DA           0x3D            // Vertical line with down arrow

typedef struct t_font {                // Font descriptor
  LOGFONT        logfont;              // System font description
  int            stockindex;           // Index for system stock fonts
  int            hadjtop;              // Height adjustment on top, pixels
  int            hadjbot;              // Height adjustment on bottom, pixels
  wchar_t        name[TEXTLEN];        // Internal font name
  HFONT          hfont;                // Font handle
  int            isstock;              // Don't destroy hfont, taken from stock
  int            isfullunicode;        // Whether UNICODE is fully supported
  int            width;                // Average font width
  int            height;               // Font height
} t_font;

typedef struct t_scheme {              // Descriptor of colour scheme
  wchar_t        name[TEXTLEN];        // Internal scheme name
  COLORREF       textcolor[NDRAW];     // Foreground colours (in DRAW_COLOR)
  COLORREF       bkcolor[NDRAW];       // Background colours (in DRAW_COLOR)
  int            hiliteoperands;       // Used only by highlighting schemes
  int            hilitemodified;       // Used only by highlighting schemes
  HBRUSH         bkbrush;              // Ordinary background brush
  HBRUSH         selbkbrush;           // Selected background brush
  HBRUSH         auxbrush;             // Auxiliary brush
  HPEN           graphpen;             // Pen for normal graphical elements
  HPEN           lopen;                // Pen for grayed graphical elements
  HPEN           hipen;                // Pen for hilited graphical elements
  HPEN           auxpen;               // Pen for auxiliary graphical elements
  HPEN           ulpen;                // Pen to underline text
} t_scheme;

stdapi (int)     Getmonitorrect(int x,int y,RECT *rc);
stdapi (void)    Sunkenframe(HDC dc,RECT *rc,int flags);
stdapi (int)     Findstockobject(ulong gdihandle,wchar_t *name,int nname);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// MEMORY FUNCTIONS ///////////////////////////////

// Mode bits used in calls to Readmemory(), Readmemoryex() and Writememory().
#define MM_REPORT      0x0000          // Display error message if unreadable
#define MM_SILENT      0x0001          // Don't display error message
#define MM_NORESTORE   0x0002          // Don't remove/set INT3 breakpoints
#define MM_PARTIAL     0x0004          // Allow less data than requested
#define MM_WRITETHRU   0x0008          // Write immediately to memory
#define MM_REMOVEINT3  0x0010          // Writememory(): remove INT3 breaks
#define MM_ADJUSTINT3  0x0020          // Writememory(): adjust INT3 breaks
#define MM_FAILGUARD   0x0040          // Fail if memory is guarded
// Mode bits used in calls to Readmemoryex().
#define MM_BPMASK      BP_ACCESSMASK   // Mask to extract memory breakpoints
#define   MM_BPREAD    BP_READ         // Fail if memory break on read is set
#define   MM_BPWRITE   BP_WRITE        // Fail if memory break on write is set
#define   MM_BPEXEC    BP_EXEC         // Fail if memory break on exec is set

// Special types of memory block.
#define MSP_NONE       0               // Not a special memory block
#define MSP_PEB        1               // Contains Process Environment Block
#define MSP_SHDATA     2               // Contains KUSER_SHARED_DATA
#define MSP_PROCPAR    3               // Contains Process Parameters
#define MSP_ENV        4               // Contains environment

typedef struct t_memory {              // Descriptor of memory block
  ulong          base;                 // Base address of memory block
  ulong          size;                 // Size of memory block
  ulong          type;                 // Service information, TY_xxx+MEM_xxx
  int            special;              // Extension of type, one of MSP_xxx
  ulong          owner;                // Address of owner of the memory
  ulong          initaccess;           // Initial read/write access
  ulong          access;               // Actual status and read/write access
  ulong          threadid;             // Block belongs to this thread or 0
  wchar_t        sectname[SHORTNAME];  // Null-terminated section name
  uchar          *copy;                // Copy used in CPU window or NULL
  uchar          *decode;              // Decoding information or NULL
} t_memory;

stdapi (void)    Flushmemorycache(void);
stdapi (ulong)   Readmemory(void *buf,ulong addr,ulong size,int mode);
stdapi (ulong)   Readmemoryex(void *buf,ulong addr,ulong size,int mode,
                   ulong threadid);
stdapi (ulong)   Writememory(const void *buf,ulong addr,ulong size,int mode);
stdapi (t_memory *) Findmemory(ulong addr);
stdapi (uchar *) Finddecode(ulong addr,ulong *psize);
stdapi (int)     Guardmemory(ulong base,ulong size,int guard);
stdapi (int)     Listmemory(void);
stdapi (HGLOBAL) Copymemoryhex(ulong addr,ulong size);
stdapi (int)     Pastememoryhex(ulong addr,ulong size,
                   int ensurebackup,int removeanalysis);
stdapi (int)     Editmemory(HWND hparent,ulong addr,ulong size,
                   int ensurebackup,int removeanalysis,int x,int y,int font);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// JUMP DATA ///////////////////////////////////

// Types of recognized jumps and calls.
#define JT_TYPE        0x000F          // Mask to extract data type
#define   JT_UNDEF     0x0000          // End of jump table
#define   JT_JUMP      0x0001          // Unconditional jump
#define   JT_COND      0x0002          // Conditional jump
#define   JT_SWITCH    0x0003          // Jump via switch table
#define   JT_RET       0x0004          // RET misused as jump
#define   JT_CALL      0x0005          // Call
#define   JT_SWCALL    0x0006          // Call via switch table
#define   JT_NETJUMP   0x0008          // Unconditional jump in CIL code
#define   JT_NETCOND   0x0009          // Conditional jump in CIL code
#define   JT_NETSW     0x000A          // Switch jump in CIL code
// Used as flag to Addjump, absent in the jump table.
#define JT_NOSORT      0x8000          // Do not sort data implicitly

// Note that these macros work both with t_jmp and t_jmpcall.
#define Isjump(jmp)    (((jmp)->type>=JT_JUMP && (jmp)->type<=JT_RET) ||       \
                       ((jmp)->type>=JT_NETJUMP && (jmp)->type<=JT_NETSW))
#define Iscall(jmp)    ((jmp)->type==JT_CALL || (jmp)->type==JT_SWCALL)

typedef struct t_jmp {                 // Descriptor of recognized jump or call
  ulong          from;                 // Address of jump/call command
  ulong          dest;                 // Adress of jump/call destination
  uchar          type;                 // Jump/call type, one of JT_xxx
} t_jmp;

typedef struct t_exe {                 // Description of executable module
  ulong          base;                 // Module base
  ulong          size;                 // Module size
  int            adjusted;             // Whether base is already adjusted
  wchar_t        path[MAXPATH];        // Full module path
} t_exe;

typedef struct t_jmpdata {             // Jump table
  ulong          modbase;              // Base of module owning jump table
  ulong          modsize;              // Size of module owning jump table
  t_jmp          *jmpdata;             // Jump data, sorted by source
  int            *jmpindex;            // Indices to jmpdata, sorted by dest
  int            maxjmp;               // Total number of elements in arrays
  int            njmp;                 // Number of used elements in arrays
  int            nsorted;              // Number of sorted elements in arrays
  int            dontsort;             // Do not sort data implicitly
  t_exe          *exe;                 // Pointed modules, unsorted
  int            maxexe;               // Allocated number of elements in exe
  int            nexe;                 // Number of used elements in exe
} t_jmpdata;

typedef struct t_jmpcall {             // Descriptor of found jump or call
  ulong          addr;                 // Source or destination address
  union {
    int          type;                 // Jump/call type, one of JT_xxx
    ulong        swcase;               // First switch case
  };
} t_jmpcall;

stdapi (int)     Addjump(t_jmpdata *pdat,ulong from,ulong dest,int type);
stdapi (void)    Sortjumpdata(t_jmpdata *pdat);
stdapi (t_jmp *) Findjumpfrom(ulong from);
stdapi (int)     Findlocaljumpsto(ulong dest,ulong *buf,int nbuf);
stdapi (int)     Findlocaljumpscallsto(ulong dest,t_jmpcall *jmpcall,
                   int njmpcall);
stdapi (int)     Arelocaljumpscallstorange(ulong addr0,ulong addr1);
stdapi (int)     Findglobalcallsto(ulong dest,ulong *buf,int nbuf);
stdapi (int)     Findglobaljumpscallsto(ulong dest,t_jmpcall *jmpcall,
                   int njmpcall);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// SETS OF RANGES ////////////////////////////////

typedef struct t_range {
  ulong        rmin;                   // Low range limit
  ulong        rmax;                   // High range limit (INCLUDED!)
} t_range;

stdapi (int)     Initset(t_range *set,ulong nmax);
stdapi (int)     Fullrange(t_range *set);
stdapi (int)     Emptyrange(t_range *set);
stdapi (ulong)   Getsetcount(const t_range *set);
stdapi (int)     Getrangecount(const t_range *set);
stdapi (int)     Isinset(const t_range *set,ulong value);
stdapi (int)     Getrangebymember(const t_range *set,ulong value,
                   ulong *rmin,ulong *rmax);
stdapi (int)     Getrangebyindex(const t_range *set,int index,
                   ulong *rmin,ulong *rmax);
stdapi (int)     Addrange(t_range *set,ulong rmin,ulong rmax);
stdapi (int)     Removerange(t_range *set,ulong rmin,ulong rmax);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// NESTED DATA //////////////////////////////////

// General item types related to nested data.
#define ND_LEVELMASK   0x000000FF      // Mask to extract nesting level
#define ND_OPENTOP     0x00000100      // Range is open on the top
#define ND_OPENBOTTOM  0x00000200      // Range is open on the bottom
#define ND_NESTHILITE  0x00000400      // Highlighted bracket
#define ND_NESTGRAY    0x00000800      // Grayed bracket
// Types specific to loop data t_loopnest:
#define ND_MOREVARS    0x00010000      // List of loop variables overflowed

#define MAXNEST        32              // Limit of displayed nesting levels

typedef struct t_nesthdr {             // Header of nested data range
  ulong          addr0;                // First address occupied by range
  ulong          addr1;                // Last occupied address (included!)
  ulong          type;                 // Level and user-defined type, TY_xxx
  ulong          aprev;                // First address of previous range
} t_nesthdr;

typedef void NDDEST(t_nesthdr *);

typedef struct t_nested {              // Descriptor of nested data
  int            n;                    // Actual number of elements
  int            nmax;                 // Maximal number of elements
  ulong          itemsize;             // Size of single element
  void           *data;                // Ordered nested data
  ulong          version;              // Changes on each modification
  NDDEST         *destfunc;            // Destructor function or NULL
} t_nested;

stdapi (void)    Destroynesteddata(t_nested *nd);
stdapi (int)     Createnesteddata(t_nested *nd,ulong itemsize,int nexp,
                   NDDEST *destfunc);
stdapi (void *)  Addnesteddata(t_nested *nd,void *item);
stdapi (void)    Deletenestedrange(t_nested *nd,ulong addr0,ulong addr1);
stdapi (int)     Getnestingpattern(t_nested *nd,ulong addr,wchar_t *pat,
                   int npat,uchar *mask,int showentry,int *isend);
stdapi (int)     Getnestingdepth(t_nested *nd,ulong addr);
stdapi (void *)  Findnesteddata(t_nested *nd,ulong addr,int level);

stdapi (void *)  Nesteddatatoudd(t_nested *nd,ulong base,ulong *datasize);
stdapi (int)     Uddtonesteddata(t_nested *nd,void *data,ulong base,ulong size);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// MODULES ////////////////////////////////////

#define SHT_MERGENEXT  0x00000001      // Merge section with the next

#define NCALLMOD       24              // Max number of saved called modules

// .NET stream identifiers. Don't change the order and the values of the
// first three items (NS_STRINGS, NS_GUID and NS_BLOB)!
#define NS_STRINGS     0               // Stream with ASCII strings
#define NS_GUID        1               // Stream with GUIDs
#define NS_BLOB        2               // Data referenced by MetaData
#define NS_US          3               // Stream with UNICODE strings
#define NS_META        4               // Stream with MetaData tables

#define NETSTREAM      5               // Number of default .NET streams

// Indices of .NET MetaData tables.
#define MDT_MODULE     0               // Module table
#define MDT_TYPEREF    1               // TypeRef table
#define MDT_TYPEDEF    2               // TypeDef table
#define MDT_FIELDPTR   3               // FieldPtr table
#define MDT_FIELD      4               // Field table
#define MDT_METHODPTR  5               // MethodPtr table
#define MDT_METHOD     6               // MethodDef table
#define MDT_PARAMPTR   7               // ParamPtr table
#define MDT_PARAM      8               // Param table
#define MDT_INTERFACE  9               // InterfaceImpl table
#define MDT_MEMBERREF  10              // MemberRef table
#define MDT_CONSTANT   11              // Constant table
#define MDT_CUSTATTR   12              // CustomAttribute table
#define MDT_MARSHAL    13              // FieldMarshal table
#define MDT_DECLSEC    14              // DeclSecurity table
#define MDT_CLASSLAY   15              // ClassLayout table
#define MDT_FIELDLAY   16              // FieldLayout table
#define MDT_SIGNATURE  17              // StandAloneSig table
#define MDT_EVENTMAP   18              // EventMap table
#define MDT_EVENTPTR   19              // EventPtr table
#define MDT_EVENT      20              // Event table
#define MDT_PROPMAP    21              // PropertyMap table
#define MDT_PROPPTR    22              // PropertyPtr table
#define MDT_PROPERTY   23              // Property table
#define MDT_METHSEM    24              // MethodSemantics table
#define MDT_METHIMPL   25              // MethodImpl table
#define MDT_MODREF     26              // ModuleRef table
#define MDT_TYPESPEC   27              // TypeSpec table
#define MDT_IMPLMAP    28              // ImplMap table
#define MDT_RVA        29              // FieldRVA table
#define MDT_ENCLOG     30              // ENCLog table
#define MDT_ENCMAP     31              // ENCMap table
#define MDT_ASSEMBLY   32              // Assembly table
#define MDT_ASMPROC    33              // AssemblyProcessor table
#define MDT_ASMOS      34              // AssemblyOS table
#define MDT_ASMREF     35              // AssemblyRef table
#define MDT_REFPROC    36              // AssemblyRefProcessor table
#define MDT_REFOS      37              // AssemblyRefOS table
#define MDT_FILE       38              // File table
#define MDT_EXPORT     39              // ExportedType table
#define MDT_RESOURCE   40              // ManifestResource table
#define MDT_NESTED     41              // NestedClass table
#define MDT_GENPARM    42              // GenericParam table
#define MDT_METHSPEC   43              // MethodSpec table
#define MDT_CONSTR     44              // GenericParamConstraint table
#define MDT_UNUSED     63              // Used only in midx[]

#define MDTCOUNT       64              // Number of .NET MetaData tables

typedef struct t_secthdr {             // Extract from IMAGE_SECTION_HEADER
  wchar_t        sectname[12];         // Null-terminated section name
  ulong          base;                 // Address of section in memory
  ulong          size;                 // Size of section loaded into memory
  ulong          type;                 // Set of SHT_xxx
  ulong          fileoffset;           // Offset of section in file
  ulong          rawsize;              // Size of section in file
  ulong          characteristics;      // Set of IMAGE_SCN_xxx
} t_secthdr;

typedef struct t_premod {              // Preliminary module descriptor
  ulong          base;                 // Base address of the module
  ulong          size;                 // Size of module or 1
  ulong          type;                 // Service information, TY_xxx+MOD_xxx
  ulong          entry;                // Address of <ModuleEntryPoint> or 0
  wchar_t        path[MAXPATH];        // Full name of the module
} t_premod;

typedef struct t_netstream {           // Location of default .NET stream
  ulong          base;                 // Base address in memory
  ulong          size;                 // Stream size, bytes
} t_netstream;

typedef struct t_metadata {            // Descriptor of .NET MetaData table
  ulong          base;                 // Location in memory or NULL if absent
  ulong          rowcount;             // Number of rows or 0 if absent
  ulong          rowsize;              // Size of single row, bytes, or 0
  ushort         nameoffs;             // Offset of name field
  ushort         namesize;             // Size of name or 0 if absent
} t_metadata;

typedef struct t_module {              // Descriptor of executable module
  ulong          base;                 // Base address of module
  ulong          size;                 // Size of memory occupied by module
  ulong          type;                 // Service information, TY_xxx+MOD_xxx
  wchar_t        modname[SHORTNAME];   // Short name of the module
  wchar_t        path[MAXPATH];        // Full name of the module
  wchar_t        version[TEXTLEN];     // Version of executable file
  ulong          fixupbase;            // Base of image in executable file
  ulong          codebase;             // Base address of module code block
  ulong          codesize;             // Size of module code block
  ulong          entry;                // Address of <ModuleEntryPoint> or 0
  ulong          sfxentry;             // Address of SFX-packed entry or 0
  ulong          winmain;              // Address of WinMain or 0
  ulong          database;             // Base address of module data block
  ulong          edatabase;            // Base address of export data table
  ulong          edatasize;            // Size of export data table
  ulong          idatatable;           // Base address of import data table
  ulong          iatbase;              // Base of Import Address Table
  ulong          iatsize;              // Size of IAT
  ulong          relocbase;            // Base address of relocation table
  ulong          relocsize;            // Size of relocation table
  ulong          resbase;              // Base address of resources
  ulong          ressize;              // Size of resources
  ulong          tlsbase;              // Base address of TLS directory table
  ulong          tlssize;              // Size of TLS directory table
  ulong          tlscallback;          // Address of first TLS callback or 0
  ulong          netentry;             // .NET entry (MOD_NETAPP only)
  ulong          clibase;              // .NET CLI header base (MOD_NETAPP)
  ulong          clisize;              // .NET CLI header base (MOD_NETAPP)
  t_netstream    netstr[NETSTREAM];    // Locations of default .NET streams
  t_metadata     metadata[MDTCOUNT];   // Descriptors of .NET MetaData tables
  ulong          sfxbase;              // Base of memory block with SFX
  ulong          sfxsize;              // Size of memory block with SFX
  ulong          rawhdrsize;           // Size of PE header in file
  ulong          memhdrsize;           // Size of PE header in memory
  int            nsect;                // Number of sections in the module
  t_secthdr      *sect;                // Extract from section headers
  int            nfixup;               // Number of 32-bit fixups
  ulong          *fixup;               // Array of 32-bit fixups
  t_jmpdata      jumps;                // Jumps and calls from this module
  t_nested       loopnest;             // Loop brackets
  t_nested       argnest;              // Call argument brackets
  t_simple       predict;              // Predicted ESP, EBP & results (sd_pred)
  t_sorted       strings;              // Resource strings (t_string)
  int            saveudd;              // UDD-relevant data is changed
  int            ncallmod;             // No. of called modules (max. NCALLMOD)
  wchar_t        callmod[NCALLMOD][SHORTNAME]; // List of called modules
} t_module;

// Keep t_aqueue identical with the header of t_module!
typedef struct t_aqueue {              // Descriptor of module to be analysed
  ulong          base;                 // Base address of module
  ulong          size;                 // Size of memory occupied by module
  ulong          type;                 // Service information, TY_xxx+MOD_xxx
} t_aqueue;

stdapi (t_module *) Findmodule(ulong addr);
stdapi (t_module *) Findmodulebyname(wchar_t *shortname);
stdapi (t_module *) Findmainmodule(void);
stdapi (int)     Issystem(ulong addr);
stdapi (ulong *) Findfixup(t_module *pmod,ulong addr);
stdapi (ulong)   Findfileoffset(t_module *pmod,ulong addr);
stdapi (int)     Decoderange(wchar_t *s,ulong addr,ulong size);
stdapi (int)     Getexeversion(wchar_t *path,wchar_t *version);
stdapi (int)     Getexportfrommemory(ulong addr,wchar_t *s);


////////////////////////////////////////////////////////////////////////////////
////////////////////////// LIST OF DEBUGGEE'S WINDOWS //////////////////////////

typedef struct t_window {              // Description of window
  ulong          hwnd;                 // Window's handle
  ulong          dummy;                // Must be 1
  ulong          type;                 // Type of window, TY_xxx+WN_xxx
  ulong          parenthw;             // Handle of parent or 0
  ulong          winproc;              // Address of WinProc or 0
  ulong          threadid;             // ID of the owning thread
  ulong          exstyle;              // Extended style
  ulong          style;                // Style
  ulong          id;                   // Identifier
  ulong          classproc;            // Address of default (class) WinProc
  RECT           windowrect;           // Window position, screen coordinates
  RECT           clientrect;           // Client position, screen coordinates
  int            child;                // Index of next child
  int            sibling;              // Index of next sibling
  int            byparent;             // Index when sorted by parent
  int            level;                // Level in genealogy (0: topmost)
  wchar_t        title[TEXTLEN];       // Window's title or text
  wchar_t        classname[TEXTLEN];   // Class name
  wchar_t        tree[MAXNEST];        // Tree display
} t_window;


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// NAMELIST WINDOWS ///////////////////////////////

// Types of action in WM_USER_NAMES broadcasts (parameter wp).
#define NA_FIND        0               // Check if namelist is already open
#define NA_UPDATE      1               // Update namelist
#define NA_CLOSE       2               // Close namelist
#define NA_CLOSEALL    3               // Close all namelists

typedef struct t_namecast {            // Structure passed on broadcast
  ulong          base;                 // Module base, 0 - list of all names
  t_table        *table;               // Filled when broadcast stops
} t_namecast;

typedef struct t_namelist {            // Element of namelist sorted data
  ulong          addr;                 // Base address of the entry
  ulong          size;                 // Size of the entry, always 1
  ulong          type;                 // Type & addr extension, TY_xxx+NL_xxx
} t_namelist;


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// RESOURCES ///////////////////////////////////

typedef struct t_string {              // Descriptor of resource string
  ulong          id;                   // Identifier associated with the string
  ulong          dummy;                // Always 1
  ulong          addr;                 // Address of string in memory
  ulong          count;                // String size, UNICODE characters!
  int            language;             // Language, one of LANG_xxx
} t_string;

stdapi (int)     Getmodulestring(t_module *pm,ulong id,wchar_t *s);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// UDD FILES ///////////////////////////////////

#define SAVEMAGIC      0xFEDCBA98      // Indicator of savearea validity

// Attention, for the sake of the compatibility between the different OllyDbg
// versions, never, ever change existing elements, only add new!
typedef struct t_savearea {
  ulong          magic;                // Validity marker, must be SAVEMAGIC
  wchar_t        dumpstr[SHORTNAME];   // Last structure decoding in dump
} t_savearea;


////////////////////////////////////////////////////////////////////////////////
//////////////////////////// THREADS AND REGISTERS /////////////////////////////

#define NREG           8               // Number of registers (of any type)
#define NSEG           6               // Number of valid segment registers
#define NHARD          4               // Number of hardware breakpoints

// Event ignoring list.
#define IGNO_INT3      0x00000001      // Ignore INT3 breakpoint
#define IGNO_ACCESS    0x00000002      // Ignore memory access violation
#define IGNO_HW        0x00000004      // Ignore hardware breakpoint

// Register displaying mode.
#define RDM_MODE       0x0000000F      // Mask to extract display mode
#define   RDM_FPU      0x00000000      // Decode FPU registers as floats
#define   RDM_MMX      0x00000001      // Decode FPU registers as MMX
#define   RDM_3DN      0x00000002      // Decode FPU registers as 3DNow!
#define   RDM_DBG      0x00000003      // Decode debug registers instead of FPU
#define RDM_SSEMODE    0x000000F0      // Mask to extract SSE decoding mode
#define   RDM_SSEI32   0x00000000      // Decode SSE as 4x32-bit hex numbers
#define   RDM_SSEF32   0x00000010      // Decode SSE as 4x32-bit floats
#define   RDM_SSEF64   0x00000020      // Decode SSE as 2x64-bit floats

// Status of registers.
#define RV_MODIFIED    0x00000001      // Update CONTEXT before run
#define RV_USERMOD     0x00000002      // Registers modified by user
#define RV_SSEVALID    0x00000004      // Whether SSE registers are valid
#define RV_SSEMOD      0x00000008      // Update SSE registers before run
#define RV_ERRVALID    0x00000010      // Whether last thread error is valid
#define RV_ERRMOD      0x00000020      // Update last thread error before run
#define RV_MEMVALID    0x00000040      // Whether memory fields are valid
#define RV_DBGMOD      0x00000080      // Update debugging registers before run

// CPU flags.
#define FLAG_C         0x00000001      // Carry flag
#define FLAG_P         0x00000004      // Parity flag
#define FLAG_A         0x00000010      // Auxiliary carry flag
#define FLAG_Z         0x00000040      // Zero flag
#define FLAG_S         0x00000080      // Sign flag
#define FLAG_T         0x00000100      // Single-step trap flag
#define FLAG_D         0x00000400      // Direction flag
#define FLAG_O         0x00000800      // Overflow flag

// Attention, number of memory fields is limited by the run trace!
#define NMEMFIELD      2               // Number of memory fields in t_reg

typedef struct t_memfield {            // Descriptor of memory field
  ulong          addr;                 // Address of data in memory
  ulong          size;                 // Data size (0 - no data)
  uchar          data[16];             // Data
} t_memfield;

// Thread registers.
typedef struct t_reg {                 // Excerpt from context
  ulong          status;               // Status of registers, set of RV_xxx
  ulong          threadid;             // ID of thread that owns registers
  ulong          ip;                   // Instruction pointer (EIP)
  ulong          r[NREG];              // EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI
  ulong          flags;                // Flags
  ulong          s[NSEG];              // Segment registers ES,CS,SS,DS,FS,GS
  ulong          base[NSEG];           // Segment bases
  ulong          limit[NSEG];          // Segment limits
  uchar          big[NSEG];            // Default size (0-16, 1-32 bit)
  uchar          dummy[2];             // Reserved, used for data alignment
  int            top;                  // Index of top-of-stack
  long double    f[NREG];              // Float registers, f[top] - top of stack
  uchar          tag[NREG];            // Float tags (0x3 - empty register)
  ulong          fst;                  // FPU status word
  ulong          fcw;                  // FPU control word
  ulong          ferrseg;              // Selector of last detected FPU error
  ulong          feroffs;              // Offset of last detected FPU error
  ulong          dr[NREG];             // Debug registers
  ulong          lasterror;            // Last thread error or 0xFFFFFFFF
  uchar          ssereg[NREG][16];     // SSE registers
  ulong          mxcsr;                // SSE control and status register
  t_memfield     mem[NMEMFIELD];       // Known memory fields from run trace
} t_reg;

typedef struct t_thread {              // Information about active threads
  ulong          threadid;             // Thread identifier
  ulong          dummy;                // Always 1
  ulong          type;                 // Service information, TY_xxx+THR_xxx
  int            ordinal;              // Thread's ordinal number (1-based)
  wchar_t        name[SHORTNAME];      // Short name of the thread
  HANDLE         thread;               // Thread handle, for OllyDbg only!
  ulong          tib;                  // Thread Information Block
  ulong          entry;                // Thread entry point
  CONTEXT        context;              // Actual context of the thread
  t_reg          reg;                  // Actual contents of registers
  int            regvalid;             // Whether reg and context are valid
  t_reg          oldreg;               // Previous contents of registers
  int            oldregvalid;          // Whether oldreg is valid
  int            suspendrun;           // Suspended for run (0 or 1)
  int            suspendcount;         // Temporarily suspended (0..inf)
  int            suspenduser;          // Suspended by user (0 or 1)
  int            trapset;              // Single-step trap set by OllyDbg
  int            trapincontext;        // Trap is catched in exception context
  ulong          rtprotocoladdr;       // Address of destination to protocol
  int            ignoreonce;           // Ignore list, IGNO_xxx
  int            drvalid;              // Contents of dr is valid
  ulong          dr[NREG];             // Expected state of DR0..3,7
  int            hwmasked;             // Temporarily masked hardware breaks
  int            hwreported;           // Reported breakpoint expressions
  // Thread-related information gathered by Updatethreaddata().
  HWND           hw;                   // One of windows owned by thread
  ulong          usertime;             // Time in user mode, 100u units or -1
  ulong          systime;              // Time in system mode, 100u units or -1
  // Thread-related information gathered by Listmemory().
  ulong          stacktop;             // Top of thread's stack
  ulong          stackbottom;          // Bottom of thread's stack
} t_thread;

stdapi (t_thread *) Findthread(ulong threadid);
stdapi (t_thread *) Findthreadbyordinal(int ordinal);
stdapi (t_reg *) Threadregisters(ulong threadid);
stdapi (int)     Decodethreadname(wchar_t *s,ulong threadid,int mode);
stdapi (void)    Registermodifiedbyuser(t_thread *pthr);


////////////////////////////////////////////////////////////////////////////////
////////////////////////// ASSEMBLER AND DISASSEMBLER //////////////////////////

#define MAXCMDSIZE     16              // Maximal length of valid 80x86 command
#define MAXSEQSIZE     256             // Maximal length of command sequence
#define INT3           0xCC            // Code of 1-byte INT3 breakpoint
#define NOP            0x90            // Code of 1-byte NOP command
#define NOPERAND       4               // Maximal allowed number of operands
#define NEGLIMIT       (-16384)        // Limit to decode offsets as negative
#define DECLIMIT       65536           // Limit to decode integers as decimal

// Registers.
#define REG_UNDEF      (-1)            // Codes of general purpose registers
#define REG_EAX        0
#define REG_ECX        1
#define REG_EDX        2
#define REG_EBX        3
#define REG_ESP        4
#define REG_EBP        5
#define REG_ESI        6
#define REG_EDI        7

#define REG_BYTE       0x80            // Flag used in switch analysis

#define REG_AL         0               // Symbolic indices of 8-bit registers
#define REG_CL         1
#define REG_DL         2
#define REG_BL         3
#define REG_AH         4
#define REG_CH         5
#define REG_DH         6
#define REG_BH         7

#define SEG_UNDEF      (-1)            // Codes of segment/selector registers
#define SEG_ES         0
#define SEG_CS         1
#define SEG_SS         2
#define SEG_DS         3
#define SEG_FS         4
#define SEG_GS         5

// Pseudoregisters, used in search for assembler commands.
#define REG_R8         NREG            // 8-bit pseudoregister R8
#define REG_R16        NREG            // 16-bit pseudoregister R16
#define REG_R32        NREG            // 32-bit pseudoregister R32
#define REG_ANY        NREG            // Pseudoregister FPUREG, MMXREG etc.
#define SEG_ANY        NREG            // Segment pseudoregister SEG
#define REG_RA         (NREG+1)        // 32-bit semi-defined pseudoregister RA
#define REG_RB         (NREG+2)        // 32-bit semi-defined pseudoregister RB

#define NPSEUDO        (NREG+3)        // Total count of resisters & pseudoregs

#define IS_REAL(r)     ((r)<REG_R32)   // Checks for real register
#define IS_PSEUDO(r)   ((r)>=REG_R32)  // Checks for pseudoregister (undefined)
#define IS_SEMI(r)     ((r)>=REG_RA)   // Checks for semi-defined register

#define D_NONE         0x00000000      // No special features
// General type of command, only one is allowed.
#define D_CMDTYPE      0x0000001F      // Mask to extract type of command
#define   D_CMD        0x00000000      // Ordinary (none of listed below)
#define   D_MOV        0x00000001      // Move to or from integer register
#define   D_MOVC       0x00000002      // Conditional move to integer register
#define   D_SETC       0x00000003      // Conditional set integer register
#define   D_TEST       0x00000004      // Used to test data (CMP, TEST, AND...)
#define   D_STRING     0x00000005      // String command with REPxxx prefix
#define   D_JMP        0x00000006      // Unconditional near jump
#define   D_JMPFAR     0x00000007      // Unconditional far jump
#define   D_JMC        0x00000008      // Conditional jump on flags
#define   D_JMCX       0x00000009      // Conditional jump on (E)CX (and flags)
#define   D_PUSH       0x0000000A      // PUSH exactly 1 (d)word of data
#define   D_POP        0x0000000B      // POP exactly 1 (d)word of data
#define   D_CALL       0x0000000C      // Plain near call
#define   D_CALLFAR    0x0000000D      // Far call
#define   D_INT        0x0000000E      // Interrupt
#define   D_RET        0x0000000F      // Plain near return from call
#define   D_RETFAR     0x00000010      // Far return or IRET
#define   D_FPU        0x00000011      // FPU command
#define   D_MMX        0x00000012      // MMX instruction, incl. SSE extensions
#define   D_3DNOW      0x00000013      // 3DNow! instruction
#define   D_SSE        0x00000014      // SSE, SSE2, SSE3 etc. instruction
#define   D_IO         0x00000015      // Accesses I/O ports
#define   D_SYS        0x00000016      // Legal but useful in system code only
#define   D_PRIVILEGED 0x00000017      // Privileged (non-Ring3) command
#define   D_DATA       0x0000001C      // Data recognized by Analyser
#define   D_PSEUDO     0x0000001D      // Pseudocommand, for search models only
#define   D_PREFIX     0x0000001E      // Standalone prefix
#define   D_BAD        0x0000001F      // Bad or unrecognized command
// Additional parts of the command.
#define D_SIZE01       0x00000020      // Bit 0x01 in last cmd is data size
#define D_POSTBYTE     0x00000040      // Command continues in postbyte
// For string commands, either long or short form can be selected.
#define D_LONGFORM     0x00000080      // Long form of string command
// Decoding of some commands depends on data or address size.
#define D_SIZEMASK     0x00000F00      // Mask for data/address size dependence
#define   D_DATA16     0x00000100      // Requires 16-bit data size
#define   D_DATA32     0x00000200      // Requires 32-bit data size
#define   D_ADDR16     0x00000400      // Requires 16-bit address size
#define   D_ADDR32     0x00000800      // Requires 32-bit address size
// Prefixes that command may, must or must not possess.
#define D_MUSTMASK     0x0000F000      // Mask for fixed set of prefixes
#define   D_NOMUST     0x00000000      // No obligatory prefixes (default)
#define   D_MUST66     0x00001000      // (SSE) Requires 66, no F2 or F3
#define   D_MUSTF2     0x00002000      // (SSE) Requires F2, no 66 or F3
#define   D_MUSTF3     0x00003000      // (SSE) Requires F3, no 66 or F2
#define   D_MUSTNONE   0x00004000      // (MMX,SSE) Requires no 66, F2 or F3
#define   D_NEEDF2     0x00005000      // (SSE) Requires F2, no F3
#define   D_NEEDF3     0x00006000      // (SSE) Requires F3, no F2
#define   D_NOREP      0x00007000      // Must not include F2 or F3
#define   D_MUSTREP    0x00008000      // Must include F3 (REP)
#define   D_MUSTREPE   0x00009000      // Must include F3 (REPE)
#define   D_MUSTREPNE  0x0000A000      // Must include F2 (REPNE)
#define D_LOCKABLE     0x00010000      // Allows for F0 (LOCK, memory only)
#define D_BHINT        0x00020000      // Allows for branch hints (2E, 3E)
// Decoding of some commands with ModRM-SIB depends whether register or memory.
#define D_MEMORY       0x00040000      // Mod field must indicate memory
#define D_REGISTER     0x00080000      // Mod field must indicate register
// Side effects caused by command.
#define D_FLAGMASK     0x00700000      // Mask to extract modified flags
#define   D_NOFLAGS    0x00000000      // Flags S,Z,P,O,C remain unchanged
#define   D_ALLFLAGS   0x00100000      // Modifies flags S,Z,P,O,C
#define   D_FLAGZ      0x00200000      // Modifies flag Z only
#define   D_FLAGC      0x00300000      // Modifies flag C only
#define   D_FLAGSCO    0x00400000      // Modifies flag C and O only
#define   D_FLAGD      0x00500000      // Modifies flag D only
#define   D_FLAGSZPC   0x00600000      // Modifies flags Z, P and C only (FPU)
#define   D_NOCFLAG    0x00700000      // S,Z,P,O modified, C unaffected
#define D_FPUMASK      0x01800000      // Mask for effects on FPU stack
#define   D_FPUSAME    0x00000000      // Doesn't rotate FPU stack (default)
#define   D_FPUPOP     0x00800000      // Pops FPU stack
#define   D_FPUPOP2    0x01000000      // Pops FPU stack twice
#define   D_FPUPUSH    0x01800000      // Pushes FPU stack
#define D_CHGESP       0x02000000      // Command indirectly modifies ESP
// Command features.
#define D_HLADIR       0x04000000      // Nonstandard order of operands in HLA
#define D_WILDCARD     0x08000000      // Mnemonics contains W/D wildcard ('*')
#define D_COND         0x10000000      // Conditional (action depends on flags)
#define D_USESCARRY    0x20000000      // Uses Carry flag
#define D_USEMASK      0xC0000000      // Mask to detect unusual commands
#define   D_RARE       0x40000000      // Rare or obsolete in Win32 apps
#define   D_SUSPICIOUS 0x80000000      // Suspicious command
#define   D_UNDOC      0xC0000000      // Undocumented command

// Extension of D_xxx.
#define DX_ZEROMASK    0x00000003      // How to decode FLAGS.Z flag
#define   DX_JE        0x00000001      // JE, JNE instead of JZ, JNZ
#define   DX_JZ        0x00000002      // JZ, JNZ instead of JE, JNE
#define DX_CARRYMASK   0x0000000C      // How to decode FLAGS.C flag
#define   DX_JB        0x00000004      // JAE, JB instead of JC, JNC
#define   DX_JC        0x00000008      // JC, JNC instead of JAE, JB
#define DX_WONKYTRAP   0x00000100      // Don't single-step this command

// Type of operand, only one is allowed.
#define B_ARGMASK      0x000000FF      // Mask to extract type of argument
#define   B_NONE       0x00000000      // Operand absent
#define   B_AL         0x00000001      // Register AL
#define   B_AH         0x00000002      // Register AH
#define   B_AX         0x00000003      // Register AX
#define   B_CL         0x00000004      // Register CL
#define   B_CX         0x00000005      // Register CX
#define   B_DX         0x00000006      // Register DX
#define   B_DXPORT     0x00000007      // Register DX as I/O port address
#define   B_EAX        0x00000008      // Register EAX
#define   B_EBX        0x00000009      // Register EBX
#define   B_ECX        0x0000000A      // Register ECX
#define   B_EDX        0x0000000B      // Register EDX
#define   B_ACC        0x0000000C      // Accumulator (AL/AX/EAX)
#define   B_STRCNT     0x0000000D      // Register CX or ECX as REPxx counter
#define   B_DXEDX      0x0000000E      // Register DX or EDX in DIV/MUL
#define   B_BPEBP      0x0000000F      // Register BP or EBP in ENTER/LEAVE
#define   B_REG        0x00000010      // 8/16/32-bit register in Reg
#define   B_REG16      0x00000011      // 16-bit register in Reg
#define   B_REG32      0x00000012      // 32-bit register in Reg
#define   B_REGCMD     0x00000013      // 16/32-bit register in last cmd byte
#define   B_REGCMD8    0x00000014      // 8-bit register in last cmd byte
#define   B_ANYREG     0x00000015      // Reg field is unused, any allowed
#define   B_INT        0x00000016      // 8/16/32-bit register/memory in ModRM
#define   B_INT8       0x00000017      // 8-bit register/memory in ModRM
#define   B_INT16      0x00000018      // 16-bit register/memory in ModRM
#define   B_INT32      0x00000019      // 32-bit register/memory in ModRM
#define   B_INT1632    0x0000001A      // 16/32-bit register/memory in ModRM
#define   B_INT64      0x0000001B      // 64-bit integer in ModRM, memory only
#define   B_INT128     0x0000001C      // 128-bit integer in ModRM, memory only
#define   B_IMMINT     0x0000001D      // 8/16/32-bit int at immediate addr
#define   B_INTPAIR    0x0000001E      // Two signed 16/32 in ModRM, memory only
#define   B_SEGOFFS    0x0000001F      // 16:16/16:32 absolute address in memory
#define   B_STRDEST    0x00000020      // 8/16/32-bit string dest, [ES:(E)DI]
#define   B_STRDEST8   0x00000021      // 8-bit string destination, [ES:(E)DI]
#define   B_STRSRC     0x00000022      // 8/16/32-bit string source, [(E)SI]
#define   B_STRSRC8    0x00000023      // 8-bit string source, [(E)SI]
#define   B_XLATMEM    0x00000024      // 8-bit memory in XLAT, [(E)BX+AL]
#define   B_EAXMEM     0x00000025      // Reference to memory addressed by [EAX]
#define   B_LONGDATA   0x00000026      // Long data in ModRM, mem only
#define   B_ANYMEM     0x00000027      // Reference to memory, data unimportant
#define   B_STKTOP     0x00000028      // 16/32-bit int top of stack
#define   B_STKTOPFAR  0x00000029      // Top of stack (16:16/16:32 far addr)
#define   B_STKTOPEFL  0x0000002A      // 16/32-bit flags on top of stack
#define   B_STKTOPA    0x0000002B      // 16/32-bit top of stack all registers
#define   B_PUSH       0x0000002C      // 16/32-bit int push to stack
#define   B_PUSHRET    0x0000002D      // 16/32-bit push of return address
#define   B_PUSHRETF   0x0000002E      // 16:16/16:32-bit push of far retaddr
#define   B_PUSHA      0x0000002F      // 16/32-bit push all registers
#define   B_EBPMEM     0x00000030      // 16/32-bit int at [EBP]
#define   B_SEG        0x00000031      // Segment register in Reg
#define   B_SEGNOCS    0x00000032      // Segment register in Reg, but not CS
#define   B_SEGCS      0x00000033      // Segment register CS
#define   B_SEGDS      0x00000034      // Segment register DS
#define   B_SEGES      0x00000035      // Segment register ES
#define   B_SEGFS      0x00000036      // Segment register FS
#define   B_SEGGS      0x00000037      // Segment register GS
#define   B_SEGSS      0x00000038      // Segment register SS
#define   B_ST         0x00000039      // 80-bit FPU register in last cmd byte
#define   B_ST0        0x0000003A      // 80-bit FPU register ST0
#define   B_ST1        0x0000003B      // 80-bit FPU register ST1
#define   B_FLOAT32    0x0000003C      // 32-bit float in ModRM, memory only
#define   B_FLOAT64    0x0000003D      // 64-bit float in ModRM, memory only
#define   B_FLOAT80    0x0000003E      // 80-bit float in ModRM, memory only
#define   B_BCD        0x0000003F      // 80-bit BCD in ModRM, memory only
#define   B_MREG8x8    0x00000040      // MMX register as 8 8-bit integers
#define   B_MMX8x8     0x00000041      // MMX reg/memory as 8 8-bit integers
#define   B_MMX8x8DI   0x00000042      // MMX 8 8-bit integers at [DS:(E)DI]
#define   B_MREG16x4   0x00000043      // MMX register as 4 16-bit integers
#define   B_MMX16x4    0x00000044      // MMX reg/memory as 4 16-bit integers
#define   B_MREG32x2   0x00000045      // MMX register as 2 32-bit integers
#define   B_MMX32x2    0x00000046      // MMX reg/memory as 2 32-bit integers
#define   B_MREG64     0x00000047      // MMX register as 1 64-bit integer
#define   B_MMX64      0x00000048      // MMX reg/memory as 1 64-bit integer
#define   B_3DREG      0x00000049      // 3DNow! register as 2 32-bit floats
#define   B_3DNOW      0x0000004A      // 3DNow! reg/memory as 2 32-bit floats
#define   B_XMM0I32x4  0x0000004B      // XMM0 as 4 32-bit integers
#define   B_XMM0I64x2  0x0000004C      // XMM0 as 2 64-bit integers
#define   B_XMM0I8x16  0x0000004D      // XMM0 as 16 8-bit integers
#define   B_SREGF32x4  0x0000004E      // SSE register as 4 32-bit floats
#define   B_SREGF32L   0x0000004F      // Low 32-bit float in SSE register
#define   B_SREGF32x2L 0x00000050      // Low 2 32-bit floats in SSE register
#define   B_SSEF32x4   0x00000051      // SSE reg/memory as 4 32-bit floats
#define   B_SSEF32L    0x00000052      // Low 32-bit float in SSE reg/memory
#define   B_SSEF32x2L  0x00000053      // Low 2 32-bit floats in SSE reg/memory
#define   B_SREGF64x2  0x00000054      // SSE register as 2 64-bit floats
#define   B_SREGF64L   0x00000055      // Low 64-bit float in SSE register
#define   B_SSEF64x2   0x00000056      // SSE reg/memory as 2 64-bit floats
#define   B_SSEF64L    0x00000057      // Low 64-bit float in SSE reg/memory
#define   B_SREGI8x16  0x00000058      // SSE register as 16 8-bit sigints
#define   B_SSEI8x16   0x00000059      // SSE reg/memory as 16 8-bit sigints
#define   B_SSEI8x16DI 0x0000005A      // SSE 16 8-bit sigints at [DS:(E)DI]
#define   B_SSEI8x8L   0x0000005B      // Low 8 8-bit ints in SSE reg/memory
#define   B_SSEI8x4L   0x0000005C      // Low 4 8-bit ints in SSE reg/memory
#define   B_SSEI8x2L   0x0000005D      // Low 2 8-bit ints in SSE reg/memory
#define   B_SREGI16x8  0x0000005E      // SSE register as 8 16-bit sigints
#define   B_SSEI16x8   0x0000005F      // SSE reg/memory as 8 16-bit sigints
#define   B_SSEI16x4L  0x00000060      // Low 4 16-bit ints in SSE reg/memory
#define   B_SSEI16x2L  0x00000061      // Low 2 16-bit ints in SSE reg/memory
#define   B_SREGI32x4  0x00000062      // SSE register as 4 32-bit sigints
#define   B_SREGI32L   0x00000063      // Low 32-bit sigint in SSE register
#define   B_SREGI32x2L 0x00000064      // Low 2 32-bit sigints in SSE register
#define   B_SSEI32x4   0x00000065      // SSE reg/memory as 4 32-bit sigints
#define   B_SSEI32x2L  0x00000066      // Low 2 32-bit sigints in SSE reg/memory
#define   B_SREGI64x2  0x00000067      // SSE register as 2 64-bit sigints
#define   B_SSEI64x2   0x00000068      // SSE reg/memory as 2 64-bit sigints
#define   B_SREGI64L   0x00000069      // Low 64-bit sigint in SSE register
#define   B_EFL        0x0000006A      // Flags register EFL
#define   B_FLAGS8     0x0000006B      // Flags (low byte)
#define   B_OFFSET     0x0000006C      // 16/32 const offset from next command
#define   B_BYTEOFFS   0x0000006D      // 8-bit sxt const offset from next cmd
#define   B_FARCONST   0x0000006E      // 16:16/16:32 absolute address constant
#define   B_DESCR      0x0000006F      // 16:32 descriptor in ModRM
#define   B_1          0x00000070      // Immediate constant 1
#define   B_CONST8     0x00000071      // Immediate 8-bit constant
#define   B_CONST8_2   0x00000072      // Immediate 8-bit const, second in cmd
#define   B_CONST16    0x00000073      // Immediate 16-bit constant
#define   B_CONST      0x00000074      // Immediate 8/16/32-bit constant
#define   B_CONSTL     0x00000075      // Immediate 16/32-bit constant
#define   B_SXTCONST   0x00000076      // Immediate 8-bit sign-extended to size
#define   B_CR         0x00000077      // Control register in Reg
#define   B_CR0        0x00000078      // Control register CR0
#define   B_DR         0x00000079      // Debug register in Reg
// Type modifiers, used for interpretation of contents, only one is allowed.
#define B_MODMASK      0x000F0000      // Mask to extract type modifier
#define   B_NONSPEC    0x00000000      // Non-specific operand
#define   B_UNSIGNED   0x00010000      // Decode as unsigned decimal
#define   B_SIGNED     0x00020000      // Decode as signed decimal
#define   B_BINARY     0x00030000      // Decode as binary (full hex) data
#define   B_BITCNT     0x00040000      // Bit count
#define   B_SHIFTCNT   0x00050000      // Shift count
#define   B_COUNT      0x00060000      // General-purpose count
#define   B_NOADDR     0x00070000      // Not an address
#define   B_JMPCALL    0x00080000      // Near jump/call/return destination
#define   B_JMPCALLFAR 0x00090000      // Far jump/call/return destination
#define   B_STACKINC   0x000A0000      // Unsigned stack increment/decrement
#define   B_PORT       0x000B0000      // I/O port
// Validity markers.
#define B_MEMORY       0x00100000      // Memory only, reg version different
#define B_REGISTER     0x00200000      // Register only, mem version different
#define B_MEMONLY      0x00400000      // Warn if operand in register
#define B_REGONLY      0x00800000      // Warn if operand in memory
#define B_32BITONLY    0x01000000      // Warn if 16-bit operand
#define B_NOESP        0x02000000      // ESP is not allowed
// Miscellaneous options.
#define B_SHOWSIZE     0x08000000      // Always show argument size in disasm
#define B_CHG          0x10000000      // Changed, old contents is not used
#define B_UPD          0x20000000      // Modified using old contents
#define B_PSEUDO       0x40000000      // Pseoudooperand, not in assembler cmd
#define B_NOSEG        0x80000000      // Don't add offset of selector

// Analysis data. Note that DEC_PBODY==DEC_PROC|DEC_PEND; this allows for
// automatical merging of overlapping procedures. Also note that DEC_NET is
// followed, if necessary, by a sequence of DEC_NEXTDATA and not DEC_NEXTCODE!
#define DEC_TYPEMASK   0x1F            // Type of analyzed byte
#define   DEC_UNKNOWN  0x00            // Not analyzed, treat as command
#define   DEC_NEXTCODE 0x01            // Next byte of command
#define   DEC_NEXTDATA 0x02            // Next byte of data
#define   DEC_FILLDATA 0x03            // Not recognized, treat as byte data
#define   DEC_INT      0x04            // First byte of integer
#define   DEC_SWITCH   0x05            // First byte of switch item or count
#define   DEC_DATA     0x06            // First byte of integer data
#define   DEC_DB       0x07            // First byte of byte string
#define   DEC_DUMP     0x08            // First byte of byte string with dump
#define   DEC_ASCII    0x09            // First byte of ASCII string
#define   DEC_ASCCNT   0x0A            // Next chunk of ASCII string
#define   DEC_UNICODE  0x0B            // First byte of UNICODE string
#define   DEC_UNICNT   0x0C            // Next chunk of UNICODE string
#define   DEC_FLOAT    0x0D            // First byte of floating number
#define   DEC_GUID     0x10            // First byte of GUID
#define   DEC_NETCMD   0x18            // First byte of .NET (CIL) command
#define   DEC_JMPNET   0x19            // First byte of .NET at jump destination
#define   DEC_CALLNET  0x1A            // First byte of .NET at call destination
#define   DEC_COMMAND  0x1C            // First byte of ordinary command
#define   DEC_JMPDEST  0x1D            // First byte of cmd at jump destination
#define   DEC_CALLDEST 0x1E            // First byte of cmd at call destination
#define   DEC_FILLING  0x1F            // Command used to fill gaps
#define DEC_PROCMASK   0x60            // Procedure analysis
#define   DEC_NOPROC   0x00            // Outside the procedure
#define   DEC_PROC     0x20            // Start of procedure
#define   DEC_PEND     0x40            // End of procedure
#define   DEC_PBODY    0x60            // Body of procedure
#define DEC_TRACED     0x80            // Hit when traced

// Full type of predicted data.
#define PST_GENMASK    0xFFFFFC00      // Mask for ESP generation
#define   PST_GENINC   0x00000400      // Increment of ESP generation
#define PST_UNCERT     0x00000200      // Uncertain, probably modified by call
#define PST_NONSTACK   0x00000100      // Not a stack, internal use only
#define PST_REL        0x00000080      // Fixup/reladdr counter of constant
#define PST_BASE       0x0000007F      // Mask for basical description
#define   PST_SPEC     0x00000040      // Special contents, type in PST_GENMASK
#define   PST_VALID    0x00000020      // Contents valid
#define   PST_ADDR     0x00000010      // Contents is in memory
#define   PST_ORIG     0x00000008      // Based on reg contents at entry point
#define   PST_OMASK    0x00000007      // Mask to extract original register

// Types of special contents when PST_SPEC is set.
#define PSS_SPECMASK   PST_GENMASK     // Mask for type of special contents
#define   PSS_SEHPTR   0x00000400      // Pointer to SEH chain

#define NSTACK         12              // Number of predicted stack entries
#define NSTKMOD        24              // Max no. of predicted stack mod addr
#define NMEM           2               // Number of predicted memory locations

typedef struct t_modrm {               // ModRM decoding
  ulong          size;                 // Total size with SIB and disp, bytes
  struct t_modrm *psib;                // Pointer to SIB table or NULL
  ulong          dispsize;             // Size of displacement or 0 if none
  ulong          features;             // Operand features, set of OP_xxx
  int            reg;                  // Register index or REG_UNDEF
  int            defseg;               // Default selector (SEG_xxx)
  uchar          scale[NREG];          // Scales of registers in memory address
  ulong          aregs;                // List of registers used in address
  int            basereg;              // Register used as base or REG_UNDEF
  wchar_t        ardec[SHORTNAME];     // Register part of address, INTEL fmt
  wchar_t        aratt[SHORTNAME];     // Register part of address, AT&T fmt
} t_modrm;

typedef struct t_predict {             // Prediction of execution
  ulong          addr;                 // Predicted EIP or NULL if uncertain
  ulong          one;                  // Must be 1
  ulong          type;                 // Type, TY_xxx/PR_xxx
  ushort         flagsmeaning;         // Set of DX_ZEROMASK|DX_CARRYMASK
  ulong          rstate[NREG];         // State of register, set of PST_xxx
  ulong          rconst[NREG];         // Constant related to register
  ulong          jmpstate;             // State of EIP after jump or return
  ulong          jmpconst;             // Constant related to jump or return
  ulong          espatpushbp;          // Offset of ESP at PUSH EBP
  int            nstack;               // Number of valid stack entries
  struct {
    long         soffset;              // Offset of data on stack (signed!)
    ulong        sstate;               // State of stack data, set of PST_xxx
    ulong        sconst;               // Constant related to stack data
  } stack[NSTACK];
  int            nstkmod;              // Number of valid stkmod addresses
  ulong          stkmod[NSTKMOD];      // Addresses of stack modifications
  int            nmem;                 // Number of valid memory entries
  struct {
    ulong        maddr;                // Address of doubleword variable
    ulong        mstate;               // State of memory, set of PST_xxx
    ulong        mconst;               // Constant related to memory data
  } mem[NMEM];
  ulong          resstate;             // State of result of command execution
  ulong          resconst;             // Constant related to result
} t_predict;

typedef struct t_callpredict {         // Simplified prediction
  ulong          addr;                 // Predicted EIP or NULL if uncertain
  ulong          one;                  // Must be 1
  ulong          type;                 // Type of prediction, TY_xxx/PR_xxx
  ulong          eaxstate;             // State of EAX, set of PST_xxx
  ulong          eaxconst;             // Constant related to EAX
  int            nstkmod;              // Number of valid stkmod addresses
  ulong          stkmod[NSTKMOD];      // Addresses of stack modifications
  ulong          resstate;             // State of result of command execution
  ulong          resconst;             // Constant related to result
} t_callpredict;

// Location of operand, only one bit is allowed.
#define OP_SOMEREG     0x000000FF      // Mask for any kind of register
#define   OP_REGISTER  0x00000001      // Operand is a general-purpose register
#define   OP_SEGREG    0x00000002      // Operand is a segment register
#define   OP_FPUREG    0x00000004      // Operand is a FPU register
#define   OP_MMXREG    0x00000008      // Operand is a MMX register
#define   OP_3DNOWREG  0x00000010      // Operand is a 3DNow! register
#define   OP_SSEREG    0x00000020      // Operand is a SSE register
#define   OP_CREG      0x00000040      // Operand is a control register
#define   OP_DREG      0x00000080      // Operand is a debug register
#define OP_MEMORY      0x00000100      // Operand is in memory
#define OP_CONST       0x00000200      // Operand is an immediate constant
#define OP_PORT        0x00000400      // Operand is an I/O port
// Additional operand properties.
#define OP_INVALID     0x00001000      // Invalid operand, like reg in mem-only
#define OP_PSEUDO      0x00002000      // Pseudooperand (not in mnenonics)
#define OP_MOD         0x00004000      // Command may change/update operand
#define OP_MODREG      0x00008000      // Memory, but modifies reg (POP,MOVSD)
#define OP_REL         0x00010000      // Relative or fixuped const or address
#define OP_IMPORT      0x00020000      // Value imported from different module
#define OP_SELECTOR    0x00040000      // Includes immediate selector
// Additional properties of memory address.
#define OP_INDEXED     0x00080000      // Memory address contains registers
#define OP_OPCONST     0x00100000      // Memory address contains constant
#define OP_ADDR16      0x00200000      // 16-bit memory address
#define OP_ADDR32      0x00400000      // Explicit 32-bit memory address
// Value of operand.
#define OP_OFFSOK      0x00800000      // Offset to selector valid
#define OP_ADDROK      0x01000000      // Address valid
#define OP_VALUEOK     0x02000000      // Value (max. 16 bytes) valid
#define OP_PREDADDR    0x04000000      // Address predicted, not actual
#define OP_PREDVAL     0x08000000      // Value predicted, not actual
#define OP_RTLOGMEM    0x10000000      // Memory contents got from run trace
#define   OP_ACTVALID  0x20000000      // Actual value is valid
// Pseudooperands, used in assembler search models only.
#define OP_ANYMEM      0x40000000      // Any memory location
#define OP_ANY         0x80000000      // Any operand

typedef struct t_operand {             // Description of disassembled operand
  // Description of operand.
  ulong          features;             // Operand features, set of OP_xxx
  ulong          arg;                  // Operand type, set of B_xxx
  int            optype;               // DEC_INT, DEC_FLOAT or DEC_UNKNOWN
  int            opsize;               // Total size of data, bytes
  int            granularity;          // Size of element (opsize exc. MMX/SSE)
  int            reg;                  // REG_xxx (also ESP in POP) or REG_UNDEF
  ulong          uses;                 // List of used regs (not in address!)
  ulong          modifies;             // List of modified regs (not in addr!)
  // Description of memory address.
  int            seg;                  // Selector (SEG_xxx)
  uchar          scale[NREG];          // Scales of registers in memory address
  ulong          aregs;                // List of registers used in address
  ulong          opconst;              // Constant or const part of address
  // Value of operand.
  ulong          offset;               // Offset to selector (usually addr)
  ulong          selector;             // Immediate selector in far jump/call
  ulong          addr;                 // Address of operand in memory
  union {
    ulong        u;                    // Value of operand (integer form)
    signed long  s;                    // Value of operand (signed form)
    uchar        value[16]; };         // Value of operand (general form)
  uchar          actual[16];           // Actual memory (if OP_ACTVALID)
  // Textual decoding.
  wchar_t        text[TEXTLEN];        // Operand, decoded to text
  wchar_t        comment[TEXTLEN];     // Commented address and contents
} t_operand;

// Prefix list.
#define PF_SEGMASK     0x0000003F      // Mask for segment override prefixes
#define   PF_ES        0x00000001      // 0x26, ES segment override
#define   PF_CS        0x00000002      // 0x2E, CS segment override
#define   PF_SS        0x00000004      // 0x36, SS segment override
#define   PF_DS        0x00000008      // 0x3E, DS segment override
#define   PF_FS        0x00000010      // 0x64, FS segment override
#define   PF_GS        0x00000020      // 0x65, GS segment override
#define PF_DSIZE       0x00000040      // 0x66, data size override
#define PF_ASIZE       0x00000080      // 0x67, address size override
#define PF_LOCK        0x00000100      // 0xF0, bus lock
#define PF_REPMASK     0x00000600      // Mask for repeat prefixes
#define   PF_REPNE     0x00000200      // 0xF2, REPNE prefix
#define   PF_REP       0x00000400      // 0xF3, REP/REPE prefix
#define PF_BYTE        0x00000800      // Size bit in command, used in cmdexec
#define PF_MUSTMASK    D_MUSTMASK      // Necessary prefixes, used in t_asmmod
#define PF_66          PF_DSIZE        // Alternative names for SSE prefixes
#define PF_F2          PF_REPNE
#define PF_F3          PF_REP
#define PF_HINT        (PF_CS|PF_DS)   // Alternative names for branch hints
#define   PF_NOTTAKEN  PF_CS
#define   PF_TAKEN     PF_DS

// Disassembling errors.
#define DAE_NOERR      0x00000000      // No error
#define DAE_BADCMD     0x00000001      // Unrecognized command
#define DAE_CROSS      0x00000002      // Command crosses end of memory block
#define DAE_MEMORY     0x00000004      // Register where only memory allowed
#define DAE_REGISTER   0x00000008      // Memory where only register allowed
#define DAE_LOCK       0x00000010      // LOCK prefix is not allowed
#define DAE_BADSEG     0x00000020      // Invalid segment register
#define DAE_SAMEPREF   0x00000040      // Two prefixes from the same group
#define DAE_MANYPREF   0x00000080      // More than 4 prefixes
#define DAE_BADCR      0x00000100      // Invalid CR register
#define DAE_INTERN     0x00000200      // Internal error

// Disassembling warnings.
#define DAW_DATASIZE   0x00000001      // Superfluous data size prefix
#define DAW_ADDRSIZE   0x00000002      // Superfluous address size prefix
#define DAW_SEGPREFIX  0x00000004      // Superfluous segment override prefix
#define DAW_REPPREFIX  0x00000008      // Superfluous REPxx prefix
#define DAW_DEFSEG     0x00000010      // Segment prefix coincides with default
#define DAW_JMP16      0x00000020      // 16-bit jump, call or return
#define DAW_FARADDR    0x00000040      // Far jump or call
#define DAW_SEGMOD     0x00000080      // Modifies segment register
#define DAW_PRIV       0x00000100      // Privileged command
#define DAW_IO         0x00000200      // I/O command
#define DAW_SHIFT      0x00000400      // Shift out of range 1..31
#define DAW_LOCK       0x00000800      // Command with valid LOCK prefix
#define DAW_STACK      0x00001000      // Unaligned stack operation
#define DAW_NOESP      0x00002000      // Suspicious use of stack pointer
#define DAW_RARE       0x00004000      // Rare, seldom used command
#define DAW_NONCLASS   0x00008000      // Non-standard or non-documented code
#define DAW_INTERRUPT  0x00010000      // Interrupt command

// Conditions of conditional commands.
#define DAF_NOCOND     0x00000000      // Unconditional command
#define DAF_TRUE       0x00000001      // Condition is true
#define DAF_FALSE      0x00000002      // Condition is false
#define DAF_ANYCOND    0x00000003      // Condition is not predictable

typedef struct t_disasm {              // Disassembled command
  // In the case that DA_HILITE flag is set, fill these members before calling
  // Disasm(). Parameter hilitereg has priority over hiliteindex.
  ulong          hilitereg;            // One of OP_SOMEREG if reg highlighting
  int            hiregindex;           // Index of register to highlight
  int            hiliteindex;          // Index of highlighting scheme (0: none)
  // Starting from this point, no need to initialize the members of t_disasm.
  ulong          ip;                   // Address of first command byte
  ulong          size;                 // Full length of command, bytes
  ulong          cmdtype;              // Type of command, D_xxx
  ulong          exttype;              // More features, set of DX_xxx
  ulong          prefixes;             // List of prefixes, set of PF_xxx
  ulong          nprefix;              // Number of prefixes, including SSE2
  ulong          memfixup;             // Offset of first 4-byte fixup or -1
  ulong          immfixup;             // Offset of second 4-byte fixup or -1
  int            errors;               // Set of DAE_xxx
  int            warnings;             // Set of DAW_xxx
  // Note that used registers are those which contents is necessary to create
  // result. Modified registers are those which value is changed. For example,
  // command MOV EAX,[EBX+ECX] uses EBX and ECX and modifies EAX. Command
  // ADD ESI,EDI uses ESI and EDI and modifies ESI.
  ulong          uses;                 // List of used registers
  ulong          modifies;             // List of modified registers
  // Useful shortcuts.
  int            condition;            // Condition, one of DAF_xxx
  ulong          jmpaddr;              // Jump/call destination or 0
  ulong          memconst;             // Constant in memory address or 0
  ulong          stackinc;             // Data size in ENTER/RETN/RETF
  // Operands.
  t_operand      op[NOPERAND];         // Operands
  // Textual decoding.
  wchar_t        dump[TEXTLEN];        // Hex dump of the command
  wchar_t        result[TEXTLEN];      // Fully decoded command as text
  uchar          mask[TEXTLEN];        // Mask to highlight result
  int            maskvalid;            // Mask corresponds to result
  wchar_t        comment[TEXTLEN];     // Comment that applies to whole command
} t_disasm;

typedef struct t_opinfo {              // Operand in t_cmdinfo
  ulong          features;             // Operand features, set of OP_xxx
  ulong          arg;                  // Operand type, set of B_xxx
  int            opsize;               // Total size of data, bytes
  int            reg;                  // REG_xxx (also ESP in POP) or REG_UNDEF
  int            seg;                  // Selector (SEG_xxx)
  uchar          scale[NREG];          // Scales of registers in memory address
  ulong          opconst;              // Constant or const part of address
} t_opinfo;

typedef struct t_cmdinfo {             // Information on command
  ulong          ip;                   // Address of first command byte
  ulong          size;                 // Full length of command, bytes
  ulong          cmdtype;              // Type of command, D_xxx
  ulong          prefixes;             // List of prefixes, set of PF_xxx
  ulong          nprefix;              // Number of prefixes, including SSE2
  ulong          memfixup;             // Offset of first 4-byte fixup or -1
  ulong          immfixup;             // Offset of second 4-byte fixup or -1
  int            errors;               // Set of DAE_xxx
  ulong          jmpaddr;              // Jump/call destination or 0
  ulong          stackinc;             // Data size in ENTER/RETN/RETF
  t_opinfo       op[NOPERAND];         // Operands
} t_cmdinfo;

// ATTENTION, when making any changes to this structure, apply them to the
// file Cmdemul.asm, too!
typedef struct t_emu {                 // Parameters passed to emulation routine
  ulong          operand[NOPERAND];    // I/O: Operands
  ulong          opsize;               // IN:  Size of operands
  ulong          memaddr;              // OUT: Save address, or 0 if none
  ulong          memsize;              // OUT: Save size (1, 2 or 4 bytes)
  ulong          memdata;              // OUT: Data to save
} t_emu;

typedef void TRACEFUNC(ulong *,ulong *,t_predict *,t_disasm *);
typedef void __cdecl EMUFUNC(t_emu *,t_reg *);

typedef struct t_bincmd {              // Description of 80x86 command
  wchar_t        *name;                // Symbolic name for this command
  ulong          cmdtype;              // Command's features, set of D_xxx
  ulong          exttype;              // More features, set of DX_xxx
  ulong          length;               // Length of main code (before ModRM/SIB)
  ulong          mask;                 // Mask for first 4 bytes of the command
  ulong          code;                 // Compare masked bytes with this
  ulong          postbyte;             // Postbyte
  ulong          arg[NOPERAND];        // Types of arguments, set of B_xxx
  TRACEFUNC      *trace;               // Result prediction function
  EMUFUNC        *emu;                 // Command emulation function
} t_bincmd;

#define AMF_SAMEORDER  0x01            // Same order of index registers in addr
#define AMF_ANYSEG     0x02            // Command has undefined segment prefix
#define AMF_POSTBYTE   0x04            // Includes postbyte
#define AMF_IMPRECISE  0x08            // Command is imprecise (search only)
#define AMF_ANYSIZE    0x10            // Any operand size is acceptable
#define AMF_NOSMALL    0x20            // 16-bit address is not allowed
#define AMF_UNDOC      0x40            // Undocumented command
#define AMF_NEWCMD     0x80            // Marks new command in multiline

#define AMP_REGISTER   0x01            // Operand is a register
#define AMP_MEMORY     0x02            // Operand is a memory location
#define AMP_CONST      0x04            // Operand is a constant
#define AMP_IMPRECISE  0x08            // Constant is imprecise
#define AMP_ANYMEM     0x10            // Any memory operand is acceptable
#define AMP_ANYOP      0x20            // Any operand is acceptable

typedef struct t_modop {               // Operand in assembler model
  uchar          features;             // Operand features, set of AMP_xxx
  uchar          reg;                  // (Pseudo)register operand
  uchar          scale[NPSEUDO];       // Scales of (pseudo)registers in address
  ulong          opconst;              // Constant or const part of address
} t_modop;

// Assembler command model.
typedef struct t_asmmod {              // Description of assembled command
  uchar          code[MAXCMDSIZE];     // Binary code
  uchar          mask[MAXCMDSIZE];     // Mask for binary code (0: bit ignored)
  ulong          prefixes;             // List of prefixes, set of PF_xxx
  uchar          ncode;                // Length of code w/o prefixes, bytes
  uchar          features;             // Code features, set of AMF_xxx
  uchar          postbyte;             // Postbyte (if AMF_POSTBYTE set)
  uchar          noperand;             // Number of operands (no pseudooperands)
  t_modop        op[NOPERAND];         // Description of operands
} t_asmmod;

typedef struct t_asmlist {             // Descriptor of the sequence of models
  t_asmmod       *pasm;                // Pointer to the start of the sequence
  int            length;               // Length of the sequence, models
  wchar_t        comment[TEXTLEN];     // Comment to the sequence
} t_asmlist;

#define DA_TEXT        0x00000001      // Decode command to text and comment
#define   DA_HILITE    0x00000002      // Use syntax highlighting (set t_disasm)
#define DA_OPCOMM      0x00000004      // Comment operands
#define DA_DUMP        0x00000008      // Dump command to hexadecimal text
#define DA_MEMORY      0x00000010      // OK to read memory and use labels
#define   DA_NOIMPORT  0x00000020      // When reading memory, hold the imports
#define   DA_RTLOGMEM  0x00000040      // Use memory saved by run trace
#define   DA_NOSTACKP  0x00000080      // Hide "Stack" prefix in comments
#define DA_STEPINTO    0x00000100      // Enter CALL when predicting registers
#define DA_SHOWARG     0x00000200      // Use predict if address ESP/EBP-based
#define DA_NOPSEUDO    0x00000400      // Skip pseudooperands
#define DA_FORHELP     0x00000800      // Decode operands for command help

#define USEDECODE      ((uchar *)1)    // Request to get decoding automatically

stdapi (int)     Byteregtodwordreg(int bytereg);
stdapi (int)     Printfloat4(wchar_t *s,float f);
stdapi (int)     Printfloat8(wchar_t *s,double d);
stdapi (int)     Printfloat10(wchar_t *s,long double ext);
stdapi (int)     Printmmx(wchar_t *s,uchar *data);
stdapi (int)     Commentcharacter(wchar_t *s,int c,int mode);
stdapi (int)     Nameoffloat(wchar_t *s,uchar *data,ulong size);
stdapi (ulong)   Disasm(uchar *cmd,ulong cmdsize,ulong ip,uchar *dec,
                   t_disasm *da,int mode,t_reg *reg,
                   t_predict *predict);
stdapi (ulong)   Cmdinfo(uchar *cmd,ulong cmdsize,ulong cmdip,
                   t_cmdinfo *ci,int cmdmode,t_reg *cmdreg);
stdapi (ulong)   Disassembleforward(uchar *copy,ulong base,ulong size,
                   ulong ip,ulong n,uchar *decode);
stdapi (ulong)   Disassembleback(uchar *copy,ulong base,ulong size,
                   ulong ip,ulong n,uchar *decode);
stdapi (int)     Checkcondition(int code,ulong flags);
stdapi (ulong)   Setcondition(int code,ulong flags);

#define AM_ALLOWBAD    0x00000001      // Allow bad or undocumented commands
#define AM_IMPRECISE   0x00000002      // Generate imprecise (search) forms
#define   AM_MULTI     0x00000004      // Multiple commands are allowed

#define AM_SEARCH      AM_IMPRECISE

stdapi (int)     Assembleallforms(wchar_t *src,ulong ip,t_asmmod *model,
                   int maxmodel,int mode,wchar_t *errtxt);
stdapi (ulong)   Assemble(wchar_t *src,ulong ip,uchar *buf,ulong nbuf,int mode,
                   wchar_t *errtxt);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////// .NET DISASSEMBLER ///////////////////////////////

// CIL command types.
#define N_CMDTYPE      0x0000001F      // Mask to extract type of command
#define   N_CMD        0x00000000      // Ordinary (none of listed below)
#define   N_JMP        0x00000001      // Unconditional jump
#define   N_JMC        0x00000002      // Conditional jump
#define   N_CALL       0x00000003      // Call
#define   N_RET        0x00000004      // Return (also from exception)
#define   N_SWITCH     0x00000005      // Switch, followed by N cases
#define   N_PREFIX     0x00000006      // Prefix, not a standalone command
#define   N_DATA       0x0000001E      // Command is decoded as data
#define   N_BAD        0x0000001F      // Bad command
#define N_POPMASK      0x00000F00      // Mask to extract number of pops
#define   N_POP0       0x00000000      // Pops no arguments (default)
#define   N_POP1       0x00000100      // Pops 1 argument from stack
#define   N_POP2       0x00000200      // Pops 2 arguments from stack
#define   N_POP3       0x00000300      // Pops 3 arguments from stack
#define   N_POPX       0x00000F00      // Pops variable arguments from stack
#define N_PUSHMASK     0x0000F000
#define   N_PUSH0      0x00000000      // Pushes no data (default)
#define   N_PUSH1      0x00001000      // Pushes 1 argument into stack
#define   N_PUSH2      0x00002000      // Pushes 2 arguments into stack
#define   N_PUSHX      0x0000F000      // Pushes 0 or 1 argument into stack

// CIL explicit operand types.
#define A_ARGMASK      0x000000FF      // Mask to extract type of argument
#define   A_NONE       0x00000000      // No operand
#define   A_OFFSET     0x00000001      // 32-bit offset from next command
#define   A_BYTEOFFS   0x00000002      // 8-bit offset from next command
#define   A_METHOD     0x00000003      // 32-bit method descriptor
#define   A_SIGNATURE  0x00000004      // 32-bit signature of call types
#define   A_TYPE       0x00000005      // 32-bit type descriptor
#define   A_FIELD      0x00000006      // 32-bit field descriptor
#define   A_STRING     0x00000007      // 32-bit string descriptor
#define   A_TOKEN      0x00000008      // 32-bit token descriptor
#define   A_INDEX1     0x00000009      // 8-bit immediate index constant
#define   A_INDEX2     0x0000000A      // 16-bit immediate index constant
#define   A_SWCOUNT    0x0000000B      // 32-bit immediate switch count
#define   A_INT1S      0x0000000C      // 8-bit immediate signed integer const
#define   A_INT4       0x0000000D      // 32-bit immediate integer constant
#define   A_INT8       0x0000000E      // 64-bit immediate integer constant
#define   A_FLOAT4     0x0000000F      // 32-bit immediate float constant
#define   A_FLOAT8     0x00000010      // 64-bit immediate float constant
#define   A_NOLIST     0x00000011      // 8-bit list following no. prefix
#define   A_ALIGN      0x00000012      // 8-bit alignment following unaligned.

typedef struct t_netasm {              // Disassembled .NET CIL command
  ulong          ip;                   // Address of first command byte
  ulong          size;                 // Full length of command, bytes
  ulong          cmdtype;              // Type of command, N_xxx
  ulong          cmdsize;              // Size of command, bytes
  ulong          opsize;               // Size of operand, bytes, or 0 if none
  ulong          nswitch;              // Size of following switch table, dwords
  ulong          jmpaddr;              // Single jump/call destination or 0
  ulong          descriptor;           // Descriptor (xx)xxxxxx or 0
  ulong          dataaddr;             // Address of pointed object/data or 0
  int            errors;               // Set of DAE_xxx
  // Description of operand.
  ulong          optype;               // Operand type, set of A_xxx
  wchar_t        optext[TEXTLEN];      // Operand, decoded to text
  // Textual decoding.
  wchar_t        dump[TEXTLEN];        // Hex dump of the command
  wchar_t        result[TEXTLEN];      // Fully decoded command as text
  wchar_t        comment[TEXTLEN];     // Comment that applies to whole command
} t_netasm;

stdapi (ulong)   Ndisasm(uchar *cmd,ulong size,ulong ip,t_netasm *da,
                   int mode,t_module *pmod);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// ANALYSIS ///////////////////////////////////

#define MAXARG         256             // Maximal sane number of arguments

#define NGUESS         7               // Max number of args in type analysis

#define AA_MANUAL      0               // No automatical analysis
#define AA_MAINONLY    1               // Automatically analyse main module
#define AA_NONSYS      2               // Automatically analyse non-sys modules
#define AA_ALL         3               // Automatically analyse all modules

#define AO_ISFORMATA   0x01            // Argument is probable ASCII format
#define AO_SIGFORMATA  0x02            // Non-trivial ASCII format
#define AO_ISFORMATW   0x04            // Argument is probable UNICODE format
#define AO_SIGFORMATW  0x08            // Non-trivial UNICODE format
#define AO_NOTFORMAT   0x10            // Argument is not a format
#define AO_ISCOUNT     0x20            // Argument is count of remaining args
#define AO_NOTCOUNT    0x40            // Argument is not a count

typedef struct t_procdata {            // Description of procedure
  ulong          addr;                 // Address of entry point
  ulong          size;                 // Size of simple procedure or 1
  ulong          type;                 // Type of procedure, TY_xxx/PD_xxx
  ulong          retsize;              // Size of return (if PD_RETSIZE)
  ulong          localsize;            // Size of reserved locals, 0 - unknown
  ulong          savedebp;             // Offset of cmd after PUSH EBP, 0 - none
  ulong          features;             // Type of known code, RAW_xxx
  char           generic[12];          // Generic name (without _INTERN_)
  int            narg;                 // No. of stack DWORDs (PD_NARG/VARARG)
  int            nguess;               // Number of guessed args (if PD_NGUESS)
  int            npush;                // Number of pushed args (if PD_NPUSH)
  int            usedarg;              // Min. number of accessed arguments
  uchar          preserved;            // Preserved registers
  uchar          argopt[NGUESS];       // Guessed argument options, AO_xxx
} t_procdata;

typedef struct t_argnest {             // Header of call arguments bracket
  ulong          addr0;                // First address occupied by range
  ulong          addr1;                // Last occupied address (included!)
  ulong          type;                 // Level and user-defined type, TY_xxx
  ulong          aprev;                // First address of previous range
} t_argnest;

#define NLOOPVAR       4               // Max number of loop variables

typedef struct t_loopnest {            // Header of loop bracket
  ulong          addr0;                // First address occupied by range
  ulong          addr1;                // Last occupied address (included!)
  ulong          type;                 // Level and user-defined type, TY_xxx
  ulong          aprev;                // First address of previous range
  ulong          eoffs;                // Offset of entry point from addr0
  struct {                             // Loop registers and variables
    uchar        type;                 // Combination of PRED_xxx
    long         espoffset;            // For locals, offset to original ESP
    long         increment;            // Increment after loop
  } loopvar[NLOOPVAR];
} t_loopnest;

stdapi (ulong)   Getpackednetint(uchar *code,ulong size,ulong *value);
stdapi (void)    Removeanalysis(ulong base,ulong size,int keephittrace);
stdapi (int)     Maybecommand(ulong addr,int requireanalysis);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// STACK WALK //////////////////////////////////

#define SF_FMUNREL     0x00000001      // Predicted frame is unreliable
#define SF_BPUNREL     0x00000002      // Predicted EBP is unreliable
#define SF_VIRTUAL     0x00000004      // DBGHELP: EBP is undefined

typedef struct t_sframe {              // Stack frame descriptor
  // Input parameters, fill before call to Findretaddrdata().
  ulong          eip;                  // Address of command that owns frame
  ulong          esp;                  // ESP at EIP
  ulong          ebp;                  // EBP at EIP, or 0 if unknown
  // Parameters used by DBGHELP.DLL, initialize only before the first call.
  int            firstcall;            // First call to Findretaddrdata()
  HANDLE         thread;               // Thread handle
  CONTEXT        context;              // Copy of CONTEXT, fill on first call
  int            contextvalid;         // Whether context contains valid data
  // Output parameters.
  ulong          status;               // Set of SF_xxx
  ulong          oldeip;               // Address of CALL or 0 if unknown
  ulong          oldesp;               // ESP at CALL or 0 if unknown
  ulong          oldebp;               // EBP at CALL or 0 if unknown
  ulong          retpos;               // Address of return in stack
  ulong          procaddr;             // Entry of current function or 0
  // Parameters used by DBGHELP.DLL, don't initialize!
  #ifdef STACKFRAME64                  // Requires <dbghelp.h>
    STACKFRAME64 sf;                   // Stack frame for StackWalk64()
  #else
    uchar        dummy[264];           // Replaces STACKFRAME64
  #endif
} t_sframe;

stdapi (ulong)   Isretaddr(ulong retaddr,ulong *procaddr);
stdapi (int)     Findretaddrdata(t_sframe *pf,ulong base,ulong size);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// KNOWN FUNCTIONS ////////////////////////////////

#define NARG           24              // Max number of arguments in a function

#define ADEC_VALID     0x00000001      // Value valid
#define ADEC_PREDICTED 0x00000002      // Value predicted
#define ADEC_CHGNAME   0x00000004      // Allow name change of substituted arg
#define ADEC_MARK      0x00000008      // (out) Important parameter

// Type of argument in the description of function or structure. Note that
// ARG_STRUCT is allowed only in conjunction with ARG_POINTER.
#define ARG_POINTER    0x01            // Argument is a pointer
#define ARG_BASE       0x06            // Mask to extract base type of argument
#define   ARG_TYPE     0x00            // Argument is a type
#define   ARG_STRUCT   0x02            // Argument is a structure
#define   ARG_DIRECT   0x04            // Argument is a direct string
#define ARG_OUT        0x08            // Pointer to data undefined at call
#define ARG_MARK       0x10            // Important parameter
#define ARG_ELLIPSYS   0x20            // Followed by ellipsys
#define ARG_VALID      0x40            // Must always be set to avoid argx=0

#define ARG_TYPEMASK   (ARG_POINTER|ARG_BASE)    // Mask to extract full type

#define ARG_PTYPE      (ARG_POINTER|ARG_TYPE)    // Pointer to type
#define ARG_PSTRUCT    (ARG_POINTER|ARG_STRUCT)  // Pointer to structure

// Bits used to define type of function.
#define FN_C           0x00000001      // Does not remove arguments from stack
#define FN_PASCAL      0x00000002      // Removes arguments from stack on return
#define FN_NORETURN    0x00000004      // Does not return, like ExitProcess()
#define FN_VARARG      0x00000008      // Variable number of arguments
#define FN_EAX         0x00000100      // EAX on return is same as on entry
#define FN_ECX         0x00000200      // ECX on return is same as on entry
#define FN_EDX         0x00000400      // EDX on return is same as on entry
#define FN_EBX         0x00000800      // EBX on return is same as on entry
#define FN_ESP         0x00001000      // ESP on return is same as on entry
#define FN_EBP         0x00002000      // EBP on return is same as on entry
#define FN_ESI         0x00004000      // ESI on return is same as on entry
#define FN_EDI         0x00008000      // EDI on return is same as on entry
#define FN_USES_EAX    0x00010000      // EAX is used as register parameter
#define FN_USES_ECX    0x00020000      // ECX is used as register parameter
#define FN_USES_EDX    0x00040000      // EDX is used as register parameter
#define FN_USES_EBX    0x00080000      // EBX is used as register parameter
#define FN_USES_ESP    0x00100000      // ESP is used as register parameter
#define FN_USES_EBP    0x00200000      // EBP is used as register parameter
#define FN_USES_ESI    0x00400000      // ESI is used as register parameter
#define FN_USES_EDI    0x00800000      // EDI on return is same as on entry

#define FN_FUNCTION    0
#define FN_STDFUNC     (FN_PASCAL|FN_EBX|FN_EBP|FN_ESI|FN_EDI)
#define FN_STDC        (FN_C|FN_EBX|FN_EBP|FN_ESI|FN_EDI)

typedef struct t_argdec {              // Descriptor of function argument
  ulong          mode;                 // Value descriptor, set of ADEC_xxx
  ulong          value;                // Value on the stack
  ulong          pushaddr;             // Address of command that pushed data
  wchar_t        prtype[SHORTNAME];    // Type of argument with ARG_xxx prefix
  wchar_t        name[TEXTLEN];        // Decoded name of argument
  wchar_t        text[TEXTLEN];        // Decoded value (if valid or predicted)
} t_argdec;

typedef struct t_strdec {              // Decoded structure item
  ulong          size;                 // Item size, bytes
  ulong          addr;                 // Address of the first byte
  ulong          value;                // Item value (only if size<=4!)
  uchar          valuevalid;           // Whether value is valid
  uchar          dec;                  // One of DEC_TYPEMASK subfields
  uchar          decsize;              // Size of decoding element
  uchar          reserved;             // Reserved for the future
  wchar_t        prtype[SHORTNAME];    // Type of item with ARG_xxx prefix
  wchar_t        name[TEXTLEN];        // Name of item
  wchar_t        text[TEXTLEN];        // Decoded value
} t_strdec;

typedef struct t_rawdata {             // Header of raw data block
  ulong          size;                 // Data size, bytes
  ulong          hasmask;              // Data is followed by mask
  ulong          features;             // Data features
} t_rawdata;                           // Data & mask immediately follow header

typedef struct t_argloc {              // Information about stack args & locals
  ulong          fntype;               // Calling convention, set of FN_xxx
  int            retfeatures;          // Return features, set of ARG_xxx
  int            retsize;              // Size of returned value
  wchar_t        rettype[SHORTNAME];   // Type of the returned value
  int            argvalid;             // Whether arg[] below is valid
  struct {                             // List of arguments
    int          features;             // Argument features, set of ARG_xxx
    int          size;                 // Size of argument on the stack
    wchar_t      name[TEXTLEN];        // Name of the argument
    wchar_t      type[SHORTNAME];      // Type of the argument
  } arg[NARG];
} t_argloc;

stdapi (int)     Getconstantbyname(wchar_t *name,ulong *value);
stdapi (int)     Getconstantbyvalue(wchar_t *groupname,
                   ulong value,wchar_t *name);
stdapi (int)     Decodetype(ulong data,wchar_t *type,wchar_t *text,int ntext);
stdapi (int)     Fillcombowithgroup(HWND hw,wchar_t *groupname,
                   int sortbyname,ulong select);
stdapi (int)     Fillcombowithstruct(HWND hw,wchar_t *prefix,wchar_t *select);
stdapi (t_rawdata *) Getrawdata(wchar_t *name);
stdapi (int)     Substitutehkeyprefix(wchar_t *key);
stdapi (int)     Decodeknownbyname(wchar_t *name,t_procdata *pd,
                   t_argdec adec[NARG],wchar_t *rettype,int nexp);
stdapi (int)     Decodeknownbyaddr(ulong addr,t_procdata *pd,
                   t_argdec adec[NARG],wchar_t *rettype,wchar_t *name,
                   int nexp,int follow);
stdapi (int)     Isnoreturn(ulong addr);
stdapi (int)     Decodeargument(t_module *pmod,wchar_t *prtype,void *data,
                   int ndata,wchar_t *text,int ntext,int *nontriv);
stdapi (int)     Getstructureitemcount(wchar_t *name,ulong *size);
stdapi (int)     Findstructureitembyoffset(wchar_t *name,ulong offset);
stdapi (int)     Decodestructure(wchar_t *name,ulong addr,int item0,
                   t_strdec *str,int nstr);
stdapi (ulong)   Getstructureitemvalue(uchar *code,ulong ncode,
                   wchar_t *name,wchar_t *itemname,void *value,ulong nvalue);


////////////////////////////////////////////////////////////////////////////////
////////////////////// EXPRESSIONS, WATCHES AND INSPECTORS /////////////////////

#define NEXPR          16              // Max. no. of expressions in EMOD_MULTI

// Mode of expression evaluation.
#define EMOD_CHKEXTRA  0x00000001      // Report extra characters on line
#define EMOD_NOVALUE   0x00000002      // Don't convert data to text
#define EMOD_NOMEMORY  0x00000004      // Don't read debuggee's memory
#define EMOD_MULTI     0x00000008      // Allow multiple expressions

#define EXPR_TYPEMASK  0x0F            // Mask to extract type of expression
#define   EXPR_INVALID 0x00            // Invalid or undefined expression
#define   EXPR_BYTE    0x01            // 8-bit integer byte
#define   EXPR_WORD    0x02            // 16-bit integer word
#define   EXPR_DWORD   0x03            // 32-bit integer doubleword
#define   EXPR_FLOAT4  0x04            // 32-bit floating-point number
#define   EXPR_FLOAT8  0x05            // 64-bit floating-point number
#define   EXPR_FLOAT10 0x06            // 80-bit floating-point number
#define   EXPR_SEG     0x07            // Segment
#define   EXPR_ASCII   0x08            // Pointer to ASCII string
#define   EXPR_UNICODE 0x09            // Pointer to UNICODE string
#define   EXPR_TEXT    0x0A            // Immediate UNICODE string
#define EXPR_REG       0x10            // Origin is register
#define EXPR_SIGNED    0x20            // Signed integer

#define EXPR_SIGDWORD  (EXPR_DWORD|EXPR_SIGNED)

typedef struct t_result {              // Result of expression's evaluation
  int            lvaltype;             // Type of expression, EXPR_xxx
  ulong          lvaladdr;             // Address of lvalue or NULL
  int            datatype;             // Type of data, EXPR_xxx
  int            repcount;             // Repeat count (0..32, 0 means default)
  union {
    uchar        data[10];             // Value as set of bytes
    ulong        u;                    // Value as address or unsigned integer
    long         l;                    // Value as signed integer
    long double  f; };                 // Value as 80-bit float
  wchar_t        value[TEXTLEN];       // Value decoded to string
} t_result;

typedef struct t_watch {               // Watch descriptor
  ulong          addr;                 // 0-based watch index
  ulong          size;                 // Reserved, always 1
  ulong          type;                 // Service information, TY_xxx
  wchar_t        expr[TEXTLEN];        // Watch expression
} t_watch;

stdapi (int)     Cexpression(wchar_t *expression,uchar *cexpr,int nexpr,
                   int *explen,wchar_t *err,ulong mode);
stdapi (int)     Exprcount(uchar *cexpr);
stdapi (int)     Eexpression(t_result *result,wchar_t *expl,uchar *cexpr,
                   int index,uchar *data,ulong base,ulong size,ulong threadid,
                   ulong a,ulong b,ulong mode);
stdapi (int)     Expression(t_result *result,wchar_t *expression,uchar *data,
                   ulong base,ulong size,ulong threadid,ulong a,ulong b,
                   ulong mode);
stdapi (int)     Fastexpression(t_result *result,ulong addr,int type,
                   ulong threadid);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////// DIALOGS AND OPTIONS //////////////////////////////

// Mode bits in calls to dialog functions.
#define DIA_SIZEMASK   0x0000001F      // Mask to extract default data size
#define   DIA_BYTE     0x00000001      // Byte data size
#define   DIA_WORD     0x00000002      // Word data size
#define   DIA_DWORD    0x00000004      // Doubleword data size (default)
#define   DIA_QWORD    0x00000008      // Quadword data size
#define   DIA_TBYTE    0x0000000A      // 10-byte data size
#define   DIA_DQWORD   0x00000010      // 16-byte data size
#define DIA_HEXONLY    0x00000020      // Hexadecimal format only
#define DIA_EXTENDED   0x00000040      // Extended format
#define DIA_DATAVALID  0x00000080      // Input data valid (edit mode)
#define DIA_DEFMASK    0x00000F00      // Mask to extract default data type
#define   DIA_DEFHEX   0x00000100      // On startup, cursor in hex control
#define   DIA_DEFSIG   0x00000200      // On startup, cursor in signed control
#define   DIA_DEFUNSIG 0x00000300      // On startup, cursor in unsigned control
#define   DIA_DEFASC   0x00000400      // On startup, cursor in ASCII control
#define   DIA_DEFUNI   0x00000500      // On startup, cursor in UNICODE control
#define   DIA_DEFCODE  0x00000600      // Default is code breakpoint
#define   DIA_DEFFLOAT 0x00000700      // Default selection is float
#define DIA_ISSEARCH   0x00001000      // Is a search dialog
#define DIA_ASKCASE    0x00002000      // Ask if case-insensitive
#define DIA_SEARCHDIR  0x00004000      // Includes direction search buttons
#define DIA_HISTORY    0x00008000      // Supports history
#define DIA_SELMASK    0x000F0000      // Mask to extract selection offset
#define   DIA_SEL0     0x00000000      // Select least significant item
#define   DIA_SEL4     0x00040000      // Select item with offset 4
#define   DIA_SEL8     0x00080000      // Select item with offset 8
#define   DIA_SEL12    0x000C0000      // Select item with offset 12
#define   DIA_SEL14    0x000E0000      // Select item with offset 14
#define DIA_JMPMODE    0x00300000      // Mask for jump/call/switch display
#define   DIA_JMPFROM  0x00000000      // Jumps/calls from specified location
#define   DIA_JMPTO    0x00100000      // Jumps/calls to specified location
#define   DIA_SWITCH   0x00200000      // Switches
#define DIA_JMPGLOB    0x00400000      // Show global jumps and calls
#define DIA_JMPLOC     0x00000000      // Show local jumps and calls
#define DIA_UTF8       0x00800000      // Support for UTF8
#define DIA_ABSXYPOS   0x10000000      // Use X-Y dialog coordinates as is
#define DIA_RESTOREPOS 0x20000000      // Restore X-Y dialog coordinates

// Types of controls that can be used in dialogs.
#define CA_END         0               // End of control list with dialog size
#define CA_COMMENT     1               // Dummy entry in control list
#define CA_TEXT        2               // Simple left-aligned text
#define CA_TEXTC       4               // Simple centered text
#define CA_TEXTR       5               // Simple right-aligned text
#define CA_WARN        6               // Multiline text, highlighted if differ
#define CA_WTEXT       7               // Text with white bg in sunken frame
#define CA_TITLE       8               // Fat centered text
#define CA_FRAME       9               // Etched frame
#define CA_SUNK        10              // Sunken frame
#define CA_GROUP       11              // Group box (named frame)
#define CA_EDIT        12              // Standard edit control
#define CA_NOEDIT      13              // Read-only edit control
#define CA_EDITHEX     14              // Standard edit control, hex uppercase
#define CA_MULTI       15              // Multiline edit control (DATALEN)
#define CA_NOMULTI     16              // Multiline read-only edit (DATALEN)
#define CA_BTN         17              // Standard pushbutton
#define CA_DEFBTN      18              // Standard default pushbutton
#define CA_COMBO       19              // Combo box control, specified font
#define CA_COMBOFIX    20              // Combo box control, fixed width font
#define CA_CEDIT       21              // Combo edit control, specified font
#define CA_CEDITFIX    22              // Combo edit control, fixed width font
#define CA_CESAV0      32              // Combo edit 0 with autosave & UNICODE
#define CA_CESAV1      33              // Combo edit 1 with autosave & UNICODE
#define CA_CESAV2      34              // Combo edit 2 with autosave & UNICODE
#define CA_CESAV3      35              // Combo edit 3 with autosave & UNICODE
#define CA_CESAV4      36              // Combo edit 4 with autosave & UNICODE
#define CA_CESAV5      37              // Combo edit 5 with autosave & UNICODE
#define CA_CESAV6      38              // Combo edit 6 with autosave & UNICODE
#define CA_CESAV7      39              // Combo edit 7 with autosave & UNICODE
#define CA_LIST        48              // Simple list box
#define CA_LISTFIX     49              // Simple list box, fixed font
#define CA_CHECK       62              // Auto check box, left-aligned
#define CA_CHECKR      63              // Auto check box, right-aligned
#define CA_BIT0        64              // Auto check box, bit 0
#define CA_BIT1        65              // Auto check box, bit 1
#define CA_BIT2        66              // Auto check box, bit 2
#define CA_BIT3        67              // Auto check box, bit 3
#define CA_BIT4        68              // Auto check box, bit 4
#define CA_BIT5        69              // Auto check box, bit 5
#define CA_BIT6        70              // Auto check box, bit 6
#define CA_BIT7        71              // Auto check box, bit 7
#define CA_BIT8        72              // Auto check box, bit 8
#define CA_BIT9        73              // Auto check box, bit 9
#define CA_BIT10       74              // Auto check box, bit 10
#define CA_BIT11       75              // Auto check box, bit 11
#define CA_BIT12       76              // Auto check box, bit 12
#define CA_BIT13       77              // Auto check box, bit 13
#define CA_BIT14       78              // Auto check box, bit 14
#define CA_BIT15       79              // Auto check box, bit 15
#define CA_BIT16       80              // Auto check box, bit 16
#define CA_BIT17       81              // Auto check box, bit 17
#define CA_BIT18       82              // Auto check box, bit 18
#define CA_BIT19       83              // Auto check box, bit 19
#define CA_BIT20       84              // Auto check box, bit 20
#define CA_BIT21       85              // Auto check box, bit 21
#define CA_BIT22       86              // Auto check box, bit 22
#define CA_BIT23       87              // Auto check box, bit 23
#define CA_BIT24       88              // Auto check box, bit 24
#define CA_BIT25       89              // Auto check box, bit 25
#define CA_BIT26       90              // Auto check box, bit 26
#define CA_BIT27       91              // Auto check box, bit 27
#define CA_BIT28       92              // Auto check box, bit 28
#define CA_BIT29       93              // Auto check box, bit 29
#define CA_BIT30       94              // Auto check box, bit 30
#define CA_BIT31       95              // Auto check box, bit 31
#define CA_RADIO0      96              // Radio button, value 0
#define CA_RADIO1      97              // Radio button, value 1
#define CA_RADIO2      98              // Radio button, value 2
#define CA_RADIO3      99              // Radio button, value 3
#define CA_RADIO4      100             // Radio button, value 4
#define CA_RADIO5      101             // Radio button, value 5
#define CA_RADIO6      102             // Radio button, value 6
#define CA_RADIO7      103             // Radio button, value 7
#define CA_RADIO8      104             // Radio button, value 8
#define CA_RADIO9      105             // Radio button, value 9
#define CA_RADIO10     106             // Radio button, value 10
#define CA_RADIO11     107             // Radio button, value 11
#define CA_RADIO12     108             // Radio button, value 12
#define CA_RADIO13     109             // Radio button, value 13
#define CA_RADIO14     110             // Radio button, value 14
#define CA_RADIO15     111             // Radio button, value 15
#define CA_CUSTOM      124             // Custom control
#define CA_CUSTSF      125             // Custom control with sunken frame
// Controls with special functions that work only in Options dialog.
#define CA_FILE        129             // Edit file (autosave, MAXPATH chars)
#define CA_BROWSE      130             // Browse file name pushbutton
#define CA_BRDIR       131             // Browse directory pushbutton
#define CA_LANGS       132             // Combobox with list of languages
#define CA_FONTS       133             // Combobox with list of fonts
#define CA_FHTOP       134             // Combobox that adjusts top font height
#define CA_FHBOT       135             // Combobox that adjusts bottom font hgt
#define CA_SCHEMES     136             // Combobox with list of schemes
#define CA_HILITE      137             // Combobox with list of hilites
#define CA_HILITE1     138             // Combobox with nontrivial hilites

// Modes of font usage in dialog windows, if applies.
#define DFM_SYSTEM     0               // Use system font
#define DFM_PARENT     1               // Use font of parent window
#define DFM_FIXED      2               // Use dlgfontindex
#define DFM_FIXALL     3               // Use dlgfontindex for all controls

#define HEXLEN         1024            // Max length of hex edit string, bytes

#define NSEARCHCMD     128             // Max number of assembler search models

typedef struct t_control {             // Descriptor of dialog control
  ulong          type;                 // Type of control, CA_xxx
  int            id;                   // Control's ID or -1 if unimportant
  int            x;                    // X coordinate, chars/4
  int            y;                    // Y coordinate, chars/8
  int            dx;                   // X size, chars/4
  int            dy;                   // Y size, chars/8
  int            *var;                 // Pointer to control variable or NULL
  wchar_t        *text;                // Name or contents of the control
  wchar_t        *help;                // Tooltip or NULL
  int            oldvar;               // Copy of control variable, internal
} t_control;

typedef struct t_dialog {              // Descriptor of OllyDbg dialog
  t_control      *controls;            // List of controls to place in dialog
  wchar_t        *title;               // Pointer to the dialog's title
  int            focus;                // ID of control with focus
  int            item;                 // Index of processing item
  ulong          u;                    // Doubleword data
  uchar          data[16];             // Data in other formats
  ulong          addr0;                // Address
  ulong          addr1;                // Address
  int            letter;               // First character entered in dialog
  int            x;                    // X reference screen coordinate
  int            y;                    // Y reference screen coordinate
  int            fi;                   // Index of font to use in dialog
  int            mode;                 // Dialog operation mode, set of DIA_xxx
  int            cesav[8];             // NM_xxx of CA_CESAVn
  HFONT          fixfont;              // Fixed font used in dialog
  int            isfullunicode;        // Whether fixfont UNICODE
  int            fixdx;                // Width of dialog fixed font
  int            fixdy;                // Height of dialog fixed font
  HWND           htooltip;             // Handle of tooltip window
  HWND           hwwarn;               // Handle of WARN control, if any
  int            initdone;             // WM_INITDIALOG finished
} t_dialog;

// ATTENTION, size of structure t_hexstr must not exceed DATALEN!
typedef struct t_hexstr {              // Data for hex/text search
  ulong          n;                    // Data length, bytes
  ulong          nmax;                 // Maximal data length, bytes
  uchar          data[HEXLEN];         // Data
  uchar          mask[HEXLEN];         // Mask, 0 bits are masked
} t_hexstr;

typedef int  BROWSECODEFUNC(int,void *,ulong *,wchar_t *);

stdapi (t_control *) Findcontrol(HWND hw);
stdapi (int)     Defaultactions(HWND hparent,t_control *pctr,
                   WPARAM wp,LPARAM lp);
stdapi (void)    Addstringtocombolist(HWND hc,wchar_t *s);
stdapi (int)     Preparedialog(HWND hw,t_dialog *pdlg);
stdapi (int)     Endotdialog(HWND hw,int result);
stdapi (int)     Getregister(HWND hparent,int reg,ulong *data,int letter,
                   int x,int y,int fi,int mode);
stdapi (int)     Getinteger(HWND hparent,wchar_t *title,ulong *data,int letter,
                   int x,int y,int fi,int mode);
stdapi (int)     Getdword(HWND hparent,wchar_t *title,ulong *data,int letter,
                   int x,int y,int fi,int mode);
stdapi (int)     Getlasterrorcode(HWND hparent,wchar_t *title,ulong *data,
                   int letter,int x,int y,int fi);
stdapi (int)     Getaddressrange(HWND hparent,wchar_t *title,
                   ulong *rmin,ulong *rmax,int x,int y,int fi,int mode);
stdapi (int)     Getexceptionrange(HWND hparent,wchar_t *title,
                   ulong *rmin,ulong *rmax,int x,int y,int fi);
stdapi (int)     Getstructuretype(HWND hparent,wchar_t *title,wchar_t *text,
                   wchar_t *strname,int x,int y,int fi);
stdapi (int)     Getfpureg(HWND hparent,int reg,void *data,int letter,
                   int x,int y,int fi);
stdapi (int)     Get3dnow(HWND hparent,wchar_t *title,void *data,int letter,
                   int x,int y,int fi,int mode);
stdapi (int)     Getfloat(HWND hparent,wchar_t *title,void *data,int letter,
                   int x,int y,int fi,int mode);
stdapi (int)     Getmmx(HWND hparent,wchar_t *title,void *data,int letter,
                   int x,int y,int fi);
stdapi (int)     Getsse(HWND hparent,wchar_t *title,void *data,int letter,
                   int x,int y,int fi,int mode);
stdapi (int)     Getstring(HWND hparent,wchar_t *title,wchar_t *s,int length,
                   int savetype,int letter,int x,int y,int fi,int mode);
stdapi (int)     Getdwordexpression(HWND hparent,wchar_t *title,ulong *u,
                   ulong threadid,int savetype,int x,int y,int fi,int mode);
stdapi (int)     Getgotoexpression(HWND hparent,wchar_t *title,ulong *u,
                   ulong threadid,int savetype,int x,int y,int fi,int mode);
stdapi (int)     Asmindump(HWND hparent,wchar_t *title,struct t_dump *pd,
                   int letter,int x,int y,int fi,int mode);
stdapi (int)     Getasmsearchmodel(HWND hparent,wchar_t *title,t_asmmod *model,
                   int nmodel,int x,int y,int fi,int mode);
stdapi (int)     Getseqsearchmodel(HWND hparent,wchar_t *title,t_asmmod *model,
                   int nmodel,int x,int y,int fi,int mode);
stdapi (int)     Binaryedit(HWND hparent,wchar_t *title,t_hexstr *hstr,
                   int letter,int x,int y,int fi,int mode);
stdapi (int)     Getpredefinedtypebyindex(int fnindex,wchar_t *type);
stdapi (int)     Getindexbypredefinedtype(wchar_t *type);
stdapi (int)     Condbreakpoint(HWND hparent,ulong *addr,int naddr,
                   wchar_t *title,int x,int y,int fi);
stdapi (int)     Condlogbreakpoint(HWND hparent,ulong *addr,int naddr,
                   int fnindex,wchar_t *title,int x,int y,int fi);
stdapi (int)     Membreakpoint(HWND hparent,ulong addr,ulong size,
                   int x,int y,int fi,int mode);
stdapi (int)     Memlogbreakpoint(HWND hparent,ulong addr,ulong size,
                   int x,int y,int fi,int mode);
stdapi (int)     Hardbreakpoint(HWND hparent,ulong addr,
                   int x,int y,int fi,int mode);
stdapi (int)     Hardlogbreakpoint(HWND hparent,ulong addr,int fnindex,
                   int x,int y,int fi,int mode);
stdapi (void)    Setrtcond(HWND hparent,int x,int y,int fi);
stdapi (void)    Setrtprot(HWND hparent,int x,int y,int fi);
stdapi (ulong)   Browsecodelocations(HWND hparent,wchar_t *title,
                   BROWSECODEFUNC *bccallback,void *data);
stdapi (int)     Fillcombowithcodepages(HWND hw,int select);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// PLUGIN OPTIONS ////////////////////////////////

#define OPT_TITLE      9001            // Pane title
#define OPT_1          9011            // First automatical control
#define OPT_2          9012            // Second automatical control
#define OPT_3          9013            // Third automatical control
#define OPT_4          9014            // Fourth automatical control
#define OPT_5          9015            // Fifth automatical control
#define OPT_6          9016            // Sixth automatical control
#define OPT_7          9017            // Seventh automatical control
#define OPT_8          9018            // Eighth automatical control
#define OPT_9          9019            // Ninth automatical control
#define OPT_10         9020            // Tenth automatical control
#define OPT_11         9021            // Eleventh automatical control
#define OPT_12         9022            // Twelfth automatical control
#define OPT_13         9023            // Thirteen automatical control
#define OPT_14         9024            // Fourteen automatical control
#define OPT_15         9025            // Fifteen automatical control
#define OPT_16         9026            // Sixteen automatical control
#define OPT_17         9027            // Seventeen automatical control
#define OPT_18         9028            // Eighteen automatical control
#define OPT_19         9029            // Nineteen automatical control
#define OPT_20         9030            // Twentieth automatical control
#define OPT_21         9031            // Twenty-first automatical control
#define OPT_22         9032            // Twenty-second automatical control
#define OPT_23         9033            // Twenty-third automatical control
#define OPT_24         9034            // Twenty-fourth automatical control
#define OPT_W1         9101            // First automatical autowarn control
#define OPT_W2         9102            // Second automatical autowarn control
#define OPT_W3         9103            // Third automatical autowarn control
#define OPT_W4         9104            // Fourth automatical autowarn control
#define OPT_W5         9105            // Fifth automatical autowarn control
#define OPT_W6         9106            // Sixth automatical autowarn control
#define OPT_W7         9107            // Seventh automatical autowarn control
#define OPT_W8         9108            // Eighth automatical autowarn control
#define OPT_W9         9109            // Ninth automatical autowarn control
#define OPT_W10        9110            // Tenth automatical autowarn control
#define OPT_W11        9111            // Eleventh automatical autowarn control
#define OPT_W12        9112            // Twelfth automatical autowarn control
#define OPT_S1         9121            // First autowarn-if-turned-on control
#define OPT_S2         9122            // Second autowarn-if-turned-on control
#define OPT_S3         9123            // Third autowarn-if-turned-on control
#define OPT_S4         9124            // Fourth autowarn-if-turned-on control
#define OPT_S5         9125            // Fifth autowarn-if-turned-on control
#define OPT_S6         9126            // Sixth autowarn-if-turned-on control
#define OPT_S7         9127            // Seventh autowarn-if-turned-on control
#define OPT_S8         9128            // Eighth autowarn-if-turned-on control
#define OPT_S9         9129            // Ninth autowarn-if-turned-on control
#define OPT_S10        9130            // Tenth autowarn-if-turned-on control
#define OPT_S11        9131            // Eleventh autowarn-if-turned-on control
#define OPT_S12        9132            // Twelfth autowarn-if-turned-on control
#define OPT_X1         9141            // First autowarn-if-all-on control
#define OPT_X2         9142            // Second autowarn-if-all-on control
#define OPT_X3         9143            // Third autowarn-if-all-on control
#define OPT_X4         9144            // Fourth autowarn-if-all-on control
#define OPT_X5         9145            // Fifth autowarn-if-all-on control
#define OPT_X6         9146            // Sixth autowarn-if-all-on control
#define OPT_X7         9147            // Seventh autowarn-if-all-on control
#define OPT_X8         9148            // Eighth autowarn-if-all-on control
#define OPT_X9         9149            // Ninth autowarn-if-all-on control
#define OPT_X10        9150            // Tenth autowarn-if-all-on control
#define OPT_X11        9151            // Eleventh autowarn-if-all-on control
#define OPT_X12        9152            // Twelfth autowarn-if-all-on control

#define OPT_CUSTMIN    9500            // Custom controls by plugins
#define OPT_CUSTMAX    9999            // End of custom area


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// COMMENTS ///////////////////////////////////

// Comments types used by Commentaddress().
#define COMM_USER      0x00000001      // Add user-defined comment
#define COMM_MARK      0x00000002      // Add important arguments
#define COMM_PROC      0x00000004      // Add procedure description
#define COMM_ALL       0xFFFFFFFF      // Add all possible comments

stdapi (int)     Stringtotext(wchar_t *data,int ndata,wchar_t *text,int ntext,
                   int stopatzero);
stdapi (int)     Isstring(ulong addr,int isstatic,wchar_t *symb,int nsymb);
stdapi (int)     Squeezename(wchar_t *dest,int ndest,wchar_t *src,int nsrc);
stdapi (void)    Uncapitalize(wchar_t *s);
stdapi (int)     Decoderelativeoffset(ulong addr,int addrmode,
                   wchar_t *symb,int nsymb);
stdapi (int)     Decodeaddress(ulong addr,ulong amod,int mode,
                   wchar_t *symb,int nsymb,wchar_t *comment);
stdapi (int)     Decodearglocal(ulong ip,ulong offs,ulong datasize,
                   wchar_t *name,int len);
stdapi (int)     Getanalysercomment(struct t_module *pmod,ulong addr,
                   wchar_t *comment,int len);
stdapi (int)     Getswitchcomment(ulong addr,wchar_t *comment,int len);
stdapi (int)     Getloopcomment(struct t_module *pmod,ulong addr,int level,
                   wchar_t *comment,int len);
stdapi (int)     Getproccomment(ulong addr,ulong acall,
                   wchar_t *comment,int len,int argonly);
stdapi (int)     Commentaddress(ulong addr,int typelist,
                   wchar_t *comment,int len);


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// LOG WINDOW //////////////////////////////////

stdapi (void)    Redrawlist(void);
varapi (void)    Addtolist(ulong addr,int color,wchar_t *format,...);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// DUMP /////////////////////////////////////

#define DU_STACK       0x80000000      // Used for internal purposes
#define DU_NOSMALL     0x40000000      // Used for internal purposes
#define DU_MODEMASK    0x3C000000      // Mask for mode bits
#define   DU_SMALL     0x20000000      // Small-size dump
#define   DU_FIXADDR   0x10000000      // Fix first visible address
#define   DU_BACKUP    0x08000000      // Display backup instead of actual data
#define   DU_USEDEC    0x04000000      // Show contents using decoding data
#define DU_COMMMASK    0x03000000      // Mask for disassembly comments
#define   DU_COMMENT   0x00000000      // Show comments
#define   DU_SOURCE    0x01000000      // Show source
#define DU_DISCARD     0x00800000      // Discardable by Esc
#define DU_PROFILE     0x00400000      // Show profile
#define DU_TYPEMASK    0x003F0000      // Mask for dump type
#define   DU_HEXTEXT   0x00010000      // Hexadecimal dump with ASCII text
#define   DU_HEXUNI    0x00020000      // Hexadecimal dump with UNICODE text
#define   DU_TEXT      0x00030000      // Character dump
#define   DU_UNICODE   0x00040000      // Unicode dump
#define   DU_INT       0x00050000      // Integer signed dump
#define   DU_UINT      0x00060000      // Integer unsigned dump
#define   DU_IHEX      0x00070000      // Integer hexadecimal dump
#define   DU_FLOAT     0x00080000      // Floating-point dump
#define   DU_ADDR      0x00090000      // Address dump
#define   DU_ADRASC    0x000A0000      // Address dump with ASCII text
#define   DU_ADRUNI    0x000B0000      // Address dump with UNICODE text
#define   DU_DISASM    0x000C0000      // Disassembly
#define   DU_DECODE    0x000D0000      // Same as DU_DISASM but for decoded data
#define DU_COUNTMASK   0x0000FF00      // Mask for number of items/line
#define DU_SIZEMASK    0x000000FF      // Mask for size of single item

#define DU_MAINPART    (DU_TYPEMASK|DU_COUNTMASK|DU_SIZEMASK)

#define DUMP_HEXA8     0x00010801      // Hex/ASCII dump, 8 bytes per line
#define DUMP_HEXA16    0x00011001      // Hex/ASCII dump, 16 bytes per line
#define DUMP_HEXU8     0x00020801      // Hex/UNICODE dump, 8 bytes per line
#define DUMP_HEXU16    0x00021001      // Hex/UNICODE dump, 16 bytes per line
#define DUMP_ASC32     0x00032001      // ASCII dump, 32 characters per line
#define DUMP_ASC64     0x00034001      // ASCII dump, 64 characters per line
#define DUMP_UNI16     0x00041002      // UNICODE dump, 16 characters per line
#define DUMP_UNI32     0x00042002      // UNICODE dump, 32 characters per line
#define DUMP_UNI64     0x00044002      // UNICODE dump, 64 characters per line
#define DUMP_INT16     0x00050802      // 16-bit signed integer dump, 8 items
#define DUMP_INT16S    0x00050402      // 16-bit signed integer dump, 4 items
#define DUMP_INT32     0x00050404      // 32-bit signed integer dump, 4 items
#define DUMP_INT32S    0x00050204      // 32-bit signed integer dump, 2 items
#define DUMP_UINT16    0x00060802      // 16-bit unsigned integer dump, 8 items
#define DUMP_UINT16S   0x00060402      // 16-bit unsigned integer dump, 4 items
#define DUMP_UINT32    0x00060404      // 32-bit unsigned integer dump, 4 items
#define DUMP_UINT32S   0x00060204      // 32-bit unsigned integer dump, 2 items
#define DUMP_IHEX16    0x00070802      // 16-bit hex integer dump, 8 items
#define DUMP_IHEX16S   0x00070402      // 16-bit hex integer dump, 4 items
#define DUMP_IHEX32    0x00070404      // 32-bit hex integer dump, 4 items
#define DUMP_IHEX32S   0x00070204      // 32-bit hex integer dump, 2 items
#define DUMP_FLOAT32   0x00080404      // 32-bit floats, 4 items
#define DUMP_FLOAT32S  0x00080104      // 32-bit floats, 1 item
#define DUMP_FLOAT64   0x00080208      // 64-bit floats, 2 items
#define DUMP_FLOAT64S  0x00080108      // 64-bit floats, 1 item
#define DUMP_FLOAT80   0x0008010A      // 80-bit floats
#define DUMP_ADDR      0x00090104      // Address dump
#define DUMP_ADDRASC   0x000A0104      // Address dump with ASCII text
#define DUMP_ADDRUNI   0x000B0104      // Address dump with UNICODE text
#define DUMP_DISASM    0x000C0110      // Disassembly (max. 16 bytes per cmd)
#define DUMP_DECODE    0x000D0110      // Decoded data (max. 16 bytes per line)

// Types of dump menu in t_dump.menutype.
#define DMT_FIXTYPE    0x00000001      // Fixed dump type, no change
#define DMT_STRUCT     0x00000002      // Dump of the structure
#define DMT_CPUMASK    0x00070000      // Dump belongs to CPU window
#define   DMT_CPUDASM  0x00010000      // This is CPU Disassembler pane
#define   DMT_CPUDUMP  0x00020000      // This is CPU Dump pane
#define   DMT_CPUSTACK 0x00040000      // This is CPU Stack pane

// Modes of Scrolldumpwindow().
#define SD_REALIGN     0x01            // Realign on specified address
#define SD_CENTERY     0x02            // Center destination vertically

// Modes of t_dump.dumpselfunc() and Reportdumpselection().
#define SCH_SEL0       0x01            // t_dump.sel0 changed
#define SCH_SEL1       0x02            // t_dump.sel1 changed

// Modes of Copydumpselection().
#define CDS_TITLES     0x00000001      // Prepend window name and column titles
#define CDS_NOGRAPH    0x00000002      // Replace graphical symbols by spaces

typedef void DUMPSELFUNC(struct t_dump *,int);

typedef struct t_dump {                // Descriptor of dump data and window
  ulong          base;                 // Start of memory block or file
  ulong          size;                 // Size of memory block or file
  ulong          dumptype;             // Dump type, DU_xxx+count+size=DUMP_xxx
  ulong          menutype;             // Menu type, set of DMT_xxx
  ulong          itemwidth;            // Width of one item, characters
  ulong          threadid;             // Use decoding and registers if not 0
  t_table        table;                // Dump window is a custom table
  ulong          addr;                 // Address of first visible byte
  ulong          sel0;                 // Address of first selected byte
  ulong          sel1;                 // Last selected byte (not included!)
  ulong          selstart;             // Addr of first byte of selection start
  ulong          selend;               // Addr of first byte of selection end
  uchar          *filecopy;            // Copy of the file or NULL
  wchar_t        path[MAXPATH];        // Name of displayed file
  uchar          *backup;              // Old backup of memory/file or NULL
  wchar_t        strname[SHORTNAME];   // Name of the structure to decode
  uchar          *decode;              // Local decoding information or NULL
  wchar_t        bkpath[MAXPATH];      // Name of last used backup file
  int            relreg;               // Addresses relative to register
  ulong          reladdr;              // Addresses relative to this address
  ulong          hilitereg;            // One of OP_SOMEREG if reg highlighting
  int            hiregindex;           // Index of register to highlight
  ulong          graylimit;            // Gray data below this address
  DUMPSELFUNC    *dumpselfunc;         // Callback indicating change of sel0
} t_dump;

stdapi (void)    Setdumptype(t_dump *pd,ulong dumptype);
stdapi (int)     Ensurememorybackup(t_memory *pmem,int makebackup);
stdapi (void)    Backupusercode(struct t_module *pm,int force);
stdapi (HGLOBAL) Copydumpselection(t_dump *pd,int mode);
stdapi (ulong)   Dumpback(t_dump *pd,ulong addr,int n);
stdapi (ulong)   Dumpforward(t_dump *pd,ulong addr,int n);
stdapi (ulong)   Scrolldumpwindow(t_dump *pd,ulong addr,int mode);
stdapi (int)     Alignselection(t_dump *pd,ulong *sel0,ulong *sel1);
stdapi (int)     Getproclimits(ulong addr,ulong *amin,ulong *amax);
stdapi (int)     Getextproclimits(ulong addr,ulong *amin,ulong *amax);
stdapi (int)     Newdumpselection(t_dump *pd,ulong addr,ulong size);
stdapi (t_dump *) Findfiledump(wchar_t *path);
stdapi (HWND)    Createdumpwindow(wchar_t *title,ulong base,ulong size,
                   wchar_t *path,ulong dumptype,ulong sel0,ulong sel1,
                   wchar_t *strname);
stdapi (HWND)    Embeddumpwindow(HWND hw,t_dump *pd,ulong dumptype);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////// SEARCH ////////////////////////////////////

// Layouts of search panel.
#define SL_UNDEF       0               // Undefined layout
#define SL_DISASM      1               // Commands or refs within one module
#define SL_SEQASM      2               // Sequences within one module
#define SL_STRINGS     3               // Referenced strings within one module
#define SL_GUIDS       4               // Referenced GUIDs within one module
#define SL_COMMENTS    5               // All user-defined comments
#define SL_SWITCHES    6               // Switches and cascaded IFs
#define SL_FLOATS      7               // Referenced floats within one module
#define SL_CALLS       8               // Intermodular calls
#define SL_MOD         9               // Modifications

// Search types.
#define SEARCH_NONE    0               // Type is not yet defined
#define SEARCH_CMD     1               // Search for assembler commands
#define SEARCH_SEQ     2               // Search for the sequence of commands
#define SEARCH_BINARY  3               // Search for binary code
#define SEARCH_CONST   4               // Search for referenced constant range
#define SEARCH_MOD     5               // Search for modifications

// Search directions.
#define SDIR_GLOBAL    0               // Search forward from the beginning
#define SDIR_FORWARD   1               // Search forward from selection
#define SDIR_BACKWARD  2               // Search backward from selection

// Search modes.
#define SRCH_NEW       0               // Ask for new search pattern
#define SRCH_NEWMEM    1               // Ask for new pattern, memory mode
#define SRCH_SAMEDIR   2               // Search in the specified direction
#define SRCH_OPPDIR    3               // Search in the opposite direction
#define SRCH_MEM       4               // Search forward, memory mode

// Mode bits in Comparesequence().
#define CSEQ_IGNORECMD 0x00000001      // Ignore non-influencing commands
#define CSEQ_ALLOWJMP  0x00000002      // Allow jumps from outside

typedef struct t_found {               // Search result
  ulong          addr;                 // Address of found item
  ulong          size;                 // Size of found item, or 0 on error
} t_found;

typedef struct t_search {              // Descriptor of found item
  ulong          addr;                 // Address of found item
  ulong          size;                 // Must be 1
  ulong          type;                 // Type of found item, TY_xxx+SE_xxx
  ulong          data;                 // Mode-related data
  ulong          seqlen;               // Length of command sequence
} t_search;

stdapi (ulong)   Comparecommand(uchar *cmd,ulong cmdsize,ulong cmdip,
                   t_asmmod *model,int nmodel,int *pa,int *pb,t_disasm *da);
stdapi (ulong)   Comparesequence(uchar *cmd,ulong cmdsize,ulong cmdip,
                   uchar *decode,t_asmmod *model,int nmodel,int mode,
                   int *pa,int *pb,t_disasm *da,ulong *amatch,int namatch);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// PATCHES ////////////////////////////////////

#define PATCHSIZE      512             // Maximal patch size, bytes

typedef struct t_patch {
  ulong          addr;                 // Base address of patch in memory
  ulong          size;                 // Size of patch, bytes
  ulong          type;                 // Type of patch, set of TY_xxx
  uchar          orig[PATCHSIZE];      // Original code
  uchar          mod[PATCHSIZE];       // Patched code
} t_patch;


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// BREAKPOINTS //////////////////////////////////

// Actions that must be performed if breakpoint of type BP_ONESHOT or BP_TEMP
// is hit.
#define BA_PERMANENT   0x00000001      // Permanent INT3 BP_TEMP on system call
#define BA_PLUGIN      0x80000000      // Pass notification to plugin

typedef struct t_bpoint {              // INT3 breakpoints
  ulong          addr;                 // Address of breakpoint
  ulong          size;                 // Must be 1
  ulong          type;                 // Type of breakpoint, TY_xxx+BP_xxx
  ushort         fnindex;              // Index of predefined function
  uchar          cmd;                  // First byte of original command
  uchar          patch;                // Used only in .udd files
  ulong          limit;                // Original pass count (0 if not set)
  ulong          count;                // Actual pass count
  ulong          actions;              // Actions, set of BA_xxx
} t_bpoint;

typedef struct t_bpmem {               // Memory breakpoints
  ulong          addr;                 // Address of breakpoint
  ulong          size;                 // Size of the breakpoint, bytes
  ulong          type;                 // Type of breakpoint, TY_xxx+BP_xxx
  ulong          limit;                // Original pass count (0 if not set)
  ulong          count;                // Actual pass count
} t_bpmem;

typedef struct t_bppage {              // Pages with modified attributes
  ulong          base;                 // Base address of memory page
  ulong          size;                 // Always PAGESIZE
  ulong          type;                 // Set of TY_xxx+BP_ACCESSMASK
  ulong          oldaccess;            // Initial access
  ulong          newaccess;            // Modified (actual) access
} t_bppage;

typedef struct t_bphard {              // Hardware breakpoints
  ulong          index;                // Index of the breakpoint (0..NHARD-1)
  ulong          dummy;                // Must be 1
  ulong          type;                 // Type of the breakpoint, TY_xxx+BP_xxx
  ulong          addr;                 // Address of breakpoint
  ulong          size;                 // Size of the breakpoint, bytes
  int            fnindex;              // Index of predefined function
  ulong          limit;                // Original pass count (0 if not set)
  ulong          count;                // Actual pass count
  ulong          actions;              // Actions, set of BA_xxx
  ulong          modbase;              // Module base, used by .udd only
  wchar_t        path[MAXPATH];        // Full module name, used by .udd only
} t_bphard;

stdapi (int)     Removeint3breakpoint(ulong addr,ulong type);
stdapi (int)     Setint3breakpoint(ulong addr,ulong type,int fnindex,
                   int limit,int count,ulong actions,
                   wchar_t *condition,wchar_t *expression,wchar_t *exprtype);
stdapi (int)     Enableint3breakpoint(ulong addr,int enable);
stdapi (int)     Confirmint3breakpoint(ulong addr);
stdapi (int)     Confirmhardwarebreakpoint(ulong addr);
stdapi (int)     Confirmint3breakpointlist(ulong *addr,int naddr);
stdapi (void)    Wipebreakpointrange(ulong addr0,ulong addr1);
stdapi (int)     Removemembreakpoint(ulong addr);
stdapi (int)     Setmembreakpoint(ulong addr,ulong size,ulong type,
                   int limit,int count,wchar_t *condition,
                   wchar_t *expression,wchar_t *exprtype);
stdapi (int)     Enablemembreakpoint(ulong addr,int enable);
stdapi (int)     Removehardbreakpoint(int index);
stdapi (int)     Sethardbreakpoint(int index,ulong size,ulong type,int fnindex,
                   ulong addr,int limit,int count,ulong actions,
                   wchar_t *condition,wchar_t *expression,wchar_t *exprtype);
stdapi (int)     Enablehardbreakpoint(int index,int enable);
stdapi (int)     Findfreehardbreakslot(ulong type);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////// CPU //////////////////////////////////////

// Mode bits for Setcpu().
#define CPU_ASMHIST    0x00000001      // Add change to Disassembler history
#define CPU_ASMCENTER  0x00000004      // Make address in the middle of window
#define CPU_ASMFOCUS   0x00000008      // Move focus to Disassembler
#define CPU_DUMPHIST   0x00000010      // Add change to Dump history
#define CPU_DUMPFIRST  0x00000020      // Make address the first byte in Dump
#define CPU_DUMPFOCUS  0x00000080      // Move focus to Dump
#define CPU_STACKFOCUS 0x00000100      // Move focus to Stack
#define CPU_STACKCTR   0x00000200      // Center stack instead moving to top
#define CPU_REGAUTO    0x00001000      // Automatically switch to FPU/MMX/3DNow!
#define CPU_NOCREATE   0x00002000      // Don't create CPU window if absent
#define CPU_REDRAW     0x00004000      // Redraw CPU window immediately
#define CPU_NOFOCUS    0x00008000      // Don't assign focus to main window
#define CPU_RUNTRACE   0x00010000      // asmaddr is run trace backstep
#define CPU_NOTRACE    0x00020000      // Stop run trace display

// Options for autoregtype.
#define ASR_OFF        0               // No FPU/MMX/3DNow! autoselection
#define ASR_EVENT      1               // Autoselection on debug events
#define ASR_ALWAYS     2               // Autoselection when command selected

#define NHISTORY       1024            // Length of history buffer, records

typedef struct t_histrec {             // Walk history record
  ulong          threadid;             // Thread ID, ignored by Dump pane
  ulong          dumptype;             // Dump type, ignored by Disasm pane
  ulong          addr;                 // Address of first visible line
  ulong          sel0;                 // Begin of selection
  ulong          sel1;                 // End of selection (not included)
} t_histrec;

// Note that hnext points to the free record following the last written, and
// hcurr points record that follows currently selected one.
typedef struct t_history {             // Walk history data
  t_histrec      h[NHISTORY];          // Circular buffer with history records
  int            holdest;              // Index of oldest valid record in h
  int            hnext;                // Index of first free record in h
  int            hcurr;                // Index of record following actual in h
} t_history;

stdapi (void)    Redrawcpudisasm(void);
stdapi (void)    Redrawcpureg(void);
stdapi (ulong)   Getcputhreadid(void);
stdapi (int)     Getcpuruntracebackstep(void);
stdapi (t_dump *) Getcpudisasmdump(void);
stdapi (ulong)   Getcpudisasmselection(void);
stdapi (t_table *) Getcpudisasmtable(void);
stdapi (void)    Addtohistory(t_history *ph,ulong threadid,ulong dumptype,
                   ulong addr,ulong sel0,ulong sel1);
stdapi (int)     Walkhistory(t_history *ph,int dir,ulong *threadid,
                   ulong *dumptype,ulong *addr,ulong *sel0,ulong *sel1);
stdapi (int)     Checkhistory(t_history *ph,int dir,int *isnewest);
stdapi (void)    Setcpu(ulong threadid,ulong asmaddr,ulong dumpaddr,
                   ulong selsize,ulong stackaddr,int mode);


////////////////////////////////////////////////////////////////////////////////
/////////////////////// DEBUGGING AND TRACING FUNCTIONS ////////////////////////

#define NIGNORE        32              // Max. no. of ignored exception ranges
#define NRTPROT        64              // No. of protocolled address ranges

#define FP_SYSBP       0               // First pause on system breakpoint
#define FP_TLS         1               // First pause on TLS callback, if any
#define FP_ENTRY       2               // First pause on program entry point
#define FP_WINMAIN     3               // First pause on WinMain, if known
#define FP_NONE        4               // Run program immediately

#define AP_SYSBP       0               // Attach pause on system breakpoint
#define AP_CODE        1               // Attach pause on program code
#define AP_NONE        2               // Run attached program immediately

#define DP_LOADDLL     0               // Loaddll pause on Loaddll entry point
#define DP_ENTRY       1               // Loaddll pause on DllEntryPoint()
#define DP_LOADED      2               // Loaddll pause after LoadLibrary()
#define DP_NONE        3               // Run Loaddll immediately

#define DR6_SET        0xFFFF0FF0      // DR6 bits specified as always 1
#define DR6_TRAP       0x00004000      // Single-step trap
#define DR6_BD         0x00002000      // Debug register access detected
#define DR6_BHIT       0x0000000F      // Some hardware breakpoint hit
#define   DR6_B3       0x00000008      // Hardware breakpoint 3 hit
#define   DR6_B2       0x00000004      // Hardware breakpoint 2 hit
#define   DR6_B1       0x00000002      // Hardware breakpoint 1 hit
#define   DR6_B0       0x00000001      // Hardware breakpoint 0 hit

#define DR7_GD         0x00002000      // Enable debug register protection
#define DR7_SET        0x00000400      // DR7 bits specified as always 1
#define DR7_EXACT      0x00000100      // Local exact instruction detection
#define DR7_G3         0x00000080      // Enable breakpoint 3 globally
#define DR7_L3         0x00000040      // Enable breakpoint 3 locally
#define DR7_G2         0x00000020      // Enable breakpoint 2 globally
#define DR7_L2         0x00000010      // Enable breakpoint 2 locally
#define DR7_G1         0x00000008      // Enable breakpoint 1 globally
#define DR7_L1         0x00000004      // Enable breakpoint 1 locally
#define DR7_G0         0x00000002      // Enable breakpoint 0 globally
#define DR7_L0         0x00000001      // Enable breakpoint 0 locally

#define DR7_IMPORTANT  (DR7_G3|DR7_L3|DR7_G2|DR7_L2|DR7_G1|DR7_L1|DR7_G0|DR7_L0)

#define NCOND          4               // Number of run trace conditions
#define NRANGE         2               // Number of memory ranges
#define NCMD           2               // Number of commands
#define NMODLIST       24              // Number of modules in pause list

// Run trace condition bits.
#define RTC_COND1      0x00000001      // Stop run trace if condition 1 is met
#define RTC_COND2      0x00000002      // Stop run trace if condition 2 is met
#define RTC_COND3      0x00000004      // Stop run trace if condition 3 is met
#define RTC_COND4      0x00000008      // Stop run trace if condition 4 is met
#define RTC_CMD1       0x00000010      // Stop run trace if command 1 matches
#define RTC_CMD2       0x00000020      // Stop run trace if command 2 matches
#define RTC_INRANGE    0x00000100      // Stop run trace if in range
#define RTC_OUTRANGE   0x00000200      // Stop run trace if out of range
#define RTC_COUNT      0x00000400      // Stop run trace if count is reached
#define RTC_MEM1       0x00001000      // Access to memory range 1
#define RTC_MEM2       0x00002000      // Access to memory range 2
#define RTC_MODCMD     0x00008000      // Attempt to execute modified command

// Run trace protocol types.
#define RTL_ALL        0               // Log all commands
#define RTL_JUMPS      1               // Taken jmp/call/ret/int + destinations
#define RTL_CDEST      2               // Call destinations only
#define RTL_MEM        3               // Access to memory

// Hit trace outside the code section.
#define HTNC_RUN       0               // Continue trace the same way as code
#define HTNC_PAUSE     1               // Pause hit trace if outside the code
#define HTNC_TRACE     2               // Trace command by command (run trace)

// SFX extraction mode.
#define SFM_RUNTRACE   0               // Use run trace to extract SFX
#define SFM_HITTRACE   1               // Use hit trace to extract SFX

typedef struct t_rtcond {              // Run trace break condition
  // These fields are saved to .udd data directly.
  int            options;              // Set of RTC_xxx
  ulong          inrange0;             // Start of in range
  ulong          inrange1;             // End of in range (not included)
  ulong          outrange0;            // Start of out range
  ulong          outrange1;            // End of out range (not included)
  ulong          count;                // Stop count
  ulong          currcount;            // Actual command count
  int            memaccess[NRANGE];    // Type of access (0:R, 1:W, 2:R/W)
  ulong          memrange0[NRANGE];    // Start of memory range
  ulong          memrange1[NRANGE];    // End of memory range
  // These fields are saved to .udd data truncated by first null.
  wchar_t        cond[NCOND][TEXTLEN]; // Conditions as text
  wchar_t        cmd[NCMD][TEXTLEN];   // Matching commands
  // These fields are not saved to .udd data.
  uchar          ccomp[NCOND][TEXTLEN];// Precompiled conditions
  int            validmodels;          // Valid command models, RTC_xxx
  t_asmmod       model[NCMD][NSEARCHCMD]; // Command search models
  int            nmodel[NCMD];         // Number of slots in each model
} t_rtcond;

typedef struct t_rtprot {              // Run trace protocol condition
  int            tracelogtype;         // Commands to protocol, one of RTL_xxx
  int            memranges;            // 0x1: range 1, 0x2: range 2 active
  int            memaccess[NRANGE];    // Type of access (0:R, 1:W, 2:R/W)
  ulong          memrange0[NRANGE];    // Start of memory range
  ulong          memrange1[NRANGE];    // End of memory range
  int            rangeactive;          // Log only commands in the range
  t_range        range[NRTPROT];       // Set of EIP ranges to protocol
} t_rtprot;

stdapi (void)    Suspendallthreads(void);
stdapi (void)    Resumeallthreads(void);
stdapi (int)     Pauseprocess(void);
stdapi (int)     Closeprocess(int confirm);
stdapi (int)     Detachprocess(void);
stdapi (int)     Getlasterror(t_thread *pthr,ulong *error,wchar_t *s);
stdapi (ulong)   Followcall(ulong addr);
stdapi (int)     Run(t_status status,int pass);
stdapi (int)     Checkfordebugevent(void);
stdapi (int)     Addprotocolrange(ulong addr0,ulong addr1);
stdapi (int)     Getruntrace(int nback,t_reg *preg,uchar *cmd);
stdapi (int)     Findruntracerecord(ulong addr0,ulong addr1);


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// LIST OF GUIDS /////////////////////////////////

#define GUIDSIZE       16              // GUID size, bytes

stdapi (int)     Getguidname(uchar *data,ulong ndata,wchar_t *name);
stdapi (int)     Isguid(ulong addr,wchar_t *name,int nname);


////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// SOURCE CODE //////////////////////////////////

typedef struct t_srcline {             // Descriptor of source line
  ulong          offset;               // Offset in source text
  int            nextent;              // Number of code extents (-1: unknown)
  int            extent;               // Index of first extent (nextent>0)
} t_srcline;

typedef struct t_srcext {              // Descriptor of code extent
  ulong          amin;                 // Address of the first command
  ulong          amax;                 // Address of last command, included
} t_srcext;

typedef struct t_source {              // Descriptor of source file
  ulong          addr;                 // Module base plus file index
  ulong          size;                 // Dummy parameter, must be 1
  ulong          type;                 // Type, TY_xxx+SRC_xxx
  wchar_t        path[MAXPATH];        // File path
  int            nameoffs;             // Name offset in path, characters
  char           *text;                // Source code in UTF-8 format or NULL
  t_srcline      *line;                // nline+1 line descriptors or NULL
  int            nline;                // Number of lines (0: as yet unknown)
  t_srcext       *extent;              // List of code extents
  int            maxextent;            // Capacity of extent table
  int            nextent;              // Current number of extents
  int            lastline;             // Last selected line
  int            lastoffset;           // Last topmost visible line
} t_source;

stdapi (t_source *) Findsource(ulong base,wchar_t *path);
stdapi (int)     Getsourceline(ulong base,wchar_t *path,int line,int skipspaces,
                   wchar_t *text,wchar_t *fname,t_srcext **extent,int *nextent);
stdapi (int)     Showsourcecode(ulong base,wchar_t *path,int line);


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// DEBUGGEE ///////////////////////////////////

// Types of exception in application.
#define AE_NONE        0               // No exception, or caused by OllyDbg
#define AE_APP         1               // Exception in the application
#define AE_SYS         2               // System exception, don't pass

typedef struct t_run {                 // Run status of debugged application
  t_status       status;               // Operation mode, one of STAT_xxx
  ulong          threadid;             // ID of single running thread, 0 if all
  ulong          tpausing;             // Tick count when pausing was requested
  int            wakestep;             // 0: wait, 1: waked, 2: warned
  ulong          eip;                  // EIP at last debugging event
  ulong          ecx;                  // ECX at last debugging event
  ulong          restoreint3addr;      // Address of temporarily removed INT3
  ulong          stepoverdest;         // Destination of STAT_STEPOVER
  int            updatebppage;         // Update temporarily removed bppage's
  DEBUG_EVENT    de;                   // Information from WaitForDebugEvent()
  int            indebugevent;         // Paused on event, threads suspended
  int            netevent;             // Event is from .NET debugger
  int            isappexception;       // Exception in application, AE_xxx
  ulong          lastexception;        // Last exception in application or 0
  int            suspended;            // Suspension counter
  int            suspendonpause;       // Whether first suspension on pause
  int            updatedebugreg;       // 1: set, -1: reset HW breakpoints
  int            dregmodified;         // Debug regs modified by application
} t_run;


////////////////////////////////////////////////////////////////////////////////
//////////// OLLYDBG VARIABLES AND STRUCTURES ACCESSIBLE BY PLUGINS ////////////

// ATTENTION, never, ever change these variables directly! Either use plugin
// API or keep your hands off! Names of variables are preceded with underscore.

///////////////////////////////// DISASSEMBLER /////////////////////////////////

oddata (t_bincmd) bincmd[];            // List of 80x86 commands

oddata (wchar_t *) regname[3][NREG];   // Names of 8/16/32-bit registers
oddata (wchar_t *) segname[NREG];      // Names of segment registers
oddata (wchar_t *) fpuname[2][NREG];   // FPU regs (ST(n) and STn forms)
oddata (wchar_t *) mmxname[NREG];      // Names of MMX/3DNow! registers
oddata (wchar_t *) ssename[NREG];      // Names of SSE registers
oddata (wchar_t *) crname[NREG];       // Names of control registers
oddata (wchar_t *) drname[NREG];       // Names of debug registers
oddata (wchar_t *) sizename[17];       // Data size keywords
oddata (wchar_t *) sizekey[17];        // Keywords for immediate data
oddata (wchar_t *) sizeatt[17];        // Keywords for immediate data, AT&T

/////////////////////////////// OLLYDBG SETTINGS ///////////////////////////////

oddata (wchar_t) ollyfile[MAXPATH];    // Path to OllyDbg
oddata (wchar_t) ollydir[MAXPATH];     // OllyDbg directory w/o backslash
oddata (wchar_t) systemdir[MAXPATH];   // Windows system directory
oddata (wchar_t) plugindir[MAXPATH];   // Plugin data dir without backslash

oddata (HINSTANCE) hollyinst;          // Current OllyDbg instance
oddata (HWND)    hwollymain;           // Handle of the main OllyDbg window
oddata (HWND)    hwclient;             // Handle of MDI client or NULL
oddata (wchar_t) ottable[SHORTNAME];   // Class of table windows
oddata (ulong)   cpufeatures;          // CPUID feature information
oddata (int)     ischild;              // Whether child debugger

oddata (int)     asciicodepage;        // Code page to display ASCII dumps
#ifdef FILE                            // Requires <stdio.h>
oddata (FILE *)  tracefile;            // System log file or NULL
#endif
oddata (int)     restorewinpos;        // Restore window position & appearance

////////////////////////////// OLLYDBG STRUCTURES //////////////////////////////

oddata (t_font)  font[NFIXFONTS];      // Fixed fonts used in table windows
oddata (t_font)  sysfont;              // Proportional system font
oddata (t_font)  titlefont;            // Proportional, 2x height of sysfont
oddata (t_font)  fixfont;              // Fixed system font
oddata (COLORREF) color[NCOLORS];      // Colours used by OllyDbg
oddata (t_scheme) scheme[NSCHEMES];    // Colour schemes used in table windows
oddata (t_scheme) hilite[NHILITE];     // Colour schemes used for highlighting

/////////////////////////////////// DEBUGGEE ///////////////////////////////////

oddata (wchar_t) executable[MAXPATH];  // Path to main (.exe) file
oddata (wchar_t) arguments[ARGLEN];    // Command line passed to debuggee

oddata (int)     netdbg;               // .NET debugging active
oddata (int)     rundll;               // Debugged file is a DLL
oddata (HANDLE)  process;              // Handle of Debuggee or NULL
oddata (ulong)   processid;            // Process ID of Debuggee or 0
oddata (ulong)   mainthreadid;         // Thread ID of main thread or 0
oddata (t_run)   run;                  // Run status of debugged application
oddata (int)     skipsystembp;         // First system INT3 not yet hit

oddata (ulong)   debugbreak;           // Address of DebugBreak() in Debuggee
oddata (ulong)   dbgbreakpoint;        // Address of DbgBreakPoint() in Debuggee
oddata (ulong)   kiuserexcept;         // Address of KiUserExceptionDispatcher()
oddata (ulong)   zwcontinue;           // Address of ZwContinue() in Debuggee
oddata (ulong)   uefilter;             // Address of UnhandledExceptionFilter()
oddata (ulong)   ntqueryinfo;          // Address of NtQueryInformationProcess()
oddata (ulong)   corexemain;           // Address of MSCOREE:_CorExeMain()
oddata (ulong)   peblock;              // Address of PE block in Debuggee
oddata (ulong)   kusershareddata;      // Address of KUSER_SHARED_DATA
oddata (ulong)   userspacelimit;       // Size of virtual process memory

oddata (t_rtcond) rtcond;              // Run trace break condition
oddata (t_rtprot) rtprot;              // Run trace protocol condition

///////////////////////////////// DATA TABLES //////////////////////////////////

oddata (t_table) list;                 // List descriptor
oddata (t_sorted) premod;              // Preliminary module data
oddata (t_table) module;               // Loaded modules
oddata (t_sorted) aqueue;              // Modules that are not yet analysed
oddata (t_table) thread;               // Active threads
oddata (t_table) memory;               // Allocated memory blocks
oddata (t_table) win;                  // List of windows
oddata (t_table) bpoint;               // INT3 breakpoints
oddata (t_table) bpmem;                // Memory breakpoints
oddata (t_sorted) bppage;              // Memory pages with changed attributes
oddata (t_table) bphard;               // Hardware breakpoints
oddata (t_table) watch;                // Watch expressions
oddata (t_table) patch;                // List of patches from previous runs
oddata (t_sorted) procdata;            // Descriptions of analyzed procedures
oddata (t_table) source;               // List of source files
oddata (t_table) srccode;              // Source code


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// PLUGIN EXPORTS ////////////////////////////////

// Relatively infrequent events passed to ODBG2_Pluginnotify().
#define PN_NEWPROC     1               // New process is created
#define PN_ENDPROC     2               // Process is terminated
#define PN_NEWTHR      3               // New thread is created
#define PN_ENDTHR      4               // Thread is terminated
#define PN_PREMOD      5               // New module is reported by Windows
#define PN_NEWMOD      6               // New module is added to the table
#define PN_ENDMOD      7               // Module is removed from the memory
#define PN_STATUS      8               // Execution status has changed
#define PN_REMOVE      16              // OllyDbg removes analysis from range
#define PN_RUN         24              // User continues code execution

// Flags returned by ODBG2_Pluginexception().
#define PE_IGNORED     0x00000000      // Plugin does not process exception
#define PE_CONTINUE    0x00000001      // Exception by plugin, continue
#define PE_STEP        0x00000002      // Exception by plugin, execute command
#define PE_PAUSE       0x00000004      // Exception by plugin, pause program

pentry (int)         ODBG2_Pluginquery(int ollydbgversion,ulong *features,
                       wchar_t pluginname[SHORTNAME],
                       wchar_t pluginversion[SHORTNAME]);
pentry (int)         ODBG2_Plugininit(void);
pentry (void)        ODBG2_Pluginanalyse(t_module *pmod);
pentry (void)        ODBG2_Pluginmainloop(DEBUG_EVENT *debugevent);
pentry (int)         ODBG2_Pluginexception(t_run *prun,const t_disasm *da,
                       t_thread *pthr,t_reg *preg,wchar_t *message);
pentry (void)        ODBG2_Plugintempbreakpoint(ulong addr,
                       const t_disasm *da,t_thread *pthr,t_reg *preg);
pentry (void)        ODBG2_Pluginnotify(int code,void *data,
                       ulong parm1,ulong parm2);
pentry (int)         ODBG2_Plugindump(t_dump *pd,wchar_t *s,uchar *mask,
                       int n,int *select,ulong addr,int column);
pentry (t_menu *)    ODBG2_Pluginmenu(wchar_t *type);
pentry (t_control *) ODBG2_Pluginoptions(UINT msg,WPARAM wp,LPARAM lp);
pentry (void)        ODBG2_Pluginsaveudd(t_uddsave *psave,t_module *pmod,
                       int ismainmodule);
pentry (void)        ODBG2_Pluginuddrecord(t_module *pmod,int ismainmodule,
                       ulong tag,ulong size,void *data);
pentry (void)        ODBG2_Pluginreset(void);
pentry (int)         ODBG2_Pluginclose(void);
pentry (void)        ODBG2_Plugindestroy(void);

#endif                                 // __ODBG_PLUGIN_H


```

`src/gisnap/ollydbg_plugin/src/snapshotformat.h`:

```h
// standard structures for writting/reading Gadget Inspector snapshots

#ifndef __SNAPSHOTFORMAT
	#define __SNAPSHOTFORMAT

#include <stdint.h> 

// Memory protection flags
#define M_READ		0x01
#define M_WRITE		0x02
#define M_EXEC		0x04

#define M_ASLR		0x08	// ASLR is enabled
#define M_DEP		0x10	// DEP is enabled

// OS flags
#define OS_WINDOWS	0x0100
#define OS_LINUX	0x0200
#define OS_MACOS	0x0400
#define OS_ANDROID	0x0800
#define OS_IOS		0x1000

// Arch. flags
#define ARCH_X86	0x10000
#define ARCH_X64	0x20000
#define ARCH_ARM	0x40000
#define ARCH_PPC	0x80000

#pragma pack(push)
#pragma pack(1)
typedef struct _SNAPSHOTFILE
{
	uint32_t sig;			// signature: "snap" or 0x70616E73 in little endian
	uint32_t version;		// if version == 1: use DUMPBLOCKV10 / version == 2 uses DUMPBLOCKV20 and so on.
	uint32_t flags;			//
	uint32_t blockcount;
} SNAPSHOTFILE, *PSNAPSHOTFILE;

typedef struct _dumpblockV10
{
	uint64_t BaseAddress;
	uint64_t RegionSize;
	uint32_t Protect;		// see memory protection constants
} DUMPBLOCKV10, *PDUMPBLOCKV10;

typedef struct _dumpblockV20
{
	uint64_t BaseAddress;
	uint64_t RegionSize;
	uint32_t Protect;		// see memory protection constants
	uint8_t  name[256];
} DUMPBLOCKV20, *PDUMPBLOCKV20;

#pragma pack(pop)
#endif // __SNAPSHOTFORMAT
```

`src/gisnap/standalone/src/LogWindow.cpp`:

```cpp
#include "stdafx.h"
#include "logwindow.h"
#include <stdio.h>

LogWindow::LogWindow(HWND hwndDlg, HINSTANCE hInstance)
{
	_parent = hwndDlg;
	_hinstance = hInstance;
	_currentline = 0;
	_hwnd = GetDlgItem(hwndDlg, IDC_LOGLIST); 
}

LogWindow::~LogWindow()
{
	CloseWindow(_hwnd);
}

void LogWindow::Clear()
{
	SendDlgItemMessage(_parent, IDC_LOGLIST, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
}

void LogWindow::LogPrint(char *formatstring, ...)
{
	va_list args;
	va_start(args, formatstring);

	char msg[1024];

	memset(msg, 0, sizeof(msg));

	_vsnprintf(msg, sizeof(msg)-2, formatstring, args);
	SendMessage(_hwnd, LB_INSERTSTRING, _currentline, (LPARAM)msg);
	SendMessage(_hwnd, LB_SETTOPINDEX, _currentline, (LPARAM)0);
	_currentline++;
	lstrcat(msg, "\n");
	FILE *logfile = fopen("roptool.log", "a+");
	fputs(msg, logfile);
	fclose(logfile);
	SendMessage(_hwnd, WM_PAINT, 0, 0);
}

```

`src/gisnap/standalone/src/LogWindow.h`:

```h
#ifndef LOGWINDOW_H
	#define LOGWINDOW_H

class LogWindow
{
	public:	
		LogWindow(HWND parent, HINSTANCE hInstance);
		~LogWindow();
		void LogPrint(char *formatstring, ...);
		void Clear(void);
		HWND _hwnd;
	private:
		HINSTANCE _hinstance;

		HWND _parent;
		DWORD _currentline;
};


#endif
```

`src/gisnap/standalone/src/MemorySnapshot.cpp`:

```cpp
#include "stdafx.h"
#include <windows.h>
#include <DbgHelp.h>
#include "memorysnapshot.h"

#include <Psapi.h>

extern int SetProgressBar(unsigned int progress);

MemorySnapshot::MemorySnapshot()
{
	hprocess = 0;
}

MemorySnapshot::~MemorySnapshot()
{
	hprocess = 0;
}

uint32_t MemorySnapshot::__getArch()
{
	SYSTEM_INFO sysinfo = {0};
	uint32_t res = 0;

	GetSystemInfo(&sysinfo);

	switch(sysinfo.wProcessorArchitecture) {
		case PROCESSOR_ARCHITECTURE_AMD64:
			res = ARCH_X64;
			break;

		case PROCESSOR_ARCHITECTURE_INTEL:
			res = ARCH_X86;
			break;

		case PROCESSOR_ARCHITECTURE_ARM:
			res = ARCH_ARM;
			break;

	}
	return res;
}


void MemorySnapshot::__getBlockInfo(MEM_BLOCK *tmpblock, char *name)
{
	*name = 0;
	HANDLE h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, hpid);
	if(h_snapshot == INVALID_HANDLE_VALUE)
		return;
	MODULEENTRY32 __modentry;
	__modentry.dwSize = sizeof(MODULEENTRY32);

	SetLastError(0);	
	if(Module32First(h_snapshot, &__modentry) == FALSE)
		return;
	do {
		if((tmpblock->BaseAddress >= (uint64_t)__modentry.modBaseAddr) && (tmpblock->BaseAddress < (uint64_t)(__modentry.modBaseAddr+__modentry.modBaseSize))) {
			lstrcpyn(name, __modentry.szModule, 1024);
			__setASLRDEP(tmpblock, (uint64_t)__modentry.modBaseAddr);
			break;
		}

		if(GetLastError() == ERROR_NO_MORE_FILES)
			break;
		__modulelist.push_back(__modentry);
	} while(Module32Next(h_snapshot, &__modentry));
	CloseHandle(h_snapshot);
}

// sets memory region flags corresponding to ASLR and/or DEP dllCharacteristics
void MemorySnapshot::__setASLRDEP(MEM_BLOCK *tmpblock, uint64_t dllbase)
{
	ULONG modidx = 0;
	ULONG64 modbase = dllbase;

	IMAGE_DOS_HEADER hdr_mz;
	ReadProcessMemory(hprocess, (LPCVOID)modbase, &hdr_mz, sizeof(IMAGE_DOS_HEADER), NULL);
	if(hdr_mz.e_magic == IMAGE_DOS_SIGNATURE) {
		IMAGE_NT_HEADERS hdr_nt;
		ReadProcessMemory(hprocess, (LPCVOID)(modbase+hdr_mz.e_lfanew), &hdr_nt, sizeof(IMAGE_NT_HEADERS), NULL);
		if(hdr_nt.Signature == IMAGE_NT_SIGNATURE) {
			IMAGE_FILE_HEADER hdr_file;
			memcpy(&hdr_file, &hdr_nt.FileHeader, sizeof(IMAGE_FILE_HEADER));

			IMAGE_OPTIONAL_HEADER hdr_optional;
			memcpy(&hdr_optional, &hdr_nt.OptionalHeader, sizeof(IMAGE_OPTIONAL_HEADER));
			if((hdr_optional.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) || (hdr_optional.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)) {
				if(hdr_optional.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) {
					tmpblock->Protect |= M_ASLR;
				}

				if(hdr_optional.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT) {
					tmpblock->Protect |= M_DEP;
				}
			}
		}
	}
}

// try to guess process arch
bool MemorySnapshot::__isProcessSameArch()
{
	BOOL res = FALSE;
#ifndef _WIN64		// 32bit process fails to create snapshot of 64bit process
	HANDLE h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, hpid);
	if(h_snapshot != INVALID_HANDLE_VALUE) {
		res = TRUE;
	}
	CloseHandle(h_snapshot);
#else
	IsWow64Process(hprocess, &res);
	res = !res;
#endif
	return (bool)res;
}


uint32_t MemorySnapshot::__translateProtFlags(uint32_t prot)
{
	uint32_t flags=0;
	switch(prot & 0xFF)
	{
		case PAGE_EXECUTE:
			flags = M_EXEC;
			break;
		case PAGE_EXECUTE_READ:
			flags = M_EXEC | M_READ;
			break;
		case PAGE_EXECUTE_READWRITE:
			flags = M_EXEC | M_READ | M_WRITE;
			break;
		case PAGE_EXECUTE_WRITECOPY:
			flags = M_EXEC | M_READ | M_WRITE;
			break;
		case PAGE_READONLY:
			flags = M_READ;
			break;
		case PAGE_READWRITE:
			flags = M_READ | M_WRITE;
			break;
		case PAGE_WRITECOPY:
			flags = M_WRITE;
			break;
	}
	return flags;
}

bool MemorySnapshot::Dump(DWORD pid, char *filename)
{
	bool res = false;		// return value

	hpid = pid;

	// open process
	hprocess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ , FALSE, hpid);
	if(hprocess == 0)
		return res;

	BOOL bIs64 = (__getArch() == ARCH_X64);

	if(!__isProcessSameArch())
		return res;		// we got passed an x64 pid on a 32bit gisnap or vice versa

	// fill a vector with valid memory blocks
	MEM_BLOCK tmpblock = {0};
	memset(&tmpblock.name, 0, 256);
	MEMORY_BASIC_INFORMATION info = {0};
	uint64_t addr=0;
	while(VirtualQueryEx((HANDLE)hprocess, (LPVOID)addr, &info, sizeof(info))) {
		if((info.State == MEM_COMMIT) || (info.Type == MEM_MAPPED) || (info.Type == MEM_IMAGE)) {
			if(bIs64) {
				tmpblock.BaseAddress = (uint64_t)info.BaseAddress;
				tmpblock.RegionSize = info.RegionSize;
			} else {
				tmpblock.BaseAddress = (DWORD)info.BaseAddress;	//cast takes care of idiotic sign extension on pointers
				tmpblock.RegionSize = (DWORD)info.RegionSize;
			}
			if(info.Protect) {
				tmpblock.Protect = __translateProtFlags(info.Protect);
			} else {
				tmpblock.Protect = __translateProtFlags(info.AllocationProtect);
			}
			__getBlockInfo(&tmpblock, (char *)&tmpblock.name);
			memblocks.push_back(tmpblock);
		}
		addr += info.RegionSize+1;
	} 

	// write
	// create dumpfile
	FILE *dumpfile = fopen(filename, "wb" );
	if(!dumpfile) {
		return res;
	}

	SNAPSHOTFILE snphdr = {0};
	snphdr.sig = 0x70616E73;
	snphdr.version = 0x00000002;
	snphdr.flags = __getArch() | OS_WINDOWS;

	snphdr.blockcount = (uint32_t)memblocks.size();
	if(snphdr.blockcount > 0)
		res = true;

	// write header SNAPSHOTFILE
	fwrite ( &snphdr, sizeof(SNAPSHOTFILE) , 1 , dumpfile);

	unsigned int blkcnt=0;

	SetProgressBar(0);

	for (std::vector<MEM_BLOCK>::iterator block = memblocks.begin(); block != memblocks.end(); ++block, ++blkcnt)
	{

		MEM_BLOCK tmpblock = {0};

		tmpblock.RegionSize = block->RegionSize;
		tmpblock.BaseAddress = block->BaseAddress;
		tmpblock.Protect = block->Protect;
		strncpy((char *)&tmpblock.name, (char *)&block->name, 255);

		// write MEM_BLOCK
		fwrite ( &tmpblock, sizeof(MEM_BLOCK) , 1 , dumpfile);
		// write data
		uint8_t *buffer = new uint8_t [(unsigned int)block->RegionSize];
		ReadProcessMemory(hprocess, (LPCVOID)block->BaseAddress, buffer, (ULONG)block->RegionSize, NULL);
		fwrite ( buffer , (size_t)block->RegionSize, 1 , dumpfile);
		delete buffer;
		SetProgressBar(blkcnt*100/snphdr.blockcount);
	}
	fclose(dumpfile);
	CloseHandle(hprocess);
	SetProgressBar(100);

	return res;
}
```

`src/gisnap/standalone/src/MemorySnapshot.h`:

```h
#ifndef MEMSNAP_H
#define MEMSNAP_H

#include <DbgEng.h>

#include <TlHelp32.h>
#include "snapshotformat.h"
#include <iostream>
#include <vector>


#define MEM_BLOCK DUMPBLOCKV20

class MemorySnapshot
{
	public:	
		MemorySnapshot();
		~MemorySnapshot();
		bool MemorySnapshot::Dump(DWORD pid, char *filename);
	
	private:
		void MemorySnapshot::__getBlockInfo(MEM_BLOCK *tmpblock, char *name);
		void MemorySnapshot::__setASLRDEP(MEM_BLOCK *tmpblock, uint64_t dllbase);

		uint32_t MemorySnapshot::__getArch();
		bool MemorySnapshot::__isProcessSameArch();
		uint32_t MemorySnapshot::__translateProtFlags(uint32_t prot);

		HANDLE hprocess;
		DWORD hpid;

		std::vector<MEM_BLOCK> memblocks;
		std::vector<MODULEENTRY32> __modulelist;
	
};
#endif
```

`src/gisnap/standalone/src/ProcessList.cpp`:

```cpp
#include "stdafx.h"
#include "psapi.h"
#include "processlist.h"
#include <stdio.h>
#include <TlHelp32.h>

//extern Debugger *gDebugger;
//extern LogWindow *gLog;

extern LPWSTR *szArglist;
extern int nArgs;


#define WM_SETUPWINDOW (WM_USER + 1)

//------------------------------------------------------------------------------------------------------
ProcessList::ProcessList(HWND hwndDlg, HINSTANCE hInstance)
//------------------------------------------------------------------------------------------------------
{
	_parent = hwndDlg;
	_hinstance = hInstance;
	_currentline = 0;
	_hwnd = GetDlgItem(hwndDlg, IDC_PROCLIST); 
}

//------------------------------------------------------------------------------------------------------
void ProcessList::SetSelectionFromPid(DWORD pid)
//------------------------------------------------------------------------------------------------------
{
	unsigned int line=0;

	while(line < sizeof(aListNames)) {
		SendMessage(_hwnd, LB_SETCURSEL, (WPARAM)line, (LPARAM)0);
		LRESULT res = SendMessage(_hwnd, LB_GETCURSEL, (WPARAM)0, (LPARAM)0);
		if(aListNames[res].pid == pid) {
			break;
		}
		line++;
	}
}

//------------------------------------------------------------------------------------------------------
ProcessList::~ProcessList()
//------------------------------------------------------------------------------------------------------
{
}

void ProcessList::EnableDisable(BOOL val)
{
	HWND btn1 = GetDlgItem(_parent, IDC_DUMP);
	HWND btn2 = GetDlgItem(_parent, IDC_REFRESH);
	EnableWindow(_hwnd, val);
	EnableWindow(btn1, val);
	EnableWindow(btn2, val);
	SendDlgItemMessage(_parent, IDC_PROCLIST, WM_PAINT, 0, 0);
}

//------------------------------------------------------------------------------------------------------
DWORD ProcessList::GetSelectedPid()
//------------------------------------------------------------------------------------------------------
{
	LRESULT res = SendMessage(_hwnd, LB_GETCURSEL, (WPARAM)0, (LPARAM)0);
	if(res == -1)
		return (DWORD)res;
	return aListNames[res].pid;
}

//------------------------------------------------------------------------------------------------------
void ProcessList::ListEmpty()
//------------------------------------------------------------------------------------------------------
{
	SendMessage(_hwnd, LB_RESETCONTENT, (WPARAM)0, (LPARAM)0);
	SendMessage(_hwnd, WM_PAINT, 0, 0);
	_currentline=0;
}

void ProcessList::FillList()
{
	ListEmpty();

	HANDLE h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	if(h_snapshot == INVALID_HANDLE_VALUE)
		return;

	DWORD index=0;
	PROCESSENTRY32 _tmpProcEntry32;
	_tmpProcEntry32.dwSize = sizeof(PROCESSENTRY32);

	HANDLE _tmphProcess = INVALID_HANDLE_VALUE;
	BOOL is64b = FALSE;

	if(Process32First(h_snapshot, &_tmpProcEntry32)) {
		do {
			_tmphProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE,  _tmpProcEntry32.th32ProcessID);
			if(_tmphProcess == 0)
				continue;
#ifndef _WIN64
		// only list 32bit processes
		SYSTEM_INFO sysinfo;
		GetNativeSystemInfo(&sysinfo);
		if(sysinfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {
			IsWow64Process(_tmphProcess, &is64b);
				if(!is64b) {
					continue;
				}
		}
#else
		// only list 64bit processes
		SYSTEM_INFO sysinfo;
		GetNativeSystemInfo(&sysinfo);
		if(sysinfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {
			IsWow64Process(_tmphProcess, &is64b);
				if(is64b) {
					continue;
				}
		}
#endif

			aListNames[index].pid = _tmpProcEntry32.th32ProcessID;
			strncpy(aListNames[index].name, _tmpProcEntry32.szExeFile, 1024);
			ListPrint("[%05d] - %s", aListNames[index].pid, aListNames[index].name);
			index++;
			CloseHandle(_tmphProcess);
		} while(Process32Next(h_snapshot, &_tmpProcEntry32));
	}
	CloseHandle(h_snapshot);
}

//------------------------------------------------------------------------------------------------------
void ProcessList::ListPrint(char *formatstring, ...)
//------------------------------------------------------------------------------------------------------
{
	va_list args;
	va_start(args, formatstring);

	char msg[1024];

	memset(msg, 0, sizeof(msg));

	_vsnprintf(msg, sizeof(msg), formatstring, args);
	SendMessage(_hwnd, LB_INSERTSTRING, _currentline, (LPARAM)msg);

	_currentline++;
}


```

`src/gisnap/standalone/src/ProcessList.h`:

```h
#ifndef PROCLIST_H
	#define PROCLIST_H


typedef struct _processListEntry {
	DWORD pid;
	char name[1024];
} processListEntry;

class ProcessList
{
	public:	
		ProcessList(HWND hwndDlg, HINSTANCE hInstance);
		~ProcessList();
		DWORD ProcessList::GetSelectedPid();
		void ProcessList::SetSelectionFromPid(DWORD pid);
		void ListPrint(char *formatstring, ...);
		void ListEmpty();
		void EnableDisable(BOOL val);
		static INT_PTR CALLBACK StaticDialogProcedure(HWND pDialog, UINT msg, WPARAM wParam, LPARAM lParam);
		INT_PTR CALLBACK DlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);
		void FillList();
	private:
		HWND _hwnd;
		HWND _parent;
		DWORD _currentline;
		DWORD _done;
		HINSTANCE _hinstance;
		processListEntry aListNames[1024];
};


#endif
```

`src/gisnap/standalone/src/gisnap.cpp`:

```cpp
// ropstandalone.cpp : Defines the entry point for the application.
//

#include "stdafx.h"

#include "gisnap.h"
#include <Commctrl.h>
#include <Commdlg.h>
#include <Shellapi.h>

#include <stdio.h>

#define MAX_LOADSTRING 100

ProcessList *gProcList;
MemorySnapshot *gMemSnap;

// Global Variables:
HINSTANCE hInst;								// current instance
TCHAR szTitle[MAX_LOADSTRING];					// The title bar text
TCHAR szWindowClass[MAX_LOADSTRING];			// the main window class name

HWND gHWND;
BOOL _done = FALSE;

LPWSTR *szArglist=0;
int nArgs=0;

BOOL InitInstance(HINSTANCE hInstance, int nCmdShow);
BOOL SetProcessPrivilege();

INT_PTR CALLBACK MainDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam);

int APIENTRY _tWinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPTSTR    lpCmdLine,
                     int       nCmdShow)
{
	UNREFERENCED_PARAMETER(hPrevInstance);
	UNREFERENCED_PARAMETER(lpCmdLine);

 	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;

	// Initialize global strings
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_GISNAP, szWindowClass, MAX_LOADSTRING);

	// Perform application initialization:
	if (!InitInstance (hInstance, nCmdShow))
	{
		return FALSE;
	}

	hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_GISNAP));

	BOOL bRet;

	while( (bRet = GetMessage( &msg, gHWND, 0, 0 )) != 0)
	{ 
		if(_done) {
			break;
		}
		if (bRet == -1) {
			break;
		} else {
			TranslateMessage(&msg); 
			DispatchMessage(&msg); 
		}
	}
	return (int) msg.wParam;
}


BOOL SetPrivilege(HANDLE hToken, LPCTSTR lpszPrivilege, BOOL bEnablePrivilege)
{
	TOKEN_PRIVILEGES pTokenPrivileges = {0};
	TOKEN_PRIVILEGES oldTokenPrivileges = {0};
	DWORD cbSize=0;
	LUID luid;

	if( !LookupPrivilegeValue( NULL, lpszPrivilege, &luid ) ) { 
		return FALSE; 
	}
	pTokenPrivileges.PrivilegeCount = 1;
	pTokenPrivileges.Privileges[ 0 ].Luid = luid;
	if(bEnablePrivilege) { 
		pTokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
	} else { 
		pTokenPrivileges.Privileges[0].Attributes = 0; 
	}
	if(!AdjustTokenPrivileges(hToken, FALSE, &pTokenPrivileges, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) { 
		return FALSE; 
	}
	if(GetLastError()== ERROR_NOT_ALL_ASSIGNED) { 
		return FALSE; 
	}
	return TRUE;
}

BOOL SetProcessPrivilege()
{
	HANDLE pToken = NULL;
	OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &pToken);
	return SetPrivilege(pToken, SE_DEBUG_NAME, TRUE);
}


BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{

	SetProcessPrivilege();

	hInst = hInstance; // Store instance handle in our global variable
	INITCOMMONCONTROLSEX InitCtrlEx;

	InitCtrlEx.dwSize = sizeof(INITCOMMONCONTROLSEX);
	InitCtrlEx.dwICC  = ICC_PROGRESS_CLASS;
	InitCommonControlsEx(&InitCtrlEx);

	gHWND = CreateDialogParam(hInstance, MAKEINTRESOURCE(IDD_MAIN), NULL, MainDlgProc, LPARAM(0)); 
	return TRUE;
}

int SetProgressBar(unsigned int progress)
{
	HWND progressbar = GetDlgItem(gHWND, IDC_PROGRESS);
	if(!progressbar) 
		return 0;
	SendDlgItemMessage(gHWND, IDC_PROGRESS, PBM_SETRANGE32, 0, 100);
	SendDlgItemMessage(gHWND, IDC_PROGRESS, PBM_GETPOS, 0, 0);
	UINT old = (UINT)SendDlgItemMessage(gHWND, IDC_PROGRESS, PBM_GETPOS, 0, 0);
	if(progress < old) {
		SendDlgItemMessage(gHWND, IDC_PROGRESS, PBM_SETPOS, progress, 0);
		SendMessage(progressbar, WM_PAINT, 0, 0);
		Sleep(5);
	} else {
		while(progress > old) {
			SendDlgItemMessage(gHWND, IDC_PROGRESS, PBM_SETPOS, old+1, 0);
			SendDlgItemMessage(gHWND, IDC_PROGRESS, WM_PAINT, 0, 0);
			old = (UINT)SendDlgItemMessage(gHWND, IDC_PROGRESS, PBM_GETPOS, 0, 0);
			Sleep(3);
		}
	}
		
	return progress;
}

bool DumpProcess(DWORD pid)
{
	gMemSnap = new MemorySnapshot;
	char filename[1024];
	OPENFILENAME ofln;

	memset(&filename, 0, sizeof(filename));
	memset(&ofln, 0, sizeof(OPENFILENAME));
	ofln.lStructSize = sizeof(OPENFILENAME);
	ofln.hwndOwner = gHWND;
	ofln.lpstrFile = filename;
	ofln.nMaxFile = sizeof(filename);
	ofln.lpstrFilter = "snap\0*.snap\0All\0*.*\0";
	ofln.nFilterIndex = 1;
	ofln.lpstrFileTitle = NULL;
	ofln.nMaxFileTitle = 0;
	ofln.lpstrInitialDir = NULL;
	ofln.lpstrDefExt = ".snap";
	ofln.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT;
	GetSaveFileName(&ofln);
	CommDlgExtendedError();
	return gMemSnap->Dump(pid, filename);
}

INT_PTR CALLBACK MainDlgProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) 
{
	int lbItem=0;
	HWND hwndList=0;
	DWORD pid=0xFFFFFFFF;

	HDC dc = 0;
	PAINTSTRUCT ps;
	gHWND = hwndDlg;

	char szpid[1024] = {0};

	switch (message)
	{
		case WM_INITDIALOG:
			// reset progress bar
			SetProgressBar(0);
			gProcList = new ProcessList(hwndDlg, hInst);
			gProcList->FillList();
			szArglist = CommandLineToArgvW(GetCommandLineW(), &nArgs);	
			if(nArgs > 1) {
				wsprintf(szpid, "%S", szArglist[1]);
				gProcList->SetSelectionFromPid(atoi(szpid));
				if(nArgs >2 ) {
					MemorySnapshot *gMemSnap = new MemorySnapshot;
					char filename[MAX_PATH];
					wsprintf(filename, "%S", szArglist[2]);
					bool res = gMemSnap->Dump(atoi(szpid), filename);
					SendMessage(hwndDlg, WM_CLOSE, IDC_DUMP, (LPARAM)res);
				} else {
					DumpProcess(atoi(szpid));
				}
			}
			return TRUE;

		case WM_PAINT:
			{
				BeginPaint(gHWND, &ps);
				RECT rc;
				GetClientRect(gHWND, &rc); 
				EndPaint(gHWND, &ps);
			}
			break;

		case WM_CLOSE:
			delete gProcList;
			gProcList = 0;
			EndDialog(gHWND, 0);
			ExitProcess((UINT)lParam);
			break;

		case WM_COMMAND:
			switch(LOWORD(wParam))
			{
				case IDC_DUMP:
					pid = gProcList->GetSelectedPid();
					gProcList->EnableDisable(FALSE);
					DumpProcess(pid);
					gProcList->EnableDisable(TRUE);
					break;
					
				case IDC_REFRESH:
					gProcList->FillList();
					break;

				case IDC_EXIT:
					SendMessage(gHWND, WM_CLOSE, 0, 0);
					break;


				case IDC_PROCLIST:
					if(pid == 0xFFFFFFFF) {
						if(gProcList) {
							pid = gProcList->GetSelectedPid();
						}
						if(pid == 0xFFFFFFFF)
							EnableWindow(GetDlgItem(gHWND, IDC_DUMP), TRUE);
					}
					switch (HIWORD(wParam)) 
					{ 
						case LBN_DBLCLK:
								SendMessage(gHWND, WM_COMMAND, IDC_DUMP, 0);
								break;
						default:
							break;
					}

				default:
					break;
			}
		default:
			break;

	}
//	UpdateWindow(gHWND);
	return (INT_PTR)FALSE;
}
```

`src/gisnap/standalone/src/gisnap.h`:

```h
#pragma once



```

`src/gisnap/standalone/src/gisnap.rc`:

```rc
#include "resource.h"

109 MENU
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
{
POPUP "&File"
{
	MENUITEM "E&xit",  105
}
POPUP "&Help"
{
	MENUITEM "&About ...",  104
}
}

103 DIALOG 22, 17, 230, 75
STYLE DS_MODALFRAME | WS_CAPTION | WS_SYSMENU
CAPTION "About"
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
FONT 8, "System"
{
   CONTROL 107, 2, STATIC, SS_ICON | WS_CHILD | WS_VISIBLE, 14, 9, 16, 16 
   CONTROL "ropstandalone Version 1.0", -1, STATIC, SS_LEFT | SS_NOPREFIX | WS_CHILD | WS_VISIBLE | WS_GROUP, 49, 10, 119, 8 
   CONTROL "Copyright (C) 2011", -1, STATIC, SS_LEFT | WS_CHILD | WS_VISIBLE | WS_GROUP, 49, 20, 119, 8 
   CONTROL "OK", 1, BUTTON, BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_GROUP | WS_TABSTOP, 195, 6, 30, 11 
}

129 DIALOGEX 0, 0, 327, 264
STYLE DS_FIXEDSYS | DS_MODALFRAME | WS_POPUP | WS_CAPTION
CAPTION "Process List"
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
FONT 8, "MS Shell Dlg", FW_NORMAL, FALSE, 1
{
   CONTROL "OK", 1, BUTTON, BS_DEFPUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 7, 243, 50, 14 
   CONTROL "Exit", 2, BUTTON, BS_PUSHBUTTON | WS_CHILD | WS_VISIBLE | WS_TABSTOP, 270, 243, 50, 14 
   CONTROL "", 1000, LISTBOX, LBS_STANDARD | LBS_NOINTEGRALHEIGHT | WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_TABSTOP, 7, 7, 313, 231 
}


STRINGTABLE
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
{
103, 	"gisnap"
109, 	"GISNAP"
}


109 ACCELERATORS
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
{
	"?", 104, ALT
	"/", 104, ALT
}

107 ICON "Icon_1.ico"

108 ICON "Icon_2.ico"


```

`src/gisnap/standalone/src/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by ropstandalone.rc
//
#define IDD_ROPSTANDALONE_DIALOG        102
#define IDS_APP_TITLE                   103
#define IDM_ABOUT                       104
#define IDM_EXIT                        105
#define IDI_ROPSTANDALONE               107
#define IDI_SMALL                       108
#define IDC_ROPSTANDALONE               109
#define IDC_MAINMENU                    109
#define IDR_MAINFRAME                   128
#define IDD_MAIN                        130
#define IDB_LOGO                        131
#define IDC_PROCLIST                    1000
#define IDC_LOGLIST                     1002
#define IDC_PROGRESS                    1003
#define IDC_MODULELIST                  1004
#define IDC_REFRESH                     1007
#define IDC_ATTACH                      1008
#define IDC_SAFESEH                     1009
#define IDC_DYNAMICBASE                 1010
#define IDC_RELOCATIONS                 1011
#define IDC_ASCII                       1012
#define IDC_BREAKPOINTADDR              1013
#define IDC_RBREAKPOINT                 1014
#define IDC_UNICODE                     1015
#define IDC_RADIO3                      1016
#define IDC_NOZERO                      1016
#define IDC_NONE                        1017
#define IDC_REXCEPTION                  1018
#define IDC_EXCEPTIONNAMES              1019
#define IDC_COMBOBOXEX1                 1020
#define IDC_COMBOBOXEX2                 1021
#define ID_FILE_OPEN                    32771
#define ID_EDIT_SETTINGS                32772
#define IDM_FILE_OPEN                   32773
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32774
#define _APS_NEXT_CONTROL_VALUE         1022
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif

```

`src/gisnap/standalone/src/resource1.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by stand-alone.rc
//
#define IDD_MAIN                        101
#define IDS_APP_TITLE                   102
#define IDC_GISNAP                      103
#define IDC_DUMP                        1001
#define IDC_PROCLIST                    1002
#define IDC_EXIT                        1003
#define IDC_REFRESH                     1004
#define IDC_PROGRESS1                   1005
#define IDC_PROGRESS                    1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`src/gisnap/standalone/src/snapshotformat.h`:

```h
// standard structures for writting/reading Gadget Inspector snapshots

#ifndef __SNAPSHOTFORMAT
	#define __SNAPSHOTFORMAT

#include <stdint.h> 

// Memory protection flags
#define M_READ		0x01
#define M_WRITE		0x02
#define M_EXEC		0x04

#define M_ASLR		0x08	// ASLR is enabled
#define M_DEP		0x10	// DEP is enabled

// OS flags
#define OS_WINDOWS	0x0100
#define OS_LINUX	0x0200
#define OS_MACOS	0x0400
#define OS_ANDROID	0x0800
#define OS_IOS		0x1000

// Arch. flags
#define ARCH_X86	0x10000
#define ARCH_X64	0x20000
#define ARCH_ARM	0x40000
#define ARCH_PPC	0x80000

#pragma pack(push)
#pragma pack(1)
typedef struct _SNAPSHOTFILE
{
	uint32_t sig;			// signature: "snap" or 0x70616E73 in little endian
	uint32_t version;		// if version == 1: use DUMPBLOCKV10 / version == 2 uses DUMPBLOCKV20 and so on.
	uint32_t flags;			//
	uint32_t blockcount;
} SNAPSHOTFILE, *PSNAPSHOTFILE;

typedef struct _dumpblockV10
{
	uint64_t BaseAddress;
	uint64_t RegionSize;
	uint32_t Protect;		// see memory protection constants
} DUMPBLOCKV10, *PDUMPBLOCKV10;

typedef struct _dumpblockV20
{
	uint64_t BaseAddress;
	uint64_t RegionSize;
	uint32_t Protect;		// see memory protection constants
	uint8_t  name[256];
} DUMPBLOCKV20, *PDUMPBLOCKV20;

#pragma pack(pop)
#endif // __SNAPSHOTFORMAT
```

`src/gisnap/standalone/src/stand-alone.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource1.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "afxres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource1.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_MAIN DIALOGEX 0, 0, 295, 239
//STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | DS_NOFAILCREATE | DS_CENTER | WS_CAPTION | WS_SYSMENU
//EXSTYLE WS_EX_TOPMOST

//IDD_MAIN DIALOGEX 0, 0, 505, 359
STYLE DS_ABSALIGN | DS_SETFONT | DS_MODALFRAME | DS_CENTER | WS_MINIMIZEBOX | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
EXSTYLE WS_EX_APPWINDOW



CAPTION "GiSnap v1.0a"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    PUSHBUTTON      "D&ump",IDC_DUMP,1,225,53,14
    LISTBOX         IDC_PROCLIST,2,19,288,194,LBS_NOINTEGRALHEIGHT | WS_VSCROLL | WS_TABSTOP
    PUSHBUTTON      "E&xit",IDC_EXIT,237,225,53,14
    LTEXT           "Select Process:",IDC_STATIC,5,6,52,13
    PUSHBUTTON      "R&efresh",IDC_REFRESH,56,225,53,14
    CONTROL         "",IDC_PROGRESS,"msctls_progress32",WS_BORDER,2,215,288,8
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_MAIN, DIALOG
    BEGIN
        RIGHTMARGIN, 293
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_APP_TITLE           "Gisnap v1.0a"
    IDC_GISNAP              "GISNAP"
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`src/gisnap/standalone/src/stand-alone.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "stand-alone", "stand-alone.vcxproj", "{3B0FC55A-CAC6-49DF-B1AE-C6924F98BCBF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{3B0FC55A-CAC6-49DF-B1AE-C6924F98BCBF}.Debug|Win32.ActiveCfg = Debug|Win32
		{3B0FC55A-CAC6-49DF-B1AE-C6924F98BCBF}.Debug|Win32.Build.0 = Debug|Win32
		{3B0FC55A-CAC6-49DF-B1AE-C6924F98BCBF}.Debug|x64.ActiveCfg = Debug|x64
		{3B0FC55A-CAC6-49DF-B1AE-C6924F98BCBF}.Debug|x64.Build.0 = Debug|x64
		{3B0FC55A-CAC6-49DF-B1AE-C6924F98BCBF}.Release|Win32.ActiveCfg = Release|Win32
		{3B0FC55A-CAC6-49DF-B1AE-C6924F98BCBF}.Release|Win32.Build.0 = Release|Win32
		{3B0FC55A-CAC6-49DF-B1AE-C6924F98BCBF}.Release|x64.ActiveCfg = Release|x64
		{3B0FC55A-CAC6-49DF-B1AE-C6924F98BCBF}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`src/gisnap/standalone/src/stand-alone.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{3B0FC55A-CAC6-49DF-B1AE-C6924F98BCBF}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>standalone</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v110_xp</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v110_xp</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v110_xp</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v110_xp</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>dbghelp.lib;comctl32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalDependencies>dbghelp.lib;comctl32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>dbghelp.lib;comctl32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalDependencies>dbghelp.lib;comctl32.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="gisnap.cpp" />
    <ClCompile Include="MemorySnapshot.cpp" />
    <ClCompile Include="ProcessList.cpp" />
    <ClCompile Include="stdafx.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="gisnap.h" />
    <ClInclude Include="MemorySnapshot.h" />
    <ClInclude Include="ProcessList.h" />
    <ClInclude Include="resource1.h" />
    <ClInclude Include="snapshotformat.h" />
    <ClInclude Include="stdafx.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="stand-alone.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/gisnap/standalone/src/stand-alone.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="gisnap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MemorySnapshot.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ProcessList.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="gisnap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="MemorySnapshot.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ProcessList.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource1.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="snapshotformat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="stand-alone.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`src/gisnap/standalone/src/stand-alone.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>1604 "c:\pnx\gadget-inspector\gisnap\gisnap_dumpinfo\2.dmp"</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`src/gisnap/standalone/src/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// ropstandalone.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`src/gisnap/standalone/src/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows XP or later.
#define WINVER 0x0501		// Change this to the appropriate value to target other versions of Windows.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows XP or later.                   
#define _WIN32_WINNT 0x0501	// Change this to the appropriate value to target other versions of Windows.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 6.0 or later.
#define _WIN32_IE 0x0600	// Change this to the appropriate value to target other versions of IE.
#endif

#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <windows.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>
#include <tchar.h>

extern void LogLine(char *formatstring, ...);

#pragma comment(lib, "psapi.lib")

#include "processlist.h"
#include "memorysnapshot.h"
#include "resource1.h"


// TODO: reference additional headers your program requires here

```

`src/gisnap/windbg_ext/readme.txt`:

```txt
copy appropiate (x86 or x64) dll to %ProgramFiles%\Debugging Tools for Windows\winext

Windbg/ntsd snapshot dumper extension


.load gisnap

!help
!gisnap <filename>
filename = name of the file to store snapshot.


```

`src/gisnap/windbg_ext/src/gisnap.cpp`:

```cpp
#include "gisnap.h"

GiSnapDump::GiSnapDump()
{
	g_Client = NULL;
	HRESULT res = DebugCreate(__uuidof(IDebugClient), (void**)&g_Client);
	if(S_OK != res) {
		dprintf("ERROR: Cannot talk to dbgeng.dll\n");
		return;
	}

	g_Client->QueryInterface(__uuidof(IDebugControl), (void**)&g_Control);
    g_Client->QueryInterface(__uuidof(IDebugSymbols), (void**)&g_Symbols);
    g_Client->QueryInterface(__uuidof(IDebugSymbols2), (void**)&g_Symbols2);

	g_Client->QueryInterface(__uuidof(IDebugDataSpaces2), (void**)&g_DataSpaces2);
	g_Client->QueryInterface(__uuidof(IDebugDataSpaces3), (void**)&g_DataSpaces3);
	g_Client->QueryInterface(__uuidof(IDebugDataSpaces4), (void**)&g_DataSpaces4);

	g_Client->QueryInterface(__uuidof(IDebugSystemObjects), (void**)&g_SystemObjects);

	// connect dbgeng.dll to the running debugger session
	g_Client->ConnectSession(DEBUG_CONNECT_SESSION_NO_VERSION | DEBUG_CONNECT_SESSION_NO_ANNOUNCE, NULL);
	if(S_OK != res) {
		dprintf("ERROR: Cannot conntect dbgeng to current debugger session\n");
		return;
	}

	ULONG myclass = 0;
	ULONG qual = 0;

	g_Control->GetDebuggeeType(&myclass, &qual);

	if(myclass == DEBUG_CLASS_UNINITIALIZED) {
		dprintf("ERROR: attach to your target first!\n\n");
	}
}


void GiSnapDump::__getStrForNativeProt(uint32_t prot, char *dest)
{
	switch(prot & 0xFF)
	{
		case PAGE_EXECUTE:
			strcpy(dest, "EXECUTE");
			break;
		case PAGE_EXECUTE_READ:
			strcpy(dest, "EXECUTE_READ");
			break;
		case PAGE_EXECUTE_READWRITE:
			strcpy(dest, "EXECUTE_READWRITE");
			break;
		case PAGE_EXECUTE_WRITECOPY:
			strcpy(dest, "EXECUTE_WRITECOPY");
			break;
		case PAGE_NOACCESS:
			strcpy(dest, "NOACCESS");
			break;
		case PAGE_READONLY:
			strcpy(dest, "READONLY");
			break;
		case PAGE_READWRITE:
			strcpy(dest, "READWRITE");
			break;
		case PAGE_WRITECOPY:
			strcpy(dest, "WRITECOPY");
			break;
		default:
			strcpy(dest, "UNKNOWN");
			break;
	}

	if(prot & PAGE_GUARD)
		strcat(dest, "|GUARD");
	if(prot & PAGE_NOCACHE)
		strcat(dest, "|NOCACHE");
	if(prot & PAGE_GUARD)
		strcat(dest, "|WRITECOMBINE");
}

void GiSnapDump::__getStrForProt(uint32_t prot, char *dest)
{
	if(prot & M_READ) {
		strcat(dest, "R");
	} else {
		strcat(dest, "-");
	}

	if(prot & M_WRITE) {
		strcat(dest, "W");
	} else {
		strcat(dest, "-");
	}

	if(prot & M_EXEC) {
		strcat(dest, "X");
	} else {
		strcat(dest, "-");
	}

	if(prot & M_ASLR) {
		strcat(dest, " ASLR");
	}

	if(prot & M_DEP) {
		strcat(dest, " DEP");
	}
}

uint32_t GiSnapDump::__translateProtFlags(uint32_t prot)
{
	uint32_t flags=0;
	switch(prot & 0xFF)
	{
		case PAGE_EXECUTE:
			flags = M_EXEC;
			break;
		case PAGE_EXECUTE_READ:
			flags = M_EXEC | M_READ;
			break;
		case PAGE_EXECUTE_READWRITE:
			flags = M_EXEC | M_READ | M_WRITE;
			break;
		case PAGE_EXECUTE_WRITECOPY:
			flags = M_EXEC | M_READ | M_WRITE;
			break;
		case PAGE_READONLY:
			flags = M_READ;
			break;
		case PAGE_READWRITE:
			flags = M_READ | M_WRITE;
			break;
		case PAGE_WRITECOPY:
			flags = M_WRITE;
			break;
	}
	return flags;
}

void GiSnapDump::__getStrForStat(uint32_t stat, char *dest)
{
	switch(stat)
	{
		case MEM_COMMIT:
			strcpy(dest, "COMMIT");
			break;
		case MEM_RESERVE:
			strcpy(dest, "RESERVE");
			break;
		case MEM_FREE:
			strcpy(dest, "FREE");
			break;
		case MEM_PRIVATE:
			strcpy(dest, "PRIVATE");
			break;
		case MEM_MAPPED:
			strcpy(dest, "MAPPED");
			break;
		case MEM_IMAGE:
			strcpy(dest, "IMAGE");
			break;
	}
}

uint32_t GiSnapDump::__getArch()
{
	ULONG processor_type=0;
	g_Control->GetExecutingProcessorType(&processor_type);

	uint32_t res = 0;
	switch(processor_type) {
		case IMAGE_FILE_MACHINE_I386:
			res = ARCH_X86;
			break;
		case IMAGE_FILE_MACHINE_ARM:
			res = ARCH_ARM;
			break;
		case IMAGE_FILE_MACHINE_AMD64:
			res = ARCH_X64;
			break;
		default:
			res = 0;
			break;
	}
	return res;
}

// gets symbol name for a memory address
void GiSnapDump::__getMemRegionName(uint64_t base, char *name)
{
	char symname[1024] = {0};
	uint8_t namesize=255;

	HRESULT status = g_Symbols->GetNameByOffset(base, symname, sizeof(symname), NULL, NULL);
	if(status == E_FAIL) {
		memset(&symname, 0, 1);
	}

	char *bang = strstr(symname, "!");
	if(bang) {
		if(bang-symname < namesize)
			namesize = (uint8_t)(bang-symname);
	}

	strncpy(name, symname, namesize);
}

// print information about a memory block to the debugger console
void GiSnapDump::__printBlockInfo(MEM_BLOCK *tmpblock)
{
	char name[1024] = {0};
//	__getMemRegionName(tmpblock->BaseAddress, name);
//	strcpy((char *)&tmpblock->name, name);

	char prot[1024] = {0};
	__getStrForProt(tmpblock->Protect, prot);

	dprintf("% 10s base:%08I64x size:%08I64x, prot:%s\n", tmpblock->name, tmpblock->BaseAddress, tmpblock->RegionSize, prot);
}
/*
// sets memory region flags corresponding to ASLR and/or DEP dllCharacteristics
void GiSnapDump::__setASLRDEP(MEM_BLOCK *tmpblock)
{
	ULONG modidx = 0;
	ULONG64 modbase = 0;

	HRESULT res = g_Symbols->GetModuleByOffset(tmpblock->BaseAddress, 0, &modidx, &modbase);

	IMAGE_DOS_HEADER hdr_mz;
	ReadMemory((ULONG_PTR)modbase, &hdr_mz, sizeof(IMAGE_DOS_HEADER), NULL);
	if(hdr_mz.e_magic == IMAGE_DOS_SIGNATURE) {
		IMAGE_NT_HEADERS hdr_nt;
		ReadMemory((ULONG_PTR)(modbase+hdr_mz.e_lfanew), &hdr_nt, sizeof(IMAGE_NT_HEADERS), NULL);
		if(hdr_nt.Signature == IMAGE_NT_SIGNATURE) {
			IMAGE_FILE_HEADER hdr_file;
			memcpy(&hdr_file, &hdr_nt.FileHeader, sizeof(IMAGE_FILE_HEADER));

			IMAGE_OPTIONAL_HEADER hdr_optional;
			memcpy(&hdr_optional, &hdr_nt.OptionalHeader, sizeof(IMAGE_OPTIONAL_HEADER));
			if((hdr_optional.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) || (hdr_optional.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)) {
				if(hdr_optional.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) {
					tmpblock->Protect |= M_ASLR;
				}

				if(hdr_optional.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT) {
					tmpblock->Protect |= M_DEP;
				}
			}
		}
	}
}
*/

void GiSnapDump::__getBlockInfo(MEM_BLOCK *tmpblock, char * name)
{
	*name = 0;
	ULONG64 hprocess = 0;
	g_SystemObjects->GetCurrentProcessHandle(&hprocess);

	HANDLE h_snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, GetProcessId((HANDLE)hprocess));
	
	if(h_snapshot == INVALID_HANDLE_VALUE)
		return;
	MODULEENTRY32 __modentry;
	__modentry.dwSize = sizeof(MODULEENTRY32);

	SetLastError(0);	
	if(Module32First(h_snapshot, &__modentry) == FALSE)
		return;
	do {
		if((tmpblock->BaseAddress >= (uint64_t)__modentry.modBaseAddr) && (tmpblock->BaseAddress < (uint64_t)(__modentry.modBaseAddr+__modentry.modBaseSize))) {
//			lstrcpyn(name, __modentry.szModule, 1024);
			wsprintfA(name, "%S", __modentry.szModule);
			__setASLRDEP(tmpblock, (uint64_t)__modentry.modBaseAddr);
			break;
		}

		if(GetLastError() == ERROR_NO_MORE_FILES)
			break;
		__modulelist.push_back(__modentry);
	} while(Module32Next(h_snapshot, &__modentry));
	CloseHandle(h_snapshot);
}


void  GiSnapDump::TakeSnapshot(char *filename)
{
	ULONG64 hprocess = 0;
	g_SystemObjects->GetCurrentProcessHandle(&hprocess);

	BOOL bIs64 = (__getArch() == ARCH_X64) ;

	// fill a vector with valid memory blocks
	MEM_BLOCK tmpblock = {0};
	memset(&tmpblock.name, 0, 256);
	MEMORY_BASIC_INFORMATION info = {0};
	uint64_t addr=0;
	while(VirtualQueryEx((HANDLE)hprocess, (LPVOID)addr, &info, sizeof(info))) {
		if((info.State == MEM_COMMIT) || (info.Type == MEM_MAPPED) || (info.Type == MEM_IMAGE)) {
			if(bIs64) {
				tmpblock.BaseAddress = (uint64_t)info.BaseAddress;
				tmpblock.RegionSize = info.RegionSize;
			} else {
				tmpblock.BaseAddress = (DWORD)info.BaseAddress;	//cast takes care of idiotic sign extension on pointers
				tmpblock.RegionSize = (DWORD)info.RegionSize;
			}
			if(info.Protect) {
				tmpblock.Protect = __translateProtFlags(info.Protect);
			} else {
				tmpblock.Protect = __translateProtFlags(info.AllocationProtect);
			}
			__getBlockInfo(&tmpblock, (char *)&tmpblock.name);
			__printBlockInfo(&tmpblock);
			memblocks.push_back(tmpblock);
		}
		addr += info.RegionSize+1;
	} 

	// write
	// create dumpfile
	FILE *dumpfile = fopen(filename, "wb" );
	if(!dumpfile) {
		return;
	}

	SNAPSHOTFILE snphdr = {0};
	snphdr.sig = 0x70616E73;
	snphdr.version = 0x00000002;
	snphdr.flags = __getArch() | OS_WINDOWS;

	snphdr.blockcount = (uint32_t)memblocks.size();

	// write header SNAPSHOTFILE
	fwrite ( &snphdr, sizeof(SNAPSHOTFILE) , 1 , dumpfile);

	unsigned int blkcnt=0;

//	SetProgressBar(0);

	for (std::vector<MEM_BLOCK>::iterator block = memblocks.begin(); block != memblocks.end(); ++block, ++blkcnt)
	{

		MEM_BLOCK tmpblock = {0};

		tmpblock.RegionSize = block->RegionSize;
		tmpblock.BaseAddress = block->BaseAddress;
		tmpblock.Protect = block->Protect;
		strncpy((char *)&tmpblock.name, (char *)&block->name, 255);

		// write MEM_BLOCK
		fwrite ( &tmpblock, sizeof(MEM_BLOCK) , 1 , dumpfile);
		// write data
		uint8_t *buffer = new uint8_t [(unsigned int)block->RegionSize];
		ReadProcessMemory((HANDLE)hprocess, (LPCVOID)block->BaseAddress, buffer, (ULONG)block->RegionSize, NULL);
		fwrite ( buffer , (size_t)block->RegionSize, 1 , dumpfile);
		delete buffer;
//		SetProgressBar(blkcnt*100/snphdr.blockcount);
	}
	fclose(dumpfile);
	dprintf("done!\n");
//	CloseHandle(hprocess);
//	SetProgressBar(100);
}

// sets memory region flags corresponding to ASLR and/or DEP dllCharacteristics
void GiSnapDump::__setASLRDEP(MEM_BLOCK *tmpblock, uint64_t dllbase)
{
	ULONG modidx = 0;
	ULONG64 modbase = dllbase;

	ULONG64 hprocess = 0;
	g_SystemObjects->GetCurrentProcessHandle(&hprocess);

	IMAGE_DOS_HEADER hdr_mz;
	ReadProcessMemory((HANDLE)hprocess, (LPCVOID)modbase, &hdr_mz, sizeof(IMAGE_DOS_HEADER), NULL);
	if(hdr_mz.e_magic == IMAGE_DOS_SIGNATURE) {
		IMAGE_NT_HEADERS hdr_nt;
		ReadProcessMemory((HANDLE)hprocess, (LPCVOID)(modbase+hdr_mz.e_lfanew), &hdr_nt, sizeof(IMAGE_NT_HEADERS), NULL);
		if(hdr_nt.Signature == IMAGE_NT_SIGNATURE) {
			IMAGE_FILE_HEADER hdr_file;
			memcpy(&hdr_file, &hdr_nt.FileHeader, sizeof(IMAGE_FILE_HEADER));

			IMAGE_OPTIONAL_HEADER hdr_optional;
			memcpy(&hdr_optional, &hdr_nt.OptionalHeader, sizeof(IMAGE_OPTIONAL_HEADER));
			if((hdr_optional.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC) || (hdr_optional.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)) {
				if(hdr_optional.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE) {
					tmpblock->Protect |= M_ASLR;
				}

				if(hdr_optional.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_NX_COMPAT) {
					tmpblock->Protect |= M_DEP;
				}
			}
		}
	}
}

/*

void GiSnapDump::TakeSnapshot(char *filename)
{
	ULONG64 hprocess = 0;
	g_SystemObjects->GetCurrentProcessHandle(&hprocess);

	//check x64
	BOOL bIs64 = (__getArch() == ARCH_X64);

	MEMORY_BASIC_INFORMATION info = {0};

	// fill a vector with valid memory blocks
	MEM_BLOCK tmpblock = {0};

	uint64_t addr=0;
	while(VirtualQueryEx((HANDLE)hprocess, (LPVOID)addr, &info, sizeof(info))) {
		if((info.State == MEM_COMMIT) && ((info.Type == MEM_MAPPED) || (info.Type == MEM_IMAGE))) {
			if(bIs64) {
				tmpblock.BaseAddress = (uint64_t)info.BaseAddress;
				tmpblock.RegionSize = info.RegionSize;
			} else {
				tmpblock.BaseAddress = (DWORD)info.BaseAddress;	//cast takes care of idiotic sign extension on pointers
				tmpblock.RegionSize = (DWORD)info.RegionSize;
			}
			tmpblock.Protect = __translateProtFlags(info.Protect);

			char name[1024] = {0};
			__getMemRegionName(tmpblock.BaseAddress, name);
			strncpy((char *)tmpblock.name, name, sizeof(tmpblock.name));

			// if region is part of an executable image we set ASLR and DEP flags accordingly
			if(info.Type == MEM_IMAGE) {
				__setASLRDEP(&tmpblock);
			}

			// print block info on the console
			__printBlockInfo(&tmpblock);
			// save for later
			memblocks.push_back(tmpblock);
		}
		addr += info.RegionSize;
	} 

	// create dumpfile
	FILE *dumpfile = fopen(filename, "wb" );
	if(!dumpfile) {
		dprintf("ERROR: cannot write %s\r\n", filename);
		return;
	}

	dprintf("Writting %s...", filename);
	SNAPSHOTFILE snphdr = {0};
	snphdr.sig = 0x70616E73;
	snphdr.version = 0x00000002;

	snphdr.flags = __getArch() | OS_WINDOWS;
	snphdr.blockcount = (uint32_t)memblocks.size();

	// write header SNAPSHOTFILE
	fwrite ( &snphdr, sizeof(SNAPSHOTFILE) , 1 , dumpfile);

	for (std::vector<MEM_BLOCK>::iterator block = memblocks.begin(); block != memblocks.end(); ++block)
	{

		MEM_BLOCK tmpblock = {0};

		tmpblock.RegionSize = block->RegionSize;
		tmpblock.BaseAddress = block->BaseAddress;
		strncpy((char *)&tmpblock.name, (char *)block->name, sizeof(tmpblock.name));
		tmpblock.Protect = block->Protect;
		
		// write MEM_BLOCK
		fwrite ( &tmpblock, sizeof(MEM_BLOCK) , 1 , dumpfile);
		// write data
		uint8_t *buffer = new uint8_t [(unsigned int)block->RegionSize];
		ReadMemory((ULONG)block->BaseAddress, buffer, (ULONG)block->RegionSize, NULL);
		fwrite ( buffer , (size_t)block->RegionSize, 1 , dumpfile);
		delete buffer;
	}
	fclose(dumpfile);
	dprintf("done!\n");
}
*/
GiSnapDump::~GiSnapDump()
{
	if (g_Client != NULL)
	{
		g_Client->EndSession(DEBUG_END_PASSIVE);
		g_Client->Release();
		g_Client = NULL;

		g_Control->Release();
		g_Symbols->Release();
		g_Symbols2->Release();
		g_DataSpaces2->Release();
		g_DataSpaces3->Release();
		g_DataSpaces4->Release();
		g_SystemObjects->Release();

	}

	g_Control = NULL;
	g_Symbols = NULL;
	g_Symbols2 = NULL;
	g_DataSpaces2 = NULL;
	g_DataSpaces3 = NULL;
	g_SystemObjects = NULL;
}

```

`src/gisnap/windbg_ext/src/gisnap.h`:

```h
#include <windows.h>

#ifdef __WIN64
	#define KDEXT_64BIT 
#endif
#include <wdbgexts.h>

#include <DbgEng.h>
#include <Psapi.h>
#include <TlHelp32.h>

#include <stdint.h> 

#include <iostream>
#include <vector>

#include "snapshotformat.h"

#ifndef __GISNAP__
	#define __GISNAP__

//#define MEM_BLOCK DUMPBLOCKV10
#define MEM_BLOCK DUMPBLOCKV20

class GiSnapDump
{
	private:
		IDebugClient* g_Client;

		IDebugControl* g_Control;
		IDebugSymbols* g_Symbols;
		IDebugSymbols2* g_Symbols2;

		IDebugDataSpaces2* g_DataSpaces2;
		IDebugDataSpaces3* g_DataSpaces3;
		IDebugDataSpaces4* g_DataSpaces4;

		IDebugSystemObjects *g_SystemObjects;

		std::vector<MEM_BLOCK> memblocks;
		std::vector<MODULEENTRY32> __modulelist;

		void GiSnapDump::__getStrForProt(uint32_t prot, char* dest);
		void GiSnapDump::__getStrForNativeProt(uint32_t prot, char *dest);

		void GiSnapDump::__getStrForStat(uint32_t stat, char* dest);

		uint32_t GiSnapDump::__translateProtFlags(uint32_t prot);
		void GiSnapDump::__setASLRDEP(MEM_BLOCK *tmpblock, uint64_t dllbase);

		void GiSnapDump::__getBlockInfo(MEM_BLOCK *tmpblock, char * name);

		uint32_t GiSnapDump::__getArch();
		uint32_t GiSnapDump::__getOS();

		void GiSnapDump::__getMemRegionName(uint64_t, char *symname);
		void GiSnapDump::__printBlockInfo(MEM_BLOCK *);

	public:
		GiSnapDump::GiSnapDump();
		GiSnapDump::~GiSnapDump();
		void GiSnapDump::TakeSnapshot(char *filename);
};


#endif

```

`src/gisnap/windbg_ext/src/snapshotformat.h`:

```h
// standard structures for writting/reading Gadget Inspector snapshots

#ifndef __SNAPSHOTFORMAT
	#define __SNAPSHOTFORMAT

#include <stdint.h> 

// Memory protection flags
#define M_READ		0x01
#define M_WRITE		0x02
#define M_EXEC		0x04

#define M_ASLR		0x08	// ASLR is enabled
#define M_DEP		0x10	// DEP is enabled

// OS flags
#define OS_WINDOWS	0x0100
#define OS_LINUX	0x0200
#define OS_MACOS	0x0400
#define OS_ANDROID	0x0800
#define OS_IOS		0x1000

// Arch. flags
#define ARCH_X86	0x10000
#define ARCH_X64	0x20000
#define ARCH_ARM	0x40000
#define ARCH_PPC	0x80000

#pragma pack(push)
#pragma pack(1)
typedef struct _SNAPSHOTFILE
{
	uint32_t sig;			// signature: "snap" or 0x70616E73 in little endian
	uint32_t version;		// if version == 1: use DUMPBLOCKV10 / version == 2 uses DUMPBLOCKV20 and so on.
	uint32_t flags;			//
	uint32_t blockcount;
} SNAPSHOTFILE, *PSNAPSHOTFILE;

typedef struct _dumpblockV10
{
	uint64_t BaseAddress;
	uint64_t RegionSize;
	uint32_t Protect;		// see memory protection constants
} DUMPBLOCKV10, *PDUMPBLOCKV10;

typedef struct _dumpblockV20
{
	uint64_t BaseAddress;
	uint64_t RegionSize;
	uint32_t Protect;		// see memory protection constants
	uint8_t  name[256];
} DUMPBLOCKV20, *PDUMPBLOCKV20;

#pragma pack(pop)
#endif // __SNAPSHOTFORMAT
```

`src/gisnap/windbg_ext/src/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// windbg_ext.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`src/gisnap/windbg_ext/src/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "targetver.h"

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files:
#include <windows.h>



// TODO: reference additional headers your program requires here

```

`src/gisnap/windbg_ext/src/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`src/gisnap/windbg_ext/src/windbg_ext.cpp`:

```cpp
// SnapshotDumper windbg/ntsd extension.

#include <windows.h>
#include <imagehlp.h>

#ifdef __WIN64
	#define KDEXT_64BIT 
#endif
#include <wdbgexts.h>

#include "gisnap.h"

// Global Variable Needed For Functions
WINDBG_EXTENSION_APIS ExtensionApis = {0};
                      
// Global Variable Needed For Versioning
EXT_API_VERSION g_ExtApiVersion = {1 , 1 , EXT_API_VERSION_NUMBER , 0};

// dllmain
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
	switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
	}
	return TRUE;
}

// ExtensionApiVersion
LPEXT_API_VERSION WDBGAPI ExtensionApiVersion (void)
{
    return &g_ExtApiVersion;
}

// WinDbgExtensionDllInit
VOID WDBGAPI WinDbgExtensionDllInit (PWINDBG_EXTENSION_APIS lpExtensionApis, USHORT usMajorVersion, USHORT usMinorVersion)
{
     ExtensionApis = *lpExtensionApis;
}

// !help
DECLARE_API (help)
{
    dprintf("Gadget Inspector - SnapshotDumper\n\n");
    dprintf("!gisnap <output.dmp>\n");
}

// !gisnap
DECLARE_API (gisnap)
{

	if (!args || !*args) {
		dprintf("Usage: \n\t!gisnap <output.dmp>\n");
		return;
	}

	GiSnapDump *gsnp = new GiSnapDump;
	gsnp->TakeSnapshot((char *)args);
	delete gsnp;
}

```

`src/gisnap/windbg_ext/src/windbg_ext.def`:

```def
LIBRARY "windbg_ext.DLL"

EXPORTS
    WinDbgExtensionDllInit
    ExtensionApiVersion
    gisnap
    help
```

`src/gisnap/windbg_ext/src/windbg_ext.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 2012
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "windbg_ext", "windbg_ext.vcxproj", "{5F2AC2EC-E314-49CC-91EB-B240D1AE8833}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{5F2AC2EC-E314-49CC-91EB-B240D1AE8833}.Debug|Win32.ActiveCfg = Release|Win32
		{5F2AC2EC-E314-49CC-91EB-B240D1AE8833}.Debug|Win32.Build.0 = Release|Win32
		{5F2AC2EC-E314-49CC-91EB-B240D1AE8833}.Debug|x64.ActiveCfg = Release|x64
		{5F2AC2EC-E314-49CC-91EB-B240D1AE8833}.Debug|x64.Build.0 = Release|x64
		{5F2AC2EC-E314-49CC-91EB-B240D1AE8833}.Release|Win32.ActiveCfg = Release|Win32
		{5F2AC2EC-E314-49CC-91EB-B240D1AE8833}.Release|Win32.Build.0 = Release|Win32
		{5F2AC2EC-E314-49CC-91EB-B240D1AE8833}.Release|x64.ActiveCfg = Release|x64
		{5F2AC2EC-E314-49CC-91EB-B240D1AE8833}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`src/gisnap/windbg_ext/src/windbg_ext.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{5F2AC2EC-E314-49CC-91EB-B240D1AE8833}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>windbg_ext</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v110</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v110</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v110</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v110</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;WINDBG_EXT_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>windbg_ext.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;_USRDLL;WINDBG_EXT_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ModuleDefinitionFile>windbg_ext.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_WINDOWS;_USRDLL;WINDBG_EXT_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>windbg_ext.def</ModuleDefinitionFile>
      <AdditionalDependencies>dbgeng.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>NotUsing</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>_CRT_SECURE_NO_WARNINGS;WIN32;NDEBUG;_WINDOWS;_USRDLL;WINDBG_EXT_EXPORTS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>windbg_ext.def</ModuleDefinitionFile>
      <AdditionalDependencies>dbgeng.lib;kernel32.lib;user32.lib;gdi32.lib;winspool.lib;comdlg32.lib;advapi32.lib;shell32.lib;ole32.lib;oleaut32.lib;uuid.lib;odbc32.lib;odbccp32.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="gisnap.h" />
    <ClInclude Include="snapshotformat.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="gisnap.cpp" />
    <ClCompile Include="windbg_ext.cpp" />
  </ItemGroup>
  <ItemGroup>
    <None Include="windbg_ext.def" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/gisnap/windbg_ext/src/windbg_ext.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="gisnap.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="snapshotformat.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="windbg_ext.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="gisnap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="windbg_ext.def">
      <Filter>Source Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Text Include="ReadMe.txt" />
  </ItemGroup>
</Project>
```

`src/gisnap/windbg_ext/src/windbg_ext.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`src/list.cpp`:

```cpp
/****************************************************************************/
/****************************************************************************/

/* list.cpp */

/****************************************************************************/
/****************************************************************************/

/* Prototipos */

class List
{
private:
  unsigned int len;
  void **elementos;

private:
  int Get_Element_By_Secuential_Search ( void * , unsigned int * );
  int Get_Element_By_Binary_Search ( void * , unsigned int * );

public:
  int ordenada;

  List ();
  ~List ();
  unsigned int Len ();
  unsigned int Len ( unsigned int );
  unsigned int Add ( void * );
  void Append ( List & );
  void Append ( List * );
  void *Get ( unsigned int );
  int GetPos ( void * , unsigned int * );
  int Set ( unsigned int , void * );
  int Find ( void * );
  int Delete ( unsigned int );
  int DeleteElement ( void * );
  int Clear ( void );
  void Sort ( void );
  void SortCouple ( List & );
  void SortCouple ( List * );
  void SortTuple ( List & , List & );
  int Swap ( unsigned int , unsigned int );

/* Metodos para hacer PERSISTENCIA */
  int Save ( FILE * );
  int Load ( FILE * );
};

/****************************************************************************/
/****************************************************************************/

/* Prototipos de funciones */

int get_element_by_secuential_search ( void * , unsigned int * );
int get_element_by_binary_search ( void * , unsigned int * );

/****************************************************************************/
/****************************************************************************/

/* Defines */

#define FALSE 0
#define TRUE  1

/* Para mantener la compatibilidad */
#ifdef _IDA_HPP
  #define fread(a,b,c,d) qfread(d,a,b)
  #define fwrite(a,b,c,d) qfwrite(d,a,b)
  #define malloc(a) my_malloc(a)
  #define realloc(a,b) my_realloc(a,b)
  #define free(a) my_free(a)
#endif

/****************************************************************************/
/****************************************************************************/

/* Funciones */

List::List ()
{
/* Seteo el flag que indica que la lista esta ordenada */
  this -> ordenada = TRUE;

/* Seteo la longitud de la lista */
  this -> len = 0;

/* Inicializo la lista */
  this -> elementos = NULL;
}

/****************************************************************************/

List::~List ()
{
/* Libero la lista */
  free ( this -> elementos );
}

/****************************************************************************/

unsigned int List::Len ( void )
{
/* Retorno la longitud de la lista */
  return ( this -> len );
}

/****************************************************************************/

unsigned int List::Len ( unsigned int new_len )
{
  unsigned int len = this -> len;
  void *new_list;
  unsigned int cont;

/* Seteo el nuevo size */
  new_list = realloc ( this -> elementos , new_len * sizeof ( void * ) );

/* Si el nuevo len pudo ser seteado */
  if ( new_list != NULL )
  {
  /* Seteo la nueva lista */
    this -> elementos = ( void ** ) new_list;

  /* Seteo el nuevo size */
    this -> len = new_len;

  /* Si la lista fue agrandada */
    if ( len < new_len )
    {
    /* PADEO la nueva parte con CEROS */
      for ( cont = len ; cont < new_len ; cont ++ )
      {
      /* Seteo la posicion con el valor NULL */
        this -> Set ( cont , NULL );
      }
    }
  }

  return ( len );
}

/****************************************************************************/

unsigned int List::Add ( void *elemento )
{
  void *new_list;
  unsigned int ultima_pos;

/* Agrando la lista */
  new_list = realloc ( this -> elementos , ( sizeof ( void * ) ) * ( this -> len + 1 ) ); 

/* Si pude agrandar la lista */
  if ( new_list != NULL )
  {
  /* Seteo la nueva lista */
    this -> elementos = ( void ** ) new_list;

  /* Agrego el nuevo elemento */
    this -> elementos [ this -> len ] = elemento;

  /* Agrando la longitud de la lista */
    this -> len ++;

  /* Retorno la posicion donde se agrego el elemento */
    ultima_pos = this -> len - 1;

  /* Si hay mas de 1 elemento en la lista */
    if ( this -> len > 1 )
    {
    /* Si el elemento agregado es menor al ultimo elemento */
      if ( this -> elementos [ this -> len - 2 ] > elemento )
      {
      /* Pierdo el orden en la lista */
        this -> ordenada = FALSE;
      }
    }
  }

  return ( ultima_pos );
}

/****************************************************************************/

void List::Append ( List &second_list )
{
  unsigned int pos;
  int ret = TRUE;

/* Recorro toda la lista */
  for ( pos = 0 ; pos < second_list.Len () ; pos ++ )
  {
  /* Agrego el elemento a la lista */
    this -> Add ( second_list.Get ( pos ) );
  }
}

/****************************************************************************/

void List::Append ( List *second_list )
{
  unsigned int pos;
  int ret = TRUE;

/* Recorro toda la lista */
  for ( pos = 0 ; pos < second_list -> Len () ; pos ++ )
  {
  /* Agrego el elemento a la lista */
    this -> Add ( second_list -> Get ( pos ) );
  }
}

/****************************************************************************/

void *List::Get ( unsigned int pos )
{
  void *elemento = NULL;

/* Si el elemento esta dentro de la lista */
  if ( pos < this -> len )
  {
  /* Retorno el elemento que hay en esa posicion */
    elemento = this -> elementos [ pos ];
  }

  return ( elemento );
}

/****************************************************************************/

int List::GetPos ( void *elemento , unsigned int *posicion )
{
  int ret;

/* Si la lista se conserva ordenada y tiene mas de 2 elementos */
  if ( ( this -> ordenada == TRUE ) && ( this -> Len () > 2 ) )
  {
  /* Busco el elemento en la lista en forma binaria */
    ret = this -> Get_Element_By_Binary_Search ( elemento , posicion );
  }
  else
  {
  /* Busco el elemento en la lista en forma secuencial */
    ret = this -> Get_Element_By_Secuential_Search ( elemento , posicion );
  }

  return ( ret );
}

/****************************************************************************/

int List::Set ( unsigned int posicion , void *elemento )
{
  int ret = TRUE;

/* Si la posicion NO sobrepasa el rango de elementos */
  if ( posicion < this -> Len () )
  {
  /* Piso el elemento existente */
    this -> elementos [ posicion ] = elemento;

  /* Apago el orden en la lista ( arreglar en algun momento ) */
    this -> ordenada = FALSE;
  }

  return ( ret );
}

/****************************************************************************/

int List::Find ( void *elemento )
{
  unsigned int pos;
  int ret;

/* Si la lista se conserva ordenada y tiene mas de 2 elementos */
  if ( ( this -> ordenada == TRUE ) && ( this -> Len () > 2 ) )
  {
  /* Busco el elemento en la lista en forma binaria */
    ret = this -> Get_Element_By_Binary_Search ( elemento , &pos );
  }
  else
  {
  /* Busco el elemento en la lista en forma secuencial */
    ret = this -> Get_Element_By_Secuential_Search ( elemento , &pos );
  }

  return ( ret );
}

/****************************************************************************/

int List::Delete ( unsigned int pos )
{
  unsigned int cont;
  int ret = FALSE;

/* Si el elemento esta dentro de la lista */
  if ( pos < this -> len )
  {
  /* Compacto la lista */
    for ( cont = ( pos + 1 ) ; cont < this -> len ; cont ++ )
    {
    /* Muevo el valor del actual al anterior */
      this -> elementos [ cont - 1 ] = this -> elementos [ cont ];
    }

  /* Achico la lista */
    this -> elementos = ( void ** ) realloc ( this -> elementos , ( sizeof ( void * ) ) * ( this -> len - 1 ) );

  /* Seteo la nueva longitud de la lista */
    this -> len --;

  /* Retorno OK */
    ret = TRUE;
  }

  return ( ret );
}

/****************************************************************************/

int List::DeleteElement ( void *elemento )
{
  unsigned int pos;
  int ret = FALSE;

/* Si el elemento existe */
  if ( this -> GetPos ( elemento , &pos ) == TRUE )
  {
  /* Elimino el elemento de la lista */
    this -> Delete ( pos );

  /* Retorno OK */
    ret = TRUE;
  }

  return ( ret );
}

/****************************************************************************/

int List::Clear ( void )
{
  int ret = TRUE;

/* Reinicializo el flag de lista ordenada */
  this -> ordenada = TRUE;

/* Seteo la longitud de la lista */
  this -> len = 0;

/* Libero la lista */
  free ( this -> elementos );

/* Inicializo la lista */
  this -> elementos = NULL;

  return ( ret );
}

/****************************************************************************/

void List::Sort ( void )
{
  unsigned int cont1;
  unsigned int cont2;
  void *elemento_temporal;

/* Si la lista esta ordenada */
  if ( this -> ordenada == TRUE )
  {
  /* Salgo sin hacer nada */
    return;
  }

/* Si NO hay elementos para ordenar */
  if ( this -> Len () < 2 )
  {
  /* Salgo sin hacer nada */
    return;
  }

/* Recorro todos los elementos */
  for ( cont1 = 0 ; cont1 < this -> Len () - 1 ; cont1 ++ )
  {
  /* Recorro todos los elementos */
    for ( cont2 = cont1 + 1 ; cont2 < this -> Len () ; cont2 ++ )
    {
    /* Si elemento1 es mayor que elemento2 */
      if ( this -> elementos [ cont1 ] > this -> elementos [ cont2 ] )
      {
      /* Intercambio los elementos */
        elemento_temporal = this -> elementos [ cont1 ];
        this -> elementos [ cont1 ] = this -> elementos [ cont2 ];
        this -> elementos [ cont2 ] = elemento_temporal;
      }
    }
  }

/* Marco la lista como ordenada */
  this -> ordenada = TRUE;
}

/****************************************************************************/

void List::SortCouple ( List &linked_list )
{
  unsigned int cont1;
  unsigned int cont2;

/* Si NO hay elementos para ordenar */
  if ( this -> Len () < 2 )
  {
  /* Salgo sin hacer nada */
    return;
  }

/* Recorro todos los elementos */
  for ( cont1 = 0 ; cont1 < this -> Len () - 1 ; cont1 ++ )
  {
  /* Recorro todos los elementos */
    for ( cont2 = cont1 + 1 ; cont2 < this -> Len () ; cont2 ++ )
    {
    /* Si elemento1 es mayor que elemento2 */
      if ( this -> elementos [ cont1 ] > this -> elementos [ cont2 ] )
      {
      /* Intercambio los elementos en la lista */
        this -> Swap ( cont1 , cont2 );

      /* Intercambio los elementos en la lista original LINKEADA */
        linked_list.Swap ( cont1 , cont2 );
      }
    }
  }

/* Marco la lista como ordenada */
  this -> ordenada = TRUE;
}

/****************************************************************************/

void List::SortCouple ( List *linked_list )
{
  unsigned int cont1;
  unsigned int cont2;

/* Si NO hay elementos para ordenar */
  if ( this -> Len () < 2 )
  {
  /* Salgo sin hacer nada */
    return;
  }

/* Recorro todos los elementos */
  for ( cont1 = 0 ; cont1 < this -> Len () - 1 ; cont1 ++ )
  {
  /* Recorro todos los elementos */
    for ( cont2 = cont1 + 1 ; cont2 < this -> Len () ; cont2 ++ )
    {
    /* Si elemento1 es mayor que elemento2 */
      if ( this -> elementos [ cont1 ] > this -> elementos [ cont2 ] )
      {
      /* Intercambio los elementos en la lista */
        this -> Swap ( cont1 , cont2 );

      /* Intercambio los elementos en la lista original LINKEADA */
        linked_list -> Swap ( cont1 , cont2 );
      }
    }
  }

/* Marco la lista como ordenada */
  this -> ordenada = TRUE;
}

/****************************************************************************/

void List::SortTuple ( List &list1 , List &list2 )
{
  unsigned int cont1;
  unsigned int cont2;

/* Si NO hay elementos para ordenar */
  if ( this -> Len () < 2 )
  {
  /* Salgo sin hacer nada */
    return;
  }

/* Recorro todos los elementos */
  for ( cont1 = 0 ; cont1 < this -> Len () - 1 ; cont1 ++ )
  {
  /* Recorro todos los elementos */
    for ( cont2 = cont1 + 1 ; cont2 < this -> Len () ; cont2 ++ )
    {
    /* Si elemento1 es mayor que elemento2 */
      if ( this -> elementos [ cont1 ] > this -> elementos [ cont2 ] )
      {
      /* Intercambio los elementos en la lista maestra */
        this -> Swap ( cont1 , cont2 );

      /* Intercambio los elementos de las listas */
        list1.Swap ( cont1 , cont2 );
        list2.Swap ( cont1 , cont2 );
      }
    }
  }

/* Marco la lista como ordenada */
  this -> ordenada = TRUE;
}

/****************************************************************************/

int List::Swap ( unsigned int pos1 , unsigned int pos2 )
{
  void *elemento1;
  void *elemento2;
  int ret = FALSE;

/* Si los rangos NO estan fuera de la cantidad de elementos */
  if ( ( pos1 < this -> Len () ) && ( pos2 < this -> Len () ) )
  {
  /* Obtengo el primer elemento */
    elemento1 = this -> Get ( pos1 );

  /* Obtengo el segundo elemento */
    elemento2 = this -> Get ( pos2 );

  /* Seteo el lugar del primer elemento con el segundo */
    this -> Set ( pos1 , elemento2 );

  /* Seteo el lugar del segundo elemento con el primero */
    this -> Set ( pos2 , elemento1 );

  /* Retorno OK */
    ret = TRUE;
  }

  return ( ret );
}

/****************************************************************************/

int List::Get_Element_By_Secuential_Search ( void *elemento , unsigned int *pos )
{
  unsigned int cont;
  unsigned int len;
  int ret = FALSE;

/* Averiguo la longitud de la lista */
  len = this -> Len ();

/* Busco el elemento en la lista */
  for ( cont = 0 ; cont < len ; cont ++ )
  {
  /* Si es el elemento que estoy buscando */
    if ( this -> Get ( cont ) == elemento )
    {
    /* Retorno la posicion del elemento */
      *pos = cont;

    /* Retorno OK */
      ret = TRUE;

    /* Corto la busqueda */
      break;
    }
  }

  return ( ret );
}

/****************************************************************************/

int List::Get_Element_By_Binary_Search ( void *elemento , unsigned int *pos )
{
  unsigned int valor_actual;
  int cota_minima;
  int cota_maxima;
  int pos_actual;
  int ret = FALSE;

/* Seteo la posicion minima */
  cota_minima = 0;

/* Seteo la posicion maxima */
  cota_maxima = this -> Len () - 1;

/* Mientras no se junten la minima con la maxima */
  while ( cota_minima <= cota_maxima )
  {
  /* Me posiciono en la mitad de las 2 cotas */
    pos_actual = ( cota_minima + cota_maxima ) / 2;

  /* Leo el valor correspondiente a la posicion */
    valor_actual = ( unsigned int ) this -> elementos [ pos_actual ];

  /* Si es el valor que estaba buscando */
    if ( valor_actual == ( unsigned int ) elemento )
    {
    /* Retorno la posicion */
      *pos = pos_actual;

    /* Retorno OK */
      ret = TRUE;

    /* Corto la busqueda */
      break;
    }

  /* Si el valor actual es mas chico que el valor que estoy buscando */
    if ( valor_actual < ( unsigned int ) elemento )
    {
    /* Muevo la cota minima una posicion mas que la actual */
      cota_minima = pos_actual + 1;
    }
  /* Si el valor actual es mas grande que el valor que estoy buscando */
    else
    {
      cota_maxima = pos_actual - 1;
    }
  }

  return ( ret );
}

/****************************************************************************/

int List::Save ( FILE *f )
{
  int ret = TRUE;

/* Guardo las propiedades del objeto */
  fwrite ( this , sizeof ( List ) , 1 , f );

/* Guardo la lista de todos los elementos */
  fwrite ( this -> elementos , this -> len * sizeof ( void * ) , 1 , f );

  return ( ret );
}

/****************************************************************************/

int List::Load ( FILE *f )
{
  int ret = TRUE;

/* Reseteo la lista */
  this -> Clear ();

/* Levanto las propiedades del objeto */
  fread ( this , sizeof ( List ) , 1 , f );

/* Alloco espacio para todas las propiedades */
  this -> elementos = ( void ** ) malloc ( this -> len * sizeof ( void * ) );

/* Levanto toda la lista de elementos */
  fread ( this -> elementos , this -> len * sizeof ( void * ) , 1 , f );

  return ( ret );
}

/****************************************************************************/
/****************************************************************************/

#undef malloc
#undef realloc
#undef free

/****************************************************************************/
/****************************************************************************/


```

`src/make.bat`:

```bat

@rem Console makefile for Microsoft Visual Studio C++
@rem Note:
@rem If you don't have the "Microsoft Visual Studio" path,
@rem  Please, execute the "vcvarsall.bat" command in "C:\Program Files\Microsoft Visual Studio XX.X\VC"

@rem To compile Gisnap use "Microsoft Visual Studio 2012"
cl.exe fsnap.c /link -SUBSYSTEM:CONSOLE -DYNAMICBASE:NO -BASE:0x08000000 -FIXED
cl.exe agafi.cpp /link -SUBSYSTEM:CONSOLE
cl agafi-rop.cpp /link -SUBSYSTEM:CONSOLE

```

`src/qemu.c`:

```c
////////////////////////////////////////////////////////////////////////////////

/* qemu,c ( QEMU wrapper ) */

////////////////////////////////////////////////////////////////////////////////

/* Estructuras */

typedef struct
{
  unsigned int padding;
  unsigned int base;
  unsigned int limit;
  unsigned int flags;
} QEMU_SEGMENT;

typedef struct
{
  unsigned int eax;
  unsigned int ecx;
  unsigned int edx;
  unsigned int ebx;
  unsigned int esp;
  unsigned int ebp;
  unsigned int esi;
  unsigned int edi;
  unsigned int eip;
  unsigned int eflags;
  unsigned int cc_src;
  unsigned int cc_dst;
  unsigned int cc_op;
  unsigned int df;
  unsigned int hflags;
  unsigned int hflags2;
  QEMU_SEGMENT segments [ 6 ]; // ES,CS,SS,DS,FS,GS
  QEMU_SEGMENT ldt;
  QEMU_SEGMENT tr;
  QEMU_SEGMENT gdt; /* only base and limit are used */
  QEMU_SEGMENT idt; /* only base and limit are used */
  unsigned int cr[5]; /* NOTE: cr1 is unused */
  unsigned int padding [0x214/sizeof (unsigned int)];
  unsigned int operation_code;
  unsigned int operation_address;
} QEMU_CONTEXT;

////////////////////////////////////////////////////////////////////////////////

/* Variables globales */

HMODULE hqemu = NULL;
char *qemu_module = "pyqemulib.dll";

////////////////////////////////////////////////////////////////////////////////

/* Funciones */

QEMU_CONTEXT *init_vm ( void )
{
  static QEMU_CONTEXT * ( *qemu_init_vm ) ( void ) = NULL;
  QEMU_CONTEXT *context;

/* Si es la primera vez */
  if ( qemu_init_vm == NULL )
  {
  /* Resuelvo el simbolo de la funcion */
    qemu_init_vm = ( QEMU_CONTEXT * ( * ) ( void ) ) GetProcAddress ( hqemu , "init_vm" );
  }

/* Instancio la VM */
  context = qemu_init_vm ();

  return ( context );
}

////////////////////////////////////////////////////////////////////////////////

void *allocate_memory ( void *address , unsigned int size )
{
  static void * ( *qemu_allocate_memory ) ( void * , unsigned int ) = NULL;
  void *new_address;

/* Si es la primera vez */
  if ( qemu_allocate_memory == NULL )
  {
  /* Resuelvo el simbolo de la funcion */
    qemu_allocate_memory = ( void * ( * ) ( void * , unsigned int ) ) GetProcAddress ( hqemu , "allocate_memory" );
  }

/* Alloco memoria */
  new_address = ( void * ( * ) ( void * , unsigned int ) ) qemu_allocate_memory ( address , size );

  return ( new_address );
}

////////////////////////////////////////////////////////////////////////////////

int read_memory ( void *address , void *data , unsigned int size )
{
  static int ( *qemu_cpu_physical_memory_rw ) ( void * , void * , unsigned int , int ) = NULL;
  int ret;
  int res;

/* Si es la primera vez */
  if ( qemu_cpu_physical_memory_rw == NULL )
  {
  /* Resuelvo el simbolo de la funcion */
    qemu_cpu_physical_memory_rw = ( int ( * ) ( void * , void * , unsigned int , int ) ) GetProcAddress ( hqemu , "cpu_physical_memory_rw" );
  }

/* Leo la memoria pedida ( read = 0 ) */
  res = qemu_cpu_physical_memory_rw ( address , data , size , 0 );
//  printf ( "READ = %i\n" , res );

/* Si pude leer la memoria */
  if ( res != 0 )
  {
  /* Retorno OK */
    ret = TRUE;
  }
/* Si hubo algun ERROR */
  else
  {
  /* Salgo con ERROR */
    ret = FALSE;
  }

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

void write_memory ( void *data , void *address , unsigned int size )
{
  static int ( *qemu_cpu_physical_memory_write_rom ) ( void * , void * , unsigned int ) = NULL;

/* Si es la primera vez */
  if ( qemu_cpu_physical_memory_write_rom == NULL )
  {
  /* Resuelvo el simbolo de la funcion */
    qemu_cpu_physical_memory_write_rom = ( int ( * ) ( void * , void * , unsigned int ) ) GetProcAddress ( hqemu , "cpu_physical_memory_write_rom" );
  }

/* Alloco memoria */
  qemu_cpu_physical_memory_write_rom ( data , address , size );
}

////////////////////////////////////////////////////////////////////////////////

int cpu_reset ( QEMU_CONTEXT *context )
{
  static int ( *qemu_cpu_reset ) ( QEMU_CONTEXT * ) = NULL;
  int ret;

/* Si es la primera vez */
  if ( qemu_cpu_reset == NULL )
  {
  /* Resuelvo el simbolo de la funcion */
    qemu_cpu_reset = ( int ( * ) ( QEMU_CONTEXT * ) ) GetProcAddress ( hqemu , "cpu_reset" );
  }

/* Alloco memoria */
  ret = qemu_cpu_reset ( context );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int do_cpu_init ( QEMU_CONTEXT *context )
{
  static int ( *qemu_do_cpu_init ) ( QEMU_CONTEXT * ) = NULL;
  int ret;

/* Si es la primera vez */
  if ( qemu_do_cpu_init == NULL )
  {
  /* Resuelvo el simbolo de la funcion */
    qemu_do_cpu_init = ( int ( * ) ( QEMU_CONTEXT * ) ) GetProcAddress ( hqemu , "do_cpu_init" );
  }

/* Alloco memoria */
  ret = qemu_do_cpu_init ( context );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int cpu_loop ( QEMU_CONTEXT *context )
{
  static int ( *qemu_cpu_loop ) ( QEMU_CONTEXT * ) = NULL;
  int ret;

/* Si es la primera vez */
  if ( qemu_cpu_loop == NULL )
  {
  /* Resuelvo el simbolo de la funcion */
    qemu_cpu_loop = ( int ( * ) ( QEMU_CONTEXT * ) ) GetProcAddress ( hqemu , "cpu_loop" );
  }

/* Alloco memoria */
  ret = qemu_cpu_loop ( context );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

int cpu_x86_exec ( QEMU_CONTEXT *context )
{
  static int ( *qemu_cpu_x86_exec ) ( QEMU_CONTEXT * ) = NULL;
  int ret;

/* Si es la primera vez */
  if ( qemu_cpu_x86_exec == NULL )
  {
  /* Resuelvo el simbolo de la funcion */
    qemu_cpu_x86_exec = ( int ( * ) ( QEMU_CONTEXT * ) ) GetProcAddress ( hqemu , "cpu_x86_exec" );
  }

/* Alloco memoria */
  ret = qemu_cpu_x86_exec ( context );

  return ( ret );
}

////////////////////////////////////////////////////////////////////////////////

```