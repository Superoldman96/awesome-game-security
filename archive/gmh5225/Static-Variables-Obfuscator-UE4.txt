Project Path: arc_gmh5225_Static-Variables-Obfuscator-UE4_so3szemv

Source Tree:

```txt
arc_gmh5225_Static-Variables-Obfuscator-UE4_so3szemv
├── LICENSE
├── README.md
├── Resources
│   └── Icon128.png
├── Source
│   └── VariableObfuscator
│       ├── Private
│       │   ├── VarObBPLib.cpp
│       │   ├── VarObDelegates.cpp
│       │   └── VariableObfuscator.cpp
│       ├── Public
│       │   ├── BPTypes
│       │   │   ├── ObfusBool.h
│       │   │   ├── ObfusByte.h
│       │   │   ├── ObfusColor.h
│       │   │   ├── ObfusFloat.h
│       │   │   ├── ObfusInt32.h
│       │   │   ├── ObfusInt64.h
│       │   │   ├── ObfusLinearColor.h
│       │   │   ├── ObfusQuat.h
│       │   │   ├── ObfusRotator.h
│       │   │   ├── ObfusTransform.h
│       │   │   ├── ObfusVector.h
│       │   │   └── ObfusVector2D.h
│       │   ├── VarOb.h
│       │   ├── VarObBPLib.h
│       │   ├── VarObChunk.h
│       │   ├── VarObDelegates.h
│       │   ├── VarObDoOnce.h
│       │   └── VarObSupportedTypes.h
│       └── VariableObfuscator.Build.cs
├── TODO.txt
└── VariableObfuscator.uplugin

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Damian Nowakowski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# Static Variables Obfuscator UE4

This code plugin for Unreal Engine 4 obfuscates any static (non-dynamic) variable so it is very difficult to locate this variable in the memory.

This makes using tools like Cheat Engine to manipulate in-game data a non trivial task.

## How to use it?

Simply wrap a declared variable with TVarOb keyword and it will obfuscate it.

``` cpp
int32 X;            // Not obfuscated variable :(
TVarOb<int32> Y;    // Obfuscated variable :)
```

Obfuscated variable can be manipulated in the same manner as normally

``` cpp
TVarOb<int32> X = 1;    // Assing variable
X += 10;                // Increase variable
int32 Y = X;            // Get variable
```

## Using it with structs

Unfortunatelly to modify obfuscated struct it has to be unencrypted first.

``` cpp
struct FSomeStruct
{
    int32 X;
};

TVarOb<FSomeStruct> Foo;

FSomeStruct Bar = Foo;
Bar.X += 10;
Foo = Bar;
```

## What types are supported?

Currently it supports all arithmetic types and the following structures:

* FTransform
* FVector
* FVector2D
* FRotator
* FQuat
* FColor
* FLinearColor

Theoretically it should work with any struct that doesn't contain dynamic variables (pointers, strings, arrays, etc). However it implements a check to ensure only verified structures are used. If You want to You can add a proper trait check to the `VarObSupportedTypes.h`.

## Serialization

You can serialize obfuscated variable into a file so it will be obfuscated in file as well! In order to do this `TVarOb` can be imported and exported to an array of bytes using the following methods:
``` cpp
void ToArray(TArray<uint8>& OutData);
void FromArray(const TArray<uint8>& InData);
```
These arrays can be saved and load using the serialization method of Your choice.

## Blueprints

This plugin works the best with code but there are some structures and functions that allows to use it with Blueprint too. For more details check `VarObBPLib.h` file.

## More

Unreal Engine forum page: https://forums.unrealengine.com/community/community-content-tools-and-tutorials/1844271-plugin-static-variables-obfuscator-ue4


```

`Source/VariableObfuscator/Private/VarObBPLib.cpp`:

```cpp
#pragma once

#include "VarObBPLib.h"

// BOOL
bool UVarOBBPLib::GetBool(FObfusBool& ObfusBool)
{
	return ObfusBool.GetVal();
}

void UVarOBBPLib::SetBool(FObfusBool& ObfusBool, bool NewValue)
{
	ObfusBool.SetVal(NewValue);
}

// BYTE
uint8 UVarOBBPLib::GetByte(FObfusByte& ObfusByte)
{
	return ObfusByte.GetVal();
}

void UVarOBBPLib::SetByte(FObfusByte& ObfusByte, uint8 NewValue)
{
	ObfusByte.SetVal(NewValue);
}

// INT32
int32 UVarOBBPLib::GetInt32(FObfusInt32& ObfusInt32)
{
	return ObfusInt32.GetVal();
}

void UVarOBBPLib::SetInt32(FObfusInt32& ObfusInt32, int32 NewValue)
{
	ObfusInt32.SetVal(NewValue);
}

// INT64
int64 UVarOBBPLib::GetInt64(FObfusInt64& ObfusInt64)
{
	return ObfusInt64.GetVal();
}

void UVarOBBPLib::SetInt64(FObfusInt64& ObfusInt64, int64 NewValue)
{
	ObfusInt64.SetVal(NewValue);
}

// FLOAT
float UVarOBBPLib::GetFloat(FObfusFloat& ObfusFloat)
{
	return ObfusFloat.GetVal();
}

void UVarOBBPLib::SetFloat(FObfusFloat& ObfusFloat, float NewValue)
{
	ObfusFloat.SetVal(NewValue);
}

// TRANSFORM
FTransform UVarOBBPLib::GetTransform(FObfusTransform& ObfusTransform)
{
	return ObfusTransform.GetVal();
}

void UVarOBBPLib::SetTransform(FObfusTransform& ObfusTransform, FTransform NewValue)
{
	ObfusTransform.SetVal(NewValue);
}

// VECTOR
FVector UVarOBBPLib::GetVector(FObfusVector& ObfusVector)
{
	return ObfusVector.GetVal();
}

void UVarOBBPLib::SetVector(FObfusVector& ObfusVector, FVector NewValue)
{
	ObfusVector.SetVal(NewValue);
}

// VECTOR2D
FVector2D UVarOBBPLib::GetVector2D(FObfusVector2D& ObfusVector2D)
{
	return ObfusVector2D.GetVal();
}

void UVarOBBPLib::SetVector2D(FObfusVector2D& ObfusVector2D, FVector2D NewValue)
{
	ObfusVector2D.SetVal(NewValue);
}

// ROTATOR
FRotator UVarOBBPLib::GetRotator(FObfusRotator& ObfusRotator)
{
	return ObfusRotator.GetVal();
}

void UVarOBBPLib::SetRotator(FObfusRotator& ObfusRotator, FRotator NewValue)
{
	ObfusRotator.SetVal(NewValue);
}

// QUAT
FQuat UVarOBBPLib::GetQuat(FObfusQuat& ObfusQuat)
{
	return ObfusQuat.GetVal();
}

void UVarOBBPLib::SetQuat(FObfusQuat& ObfusQuat, FQuat NewValue)
{
	ObfusQuat.SetVal(NewValue);
}

// COLOR
FColor UVarOBBPLib::GetColor(FObfusColor& ObfusColor)
{
	return ObfusColor.GetVal();
}

void UVarOBBPLib::SetColor(FObfusColor& ObfusColor, FColor NewValue)
{
	ObfusColor.SetVal(NewValue);
}

// LINEARCOLOR
FLinearColor UVarOBBPLib::GetLinearColor(FObfusLinearColor& ObfusLinearColor)
{
	return ObfusLinearColor.GetVal();
}

void UVarOBBPLib::SetLinearColor(FObfusLinearColor& ObfusLinearColor, FLinearColor NewValue)
{
	ObfusLinearColor.SetVal(NewValue);
}

```

`Source/VariableObfuscator/Private/VarObDelegates.cpp`:

```cpp
#include "VarObDelegates.h"

FVarObDelegates::FOnVariableCheatDetected FVarObDelegates::OnVariableCheatDetected;
```

`Source/VariableObfuscator/Private/VariableObfuscator.cpp`:

```cpp
#include "Modules/ModuleInterface.h"

class FVariableObfuscator : public IModuleInterface
{};

IMPLEMENT_MODULE(FVariableObfuscator, VariableObfuscator)
```

`Source/VariableObfuscator/Public/BPTypes/ObfusBool.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "VarOb.h"
#include "VarObDoOnce.h"
#include "ObfusBool.generated.h"

USTRUCT(BlueprintType, Category = "Variable Obfuscator")
struct FObfusBool
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere)
	bool InitVal;

	bool GetVal()
	{
		DoOnce.Do([this]() { Val = InitVal; });
		return Val;
	}

	void SetVal(bool NewVal)
	{
		DoOnce.DoEmpty();
		Val = NewVal;
	}

	void ToArray(TArray<uint8>& OutData)
	{
		Val.ToArray(OutData);
	}

	void FromArray(const TArray<uint8>& InData)
	{
		Val.FromArray(InData);
	}

private:

	TVarOb<bool> Val;
	FVarObDoOnce DoOnce;
};

```

`Source/VariableObfuscator/Public/BPTypes/ObfusByte.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "VarOb.h"
#include "VarObDoOnce.h"
#include "ObfusByte.generated.h"

USTRUCT(BlueprintType, Category = "Variable Obfuscator")
struct FObfusByte
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere)
	uint8 InitVal;

	uint8 GetVal()
	{
		DoOnce.Do([this]() { Val = InitVal; });
		return Val;
	}

	void SetVal(uint8 NewVal)
	{
		DoOnce.DoEmpty();
		Val = NewVal;
	}

	void ToArray(TArray<uint8>& OutData)
	{
		Val.ToArray(OutData);
	}

	void FromArray(const TArray<uint8>& InData)
	{
		Val.FromArray(InData);
	}

private:

	TVarOb<uint8> Val;
	FVarObDoOnce DoOnce;
};

```

`Source/VariableObfuscator/Public/BPTypes/ObfusColor.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "VarOb.h"
#include "VarObDoOnce.h"
#include "ObfusColor.generated.h"

USTRUCT(BlueprintType, Category = "Variable Obfuscator")
struct FObfusColor
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere)
	FColor InitVal;

	FColor GetVal()
	{
		DoOnce.Do([this]() { Val = InitVal; });
		return Val;
	}

	void SetVal(FColor NewVal)
	{
		DoOnce.DoEmpty();
		Val = NewVal;
	}

	void ToArray(TArray<uint8>& OutData)
	{
		Val.ToArray(OutData);
	}

	void FromArray(const TArray<uint8>& InData)
	{
		Val.FromArray(InData);
	}

private:

	TVarOb<FColor> Val;
	FVarObDoOnce DoOnce;
};

```

`Source/VariableObfuscator/Public/BPTypes/ObfusFloat.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "VarOb.h"
#include "VarObDoOnce.h"
#include "ObfusFloat.generated.h"

USTRUCT(BlueprintType, Category = "Variable Obfuscator")
struct FObfusFloat
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere)
	float InitVal;

	float GetVal()
	{
		DoOnce.Do([this]() { Val = InitVal; });
		return Val;
	}

	void SetVal(float NewVal)
	{
		DoOnce.DoEmpty();
		Val = NewVal;
	}

	void ToArray(TArray<uint8>& OutData)
	{
		Val.ToArray(OutData);
	}

	void FromArray(const TArray<uint8>& InData)
	{
		Val.FromArray(InData);
	}

private:

	TVarOb<float> Val;
	FVarObDoOnce DoOnce;
};

```

`Source/VariableObfuscator/Public/BPTypes/ObfusInt32.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "VarOb.h"
#include "VarObDoOnce.h"
#include "ObfusInt32.generated.h"

USTRUCT(BlueprintType, Category = "Variable Obfuscator")
struct FObfusInt32
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere)
	int32 InitVal;

	int32 GetVal()
	{
		DoOnce.Do([this]() { Val = InitVal; });
		return Val;
	}

	void SetVal(int32 NewVal)
	{
		DoOnce.DoEmpty();
		Val = NewVal;
	}

	void ToArray(TArray<uint8>& OutData)
	{
		Val.ToArray(OutData);
	}

	void FromArray(const TArray<uint8>& InData)
	{
		Val.FromArray(InData);
	}

private:

	TVarOb<int32> Val;
	FVarObDoOnce DoOnce;
};

```

`Source/VariableObfuscator/Public/BPTypes/ObfusInt64.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "VarOb.h"
#include "VarObDoOnce.h"
#include "ObfusInt64.generated.h"

USTRUCT(BlueprintType, Category = "Variable Obfuscator")
struct FObfusInt64
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere)
	int64 InitVal;

	int64 GetVal()
	{
		DoOnce.Do([this]() { Val = InitVal; });
		return Val;
	}

	void SetVal(int64 NewVal)
	{
		DoOnce.DoEmpty();
		Val = NewVal;
	}

	void ToArray(TArray<uint8>& OutData)
	{
		Val.ToArray(OutData);
	}

	void FromArray(const TArray<uint8>& InData)
	{
		Val.FromArray(InData);
	}

private:

	TVarOb<int64> Val;
	FVarObDoOnce DoOnce;
};

```

`Source/VariableObfuscator/Public/BPTypes/ObfusLinearColor.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "VarOb.h"
#include "VarObDoOnce.h"
#include "ObfusLinearColor.generated.h"

USTRUCT(BlueprintType, Category = "Variable Obfuscator")
struct FObfusLinearColor
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere)
	FLinearColor InitVal;

	FLinearColor GetVal()
	{
		DoOnce.Do([this]() { Val = InitVal; });
		return Val;
	}

	void SetVal(FLinearColor NewVal)
	{
		DoOnce.DoEmpty();
		Val = NewVal;
	}

	void ToArray(TArray<uint8>& OutData)
	{
		Val.ToArray(OutData);
	}

	void FromArray(const TArray<uint8>& InData)
	{
		Val.FromArray(InData);
	}

private:

	TVarOb<FLinearColor> Val;
	FVarObDoOnce DoOnce;
};

```

`Source/VariableObfuscator/Public/BPTypes/ObfusQuat.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "VarOb.h"
#include "VarObDoOnce.h"
#include "ObfusQuat.generated.h"

USTRUCT(BlueprintType, Category = "Variable Obfuscator")
struct FObfusQuat
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere)
	FQuat InitVal;

	FQuat GetVal()
	{
		DoOnce.Do([this]() { Val = InitVal; });
		return Val;
	}

	void SetVal(FQuat NewVal)
	{
		DoOnce.DoEmpty();
		Val = NewVal;
	}

	void ToArray(TArray<uint8>& OutData)
	{
		Val.ToArray(OutData);
	}

	void FromArray(const TArray<uint8>& InData)
	{
		Val.FromArray(InData);
	}

private:

	TVarOb<FQuat> Val;
	FVarObDoOnce DoOnce;
};

```

`Source/VariableObfuscator/Public/BPTypes/ObfusRotator.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "VarOb.h"
#include "VarObDoOnce.h"
#include "ObfusRotator.generated.h"

USTRUCT(BlueprintType, Category = "Variable Obfuscator")
struct FObfusRotator
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere)
	FRotator InitVal;

	FRotator GetVal()
	{
		DoOnce.Do([this]() { Val = InitVal; });
		return Val;
	}

	void SetVal(FRotator NewVal)
	{
		DoOnce.DoEmpty();
		Val = NewVal;
	}

	void ToArray(TArray<uint8>& OutData)
	{
		Val.ToArray(OutData);
	}

	void FromArray(const TArray<uint8>& InData)
	{
		Val.FromArray(InData);
	}

private:

	TVarOb<FRotator> Val;
	FVarObDoOnce DoOnce;
};

```

`Source/VariableObfuscator/Public/BPTypes/ObfusTransform.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "VarOb.h"
#include "VarObDoOnce.h"
#include "ObfusTransform.generated.h"

USTRUCT(BlueprintType, Category = "Variable Obfuscator")
struct FObfusTransform
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere)
	FTransform InitVal;

	FTransform GetVal()
	{
		DoOnce.Do([this]() { Val = InitVal; });
		return Val;
	}

	void SetVal(FTransform NewVal)
	{
		DoOnce.DoEmpty();
		Val = NewVal;
	}

	void ToArray(TArray<uint8>& OutData)
	{
		Val.ToArray(OutData);
	}

	void FromArray(const TArray<uint8>& InData)
	{
		Val.FromArray(InData);
	}

private:

	TVarOb<FTransform> Val;
	FVarObDoOnce DoOnce;
};

```

`Source/VariableObfuscator/Public/BPTypes/ObfusVector.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "VarOb.h"
#include "VarObDoOnce.h"
#include "ObfusVector.generated.h"

USTRUCT(BlueprintType, Category = "Variable Obfuscator")
struct FObfusVector
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere)
	FVector InitVal;

	FVector GetVal()
	{
		DoOnce.Do([this]() { Val = InitVal; });
		return Val;
	}

	void SetVal(FVector NewVal)
	{
		DoOnce.DoEmpty();
		Val = NewVal;
	}

	void ToArray(TArray<uint8>& OutData)
	{
		Val.ToArray(OutData);
	}

	void FromArray(const TArray<uint8>& InData)
	{
		Val.FromArray(InData);
	}

private:

	TVarOb<FVector> Val;
	FVarObDoOnce DoOnce;
};

```

`Source/VariableObfuscator/Public/BPTypes/ObfusVector2D.h`:

```h
#pragma once

#include "CoreMinimal.h"
#include "VarOb.h"
#include "VarObDoOnce.h"
#include "ObfusVector2D.generated.h"

USTRUCT(BlueprintType, Category = "Variable Obfuscator")
struct FObfusVector2D
{
	GENERATED_BODY()

public:

	UPROPERTY(EditAnywhere)
	FVector2D InitVal;

	FVector2D GetVal()
	{
		DoOnce.Do([this]() { Val = InitVal; });
		return Val;
	}

	void SetVal(FVector2D NewVal)
	{
		DoOnce.DoEmpty();
		Val = NewVal;
	}

	void ToArray(TArray<uint8>& OutData)
	{
		Val.ToArray(OutData);
	}

	void FromArray(const TArray<uint8>& InData)
	{
		Val.FromArray(InData);
	}

private:

	TVarOb<FVector2D> Val;
	FVarObDoOnce DoOnce;
};

```

`Source/VariableObfuscator/Public/VarOb.h`:

```h
#pragma once

/**
 * This is the core of the obfuscator. 
 * To obfuscate a static data declare it as in example: TVarOb<int32>.
 */

#include "CoreMinimal.h"
#include "VarObChunk.h"
#include "VarObDelegates.h"
#include "VarObSupportedTypes.h"

#define VO_VAL 0
#define VO_KEY 1
#define VO_CHK 2

template<typename T>
class TVarOb
{
    using FChunkX = FChunkN<(sizeof(T)-1)/4+1>;

private:

    FChunkX Data[3] = {};

    inline void MemMangle()
    {
        if (uint8* DataPtr = reinterpret_cast<uint8*>(Data))
        {
            for (uint8 I = 0; I < sizeof(FChunkX) * 3; I += 3)
            {
                uint8 Tmp = DataPtr[I];
                DataPtr[I] = DataPtr[I + 2];
                DataPtr[I + 2] = Tmp;
            }
        }
    }

    inline void Check(bool bCondition)
    {
        if (bCondition == false)
        {
            FVarObDelegates::OnVariableCheatDetected.Broadcast();
        }
    }

public:

    TVarOb(T V = T())
    {
        static_assert(TVarObSupportedType<T>::Value, "Unsupported Type");

        Data[VO_KEY].GenRand();
        Data[VO_VAL] = *(FChunkX*)&V;
        Data[VO_CHK] = (Data[VO_VAL] ^ VO_MASK);

        Data[VO_VAL] ^= Data[VO_KEY];
        MemMangle();
    }

    TVarOb(TVarOb& V)
    {
        FMemory::Memcpy(Data, V.Data, sizeof(FChunkX) * 3);
    }

    TVarOb& operator=(T& V)
    {
        static_assert(TVarObSupportedType<T>::Value, "Unsupported Type");

        Data[VO_KEY].GenRand();
        Data[VO_VAL] = *(FChunkX*)&V;
        Data[VO_CHK] = (Data[VO_VAL] ^ VO_MASK);

        Data[VO_VAL] ^= Data[VO_KEY];
        MemMangle();

        return *this;
    }

    operator T()
    {
        MemMangle();
        FChunkX Tmp = Data[VO_VAL] ^ Data[VO_KEY];
        Check(Tmp == (Data[VO_CHK] ^ VO_MASK));
        MemMangle();
        return *(T*)&Tmp;
    }

    void ToArray(TArray<uint8>& OutData)
    {
        OutData.SetNum(sizeof(FChunkX) * 3);
        FMemory::Memcpy(OutData.GetData(), Data, sizeof(FChunkX) * 3);
    }

    void FromArray(const TArray<uint8>& InData)
    {
        checkf(InData.Num() == sizeof(FChunkX) * 3, TEXT("Bad size of imported array (expected %i bytes but received %i bytes"), sizeof(FChunkX) * 3, InData.Num());
        FMemory::Memcpy(Data, InData.GetData(), sizeof(FChunkX) * 3);
    }

#define VO_BINARY_OP(_op)   TVarOb& operator _op (const T& Rhs)                         \
                            {                                                           \
                                MemMangle();                                            \
                                FChunkX Tmp = Data[VO_VAL] ^ Data[VO_KEY];              \
                                Check(Tmp == (Data[VO_CHK] ^ VO_MASK));                 \
                                T Res = *(T*)&Tmp;                                      \
                                Res _op Rhs;                                            \
                                Data[VO_KEY].GenRand();                                 \
                                Data[VO_VAL] = *(FChunkX*)&Res;                         \
                                Data[VO_CHK] = (Data[VO_VAL] ^ VO_MASK);                \
                                Data[VO_VAL] ^= Data[VO_KEY];                           \
                                MemMangle();                                            \
                                return *this;                                           \
                            }                                                           \

#define VO_UNARY_OP(_op)    TVarOb& operator _op ()                                     \
                            {                                                           \
                                MemMangle();                                            \
                                FChunkX Tmp = Data[VO_VAL] ^ Data[VO_KEY];              \
                                Check(Tmp == (Data[VO_CHK] ^ VO_MASK));                 \
                                T V = *(T*)&Tmp;                                        \
                                v _op;                                                  \
                                Data[VO_KEY].GenRand();                                 \
                                Data[VO_VAL] = *(FChunkX*)&V;                           \
                                Data[VO_CHK] = (Data[VO_VAL] ^ VO_MASK);                \
                                Data[VO_VAL] ^= Data[VO_KEY];                           \
                                MemMangle();                                            \
                                return *this;                                           \
                            }                                                           \
                            TVarOb operator _op (int)                                   \
                            {                                                           \
                                TVarOb Tmp(*this);                                      \
                                operator _op();                                         \
                                return Tmp;                                             \
                            }                                                           \

    VO_BINARY_OP(*=)
    VO_BINARY_OP(/=)
    VO_BINARY_OP(%=)
    VO_BINARY_OP(-=)
    VO_BINARY_OP(+=)
    VO_BINARY_OP(^=)
    VO_BINARY_OP(<<)
    VO_BINARY_OP(>>)

    VO_UNARY_OP(++)
    VO_UNARY_OP(--)
};

```

`Source/VariableObfuscator/Public/VarObBPLib.h`:

```h
#pragma once

/**
 * This is a BP library to somehow handle obfuscation in BP.
 */

#include "CoreMinimal.h"
#include "Kismet/BlueprintFunctionLibrary.h"

#include "BPTypes/ObfusBool.h"
#include "BPTypes/ObfusByte.h"
#include "BPTypes/ObfusInt32.h"
#include "BPTypes/ObfusInt64.h"
#include "BPTypes/ObfusFloat.h"

#include "BPTypes/ObfusTransform.h"
#include "BPTypes/ObfusVector.h"
#include "BPTypes/ObfusVector2D.h"
#include "BPTypes/ObfusRotator.h"
#include "BPTypes/ObfusQuat.h"

#include "BPTypes/ObfusColor.h"
#include "BPTypes/ObfusLinearColor.h"

#include "VarObBPLib.generated.h"

UCLASS()
class VARIABLEOBFUSCATOR_API UVarOBBPLib : public UBlueprintFunctionLibrary 
{
	GENERATED_BODY()

public:

	// BOOL
	UFUNCTION(BlueprintPure, Category = "Variable Obfuscator")
	static bool GetBool(UPARAM(Ref) FObfusBool& ObfusBool);

	UFUNCTION(BlueprintCallable, Category = "Variable Obfuscator")
	static void SetBool(UPARAM(Ref) FObfusBool& ObfusBool, bool NewValue);

	// BYTE
	UFUNCTION(BlueprintPure, Category = "Variable Obfuscator")
	static uint8 GetByte(UPARAM(Ref) FObfusByte& ObfusByte);

	UFUNCTION(BlueprintCallable, Category = "Variable Obfuscator")
	static void SetByte(UPARAM(Ref) FObfusByte& ObfusByte, uint8 NewValue);

	// INT32
	UFUNCTION(BlueprintPure, Category = "Variable Obfuscator")
	static int32 GetInt32(UPARAM(Ref) FObfusInt32& ObfusInt32);

	UFUNCTION(BlueprintCallable, Category = "Variable Obfuscator")
	static void SetInt32(UPARAM(Ref) FObfusInt32& ObfusInt32, int32 NewValue);

	// INT64
	UFUNCTION(BlueprintPure, Category = "Variable Obfuscator")
	static int64 GetInt64(UPARAM(Ref) FObfusInt64& ObfusInt64);

	UFUNCTION(BlueprintCallable, Category = "Variable Obfuscator")
	static void SetInt64(UPARAM(Ref) FObfusInt64& ObfusInt64, int64 NewValue);

	// FLOAT
	UFUNCTION(BlueprintPure, Category = "Variable Obfuscator")
	static float GetFloat(UPARAM(Ref) FObfusFloat& ObfusFloat);

	UFUNCTION(BlueprintCallable, Category = "Variable Obfuscator")
	static void SetFloat(UPARAM(Ref) FObfusFloat& ObfusFloat, float NewValue);

	// TRANSFORM
	UFUNCTION(BlueprintPure, Category = "Variable Obfuscator")
	static FTransform GetTransform(UPARAM(Ref) FObfusTransform& ObfusTransform);

	UFUNCTION(BlueprintCallable, Category = "Variable Obfuscator")
	static void SetTransform(UPARAM(Ref) FObfusTransform& ObfusTransform, FTransform NewValue);

	// VECTOR
	UFUNCTION(BlueprintPure, Category = "Variable Obfuscator")
	static FVector GetVector(UPARAM(Ref) FObfusVector& ObfusVector);

	UFUNCTION(BlueprintCallable, Category = "Variable Obfuscator")
	static void SetVector(UPARAM(Ref) FObfusVector& ObfusVector, FVector NewValue);

	// VECTOR2D
	UFUNCTION(BlueprintPure, Category = "Variable Obfuscator")
	static FVector2D GetVector2D(UPARAM(Ref) FObfusVector2D& ObfusVector2D);

	UFUNCTION(BlueprintCallable, Category = "Variable Obfuscator")
	static void SetVector2D(UPARAM(Ref) FObfusVector2D& ObfusVector2D, FVector2D NewValue);

	// ROTATOR
	UFUNCTION(BlueprintPure, Category = "Variable Obfuscator")
	static FRotator GetRotator(UPARAM(Ref) FObfusRotator& ObfusRotator);

	UFUNCTION(BlueprintCallable, Category = "Variable Obfuscator")
	static void SetRotator(UPARAM(Ref) FObfusRotator& ObfusRotator, FRotator NewValue);

	// QUAT
	UFUNCTION(BlueprintPure, Category = "Variable Obfuscator")
	static FQuat GetQuat(UPARAM(Ref) FObfusQuat& ObfusQuat);

	UFUNCTION(BlueprintCallable, Category = "Variable Obfuscator")
	static void SetQuat(UPARAM(Ref) FObfusQuat& ObfusQuat, FQuat NewValue);

	// COLOR
	UFUNCTION(BlueprintPure, Category = "Variable Obfuscator")
	static FColor GetColor(UPARAM(Ref) FObfusColor& ObfusColor);

	UFUNCTION(BlueprintCallable, Category = "Variable Obfuscator")
	static void SetColor(UPARAM(Ref) FObfusColor& ObfusColor, FColor NewValue);

	// LINEARCOLOR
	UFUNCTION(BlueprintPure, Category = "Variable Obfuscator")
	static FLinearColor GetLinearColor(UPARAM(Ref) FObfusLinearColor& ObfusLinearColor);

	UFUNCTION(BlueprintCallable, Category = "Variable Obfuscator")
	static void SetLinearColor(UPARAM(Ref) FObfusLinearColor& ObfusLinearColor, FLinearColor NewValue);
};
```

`Source/VariableObfuscator/Public/VarObChunk.h`:

```h
#pragma once

/**
 * This struct defines a chunk of data that will be obfuscated later.
 * N is a size of a chunk. 
 * Chunk of size 1 is a 4 bytes chunk, chunk of size 2 is a 8 bytes chunk etc. 
 */

#include "CoreMinimal.h"

template<int N>
struct FChunkN
{
    uint32 Data[N];

    FChunkN<N> operator^(const FChunkN<N>& Rhs)
    {
        FChunkN<N> Tmp;
        for (int32 I = 0; I < N; I++)
        {
            Tmp.Data[I] = Data[I] ^ Rhs.Data[I];
        }
        return Tmp;
    }

    FChunkN<N> operator^(const int32& Rhs)
    {
        FChunkN<N> Tmp;
        for (int32 I = 0; I < N; I++)
        {
            Tmp.Data[I] = Data[I] ^ Rhs;
        }
        return Tmp;
    }

    FChunkN<N>& operator^=(const FChunkN<N>& Rhs)
    {
        for (int32 I = 0; I < N; I++)
        {
            Data[I] ^= Rhs.Data[I];
        }
        return *this;
    }

    bool operator==(const FChunkN<N>& Rhs)
    {
        for (int32 I = 0; I < N; I++)
        {
            if (Data[I] != Rhs.Data[I])
            {
                return false;
            }
        }
        return true;
    }

    void GenRand()
    {
        for (int32 I = 0; I < N; I++)
        {
            Data[I] = static_cast<uint32>(FMath::RandHelper(0x7fff));
        }
    }
};

```

`Source/VariableObfuscator/Public/VarObDelegates.h`:

```h
#pragma once

/**
 * This is a delegate which will broadcast warning about possible
 * memory breach. 
 */

#include "CoreMinimal.h"

class VARIABLEOBFUSCATOR_API FVarObDelegates
{

public:

	DECLARE_MULTICAST_DELEGATE(FOnVariableCheatDetected);
	static FOnVariableCheatDetected OnVariableCheatDetected;
};
```

`Source/VariableObfuscator/Public/VarObDoOnce.h`:

```h
#pragma once

/**
 * Small, helper struct to ensue the function will perform only once.
 */

#include "CoreMinimal.h"

class FVarObDoOnce
{

public:

	void Do(const TFunction<void()>& Action)
	{
		if (bDone == false)
		{
			bDone = true;
			Action();
		}
	}

	void DoEmpty()
	{
		bDone = true;
	}

private:

	bool bDone = false;
};
```

`Source/VariableObfuscator/Public/VarObSupportedTypes.h`:

```h
#pragma once

/**
 * These are traits that defines all of the supported types that can be obfuscated.
 * This obfuscator should work with any kind of static data but just to be safe
 * we define here well tested types. This list can be expanded by the end user.
 */

#include "CoreMinimal.h"

// By default we accept any arithmetic value
template<typename T> struct TVarObSupportedType { enum { Value = TIsArithmetic<T>::Value }; };

// And any other simple structure
template<> struct TVarObSupportedType<FTransform> { enum { Value = true }; };
template<> struct TVarObSupportedType<FVector> { enum { Value = true }; };
template<> struct TVarObSupportedType<FVector2D> { enum { Value = true }; };
template<> struct TVarObSupportedType<FRotator> { enum { Value = true }; };
template<> struct TVarObSupportedType<FQuat> { enum { Value = true }; };
template<> struct TVarObSupportedType<FColor> { enum { Value = true }; };
template<> struct TVarObSupportedType<FLinearColor> { enum { Value = true }; };
```

`Source/VariableObfuscator/VariableObfuscator.Build.cs`:

```cs
// Copyright Epic Games, Inc. All Rights Reserved.

using UnrealBuildTool;

public class VariableObfuscator : ModuleRules
{
	public VariableObfuscator(ReadOnlyTargetRules Target) : base(Target)
	{
		PCHUsage = ModuleRules.PCHUsageMode.UseExplicitOrSharedPCHs;

		PublicDependencyModuleNames.AddRange(
			new string[]
			{
				"Core"
			}
		);
			
		PrivateDependencyModuleNames.AddRange(
			new string[]
			{
				"CoreUObject",
				"Engine"
			}
		);

		PublicDefinitions.Add("VO_MASK=1254321586");
	}
}

```

`TODO.txt`:

```txt
* Optimize some of the functions with passing by const ref
* Better comments
* Provide some tutorial materials

```

`VariableObfuscator.uplugin`:

```uplugin
{
	"FileVersion": 3,
	"Version": 1,
	"VersionName": "1.0",
	"FriendlyName": "Variable Obfuscator",
	"Description": "",
	"Category": "Other",
	"CreatedBy": "Damian Nowakowski",
	"CreatedByURL": "",
	"DocsURL": "",
	"MarketplaceURL": "",
	"SupportURL": "",
	"CanContainContent": true,
	"IsBetaVersion": false,
	"IsExperimentalVersion": false,
	"Installed": false,
	"Modules": [
		{
			"Name": "VariableObfuscator",
			"Type": "Runtime",
			"LoadingPhase": "Default"
		}
	]
}
```