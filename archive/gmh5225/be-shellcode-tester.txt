Project Path: arc_gmh5225_be-shellcode-tester_cor8j2_t

Source Tree:

```txt
arc_gmh5225_be-shellcode-tester_cor8j2_t
├── be-shellcode-tester
│   ├── battleye
│   │   ├── battleye.hpp
│   │   ├── handlers
│   │   │   ├── beclient_encrypted.cpp
│   │   │   ├── driver_presence.cpp
│   │   │   ├── encrypted.cpp
│   │   │   ├── general_info.cpp
│   │   │   ├── memory_anomaly.cpp
│   │   │   ├── memory_region.cpp
│   │   │   ├── memory_signature.cpp
│   │   │   ├── mono_assets.cpp
│   │   │   ├── veh.cpp
│   │   │   └── window_title.cpp
│   │   ├── reports.cpp
│   │   ├── reports.hpp
│   │   └── resources
│   │       └── beclient_x64.hpp
│   ├── be-shellcode-tester.vcxproj
│   ├── be-shellcode-tester.vcxproj.filters
│   ├── be-shellcode-tester.vcxproj.user
│   ├── bootstrap
│   │   ├── bootstrap.cpp
│   │   └── bootstrap.hpp
│   ├── entry.cpp
│   ├── hooks
│   │   ├── battleye
│   │   │   └── send_report.cpp
│   │   ├── hooks.hpp
│   │   └── winapi
│   │       ├── GetModuleHandle.cpp
│   │       ├── GetProcAddress.cpp
│   │       ├── IsBadReadPtr.cpp
│   │       ├── LoadLibraryA.cpp
│   │       └── WideCharToMultiByte.cpp
│   ├── loader
│   │   ├── loader.cpp
│   │   └── loader.hpp
│   └── util
│       ├── io
│       │   ├── io.cpp
│       │   └── io.hpp
│       ├── logger.hpp
│       ├── mem
│       │   ├── mem.cpp
│       │   └── mem.hpp
│       ├── pe
│       │   ├── pe.cpp
│       │   └── pe.hpp
│       ├── util.cpp
│       └── util.hpp
├── be-shellcode-tester.sln
└── readme.md

```

`be-shellcode-tester.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.31515.178
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "be-shellcode-tester", "be-shellcode-tester\be-shellcode-tester.vcxproj", "{D867B1EA-3C81-4EC2-A081-C3015D944B75}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug [dll]|x64 = Debug [dll]|x64
		Debug [dll]|x86 = Debug [dll]|x86
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release [dll]|x64 = Release [dll]|x64
		Release [dll]|x86 = Release [dll]|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Debug [dll]|x64.ActiveCfg = Debug [dll]|x64
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Debug [dll]|x64.Build.0 = Debug [dll]|x64
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Debug [dll]|x86.ActiveCfg = Debug [dll]|Win32
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Debug [dll]|x86.Build.0 = Debug [dll]|Win32
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Debug|x64.ActiveCfg = Debug|x64
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Debug|x64.Build.0 = Debug|x64
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Debug|x86.ActiveCfg = Debug|Win32
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Debug|x86.Build.0 = Debug|Win32
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Release [dll]|x64.ActiveCfg = Release [dll]|x64
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Release [dll]|x64.Build.0 = Release [dll]|x64
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Release [dll]|x86.ActiveCfg = Release [dll]|Win32
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Release [dll]|x86.Build.0 = Release [dll]|Win32
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Release|x64.ActiveCfg = Release|x64
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Release|x64.Build.0 = Release|x64
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Release|x86.ActiveCfg = Release|Win32
		{D867B1EA-3C81-4EC2-A081-C3015D944B75}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {39E3FD5C-18F1-4A9E-81DA-97DDD2DA0261}
	EndGlobalSection
EndGlobal

```

`be-shellcode-tester/battleye/battleye.hpp`:

```hpp
#pragma once
#include "resources/beclient_x64.hpp"

#include <unordered_map>
#include <string>


namespace battleye { 
	namespace typedefs {
		using shellcode_startup_t = void( * )( uintptr_t a1 /* it should be base addr but idk */, void* send_report_fn, void* get_module_handle_fn, void* get_proc_address_fn, void* a5 /* unknown :shrug: */ );
	};

	namespace enums {
		enum class e_report_id : uint8_t {
			REPORT_UNKNOWN = 0x0,
			REPORT_ENCRYPTED = 0x4B,
			REPORT_GENERAL_INFO = 0x3C,
			REPORT_VEH = 0x31,
			REPORT_MEMORY_ANOMALY = 0x2F,
			REPORT_WINDOW_TITLE = 0x33,
			REPORT_MEMORY_SIGNATURE = 0x35,
			REPORT_DRIVER_PRESENCE_BEEP = 0x3E,
			REPORT_DRIVER_PRESENCE_NULL = 0x3F,
			REPORT_MEMORY_REGION = 0x21,
			REPORT_BECLIENT_ENCRYPTED = 0x39,
			REPORT_MONO_ASSETS = 0x49
		};

		inline const char* report_id_to_string( e_report_id id ) {
			switch ( id ) {
				case e_report_id::REPORT_BECLIENT_ENCRYPTED:
				case e_report_id::REPORT_ENCRYPTED:
					return "ENCRYPTED";
				case e_report_id::REPORT_GENERAL_INFO:
					return "GENERAL_INFO";
				case e_report_id::REPORT_VEH:
					return "VEH";
				case e_report_id::REPORT_MEMORY_ANOMALY:
					return "MEMORY_ANOMALY";
				case e_report_id::REPORT_WINDOW_TITLE:
					return "WINDOW_TITLE";
				case e_report_id::REPORT_MEMORY_SIGNATURE:
					return "MEMORY_SIGNATURE";
				case e_report_id::REPORT_DRIVER_PRESENCE_NULL:
				case e_report_id::REPORT_DRIVER_PRESENCE_BEEP:
					return "DRIVER_PRESENCE";
				case e_report_id::REPORT_MEMORY_REGION:
					return "MEMORY_REGION";
				case e_report_id::REPORT_MONO_ASSETS:
					return "MONO_ASSETS";
				default:
					return "UNKNOWN";
			}
		}
	};

	inline std::unordered_map<std::string, unsigned char*> resources_list = {
		{ "BEClient_x64.dll", resources::beclient_x64 }
	};
}

```

`be-shellcode-tester/battleye/handlers/beclient_encrypted.cpp`:

```cpp
#include "battleye/reports.hpp"


namespace battleye::reports::handlers {
	void beclient_encrypted( battleye::enums::e_report_id id, util::io::reader_t& reader ) {
		util::hexdump( "", reader.get_buffer( ), reader.get_size( ) );
		reader.skip( reader.get_size( ) );

		// @todo: @es3n1n: decryption
		/*
		snippet from beclient:

		LABEL_53:
		LOWORD(_EAX) = v236 ^ inputParam ^ 0x5979;
		encryption_key = v236 ^ inputParam ^ 0x378E5979;
LABEL_90:
		for ( m = 2; m < 505; ++m )
		{
		  *(int *)((char *)v230 + m) ^= encryption_key;
		  _CL = m % 32;
		  if ( ((encryption_key >> _CL) & 1) != 0 )
		  {
			__asm { rcr     cl, 3 }
			encryption_key *= ~encryption_key;
		  }
LABEL_117:
		  v115 = (*((_BYTE *)&encryption_key + m % 4) & 3) + 4;
		  _ECX = 512 - v115;
		  _EAX = v115 & ~(1 << (char)v113);
		  LOWORD(_EAX) = __ROL2__(_EAX, 2);
		  __asm { rcl     eax, cl }
		  v142 = m == _ECX;
		  if ( m < _ECX )
		  {
			LOWORD(_ECX) = __ROR2__(_ECX + 1, _ECX + 1);
			__asm { rcr     ecx, 9 }
			LOWORD(_ECX) = _ECX ^ 0x8F07;
			LOBYTE(_ECX) = BYTE1(v111) | _ECX;
			_ECX = -_ECX;
			LOBYTE(_ECX) = BYTE1(v111) | _ECX;
			BYTE1(_ECX) = -BYTE1(_ECX);
			LOWORD(_ECX) = v112 | _ECX;
			BYTE1(_ECX) <<= 6;
			v23 = m % 4;
LABEL_94:
			__asm { rcr     ch, cl }
			v24 = *((_BYTE *)&encryption_key + v23) & 3;
			v142 = v24 + m == 0;
			LOBYTE(_ECX) = v24 + m;
			m += v24;
		  }
		  while ( !v142 )
		  {
			_EAX = ++m;
			if ( _EAX >= 505 )
			  goto LABEL_324;
			_DH = 117;
			__asm { rcl     dh, 2 }
			*(int *)((char *)v230 + _EAX) ^= encryption_key;
			_RDX = (_EAX >> 31) & 0x1F;
			_CL = -57;
			__asm { rcr     cl, 4 }
			if ( !((encryption_key >> (_EAX % 32)) & 1) )
			  goto LABEL_117;
			__asm { rcr     rdx, 2Bh }
			encryption_key *= ~encryption_key;
			_ECX = 512 - ((*((_BYTE *)&encryption_key + m % 4) & 3) + 4);
			v142 = m == _ECX;
			if ( m < _ECX )
			{
			  v23 = m % 4;
			  goto LABEL_94;
			}
		  }
		  LOWORD(_EAX) = m + 1;
		}
		*/
	}
}

```

`be-shellcode-tester/battleye/handlers/driver_presence.cpp`:

```cpp
#include "battleye/reports.hpp"


namespace battleye::reports::handlers {
	void driver_presence( battleye::enums::e_report_id id, util::io::reader_t& reader ) {
		util::logger::info( "\tDriver: %s", id == enums::e_report_id::REPORT_DRIVER_PRESENCE_BEEP ? "\\\\.\\Beep" : "\\\\.\\Null" );
	}
}

```

`be-shellcode-tester/battleye/handlers/encrypted.cpp`:

```cpp
#include "battleye/reports.hpp"


namespace battleye::reports::handlers {
	void encrypted( battleye::enums::e_report_id id, util::io::reader_t& reader ) {
		// @note: user344: This decryption is really bad coded, but it works
		// and i dont want to spend any more time on it so shall it stay.
		auto v90 = ( uint8_t )reader.read<uint32_t>( );
		for ( auto i = reader.get_start_size( ) - 1; i >= 5; --i ) {
			auto v408 = i != 0 ? *( uint8_t* )( reader.get_start_buffer( ) + i - 1 ) : v90;
			*( uint8_t* )( reader.get_start_buffer( ) + i ) ^= v408;
		}

		// @note: user344: Since our decryption is not proper and we dont decrypt last byte
		// we cant do a proper "if (report_size == 0xFFFF) break;" check inside loop
		// thus im forced to do this ugly "while (bf.get_size() > 2)" check for now.
		// CHANGE WHEN DECRYPTION IS FIXED!!!
		int iteration = 0;
		while ( reader.get_size( ) > 4 ) {
			const auto report_size = reader.read<uint16_t>( );
			if ( ( iteration > 0 && report_size > reader.get_size( ) ) || !report_size ) // @note: es3n1n: otherwise it will fail cz of inproper decryption
				continue;

			battleye::reports::execute_handler( reader.get_buffer( ), report_size );

			reader.skip( report_size );
			iteration += 1;
		}

		// @note: user344: skip remaining bytes due to improper decryption
		reader.skip( reader.get_size( ) );
	}
}

```

`be-shellcode-tester/battleye/handlers/general_info.cpp`:

```cpp
#include "battleye/reports.hpp"


namespace battleye::reports::handlers {
	void general_info( battleye::enums::e_report_id id, util::io::reader_t& reader ) {
		char buffer[ 256 ] = { '\0' };

		util::logger::info( "\twindows:" );

		auto windows_end = reader.read<uint16_t>( ) + reader.get_buffer( );
		while ( reader.get_buffer( ) < windows_end ) {
			auto window_title_len = reader.read<uint8_t>( );
			if ( window_title_len ) {
				reader.read_to( buffer, window_title_len );
				buffer[ window_title_len ] = '\0';
				util::logger::info( "\t\ttitle: %s", buffer );
			}

			auto window_class_len = reader.read<uint8_t>( );
			if ( window_class_len ) {
				reader.read_to( buffer, window_class_len );
				buffer[ window_class_len ] = '\0';
				util::logger::info( "\t\tclass: %s", buffer );
			}

			auto window_path_len = reader.read<uint8_t>( );
			if ( window_path_len ) {
				reader.read_to( buffer, window_path_len );
				buffer[ window_path_len ] = '\0';
				util::logger::info( "\t\tpath: %s", buffer );
			}

			util::logger::info( "\t\tfile_size: %d", reader.read<uint32_t>( ) );
			util::logger::info( "\t\twindow_style: %x", reader.read<uint32_t>( ) );
			util::logger::info( "\t\twindow_ex_style: %x", reader.read<uint32_t>( ) );

			auto window_rect = reader.read<RECT>( );
			util::logger::info( "\t\twindow_rect.left: %d", window_rect.left );
			util::logger::info( "\t\twindow_rect.top: %d", window_rect.top );
			util::logger::info( "\t\twindow_rect.right: %d", window_rect.right );
			util::logger::info( "\t\twindow_rect.bottom: %d", window_rect.bottom );
			util::logger::info( "\t\t================================" );
		}

		util::logger::info( "\thandles:" );
		auto handles_end = reader.read<uint16_t>( ) + reader.get_buffer( );
		while (reader.get_buffer() < handles_end) {
			auto len = reader.read<uint8_t>( );
			if ( len ) {
				reader.read_to( buffer, len );
				buffer[ len ] = '\0';
				util::logger::info( "\t\tpath: %s", buffer );
			}
			util::logger::info( "\t\tfile_size: %d", reader.read<uint32_t>( ) );
			util::logger::info( "\t\taccess_mask: %x", reader.read<uint32_t>( ) );
			util::logger::info( "\t\t================================" );
		}

		// @fixme: unknown zeroes?
		reader.skip( sizeof( uint32_t ) * 4 );
		
		uint64_t hooked_addr = reader.read<uint64_t>( );
		if ( hooked_addr ) {
			//util::logger::info("\thooked function:\n");
			//util::logger::info("\t\taddress: %p\n", hooked_addr);
			reader.skip( sizeof( uint64_t ) * 3 );
		}

		util::logger::info( "\tsystem:" );
		util::logger::info( "\t\tstartup_time: %d", reader.read<uint32_t>( ) );

		util::logger::info( "\tbootmgfw.efi:" );
		util::logger::info( "\t\tcreated_at: %d", reader.read<uint32_t>( ) );
		util::logger::info( "\t\tlast_access_time: %d", reader.read<uint32_t>( ) );
		util::logger::info( "\t\tlast_write_time: %d", reader.read<uint32_t>( ) );
		util::logger::info( "\t\tchange_time: %d", reader.read<uint32_t>( ) );
		util::logger::info( "\t\tfile_attributes: %d", reader.read<uint32_t>( ) );
	}
}

```

`be-shellcode-tester/battleye/handlers/memory_anomaly.cpp`:

```cpp
#include "battleye/reports.hpp"


namespace battleye::reports::handlers {
	void memory_anomaly( battleye::enums::e_report_id id, util::io::reader_t& reader ) {
		util::logger::info( "\tbase_address: 0x%p", reader.read<uint64_t>( ) );
		util::logger::info( "\tregion_size: 0x%x", reader.read<uint32_t>( ) );
		util::logger::info( "\tmemory_info: %x", reader.read<uint32_t>( ) );
	}
}

```

`be-shellcode-tester/battleye/handlers/memory_region.cpp`:

```cpp
#include "battleye/reports.hpp"


namespace battleye::reports::handlers {
	void memory_region( battleye::enums::e_report_id id, util::io::reader_t& reader ) {
		util::logger::info( "\tunk_mem_type: %d", reader.read<uint8_t>( ) );
		util::logger::info( "\tbase_addr: 0x%p", reader.read<uint64_t>( ) );
		util::logger::info( "\tregion_size: 0x%x", reader.read<uint32_t>( ) );
		util::logger::info( "\tregion_flags: %x", reader.read<uint32_t>( ) );

		//size_t sz = reader.get_size( );
		//uint8_t* dump = ( uint8_t* )( malloc( sz ) );
		//reader.read_to( dump, sz );
		//util::logger::info( "\thexdump:" );
		//util::hexdump( "\t\t", dump, sz );
		//free( dump );
		reader.skip( reader.get_size( ) );
	}
}

```

`be-shellcode-tester/battleye/handlers/memory_signature.cpp`:

```cpp
#include "battleye/reports.hpp"


namespace battleye::reports::handlers {
	void memory_signature( battleye::enums::e_report_id id, util::io::reader_t& reader ) {
		const auto type = reader.read<uint16_t>( );
		const auto data = reader.read<uint64_t>( );
		const auto base_address = reader.read<uint64_t>( );
		const auto region_size = reader.read<uint32_t>( );
		const auto memory_info = reader.read<uint32_t>( );
		const auto len = strnlen( ( char* )data, 256 );

		util::logger::info( "\ttype: %hx", type );
		util::logger::info( "\tdata: 0x%p", data );
		util::logger::info( "\tbase_address: 0x%p", base_address );
		util::logger::info( "\tregion_size: 0x%x", region_size );
		util::logger::info( "\tmemory_info: %x", memory_info );
		util::logger::info( "\thexdump:" );
		util::hexdump( "\t\t", reinterpret_cast< void* >( data ), ( len != 0 && len != 256 ) ? len : 10 );
	}
}

```

`be-shellcode-tester/battleye/handlers/mono_assets.cpp`:

```cpp
#include "battleye/reports.hpp"


namespace battleye::reports::handlers {
	void mono_assets( battleye::enums::e_report_id id, util::io::reader_t& reader ) {
		util::logger::info( "\tassets:" );

		while ( reader.get_size( ) > 1 ) {
			char buf[ 256 ];

			// @note: es3n1n:
			//**buffer_ptr = strlen;
			//for ( off = 0; off < **buffer_ptr; ++off )
			//	( *buffer_ptr )[ off + 1 ] = *( ( _BYTE* )file_name + 2 * off );// write file name to buffer
			auto len = reader.read<uint8_t>( );
			reader.read_to( buf, len );
			buf[ len ] = '\0';
			util::logger::info( "\tname: %s", buf );

			// @note: es3n1n: 
			// if ( getfileattributesexw(full_path, 0i64, v27) )
			//		*( _DWORD* )*buffer_ptr = v28;       // write attributes
			auto file_attributes = reader.read<uint32_t>( );
			util::logger::info( "\t\tfile_attributes: 0x%x", file_attributes );

			// @note: es3n1n:
			// *((_DWORD *)*buffer_ptr + 1) = 0;
			// memset( read_buf, 0, sizeof( read_buf ) );
			// while ( readfile( v26, read_buf, 256i64, &v25, 0i64 ) && v25 )
			//		*( ( _DWORD* )*buffer_ptr + 1 ) += read_buf[ 3 ] + read_buf[ 2 ] + read_buf[ 1 ] + read_buf[ 0 ];
			auto checksum = reader.read<uint32_t>( );
			util::logger::info( "\t\tchecksum: 0x%x", checksum );

			util::logger::info( "\t================================" );
		}
	}
}

```

`be-shellcode-tester/battleye/handlers/veh.cpp`:

```cpp
#include "battleye/reports.hpp"


namespace battleye::reports::handlers {
	void veh( battleye::enums::e_report_id id, util::io::reader_t& reader ) {
		util::logger::info( "\thook_id: %d", reader.read<uint8_t>( ) );
		util::logger::info( "\tcalled_by: 0x%p", reader.read<uint64_t>( ) );

		uint8_t dump[ 32 ];
		reader.read_to( dump, 32 );

		util::logger::info( "\tallocation_base: 0x%p", reader.read<uint64_t>( ) );
		util::logger::info( "\tbase_address: 0x%p", reader.read<uint64_t>( ) );
		util::logger::info( "\tregion_size: 0x%x", reader.read<uint32_t>( ) );
		util::logger::info( "\tstate: 0x%x", reader.read<uint32_t>( ) );

		util::logger::info( "\thexdump:" );
		util::hexdump( "\t\t", dump, 32 );
	}
}

```

`be-shellcode-tester/battleye/handlers/window_title.cpp`:

```cpp
#include "battleye/reports.hpp"


namespace battleye::reports::handlers {
	void window_title( battleye::enums::e_report_id id, util::io::reader_t& reader ) {
		char buf[ 128 ] = { '\0' };
		reader.read_to( buf, reader.read<uint16_t>( ) );
		util::logger::info( "\ttitle: %s", buf );
	}
}

```

`be-shellcode-tester/battleye/reports.cpp`:

```cpp
#include "reports.hpp"
#include <cassert>


namespace battleye::reports {
	void register_handlers( ) {
		registered_handlers[ battleye::enums::e_report_id::REPORT_UNKNOWN ] = handlers::unknown;
		registered_handlers[ battleye::enums::e_report_id::REPORT_ENCRYPTED ] = handlers::encrypted;
		registered_handlers[ battleye::enums::e_report_id::REPORT_GENERAL_INFO ] = handlers::general_info;
		registered_handlers[ battleye::enums::e_report_id::REPORT_VEH ] = handlers::veh;
		registered_handlers[ battleye::enums::e_report_id::REPORT_MEMORY_ANOMALY ] = handlers::memory_anomaly;
		registered_handlers[ battleye::enums::e_report_id::REPORT_WINDOW_TITLE ] = handlers::window_title;
		registered_handlers[ battleye::enums::e_report_id::REPORT_MEMORY_SIGNATURE ] = handlers::memory_signature;
		registered_handlers[ battleye::enums::e_report_id::REPORT_DRIVER_PRESENCE_BEEP ] = handlers::driver_presence;
		registered_handlers[ battleye::enums::e_report_id::REPORT_DRIVER_PRESENCE_NULL ] = handlers::driver_presence;
		registered_handlers[ battleye::enums::e_report_id::REPORT_MEMORY_REGION ] = handlers::memory_region;
		registered_handlers[ battleye::enums::e_report_id::REPORT_BECLIENT_ENCRYPTED ] = handlers::beclient_encrypted;
		registered_handlers[ battleye::enums::e_report_id::REPORT_MONO_ASSETS ] = handlers::mono_assets;
	}

	void execute_handler( battleye::enums::e_report_id id, util::io::reader_t& reader ) {
		auto handler = registered_handlers.find( id );
		if ( handler == registered_handlers.end( ) )
			handler = registered_handlers.find( battleye::enums::e_report_id::REPORT_UNKNOWN );
		if ( id != battleye::enums::e_report_id::REPORT_ENCRYPTED )
			util::logger::info( "[0x%x] Report(%s):", id, enums::report_id_to_string( id ) );
		handler->second( id, reader );
		if ( id != battleye::enums::e_report_id::REPORT_ENCRYPTED )
			util::logger::info( "" );
	}

	void execute_handler( const uint8_t* buffer, size_t size ) {
		auto reader = util::io::reader_t( buffer, size );
		auto id = reader.read<uint8_t>( );
		if ( id == 0x0 ) {
			util::logger::error( "Got invalid report 0x0" );
			return;
		}
		execute_handler( static_cast< enums::e_report_id >( id ), reader );
		assert( reader.get_size( ) == 0 );
	}
}

```

`be-shellcode-tester/battleye/reports.hpp`:

```hpp
#pragma once
#include "util/util.hpp"
#include "battleye/battleye.hpp"


namespace battleye::reports {
	using report_handler_t = void( * )( battleye::enums::e_report_id, util::io::reader_t& );

	namespace handlers {
		void encrypted( battleye::enums::e_report_id, util::io::reader_t& reader );
		void general_info( battleye::enums::e_report_id, util::io::reader_t& reader );
		void veh( battleye::enums::e_report_id, util::io::reader_t& reader );
		void memory_anomaly( battleye::enums::e_report_id, util::io::reader_t& reader );
		void window_title( battleye::enums::e_report_id, util::io::reader_t& reader );
		void memory_signature( battleye::enums::e_report_id, util::io::reader_t& reader );
		void driver_presence( battleye::enums::e_report_id, util::io::reader_t& reader );
		void memory_region( battleye::enums::e_report_id, util::io::reader_t& reader );
		void beclient_encrypted( battleye::enums::e_report_id, util::io::reader_t& reader );
		void mono_assets( battleye::enums::e_report_id, util::io::reader_t& reader );
		
		inline void unknown( battleye::enums::e_report_id, util::io::reader_t& reader ) { 
			util::hexdump( "", reader.get_buffer( ), reader.get_size( ) );
			reader.skip( reader.get_size( ) );
		}
	}

	inline std::unordered_map<battleye::enums::e_report_id, report_handler_t> registered_handlers;

	void register_handlers( );
	void execute_handler( battleye::enums::e_report_id id, util::io::reader_t& reader );
	void execute_handler( const uint8_t* buffer, size_t size );
}

```

`be-shellcode-tester/battleye/resources/beclient_x64.hpp`:

```hpp
#pragma once


namespace battleye::resources {
	inline unsigned char beclient_x64[ 1024 ] = {
		0x4D, 0x5A, 0x90, 0x00, 0x03, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
		0xFF, 0xFF, 0x00, 0x00, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xE0, 0x00, 0x00, 0x00, 0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
		0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21, 0x54, 0x68, 0x69, 0x73, 0x20, 0x70,
		0x72, 0x6F, 0x67, 0x72, 0x61, 0x6D, 0x20, 0x63, 0x61, 0x6E, 0x6E, 0x6F,
		0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6E, 0x20, 0x69, 0x6E, 0x20,
		0x44, 0x4F, 0x53, 0x20, 0x6D, 0x6F, 0x64, 0x65, 0x2E, 0x0D, 0x0D, 0x0A,
		0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB9, 0xB8, 0xD8, 0xCD,
		0xFD, 0xD9, 0xB6, 0x9E, 0xFD, 0xD9, 0xB6, 0x9E, 0xFD, 0xD9, 0xB6, 0x9E,
		0x91, 0xAD, 0xB5, 0x9F, 0xFC, 0xD9, 0xB6, 0x9E, 0xA6, 0xB1, 0xB7, 0x9F,
		0xFE, 0xD9, 0xB6, 0x9E, 0xFD, 0xD9, 0xB7, 0x9E, 0xFF, 0xD9, 0xB6, 0x9E,
		0x24, 0xAD, 0xBF, 0x9F, 0xFE, 0xD9, 0xB6, 0x9E, 0x24, 0xAD, 0xB6, 0x9F,
		0xFC, 0xD9, 0xB6, 0x9E, 0x24, 0xAD, 0xB4, 0x9F, 0xFC, 0xD9, 0xB6, 0x9E,
		0x52, 0x69, 0x63, 0x68, 0xFD, 0xD9, 0xB6, 0x9E, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x50, 0x45, 0x00, 0x00,
		0x64, 0x86, 0x00, 0x00, 0xAF, 0xA2, 0x7A, 0x5D, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x22, 0x20, 0x0B, 0x02, 0x0E, 0x1C,
		0x00, 0x7C, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
		0x01, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x60, 0x01, 0x00, 0x00, 0x10, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00
	};
}

```

`be-shellcode-tester/be-shellcode-tester.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug [dll]|Win32">
      <Configuration>Debug [dll]</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug [dll]|x64">
      <Configuration>Debug [dll]</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release [dll]|Win32">
      <Configuration>Release [dll]</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release [dll]|x64">
      <Configuration>Release [dll]</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d867b1ea-3c81-4ec2-a081-c3015d944b75}</ProjectGuid>
    <RootNamespace>beshellcodetester</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug [dll]|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release [dll]|Win32'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug [dll]|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release [dll]|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug [dll]|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release [dll]|Win32'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug [dll]|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release [dll]|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)output\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)intermediates\$(Configuration)\$(MSBuildProjectName)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug [dll]|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)output\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)intermediates\$(Configuration)\$(MSBuildProjectName)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)output\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)intermediates\$(Configuration)\$(MSBuildProjectName)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release [dll]|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)output\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)intermediates\$(Configuration)\$(MSBuildProjectName)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)output\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)intermediates\$(Configuration)\$(MSBuildProjectName)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug [dll]|x64'">
    <LinkIncremental>true</LinkIncremental>
    <OutDir>$(SolutionDir)output\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)intermediates\$(Configuration)\$(MSBuildProjectName)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)output\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)intermediates\$(Configuration)\$(MSBuildProjectName)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release [dll]|x64'">
    <LinkIncremental>false</LinkIncremental>
    <OutDir>$(SolutionDir)output\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)intermediates\$(Configuration)\$(MSBuildProjectName)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir)$(ProjectName)\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug [dll]|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>DLL;WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir)$(ProjectName)\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir)$(ProjectName)\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release [dll]|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>DLL;WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir)$(ProjectName)\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir)$(ProjectName)\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug [dll]|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>DLL;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir)$(ProjectName)\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir)$(ProjectName)\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release [dll]|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>DLL;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <LanguageStandard_C>stdc17</LanguageStandard_C>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>$(SolutionDir)$(ProjectName)\;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="battleye\handlers\beclient_encrypted.cpp" />
    <ClCompile Include="battleye\handlers\mono_assets.cpp" />
    <ClCompile Include="battleye\handlers\memory_region.cpp" />
    <ClCompile Include="battleye\reports.cpp" />
    <ClCompile Include="battleye\handlers\driver_presence.cpp" />
    <ClCompile Include="battleye\handlers\encrypted.cpp" />
    <ClCompile Include="battleye\handlers\general_info.cpp" />
    <ClCompile Include="battleye\handlers\memory_anomaly.cpp" />
    <ClCompile Include="battleye\handlers\memory_signature.cpp" />
    <ClCompile Include="battleye\handlers\veh.cpp" />
    <ClCompile Include="battleye\handlers\window_title.cpp" />
    <ClCompile Include="bootstrap\bootstrap.cpp" />
    <ClCompile Include="entry.cpp" />
    <ClCompile Include="hooks\battleye\send_report.cpp" />
    <ClCompile Include="hooks\winapi\GetModuleHandle.cpp" />
    <ClCompile Include="hooks\winapi\GetProcAddress.cpp" />
    <ClCompile Include="hooks\winapi\IsBadReadPtr.cpp" />
    <ClCompile Include="hooks\winapi\LoadLibraryA.cpp" />
    <ClCompile Include="hooks\winapi\WideCharToMultiByte.cpp" />
    <ClCompile Include="loader\loader.cpp" />
    <ClCompile Include="util\io\io.cpp" />
    <ClCompile Include="util\mem\mem.cpp" />
    <ClCompile Include="util\pe\pe.cpp" />
    <ClCompile Include="util\util.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="battleye\battleye.hpp" />
    <ClInclude Include="battleye\reports.hpp" />
    <ClInclude Include="battleye\resources\beclient_x64.hpp" />
    <ClInclude Include="bootstrap\bootstrap.hpp" />
    <ClInclude Include="hooks\hooks.hpp" />
    <ClInclude Include="loader\loader.hpp" />
    <ClInclude Include="util\io\io.hpp" />
    <ClInclude Include="util\logger.hpp" />
    <ClInclude Include="util\mem\mem.hpp" />
    <ClInclude Include="util\pe\pe.hpp" />
    <ClInclude Include="util\util.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`be-shellcode-tester/be-shellcode-tester.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="entry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util\io\io.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util\util.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="bootstrap\bootstrap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="loader\loader.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks\winapi\GetModuleHandle.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks\winapi\GetProcAddress.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks\winapi\IsBadReadPtr.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks\battleye\send_report.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks\winapi\LoadLibraryA.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util\pe\pe.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="battleye\handlers\encrypted.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="battleye\handlers\general_info.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="battleye\handlers\veh.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="battleye\handlers\memory_anomaly.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="battleye\handlers\window_title.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="battleye\handlers\memory_signature.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="battleye\handlers\driver_presence.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="battleye\reports.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="battleye\handlers\memory_region.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="battleye\handlers\beclient_encrypted.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="hooks\winapi\WideCharToMultiByte.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="battleye\handlers\mono_assets.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="util\mem\mem.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="util\util.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util\io\io.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="bootstrap\bootstrap.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util\logger.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="loader\loader.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="battleye\battleye.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="hooks\hooks.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="battleye\resources\beclient_x64.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util\pe\pe.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="battleye\reports.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="util\mem\mem.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`be-shellcode-tester/be-shellcode-tester.vcxproj.user`:

```user
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="Current" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <ShowAllFiles>true</ShowAllFiles>
  </PropertyGroup>
</Project>
```

`be-shellcode-tester/bootstrap/bootstrap.cpp`:

```cpp
#include "bootstrap.hpp"
#include "battleye/reports.hpp"
#include "hooks/hooks.hpp"
#include <mutex>


namespace bootstrap {
	namespace detail {
		void init( ) {
			static std::once_flag fl;
			std::call_once( fl, [ ] ( ) -> void {
				util::logger::info( "Registering handlers" );
				battleye::reports::register_handlers( );
			} );
		}
	}

	void run_file( const std::wstring& path, const std::wstring& name ) {
		detail::init( );

		util::logger::info( "Loading %ws", name.c_str( ) );
		loader::load_shellcode( util::io::open_file( path.c_str( ) ) );
	}

	void run_dir( const std::string& dir ) {
		detail::init( );

		util::logger::info( "Iterating dir %s", dir.c_str( ) );

		for ( const auto& entry : std::filesystem::directory_iterator( dir ) ) {
			const auto& path = entry.path( );
			const auto& name = path.filename( );

			// run only .bin files
			if ( name.extension( ) != L".bin" )
				continue;

			run_file( path, name );
		}

		util::logger::info( "Finished" );
	}
}
```

`be-shellcode-tester/bootstrap/bootstrap.hpp`:

```hpp
#pragma once
#include "util/util.hpp"
#include "loader/loader.hpp"


namespace bootstrap {
	void run_file( const std::wstring& path, const std::wstring& name );
	void run_dir( const std::string& dir );
}
```

`be-shellcode-tester/entry.cpp`:

```cpp
#include "bootstrap/bootstrap.hpp"


#ifndef DLL
int main( int argc, char* argv[ ] ) {
	util::logger::info( "Starting..." );
	bootstrap::run_dir(
		argc >= 2 ? argv[ 1 ] : "C:\\shellcodes\\"
	);
	return EXIT_SUCCESS;
}
#else
DWORD __stdcall th( LPVOID h ) {
	util::logger::attach( );
	util::logger::info( "Starting..." );
	bootstrap::run_dir(
		"C:\\shellcodes\\"
	);
	if ( h )
		FreeLibraryAndExitThread( static_cast< HMODULE >( h ), 0x1 );
	return 1;
}

BOOL __stdcall DllMain( HANDLE h, uint32_t call_reason, uintptr_t reserved ) { 
	if ( call_reason != DLL_PROCESS_ATTACH ) return TRUE;

	CreateThread( 0, 0, th, h, 0, 0 );

	return TRUE;
}
#endif

```

`be-shellcode-tester/hooks/battleye/send_report.cpp`:

```cpp
#include "hooks/hooks.hpp"
#include "battleye/reports.hpp"


namespace hooks {
	void send_report( uint8_t* buffer, size_t size, bool unk ) {
		std::vector<uint8_t> report( size - 1 );
		memcpy( report.data( ), buffer + 1, size - 1 );

		util::logger::info( "Got %d size report", report.size( ) );
		//__debugbreak( );
		battleye::reports::execute_handler( report.data( ), report.size( ) );
	}
}

```

`be-shellcode-tester/hooks/hooks.hpp`:

```hpp
#pragma once
#include "util/util.hpp"


namespace hooks {
	// winapi funcs
	HMODULE GetModuleHandleA( const char* module_name );
	FARPROC GetProcAddress( HMODULE mod, const char* proc );
	BOOL IsBadReadPtr( const void* lp, uintptr_t ucb );
	HMODULE LoadLibraryA( const char* file_name );
	int WideCharToMultiByte( UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar );

	// battleye funcs
	void send_report( uint8_t* buffer, size_t size, bool unk );

	inline std::unordered_map<std::string, void*> hooked_functions = {
		{ "GetModuleHandleA", ::hooks::GetModuleHandleA },
		{ "GetProcAddress", ::hooks::GetProcAddress },
		{ "IsBadReadPtr", ::hooks::IsBadReadPtr },
		{ "LoadLibraryA", ::hooks::LoadLibraryA },
		{ "WideCharToMultiByte", hooks::WideCharToMultiByte }
	};
}

```

`be-shellcode-tester/hooks/winapi/GetModuleHandle.cpp`:

```cpp
#include "hooks/hooks.hpp"
#include "battleye/battleye.hpp"
#include <vector>


namespace hooks {
	namespace detail {
		static std::vector<std::string> allowed_modules_to_load = {
			"msvcrt.dll", "USER32.dll", "shell32.dll", "mmres.dll"
		};
	}

	HMODULE GetModuleHandleA( const char* module_name ) {
		util::logger::info( "%s%s%s%s%s", __FUNCTION__, module_name ? "(\"" : "", module_name, module_name ? "\"" : "", module_name ? ")" : "" );

		if ( !module_name ) { // @note: es3n1n: if battleye asks for game handle, then we'll fake it
			static void* fake = nullptr;
			if ( !fake ) {
				fake = malloc( 0xFFFFFF );

				const auto mod = reinterpret_cast< uint8_t* >( ::GetModuleHandleA( NULL ) );
				auto pe = util::c_pe( mod );
				memcpy( fake, mod, pe.get_headers_size( ) );
				// @note: es3n1n: copy only headers and leave everything as it is
			}
			return reinterpret_cast< HMODULE >( fake );
		}

		auto res = battleye::resources_list.find( module_name );
		if ( res != battleye::resources_list.end( ) )
			return reinterpret_cast< HMODULE >( res->second );

		HMODULE ret = ::GetModuleHandleA( module_name );
		if ( !ret ) {
			if ( std::find( detail::allowed_modules_to_load.begin( ), detail::allowed_modules_to_load.end( ), module_name ) != detail::allowed_modules_to_load.end( ) )
				ret = ::LoadLibraryA( module_name );
		}

		//if ( !ret )
		//	util::logger::error( "Module %s not found!", module_name );

		return ret;
	}
}

```

`be-shellcode-tester/hooks/winapi/GetProcAddress.cpp`:

```cpp
#include "hooks/hooks.hpp"


namespace hooks {
	FARPROC GetProcAddress( HMODULE mod, const char* proc ) { 
		util::logger::info( "%s(0x%p, \"%s\")", __FUNCTION__, mod, proc );
		
		auto hk = hooks::hooked_functions.find( proc );
		if ( hk != hooks::hooked_functions.end( ) )
			return static_cast< FARPROC >( hk->second );
		
		return ::GetProcAddress( mod, proc );
	}
}
```

`be-shellcode-tester/hooks/winapi/IsBadReadPtr.cpp`:

```cpp
#include "hooks/hooks.hpp"


namespace hooks {
	BOOL IsBadReadPtr( const void* lp, uintptr_t ucb ) { // @note: es3n1n: I've made this hook cz i'm tired of unhandled errors
		MEMORY_BASIC_INFORMATION mbi = { 0 };
		VirtualQuery( lp, &mbi, sizeof( mbi ) );
		return !!GetLastError( ) || !(
			mbi.Protect & PAGE_EXECUTE_READ ||
			mbi.Protect & PAGE_EXECUTE_READWRITE
		);
	}
}

```

`be-shellcode-tester/hooks/winapi/LoadLibraryA.cpp`:

```cpp
#include "hooks/hooks.hpp"


namespace hooks {
	HMODULE LoadLibraryA( const char* file_name ) {
		util::logger::info( "%s(\"%s\")", __FUNCTION__, file_name );

		HMODULE ret = ::LoadLibraryA( file_name );
		if ( !ret ) {
			util::logger::error( "Failed to load %s", file_name );
		}

		if ( ret && util::str_ends_with( file_name, "BEClient2.dll" ) ) {
			// @note: es3n1n: the trick is that we'll iterate through IAT(Import Address Table) and replace original fn addr with our hk
			auto pe = util::c_pe( reinterpret_cast< uint8_t* >( ret ) );

			for ( auto& [mod, imports] : pe.get_imports( ) ) {
				for ( auto& import_data : imports ) {
					auto hk = hooks::hooked_functions.find( import_data.name );
					if ( hk == hooks::hooked_functions.end( ) ) continue;

					// @note: es3n1n: change protection, and we'll able to write our hooks there
					DWORD old_protection;
					VirtualProtect( reinterpret_cast< void* >( uintptr_t( ret ) + import_data.function_rva ), sizeof( uintptr_t ) * 3, PAGE_EXECUTE_READWRITE, &old_protection );

					// @note: es3n1n: write hook address
					*reinterpret_cast< uintptr_t* >( uintptr_t( ret ) + import_data.function_rva ) = uintptr_t( hk->second );

					// @fixme: es3n1n: GetModuleHandleA import doesn't present in iat idk lol
					if ( !strcmp( import_data.name.c_str( ), "GetProcAddress" ) )
						*reinterpret_cast< uintptr_t* >( uintptr_t( ret ) + import_data.function_rva + sizeof( uintptr_t ) ) = uintptr_t( hooks::hooked_functions[ "GetModuleHandleA" ] );

					// @note: es3n1n: restore protection
					VirtualProtect( reinterpret_cast< void* >( uintptr_t( ret ) + import_data.function_rva ), sizeof( uintptr_t ) * 3, old_protection, &old_protection );
				}
			}
		}

		return ret;
	}
}

```

`be-shellcode-tester/hooks/winapi/WideCharToMultiByte.cpp`:

```cpp
#include "hooks/hooks.hpp"


namespace hooks {
	int WideCharToMultiByte( UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar ) {
		// @note: es3n1n: stupid bastian cannot handle it properly
		//  000001CA0FE58896 | 81BC04 221D0000 64776D2E | cmp dword ptr ss:[rsp+rax+1D22],2E6D7764  |
		return ::WideCharToMultiByte( CodePage, dwFlags, lpWideCharStr, lstrlenW( lpWideCharStr ), lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar );
	}
}

```

`be-shellcode-tester/loader/loader.cpp`:

```cpp
#include "loader.hpp"


namespace loader {
	bool load_shellcode( util::io::handle_t file_handle ) {
		// @note: es3n1n: assert file
		if ( file_handle == INVALID_HANDLE_VALUE ) {
			util::logger::error( "Got invalid file_handle" );
			util::io::close_file( file_handle );
			return false;
		}

		// @note: es3n1n: read file size, assert it then
		size_t file_size = util::io::get_file_size( file_handle );
		if ( !file_size ) {
			util::logger::error( "Got empty file to load" );
			util::io::close_file( file_handle );
			return false;
		}

		// @note: es3n1n: allocating region for mapped shellcode
		uint8_t* shellcode_region = static_cast< uint8_t* >( VirtualAlloc( NULL, file_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE ) );
		if ( !shellcode_region ) {
			util::logger::error( "Failed to allocate memory" );
			util::io::close_file( file_handle );
			return false;
		}

		// @note: es3n1n: reading from file to allocated memory
		if ( !util::io::read_file( file_handle, shellcode_region, file_size ) ) {
			util::logger::error( "Failed to allocate memory" );
			util::io::close_file( file_handle );
			return false;
		}
		util::io::close_file( file_handle );

		// @note: es3n1n: fix some weird check
		uint32_t* report_end = reinterpret_cast< uint32_t* >( reinterpret_cast< uint8_t* >( hooks::send_report ) + 5 );
		if ( *report_end == 0xCCCCCCCC ) {
			DWORD old_protect;
			VirtualProtect( report_end, sizeof( uint32_t ), PAGE_EXECUTE_READWRITE, &old_protect );
			*report_end = 0xCCCC90CC;
			VirtualProtect( report_end, sizeof( uint32_t ), old_protect, &old_protect );
		}

		// @note: es3n1n: searching for shellcode ep
		auto ep_rva = util::mem::sig( shellcode_region, file_size, "4C 89 4C 24 ? 4C 89 44 24 ? 48 89 54 24 ? 89 4C 24 08" ); // @note: es3n1n: if this sig has failed, it will return 0
		util::logger::info( "Found EP at 0x%p [rva]", ep_rva );

		// @note: es3n1n: checking if the returned rva is valid
		if ( *reinterpret_cast< uint8_t* >( shellcode_region + ep_rva ) != 0x4C ) {
			util::logger::warn( "It seems like EP rva is invalid, continue?" );
			util::logger::pause( );
		}

		// @note: es3n1n: ready to run
		util::logger::info( "Ready to run" );
	#ifdef _DEBUG
		util::logger::pause( );
	#endif

		// @note: es3n1n: running
		bool unk = true;
		reinterpret_cast< battleye::typedefs::shellcode_startup_t >( shellcode_region + ep_rva )(
			0, hooks::send_report, hooks::GetModuleHandleA, hooks::GetProcAddress, &unk
		);

		// @note: es3n1n: cleaning up
		VirtualFree( shellcode_region, 0, MEM_RELEASE );

		return true;
	}
}

```

`be-shellcode-tester/loader/loader.hpp`:

```hpp
#pragma once
#include "util/util.hpp"
#include "battleye/battleye.hpp"
#include "hooks/hooks.hpp"


namespace loader {
	bool load_shellcode( util::io::handle_t file_handle );
}

```

`be-shellcode-tester/util/io/io.cpp`:

```cpp
#include "io.hpp"


namespace util::io {
	handle_t create_file( const char* path ) {
		return CreateFileA( path,
			GENERIC_READ,
			FILE_SHARE_READ,
			NULL,
			CREATE_NEW,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		);
	}

	handle_t create_file( const wchar_t* path ) {
		return CreateFileW( path,
			GENERIC_READ,
			FILE_SHARE_READ,
			NULL,
			CREATE_NEW,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		);
	}

	handle_t open_file( const char* path ) {
		return CreateFileA( path,
			GENERIC_READ,
			FILE_SHARE_READ,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		);
	}

	handle_t open_file( const wchar_t* path ) {
		return CreateFileW( path,
			GENERIC_READ,
			FILE_SHARE_READ,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		);
	}

	size_t get_file_size( handle_t handle ) {
		LARGE_INTEGER i = {};
		if ( GetFileSizeEx( handle, &i ) )
			return i.QuadPart;

		return 0;
	}

	bool read_file( handle_t handle, uint8_t* buffer, size_t size ) {
		const auto file_size = get_file_size( handle );

		DWORD bytes_read = 0;
		return ReadFile( handle, buffer, static_cast< DWORD >( size ), &bytes_read, NULL );
	}

	bool write_file( handle_t handle, uint8_t* buffer, size_t size ) {
		return WriteFile( handle, buffer, static_cast< DWORD >( size ), NULL, NULL );
	}

	void close_file( handle_t handle ) {
		CloseHandle( handle );
	}
}
```

`be-shellcode-tester/util/io/io.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <cstdint>
#include <filesystem>


namespace util::io {
	using handle_t = HANDLE;

	handle_t create_file( const char* path );
	handle_t create_file( const wchar_t* path );
	handle_t open_file( const char* path );
	handle_t open_file( const wchar_t* path );
	size_t get_file_size( handle_t handle );
	bool read_file( handle_t handle, uint8_t* buffer, size_t size );
	bool write_file( handle_t handle, uint8_t* buffer, size_t size );
	void close_file( handle_t handle );

	struct reader_t {
	private:
		const uint8_t* m_buffer;
		const uint8_t* m_start_buffer;
		size_t m_size; // @note: es3n1n: isn't const cz we'll change it skip function obv
		const size_t m_start_size;
	public: // ctor/etc
		reader_t( ) = default;
		~reader_t( ) = default;
		reader_t( const uint8_t* buffer, size_t size ) : m_buffer( buffer ), m_size( size ), m_start_size( size ), m_start_buffer( buffer ) { }
	public: // getters
		__forceinline const uint8_t* get_buffer( ) { return m_buffer; }
		__forceinline size_t get_size( ) { return m_size; }
		__forceinline size_t get_start_size( ) { return m_start_size; }
		__forceinline const uint8_t* get_start_buffer( ) { return m_start_buffer; }
	public: // r/w funcs
		template <typename t>
		__forceinline t read( ) {
			t ret = *( t* )m_buffer;
			skip( sizeof( t ) );
			return ret;
		}
		template <typename t>
		__forceinline void read_to( t* buf, size_t size ) {
			memcpy( buf, m_buffer, size );
			skip( size );
		}
		__forceinline void skip( size_t size ) {
			m_buffer += size;
			m_size -= size;
		}
	};
}
```

`be-shellcode-tester/util/logger.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <stdio.h>
#include <Windows.h>
#include <functional>


#define L_ERROR(...) util::logger::error(__FUNCTION__ "(): " __VA_ARGS__);
#define TRACE_FN util::logger::debug( "%s()", __FUNCTION__ );

#define LOGGER_PARSE_FMT  char buf[1024]; va_list va; va_start( va, fmt ); _vsnprintf_s( buf, 1024, fmt, va ); va_end( va );
#define CREATE_LOGGER_METHOD(n) inline void n(const char* fmt, ...) { LOGGER_PARSE_FMT; log( #n, e_level_color::level_color_ ##n, buf ); }


namespace util {
	namespace logger {
		enum class e_level_color : uint32_t {
			level_color_none = 15, // black bg and white fg
			level_color_debug = 8,
			level_color_info = 10,
			level_color_warn = 14,
			level_color_error = 12
		};

		namespace _colors {
			inline void* m_console_handle = nullptr;

			inline bool ensure_handle( ) {
				if ( !m_console_handle )
					m_console_handle = GetStdHandle( STD_OUTPUT_HANDLE );
				return static_cast< bool >( m_console_handle );
			}

			inline void apply( uint32_t clr ) {
				if ( !ensure_handle( ) ) return;
				SetConsoleTextAttribute( m_console_handle, clr );
			}

			inline void reset( ) {
				apply( static_cast< uint32_t >( e_level_color::level_color_none ) );
			}

			inline void colorify( uint32_t clr, std::function<void( )> cb ) {
				apply( clr );
				cb( );
				reset( );
			}
		}

		inline void log( const char* prefix, e_level_color level, const char* message ) {
			_colors::colorify( static_cast< uint32_t >( level ), [ prefix ] ( ) -> void {
				printf( "%s >> ", prefix );
			} );

			printf( "%s\n", message );
		}

	#ifdef _DEBUG
		CREATE_LOGGER_METHOD( debug );
	#else
		__forceinline void debug( const char* fmt, ... ) { }
	#endif
		CREATE_LOGGER_METHOD( info );
		CREATE_LOGGER_METHOD( warn );
		CREATE_LOGGER_METHOD( error );
		inline void fatal( const char* fmt, ... ) {
			LOGGER_PARSE_FMT;
			error( "Fatal error: %s", buf );
			MessageBoxA( NULL, buf, "Fatal error", MB_OK );
			ExitProcess( -1 );
		}

		inline void pause( ) {
			_colors::colorify( static_cast< uint32_t >( e_level_color::level_color_warn ), [ ] ( ) -> void {
				printf( "warn >> " );
			} );
			printf( "Press any key to continue..." );
			_getwch( );
			printf( "\n" );
		}

		__forceinline void attach( ) {
			::AllocConsole( );
			freopen_s( reinterpret_cast< FILE** >( stdin ), "CONIN$", "r", stdin );
			freopen_s( reinterpret_cast< FILE** >( stdout ), "CONOUT$", "w", stdout );
		}

		__forceinline void detach( ) {
			::ShowWindow( ::GetConsoleWindow( ), SW_HIDE );
			::FreeConsole( );
		}
	}
}

#undef CREATE_LOGGER_METHOD
```

`be-shellcode-tester/util/mem/mem.cpp`:

```cpp
#include "util/mem/mem.hpp"


namespace {
	std::vector<int> pattern_to_byte( std::string_view pattern ) {
		auto bytes = std::vector<int> {};
		auto start = const_cast< char* >( pattern.data( ) );
		auto len = pattern.length( );
		auto end = const_cast< char* >( start ) + len;
		bytes.reserve( len / 3 + 5 );

		for ( auto current = start; current < end; ++current ) {
			if ( *current == '?' ) {
				++current;

				if ( *current == '?' )
					++current;

				bytes.emplace_back( -1 );
			} else
				bytes.emplace_back( strtoul( current, &current, 16 ) );
		}
		return bytes;
	}
}

namespace util::mem {
	uintptr_t sig( uint8_t* buffer, size_t size, std::string_view pattern ) {
		const auto pattern_bytes = pattern_to_byte( pattern.data( ) );

		const std::size_t pattern_size = pattern_bytes.size( );
		const int* pattern_data = pattern_bytes.data( );

		for ( std::uint32_t i = 0ul; i < size - pattern_size; ++i ) {
			bool found = true;

			for ( std::uint32_t j = 0ul; j < pattern_size; ++j ) {
				if ( buffer[ i + j ] == pattern_data[ j ] || pattern_data[ j ] == -1 )
					continue;

				found = false;
				break;
			}

			if ( !found )
				continue;

			return i;
		}

		return 0;
	}
}

```

`be-shellcode-tester/util/mem/mem.hpp`:

```hpp
#pragma once
#include <cstdint>
#include <string>
#include <vector>


namespace util::mem {
	uintptr_t sig( uint8_t* buffer, size_t size, std::string_view pattern ); // @note: es3n1n: it returns RVA
}
```

`be-shellcode-tester/util/pe/pe.cpp`:

```cpp
#include "pe.hpp"


namespace util {
	c_pe::import_list c_pe::get_imports( ) {
		c_pe::import_list import_modules;

		auto import_dir = this->get_dir( IMAGE_DIRECTORY_ENTRY_IMPORT );
		if ( import_dir.VirtualAddress == 0 || import_dir.Size == 0 )
			return import_modules;

		auto import_table = reinterpret_cast< ::PIMAGE_IMPORT_DESCRIPTOR >( this->get_image_base( ) + import_dir.VirtualAddress );

		for ( std::uint32_t previous_name = 0;
			previous_name < import_table->Name;
			previous_name = import_table->Name, ++import_table ) {
			auto module_name = std::string( reinterpret_cast< char* >( uintptr_t( m_base ) + import_table->Name ) );

			if ( module_name.empty( ) ) // probably shoud be handled somehow ?
				continue;

			auto entry = reinterpret_cast< ::PIMAGE_THUNK_DATA32 >( uintptr_t( m_base ) + import_table->OriginalFirstThunk );
			for ( std::uintptr_t index = 0; entry->u1.AddressOfData; index += sizeof( std::uint32_t ), ++entry ) {
				auto import_by_name = reinterpret_cast< ::PIMAGE_IMPORT_BY_NAME >( uintptr_t( m_base ) + entry->u1.AddressOfData );

				auto& data = import_modules[ module_name ].emplace_back( );
				data.function_rva = import_table->FirstThunk + index;

				if ( entry->u1.Ordinal < IMAGE_ORDINAL_FLAG32 && import_by_name->Name[ 0 ] ) {
					data.name = reinterpret_cast< const char* >( import_by_name->Name ); // IMPORT BY NAME
				} else {
					data.ordinal = IMAGE_ORDINAL32( entry->u1.AddressOfData ); // IMPORT BY ORDINAL
				}
			}
		}

		return import_modules;
	}
}
```

`be-shellcode-tester/util/pe/pe.hpp`:

```hpp
#pragma once
#include <Windows.h>
#include <cstdint>
#include <string>
#include <unordered_map>


namespace util {
	class c_pe {
	public: // ctors/etc
		c_pe( ) = default;
		~c_pe( ) = default;
		c_pe( uint8_t* base ) : m_base( base ) {
			m_dos_headers = reinterpret_cast< IMAGE_DOS_HEADER* >( m_base );
			m_nt_headers = reinterpret_cast< IMAGE_NT_HEADERS* >( m_base + m_dos_headers->e_lfanew );
		}
	public: // getters
		__forceinline uintptr_t get_image_base( ) { return m_nt_headers->OptionalHeader.ImageBase; }
		__forceinline size_t get_image_size( ) { return m_nt_headers->OptionalHeader.SizeOfImage; }
		__forceinline size_t get_headers_size( ) { return m_nt_headers->OptionalHeader.SizeOfHeaders; }
		__forceinline IMAGE_DATA_DIRECTORY get_dir( size_t i ) { return m_nt_headers->OptionalHeader.DataDirectory[ i ]; }
	public: // imports stuff
		struct import_data_t {
			std::string name;
			uintptr_t function_rva;
			uintptr_t ordinal = 0;
		};
		using import_list = std::unordered_map<std::string, std::vector<import_data_t>>;
	public: // imports stuff
		import_list get_imports( );
	private: // fields
		uint8_t* m_base;
		IMAGE_DOS_HEADER* m_dos_headers;
		IMAGE_NT_HEADERS* m_nt_headers;
	};
}
```

`be-shellcode-tester/util/util.cpp`:

```cpp
#include "util.hpp"


namespace util {
	void hexdump( const char* prefix, const void* ptr, size_t buflen ) {
		unsigned char* buf = ( unsigned char* )ptr;
		int i, j;
		for ( i = 0; i < buflen; i += 16 ) {
			printf( "%s%06x: ", prefix, i );
			for ( j = 0; j < 16; j++ )
				if ( i + j < buflen )
					printf( "%02x ", buf[ i + j ] );
				else
					printf( "   " );
			printf( " " );
			for ( j = 0; j < 16; j++ )
				if ( i + j < buflen )
					printf( "%c", isprint( buf[ i + j ] ) ? buf[ i + j ] : '.' );
			printf( "\n" );
		}
	}
}

```

`be-shellcode-tester/util/util.hpp`:

```hpp
#pragma once
#include <stdio.h>
#include <ctype.h>

#include "io/io.hpp"
#include "logger.hpp"
#include "mem/mem.hpp"
#include "pe/pe.hpp"


namespace util {
	void hexdump( const char* prefix, const void* ptr, size_t buflen );
	__forceinline bool str_ends_with( const char* str, const char* suffix ) {
		if ( !str || !suffix )
			return 0;
		size_t lenstr = strlen( str );
		size_t lensuffix = strlen( suffix );
		if ( lensuffix > lenstr )
			return 0;
		return !strncmp( str + lenstr - lensuffix, suffix, lensuffix );
	}
}

```

`readme.md`:

```md
## be-shellcode-tester

### What is this?
As you may know battleye loads custom shellcodes for detecting some stuff. \
Well this software is running those shellcodes and dumps every report that was sent.

### How's this works?
- Iterating dir with previously dumped shellcodes and maps it to self mem.
- Passes 'hooked' GetProcAddress/GetModuleHandleA/send_report functions to shellcode.
- Reads report and prints info about it.

### How's it useful for me?
Imagine your p2c is detected in be-protected game, all you need to do is dump their shellcodes and check your cheat with this tool.

### Features:
- [x] Hookless
- [x] Parses 9/10 reports(tested only on eft/r6 tho)
- [x] Both .dll and .exe versions are available
- [x] Decrypts encrypted reports from shellcodes
- [ ] Decrypts encrypted reports from BEClient2.dll

### How can i dump shellcode from game?
Hook GetProcAddress, get mbi of return address and check if it's not a legit module.

### Screenshot:
![img](https://i.imgur.com/9qbQ6JZ.png)

### Contributing
Any contributions you make are **greatly appreciated**.

1. Fork the Project
2. Create your Feature Branch (`git checkout -b feature/AmazingFeature`)
3. Commit your Changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the Branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

### Credits:
[@es3n1n](https://github.com/es3n1n/) \
[@user344](https://github.com/user344/)


```